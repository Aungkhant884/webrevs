{"files":[{"patch":"@@ -46,1 +46,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/AbstractExecutableMemberWriter.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -45,3 +45,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.MemberSummaryWriter;\n-import jdk.javadoc.internal.doclets.toolkit.MemberWriter;\n@@ -50,0 +47,1 @@\n+import jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable;\n@@ -54,1 +52,1 @@\n-public abstract class AbstractMemberWriter implements MemberSummaryWriter, MemberWriter {\n+public abstract class AbstractMemberWriter {\n@@ -83,0 +81,27 @@\n+    \/**\n+     * Returns the member summary header for the given class.\n+     *\n+     * @param typeElement the class the summary belongs to\n+     * @param content     the content to which the member summary will be added\n+     *\n+     * @return the member summary header\n+     *\/\n+    public abstract Content getMemberSummaryHeader(TypeElement typeElement, Content content);\n+    \/**\n+     * Adds the given summary to the list of summaries.\n+     *\n+     * @param summariesList the list of summaries\n+     * @param content       the summary\n+     *\/\n+    public abstract void addSummary(Content summariesList, Content content);\n+\n+    \/**\n+     * Returns a list of visible elements of the specified kind in this\n+     * type element.\n+     * @param kind of members\n+     * @return a list of members\n+     *\/\n+    protected List<Element> getVisibleMembers(VisibleMemberTable.Kind kind) {\n+        return configuration.getVisibleMemberTable(typeElement).getVisibleMembers(kind);\n+    }\n+\n@@ -343,1 +368,7 @@\n-    @Override\n+    \/**\n+     * Adds the member summary for the given class and member.\n+     *\n+     * @param tElement           the class the summary belongs to\n+     * @param member             the member that is documented\n+     * @param firstSentenceTrees the tags for the sentence being documented\n+     *\/\n@@ -347,1 +378,1 @@\n-            throw new IllegalStateException();\n+            throw new IllegalStateException(tElement + \", \" + typeElement);\n@@ -364,1 +395,9 @@\n-    @Override\n+    \/**\n+     * Adds the inherited member summary for the given class and member.\n+     *\n+     * @param tElement the class the inherited member belongs to\n+     * @param member the inherited member that is being documented\n+     * @param isFirst true if this is the first member in the list\n+     * @param isLast true if this is the last member in the list\n+     * @param content the content to which the links will be added\n+     *\/\n@@ -366,1 +405,1 @@\n-            Element nestedClass, boolean isFirst, boolean isLast,\n+            Element member, boolean isFirst, boolean isLast,\n@@ -368,1 +407,1 @@\n-        writer.addInheritedMemberSummary(this, tElement, nestedClass, isFirst, content);\n+        writer.addInheritedMemberSummary(this, tElement, member, isFirst, content);\n@@ -371,1 +410,7 @@\n-    @Override\n+    \/**\n+     * Returns the inherited member summary header for the given class.\n+     *\n+     * @param tElement the class the summary belongs to\n+     *\n+     * @return the inherited member summary header\n+     *\/\n@@ -378,1 +423,5 @@\n-    @Override\n+    \/**\n+     * Returns the inherited summary links.\n+     *\n+     * @return the inherited summary links\n+     *\/\n@@ -383,1 +432,7 @@\n-    @Override\n+    \/**\n+     * Returns the summary table for the given class.\n+     *\n+     * @param tElement the class the summary table belongs to\n+     *\n+     * @return the summary table\n+     *\/\n@@ -391,1 +446,7 @@\n-    @Override\n+    \/**\n+     * Returns the member content.\n+     *\n+     * @param memberContent the content representing the member\n+     *\n+     * @return the member content\n+     *\/\n@@ -396,2 +457,6 @@\n-    @Override\n-    public Content getMemberList() {\n+    \/**\n+     * {@return a list to add member items to}\n+     *\n+     * @see #getMemberListItem(Content)\n+     *\/\n+    protected Content getMemberList() {\n@@ -401,2 +466,7 @@\n-    @Override\n-    public Content getMemberListItem(Content memberContent) {\n+    \/**\n+     * {@return a member item}\n+     *\n+     * @param memberContent the member to represent as an item\n+     * @see #getMemberList()\n+     *\/\n+    protected Content getMemberListItem(Content memberContent) {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/AbstractMemberWriter.java","additions":87,"deletions":17,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/AbstractOverviewIndexWriter.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/AbstractTreeWriter.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n@@ -120,1 +119,1 @@\n-                .addTab(contents.classes, e -> utils.isNonThrowableClass(e))\n+                .addTab(contents.classes, utils::isNonThrowableClass)\n@@ -122,2 +121,2 @@\n-                .addTab(contents.records, e -> utils.isRecord(e))\n-                .addTab(contents.exceptionClasses, e -> utils.isThrowable(e))\n+                .addTab(contents.records, utils::isRecord)\n+                .addTab(contents.exceptionClasses, utils::isThrowable)\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/AllClassesIndexWriter.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/AllPackagesIndexWriter.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,370 @@\n+\/*\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html;\n+\n+import javax.lang.model.SourceVersion;\n+import javax.lang.model.element.AnnotationValue;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeMirror;\n+\n+import jdk.javadoc.internal.doclets.formats.html.markup.Comment;\n+import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n+import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n+import jdk.javadoc.internal.doclets.toolkit.BaseOptions;\n+import jdk.javadoc.internal.doclets.toolkit.DocletException;\n+import jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable;\n+\n+\n+\/**\n+ * Writes annotation interface member documentation in HTML format.\n+ *\/\n+public class AnnotationTypeMemberWriter extends AbstractMemberWriter {\n+\n+    \/**\n+     * We generate separate summaries for required and optional annotation interface members,\n+     * so we need dedicated writer instances for each kind. For the details section, a single\n+     * shared list is generated so a special {@code ANY} value is provided for this case.\n+     *\/\n+    enum Kind {\n+        OPTIONAL,\n+        REQUIRED,\n+        ANY\n+    }\n+\n+    private final Kind kind;\n+\n+    \/**\n+     * The index of the current member that is being documented at this point\n+     * in time.\n+     *\/\n+    protected Element currentMember;\n+\n+    \/**\n+     * Constructs a new AnnotationTypeMemberWriterImpl for any kind of member.\n+     *\n+     * @param writer The writer for the class that the member belongs to.\n+     *\/\n+    public AnnotationTypeMemberWriter(SubWriterHolderWriter writer) {\n+        super(writer);\n+        this.kind = Kind.ANY;\n+    }\n+\n+    \/**\n+     * Constructs a new AnnotationTypeMemberWriterImpl for a specific kind of member.\n+     *\n+     * @param writer         the writer that will write the output.\n+     * @param annotationType the AnnotationType that holds this member.\n+     * @param kind           the kind of annotation interface members to handle.\n+     *\/\n+    public AnnotationTypeMemberWriter(SubWriterHolderWriter writer,\n+                                      TypeElement annotationType,\n+                                      Kind kind) {\n+        super(writer, annotationType);\n+        this.kind = kind;\n+    }\n+\n+    public void build(Content target) throws DocletException {\n+        buildAnnotationTypeMember(target);\n+    }\n+\n+    \/**\n+     * Build the member documentation.\n+     *\n+     * @param target the content to which the documentation will be added\n+     *\/\n+    protected void buildAnnotationTypeMember(Content target) {\n+        \/\/ In contrast to the annotation interface member summaries the details generated\n+        \/\/ by this builder share a single list for both required and optional members.\n+        var members = getVisibleMembers(VisibleMemberTable.Kind.ANNOTATION_TYPE_MEMBER);\n+        if (!members.isEmpty()) {\n+            addAnnotationDetailsMarker(target);\n+            Content annotationDetailsHeader = getAnnotationDetailsHeader();\n+            Content memberList = getMemberList();\n+\n+            for (Element member : members) {\n+                currentMember = member;\n+                Content annotationContent = getAnnotationHeaderContent(currentMember);\n+\n+                buildAnnotationTypeMemberChildren(annotationContent);\n+\n+                memberList.add(writer.getMemberListItem(annotationContent));\n+            }\n+            Content annotationDetails = getAnnotationDetails(annotationDetailsHeader, memberList);\n+            target.add(annotationDetails);\n+        }\n+    }\n+\n+    protected void buildAnnotationTypeMemberChildren(Content annotationContent) {\n+        buildSignature(annotationContent);\n+        buildDeprecationInfo(annotationContent);\n+        buildPreviewInfo(annotationContent);\n+        buildMemberComments(annotationContent);\n+        buildTagInfo(annotationContent);\n+        buildDefaultValueInfo(annotationContent);\n+    }\n+\n+    \/**\n+     * Build the signature.\n+     *\n+     * @param target the content to which the documentation will be added\n+     *\/\n+    protected void buildSignature(Content target) {\n+        target.add(getSignature(currentMember));\n+    }\n+\n+    \/**\n+     * Build the deprecation information.\n+     *\n+     * @param annotationContent the content to which the documentation will be added\n+     *\/\n+    protected void buildDeprecationInfo(Content annotationContent) {\n+        addDeprecated(currentMember, annotationContent);\n+    }\n+\n+    \/**\n+     * Build the preview information.\n+     *\n+     * @param annotationContent the content to which the documentation will be added\n+     *\/\n+    protected void buildPreviewInfo(Content annotationContent) {\n+        addPreview(currentMember, annotationContent);\n+    }\n+\n+    \/**\n+     * Build the comments for the member.  Do nothing if\n+     * {@link BaseOptions#noComment()} is set to true.\n+     *\n+     * @param annotationContent the content to which the documentation will be added\n+     *\/\n+    protected void buildMemberComments(Content annotationContent) {\n+        if (!options.noComment()) {\n+            addComments(currentMember, annotationContent);\n+        }\n+    }\n+\n+    \/**\n+     * Build the tag information.\n+     *\n+     * @param annotationContent the content to which the documentation will be added\n+     *\/\n+    protected void buildTagInfo(Content annotationContent) {\n+        addTags(currentMember, annotationContent);\n+    }\n+\n+    \/**\n+     * Build the default value for this optional member.\n+     *\n+     * @param annotationContent the content to which the documentation will be added\n+     *\/\n+    protected void buildDefaultValueInfo(Content annotationContent) {\n+        addDefaultValueInfo(currentMember, annotationContent);\n+    }\n+\n+    @Override\n+    public Content getMemberSummaryHeader(TypeElement typeElement,\n+            Content content) {\n+        switch (kind) {\n+            case OPTIONAL -> content.add(selectComment(\n+                    MarkerComments.START_OF_ANNOTATION_TYPE_OPTIONAL_MEMBER_SUMMARY,\n+                    MarkerComments.START_OF_ANNOTATION_INTERFACE_OPTIONAL_MEMBER_SUMMARY));\n+            case REQUIRED -> content.add(selectComment(\n+                    MarkerComments.START_OF_ANNOTATION_TYPE_REQUIRED_MEMBER_SUMMARY,\n+                    MarkerComments.START_OF_ANNOTATION_INTERFACE_REQUIRED_MEMBER_SUMMARY));\n+            case ANY -> throw new UnsupportedOperationException(\"unsupported member kind\");\n+        }\n+        Content c = new ContentBuilder();\n+        writer.addSummaryHeader(this, c);\n+        return c;\n+    }\n+\n+    protected Content getMemberHeader() {\n+        return writer.getMemberHeader();\n+    }\n+\n+    @Override\n+    public void addSummary(Content summariesList, Content content) {\n+        writer.addSummary(HtmlStyle.memberSummary,\n+                switch (kind) {\n+                    case REQUIRED -> HtmlIds.ANNOTATION_TYPE_REQUIRED_ELEMENT_SUMMARY;\n+                    case OPTIONAL -> HtmlIds.ANNOTATION_TYPE_OPTIONAL_ELEMENT_SUMMARY;\n+                    case ANY -> throw new UnsupportedOperationException(\"unsupported member kind\");\n+                },\n+                summariesList, content);\n+    }\n+\n+    protected void addAnnotationDetailsMarker(Content memberDetails) {\n+        memberDetails.add(selectComment(\n+                MarkerComments.START_OF_ANNOTATION_TYPE_DETAILS,\n+                MarkerComments.START_OF_ANNOTATION_INTERFACE_DETAILS));\n+    }\n+\n+    protected Content getAnnotationDetailsHeader() {\n+        Content memberDetails = new ContentBuilder();\n+        var heading = HtmlTree.HEADING(Headings.TypeDeclaration.DETAILS_HEADING,\n+                contents.annotationTypeDetailsLabel);\n+        memberDetails.add(heading);\n+        return memberDetails;\n+    }\n+\n+    protected Content getAnnotationHeaderContent(Element member) {\n+        Content content = new ContentBuilder();\n+        var heading = HtmlTree.HEADING(Headings.TypeDeclaration.MEMBER_HEADING,\n+                Text.of(name(member)));\n+        content.add(heading);\n+        return HtmlTree.SECTION(HtmlStyle.detail, content)\n+                .setId(htmlIds.forMember(typeElement, (ExecutableElement) member));\n+    }\n+\n+    protected Content getSignature(Element member) {\n+        return new Signatures.MemberSignature(member, this)\n+                .setType(getType(member))\n+                .setAnnotations(writer.getAnnotationInfo(member, true))\n+                .toContent();\n+    }\n+\n+    protected void addDeprecated(Element member, Content target) {\n+        addDeprecatedInfo(member, target);\n+    }\n+\n+    protected void addPreview(Element member, Content content) {\n+        addPreviewInfo(member, content);\n+    }\n+\n+    protected void addComments(Element member, Content annotationContent) {\n+        addComment(member, annotationContent);\n+    }\n+\n+    protected void addTags(Element member, Content annotationContent) {\n+        writer.addTagsInfo(member, annotationContent);\n+    }\n+\n+    protected Content getAnnotationDetails(Content annotationDetailsHeader, Content annotationDetails) {\n+        Content c = new ContentBuilder(annotationDetailsHeader, annotationDetails);\n+        return getMember(HtmlTree.SECTION(HtmlStyle.memberDetails, c));\n+    }\n+\n+    @Override\n+    public void addSummaryLabel(Content content) {\n+        var label = HtmlTree.HEADING(Headings.TypeDeclaration.SUMMARY_HEADING,\n+                switch (kind) {\n+                    case REQUIRED -> contents.annotateTypeRequiredMemberSummaryLabel;\n+                    case OPTIONAL -> contents.annotateTypeOptionalMemberSummaryLabel;\n+                    case ANY -> throw new UnsupportedOperationException(\"unsupported member kind\");\n+                });\n+        content.add(label);\n+    }\n+\n+    \/**\n+     * Get the caption for the summary table.\n+     * @return the caption\n+     *\/\n+    protected Content getCaption() {\n+        return contents.getContent(\n+                switch (kind) {\n+                    case REQUIRED -> \"doclet.Annotation_Type_Required_Members\";\n+                    case OPTIONAL -> \"doclet.Annotation_Type_Optional_Members\";\n+                    case ANY -> throw new UnsupportedOperationException(\"unsupported member kind\");\n+                });\n+    }\n+\n+    @Override\n+    public TableHeader getSummaryTableHeader(Element member) {\n+        return new TableHeader(contents.modifierAndTypeLabel,\n+                switch (kind) {\n+                    case REQUIRED -> contents.annotationTypeRequiredMemberLabel;\n+                    case OPTIONAL -> contents.annotationTypeOptionalMemberLabel;\n+                    case ANY -> throw new UnsupportedOperationException(\"unsupported member kind\");\n+                },\n+                contents.descriptionLabel);\n+    }\n+\n+    @Override\n+    protected Table<Element> createSummaryTable() {\n+        return new Table<Element>(HtmlStyle.summaryTable)\n+                .setCaption(getCaption())\n+                .setHeader(getSummaryTableHeader(typeElement))\n+                .setColumnStyles(HtmlStyle.colFirst, HtmlStyle.colSecond, HtmlStyle.colLast);\n+    }\n+\n+    @Override\n+    public void addInheritedSummaryLabel(TypeElement typeElement, Content content) {\n+    }\n+\n+    @Override\n+    protected void addSummaryLink(HtmlLinkInfo.Kind context, TypeElement typeElement, Element member,\n+                                  Content content) {\n+        Content memberLink = writer.getDocLink(context, utils.getEnclosingTypeElement(member), member,\n+                name(member), HtmlStyle.memberNameLink);\n+        var code = HtmlTree.CODE(memberLink);\n+        content.add(code);\n+    }\n+\n+    @Override\n+    protected void addInheritedSummaryLink(TypeElement typeElement,\n+            Element member, Content target) {\n+        \/\/Not applicable.\n+    }\n+\n+    @Override\n+    protected void addSummaryType(Element member, Content content) {\n+        addModifiersAndType(member, getType(member), content);\n+    }\n+\n+    @Override\n+    protected Content getSummaryLink(Element member) {\n+        String name = utils.getFullyQualifiedName(member) + \".\" + member.getSimpleName();\n+        return writer.getDocLink(HtmlLinkInfo.Kind.SHOW_PREVIEW, member, name);\n+    }\n+\n+    protected Comment selectComment(Comment c1, Comment c2) {\n+        HtmlConfiguration configuration = writer.configuration;\n+        SourceVersion sv = configuration.docEnv.getSourceVersion();\n+        return sv.compareTo(SourceVersion.RELEASE_16) < 0 ? c1 : c2;\n+    }\n+\n+    private TypeMirror getType(Element member) {\n+        return utils.isExecutableElement(member)\n+                ? utils.getReturnType(typeElement, (ExecutableElement) member)\n+                : member.asType();\n+    }\n+\n+    public void addDefaultValueInfo(Element member, Content annotationContent) {\n+        if (utils.isAnnotationInterface(member.getEnclosingElement())) {\n+            ExecutableElement ee = (ExecutableElement) member;\n+            AnnotationValue value = ee.getDefaultValue();\n+            if (value != null) {\n+                var dl = HtmlTree.DL(HtmlStyle.notes);\n+                dl.add(HtmlTree.DT(contents.default_));\n+                dl.add(HtmlTree.DD(HtmlTree.CODE(Text.of(value.toString()))));\n+                annotationContent.add(dl);\n+            }\n+        }\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/AnnotationTypeMemberWriter.java","additions":370,"deletions":0,"binary":false,"changes":370,"status":"added"},{"patch":"@@ -1,278 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.formats.html;\n-\n-import javax.lang.model.SourceVersion;\n-import javax.lang.model.element.AnnotationValue;\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.ExecutableElement;\n-import javax.lang.model.element.TypeElement;\n-import javax.lang.model.type.TypeMirror;\n-\n-import jdk.javadoc.internal.doclets.formats.html.markup.Comment;\n-import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n-import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n-import jdk.javadoc.internal.doclets.toolkit.AnnotationTypeMemberWriter;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.MemberSummaryWriter;\n-\n-\n-\/**\n- * Writes annotation interface member documentation in HTML format.\n- *\/\n-public class AnnotationTypeMemberWriterImpl extends AbstractMemberWriter\n-    implements AnnotationTypeMemberWriter, MemberSummaryWriter {\n-\n-    \/**\n-     * We generate separate summaries for required and optional annotation interface members,\n-     * so we need dedicated writer instances for each kind. For the details section, a single\n-     * shared list is generated so a special {@code ANY} value is provided for this case.\n-     *\/\n-    enum Kind {\n-        OPTIONAL,\n-        REQUIRED,\n-        ANY\n-    }\n-\n-    private final Kind kind;\n-\n-    \/**\n-     * Constructs a new AnnotationTypeMemberWriterImpl for any kind of member.\n-     *\n-     * @param writer The writer for the class that the member belongs to.\n-     *\/\n-    public AnnotationTypeMemberWriterImpl(SubWriterHolderWriter writer) {\n-        super(writer);\n-        this.kind = Kind.ANY;\n-    }\n-\n-    \/**\n-     * Constructs a new AnnotationTypeMemberWriterImpl for a specific kind of member.\n-     *\n-     * @param writer         the writer that will write the output.\n-     * @param annotationType the AnnotationType that holds this member.\n-     * @param kind           the kind of annotation interface members to handle.\n-     *\/\n-    public AnnotationTypeMemberWriterImpl(SubWriterHolderWriter writer,\n-                                          TypeElement annotationType,\n-                                          Kind kind) {\n-        super(writer, annotationType);\n-        this.kind = kind;\n-    }\n-\n-    @Override\n-    public Content getMemberSummaryHeader(TypeElement typeElement,\n-            Content content) {\n-        switch (kind) {\n-            case OPTIONAL -> content.add(selectComment(\n-                    MarkerComments.START_OF_ANNOTATION_TYPE_OPTIONAL_MEMBER_SUMMARY,\n-                    MarkerComments.START_OF_ANNOTATION_INTERFACE_OPTIONAL_MEMBER_SUMMARY));\n-            case REQUIRED -> content.add(selectComment(\n-                    MarkerComments.START_OF_ANNOTATION_TYPE_REQUIRED_MEMBER_SUMMARY,\n-                    MarkerComments.START_OF_ANNOTATION_INTERFACE_REQUIRED_MEMBER_SUMMARY));\n-            case ANY -> throw new UnsupportedOperationException(\"unsupported member kind\");\n-        }\n-        Content c = new ContentBuilder();\n-        writer.addSummaryHeader(this, c);\n-        return c;\n-    }\n-\n-    @Override\n-    public Content getMemberHeader() {\n-        return writer.getMemberHeader();\n-    }\n-\n-    @Override\n-    public void addSummary(Content summariesList, Content content) {\n-        writer.addSummary(HtmlStyle.memberSummary,\n-                switch (kind) {\n-                    case REQUIRED -> HtmlIds.ANNOTATION_TYPE_REQUIRED_ELEMENT_SUMMARY;\n-                    case OPTIONAL -> HtmlIds.ANNOTATION_TYPE_OPTIONAL_ELEMENT_SUMMARY;\n-                    case ANY -> throw new UnsupportedOperationException(\"unsupported member kind\");\n-                },\n-                summariesList, content);\n-    }\n-\n-    @Override\n-    public void addAnnotationDetailsMarker(Content memberDetails) {\n-        memberDetails.add(selectComment(\n-                MarkerComments.START_OF_ANNOTATION_TYPE_DETAILS,\n-                MarkerComments.START_OF_ANNOTATION_INTERFACE_DETAILS));\n-    }\n-\n-    @Override\n-    public Content getAnnotationDetailsHeader() {\n-        Content memberDetails = new ContentBuilder();\n-        var heading = HtmlTree.HEADING(Headings.TypeDeclaration.DETAILS_HEADING,\n-                contents.annotationTypeDetailsLabel);\n-        memberDetails.add(heading);\n-        return memberDetails;\n-    }\n-\n-    @Override\n-    public Content getAnnotationHeaderContent(Element member) {\n-        Content content = new ContentBuilder();\n-        var heading = HtmlTree.HEADING(Headings.TypeDeclaration.MEMBER_HEADING,\n-                Text.of(name(member)));\n-        content.add(heading);\n-        return HtmlTree.SECTION(HtmlStyle.detail, content)\n-                .setId(htmlIds.forMember(typeElement, (ExecutableElement) member));\n-    }\n-\n-    @Override\n-    public Content getSignature(Element member) {\n-        return new Signatures.MemberSignature(member, this)\n-                .setType(getType(member))\n-                .setAnnotations(writer.getAnnotationInfo(member, true))\n-                .toContent();\n-    }\n-\n-    @Override\n-    public void addDeprecated(Element member, Content target) {\n-        addDeprecatedInfo(member, target);\n-    }\n-\n-    @Override\n-    public void addPreview(Element member, Content content) {\n-        addPreviewInfo(member, content);\n-    }\n-\n-    @Override\n-    public void addComments(Element member, Content annotationContent) {\n-        addComment(member, annotationContent);\n-    }\n-\n-    @Override\n-    public void addTags(Element member, Content annotationContent) {\n-        writer.addTagsInfo(member, annotationContent);\n-    }\n-\n-    @Override\n-    public Content getAnnotationDetails(Content annotationDetailsHeader, Content annotationDetails) {\n-        Content c = new ContentBuilder(annotationDetailsHeader, annotationDetails);\n-        return getMember(HtmlTree.SECTION(HtmlStyle.memberDetails, c));\n-    }\n-\n-    @Override\n-    public void addSummaryLabel(Content content) {\n-        var label = HtmlTree.HEADING(Headings.TypeDeclaration.SUMMARY_HEADING,\n-                switch (kind) {\n-                    case REQUIRED -> contents.annotateTypeRequiredMemberSummaryLabel;\n-                    case OPTIONAL -> contents.annotateTypeOptionalMemberSummaryLabel;\n-                    case ANY -> throw new UnsupportedOperationException(\"unsupported member kind\");\n-                });\n-        content.add(label);\n-    }\n-\n-    \/**\n-     * Get the caption for the summary table.\n-     * @return the caption\n-     *\/\n-    protected Content getCaption() {\n-        return contents.getContent(\n-                switch (kind) {\n-                    case REQUIRED -> \"doclet.Annotation_Type_Required_Members\";\n-                    case OPTIONAL -> \"doclet.Annotation_Type_Optional_Members\";\n-                    case ANY -> throw new UnsupportedOperationException(\"unsupported member kind\");\n-                });\n-    }\n-\n-    @Override\n-    public TableHeader getSummaryTableHeader(Element member) {\n-        return new TableHeader(contents.modifierAndTypeLabel,\n-                switch (kind) {\n-                    case REQUIRED -> contents.annotationTypeRequiredMemberLabel;\n-                    case OPTIONAL -> contents.annotationTypeOptionalMemberLabel;\n-                    case ANY -> throw new UnsupportedOperationException(\"unsupported member kind\");\n-                },\n-                contents.descriptionLabel);\n-    }\n-\n-    @Override\n-    protected Table<Element> createSummaryTable() {\n-        return new Table<Element>(HtmlStyle.summaryTable)\n-                .setCaption(getCaption())\n-                .setHeader(getSummaryTableHeader(typeElement))\n-                .setColumnStyles(HtmlStyle.colFirst, HtmlStyle.colSecond, HtmlStyle.colLast);\n-    }\n-\n-    @Override\n-    public void addInheritedSummaryLabel(TypeElement typeElement, Content content) {\n-    }\n-\n-    @Override\n-    protected void addSummaryLink(HtmlLinkInfo.Kind context, TypeElement typeElement, Element member,\n-                                  Content content) {\n-        Content memberLink = writer.getDocLink(context, utils.getEnclosingTypeElement(member), member,\n-                name(member), HtmlStyle.memberNameLink);\n-        var code = HtmlTree.CODE(memberLink);\n-        content.add(code);\n-    }\n-\n-    @Override\n-    protected void addInheritedSummaryLink(TypeElement typeElement,\n-            Element member, Content target) {\n-        \/\/Not applicable.\n-    }\n-\n-    @Override\n-    protected void addSummaryType(Element member, Content content) {\n-        addModifiersAndType(member, getType(member), content);\n-    }\n-\n-    @Override\n-    protected Content getSummaryLink(Element member) {\n-        String name = utils.getFullyQualifiedName(member) + \".\" + member.getSimpleName();\n-        return writer.getDocLink(HtmlLinkInfo.Kind.SHOW_PREVIEW, member, name);\n-    }\n-\n-    protected Comment selectComment(Comment c1, Comment c2) {\n-        HtmlConfiguration configuration = writer.configuration;\n-        SourceVersion sv = configuration.docEnv.getSourceVersion();\n-        return sv.compareTo(SourceVersion.RELEASE_16) < 0 ? c1 : c2;\n-    }\n-\n-    private TypeMirror getType(Element member) {\n-        return utils.isExecutableElement(member)\n-                ? utils.getReturnType(typeElement, (ExecutableElement) member)\n-                : member.asType();\n-    }\n-\n-    public void addDefaultValueInfo(Element member, Content annotationContent) {\n-        if (utils.isAnnotationInterface(member.getEnclosingElement())) {\n-            ExecutableElement ee = (ExecutableElement) member;\n-            AnnotationValue value = ee.getDefaultValue();\n-            if (value != null) {\n-                var dl = HtmlTree.DL(HtmlStyle.notes);\n-                dl.add(HtmlTree.DT(contents.default_));\n-                dl.add(HtmlTree.DD(HtmlTree.CODE(Text.of(value.toString()))));\n-                annotationContent.add(dl);\n-            }\n-        }\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/AnnotationTypeMemberWriterImpl.java","additions":0,"deletions":278,"binary":false,"changes":278,"status":"deleted"},{"patch":"@@ -46,1 +46,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n@@ -84,4 +83,4 @@\n-    final MethodWriterImpl methodSubWriter;\n-    final ConstructorWriterImpl constrSubWriter;\n-    final FieldWriterImpl fieldSubWriter;\n-    final NestedClassWriterImpl classSubWriter;\n+    final MethodWriter methodSubWriter;\n+    final ConstructorWriter constrSubWriter;\n+    final FieldWriter fieldSubWriter;\n+    final NestedClassWriter classSubWriter;\n@@ -135,2 +134,2 @@\n-        methodSubWriter = new MethodWriterImpl(this);\n-        constrSubWriter = new ConstructorWriterImpl(this);\n+        methodSubWriter = new MethodWriter(this);\n+        constrSubWriter = new ConstructorWriter(this);\n@@ -138,2 +137,2 @@\n-        fieldSubWriter = new FieldWriterImpl(this);\n-        classSubWriter = new NestedClassWriterImpl(this);\n+        fieldSubWriter = new FieldWriter(this);\n+        classSubWriter = new NestedClassWriter(this);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/ClassUseWriter.java","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,1093 @@\n+\/*\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+import java.util.stream.Collectors;\n+\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.ModuleElement;\n+import javax.lang.model.element.Name;\n+import javax.lang.model.element.PackageElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.type.TypeMirror;\n+import javax.lang.model.util.SimpleElementVisitor8;\n+\n+import com.sun.source.doctree.DeprecatedTree;\n+import com.sun.source.doctree.DocTree;\n+\n+import jdk.javadoc.internal.doclets.formats.html.Navigation.PageMode;\n+import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n+import jdk.javadoc.internal.doclets.formats.html.markup.Entity;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlAttr;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n+import jdk.javadoc.internal.doclets.formats.html.markup.TagName;\n+import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n+import jdk.javadoc.internal.doclets.toolkit.CommentUtils;\n+import jdk.javadoc.internal.doclets.toolkit.DocletException;\n+import jdk.javadoc.internal.doclets.toolkit.PropertyUtils;\n+import jdk.javadoc.internal.doclets.toolkit.util.ClassTree;\n+import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocFileIOException;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocFinder;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocPath;\n+import jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable;\n+\n+import static jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable.Kind.ANNOTATION_TYPE_MEMBER_OPTIONAL;\n+import static jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable.Kind.ANNOTATION_TYPE_MEMBER_REQUIRED;\n+import static jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable.Kind.CONSTRUCTORS;\n+import static jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable.Kind.ENUM_CONSTANTS;\n+import static jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable.Kind.FIELDS;\n+import static jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable.Kind.METHODS;\n+import static jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable.Kind.NESTED_CLASSES;\n+import static jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable.Kind.PROPERTIES;\n+\n+\/**\n+ * Generate the Class Information Page.\n+ *\n+ * @see javax.lang.model.element.TypeElement\n+ *\/\n+public class ClassWriter extends SubWriterHolderWriter {\n+\n+    private static final Set<String> suppressSubtypesSet\n+            = Set.of(\"java.lang.Object\",\n+                     \"org.omg.CORBA.Object\");\n+\n+    private static final Set<String> suppressImplementingSet\n+            = Set.of(\"java.lang.Cloneable\",\n+                     \"java.lang.constant.Constable\",\n+                     \"java.lang.constant.ConstantDesc\",\n+                     \"java.io.Serializable\");\n+\n+    protected final TypeElement typeElement;\n+    protected final VisibleMemberTable visibleMemberTable;\n+\n+    protected final ClassTree classTree;\n+\n+    private final Comparator<Element> summariesComparator;\n+    private final PropertyUtils.PropertyHelper pHelper;\n+\n+    \/**\n+     * @param configuration the configuration data for the doclet\n+     * @param typeElement the class being documented.\n+     * @param classTree the class tree for the given class.\n+     *\/\n+    public ClassWriter(HtmlConfiguration configuration, TypeElement typeElement,\n+                       ClassTree classTree) {\n+        super(configuration, configuration.docPaths.forClass(typeElement));\n+        this.typeElement = typeElement;\n+        configuration.currentTypeElement = typeElement;\n+        this.classTree = classTree;\n+\n+        visibleMemberTable = configuration.getVisibleMemberTable(typeElement);\n+        summariesComparator = utils.comparators.makeIndexElementComparator();\n+        pHelper = new PropertyUtils.PropertyHelper(configuration, typeElement);\n+\n+        switch (typeElement.getKind()) {\n+            case ENUM   -> setEnumDocumentation(typeElement);\n+            case RECORD -> setRecordDocumentation(typeElement);\n+        }\n+    }\n+\n+    public void build() throws DocletException {\n+        buildClassDoc();\n+    }\n+\n+    \/**\n+     * Handles the {@literal <TypeElement>} tag.\n+     *\n+     * @throws DocletException if there is a problem while building the documentation\n+     *\/\n+    protected void buildClassDoc() throws DocletException {\n+        String key = switch (typeElement.getKind()) {\n+            case INTERFACE       -> \"doclet.Interface\";\n+            case ENUM            -> \"doclet.Enum\";\n+            case RECORD          -> \"doclet.RecordClass\";\n+            case ANNOTATION_TYPE -> \"doclet.AnnotationType\";\n+            case CLASS           -> \"doclet.Class\";\n+            default -> throw new IllegalStateException(typeElement.getKind() + \" \" + typeElement);\n+        };\n+        Content content = getHeader(resources.getText(key) + \" \" + utils.getSimpleName(typeElement));\n+        Content classContent = getClassContentHeader();\n+\n+        buildClassTree(classContent);\n+        buildClassInfo(classContent);\n+        buildMemberSummary(classContent);\n+        buildMemberDetails(classContent);\n+\n+        addClassContent(classContent);\n+        addFooter();\n+        printDocument(content);\n+        copyDocFiles();\n+    }\n+\n+    \/**\n+     * Build the class inheritance tree documentation.\n+     *\n+     * @param classContent the content to which the documentation will be added\n+     *\/\n+    protected void buildClassTree(Content classContent) {\n+        addClassTree(classContent);\n+    }\n+\n+    \/**\n+     * Build the class information documentation.\n+     *\n+     * @param target the content to which the documentation will be added\n+     *\/\n+    protected void buildClassInfo(Content target) {\n+        Content c = getOutputInstance();\n+        buildParamInfo(c);\n+        buildSuperInterfacesInfo(c);\n+        buildImplementedInterfacesInfo(c);\n+        buildSubClassInfo(c);\n+        buildSubInterfacesInfo(c);\n+        buildInterfaceUsageInfo(c);\n+        buildNestedClassInfo(c);\n+        buildFunctionalInterfaceInfo(c);\n+        buildClassSignature(c);\n+        buildDeprecationInfo(c);\n+        buildClassDescription(c);\n+        buildClassTagInfo(c);\n+\n+        target.add(getClassInfo(c));\n+    }\n+\n+    \/**\n+     * Build the type parameters and state components of this class.\n+     *\n+     * @param target the content to which the documentation will be added\n+     *\/\n+    protected void buildParamInfo(Content target) {\n+        addParamInfo(target);\n+    }\n+\n+    \/**\n+     * If this is an interface, list all superinterfaces.\n+     *\n+     * @param target the content to which the documentation will be added\n+     *\/\n+    protected void buildSuperInterfacesInfo(Content target) {\n+        addSuperInterfacesInfo(target);\n+    }\n+\n+    \/**\n+     * If this is a class, list all interfaces implemented by this class.\n+     *\n+     * @param target the content to which the documentation will be added\n+     *\/\n+    protected void buildImplementedInterfacesInfo(Content target) {\n+        addImplementedInterfacesInfo(target);\n+    }\n+\n+    \/**\n+     * List all the classes that extend this one.\n+     *\n+     * @param target the content to which the documentation will be added\n+     *\/\n+    protected void buildSubClassInfo(Content target) {\n+        addSubClassInfo(target);\n+    }\n+\n+    \/**\n+     * List all the interfaces that extend this one.\n+     *\n+     * @param target the content to which the documentation will be added\n+     *\/\n+    protected void buildSubInterfacesInfo(Content target) {\n+        addSubInterfacesInfo(target);\n+    }\n+\n+    \/**\n+     * If this is an interface, list all classes that implement this interface.\n+     *\n+     * @param target the content to which the documentation will be added\n+     *\/\n+    protected void buildInterfaceUsageInfo(Content target) {\n+        addInterfaceUsageInfo(target);\n+    }\n+\n+    \/**\n+     * If this is a functional interface, display appropriate message.\n+     *\n+     * @param target the content to which the documentation will be added\n+     *\/\n+    protected void buildFunctionalInterfaceInfo(Content target) {\n+        addFunctionalInterfaceInfo(target);\n+    }\n+\n+    \/**\n+     * If this class is deprecated, build the appropriate information.\n+     *\n+     * @param target the content to which the documentation will be added\n+     *\/\n+    protected void buildDeprecationInfo(Content target) {\n+        addClassDeprecationInfo(target);\n+    }\n+\n+    \/**\n+     * If this is an inner class or interface, list the enclosing class or interface.\n+     *\n+     * @param target the content to which the documentation will be added\n+     *\/\n+    protected void buildNestedClassInfo(Content target) {\n+        addNestedClassInfo(target);\n+    }\n+\n+    \/**\n+     * Copy the doc files.\n+     *\n+     * @throws DocFileIOException if there is a problem while copying the files\n+     *\/\n+    private void copyDocFiles() throws DocletException {\n+        PackageElement containingPackage = utils.containingPackage(typeElement);\n+        var containingPackagesSeen = configuration.getContainingPackagesSeen();\n+        if ((configuration.packages == null ||\n+                !configuration.packages.contains(containingPackage)) &&\n+                !containingPackagesSeen.contains(containingPackage)) {\n+            \/\/Only copy doc files dir if the containing package is not\n+            \/\/documented AND if we have not documented a class from the same\n+            \/\/package already. Otherwise, we are making duplicate copies.\n+            var docFilesHandler = configuration\n+                    .getWriterFactory()\n+                    .getDocFilesHandler(containingPackage);\n+            docFilesHandler.copyDocFiles();\n+            containingPackagesSeen.add(containingPackage);\n+        }\n+    }\n+\n+    \/**\n+     * Build the signature of the current class.\n+     *\n+     * @param target the content to which the documentation will be added\n+     *\/\n+    protected void buildClassSignature(Content target) {\n+        addClassSignature(target);\n+    }\n+\n+    \/**\n+     * Build the class description.\n+     *\n+     * @param target the content to which the documentation will be added\n+     *\/\n+    protected void buildClassDescription(Content target) {\n+        addClassDescription(target);\n+    }\n+\n+    \/**\n+     * Build the tag information for the current class.\n+     *\n+     * @param target the content to which the documentation will be added\n+     *\/\n+    protected void buildClassTagInfo(Content target) {\n+        addClassTagInfo(target);\n+    }\n+\n+    \/**\n+     * Build the member summary contents of the page.\n+     *\n+     * @param classContent the content to which the documentation will be added\n+     *\/\n+    protected void buildMemberSummary(Content classContent) {\n+        Content summariesList = getSummariesList();\n+        buildSummaries(summariesList);\n+        classContent.add(getMemberSummary(summariesList));\n+    }\n+\n+    protected void buildSummaries(Content target) {\n+        buildPropertiesSummary(target);\n+        buildNestedClassesSummary(target);\n+        buildEnumConstantsSummary(target);\n+        buildAnnotationTypeRequiredMemberSummary(target);\n+        buildAnnotationTypeOptionalMemberSummary(target);\n+        buildFieldsSummary(target);\n+        buildConstructorsSummary(target);\n+        buildMethodsSummary(target);\n+    }\n+\n+    \/**\n+     * Builds the summary for any optional members of an annotation type.\n+     *\n+     * @param summariesList the list of summaries to which the summary will be added\n+     *\/\n+    protected void buildAnnotationTypeOptionalMemberSummary(Content summariesList) {\n+\/\/        MemberSummaryWriter writer = memberSummaryWriters.get(ANNOTATION_TYPE_MEMBER_OPTIONAL);\n+        var writerFactory = configuration.getWriterFactory();\n+        var writer = writerFactory.getAnnotationTypeOptionalMemberWriter(this);\n+        addSummary(writer, ANNOTATION_TYPE_MEMBER_OPTIONAL, false, summariesList);\n+    }\n+\n+    \/**\n+     * Builds the summary for any required members of an annotation type.\n+     *\n+     * @param summariesList the list of summaries to which the summary will be added\n+     *\/\n+    protected void buildAnnotationTypeRequiredMemberSummary(Content summariesList) {\n+\/\/        MemberSummaryWriter writer = memberSummaryWriters.get(ANNOTATION_TYPE_MEMBER_REQUIRED);\n+        var writerFactory = configuration.getWriterFactory();\n+        var writer = writerFactory.getAnnotationTypeRequiredMemberWriter(this);\n+        addSummary(writer, ANNOTATION_TYPE_MEMBER_REQUIRED, false, summariesList);\n+    }\n+\n+    \/**\n+     * Builds the summary for any enum constants of an enum type.\n+     *\n+     * @param summariesList the list of summaries to which the summary will be added\n+     *\/\n+    protected void buildEnumConstantsSummary(Content summariesList) {\n+\/\/        MemberSummaryWriter writer = memberSummaryWriters.get(ENUM_CONSTANTS);\n+        var writerFactory = configuration.getWriterFactory();\n+        var writer = writerFactory.getEnumConstantWriter(this);\n+        addSummary(writer, ENUM_CONSTANTS, false, summariesList);\n+    }\n+\n+    \/**\n+     * Builds the summary for any fields.\n+     *\n+     * @param summariesList the list of summaries to which the summary will be added\n+     *\/\n+    protected void buildFieldsSummary(Content summariesList) {\n+\/\/        MemberSummaryWriter writer = memberSummaryWriters.get(FIELDS);\n+        var writerFactory = configuration.getWriterFactory();\n+        var writer = writerFactory.getFieldWriter(this);\n+        addSummary(writer, FIELDS, true, summariesList);\n+    }\n+\n+    \/**\n+     * Builds the summary for any properties.\n+     *\n+     * @param summariesList the list of summaries to which the summary will be added\n+     *\/\n+    protected void buildPropertiesSummary(Content summariesList) {\n+\/\/        MemberSummaryWriter writer = memberSummaryWriters.get(PROPERTIES);\n+        var writerFactory = configuration.getWriterFactory();\n+        var writer = writerFactory.getPropertyWriter(this);\n+        addSummary(writer, PROPERTIES, true, summariesList);\n+    }\n+\n+    \/**\n+     * Builds the summary for any nested classes.\n+     *\n+     * @param summariesList the list of summaries to which the summary will be added\n+     *\/\n+    protected void buildNestedClassesSummary(Content summariesList) {\n+\/\/        MemberSummaryWriter writer = memberSummaryWriters.get(NESTED_CLASSES);\n+        var writerFactory = configuration.getWriterFactory();\n+        var writer = new NestedClassWriter(this, typeElement); \/\/ TODO: surprising omission from WriterFactory\n+        addSummary(writer, NESTED_CLASSES, true, summariesList);\n+    }\n+\n+    \/**\n+     * Builds the summary for any methods.\n+     *\n+     * @param summariesList the content to which the documentation will be added\n+     *\/\n+    protected void buildMethodsSummary(Content summariesList) {\n+\/\/        MemberSummaryWriter writer = memberSummaryWriters.get(METHODS);\n+        var writerFactory = configuration.getWriterFactory();\n+        var writer = writerFactory.getMethodWriter(this);\n+        addSummary(writer, METHODS, true, summariesList);\n+    }\n+\n+    \/**\n+     * Builds the summary for any constructors.\n+     *\n+     * @param summariesList the content to which the documentation will be added\n+     *\/\n+    protected void buildConstructorsSummary(Content summariesList) {\n+\/\/        MemberSummaryWriter writer = memberSummaryWriters.get(CONSTRUCTORS);\n+        var writerFactory = configuration.getWriterFactory();\n+        var writer = writerFactory.getConstructorWriter(this);\n+        addSummary(writer, CONSTRUCTORS, false, summariesList);\n+    }\n+\n+\n+    \/**\n+     * Adds the summary for the documentation.\n+     *\n+     * @param writer               the writer for this member summary\n+     * @param kind                 the kind of members to document\n+     * @param showInheritedSummary true if a summary of any inherited elements should be documented\n+     * @param summariesList        the list of summaries to which the summary will be added\n+     *\/\n+    private void addSummary(AbstractMemberWriter writer,\n+                            VisibleMemberTable.Kind kind,\n+                            boolean showInheritedSummary,\n+                            Content summariesList)\n+    {\n+        \/\/ TODO: could infer the writer from the kind\n+        \/\/ TODO: why LinkedList?\n+        List<Content> summaryTreeList = new LinkedList<>();\n+        buildSummary(writer, kind, summaryTreeList);\n+        if (showInheritedSummary)\n+            buildInheritedSummary(writer, kind, summaryTreeList);\n+        if (!summaryTreeList.isEmpty()) {\n+            Content member = writer.getMemberSummaryHeader(typeElement, summariesList);\n+            summaryTreeList.forEach(member::add);\n+            writer.addSummary(summariesList, member);\n+        }\n+    }\n+\n+    \/**\n+     * Build the member summary for the given members.\n+     *\n+     * @param writer the summary writer to write the output.\n+     * @param kind the kind of  members to summarize.\n+     * @param summaryTreeList the list of contents to which the documentation will be added\n+     *\/\n+    private void buildSummary(AbstractMemberWriter writer,\n+                              VisibleMemberTable.Kind kind, List<Content> summaryTreeList) {\n+        SortedSet<? extends Element> members = asSortedSet(visibleMemberTable.getVisibleMembers(kind));\n+        if (!members.isEmpty()) {\n+            for (Element member : members) {\n+                final Element property = pHelper.getPropertyElement(member);\n+                if (property != null && member instanceof ExecutableElement ee) {\n+                    configuration.cmtUtils.updatePropertyMethodComment(ee, property);\n+                }\n+                if (utils.isMethod(member)) {\n+                    var docFinder = utils.docFinder();\n+                    Optional<List<? extends DocTree>> r = docFinder.search((ExecutableElement) member, (m -> {\n+                        var firstSentenceTrees = utils.getFirstSentenceTrees(m);\n+                        Optional<List<? extends DocTree>> optional = firstSentenceTrees.isEmpty() ? Optional.empty() : Optional.of(firstSentenceTrees);\n+                        return DocFinder.Result.fromOptional(optional);\n+                    })).toOptional();\n+                    \/\/ The fact that we use `member` for possibly unrelated tags is suspicious\n+                    writer.addMemberSummary(typeElement, member, r.orElse(List.of()));\n+                } else {\n+                    writer.addMemberSummary(typeElement, member, utils.getFirstSentenceTrees(member));\n+                }\n+            }\n+            summaryTreeList.add(writer.getSummaryTable(typeElement));\n+        }\n+    }\n+\n+    \/**\n+     * Build the inherited member summary for the given methods.\n+     *\n+     * @param writer the writer for this member summary.\n+     * @param kind the kind of members to document.\n+     * @param targets the list of contents to which the documentation will be added\n+     *\/\n+    private void buildInheritedSummary(AbstractMemberWriter writer,\n+                                       VisibleMemberTable.Kind kind, List<Content> targets) {\n+        SortedSet<? extends Element> inheritedMembersFromMap = asSortedSet(visibleMemberTable.getAllVisibleMembers(kind));\n+\n+        for (TypeElement inheritedClass : visibleMemberTable.getVisibleTypeElements()) {\n+            if (!(utils.isPublic(inheritedClass) || utils.isLinkable(inheritedClass))) {\n+                continue;\n+            }\n+            if (Objects.equals(inheritedClass, typeElement)) {\n+                continue;\n+            }\n+            if (utils.hasHiddenTag(inheritedClass)) {\n+                continue;\n+            }\n+\n+            List<? extends Element> members = inheritedMembersFromMap.stream()\n+                    .filter(e -> Objects.equals(utils.getEnclosingTypeElement(e), inheritedClass))\n+                    .toList();\n+\n+            if (!members.isEmpty()) {\n+                SortedSet<Element> inheritedMembers = new TreeSet<>(summariesComparator);\n+                inheritedMembers.addAll(members);\n+                Content inheritedHeader = writer.getInheritedSummaryHeader(inheritedClass);\n+                Content links = writer.getInheritedSummaryLinks();\n+                addSummaryFootNote(inheritedClass, inheritedMembers, links, writer);\n+                inheritedHeader.add(links);\n+                targets.add(inheritedHeader);\n+            }\n+        }\n+    }\n+\n+    private void addSummaryFootNote(TypeElement inheritedClass, Iterable<Element> inheritedMembers,\n+                                    Content links, AbstractMemberWriter writer) {\n+        boolean isFirst = true;\n+        for (var iterator = inheritedMembers.iterator(); iterator.hasNext(); ) {\n+            var member = iterator.next();\n+            TypeElement t = utils.isUndocumentedEnclosure(inheritedClass)\n+                    ? typeElement : inheritedClass;\n+            writer.addInheritedMemberSummary(t, member, isFirst, !iterator.hasNext(), links);\n+            isFirst = false;\n+        }\n+    }\n+\n+    private SortedSet<? extends Element> asSortedSet(Collection<? extends Element> members) {\n+        SortedSet<Element> out = new TreeSet<>(summariesComparator);\n+        out.addAll(members);\n+        return out;\n+    }\n+\n+    \/**\n+     * Build the member details contents of the page.\n+     *\n+     * @param classContent the content to which the documentation will be added\n+     * @throws DocletException if there is a problem while building the documentation\n+     *\/\n+    protected void buildMemberDetails(Content classContent) throws DocletException {\n+        Content detailsList = getDetailsList();\n+\n+        buildEnumConstantsDetails(detailsList);\n+        buildPropertyDetails(detailsList);\n+        buildFieldDetails(detailsList);\n+        buildConstructorDetails(detailsList);\n+        buildAnnotationTypeMemberDetails(detailsList);\n+        buildMethodDetails(detailsList);\n+\n+        classContent.add(getMemberDetails(detailsList));\n+    }\n+\n+    \/**\n+     * Build the enum constants documentation.\n+     *\n+     * @param detailsList the content to which the documentation will be added\n+     *\/\n+    protected void buildEnumConstantsDetails(Content detailsList) {\n+        var writerFactory = configuration.getWriterFactory();\n+        var enumConstantWriter = writerFactory.getEnumConstantWriter(this);\n+        enumConstantWriter.build(detailsList);\n+    }\n+\n+    \/**\n+     * Build the field documentation.\n+     *\n+     * @param detailsList the content to which the documentation will be added\n+     * @throws DocletException if there is a problem while building the documentation\n+     *\/\n+    protected void buildFieldDetails(Content detailsList) throws DocletException {\n+        var writerFactory = configuration.getWriterFactory();\n+        var fieldWriter = writerFactory.getFieldWriter(this);\n+        fieldWriter.build(detailsList);\n+    }\n+\n+    \/**\n+     * Build the property documentation.\n+     *\n+     * @param detailsList the content to which the documentation will be added\n+     *\/\n+    public void buildPropertyDetails( Content detailsList) {\n+        var writerFactory = configuration.getWriterFactory();\n+        var propertyWriter = writerFactory.getPropertyWriter(this);\n+        propertyWriter.build(detailsList);\n+    }\n+\n+    \/**\n+     * Build the constructor documentation.\n+     *\n+     * @param detailsList the content to which the documentation will be added\n+     * @throws DocletException if there is a problem while building the documentation\n+     *\/\n+    protected void buildConstructorDetails(Content detailsList) throws DocletException {\n+        var writerFactory = configuration.getWriterFactory();\n+        var constructorWriter = writerFactory.getConstructorWriter(this);\n+        constructorWriter.build(detailsList);\n+    }\n+\n+    \/**\n+     * Build the method documentation.\n+     *\n+     * @param detailsList the content to which the documentation will be added\n+     * @throws DocletException if there is a problem while building the documentation\n+     *\/\n+    protected void buildMethodDetails(Content detailsList) throws DocletException {\n+        var writerFactory = configuration.getWriterFactory();\n+        var methodWriter = writerFactory.getMethodWriter(this);\n+        methodWriter.build(detailsList);\n+    }\n+\n+    \/**\n+     * Build the annotation type optional member documentation.\n+     *\n+     * @param target the content to which the documentation will be added\n+     * @throws DocletException if there is a problem building the documentation\n+     *\/\n+    protected void buildAnnotationTypeMemberDetails(Content target)\n+            throws DocletException {\n+        var writerFactory = configuration.getWriterFactory();\n+        var annotationTypeMemberWriter = writerFactory.getAnnotationTypeMemberWriter(this);\n+        annotationTypeMemberWriter.build(target);\n+    }\n+\n+    \/**\n+     * The documentation for values() and valueOf() in Enums are set by the\n+     * doclet only iff the user or overridden methods are missing.\n+     * @param elem the enum element\n+     *\/\n+    private void setEnumDocumentation(TypeElement elem) {\n+        CommentUtils cmtUtils = configuration.cmtUtils;\n+        for (ExecutableElement ee : utils.getMethods(elem)) {\n+            if (!utils.getFullBody(ee).isEmpty()) \/\/ ignore if already set\n+                continue;\n+            Name name = ee.getSimpleName();\n+            if (name.contentEquals(\"values\") && ee.getParameters().isEmpty()) {\n+                utils.removeCommentHelper(ee); \/\/ purge previous entry\n+                cmtUtils.setEnumValuesTree(ee);\n+            } else if (name.contentEquals(\"valueOf\") && ee.getParameters().size() == 1) {\n+                \/\/ TODO: check parameter type\n+                utils.removeCommentHelper(ee); \/\/ purge previous entry\n+                cmtUtils.setEnumValueOfTree(ee);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Sets the documentation as needed for the mandated parts of a record type.\n+     * This includes the canonical constructor, methods like {@code equals},\n+     * {@code hashCode}, {@code toString}, the accessor methods, and the underlying\n+     * field.\n+     * @param elem the record element\n+     *\/\n+\n+    private void setRecordDocumentation(TypeElement elem) {\n+        CommentUtils cmtUtils = configuration.cmtUtils;\n+        Set<Name> componentNames = elem.getRecordComponents().stream()\n+                .map(Element::getSimpleName)\n+                .collect(Collectors.toSet());\n+\n+        for (ExecutableElement ee : utils.getConstructors(elem)) {\n+            if (utils.isCanonicalRecordConstructor(ee)) {\n+                if (utils.getFullBody(ee).isEmpty()) {\n+                    utils.removeCommentHelper(ee); \/\/ purge previous entry\n+                    cmtUtils.setRecordConstructorTree(ee);\n+                }\n+                \/\/ only one canonical constructor; no need to keep looking\n+                break;\n+            }\n+        }\n+\n+        var fields = utils.isSerializable(elem)\n+                ? utils.getFieldsUnfiltered(elem)\n+                : utils.getFields(elem);\n+        for (VariableElement ve : fields) {\n+            \/\/ The fields for the record component cannot be declared by the\n+            \/\/ user and so cannot have any pre-existing comment.\n+            Name name = ve.getSimpleName();\n+            if (componentNames.contains(name)) {\n+                utils.removeCommentHelper(ve); \/\/ purge previous entry\n+                cmtUtils.setRecordFieldTree(ve);\n+            }\n+        }\n+\n+        TypeMirror objectType = utils.getObjectType();\n+\n+        for (ExecutableElement ee : utils.getMethods(elem)) {\n+            if (!utils.getFullBody(ee).isEmpty()) {\n+                continue;\n+            }\n+\n+            Name name = ee.getSimpleName();\n+            List<? extends VariableElement> params = ee.getParameters();\n+            if (name.contentEquals(\"equals\")) {\n+                if (params.size() == 1 && utils.typeUtils.isSameType(params.get(0).asType(), objectType)) {\n+                    utils.removeCommentHelper(ee); \/\/ purge previous entry\n+                    cmtUtils.setRecordEqualsTree(ee);\n+                }\n+            } else if (name.contentEquals(\"hashCode\")) {\n+                if (params.isEmpty()) {\n+                    utils.removeCommentHelper(ee); \/\/ purge previous entry\n+                    cmtUtils.setRecordHashCodeTree(ee);\n+                }\n+            } else if (name.contentEquals(\"toString\")) {\n+                if (params.isEmpty()) {\n+                    utils.removeCommentHelper(ee); \/\/ purge previous entry\n+                    cmtUtils.setRecordToStringTree(ee);\n+                }\n+            } else if (componentNames.contains(name)) {\n+                if (params.isEmpty()) {\n+                    utils.removeCommentHelper(ee); \/\/ purge previous entry\n+                    cmtUtils.setRecordAccessorTree(ee);\n+                }\n+            }\n+        }\n+\n+    }\n+\n+    \/\/ TODO: inline this\n+    public Content getOutputInstance() {\n+        return new ContentBuilder();\n+    }\n+\n+    protected Content getHeader(String header) {\n+        HtmlTree body = getBody(getWindowTitle(utils.getSimpleName(typeElement)));\n+        var div = HtmlTree.DIV(HtmlStyle.header);\n+        if (configuration.showModules) {\n+            ModuleElement mdle = configuration.docEnv.getElementUtils().getModuleOf(typeElement);\n+            var classModuleLabel = HtmlTree.SPAN(HtmlStyle.moduleLabelInType, contents.moduleLabel);\n+            var moduleNameDiv = HtmlTree.DIV(HtmlStyle.subTitle, classModuleLabel);\n+            moduleNameDiv.add(Entity.NO_BREAK_SPACE);\n+            moduleNameDiv.add(getModuleLink(mdle,\n+                    Text.of(mdle.getQualifiedName())));\n+            div.add(moduleNameDiv);\n+        }\n+        PackageElement pkg = utils.containingPackage(typeElement);\n+        if (!pkg.isUnnamed()) {\n+            var classPackageLabel = HtmlTree.SPAN(HtmlStyle.packageLabelInType, contents.packageLabel);\n+            var pkgNameDiv = HtmlTree.DIV(HtmlStyle.subTitle, classPackageLabel);\n+            pkgNameDiv.add(Entity.NO_BREAK_SPACE);\n+            Content pkgNameContent = getPackageLink(pkg, getLocalizedPackageName(pkg));\n+            pkgNameDiv.add(pkgNameContent);\n+            div.add(pkgNameDiv);\n+        }\n+        HtmlLinkInfo linkInfo = new HtmlLinkInfo(configuration,\n+                HtmlLinkInfo.Kind.SHOW_TYPE_PARAMS_AND_BOUNDS, typeElement)\n+                .linkToSelf(false);  \/\/ Let's not link to ourselves in the header\n+        var heading = HtmlTree.HEADING_TITLE(Headings.PAGE_TITLE_HEADING,\n+                HtmlStyle.title, Text.of(header));\n+        heading.add(getTypeParameterLinks(linkInfo));\n+        div.add(heading);\n+        bodyContents.setHeader(getHeader(PageMode.CLASS, typeElement))\n+                .addMainContent(MarkerComments.START_OF_CLASS_DATA)\n+                .addMainContent(div);\n+        return body;\n+    }\n+\n+    protected Content getClassContentHeader() {\n+        return getContentHeader();\n+    }\n+\n+    @Override\n+    protected Navigation getNavBar(PageMode pageMode, Element element) {\n+        Content linkContent = getModuleLink(utils.elementUtils.getModuleOf(element),\n+                contents.moduleLabel);\n+        return super.getNavBar(pageMode, element)\n+                .setNavLinkModule(linkContent)\n+                .setSubNavLinks(() -> {\n+                    List<Content> list = new ArrayList<>();\n+                    VisibleMemberTable vmt = configuration.getVisibleMemberTable(typeElement);\n+                    Set<VisibleMemberTable.Kind> summarySet =\n+                            VisibleMemberTable.Kind.forSummariesOf(element.getKind());\n+                    for (VisibleMemberTable.Kind kind : summarySet) {\n+                        list.add(links.createLink(HtmlIds.forMemberSummary(kind),\n+                                contents.getNavLinkLabelContent(kind), vmt.hasVisibleMembers(kind)));\n+                    }\n+                    return list;\n+                });\n+    }\n+\n+    protected void addFooter() {\n+        bodyContents.addMainContent(MarkerComments.END_OF_CLASS_DATA);\n+        bodyContents.setFooter(getFooter());\n+    }\n+\n+    protected void printDocument(Content content) throws DocFileIOException {\n+        String description = getDescription(\"declaration\", typeElement);\n+        PackageElement pkg = utils.containingPackage(typeElement);\n+        List<DocPath> localStylesheets = getLocalStylesheets(pkg);\n+        content.add(bodyContents);\n+        printHtmlDocument(configuration.metakeywords.getMetaKeywords(typeElement),\n+                description, localStylesheets, content);\n+    }\n+\n+    protected Content getClassInfo(Content classInfo) {\n+        return getMember(HtmlIds.CLASS_DESCRIPTION, HtmlStyle.classDescription, classInfo);\n+    }\n+\n+    @Override\n+    public TypeElement getCurrentPageElement() {\n+        return typeElement;\n+    }\n+\n+    protected void addClassSignature(Content classInfo) {\n+        classInfo.add(new HtmlTree(TagName.HR));\n+        classInfo.add(new Signatures.TypeSignature(typeElement, this)\n+                .toContent());\n+    }\n+\n+    protected void addClassDescription(Content classInfo) {\n+        addPreviewInfo(classInfo);\n+        if (!options.noComment()) {\n+            \/\/ generate documentation for the class.\n+            if (!utils.getFullBody(typeElement).isEmpty()) {\n+                addInlineComment(typeElement, classInfo);\n+            }\n+        }\n+    }\n+\n+    private void addPreviewInfo(Content content) {\n+        addPreviewInfo(typeElement, content);\n+    }\n+\n+    protected void addClassTagInfo(Content classInfo) {\n+        if (!options.noComment()) {\n+            \/\/ Print Information about all the tags here\n+            addTagsInfo(typeElement, classInfo);\n+        }\n+    }\n+\n+    \/**\n+     * Get the class inheritance tree for the given class.\n+     *\n+     * @param type the class to get the inheritance tree for\n+     * @return the class inheritance tree\n+     *\/\n+    private Content getClassInheritanceTreeContent(TypeMirror type) {\n+        TypeMirror sup;\n+        HtmlTree classTree = null;\n+        do {\n+            sup = utils.getFirstVisibleSuperClass(type);\n+            var entry = HtmlTree.DIV(HtmlStyle.inheritance, getClassHelperContent(type));\n+            if (classTree != null)\n+                entry.add(classTree);\n+            classTree = entry;\n+            type = sup;\n+        } while (sup != null);\n+        classTree.put(HtmlAttr.TITLE, contents.getContent(\"doclet.Inheritance_Tree\").toString());\n+        return classTree;\n+    }\n+\n+    \/**\n+     * Get the class helper for the given class.\n+     *\n+     * @param type the class to get the helper for\n+     * @return the class helper\n+     *\/\n+    private Content getClassHelperContent(TypeMirror type) {\n+        Content result = new ContentBuilder();\n+        if (utils.typeUtils.isSameType(type, typeElement.asType())) {\n+            Content typeParameters = getTypeParameterLinks(\n+                    new HtmlLinkInfo(configuration, HtmlLinkInfo.Kind.SHOW_TYPE_PARAMS,\n+                    typeElement));\n+            if (configuration.shouldExcludeQualifier(utils.containingPackage(typeElement).toString())) {\n+                result.add(utils.asTypeElement(type).getSimpleName());\n+                result.add(typeParameters);\n+            } else {\n+                result.add(utils.asTypeElement(type).getQualifiedName());\n+                result.add(typeParameters);\n+            }\n+        } else {\n+            Content link = getLink(new HtmlLinkInfo(configuration,\n+                    HtmlLinkInfo.Kind.SHOW_TYPE_PARAMS, type)\n+                    .label(configuration.getClassName(utils.asTypeElement(type))));\n+            result.add(link);\n+        }\n+        return result;\n+    }\n+\n+    protected void addClassTree(Content target) {\n+        if (!utils.isClass(typeElement)) {\n+            return;\n+        }\n+        target.add(getClassInheritanceTreeContent(typeElement.asType()));\n+    }\n+\n+    protected void addParamInfo(Content target) {\n+        if (utils.hasBlockTag(typeElement, DocTree.Kind.PARAM)) {\n+            var t = configuration.tagletManager.getTaglet(DocTree.Kind.PARAM);\n+            Content paramInfo = t.getAllBlockTagOutput(typeElement, getTagletWriterInstance(false));\n+            if (!paramInfo.isEmpty()) {\n+                target.add(HtmlTree.DL(HtmlStyle.notes, paramInfo));\n+            }\n+        }\n+    }\n+\n+    protected void addSubClassInfo(Content target) {\n+        if (utils.isClass(typeElement)) {\n+            for (String s : suppressSubtypesSet) {\n+                if (typeElement.getQualifiedName().contentEquals(s)) {\n+                    return;    \/\/ Don't generate the list, too huge\n+                }\n+            }\n+            Set<TypeElement> subclasses = classTree.hierarchy(typeElement).subtypes(typeElement);\n+            if (!subclasses.isEmpty()) {\n+                var dl = HtmlTree.DL(HtmlStyle.notes);\n+                dl.add(HtmlTree.DT(contents.subclassesLabel));\n+                dl.add(HtmlTree.DD(getClassLinks(HtmlLinkInfo.Kind.PLAIN, subclasses)));\n+                target.add(dl);\n+            }\n+        }\n+    }\n+\n+    protected void addSubInterfacesInfo(Content target) {\n+        if (utils.isPlainInterface(typeElement)) {\n+            Set<TypeElement> subInterfaces = classTree.hierarchy(typeElement).allSubtypes(typeElement);\n+            if (!subInterfaces.isEmpty()) {\n+                var dl = HtmlTree.DL(HtmlStyle.notes);\n+                dl.add(HtmlTree.DT(contents.subinterfacesLabel));\n+                dl.add(HtmlTree.DD(getClassLinks(HtmlLinkInfo.Kind.SHOW_TYPE_PARAMS, subInterfaces)));\n+                target.add(dl);\n+            }\n+        }\n+    }\n+\n+    protected void addInterfaceUsageInfo(Content target) {\n+        if (!utils.isPlainInterface(typeElement)) {\n+            return;\n+        }\n+        for (String s : suppressImplementingSet) {\n+            if (typeElement.getQualifiedName().contentEquals(s)) {\n+                return;    \/\/ Don't generate the list, too huge\n+            }\n+        }\n+        Set<TypeElement> implcl = classTree.implementingClasses(typeElement);\n+        if (!implcl.isEmpty()) {\n+            var dl = HtmlTree.DL(HtmlStyle.notes);\n+            dl.add(HtmlTree.DT(contents.implementingClassesLabel));\n+            dl.add(HtmlTree.DD(getClassLinks(HtmlLinkInfo.Kind.PLAIN, implcl)));\n+            target.add(dl);\n+        }\n+    }\n+\n+    protected void addImplementedInterfacesInfo(Content target) {\n+        SortedSet<TypeMirror> interfaces = new TreeSet<>(comparators.makeTypeMirrorClassUseComparator());\n+        interfaces.addAll(utils.getAllInterfaces(typeElement));\n+        if (utils.isClass(typeElement) && !interfaces.isEmpty()) {\n+            var dl = HtmlTree.DL(HtmlStyle.notes);\n+            dl.add(HtmlTree.DT(contents.allImplementedInterfacesLabel));\n+            dl.add(HtmlTree.DD(getClassLinks(HtmlLinkInfo.Kind.SHOW_TYPE_PARAMS, interfaces)));\n+            target.add(dl);\n+        }\n+    }\n+\n+    protected void addSuperInterfacesInfo(Content target) {\n+        SortedSet<TypeMirror> interfaces =\n+                new TreeSet<>(comparators.makeTypeMirrorIndexUseComparator());\n+        interfaces.addAll(utils.getAllInterfaces(typeElement));\n+\n+        if (utils.isPlainInterface(typeElement) && !interfaces.isEmpty()) {\n+            var dl = HtmlTree.DL(HtmlStyle.notes);\n+            dl.add(HtmlTree.DT(contents.allSuperinterfacesLabel));\n+            dl.add(HtmlTree.DD(getClassLinks(HtmlLinkInfo.Kind.SHOW_TYPE_PARAMS, interfaces)));\n+            target.add(dl);\n+        }\n+    }\n+\n+    protected void addNestedClassInfo(final Content target) {\n+        Element outerClass = typeElement.getEnclosingElement();\n+        if (outerClass == null)\n+            return;\n+        new SimpleElementVisitor8<Void, Void>() {\n+            @Override\n+            public Void visitType(TypeElement e, Void p) {\n+                var dl = HtmlTree.DL(HtmlStyle.notes);\n+                dl.add(HtmlTree.DT(utils.isPlainInterface(e)\n+                        ? contents.enclosingInterfaceLabel\n+                        : contents.enclosingClassLabel));\n+                dl.add(HtmlTree.DD(getClassLinks(HtmlLinkInfo.Kind.LINK_TYPE_PARAMS_AND_BOUNDS, List.of(e))));\n+                target.add(dl);\n+                return null;\n+            }\n+        }.visit(outerClass);\n+    }\n+\n+    protected void addFunctionalInterfaceInfo (Content target) {\n+        if (isFunctionalInterface()) {\n+            var dl = HtmlTree.DL(HtmlStyle.notes);\n+            dl.add(HtmlTree.DT(contents.functionalInterface));\n+            var dd = new HtmlTree(TagName.DD);\n+            dd.add(contents.functionalInterfaceMessage);\n+            dl.add(dd);\n+            target.add(dl);\n+        }\n+    }\n+\n+    public boolean isFunctionalInterface() {\n+        List<? extends AnnotationMirror> annotationMirrors = typeElement.getAnnotationMirrors();\n+        for (AnnotationMirror anno : annotationMirrors) {\n+            if (utils.isFunctionalInterface(anno)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+\n+    protected void addClassDeprecationInfo(Content classInfo) {\n+        List<? extends DeprecatedTree> deprs = utils.getDeprecatedTrees(typeElement);\n+        if (utils.isDeprecated(typeElement)) {\n+            var deprLabel = HtmlTree.SPAN(HtmlStyle.deprecatedLabel, getDeprecatedPhrase(typeElement));\n+            var div = HtmlTree.DIV(HtmlStyle.deprecationBlock, deprLabel);\n+            if (!deprs.isEmpty()) {\n+                CommentHelper ch = utils.getCommentHelper(typeElement);\n+                DocTree dt = deprs.get(0);\n+                List<? extends DocTree> commentTags = ch.getBody(dt);\n+                if (!commentTags.isEmpty()) {\n+                    addInlineDeprecatedComment(typeElement, deprs.get(0), div);\n+                }\n+            }\n+            classInfo.add(div);\n+        }\n+    }\n+\n+    \/**\n+     * Get the links to the given classes.\n+     *\n+     * @param context the id of the context where the links will be added\n+     * @param list the classes\n+     * @return the links\n+     *\/\n+    private Content getClassLinks(HtmlLinkInfo.Kind context, Collection<?> list) {\n+        Content content = new ContentBuilder();\n+        boolean isFirst = true;\n+        for (Object type : list) {\n+            if (!isFirst) {\n+                content.add(Text.of(\", \"));\n+            } else {\n+                isFirst = false;\n+            }\n+            \/\/ TODO: should we simply split this method up to avoid instanceof ?\n+            if (type instanceof TypeElement te) {\n+                Content link = getLink(\n+                        new HtmlLinkInfo(configuration, context, te));\n+                content.add(HtmlTree.CODE(link));\n+            } else {\n+                Content link = getLink(\n+                        new HtmlLinkInfo(configuration, context, ((TypeMirror)type)));\n+                content.add(HtmlTree.CODE(link));\n+            }\n+        }\n+        return content;\n+    }\n+\n+    \/**\n+     * Return the TypeElement being documented.\n+     *\n+     * @return the TypeElement being documented.\n+     *\/\n+    public TypeElement getTypeElement() {\n+        return typeElement;\n+    }\n+\n+    protected Content getMemberDetails(Content content) {\n+        var section = HtmlTree.SECTION(HtmlStyle.details, content);\n+        \/\/ The following id is required by the Navigation bar\n+        if (utils.isAnnotationInterface(typeElement)) {\n+            section.setId(HtmlIds.ANNOTATION_TYPE_ELEMENT_DETAIL);\n+        }\n+        return section;\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/ClassWriter.java","additions":1093,"deletions":0,"binary":false,"changes":1093,"status":"added"},{"patch":"@@ -1,470 +0,0 @@\n-\/*\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.formats.html;\n-\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.List;\n-import java.util.Set;\n-import java.util.SortedSet;\n-import java.util.TreeSet;\n-\n-import javax.lang.model.element.AnnotationMirror;\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.ModuleElement;\n-import javax.lang.model.element.PackageElement;\n-import javax.lang.model.element.TypeElement;\n-import javax.lang.model.type.TypeMirror;\n-import javax.lang.model.util.SimpleElementVisitor8;\n-\n-import com.sun.source.doctree.DeprecatedTree;\n-import com.sun.source.doctree.DocTree;\n-\n-import jdk.javadoc.internal.doclets.formats.html.Navigation.PageMode;\n-import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n-import jdk.javadoc.internal.doclets.formats.html.markup.Entity;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlAttr;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n-import jdk.javadoc.internal.doclets.formats.html.markup.TagName;\n-import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n-import jdk.javadoc.internal.doclets.toolkit.ClassWriter;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.util.ClassTree;\n-import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocFileIOException;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocPath;\n-import jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable;\n-\n-\/**\n- * Generate the Class Information Page.\n- *\n- * @see javax.lang.model.element.TypeElement\n- *\/\n-public class ClassWriterImpl extends SubWriterHolderWriter implements ClassWriter {\n-\n-    private static final Set<String> suppressSubtypesSet\n-            = Set.of(\"java.lang.Object\",\n-                     \"org.omg.CORBA.Object\");\n-\n-    private static final Set<String> suppressImplementingSet\n-            = Set.of(\"java.lang.Cloneable\",\n-                     \"java.lang.constant.Constable\",\n-                     \"java.lang.constant.ConstantDesc\",\n-                     \"java.io.Serializable\");\n-\n-    protected final TypeElement typeElement;\n-\n-    protected final ClassTree classTree;\n-\n-    \/**\n-     * @param configuration the configuration data for the doclet\n-     * @param typeElement the class being documented.\n-     * @param classTree the class tree for the given class.\n-     *\/\n-    public ClassWriterImpl(HtmlConfiguration configuration, TypeElement typeElement,\n-                           ClassTree classTree) {\n-        super(configuration, configuration.docPaths.forClass(typeElement));\n-        this.typeElement = typeElement;\n-        configuration.currentTypeElement = typeElement;\n-        this.classTree = classTree;\n-    }\n-\n-    @Override\n-    public Content getOutputInstance() {\n-        return new ContentBuilder();\n-    }\n-\n-    @Override\n-    public Content getHeader(String header) {\n-        HtmlTree body = getBody(getWindowTitle(utils.getSimpleName(typeElement)));\n-        var div = HtmlTree.DIV(HtmlStyle.header);\n-        if (configuration.showModules) {\n-            ModuleElement mdle = configuration.docEnv.getElementUtils().getModuleOf(typeElement);\n-            var classModuleLabel = HtmlTree.SPAN(HtmlStyle.moduleLabelInType, contents.moduleLabel);\n-            var moduleNameDiv = HtmlTree.DIV(HtmlStyle.subTitle, classModuleLabel);\n-            moduleNameDiv.add(Entity.NO_BREAK_SPACE);\n-            moduleNameDiv.add(getModuleLink(mdle,\n-                    Text.of(mdle.getQualifiedName())));\n-            div.add(moduleNameDiv);\n-        }\n-        PackageElement pkg = utils.containingPackage(typeElement);\n-        if (!pkg.isUnnamed()) {\n-            var classPackageLabel = HtmlTree.SPAN(HtmlStyle.packageLabelInType, contents.packageLabel);\n-            var pkgNameDiv = HtmlTree.DIV(HtmlStyle.subTitle, classPackageLabel);\n-            pkgNameDiv.add(Entity.NO_BREAK_SPACE);\n-            Content pkgNameContent = getPackageLink(pkg, getLocalizedPackageName(pkg));\n-            pkgNameDiv.add(pkgNameContent);\n-            div.add(pkgNameDiv);\n-        }\n-        HtmlLinkInfo linkInfo = new HtmlLinkInfo(configuration,\n-                HtmlLinkInfo.Kind.SHOW_TYPE_PARAMS_AND_BOUNDS, typeElement)\n-                .linkToSelf(false);  \/\/ Let's not link to ourselves in the header\n-        var heading = HtmlTree.HEADING_TITLE(Headings.PAGE_TITLE_HEADING,\n-                HtmlStyle.title, Text.of(header));\n-        heading.add(getTypeParameterLinks(linkInfo));\n-        div.add(heading);\n-        bodyContents.setHeader(getHeader(PageMode.CLASS, typeElement))\n-                .addMainContent(MarkerComments.START_OF_CLASS_DATA)\n-                .addMainContent(div);\n-        return body;\n-    }\n-\n-    @Override\n-    public Content getClassContentHeader() {\n-        return getContentHeader();\n-    }\n-\n-    @Override\n-    protected Navigation getNavBar(PageMode pageMode, Element element) {\n-        Content linkContent = getModuleLink(utils.elementUtils.getModuleOf(element),\n-                contents.moduleLabel);\n-        return super.getNavBar(pageMode, element)\n-                .setNavLinkModule(linkContent)\n-                .setSubNavLinks(() -> {\n-                    List<Content> list = new ArrayList<>();\n-                    VisibleMemberTable vmt = configuration.getVisibleMemberTable(typeElement);\n-                    Set<VisibleMemberTable.Kind> summarySet =\n-                            VisibleMemberTable.Kind.forSummariesOf(element.getKind());\n-                    for (VisibleMemberTable.Kind kind : summarySet) {\n-                        list.add(links.createLink(HtmlIds.forMemberSummary(kind),\n-                                contents.getNavLinkLabelContent(kind), vmt.hasVisibleMembers(kind)));\n-                    }\n-                    return list;\n-                });\n-    }\n-\n-    @Override\n-    public void addFooter() {\n-        bodyContents.addMainContent(MarkerComments.END_OF_CLASS_DATA);\n-        bodyContents.setFooter(getFooter());\n-    }\n-\n-    @Override\n-    public void printDocument(Content content) throws DocFileIOException {\n-        String description = getDescription(\"declaration\", typeElement);\n-        PackageElement pkg = utils.containingPackage(typeElement);\n-        List<DocPath> localStylesheets = getLocalStylesheets(pkg);\n-        content.add(bodyContents);\n-        printHtmlDocument(configuration.metakeywords.getMetaKeywords(typeElement),\n-                description, localStylesheets, content);\n-    }\n-\n-    @Override\n-    public Content getClassInfo(Content classInfo) {\n-        return getMember(HtmlIds.CLASS_DESCRIPTION, HtmlStyle.classDescription, classInfo);\n-    }\n-\n-    @Override\n-    public TypeElement getCurrentPageElement() {\n-        return typeElement;\n-    }\n-\n-    @Override\n-    public void addClassSignature(Content classInfo) {\n-        classInfo.add(new HtmlTree(TagName.HR));\n-        classInfo.add(new Signatures.TypeSignature(typeElement, this)\n-                .toContent());\n-    }\n-\n-\n-    @Override\n-    public void addClassDescription(Content classInfo) {\n-        addPreviewInfo(classInfo);\n-        if (!options.noComment()) {\n-            \/\/ generate documentation for the class.\n-            if (!utils.getFullBody(typeElement).isEmpty()) {\n-                addInlineComment(typeElement, classInfo);\n-            }\n-        }\n-    }\n-\n-    private void addPreviewInfo(Content content) {\n-        addPreviewInfo(typeElement, content);\n-    }\n-\n-    @Override\n-    public void addClassTagInfo(Content classInfo) {\n-        if (!options.noComment()) {\n-            \/\/ Print Information about all the tags here\n-            addTagsInfo(typeElement, classInfo);\n-        }\n-    }\n-\n-    \/**\n-     * Get the class inheritance tree for the given class.\n-     *\n-     * @param type the class to get the inheritance tree for\n-     * @return the class inheritance tree\n-     *\/\n-    private Content getClassInheritanceTreeContent(TypeMirror type) {\n-        TypeMirror sup;\n-        HtmlTree classTree = null;\n-        do {\n-            sup = utils.getFirstVisibleSuperClass(type);\n-            var entry = HtmlTree.DIV(HtmlStyle.inheritance, getClassHelperContent(type));\n-            if (classTree != null)\n-                entry.add(classTree);\n-            classTree = entry;\n-            type = sup;\n-        } while (sup != null);\n-        classTree.put(HtmlAttr.TITLE, contents.getContent(\"doclet.Inheritance_Tree\").toString());\n-        return classTree;\n-    }\n-\n-    \/**\n-     * Get the class helper for the given class.\n-     *\n-     * @param type the class to get the helper for\n-     * @return the class helper\n-     *\/\n-    private Content getClassHelperContent(TypeMirror type) {\n-        Content result = new ContentBuilder();\n-        if (utils.typeUtils.isSameType(type, typeElement.asType())) {\n-            Content typeParameters = getTypeParameterLinks(\n-                    new HtmlLinkInfo(configuration, HtmlLinkInfo.Kind.SHOW_TYPE_PARAMS,\n-                    typeElement));\n-            if (configuration.shouldExcludeQualifier(utils.containingPackage(typeElement).toString())) {\n-                result.add(utils.asTypeElement(type).getSimpleName());\n-                result.add(typeParameters);\n-            } else {\n-                result.add(utils.asTypeElement(type).getQualifiedName());\n-                result.add(typeParameters);\n-            }\n-        } else {\n-            Content link = getLink(new HtmlLinkInfo(configuration,\n-                    HtmlLinkInfo.Kind.SHOW_TYPE_PARAMS, type)\n-                    .label(configuration.getClassName(utils.asTypeElement(type))));\n-            result.add(link);\n-        }\n-        return result;\n-    }\n-\n-    @Override\n-    public void addClassTree(Content target) {\n-        if (!utils.isClass(typeElement)) {\n-            return;\n-        }\n-        target.add(getClassInheritanceTreeContent(typeElement.asType()));\n-    }\n-\n-    @Override\n-    public void addParamInfo(Content target) {\n-        if (utils.hasBlockTag(typeElement, DocTree.Kind.PARAM)) {\n-            var t = configuration.tagletManager.getTaglet(DocTree.Kind.PARAM);\n-            Content paramInfo = t.getAllBlockTagOutput(typeElement, getTagletWriterInstance(false));\n-            if (!paramInfo.isEmpty()) {\n-                target.add(HtmlTree.DL(HtmlStyle.notes, paramInfo));\n-            }\n-        }\n-    }\n-\n-    @Override\n-    public void addSubClassInfo(Content target) {\n-        if (utils.isClass(typeElement)) {\n-            for (String s : suppressSubtypesSet) {\n-                if (typeElement.getQualifiedName().contentEquals(s)) {\n-                    return;    \/\/ Don't generate the list, too huge\n-                }\n-            }\n-            Set<TypeElement> subclasses = classTree.hierarchy(typeElement).subtypes(typeElement);\n-            if (!subclasses.isEmpty()) {\n-                var dl = HtmlTree.DL(HtmlStyle.notes);\n-                dl.add(HtmlTree.DT(contents.subclassesLabel));\n-                dl.add(HtmlTree.DD(getClassLinks(HtmlLinkInfo.Kind.PLAIN, subclasses)));\n-                target.add(dl);\n-            }\n-        }\n-    }\n-\n-    @Override\n-    public void addSubInterfacesInfo(Content target) {\n-        if (utils.isPlainInterface(typeElement)) {\n-            Set<TypeElement> subInterfaces = classTree.hierarchy(typeElement).allSubtypes(typeElement);\n-            if (!subInterfaces.isEmpty()) {\n-                var dl = HtmlTree.DL(HtmlStyle.notes);\n-                dl.add(HtmlTree.DT(contents.subinterfacesLabel));\n-                dl.add(HtmlTree.DD(getClassLinks(HtmlLinkInfo.Kind.SHOW_TYPE_PARAMS, subInterfaces)));\n-                target.add(dl);\n-            }\n-        }\n-    }\n-\n-    @Override\n-    public void addInterfaceUsageInfo(Content target) {\n-        if (!utils.isPlainInterface(typeElement)) {\n-            return;\n-        }\n-        for (String s : suppressImplementingSet) {\n-            if (typeElement.getQualifiedName().contentEquals(s)) {\n-                return;    \/\/ Don't generate the list, too huge\n-            }\n-        }\n-        Set<TypeElement> implcl = classTree.implementingClasses(typeElement);\n-        if (!implcl.isEmpty()) {\n-            var dl = HtmlTree.DL(HtmlStyle.notes);\n-            dl.add(HtmlTree.DT(contents.implementingClassesLabel));\n-            dl.add(HtmlTree.DD(getClassLinks(HtmlLinkInfo.Kind.PLAIN, implcl)));\n-            target.add(dl);\n-        }\n-    }\n-\n-    @Override\n-    public void addImplementedInterfacesInfo(Content target) {\n-        SortedSet<TypeMirror> interfaces = new TreeSet<>(comparators.makeTypeMirrorClassUseComparator());\n-        interfaces.addAll(utils.getAllInterfaces(typeElement));\n-        if (utils.isClass(typeElement) && !interfaces.isEmpty()) {\n-            var dl = HtmlTree.DL(HtmlStyle.notes);\n-            dl.add(HtmlTree.DT(contents.allImplementedInterfacesLabel));\n-            dl.add(HtmlTree.DD(getClassLinks(HtmlLinkInfo.Kind.SHOW_TYPE_PARAMS, interfaces)));\n-            target.add(dl);\n-        }\n-    }\n-\n-    @Override\n-    public void addSuperInterfacesInfo(Content target) {\n-        SortedSet<TypeMirror> interfaces =\n-                new TreeSet<>(comparators.makeTypeMirrorIndexUseComparator());\n-        interfaces.addAll(utils.getAllInterfaces(typeElement));\n-\n-        if (utils.isPlainInterface(typeElement) && !interfaces.isEmpty()) {\n-            var dl = HtmlTree.DL(HtmlStyle.notes);\n-            dl.add(HtmlTree.DT(contents.allSuperinterfacesLabel));\n-            dl.add(HtmlTree.DD(getClassLinks(HtmlLinkInfo.Kind.SHOW_TYPE_PARAMS, interfaces)));\n-            target.add(dl);\n-        }\n-    }\n-\n-    @Override\n-    public void addNestedClassInfo(final Content target) {\n-        Element outerClass = typeElement.getEnclosingElement();\n-        if (outerClass == null)\n-            return;\n-        new SimpleElementVisitor8<Void, Void>() {\n-            @Override\n-            public Void visitType(TypeElement e, Void p) {\n-                var dl = HtmlTree.DL(HtmlStyle.notes);\n-                dl.add(HtmlTree.DT(utils.isPlainInterface(e)\n-                        ? contents.enclosingInterfaceLabel\n-                        : contents.enclosingClassLabel));\n-                dl.add(HtmlTree.DD(getClassLinks(HtmlLinkInfo.Kind.LINK_TYPE_PARAMS_AND_BOUNDS, List.of(e))));\n-                target.add(dl);\n-                return null;\n-            }\n-        }.visit(outerClass);\n-    }\n-\n-    @Override\n-    public void addFunctionalInterfaceInfo (Content target) {\n-        if (isFunctionalInterface()) {\n-            var dl = HtmlTree.DL(HtmlStyle.notes);\n-            dl.add(HtmlTree.DT(contents.functionalInterface));\n-            var dd = new HtmlTree(TagName.DD);\n-            dd.add(contents.functionalInterfaceMessage);\n-            dl.add(dd);\n-            target.add(dl);\n-        }\n-    }\n-\n-    public boolean isFunctionalInterface() {\n-        List<? extends AnnotationMirror> annotationMirrors = typeElement.getAnnotationMirrors();\n-        for (AnnotationMirror anno : annotationMirrors) {\n-            if (utils.isFunctionalInterface(anno)) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-\n-    @Override\n-    public void addClassDeprecationInfo(Content classInfo) {\n-        List<? extends DeprecatedTree> deprs = utils.getDeprecatedTrees(typeElement);\n-        if (utils.isDeprecated(typeElement)) {\n-            var deprLabel = HtmlTree.SPAN(HtmlStyle.deprecatedLabel, getDeprecatedPhrase(typeElement));\n-            var div = HtmlTree.DIV(HtmlStyle.deprecationBlock, deprLabel);\n-            if (!deprs.isEmpty()) {\n-                CommentHelper ch = utils.getCommentHelper(typeElement);\n-                DocTree dt = deprs.get(0);\n-                List<? extends DocTree> commentTags = ch.getBody(dt);\n-                if (!commentTags.isEmpty()) {\n-                    addInlineDeprecatedComment(typeElement, deprs.get(0), div);\n-                }\n-            }\n-            classInfo.add(div);\n-        }\n-    }\n-\n-    \/**\n-     * Get the links to the given classes.\n-     *\n-     * @param context the id of the context where the links will be added\n-     * @param list the classes\n-     * @return the links\n-     *\/\n-    private Content getClassLinks(HtmlLinkInfo.Kind context, Collection<?> list) {\n-        Content content = new ContentBuilder();\n-        boolean isFirst = true;\n-        for (Object type : list) {\n-            if (!isFirst) {\n-                content.add(Text.of(\", \"));\n-            } else {\n-                isFirst = false;\n-            }\n-            \/\/ TODO: should we simply split this method up to avoid instanceof ?\n-            if (type instanceof TypeElement te) {\n-                Content link = getLink(\n-                        new HtmlLinkInfo(configuration, context, te));\n-                content.add(HtmlTree.CODE(link));\n-            } else {\n-                Content link = getLink(\n-                        new HtmlLinkInfo(configuration, context, ((TypeMirror)type)));\n-                content.add(HtmlTree.CODE(link));\n-            }\n-        }\n-        return content;\n-    }\n-\n-    \/**\n-     * Return the TypeElement being documented.\n-     *\n-     * @return the TypeElement being documented.\n-     *\/\n-    @Override\n-    public TypeElement getTypeElement() {\n-        return typeElement;\n-    }\n-\n-    @Override\n-    public Content getMemberDetails(Content content) {\n-        var section = HtmlTree.SECTION(HtmlStyle.details, content);\n-        \/\/ The following id is required by the Navigation bar\n-        if (utils.isAnnotationInterface(typeElement)) {\n-            section.setId(HtmlIds.ANNOTATION_TYPE_ELEMENT_DETAIL);\n-        }\n-        return section;\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/ClassWriterImpl.java","additions":0,"deletions":470,"binary":false,"changes":470,"status":"deleted"},{"patch":"@@ -0,0 +1,488 @@\n+\/*\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.Modifier;\n+import javax.lang.model.element.PackageElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+\n+import jdk.javadoc.internal.doclets.formats.html.markup.BodyContents;\n+import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n+import jdk.javadoc.internal.doclets.formats.html.markup.Entity;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlId;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;\n+import jdk.javadoc.internal.doclets.formats.html.markup.TagName;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n+import jdk.javadoc.internal.doclets.formats.html.Navigation.PageMode;\n+import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n+import jdk.javadoc.internal.doclets.toolkit.DocletException;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocFileIOException;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocLink;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocPaths;\n+import jdk.javadoc.internal.doclets.toolkit.util.IndexItem;\n+import jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable;\n+\n+\n+\/**\n+ * Write the Constants Summary Page in HTML format.\n+ *\/\n+public class ConstantsSummaryWriter extends HtmlDocletWriter {\n+\n+    \/**\n+     * The maximum number of package directories shown in the headings of\n+     * the constant values contents list and headings.\n+     *\/\n+    private static final int MAX_CONSTANT_VALUE_INDEX_LENGTH = 2;\n+\n+    \/**\n+     * The current class being documented.\n+     *\/\n+    private TypeElement currentTypeElement;\n+\n+    private final TableHeader constantsTableHeader;\n+\n+    \/**\n+     * The HTML tree for constant values summary currently being written.\n+     *\/\n+    private HtmlTree summarySection;\n+\n+    private final BodyContents bodyContents = new BodyContents();\n+\n+    private boolean hasConstants = false;\n+\n+\n+    \/**\n+     * The set of type elements that have constant fields.\n+     *\/\n+    protected final Set<TypeElement> typeElementsWithConstFields;\n+\n+    \/**\n+     * The set of package-group headings.\n+     *\/\n+    protected final Set<String> packageGroupHeadings;\n+\n+    private PackageElement currentPackage;\n+    private TypeElement currentClass; \/\/ FIXME: dup of currentTypeElement\n+\n+\n+    \/**\n+     * Construct a ConstantsSummaryWriter.\n+     * @param configuration the configuration used in this run\n+     *        of the standard doclet.\n+     *\/\n+    public ConstantsSummaryWriter(HtmlConfiguration configuration) {\n+        super(configuration, DocPaths.CONSTANT_VALUES, false);\n+        constantsTableHeader = new TableHeader(\n+                contents.modifierAndTypeLabel, contents.constantFieldLabel, contents.valueLabel);\n+\n+        this.typeElementsWithConstFields = new HashSet<>();\n+        this.packageGroupHeadings = new TreeSet<>(utils::compareStrings);\n+    }\n+\n+    public void build() throws DocletException {\n+        boolean anyConstants = configuration.packages.stream().anyMatch(this::hasConstantField);\n+        if (!anyConstants) {\n+            return;\n+        }\n+\n+        configuration.conditionalPages.add(HtmlConfiguration.ConditionalPage.CONSTANT_VALUES);\n+        writeGenerating();\n+\n+        buildConstantSummary();\n+    }\n+\n+    \/**\n+     * Builds the constant summary page.\n+     *\n+     * @throws DocletException if there is a problem while building the documentation\n+     *\/\n+    protected void buildConstantSummary() throws DocletException {\n+        Content content = getHeader();\n+\n+        buildContents();\n+        buildConstantSummaries();\n+\n+        addFooter();\n+        printDocument(content);\n+    }\n+\n+    \/**\n+     * Builds the list of contents for the groups of packages appearing in the constants summary page.\n+     *\/\n+    protected void buildContents() {\n+        Content contentList = getContentsHeader();\n+        packageGroupHeadings.clear();\n+        for (PackageElement pkg : configuration.packages) {\n+            String abbrevPackageName = getAbbrevPackageName(pkg);\n+            if (hasConstantField(pkg) && !packageGroupHeadings.contains(abbrevPackageName)) {\n+                addLinkToPackageContent(abbrevPackageName, contentList);\n+                packageGroupHeadings.add(abbrevPackageName);\n+            }\n+        }\n+        addContentsList(contentList);\n+    }\n+\n+    \/**\n+     * Builds the summary for each documented package.\n+     *\/\n+    protected void buildConstantSummaries() {\n+        packageGroupHeadings.clear();\n+        Content summaries = getConstantSummaries();\n+        for (PackageElement aPackage : configuration.packages) {\n+            if (hasConstantField(aPackage)) {\n+                currentPackage = aPackage;\n+                \/\/Build the documentation for the current package.\n+                buildPackageHeader(summaries);\n+                buildClassConstantSummary();\n+            }\n+        }\n+        addConstantSummaries(summaries);\n+    }\n+\n+    \/**\n+     * Builds the header for the given package.\n+     *\n+     * @param target the content to which the package header will be added\n+     *\/\n+    protected void buildPackageHeader(Content target) {\n+        String abbrevPkgName = getAbbrevPackageName(currentPackage);\n+        if (!packageGroupHeadings.contains(abbrevPkgName)) {\n+            addPackageGroup(abbrevPkgName, target);\n+            packageGroupHeadings.add(abbrevPkgName);\n+        }\n+    }\n+\n+    \/**\n+     * Builds the summary for the current class.\n+     *\/\n+    protected void buildClassConstantSummary() {\n+        SortedSet<TypeElement> classes = !currentPackage.isUnnamed()\n+                ? utils.getAllClasses(currentPackage)\n+                : configuration.typeElementCatalog.allUnnamedClasses();\n+        Content classConstantHeader = getClassConstantHeader();\n+        for (TypeElement te : classes) {\n+            if (!typeElementsWithConstFields.contains(te) ||\n+                    !utils.isIncluded(te)) {\n+                continue;\n+            }\n+            currentClass = te;\n+            \/\/Build the documentation for the current class.\n+\n+            buildConstantMembers(classConstantHeader);\n+\n+        }\n+        addClassConstant(classConstantHeader);\n+    }\n+\n+    \/**\n+     * Builds the summary of constant members in the class.\n+     *\n+     * @param target the content to which the table of constant members will be added\n+     *\/\n+    protected void buildConstantMembers(Content target) {\n+        new ConstantFieldBuilder(currentClass).buildMembersSummary(target);\n+    }\n+\n+    \/**\n+     * {@return true if the given package has constant fields to document}\n+     *\n+     * @param pkg   the package to be checked\n+     *\/\n+    private boolean hasConstantField(PackageElement pkg) {\n+        SortedSet<TypeElement> classes = !pkg.isUnnamed()\n+                ? utils.getAllClasses(pkg)\n+                : configuration.typeElementCatalog.allUnnamedClasses();\n+        boolean found = false;\n+        for (TypeElement te : classes) {\n+            if (utils.isIncluded(te) && hasConstantField(te)) {\n+                found = true;\n+            }\n+        }\n+        return found;\n+    }\n+\n+    \/**\n+     * {@return true if the given class has constant fields to document}\n+     *\n+     * @param typeElement the class to be checked\n+     *\/\n+    private boolean hasConstantField(TypeElement typeElement) {\n+        VisibleMemberTable vmt = configuration.getVisibleMemberTable(typeElement);\n+        List<? extends Element> fields = vmt.getVisibleMembers(VisibleMemberTable.Kind.FIELDS);\n+        for (Element f : fields) {\n+            VariableElement field = (VariableElement)f;\n+            if (field.getConstantValue() != null) {\n+                typeElementsWithConstFields.add(typeElement);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    \/**\n+     * {@return the abbreviated name for a package, containing the leading segments of the name}\n+     *\n+     * @param pkg the package\n+     *\/\n+    public String getAbbrevPackageName(PackageElement pkg) {\n+        if (pkg.isUnnamed()) {\n+            return \"\";\n+        }\n+\n+        String packageName = utils.getPackageName(pkg);\n+        int index = -1;\n+        for (int j = 0; j < MAX_CONSTANT_VALUE_INDEX_LENGTH; j++) {\n+            index = packageName.indexOf(\".\", index + 1);\n+        }\n+        return index == -1 ? packageName : packageName.substring(0, index);\n+    }\n+\n+    \/**\n+     * Builder for the table of fields with constant values.\n+     *\/\n+    private class ConstantFieldBuilder {\n+\n+        \/**\n+         * The type element that we are examining constants for.\n+         *\/\n+        protected TypeElement typeElement;\n+\n+        \/**\n+         * Constructs a {@code ConstantFieldBuilder}.\n+         * @param typeElement the type element that we are examining constants for\n+         *\/\n+        public ConstantFieldBuilder(TypeElement typeElement) {\n+            this.typeElement = typeElement;\n+        }\n+\n+        \/**\n+         * Builds the table of constants for a given class.\n+         *\n+         * @param target the content to which the table of class constants will be added\n+         *\/\n+        protected void buildMembersSummary(Content target) {\n+            SortedSet<VariableElement> members = members();\n+            if (!members.isEmpty()) {\n+                addConstantMembers(typeElement, members, target);\n+            }\n+        }\n+\n+        \/**\n+         * {@return a set of visible constant fields for the given type}\n+         *\/\n+        protected SortedSet<VariableElement> members() {\n+            VisibleMemberTable vmt = configuration.getVisibleMemberTable(typeElement);\n+            List<Element> members = new ArrayList<>();\n+            members.addAll(vmt.getVisibleMembers(VisibleMemberTable.Kind.FIELDS));\n+            members.addAll(vmt.getVisibleMembers(VisibleMemberTable.Kind.ENUM_CONSTANTS));\n+            SortedSet<VariableElement> includes =\n+                    new TreeSet<>(utils.comparators.makeGeneralPurposeComparator());\n+            for (Element element : members) {\n+                VariableElement member = (VariableElement)element;\n+                if (member.getConstantValue() != null) {\n+                    includes.add(member);\n+                }\n+            }\n+            return includes;\n+        }\n+    }\n+\n+     Content getHeader() {\n+        String label = resources.getText(\"doclet.Constants_Summary\");\n+        HtmlTree body = getBody(getWindowTitle(label));\n+        bodyContents.setHeader(getHeader(PageMode.CONSTANT_VALUES));\n+        return body;\n+    }\n+\n+     Content getContentsHeader() {\n+        return HtmlTree.UL(HtmlStyle.contentsList);\n+    }\n+\n+     void addLinkToPackageContent(String abbrevPackageName, Content content) {\n+        \/\/add link to summary\n+        Content link;\n+        if (abbrevPackageName.isEmpty()) {\n+            link = links.createLink(HtmlIds.UNNAMED_PACKAGE_ANCHOR,\n+                    contents.defaultPackageLabel, \"\");\n+        } else {\n+            Content packageNameContent = Text.of(abbrevPackageName + \".*\");\n+            link = links.createLink(DocLink.fragment(abbrevPackageName),\n+                    packageNameContent, \"\");\n+        }\n+        content.add(HtmlTree.LI(link));\n+    }\n+\n+     void addContentsList(Content content) {\n+        Content titleContent = contents.constantsSummaryTitle;\n+        var pHeading = HtmlTree.HEADING_TITLE(Headings.PAGE_TITLE_HEADING,\n+                HtmlStyle.title, titleContent);\n+        var div = HtmlTree.DIV(HtmlStyle.header, pHeading);\n+        bodyContents.addMainContent(div);\n+        Content headingContent = contents.contentsHeading;\n+        var heading = HtmlTree.HEADING_TITLE(Headings.CONTENT_HEADING,\n+                headingContent);\n+        var section = HtmlTree.SECTION(HtmlStyle.packages, heading);\n+        section.add(content);\n+        bodyContents.addMainContent(section);\n+    }\n+\n+    \/\/@Override\n+    \/\/ TODO: inline?\n+    public Content getConstantSummaries() {\n+        return new ContentBuilder();\n+    }\n+\n+     void addPackageGroup(String abbrevPackageName, Content toContent) {\n+        Content headingContent;\n+        HtmlId anchorName;\n+        if (abbrevPackageName.isEmpty()) {\n+            anchorName = HtmlIds.UNNAMED_PACKAGE_ANCHOR;\n+            headingContent = contents.defaultPackageLabel;\n+        } else {\n+            anchorName = htmlIds.forPackageName(abbrevPackageName);\n+            headingContent = new ContentBuilder(\n+                    getPackageLabel(abbrevPackageName),\n+                    Text.of(\".*\"));\n+        }\n+        var heading = HtmlTree.HEADING_TITLE(\n+                Headings.ConstantsSummary.PACKAGE_HEADING,\n+                headingContent);\n+        summarySection = HtmlTree.SECTION(HtmlStyle.constantsSummary, heading)\n+                .setId(anchorName);\n+\n+        toContent.add(summarySection);\n+    }\n+\n+     Content getClassConstantHeader() {\n+        return HtmlTree.UL(HtmlStyle.blockList);\n+    }\n+\n+     void addClassConstant(Content fromClassConstant) {\n+        summarySection.add(fromClassConstant);\n+        hasConstants = true;\n+    }\n+\n+     void addConstantMembers(TypeElement typeElement, Collection<VariableElement> fields,\n+            Content target) {\n+        currentTypeElement = typeElement;\n+\n+        \/\/generate links backward only to public classes.\n+        Content classLink = (utils.isPublic(typeElement) || utils.isProtected(typeElement)) ?\n+            getLink(new HtmlLinkInfo(configuration,\n+                    HtmlLinkInfo.Kind.SHOW_TYPE_PARAMS_IN_LABEL, typeElement)) :\n+            Text.of(utils.getFullyQualifiedName(typeElement));\n+\n+        PackageElement enclosingPackage  = utils.containingPackage(typeElement);\n+        Content caption = new ContentBuilder();\n+        if (!enclosingPackage.isUnnamed()) {\n+            caption.add(enclosingPackage.getQualifiedName());\n+            caption.add(\".\");\n+        }\n+        caption.add(classLink);\n+\n+        var table = new Table<Void>(HtmlStyle.summaryTable)\n+                .setCaption(caption)\n+                .setHeader(constantsTableHeader)\n+                .setColumnStyles(HtmlStyle.colFirst, HtmlStyle.colSecond, HtmlStyle.colLast);\n+\n+        for (VariableElement field : fields) {\n+            table.addRow(getTypeColumn(field), getNameColumn(field), getValue(field));\n+        }\n+        target.add(HtmlTree.LI(table));\n+    }\n+\n+    \/**\n+     * Get the type column for the constant summary table row.\n+     *\n+     * @param member the field to be documented.\n+     * @return the type column of the constant table row\n+     *\/\n+    private Content getTypeColumn(VariableElement member) {\n+        Content typeContent = new ContentBuilder();\n+        var code = new HtmlTree(TagName.CODE)\n+                .setId(htmlIds.forMember(currentTypeElement, member));\n+        for (Modifier mod : member.getModifiers()) {\n+            code.add(Text.of(mod.toString()))\n+                    .add(Entity.NO_BREAK_SPACE);\n+        }\n+        Content type = getLink(new HtmlLinkInfo(configuration,\n+                HtmlLinkInfo.Kind.LINK_TYPE_PARAMS_AND_BOUNDS, member.asType()));\n+        code.add(type);\n+        typeContent.add(code);\n+        return typeContent;\n+    }\n+\n+    \/**\n+     * Get the name column for the constant summary table row.\n+     *\n+     * @param member the field to be documented.\n+     * @return the name column of the constant table row\n+     *\/\n+    private Content getNameColumn(VariableElement member) {\n+        Content nameContent = getDocLink(HtmlLinkInfo.Kind.PLAIN,\n+                member, member.getSimpleName());\n+        return HtmlTree.CODE(nameContent);\n+    }\n+\n+    \/**\n+     * Get the value column for the constant summary table row.\n+     *\n+     * @param member the field to be documented.\n+     * @return the value column of the constant table row\n+     *\/\n+    private Content getValue(VariableElement member) {\n+        String value = utils.constantValueExpression(member);\n+        return HtmlTree.CODE(Text.of(value));\n+    }\n+\n+     void addConstantSummaries(Content content) {\n+        bodyContents.addMainContent(content);\n+    }\n+\n+     void addFooter() {\n+        bodyContents.setFooter(getFooter());\n+    }\n+\n+     void printDocument(Content content) throws DocFileIOException {\n+        content.add(bodyContents);\n+        printHtmlDocument(null, \"summary of constants\", content);\n+\n+        if (hasConstants && configuration.mainIndex != null) {\n+            configuration.mainIndex.add(IndexItem.of(IndexItem.Category.TAGS,\n+                    resources.getText(\"doclet.Constants_Summary\"), path));\n+        }\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/ConstantsSummaryWriter.java","additions":488,"deletions":0,"binary":false,"changes":488,"status":"added"},{"patch":"@@ -1,260 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.formats.html;\n-\n-import java.util.Collection;\n-\n-import javax.lang.model.element.Modifier;\n-import javax.lang.model.element.PackageElement;\n-import javax.lang.model.element.TypeElement;\n-import javax.lang.model.element.VariableElement;\n-\n-import jdk.javadoc.internal.doclets.formats.html.markup.BodyContents;\n-import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n-import jdk.javadoc.internal.doclets.formats.html.markup.Entity;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlId;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;\n-import jdk.javadoc.internal.doclets.formats.html.markup.TagName;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n-import jdk.javadoc.internal.doclets.formats.html.Navigation.PageMode;\n-import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n-import jdk.javadoc.internal.doclets.toolkit.ConstantsSummaryWriter;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocFileIOException;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocLink;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocPaths;\n-import jdk.javadoc.internal.doclets.toolkit.util.IndexItem;\n-\n-\n-\/**\n- * Write the Constants Summary Page in HTML format.\n- *\/\n-public class ConstantsSummaryWriterImpl extends HtmlDocletWriter implements ConstantsSummaryWriter {\n-\n-    \/**\n-     * The current class being documented.\n-     *\/\n-    private TypeElement currentTypeElement;\n-\n-    private final TableHeader constantsTableHeader;\n-\n-    \/**\n-     * The HTML tree for constant values summary currently being written.\n-     *\/\n-    private HtmlTree summarySection;\n-\n-    private final BodyContents bodyContents = new BodyContents();\n-\n-    private boolean hasConstants = false;\n-\n-    \/**\n-     * Construct a ConstantsSummaryWriter.\n-     * @param configuration the configuration used in this run\n-     *        of the standard doclet.\n-     *\/\n-    public ConstantsSummaryWriterImpl(HtmlConfiguration configuration) {\n-        super(configuration, DocPaths.CONSTANT_VALUES);\n-        constantsTableHeader = new TableHeader(\n-                contents.modifierAndTypeLabel, contents.constantFieldLabel, contents.valueLabel);\n-        configuration.conditionalPages.add(HtmlConfiguration.ConditionalPage.CONSTANT_VALUES);\n-    }\n-\n-    @Override\n-    public Content getHeader() {\n-        String label = resources.getText(\"doclet.Constants_Summary\");\n-        HtmlTree body = getBody(getWindowTitle(label));\n-        bodyContents.setHeader(getHeader(PageMode.CONSTANT_VALUES));\n-        return body;\n-    }\n-\n-    @Override\n-    public Content getContentsHeader() {\n-        return HtmlTree.UL(HtmlStyle.contentsList);\n-    }\n-\n-    @Override\n-    public void addLinkToPackageContent(String abbrevPackageName, Content content) {\n-        \/\/add link to summary\n-        Content link;\n-        if (abbrevPackageName.isEmpty()) {\n-            link = links.createLink(HtmlIds.UNNAMED_PACKAGE_ANCHOR,\n-                    contents.defaultPackageLabel, \"\");\n-        } else {\n-            Content packageNameContent = Text.of(abbrevPackageName + \".*\");\n-            link = links.createLink(DocLink.fragment(abbrevPackageName),\n-                    packageNameContent, \"\");\n-        }\n-        content.add(HtmlTree.LI(link));\n-    }\n-\n-    @Override\n-    public void addContentsList(Content content) {\n-        Content titleContent = contents.constantsSummaryTitle;\n-        var pHeading = HtmlTree.HEADING_TITLE(Headings.PAGE_TITLE_HEADING,\n-                HtmlStyle.title, titleContent);\n-        var div = HtmlTree.DIV(HtmlStyle.header, pHeading);\n-        bodyContents.addMainContent(div);\n-        Content headingContent = contents.contentsHeading;\n-        var heading = HtmlTree.HEADING_TITLE(Headings.CONTENT_HEADING,\n-                headingContent);\n-        var section = HtmlTree.SECTION(HtmlStyle.packages, heading);\n-        section.add(content);\n-        bodyContents.addMainContent(section);\n-    }\n-\n-    @Override\n-    public Content getConstantSummaries() {\n-        return new ContentBuilder();\n-    }\n-\n-    @Override\n-    public void addPackageGroup(String abbrevPackageName, Content toContent) {\n-        Content headingContent;\n-        HtmlId anchorName;\n-        if (abbrevPackageName.isEmpty()) {\n-            anchorName = HtmlIds.UNNAMED_PACKAGE_ANCHOR;\n-            headingContent = contents.defaultPackageLabel;\n-        } else {\n-            anchorName = htmlIds.forPackageName(abbrevPackageName);\n-            headingContent = new ContentBuilder(\n-                    getPackageLabel(abbrevPackageName),\n-                    Text.of(\".*\"));\n-        }\n-        var heading = HtmlTree.HEADING_TITLE(\n-                Headings.ConstantsSummary.PACKAGE_HEADING,\n-                headingContent);\n-        summarySection = HtmlTree.SECTION(HtmlStyle.constantsSummary, heading)\n-                .setId(anchorName);\n-\n-        toContent.add(summarySection);\n-    }\n-\n-    @Override\n-    public Content getClassConstantHeader() {\n-        return HtmlTree.UL(HtmlStyle.blockList);\n-    }\n-\n-    @Override\n-    public void addClassConstant(Content fromClassConstant) {\n-        summarySection.add(fromClassConstant);\n-        hasConstants = true;\n-    }\n-\n-    @Override\n-    public void addConstantMembers(TypeElement typeElement, Collection<VariableElement> fields,\n-            Content target) {\n-        currentTypeElement = typeElement;\n-\n-        \/\/generate links backward only to public classes.\n-        Content classLink = (utils.isPublic(typeElement) || utils.isProtected(typeElement)) ?\n-            getLink(new HtmlLinkInfo(configuration,\n-                    HtmlLinkInfo.Kind.SHOW_TYPE_PARAMS_IN_LABEL, typeElement)) :\n-            Text.of(utils.getFullyQualifiedName(typeElement));\n-\n-        PackageElement enclosingPackage  = utils.containingPackage(typeElement);\n-        Content caption = new ContentBuilder();\n-        if (!enclosingPackage.isUnnamed()) {\n-            caption.add(enclosingPackage.getQualifiedName());\n-            caption.add(\".\");\n-        }\n-        caption.add(classLink);\n-\n-        var table = new Table<Void>(HtmlStyle.summaryTable)\n-                .setCaption(caption)\n-                .setHeader(constantsTableHeader)\n-                .setColumnStyles(HtmlStyle.colFirst, HtmlStyle.colSecond, HtmlStyle.colLast);\n-\n-        for (VariableElement field : fields) {\n-            table.addRow(getTypeColumn(field), getNameColumn(field), getValue(field));\n-        }\n-        target.add(HtmlTree.LI(table));\n-    }\n-\n-    \/**\n-     * Get the type column for the constant summary table row.\n-     *\n-     * @param member the field to be documented.\n-     * @return the type column of the constant table row\n-     *\/\n-    private Content getTypeColumn(VariableElement member) {\n-        Content typeContent = new ContentBuilder();\n-        var code = new HtmlTree(TagName.CODE)\n-                .setId(htmlIds.forMember(currentTypeElement, member));\n-        for (Modifier mod : member.getModifiers()) {\n-            code.add(Text.of(mod.toString()))\n-                    .add(Entity.NO_BREAK_SPACE);\n-        }\n-        Content type = getLink(new HtmlLinkInfo(configuration,\n-                HtmlLinkInfo.Kind.LINK_TYPE_PARAMS_AND_BOUNDS, member.asType()));\n-        code.add(type);\n-        typeContent.add(code);\n-        return typeContent;\n-    }\n-\n-    \/**\n-     * Get the name column for the constant summary table row.\n-     *\n-     * @param member the field to be documented.\n-     * @return the name column of the constant table row\n-     *\/\n-    private Content getNameColumn(VariableElement member) {\n-        Content nameContent = getDocLink(HtmlLinkInfo.Kind.PLAIN,\n-                member, member.getSimpleName());\n-        return HtmlTree.CODE(nameContent);\n-    }\n-\n-    \/**\n-     * Get the value column for the constant summary table row.\n-     *\n-     * @param member the field to be documented.\n-     * @return the value column of the constant table row\n-     *\/\n-    private Content getValue(VariableElement member) {\n-        String value = utils.constantValueExpression(member);\n-        return HtmlTree.CODE(Text.of(value));\n-    }\n-\n-    @Override\n-    public void addConstantSummaries(Content content) {\n-        bodyContents.addMainContent(content);\n-    }\n-\n-    @Override\n-    public void addFooter() {\n-        bodyContents.setFooter(getFooter());\n-    }\n-\n-    @Override\n-    public void printDocument(Content content) throws DocFileIOException {\n-        content.add(bodyContents);\n-        printHtmlDocument(null, \"summary of constants\", content);\n-\n-        if (hasConstants && configuration.mainIndex != null) {\n-            configuration.mainIndex.add(IndexItem.of(IndexItem.Category.TAGS,\n-                    resources.getText(\"doclet.Constants_Summary\"), path));\n-        }\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/ConstantsSummaryWriterImpl.java","additions":0,"deletions":260,"binary":false,"changes":260,"status":"deleted"},{"patch":"@@ -0,0 +1,304 @@\n+\/*\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+\n+import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n+import jdk.javadoc.internal.doclets.formats.html.markup.Entity;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlId;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;\n+import jdk.javadoc.internal.doclets.formats.html.markup.TagName;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n+import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n+import jdk.javadoc.internal.doclets.toolkit.BaseOptions;\n+import jdk.javadoc.internal.doclets.toolkit.DocletException;\n+import jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable;\n+\n+\n+\/**\n+ * Writes constructor documentation.\n+ *\/\n+public class ConstructorWriter extends AbstractExecutableMemberWriter {\n+\n+    \/**\n+     * The current constructor that is being documented at this point in time.\n+     *\/\n+    private ExecutableElement currentConstructor;\n+\n+    private boolean foundNonPubConstructor = false;\n+\n+    \/**\n+     * Construct a new ConstructorWriterImpl.\n+     *\n+     * @param writer The writer for the class that the constructors belong to.\n+     *\/\n+    public ConstructorWriter(ClassWriter writer) {\n+        super(writer, writer.getTypeElement());\n+\n+        \/\/ the following must be done before the summary table is generated\n+        var constructors = getVisibleMembers(VisibleMemberTable.Kind.CONSTRUCTORS);\n+        for (Element constructor : constructors) {\n+            if (utils.isProtected(constructor) || utils.isPrivate(constructor)) {\n+                setFoundNonPubConstructor(true);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Construct a new ConstructorWriterImpl.\n+     *\n+     * @param writer The writer for the class that the constructors belong to.\n+     *\/\n+    public ConstructorWriter(SubWriterHolderWriter writer) {\n+        super(writer);\n+    }\n+\n+    public void build(Content target) throws DocletException {\n+        buildConstructorDoc(target);\n+    }\n+\n+    \/**\n+     * Build the constructor documentation.\n+     *\n+     * @param target the content to which the documentation will be added\n+     *\/\n+    protected void buildConstructorDoc(Content target) {\n+        var constructors = getVisibleMembers(VisibleMemberTable.Kind.CONSTRUCTORS);\n+        if (!constructors.isEmpty()) {\n+            for (Element constructor : constructors) {\n+                if (utils.isProtected(constructor) || utils.isPrivate(constructor)) {\n+                    setFoundNonPubConstructor(true);\n+                }\n+            }\n+\n+            Content constructorDetailsHeader = getConstructorDetailsHeader(target);\n+            Content memberList = getMemberList();\n+\n+            for (Element constructor : constructors) {\n+                currentConstructor = (ExecutableElement)constructor;\n+                Content constructorContent = getConstructorHeaderContent(currentConstructor);\n+\n+                buildSignature(constructorContent);\n+                buildDeprecationInfo(constructorContent);\n+                buildPreviewInfo(constructorContent);\n+                buildConstructorComments(constructorContent);\n+                buildTagInfo(constructorContent);\n+\n+                memberList.add(getMemberListItem(constructorContent));\n+            }\n+            Content constructorDetails = getConstructorDetails(constructorDetailsHeader, memberList);\n+            target.add(constructorDetails);\n+        }\n+    }\n+\n+    \/**\n+     * Build the signature.\n+     *\n+     * @param constructorContent the content to which the documentation will be added\n+     *\/\n+    protected void buildSignature(Content constructorContent) {\n+        constructorContent.add(getSignature(currentConstructor));\n+    }\n+\n+    \/**\n+     * Build the deprecation information.\n+     *\n+     * @param constructorContent the content to which the documentation will be added\n+     *\/\n+    protected void buildDeprecationInfo(Content constructorContent) {\n+        addDeprecated(currentConstructor, constructorContent);\n+    }\n+\n+    \/**\n+     * Build the preview information.\n+     *\n+     * @param constructorContent the content to which the documentation will be added\n+     *\/\n+    protected void buildPreviewInfo(Content constructorContent) {\n+        addPreview(currentConstructor, constructorContent);\n+    }\n+\n+    \/**\n+     * Build the comments for the constructor.  Do nothing if\n+     * {@link BaseOptions#noComment()} is set to true.\n+     *\n+     * @param constructorContent the content to which the documentation will be added\n+     *\/\n+    protected void buildConstructorComments(Content constructorContent) {\n+        if (!options.noComment()) {\n+            addComments(currentConstructor, constructorContent);\n+        }\n+    }\n+\n+    \/**\n+     * Build the tag information.\n+     *\n+     * @param constructorContent the content to which the documentation will be added\n+     *\/\n+    protected void buildTagInfo(Content constructorContent) {\n+        addTags(currentConstructor, constructorContent);\n+    }\n+\n+    @Override\n+    public Content getMemberSummaryHeader(TypeElement typeElement,\n+            Content content) {\n+        content.add(MarkerComments.START_OF_CONSTRUCTOR_SUMMARY);\n+        Content c = new ContentBuilder();\n+        writer.addSummaryHeader(this, c);\n+        return c;\n+    }\n+\n+    @Override\n+    public void addSummary(Content summariesList, Content content) {\n+        writer.addSummary(HtmlStyle.constructorSummary,\n+                HtmlIds.CONSTRUCTOR_SUMMARY, summariesList, content);\n+    }\n+\n+    protected Content getConstructorDetailsHeader(Content content) {\n+        content.add(MarkerComments.START_OF_CONSTRUCTOR_DETAILS);\n+        Content constructorDetails = new ContentBuilder();\n+        var heading = HtmlTree.HEADING(Headings.TypeDeclaration.DETAILS_HEADING,\n+                contents.constructorDetailsLabel);\n+        constructorDetails.add(heading);\n+        return constructorDetails;\n+    }\n+\n+    protected Content getConstructorHeaderContent(ExecutableElement constructor) {\n+        Content content = new ContentBuilder();\n+        var heading = HtmlTree.HEADING(Headings.TypeDeclaration.MEMBER_HEADING,\n+                Text.of(name(constructor)));\n+        HtmlId erasureAnchor = htmlIds.forErasure(constructor);\n+        if (erasureAnchor != null) {\n+            heading.setId(erasureAnchor);\n+        }\n+        content.add(heading);\n+        return HtmlTree.SECTION(HtmlStyle.detail, content)\n+                .setId(htmlIds.forMember(constructor));\n+    }\n+\n+    protected Content getSignature(ExecutableElement constructor) {\n+        return new Signatures.MemberSignature(constructor, this)\n+                .setParameters(getParameters(constructor, true))\n+                .setExceptions(getExceptions(constructor))\n+                .setAnnotations(writer.getAnnotationInfo(constructor, true))\n+                .toContent();\n+    }\n+\n+    protected void addDeprecated(ExecutableElement constructor, Content constructorContent) {\n+        addDeprecatedInfo(constructor, constructorContent);\n+    }\n+\n+    protected void addPreview(ExecutableElement constructor, Content content) {\n+        addPreviewInfo(constructor, content);\n+    }\n+\n+    protected void addComments(ExecutableElement constructor, Content constructorContent) {\n+        addComment(constructor, constructorContent);\n+    }\n+\n+    protected void addTags(ExecutableElement constructor, Content constructorContent) {\n+        writer.addTagsInfo(constructor, constructorContent);\n+    }\n+\n+    protected Content getConstructorDetails(Content memberDetailsHeader, Content memberDetails) {\n+        return writer.getDetailsListItem(\n+                HtmlTree.SECTION(HtmlStyle.constructorDetails)\n+                        .setId(HtmlIds.CONSTRUCTOR_DETAIL)\n+                        .add(memberDetailsHeader)\n+                        .add(memberDetails));\n+    }\n+\n+    protected void setFoundNonPubConstructor(boolean foundNonPubConstructor) {\n+        this.foundNonPubConstructor = foundNonPubConstructor;\n+    }\n+\n+    @Override\n+    public void addSummaryLabel(Content content) {\n+        var label = HtmlTree.HEADING(Headings.TypeDeclaration.SUMMARY_HEADING,\n+                contents.constructorSummaryLabel);\n+        content.add(label);\n+    }\n+\n+    @Override\n+    public TableHeader getSummaryTableHeader(Element member) {\n+        if (foundNonPubConstructor) {\n+            return new TableHeader(contents.modifierLabel, contents.constructorLabel,\n+                    contents.descriptionLabel);\n+        } else {\n+            return new TableHeader(contents.constructorLabel, contents.descriptionLabel);\n+        }\n+    }\n+\n+    @Override\n+    protected Table<Element> createSummaryTable() {\n+        List<HtmlStyle> bodyRowStyles;\n+\n+        if (foundNonPubConstructor) {\n+            bodyRowStyles = Arrays.asList(HtmlStyle.colFirst, HtmlStyle.colConstructorName,\n+                    HtmlStyle.colLast);\n+        } else {\n+            bodyRowStyles = Arrays.asList(HtmlStyle.colConstructorName, HtmlStyle.colLast);\n+        }\n+\n+        return new Table<Element>(\n+                HtmlStyle.summaryTable)\n+                .setCaption(contents.constructors)\n+                .setHeader(getSummaryTableHeader(typeElement))\n+                .setColumnStyles(bodyRowStyles);\n+    }\n+\n+    @Override\n+    public void addInheritedSummaryLabel(TypeElement typeElement, Content content) {\n+    }\n+\n+    @Override\n+    protected void addSummaryType(Element member, Content content) {\n+        if (foundNonPubConstructor) {\n+            var code = new HtmlTree(TagName.CODE);\n+            if (utils.isProtected(member)) {\n+                code.add(\"protected \");\n+            } else if (utils.isPrivate(member)) {\n+                code.add(\"private \");\n+            } else if (utils.isPublic(member)) {\n+                code.add(Entity.NO_BREAK_SPACE);\n+            } else {\n+                code.add(\n+                        resources.getText(\"doclet.Package_private\"));\n+            }\n+            content.add(code);\n+        }\n+    }\n+\n+    protected Content getMemberHeader(){\n+        return writer.getMemberHeader();\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/ConstructorWriter.java","additions":304,"deletions":0,"binary":false,"changes":304,"status":"added"},{"patch":"@@ -1,229 +0,0 @@\n-\/*\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.formats.html;\n-\n-import java.util.Arrays;\n-import java.util.List;\n-\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.ExecutableElement;\n-import javax.lang.model.element.TypeElement;\n-\n-import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n-import jdk.javadoc.internal.doclets.formats.html.markup.Entity;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlId;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;\n-import jdk.javadoc.internal.doclets.formats.html.markup.TagName;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n-import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n-import jdk.javadoc.internal.doclets.toolkit.ConstructorWriter;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.MemberSummaryWriter;\n-import jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable;\n-\n-import static jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable.Kind.CONSTRUCTORS;\n-\n-\n-\/**\n- * Writes constructor documentation.\n- *\/\n-public class ConstructorWriterImpl extends AbstractExecutableMemberWriter\n-    implements ConstructorWriter, MemberSummaryWriter {\n-\n-    private boolean foundNonPubConstructor = false;\n-\n-    \/**\n-     * Construct a new ConstructorWriterImpl.\n-     *\n-     * @param writer The writer for the class that the constructors belong to.\n-     * @param typeElement the class being documented.\n-     *\/\n-    public ConstructorWriterImpl(SubWriterHolderWriter writer, TypeElement typeElement) {\n-        super(writer, typeElement);\n-\n-        VisibleMemberTable vmt = configuration.getVisibleMemberTable(typeElement);\n-        List<? extends Element> constructors = vmt.getVisibleMembers(CONSTRUCTORS);\n-\n-        for (Element constructor : constructors) {\n-            if (utils.isProtected(constructor) || utils.isPrivate(constructor)) {\n-                setFoundNonPubConstructor(true);\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Construct a new ConstructorWriterImpl.\n-     *\n-     * @param writer The writer for the class that the constructors belong to.\n-     *\/\n-    public ConstructorWriterImpl(SubWriterHolderWriter writer) {\n-        super(writer);\n-    }\n-\n-    @Override\n-    public Content getMemberSummaryHeader(TypeElement typeElement,\n-            Content content) {\n-        content.add(MarkerComments.START_OF_CONSTRUCTOR_SUMMARY);\n-        Content c = new ContentBuilder();\n-        writer.addSummaryHeader(this, c);\n-        return c;\n-    }\n-\n-    @Override\n-    public void addSummary(Content summariesList, Content content) {\n-        writer.addSummary(HtmlStyle.constructorSummary,\n-                HtmlIds.CONSTRUCTOR_SUMMARY, summariesList, content);\n-    }\n-\n-    @Override\n-    public Content getConstructorDetailsHeader(Content content) {\n-        content.add(MarkerComments.START_OF_CONSTRUCTOR_DETAILS);\n-        Content constructorDetails = new ContentBuilder();\n-        var heading = HtmlTree.HEADING(Headings.TypeDeclaration.DETAILS_HEADING,\n-                contents.constructorDetailsLabel);\n-        constructorDetails.add(heading);\n-        return constructorDetails;\n-    }\n-\n-    @Override\n-    public Content getConstructorHeaderContent(ExecutableElement constructor) {\n-        Content content = new ContentBuilder();\n-        var heading = HtmlTree.HEADING(Headings.TypeDeclaration.MEMBER_HEADING,\n-                Text.of(name(constructor)));\n-        HtmlId erasureAnchor = htmlIds.forErasure(constructor);\n-        if (erasureAnchor != null) {\n-            heading.setId(erasureAnchor);\n-        }\n-        content.add(heading);\n-        return HtmlTree.SECTION(HtmlStyle.detail, content)\n-                .setId(htmlIds.forMember(constructor));\n-    }\n-\n-    @Override\n-    public Content getSignature(ExecutableElement constructor) {\n-        return new Signatures.MemberSignature(constructor, this)\n-                .setParameters(getParameters(constructor, true))\n-                .setExceptions(getExceptions(constructor))\n-                .setAnnotations(writer.getAnnotationInfo(constructor, true))\n-                .toContent();\n-    }\n-\n-    @Override\n-    public void addDeprecated(ExecutableElement constructor, Content constructorContent) {\n-        addDeprecatedInfo(constructor, constructorContent);\n-    }\n-\n-    @Override\n-    public void addPreview(ExecutableElement constructor, Content content) {\n-        addPreviewInfo(constructor, content);\n-    }\n-\n-    @Override\n-    public void addComments(ExecutableElement constructor, Content constructorContent) {\n-        addComment(constructor, constructorContent);\n-    }\n-\n-    @Override\n-    public void addTags(ExecutableElement constructor, Content constructorContent) {\n-        writer.addTagsInfo(constructor, constructorContent);\n-    }\n-\n-    @Override\n-    public Content getConstructorDetails(Content memberDetailsHeader, Content memberDetails) {\n-        return writer.getDetailsListItem(\n-                HtmlTree.SECTION(HtmlStyle.constructorDetails)\n-                        .setId(HtmlIds.CONSTRUCTOR_DETAIL)\n-                        .add(memberDetailsHeader)\n-                        .add(memberDetails));\n-    }\n-\n-    @Override\n-    public void setFoundNonPubConstructor(boolean foundNonPubConstructor) {\n-        this.foundNonPubConstructor = foundNonPubConstructor;\n-    }\n-\n-    @Override\n-    public void addSummaryLabel(Content content) {\n-        var label = HtmlTree.HEADING(Headings.TypeDeclaration.SUMMARY_HEADING,\n-                contents.constructorSummaryLabel);\n-        content.add(label);\n-    }\n-\n-    @Override\n-    public TableHeader getSummaryTableHeader(Element member) {\n-        if (foundNonPubConstructor) {\n-            return new TableHeader(contents.modifierLabel, contents.constructorLabel,\n-                    contents.descriptionLabel);\n-        } else {\n-            return new TableHeader(contents.constructorLabel, contents.descriptionLabel);\n-        }\n-    }\n-\n-    @Override\n-    protected Table<Element> createSummaryTable() {\n-        List<HtmlStyle> bodyRowStyles;\n-\n-        if (foundNonPubConstructor) {\n-            bodyRowStyles = Arrays.asList(HtmlStyle.colFirst, HtmlStyle.colConstructorName,\n-                    HtmlStyle.colLast);\n-        } else {\n-            bodyRowStyles = Arrays.asList(HtmlStyle.colConstructorName, HtmlStyle.colLast);\n-        }\n-\n-        return new Table<Element>(\n-                HtmlStyle.summaryTable)\n-                .setCaption(contents.constructors)\n-                .setHeader(getSummaryTableHeader(typeElement))\n-                .setColumnStyles(bodyRowStyles);\n-    }\n-\n-    @Override\n-    public void addInheritedSummaryLabel(TypeElement typeElement, Content content) {\n-    }\n-\n-    @Override\n-    protected void addSummaryType(Element member, Content content) {\n-        if (foundNonPubConstructor) {\n-            var code = new HtmlTree(TagName.CODE);\n-            if (utils.isProtected(member)) {\n-                code.add(\"protected \");\n-            } else if (utils.isPrivate(member)) {\n-                code.add(\"private \");\n-            } else if (utils.isPublic(member)) {\n-                code.add(Entity.NO_BREAK_SPACE);\n-            } else {\n-                code.add(\n-                        resources.getText(\"doclet.Package_private\"));\n-            }\n-            content.add(code);\n-        }\n-    }\n-\n-    @Override\n-    public Content getMemberHeader(){\n-        return writer.getMemberHeader();\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/ConstructorWriterImpl.java","additions":0,"deletions":229,"binary":false,"changes":229,"status":"deleted"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.javadoc.internal.doclets.toolkit;\n+package jdk.javadoc.internal.doclets.formats.html;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/Content.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/Content.java","status":"renamed"},{"patch":"@@ -37,1 +37,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n@@ -396,1 +395,1 @@\n-        Pattern p = Pattern.compile(\"\\\\{([012])\\\\}\");\n+        Pattern p = Pattern.compile(\"\\\\{([012])}\");\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/Contents.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/DeprecatedListWriter.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n@@ -36,1 +35,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.DocFilesHandler;\n@@ -57,1 +55,1 @@\n-public class DocFilesHandlerImpl implements DocFilesHandler {\n+public class DocFilesHandler {\n@@ -72,1 +70,1 @@\n-    public DocFilesHandlerImpl(HtmlConfiguration configuration, Element element) {\n+    public DocFilesHandler(HtmlConfiguration configuration, Element element) {\n@@ -105,1 +103,0 @@\n-    @Override\n@@ -122,1 +119,0 @@\n-    @Override\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/DocFilesHandler.java","additions":2,"deletions":6,"binary":false,"changes":8,"previous_filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/DocFilesHandlerImpl.java","status":"renamed"},{"patch":"@@ -0,0 +1,258 @@\n+\/*\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+\n+import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n+import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n+import jdk.javadoc.internal.doclets.toolkit.BaseOptions;\n+import jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable;\n+\n+\/**\n+ * Writes enum constant documentation in HTML format.\n+ *\/\n+public class EnumConstantWriter extends AbstractMemberWriter {\n+\n+    \/**\n+     * The current enum constant that is being documented.\n+     *\/\n+    private VariableElement currentElement;\n+\n+    public EnumConstantWriter(ClassWriter classWriter) {\n+        super(classWriter, classWriter.typeElement);\n+    }\n+\n+    public EnumConstantWriter(SubWriterHolderWriter writer) {\n+        super(writer);\n+    }\n+\n+    public void build(Content target) {\n+        buildEnumConstant(target);\n+    }\n+\n+    \/**\n+     * Build the enum constant documentation.\n+     *\n+     * @param target the content to which the documentation will be added\n+     *\/\n+    protected void buildEnumConstant(Content target) {\n+        var enumConstants = getVisibleMembers(VisibleMemberTable.Kind.ENUM_CONSTANTS);\n+        if (!enumConstants.isEmpty()) {\n+            Content enumConstantsDetailsHeader = getEnumConstantsDetailsHeader(typeElement,\n+                    target);\n+            Content memberList = getMemberList();\n+\n+            for (Element enumConstant : enumConstants) {\n+                currentElement = (VariableElement)enumConstant;\n+                Content enumConstantContent = getEnumConstantsHeader(currentElement,\n+                        memberList);\n+\n+                buildSignature(enumConstantContent);\n+                buildDeprecationInfo(enumConstantContent);\n+                buildPreviewInfo(enumConstantContent);\n+                buildEnumConstantComments(enumConstantContent);\n+                buildTagInfo(enumConstantContent);\n+\n+                memberList.add(getMemberListItem(enumConstantContent));\n+            }\n+            Content enumConstantDetails = getEnumConstantsDetails(\n+                    enumConstantsDetailsHeader, memberList);\n+            target.add(enumConstantDetails);\n+        }\n+    }\n+\n+    \/**\n+     * Build the signature.\n+     *\n+     * @param target the content to which the documentation will be added\n+     *\/\n+    protected void buildSignature(Content target) {\n+        target.add(getSignature(currentElement));\n+    }\n+\n+    \/**\n+     * Build the deprecation information.\n+     *\n+     * @param target the content to which the documentation will be added\n+     *\/\n+    protected void buildDeprecationInfo(Content target) {\n+        addDeprecated(currentElement, target);\n+    }\n+\n+    \/**\n+     * Build the preview information.\n+     *\n+     * @param target the content to which the documentation will be added\n+     *\/\n+    protected void buildPreviewInfo(Content target) {\n+        addPreview(currentElement, target);\n+    }\n+\n+    \/**\n+     * Build the comments for the enum constant.  Do nothing if\n+     * {@link BaseOptions#noComment()} is set to true.\n+     *\n+     * @param target the content to which the documentation will be added\n+     *\/\n+    protected void buildEnumConstantComments(Content target) {\n+        if (!options.noComment()) {\n+            addComments(currentElement, target);\n+        }\n+    }\n+\n+    \/**\n+     * Build the tag information.\n+     *\n+     * @param target the content to which the documentation will be added\n+     *\/\n+    protected void buildTagInfo(Content target) {\n+        addTags(currentElement, target);\n+    }\n+\n+    @Override\n+    public Content getMemberSummaryHeader(TypeElement typeElement,\n+            Content content) {\n+        content.add(MarkerComments.START_OF_ENUM_CONSTANT_SUMMARY);\n+        Content memberContent = new ContentBuilder();\n+        writer.addSummaryHeader(this, memberContent);\n+        return memberContent;\n+    }\n+\n+    @Override\n+    public void addSummary(Content summariesList, Content content) {\n+        writer.addSummary(HtmlStyle.constantsSummary,\n+                HtmlIds.ENUM_CONSTANT_SUMMARY, summariesList, content);\n+    }\n+\n+    protected Content getEnumConstantsDetailsHeader(TypeElement typeElement,\n+                                                 Content memberDetails) {\n+        memberDetails.add(MarkerComments.START_OF_ENUM_CONSTANT_DETAILS);\n+        var enumConstantsDetailsContent = new ContentBuilder();\n+        var heading = HtmlTree.HEADING(Headings.TypeDeclaration.DETAILS_HEADING,\n+                contents.enumConstantDetailLabel);\n+        enumConstantsDetailsContent.add(heading);\n+        return enumConstantsDetailsContent;\n+    }\n+\n+    protected Content getEnumConstantsHeader(VariableElement enumConstant,\n+                                          Content enumConstantsDetails) {\n+        Content enumConstantsContent = new ContentBuilder();\n+        var heading = HtmlTree.HEADING(Headings.TypeDeclaration.MEMBER_HEADING,\n+                Text.of(name(enumConstant)));\n+        enumConstantsContent.add(heading);\n+        return HtmlTree.SECTION(HtmlStyle.detail, enumConstantsContent)\n+                .setId(htmlIds.forMember(enumConstant));\n+    }\n+\n+    protected Content getSignature(VariableElement enumConstant) {\n+        return new Signatures.MemberSignature(enumConstant, this)\n+                .setType(enumConstant.asType())\n+                .setAnnotations(writer.getAnnotationInfo(enumConstant, true))\n+                .toContent();\n+    }\n+\n+    protected void addDeprecated(VariableElement enumConstant, Content content) {\n+        addDeprecatedInfo(enumConstant, content);\n+    }\n+\n+    protected void addPreview(VariableElement enumConstant, Content content) {\n+        addPreviewInfo(enumConstant, content);\n+    }\n+\n+    protected void addComments(VariableElement enumConstant, Content enumConstants) {\n+        addComment(enumConstant, enumConstants);\n+    }\n+\n+    protected void addTags(VariableElement enumConstant, Content content) {\n+        writer.addTagsInfo(enumConstant, content);\n+    }\n+\n+    protected Content getEnumConstantsDetails(Content memberDetailsHeader,\n+            Content content) {\n+        return writer.getDetailsListItem(\n+                HtmlTree.SECTION(HtmlStyle.constantDetails)\n+                        .setId(HtmlIds.ENUM_CONSTANT_DETAIL)\n+                        .add(memberDetailsHeader)\n+                        .add(content));\n+    }\n+\n+    @Override\n+    public void addSummaryLabel(Content content) {\n+        var label = HtmlTree.HEADING(Headings.TypeDeclaration.SUMMARY_HEADING,\n+                contents.enumConstantSummary);\n+        content.add(label);\n+    }\n+\n+    @Override\n+    public TableHeader getSummaryTableHeader(Element member) {\n+        return new TableHeader(contents.enumConstantLabel, contents.descriptionLabel);\n+    }\n+\n+    @Override\n+    protected Table<Element> createSummaryTable() {\n+        return new Table<Element>(HtmlStyle.summaryTable)\n+                .setCaption(contents.getContent(\"doclet.Enum_Constants\"))\n+                .setHeader(getSummaryTableHeader(typeElement))\n+                .setColumnStyles(HtmlStyle.colFirst, HtmlStyle.colLast);\n+    }\n+\n+    @Override\n+    public void addInheritedSummaryLabel(TypeElement typeElement, Content content) {\n+    }\n+\n+    @Override\n+    protected void addSummaryLink(HtmlLinkInfo.Kind context, TypeElement typeElement, Element member,\n+                                  Content content) {\n+        Content memberLink = writer.getDocLink(context, utils.getEnclosingTypeElement(member), member,\n+                name(member), HtmlStyle.memberNameLink);\n+        var code = HtmlTree.CODE(memberLink);\n+        content.add(code);\n+    }\n+\n+    @Override\n+    protected void addInheritedSummaryLink(TypeElement typeElement, Element member, Content target) {\n+    }\n+\n+    @Override\n+    protected void addSummaryType(Element member, Content content) {\n+        \/\/Not applicable.\n+    }\n+\n+    @Override\n+    protected Content getSummaryLink(Element member) {\n+        String name = utils.getFullyQualifiedName(member) + \".\" + member.getSimpleName();\n+        return writer.getDocLink(HtmlLinkInfo.Kind.SHOW_PREVIEW, member, name);\n+    }\n+\n+    protected Content getMemberHeader(){\n+        return writer.getMemberHeader();\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/EnumConstantWriter.java","additions":258,"deletions":0,"binary":false,"changes":258,"status":"added"},{"patch":"@@ -1,182 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.formats.html;\n-\n-\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.TypeElement;\n-import javax.lang.model.element.VariableElement;\n-\n-import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n-import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.EnumConstantWriter;\n-import jdk.javadoc.internal.doclets.toolkit.MemberSummaryWriter;\n-\n-\/**\n- * Writes enum constant documentation in HTML format.\n- *\/\n-public class EnumConstantWriterImpl extends AbstractMemberWriter\n-    implements EnumConstantWriter, MemberSummaryWriter {\n-\n-    public EnumConstantWriterImpl(SubWriterHolderWriter writer, TypeElement typeElement) {\n-        super(writer, typeElement);\n-    }\n-\n-    public EnumConstantWriterImpl(SubWriterHolderWriter writer) {\n-        super(writer);\n-    }\n-\n-    @Override\n-    public Content getMemberSummaryHeader(TypeElement typeElement,\n-            Content content) {\n-        content.add(MarkerComments.START_OF_ENUM_CONSTANT_SUMMARY);\n-        Content memberContent = new ContentBuilder();\n-        writer.addSummaryHeader(this, memberContent);\n-        return memberContent;\n-    }\n-\n-    @Override\n-    public void addSummary(Content summariesList, Content content) {\n-        writer.addSummary(HtmlStyle.constantsSummary,\n-                HtmlIds.ENUM_CONSTANT_SUMMARY, summariesList, content);\n-    }\n-\n-    @Override\n-    public Content getEnumConstantsDetailsHeader(TypeElement typeElement,\n-                                                 Content memberDetails) {\n-        memberDetails.add(MarkerComments.START_OF_ENUM_CONSTANT_DETAILS);\n-        var enumConstantsDetailsContent = new ContentBuilder();\n-        var heading = HtmlTree.HEADING(Headings.TypeDeclaration.DETAILS_HEADING,\n-                contents.enumConstantDetailLabel);\n-        enumConstantsDetailsContent.add(heading);\n-        return enumConstantsDetailsContent;\n-    }\n-\n-    @Override\n-    public Content getEnumConstantsHeader(VariableElement enumConstant,\n-                                          Content enumConstantsDetails) {\n-        Content enumConstantsContent = new ContentBuilder();\n-        var heading = HtmlTree.HEADING(Headings.TypeDeclaration.MEMBER_HEADING,\n-                Text.of(name(enumConstant)));\n-        enumConstantsContent.add(heading);\n-        return HtmlTree.SECTION(HtmlStyle.detail, enumConstantsContent)\n-                .setId(htmlIds.forMember(enumConstant));\n-    }\n-\n-    @Override\n-    public Content getSignature(VariableElement enumConstant) {\n-        return new Signatures.MemberSignature(enumConstant, this)\n-                .setType(enumConstant.asType())\n-                .setAnnotations(writer.getAnnotationInfo(enumConstant, true))\n-                .toContent();\n-    }\n-\n-    @Override\n-    public void addDeprecated(VariableElement enumConstant, Content content) {\n-        addDeprecatedInfo(enumConstant, content);\n-    }\n-\n-    @Override\n-    public void addPreview(VariableElement enumConstant, Content content) {\n-        addPreviewInfo(enumConstant, content);\n-    }\n-\n-    @Override\n-    public void addComments(VariableElement enumConstant, Content enumConstants) {\n-        addComment(enumConstant, enumConstants);\n-    }\n-\n-    @Override\n-    public void addTags(VariableElement enumConstant, Content content) {\n-        writer.addTagsInfo(enumConstant, content);\n-    }\n-\n-    @Override\n-    public Content getEnumConstantsDetails(Content memberDetailsHeader,\n-            Content content) {\n-        return writer.getDetailsListItem(\n-                HtmlTree.SECTION(HtmlStyle.constantDetails)\n-                        .setId(HtmlIds.ENUM_CONSTANT_DETAIL)\n-                        .add(memberDetailsHeader)\n-                        .add(content));\n-    }\n-\n-    @Override\n-    public void addSummaryLabel(Content content) {\n-        var label = HtmlTree.HEADING(Headings.TypeDeclaration.SUMMARY_HEADING,\n-                contents.enumConstantSummary);\n-        content.add(label);\n-    }\n-\n-    @Override\n-    public TableHeader getSummaryTableHeader(Element member) {\n-        return new TableHeader(contents.enumConstantLabel, contents.descriptionLabel);\n-    }\n-\n-    @Override\n-    protected Table<Element> createSummaryTable() {\n-        return new Table<Element>(HtmlStyle.summaryTable)\n-                .setCaption(contents.getContent(\"doclet.Enum_Constants\"))\n-                .setHeader(getSummaryTableHeader(typeElement))\n-                .setColumnStyles(HtmlStyle.colFirst, HtmlStyle.colLast);\n-    }\n-\n-    @Override\n-    public void addInheritedSummaryLabel(TypeElement typeElement, Content content) {\n-    }\n-\n-    @Override\n-    protected void addSummaryLink(HtmlLinkInfo.Kind context, TypeElement typeElement, Element member,\n-                                  Content content) {\n-        Content memberLink = writer.getDocLink(context, utils.getEnclosingTypeElement(member), member,\n-                name(member), HtmlStyle.memberNameLink);\n-        var code = HtmlTree.CODE(memberLink);\n-        content.add(code);\n-    }\n-\n-    @Override\n-    protected void addInheritedSummaryLink(TypeElement typeElement, Element member, Content target) {\n-    }\n-\n-    @Override\n-    protected void addSummaryType(Element member, Content content) {\n-        \/\/Not applicable.\n-    }\n-\n-    @Override\n-    protected Content getSummaryLink(Element member) {\n-        String name = utils.getFullyQualifiedName(member) + \".\" + member.getSimpleName();\n-        return writer.getDocLink(HtmlLinkInfo.Kind.SHOW_PREVIEW, member, name);\n-    }\n-\n-    @Override\n-    public Content getMemberHeader(){\n-        return writer.getMemberHeader();\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/EnumConstantWriterImpl.java","additions":0,"deletions":182,"binary":false,"changes":182,"status":"deleted"},{"patch":"@@ -56,1 +56,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n@@ -250,25 +249,9 @@\n-        return new Comparator<>() {\n-            @Override\n-            public int compare(String s1, String s2) {\n-                int i1 = 0;\n-                int i2 = 0;\n-                while (i1 < s1.length() && i2 < s2.length()) {\n-                    int j1 = find(s1, i1, Character::isDigit);\n-                    int j2 = find(s2, i2, Character::isDigit);\n-                    int cmp = collator.compare(s1.substring(i1, j1), s2.substring(i2, j2));\n-                    if (cmp != 0) {\n-                        return cmp;\n-                    }\n-                    if (j1 == s1.length() || j2 == s2.length()) {\n-                        i1 = j1;\n-                        i2 = j2;\n-                        break;\n-                    }\n-                    int k1 = find(s1, j1, ch -> !Character.isDigit(ch));\n-                    int k2 = find(s2, j2, ch -> !Character.isDigit(ch));\n-                    cmp = Integer.compare(Integer.parseInt(s1.substring(j1, k1)), Integer.parseInt(s2.substring(j2, k2)));\n-                    if (cmp != 0) {\n-                        return cmp;\n-                    }\n-                    i1 = k1;\n-                    i2 = k2;\n+        return (s1, s2) -> {\n+            int i1 = 0;\n+            int i2 = 0;\n+            while (i1 < s1.length() && i2 < s2.length()) {\n+                int j1 = find(s1, i1, Character::isDigit);\n+                int j2 = find(s2, i2, Character::isDigit);\n+                int cmp = collator.compare(s1.substring(i1, j1), s2.substring(i2, j2));\n+                if (cmp != 0) {\n+                    return cmp;\n@@ -276,1 +259,13 @@\n-                return i1 < s1.length() ? 1 : i2 < s2.length() ? -1 : 0;\n+                if (j1 == s1.length() || j2 == s2.length()) {\n+                    i1 = j1;\n+                    i2 = j2;\n+                    break;\n+                }\n+                int k1 = find(s1, j1, ch -> !Character.isDigit(ch));\n+                int k2 = find(s2, j2, ch -> !Character.isDigit(ch));\n+                cmp = Integer.compare(Integer.parseInt(s1.substring(j1, k1)), Integer.parseInt(s2.substring(j2, k2)));\n+                if (cmp != 0) {\n+                    return cmp;\n+                }\n+                i1 = k1;\n+                i2 = k2;\n@@ -278,0 +273,1 @@\n+            return i1 < s1.length() ? 1 : i2 < s2.length() ? -1 : 0;\n@@ -295,2 +291,1 @@\n-        } else if (element instanceof DocletElement) {\n-            DocletElement e = (DocletElement) element;\n+        } else if (element instanceof DocletElement e) {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/ExternalSpecsWriter.java","additions":24,"deletions":29,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -0,0 +1,290 @@\n+\/*\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+\n+import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n+import jdk.javadoc.internal.doclets.formats.html.markup.Entity;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n+import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n+import jdk.javadoc.internal.doclets.toolkit.BaseOptions;\n+import jdk.javadoc.internal.doclets.toolkit.DocletException;\n+import jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable;\n+\n+\/**\n+ * Writes field documentation in HTML format.\n+ *\/\n+public class FieldWriter extends AbstractMemberWriter {\n+\n+    \/**\n+     * The index of the current field that is being documented at this point\n+     * in time.\n+     *\/\n+    private VariableElement currentElement;\n+\n+    public FieldWriter(ClassWriter writer) {\n+        super(writer, writer.typeElement);\n+    }\n+\n+    public FieldWriter(SubWriterHolderWriter writer, TypeElement typeElement) {\n+        super(writer, typeElement);\n+    }\n+\n+    \/\/ used in ClassUseWriter and SummaryUseWriter\n+    public FieldWriter(SubWriterHolderWriter writer) {\n+        super(writer);\n+    }\n+\n+    public void build(Content target) throws DocletException {\n+        buildFieldDoc(target);\n+    }\n+\n+    \/**\n+     * Build the field documentation.\n+     *\n+     * @param target the content to which the documentation will be added\n+     *\/\n+    protected void buildFieldDoc(Content target) {\n+        var fields = getVisibleMembers(VisibleMemberTable.Kind.FIELDS);\n+        if (!fields.isEmpty()) {\n+            Content fieldDetailsHeader = getFieldDetailsHeader(target);\n+            Content memberList = getMemberList();\n+\n+            for (Element element : fields) {\n+                currentElement = (VariableElement)element;\n+                Content fieldContent = getFieldHeaderContent(currentElement);\n+\n+                buildSignature(fieldContent);\n+                buildDeprecationInfo(fieldContent);\n+                buildPreviewInfo(fieldContent);\n+                buildFieldComments(fieldContent);\n+                buildTagInfo(fieldContent);\n+\n+                memberList.add(getMemberListItem(fieldContent));\n+            }\n+            Content fieldDetails = getFieldDetails(fieldDetailsHeader, memberList);\n+            target.add(fieldDetails);\n+        }\n+    }\n+\n+    \/**\n+     * Build the signature.\n+     *\n+     * @param fieldContent the content to which the documentation will be added\n+     *\/\n+    protected void buildSignature(Content fieldContent) {\n+        fieldContent.add(getSignature(currentElement));\n+    }\n+\n+    \/**\n+     * Build the deprecation information.\n+     *\n+     * @param fieldContent the content to which the documentation will be added\n+     *\/\n+    protected void buildDeprecationInfo(Content fieldContent) {\n+        addDeprecated(currentElement, fieldContent);\n+    }\n+\n+    \/**\n+     * Build the preview information.\n+     *\n+     * @param fieldContent the content to which the documentation will be added\n+     *\/\n+    protected void buildPreviewInfo(Content fieldContent) {\n+        addPreview(currentElement, fieldContent);\n+    }\n+\n+    \/**\n+     * Build the comments for the field.  Do nothing if\n+     * {@link BaseOptions#noComment()} is set to true.\n+     *\n+     * @param fieldContent the content to which the documentation will be added\n+     *\/\n+    protected void buildFieldComments(Content fieldContent) {\n+        if (!options.noComment()) {\n+            addComments(currentElement, fieldContent);\n+        }\n+    }\n+\n+    \/**\n+     * Build the tag information.\n+     *\n+     * @param fieldContent the content to which the documentation will be added\n+     *\/\n+    protected void buildTagInfo(Content fieldContent) {\n+        addTags(currentElement, fieldContent);\n+    }\n+\n+\n+    @Override\n+    public Content getMemberSummaryHeader(TypeElement typeElement,\n+            Content content) {\n+        content.add(MarkerComments.START_OF_FIELD_SUMMARY);\n+        Content memberContent = new ContentBuilder();\n+        writer.addSummaryHeader(this, memberContent);\n+        return memberContent;\n+    }\n+\n+    @Override\n+    public void addSummary(Content summariesList, Content content) {\n+        writer.addSummary(HtmlStyle.fieldSummary,\n+                HtmlIds.FIELD_SUMMARY, summariesList, content);\n+    }\n+\n+    protected Content getFieldDetailsHeader(Content content) {\n+        content.add(MarkerComments.START_OF_FIELD_DETAILS);\n+        Content fieldDetailsContent = new ContentBuilder();\n+        var heading = HtmlTree.HEADING(Headings.TypeDeclaration.DETAILS_HEADING,\n+                contents.fieldDetailsLabel);\n+        fieldDetailsContent.add(heading);\n+        return fieldDetailsContent;\n+    }\n+\n+    protected Content getFieldHeaderContent(VariableElement field) {\n+        Content content = new ContentBuilder();\n+        var heading = HtmlTree.HEADING(Headings.TypeDeclaration.MEMBER_HEADING,\n+                Text.of(name(field)));\n+        content.add(heading);\n+        return HtmlTree.SECTION(HtmlStyle.detail, content)\n+                .setId(htmlIds.forMember(field));\n+    }\n+\n+    protected Content getSignature(VariableElement field) {\n+        return new Signatures.MemberSignature(field, this)\n+                .setType(utils.asInstantiatedFieldType(typeElement, field))\n+                .setAnnotations(writer.getAnnotationInfo(field, true))\n+                .toContent();\n+    }\n+\n+    protected void addDeprecated(VariableElement field, Content fieldContent) {\n+        addDeprecatedInfo(field, fieldContent);\n+    }\n+\n+    protected void addPreview(VariableElement field, Content content) {\n+        addPreviewInfo(field, content);\n+    }\n+\n+    protected void addComments(VariableElement field, Content fieldContent) {\n+        if (!utils.getFullBody(field).isEmpty()) {\n+            writer.addInlineComment(field, fieldContent);\n+        }\n+    }\n+\n+    protected void addTags(VariableElement field, Content fieldContent) {\n+        writer.addTagsInfo(field, fieldContent);\n+    }\n+\n+    protected Content getFieldDetails(Content memberDetailsHeaderContent, Content memberContent) {\n+        return writer.getDetailsListItem(\n+                HtmlTree.SECTION(HtmlStyle.fieldDetails)\n+                        .setId(HtmlIds.FIELD_DETAIL)\n+                        .add(memberDetailsHeaderContent)\n+                        .add(memberContent));\n+    }\n+\n+    @Override\n+    public void addSummaryLabel(Content content) {\n+        var label = HtmlTree.HEADING(Headings.TypeDeclaration.SUMMARY_HEADING,\n+                contents.fieldSummaryLabel);\n+        content.add(label);\n+    }\n+\n+    @Override\n+    public TableHeader getSummaryTableHeader(Element member) {\n+        return new TableHeader(contents.modifierAndTypeLabel, contents.fieldLabel,\n+                contents.descriptionLabel);\n+    }\n+\n+    @Override\n+    protected Table<Element> createSummaryTable() {\n+        List<HtmlStyle> bodyRowStyles = Arrays.asList(HtmlStyle.colFirst, HtmlStyle.colSecond,\n+                HtmlStyle.colLast);\n+\n+        return new Table<Element>(HtmlStyle.summaryTable)\n+                .setCaption(contents.fields)\n+                .setHeader(getSummaryTableHeader(typeElement))\n+                .setColumnStyles(bodyRowStyles);\n+    }\n+\n+    @Override\n+    public void addInheritedSummaryLabel(TypeElement typeElement, Content content) {\n+        Content classLink = writer.getPreQualifiedClassLink(\n+                HtmlLinkInfo.Kind.PLAIN, typeElement);\n+        Content label;\n+        if (options.summarizeOverriddenMethods()) {\n+            label = Text.of(utils.isClass(typeElement)\n+                    ? resources.getText(\"doclet.Fields_Declared_In_Class\")\n+                    : resources.getText(\"doclet.Fields_Declared_In_Interface\"));\n+        } else {\n+            label = Text.of(utils.isClass(typeElement)\n+                    ? resources.getText(\"doclet.Fields_Inherited_From_Class\")\n+                    : resources.getText(\"doclet.Fields_Inherited_From_Interface\"));\n+        }\n+        var labelHeading = HtmlTree.HEADING(Headings.TypeDeclaration.INHERITED_SUMMARY_HEADING,\n+                label);\n+        labelHeading.setId(htmlIds.forInheritedFields(typeElement));\n+        labelHeading.add(Entity.NO_BREAK_SPACE);\n+        labelHeading.add(classLink);\n+        content.add(labelHeading);\n+    }\n+\n+    @Override\n+    protected void addSummaryLink(HtmlLinkInfo.Kind context, TypeElement typeElement, Element member,\n+                                  Content content) {\n+        Content memberLink = writer.getDocLink(context, typeElement , member, name(member),\n+                HtmlStyle.memberNameLink);\n+        var code = HtmlTree.CODE(memberLink);\n+        content.add(code);\n+    }\n+\n+    @Override\n+    protected void addInheritedSummaryLink(TypeElement typeElement, Element member, Content target) {\n+        target.add(\n+                writer.getDocLink(HtmlLinkInfo.Kind.PLAIN, typeElement, member, name(member)));\n+    }\n+\n+    @Override\n+    protected void addSummaryType(Element member, Content content) {\n+        addModifiersAndType(member, utils.asInstantiatedFieldType(typeElement, (VariableElement)member), content);\n+    }\n+\n+    @Override\n+    protected Content getSummaryLink(Element member) {\n+        String name = utils.getFullyQualifiedName(member) + \".\" + member.getSimpleName();\n+        return writer.getDocLink(HtmlLinkInfo.Kind.SHOW_PREVIEW, member, name);\n+    }\n+\n+    protected Content getMemberHeader(){\n+        return writer.getMemberHeader();\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/FieldWriter.java","additions":290,"deletions":0,"binary":false,"changes":290,"status":"added"},{"patch":"@@ -1,208 +0,0 @@\n-\/*\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.formats.html;\n-\n-import java.util.Arrays;\n-import java.util.List;\n-\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.TypeElement;\n-import javax.lang.model.element.VariableElement;\n-\n-import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n-import jdk.javadoc.internal.doclets.formats.html.markup.Entity;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n-import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.FieldWriter;\n-import jdk.javadoc.internal.doclets.toolkit.MemberSummaryWriter;\n-\n-\/**\n- * Writes field documentation in HTML format.\n- *\/\n-public class FieldWriterImpl extends AbstractMemberWriter\n-    implements FieldWriter, MemberSummaryWriter {\n-\n-    public FieldWriterImpl(SubWriterHolderWriter writer, TypeElement typeElement) {\n-        super(writer, typeElement);\n-    }\n-\n-    public FieldWriterImpl(SubWriterHolderWriter writer) {\n-        super(writer);\n-    }\n-\n-    @Override\n-    public Content getMemberSummaryHeader(TypeElement typeElement,\n-            Content content) {\n-        content.add(MarkerComments.START_OF_FIELD_SUMMARY);\n-        Content memberContent = new ContentBuilder();\n-        writer.addSummaryHeader(this, memberContent);\n-        return memberContent;\n-    }\n-\n-    @Override\n-    public void addSummary(Content summariesList, Content content) {\n-        writer.addSummary(HtmlStyle.fieldSummary,\n-                HtmlIds.FIELD_SUMMARY, summariesList, content);\n-    }\n-\n-    @Override\n-    public Content getFieldDetailsHeader(Content content) {\n-        content.add(MarkerComments.START_OF_FIELD_DETAILS);\n-        Content fieldDetailsContent = new ContentBuilder();\n-        var heading = HtmlTree.HEADING(Headings.TypeDeclaration.DETAILS_HEADING,\n-                contents.fieldDetailsLabel);\n-        fieldDetailsContent.add(heading);\n-        return fieldDetailsContent;\n-    }\n-\n-    @Override\n-    public Content getFieldHeaderContent(VariableElement field) {\n-        Content content = new ContentBuilder();\n-        var heading = HtmlTree.HEADING(Headings.TypeDeclaration.MEMBER_HEADING,\n-                Text.of(name(field)));\n-        content.add(heading);\n-        return HtmlTree.SECTION(HtmlStyle.detail, content)\n-                .setId(htmlIds.forMember(field));\n-    }\n-\n-    @Override\n-    public Content getSignature(VariableElement field) {\n-        return new Signatures.MemberSignature(field, this)\n-                .setType(utils.asInstantiatedFieldType(typeElement, field))\n-                .setAnnotations(writer.getAnnotationInfo(field, true))\n-                .toContent();\n-    }\n-\n-    @Override\n-    public void addDeprecated(VariableElement field, Content fieldContent) {\n-        addDeprecatedInfo(field, fieldContent);\n-    }\n-\n-    @Override\n-    public void addPreview(VariableElement field, Content content) {\n-        addPreviewInfo(field, content);\n-    }\n-\n-    @Override\n-    public void addComments(VariableElement field, Content fieldContent) {\n-        if (!utils.getFullBody(field).isEmpty()) {\n-            writer.addInlineComment(field, fieldContent);\n-        }\n-    }\n-\n-    @Override\n-    public void addTags(VariableElement field, Content fieldContent) {\n-        writer.addTagsInfo(field, fieldContent);\n-    }\n-\n-    @Override\n-    public Content getFieldDetails(Content memberDetailsHeaderContent, Content memberContent) {\n-        return writer.getDetailsListItem(\n-                HtmlTree.SECTION(HtmlStyle.fieldDetails)\n-                        .setId(HtmlIds.FIELD_DETAIL)\n-                        .add(memberDetailsHeaderContent)\n-                        .add(memberContent));\n-    }\n-\n-    @Override\n-    public void addSummaryLabel(Content content) {\n-        var label = HtmlTree.HEADING(Headings.TypeDeclaration.SUMMARY_HEADING,\n-                contents.fieldSummaryLabel);\n-        content.add(label);\n-    }\n-\n-    @Override\n-    public TableHeader getSummaryTableHeader(Element member) {\n-        return new TableHeader(contents.modifierAndTypeLabel, contents.fieldLabel,\n-                contents.descriptionLabel);\n-    }\n-\n-    @Override\n-    protected Table<Element> createSummaryTable() {\n-        List<HtmlStyle> bodyRowStyles = Arrays.asList(HtmlStyle.colFirst, HtmlStyle.colSecond,\n-                HtmlStyle.colLast);\n-\n-        return new Table<Element>(HtmlStyle.summaryTable)\n-                .setCaption(contents.fields)\n-                .setHeader(getSummaryTableHeader(typeElement))\n-                .setColumnStyles(bodyRowStyles);\n-    }\n-\n-    @Override\n-    public void addInheritedSummaryLabel(TypeElement typeElement, Content content) {\n-        Content classLink = writer.getPreQualifiedClassLink(\n-                HtmlLinkInfo.Kind.PLAIN, typeElement);\n-        Content label;\n-        if (options.summarizeOverriddenMethods()) {\n-            label = Text.of(utils.isClass(typeElement)\n-                    ? resources.getText(\"doclet.Fields_Declared_In_Class\")\n-                    : resources.getText(\"doclet.Fields_Declared_In_Interface\"));\n-        } else {\n-            label = Text.of(utils.isClass(typeElement)\n-                    ? resources.getText(\"doclet.Fields_Inherited_From_Class\")\n-                    : resources.getText(\"doclet.Fields_Inherited_From_Interface\"));\n-        }\n-        var labelHeading = HtmlTree.HEADING(Headings.TypeDeclaration.INHERITED_SUMMARY_HEADING,\n-                label);\n-        labelHeading.setId(htmlIds.forInheritedFields(typeElement));\n-        labelHeading.add(Entity.NO_BREAK_SPACE);\n-        labelHeading.add(classLink);\n-        content.add(labelHeading);\n-    }\n-\n-    @Override\n-    protected void addSummaryLink(HtmlLinkInfo.Kind context, TypeElement typeElement, Element member,\n-                                  Content content) {\n-        Content memberLink = writer.getDocLink(context, typeElement , member, name(member),\n-                HtmlStyle.memberNameLink);\n-        var code = HtmlTree.CODE(memberLink);\n-        content.add(code);\n-    }\n-\n-    @Override\n-    protected void addInheritedSummaryLink(TypeElement typeElement, Element member, Content target) {\n-        target.add(\n-                writer.getDocLink(HtmlLinkInfo.Kind.PLAIN, typeElement, member, name(member)));\n-    }\n-\n-    @Override\n-    protected void addSummaryType(Element member, Content content) {\n-        addModifiersAndType(member, utils.asInstantiatedFieldType(typeElement, (VariableElement)member), content);\n-    }\n-\n-    @Override\n-    protected Content getSummaryLink(Element member) {\n-        String name = utils.getFullyQualifiedName(member) + \".\" + member.getSimpleName();\n-        return writer.getDocLink(HtmlLinkInfo.Kind.SHOW_PREVIEW, member, name);\n-    }\n-\n-    @Override\n-    public Content getMemberHeader(){\n-        return writer.getMemberHeader();\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/FieldWriterImpl.java","additions":0,"deletions":208,"binary":false,"changes":208,"status":"deleted"},{"patch":"@@ -39,1 +39,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HelpWriter.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import java.util.HashSet;\n@@ -64,1 +65,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.WriterFactory;\n@@ -186,0 +186,5 @@\n+    \/**\n+     * The set of packages for which we have copied the doc files.\n+     *\/\n+    private Set<PackageElement> containingPackagesSeen;\n+\n@@ -223,0 +228,1 @@\n+        containingPackagesSeen = new HashSet<>();\n@@ -274,0 +280,9 @@\n+    \/**\n+     * {@return the packages for which we have copied the doc files}\n+     *\n+     * @see {@link ClassWriter#copyDocFiles()}\n+     *\/\n+    public Set<PackageElement> getContainingPackagesSeen() {\n+        return containingPackagesSeen;\n+    }\n+\n@@ -368,1 +383,0 @@\n-    @Override\n@@ -370,1 +384,2 @@\n-        return new WriterFactoryImpl(this);\n+        \/\/ TODO: this is called many times: why not create and use a single instance?\n+        return new WriterFactory(this);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlConfiguration.java","additions":18,"deletions":3,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -54,2 +54,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.builders.AbstractBuilder;\n-import jdk.javadoc.internal.doclets.toolkit.builders.BuilderFactory;\n@@ -216,1 +214,5 @@\n-        HtmlOptions options = configuration.getOptions();\n+\n+        new ConstantsSummaryWriter(configuration).build();\n+        new SerializedFormWriter(configuration).build();\n+\n+        var options = configuration.getOptions();\n@@ -326,1 +328,1 @@\n-        if (configuration.tagletManager != null) { \/\/ may be null, if no files generated, perhaps because of errros\n+        if (configuration.tagletManager != null) { \/\/ may be null, if no files generated, perhaps because of errors\n@@ -391,1 +393,0 @@\n-        BuilderFactory f = configuration.getBuilderFactory();\n@@ -397,1 +398,1 @@\n-            f.getClassBuilder(te, classTree).build();\n+            new ClassWriter(configuration, te, classTree).build();\n@@ -406,3 +407,1 @@\n-                AbstractBuilder moduleSummaryBuilder =\n-                        configuration.getBuilderFactory().getModuleSummaryBuilder(mdle);\n-                moduleSummaryBuilder.build();\n+                new ModuleWriter(configuration, mdle).build();\n@@ -423,3 +422,1 @@\n-                AbstractBuilder packageSummaryBuilder =\n-                        configuration.getBuilderFactory().getPackageSummaryBuilder(pkg);\n-                packageSummaryBuilder.build();\n+                new PackageWriter(configuration, pkg).build();\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlDoclet.java","additions":9,"deletions":12,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -95,1 +95,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n@@ -202,0 +201,10 @@\n+        this(configuration, path, true);\n+    }\n+    \/**\n+     * Creates an {@code HtmlDocletWriter}.\n+     *\n+     * @param configuration the configuration for this doclet\n+     * @param path the file to be generated.\n+     * @param generating whether to write a \"Geneterating ...\" message to the console\n+     *\/\n+    public HtmlDocletWriter(HtmlConfiguration configuration, DocPath path, boolean generating) {\n@@ -217,0 +226,9 @@\n+        if (generating) {\n+            writeGenerating();\n+        }\n+    }\n+\n+    \/**\n+     * Writes a \"Generating _file_\" message to the console\n+     *\/\n+    protected final void writeGenerating() {\n@@ -218,1 +236,1 @@\n-            DocFile.createFileForOutput(configuration, path).getPath());\n+                DocFile.createFileForOutput(configuration, path).getPath());\n@@ -303,1 +321,1 @@\n-            MethodWriterImpl.addImplementsInfo(this, method, implementedMethods, dl);\n+            MethodWriter.addImplementsInfo(this, method, implementedMethods, dl);\n@@ -306,1 +324,1 @@\n-            MethodWriterImpl.addOverridden(this,\n+            MethodWriter.addOverridden(this,\n@@ -1479,1 +1497,1 @@\n-            if (this instanceof PackageWriterImpl packageWriter) {\n+            if (this instanceof PackageWriter packageWriter) {\n@@ -1481,1 +1499,1 @@\n-            } else if (this instanceof ModuleWriterImpl moduleWriter) {\n+            } else if (this instanceof ModuleWriter moduleWriter) {\n@@ -1514,1 +1532,1 @@\n-        Element currentPageElement = (this instanceof PackageWriterImpl packageWriter)\n+        Element currentPageElement = (this instanceof PackageWriter packageWriter)\n@@ -2021,2 +2039,1 @@\n-            DocFilesHandlerImpl docFilesHandler = (DocFilesHandlerImpl)configuration\n-                    .getWriterFactory().getDocFilesHandler(element);\n+            DocFilesHandler docFilesHandler = configuration.getWriterFactory().getDocFilesHandler(element);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlDocletWriter.java","additions":26,"deletions":9,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlLinkFactory.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n@@ -80,1 +79,1 @@\n-        LINK_TYPE_PARAMS_AND_BOUNDS;\n+        LINK_TYPE_PARAMS_AND_BOUNDS\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlLinkInfo.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,180 +0,0 @@\n-\/*\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.formats.html;\n-\n-import java.util.List;\n-import java.util.SortedSet;\n-\n-import javax.lang.model.element.TypeElement;\n-import javax.lang.model.element.VariableElement;\n-import javax.lang.model.type.TypeMirror;\n-\n-import com.sun.source.doctree.DocTree;\n-import com.sun.source.doctree.SerialFieldTree;\n-import com.sun.source.doctree.SerialTree;\n-\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n-import jdk.javadoc.internal.doclets.formats.html.markup.TagName;\n-import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n-import jdk.javadoc.internal.doclets.formats.html.taglets.TagletWriter;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.SerializedFormWriter;\n-\n-\/**\n- * Generate serialized form for serializable fields.\n- * Documentation denoted by the tags <code>serial<\/code> and\n- * <code>serialField<\/code> is processed.\n- *\/\n-public class HtmlSerialFieldWriter extends FieldWriterImpl\n-        implements SerializedFormWriter.SerialFieldWriter {\n-\n-    public HtmlSerialFieldWriter(SubWriterHolderWriter writer, TypeElement typeElement) {\n-        super(writer, typeElement);\n-    }\n-\n-    public SortedSet<VariableElement> members(TypeElement te) {\n-        return utils.serializableFields(te);\n-    }\n-\n-    @Override\n-    public Content getSerializableFieldsHeader() {\n-        return HtmlTree.UL(HtmlStyle.blockList);\n-    }\n-\n-    @Override\n-    public Content getFieldsContentHeader(boolean isLastContent) {\n-        return new HtmlTree(TagName.LI).setStyle(HtmlStyle.blockList);\n-    }\n-\n-    @Override\n-    public Content getSerializableFields(String heading, Content source) {\n-        var section = HtmlTree.SECTION(HtmlStyle.detail);\n-        if (!source.isEmpty()) {\n-            Content headingContent = Text.of(heading);\n-            var serialHeading = HtmlTree.HEADING(Headings.SerializedForm.CLASS_SUBHEADING, headingContent);\n-            section.add(serialHeading);\n-            section.add(source);\n-        }\n-        return HtmlTree.LI(section);\n-    }\n-\n-    @Override\n-    public void addMemberHeader(TypeMirror fieldType, String fieldName, Content content) {\n-        Content nameContent = Text.of(fieldName);\n-        var heading = HtmlTree.HEADING(Headings.SerializedForm.MEMBER_HEADING, nameContent);\n-        content.add(heading);\n-        var pre = new HtmlTree(TagName.PRE);\n-        Content fieldContent = writer.getLink(new HtmlLinkInfo(\n-                configuration, HtmlLinkInfo.Kind.LINK_TYPE_PARAMS_AND_BOUNDS, fieldType));\n-        pre.add(fieldContent);\n-        pre.add(\" \");\n-        pre.add(fieldName);\n-        content.add(pre);\n-    }\n-\n-    \/**\n-     * Add the deprecated information for this member.\n-     *\n-     * @param field the field to document.\n-     * @param content the content to which the deprecated info will be added\n-     *\/\n-    @Override\n-    public void addMemberDeprecatedInfo(VariableElement field, Content content) {\n-        addDeprecatedInfo(field, content);\n-    }\n-\n-    \/**\n-     * Add the description text for this member.\n-     *\n-     * @param field the field to document.\n-     * @param content the content to which the deprecated info will be added\n-     *\/\n-    @Override\n-    public void addMemberDescription(VariableElement field, Content content) {\n-        if (!utils.getFullBody(field).isEmpty()) {\n-            writer.addInlineComment(field, content);\n-        }\n-        List<? extends SerialTree> tags = utils.getSerialTrees(field);\n-        if (!tags.isEmpty() && !tags.get(0).getDescription().isEmpty()) {\n-            writer.addInlineComment(field, tags.get(0), content);\n-        }\n-    }\n-\n-    \/**\n-     * Add the description text for this member represented by the tag.\n-     *\n-     * @param serialFieldTag the field to document (represented by tag)\n-     * @param content the content to which the deprecated info will be added\n-     *\/\n-    @Override\n-    public void addMemberDescription(VariableElement field, SerialFieldTree serialFieldTag, Content content) {\n-        List<? extends DocTree> description = serialFieldTag.getDescription();\n-        if (!description.isEmpty()) {\n-            Content serialFieldContent = writer.commentTagsToContent(field,\n-                    description,\n-                    new TagletWriter.Context(false, false));\n-            var div = HtmlTree.DIV(HtmlStyle.block, serialFieldContent);\n-            content.add(div);\n-        }\n-    }\n-\n-    \/**\n-     * Add the tag information for this member.\n-     *\n-     * @param field the field to document.\n-     * @param content the content to which the member tags info will be added\n-     *\/\n-    @Override\n-    public void addMemberTags(VariableElement field, Content content) {\n-        Content tagContent = writer.getBlockTagOutput(field);\n-        if (!tagContent.isEmpty()) {\n-            var dl = HtmlTree.DL(HtmlStyle.notes);\n-            dl.add(tagContent);\n-            content.add(dl);\n-        }\n-    }\n-\n-    \/**\n-     * Check to see if overview details should be printed. If\n-     * nocomment option set or if there is no text to be printed\n-     * for deprecation info, comment or tags, do not print overview details.\n-     *\n-     * @param field the field to check overview details for.\n-     * @return true if overview details need to be printed\n-     *\/\n-    @Override\n-    public boolean shouldPrintOverview(VariableElement field) {\n-        if (!options.noComment()) {\n-            if(!utils.getFullBody(field).isEmpty() ||\n-                    writer.hasSerializationOverviewTags(field))\n-                return true;\n-        }\n-        if (utils.isDeprecated(field))\n-            return true;\n-        return false;\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlSerialFieldWriter.java","additions":0,"deletions":180,"binary":false,"changes":180,"status":"deleted"},{"patch":"@@ -1,144 +0,0 @@\n-\/*\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.formats.html;\n-\n-import javax.lang.model.element.ExecutableElement;\n-import javax.lang.model.element.TypeElement;\n-\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;\n-import jdk.javadoc.internal.doclets.formats.html.markup.TagName;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n-import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.SerializedFormWriter;\n-import jdk.javadoc.internal.doclets.formats.html.taglets.TagletManager;\n-\n-\n-\/**\n- * Generate serialized form for Serializable\/Externalizable methods.\n- * Documentation denoted by the <code>serialData<\/code> tag is processed.\n- *\/\n-public class HtmlSerialMethodWriter extends MethodWriterImpl implements\n-        SerializedFormWriter.SerialMethodWriter {\n-\n-    public HtmlSerialMethodWriter(SubWriterHolderWriter writer, TypeElement  typeElement) {\n-        super(writer, typeElement);\n-    }\n-\n-    @Override\n-    public Content getSerializableMethodsHeader() {\n-        return HtmlTree.UL(HtmlStyle.blockList);\n-    }\n-\n-    @Override\n-    public Content getMethodsContentHeader(boolean isLastContent) {\n-        return new HtmlTree(TagName.LI);\n-    }\n-\n-    \/**\n-     * Add serializable methods.\n-     *\n-     * @param heading the heading for the section\n-     * @param source the content to be added to the serializable methods\n-     *        content\n-     * @return a content for the serializable methods content\n-     *\/\n-    @Override\n-    public Content getSerializableMethods(String heading, Content source) {\n-        Content headingContent = Text.of(heading);\n-        var serialHeading = HtmlTree.HEADING(Headings.SerializedForm.CLASS_SUBHEADING, headingContent);\n-        var section = HtmlTree.SECTION(HtmlStyle.detail, serialHeading);\n-        section.add(source);\n-        return HtmlTree.LI(section);\n-    }\n-\n-    \/**\n-     * Return the no customization message.\n-     *\n-     * @param msg the message to be displayed\n-     * @return no customization message content\n-     *\/\n-    @Override\n-    public Content getNoCustomizationMsg(String msg) {\n-        return Text.of(msg);\n-    }\n-\n-    \/**\n-     * Add the member header.\n-     *\n-     * @param member the method document to be listed\n-     * @param methodsContent the content to which the member header will be added\n-     *\/\n-    @Override\n-    public void addMemberHeader(ExecutableElement member, Content methodsContent) {\n-        Content memberContent = Text.of(name(member));\n-        var heading = HtmlTree.HEADING(Headings.SerializedForm.MEMBER_HEADING, memberContent);\n-        methodsContent.add(heading);\n-        methodsContent.add(getSignature(member));\n-    }\n-\n-    \/**\n-     * Add the deprecated information for this member.\n-     *\n-     * @param member the method to document.\n-     * @param methodsContent the content to which the deprecated info will be added\n-     *\/\n-    @Override\n-    public void addDeprecatedMemberInfo(ExecutableElement member, Content methodsContent) {\n-        addDeprecatedInfo(member, methodsContent);\n-    }\n-\n-    \/**\n-     * Add the description text for this member.\n-     *\n-     * @param member the method to document.\n-     * @param methodsContent the content to which the deprecated info will be added\n-     *\/\n-    @Override\n-    public void addMemberDescription(ExecutableElement member, Content methodsContent) {\n-        addComment(member, methodsContent);\n-    }\n-\n-    \/**\n-     * Add the tag information for this member.\n-     *\n-     * @param member the method to document.\n-     * @param methodsContent the content to which the member tags info will be added\n-     *\/\n-    @Override\n-    public void addMemberTags(ExecutableElement member, Content methodsContent) {\n-        TagletManager tagletManager = configuration.tagletManager;\n-        Content tagContent = writer.getBlockTagOutput(member, tagletManager.getSerializedFormTaglets());\n-        var dl = HtmlTree.DL(HtmlStyle.notes);\n-        dl.add(tagContent);\n-        methodsContent.add(dl);\n-        if (name(member).equals(\"writeExternal\")\n-                && utils.getSerialDataTrees(member).isEmpty()) {\n-            serialWarning(member, \"doclet.MissingSerialDataTag\",\n-                utils.getFullyQualifiedName(member.getEnclosingElement()), name(member));\n-        }\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlSerialMethodWriter.java","additions":0,"deletions":144,"binary":false,"changes":144,"status":"deleted"},{"patch":"@@ -39,1 +39,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/IndexRedirectWriter.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/IndexWriter.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,441 @@\n+\/*\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html;\n+\n+import java.util.Collection;\n+import java.util.Optional;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeMirror;\n+\n+import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n+import jdk.javadoc.internal.doclets.formats.html.markup.Entity;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlId;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n+import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n+import jdk.javadoc.internal.doclets.toolkit.BaseOptions;\n+import jdk.javadoc.internal.doclets.toolkit.DocletException;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocFinder;\n+import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n+import jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable;\n+\n+\/**\n+ * Writes method documentation in HTML format.\n+ *\/\n+public class MethodWriter extends AbstractExecutableMemberWriter {\n+\n+    \/**\n+     * The index of the current field that is being documented at this point\n+     * in time.\n+     *\/\n+    private ExecutableElement currentMethod;\n+\n+    \/**\n+     * Construct a new MethodWriterImpl.\n+     *\n+     * @param writer the writer for the class that the methods belong to.\\\n+     *\/\n+    public MethodWriter(ClassWriter writer) {\n+        super(writer, writer.typeElement);\n+    }\n+\n+    \/**\n+     * Construct a new MethodWriterImpl.\n+     *\n+     * @param writer the writer for the class that the methods belong to.\n+     * @param typeElement the class\n+     *\/\n+    public MethodWriter(SubWriterHolderWriter writer, TypeElement typeElement) {\n+        super(writer, typeElement);\n+    }\n+\n+    \/**\n+     * Construct a new MethodWriterImpl.\n+     *\n+     * @param writer The writer for the class that the methods belong to.\n+     *\/\n+    \/\/ used in ClassUseWriter and SummaryUseWriter\n+    public MethodWriter(SubWriterHolderWriter writer) {\n+        super(writer);\n+    }\n+\n+    public void build(Content target) throws DocletException {\n+        buildMethodDoc(target);\n+    }\n+\n+    \/**\n+     * Build the method documentation.\n+     *\n+     * @param detailsList the content to which the documentation will be added\n+     *\/\n+    protected void buildMethodDoc(Content detailsList) {\n+        var methods = getVisibleMembers(VisibleMemberTable.Kind.METHODS);\n+        if (!methods.isEmpty()) {\n+            Content methodDetailsHeader = getMethodDetailsHeader(detailsList);\n+            Content memberList = writer.getMemberList();\n+\n+            for (Element method : methods) {\n+                currentMethod = (ExecutableElement)method;\n+                Content methodContent = getMethodHeader(currentMethod);\n+\n+                buildSignature(methodContent);\n+                buildDeprecationInfo(methodContent);\n+                buildPreviewInfo(methodContent);\n+                buildMethodComments(methodContent);\n+                buildTagInfo(methodContent);\n+\n+                memberList.add(writer.getMemberListItem(methodContent));\n+            }\n+            Content methodDetails = getMethodDetails(methodDetailsHeader, memberList);\n+            detailsList.add(methodDetails);\n+        }\n+    }\n+\n+    \/**\n+     * Build the signature.\n+     *\n+     * @param methodContent the content to which the documentation will be added\n+     *\/\n+    protected void buildSignature(Content methodContent) {\n+        methodContent.add(getSignature(currentMethod));\n+    }\n+\n+    \/**\n+     * Build the deprecation information.\n+     *\n+     * @param methodContent the content to which the documentation will be added\n+     *\/\n+    protected void buildDeprecationInfo(Content methodContent) {\n+        addDeprecated(currentMethod, methodContent);\n+    }\n+\n+    \/**\n+     * Build the preview information.\n+     *\n+     * @param methodContent the content to which the documentation will be added\n+     *\/\n+    protected void buildPreviewInfo(Content methodContent) {\n+        addPreview(currentMethod, methodContent);\n+    }\n+\n+    \/**\n+     * Build the comments for the method.  Do nothing if\n+     * {@link BaseOptions#noComment()} is set to true.\n+     *\n+     * @param methodContent the content to which the documentation will be added\n+     *\/\n+    protected void buildMethodComments(Content methodContent) {\n+        if (!options.noComment()) {\n+            assert utils.isMethod(currentMethod); \/\/ not all executables are methods\n+            var docFinder = utils.docFinder();\n+            Optional<ExecutableElement> r = docFinder.search(currentMethod,\n+                    m -> DocFinder.Result.fromOptional(utils.getFullBody(m).isEmpty() ? Optional.empty() : Optional.of(m))).toOptional();\n+            ExecutableElement method = r.orElse(currentMethod);\n+            TypeMirror containingType = method.getEnclosingElement().asType();\n+            addComments(containingType, method, methodContent);\n+        }\n+    }\n+\n+    \/**\n+     * Build the tag information.\n+     *\n+     * @param methodContent the content to which the documentation will be added\n+     *\/\n+    protected void buildTagInfo(Content methodContent) {\n+        addTags(currentMethod, methodContent);\n+    }\n+\n+    @Override\n+    public Content getMemberSummaryHeader(TypeElement typeElement, Content target) {\n+        target.add(MarkerComments.START_OF_METHOD_SUMMARY);\n+        Content memberContent = new ContentBuilder();\n+        writer.addSummaryHeader(this, memberContent);\n+        return memberContent;\n+    }\n+\n+    @Override\n+    public void addSummary(Content summariesList, Content content) {\n+        writer.addSummary(HtmlStyle.methodSummary,\n+                HtmlIds.METHOD_SUMMARY, summariesList, content);\n+    }\n+\n+    protected Content getMethodDetailsHeader(Content content) {\n+        content.add(MarkerComments.START_OF_METHOD_DETAILS);\n+        Content methodDetailsContent = new ContentBuilder();\n+        var heading = HtmlTree.HEADING(Headings.TypeDeclaration.DETAILS_HEADING,\n+                contents.methodDetailLabel);\n+        methodDetailsContent.add(heading);\n+        return methodDetailsContent;\n+    }\n+\n+    protected Content getMethodHeader(ExecutableElement method) {\n+        Content content = new ContentBuilder();\n+        var heading = HtmlTree.HEADING(Headings.TypeDeclaration.MEMBER_HEADING,\n+                Text.of(name(method)));\n+        HtmlId erasureAnchor;\n+        if ((erasureAnchor = htmlIds.forErasure(method)) != null) {\n+            heading.setId(erasureAnchor);\n+        }\n+        content.add(heading);\n+        return HtmlTree.SECTION(HtmlStyle.detail, content)\n+                .setId(htmlIds.forMember(method));\n+    }\n+\n+    protected Content getSignature(ExecutableElement method) {\n+        return new Signatures.MemberSignature(method, this)\n+                .setTypeParameters(getTypeParameters(method))\n+                .setReturnType(getReturnType(method))\n+                .setParameters(getParameters(method, true))\n+                .setExceptions(getExceptions(method))\n+                .setAnnotations(writer.getAnnotationInfo(method, true))\n+                .toContent();\n+    }\n+\n+    protected void addDeprecated(ExecutableElement method, Content methodContent) {\n+        addDeprecatedInfo(method, methodContent);\n+    }\n+\n+    protected void addPreview(ExecutableElement method, Content content) {\n+        addPreviewInfo(method, content);\n+    }\n+\n+    protected void addComments(TypeMirror holderType, ExecutableElement method, Content methodContent) {\n+        TypeElement holder = utils.asTypeElement(holderType);\n+        if (!utils.getFullBody(method).isEmpty()) {\n+            if (holder.equals(typeElement) ||\n+                    !(utils.isPublic(holder) ||\n+                    utils.isLinkable(holder))) {\n+                writer.addInlineComment(method, methodContent);\n+            } else {\n+                if (!utils.hasHiddenTag(holder) && !utils.hasHiddenTag(method)) {\n+                    Content link =\n+                            writer.getDocLink(HtmlLinkInfo.Kind.PLAIN,\n+                                    holder, method,\n+                                    utils.isIncluded(holder)\n+                                            ? utils.getSimpleName(holder)\n+                                            : utils.getFullyQualifiedName(holder));\n+                    var codeLink = HtmlTree.CODE(link);\n+                    var descriptionFromTypeLabel = HtmlTree.SPAN(HtmlStyle.descriptionFromTypeLabel,\n+                            utils.isClass(holder)\n+                                    ? contents.descriptionFromClassLabel\n+                                    : contents.descriptionFromInterfaceLabel);\n+                    descriptionFromTypeLabel.add(Entity.NO_BREAK_SPACE);\n+                    descriptionFromTypeLabel.add(codeLink);\n+                    methodContent.add(HtmlTree.DIV(HtmlStyle.block, descriptionFromTypeLabel));\n+                }\n+                writer.addInlineComment(method, methodContent);\n+            }\n+        }\n+    }\n+\n+    protected void addTags(ExecutableElement method, Content methodContent) {\n+        writer.addTagsInfo(method, methodContent);\n+    }\n+\n+    protected Content getMethodDetails(Content methodDetailsHeader, Content methodDetails) {\n+        Content c = new ContentBuilder(methodDetailsHeader, methodDetails);\n+        return getMember(HtmlTree.SECTION(HtmlStyle.methodDetails, c)\n+                .setId(HtmlIds.METHOD_DETAIL));\n+    }\n+\n+    @Override\n+    public void addSummaryLabel(Content content) {\n+        var label = HtmlTree.HEADING(Headings.TypeDeclaration.SUMMARY_HEADING,\n+                contents.methodSummary);\n+        content.add(label);\n+    }\n+\n+    @Override\n+    public TableHeader getSummaryTableHeader(Element member) {\n+        return new TableHeader(contents.modifierAndTypeLabel, contents.methodLabel,\n+                contents.descriptionLabel);\n+    }\n+\n+    @Override\n+    protected Table<Element> createSummaryTable() {\n+        return new Table<Element>(HtmlStyle.summaryTable)\n+                .setHeader(getSummaryTableHeader(typeElement))\n+                .setColumnStyles(HtmlStyle.colFirst, HtmlStyle.colSecond, HtmlStyle.colLast)\n+                .setId(HtmlIds.METHOD_SUMMARY_TABLE)\n+                .setDefaultTab(contents.getContent(\"doclet.All_Methods\"))\n+                .addTab(contents.getContent(\"doclet.Static_Methods\"), utils::isStatic)\n+                .addTab(contents.getContent(\"doclet.Instance_Methods\"), e -> !utils.isStatic(e))\n+                .addTab(contents.getContent(\"doclet.Abstract_Methods\"), utils::isAbstract)\n+                .addTab(contents.getContent(\"doclet.Concrete_Methods\"),\n+                        e -> !utils.isAbstract(e) && !utils.isPlainInterface(e.getEnclosingElement()))\n+                .addTab(contents.getContent(\"doclet.Default_Methods\"), utils::isDefault)\n+                .addTab(contents.getContent(\"doclet.Deprecated_Methods\"),\n+                        e -> utils.isDeprecated(e) || utils.isDeprecated(typeElement));\n+    }\n+\n+    @Override\n+    public void addInheritedSummaryLabel(TypeElement typeElement, Content content) {\n+        Content classLink = writer.getPreQualifiedClassLink(\n+                HtmlLinkInfo.Kind.PLAIN, typeElement);\n+        Content label;\n+        if (options.summarizeOverriddenMethods()) {\n+            label = Text.of(utils.isClass(typeElement)\n+                    ? resources.getText(\"doclet.Methods_Declared_In_Class\")\n+                    : resources.getText(\"doclet.Methods_Declared_In_Interface\"));\n+        } else {\n+            label = Text.of(utils.isClass(typeElement)\n+                    ? resources.getText(\"doclet.Methods_Inherited_From_Class\")\n+                    : resources.getText(\"doclet.Methods_Inherited_From_Interface\"));\n+        }\n+        var labelHeading = HtmlTree.HEADING(Headings.TypeDeclaration.INHERITED_SUMMARY_HEADING,\n+                label);\n+        labelHeading.setId(htmlIds.forInheritedMethods(typeElement));\n+        labelHeading.add(Entity.NO_BREAK_SPACE);\n+        labelHeading.add(classLink);\n+        content.add(labelHeading);\n+    }\n+\n+    @Override\n+    protected void addSummaryType(Element member, Content content) {\n+        ExecutableElement meth = (ExecutableElement)member;\n+        addModifiersAndType(meth, utils.getReturnType(typeElement, meth), content);\n+    }\n+\n+    \/**\n+     * Adds \"overrides\" or \"specified by\" information about a method (if appropriate)\n+     * into a definition list.\n+     *\n+     * @param writer         the writer for the element\n+     * @param overriddenType the superclass\n+     * @param method         the method\n+     * @param dl             the list in which to add the information.\n+     *\/\n+    protected static void addOverridden(HtmlDocletWriter writer,\n+                                        TypeMirror overriddenType,\n+                                        ExecutableElement method,\n+                                        Content dl) {\n+        if (writer.options.noComment()) {\n+            return;\n+        }\n+        Utils utils = writer.utils;\n+        TypeElement holder = utils.getEnclosingTypeElement(method);\n+        if (!(utils.isPublic(holder) || utils.isLinkable(holder))) {\n+            \/\/This is an implementation detail that should not be documented.\n+            return;\n+        }\n+        if (utils.isIncluded(holder) && !utils.isIncluded(method)) {\n+            \/\/The class is included but the method is not.  That means that it\n+            \/\/is not visible so don't document this.\n+            return;\n+        }\n+        if (utils.hasHiddenTag(holder) || utils.hasHiddenTag(method)) {\n+            return;\n+        }\n+\n+        Contents contents = writer.contents;\n+        Content label;\n+        HtmlLinkInfo.Kind context;\n+        \/\/ Abstract method is implemented from abstract class, not overridden\n+        label = utils.isAbstract(holder) && utils.isAbstract(method) ? contents.specifiedByLabel : contents.overridesLabel;\n+        context = HtmlLinkInfo.Kind.LINK_TYPE_PARAMS_AND_BOUNDS;\n+        dl.add(HtmlTree.DT(label));\n+        Content overriddenTypeLink =\n+                writer.getLink(new HtmlLinkInfo(writer.configuration, context, overriddenType));\n+        var codeOverriddenTypeLink = HtmlTree.CODE(overriddenTypeLink);\n+        Content methlink = writer.getLink(\n+                new HtmlLinkInfo(writer.configuration, HtmlLinkInfo.Kind.PLAIN, holder)\n+                        .fragment(writer.htmlIds.forMember(method).name())\n+                        .label(method.getSimpleName()));\n+        var codeMethLink = HtmlTree.CODE(methlink);\n+        var dd = HtmlTree.DD(codeMethLink);\n+        dd.add(Entity.NO_BREAK_SPACE);\n+        dd.add(contents.inClass);\n+        dd.add(Entity.NO_BREAK_SPACE);\n+        dd.add(codeOverriddenTypeLink);\n+        dl.add(dd);\n+    }\n+\n+    \/**\n+     * Adds \"implements\" information for a method (if appropriate)\n+     * into a definition list.\n+     *\n+     * @param writer  the writer for the method\n+     * @param method  the method\n+     * @param methods implemented methods\n+     * @param dl      the definition list\n+     *\/\n+    protected static void addImplementsInfo(HtmlDocletWriter writer,\n+                                            ExecutableElement method,\n+                                            Collection<ExecutableElement> methods,\n+                                            Content dl) {\n+        Utils utils = writer.utils;\n+        if (writer.options.noComment()) {\n+            return;\n+        }\n+        Contents contents = writer.contents;\n+        var enclosing = (TypeElement) method.getEnclosingElement();\n+        VisibleMemberTable vmt = writer.configuration.getVisibleMemberTable(enclosing);\n+        SortedSet<ExecutableElement> implementedMethods =\n+                new TreeSet<>(utils.comparators.makeOverrideUseComparator());\n+        implementedMethods.addAll(methods);\n+        for (ExecutableElement implementedMeth : implementedMethods) {\n+            TypeMirror intfac = vmt.getImplementedMethodHolder(method, implementedMeth);\n+            intfac = utils.getDeclaredType(enclosing, intfac);\n+            Content intfaclink = writer.getLink(new HtmlLinkInfo(\n+                    writer.configuration, HtmlLinkInfo.Kind.LINK_TYPE_PARAMS_AND_BOUNDS, intfac));\n+            var codeIntfacLink = HtmlTree.CODE(intfaclink);\n+            dl.add(HtmlTree.DT(contents.specifiedByLabel));\n+            Content methlink = writer.getDocLink(\n+                    HtmlLinkInfo.Kind.PLAIN, implementedMeth,\n+                    implementedMeth.getSimpleName());\n+            var codeMethLink = HtmlTree.CODE(methlink);\n+            var dd = HtmlTree.DD(codeMethLink);\n+            dd.add(Entity.NO_BREAK_SPACE);\n+            dd.add(contents.inInterface);\n+            dd.add(Entity.NO_BREAK_SPACE);\n+            dd.add(codeIntfacLink);\n+            dl.add(dd);\n+        }\n+    }\n+\n+    \/**\n+     * Get the return type for the given method.\n+     *\n+     * @param method the method being documented.\n+     * @return the return type\n+     *\/\n+    protected Content getReturnType(ExecutableElement method) {\n+        TypeMirror type = utils.getReturnType(typeElement, method);\n+        if (type != null) {\n+            return writer.getLink(new HtmlLinkInfo(configuration, HtmlLinkInfo.Kind.LINK_TYPE_PARAMS, type));\n+        }\n+        return new ContentBuilder();\n+    }\n+\n+    protected Content getMemberHeader(){\n+        return writer.getMemberHeader();\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/MethodWriter.java","additions":441,"deletions":0,"binary":false,"changes":441,"status":"added"},{"patch":"@@ -1,354 +0,0 @@\n-\/*\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.formats.html;\n-\n-import java.util.Collection;\n-import java.util.SortedSet;\n-import java.util.TreeSet;\n-\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.ExecutableElement;\n-import javax.lang.model.element.TypeElement;\n-import javax.lang.model.type.TypeMirror;\n-\n-import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n-import jdk.javadoc.internal.doclets.formats.html.markup.Entity;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlId;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n-import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.MemberSummaryWriter;\n-import jdk.javadoc.internal.doclets.toolkit.MethodWriter;\n-import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n-import jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable;\n-\n-\/**\n- * Writes method documentation in HTML format.\n- *\/\n-public class MethodWriterImpl extends AbstractExecutableMemberWriter\n-        implements MethodWriter, MemberSummaryWriter {\n-\n-    \/**\n-     * Construct a new MethodWriterImpl.\n-     *\n-     * @param writer the writer for the class that the methods belong to.\n-     * @param typeElement the class being documented.\n-     *\/\n-    public MethodWriterImpl(SubWriterHolderWriter writer, TypeElement typeElement) {\n-        super(writer, typeElement);\n-    }\n-\n-    \/**\n-     * Construct a new MethodWriterImpl.\n-     *\n-     * @param writer The writer for the class that the methods belong to.\n-     *\/\n-    public MethodWriterImpl(SubWriterHolderWriter writer) {\n-        super(writer);\n-    }\n-\n-    @Override\n-    public Content getMemberSummaryHeader(TypeElement typeElement, Content target) {\n-        target.add(MarkerComments.START_OF_METHOD_SUMMARY);\n-        Content memberContent = new ContentBuilder();\n-        writer.addSummaryHeader(this, memberContent);\n-        return memberContent;\n-    }\n-\n-    @Override\n-    public void addSummary(Content summariesList, Content content) {\n-        writer.addSummary(HtmlStyle.methodSummary,\n-                HtmlIds.METHOD_SUMMARY, summariesList, content);\n-    }\n-\n-    @Override\n-    public Content getMethodDetailsHeader(Content content) {\n-        content.add(MarkerComments.START_OF_METHOD_DETAILS);\n-        Content methodDetailsContent = new ContentBuilder();\n-        var heading = HtmlTree.HEADING(Headings.TypeDeclaration.DETAILS_HEADING,\n-                contents.methodDetailLabel);\n-        methodDetailsContent.add(heading);\n-        return methodDetailsContent;\n-    }\n-\n-    @Override\n-    public Content getMethodHeader(ExecutableElement method) {\n-        Content content = new ContentBuilder();\n-        var heading = HtmlTree.HEADING(Headings.TypeDeclaration.MEMBER_HEADING,\n-                Text.of(name(method)));\n-        HtmlId erasureAnchor;\n-        if ((erasureAnchor = htmlIds.forErasure(method)) != null) {\n-            heading.setId(erasureAnchor);\n-        }\n-        content.add(heading);\n-        return HtmlTree.SECTION(HtmlStyle.detail, content)\n-                .setId(htmlIds.forMember(method));\n-    }\n-\n-    @Override\n-    public Content getSignature(ExecutableElement method) {\n-        return new Signatures.MemberSignature(method, this)\n-                .setTypeParameters(getTypeParameters(method))\n-                .setReturnType(getReturnType(method))\n-                .setParameters(getParameters(method, true))\n-                .setExceptions(getExceptions(method))\n-                .setAnnotations(writer.getAnnotationInfo(method, true))\n-                .toContent();\n-    }\n-\n-    @Override\n-    public void addDeprecated(ExecutableElement method, Content methodContent) {\n-        addDeprecatedInfo(method, methodContent);\n-    }\n-\n-    @Override\n-    public void addPreview(ExecutableElement method, Content content) {\n-        addPreviewInfo(method, content);\n-    }\n-\n-    @Override\n-    public void addComments(TypeMirror holderType, ExecutableElement method, Content methodContent) {\n-        TypeElement holder = utils.asTypeElement(holderType);\n-        if (!utils.getFullBody(method).isEmpty()) {\n-            if (holder.equals(typeElement) ||\n-                    !(utils.isPublic(holder) ||\n-                    utils.isLinkable(holder))) {\n-                writer.addInlineComment(method, methodContent);\n-            } else {\n-                if (!utils.hasHiddenTag(holder) && !utils.hasHiddenTag(method)) {\n-                    Content link =\n-                            writer.getDocLink(HtmlLinkInfo.Kind.PLAIN,\n-                                    holder, method,\n-                                    utils.isIncluded(holder)\n-                                            ? utils.getSimpleName(holder)\n-                                            : utils.getFullyQualifiedName(holder));\n-                    var codeLink = HtmlTree.CODE(link);\n-                    var descriptionFromTypeLabel = HtmlTree.SPAN(HtmlStyle.descriptionFromTypeLabel,\n-                            utils.isClass(holder)\n-                                    ? contents.descriptionFromClassLabel\n-                                    : contents.descriptionFromInterfaceLabel);\n-                    descriptionFromTypeLabel.add(Entity.NO_BREAK_SPACE);\n-                    descriptionFromTypeLabel.add(codeLink);\n-                    methodContent.add(HtmlTree.DIV(HtmlStyle.block, descriptionFromTypeLabel));\n-                }\n-                writer.addInlineComment(method, methodContent);\n-            }\n-        }\n-    }\n-\n-    @Override\n-    public void addTags(ExecutableElement method, Content methodContent) {\n-        writer.addTagsInfo(method, methodContent);\n-    }\n-\n-    @Override\n-    public Content getMethodDetails(Content methodDetailsHeader, Content methodDetails) {\n-        Content c = new ContentBuilder(methodDetailsHeader, methodDetails);\n-        return getMember(HtmlTree.SECTION(HtmlStyle.methodDetails, c)\n-                .setId(HtmlIds.METHOD_DETAIL));\n-    }\n-\n-    @Override\n-    public void addSummaryLabel(Content content) {\n-        var label = HtmlTree.HEADING(Headings.TypeDeclaration.SUMMARY_HEADING,\n-                contents.methodSummary);\n-        content.add(label);\n-    }\n-\n-    @Override\n-    public TableHeader getSummaryTableHeader(Element member) {\n-        return new TableHeader(contents.modifierAndTypeLabel, contents.methodLabel,\n-                contents.descriptionLabel);\n-    }\n-\n-    @Override\n-    protected Table<Element> createSummaryTable() {\n-        return new Table<Element>(HtmlStyle.summaryTable)\n-                .setHeader(getSummaryTableHeader(typeElement))\n-                .setColumnStyles(HtmlStyle.colFirst, HtmlStyle.colSecond, HtmlStyle.colLast)\n-                .setId(HtmlIds.METHOD_SUMMARY_TABLE)\n-                .setDefaultTab(contents.getContent(\"doclet.All_Methods\"))\n-                .addTab(contents.getContent(\"doclet.Static_Methods\"), utils::isStatic)\n-                .addTab(contents.getContent(\"doclet.Instance_Methods\"), e -> !utils.isStatic(e))\n-                .addTab(contents.getContent(\"doclet.Abstract_Methods\"), utils::isAbstract)\n-                .addTab(contents.getContent(\"doclet.Concrete_Methods\"),\n-                        e -> !utils.isAbstract(e) && !utils.isPlainInterface(e.getEnclosingElement()))\n-                .addTab(contents.getContent(\"doclet.Default_Methods\"), utils::isDefault)\n-                .addTab(contents.getContent(\"doclet.Deprecated_Methods\"),\n-                        e -> utils.isDeprecated(e) || utils.isDeprecated(typeElement));\n-    }\n-\n-    @Override\n-    public void addInheritedSummaryLabel(TypeElement typeElement, Content content) {\n-        Content classLink = writer.getPreQualifiedClassLink(\n-                HtmlLinkInfo.Kind.PLAIN, typeElement);\n-        Content label;\n-        if (options.summarizeOverriddenMethods()) {\n-            label = Text.of(utils.isClass(typeElement)\n-                    ? resources.getText(\"doclet.Methods_Declared_In_Class\")\n-                    : resources.getText(\"doclet.Methods_Declared_In_Interface\"));\n-        } else {\n-            label = Text.of(utils.isClass(typeElement)\n-                    ? resources.getText(\"doclet.Methods_Inherited_From_Class\")\n-                    : resources.getText(\"doclet.Methods_Inherited_From_Interface\"));\n-        }\n-        var labelHeading = HtmlTree.HEADING(Headings.TypeDeclaration.INHERITED_SUMMARY_HEADING,\n-                label);\n-        labelHeading.setId(htmlIds.forInheritedMethods(typeElement));\n-        labelHeading.add(Entity.NO_BREAK_SPACE);\n-        labelHeading.add(classLink);\n-        content.add(labelHeading);\n-    }\n-\n-    @Override\n-    protected void addSummaryType(Element member, Content content) {\n-        ExecutableElement meth = (ExecutableElement)member;\n-        addModifiersAndType(meth, utils.getReturnType(typeElement, meth), content);\n-    }\n-\n-    \/**\n-     * Adds \"overrides\" or \"specified by\" information about a method (if appropriate)\n-     * into a definition list.\n-     *\n-     * @param writer         the writer for the element\n-     * @param overriddenType the superclass\n-     * @param method         the method\n-     * @param dl             the list in which to add the information.\n-     *\/\n-    protected static void addOverridden(HtmlDocletWriter writer,\n-                                        TypeMirror overriddenType,\n-                                        ExecutableElement method,\n-                                        Content dl) {\n-        if (writer.options.noComment()) {\n-            return;\n-        }\n-        Utils utils = writer.utils;\n-        TypeElement holder = utils.getEnclosingTypeElement(method);\n-        if (!(utils.isPublic(holder) || utils.isLinkable(holder))) {\n-            \/\/This is an implementation detail that should not be documented.\n-            return;\n-        }\n-        if (utils.isIncluded(holder) && !utils.isIncluded(method)) {\n-            \/\/The class is included but the method is not.  That means that it\n-            \/\/is not visible so don't document this.\n-            return;\n-        }\n-        if (utils.hasHiddenTag(holder) || utils.hasHiddenTag(method)) {\n-            return;\n-        }\n-\n-        Contents contents = writer.contents;\n-        Content label;\n-        HtmlLinkInfo.Kind context;\n-        if (utils.isAbstract(holder) && utils.isAbstract(method)) {\n-            \/\/Abstract method is implemented from abstract class,\n-            \/\/not overridden\n-            label = contents.specifiedByLabel;\n-            context = HtmlLinkInfo.Kind.LINK_TYPE_PARAMS_AND_BOUNDS;\n-        } else {\n-            label = contents.overridesLabel;\n-            context = HtmlLinkInfo.Kind.LINK_TYPE_PARAMS_AND_BOUNDS;\n-        }\n-        dl.add(HtmlTree.DT(label));\n-        Content overriddenTypeLink =\n-                writer.getLink(new HtmlLinkInfo(writer.configuration, context, overriddenType));\n-        var codeOverriddenTypeLink = HtmlTree.CODE(overriddenTypeLink);\n-        Content methlink = writer.getLink(\n-                new HtmlLinkInfo(writer.configuration, HtmlLinkInfo.Kind.PLAIN, holder)\n-                        .fragment(writer.htmlIds.forMember(method).name())\n-                        .label(method.getSimpleName()));\n-        var codeMethLink = HtmlTree.CODE(methlink);\n-        var dd = HtmlTree.DD(codeMethLink);\n-        dd.add(Entity.NO_BREAK_SPACE);\n-        dd.add(contents.inClass);\n-        dd.add(Entity.NO_BREAK_SPACE);\n-        dd.add(codeOverriddenTypeLink);\n-        dl.add(dd);\n-    }\n-\n-    \/**\n-     * Adds \"implements\" information for a method (if appropriate)\n-     * into a definition list.\n-     *\n-     * @param writer  the writer for the method\n-     * @param method  the method\n-     * @param methods implemented methods\n-     * @param dl      the definition list\n-     *\/\n-    protected static void addImplementsInfo(HtmlDocletWriter writer,\n-                                            ExecutableElement method,\n-                                            Collection<ExecutableElement> methods,\n-                                            Content dl) {\n-        Utils utils = writer.utils;\n-        if (writer.options.noComment()) {\n-            return;\n-        }\n-        Contents contents = writer.contents;\n-        var enclosing = (TypeElement) method.getEnclosingElement();\n-        VisibleMemberTable vmt = writer.configuration.getVisibleMemberTable(enclosing);\n-        SortedSet<ExecutableElement> implementedMethods =\n-                new TreeSet<>(utils.comparators.makeOverrideUseComparator());\n-        implementedMethods.addAll(methods);\n-        for (ExecutableElement implementedMeth : implementedMethods) {\n-            TypeMirror intfac = vmt.getImplementedMethodHolder(method, implementedMeth);\n-            intfac = utils.getDeclaredType(enclosing, intfac);\n-            Content intfaclink = writer.getLink(new HtmlLinkInfo(\n-                    writer.configuration, HtmlLinkInfo.Kind.LINK_TYPE_PARAMS_AND_BOUNDS, intfac));\n-            var codeIntfacLink = HtmlTree.CODE(intfaclink);\n-            dl.add(HtmlTree.DT(contents.specifiedByLabel));\n-            Content methlink = writer.getDocLink(\n-                    HtmlLinkInfo.Kind.PLAIN, implementedMeth,\n-                    implementedMeth.getSimpleName());\n-            var codeMethLink = HtmlTree.CODE(methlink);\n-            var dd = HtmlTree.DD(codeMethLink);\n-            dd.add(Entity.NO_BREAK_SPACE);\n-            dd.add(contents.inInterface);\n-            dd.add(Entity.NO_BREAK_SPACE);\n-            dd.add(codeIntfacLink);\n-            dl.add(dd);\n-        }\n-    }\n-\n-    \/**\n-     * Get the return type for the given method.\n-     *\n-     * @param method the method being documented.\n-     * @return the return type\n-     *\/\n-    protected Content getReturnType(ExecutableElement method) {\n-        TypeMirror type = utils.getReturnType(typeElement, method);\n-        if (type != null) {\n-            return writer.getLink(new HtmlLinkInfo(configuration, HtmlLinkInfo.Kind.LINK_TYPE_PARAMS, type));\n-        }\n-        return new ContentBuilder();\n-    }\n-\n-    @Override\n-    public Content getMemberHeader(){\n-        return writer.getMemberHeader();\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/MethodWriterImpl.java","additions":0,"deletions":354,"binary":false,"changes":354,"status":"deleted"},{"patch":"@@ -37,1 +37,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/ModuleIndexWriter.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -53,2 +53,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.ModuleSummaryWriter;\n+import jdk.javadoc.internal.doclets.toolkit.DocletException;\n@@ -63,1 +62,1 @@\n-public class ModuleWriterImpl extends HtmlDocletWriter implements ModuleSummaryWriter {\n+public class ModuleWriter extends HtmlDocletWriter {\n@@ -94,1 +93,1 @@\n-    class PackageEntry {\n+    static class PackageEntry {\n@@ -162,1 +161,1 @@\n-    public ModuleWriterImpl(HtmlConfiguration configuration, ModuleElement mdle) {\n+    public ModuleWriter(HtmlConfiguration configuration, ModuleElement mdle) {\n@@ -169,2 +168,94 @@\n-    @Override\n-    public Content getModuleHeader(String heading) {\n+    \/**\n+     * Build the module summary.\n+     *\n+     * @throws DocletException if there is a problem while building the documentation\n+     *\/\n+    public void build() throws DocletException {\n+        buildModuleDoc();\n+    }\n+\n+    \/**\n+     * Build the module documentation.\n+     *\n+     * @throws DocletException if there is a problem while building the documentation\n+     *\/\n+    protected void buildModuleDoc() throws DocletException {\n+        Content content = getModuleHeader(mdle.getQualifiedName().toString());\n+\n+        buildContent();\n+\n+        addModuleFooter();\n+        printDocument(content);\n+        var docFilesHandler = configuration.getWriterFactory().getDocFilesHandler(mdle);\n+        docFilesHandler.copyDocFiles();\n+    }\n+\n+    \/**\n+     * Build the content for the module doc.\n+     *\/\n+    protected void buildContent() {\n+        Content moduleContent = getContentHeader();\n+\n+        addModuleSignature(moduleContent);\n+        buildModuleDescription(moduleContent);\n+        buildSummary(moduleContent);\n+\n+        addModuleContent(moduleContent);\n+    }\n+\n+    \/**\n+     * Builds the list of summary sections for this module.\n+     *\n+     * @param target the module content to which the summaries will\n+     *               be added\n+     *\/\n+    protected void buildSummary(Content target) {\n+        Content summariesList = getSummariesList();\n+\n+        buildPackagesSummary(summariesList);\n+        buildModulesSummary(summariesList);\n+        buildServicesSummary(summariesList);\n+\n+        target.add(getSummary(summariesList));\n+    }\n+\n+    \/**\n+     * Builds the summary of the module dependencies of this module.\n+     *\n+     * @param summariesList the list of summaries to which the summary will be added\n+     *\/\n+    protected void buildModulesSummary(Content summariesList) {\n+        addModulesSummary(summariesList);\n+    }\n+\n+    \/**\n+     * Builds the summary of the packages exported or opened by this module.\n+     *\n+     * @param summariesList the list of summaries to which the summary will be added\n+     *\/\n+    protected void buildPackagesSummary(Content summariesList) {\n+        addPackagesSummary(summariesList);\n+    }\n+\n+    \/**\n+     * Builds the summary of the services used or provided by this module.\n+     *\n+     * @param summariesList the list of summaries to which the summary will be added\n+     *\/\n+    protected void buildServicesSummary(Content summariesList) {\n+        addServicesSummary(summariesList);\n+    }\n+\n+    \/**\n+     * Builds the description for this module.\n+     *\n+     * @param moduleContent the content to which the module description will\n+     *                      be added\n+     *\/\n+    protected void buildModuleDescription(Content moduleContent) {\n+        if (!options.noComment()) {\n+            addModuleDescription(moduleContent);\n+        }\n+    }\n+\n+    protected Content getModuleHeader(String heading) {\n@@ -200,2 +291,1 @@\n-    @Override\n-    public Content getContentHeader() {\n+    protected Content getContentHeader() {\n@@ -205,2 +295,1 @@\n-    @Override\n-    public Content getSummariesList() {\n+    protected Content getSummariesList() {\n@@ -210,2 +299,1 @@\n-    @Override\n-    public Content getSummary(Content source) {\n+    protected Content getSummary(Content source) {\n@@ -451,2 +539,1 @@\n-    @Override\n-    public void addModulesSummary(Content summariesList) {\n+    protected void addModulesSummary(Content summariesList) {\n@@ -495,2 +582,1 @@\n-    @Override\n-    public void addPackagesSummary(Content summariesList) {\n+    protected void addPackagesSummary(Content summariesList) {\n@@ -662,2 +748,1 @@\n-    @Override\n-    public void addServicesSummary(Content summariesList) {\n+    protected void addServicesSummary(Content summariesList) {\n@@ -789,2 +874,1 @@\n-    @Override\n-    public void addModuleDescription(Content moduleContent) {\n+    protected void addModuleDescription(Content moduleContent) {\n@@ -803,2 +887,1 @@\n-    @Override\n-    public void addModuleSignature(Content moduleContent) {\n+    protected void addModuleSignature(Content moduleContent) {\n@@ -809,2 +892,1 @@\n-    @Override\n-    public void addModuleContent(Content source) {\n+    protected void addModuleContent(Content source) {\n@@ -814,2 +896,1 @@\n-    @Override\n-    public void addModuleFooter() {\n+    protected void addModuleFooter() {\n@@ -819,2 +900,1 @@\n-    @Override\n-    public void printDocument(Content content) throws DocFileIOException {\n+    protected void printDocument(Content content) throws DocFileIOException {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/ModuleWriter.java","additions":109,"deletions":29,"binary":false,"changes":138,"previous_filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/ModuleWriterImpl.java","status":"renamed"},{"patch":"@@ -45,1 +45,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n@@ -52,2 +51,0 @@\n-import static jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable.Kind.*;\n-\n@@ -101,1 +98,1 @@\n-        USE;\n+        USE\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/Navigation.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -39,2 +39,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.MemberSummaryWriter;\n@@ -45,2 +43,1 @@\n-public class NestedClassWriterImpl extends AbstractMemberWriter\n-    implements MemberSummaryWriter {\n+public class NestedClassWriter extends AbstractMemberWriter {\n@@ -48,1 +45,1 @@\n-    public NestedClassWriterImpl(SubWriterHolderWriter writer, TypeElement typeElement) {\n+    public NestedClassWriter(SubWriterHolderWriter writer, TypeElement typeElement) {\n@@ -52,1 +49,1 @@\n-    public NestedClassWriterImpl(SubWriterHolderWriter writer) {\n+    public NestedClassWriter(SubWriterHolderWriter writer) {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/NestedClassWriter.java","additions":3,"deletions":6,"binary":false,"changes":9,"previous_filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/NestedClassWriterImpl.java","status":"renamed"},{"patch":"@@ -37,1 +37,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/NewAPIListWriter.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/PackageIndexWriter.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/PackageTreeWriter.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -44,1 +44,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/PackageUseWriter.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,465 @@\n+\/*\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.SortedSet;\n+import java.util.function.Predicate;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ModuleElement;\n+import javax.lang.model.element.PackageElement;\n+import javax.lang.model.element.TypeElement;\n+\n+import com.sun.source.doctree.DeprecatedTree;\n+import com.sun.source.doctree.DocTree;\n+import jdk.javadoc.internal.doclets.formats.html.markup.BodyContents;\n+import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n+import jdk.javadoc.internal.doclets.formats.html.markup.Entity;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;\n+import jdk.javadoc.internal.doclets.formats.html.markup.TagName;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n+import jdk.javadoc.internal.doclets.formats.html.Navigation.PageMode;\n+import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n+import jdk.javadoc.internal.doclets.toolkit.DocletException;\n+import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocFileIOException;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocPath;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocPaths;\n+\n+\/**\n+ * Class to generate file for each package contents in the right-hand\n+ * frame. This will list all the Class Kinds in the package. A click on any\n+ * class-kind will update the frame with the clicked class-kind page.\n+ *\/\n+public class PackageWriter extends HtmlDocletWriter {\n+\n+    \/**\n+     * The package being documented.\n+     *\/\n+    protected PackageElement packageElement;\n+\n+    private List<PackageElement> relatedPackages;\n+    private SortedSet<TypeElement> allClasses;\n+\n+    \/**\n+     * The HTML element for the section tag being written.\n+     *\/\n+    private final HtmlTree section = HtmlTree.SECTION(HtmlStyle.packageDescription, new ContentBuilder());\n+\n+    private final BodyContents bodyContents = new BodyContents();\n+\n+    \/\/ Maximum number of subpackages and sibling packages to list in related packages table\n+    private static final int MAX_SUBPACKAGES = 20;\n+    private static final int MAX_SIBLING_PACKAGES = 5;\n+\n+\n+    \/**\n+     * Constructor to construct PackageWriter object and to generate\n+     * \"package-summary.html\" file in the respective package directory.\n+     * For example for package \"java.lang\" this will generate file\n+     * \"package-summary.html\" file in the \"java\/lang\" directory. It will also\n+     * create \"java\/lang\" directory in the current or the destination directory\n+     * if it doesn't exist.\n+     *\n+     * @param configuration the configuration of the doclet.\n+     * @param packageElement    PackageElement under consideration.\n+     *\/\n+    public PackageWriter(HtmlConfiguration configuration, PackageElement packageElement) {\n+        super(configuration,\n+                configuration.docPaths.forPackage(packageElement)\n+                .resolve(DocPaths.PACKAGE_SUMMARY));\n+        this.packageElement = packageElement;\n+        computePackageData();\n+    }\n+\n+    \/**\n+     * Build the package summary.\n+     *\n+     * @throws DocletException if there is a problem while building the documentation\n+     *\/\n+    public void build() throws DocletException {\n+        buildPackageDoc();\n+    }\n+\n+    \/**\n+     * Build the package documentation.\n+     *\n+     * @throws DocletException if there is a problem while building the documentation\n+     *\/\n+    protected void buildPackageDoc() throws DocletException {\n+        Content content = getPackageHeader();\n+\n+        buildContent();\n+\n+        addPackageFooter();\n+        printDocument(content);\n+        var docFilesHandler = configuration\n+                .getWriterFactory()\n+                .getDocFilesHandler(packageElement);\n+        docFilesHandler.copyDocFiles();\n+    }\n+\n+    \/**\n+     * Build the content for the package.\n+     *\/\n+    protected void buildContent() {\n+        Content packageContent = getContentHeader();\n+\n+        addPackageSignature(packageContent);\n+        buildPackageDescription(packageContent);\n+        buildPackageTags(packageContent);\n+        buildSummary(packageContent);\n+\n+        addPackageContent(packageContent);\n+    }\n+\n+    \/**\n+     * Builds the list of summaries for the different kinds of types in this package.\n+     *\n+     * @param packageContent the package content to which the summaries will\n+     *                       be added\n+     *\/\n+    protected void buildSummary(Content packageContent) {\n+        Content summariesList = getSummariesList();\n+\n+        buildRelatedPackagesSummary(summariesList);\n+        buildAllClassesAndInterfacesSummary(summariesList);\n+\n+        packageContent.add(getPackageSummary(summariesList));\n+    }\n+\n+    \/**\n+     * Builds a list of \"nearby\" packages (subpackages, superpackages, and sibling packages).\n+     *\n+     * @param summariesList the list of summaries to which the summary will be added\n+     *\/\n+    protected void buildRelatedPackagesSummary(Content summariesList) {\n+        addRelatedPackagesSummary(summariesList);\n+    }\n+\n+    \/**\n+     * Builds the summary for all classes and interfaces in this package.\n+     *\n+     * @param summariesList the list of summaries to which the summary will be added\n+     *\/\n+    protected void buildAllClassesAndInterfacesSummary(Content summariesList) {\n+        addAllClassesAndInterfacesSummary(summariesList);\n+    }\n+\n+\n+    \/**\n+     * Build the description of the summary.\n+     *\n+     * @param packageContent the content to which the package description will\n+     *                       be added\n+     *\/\n+    protected void buildPackageDescription(Content packageContent) {\n+        if (options.noComment()) {\n+            return;\n+        }\n+        addPackageDescription(packageContent);\n+    }\n+\n+    \/**\n+     * Build the tags of the summary.\n+     *\n+     * @param packageContent the content to which the package tags will be added\n+     *\/\n+    protected void buildPackageTags(Content packageContent) {\n+        if (options.noComment()) {\n+            return;\n+        }\n+        addPackageTags(packageContent);\n+    }\n+\n+    protected Content getPackageHeader() {\n+        String packageName = getLocalizedPackageName(packageElement).toString();\n+        HtmlTree body = getBody(getWindowTitle(packageName));\n+        var div = HtmlTree.DIV(HtmlStyle.header);\n+        if (configuration.showModules) {\n+            ModuleElement mdle = configuration.docEnv.getElementUtils().getModuleOf(packageElement);\n+            var classModuleLabel = HtmlTree.SPAN(HtmlStyle.moduleLabelInPackage, contents.moduleLabel);\n+            var moduleNameDiv = HtmlTree.DIV(HtmlStyle.subTitle, classModuleLabel);\n+            moduleNameDiv.add(Entity.NO_BREAK_SPACE);\n+            moduleNameDiv.add(getModuleLink(mdle,\n+                    Text.of(mdle.getQualifiedName().toString())));\n+            div.add(moduleNameDiv);\n+        }\n+        Content packageHead = new ContentBuilder();\n+        if (!packageElement.isUnnamed()) {\n+            packageHead.add(contents.packageLabel).add(\" \");\n+        }\n+        packageHead.add(packageName);\n+        var tHeading = HtmlTree.HEADING_TITLE(Headings.PAGE_TITLE_HEADING,\n+                HtmlStyle.title, packageHead);\n+        div.add(tHeading);\n+        bodyContents.setHeader(getHeader(PageMode.PACKAGE, packageElement))\n+                .addMainContent(div);\n+        return body;\n+    }\n+\n+    protected Content getContentHeader() {\n+        return new ContentBuilder();\n+    }\n+\n+    private void computePackageData() {\n+        relatedPackages = findRelatedPackages();\n+        boolean isSpecified = utils.isSpecified(packageElement);\n+        allClasses = filterClasses(isSpecified\n+                ? utils.getAllClasses(packageElement)\n+                : configuration.typeElementCatalog.allClasses(packageElement));\n+    }\n+\n+    private SortedSet<TypeElement> filterClasses(SortedSet<TypeElement> types) {\n+        List<TypeElement> typeList = types\n+                .stream()\n+                .filter(te -> utils.isCoreClass(te) && configuration.isGeneratedDoc(te))\n+                .collect(Collectors.toList());\n+        return utils.filterOutPrivateClasses(typeList, options.javafx());\n+    }\n+\n+    private List<PackageElement> findRelatedPackages() {\n+        String pkgName = packageElement.getQualifiedName().toString();\n+\n+        \/\/ always add superpackage\n+        int lastdot = pkgName.lastIndexOf('.');\n+        String pkgPrefix = lastdot > 0 ? pkgName.substring(0, lastdot) : null;\n+        List<PackageElement> packages = new ArrayList<>(\n+                filterPackages(p -> p.getQualifiedName().toString().equals(pkgPrefix)));\n+        boolean hasSuperPackage = !packages.isEmpty();\n+\n+        \/\/ add subpackages unless there are very many of them\n+        Pattern subPattern = Pattern.compile(pkgName.replace(\".\", \"\\\\.\") + \"\\\\.\\\\w+\");\n+        List<PackageElement> subpackages = filterPackages(\n+                p -> subPattern.matcher(p.getQualifiedName().toString()).matches());\n+        if (subpackages.size() <= MAX_SUBPACKAGES) {\n+            packages.addAll(subpackages);\n+        }\n+\n+        \/\/ only add sibling packages if there is a non-empty superpackage, we are beneath threshold,\n+        \/\/ and number of siblings is beneath threshold as well\n+        if (hasSuperPackage && pkgPrefix != null && packages.size() <= MAX_SIBLING_PACKAGES) {\n+            Pattern siblingPattern = Pattern.compile(pkgPrefix.replace(\".\", \"\\\\.\") + \"\\\\.\\\\w+\");\n+\n+            List<PackageElement> siblings = filterPackages(\n+                    p -> siblingPattern.matcher(p.getQualifiedName().toString()).matches());\n+            if (siblings.size() <= MAX_SIBLING_PACKAGES) {\n+                packages.addAll(siblings);\n+            }\n+        }\n+        return packages;\n+    }\n+\n+    @Override\n+    protected Navigation getNavBar(PageMode pageMode, Element element) {\n+        Content linkContent = getModuleLink(utils.elementUtils.getModuleOf(packageElement),\n+                contents.moduleLabel);\n+        return super.getNavBar(pageMode, element)\n+                .setNavLinkModule(linkContent)\n+                .setSubNavLinks(() -> List.of(\n+                        links.createLink(HtmlIds.PACKAGE_DESCRIPTION, contents.navDescription,\n+                                !utils.getFullBody(packageElement).isEmpty() && !options.noComment()),\n+                        links.createLink(HtmlIds.RELATED_PACKAGE_SUMMARY, contents.relatedPackages,\n+                                relatedPackages != null && !relatedPackages.isEmpty()),\n+                        links.createLink(HtmlIds.CLASS_SUMMARY, contents.navClassesAndInterfaces,\n+                                allClasses != null && !allClasses.isEmpty())));\n+    }\n+\n+    \/**\n+     * Add the package deprecation information to the documentation tree.\n+     *\n+     * @param div the content to which the deprecation information will be added\n+     *\/\n+    public void addDeprecationInfo(Content div) {\n+        List<? extends DeprecatedTree> deprs = utils.getDeprecatedTrees(packageElement);\n+        if (utils.isDeprecated(packageElement)) {\n+            CommentHelper ch = utils.getCommentHelper(packageElement);\n+            var deprDiv = HtmlTree.DIV(HtmlStyle.deprecationBlock);\n+            var deprPhrase = HtmlTree.SPAN(HtmlStyle.deprecatedLabel, getDeprecatedPhrase(packageElement));\n+            deprDiv.add(deprPhrase);\n+            if (!deprs.isEmpty()) {\n+                List<? extends DocTree> commentTags = ch.getDescription(deprs.get(0));\n+                if (!commentTags.isEmpty()) {\n+                    addInlineDeprecatedComment(packageElement, deprs.get(0), deprDiv);\n+                }\n+            }\n+            div.add(deprDiv);\n+        }\n+    }\n+\n+    protected Content getSummariesList() {\n+        return HtmlTree.UL(HtmlStyle.summaryList);\n+    }\n+\n+    protected void addRelatedPackagesSummary(Content summaryContent) {\n+        boolean showModules = configuration.showModules && hasRelatedPackagesInOtherModules(relatedPackages);\n+        TableHeader tableHeader= showModules\n+                ? new TableHeader(contents.moduleLabel, contents.packageLabel, contents.descriptionLabel)\n+                : new TableHeader(contents.packageLabel, contents.descriptionLabel);\n+        addPackageSummary(relatedPackages, contents.relatedPackages, tableHeader,\n+                summaryContent, showModules);\n+    }\n+\n+\n+    \/**\n+     * Add all types to the content.\n+     *\n+     * @param target the content to which the links will be added\n+     *\/\n+    public void addAllClassesAndInterfacesSummary(Content target) {\n+        var table = new Table<TypeElement>(HtmlStyle.summaryTable)\n+                .setHeader(new TableHeader(contents.classLabel, contents.descriptionLabel))\n+                .setColumnStyles(HtmlStyle.colFirst, HtmlStyle.colLast)\n+                .setId(HtmlIds.CLASS_SUMMARY)\n+                .setDefaultTab(contents.allClassesAndInterfacesLabel)\n+                .addTab(contents.interfaces, utils::isPlainInterface)\n+                .addTab(contents.classes, utils::isNonThrowableClass)\n+                .addTab(contents.enums, utils::isEnum)\n+                .addTab(contents.records, utils::isRecord)\n+                .addTab(contents.exceptionClasses, utils::isThrowable)\n+                .addTab(contents.annotationTypes, utils::isAnnotationInterface);\n+        for (TypeElement typeElement : allClasses) {\n+            if (typeElement != null && utils.isCoreClass(typeElement)) {\n+                Content classLink = getLink(new HtmlLinkInfo(\n+                        configuration, HtmlLinkInfo.Kind.SHOW_TYPE_PARAMS_AND_BOUNDS, typeElement));\n+                ContentBuilder description = new ContentBuilder();\n+                addPreviewSummary(typeElement, description);\n+                if (utils.isDeprecated(typeElement)) {\n+                    description.add(getDeprecatedPhrase(typeElement));\n+                    List<? extends DeprecatedTree> tags = utils.getDeprecatedTrees(typeElement);\n+                    if (!tags.isEmpty()) {\n+                        addSummaryDeprecatedComment(typeElement, tags.get(0), description);\n+                    }\n+                } else {\n+                    addSummaryComment(typeElement, description);\n+                }\n+                table.addRow(typeElement, Arrays.asList(classLink, description));\n+            }\n+        }\n+        if (!table.isEmpty()) {\n+            target.add(HtmlTree.LI(table));\n+        }\n+    }\n+\n+    public void addPackageSummary(List<PackageElement> packages, Content label,\n+                                  TableHeader tableHeader, Content summaryContent,\n+                                  boolean showModules) {\n+        if (!packages.isEmpty()) {\n+            var table = new Table<Void>(HtmlStyle.summaryTable)\n+                    .setId(HtmlIds.RELATED_PACKAGE_SUMMARY)\n+                    .setCaption(label)\n+                    .setHeader(tableHeader);\n+            if (showModules) {\n+                table.setColumnStyles(HtmlStyle.colPlain, HtmlStyle.colFirst, HtmlStyle.colLast);\n+            } else {\n+                table.setColumnStyles(HtmlStyle.colFirst, HtmlStyle.colLast);\n+            }\n+\n+            for (PackageElement pkg : packages) {\n+                Content packageLink = getPackageLink(pkg, Text.of(pkg.getQualifiedName()));\n+                Content moduleLink = Text.EMPTY;\n+                if (showModules) {\n+                    ModuleElement module = (ModuleElement) pkg.getEnclosingElement();\n+                    if (module != null && !module.isUnnamed()) {\n+                        moduleLink = getModuleLink(module, Text.of(module.getQualifiedName()));\n+                    }\n+                }\n+                ContentBuilder description = new ContentBuilder();\n+                addPreviewSummary(pkg, description);\n+                if (utils.isDeprecated(pkg)) {\n+                    description.add(getDeprecatedPhrase(pkg));\n+                    List<? extends DeprecatedTree> tags = utils.getDeprecatedTrees(pkg);\n+                    if (!tags.isEmpty()) {\n+                        addSummaryDeprecatedComment(pkg, tags.get(0), description);\n+                    }\n+                } else {\n+                    addSummaryComment(pkg, description);\n+                }\n+                if (showModules) {\n+                    table.addRow(moduleLink, packageLink, description);\n+                } else {\n+                    table.addRow(packageLink, description);\n+                }\n+            }\n+            summaryContent.add(HtmlTree.LI(table));\n+        }\n+    }\n+\n+    protected void addPackageDescription(Content packageContent) {\n+        addPreviewInfo(packageElement, packageContent);\n+        if (!utils.getBody(packageElement).isEmpty()) {\n+            section.setId(HtmlIds.PACKAGE_DESCRIPTION);\n+            addDeprecationInfo(section);\n+            addInlineComment(packageElement, section);\n+        }\n+    }\n+\n+    protected void addPackageTags(Content packageContent) {\n+        addTagsInfo(packageElement, section);\n+        packageContent.add(section);\n+    }\n+\n+    protected void addPackageSignature(Content packageContent) {\n+        packageContent.add(new HtmlTree(TagName.HR));\n+        packageContent.add(Signatures.getPackageSignature(packageElement, this));\n+    }\n+\n+    protected void addPackageContent(Content packageContent) {\n+        bodyContents.addMainContent(packageContent);\n+    }\n+\n+    protected void addPackageFooter() {\n+        bodyContents.setFooter(getFooter());\n+    }\n+\n+    protected void printDocument(Content content) throws DocFileIOException {\n+        String description = getDescription(\"declaration\", packageElement);\n+        List<DocPath> localStylesheets = getLocalStylesheets(packageElement);\n+        content.add(bodyContents);\n+        printHtmlDocument(configuration.metakeywords.getMetaKeywords(packageElement),\n+                description, localStylesheets, content);\n+    }\n+\n+    protected Content getPackageSummary(Content summaryContent) {\n+        return HtmlTree.SECTION(HtmlStyle.summary, summaryContent);\n+    }\n+\n+    private boolean hasRelatedPackagesInOtherModules(List<PackageElement> relatedPackages) {\n+        final ModuleElement module = (ModuleElement) packageElement.getEnclosingElement();\n+        return relatedPackages.stream().anyMatch(pkg -> module != pkg.getEnclosingElement());\n+    }\n+\n+    private List<PackageElement> filterPackages(Predicate<? super PackageElement> filter) {\n+        return configuration.packages.stream()\n+                .filter(p -> p != packageElement && filter.test(p))\n+                .collect(Collectors.toList());\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/PackageWriter.java","additions":465,"deletions":0,"binary":false,"changes":465,"status":"added"},{"patch":"@@ -1,378 +0,0 @@\n-\/*\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.formats.html;\n-\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.SortedSet;\n-import java.util.function.Predicate;\n-import java.util.regex.Pattern;\n-import java.util.stream.Collectors;\n-\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.ModuleElement;\n-import javax.lang.model.element.PackageElement;\n-import javax.lang.model.element.TypeElement;\n-\n-import com.sun.source.doctree.DeprecatedTree;\n-import com.sun.source.doctree.DocTree;\n-import jdk.javadoc.internal.doclets.formats.html.markup.BodyContents;\n-import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n-import jdk.javadoc.internal.doclets.formats.html.markup.Entity;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;\n-import jdk.javadoc.internal.doclets.formats.html.markup.TagName;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n-import jdk.javadoc.internal.doclets.formats.html.Navigation.PageMode;\n-import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.PackageSummaryWriter;\n-import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocFileIOException;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocPath;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocPaths;\n-\n-\/**\n- * Class to generate file for each package contents in the right-hand\n- * frame. This will list all the Class Kinds in the package. A click on any\n- * class-kind will update the frame with the clicked class-kind page.\n- *\/\n-public class PackageWriterImpl extends HtmlDocletWriter\n-    implements PackageSummaryWriter {\n-\n-    \/**\n-     * The package being documented.\n-     *\/\n-    protected PackageElement packageElement;\n-\n-    private List<PackageElement> relatedPackages;\n-    private SortedSet<TypeElement> allClasses;\n-\n-    \/**\n-     * The HTML element for the section tag being written.\n-     *\/\n-    private final HtmlTree section = HtmlTree.SECTION(HtmlStyle.packageDescription, new ContentBuilder());\n-\n-    private final BodyContents bodyContents = new BodyContents();\n-\n-    \/\/ Maximum number of subpackages and sibling packages to list in related packages table\n-    private static final int MAX_SUBPACKAGES = 20;\n-    private static final int MAX_SIBLING_PACKAGES = 5;\n-\n-\n-    \/**\n-     * Constructor to construct PackageWriter object and to generate\n-     * \"package-summary.html\" file in the respective package directory.\n-     * For example for package \"java.lang\" this will generate file\n-     * \"package-summary.html\" file in the \"java\/lang\" directory. It will also\n-     * create \"java\/lang\" directory in the current or the destination directory\n-     * if it doesn't exist.\n-     *\n-     * @param configuration the configuration of the doclet.\n-     * @param packageElement    PackageElement under consideration.\n-     *\/\n-    public PackageWriterImpl(HtmlConfiguration configuration, PackageElement packageElement) {\n-        super(configuration,\n-                configuration.docPaths.forPackage(packageElement)\n-                .resolve(DocPaths.PACKAGE_SUMMARY));\n-        this.packageElement = packageElement;\n-        computePackageData();\n-    }\n-\n-    @Override\n-    public Content getPackageHeader() {\n-        String packageName = getLocalizedPackageName(packageElement).toString();\n-        HtmlTree body = getBody(getWindowTitle(packageName));\n-        var div = HtmlTree.DIV(HtmlStyle.header);\n-        if (configuration.showModules) {\n-            ModuleElement mdle = configuration.docEnv.getElementUtils().getModuleOf(packageElement);\n-            var classModuleLabel = HtmlTree.SPAN(HtmlStyle.moduleLabelInPackage, contents.moduleLabel);\n-            var moduleNameDiv = HtmlTree.DIV(HtmlStyle.subTitle, classModuleLabel);\n-            moduleNameDiv.add(Entity.NO_BREAK_SPACE);\n-            moduleNameDiv.add(getModuleLink(mdle,\n-                    Text.of(mdle.getQualifiedName().toString())));\n-            div.add(moduleNameDiv);\n-        }\n-        Content packageHead = new ContentBuilder();\n-        if (!packageElement.isUnnamed()) {\n-            packageHead.add(contents.packageLabel).add(\" \");\n-        }\n-        packageHead.add(packageName);\n-        var tHeading = HtmlTree.HEADING_TITLE(Headings.PAGE_TITLE_HEADING,\n-                HtmlStyle.title, packageHead);\n-        div.add(tHeading);\n-        bodyContents.setHeader(getHeader(PageMode.PACKAGE, packageElement))\n-                .addMainContent(div);\n-        return body;\n-    }\n-\n-    @Override\n-    public Content getContentHeader() {\n-        return new ContentBuilder();\n-    }\n-\n-    private void computePackageData() {\n-        relatedPackages = findRelatedPackages();\n-        boolean isSpecified = utils.isSpecified(packageElement);\n-        allClasses = filterClasses(isSpecified\n-                ? utils.getAllClasses(packageElement)\n-                : configuration.typeElementCatalog.allClasses(packageElement));\n-    }\n-\n-    private SortedSet<TypeElement> filterClasses(SortedSet<TypeElement> types) {\n-        List<TypeElement> typeList = types\n-                .stream()\n-                .filter(te -> utils.isCoreClass(te) && configuration.isGeneratedDoc(te))\n-                .collect(Collectors.toList());\n-        return utils.filterOutPrivateClasses(typeList, options.javafx());\n-    }\n-\n-    private List<PackageElement> findRelatedPackages() {\n-        String pkgName = packageElement.getQualifiedName().toString();\n-\n-        \/\/ always add superpackage\n-        int lastdot = pkgName.lastIndexOf('.');\n-        String pkgPrefix = lastdot > 0 ? pkgName.substring(0, lastdot) : null;\n-        List<PackageElement> packages = new ArrayList<>(\n-                filterPackages(p -> p.getQualifiedName().toString().equals(pkgPrefix)));\n-        boolean hasSuperPackage = !packages.isEmpty();\n-\n-        \/\/ add subpackages unless there are very many of them\n-        Pattern subPattern = Pattern.compile(pkgName.replace(\".\", \"\\\\.\") + \"\\\\.\\\\w+\");\n-        List<PackageElement> subpackages = filterPackages(\n-                p -> subPattern.matcher(p.getQualifiedName().toString()).matches());\n-        if (subpackages.size() <= MAX_SUBPACKAGES) {\n-            packages.addAll(subpackages);\n-        }\n-\n-        \/\/ only add sibling packages if there is a non-empty superpackage, we are beneath threshold,\n-        \/\/ and number of siblings is beneath threshold as well\n-        if (hasSuperPackage && pkgPrefix != null && packages.size() <= MAX_SIBLING_PACKAGES) {\n-            Pattern siblingPattern = Pattern.compile(pkgPrefix.replace(\".\", \"\\\\.\") + \"\\\\.\\\\w+\");\n-\n-            List<PackageElement> siblings = filterPackages(\n-                    p -> siblingPattern.matcher(p.getQualifiedName().toString()).matches());\n-            if (siblings.size() <= MAX_SIBLING_PACKAGES) {\n-                packages.addAll(siblings);\n-            }\n-        }\n-        return packages;\n-    }\n-\n-    @Override\n-    protected Navigation getNavBar(PageMode pageMode, Element element) {\n-        Content linkContent = getModuleLink(utils.elementUtils.getModuleOf(packageElement),\n-                contents.moduleLabel);\n-        return super.getNavBar(pageMode, element)\n-                .setNavLinkModule(linkContent)\n-                .setSubNavLinks(() -> List.of(\n-                        links.createLink(HtmlIds.PACKAGE_DESCRIPTION, contents.navDescription,\n-                                !utils.getFullBody(packageElement).isEmpty() && !options.noComment()),\n-                        links.createLink(HtmlIds.RELATED_PACKAGE_SUMMARY, contents.relatedPackages,\n-                                relatedPackages != null && !relatedPackages.isEmpty()),\n-                        links.createLink(HtmlIds.CLASS_SUMMARY, contents.navClassesAndInterfaces,\n-                                allClasses != null && !allClasses.isEmpty())));\n-    }\n-\n-    \/**\n-     * Add the package deprecation information to the documentation tree.\n-     *\n-     * @param div the content to which the deprecation information will be added\n-     *\/\n-    public void addDeprecationInfo(Content div) {\n-        List<? extends DeprecatedTree> deprs = utils.getDeprecatedTrees(packageElement);\n-        if (utils.isDeprecated(packageElement)) {\n-            CommentHelper ch = utils.getCommentHelper(packageElement);\n-            var deprDiv = HtmlTree.DIV(HtmlStyle.deprecationBlock);\n-            var deprPhrase = HtmlTree.SPAN(HtmlStyle.deprecatedLabel, getDeprecatedPhrase(packageElement));\n-            deprDiv.add(deprPhrase);\n-            if (!deprs.isEmpty()) {\n-                List<? extends DocTree> commentTags = ch.getDescription(deprs.get(0));\n-                if (!commentTags.isEmpty()) {\n-                    addInlineDeprecatedComment(packageElement, deprs.get(0), deprDiv);\n-                }\n-            }\n-            div.add(deprDiv);\n-        }\n-    }\n-\n-    @Override\n-    public Content getSummariesList() {\n-        return HtmlTree.UL(HtmlStyle.summaryList);\n-    }\n-\n-    @Override\n-    public void addRelatedPackagesSummary(Content summaryContent) {\n-        boolean showModules = configuration.showModules && hasRelatedPackagesInOtherModules(relatedPackages);\n-        TableHeader tableHeader= showModules\n-                ? new TableHeader(contents.moduleLabel, contents.packageLabel, contents.descriptionLabel)\n-                : new TableHeader(contents.packageLabel, contents.descriptionLabel);\n-        addPackageSummary(relatedPackages, contents.relatedPackages, tableHeader,\n-                summaryContent, showModules);\n-    }\n-\n-\n-    \/**\n-     * Add all types to the content.\n-     *\n-     * @param target the content to which the links will be added\n-     *\/\n-    public void addAllClassesAndInterfacesSummary(Content target) {\n-        var table = new Table<TypeElement>(HtmlStyle.summaryTable)\n-                .setHeader(new TableHeader(contents.classLabel, contents.descriptionLabel))\n-                .setColumnStyles(HtmlStyle.colFirst, HtmlStyle.colLast)\n-                .setId(HtmlIds.CLASS_SUMMARY)\n-                .setDefaultTab(contents.allClassesAndInterfacesLabel)\n-                .addTab(contents.interfaces, utils::isPlainInterface)\n-                .addTab(contents.classes, e -> utils.isNonThrowableClass(e))\n-                .addTab(contents.enums, utils::isEnum)\n-                .addTab(contents.records, e -> utils.isRecord(e))\n-                .addTab(contents.exceptionClasses, e -> utils.isThrowable(e))\n-                .addTab(contents.annotationTypes, utils::isAnnotationInterface);\n-        for (TypeElement typeElement : allClasses) {\n-            if (typeElement != null && utils.isCoreClass(typeElement)) {\n-                Content classLink = getLink(new HtmlLinkInfo(\n-                        configuration, HtmlLinkInfo.Kind.SHOW_TYPE_PARAMS_AND_BOUNDS, typeElement));\n-                ContentBuilder description = new ContentBuilder();\n-                addPreviewSummary(typeElement, description);\n-                if (utils.isDeprecated(typeElement)) {\n-                    description.add(getDeprecatedPhrase(typeElement));\n-                    List<? extends DeprecatedTree> tags = utils.getDeprecatedTrees(typeElement);\n-                    if (!tags.isEmpty()) {\n-                        addSummaryDeprecatedComment(typeElement, tags.get(0), description);\n-                    }\n-                } else {\n-                    addSummaryComment(typeElement, description);\n-                }\n-                table.addRow(typeElement, Arrays.asList(classLink, description));\n-            }\n-        }\n-        if (!table.isEmpty()) {\n-            target.add(HtmlTree.LI(table));\n-        }\n-    }\n-\n-    public void addPackageSummary(List<PackageElement> packages, Content label,\n-                                  TableHeader tableHeader, Content summaryContent,\n-                                  boolean showModules) {\n-        if (!packages.isEmpty()) {\n-            var table = new Table<Void>(HtmlStyle.summaryTable)\n-                    .setId(HtmlIds.RELATED_PACKAGE_SUMMARY)\n-                    .setCaption(label)\n-                    .setHeader(tableHeader);\n-            if (showModules) {\n-                table.setColumnStyles(HtmlStyle.colPlain, HtmlStyle.colFirst, HtmlStyle.colLast);\n-            } else {\n-                table.setColumnStyles(HtmlStyle.colFirst, HtmlStyle.colLast);\n-            }\n-\n-            for (PackageElement pkg : packages) {\n-                Content packageLink = getPackageLink(pkg, Text.of(pkg.getQualifiedName()));\n-                Content moduleLink = Text.EMPTY;\n-                if (showModules) {\n-                    ModuleElement module = (ModuleElement) pkg.getEnclosingElement();\n-                    if (module != null && !module.isUnnamed()) {\n-                        moduleLink = getModuleLink(module, Text.of(module.getQualifiedName()));\n-                    }\n-                }\n-                ContentBuilder description = new ContentBuilder();\n-                addPreviewSummary(pkg, description);\n-                if (utils.isDeprecated(pkg)) {\n-                    description.add(getDeprecatedPhrase(pkg));\n-                    List<? extends DeprecatedTree> tags = utils.getDeprecatedTrees(pkg);\n-                    if (!tags.isEmpty()) {\n-                        addSummaryDeprecatedComment(pkg, tags.get(0), description);\n-                    }\n-                } else {\n-                    addSummaryComment(pkg, description);\n-                }\n-                if (showModules) {\n-                    table.addRow(moduleLink, packageLink, description);\n-                } else {\n-                    table.addRow(packageLink, description);\n-                }\n-            }\n-            summaryContent.add(HtmlTree.LI(table));\n-        }\n-    }\n-\n-    @Override\n-    public void addPackageDescription(Content packageContent) {\n-        addPreviewInfo(packageElement, packageContent);\n-        if (!utils.getBody(packageElement).isEmpty()) {\n-            section.setId(HtmlIds.PACKAGE_DESCRIPTION);\n-            addDeprecationInfo(section);\n-            addInlineComment(packageElement, section);\n-        }\n-    }\n-\n-    @Override\n-    public void addPackageTags(Content packageContent) {\n-        addTagsInfo(packageElement, section);\n-        packageContent.add(section);\n-    }\n-\n-    @Override\n-    public void addPackageSignature(Content packageContent) {\n-        packageContent.add(new HtmlTree(TagName.HR));\n-        packageContent.add(Signatures.getPackageSignature(packageElement, this));\n-    }\n-\n-    @Override\n-    public void addPackageContent(Content packageContent) {\n-        bodyContents.addMainContent(packageContent);\n-    }\n-\n-    @Override\n-    public void addPackageFooter() {\n-        bodyContents.setFooter(getFooter());\n-    }\n-\n-    @Override\n-    public void printDocument(Content content) throws DocFileIOException {\n-        String description = getDescription(\"declaration\", packageElement);\n-        List<DocPath> localStylesheets = getLocalStylesheets(packageElement);\n-        content.add(bodyContents);\n-        printHtmlDocument(configuration.metakeywords.getMetaKeywords(packageElement),\n-                description, localStylesheets, content);\n-    }\n-\n-    @Override\n-    public Content getPackageSummary(Content summaryContent) {\n-        return HtmlTree.SECTION(HtmlStyle.summary, summaryContent);\n-    }\n-\n-    private boolean hasRelatedPackagesInOtherModules(List<PackageElement> relatedPackages) {\n-        final ModuleElement module = (ModuleElement) packageElement.getEnclosingElement();\n-        return relatedPackages.stream().anyMatch(pkg -> module != pkg.getEnclosingElement());\n-    }\n-\n-    private List<PackageElement> filterPackages(Predicate<? super PackageElement> filter) {\n-        return configuration.packages.stream()\n-                .filter(p -> p != packageElement && filter.test(p))\n-                .collect(Collectors.toList());\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/PackageWriterImpl.java","additions":0,"deletions":378,"binary":false,"changes":378,"status":"deleted"},{"patch":"@@ -41,1 +41,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/PreviewListWriter.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,318 @@\n+\/*\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html;\n+\n+import java.util.ArrayList;\n+import java.util.stream.Collectors;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+\n+import com.sun.source.doctree.DocCommentTree;\n+import com.sun.source.doctree.DocTree;\n+\n+import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n+import jdk.javadoc.internal.doclets.formats.html.markup.Entity;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n+import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n+import jdk.javadoc.internal.doclets.toolkit.BaseOptions;\n+import jdk.javadoc.internal.doclets.toolkit.CommentUtils;\n+import jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable;\n+\n+\/**\n+ * Writes property documentation in HTML format.\n+ *\/\n+public class PropertyWriter extends AbstractMemberWriter {\n+\n+    \/**\n+     * The index of the current property that is being documented at this point\n+     * in time.\n+     *\/\n+    private ExecutableElement currentProperty;\n+\n+    public PropertyWriter(ClassWriter writer) {\n+        super(writer, writer.typeElement);\n+    }\n+\n+    public void build(Content target) {\n+        buildPropertyDoc(target);\n+    }\n+\n+    \/**\n+     * Build the property documentation.\n+     *\n+     * @param detailsList the content to which the documentation will be added\n+     *\/\n+    protected void buildPropertyDoc(Content detailsList) {\n+        var properties  = getVisibleMembers(VisibleMemberTable.Kind.PROPERTIES);\n+        if (!properties.isEmpty()) {\n+            Content propertyDetailsHeader = getPropertyDetailsHeader(detailsList);\n+            Content memberList = getMemberList();\n+\n+            for (Element property : properties) {\n+                currentProperty = (ExecutableElement)property;\n+                Content propertyContent = getPropertyHeaderContent(currentProperty);\n+\n+                buildSignature(propertyContent);\n+                buildPropertyComments(propertyContent);\n+                buildTagInfo(propertyContent);\n+\n+                memberList.add(getMemberListItem(propertyContent));\n+            }\n+            Content propertyDetails = getPropertyDetails(propertyDetailsHeader, memberList);\n+            detailsList.add(propertyDetails);\n+        }\n+    }\n+\n+    \/**\n+     * Build the signature.\n+     *\n+     * @param propertyContent the content to which the documentation will be added\n+     *\/\n+    protected void buildSignature(Content propertyContent) {\n+        propertyContent.add(getSignature(currentProperty));\n+    }\n+\n+    \/**\n+     * Build the deprecation information.\n+     *\n+     * @param propertyContent the content to which the documentation will be added\n+     *\/\n+    protected void buildDeprecationInfo(Content propertyContent) {\n+        addDeprecated(currentProperty, propertyContent);\n+    }\n+\n+    \/**\n+     * Build the preview information.\n+     *\n+     * @param propertyContent the content to which the documentation will be added\n+     *\/\n+    protected void buildPreviewInfo(Content propertyContent) {\n+        addPreview(currentProperty, propertyContent);\n+    }\n+\n+    \/**\n+     * Build the comments for the property.  Do nothing if\n+     * {@link BaseOptions#noComment()} is set to true.\n+     *\n+     * @param propertyContent the content to which the documentation will be added\n+     *\/\n+    protected void buildPropertyComments(Content propertyContent) {\n+        if (!options.noComment()) {\n+            addComments(currentProperty, propertyContent);\n+        }\n+    }\n+\n+    \/**\n+     * Build the tag information.\n+     *\n+     * @param propertyContent the content to which the documentation will be added\n+     *\/\n+    protected void buildTagInfo(Content propertyContent) {\n+        CommentUtils cmtUtils = configuration.cmtUtils;\n+        DocCommentTree dct = utils.getDocCommentTree(currentProperty);\n+        var fullBody = dct.getFullBody();\n+        ArrayList<DocTree> blockTags = dct.getBlockTags().stream()\n+                .filter(t -> t.getKind() != DocTree.Kind.RETURN)\n+                .collect(Collectors.toCollection(ArrayList::new));\n+        String sig = \"#\" + currentProperty.getSimpleName() + \"()\";\n+        blockTags.add(cmtUtils.makeSeeTree(sig, currentProperty));\n+        \/\/ The property method is used as a proxy for the property\n+        \/\/ (which does not have an explicit element of its own.)\n+        \/\/ Temporarily override the doc comment for the property method\n+        \/\/ by removing the `@return` tag, which should not be displayed for\n+        \/\/ the property.\n+        CommentUtils.DocCommentInfo prev = cmtUtils.setDocCommentTree(currentProperty, fullBody, blockTags);\n+        try {\n+            addTags(currentProperty, propertyContent);\n+        } finally {\n+            cmtUtils.setDocCommentInfo(currentProperty, prev);\n+        }\n+    }\n+\n+\n+    @Override\n+    public Content getMemberSummaryHeader(TypeElement typeElement, Content content) {\n+        content.add(MarkerComments.START_OF_PROPERTY_SUMMARY);\n+        Content memberContent = new ContentBuilder();\n+        writer.addSummaryHeader(this, memberContent);\n+        return memberContent;\n+    }\n+\n+    @Override\n+    public void addSummary(Content summariesList, Content content) {\n+        writer.addSummary(HtmlStyle.propertySummary,\n+                HtmlIds.PROPERTY_SUMMARY, summariesList, content);\n+    }\n+\n+    protected Content getPropertyDetailsHeader(Content memberDetails) {\n+        memberDetails.add(MarkerComments.START_OF_PROPERTY_DETAILS);\n+        Content propertyDetailsContent = new ContentBuilder();\n+        var heading = HtmlTree.HEADING(Headings.TypeDeclaration.DETAILS_HEADING,\n+                contents.propertyDetailsLabel);\n+        propertyDetailsContent.add(heading);\n+        return propertyDetailsContent;\n+    }\n+\n+    protected Content getPropertyHeaderContent(ExecutableElement property) {\n+        Content content = new ContentBuilder();\n+        var heading = HtmlTree.HEADING(Headings.TypeDeclaration.MEMBER_HEADING,\n+                Text.of(utils.getPropertyLabel(name(property))));\n+        content.add(heading);\n+        return HtmlTree.SECTION(HtmlStyle.detail, content)\n+                .setId(htmlIds.forProperty(property));\n+    }\n+\n+    protected Content getSignature(ExecutableElement property) {\n+        return new Signatures.MemberSignature(property, this)\n+                .setType(utils.getReturnType(typeElement, property))\n+                .setAnnotations(writer.getAnnotationInfo(property, true))\n+                .toContent();\n+    }\n+\n+    protected void addDeprecated(ExecutableElement property, Content propertyContent) {\n+    }\n+\n+    protected void addPreview(ExecutableElement property, Content content) {\n+    }\n+\n+    protected void addComments(ExecutableElement property, Content propertyContent) {\n+        TypeElement holder = (TypeElement)property.getEnclosingElement();\n+        if (!utils.getFullBody(property).isEmpty()) {\n+            if (holder.equals(typeElement) ||\n+                    (!utils.isPublic(holder) || utils.isLinkable(holder))) {\n+                writer.addInlineComment(property, propertyContent);\n+            } else {\n+                if (!utils.hasHiddenTag(holder) && !utils.hasHiddenTag(property)) {\n+                    Content link =\n+                            writer.getDocLink(HtmlLinkInfo.Kind.PLAIN,\n+                                    holder, property,\n+                                    utils.isIncluded(holder)\n+                                            ? holder.getSimpleName() : holder.getQualifiedName());\n+                    var codeLink = HtmlTree.CODE(link);\n+                    var descriptionFromLabel = HtmlTree.SPAN(HtmlStyle.descriptionFromTypeLabel,\n+                            utils.isClass(holder)\n+                                    ? contents.descriptionFromClassLabel\n+                                    : contents.descriptionFromInterfaceLabel);\n+                    descriptionFromLabel.add(Entity.NO_BREAK_SPACE);\n+                    descriptionFromLabel.add(codeLink);\n+                    propertyContent.add(HtmlTree.DIV(HtmlStyle.block, descriptionFromLabel));\n+                }\n+                writer.addInlineComment(property, propertyContent);\n+            }\n+        }\n+    }\n+\n+    protected void addTags(ExecutableElement property, Content propertyContent) {\n+        writer.addTagsInfo(property, propertyContent);\n+    }\n+\n+    protected Content getPropertyDetails(Content memberDetailsHeader, Content memberDetails) {\n+        return writer.getDetailsListItem(\n+                HtmlTree.SECTION(HtmlStyle.propertyDetails)\n+                        .setId(HtmlIds.PROPERTY_DETAIL)\n+                        .add(memberDetailsHeader)\n+                        .add(memberDetails));\n+    }\n+\n+    @Override\n+    public void addSummaryLabel(Content content) {\n+        var label = HtmlTree.HEADING(Headings.TypeDeclaration.SUMMARY_HEADING,\n+                contents.propertySummaryLabel);\n+        content.add(label);\n+    }\n+\n+    @Override\n+    public TableHeader getSummaryTableHeader(Element member) {\n+        return new TableHeader(contents.typeLabel, contents.propertyLabel,\n+                contents.descriptionLabel);\n+    }\n+\n+    @Override\n+    protected Table<Element> createSummaryTable() {\n+        return new Table<Element>(HtmlStyle.summaryTable)\n+                .setCaption(contents.properties)\n+                .setHeader(getSummaryTableHeader(typeElement))\n+                .setColumnStyles(HtmlStyle.colFirst, HtmlStyle.colSecond, HtmlStyle.colLast);\n+    }\n+\n+    @Override\n+    public void addInheritedSummaryLabel(TypeElement typeElement, Content content) {\n+        Content classLink = writer.getPreQualifiedClassLink(\n+                HtmlLinkInfo.Kind.PLAIN, typeElement);\n+        Content label;\n+        if (options.summarizeOverriddenMethods()) {\n+            label = Text.of(utils.isClass(typeElement)\n+                    ? resources.getText(\"doclet.Properties_Declared_In_Class\")\n+                    : resources.getText(\"doclet.Properties_Declared_In_Interface\"));\n+        } else {\n+            label = Text.of(utils.isClass(typeElement)\n+                    ? resources.getText(\"doclet.Properties_Inherited_From_Class\")\n+                    : resources.getText(\"doclet.Properties_Inherited_From_Interface\"));\n+        }\n+        var labelHeading =\n+                HtmlTree.HEADING(Headings.TypeDeclaration.INHERITED_SUMMARY_HEADING, label)\n+                        .setId(htmlIds.forInheritedProperties(typeElement))\n+                        .add(Entity.NO_BREAK_SPACE)\n+                        .add(classLink);\n+        content.add(labelHeading);\n+    }\n+\n+    @Override\n+    protected void addSummaryLink(HtmlLinkInfo.Kind context, TypeElement typeElement, Element member,\n+                                  Content content) {\n+        Content memberLink = writer.getDocLink(context, typeElement,\n+                member,\n+                Text.of(utils.getPropertyLabel(name(member))),\n+                HtmlStyle.memberNameLink,\n+                true);\n+\n+        var code = HtmlTree.CODE(memberLink);\n+        content.add(code);\n+    }\n+\n+    @Override\n+    protected void addInheritedSummaryLink(TypeElement typeElement, Element member, Content target) {\n+        String mname = name(member);\n+        Content content = writer.getDocLink(HtmlLinkInfo.Kind.PLAIN, typeElement, member,\n+                utils.isProperty(mname) ? utils.getPropertyName(mname) : mname, true);\n+        target.add(content);\n+    }\n+\n+    @Override\n+    protected void addSummaryType(Element member, Content content) {\n+        addModifiersAndType(member, utils.getReturnType(typeElement, (ExecutableElement)member), content);\n+    }\n+\n+    @Override\n+    protected Content getSummaryLink(Element member) {\n+        return writer.getDocLink(HtmlLinkInfo.Kind.SHOW_PREVIEW, member,\n+                utils.getFullyQualifiedName(member));\n+    }\n+\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/PropertyWriter.java","additions":318,"deletions":0,"binary":false,"changes":318,"status":"added"},{"patch":"@@ -1,218 +0,0 @@\n-\/*\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.formats.html;\n-\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.ExecutableElement;\n-import javax.lang.model.element.TypeElement;\n-\n-import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n-import jdk.javadoc.internal.doclets.formats.html.markup.Entity;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n-import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.MemberSummaryWriter;\n-import jdk.javadoc.internal.doclets.toolkit.PropertyWriter;\n-\n-\/**\n- * Writes property documentation in HTML format.\n- *\/\n-public class PropertyWriterImpl extends AbstractMemberWriter\n-    implements PropertyWriter, MemberSummaryWriter {\n-\n-    public PropertyWriterImpl(SubWriterHolderWriter writer, TypeElement typeElement) {\n-        super(writer, typeElement);\n-    }\n-\n-    @Override\n-    public Content getMemberSummaryHeader(TypeElement typeElement, Content content) {\n-        content.add(MarkerComments.START_OF_PROPERTY_SUMMARY);\n-        Content memberContent = new ContentBuilder();\n-        writer.addSummaryHeader(this, memberContent);\n-        return memberContent;\n-    }\n-\n-    @Override\n-    public void addSummary(Content summariesList, Content content) {\n-        writer.addSummary(HtmlStyle.propertySummary,\n-                HtmlIds.PROPERTY_SUMMARY, summariesList, content);\n-    }\n-\n-    @Override\n-    public Content getPropertyDetailsHeader(Content memberDetails) {\n-        memberDetails.add(MarkerComments.START_OF_PROPERTY_DETAILS);\n-        Content propertyDetailsContent = new ContentBuilder();\n-        var heading = HtmlTree.HEADING(Headings.TypeDeclaration.DETAILS_HEADING,\n-                contents.propertyDetailsLabel);\n-        propertyDetailsContent.add(heading);\n-        return propertyDetailsContent;\n-    }\n-\n-    @Override\n-    public Content getPropertyHeaderContent(ExecutableElement property) {\n-        Content content = new ContentBuilder();\n-        var heading = HtmlTree.HEADING(Headings.TypeDeclaration.MEMBER_HEADING,\n-                Text.of(utils.getPropertyLabel(name(property))));\n-        content.add(heading);\n-        return HtmlTree.SECTION(HtmlStyle.detail, content)\n-                .setId(htmlIds.forProperty(property));\n-    }\n-\n-    @Override\n-    public Content getSignature(ExecutableElement property) {\n-        return new Signatures.MemberSignature(property, this)\n-                .setType(utils.getReturnType(typeElement, property))\n-                .setAnnotations(writer.getAnnotationInfo(property, true))\n-                .toContent();\n-    }\n-\n-    @Override\n-    public void addDeprecated(ExecutableElement property, Content propertyContent) {\n-    }\n-\n-    @Override\n-    public void addPreview(ExecutableElement property, Content content) {\n-    }\n-\n-    @Override\n-    public void addComments(ExecutableElement property, Content propertyContent) {\n-        TypeElement holder = (TypeElement)property.getEnclosingElement();\n-        if (!utils.getFullBody(property).isEmpty()) {\n-            if (holder.equals(typeElement) ||\n-                    (!utils.isPublic(holder) || utils.isLinkable(holder))) {\n-                writer.addInlineComment(property, propertyContent);\n-            } else {\n-                if (!utils.hasHiddenTag(holder) && !utils.hasHiddenTag(property)) {\n-                    Content link =\n-                            writer.getDocLink(HtmlLinkInfo.Kind.PLAIN,\n-                                    holder, property,\n-                                    utils.isIncluded(holder)\n-                                            ? holder.getSimpleName() : holder.getQualifiedName());\n-                    var codeLink = HtmlTree.CODE(link);\n-                    var descriptionFromLabel = HtmlTree.SPAN(HtmlStyle.descriptionFromTypeLabel,\n-                            utils.isClass(holder)\n-                                    ? contents.descriptionFromClassLabel\n-                                    : contents.descriptionFromInterfaceLabel);\n-                    descriptionFromLabel.add(Entity.NO_BREAK_SPACE);\n-                    descriptionFromLabel.add(codeLink);\n-                    propertyContent.add(HtmlTree.DIV(HtmlStyle.block, descriptionFromLabel));\n-                }\n-                writer.addInlineComment(property, propertyContent);\n-            }\n-        }\n-    }\n-\n-    @Override\n-    public void addTags(ExecutableElement property, Content propertyContent) {\n-        writer.addTagsInfo(property, propertyContent);\n-    }\n-\n-    @Override\n-    public Content getPropertyDetails(Content memberDetailsHeader, Content memberDetails) {\n-        return writer.getDetailsListItem(\n-                HtmlTree.SECTION(HtmlStyle.propertyDetails)\n-                        .setId(HtmlIds.PROPERTY_DETAIL)\n-                        .add(memberDetailsHeader)\n-                        .add(memberDetails));\n-    }\n-\n-    @Override\n-    public void addSummaryLabel(Content content) {\n-        var label = HtmlTree.HEADING(Headings.TypeDeclaration.SUMMARY_HEADING,\n-                contents.propertySummaryLabel);\n-        content.add(label);\n-    }\n-\n-    @Override\n-    public TableHeader getSummaryTableHeader(Element member) {\n-        return new TableHeader(contents.typeLabel, contents.propertyLabel,\n-                contents.descriptionLabel);\n-    }\n-\n-    @Override\n-    protected Table<Element> createSummaryTable() {\n-        return new Table<Element>(HtmlStyle.summaryTable)\n-                .setCaption(contents.properties)\n-                .setHeader(getSummaryTableHeader(typeElement))\n-                .setColumnStyles(HtmlStyle.colFirst, HtmlStyle.colSecond, HtmlStyle.colLast);\n-    }\n-\n-    @Override\n-    public void addInheritedSummaryLabel(TypeElement typeElement, Content content) {\n-        Content classLink = writer.getPreQualifiedClassLink(\n-                HtmlLinkInfo.Kind.PLAIN, typeElement);\n-        Content label;\n-        if (options.summarizeOverriddenMethods()) {\n-            label = Text.of(utils.isClass(typeElement)\n-                    ? resources.getText(\"doclet.Properties_Declared_In_Class\")\n-                    : resources.getText(\"doclet.Properties_Declared_In_Interface\"));\n-        } else {\n-            label = Text.of(utils.isClass(typeElement)\n-                    ? resources.getText(\"doclet.Properties_Inherited_From_Class\")\n-                    : resources.getText(\"doclet.Properties_Inherited_From_Interface\"));\n-        }\n-        var labelHeading =\n-                HtmlTree.HEADING(Headings.TypeDeclaration.INHERITED_SUMMARY_HEADING, label)\n-                        .setId(htmlIds.forInheritedProperties(typeElement))\n-                        .add(Entity.NO_BREAK_SPACE)\n-                        .add(classLink);\n-        content.add(labelHeading);\n-    }\n-\n-    @Override\n-    protected void addSummaryLink(HtmlLinkInfo.Kind context, TypeElement typeElement, Element member,\n-                                  Content content) {\n-        Content memberLink = writer.getDocLink(context, typeElement,\n-                member,\n-                Text.of(utils.getPropertyLabel(name(member))),\n-                HtmlStyle.memberNameLink,\n-                true);\n-\n-        var code = HtmlTree.CODE(memberLink);\n-        content.add(code);\n-    }\n-\n-    @Override\n-    protected void addInheritedSummaryLink(TypeElement typeElement, Element member, Content target) {\n-        String mname = name(member);\n-        Content content = writer.getDocLink(HtmlLinkInfo.Kind.PLAIN, typeElement, member,\n-                utils.isProperty(mname) ? utils.getPropertyName(mname) : mname, true);\n-        target.add(content);\n-    }\n-\n-    @Override\n-    protected void addSummaryType(Element member, Content content) {\n-        addModifiersAndType(member, utils.getReturnType(typeElement, (ExecutableElement)member), content);\n-    }\n-\n-    @Override\n-    protected Content getSummaryLink(Element member) {\n-        return writer.getDocLink(HtmlLinkInfo.Kind.SHOW_PREVIEW, member,\n-                utils.getFullyQualifiedName(member));\n-    }\n-\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/PropertyWriterImpl.java","additions":0,"deletions":218,"binary":false,"changes":218,"status":"deleted"},{"patch":"@@ -37,1 +37,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/SearchWriter.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,168 @@\n+\/*\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html;\n+\n+import java.util.List;\n+import java.util.SortedSet;\n+\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.type.TypeMirror;\n+\n+import com.sun.source.doctree.DocTree;\n+import com.sun.source.doctree.SerialFieldTree;\n+import com.sun.source.doctree.SerialTree;\n+\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n+import jdk.javadoc.internal.doclets.formats.html.markup.TagName;\n+import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n+import jdk.javadoc.internal.doclets.formats.html.taglets.TagletWriter;\n+\n+\/**\n+ * Generate serialized form for serializable fields.\n+ * Documentation denoted by the tags <code>serial<\/code> and\n+ * <code>serialField<\/code> is processed.\n+ *\/\n+public class SerialFieldWriter extends FieldWriter {\n+\n+    public SerialFieldWriter(SubWriterHolderWriter writer, TypeElement typeElement) {\n+        super(writer, typeElement);\n+    }\n+\n+    public SortedSet<VariableElement> members(TypeElement te) {\n+        return utils.serializableFields(te);\n+    }\n+\n+    protected Content getSerializableFieldsHeader() {\n+        return HtmlTree.UL(HtmlStyle.blockList);\n+    }\n+\n+    protected Content getFieldsContentHeader(boolean isLastContent) {\n+        return new HtmlTree(TagName.LI).setStyle(HtmlStyle.blockList);\n+    }\n+\n+    protected Content getSerializableFields(String heading, Content source) {\n+        var section = HtmlTree.SECTION(HtmlStyle.detail);\n+        if (!source.isEmpty()) {\n+            Content headingContent = Text.of(heading);\n+            var serialHeading = HtmlTree.HEADING(Headings.SerializedForm.CLASS_SUBHEADING, headingContent);\n+            section.add(serialHeading);\n+            section.add(source);\n+        }\n+        return HtmlTree.LI(section);\n+    }\n+\n+    protected void addMemberHeader(TypeMirror fieldType, String fieldName, Content content) {\n+        Content nameContent = Text.of(fieldName);\n+        var heading = HtmlTree.HEADING(Headings.SerializedForm.MEMBER_HEADING, nameContent);\n+        content.add(heading);\n+        var pre = new HtmlTree(TagName.PRE);\n+        Content fieldContent = writer.getLink(new HtmlLinkInfo(\n+                configuration, HtmlLinkInfo.Kind.LINK_TYPE_PARAMS_AND_BOUNDS, fieldType));\n+        pre.add(fieldContent);\n+        pre.add(\" \");\n+        pre.add(fieldName);\n+        content.add(pre);\n+    }\n+\n+    \/**\n+     * Add the deprecated information for this member.\n+     *\n+     * @param field the field to document.\n+     * @param content the content to which the deprecated info will be added\n+     *\/\n+    protected void addMemberDeprecatedInfo(VariableElement field, Content content) {\n+        addDeprecatedInfo(field, content);\n+    }\n+\n+    \/**\n+     * Add the description text for this member.\n+     *\n+     * @param field the field to document.\n+     * @param content the content to which the deprecated info will be added\n+     *\/\n+    protected void addMemberDescription(VariableElement field, Content content) {\n+        if (!utils.getFullBody(field).isEmpty()) {\n+            writer.addInlineComment(field, content);\n+        }\n+        List<? extends SerialTree> tags = utils.getSerialTrees(field);\n+        if (!tags.isEmpty() && !tags.get(0).getDescription().isEmpty()) {\n+            writer.addInlineComment(field, tags.get(0), content);\n+        }\n+    }\n+\n+    \/**\n+     * Add the description text for this member represented by the tag.\n+     *\n+     * @param serialFieldTag the field to document (represented by tag)\n+     * @param content the content to which the deprecated info will be added\n+     *\/\n+    protected void addMemberDescription(VariableElement field, SerialFieldTree serialFieldTag, Content content) {\n+        List<? extends DocTree> description = serialFieldTag.getDescription();\n+        if (!description.isEmpty()) {\n+            Content serialFieldContent = writer.commentTagsToContent(field,\n+                    description,\n+                    new TagletWriter.Context(false, false));\n+            var div = HtmlTree.DIV(HtmlStyle.block, serialFieldContent);\n+            content.add(div);\n+        }\n+    }\n+\n+    \/**\n+     * Add the tag information for this member.\n+     *\n+     * @param field the field to document.\n+     * @param content the content to which the member tags info will be added\n+     *\/\n+    protected void addMemberTags(VariableElement field, Content content) {\n+        Content tagContent = writer.getBlockTagOutput(field);\n+        if (!tagContent.isEmpty()) {\n+            var dl = HtmlTree.DL(HtmlStyle.notes);\n+            dl.add(tagContent);\n+            content.add(dl);\n+        }\n+    }\n+\n+    \/**\n+     * Check to see if overview details should be printed. If\n+     * nocomment option set or if there is no text to be printed\n+     * for deprecation info, comment or tags, do not print overview details.\n+     *\n+     * @param field the field to check overview details for.\n+     * @return true if overview details need to be printed\n+     *\/\n+    protected boolean shouldPrintOverview(VariableElement field) {\n+        if (!options.noComment()) {\n+            if(!utils.getFullBody(field).isEmpty() ||\n+                    writer.hasSerializationOverviewTags(field))\n+                return true;\n+        }\n+        if (utils.isDeprecated(field))\n+            return true;\n+        return false;\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/SerialFieldWriter.java","additions":168,"deletions":0,"binary":false,"changes":168,"status":"added"},{"patch":"@@ -0,0 +1,133 @@\n+\/*\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html;\n+\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n+import jdk.javadoc.internal.doclets.formats.html.markup.TagName;\n+import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n+import jdk.javadoc.internal.doclets.formats.html.taglets.TagletManager;\n+\n+\n+\/**\n+ * Generate serialized form for Serializable\/Externalizable methods.\n+ * Documentation denoted by the <code>serialData<\/code> tag is processed.\n+ *\/\n+public class SerialMethodWriter extends MethodWriter {\n+\n+    public SerialMethodWriter(SubWriterHolderWriter writer, TypeElement typeElement) {\n+        super(writer, typeElement);\n+    }\n+\n+    protected Content getSerializableMethodsHeader() {\n+        return HtmlTree.UL(HtmlStyle.blockList);\n+    }\n+\n+    protected Content getMethodsContentHeader(boolean isLastContent) {\n+        return new HtmlTree(TagName.LI);\n+    }\n+\n+    \/**\n+     * Add serializable methods.\n+     *\n+     * @param heading the heading for the section\n+     * @param source the content to be added to the serializable methods\n+     *        content\n+     * @return a content for the serializable methods content\n+     *\/\n+    protected Content getSerializableMethods(String heading, Content source) {\n+        Content headingContent = Text.of(heading);\n+        var serialHeading = HtmlTree.HEADING(Headings.SerializedForm.CLASS_SUBHEADING, headingContent);\n+        var section = HtmlTree.SECTION(HtmlStyle.detail, serialHeading);\n+        section.add(source);\n+        return HtmlTree.LI(section);\n+    }\n+\n+    \/**\n+     * Return the no customization message.\n+     *\n+     * @param msg the message to be displayed\n+     * @return no customization message content\n+     *\/\n+    protected Content getNoCustomizationMsg(String msg) {\n+        return Text.of(msg);\n+    }\n+\n+    \/**\n+     * Add the member header.\n+     *\n+     * @param member the method document to be listed\n+     * @param methodsContent the content to which the member header will be added\n+     *\/\n+    protected void addMemberHeader(ExecutableElement member, Content methodsContent) {\n+        Content memberContent = Text.of(name(member));\n+        var heading = HtmlTree.HEADING(Headings.SerializedForm.MEMBER_HEADING, memberContent);\n+        methodsContent.add(heading);\n+        methodsContent.add(getSignature(member));\n+    }\n+\n+    \/**\n+     * Add the deprecated information for this member.\n+     *\n+     * @param member the method to document.\n+     * @param methodsContent the content to which the deprecated info will be added\n+     *\/\n+    protected void addDeprecatedMemberInfo(ExecutableElement member, Content methodsContent) {\n+        addDeprecatedInfo(member, methodsContent);\n+    }\n+\n+    \/**\n+     * Add the description text for this member.\n+     *\n+     * @param member the method to document.\n+     * @param methodsContent the content to which the deprecated info will be added\n+     *\/\n+    protected void addMemberDescription(ExecutableElement member, Content methodsContent) {\n+        addComment(member, methodsContent);\n+    }\n+\n+    \/**\n+     * Add the tag information for this member.\n+     *\n+     * @param member the method to document.\n+     * @param methodsContent the content to which the member tags info will be added\n+     *\/\n+    protected void addMemberTags(ExecutableElement member, Content methodsContent) {\n+        TagletManager tagletManager = configuration.tagletManager;\n+        Content tagContent = writer.getBlockTagOutput(member, tagletManager.getSerializedFormTaglets());\n+        var dl = HtmlTree.DL(HtmlStyle.notes);\n+        dl.add(tagContent);\n+        methodsContent.add(dl);\n+        if (name(member).equals(\"writeExternal\")\n+                && utils.getSerialDataTrees(member).isEmpty()) {\n+            serialWarning(member, \"doclet.MissingSerialDataTag\",\n+                utils.getFullyQualifiedName(member.getEnclosingElement()), name(member));\n+        }\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/SerialMethodWriter.java","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"},{"patch":"@@ -0,0 +1,726 @@\n+\/*\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.PackageElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.type.TypeMirror;\n+\n+import com.sun.source.doctree.SerialFieldTree;\n+import com.sun.source.doctree.SerialTree;\n+\n+import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n+import jdk.javadoc.internal.doclets.formats.html.markup.Entity;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n+import jdk.javadoc.internal.doclets.formats.html.Navigation.PageMode;\n+import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n+import jdk.javadoc.internal.doclets.toolkit.DocletException;\n+import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocFileIOException;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocPaths;\n+import jdk.javadoc.internal.doclets.toolkit.util.IndexItem;\n+import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n+\n+\/**\n+ * Generates the Serialized Form Information Page, <i>serialized-form.html<\/i>.\n+ *\/\n+public class SerializedFormWriter extends SubWriterHolderWriter {\n+\n+    \/**\n+     * The writer for serializable fields.\n+     *\/\n+    private SerialFieldWriter fieldWriter;\n+\n+    \/**\n+     * The writer for serializable method documentation.\n+     *\/\n+    private SerialMethodWriter methodWriter;\n+\n+    \/**\n+     * The header for the serial version UID.  Save the string\n+     * here instead of the properties file because we do not want\n+     * this string to be localized.\n+     *\/\n+    private static final String SERIAL_VERSION_UID = \"serialVersionUID\";\n+    private static final String SERIAL_VERSION_UID_HEADER = SERIAL_VERSION_UID + \":\";\n+\n+    \/**\n+     * The current package being documented.\n+     *\/\n+    private PackageElement currentPackage;\n+\n+    \/**\n+     * The current class being documented.\n+     *\/\n+    private TypeElement currentTypeElement;\n+\n+    \/**\n+     * The current member being documented.\n+     *\/\n+    protected Element currentMember;\n+\n+    Set<TypeElement> visibleClasses;\n+\n+    \/**\n+     * @param configuration the configuration data for the doclet\n+     *\/\n+    public SerializedFormWriter(HtmlConfiguration configuration) {\n+        super(configuration, DocPaths.SERIALIZED_FORM, false);\n+        visibleClasses = configuration.getIncludedTypeElements();\n+        configuration.conditionalPages.add(HtmlConfiguration.ConditionalPage.SERIALIZED_FORM);\n+    }\n+\n+    \/**\n+     * Build the serialized form.\n+     *\n+     * @throws DocletException if there is a problem while building the documentation\n+     *\/\n+     void build() throws DocletException {\n+        SortedSet<TypeElement> rootclasses = new TreeSet<>(utils.comparators.makeGeneralPurposeComparator());\n+        rootclasses.addAll(configuration.getIncludedTypeElements());\n+        if (!serialClassFoundToDocument(rootclasses)) {\n+            \/\/Nothing to document.\n+            return;\n+        }\n+\n+        configuration.conditionalPages.add(HtmlConfiguration.ConditionalPage.SERIALIZED_FORM);\n+        writeGenerating();\n+\n+        buildSerializedForm();\n+    }\n+\n+    \/**\n+     * Build the serialized form.\n+     *\n+     * @throws DocletException if there is a problem while building the documentation\n+     *\/\n+    protected void buildSerializedForm() throws DocletException {\n+        Content content = getHeader(resources.getText(\n+                \"doclet.Serialized_Form\"));\n+\n+        buildSerializedFormSummaries();\n+\n+        addFooter();\n+        printDocument(content);\n+    }\n+\n+    \/**\n+     * Build the serialized form summaries.\n+     *\/\n+    protected void buildSerializedFormSummaries() {\n+        Content c = getSerializedSummariesHeader();\n+        for (PackageElement pkg : configuration.packages) {\n+            currentPackage = pkg;\n+\n+            buildPackageSerializedForm(c);\n+        }\n+        addSerializedContent(c);\n+    }\n+\n+    \/**\n+     * Build the package serialized form for the current package being processed.\n+     *\n+     * @param target the content to which the documentation will be added\n+     *\/\n+    protected void buildPackageSerializedForm(Content target) {\n+        Content packageSerializedHeader = getPackageSerializedHeader();\n+        SortedSet<TypeElement> classes = utils.getAllClassesUnfiltered(currentPackage);\n+        if (classes.isEmpty()) {\n+            return;\n+        }\n+        if (!serialInclude(utils, currentPackage)) {\n+            return;\n+        }\n+        if (!serialClassFoundToDocument(classes)) {\n+            return;\n+        }\n+\n+        buildPackageHeader(packageSerializedHeader);\n+        buildClassSerializedForm(packageSerializedHeader);\n+\n+        addPackageSerialized(target, packageSerializedHeader);\n+    }\n+\n+    \/**\n+     * Build the package header.\n+     *\n+     * @param target the content to which the documentation will be added\n+     *\/\n+    protected void buildPackageHeader(Content target) {\n+        target.add(getPackageHeader(currentPackage));\n+    }\n+\n+    \/**\n+     * Build the class serialized form.\n+     *\n+     * @param target the content to which the documentation will be added\n+     *\/\n+    protected void buildClassSerializedForm(Content target) {\n+        Content classSerializedHeader = getClassSerializedHeader();\n+        SortedSet<TypeElement> typeElements = utils.getAllClassesUnfiltered(currentPackage);\n+        for (TypeElement typeElement : typeElements) {\n+            currentTypeElement = typeElement;\n+            fieldWriter = getSerialFieldWriter(currentTypeElement);\n+            methodWriter = getSerialMethodWriter(currentTypeElement);\n+            if (utils.isClass(currentTypeElement) && utils.isSerializable(currentTypeElement)) {\n+                if (!serialClassInclude(utils, currentTypeElement)) {\n+                    continue;\n+                }\n+                Content classHeader = getClassHeader(currentTypeElement);\n+\n+                buildSerialUIDInfo(classHeader);\n+                buildClassContent(classHeader);\n+\n+                classSerializedHeader.add(getMember(classHeader));\n+            }\n+        }\n+        target.add(classSerializedHeader);\n+    }\n+\n+    \/**\n+     * Build the serial UID information for the given class.\n+     *\n+     * @param target the content to which the serial UID information will be added\n+     *\/\n+    protected void buildSerialUIDInfo(Content target) {\n+        Content serialUIDHeader = getSerialUIDInfoHeader();\n+        for (VariableElement field : utils.getFieldsUnfiltered(currentTypeElement)) {\n+            if (field.getSimpleName().toString().compareTo(SERIAL_VERSION_UID) == 0 &&\n+                    field.getConstantValue() != null) {\n+                addSerialUIDInfo(SERIAL_VERSION_UID_HEADER,\n+                        utils.constantValueExpression(field), serialUIDHeader);\n+                break;\n+            }\n+        }\n+        target.add(serialUIDHeader);\n+    }\n+\n+    \/**\n+     * Build the summaries for the methods and fields.\n+     *\n+     * @param target the content to which the documentation will be added\n+     *\/\n+    protected void buildClassContent(Content target) {\n+        Content classContent = getClassContentHeader();\n+\n+        buildSerializableMethods(classContent);\n+        buildFieldHeader(classContent);\n+        buildSerializableFields(classContent);\n+\n+        target.add(classContent);\n+    }\n+\n+    \/**\n+     * Build the summaries for the methods that belong to the given class.\n+     *\n+     * @param target the content to which the documentation will be added\n+     *\/\n+    protected void buildSerializableMethods(Content target) {\n+        Content serializableMethodsHeader = methodWriter.getSerializableMethodsHeader();\n+        for (var i = utils.serializationMethods(currentTypeElement).iterator(); i.hasNext(); ) {\n+            currentMember = i.next();\n+            Content methodsContent = methodWriter.getMethodsContentHeader(!i.hasNext());\n+\n+            buildMethodSubHeader(methodsContent);\n+            buildDeprecatedMethodInfo(methodsContent);\n+            buildMethodInfo(methodsContent);\n+\n+            serializableMethodsHeader.add(methodsContent);\n+        }\n+        if (!utils.serializationMethods(currentTypeElement).isEmpty()) {\n+            target.add(methodWriter.getSerializableMethods(\n+                    resources.getText(\"doclet.Serialized_Form_methods\"),\n+                    serializableMethodsHeader));\n+            if (utils.isSerializable(currentTypeElement) && !utils.isExternalizable(currentTypeElement)) {\n+                if (utils.serializationMethods(currentTypeElement).isEmpty()) {\n+                    Content noCustomizationMsg = methodWriter.getNoCustomizationMsg(\n+                            resources.getText(\"doclet.Serializable_no_customization\"));\n+                    target.add(methodWriter.getSerializableMethods(\n+                            resources.getText(\"doclet.Serialized_Form_methods\"),\n+                            noCustomizationMsg));\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Build the method sub header.\n+     *\n+     * @param methodsContent the content to which the documentation will be added\n+     *\/\n+    protected void buildMethodSubHeader(Content methodsContent)  {\n+        methodWriter.addMemberHeader((ExecutableElement)currentMember, methodsContent);\n+    }\n+\n+    \/**\n+     * Build the deprecated method description.\n+     *\n+     * @param methodsContent the content to which the documentation will be added\n+     *\/\n+    protected void buildDeprecatedMethodInfo(Content methodsContent) {\n+        methodWriter.addDeprecatedMemberInfo((ExecutableElement)currentMember, methodsContent);\n+    }\n+\n+    \/**\n+     * Build the information for the method.\n+     *\n+     * @param methodsContent the content to which the documentation will be added\n+     *\/\n+    protected void buildMethodInfo(Content methodsContent) {\n+        if (options.noComment()) {\n+            return;\n+        }\n+\n+        buildMethodDescription(methodsContent);\n+        buildMethodTags(methodsContent);\n+    }\n+\n+    \/**\n+     * Build method description.\n+     *\n+     * @param methodsContent the content to which the documentation will be added\n+     *\/\n+    protected void buildMethodDescription(Content methodsContent) {\n+        methodWriter.addMemberDescription((ExecutableElement)currentMember, methodsContent);\n+    }\n+\n+    \/**\n+     * Build the method tags.\n+     *\n+     * @param methodsContent the content to which the documentation will be added\n+     *\/\n+    protected void buildMethodTags(Content methodsContent) {\n+        methodWriter.addMemberTags((ExecutableElement)currentMember, methodsContent);\n+        ExecutableElement method = (ExecutableElement)currentMember;\n+        if (method.getSimpleName().toString().compareTo(\"writeExternal\") == 0\n+                && utils.getSerialDataTrees(method).isEmpty()) {\n+            if (options.serialWarn()) {\n+                TypeElement encl  = (TypeElement) method.getEnclosingElement();\n+                messages.warning(currentMember,\n+                        \"doclet.MissingSerialDataTag\", encl.getQualifiedName().toString(),\n+                        method.getSimpleName().toString());\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Build the field header.\n+     *\n+     * @param classContent the content to which the documentation will be added\n+     *\/\n+    protected void buildFieldHeader(Content classContent) {\n+        if (!utils.serializableFields(currentTypeElement).isEmpty()) {\n+            buildFieldSerializationOverview(currentTypeElement, classContent);\n+        }\n+    }\n+\n+    \/**\n+     * Build the serialization overview for the given class.\n+     *\n+     * @param typeElement the class to print the overview for.\n+     * @param classContent the content to which the documentation will be added\n+     *\/\n+    public void buildFieldSerializationOverview(TypeElement typeElement, Content classContent) {\n+        if (utils.definesSerializableFields(typeElement)) {\n+            VariableElement ve = utils.serializableFields(typeElement).first();\n+            \/\/ Check to see if there are inline comments, tags or deprecation\n+            \/\/ information to be printed.\n+            if (fieldWriter.shouldPrintOverview(ve)) {\n+                Content serializableFieldsHeader = fieldWriter.getSerializableFieldsHeader();\n+                Content fieldsOverviewContent = fieldWriter.getFieldsContentHeader(true);\n+                fieldWriter.addMemberDeprecatedInfo(ve, fieldsOverviewContent);\n+                if (!options.noComment()) {\n+                    fieldWriter.addMemberDescription(ve, fieldsOverviewContent);\n+                    fieldWriter.addMemberTags(ve, fieldsOverviewContent);\n+                }\n+                serializableFieldsHeader.add(fieldsOverviewContent);\n+                classContent.add(fieldWriter.getSerializableFields(\n+                        resources.getText(\"doclet.Serialized_Form_class\"),\n+                        serializableFieldsHeader));\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Build the summaries for the fields that belong to the given class.\n+     *\n+     * @param target the content to which the documentation will be added\n+     *\/\n+    protected void buildSerializableFields(Content target) {\n+        Collection<VariableElement> members = utils.serializableFields(currentTypeElement);\n+        if (!members.isEmpty()) {\n+            Content serializableFieldsHeader = fieldWriter.getSerializableFieldsHeader();\n+            for (var i = members.iterator(); i.hasNext();) {\n+                currentMember = i.next();\n+                if (!utils.definesSerializableFields(currentTypeElement)) {\n+                    Content fieldsContent = fieldWriter.getFieldsContentHeader(!i.hasNext());\n+\n+                    buildFieldSubHeader(fieldsContent);\n+                    buildFieldDeprecationInfo(fieldsContent);\n+                    buildFieldInfo(fieldsContent);\n+\n+                    serializableFieldsHeader.add(fieldsContent);\n+                } else {\n+                    buildSerialFieldTagsInfo(serializableFieldsHeader);\n+                }\n+            }\n+            target.add(fieldWriter.getSerializableFields(\n+                    resources.getText(\"doclet.Serialized_Form_fields\"),\n+                    serializableFieldsHeader));\n+        }\n+    }\n+\n+    \/**\n+     * Build the field sub header.\n+     *\n+     * @param fieldsContent the content to which the documentation will be added\n+     *\/\n+    protected void buildFieldSubHeader(Content fieldsContent) {\n+        if (!utils.definesSerializableFields(currentTypeElement)) {\n+            VariableElement field = (VariableElement) currentMember;\n+            fieldWriter.addMemberHeader(field.asType(),\n+                    utils.getSimpleName(field),\n+                    fieldsContent);\n+        }\n+    }\n+\n+    \/**\n+     * Build the field deprecation information.\n+     *\n+     * @param fieldsContent the content to which the documentation will be added\n+     *\/\n+    protected void buildFieldDeprecationInfo(Content fieldsContent) {\n+        if (!utils.definesSerializableFields(currentTypeElement)) {\n+            fieldWriter.addMemberDeprecatedInfo((VariableElement)currentMember,\n+                    fieldsContent);\n+        }\n+    }\n+\n+    \/**\n+     * Build the serial field tags information.\n+     *\n+     * @param target the content to which the documentation will be added\n+     *\/\n+    protected void buildSerialFieldTagsInfo(Content target) {\n+        if (options.noComment()) {\n+            return;\n+        }\n+        VariableElement field = (VariableElement)currentMember;\n+        \/\/ Process Serializable Fields specified as array of\n+        \/\/ ObjectStreamFields. Print a member for each serialField tag.\n+        \/\/ (There should be one serialField tag per ObjectStreamField\n+        \/\/ element.)\n+        SortedSet<SerialFieldTree> tags = new TreeSet<>(utils.comparators.makeSerialFieldTreeComparator());\n+        \/\/ sort the elements\n+        tags.addAll(utils.getSerialFieldTrees(field));\n+\n+        CommentHelper ch = utils.getCommentHelper(field);\n+        for (SerialFieldTree tag : tags) {\n+            if (tag.getName() == null || tag.getType() == null)  \/\/ ignore malformed @serialField tags\n+                continue;\n+            Content fieldsContent = fieldWriter.getFieldsContentHeader(tag.equals(tags.last()));\n+            TypeMirror type = ch.getReferencedType(tag);\n+            fieldWriter.addMemberHeader(type, tag.getName().getName().toString(), fieldsContent);\n+            fieldWriter.addMemberDescription(field, tag, fieldsContent);\n+            target.add(fieldsContent);\n+        }\n+    }\n+\n+    \/**\n+     * Build the field information.\n+     *\n+     * @param fieldsContent the content to which the documentation will be added\n+     *\/\n+    protected void buildFieldInfo(Content fieldsContent) {\n+        if (options.noComment()) {\n+            return;\n+        }\n+        VariableElement field = (VariableElement)currentMember;\n+        TypeElement te = utils.getEnclosingTypeElement(currentMember);\n+        \/\/ Process default Serializable field.\n+        if ((utils.getSerialTrees(field).isEmpty()) \/*&& !field.isSynthetic()*\/\n+                && options.serialWarn()) {\n+            messages.warning(field,\n+                    \"doclet.MissingSerialTag\", utils.getFullyQualifiedName(te),\n+                    utils.getSimpleName(field));\n+        }\n+        fieldWriter.addMemberDescription(field, fieldsContent);\n+        fieldWriter.addMemberTags(field, fieldsContent);\n+    }\n+\n+    \/**\n+     * Returns true if the given Element should be included\n+     * in the serialized form.\n+     *\n+     * @param utils the utils object\n+     * @param element the Element object to check for serializability\n+     * @return true if the element should be included in the serial form\n+     *\/\n+    public static boolean serialInclude(Utils utils, Element element) {\n+        if (element == null) {\n+            return false;\n+        }\n+        return utils.isClass(element)\n+                ? serialClassInclude(utils, (TypeElement)element)\n+                : serialDocInclude(utils, element);\n+    }\n+\n+    \/**\n+     * Returns true if the given TypeElement should be included\n+     * in the serialized form.\n+     *\n+     * @param te the TypeElement object to check for serializability.\n+     *\/\n+    private static boolean serialClassInclude(Utils utils, TypeElement te) {\n+        if (utils.isEnum(te)) {\n+            return false;\n+        }\n+        if (utils.isSerializable(te)) {\n+            if (utils.hasDocCommentTree(te) && !utils.getSerialTrees(te).isEmpty()) {\n+                return serialDocInclude(utils, te);\n+            } else {\n+                return utils.isPublic(te) || utils.isProtected(te);\n+            }\n+        }\n+        return false;\n+    }\n+\n+    \/**\n+     * Return true if the given Element should be included\n+     * in the serialized form.\n+     *\n+     * @param element the Element to check for serializability.\n+     *\/\n+    private static boolean serialDocInclude(Utils utils, Element element) {\n+        if (utils.isEnum(element)) {\n+            return false;\n+        }\n+        List<? extends SerialTree> serial = utils.getSerialTrees(element);\n+        if (!serial.isEmpty()) {\n+            \/\/ look for `@serial include|exclude`\n+            String serialtext = Utils.toLowerCase(serial.get(0).toString());\n+            if (serialtext.contains(\"exclude\")) {\n+                return false;\n+            } else if (serialtext.contains(\"include\")) {\n+                return true;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    \/**\n+     * Return true if any of the given typeElements have a {@code @serial include} tag.\n+     *\n+     * @param classes the typeElements to check.\n+     * @return true if any of the given typeElements have a {@code @serial include} tag.\n+     *\/\n+    private boolean serialClassFoundToDocument(SortedSet<TypeElement> classes) {\n+        for (TypeElement aClass : classes) {\n+            if (serialClassInclude(utils, aClass)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    \/**\n+     * Get the given header.\n+     *\n+     * @param header the header to write\n+     * @return the body content\n+     *\/\n+     Content getHeader(String header) {\n+        HtmlTree body = getBody(getWindowTitle(header));\n+        Content h1Content = Text.of(header);\n+        var heading = HtmlTree.HEADING_TITLE(Headings.PAGE_TITLE_HEADING,\n+                HtmlStyle.title, h1Content);\n+        var div = HtmlTree.DIV(HtmlStyle.header, heading);\n+        bodyContents.setHeader(getHeader(PageMode.SERIALIZED_FORM))\n+                .addMainContent(div);\n+        return body;\n+    }\n+\n+    \/**\n+     * Get the serialized form summaries header.\n+     *\n+     * @return the serialized form summaries header\n+     *\/\n+     Content getSerializedSummariesHeader() {\n+        return HtmlTree.UL(HtmlStyle.blockList);\n+    }\n+\n+    \/**\n+     * Get the package serialized form header.\n+     *\n+     * @return the package serialized form header tree\n+     *\/\n+     Content getPackageSerializedHeader() {\n+        return HtmlTree.SECTION(HtmlStyle.serializedPackageContainer);\n+    }\n+\n+     Content getPackageHeader(PackageElement packageElement) {\n+        var heading = HtmlTree.HEADING_TITLE(Headings.SerializedForm.PACKAGE_HEADING,\n+                contents.packageLabel);\n+        heading.add(Entity.NO_BREAK_SPACE);\n+        heading.add(getPackageLink(packageElement, Text.of(utils.getPackageName(packageElement))));\n+        return heading;\n+    }\n+\n+     Content getClassSerializedHeader() {\n+        return HtmlTree.UL(HtmlStyle.blockList);\n+    }\n+\n+    \/**\n+     * Checks if a class is generated and is visible.\n+     *\n+     * @param typeElement the class being processed.\n+     * @return true if the class, that is being processed, is generated and is visible.\n+     *\/\n+    public boolean isVisibleClass(TypeElement typeElement) {\n+        return visibleClasses.contains(typeElement) && configuration.isGeneratedDoc(typeElement)\n+                && !utils.hasHiddenTag(typeElement);\n+    }\n+\n+     Content getClassHeader(TypeElement typeElement) {\n+        Content classLink = (isVisibleClass(typeElement))\n+                ? getLink(new HtmlLinkInfo(configuration, HtmlLinkInfo.Kind.PLAIN, typeElement)\n+                        .label(configuration.getClassName(typeElement)))\n+                : Text.of(utils.getFullyQualifiedName(typeElement));\n+        var section = HtmlTree.SECTION(HtmlStyle.serializedClassDetails)\n+                .setId(htmlIds.forClass(typeElement));\n+        Content superClassLink = typeElement.getSuperclass() != null\n+                ? getLink(new HtmlLinkInfo(configuration, HtmlLinkInfo.Kind.LINK_TYPE_PARAMS_AND_BOUNDS,\n+                        typeElement.getSuperclass()))\n+                : null;\n+        Content interfaceLink = getLink(new HtmlLinkInfo(configuration, HtmlLinkInfo.Kind.LINK_TYPE_PARAMS_AND_BOUNDS,\n+                utils.isExternalizable(typeElement)\n+                        ? utils.getExternalizableType()\n+                        : utils.getSerializableType()));\n+\n+        \/\/ Print the heading.\n+        Content className = new ContentBuilder();\n+        className.add(utils.getTypeElementKindName(typeElement, false));\n+        className.add(Entity.NO_BREAK_SPACE);\n+        className.add(classLink);\n+        section.add(HtmlTree.HEADING(Headings.SerializedForm.CLASS_HEADING, className));\n+        \/\/ Print a simplified signature.\n+        Content signature = new ContentBuilder();\n+        signature.add(\"class \");\n+        signature.add(typeElement.getSimpleName());\n+        signature.add(\" extends \");\n+        signature.add(superClassLink);\n+        signature.add(\" implements \");\n+        signature.add(interfaceLink);\n+        section.add(HtmlTree.DIV(HtmlStyle.typeSignature, signature));\n+        return section;\n+    }\n+\n+     Content getSerialUIDInfoHeader() {\n+        return HtmlTree.DL(HtmlStyle.nameValue);\n+    }\n+\n+    \/**\n+     * Adds the serial UID info.\n+     *\n+     * @param header the header that will show up before the UID.\n+     * @param serialUID the serial UID to print.\n+     * @param target the serial UID content to which the serial UID\n+     *               content will be added\n+     *\/\n+     void addSerialUIDInfo(String header,\n+                                 String serialUID,\n+                                 Content target)\n+    {\n+        Content headerContent = Text.of(header);\n+        target.add(HtmlTree.DT(headerContent));\n+        Content serialContent = Text.of(serialUID);\n+        target.add(HtmlTree.DD(serialContent));\n+    }\n+\n+     Content getClassContentHeader() {\n+        return HtmlTree.UL(HtmlStyle.blockList);\n+    }\n+\n+    \/**\n+     * Add the serialized content section.\n+     *\n+     * @param source the serialized content to be added\n+     *\/\n+     void addSerializedContent(Content source) {\n+        bodyContents.addMainContent(source);\n+    }\n+\n+     void addPackageSerialized(Content serializedSummaries,\n+                                     Content packageSerialized)\n+    {\n+        serializedSummaries.add(HtmlTree.LI(packageSerialized));\n+    }\n+\n+    \/**\n+     * Add the footer.\n+     *\/\n+     void addFooter() {\n+        bodyContents.setFooter(getFooter());\n+    }\n+\n+     void printDocument(Content source) throws DocFileIOException {\n+        source.add(bodyContents);\n+        printHtmlDocument(null, \"serialized forms\", source);\n+\n+        if (configuration.mainIndex != null) {\n+            configuration.mainIndex.add(IndexItem.of(IndexItem.Category.TAGS,\n+                    resources.getText(\"doclet.Serialized_Form\"), path));\n+        }\n+    }\n+\n+    \/**\n+     * Return an instance of a SerialFieldWriter.\n+     *\n+     * @return an instance of a SerialFieldWriter.\n+     *\/\n+     SerialFieldWriter getSerialFieldWriter(TypeElement typeElement) {\n+        return new SerialFieldWriter(this, typeElement);\n+    }\n+\n+    \/**\n+     * Return an instance of a SerialMethodWriter.\n+     *\n+     * @return an instance of a SerialMethodWriter.\n+     *\/\n+     SerialMethodWriter getSerialMethodWriter(TypeElement typeElement) {\n+        return new SerialMethodWriter(this, typeElement);\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/SerializedFormWriter.java","additions":726,"deletions":0,"binary":false,"changes":726,"status":"added"},{"patch":"@@ -1,244 +0,0 @@\n-\/*\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.formats.html;\n-\n-import java.util.Set;\n-\n-import javax.lang.model.element.PackageElement;\n-import javax.lang.model.element.TypeElement;\n-\n-import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n-import jdk.javadoc.internal.doclets.formats.html.markup.Entity;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n-import jdk.javadoc.internal.doclets.formats.html.Navigation.PageMode;\n-import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.SerializedFormWriter;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocFileIOException;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocPaths;\n-import jdk.javadoc.internal.doclets.toolkit.util.IndexItem;\n-\n-\/**\n- * Generates the Serialized Form Information Page, <i>serialized-form.html<\/i>.\n- *\/\n-public class SerializedFormWriterImpl extends SubWriterHolderWriter\n-    implements SerializedFormWriter {\n-\n-    Set<TypeElement> visibleClasses;\n-\n-    \/**\n-     * @param configuration the configuration data for the doclet\n-     *\/\n-    public SerializedFormWriterImpl(HtmlConfiguration configuration) {\n-        super(configuration, DocPaths.SERIALIZED_FORM);\n-        visibleClasses = configuration.getIncludedTypeElements();\n-        configuration.conditionalPages.add(HtmlConfiguration.ConditionalPage.SERIALIZED_FORM);\n-    }\n-\n-    \/**\n-     * Get the given header.\n-     *\n-     * @param header the header to write\n-     * @return the body content\n-     *\/\n-    @Override\n-    public Content getHeader(String header) {\n-        HtmlTree body = getBody(getWindowTitle(header));\n-        Content h1Content = Text.of(header);\n-        var heading = HtmlTree.HEADING_TITLE(Headings.PAGE_TITLE_HEADING,\n-                HtmlStyle.title, h1Content);\n-        var div = HtmlTree.DIV(HtmlStyle.header, heading);\n-        bodyContents.setHeader(getHeader(PageMode.SERIALIZED_FORM))\n-                .addMainContent(div);\n-        return body;\n-    }\n-\n-    \/**\n-     * Get the serialized form summaries header.\n-     *\n-     * @return the serialized form summaries header\n-     *\/\n-    @Override\n-    public Content getSerializedSummariesHeader() {\n-        return HtmlTree.UL(HtmlStyle.blockList);\n-    }\n-\n-    \/**\n-     * Get the package serialized form header.\n-     *\n-     * @return the package serialized form header tree\n-     *\/\n-    @Override\n-    public Content getPackageSerializedHeader() {\n-        return HtmlTree.SECTION(HtmlStyle.serializedPackageContainer);\n-    }\n-\n-    @Override\n-    public Content getPackageHeader(PackageElement packageElement) {\n-        var heading = HtmlTree.HEADING_TITLE(Headings.SerializedForm.PACKAGE_HEADING,\n-                contents.packageLabel);\n-        heading.add(Entity.NO_BREAK_SPACE);\n-        heading.add(getPackageLink(packageElement, Text.of(utils.getPackageName(packageElement))));\n-        return heading;\n-    }\n-\n-    @Override\n-    public Content getClassSerializedHeader() {\n-        return HtmlTree.UL(HtmlStyle.blockList);\n-    }\n-\n-    \/**\n-     * Checks if a class is generated and is visible.\n-     *\n-     * @param typeElement the class being processed.\n-     * @return true if the class, that is being processed, is generated and is visible.\n-     *\/\n-    public boolean isVisibleClass(TypeElement typeElement) {\n-        return visibleClasses.contains(typeElement) && configuration.isGeneratedDoc(typeElement)\n-                && !utils.hasHiddenTag(typeElement);\n-    }\n-\n-    @Override\n-    public Content getClassHeader(TypeElement typeElement) {\n-        Content classLink = (isVisibleClass(typeElement))\n-                ? getLink(new HtmlLinkInfo(configuration, HtmlLinkInfo.Kind.PLAIN, typeElement)\n-                        .label(configuration.getClassName(typeElement)))\n-                : Text.of(utils.getFullyQualifiedName(typeElement));\n-        var section = HtmlTree.SECTION(HtmlStyle.serializedClassDetails)\n-                .setId(htmlIds.forClass(typeElement));\n-        Content superClassLink = typeElement.getSuperclass() != null\n-                ? getLink(new HtmlLinkInfo(configuration, HtmlLinkInfo.Kind.LINK_TYPE_PARAMS_AND_BOUNDS,\n-                        typeElement.getSuperclass()))\n-                : null;\n-        Content interfaceLink = getLink(new HtmlLinkInfo(configuration, HtmlLinkInfo.Kind.LINK_TYPE_PARAMS_AND_BOUNDS,\n-                utils.isExternalizable(typeElement)\n-                        ? utils.getExternalizableType()\n-                        : utils.getSerializableType()));\n-\n-        \/\/ Print the heading.\n-        Content className = new ContentBuilder();\n-        className.add(utils.getTypeElementKindName(typeElement, false));\n-        className.add(Entity.NO_BREAK_SPACE);\n-        className.add(classLink);\n-        section.add(HtmlTree.HEADING(Headings.SerializedForm.CLASS_HEADING, className));\n-        \/\/ Print a simplified signature.\n-        Content signature = new ContentBuilder();\n-        signature.add(\"class \");\n-        signature.add(typeElement.getSimpleName());\n-        signature.add(\" extends \");\n-        signature.add(superClassLink);\n-        signature.add(\" implements \");\n-        signature.add(interfaceLink);\n-        section.add(HtmlTree.DIV(HtmlStyle.typeSignature, signature));\n-        return section;\n-    }\n-\n-    @Override\n-    public Content getSerialUIDInfoHeader() {\n-        return HtmlTree.DL(HtmlStyle.nameValue);\n-    }\n-\n-    \/**\n-     * Adds the serial UID info.\n-     *\n-     * @param header the header that will show up before the UID.\n-     * @param serialUID the serial UID to print.\n-     * @param target the serial UID content to which the serial UID\n-     *               content will be added\n-     *\/\n-    @Override\n-    public void addSerialUIDInfo(String header,\n-                                 String serialUID,\n-                                 Content target)\n-    {\n-        Content headerContent = Text.of(header);\n-        target.add(HtmlTree.DT(headerContent));\n-        Content serialContent = Text.of(serialUID);\n-        target.add(HtmlTree.DD(serialContent));\n-    }\n-\n-    @Override\n-    public Content getClassContentHeader() {\n-        return HtmlTree.UL(HtmlStyle.blockList);\n-    }\n-\n-    \/**\n-     * Add the serialized content section.\n-     *\n-     * @param source the serialized content to be added\n-     *\/\n-    @Override\n-    public void addSerializedContent(Content source) {\n-        bodyContents.addMainContent(source);\n-    }\n-\n-    @Override\n-    public void addPackageSerialized(Content serializedSummaries,\n-                                     Content packageSerialized)\n-    {\n-        serializedSummaries.add(HtmlTree.LI(packageSerialized));\n-    }\n-\n-    \/**\n-     * Add the footer.\n-     *\/\n-    @Override\n-    public void addFooter() {\n-        bodyContents.setFooter(getFooter());\n-    }\n-\n-    @Override\n-    public void printDocument(Content source) throws DocFileIOException {\n-        source.add(bodyContents);\n-        printHtmlDocument(null, \"serialized forms\", source);\n-\n-        if (configuration.mainIndex != null) {\n-            configuration.mainIndex.add(IndexItem.of(IndexItem.Category.TAGS,\n-                    resources.getText(\"doclet.Serialized_Form\"), path));\n-        }\n-    }\n-\n-    \/**\n-     * Return an instance of a SerialFieldWriter.\n-     *\n-     * @return an instance of a SerialFieldWriter.\n-     *\/\n-    @Override\n-    public SerialFieldWriter getSerialFieldWriter(TypeElement typeElement) {\n-        return new HtmlSerialFieldWriter(this, typeElement);\n-    }\n-\n-    \/**\n-     * Return an instance of a SerialMethodWriter.\n-     *\n-     * @return an instance of a SerialMethodWriter.\n-     *\/\n-    @Override\n-    public SerialMethodWriter getSerialMethodWriter(TypeElement typeElement) {\n-        return new HtmlSerialMethodWriter(this, typeElement);\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/SerializedFormWriterImpl.java","additions":0,"deletions":244,"binary":false,"changes":244,"status":"deleted"},{"patch":"@@ -35,1 +35,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n@@ -66,1 +65,1 @@\n-    public static Content getModuleSignature(ModuleElement mdle, ModuleWriterImpl moduleWriter) {\n+    public static Content getModuleSignature(ModuleElement mdle, ModuleWriter moduleWriter) {\n@@ -83,1 +82,1 @@\n-    public static Content getPackageSignature(PackageElement pkg, PackageWriterImpl pkgWriter) {\n+    public static Content getPackageSignature(PackageElement pkg, PackageWriter pkgWriter) {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/Signatures.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -46,1 +46,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/SourceToHTMLConverter.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n@@ -52,1 +51,1 @@\n- * @see ClassWriterImpl\n+ * @see ClassWriter\n@@ -65,0 +64,4 @@\n+    public SubWriterHolderWriter(HtmlConfiguration configuration, DocPath filename, boolean generating) {\n+        super(configuration, filename, generating);\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/SubWriterHolderWriter.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n@@ -254,0 +253,2 @@\n+        \/\/ TODO: notable that these do not go through the writerFactory\n+        \/\/       also maybe notable that annotation type members are not handled as such\n@@ -256,5 +257,5 @@\n-                 ANNOTATION_TYPE, RECORD -> new NestedClassWriterImpl(this);\n-            case FIELD -> new FieldWriterImpl(this);\n-            case METHOD -> new MethodWriterImpl(this);\n-            case CONSTRUCTOR -> new ConstructorWriterImpl(this);\n-            case ENUM_CONSTANT -> new EnumConstantWriterImpl(this);\n+                 ANNOTATION_TYPE, RECORD -> new NestedClassWriter(this);\n+            case FIELD -> new FieldWriter(this);\n+            case METHOD -> new MethodWriter(this);\n+            case CONSTRUCTOR -> new ConstructorWriter(this);\n+            case ENUM_CONSTANT -> new EnumConstantWriter(this);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/SummaryListWriter.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/SystemPropertiesWriter.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -44,1 +44,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/Table.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/TableHeader.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/TreeWriter.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,133 @@\n+\/*\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html;\n+\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ModuleElement;\n+import javax.lang.model.element.PackageElement;\n+import javax.lang.model.element.TypeElement;\n+\n+import jdk.javadoc.internal.doclets.toolkit.util.ClassTree;\n+import jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable;\n+\n+\/**\n+ * The factory that returns HTML writers.\n+ *\/\n+\/\/ TODO: be more consistent about using this factory\n+public class WriterFactory {\n+\n+    private final HtmlConfiguration configuration;\n+    public WriterFactory(HtmlConfiguration configuration) {\n+        this.configuration = configuration;\n+    }\n+\n+    public ConstantsSummaryWriter getConstantsSummaryWriter() {\n+        return new ConstantsSummaryWriter(configuration);\n+    }\n+\n+    public PackageWriter getPackageSummaryWriter(PackageElement packageElement) {\n+        return new PackageWriter(configuration, packageElement);\n+    }\n+\n+    public ModuleWriter getModuleSummaryWriter(ModuleElement mdle) {\n+        return new ModuleWriter(configuration, mdle);\n+    }\n+\n+    public ClassWriter getClassWriter(TypeElement typeElement, ClassTree classTree) {\n+        return new ClassWriter(configuration, typeElement, classTree);\n+    }\n+\n+    public AnnotationTypeMemberWriter getAnnotationTypeMemberWriter(\n+            ClassWriter classWriter) {\n+        TypeElement te = classWriter.getTypeElement();\n+        return new AnnotationTypeMemberWriter(classWriter, te, AnnotationTypeMemberWriter.Kind.ANY);\n+    }\n+\n+    public AnnotationTypeMemberWriter getAnnotationTypeOptionalMemberWriter(\n+            ClassWriter classWriter) {\n+        TypeElement te = classWriter.getTypeElement();\n+        return new AnnotationTypeMemberWriter(classWriter, te, AnnotationTypeMemberWriter.Kind.OPTIONAL);\n+    }\n+\n+    public AnnotationTypeMemberWriter getAnnotationTypeRequiredMemberWriter(\n+            ClassWriter classWriter) {\n+        TypeElement te = classWriter.getTypeElement();\n+        return new AnnotationTypeMemberWriter(classWriter, te, AnnotationTypeMemberWriter.Kind.REQUIRED);\n+    }\n+\n+    public EnumConstantWriter getEnumConstantWriter(ClassWriter classWriter) {\n+        return new EnumConstantWriter(classWriter);\n+    }\n+\n+    public FieldWriter getFieldWriter(ClassWriter classWriter) {\n+        return new FieldWriter(classWriter);\n+    }\n+\n+    public PropertyWriter getPropertyWriter(ClassWriter classWriter) {\n+        return new PropertyWriter(classWriter);\n+    }\n+\n+    public MethodWriter getMethodWriter(ClassWriter classWriter) {\n+        return new MethodWriter(classWriter);\n+    }\n+\n+    public ConstructorWriter getConstructorWriter(ClassWriter classWriter) {\n+        return new ConstructorWriter(classWriter);\n+    }\n+\n+    public AbstractMemberWriter getMemberSummaryWriter(ClassWriter classWriter,\n+                                                       VisibleMemberTable.Kind memberType) {\n+        switch (memberType) {\n+            case CONSTRUCTORS:\n+                return getConstructorWriter(classWriter);\n+            case ENUM_CONSTANTS:\n+                return getEnumConstantWriter(classWriter);\n+            case ANNOTATION_TYPE_MEMBER_OPTIONAL:\n+                return getAnnotationTypeOptionalMemberWriter(classWriter);\n+            case ANNOTATION_TYPE_MEMBER_REQUIRED:\n+                return getAnnotationTypeRequiredMemberWriter(classWriter);\n+            case FIELDS:\n+                return getFieldWriter(classWriter);\n+            case PROPERTIES:\n+                return getPropertyWriter(classWriter);\n+            case NESTED_CLASSES:\n+                return new NestedClassWriter(classWriter, classWriter.getTypeElement());\n+            case METHODS:\n+                return getMethodWriter(classWriter);\n+            default:\n+                return null;\n+        }\n+    }\n+\n+    public SerializedFormWriter getSerializedFormWriter() {\n+        return new SerializedFormWriter(configuration);\n+    }\n+\n+    public DocFilesHandler getDocFilesHandler(Element element) {\n+        return new DocFilesHandler(configuration, element);\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/WriterFactory.java","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"},{"patch":"@@ -1,162 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.formats.html;\n-\n-\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.ModuleElement;\n-import javax.lang.model.element.PackageElement;\n-import javax.lang.model.element.TypeElement;\n-\n-import jdk.javadoc.internal.doclets.toolkit.ClassWriter;\n-import jdk.javadoc.internal.doclets.toolkit.ConstantsSummaryWriter;\n-import jdk.javadoc.internal.doclets.toolkit.DocFilesHandler;\n-import jdk.javadoc.internal.doclets.toolkit.MemberSummaryWriter;\n-import jdk.javadoc.internal.doclets.toolkit.ModuleSummaryWriter;\n-import jdk.javadoc.internal.doclets.toolkit.PackageSummaryWriter;\n-import jdk.javadoc.internal.doclets.toolkit.SerializedFormWriter;\n-import jdk.javadoc.internal.doclets.toolkit.WriterFactory;\n-import jdk.javadoc.internal.doclets.toolkit.util.ClassTree;\n-import jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable;\n-\n-\/**\n- * The factory that returns HTML writers.\n- *\/\n-public class WriterFactoryImpl implements WriterFactory {\n-\n-    private final HtmlConfiguration configuration;\n-    public WriterFactoryImpl(HtmlConfiguration configuration) {\n-        this.configuration = configuration;\n-    }\n-\n-    @Override\n-    public ConstantsSummaryWriter getConstantsSummaryWriter() {\n-        return new ConstantsSummaryWriterImpl(configuration);\n-    }\n-\n-    @Override\n-    public PackageSummaryWriter getPackageSummaryWriter(PackageElement packageElement) {\n-        return new PackageWriterImpl(configuration, packageElement);\n-    }\n-\n-    @Override\n-    public ModuleSummaryWriter getModuleSummaryWriter(ModuleElement mdle) {\n-        return new ModuleWriterImpl(configuration, mdle);\n-    }\n-\n-    @Override\n-    public ClassWriter getClassWriter(TypeElement typeElement, ClassTree classTree) {\n-        return new ClassWriterImpl(configuration, typeElement, classTree);\n-    }\n-\n-    @Override\n-    public AnnotationTypeMemberWriterImpl getAnnotationTypeMemberWriter(\n-            ClassWriter classWriter) {\n-        TypeElement te = classWriter.getTypeElement();\n-        return new AnnotationTypeMemberWriterImpl(\n-                (ClassWriterImpl) classWriter, te, AnnotationTypeMemberWriterImpl.Kind.ANY);\n-    }\n-\n-    @Override\n-    public AnnotationTypeMemberWriterImpl getAnnotationTypeOptionalMemberWriter(\n-            ClassWriter classWriter) {\n-        TypeElement te = classWriter.getTypeElement();\n-        return new AnnotationTypeMemberWriterImpl(\n-                (ClassWriterImpl) classWriter, te, AnnotationTypeMemberWriterImpl.Kind.OPTIONAL);\n-    }\n-\n-    @Override\n-    public AnnotationTypeMemberWriterImpl getAnnotationTypeRequiredMemberWriter(\n-            ClassWriter classWriter) {\n-        TypeElement te = classWriter.getTypeElement();\n-        return new AnnotationTypeMemberWriterImpl(\n-            (ClassWriterImpl) classWriter, te, AnnotationTypeMemberWriterImpl.Kind.REQUIRED);\n-    }\n-\n-    @Override\n-    public EnumConstantWriterImpl getEnumConstantWriter(ClassWriter classWriter) {\n-        return new EnumConstantWriterImpl((ClassWriterImpl) classWriter,\n-                classWriter.getTypeElement());\n-    }\n-\n-    @Override\n-    public FieldWriterImpl getFieldWriter(ClassWriter classWriter) {\n-        return new FieldWriterImpl((ClassWriterImpl) classWriter, classWriter.getTypeElement());\n-    }\n-\n-    @Override\n-    public PropertyWriterImpl getPropertyWriter(ClassWriter classWriter) {\n-        return new PropertyWriterImpl((ClassWriterImpl) classWriter,\n-                classWriter.getTypeElement());\n-    }\n-\n-    @Override\n-    public MethodWriterImpl getMethodWriter(ClassWriter classWriter) {\n-        return new MethodWriterImpl((ClassWriterImpl) classWriter, classWriter.getTypeElement());\n-    }\n-\n-    @Override\n-    public ConstructorWriterImpl getConstructorWriter(ClassWriter classWriter) {\n-        return new ConstructorWriterImpl((ClassWriterImpl) classWriter,\n-                classWriter.getTypeElement());\n-    }\n-\n-    @Override\n-    public MemberSummaryWriter getMemberSummaryWriter(ClassWriter classWriter,\n-            VisibleMemberTable.Kind memberType) {\n-        switch (memberType) {\n-            case CONSTRUCTORS:\n-                return getConstructorWriter(classWriter);\n-            case ENUM_CONSTANTS:\n-                return getEnumConstantWriter(classWriter);\n-            case ANNOTATION_TYPE_MEMBER_OPTIONAL:\n-                return getAnnotationTypeOptionalMemberWriter(classWriter);\n-            case ANNOTATION_TYPE_MEMBER_REQUIRED:\n-                return getAnnotationTypeRequiredMemberWriter(classWriter);\n-            case FIELDS:\n-                return getFieldWriter(classWriter);\n-            case PROPERTIES:\n-                return getPropertyWriter(classWriter);\n-            case NESTED_CLASSES:\n-                return new NestedClassWriterImpl((SubWriterHolderWriter)\n-                    classWriter, classWriter.getTypeElement());\n-            case METHODS:\n-                return getMethodWriter(classWriter);\n-            default:\n-                return null;\n-        }\n-    }\n-\n-    @Override\n-    public SerializedFormWriter getSerializedFormWriter() {\n-        return new SerializedFormWriterImpl(configuration);\n-    }\n-\n-    @Override\n-    public DocFilesHandler getDocFilesHandler(Element element) {\n-        return new DocFilesHandlerImpl(configuration, element);\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/WriterFactoryImpl.java","additions":0,"deletions":162,"binary":false,"changes":162,"status":"deleted"},{"patch":"@@ -28,1 +28,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.formats.html.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/markup\/BodyContents.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.formats.html.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/markup\/Comment.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.formats.html.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/markup\/ContentBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.formats.html.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/markup\/Entity.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.formats.html.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/markup\/Head.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.formats.html.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/markup\/HtmlDocument.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.formats.html.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/markup\/HtmlTree.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.formats.html.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/markup\/Links.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.formats.html.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/markup\/RawHtml.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,2 +31,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocletConstants;\n+import jdk.javadoc.internal.doclets.formats.html.Content;\n@@ -168,1 +167,1 @@\n-                    sb.append(\"\\\\\\'\");\n+                    sb.append(\"\\\\'\");\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/markup\/Script.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.formats.html.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/markup\/Text.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.formats.html.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/markup\/TextBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.formats.html.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/BaseTaglet.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.formats.html.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/DeprecatedTaglet.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.formats.html.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/DocRootTaglet.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.formats.html.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/IndexTaglet.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.formats.html.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/InheritDocTaglet.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-import jdk.javadoc.internal.doclets.formats.html.ClassWriterImpl;\n+import jdk.javadoc.internal.doclets.formats.html.ClassWriter;\n@@ -51,1 +51,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.formats.html.Content;\n@@ -240,1 +240,1 @@\n-                if (htmlWriter instanceof ClassWriterImpl cw) {\n+                if (htmlWriter instanceof ClassWriter cw) {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/LinkTaglet.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.formats.html.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/LiteralTaglet.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.formats.html.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/ParamTaglet.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.formats.html.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/ReturnTaglet.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-import jdk.javadoc.internal.doclets.formats.html.ClassWriterImpl;\n+import jdk.javadoc.internal.doclets.formats.html.ClassWriter;\n@@ -46,0 +46,1 @@\n+import jdk.javadoc.internal.doclets.formats.html.SerializedFormWriter;\n@@ -49,2 +50,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.builders.SerializedFormBuilder;\n+import jdk.javadoc.internal.doclets.formats.html.Content;\n@@ -110,1 +110,1 @@\n-                htmlWriter instanceof ClassWriterImpl classWriter) {\n+                htmlWriter instanceof ClassWriter classWriter) {\n@@ -123,2 +123,2 @@\n-            if (SerializedFormBuilder.serialInclude(utils, holder) &&\n-                    SerializedFormBuilder.serialInclude(utils, utils.containingPackage(holder))) {\n+            if (SerializedFormWriter.serialInclude(utils, holder) &&\n+                    SerializedFormWriter.serialInclude(utils, utils.containingPackage(holder))) {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/SeeTaglet.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-import com.sun.source.doctree.UnknownBlockTagTree;\n@@ -46,1 +45,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.formats.html.Content;\n@@ -187,1 +186,1 @@\n-        return simpleBlockTagOutput(holder, tags, header, tagletWriter);\n+        return simpleBlockTagOutput(holder, tags, header);\n@@ -201,2 +200,1 @@\n-                                        String header,\n-                                        TagletWriter writer) {\n+                                        String header) {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/SimpleTaglet.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.formats.html.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/SnippetTaglet.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.formats.html.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/SpecTaglet.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.formats.html.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/SummaryTaglet.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.formats.html.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/SystemPropertyTaglet.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.formats.html.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/Taglet.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.formats.html.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/TagletWriter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.formats.html.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/ThrowsTaglet.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.formats.html.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/UserTaglet.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.formats.html.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/ValueTaglet.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,2 +38,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.builders.AbstractBuilder;\n-import jdk.javadoc.internal.doclets.toolkit.builders.BuilderFactory;\n@@ -196,7 +194,1 @@\n-    protected void generateOtherFiles(ClassTree classTree) throws DocletException {\n-        BuilderFactory builderFactory = configuration.getBuilderFactory();\n-        AbstractBuilder constantsSummaryBuilder = builderFactory.getConstantsSummaryBuilder();\n-        constantsSummaryBuilder.build();\n-        AbstractBuilder serializedFormBuilder = builderFactory.getSerializedFormBuilder();\n-        serializedFormBuilder.build();\n-    }\n+    protected void generateOtherFiles(ClassTree classTree) throws DocletException { }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/AbstractDoclet.java","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,119 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit;\n-\n-import javax.lang.model.element.Element;\n-\n-\/**\n- * The interface for writing annotation type required member output.\n- *\/\n-public interface AnnotationTypeMemberWriter extends MemberWriter {\n-\n-    \/**\n-     * Adds the annotation type member header.\n-     *\n-     * @return the content for the member header\n-     *\/\n-    Content getMemberHeader();\n-\n-    \/**\n-     * Adds the annotation type details marker.\n-     *\n-     * @param memberDetails the content representing details marker\n-     *\/\n-    void addAnnotationDetailsMarker(Content memberDetails);\n-\n-    \/**\n-     * Adds the annotation type details header.\n-     *\n-     * @return the content for the annotation details header\n-     *\/\n-    Content getAnnotationDetailsHeader();\n-\n-    \/**\n-     * Gets the annotation type documentation header.\n-     *\n-     * @param member the annotation type being documented\n-     * @return the content for the annotation type documentation header\n-     *\/\n-    Content getAnnotationHeaderContent(Element member);\n-\n-    \/**\n-     * Gets the annotation type details.\n-     *\n-     * @param annotationDetailsHeader the content representing annotation type details header\n-     * @param annotationDetails the content representing annotation type details\n-     * @return the annotation type details\n-     *\/\n-    Content getAnnotationDetails(Content annotationDetailsHeader, Content annotationDetails);\n-\n-    \/**\n-     * {@return the signature for the specified member}\n-     *\n-     * @param member the member being documented\n-     *\/\n-    Content getSignature(Element member);\n-\n-    \/**\n-     * Adds the deprecated output for the given member.\n-     *\n-     * @param member the member being documented\n-     * @param target the content to which the deprecated information will be added\n-     *\/\n-    void addDeprecated(Element member, Content target);\n-\n-    \/**\n-     * Adds the preview output for the given member.\n-     *\n-     * @param member the member being documented\n-     * @param content the content to which the preview information will be added\n-     *\/\n-    void addPreview(Element member, Content content);\n-\n-    \/**\n-     * Adds the comments for the given member.\n-     *\n-     * @param member the member being documented\n-     * @param annotationContent the content to which the comments will be added\n-     *\/\n-    void addComments(Element member, Content annotationContent);\n-\n-    \/**\n-     * Adds the tags for the given member.\n-     *\n-     * @param member the member being documented\n-     * @param annotationContent the content to which the tags will be added\n-     *\/\n-    void addTags(Element member, Content annotationContent);\n-\n-    \/**\n-     * Adds the default value documentation if the member has one.\n-     *\n-     * @param member the member being documented\n-     * @param annotationContent the content to which the default value will be added\n-     *\/\n-    void addDefaultValueInfo(Element member, Content annotationContent);\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/AnnotationTypeMemberWriter.java","additions":0,"deletions":119,"binary":false,"changes":119,"status":"deleted"},{"patch":"@@ -63,1 +63,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.builders.BuilderFactory;\n@@ -90,5 +89,0 @@\n-    \/**\n-     * The factory for builders.\n-     *\/\n-    protected BuilderFactory builderFactory;\n-\n@@ -252,12 +246,0 @@\n-    \/**\n-     * Return the builder factory for this doclet.\n-     *\n-     * @return the builder factory for this doclet.\n-     *\/\n-    public BuilderFactory getBuilderFactory() {\n-        if (builderFactory == null) {\n-            builderFactory = new BuilderFactory(this);\n-        }\n-        return builderFactory;\n-    }\n-\n@@ -485,7 +467,0 @@\n-    \/**\n-     * Return the doclet specific instance of a writer factory.\n-     *\n-     * @return the {@link WriterFactory} for the doclet.\n-     *\/\n-    public abstract WriterFactory getWriterFactory();\n-\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/BaseConfiguration.java","additions":0,"deletions":25,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -1,228 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit;\n-\n-import javax.lang.model.element.TypeElement;\n-\n-import jdk.javadoc.internal.doclets.toolkit.util.DocFileIOException;\n-\n-\/**\n- * The interface for writing class output.\n- *\/\n-public interface ClassWriter {\n-    \/**\n-     * Returns an instance of an output object.\n-     *\n-     * @return an instance of an output object\n-     *\/\n-    Content getOutputInstance();\n-\n-    \/**\n-     * Get the header of the page.\n-     *\n-     * @param header the header string to write\n-     * @return header content that needs to be added to the documentation\n-     *\/\n-    Content getHeader(String header);\n-\n-    \/**\n-     * Get the class content header.\n-     *\n-     * @return class content header that needs to be added to the documentation\n-     *\/\n-    Content getClassContentHeader();\n-\n-    \/**\n-     * Add the class inheritance tree documentation.\n-     *\n-     * @param target the content to which the documentation will be added\n-     *\/\n-    void addClassTree(Content target);\n-\n-    \/**\n-     * Add the type parameter and state component information.\n-     *\n-     * @param target the content to which the documentation will be added\n-     *\/\n-    void addParamInfo(Content target);\n-\n-    \/**\n-     * Add all superinterfaces if this is an interface.\n-     *\n-     * @param target the content to which the documentation will be added\n-     *\/\n-    void addSuperInterfacesInfo(Content target);\n-\n-    \/**\n-     * Add all implemented interfaces if this is a class.\n-     *\n-     * @param target the content to which the documentation will be added\n-     *\/\n-    void addImplementedInterfacesInfo(Content target);\n-\n-    \/**\n-     * Add all the classes that extend this one.\n-     *\n-     * @param target the content to which the documentation will be added\n-     *\/\n-    void addSubClassInfo(Content target);\n-\n-    \/**\n-     * Add all the interfaces that extend this one.\n-     *\n-     * @param target the content to which the documentation will be added\n-     *\/\n-    void addSubInterfacesInfo(Content target);\n-\n-    \/**\n-     * If this is an interface, add all classes that implement this\n-     * interface.\n-     *\n-     * @param target the content to which the documentation will be added\n-     *\/\n-    void addInterfaceUsageInfo(Content target);\n-\n-    \/**\n-     * If this is an functional interface, display appropriate message.\n-     *\n-     * @param target the content to which the documentation will be added\n-     *\/\n-    void addFunctionalInterfaceInfo(Content target);\n-\n-    \/**\n-     * If this is an inner class or interface, add the enclosing class or\n-     * interface.\n-     *\n-     * @param target the content to which the documentation will be added\n-     *\/\n-    void addNestedClassInfo(Content target);\n-\n-    \/**\n-     * {@return the class information}\n-     *\n-     * @param classInfo the class information\n-     *\/\n-    Content getClassInfo(Content classInfo);\n-\n-    \/**\n-     * If this class is deprecated, add the appropriate information.\n-     *\n-     * @param classInfo the content to which the documentation will be added\n-     *\/\n-    void addClassDeprecationInfo(Content classInfo);\n-\n-    \/**\n-     * Add the signature of the current class content.\n-     *\n-     * @param classInfo the class content to which the signature will be added\n-     *\/\n-    void addClassSignature(Content classInfo);\n-\n-    \/**\n-     * Build the class description.\n-     *\n-     * @param classInfo the content to which the documentation will be added\n-     *\/\n-    void addClassDescription(Content classInfo);\n-\n-    \/**\n-     * Add the tag information for the current class.\n-     *\n-     * @param classInfo the content to which the tag information will be added\n-     *\/\n-    void addClassTagInfo(Content classInfo);\n-\n-    \/**\n-     * Returns a list to be used for the list of summaries for members of a given kind.\n-     *\n-     * @return a list to be used for the list of summaries for members of a given kind\n-     *\/\n-    Content getSummariesList();\n-\n-    \/**\n-     * Returns an item for the list of summaries for members of a given kind.\n-     *\n-     * @param content content for the item\n-     * @return an item for the list of summaries for members of a given kind\n-     *\/\n-    Content getSummariesListItem(Content content);\n-\n-    \/**\n-     * Returns a list to be used for the list of details for members of a given kind.\n-     *\n-     * @return a list to be used for the list of details for members of a given kind\n-     *\/\n-    Content getDetailsList();\n-\n-    \/**\n-     * Returns an item for the list of details for members of a given kind.\n-     *\n-     * @param content content for the item\n-     * @return an item for the list of details for members of a given kind\n-     *\/\n-    Content getDetailsListItem(Content content);\n-\n-    \/**\n-     * Add the class content.\n-     *\n-     * @param classContent the class content which will be added to the content\n-     *\/\n-    void addClassContent(Content classContent);\n-\n-    \/**\n-     * Add the footer of the page.\n-     *\/\n-    void addFooter();\n-\n-    \/**\n-     * Print the document.\n-     *\n-     * @param content the content that will be printed as a document\n-     * @throws DocFileIOException if there is a problem while writing the document\n-     *\/\n-    void printDocument(Content content) throws DocFileIOException;\n-\n-    \/**\n-     * Return the TypeElement being documented.\n-     *\n-     * @return the TypeElement being documented.\n-     *\/\n-    TypeElement getTypeElement();\n-\n-    \/**\n-     * {@return the member summary}\n-     *\n-     * @param memberContent the content used to build the summary\n-     *\/\n-    Content getMemberSummary(Content memberContent);\n-\n-    \/**\n-     * {@return the member details}\n-     *\n-     * @param memberContent the content used to generate the member details\n-     *\/\n-    Content getMemberDetails(Content memberContent);\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/ClassWriter.java","additions":0,"deletions":228,"binary":false,"changes":228,"status":"deleted"},{"patch":"@@ -1,129 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit;\n-\n-import java.util.*;\n-\n-import javax.lang.model.element.PackageElement;\n-import javax.lang.model.element.TypeElement;\n-import javax.lang.model.element.VariableElement;\n-\n-import jdk.javadoc.internal.doclets.toolkit.util.DocFileIOException;\n-\n-\/**\n- * The interface for writing constants summary output.\n- *\/\n-public interface ConstantsSummaryWriter {\n-\n-    \/**\n-     * Get the header for the constant summary documentation.\n-     *\n-     * @return header that needs to be added to the documentation\n-     *\/\n-    Content getHeader();\n-\n-    \/**\n-     * Get the header for the constant content list.\n-     *\n-     * @return content header that needs to be added to the documentation\n-     *\/\n-    Content getContentsHeader();\n-\n-    \/**\n-     * Adds the given package name link to the constant content list.\n-     *\n-     * @param abbrevPackageName the abbreviated package name\n-     * @param content       the content to which the link will be added\n-     *\/\n-    void addLinkToPackageContent(String abbrevPackageName, Content content);\n-\n-    \/**\n-     * Add the content list to the documentation.\n-     *\n-     * @param content the content that will be added to the list\n-     *\/\n-    void addContentsList(Content content);\n-\n-    \/**\n-     * Get the constant summaries for the document.\n-     *\n-     * @return constant summaries header to be added to the documentation\n-     *\/\n-    Content getConstantSummaries();\n-\n-    \/**\n-     * Adds a header for the given abbreviated package name.\n-     *\n-     * @param abbrevPackageName  the abbreviated package name\n-     * @param toContent the summaries documentation\n-     *\/\n-    void addPackageGroup(String abbrevPackageName, Content toContent);\n-\n-    \/**\n-     * Get the class summary header for the constants summary.\n-     *\n-     * @return the header content for the class constants summary\n-     *\/\n-    Content getClassConstantHeader();\n-\n-    \/**\n-     * Add the content list to the documentation summaries.\n-     *\n-     * @param fromClassConstant the class constant content that will be added to the list\n-     *\/\n-    void addClassConstant(Content fromClassConstant);\n-\n-    \/**\n-     * Adds the constant member table to the documentation.\n-     *\n-     * @param typeElement the class whose constants are being documented.\n-     * @param fields the constants being documented.\n-     * @param target the content to which the constant member\n-     *               table content will be added\n-     *\/\n-    void addConstantMembers(TypeElement typeElement, Collection<VariableElement> fields,\n-                            Content target);\n-\n-    \/**\n-     * Add the summaries list to the content.\n-     *\n-     * @param content the summaries content that will be added to the list\n-     *\/\n-    void addConstantSummaries(Content content);\n-\n-    \/**\n-     * Adds the footer for the summary documentation.\n-     *\/\n-    void addFooter();\n-\n-    \/**\n-     * Print the constants summary document.\n-     *\n-     * @param content the content which should be printed\n-     * @throws DocFileIOException if there is a problem while writing the document\n-     *\/\n-    void printDocument(Content content) throws DocFileIOException;\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/ConstantsSummaryWriter.java","additions":0,"deletions":129,"binary":false,"changes":129,"status":"deleted"},{"patch":"@@ -1,107 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit;\n-\n-import javax.lang.model.element.ExecutableElement;\n-\n-\/**\n- * The interface for writing constructor output.\n- *\/\n-public interface ConstructorWriter extends MemberWriter {\n-\n-    \/**\n-     * {@return the constructor details header}\n-     *\n-     * @param content the content representing member details\n-     *\/\n-    Content getConstructorDetailsHeader(Content content);\n-\n-    \/**\n-     * {@return the constructor documentation header}\n-     *\n-     * @param constructor the constructor being documented\n-     *\/\n-    Content getConstructorHeaderContent(ExecutableElement constructor);\n-\n-    \/**\n-     * {@return the signature for the given constructor}\n-     *\n-     * @param constructor the constructor being documented\n-     *\/\n-    Content getSignature(ExecutableElement constructor);\n-\n-    \/**\n-     * Add the deprecated output for the given constructor.\n-     *\n-     * @param constructor the constructor being documented\n-     * @param constructorContent the content to which the deprecated information will be added\n-     *\/\n-    void addDeprecated(ExecutableElement constructor, Content constructorContent);\n-\n-    \/**\n-     * Add the preview output for the given member.\n-     *\n-     * @param member the member being documented\n-     * @param content the content to which the preview information will be added\n-     *\/\n-    void addPreview(ExecutableElement member, Content content);\n-\n-    \/**\n-     * Add the comments for the given constructor.\n-     *\n-     * @param constructor the constructor being documented\n-     * @param constructorContent the content to which the comments will be added\n-     *\/\n-    void addComments(ExecutableElement constructor, Content constructorContent);\n-\n-    \/**\n-     * Add the tags for the given constructor.\n-     *\n-     * @param constructor the constructor being documented\n-     * @param constructorContent the content to which the tags will be added\n-     *\/\n-    void addTags(ExecutableElement constructor, Content constructorContent);\n-\n-    \/**\n-     * {@return the constructor details}\n-     *\n-     * @param memberDetailsHeader the content representing member details header\n-     * @param memberDetails the content representing member details\n-     *\/\n-    Content getConstructorDetails(Content memberDetailsHeader, Content memberDetails);\n-\n-    \/**\n-     * Let the writer know whether a non public constructor was found.\n-     *\n-     * @param foundNonPubConstructor true if we found a non public constructor.\n-     *\/\n-    void setFoundNonPubConstructor(boolean foundNonPubConstructor);\n-\n-    \/**\n-     * @return the member header}\n-     *\/\n-    Content getMemberHeader();\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/ConstructorWriter.java","additions":0,"deletions":107,"binary":false,"changes":107,"status":"deleted"},{"patch":"@@ -1,39 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-package jdk.javadoc.internal.doclets.toolkit;\n-\n-import java.util.List;\n-\n-import jdk.javadoc.internal.doclets.toolkit.util.DocPath;\n-\n-\/**\n- * The interface for copying doc-files to the output.\n- *\/\n-public interface DocFilesHandler {\n-    void copyDocFiles() throws DocletException;\n-    List<DocPath> getStylesheets() throws DocletException;\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/DocFilesHandler.java","additions":0,"deletions":39,"binary":false,"changes":39,"status":"deleted"},{"patch":"@@ -1,111 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit;\n-\n-import javax.lang.model.element.TypeElement;\n-import javax.lang.model.element.VariableElement;\n-\n-\/**\n- * The interface for writing enum constant output.\n- *\/\n-public interface EnumConstantWriter extends MemberWriter {\n-\n-    \/**\n-     * Get the enum constants details header.\n-     *\n-     * @param typeElement the class being documented\n-     * @param memberDetails the content representing member details\n-     * @return a content for the enum constants details header\n-     *\/\n-    Content getEnumConstantsDetailsHeader(TypeElement typeElement,\n-                                          Content memberDetails);\n-\n-    \/**\n-     * Get the enum constants documentation header.\n-     *\n-     * @param enumConstant the enum constant being documented\n-     * @param enumConstantsDetails the content representing enum constant details\n-     * @return the enum constant documentation header\n-     *\/\n-    Content getEnumConstantsHeader(VariableElement enumConstant,\n-                                   Content enumConstantsDetails);\n-\n-    \/**\n-     * Get the signature for the given enum constant.\n-     *\n-     * @param enumConstant the enum constant being documented\n-     * @return the enum constant signature\n-     *\/\n-    Content getSignature(VariableElement enumConstant);\n-\n-    \/**\n-     * Add the deprecated output for the given enum constant.\n-     *\n-     * @param enumConstant the enum constant being documented\n-     * @param content the content to which the deprecated information will be added\n-     *\/\n-    void addDeprecated(VariableElement enumConstant, Content content);\n-\n-    \/**\n-     * Add the preview output for the given member.\n-     *\n-     * @param member the member being documented\n-     * @param content the content to which the preview information will be added\n-     *\/\n-    void addPreview(VariableElement member, Content content);\n-\n-    \/**\n-     * Add the comments for the given enum constant.\n-     *\n-     * @param enumConstant the enum constant being documented\n-     * @param enumConstants the content to which the comments will be added\n-     *\/\n-    void addComments(VariableElement enumConstant, Content enumConstants);\n-\n-    \/**\n-     * Add the tags for the given enum constant.\n-     *\n-     * @param enumConstant the enum constant being documented\n-     * @param content the content to which the tags will be added\n-     *\/\n-    void addTags(VariableElement enumConstant, Content content);\n-\n-    \/**\n-     * Get the enum constants details.\n-     *\n-     * @param memberDetailsHeader member details header\n-     * @param content the content representing member details\n-     * @return the enum constant details\n-     *\/\n-    Content getEnumConstantsDetails(Content memberDetailsHeader, Content content);\n-\n-    \/**\n-     * Gets the member header.\n-     *\n-     * @return the member header\n-     *\/\n-    Content getMemberHeader();\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/EnumConstantWriter.java","additions":0,"deletions":111,"binary":false,"changes":111,"status":"deleted"},{"patch":"@@ -1,106 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit;\n-\n-import javax.lang.model.element.VariableElement;\n-\n-\/**\n- * The interface for writing field output.\n- *\/\n-public interface FieldWriter extends MemberWriter {\n-\n-    \/**\n-     * Get the field details header.\n-     *\n-     * @param content the content representing member details\n-     * @return the field details header\n-     *\/\n-    Content getFieldDetailsHeader(Content content);\n-\n-    \/**\n-     * Get the field documentation header.\n-     *\n-     * @param field the constructor being documented\n-     * @return the field documentation header\n-     *\/\n-    Content getFieldHeaderContent(VariableElement field);\n-\n-    \/**\n-     * Get the signature for the given field.\n-     *\n-     * @param field the field being documented\n-     * @return the field signature\n-     *\/\n-    Content getSignature(VariableElement field);\n-\n-    \/**\n-     * Add the deprecated output for the given field.\n-     *\n-     * @param field the field being documented\n-     * @param fieldContent the content to which the deprecated information will be added\n-     *\/\n-    void addDeprecated(VariableElement field, Content fieldContent);\n-\n-    \/**\n-     * Adds the preview output for the given member.\n-     *\n-     * @param member the member being documented\n-     * @param content the content to which the preview information will be added\n-     *\/\n-    void addPreview(VariableElement member, Content content);\n-\n-    \/**\n-     * Add the comments for the given field.\n-     *\n-     * @param field the field being documented\n-     * @param fieldContent the content to which the comments will be added\n-     *\/\n-    void addComments(VariableElement field, Content fieldContent);\n-\n-    \/**\n-     * Add the tags for the given field.\n-     *\n-     * @param field the field being documented\n-     * @param fieldContent the content to which the tags will be added\n-     *\/\n-    void addTags(VariableElement field, Content fieldContent);\n-\n-    \/**\n-     * Get the field details.\n-     *\n-     * @param memberDetailsHeaderContent the content representing member details header\n-     * @param memberContent the content representing member details\n-     * @return the field details\n-     *\/\n-    Content getFieldDetails(Content memberDetailsHeaderContent, Content memberContent);\n-\n-    \/**\n-     * Gets the member header.\n-     *\n-     * @return the member header\n-     *\/\n-    Content getMemberHeader();\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/FieldWriter.java","additions":0,"deletions":106,"binary":false,"changes":106,"status":"deleted"},{"patch":"@@ -1,114 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit;\n-\n-import java.util.*;\n-\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.TypeElement;\n-\n-import com.sun.source.doctree.DocTree;\n-\n-\/**\n- * The interface for writing member summary output.\n- *\/\n-public interface MemberSummaryWriter {\n-\n-    \/**\n-     * Returns the member summary header for the given class.\n-     *\n-     * @param typeElement the class the summary belongs to\n-     * @param content     the content to which the member summary will be added\n-     *\n-     * @return the member summary header\n-     *\/\n-    Content getMemberSummaryHeader(TypeElement typeElement, Content content);\n-\n-    \/**\n-     * Returns the summary table for the given class.\n-     *\n-     * @param typeElement the class the summary table belongs to\n-     *\n-     * @return the summary table\n-     *\/\n-    Content getSummaryTable(TypeElement typeElement);\n-\n-    \/**\n-     * Adds the member summary for the given class and member.\n-     *\n-     * @param typeElement        the class the summary belongs to\n-     * @param member             the member that is documented\n-     * @param firstSentenceTrees the tags for the sentence being documented\n-     *\/\n-    void addMemberSummary(TypeElement typeElement, Element member,\n-                          List<? extends DocTree> firstSentenceTrees);\n-\n-    \/**\n-     * Returns the inherited member summary header for the given class.\n-     *\n-     * @param typeElement the class the summary belongs to\n-     *\n-     * @return the inherited member summary header\n-     *\/\n-    Content getInheritedSummaryHeader(TypeElement typeElement);\n-\n-    \/**\n-     * Adds the inherited member summary for the given class and member.\n-     *\n-     * @param typeElement the class the inherited member belongs to\n-     * @param member the inherited member that is being documented\n-     * @param isFirst true if this is the first member in the list\n-     * @param isLast true if this is the last member in the list\n-     * @param content the content to which the links will be added\n-     *\/\n-    void addInheritedMemberSummary(TypeElement typeElement,\n-                                   Element member, boolean isFirst, boolean isLast,\n-                                   Content content);\n-\n-    \/**\n-     * Returns the inherited summary links.\n-     *\n-     * @return the inherited summary links\n-     *\/\n-    Content getInheritedSummaryLinks();\n-\n-    \/**\n-     * Adds the given summary to the list of summaries.\n-     *\n-     * @param summariesList the list of summaries\n-     * @param content       the summary\n-     *\/\n-    void addSummary(Content summariesList, Content content);\n-\n-    \/**\n-     * Returns the member content.\n-     *\n-     * @param memberContent the content representing the member\n-     *\n-     * @return the member content\n-     *\/\n-    Content getMember(Content memberContent);\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/MemberSummaryWriter.java","additions":0,"deletions":114,"binary":false,"changes":114,"status":"deleted"},{"patch":"@@ -1,47 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit;\n-\n-\/**\n- * Common behavior for writing members of a type.\n- *\/\n-public interface MemberWriter {\n-\n-    \/**\n-     * {@return a list to add member items to}\n-     *\n-     * @see #getMemberListItem(Content)\n-     *\/\n-    Content getMemberList();\n-\n-    \/**\n-     * {@return a member item}\n-     *\n-     * @param member the member to represent as an item\n-     * @see #getMemberList()\n-     *\/\n-    Content getMemberListItem(Content member);\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/MemberWriter.java","additions":0,"deletions":47,"binary":false,"changes":47,"status":"deleted"},{"patch":"@@ -1,108 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit;\n-\n-import javax.lang.model.element.ExecutableElement;\n-import javax.lang.model.type.TypeMirror;\n-\n-\/**\n- * The interface for writing method output.\n- *\/\n-public interface MethodWriter extends MemberWriter {\n-\n-    \/**\n-     * Get the method details header.\n-     *\n-     * @param content the content representing member details\n-     * @return the method details header\n-     *\/\n-    Content getMethodDetailsHeader(Content content);\n-\n-    \/**\n-     * Get the method documentation header.\n-     *\n-     * @param method the method being documented\n-     * @return the method documentation header\n-     *\/\n-    Content getMethodHeader(ExecutableElement method);\n-\n-    \/**\n-     * Get the signature for the given method.\n-     *\n-     * @param method the method being documented\n-     * @return the method signature\n-     *\/\n-    Content getSignature(ExecutableElement method);\n-\n-    \/**\n-     * Add the deprecated output for the given method.\n-     *\n-     * @param method the method being documented\n-     * @param methodContent the content to which the deprecated information will be added\n-     *\/\n-    void addDeprecated(ExecutableElement method, Content methodContent);\n-\n-    \/**\n-     * Adds the preview output for the given member.\n-     *\n-     * @param member the member being documented\n-     * @param content the content to which the preview information will be added\n-     *\/\n-    void addPreview(ExecutableElement member, Content content);\n-\n-    \/**\n-     * Add the comments for the given method.\n-     *\n-     * @param holder the holder type (not erasure) of the method\n-     * @param method the method being documented\n-     * @param methodContent the content to which the comments will be added\n-     *\/\n-    void addComments(TypeMirror holder, ExecutableElement method, Content methodContent);\n-\n-    \/**\n-     * Add the tags for the given method.\n-     *\n-     * @param method the method being documented\n-     * @param methodContent the content to which the tags will be added\n-     *\/\n-    void addTags(ExecutableElement method, Content methodContent);\n-\n-    \/**\n-     * Get the method details.\n-     *\n-     * @param methodDetailsHeader the content representing method details header\n-     * @param methodDetails the content representing method details\n-     * @return the method details\n-     *\/\n-    Content getMethodDetails(Content methodDetailsHeader, Content methodDetails);\n-\n-    \/**\n-     * Gets the member header.\n-     *\n-     * @return the member header\n-     *\/\n-    Content getMemberHeader();\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/MethodWriter.java","additions":0,"deletions":108,"binary":false,"changes":108,"status":"deleted"},{"patch":"@@ -1,121 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit;\n-\n-import jdk.javadoc.internal.doclets.toolkit.util.DocFileIOException;\n-\n-\/**\n- * The interface for writing module summary output.\n- *\/\n-public interface ModuleSummaryWriter {\n-\n-    \/**\n-     * Get the header for the summary.\n-     *\n-     * @param heading module name.\n-     * @return the header to be added to the content\n-     *\/\n-    Content getModuleHeader(String heading);\n-\n-    \/**\n-     * Get the header for the module content.\n-     *\n-     * @return the module content header\n-     *\/\n-    Content getContentHeader();\n-\n-    \/**\n-     * Get the header for the summary header.\n-     *\n-     * @return the summary header\n-     *\/\n-    Content getSummariesList();\n-\n-    \/**\n-     * Wrap the content into summary section.\n-     *\n-     * @param source the content to wrap into the summary section\n-     * @return the summary\n-     *\/\n-    Content getSummary(Content source);\n-\n-    \/**\n-     * Adds the module description.\n-     *\n-     * @param moduleContent the content to which the module description\n-     *                      will be added\n-     *\/\n-    void addModuleDescription(Content moduleContent);\n-\n-    \/**\n-     * Adds the module signature.\n-     *\n-     * @param moduleContent the content to which the module signature\n-     *                      will be added\n-     *\/\n-    void addModuleSignature(Content moduleContent);\n-\n-    \/**\n-     * Adds the summary of modules to the list of summaries.\n-     *\n-     * @param summariesList the list of summaries\n-     *\/\n-    void addModulesSummary(Content summariesList);\n-\n-    \/**\n-     * Adds the summary of packages to the list of summaries.\n-     *\n-     * @param summariesList the list of summaries\n-     *\/\n-    void addPackagesSummary(Content summariesList);\n-\n-    \/**\n-     * Adds the summary of services to the list of summaries.\n-     *\n-     * @param summariesList the list of summaries\n-     *\/\n-    void addServicesSummary(Content summariesList);\n-\n-    \/**\n-     * Adds the module content to the documentation.\n-     *\n-     * @param source the content that will be added\n-     *\/\n-    void addModuleContent(Content source);\n-\n-    \/**\n-     * Adds the footer to the documentation.\n-     *\/\n-    void addModuleFooter();\n-\n-    \/**\n-     * Print the module summary document.\n-     *\n-     * @param content the content that will be printed\n-     * @throws DocFileIOException if there is a problem while writing the document\n-     *\/\n-    void printDocument(Content content) throws DocFileIOException;\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/ModuleSummaryWriter.java","additions":0,"deletions":121,"binary":false,"changes":121,"status":"deleted"},{"patch":"@@ -1,32 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit;\n-\n-\/**\n- * The interface for writing class output.\n- *\/\n-public interface NestedClassWriter {\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/NestedClassWriter.java","additions":0,"deletions":32,"binary":false,"changes":32,"status":"deleted"},{"patch":"@@ -1,127 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit;\n-\n-import java.util.List;\n-import java.util.SortedSet;\n-\n-import javax.lang.model.element.PackageElement;\n-import javax.lang.model.element.TypeElement;\n-\n-import jdk.javadoc.internal.doclets.toolkit.util.DocFileIOException;\n-\n-\/**\n- * The interface for writing package summary output.\n- *\/\n-public interface PackageSummaryWriter {\n-\n-    \/**\n-     * Get the header for the summary.\n-     *\n-     * @return the header to be added to the content\n-     *\/\n-    Content getPackageHeader();\n-\n-    \/**\n-     * Get the header for the package content.\n-     *\n-     * @return the package content header\n-     *\/\n-    Content getContentHeader();\n-\n-    \/**\n-     * Get the header for the package summary.\n-     *\n-     * @return the package summary header\n-     *\/\n-    Content getSummariesList();\n-\n-    \/**\n-     * Adds the table of related packages to the documentation.\n-     *\n-     * @param summaryContent the content to which the summaries will be added\n-     *\/\n-    void addRelatedPackagesSummary(Content summaryContent);\n-\n-    \/**\n-     * Adds the table of all classes and interfaces to the documentation.\n-     *\n-     * @param summaryContent the content to which the summaries will be added\n-     *\/\n-    void addAllClassesAndInterfacesSummary(Content summaryContent);\n-\n-    \/**\n-     * Adds the package description from the \"packages.html\" file to the documentation.\n-     *\n-     * @param packageContent the content to which the package description\n-     *                       will be added\n-     *\/\n-    void addPackageDescription(Content packageContent);\n-\n-    \/**\n-     * Adds the tag information from the \"packages.html\" file to the documentation.\n-     *\n-     * @param packageContent the content to which the package tags will\n-     *                       be added\n-     *\/\n-    void addPackageTags(Content packageContent);\n-\n-    \/**\n-     * Adds the package signature.\n-     *\n-     * @param packageContent the content to which the package signature\n-     *                       will be added\n-     *\/\n-    void addPackageSignature(Content packageContent);\n-\n-    \/**\n-     * Adds the tag information from the \"packages.html\" or \"package-info.java\" file to the\n-     * documentation.\n-     *\n-     * @param packageContent the package content to be added\n-     *\/\n-    void addPackageContent(Content packageContent);\n-\n-    \/**\n-     * Adds the footer to the documentation.\n-     *\/\n-    void addPackageFooter();\n-\n-    \/**\n-     * Print the package summary document.\n-     *\n-     * @param content the content that will be printed\n-     * @throws DocFileIOException if there is a problem while writing the document\n-     *\/\n-    void printDocument(Content content) throws DocFileIOException;\n-\n-    \/**\n-     * Gets the package summary.\n-     * @param summaryContent the content representing the package summary\n-     * @return the package summary\n-     *\/\n-    Content getPackageSummary(Content summaryContent);\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/PackageSummaryWriter.java","additions":0,"deletions":127,"binary":false,"changes":127,"status":"deleted"},{"patch":"@@ -28,0 +28,4 @@\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n@@ -29,0 +33,2 @@\n+\n+import javax.lang.model.element.Element;\n@@ -30,0 +36,2 @@\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n@@ -32,0 +40,1 @@\n+import javax.lang.model.util.ElementFilter;\n@@ -33,0 +42,8 @@\n+import javax.tools.Diagnostic;\n+\n+import com.sun.source.doctree.DocCommentTree;\n+\n+import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n+import jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable;\n+\n+import static jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable.Kind.PROPERTIES;\n@@ -172,0 +189,88 @@\n+\n+\n+    \/**\n+     * A utility class to manage the property-related methods that should be\n+     * synthesized or updated.\n+     *\n+     * A property may comprise a field (that is typically private, if present),\n+     * a {@code fooProperty()} method (which is the defining characteristic for\n+     * a property), a {@code getFoo()} method and\/or a {@code setFoo(Foo foo)} method.\n+     *\n+     * Either the field (if present) or the {@code fooProperty()} method should have a\n+     * comment. If there is no field, or no comment on the field, the description for\n+     * the property will be derived from the description of the {@code fooProperty()}\n+     * method. If any method does not have a comment, one will be provided.\n+     *\/\n+    public static class PropertyHelper {\n+        private final BaseConfiguration configuration;\n+        private final Utils utils;\n+        private final TypeElement typeElement;\n+\n+        private final Map<Element, Element> classPropertiesMap = new HashMap<>();\n+\n+        public PropertyHelper(BaseConfiguration configuration, TypeElement typeElement) {\n+            this.configuration = configuration;\n+            this.utils = configuration.utils;\n+            this.typeElement = typeElement;\n+            computeProperties();\n+        }\n+\n+        private void computeProperties() {\n+            VisibleMemberTable vmt = configuration.getVisibleMemberTable(typeElement);\n+            List<ExecutableElement> props = ElementFilter.methodsIn(vmt.getVisibleMembers(PROPERTIES));\n+            for (ExecutableElement propertyMethod : props) {\n+                ExecutableElement getter = vmt.getPropertyGetter(propertyMethod);\n+                ExecutableElement setter = vmt.getPropertySetter(propertyMethod);\n+                VariableElement field = vmt.getPropertyField(propertyMethod);\n+\n+                addToPropertiesMap(propertyMethod, field, getter, setter);\n+            }\n+        }\n+\n+        private void addToPropertiesMap(ExecutableElement propertyMethod,\n+                                        VariableElement field,\n+                                        ExecutableElement getter,\n+                                        ExecutableElement setter) {\n+            \/\/ determine the preferred element from which to derive the property description\n+            Element e = field == null || !utils.hasDocCommentTree(field)\n+                    ? propertyMethod : field;\n+\n+            if (e == field && utils.hasDocCommentTree(propertyMethod)) {\n+                configuration.getReporter().print(Diagnostic.Kind.WARNING,\n+                        propertyMethod, configuration.getDocResources().getText(\"doclet.duplicate.comment.for.property\"));\n+            }\n+\n+            addToPropertiesMap(propertyMethod, e);\n+            addToPropertiesMap(getter, e);\n+            addToPropertiesMap(setter, e);\n+        }\n+\n+        private void addToPropertiesMap(Element propertyMethod,\n+                                        Element commentSource) {\n+            Objects.requireNonNull(commentSource);\n+            if (propertyMethod == null) {\n+                return;\n+            }\n+\n+            DocCommentTree docTree = utils.hasDocCommentTree(propertyMethod)\n+                    ? utils.getDocCommentTree(propertyMethod)\n+                    : null;\n+\n+            \/* The second condition is required for the property buckets. In\n+             * this case the comment is at the property method (not at the field)\n+             * and it needs to be listed in the map.\n+             *\/\n+            if ((docTree == null) || propertyMethod.equals(commentSource)) {\n+                classPropertiesMap.put(propertyMethod, commentSource);\n+            }\n+        }\n+\n+        \/**\n+         * Returns the element for the property documentation belonging to the given member.\n+         * @param element the member for which the property documentation is needed.\n+         * @return the element for the property documentation, null if there is none.\n+         *\/\n+        public Element getPropertyElement(Element element) {\n+            return classPropertiesMap.get(element);\n+        }\n+    }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/PropertyUtils.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -1,99 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit;\n-\n-import javax.lang.model.element.ExecutableElement;\n-\n-\/**\n- * The interface for writing property output.\n- *\/\n-public interface PropertyWriter extends MemberWriter {\n-\n-    \/**\n-     * Get the property details header.\n-     *\n-     * @param memberDetails the content representing member details\n-     * @return the property details header\n-     *\/\n-    Content getPropertyDetailsHeader(Content memberDetails);\n-\n-    \/**\n-     * Get the property documentation header.\n-     *\n-     * @param property the property being documented\n-     * @return the property documentation header\n-     *\/\n-    Content getPropertyHeaderContent(ExecutableElement property);\n-\n-    \/**\n-     * Get the signature for the given property.\n-     *\n-     * @param property the property being documented\n-     * @return the property signature\n-     *\/\n-    Content getSignature(ExecutableElement property);\n-\n-    \/**\n-     * Add the deprecated output for the given property.\n-     *\n-     * @param property the property being documented\n-     * @param propertyContent content to which the deprecated information will be added\n-     *\/\n-    void addDeprecated(ExecutableElement property, Content propertyContent);\n-\n-    \/**\n-     * Add the preview output for the given member.\n-     *\n-     * @param member the member being documented\n-     * @param content the content to which the preview information will be added\n-     *\/\n-    void addPreview(ExecutableElement member, Content content);\n-\n-    \/**\n-     * Add the comments for the given property.\n-     *\n-     * @param property the property being documented\n-     * @param propertyContent the content to which the comments will be added\n-     *\/\n-    void addComments(ExecutableElement property, Content propertyContent);\n-\n-    \/**\n-     * Add the tags for the given property.\n-     *\n-     * @param property the property being documented\n-     * @param propertyContent the content to which the tags will be added\n-     *\/\n-    void addTags(ExecutableElement property, Content propertyContent);\n-\n-    \/**\n-     * Get the property details.\n-     *\n-     * @param memberDetailsHeader the content representing member details header\n-     * @param memberDetails the content representing member details\n-     * @return the property details\n-     *\/\n-    Content getPropertyDetails(Content memberDetailsHeader, Content memberDetails);\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/PropertyWriter.java","additions":0,"deletions":99,"binary":false,"changes":99,"status":"deleted"},{"patch":"@@ -1,303 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit;\n-\n-import javax.lang.model.element.ExecutableElement;\n-import javax.lang.model.element.PackageElement;\n-import javax.lang.model.element.TypeElement;\n-import javax.lang.model.element.VariableElement;\n-import javax.lang.model.type.TypeMirror;\n-\n-import com.sun.source.doctree.SerialFieldTree;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocFileIOException;\n-\n-\/**\n- * The interface for writing serialized form output.\n- *\/\n-public interface SerializedFormWriter {\n-\n-    \/**\n-     * Get the header.\n-     *\n-     * @param header the header to write.\n-     * @return the header content\n-     *\/\n-    Content getHeader(String header);\n-\n-    \/**\n-     * Get the serialized form summaries header.\n-     *\n-     * @return the serialized form summary header\n-     *\/\n-    Content getSerializedSummariesHeader();\n-\n-    \/**\n-     * Get the package serialized form header.\n-     *\n-     * @return the package serialized form header\n-     *\/\n-    Content getPackageSerializedHeader();\n-\n-    \/**\n-     * Add the serialized package to the serialized summaries.\n-     *\n-     * @param serializedSummaries the serialized content to which the package serialized content will be added\n-     * @param packageSerialized the serialized content per package that needs to be added\n-     *\/\n-    void addPackageSerialized(Content serializedSummaries, Content packageSerialized);\n-\n-    \/**\n-     * {@return a header for the given package}\n-     *\n-     * @param packageElement the package element to write\n-     *\/\n-    Content getPackageHeader(PackageElement packageElement);\n-\n-    \/**\n-     * {@return the serialized class header}\n-     *\/\n-    Content getClassSerializedHeader();\n-\n-    \/**\n-     * {@return the heading for the serializable class}\n-     *\n-     * @param typeElement the class being processed\n-     *\/\n-    Content getClassHeader(TypeElement typeElement);\n-\n-    \/**\n-     * {@return the serial UID info header}\n-     *\/\n-    Content getSerialUIDInfoHeader();\n-\n-    \/**\n-     * Adds the serial UID info.\n-     *\n-     * @param header the header that will show up before the UID.\n-     * @param serialUID the serial UID to print.\n-     * @param target the serial UID to which the content will be added.\n-     *\/\n-    void addSerialUIDInfo(String header, String serialUID, Content target);\n-\n-    \/**\n-     * {@return the serialized class header}\n-     *\/\n-    Content getClassContentHeader();\n-\n-    \/**\n-     * Return an instance of a SerialFieldWriter for a class.\n-     *\n-     * @param typeElement the class\n-     * @return an instance of a SerialFieldWriter.\n-     *\/\n-    SerialFieldWriter getSerialFieldWriter(TypeElement typeElement);\n-\n-    \/**\n-     * Return an instance of a SerialMethodWriter for a class.\n-     *\n-     * @param typeElement the class\n-     * @return an instance of a SerialMethodWriter.\n-     *\/\n-    SerialMethodWriter getSerialMethodWriter(TypeElement typeElement);\n-\n-    \/**\n-     * Add the serialized content to the body content.\n-     *\n-     * @param source content for serialized data\n-     *\/\n-    void addSerializedContent(Content source);\n-\n-    \/**\n-     * Add the footer.\n-     *\/\n-    void addFooter();\n-\n-    \/**\n-     * Print the serialized form document.\n-     *\n-     * @param source the content that will be printed\n-     * @throws DocFileIOException if there is a problem while writing the document\n-     *\/\n-    void printDocument(Content source) throws DocFileIOException;\n-\n-    \/**\n-     * Gets the member.\n-     *\n-     * @param content the content used to generate the complete member\n-     * @return the member\n-     *\/\n-    Content getMember(Content content);\n-\n-    \/**\n-     * A writer for the serialized form for a given field.\n-     *\/\n-    interface SerialFieldWriter {\n-\n-        \/**\n-         * {@return the serializable field header}\n-         *\/\n-        Content getSerializableFieldsHeader();\n-\n-        \/**\n-         * {@return the field content header}\n-         *\n-         * @param isLastContent true if this is the last content to be documented\n-         *\/\n-        Content getFieldsContentHeader(boolean isLastContent);\n-\n-        \/**\n-         * {@return the fields}\n-         *\n-         * @param heading the heading to write.\n-         * @param content the content to be added\n-         * @return serializable fields content\n-         *\/\n-        Content getSerializableFields(String heading, Content content);\n-\n-        \/**\n-         * Adds the deprecated information for this member.\n-         *\n-         * @param field the field to document.\n-         * @param content the content to which the deprecated information will be added\n-         *\/\n-        void addMemberDeprecatedInfo(VariableElement field, Content content);\n-\n-        \/**\n-         * Adds the description text for this member.\n-         *\n-         * @param field the field to document\n-         * @param content the content to which the member description will be added\n-         *\/\n-        void addMemberDescription(VariableElement field, Content content);\n-\n-        \/**\n-         * Adds the description text for this member represented by the tag.\n-         *\n-         * @param field the field to document\n-         * @param serialFieldTag the field to document (represented by tag)\n-         * @param content the content to which the member description will be added\n-         *\/\n-        void addMemberDescription(VariableElement field, SerialFieldTree serialFieldTag, Content content);\n-\n-        \/**\n-         * Adds the tag information for this member.\n-         *\n-         * @param field the field to document\n-         * @param content the content to which the member tags will be added\n-         *\/\n-        void addMemberTags(VariableElement field, Content content);\n-\n-        \/**\n-         * Adds the member header.\n-         *\n-         * @param fieldType the type of the field\n-         * @param fieldName the name of the field\n-         * @param content the content to which the member header will be added\n-         *\/\n-        void addMemberHeader(TypeMirror fieldType, String fieldName, Content content);\n-\n-        \/**\n-         * Check to see if overview details should be printed. If\n-         * nocomment option set or if there is no text to be printed\n-         * for deprecation info, inline comment or tags,\n-         * do not print overview details.\n-         *\n-         * @param field the field to check overview details for\n-         * @return true if overview details need to be printed\n-         *\/\n-        boolean shouldPrintOverview(VariableElement field);\n-    }\n-\n-    \/**\n-     * Write the serialized form for a given field.\n-     *\/\n-    interface SerialMethodWriter {\n-\n-        \/**\n-         * {@return the header for serializable methods section}\n-         *\/\n-        Content getSerializableMethodsHeader();\n-\n-        \/**\n-         * {@return the header for serializable methods content section}\n-         *\n-         * @param isLastContent true if the content being documented is the last content\n-         *\/\n-        Content getMethodsContentHeader(boolean isLastContent);\n-\n-        \/**\n-         * Gets the given heading.\n-         *\n-         * @param heading the heading to write\n-         * @param source the content which will be added\n-         * @return a serializable methods content\n-         *\/\n-        Content getSerializableMethods(String heading, Content source);\n-\n-        \/**\n-         * Gets a warning that no serializable methods exist.\n-         *\n-         * @param msg the warning to print\n-         * @return a no customization message\n-         *\/\n-        Content getNoCustomizationMsg(String msg);\n-\n-        \/**\n-         * Adds the header.\n-         *\n-         * @param member the member to write the header for\n-         * @param methodsContent the content to which the header will be added\n-         *\/\n-        void addMemberHeader(ExecutableElement member, Content methodsContent);\n-\n-        \/**\n-         * Adds the deprecated information for this member.\n-         *\n-         * @param member the member to write the deprecated information for\n-         * @param methodsContent the content to which the deprecated\n-         * information will be added\n-         *\/\n-        void addDeprecatedMemberInfo(ExecutableElement member, Content methodsContent);\n-\n-        \/**\n-         * Adds the description for this member.\n-         *\n-         * @param member the member to write the information for\n-         * @param methodsContent the content to which the member\n-         * information will be added\n-         *\/\n-        void addMemberDescription(ExecutableElement member, Content methodsContent);\n-\n-        \/**\n-         * Adds the tag information for this member.\n-         *\n-         * @param member the member to write the tags information for\n-         * @param methodsContent the content to which the tags\n-         * information will be added\n-         *\/\n-        void addMemberTags(ExecutableElement member, Content methodsContent);\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/SerializedFormWriter.java","additions":0,"deletions":303,"binary":false,"changes":303,"status":"deleted"},{"patch":"@@ -1,180 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit;\n-\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.ModuleElement;\n-import javax.lang.model.element.PackageElement;\n-import javax.lang.model.element.TypeElement;\n-\n-import jdk.javadoc.internal.doclets.toolkit.util.ClassTree;\n-import jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable;\n-\n-\/**\n- * The interface for a factory creates writers.\n- *\/\n-public interface WriterFactory {\n-\n-    \/**\n-     * Return the writer for the constant summary.\n-     *\n-     * @return the writer for the constant summary.  Return null if this\n-     * writer is not supported by the doclet.\n-     *\/\n-    ConstantsSummaryWriter getConstantsSummaryWriter();\n-\n-    \/**\n-     * Return the writer for the package summary.\n-     *\n-     * @param packageElement the package being documented\n-     * @return the writer for the package summary.  Return null if this\n-     * writer is not supported by the doclet.\n-     *\/\n-    PackageSummaryWriter getPackageSummaryWriter(PackageElement packageElement);\n-\n-    \/**\n-     * Return the writer for the module summary.\n-     *\n-     * @param mdle the module being documented\n-     * @return the writer for the module summary.  Return null if this\n-     * writer is not supported by the doclet.\n-     *\/\n-    ModuleSummaryWriter getModuleSummaryWriter(ModuleElement mdle);\n-\n-    \/**\n-     * Returns the writer for a given type element,\n-     * or null if this writer is not supported by the doclet.\n-     *\n-     * @param typeElement the class being documented\n-     * @param classTree   the class tree\n-     * @return the writer\n-     *\/\n-    ClassWriter getClassWriter(TypeElement typeElement, ClassTree classTree);\n-\n-    \/**\n-     * Return the method writer for a given type element,\n-     * or null if this writer is not supported by the doclet.\n-     *\n-     * @param classWriter the writer for the class being documented\n-     * @return the method writer\n-     *\/\n-    MethodWriter getMethodWriter(ClassWriter classWriter);\n-\n-    \/**\n-     * Return the annotation type member writer for a given annotation\n-     * type, or null if this writer is not supported by the doclet.\n-     *\n-     * @param classWriter the writer for the annotation type being documented\n-     * @return the member writer\n-     *\/\n-    AnnotationTypeMemberWriter getAnnotationTypeMemberWriter(\n-            ClassWriter classWriter);\n-\n-    \/**\n-     * Return the annotation type optional member writer for a given annotation\n-     * type, or null if this writer is not supported by the doclet.\n-     *\n-     * @param classWriter the writer for the annotation type being documented\n-     * @return the member writer\n-     *\/\n-    AnnotationTypeMemberWriter getAnnotationTypeOptionalMemberWriter(\n-            ClassWriter classWriter);\n-\n-    \/**\n-     * Return the annotation type required member writer for a given annotation\n-     * type, or null if this writer is not supported by the doclet.\n-     *\n-     * @param classWriter the writer for the annotation type being documented\n-     * @return the member writer\n-     *\/\n-    AnnotationTypeMemberWriter getAnnotationTypeRequiredMemberWriter(\n-            ClassWriter classWriter);\n-\n-    \/**\n-     * Return the enum constant writer for a given type element,\n-     * or null if this writer is not supported by the doclet.\n-     *\n-     * @param classWriter the writer for the type element being documented\n-     * @return the enum constant writer\n-     *\/\n-    EnumConstantWriter getEnumConstantWriter(ClassWriter classWriter);\n-\n-    \/**\n-     * Return the field writer for a given type element,\n-     * or null if this writer is not supported by the doclet.\n-     *\n-     * @param classWriter the writer for the class being documented\n-     * @return the field writer for the given class.  Return null if this\n-     * writer is not supported by the doclet.\n-     *\/\n-    FieldWriter getFieldWriter(ClassWriter classWriter);\n-\n-    \/**\n-     * Return the property writer for a given class,\n-     * or null if this writer is not supported by the doclet.\n-     *\n-     * @param classWriter the writer for the type element being documented\n-     * @return the property writer\n-     *\/\n-    PropertyWriter getPropertyWriter(ClassWriter classWriter);\n-\n-    \/**\n-     * Return the constructor writer for a given type element,\n-     * or null if this writer is not supported by the doclet.\n-     *\n-     * @param classWriter the writer for the type element being documented\n-     * @return the constructor writer\n-     *\/\n-    ConstructorWriter getConstructorWriter(ClassWriter classWriter);\n-\n-    \/**\n-     * Return the specified member summary writer for a given type element,\n-     * or null if this writer is not supported by the doclet.\n-     *\n-     * @param classWriter the writer for the class being documented\n-     * @param memberType  the {@link VisibleMemberTable} member type indicating\n-     *                    the type of member summary that should be returned\n-     * @return the summary writer\n-     *\n-     * @see VisibleMemberTable\n-     *\/\n-    MemberSummaryWriter getMemberSummaryWriter(ClassWriter classWriter,\n-                                               VisibleMemberTable.Kind memberType);\n-\n-    \/**\n-     * Return the writer for the serialized form.\n-     *\n-     * @return the writer for the serialized form\n-     *\/\n-    SerializedFormWriter getSerializedFormWriter();\n-\n-    \/**\n-     * Return the handler for doc files.\n-     *\n-     * @return the handler for the doc files\n-     *\/\n-    DocFilesHandler getDocFilesHandler(Element pkg);\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/WriterFactory.java","additions":0,"deletions":180,"binary":false,"changes":180,"status":"deleted"},{"patch":"@@ -1,108 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.builders;\n-\n-import java.util.*;\n-\n-import javax.lang.model.element.PackageElement;\n-\n-import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n-import jdk.javadoc.internal.doclets.toolkit.BaseOptions;\n-import jdk.javadoc.internal.doclets.toolkit.DocletException;\n-import jdk.javadoc.internal.doclets.toolkit.Messages;\n-import jdk.javadoc.internal.doclets.toolkit.Resources;\n-import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n-\n-\n-\/**\n- * The superclass for all builders.  A builder is a class that provides\n- * the structure and content of API documentation.  A builder is completely\n- * doclet independent which means that any doclet can use builders to\n- * construct documentation, as long as it implements the appropriate\n- * writer interfaces.  For example, if a doclet wanted to use\n- * {@link ConstantsSummaryBuilder} to build a constant summary, all it has to\n- * do is implement the ConstantsSummaryWriter interface and pass it to the\n- * builder using a WriterFactory.\n- *\/\n-public abstract class AbstractBuilder {\n-    public static class Context {\n-        \/**\n-         * The configuration used in this run of the doclet.\n-         *\/\n-        final BaseConfiguration configuration;\n-\n-        \/**\n-         * Keep track of which packages we have seen for\n-         * efficiency purposes.  We don't want to copy the\n-         * doc files multiple times for a single package.\n-         *\/\n-        final Set<PackageElement> containingPackagesSeen;\n-\n-        Context(BaseConfiguration configuration, Set<PackageElement> containingPackagesSeen) {\n-            this.configuration = configuration;\n-            this.containingPackagesSeen = containingPackagesSeen;\n-        }\n-    }\n-\n-    \/**\n-     * The configuration used in this run of the doclet.\n-     *\/\n-    protected final BaseConfiguration configuration;\n-    protected final BaseOptions options;\n-\n-    protected final BuilderFactory builderFactory;\n-    protected final Messages messages;\n-    protected final Resources resources;\n-    protected final Utils utils;\n-\n-    \/**\n-     * Keep track of which packages we have seen for\n-     * efficiency purposes.  We don't want to copy the\n-     * doc files multiple times for a single package.\n-     *\/\n-    protected final Set<PackageElement> containingPackagesSeen;\n-\n-    \/**\n-     * Construct a Builder.\n-     * @param c a context providing information used in this run of the doclet\n-     *\/\n-    public AbstractBuilder(Context c) {\n-        this.configuration = c.configuration;\n-        this.options = configuration.getOptions();\n-        this.builderFactory = configuration.getBuilderFactory();\n-        this.messages = configuration.getMessages();\n-        this.resources = configuration.getDocResources();\n-        this.utils = configuration.utils;\n-        this.containingPackagesSeen = c.containingPackagesSeen;\n-    }\n-\n-    \/**\n-     * Build the documentation.\n-     *\n-     * @throws DocletException if there is a problem building the documentation\n-     *\/\n-    public abstract void build() throws DocletException;\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/builders\/AbstractBuilder.java","additions":0,"deletions":108,"binary":false,"changes":108,"status":"deleted"},{"patch":"@@ -1,94 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.builders;\n-\n-import java.util.List;\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.TypeElement;\n-\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.DocletException;\n-import jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable;\n-import jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable.Kind;\n-\n-\/**\n- * The superclass for all member builders.  Member builders are only executed\n- * within Class Builders.  They essentially build subcomponents.  For example,\n- * method documentation is a subcomponent of class documentation.\n- *\/\n-public abstract class AbstractMemberBuilder extends AbstractBuilder {\n-\n-    protected final TypeElement typeElement;\n-\n-    protected final VisibleMemberTable visibleMemberTable;\n-\n-    \/**\n-     * Construct a SubBuilder.\n-     * @param context a context object, providing information used in this run\n-     *        of the doclet.\n-     *\/\n-    public AbstractMemberBuilder(Context context, TypeElement typeElement) {\n-        super(context);\n-        this.typeElement = typeElement;\n-        visibleMemberTable = configuration.getVisibleMemberTable(typeElement);\n-    }\n-\n-    \/**\n-     * This method is not supported by subbuilders.\n-     *\n-     * @throws AssertionError always\n-     *\/\n-    @Override\n-    public void build() {\n-        \/\/ You may not call the build method in a subbuilder.\n-        throw new AssertionError();\n-    }\n-\n-    \/**\n-     * Build the documentation.\n-     *\n-     * @param target the content into which to add the documentation\n-     * @throws DocletException if there is a problem building the documentation\n-     *\/\n-    public abstract void build(Content target) throws DocletException;\n-\n-    \/**\n-     * Returns true if this subbuilder has anything to document.\n-     *\n-     * @return true if this subbuilder has anything to document\n-     *\/\n-    public abstract boolean hasMembersToDocument();\n-\n-    \/**\n-     * Returns a list of visible elements of the specified kind in this\n-     * type element.\n-     * @param kind of members\n-     * @return a list of members\n-     *\/\n-    protected List<Element> getVisibleMembers(Kind kind) {\n-        return visibleMemberTable.getVisibleMembers(kind);\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/builders\/AbstractMemberBuilder.java","additions":0,"deletions":94,"binary":false,"changes":94,"status":"deleted"},{"patch":"@@ -1,209 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.builders;\n-\n-import java.util.*;\n-\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.TypeElement;\n-\n-import jdk.javadoc.internal.doclets.toolkit.AnnotationTypeMemberWriter;\n-import jdk.javadoc.internal.doclets.toolkit.BaseOptions;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.DocletException;\n-\n-import static jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable.Kind.*;\n-\n-\/**\n- * Builds documentation for required annotation type members.\n- *\/\n-public class AnnotationTypeMemberBuilder extends AbstractMemberBuilder {\n-\n-    \/**\n-     * The writer to output the member documentation.\n-     *\/\n-    protected AnnotationTypeMemberWriter writer;\n-\n-    \/**\n-     * The list of members being documented.\n-     *\/\n-    protected List<Element> members;\n-\n-    \/**\n-     * The index of the current member that is being documented at this point\n-     * in time.\n-     *\/\n-    protected Element currentMember;\n-\n-    \/**\n-     * Construct a new AnnotationTypeRequiredMemberBuilder.\n-     *\n-     * @param context  the build context.\n-     * @param typeElement the class whose members are being documented.\n-     * @param writer the doclet specific writer.\n-     *\/\n-    protected AnnotationTypeMemberBuilder(Context context,\n-                                          TypeElement typeElement,\n-                                          AnnotationTypeMemberWriter writer) {\n-        super(context, typeElement);\n-        this.writer = Objects.requireNonNull(writer);\n-        \/\/ In contrast to the annotation interface member summaries the details generated\n-        \/\/ by this builder share a single list for both required and optional members.\n-        this.members = getVisibleMembers(ANNOTATION_TYPE_MEMBER);\n-    }\n-\n-\n-    \/**\n-     * Construct a new AnnotationTypeMemberBuilder.\n-     *\n-     * @param context  the build context.\n-     * @param typeElement the class whose members are being documented.\n-     * @param writer the doclet specific writer.\n-     * @return an instance of this object\n-     *\/\n-    public static AnnotationTypeMemberBuilder getInstance(\n-            Context context, TypeElement typeElement,\n-            AnnotationTypeMemberWriter writer) {\n-        return new AnnotationTypeMemberBuilder(context, typeElement,\n-                writer);\n-    }\n-\n-    \/**\n-     * Returns whether or not there are members to document.\n-     * @return whether or not there are members to document\n-     *\/\n-    @Override\n-    public boolean hasMembersToDocument() {\n-        return !members.isEmpty();\n-    }\n-\n-    @Override\n-    public void build(Content target) throws DocletException {\n-        buildAnnotationTypeMember(target);\n-    }\n-\n-    \/**\n-     * Build the member documentation.\n-     *\n-     * @param target the content to which the documentation will be added\n-     * @throws DocletException if an error occurs\n-     *\/\n-    protected void buildAnnotationTypeMember(Content target)\n-            throws DocletException {\n-        if (hasMembersToDocument()) {\n-            writer.addAnnotationDetailsMarker(target);\n-            Content annotationDetailsHeader = writer.getAnnotationDetailsHeader();\n-            Content memberList = writer.getMemberList();\n-\n-            for (Element member : members) {\n-                currentMember = member;\n-                Content annotationContent = writer.getAnnotationHeaderContent(currentMember);\n-\n-                buildAnnotationTypeMemberChildren(annotationContent);\n-\n-                memberList.add(writer.getMemberListItem(annotationContent));\n-            }\n-            Content annotationDetails = writer.getAnnotationDetails(annotationDetailsHeader, memberList);\n-            target.add(annotationDetails);\n-        }\n-    }\n-\n-    protected void buildAnnotationTypeMemberChildren(Content annotationContent) {\n-        buildSignature(annotationContent);\n-        buildDeprecationInfo(annotationContent);\n-        buildPreviewInfo(annotationContent);\n-        buildMemberComments(annotationContent);\n-        buildTagInfo(annotationContent);\n-        buildDefaultValueInfo(annotationContent);\n-    }\n-\n-    \/**\n-     * Build the signature.\n-     *\n-     * @param target the content to which the documentation will be added\n-     *\/\n-    protected void buildSignature(Content target) {\n-        target.add(writer.getSignature(currentMember));\n-    }\n-\n-    \/**\n-     * Build the deprecation information.\n-     *\n-     * @param annotationContent the content to which the documentation will be added\n-     *\/\n-    protected void buildDeprecationInfo(Content annotationContent) {\n-        writer.addDeprecated(currentMember, annotationContent);\n-    }\n-\n-    \/**\n-     * Build the preview information.\n-     *\n-     * @param annotationContent the content to which the documentation will be added\n-     *\/\n-    protected void buildPreviewInfo(Content annotationContent) {\n-        writer.addPreview(currentMember, annotationContent);\n-    }\n-\n-    \/**\n-     * Build the comments for the member.  Do nothing if\n-     * {@link BaseOptions#noComment()} is set to true.\n-     *\n-     * @param annotationContent the content to which the documentation will be added\n-     *\/\n-    protected void buildMemberComments(Content annotationContent) {\n-        if (!options.noComment()) {\n-            writer.addComments(currentMember, annotationContent);\n-        }\n-    }\n-\n-    \/**\n-     * Build the tag information.\n-     *\n-     * @param annotationContent the content to which the documentation will be added\n-     *\/\n-    protected void buildTagInfo(Content annotationContent) {\n-        writer.addTags(currentMember, annotationContent);\n-    }\n-\n-    \/**\n-     * Build the default value for this optional member.\n-     *\n-     * @param annotationContent the content to which the documentation will be added\n-     *\/\n-    protected void buildDefaultValueInfo(Content annotationContent) {\n-        writer.addDefaultValueInfo(currentMember, annotationContent);\n-    }\n-\n-    \/**\n-     * Return the annotation type required member writer for this builder.\n-     *\n-     * @return the annotation type required member constant writer for this\n-     * builder.\n-     *\/\n-    public AnnotationTypeMemberWriter getWriter() {\n-        return writer;\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/builders\/AnnotationTypeMemberBuilder.java","additions":0,"deletions":209,"binary":false,"changes":209,"status":"deleted"},{"patch":"@@ -1,199 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.builders;\n-\n-import java.util.HashSet;\n-import java.util.Set;\n-\n-import javax.lang.model.element.ModuleElement;\n-import javax.lang.model.element.PackageElement;\n-import javax.lang.model.element.TypeElement;\n-\n-import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n-import jdk.javadoc.internal.doclets.toolkit.ClassWriter;\n-import jdk.javadoc.internal.doclets.toolkit.PropertyWriter;\n-import jdk.javadoc.internal.doclets.toolkit.WriterFactory;\n-import jdk.javadoc.internal.doclets.toolkit.util.ClassTree;\n-\n-\/**\n- * The factory for constructing builders.\n- *\/\n-public class BuilderFactory {\n-\n-    \/**\n-     * The factory to retrieve the required writers from.\n-     *\/\n-    private final WriterFactory writerFactory;\n-\n-    private final AbstractBuilder.Context context;\n-\n-    \/**\n-     * Construct a builder factory using the given configuration.\n-     * @param configuration the configuration for the current doclet\n-     * being executed.\n-     *\/\n-    public BuilderFactory (BaseConfiguration configuration) {\n-        this.writerFactory = configuration.getWriterFactory();\n-\n-        Set<PackageElement> containingPackagesSeen = new HashSet<>();\n-        context = new AbstractBuilder.Context(configuration, containingPackagesSeen);\n-    }\n-\n-    \/**\n-     * Return the builder that builds the constant summary.\n-     * @return the builder that builds the constant summary.\n-     *\/\n-    public AbstractBuilder getConstantsSummaryBuilder() {\n-        return ConstantsSummaryBuilder.getInstance(context);\n-    }\n-\n-    \/**\n-     * Return the builder that builds the package summary.\n-     *\n-     * @param pkg the package being documented.\n-     * @return the builder that builds the package summary.\n-     *\/\n-    public AbstractBuilder getPackageSummaryBuilder(PackageElement pkg) {\n-        return PackageSummaryBuilder.getInstance(context, pkg,\n-            writerFactory.getPackageSummaryWriter(pkg));\n-    }\n-\n-    \/**\n-     * Return the builder that builds the module summary.\n-     *\n-     * @param mdle the module being documented.\n-     * @return the builder that builds the module summary.\n-     *\/\n-    public AbstractBuilder getModuleSummaryBuilder(ModuleElement mdle) {\n-        return ModuleSummaryBuilder.getInstance(context, mdle,\n-            writerFactory.getModuleSummaryWriter(mdle));\n-    }\n-\n-    \/**\n-     * Return the builder for the class.\n-     *\n-     * @param typeElement the class being documented.\n-     * @param classTree the class tree.\n-     * @return the writer for the class.  Return null if this\n-     * writer is not supported by the doclet.\n-     *\/\n-    public AbstractBuilder getClassBuilder(TypeElement typeElement, ClassTree classTree) {\n-        return ClassBuilder.getInstance(context, typeElement,\n-            writerFactory.getClassWriter(typeElement, classTree));\n-    }\n-\n-    \/**\n-     * Return an instance of the method builder for the given class.\n-     *\n-     * @param classWriter the writer for the enclosing class\n-     * @return an instance of the method builder for the given class.\n-     *\/\n-    public AbstractMemberBuilder getMethodBuilder(ClassWriter classWriter) {\n-        return MethodBuilder.getInstance(context, classWriter.getTypeElement(),\n-            writerFactory.getMethodWriter(classWriter));\n-    }\n-\n-    \/**\n-     * Return an instance of the annotation type member builder for the given\n-     * class.\n-     *\n-     * @param classWriter the writer for the enclosing annotation type\n-     * @return an instance of the annotation type member builder for the given\n-     *         annotation type.\n-     *\/\n-    public AbstractMemberBuilder getAnnotationTypeMemberBuilder(\n-            ClassWriter classWriter) {\n-        return AnnotationTypeMemberBuilder.getInstance(context,\n-            classWriter.getTypeElement(),\n-            writerFactory.getAnnotationTypeMemberWriter(classWriter));\n-    }\n-\n-    \/**\n-     * Return an instance of the enum constants builder for the given class.\n-     *\n-     * @param classWriter the writer for the enclosing class\n-     * @return an instance of the enum constants builder for the given class.\n-     *\/\n-    public AbstractMemberBuilder getEnumConstantsBuilder(ClassWriter classWriter) {\n-        return EnumConstantBuilder.getInstance(context, classWriter.getTypeElement(),\n-                writerFactory.getEnumConstantWriter(classWriter));\n-    }\n-\n-    \/**\n-     * Return an instance of the field builder for the given class.\n-     *\n-     * @param classWriter the writer for the enclosing class\n-     * @return an instance of the field builder for the given class.\n-     *\/\n-    public AbstractMemberBuilder getFieldBuilder(ClassWriter classWriter) {\n-        return FieldBuilder.getInstance(context, classWriter.getTypeElement(),\n-            writerFactory.getFieldWriter(classWriter));\n-    }\n-\n-    \/**\n-     * Return an instance of the property builder for the given class.\n-     *\n-     * @param classWriter the writer for the enclosing class\n-     * @return an instance of the field builder for the given class.\n-     *\/\n-    public AbstractMemberBuilder getPropertyBuilder(ClassWriter classWriter) {\n-        final PropertyWriter propertyWriter =\n-                writerFactory.getPropertyWriter(classWriter);\n-        return PropertyBuilder.getInstance(context,\n-                                           classWriter.getTypeElement(),\n-                                           propertyWriter);\n-    }\n-\n-    \/**\n-     * Return an instance of the constructor builder for the given class.\n-     *\n-     * @param classWriter the writer for the enclosing class\n-     * @return an instance of the constructor builder for the given class.\n-     *\/\n-    public AbstractMemberBuilder getConstructorBuilder(ClassWriter classWriter) {\n-        return ConstructorBuilder.getInstance(context, classWriter.getTypeElement(),\n-            writerFactory.getConstructorWriter(classWriter));\n-    }\n-\n-    \/**\n-     * Return an instance of the member summary builder for the given class.\n-     *\n-     * @param classWriter the writer for the enclosing class\n-     * @return an instance of the member summary builder for the given class.\n-     *\/\n-    public MemberSummaryBuilder getMemberSummaryBuilder(ClassWriter classWriter) {\n-        return MemberSummaryBuilder.getInstance(classWriter, context);\n-    }\n-\n-    \/**\n-     * Return the builder that builds the serialized form.\n-     *\n-     * @return the builder that builds the serialized form.\n-     *\/\n-    public AbstractBuilder getSerializedFormBuilder() {\n-        return SerializedFormBuilder.getInstance(context);\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/builders\/BuilderFactory.java","additions":0,"deletions":199,"binary":false,"changes":199,"status":"deleted"},{"patch":"@@ -1,476 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.builders;\n-\n-import java.util.List;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.ExecutableElement;\n-import javax.lang.model.element.Name;\n-import javax.lang.model.element.PackageElement;\n-import javax.lang.model.element.TypeElement;\n-import javax.lang.model.element.VariableElement;\n-import javax.lang.model.type.TypeMirror;\n-\n-import jdk.javadoc.internal.doclets.toolkit.ClassWriter;\n-import jdk.javadoc.internal.doclets.toolkit.CommentUtils;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.DocFilesHandler;\n-import jdk.javadoc.internal.doclets.toolkit.DocletException;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocFileIOException;\n-import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n-\n-\/**\n- * Builds the summary for a given class.\n- *\/\n-public class ClassBuilder extends AbstractBuilder {\n-\n-    \/**\n-     * The class being documented.\n-     *\/\n-    private final TypeElement typeElement;\n-\n-    \/**\n-     * The doclet specific writer.\n-     *\/\n-    private final ClassWriter writer;\n-\n-    private final Utils utils;\n-\n-    \/**\n-     * Construct a new ClassBuilder.\n-     *\n-     * @param context  the build context\n-     * @param typeElement the class being documented.\n-     * @param writer the doclet specific writer.\n-     *\/\n-    private ClassBuilder(Context context, TypeElement typeElement, ClassWriter writer) {\n-        super(context);\n-        this.typeElement = typeElement;\n-        this.writer = writer;\n-        this.utils = configuration.utils;\n-        switch (typeElement.getKind()) {\n-            case ENUM   -> setEnumDocumentation(typeElement);\n-            case RECORD -> setRecordDocumentation(typeElement);\n-        }\n-    }\n-\n-    \/**\n-     * Constructs a new ClassBuilder.\n-     *\n-     * @param context  the build context\n-     * @param typeElement the class being documented.\n-     * @param writer the doclet specific writer.\n-     * @return the new ClassBuilder\n-     *\/\n-    public static ClassBuilder getInstance(Context context, TypeElement typeElement, ClassWriter writer) {\n-        return new ClassBuilder(context, typeElement, writer);\n-    }\n-\n-    @Override\n-    public void build() throws DocletException {\n-        buildClassDoc();\n-    }\n-\n-    \/**\n-     * Handles the {@literal <TypeElement>} tag.\n-     *\n-     * @throws DocletException if there is a problem while building the documentation\n-     *\/\n-    protected void buildClassDoc() throws DocletException {\n-        String key = switch (typeElement.getKind()) {\n-            case INTERFACE       -> \"doclet.Interface\";\n-            case ENUM            -> \"doclet.Enum\";\n-            case RECORD          -> \"doclet.RecordClass\";\n-            case ANNOTATION_TYPE -> \"doclet.AnnotationType\";\n-            case CLASS           -> \"doclet.Class\";\n-            default -> throw new IllegalStateException(typeElement.getKind() + \" \" + typeElement);\n-        };\n-        Content content = writer.getHeader(resources.getText(key) + \" \"\n-                + utils.getSimpleName(typeElement));\n-        Content classContent = writer.getClassContentHeader();\n-\n-        buildClassTree(classContent);\n-        buildClassInfo(classContent);\n-        buildMemberSummary(classContent);\n-        buildMemberDetails(classContent);\n-\n-        writer.addClassContent(classContent);\n-        writer.addFooter();\n-        writer.printDocument(content);\n-        copyDocFiles();\n-    }\n-\n-    \/**\n-     * Build the class inheritance tree documentation.\n-     *\n-     * @param classContent the content to which the documentation will be added\n-     *\/\n-    protected void buildClassTree(Content classContent) {\n-        writer.addClassTree(classContent);\n-    }\n-\n-    \/**\n-     * Build the class information documentation.\n-     *\n-     * @param target the content to which the documentation will be added\n-     * @throws DocletException if there is a problem while building the documentation\n-     *\/\n-    protected void buildClassInfo(Content target) throws DocletException {\n-        Content c = writer.getOutputInstance();\n-        buildParamInfo(c);\n-        buildSuperInterfacesInfo(c);\n-        buildImplementedInterfacesInfo(c);\n-        buildSubClassInfo(c);\n-        buildSubInterfacesInfo(c);\n-        buildInterfaceUsageInfo(c);\n-        buildNestedClassInfo(c);\n-        buildFunctionalInterfaceInfo(c);\n-        buildClassSignature(c);\n-        buildDeprecationInfo(c);\n-        buildClassDescription(c);\n-        buildClassTagInfo(c);\n-\n-        target.add(writer.getClassInfo(c));\n-    }\n-\n-    \/**\n-     * Build the type parameters and state components of this class.\n-     *\n-     * @param target the content to which the documentation will be added\n-     *\/\n-    protected void buildParamInfo(Content target) {\n-        writer.addParamInfo(target);\n-    }\n-\n-    \/**\n-     * If this is an interface, list all superinterfaces.\n-     *\n-     * @param target the content to which the documentation will be added\n-     *\/\n-    protected void buildSuperInterfacesInfo(Content target) {\n-        writer.addSuperInterfacesInfo(target);\n-    }\n-\n-    \/**\n-     * If this is a class, list all interfaces implemented by this class.\n-     *\n-     * @param target the content to which the documentation will be added\n-     *\/\n-    protected void buildImplementedInterfacesInfo(Content target) {\n-        writer.addImplementedInterfacesInfo(target);\n-    }\n-\n-    \/**\n-     * List all the classes that extend this one.\n-     *\n-     * @param target the content to which the documentation will be added\n-     *\/\n-    protected void buildSubClassInfo(Content target) {\n-        writer.addSubClassInfo(target);\n-    }\n-\n-    \/**\n-     * List all the interfaces that extend this one.\n-     *\n-     * @param target the content to which the documentation will be added\n-     *\/\n-    protected void buildSubInterfacesInfo(Content target) {\n-        writer.addSubInterfacesInfo(target);\n-    }\n-\n-    \/**\n-     * If this is an interface, list all classes that implement this interface.\n-     *\n-     * @param target the content to which the documentation will be added\n-     *\/\n-    protected void buildInterfaceUsageInfo(Content target) {\n-        writer.addInterfaceUsageInfo(target);\n-    }\n-\n-    \/**\n-     * If this is an functional interface, display appropriate message.\n-     *\n-     * @param target the content to which the documentation will be added\n-     *\/\n-    protected void buildFunctionalInterfaceInfo(Content target) {\n-        writer.addFunctionalInterfaceInfo(target);\n-    }\n-\n-    \/**\n-     * If this class is deprecated, build the appropriate information.\n-     *\n-     * @param target the content to which the documentation will be added\n-     *\/\n-    protected void buildDeprecationInfo(Content target) {\n-        writer.addClassDeprecationInfo(target);\n-    }\n-\n-    \/**\n-     * If this is an inner class or interface, list the enclosing class or interface.\n-     *\n-     * @param target the content to which the documentation will be added\n-     *\/\n-    protected void buildNestedClassInfo(Content target) {\n-        writer.addNestedClassInfo(target);\n-    }\n-\n-    \/**\n-     * Copy the doc files.\n-     *\n-     * @throws DocFileIOException if there is a problem while copying the files\n-     *\/\n-    private void copyDocFiles() throws DocletException {\n-        PackageElement containingPackage = utils.containingPackage(typeElement);\n-        if ((configuration.packages == null ||\n-            !configuration.packages.contains(containingPackage)) &&\n-            !containingPackagesSeen.contains(containingPackage)) {\n-            \/\/Only copy doc files dir if the containing package is not\n-            \/\/documented AND if we have not documented a class from the same\n-            \/\/package already. Otherwise, we are making duplicate copies.\n-            DocFilesHandler docFilesHandler = configuration\n-                    .getWriterFactory()\n-                    .getDocFilesHandler(containingPackage);\n-            docFilesHandler.copyDocFiles();\n-            containingPackagesSeen.add(containingPackage);\n-        }\n-    }\n-\n-    \/**\n-     * Build the signature of the current class.\n-     *\n-     * @param target the content to which the documentation will be added\n-     *\/\n-    protected void buildClassSignature(Content target) {\n-        writer.addClassSignature(target);\n-    }\n-\n-    \/**\n-     * Build the class description.\n-     *\n-     * @param target the content to which the documentation will be added\n-     *\/\n-    protected void buildClassDescription(Content target) {\n-        writer.addClassDescription(target);\n-    }\n-\n-    \/**\n-     * Build the tag information for the current class.\n-     *\n-     * @param target the content to which the documentation will be added\n-     *\/\n-    protected void buildClassTagInfo(Content target) {\n-        writer.addClassTagInfo(target);\n-    }\n-\n-    \/**\n-     * Build the member summary contents of the page.\n-     *\n-     * @param classContent the content to which the documentation will be added\n-     * @throws DocletException if there is a problem while building the documentation\n-     *\/\n-    protected void buildMemberSummary(Content classContent) throws DocletException {\n-        Content summariesList = writer.getSummariesList();\n-        builderFactory.getMemberSummaryBuilder(writer).build(summariesList);\n-        classContent.add(writer.getMemberSummary(summariesList));\n-    }\n-\n-    \/**\n-     * Build the member details contents of the page.\n-     *\n-     * @param classContent the content to which the documentation will be added\n-     * @throws DocletException if there is a problem while building the documentation\n-     *\/\n-    protected void buildMemberDetails(Content classContent) throws DocletException {\n-        Content detailsList = writer.getDetailsList();\n-\n-        buildEnumConstantsDetails(detailsList);\n-        buildPropertyDetails(detailsList);\n-        buildFieldDetails(detailsList);\n-        buildConstructorDetails(detailsList);\n-        buildAnnotationTypeMemberDetails(detailsList);\n-        buildMethodDetails(detailsList);\n-\n-        classContent.add(writer.getMemberDetails(detailsList));\n-    }\n-\n-    \/**\n-     * Build the enum constants documentation.\n-     *\n-     * @param detailsList the content to which the documentation will be added\n-     * @throws DocletException if there is a problem while building the documentation\n-     *\/\n-    protected void buildEnumConstantsDetails(Content detailsList) throws DocletException {\n-        builderFactory.getEnumConstantsBuilder(writer).build(detailsList);\n-    }\n-\n-    \/**\n-     * Build the field documentation.\n-     *\n-     * @param detailsList the content to which the documentation will be added\n-     * @throws DocletException if there is a problem while building the documentation\n-     *\/\n-    protected void buildFieldDetails(Content detailsList) throws DocletException {\n-        builderFactory.getFieldBuilder(writer).build(detailsList);\n-    }\n-\n-    \/**\n-     * Build the property documentation.\n-     *\n-     * @param detailsList the content to which the documentation will be added\n-     * @throws DocletException if there is a problem while building the documentation\n-     *\/\n-    public void buildPropertyDetails( Content detailsList) throws DocletException {\n-        builderFactory.getPropertyBuilder(writer).build(detailsList);\n-    }\n-\n-    \/**\n-     * Build the constructor documentation.\n-     *\n-     * @param detailsList the content to which the documentation will be added\n-     * @throws DocletException if there is a problem while building the documentation\n-     *\/\n-    protected void buildConstructorDetails(Content detailsList) throws DocletException {\n-        builderFactory.getConstructorBuilder(writer).build(detailsList);\n-    }\n-\n-    \/**\n-     * Build the method documentation.\n-     *\n-     * @param detailsList the content to which the documentation will be added\n-     * @throws DocletException if there is a problem while building the documentation\n-     *\/\n-    protected void buildMethodDetails(Content detailsList) throws DocletException {\n-        builderFactory.getMethodBuilder(writer).build(detailsList);\n-    }\n-\n-    \/**\n-     * Build the annotation type optional member documentation.\n-     *\n-     * @param target the content to which the documentation will be added\n-     * @throws DocletException if there is a problem building the documentation\n-     *\/\n-    protected void buildAnnotationTypeMemberDetails(Content target)\n-            throws DocletException {\n-        builderFactory.getAnnotationTypeMemberBuilder(writer).build(target);\n-    }\n-\n-    \/**\n-     * The documentation for values() and valueOf() in Enums are set by the\n-     * doclet only iff the user or overridden methods are missing.\n-     * @param elem the enum element\n-     *\/\n-    private void setEnumDocumentation(TypeElement elem) {\n-        CommentUtils cmtUtils = configuration.cmtUtils;\n-        for (ExecutableElement ee : utils.getMethods(elem)) {\n-            if (!utils.getFullBody(ee).isEmpty()) \/\/ ignore if already set\n-                continue;\n-            Name name = ee.getSimpleName();\n-            if (name.contentEquals(\"values\") && ee.getParameters().isEmpty()) {\n-                utils.removeCommentHelper(ee); \/\/ purge previous entry\n-                cmtUtils.setEnumValuesTree(ee);\n-            } else if (name.contentEquals(\"valueOf\") && ee.getParameters().size() == 1) {\n-                \/\/ TODO: check parameter type\n-                utils.removeCommentHelper(ee); \/\/ purge previous entry\n-                cmtUtils.setEnumValueOfTree(ee);\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Sets the documentation as needed for the mandated parts of a record type.\n-     * This includes the canonical constructor, methods like {@code equals},\n-     * {@code hashCode}, {@code toString}, the accessor methods, and the underlying\n-     * field.\n-     * @param elem the record element\n-     *\/\n-\n-    private void setRecordDocumentation(TypeElement elem) {\n-        CommentUtils cmtUtils = configuration.cmtUtils;\n-        Set<Name> componentNames = elem.getRecordComponents().stream()\n-                .map(Element::getSimpleName)\n-                .collect(Collectors.toSet());\n-\n-        for (ExecutableElement ee : utils.getConstructors(elem)) {\n-            if (utils.isCanonicalRecordConstructor(ee)) {\n-                if (utils.getFullBody(ee).isEmpty()) {\n-                    utils.removeCommentHelper(ee); \/\/ purge previous entry\n-                    cmtUtils.setRecordConstructorTree(ee);\n-                }\n-                \/\/ only one canonical constructor; no need to keep looking\n-                break;\n-            }\n-        }\n-\n-        var fields = utils.isSerializable(elem)\n-                ? utils.getFieldsUnfiltered(elem)\n-                : utils.getFields(elem);\n-        for (VariableElement ve : fields) {\n-            \/\/ The fields for the record component cannot be declared by the\n-            \/\/ user and so cannot have any pre-existing comment.\n-            Name name = ve.getSimpleName();\n-            if (componentNames.contains(name)) {\n-                utils.removeCommentHelper(ve); \/\/ purge previous entry\n-                cmtUtils.setRecordFieldTree(ve);\n-            }\n-        }\n-\n-        TypeMirror objectType = utils.getObjectType();\n-\n-        for (ExecutableElement ee : utils.getMethods(elem)) {\n-            if (!utils.getFullBody(ee).isEmpty()) {\n-                continue;\n-            }\n-\n-            Name name = ee.getSimpleName();\n-            List<? extends VariableElement> params = ee.getParameters();\n-            if (name.contentEquals(\"equals\")) {\n-                if (params.size() == 1 && utils.typeUtils.isSameType(params.get(0).asType(), objectType)) {\n-                    utils.removeCommentHelper(ee); \/\/ purge previous entry\n-                    cmtUtils.setRecordEqualsTree(ee);\n-                }\n-            } else if (name.contentEquals(\"hashCode\")) {\n-                if (params.isEmpty()) {\n-                    utils.removeCommentHelper(ee); \/\/ purge previous entry\n-                    cmtUtils.setRecordHashCodeTree(ee);\n-                }\n-            } else if (name.contentEquals(\"toString\")) {\n-                if (params.isEmpty()) {\n-                    utils.removeCommentHelper(ee); \/\/ purge previous entry\n-                    cmtUtils.setRecordToStringTree(ee);\n-                }\n-            } else if (componentNames.contains(name)) {\n-                if (params.isEmpty()) {\n-                    utils.removeCommentHelper(ee); \/\/ purge previous entry\n-                    cmtUtils.setRecordAccessorTree(ee);\n-                }\n-            }\n-        }\n-\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/builders\/ClassBuilder.java","additions":0,"deletions":476,"binary":false,"changes":476,"status":"deleted"},{"patch":"@@ -1,314 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.builders;\n-\n-import java.util.*;\n-\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.PackageElement;\n-import javax.lang.model.element.TypeElement;\n-import javax.lang.model.element.VariableElement;\n-\n-import jdk.javadoc.internal.doclets.toolkit.ConstantsSummaryWriter;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.DocletException;\n-import jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable;\n-\n-import static jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable.Kind.*;\n-\n-\/**\n- * Builds the Constants Summary Page.\n- *\/\n-public class ConstantsSummaryBuilder extends AbstractBuilder {\n-\n-    \/**\n-     * The maximum number of package directories shown in the headings of\n-     * the constant values contents list and headings.\n-     *\/\n-    private static final int MAX_CONSTANT_VALUE_INDEX_LENGTH = 2;\n-\n-    \/**\n-     * The writer used to write the results.\n-     *\/\n-    protected ConstantsSummaryWriter writer;\n-\n-    \/**\n-     * The set of type elements that have constant fields.\n-     *\/\n-    protected final Set<TypeElement> typeElementsWithConstFields;\n-\n-    \/**\n-     * The set of package-group headings.\n-     *\/\n-    protected final Set<String> packageGroupHeadings;\n-\n-    \/**\n-     * The current package being documented.\n-     *\/\n-    private PackageElement currentPackage;\n-\n-    \/**\n-     * The current class being documented.\n-     *\/\n-    private TypeElement currentClass;\n-\n-    \/**\n-     * Constructs a new {@code ConstantsSummaryBuilder}.\n-     *\n-     * @param context       the build context\n-     *\/\n-    private ConstantsSummaryBuilder(Context context) {\n-        super(context);\n-        this.typeElementsWithConstFields = new HashSet<>();\n-        this.packageGroupHeadings = new TreeSet<>(utils::compareStrings);\n-    }\n-\n-    \/**\n-     * Constructs a {@code ConstantsSummaryBuilder}.\n-     *\n-     * @param context       the build context\n-     * @return the new ConstantsSummaryBuilder\n-     *\/\n-    public static ConstantsSummaryBuilder getInstance(Context context) {\n-        return new ConstantsSummaryBuilder(context);\n-    }\n-\n-    @Override\n-    public void build() throws DocletException {\n-        boolean anyConstants = configuration.packages.stream().anyMatch(this::hasConstantField);\n-        if (!anyConstants) {\n-            return;\n-        }\n-\n-        writer = configuration.getWriterFactory().getConstantsSummaryWriter();\n-        if (writer == null) {\n-            \/\/Doclet does not support this output.\n-            return;\n-        }\n-        buildConstantSummary();\n-    }\n-\n-    \/**\n-     * Builds the constant summary page.\n-     *\n-     * @throws DocletException if there is a problem while building the documentation\n-     *\/\n-    protected void buildConstantSummary() throws DocletException {\n-        Content content = writer.getHeader();\n-\n-        buildContents();\n-        buildConstantSummaries();\n-\n-        writer.addFooter();\n-        writer.printDocument(content);\n-    }\n-\n-    \/**\n-     * Builds the list of contents for the groups of packages appearing in the constants summary page.\n-     *\/\n-    protected void buildContents() {\n-        Content contentList = writer.getContentsHeader();\n-        packageGroupHeadings.clear();\n-        for (PackageElement pkg : configuration.packages) {\n-            String abbrevPackageName = getAbbrevPackageName(pkg);\n-            if (hasConstantField(pkg) && !packageGroupHeadings.contains(abbrevPackageName)) {\n-                writer.addLinkToPackageContent(abbrevPackageName, contentList);\n-                packageGroupHeadings.add(abbrevPackageName);\n-            }\n-        }\n-        writer.addContentsList(contentList);\n-    }\n-\n-    \/**\n-     * Builds the summary for each documented package.\n-     *\n-     * @throws DocletException if there is a problem while building the documentation\n-     *\/\n-    protected void buildConstantSummaries() throws DocletException {\n-        packageGroupHeadings.clear();\n-        Content summaries = writer.getConstantSummaries();\n-        for (PackageElement aPackage : configuration.packages) {\n-            if (hasConstantField(aPackage)) {\n-                currentPackage = aPackage;\n-                \/\/Build the documentation for the current package.\n-                buildPackageHeader(summaries);\n-                buildClassConstantSummary();\n-            }\n-        }\n-        writer.addConstantSummaries(summaries);\n-    }\n-\n-    \/**\n-     * Builds the header for the given package.\n-     *\n-     * @param target the content to which the package header will be added\n-     *\/\n-    protected void buildPackageHeader(Content target) {\n-        String abbrevPkgName = getAbbrevPackageName(currentPackage);\n-        if (!packageGroupHeadings.contains(abbrevPkgName)) {\n-            writer.addPackageGroup(abbrevPkgName, target);\n-            packageGroupHeadings.add(abbrevPkgName);\n-        }\n-    }\n-\n-    \/**\n-     * Builds the summary for the current class.\n-     *\n-     * @throws DocletException if there is a problem while building the documentation\n-     *\/\n-    protected void buildClassConstantSummary()\n-            throws DocletException {\n-        SortedSet<TypeElement> classes = !currentPackage.isUnnamed()\n-                ? utils.getAllClasses(currentPackage)\n-                : configuration.typeElementCatalog.allUnnamedClasses();\n-        Content classConstantHeader = writer.getClassConstantHeader();\n-        for (TypeElement te : classes) {\n-            if (!typeElementsWithConstFields.contains(te) ||\n-                !utils.isIncluded(te)) {\n-                continue;\n-            }\n-            currentClass = te;\n-            \/\/Build the documentation for the current class.\n-\n-            buildConstantMembers(classConstantHeader);\n-\n-        }\n-        writer.addClassConstant(classConstantHeader);\n-    }\n-\n-    \/**\n-     * Builds the summary of constant members in the class.\n-     *\n-     * @param target the content to which the table of constant members will be added\n-     *\/\n-    protected void buildConstantMembers(Content target) {\n-        new ConstantFieldBuilder(currentClass).buildMembersSummary(target);\n-    }\n-\n-    \/**\n-     * {@return true if the given package has constant fields to document}\n-     *\n-     * @param pkg   the package to be checked\n-     *\/\n-    private boolean hasConstantField(PackageElement pkg) {\n-        SortedSet<TypeElement> classes = !pkg.isUnnamed()\n-                  ? utils.getAllClasses(pkg)\n-                  : configuration.typeElementCatalog.allUnnamedClasses();\n-        boolean found = false;\n-        for (TypeElement te : classes) {\n-            if (utils.isIncluded(te) && hasConstantField(te)) {\n-                found = true;\n-            }\n-        }\n-        return found;\n-    }\n-\n-    \/**\n-     * {@return true if the given class has constant fields to document}\n-     *\n-     * @param typeElement the class to be checked\n-     *\/\n-    private boolean hasConstantField (TypeElement typeElement) {\n-        VisibleMemberTable vmt = configuration.getVisibleMemberTable(typeElement);\n-        List<? extends Element> fields = vmt.getVisibleMembers(FIELDS);\n-        for (Element f : fields) {\n-            VariableElement field = (VariableElement)f;\n-            if (field.getConstantValue() != null) {\n-                typeElementsWithConstFields.add(typeElement);\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    \/**\n-     * {@return the abbreviated name for a package, containing the leading segments of the name}\n-     *\n-     * @param pkg the package\n-     *\/\n-    public String getAbbrevPackageName(PackageElement pkg) {\n-        if (pkg.isUnnamed()) {\n-            return \"\";\n-        }\n-\n-        String packageName = utils.getPackageName(pkg);\n-        int index = -1;\n-        for (int j = 0; j < MAX_CONSTANT_VALUE_INDEX_LENGTH; j++) {\n-            index = packageName.indexOf(\".\", index + 1);\n-        }\n-        return index == -1 ? packageName : packageName.substring(0, index);\n-    }\n-\n-    \/**\n-     * Builder for the table of fields with constant values.\n-     *\/\n-    private class ConstantFieldBuilder {\n-\n-        \/**\n-         * The type element that we are examining constants for.\n-         *\/\n-        protected TypeElement typeElement;\n-\n-        \/**\n-         * Constructs a {@code ConstantFieldBuilder}.\n-         * @param typeElement the type element that we are examining constants for\n-         *\/\n-        public ConstantFieldBuilder(TypeElement typeElement) {\n-            this.typeElement = typeElement;\n-        }\n-\n-        \/**\n-         * Builds the table of constants for a given class.\n-         *\n-         * @param target the content to which the table of class constants will be added\n-         *\/\n-        protected void buildMembersSummary(Content target) {\n-            SortedSet<VariableElement> members = members();\n-            if (!members.isEmpty()) {\n-                writer.addConstantMembers(typeElement, members, target);\n-            }\n-        }\n-\n-        \/**\n-         * {@return a set of visible constant fields for the given type}\n-         *\/\n-        protected SortedSet<VariableElement> members() {\n-            VisibleMemberTable vmt = configuration.getVisibleMemberTable(typeElement);\n-            List<Element> members = new ArrayList<>();\n-            members.addAll(vmt.getVisibleMembers(FIELDS));\n-            members.addAll(vmt.getVisibleMembers(ENUM_CONSTANTS));\n-            SortedSet<VariableElement> includes =\n-                    new TreeSet<>(utils.comparators.makeGeneralPurposeComparator());\n-            for (Element element : members) {\n-                VariableElement member = (VariableElement)element;\n-                if (member.getConstantValue() != null) {\n-                    includes.add(member);\n-                }\n-            }\n-            return includes;\n-        }\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/builders\/ConstantsSummaryBuilder.java","additions":0,"deletions":314,"binary":false,"changes":314,"status":"deleted"},{"patch":"@@ -1,188 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.builders;\n-\n-import java.util.*;\n-\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.ExecutableElement;\n-import javax.lang.model.element.TypeElement;\n-\n-import jdk.javadoc.internal.doclets.toolkit.BaseOptions;\n-import jdk.javadoc.internal.doclets.toolkit.ConstructorWriter;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.DocletException;\n-\n-import static jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable.Kind.*;\n-\n-\/**\n- * Builds documentation for a constructor.\n- *\/\n-public class ConstructorBuilder extends AbstractMemberBuilder {\n-\n-    \/**\n-     * The current constructor that is being documented at this point in time.\n-     *\/\n-    private ExecutableElement currentConstructor;\n-\n-    \/**\n-     * The writer to output the constructor documentation.\n-     *\/\n-    private final ConstructorWriter writer;\n-\n-    \/**\n-     * The constructors being documented.\n-     *\/\n-    private final List<? extends Element> constructors;\n-\n-    \/**\n-     * Construct a new ConstructorBuilder.\n-     *\n-     * @param context  the build context.\n-     * @param typeElement the class whose members are being documented.\n-     * @param writer the doclet specific writer.\n-     *\/\n-    private ConstructorBuilder(Context context,\n-            TypeElement typeElement,\n-            ConstructorWriter writer) {\n-        super(context, typeElement);\n-        this.writer = Objects.requireNonNull(writer);\n-        constructors = getVisibleMembers(CONSTRUCTORS);\n-        for (Element ctor : constructors) {\n-            if (utils.isProtected(ctor) || utils.isPrivate(ctor)) {\n-                writer.setFoundNonPubConstructor(true);\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Construct a new ConstructorBuilder.\n-     *\n-     * @param context  the build context.\n-     * @param typeElement the class whose members are being documented.\n-     * @param writer the doclet specific writer.\n-     * @return the new ConstructorBuilder\n-     *\/\n-    public static ConstructorBuilder getInstance(Context context,\n-            TypeElement typeElement, ConstructorWriter writer) {\n-        return new ConstructorBuilder(context, typeElement, writer);\n-    }\n-\n-    @Override\n-    public boolean hasMembersToDocument() {\n-        return !constructors.isEmpty();\n-    }\n-\n-    \/**\n-     * Return the constructor writer for this builder.\n-     *\n-     * @return the constructor writer for this builder.\n-     *\/\n-    public ConstructorWriter getWriter() {\n-        return writer;\n-    }\n-\n-    @Override\n-    public void build(Content target) throws DocletException {\n-        buildConstructorDoc(target);\n-    }\n-\n-    \/**\n-     * Build the constructor documentation.\n-     *\n-     * @param target the content to which the documentation will be added\n-     * @throws DocletException if there is a problem while building the documentation\n-     *\/\n-    protected void buildConstructorDoc(Content target) throws DocletException {\n-        if (hasMembersToDocument()) {\n-            Content constructorDetailsHeader = writer.getConstructorDetailsHeader(target);\n-            Content memberList = writer.getMemberList();\n-\n-            for (Element constructor : constructors) {\n-                currentConstructor = (ExecutableElement)constructor;\n-                Content constructorContent = writer.getConstructorHeaderContent(currentConstructor);\n-\n-                buildSignature(constructorContent);\n-                buildDeprecationInfo(constructorContent);\n-                buildPreviewInfo(constructorContent);\n-                buildConstructorComments(constructorContent);\n-                buildTagInfo(constructorContent);\n-\n-                memberList.add(writer.getMemberListItem(constructorContent));\n-            }\n-            Content constructorDetails = writer.getConstructorDetails(constructorDetailsHeader, memberList);\n-            target.add(constructorDetails);\n-        }\n-    }\n-\n-    \/**\n-     * Build the signature.\n-     *\n-     * @param constructorContent the content to which the documentation will be added\n-     *\/\n-    protected void buildSignature(Content constructorContent) {\n-        constructorContent.add(writer.getSignature(currentConstructor));\n-    }\n-\n-    \/**\n-     * Build the deprecation information.\n-     *\n-     * @param constructorContent the content to which the documentation will be added\n-     *\/\n-    protected void buildDeprecationInfo(Content constructorContent) {\n-        writer.addDeprecated(currentConstructor, constructorContent);\n-    }\n-\n-    \/**\n-     * Build the preview information.\n-     *\n-     * @param constructorContent the content to which the documentation will be added\n-     *\/\n-    protected void buildPreviewInfo(Content constructorContent) {\n-        writer.addPreview(currentConstructor, constructorContent);\n-    }\n-\n-    \/**\n-     * Build the comments for the constructor.  Do nothing if\n-     * {@link BaseOptions#noComment()} is set to true.\n-     *\n-     * @param constructorContent the content to which the documentation will be added\n-     *\/\n-    protected void buildConstructorComments(Content constructorContent) {\n-        if (!options.noComment()) {\n-            writer.addComments(currentConstructor, constructorContent);\n-        }\n-    }\n-\n-    \/**\n-     * Build the tag information.\n-     *\n-     * @param constructorContent the content to which the documentation will be added\n-     *\/\n-    protected void buildTagInfo(Content constructorContent) {\n-        writer.addTags(currentConstructor, constructorContent);\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/builders\/ConstructorBuilder.java","additions":0,"deletions":188,"binary":false,"changes":188,"status":"deleted"},{"patch":"@@ -1,191 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.builders;\n-\n-import java.util.*;\n-\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.TypeElement;\n-import javax.lang.model.element.VariableElement;\n-\n-import jdk.javadoc.internal.doclets.toolkit.BaseOptions;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.DocletException;\n-import jdk.javadoc.internal.doclets.toolkit.EnumConstantWriter;\n-\n-import static jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable.Kind.*;\n-\n-\/**\n- * Builds documentation for a enum constants.\n- *\/\n-public class EnumConstantBuilder extends AbstractMemberBuilder {\n-\n-    \/**\n-     * The writer to output the enum constants documentation.\n-     *\/\n-    private final EnumConstantWriter writer;\n-\n-    \/**\n-     * The set of enum constants being documented.\n-     *\/\n-    private final List<? extends Element> enumConstants;\n-\n-    \/**\n-     * The current enum constant that is being documented at this point\n-     * in time.\n-     *\/\n-    private VariableElement currentElement;\n-\n-    \/**\n-     * Construct a new EnumConstantsBuilder.\n-     *\n-     * @param context  the build context.\n-     * @param typeElement the class whose members are being documented.\n-     * @param writer the doclet specific writer.\n-     *\/\n-    private EnumConstantBuilder(Context context,\n-            TypeElement typeElement, EnumConstantWriter writer) {\n-        super(context, typeElement);\n-        this.writer = Objects.requireNonNull(writer);\n-        enumConstants = getVisibleMembers(ENUM_CONSTANTS);\n-    }\n-\n-    \/**\n-     * Construct a new EnumConstantsBuilder.\n-     *\n-     * @param context  the build context.\n-     * @param typeElement the class whose members are being documented.\n-     * @param writer the doclet specific writer.\n-     * @return the new EnumConstantsBuilder\n-     *\/\n-    public static EnumConstantBuilder getInstance(Context context,\n-            TypeElement typeElement, EnumConstantWriter writer) {\n-        return new EnumConstantBuilder(context, typeElement, writer);\n-    }\n-\n-    \/**\n-     * Returns whether or not there are members to document.\n-     *\n-     * @return whether or not there are members to document\n-     *\/\n-    @Override\n-    public boolean hasMembersToDocument() {\n-        return !enumConstants.isEmpty();\n-    }\n-\n-    @Override\n-    public void build(Content target) throws DocletException {\n-        buildEnumConstant(target);\n-    }\n-\n-    \/**\n-     * Build the enum constant documentation.\n-     *\n-     * @param target the content to which the documentation will be added\n-     * @throws DocletException is there is a problem while building the documentation\n-     *\/\n-    protected void buildEnumConstant(Content target) throws DocletException {\n-        if (hasMembersToDocument()) {\n-            Content enumConstantsDetailsHeader = writer.getEnumConstantsDetailsHeader(typeElement,\n-                    target);\n-            Content memberList = writer.getMemberList();\n-\n-            for (Element enumConstant : enumConstants) {\n-                currentElement = (VariableElement)enumConstant;\n-                Content enumConstants = writer.getEnumConstantsHeader(currentElement,\n-                        memberList);\n-\n-                buildSignature(enumConstants);\n-                buildDeprecationInfo(enumConstants);\n-                buildPreviewInfo(enumConstants);\n-                buildEnumConstantComments(enumConstants);\n-                buildTagInfo(enumConstants);\n-\n-                memberList.add(writer.getMemberListItem(enumConstants));\n-            }\n-            Content enumConstantDetails = writer.getEnumConstantsDetails(\n-                    enumConstantsDetailsHeader, memberList);\n-            target.add(enumConstantDetails);\n-        }\n-    }\n-\n-    \/**\n-     * Build the signature.\n-     *\n-     * @param target the content to which the documentation will be added\n-     *\/\n-    protected void buildSignature(Content target) {\n-        target.add(writer.getSignature(currentElement));\n-    }\n-\n-    \/**\n-     * Build the deprecation information.\n-     *\n-     * @param target the content to which the documentation will be added\n-     *\/\n-    protected void buildDeprecationInfo(Content target) {\n-        writer.addDeprecated(currentElement, target);\n-    }\n-\n-    \/**\n-     * Build the preview information.\n-     *\n-     * @param target the content to which the documentation will be added\n-     *\/\n-    protected void buildPreviewInfo(Content target) {\n-        writer.addPreview(currentElement, target);\n-    }\n-\n-    \/**\n-     * Build the comments for the enum constant.  Do nothing if\n-     * {@link BaseOptions#noComment()} is set to true.\n-     *\n-     * @param target the content to which the documentation will be added\n-     *\/\n-    protected void buildEnumConstantComments(Content target) {\n-        if (!options.noComment()) {\n-            writer.addComments(currentElement, target);\n-        }\n-    }\n-\n-    \/**\n-     * Build the tag information.\n-     *\n-     * @param target the content to which the documentation will be added\n-     *\/\n-    protected void buildTagInfo(Content target) {\n-        writer.addTags(currentElement, target);\n-    }\n-\n-    \/**\n-     * Return the enum constant writer for this builder.\n-     *\n-     * @return the enum constant writer for this builder.\n-     *\/\n-    public EnumConstantWriter getWriter() {\n-        return writer;\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/builders\/EnumConstantBuilder.java","additions":0,"deletions":191,"binary":false,"changes":191,"status":"deleted"},{"patch":"@@ -1,190 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.builders;\n-\n-import java.util.*;\n-\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.TypeElement;\n-import javax.lang.model.element.VariableElement;\n-\n-import jdk.javadoc.internal.doclets.toolkit.BaseOptions;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.DocletException;\n-import jdk.javadoc.internal.doclets.toolkit.FieldWriter;\n-\n-import static jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable.Kind.*;\n-\n-\/**\n- * Builds documentation for a field.\n- *\/\n-public class FieldBuilder extends AbstractMemberBuilder {\n-\n-    \/**\n-     * The writer to output the field documentation.\n-     *\/\n-    private final FieldWriter writer;\n-\n-    \/**\n-     * The list of fields being documented.\n-     *\/\n-    private final List<? extends Element> fields;\n-\n-    \/**\n-     * The index of the current field that is being documented at this point\n-     * in time.\n-     *\/\n-    private VariableElement currentElement;\n-\n-    \/**\n-     * Construct a new FieldBuilder.\n-     *\n-     * @param context  the build context.\n-     * @param typeElement the class whose members are being documented.\n-     * @param writer the doclet specific writer.\n-     *\/\n-    private FieldBuilder(Context context,\n-                         TypeElement typeElement,\n-                         FieldWriter writer) {\n-        super(context, typeElement);\n-        this.writer = Objects.requireNonNull(writer);\n-        fields = getVisibleMembers(FIELDS);\n-    }\n-\n-    \/**\n-     * Construct a new FieldBuilder.\n-     *\n-     * @param context  the build context.\n-     * @param typeElement the class whose members are being documented.\n-     * @param writer the doclet specific writer.\n-     * @return the new FieldBuilder\n-     *\/\n-    public static FieldBuilder getInstance(Context context,\n-            TypeElement typeElement,\n-            FieldWriter writer) {\n-        return new FieldBuilder(context, typeElement, writer);\n-    }\n-\n-    \/**\n-     * Returns whether or not there are members to document.\n-     *\n-     * @return whether or not there are members to document\n-     *\/\n-    @Override\n-    public boolean hasMembersToDocument() {\n-        return !fields.isEmpty();\n-    }\n-\n-    @Override\n-    public void build(Content target) throws DocletException {\n-        buildFieldDoc(target);\n-    }\n-\n-    \/**\n-     * Build the field documentation.\n-     *\n-     * @param target the content to which the documentation will be added\n-     * @throws DocletException if there is a problem while building the documentation\n-     *\/\n-    protected void buildFieldDoc(Content target) throws DocletException {\n-        if (!fields.isEmpty()) {\n-            Content fieldDetailsHeader = writer.getFieldDetailsHeader(target);\n-            Content memberList = writer.getMemberList();\n-\n-            for (Element element : fields) {\n-                currentElement = (VariableElement)element;\n-                Content fieldContent = writer.getFieldHeaderContent(currentElement);\n-\n-                buildSignature(fieldContent);\n-                buildDeprecationInfo(fieldContent);\n-                buildPreviewInfo(fieldContent);\n-                buildFieldComments(fieldContent);\n-                buildTagInfo(fieldContent);\n-\n-                memberList.add(writer.getMemberListItem(fieldContent));\n-            }\n-            Content fieldDetails = writer.getFieldDetails(fieldDetailsHeader, memberList);\n-            target.add(fieldDetails);\n-        }\n-    }\n-\n-    \/**\n-     * Build the signature.\n-     *\n-     * @param fieldContent the content to which the documentation will be added\n-     *\/\n-    protected void buildSignature(Content fieldContent) {\n-        fieldContent.add(writer.getSignature(currentElement));\n-    }\n-\n-    \/**\n-     * Build the deprecation information.\n-     *\n-     * @param fieldContent the content to which the documentation will be added\n-     *\/\n-    protected void buildDeprecationInfo(Content fieldContent) {\n-        writer.addDeprecated(currentElement, fieldContent);\n-    }\n-\n-    \/**\n-     * Build the preview information.\n-     *\n-     * @param fieldContent the content to which the documentation will be added\n-     *\/\n-    protected void buildPreviewInfo(Content fieldContent) {\n-        writer.addPreview(currentElement, fieldContent);\n-    }\n-\n-    \/**\n-     * Build the comments for the field.  Do nothing if\n-     * {@link BaseOptions#noComment()} is set to true.\n-     *\n-     * @param fieldContent the content to which the documentation will be added\n-     *\/\n-    protected void buildFieldComments(Content fieldContent) {\n-        if (!options.noComment()) {\n-            writer.addComments(currentElement, fieldContent);\n-        }\n-    }\n-\n-    \/**\n-     * Build the tag information.\n-     *\n-     * @param fieldContent the content to which the documentation will be added\n-     *\/\n-    protected void buildTagInfo(Content fieldContent) {\n-        writer.addTags(currentElement, fieldContent);\n-    }\n-\n-    \/**\n-     * Return the field writer for this builder.\n-     *\n-     * @return the field writer for this builder.\n-     *\/\n-    public FieldWriter getWriter() {\n-        return writer;\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/builders\/FieldBuilder.java","additions":0,"deletions":190,"binary":false,"changes":190,"status":"deleted"},{"patch":"@@ -1,448 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.builders;\n-\n-import java.util.Collection;\n-import java.util.Comparator;\n-import java.util.EnumMap;\n-import java.util.HashMap;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.SortedSet;\n-import java.util.TreeSet;\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.ExecutableElement;\n-import javax.lang.model.element.TypeElement;\n-import javax.lang.model.element.VariableElement;\n-import javax.lang.model.util.ElementFilter;\n-import javax.tools.Diagnostic;\n-\n-import com.sun.source.doctree.DocCommentTree;\n-import com.sun.source.doctree.DocTree;\n-import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n-import jdk.javadoc.internal.doclets.toolkit.ClassWriter;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.MemberSummaryWriter;\n-import jdk.javadoc.internal.doclets.toolkit.WriterFactory;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocFinder;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocFinder.Result;\n-import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n-import jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable;\n-\n-import static jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable.Kind.*;\n-\n-\/**\n- * Builds the member summary.\n- * There are two anonymous subtype variants of this builder, created\n- * in the {@link #getInstance} methods. One is for general types;\n- * the other is for annotation types.\n- *\/\n-public abstract class MemberSummaryBuilder extends AbstractMemberBuilder {\n-\n-    \/*\n-     * Comparator used to sort the members in the summary.\n-     *\/\n-    private final Comparator<Element> comparator;\n-\n-    \/**\n-     * The member summary writers for the given class.\n-     *\/\n-    private final EnumMap<VisibleMemberTable.Kind, MemberSummaryWriter> memberSummaryWriters;\n-\n-    final PropertyHelper pHelper;\n-\n-    \/**\n-     * Construct a new MemberSummaryBuilder.\n-     *\n-     * @param context       the build context.\n-     * @param typeElement   the type element.\n-     *\/\n-    private MemberSummaryBuilder(Context context, TypeElement typeElement) {\n-        super(context, typeElement);\n-        memberSummaryWriters = new EnumMap<>(VisibleMemberTable.Kind.class);\n-        comparator = utils.comparators.makeIndexElementComparator();\n-        pHelper = new PropertyHelper(this);\n-    }\n-\n-    \/**\n-     * Construct a new MemberSummaryBuilder for a general type.\n-     *\n-     * @param classWriter   the writer for the class whose members are being\n-     *                      summarized.\n-     * @param context       the build context.\n-     * @return              the instance\n-     *\/\n-    public static MemberSummaryBuilder getInstance(\n-            ClassWriter classWriter, Context context) {\n-        MemberSummaryBuilder builder = new MemberSummaryBuilder(context, classWriter.getTypeElement()) {\n-            @Override\n-            public void build(Content target) {\n-                buildPropertiesSummary(target);\n-                buildNestedClassesSummary(target);\n-                buildEnumConstantsSummary(target);\n-                buildAnnotationTypeRequiredMemberSummary(target);\n-                buildAnnotationTypeOptionalMemberSummary(target);\n-                buildFieldsSummary(target);\n-                buildConstructorsSummary(target);\n-                buildMethodsSummary(target);\n-            }\n-\n-            @Override\n-            public boolean hasMembersToDocument() {\n-                return visibleMemberTable.hasVisibleMembers();\n-            }\n-        };\n-        WriterFactory wf = context.configuration.getWriterFactory();\n-        for (VisibleMemberTable.Kind kind : VisibleMemberTable.Kind.values()) {\n-            MemberSummaryWriter msw = builder.getVisibleMemberTable().hasVisibleMembers(kind)\n-                    ? wf.getMemberSummaryWriter(classWriter, kind)\n-                    : null;\n-            builder.memberSummaryWriters.put(kind, msw);\n-        }\n-        return builder;\n-    }\n-\n-    \/**\n-     * Return the specified visible member map.\n-     *\n-     * @return the specified visible member map.\n-     * @throws ArrayIndexOutOfBoundsException when the type is invalid.\n-     * @see VisibleMemberTable\n-     *\/\n-    public VisibleMemberTable getVisibleMemberTable() {\n-        return visibleMemberTable;\n-    }\n-\n-    \/**.\n-     * Return the specified member summary writer.\n-     *\n-     * @param kind the kind of member summary writer to return.\n-     * @return the specified member summary writer.\n-     * @throws ArrayIndexOutOfBoundsException when the type is invalid.\n-     * @see VisibleMemberTable\n-     *\/\n-    public MemberSummaryWriter getMemberSummaryWriter(VisibleMemberTable.Kind kind) {\n-        return memberSummaryWriters.get(kind);\n-    }\n-\n-    \/**\n-     * Returns a list of methods that will be documented for the given class.\n-     * This information can be used for doclet specific documentation\n-     * generation.\n-     *\n-     * @param kind the kind of elements to return.\n-     * @return a list of methods that will be documented.\n-     * @see VisibleMemberTable\n-     *\/\n-    public SortedSet<Element> members(VisibleMemberTable.Kind kind) {\n-        TreeSet<Element> out = new TreeSet<>(comparator);\n-        out.addAll(getVisibleMembers(kind));\n-        return out;\n-    }\n-\n-    \/**\n-     * Builds the summary for any optional members of an annotation type.\n-     *\n-     * @param summariesList the list of summaries to which the summary will be added\n-     *\/\n-    protected void buildAnnotationTypeOptionalMemberSummary(Content summariesList) {\n-        MemberSummaryWriter writer = memberSummaryWriters.get(ANNOTATION_TYPE_MEMBER_OPTIONAL);\n-        addSummary(writer, ANNOTATION_TYPE_MEMBER_OPTIONAL, false, summariesList);\n-    }\n-\n-    \/**\n-     * Builds the summary for any required members of an annotation type.\n-     *\n-     * @param summariesList the list of summaries to which the summary will be added\n-     *\/\n-    protected void buildAnnotationTypeRequiredMemberSummary(Content summariesList) {\n-        MemberSummaryWriter writer = memberSummaryWriters.get(ANNOTATION_TYPE_MEMBER_REQUIRED);\n-        addSummary(writer, ANNOTATION_TYPE_MEMBER_REQUIRED, false, summariesList);\n-    }\n-\n-    \/**\n-     * Builds the summary for any enum constants of an enum type.\n-     *\n-     * @param summariesList the list of summaries to which the summary will be added\n-     *\/\n-    protected void buildEnumConstantsSummary(Content summariesList) {\n-        MemberSummaryWriter writer = memberSummaryWriters.get(ENUM_CONSTANTS);\n-        addSummary(writer, ENUM_CONSTANTS, false, summariesList);\n-    }\n-\n-    \/**\n-     * Builds the summary for any fields.\n-     *\n-     * @param summariesList the list of summaries to which the summary will be added\n-     *\/\n-    protected void buildFieldsSummary(Content summariesList) {\n-        MemberSummaryWriter writer = memberSummaryWriters.get(FIELDS);\n-        addSummary(writer, FIELDS, true, summariesList);\n-    }\n-\n-    \/**\n-     * Builds the summary for any properties.\n-     *\n-     * @param summariesList the list of summaries to which the summary will be added\n-     *\/\n-    protected void buildPropertiesSummary(Content summariesList) {\n-        MemberSummaryWriter writer = memberSummaryWriters.get(PROPERTIES);\n-        addSummary(writer, PROPERTIES, true, summariesList);\n-    }\n-\n-    \/**\n-     * Builds the summary for any nested classes.\n-     *\n-     * @param summariesList the list of summaries to which the summary will be added\n-     *\/\n-    protected void buildNestedClassesSummary(Content summariesList) {\n-        MemberSummaryWriter writer = memberSummaryWriters.get(NESTED_CLASSES);\n-        addSummary(writer, NESTED_CLASSES, true, summariesList);\n-    }\n-\n-    \/**\n-     * Builds the summary for any methods.\n-     *\n-     * @param summariesList the content to which the documentation will be added\n-     *\/\n-    protected void buildMethodsSummary(Content summariesList) {\n-        MemberSummaryWriter writer = memberSummaryWriters.get(METHODS);\n-        addSummary(writer, METHODS, true, summariesList);\n-    }\n-\n-    \/**\n-     * Builds the summary for any constructors.\n-     *\n-     * @param summariesList the content to which the documentation will be added\n-     *\/\n-    protected void buildConstructorsSummary(Content summariesList) {\n-        MemberSummaryWriter writer = memberSummaryWriters.get(CONSTRUCTORS);\n-        addSummary(writer, CONSTRUCTORS, false, summariesList);\n-    }\n-\n-    \/**\n-     * Build the member summary for the given members.\n-     *\n-     * @param writer the summary writer to write the output.\n-     * @param kind the kind of  members to summarize.\n-     * @param summaryTreeList the list of contents to which the documentation will be added\n-     *\/\n-    private void buildSummary(MemberSummaryWriter writer,\n-            VisibleMemberTable.Kind kind, LinkedList<Content> summaryTreeList) {\n-        SortedSet<? extends Element> members = asSortedSet(getVisibleMembers(kind));\n-        if (!members.isEmpty()) {\n-            for (Element member : members) {\n-                final Element property = pHelper.getPropertyElement(member);\n-                if (property != null && member instanceof ExecutableElement ee) {\n-                    configuration.cmtUtils.updatePropertyMethodComment(ee, property);\n-                }\n-                if (utils.isMethod(member)) {\n-                    var docFinder = utils.docFinder();\n-                    Optional<List<? extends DocTree>> r = docFinder.search((ExecutableElement) member, (m -> {\n-                        var firstSentenceTrees = utils.getFirstSentenceTrees(m);\n-                        Optional<List<? extends DocTree>> optional = firstSentenceTrees.isEmpty() ? Optional.empty() : Optional.of(firstSentenceTrees);\n-                        return Result.fromOptional(optional);\n-                    })).toOptional();\n-                    \/\/ The fact that we use `member` for possibly unrelated tags is suspicious\n-                    writer.addMemberSummary(typeElement, member, r.orElse(List.of()));\n-                } else {\n-                    writer.addMemberSummary(typeElement, member, utils.getFirstSentenceTrees(member));\n-                }\n-            }\n-            summaryTreeList.add(writer.getSummaryTable(typeElement));\n-        }\n-    }\n-\n-    \/**\n-     * Build the inherited member summary for the given methods.\n-     *\n-     * @param writer the writer for this member summary.\n-     * @param kind the kind of members to document.\n-     * @param targets the list of contents to which the documentation will be added\n-     *\/\n-    private void buildInheritedSummary(MemberSummaryWriter writer,\n-            VisibleMemberTable.Kind kind, LinkedList<Content> targets) {\n-        VisibleMemberTable visibleMemberTable = getVisibleMemberTable();\n-        SortedSet<? extends Element> inheritedMembersFromMap = asSortedSet(visibleMemberTable.getAllVisibleMembers(kind));\n-\n-        for (TypeElement inheritedClass : visibleMemberTable.getVisibleTypeElements()) {\n-            if (!(utils.isPublic(inheritedClass) || utils.isLinkable(inheritedClass))) {\n-                continue;\n-            }\n-            if (Objects.equals(inheritedClass, typeElement)) {\n-                continue;\n-            }\n-            if (utils.hasHiddenTag(inheritedClass)) {\n-                continue;\n-            }\n-\n-            List<? extends Element> members = inheritedMembersFromMap.stream()\n-                    .filter(e -> Objects.equals(utils.getEnclosingTypeElement(e), inheritedClass))\n-                    .toList();\n-\n-            if (!members.isEmpty()) {\n-                SortedSet<Element> inheritedMembers = new TreeSet<>(comparator);\n-                inheritedMembers.addAll(members);\n-                Content inheritedHeader = writer.getInheritedSummaryHeader(inheritedClass);\n-                Content links = writer.getInheritedSummaryLinks();\n-                addSummaryFootNote(inheritedClass, inheritedMembers, links, writer);\n-                inheritedHeader.add(links);\n-                targets.add(inheritedHeader);\n-            }\n-        }\n-    }\n-\n-    private void addSummaryFootNote(TypeElement inheritedClass, Iterable<Element> inheritedMembers,\n-                                    Content links, MemberSummaryWriter writer) {\n-        boolean isFirst = true;\n-        for (var iterator = inheritedMembers.iterator(); iterator.hasNext(); ) {\n-            var member = iterator.next();\n-            TypeElement t = utils.isUndocumentedEnclosure(inheritedClass)\n-                    ? typeElement : inheritedClass;\n-            writer.addInheritedMemberSummary(t, member, isFirst, !iterator.hasNext(), links);\n-            isFirst = false;\n-        }\n-    }\n-\n-    \/**\n-     * Adds the summary for the documentation.\n-     *\n-     * @param writer               the writer for this member summary\n-     * @param kind                 the kind of members to document\n-     * @param showInheritedSummary true if a summary of any inherited elements should be documented\n-     * @param summariesList        the list of summaries to which the summary will be added\n-     *\/\n-    private void addSummary(MemberSummaryWriter writer,\n-                            VisibleMemberTable.Kind kind,\n-                            boolean showInheritedSummary,\n-                            Content summariesList)\n-    {\n-        LinkedList<Content> summaryTreeList = new LinkedList<>();\n-        buildSummary(writer, kind, summaryTreeList);\n-        if (showInheritedSummary)\n-            buildInheritedSummary(writer, kind, summaryTreeList);\n-        if (!summaryTreeList.isEmpty()) {\n-            Content member = writer.getMemberSummaryHeader(typeElement, summariesList);\n-            summaryTreeList.forEach(member::add);\n-            writer.addSummary(summariesList, member);\n-        }\n-    }\n-\n-    private SortedSet<? extends Element> asSortedSet(Collection<? extends Element> members) {\n-        SortedSet<Element> out = new TreeSet<>(comparator);\n-        out.addAll(members);\n-        return out;\n-    }\n-\n-    \/**\n-     * A utility class to manage the property-related methods that should be\n-     * synthesized or updated.\n-     *\n-     * A property may comprise a field (that is typically private, if present),\n-     * a {@code fooProperty()} method (which is the defining characteristic for\n-     * a property), a {@code getFoo()} method and\/or a {@code setFoo(Foo foo)} method.\n-     *\n-     * Either the field (if present) or the {@code fooProperty()} method should have a\n-     * comment. If there is no field, or no comment on the field, the description for\n-     * the property will be derived from the description of the {@code fooProperty()}\n-     * method. If any method does not have a comment, one will be provided.\n-     *\/\n-    static class PropertyHelper {\n-\n-        private final Map<Element, Element> classPropertiesMap = new HashMap<>();\n-\n-        private final MemberSummaryBuilder  builder;\n-\n-        PropertyHelper(MemberSummaryBuilder builder) {\n-            this.builder = builder;\n-            computeProperties();\n-        }\n-\n-        private void computeProperties() {\n-            VisibleMemberTable vmt = builder.getVisibleMemberTable();\n-            List<ExecutableElement> props = ElementFilter.methodsIn(vmt.getVisibleMembers(PROPERTIES));\n-            for (ExecutableElement propertyMethod : props) {\n-                ExecutableElement getter = vmt.getPropertyGetter(propertyMethod);\n-                ExecutableElement setter = vmt.getPropertySetter(propertyMethod);\n-                VariableElement field = vmt.getPropertyField(propertyMethod);\n-\n-                addToPropertiesMap(propertyMethod, field, getter, setter);\n-            }\n-        }\n-\n-        private void addToPropertiesMap(ExecutableElement propertyMethod,\n-                                        VariableElement field,\n-                                        ExecutableElement getter,\n-                                        ExecutableElement setter) {\n-            \/\/ determine the preferred element from which to derive the property description\n-            Element e = field == null || !builder.utils.hasDocCommentTree(field)\n-                    ? propertyMethod : field;\n-\n-            if (e == field && builder.utils.hasDocCommentTree(propertyMethod)) {\n-                BaseConfiguration configuration = builder.configuration;\n-                configuration.getReporter().print(Diagnostic.Kind.WARNING,\n-                        propertyMethod, configuration.getDocResources().getText(\"doclet.duplicate.comment.for.property\"));\n-            }\n-\n-            addToPropertiesMap(propertyMethod, e);\n-            addToPropertiesMap(getter, e);\n-            addToPropertiesMap(setter, e);\n-        }\n-\n-        private void addToPropertiesMap(Element propertyMethod,\n-                                        Element commentSource) {\n-            Objects.requireNonNull(commentSource);\n-            if (propertyMethod == null) {\n-                return;\n-            }\n-\n-            Utils utils = builder.utils;\n-            DocCommentTree docTree = utils.hasDocCommentTree(propertyMethod)\n-                    ? utils.getDocCommentTree(propertyMethod)\n-                    : null;\n-\n-            \/* The second condition is required for the property buckets. In\n-             * this case the comment is at the property method (not at the field)\n-             * and it needs to be listed in the map.\n-             *\/\n-            if ((docTree == null) || propertyMethod.equals(commentSource)) {\n-                classPropertiesMap.put(propertyMethod, commentSource);\n-            }\n-        }\n-\n-        \/**\n-         * Returns the element for the property documentation belonging to the given member.\n-         * @param element the member for which the property documentation is needed.\n-         * @return the element for the property documentation, null if there is none.\n-         *\/\n-        public Element getPropertyElement(Element element) {\n-            return classPropertiesMap.get(element);\n-        }\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/builders\/MemberSummaryBuilder.java","additions":0,"deletions":448,"binary":false,"changes":448,"status":"deleted"},{"patch":"@@ -1,196 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.builders;\n-\n-import java.util.*;\n-\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.ExecutableElement;\n-import javax.lang.model.element.TypeElement;\n-import javax.lang.model.type.TypeMirror;\n-\n-import com.sun.source.doctree.DocTree;\n-import jdk.javadoc.internal.doclets.toolkit.BaseOptions;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.DocletException;\n-import jdk.javadoc.internal.doclets.toolkit.MethodWriter;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocFinder;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocFinder.Result;\n-\n-import static jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable.Kind.*;\n-\n-\/**\n- * Builds documentation for a method.\n- *\/\n-public class MethodBuilder extends AbstractMemberBuilder {\n-\n-    \/**\n-     * The index of the current field that is being documented at this point\n-     * in time.\n-     *\/\n-    private ExecutableElement currentMethod;\n-\n-    \/**\n-     * The writer to output the method documentation.\n-     *\/\n-    private final MethodWriter writer;\n-\n-    \/**\n-     * The methods being documented.\n-     *\/\n-    private final List<? extends Element> methods;\n-\n-\n-    \/**\n-     * Construct a new MethodBuilder.\n-     *\n-     * @param context       the build context.\n-     * @param typeElement the class whose members are being documented.\n-     * @param writer the doclet specific writer.\n-     *\/\n-    private MethodBuilder(Context context,\n-            TypeElement typeElement,\n-            MethodWriter writer) {\n-        super(context, typeElement);\n-        this.writer = Objects.requireNonNull(writer);\n-        methods = getVisibleMembers(METHODS);\n-    }\n-\n-    \/**\n-     * Construct a new MethodBuilder.\n-     *\n-     * @param context       the build context.\n-     * @param typeElement the class whose members are being documented.\n-     * @param writer the doclet specific writer.\n-     *\n-     * @return an instance of a MethodBuilder.\n-     *\/\n-    public static MethodBuilder getInstance(Context context,\n-            TypeElement typeElement, MethodWriter writer) {\n-        return new MethodBuilder(context, typeElement, writer);\n-    }\n-\n-    @Override\n-    public boolean hasMembersToDocument() {\n-        return !methods.isEmpty();\n-    }\n-\n-    @Override\n-    public void build(Content target) throws DocletException {\n-        buildMethodDoc(target);\n-    }\n-\n-    \/**\n-     * Build the method documentation.\n-     *\n-     * @param detailsList the content to which the documentation will be added\n-     * @throws DocletException if there is a problem while building the documentation\n-     *\/\n-    protected void buildMethodDoc(Content detailsList) throws DocletException {\n-        if (hasMembersToDocument()) {\n-            Content methodDetailsHeader = writer.getMethodDetailsHeader(detailsList);\n-            Content memberList = writer.getMemberList();\n-\n-            for (Element method : methods) {\n-                currentMethod = (ExecutableElement)method;\n-                Content methodContent = writer.getMethodHeader(currentMethod);\n-\n-                buildSignature(methodContent);\n-                buildDeprecationInfo(methodContent);\n-                buildPreviewInfo(methodContent);\n-                buildMethodComments(methodContent);\n-                buildTagInfo(methodContent);\n-\n-                memberList.add(writer.getMemberListItem(methodContent));\n-            }\n-            Content methodDetails = writer.getMethodDetails(methodDetailsHeader, memberList);\n-            detailsList.add(methodDetails);\n-        }\n-    }\n-\n-    \/**\n-     * Build the signature.\n-     *\n-     * @param methodContent the content to which the documentation will be added\n-     *\/\n-    protected void buildSignature(Content methodContent) {\n-        methodContent.add(writer.getSignature(currentMethod));\n-    }\n-\n-    \/**\n-     * Build the deprecation information.\n-     *\n-     * @param methodContent the content to which the documentation will be added\n-     *\/\n-    protected void buildDeprecationInfo(Content methodContent) {\n-        writer.addDeprecated(currentMethod, methodContent);\n-    }\n-\n-    \/**\n-     * Build the preview information.\n-     *\n-     * @param methodContent the content to which the documentation will be added\n-     *\/\n-    protected void buildPreviewInfo(Content methodContent) {\n-        writer.addPreview(currentMethod, methodContent);\n-    }\n-\n-    \/**\n-     * Build the comments for the method.  Do nothing if\n-     * {@link BaseOptions#noComment()} is set to true.\n-     *\n-     * @param methodContent the content to which the documentation will be added\n-     *\/\n-    protected void buildMethodComments(Content methodContent) {\n-        if (!options.noComment()) {\n-            assert utils.isMethod(currentMethod); \/\/ not all executables are methods\n-            var docFinder = utils.docFinder();\n-            Optional<ExecutableElement> r = docFinder.search(currentMethod,\n-                    m -> Result.fromOptional(utils.getFullBody(m).isEmpty() ? Optional.empty() : Optional.of(m))).toOptional();\n-            ExecutableElement method = r.orElse(currentMethod);\n-            TypeMirror containingType = method.getEnclosingElement().asType();\n-            writer.addComments(containingType, method, methodContent);\n-        }\n-    }\n-\n-    \/**\n-     * Build the tag information.\n-     *\n-     * @param methodContent the content to which the documentation will be added\n-     *\/\n-    protected void buildTagInfo(Content methodContent) {\n-        writer.addTags(currentMethod, methodContent);\n-    }\n-\n-    \/**\n-     * Return the method writer for this builder.\n-     *\n-     * @return the method writer for this builder.\n-     *\/\n-    public MethodWriter getWriter() {\n-        return writer;\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/builders\/MethodBuilder.java","additions":0,"deletions":196,"binary":false,"changes":196,"status":"deleted"},{"patch":"@@ -1,181 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.builders;\n-\n-import javax.lang.model.element.ModuleElement;\n-\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.DocFilesHandler;\n-import jdk.javadoc.internal.doclets.toolkit.DocletException;\n-import jdk.javadoc.internal.doclets.toolkit.ModuleSummaryWriter;\n-\n-\n-\/**\n- * Builds the summary for a given module.\n- *\/\n-public class ModuleSummaryBuilder extends AbstractBuilder {\n-\n-    \/**\n-     * The module being documented.\n-     *\/\n-    private final ModuleElement mdle;\n-\n-    \/**\n-     * The doclet specific writer that will output the result.\n-     *\/\n-    private final ModuleSummaryWriter moduleWriter;\n-\n-    \/**\n-     * Construct a new ModuleSummaryBuilder.\n-     *\n-     * @param context  the build context.\n-     * @param mdle the module being documented.\n-     * @param moduleWriter the doclet specific writer that will output the\n-     *        result.\n-     *\/\n-    private ModuleSummaryBuilder(Context context,\n-            ModuleElement mdle, ModuleSummaryWriter moduleWriter) {\n-        super(context);\n-        this.mdle = mdle;\n-        this.moduleWriter = moduleWriter;\n-    }\n-\n-    \/**\n-     * Construct a new ModuleSummaryBuilder.\n-     *\n-     * @param context  the build context.\n-     * @param mdle the module being documented.\n-     * @param moduleWriter the doclet specific writer that will output the\n-     *        result.\n-     *\n-     * @return an instance of a ModuleSummaryBuilder.\n-     *\/\n-    public static ModuleSummaryBuilder getInstance(Context context,\n-            ModuleElement mdle, ModuleSummaryWriter moduleWriter) {\n-        return new ModuleSummaryBuilder(context, mdle, moduleWriter);\n-    }\n-\n-    \/**\n-     * Build the module summary.\n-     *\n-     * @throws DocletException if there is a problem while building the documentation\n-     *\/\n-    @Override\n-    public void build() throws DocletException {\n-        if (moduleWriter == null) {\n-            \/\/Doclet does not support this output.\n-            return;\n-        }\n-        buildModuleDoc();\n-    }\n-\n-    \/**\n-     * Build the module documentation.\n-     *\n-     * @throws DocletException if there is a problem while building the documentation\n-     *\/\n-    protected void buildModuleDoc() throws DocletException {\n-        Content content = moduleWriter.getModuleHeader(mdle.getQualifiedName().toString());\n-\n-        buildContent();\n-\n-        moduleWriter.addModuleFooter();\n-        moduleWriter.printDocument(content);\n-        DocFilesHandler docFilesHandler = configuration.getWriterFactory().getDocFilesHandler(mdle);\n-        docFilesHandler.copyDocFiles();\n-    }\n-\n-    \/**\n-     * Build the content for the module doc.\n-     *\n-     * @throws DocletException if there is a problem while building the documentation\n-     *\/\n-    protected void buildContent() throws DocletException {\n-        Content moduleContent = moduleWriter.getContentHeader();\n-\n-        moduleWriter.addModuleSignature(moduleContent);\n-        buildModuleDescription(moduleContent);\n-        buildSummary(moduleContent);\n-\n-        moduleWriter.addModuleContent(moduleContent);\n-    }\n-\n-    \/**\n-     * Builds the list of summary sections for this module.\n-     *\n-     * @param target the module content to which the summaries will\n-     *               be added\n-     * @throws DocletException if there is a problem while building the documentation\n-     *\/\n-    protected void buildSummary(Content target) throws DocletException {\n-        Content summariesList = moduleWriter.getSummariesList();\n-\n-        buildPackagesSummary(summariesList);\n-        buildModulesSummary(summariesList);\n-        buildServicesSummary(summariesList);\n-\n-        target.add(moduleWriter.getSummary(summariesList));\n-    }\n-\n-    \/**\n-     * Builds the summary of the module dependencies of this module.\n-     *\n-     * @param summariesList the list of summaries to which the summary will be added\n-     *\/\n-    protected void buildModulesSummary(Content summariesList) {\n-        moduleWriter.addModulesSummary(summariesList);\n-    }\n-\n-    \/**\n-     * Builds the summary of the packages exported or opened by this module.\n-     *\n-     * @param summariesList the list of summaries to which the summary will be added\n-     *\/\n-    protected void buildPackagesSummary(Content summariesList) {\n-        moduleWriter.addPackagesSummary(summariesList);\n-    }\n-\n-    \/**\n-     * Builds the summary of the services used or provided by this module.\n-     *\n-     * @param summariesList the list of summaries to which the summary will be added\n-     *\/\n-    protected void buildServicesSummary(Content summariesList) {\n-        moduleWriter.addServicesSummary(summariesList);\n-    }\n-\n-    \/**\n-     * Builds the description for this module.\n-     *\n-     * @param moduleContent the content to which the module description will\n-     *                      be added\n-     *\/\n-    protected void buildModuleDescription(Content moduleContent) {\n-        if (!options.noComment()) {\n-            moduleWriter.addModuleDescription(moduleContent);\n-        }\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/builders\/ModuleSummaryBuilder.java","additions":0,"deletions":181,"binary":false,"changes":181,"status":"deleted"},{"patch":"@@ -1,189 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.builders;\n-\n-import javax.lang.model.element.PackageElement;\n-\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.DocFilesHandler;\n-import jdk.javadoc.internal.doclets.toolkit.DocletException;\n-import jdk.javadoc.internal.doclets.toolkit.PackageSummaryWriter;\n-\n-\n-\/**\n- * Builds the summary for a given package.\n- *\/\n-public class PackageSummaryBuilder extends AbstractBuilder {\n-\n-    \/**\n-     * The package being documented.\n-     *\/\n-    private final PackageElement packageElement;\n-\n-    \/**\n-     * The doclet specific writer that will output the result.\n-     *\/\n-    private final PackageSummaryWriter packageWriter;\n-\n-    \/**\n-     * Construct a new PackageSummaryBuilder.\n-     *\n-     * @param context  the build context.\n-     * @param pkg the package being documented.\n-     * @param packageWriter the doclet specific writer that will output the\n-     *        result.\n-     *\/\n-    private PackageSummaryBuilder(Context context,\n-            PackageElement pkg,\n-            PackageSummaryWriter packageWriter) {\n-        super(context);\n-        this.packageElement = pkg;\n-        this.packageWriter = packageWriter;\n-    }\n-\n-    \/**\n-     * Construct a new PackageSummaryBuilder.\n-     *\n-     * @param context  the build context.\n-     * @param pkg the package being documented.\n-     * @param packageWriter the doclet specific writer that will output the\n-     *        result.\n-     *\n-     * @return an instance of a PackageSummaryBuilder.\n-     *\/\n-    public static PackageSummaryBuilder getInstance(Context context,\n-            PackageElement pkg, PackageSummaryWriter packageWriter) {\n-        return new PackageSummaryBuilder(context, pkg, packageWriter);\n-    }\n-\n-    \/**\n-     * Build the package summary.\n-     *\n-     * @throws DocletException if there is a problem while building the documentation\n-     *\/\n-    @Override\n-    public void build() throws DocletException {\n-        if (packageWriter == null) {\n-            \/\/Doclet does not support this output.\n-            return;\n-        }\n-        buildPackageDoc();\n-    }\n-\n-    \/**\n-     * Build the package documentation.\n-     *\n-     * @throws DocletException if there is a problem while building the documentation\n-     *\/\n-    protected void buildPackageDoc() throws DocletException {\n-        Content content = packageWriter.getPackageHeader();\n-\n-        buildContent();\n-\n-        packageWriter.addPackageFooter();\n-        packageWriter.printDocument(content);\n-        DocFilesHandler docFilesHandler = configuration\n-                .getWriterFactory()\n-                .getDocFilesHandler(packageElement);\n-        docFilesHandler.copyDocFiles();\n-    }\n-\n-    \/**\n-     * Build the content for the package.\n-     *\n-     * @throws DocletException if there is a problem while building the documentation\n-     *\/\n-    protected void buildContent() throws DocletException {\n-        Content packageContent = packageWriter.getContentHeader();\n-\n-        packageWriter.addPackageSignature(packageContent);\n-        buildPackageDescription(packageContent);\n-        buildPackageTags(packageContent);\n-        buildSummary(packageContent);\n-\n-        packageWriter.addPackageContent(packageContent);\n-    }\n-\n-    \/**\n-     * Builds the list of summaries for the different kinds of types in this package.\n-     *\n-     * @param packageContent the package content to which the summaries will\n-     *                       be added\n-     * @throws DocletException if there is a problem while building the documentation\n-     *\/\n-    protected void buildSummary(Content packageContent) throws DocletException {\n-        Content summariesList = packageWriter.getSummariesList();\n-\n-        buildRelatedPackagesSummary(summariesList);\n-        buildAllClassesAndInterfacesSummary(summariesList);\n-\n-        packageContent.add(packageWriter.getPackageSummary(summariesList));\n-    }\n-\n-    \/**\n-     * Builds a list of \"nearby\" packages (subpackages, superpackages, and sibling packages).\n-     *\n-     * @param summariesList the list of summaries to which the summary will be added\n-     *\/\n-    protected void buildRelatedPackagesSummary(Content summariesList) {\n-        packageWriter.addRelatedPackagesSummary(summariesList);\n-    }\n-\n-    \/**\n-     * Builds the summary for all classes and interfaces in this package.\n-     *\n-     * @param summariesList the list of summaries to which the summary will be added\n-     *\/\n-    protected void buildAllClassesAndInterfacesSummary(Content summariesList) {\n-        packageWriter.addAllClassesAndInterfacesSummary(summariesList);\n-    }\n-\n-\n-    \/**\n-     * Build the description of the summary.\n-     *\n-     * @param packageContent the content to which the package description will\n-     *                       be added\n-     *\/\n-    protected void buildPackageDescription(Content packageContent) {\n-        if (options.noComment()) {\n-            return;\n-        }\n-        packageWriter.addPackageDescription(packageContent);\n-    }\n-\n-    \/**\n-     * Build the tags of the summary.\n-     *\n-     * @param packageContent the content to which the package tags will be added\n-     *\/\n-    protected void buildPackageTags(Content packageContent) {\n-        if (options.noComment()) {\n-            return;\n-        }\n-        packageWriter.addPackageTags(packageContent);\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/builders\/PackageSummaryBuilder.java","additions":0,"deletions":189,"binary":false,"changes":189,"status":"deleted"},{"patch":"@@ -1,211 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.builders;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Objects;\n-import java.util.stream.Collectors;\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.ExecutableElement;\n-import javax.lang.model.element.TypeElement;\n-\n-import com.sun.source.doctree.DocCommentTree;\n-import com.sun.source.doctree.DocTree;\n-import jdk.javadoc.internal.doclets.toolkit.BaseOptions;\n-import jdk.javadoc.internal.doclets.toolkit.CommentUtils;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.DocletException;\n-import jdk.javadoc.internal.doclets.toolkit.PropertyWriter;\n-\n-import static jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable.Kind.PROPERTIES;\n-\n-\/**\n- * Builds documentation for a property.\n- *\/\n-public class PropertyBuilder extends AbstractMemberBuilder {\n-\n-    \/**\n-     * The writer to output the property documentation.\n-     *\/\n-    private final PropertyWriter writer;\n-\n-    \/**\n-     * The list of properties being documented.\n-     *\/\n-    private final List<? extends Element> properties;\n-\n-    \/**\n-     * The index of the current property that is being documented at this point\n-     * in time.\n-     *\/\n-    private ExecutableElement currentProperty;\n-\n-    \/**\n-     * Construct a new PropertyBuilder.\n-     *\n-     * @param context  the build context.\n-     * @param typeElement the class whose members are being documented.\n-     * @param writer the doclet specific writer.\n-     *\/\n-    private PropertyBuilder(Context context,\n-            TypeElement typeElement,\n-            PropertyWriter writer) {\n-        super(context, typeElement);\n-        this.writer = Objects.requireNonNull(writer);\n-        properties = getVisibleMembers(PROPERTIES);\n-    }\n-\n-    \/**\n-     * Construct a new PropertyBuilder.\n-     *\n-     * @param context  the build context.\n-     * @param typeElement the class whose members are being documented.\n-     * @param writer the doclet specific writer.\n-     * @return the new PropertyBuilder\n-     *\/\n-    public static PropertyBuilder getInstance(Context context,\n-            TypeElement typeElement,\n-            PropertyWriter writer) {\n-        return new PropertyBuilder(context, typeElement, writer);\n-    }\n-\n-    \/**\n-     * Returns whether or not there are members to document.\n-     *\n-     * @return whether or not there are members to document\n-     *\/\n-    @Override\n-    public boolean hasMembersToDocument() {\n-        return !properties.isEmpty();\n-    }\n-\n-    @Override\n-    public void build(Content target) throws DocletException {\n-        buildPropertyDoc(target);\n-    }\n-\n-    \/**\n-     * Build the property documentation.\n-     *\n-     * @param detailsList the content to which the documentation will be added\n-     * @throws DocletException if there is a problem while building the documentation\n-     *\/\n-    protected void buildPropertyDoc(Content detailsList) throws DocletException {\n-        if (hasMembersToDocument()) {\n-            Content propertyDetailsHeader = writer.getPropertyDetailsHeader(detailsList);\n-            Content memberList = writer.getMemberList();\n-\n-            for (Element property : properties) {\n-                currentProperty = (ExecutableElement)property;\n-                Content propertyContent = writer.getPropertyHeaderContent(currentProperty);\n-\n-                buildSignature(propertyContent);\n-                buildPropertyComments(propertyContent);\n-                buildTagInfo(propertyContent);\n-\n-                memberList.add(writer.getMemberListItem(propertyContent));\n-            }\n-            Content propertyDetails = writer.getPropertyDetails(propertyDetailsHeader, memberList);\n-            detailsList.add(propertyDetails);\n-        }\n-    }\n-\n-    \/**\n-     * Build the signature.\n-     *\n-     * @param propertyContent the content to which the documentation will be added\n-     *\/\n-    protected void buildSignature(Content propertyContent) {\n-        propertyContent.add(writer.getSignature(currentProperty));\n-    }\n-\n-    \/**\n-     * Build the deprecation information.\n-     *\n-     * @param propertyContent the content to which the documentation will be added\n-     *\/\n-    protected void buildDeprecationInfo(Content propertyContent) {\n-        writer.addDeprecated(currentProperty, propertyContent);\n-    }\n-\n-    \/**\n-     * Build the preview information.\n-     *\n-     * @param propertyContent the content to which the documentation will be added\n-     *\/\n-    protected void buildPreviewInfo(Content propertyContent) {\n-        writer.addPreview(currentProperty, propertyContent);\n-    }\n-\n-    \/**\n-     * Build the comments for the property.  Do nothing if\n-     * {@link BaseOptions#noComment()} is set to true.\n-     *\n-     * @param propertyContent the content to which the documentation will be added\n-     *\/\n-    protected void buildPropertyComments(Content propertyContent) {\n-        if (!options.noComment()) {\n-            writer.addComments(currentProperty, propertyContent);\n-        }\n-    }\n-\n-    \/**\n-     * Build the tag information.\n-     *\n-     * @param propertyContent the content to which the documentation will be added\n-     *\/\n-    protected void buildTagInfo(Content propertyContent) {\n-        CommentUtils cmtUtils = configuration.cmtUtils;\n-        DocCommentTree dct = utils.getDocCommentTree(currentProperty);\n-        var fullBody = dct.getFullBody();\n-        ArrayList<DocTree> blockTags = dct.getBlockTags().stream()\n-                .filter(t -> t.getKind() != DocTree.Kind.RETURN)\n-                .collect(Collectors.toCollection(ArrayList::new));\n-        String sig = \"#\" + currentProperty.getSimpleName() + \"()\";\n-        blockTags.add(cmtUtils.makeSeeTree(sig, currentProperty));\n-        \/\/ The property method is used as a proxy for the property\n-        \/\/ (which does not have an explicit element of its own.)\n-        \/\/ Temporarily override the doc comment for the property method\n-        \/\/ by removing the `@return` tag, which should not be displayed for\n-        \/\/ the property.\n-        CommentUtils.DocCommentInfo prev = cmtUtils.setDocCommentTree(currentProperty, fullBody, blockTags);\n-        try {\n-            writer.addTags(currentProperty, propertyContent);\n-        } finally {\n-            cmtUtils.setDocCommentInfo(currentProperty, prev);\n-        }\n-    }\n-\n-    \/**\n-     * Return the property writer for this builder.\n-     *\n-     * @return the property writer for this builder.\n-     *\/\n-    public PropertyWriter getWriter() {\n-        return writer;\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/builders\/PropertyBuilder.java","additions":0,"deletions":211,"binary":false,"changes":211,"status":"deleted"},{"patch":"@@ -1,577 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.builders;\n-\n-\n-import java.util.Collection;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.SortedSet;\n-import java.util.TreeSet;\n-\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.ExecutableElement;\n-import javax.lang.model.element.PackageElement;\n-import javax.lang.model.element.TypeElement;\n-import javax.lang.model.element.VariableElement;\n-import javax.lang.model.type.TypeMirror;\n-\n-import com.sun.source.doctree.SerialFieldTree;\n-import com.sun.source.doctree.SerialTree;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.DocletException;\n-import jdk.javadoc.internal.doclets.toolkit.SerializedFormWriter;\n-import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;\n-import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n-\n-\/**\n- * Builds the serialized form.\n- *\/\n-public class SerializedFormBuilder extends AbstractBuilder {\n-\n-    \/**\n-     * The writer for this builder.\n-     *\/\n-    private SerializedFormWriter writer;\n-\n-    \/**\n-     * The writer for serializable fields.\n-     *\/\n-    private SerializedFormWriter.SerialFieldWriter fieldWriter;\n-\n-    \/**\n-     * The writer for serializable method documentation.\n-     *\/\n-    private SerializedFormWriter.SerialMethodWriter methodWriter;\n-\n-    \/**\n-     * The header for the serial version UID.  Save the string\n-     * here instead of the properties file because we do not want\n-     * this string to be localized.\n-     *\/\n-    private static final String SERIAL_VERSION_UID = \"serialVersionUID\";\n-    private static final String SERIAL_VERSION_UID_HEADER = SERIAL_VERSION_UID + \":\";\n-\n-    \/**\n-     * The current package being documented.\n-     *\/\n-    private PackageElement currentPackage;\n-\n-    \/**\n-     * The current class being documented.\n-     *\/\n-    private TypeElement currentTypeElement;\n-\n-    \/**\n-     * The current member being documented.\n-     *\/\n-    protected Element currentMember;\n-\n-    \/**\n-     * Construct a new SerializedFormBuilder.\n-     * @param context  the build context.\n-     *\/\n-    private SerializedFormBuilder(Context context) {\n-        super(context);\n-    }\n-\n-    \/**\n-     * Construct a new SerializedFormBuilder.\n-     *\n-     * @param context  the build context.\n-     * @return the new SerializedFormBuilder\n-     *\/\n-    public static SerializedFormBuilder getInstance(Context context) {\n-        return new SerializedFormBuilder(context);\n-    }\n-\n-    \/**\n-     * Build the serialized form.\n-     *\n-     * @throws DocletException if there is a problem while building the documentation\n-     *\/\n-    @Override\n-    public void build() throws DocletException {\n-        SortedSet<TypeElement> rootclasses = new TreeSet<>(utils.comparators.makeGeneralPurposeComparator());\n-        rootclasses.addAll(configuration.getIncludedTypeElements());\n-        if (!serialClassFoundToDocument(rootclasses)) {\n-            \/\/Nothing to document.\n-            return;\n-        }\n-        writer = configuration.getWriterFactory().getSerializedFormWriter();\n-        if (writer == null) {\n-            \/\/Doclet does not support this output.\n-            return;\n-        }\n-        buildSerializedForm();\n-    }\n-\n-    \/**\n-     * Build the serialized form.\n-     *\n-     * @throws DocletException if there is a problem while building the documentation\n-     *\/\n-    protected void buildSerializedForm() throws DocletException {\n-        Content content = writer.getHeader(resources.getText(\n-                \"doclet.Serialized_Form\"));\n-\n-        buildSerializedFormSummaries();\n-\n-        writer.addFooter();\n-        writer.printDocument(content);\n-    }\n-\n-    \/**\n-     * Build the serialized form summaries.\n-     *\n-     * @throws DocletException if there is a problem while building the documentation\n-     *\/\n-    protected void buildSerializedFormSummaries()\n-            throws DocletException {\n-        Content c = writer.getSerializedSummariesHeader();\n-        for (PackageElement pkg : configuration.packages) {\n-            currentPackage = pkg;\n-\n-            buildPackageSerializedForm(c);\n-        }\n-        writer.addSerializedContent(c);\n-    }\n-\n-    \/**\n-     * Build the package serialized form for the current package being processed.\n-     *\n-     * @param target the content to which the documentation will be added\n-     * @throws DocletException if there is a problem while building the documentation\n-     *\/\n-    protected void buildPackageSerializedForm(Content target) throws DocletException {\n-        Content packageSerializedHeader = writer.getPackageSerializedHeader();\n-        SortedSet<TypeElement> classes = utils.getAllClassesUnfiltered(currentPackage);\n-        if (classes.isEmpty()) {\n-            return;\n-        }\n-        if (!serialInclude(utils, currentPackage)) {\n-            return;\n-        }\n-        if (!serialClassFoundToDocument(classes)) {\n-            return;\n-        }\n-\n-        buildPackageHeader(packageSerializedHeader);\n-        buildClassSerializedForm(packageSerializedHeader);\n-\n-        writer.addPackageSerialized(target, packageSerializedHeader);\n-    }\n-\n-    \/**\n-     * Build the package header.\n-     *\n-     * @param target the content to which the documentation will be added\n-     *\/\n-    protected void buildPackageHeader(Content target) {\n-        target.add(writer.getPackageHeader(currentPackage));\n-    }\n-\n-    \/**\n-     * Build the class serialized form.\n-     *\n-     * @param target the content to which the documentation will be added\n-     * @throws DocletException if there is a problem while building the documentation\n-     *\/\n-    protected void buildClassSerializedForm(Content target)\n-            throws DocletException {\n-        Content classSerializedHeader = writer.getClassSerializedHeader();\n-        SortedSet<TypeElement> typeElements = utils.getAllClassesUnfiltered(currentPackage);\n-        for (TypeElement typeElement : typeElements) {\n-            currentTypeElement = typeElement;\n-            fieldWriter = writer.getSerialFieldWriter(currentTypeElement);\n-            methodWriter = writer.getSerialMethodWriter(currentTypeElement);\n-            if (utils.isClass(currentTypeElement) && utils.isSerializable(currentTypeElement)) {\n-                if (!serialClassInclude(utils, currentTypeElement)) {\n-                    continue;\n-                }\n-                Content classHeader = writer.getClassHeader(currentTypeElement);\n-\n-                buildSerialUIDInfo(classHeader);\n-                buildClassContent(classHeader);\n-\n-                classSerializedHeader.add(writer.getMember(classHeader));\n-            }\n-        }\n-        target.add(classSerializedHeader);\n-    }\n-\n-    \/**\n-     * Build the serial UID information for the given class.\n-     *\n-     * @param target the content to which the serial UID information will be added\n-     *\/\n-    protected void buildSerialUIDInfo(Content target) {\n-        Content serialUIDHeader = writer.getSerialUIDInfoHeader();\n-        for (VariableElement field : utils.getFieldsUnfiltered(currentTypeElement)) {\n-            if (field.getSimpleName().toString().compareTo(SERIAL_VERSION_UID) == 0 &&\n-                field.getConstantValue() != null) {\n-                writer.addSerialUIDInfo(SERIAL_VERSION_UID_HEADER,\n-                                        utils.constantValueExpression(field), serialUIDHeader);\n-                break;\n-            }\n-        }\n-        target.add(serialUIDHeader);\n-    }\n-\n-    \/**\n-     * Build the summaries for the methods and fields.\n-     *\n-     * @param target the content to which the documentation will be added\n-     * @throws DocletException if there is a problem while building the documentation\n-     *\/\n-    protected void buildClassContent(Content target) throws DocletException {\n-        Content classContent = writer.getClassContentHeader();\n-\n-        buildSerializableMethods(classContent);\n-        buildFieldHeader(classContent);\n-        buildSerializableFields(classContent);\n-\n-        target.add(classContent);\n-    }\n-\n-    \/**\n-     * Build the summaries for the methods that belong to the given class.\n-     *\n-     * @param target the content to which the documentation will be added\n-     * @throws DocletException if there is a problem while building the documentation\n-     *\/\n-    protected void buildSerializableMethods(Content target) throws DocletException {\n-        Content serializableMethodsHeader = methodWriter.getSerializableMethodsHeader();\n-        for (var i = utils.serializationMethods(currentTypeElement).iterator(); i.hasNext(); ) {\n-            currentMember = i.next();\n-            Content methodsContent = methodWriter.getMethodsContentHeader(!i.hasNext());\n-\n-            buildMethodSubHeader(methodsContent);\n-            buildDeprecatedMethodInfo(methodsContent);\n-            buildMethodInfo(methodsContent);\n-\n-            serializableMethodsHeader.add(methodsContent);\n-        }\n-        if (!utils.serializationMethods(currentTypeElement).isEmpty()) {\n-            target.add(methodWriter.getSerializableMethods(\n-                    resources.getText(\"doclet.Serialized_Form_methods\"),\n-                    serializableMethodsHeader));\n-            if (utils.isSerializable(currentTypeElement) && !utils.isExternalizable(currentTypeElement)) {\n-                if (utils.serializationMethods(currentTypeElement).isEmpty()) {\n-                    Content noCustomizationMsg = methodWriter.getNoCustomizationMsg(\n-                            resources.getText(\"doclet.Serializable_no_customization\"));\n-                    target.add(methodWriter.getSerializableMethods(\n-                            resources.getText(\"doclet.Serialized_Form_methods\"),\n-                            noCustomizationMsg));\n-                }\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Build the method sub header.\n-     *\n-     * @param methodsContent the content to which the documentation will be added\n-     *\/\n-    protected void buildMethodSubHeader(Content methodsContent)  {\n-        methodWriter.addMemberHeader((ExecutableElement)currentMember, methodsContent);\n-    }\n-\n-    \/**\n-     * Build the deprecated method description.\n-     *\n-     * @param methodsContent the content to which the documentation will be added\n-     *\/\n-    protected void buildDeprecatedMethodInfo(Content methodsContent) {\n-        methodWriter.addDeprecatedMemberInfo((ExecutableElement)currentMember, methodsContent);\n-    }\n-\n-    \/**\n-     * Build the information for the method.\n-     *\n-     * @param methodsContent the content to which the documentation will be added\n-     * @throws DocletException if there is a problem while building the documentation\n-     *\/\n-    protected void buildMethodInfo(Content methodsContent) throws DocletException  {\n-        if (options.noComment()) {\n-            return;\n-        }\n-\n-        buildMethodDescription(methodsContent);\n-        buildMethodTags(methodsContent);\n-    }\n-\n-    \/**\n-     * Build method description.\n-     *\n-     * @param methodsContent the content to which the documentation will be added\n-     *\/\n-    protected void buildMethodDescription(Content methodsContent) {\n-        methodWriter.addMemberDescription((ExecutableElement)currentMember, methodsContent);\n-    }\n-\n-    \/**\n-     * Build the method tags.\n-     *\n-     * @param methodsContent the content to which the documentation will be added\n-     *\/\n-    protected void buildMethodTags(Content methodsContent) {\n-        methodWriter.addMemberTags((ExecutableElement)currentMember, methodsContent);\n-        ExecutableElement method = (ExecutableElement)currentMember;\n-        if (method.getSimpleName().toString().compareTo(\"writeExternal\") == 0\n-                && utils.getSerialDataTrees(method).isEmpty()) {\n-            if (options.serialWarn()) {\n-                TypeElement encl  = (TypeElement) method.getEnclosingElement();\n-                messages.warning(currentMember,\n-                        \"doclet.MissingSerialDataTag\", encl.getQualifiedName().toString(),\n-                        method.getSimpleName().toString());\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Build the field header.\n-     *\n-     * @param classContent the content to which the documentation will be added\n-     *\/\n-    protected void buildFieldHeader(Content classContent) {\n-        if (!utils.serializableFields(currentTypeElement).isEmpty()) {\n-            buildFieldSerializationOverview(currentTypeElement, classContent);\n-        }\n-    }\n-\n-    \/**\n-     * Build the serialization overview for the given class.\n-     *\n-     * @param typeElement the class to print the overview for.\n-     * @param classContent the content to which the documentation will be added\n-     *\/\n-    public void buildFieldSerializationOverview(TypeElement typeElement, Content classContent) {\n-        if (utils.definesSerializableFields(typeElement)) {\n-            VariableElement ve = utils.serializableFields(typeElement).first();\n-            \/\/ Check to see if there are inline comments, tags or deprecation\n-            \/\/ information to be printed.\n-            if (fieldWriter.shouldPrintOverview(ve)) {\n-                Content serializableFieldsHeader = fieldWriter.getSerializableFieldsHeader();\n-                Content fieldsOverviewContent = fieldWriter.getFieldsContentHeader(true);\n-                fieldWriter.addMemberDeprecatedInfo(ve, fieldsOverviewContent);\n-                if (!options.noComment()) {\n-                    fieldWriter.addMemberDescription(ve, fieldsOverviewContent);\n-                    fieldWriter.addMemberTags(ve, fieldsOverviewContent);\n-                }\n-                serializableFieldsHeader.add(fieldsOverviewContent);\n-                classContent.add(fieldWriter.getSerializableFields(\n-                        resources.getText(\"doclet.Serialized_Form_class\"),\n-                        serializableFieldsHeader));\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Build the summaries for the fields that belong to the given class.\n-     *\n-     * @param target the content to which the documentation will be added\n-     * @throws DocletException if there is a problem while building the documentation\n-     *\/\n-    protected void buildSerializableFields(Content target)\n-            throws DocletException {\n-        Collection<VariableElement> members = utils.serializableFields(currentTypeElement);\n-        if (!members.isEmpty()) {\n-            Content serializableFieldsHeader = fieldWriter.getSerializableFieldsHeader();\n-            for (var i = members.iterator(); i.hasNext();) {\n-                currentMember = i.next();\n-                if (!utils.definesSerializableFields(currentTypeElement)) {\n-                    Content fieldsContent = fieldWriter.getFieldsContentHeader(!i.hasNext());\n-\n-                    buildFieldSubHeader(fieldsContent);\n-                    buildFieldDeprecationInfo(fieldsContent);\n-                    buildFieldInfo(fieldsContent);\n-\n-                    serializableFieldsHeader.add(fieldsContent);\n-                } else {\n-                    buildSerialFieldTagsInfo(serializableFieldsHeader);\n-                }\n-            }\n-            target.add(fieldWriter.getSerializableFields(\n-                    resources.getText(\"doclet.Serialized_Form_fields\"),\n-                    serializableFieldsHeader));\n-        }\n-    }\n-\n-    \/**\n-     * Build the field sub header.\n-     *\n-     * @param fieldsContent the content to which the documentation will be added\n-     *\/\n-    protected void buildFieldSubHeader(Content fieldsContent) {\n-        if (!utils.definesSerializableFields(currentTypeElement)) {\n-            VariableElement field = (VariableElement) currentMember;\n-            fieldWriter.addMemberHeader(field.asType(),\n-                    utils.getSimpleName(field),\n-                    fieldsContent);\n-        }\n-    }\n-\n-    \/**\n-     * Build the field deprecation information.\n-     *\n-     * @param fieldsContent the content to which the documentation will be added\n-     *\/\n-    protected void buildFieldDeprecationInfo(Content fieldsContent) {\n-        if (!utils.definesSerializableFields(currentTypeElement)) {\n-            fieldWriter.addMemberDeprecatedInfo((VariableElement)currentMember,\n-                    fieldsContent);\n-        }\n-    }\n-\n-    \/**\n-     * Build the serial field tags information.\n-     *\n-     * @param target the content to which the documentation will be added\n-     *\/\n-    protected void buildSerialFieldTagsInfo(Content target) {\n-        if (options.noComment()) {\n-            return;\n-        }\n-        VariableElement field = (VariableElement)currentMember;\n-        \/\/ Process Serializable Fields specified as array of\n-        \/\/ ObjectStreamFields. Print a member for each serialField tag.\n-        \/\/ (There should be one serialField tag per ObjectStreamField\n-        \/\/ element.)\n-        SortedSet<SerialFieldTree> tags = new TreeSet<>(utils.comparators.makeSerialFieldTreeComparator());\n-        \/\/ sort the elements\n-        tags.addAll(utils.getSerialFieldTrees(field));\n-\n-        CommentHelper ch = utils.getCommentHelper(field);\n-        for (SerialFieldTree tag : tags) {\n-            if (tag.getName() == null || tag.getType() == null)  \/\/ ignore malformed @serialField tags\n-                continue;\n-            Content fieldsContent = fieldWriter.getFieldsContentHeader(tag.equals(tags.last()));\n-            TypeMirror type = ch.getReferencedType(tag);\n-            fieldWriter.addMemberHeader(type, tag.getName().getName().toString(), fieldsContent);\n-            fieldWriter.addMemberDescription(field, tag, fieldsContent);\n-            target.add(fieldsContent);\n-        }\n-    }\n-\n-    \/**\n-     * Build the field information.\n-     *\n-     * @param fieldsContent the content to which the documentation will be added\n-     *\/\n-    protected void buildFieldInfo(Content fieldsContent) {\n-        if (options.noComment()) {\n-            return;\n-        }\n-        VariableElement field = (VariableElement)currentMember;\n-        TypeElement te = utils.getEnclosingTypeElement(currentMember);\n-        \/\/ Process default Serializable field.\n-        if ((utils.getSerialTrees(field).isEmpty()) \/*&& !field.isSynthetic()*\/\n-                && options.serialWarn()) {\n-            messages.warning(field,\n-                    \"doclet.MissingSerialTag\", utils.getFullyQualifiedName(te),\n-                    utils.getSimpleName(field));\n-        }\n-        fieldWriter.addMemberDescription(field, fieldsContent);\n-        fieldWriter.addMemberTags(field, fieldsContent);\n-    }\n-\n-    \/**\n-     * Returns true if the given Element should be included\n-     * in the serialized form.\n-     *\n-     * @param utils the utils object\n-     * @param element the Element object to check for serializability\n-     * @return true if the element should be included in the serial form\n-     *\/\n-    public static boolean serialInclude(Utils utils, Element element) {\n-        if (element == null) {\n-            return false;\n-        }\n-        return utils.isClass(element)\n-                ? serialClassInclude(utils, (TypeElement)element)\n-                : serialDocInclude(utils, element);\n-    }\n-\n-    \/**\n-     * Returns true if the given TypeElement should be included\n-     * in the serialized form.\n-     *\n-     * @param te the TypeElement object to check for serializability.\n-     *\/\n-    private static boolean serialClassInclude(Utils utils, TypeElement te) {\n-        if (utils.isEnum(te)) {\n-            return false;\n-        }\n-        if (utils.isSerializable(te)) {\n-            if (utils.hasDocCommentTree(te) && !utils.getSerialTrees(te).isEmpty()) {\n-                return serialDocInclude(utils, te);\n-            } else {\n-                return utils.isPublic(te) || utils.isProtected(te);\n-            }\n-        }\n-        return false;\n-    }\n-\n-    \/**\n-     * Return true if the given Element should be included\n-     * in the serialized form.\n-     *\n-     * @param element the Element to check for serializability.\n-     *\/\n-    private static boolean serialDocInclude(Utils utils, Element element) {\n-        if (utils.isEnum(element)) {\n-            return false;\n-        }\n-        List<? extends SerialTree> serial = utils.getSerialTrees(element);\n-        if (!serial.isEmpty()) {\n-            CommentHelper ch = utils.getCommentHelper(element);\n-            \/\/ look for `@serial include|exclude`\n-            String serialtext = Utils.toLowerCase(serial.get(0).toString());\n-            if (serialtext.contains(\"exclude\")) {\n-                return false;\n-            } else if (serialtext.contains(\"include\")) {\n-                return true;\n-            }\n-        }\n-        return true;\n-    }\n-\n-    \/**\n-     * Return true if any of the given typeElements have a {@code @serial include} tag.\n-     *\n-     * @param classes the typeElements to check.\n-     * @return true if any of the given typeElements have a {@code @serial include} tag.\n-     *\/\n-    private boolean serialClassFoundToDocument(SortedSet<TypeElement> classes) {\n-        for (TypeElement aClass : classes) {\n-            if (serialClassInclude(utils, aClass)) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/builders\/SerializedFormBuilder.java","additions":0,"deletions":577,"binary":false,"changes":577,"status":"deleted"},{"patch":"@@ -1,35 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * This doclet-independent package has a set of classes and\n- * interfaces that are the building blocks for doclets. They\n- * define the basic structure of doclets and make doclet\n- * writing much easier because they provide the content generation\n- * code to be shared among different doclets. Builders only provide\n- * the structure and content of API documentation.\n- * They do not directly provide any style markup.\n- *\/\n-package jdk.javadoc.internal.doclets.toolkit.builders;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/builders\/package-info.java","additions":0,"deletions":35,"binary":false,"changes":35,"status":"deleted"},{"patch":"@@ -73,1 +73,1 @@\n- *          {@link jdk.javadoc.internal.doclets.toolkit.Content}, the {@code markup} library\n+ *          {@link jdk.javadoc.internal.doclets.formats.html.Content}, the {@code markup} library\n@@ -78,12 +78,0 @@\n- *          The {@link jdk.javadoc.internal.doclets.toolkit toolkit} package provides\n- *          support for a format-neutral\n- *          {@linkplain jdk.javadoc.internal.doclets.toolkit.AbstractDoclet abstract doclet},\n- *          which uses\n- *          {@linkplain jdk.javadoc.internal.doclets.toolkit.builders.AbstractBuilder builders}\n- *          to generate pages of abstract\n- *          {@linkplain jdk.javadoc.internal.doclets.toolkit.Content content}.\n- *\n- *          <p>The format-specific content for each page is provided by implementations\n- *          of various <em>writer<\/em> interfaces, created by a format-specific\n- *          {@linkplain jdk.javadoc.internal.doclets.toolkit.WriterFactory writer factory}.\n- *\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/package-info.java","additions":1,"deletions":13,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -215,2 +215,2 @@\n-            \"ClassWriterImpl\",\n-            \"ConstantsSummaryWriterImpl\",\n+            \"ClassWriter\",\n+            \"ConstantsSummaryWriter\",\n@@ -224,1 +224,1 @@\n-            \"ModuleWriterImpl\",\n+            \"ModuleWriter\",\n@@ -228,1 +228,1 @@\n-            \"PackageWriterImpl\",\n+            \"PackageWriter\",\n@@ -230,1 +230,1 @@\n-            \"SerializedFormWriterImpl\",\n+            \"SerializedFormWriter\",\n@@ -324,4 +324,4 @@\n-            case \"AnnotationTypeWriterImpl\":\n-            case \"ClassWriterImpl\":\n-            case \"ModuleWriterImpl\":\n-            case \"PackageWriterImpl\":\n+            case \"AnnotationTypeWriter\":\n+            case \"ClassWriter\":\n+            case \"ModuleWriter\":\n+            case \"PackageWriter\":\n@@ -336,1 +336,1 @@\n-            case \"ConstantsSummaryWriterImpl\":\n+            case \"ConstantsSummaryWriter\":\n@@ -373,1 +373,1 @@\n-            case \"SerializedFormWriterImpl\":\n+            case \"SerializedFormWriter\":\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testMetadata\/TestMetadata.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"}]}