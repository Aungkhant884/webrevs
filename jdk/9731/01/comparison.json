{"files":[{"patch":"@@ -33,0 +33,1 @@\n+import java.security.Security;\n@@ -34,7 +35,2 @@\n-import java.util.Arrays;\n-import java.util.EnumSet;\n-import java.util.HexFormat;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Map;\n+import java.util.*;\n+import java.util.stream.Collectors;\n@@ -52,0 +48,1 @@\n+import sun.security.util.LegacyAlgorithmConstraints;\n@@ -409,0 +406,1 @@\n+\n@@ -418,0 +416,1 @@\n+            boolean CSFound = false;\n@@ -424,0 +423,3 @@\n+                \/\/ only reason for failure now would be key exchange issue\n+                CSFound = true;\n+\n@@ -434,0 +436,1 @@\n+\n@@ -437,0 +440,1 @@\n+\n@@ -471,2 +475,6 @@\n-            throw shc.conContext.fatal(Alert.HANDSHAKE_FAILURE,\n-                    \"no cipher suites in common\");\n+            \/\/negotiation failed between client and server, print server enabled cipher suites\n+            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                printServerSocketConfig(shc, legacySuites);\n+            }\n+            String finalErrorMessage = CSFound ? \"key exchange failed\" : \"no cipher suites in common\";\n+            throw shc.conContext.fatal(Alert.HANDSHAKE_FAILURE, finalErrorMessage);\n@@ -748,0 +756,3 @@\n+            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                printServerSocketConfig(shc, null);\n+            }\n@@ -752,0 +763,38 @@\n+    \/\/ print out server socket config\n+    private static void printServerSocketConfig(ServerHandshakeContext shc,\n+                                                       List<CipherSuite> legacySuites) {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"\\\"{0}\\\": '\\n{'\\n\")\n+                .append(\"  \\\"preferred ciphersuites\\\"     : \\\"{1}\\\",\\n\")\n+                .append(\"  \\\"client auth type\\\"           : \\\"{2}\\\",\\n\")\n+                .append(\"  \\\"enabled server ciphersuites\\\": \\\"{3}\\\",\\n\")\n+                .append(\"  \\\"legacy algorithms\\\"          : \\\"{4}\\\"\");\n+\n+        LinkedList<String> fieldsList = new LinkedList<>();\n+\n+        fieldsList.add(\"SSLSeverSocket info\");\n+        fieldsList.add(shc.sslConfig.preferLocalCipherSuites ? \"Server preference\" : \"Client preference\");\n+        fieldsList.add(shc.sslConfig.clientAuthType.toString());\n+        fieldsList.add(shc.activeCipherSuites != null ? shc.activeCipherSuites.toString() : \"Not Set\");\n+        fieldsList.add(Security.getProperty(LegacyAlgorithmConstraints.PROPERTY_TLS_LEGACY_ALGS));\n+\n+        if (!shc.negotiatedProtocol.name.equalsIgnoreCase(ProtocolVersion.TLS13.name)) {\n+            sb.append(\",\\n\");\n+            sb.append(\"  \\\"legacy ciphersuites\\\"        : \\\"{5}\\\",\\n\");\n+\n+            fieldsList.add(legacySuites != null ? legacySuites.stream()\n+                    .map(n -> n.name())\n+                    .collect(Collectors.joining(\",\", \"[\", \"]\")) : \"Not Set\");\n+        } else {\n+            sb.append(\"\\n\");\n+        }\n+        sb.append(\"'}'\");\n+\n+        MessageFormat messageFormat = new MessageFormat(sb.toString(), Locale.ENGLISH);\n+\n+        Object[] messageFields = new Object[fieldsList.size()];\n+        messageFields = fieldsList.toArray(messageFields);\n+\n+        SSLLogger.fine(messageFormat.format(messageFields));\n+    }\n+\n@@ -1512,1 +1561,1 @@\n-}\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/ServerHello.java","additions":59,"deletions":10,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -0,0 +1,169 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8133816\n+ * @library \/test\/lib \/javax\/net\/ssl\/templates\n+ * @summary Display extra SSLServerSocket info in debug mode\n+ *\/\n+\n+import jdk.test.lib.process.ProcessTools;\n+\n+import java.net.InetAddress;\n+import java.security.Security;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLServerSocket;\n+import javax.net.ssl.SSLSocket;\n+\n+public class ServerSocketConfigTest extends SSLSocketTemplate {\n+    private  String protocol;\n+\n+    private final static String[] PROTOCOLS = {\"TLSv1.2\", \"TLSv1.3\"};\n+    private final static String[] SERVER_CS = {\n+            \"TLS_RSA_WITH_NULL_SHA256\",\n+            \"TLS_DH_anon_WITH_AES_128_CBC_SHA\",\n+            \"TLS_ECDH_anon_WITH_AES_128_CBC_SHA\",\n+            \"TLS_ECDHE_ECDSA_WITH_RC4_128_SHA\",\n+            \"TLS_RSA_WITH_DES_CBC_SHA\",\n+            \"TLS_RSA_WITH_3DES_EDE_CBC_SHA\",\n+            \"TLS_CHACHA20_POLY1305_SHA256\",\n+            \"TLS_AES_256_GCM_SHA384\"};\n+\n+    private final static String[] NO_COMMON_CS = {\n+            \"TLS_DH_anon_WITH_AES_128_CBC_SHA\",\n+            \"TLS_ECDH_anon_WITH_AES_128_CBC_SHA\",\n+            \"TLS_ECDHE_ECDSA_WITH_RC4_128_SHA\",\n+            \"TLS_RSA_WITH_DES_CBC_SHA\",\n+            \"TLS_RSA_WITH_3DES_EDE_CBC_SHA\"};\n+\n+    private final static String[] CLIENT_TLSV12_CS = {\"TLS_RSA_WITH_NULL_SHA256\"};\n+\n+    private final static String[] CLIENT_TLSV13_CS = {\"TLS_AES_128_GCM_SHA256\"};\n+    private final static String DEBUG_MESSAGE = \"\\\"SSLSeverSocket info\\\":\";\n+    private final static String LEGACY_CS = \"\\\"[TLS_RSA_WITH_NULL_SHA256]\\\"\";\n+\n+    private final static String NO_COMMON_IN_CS_MSG = \"no cipher suites in common\";\n+\n+    private final static String KEY_EXCHANGE_FAILED_MSG = \"key exchange failed\";\n+\n+    ServerSocketConfigTest(String protocol) {\n+        serverAddress = InetAddress.getLoopbackAddress();\n+        this.protocol = protocol;\n+    }\n+\n+    @Override\n+    protected SSLContext createServerSSLContext() throws Exception {\n+        if (PROTOCOLS[0].equalsIgnoreCase(protocol)) {\n+            return createSSLContext(TRUSTED_CERTS, null,\n+                    getServerContextParameters());\n+        } else {\n+            return createSSLContext(TRUSTED_CERTS, END_ENTITY_CERTS,\n+                    getServerContextParameters());\n+        }\n+    }\n+\n+    @Override\n+    protected void configureServerSocket(SSLServerSocket socket) {\n+        if (PROTOCOLS[0].equalsIgnoreCase(protocol) || PROTOCOLS[1].equalsIgnoreCase(protocol)) {\n+            socket.setEnabledCipherSuites(SERVER_CS);\n+            socket.setEnabledProtocols(new String[]{protocol});\n+        } else {\n+            socket.setEnabledCipherSuites(NO_COMMON_CS);\n+            socket.setEnabledProtocols(new String[]{PROTOCOLS[0]});\n+        }\n+    }\n+\n+    @Override\n+    protected void configureClientSocket(SSLSocket socket) {\n+        String[] clientCipherSuites = PROTOCOLS[1].equalsIgnoreCase(protocol) ?\n+                CLIENT_TLSV13_CS : CLIENT_TLSV12_CS;\n+\n+        socket.setEnabledCipherSuites(clientCipherSuites);\n+\n+        if (PROTOCOLS[1].equalsIgnoreCase(protocol)) {\n+            socket.setEnabledProtocols(new String[]{protocol});\n+        } else {\n+            socket.setEnabledProtocols(new String[]{PROTOCOLS[0]});\n+        }\n+    }\n+\n+    @Override\n+    protected void runServerApplication(SSLSocket socket){\n+        try{\n+            super.runServerApplication(socket);\n+        }catch(Exception e){\n+\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        Security.setProperty(\"jdk.tls.disabledAlgorithms\", \"\");\n+        if (args.length != 0) {\n+            \/\/ A non-empty set of arguments occurs when the \"runTest\" argument\n+            \/\/ is passed to the test via ProcessTools::executeTestJvm.\n+            \/\/\n+            \/\/ This is done because an OutputAnalyzer is unable to read\n+            \/\/ the output of the current running JVM, and must therefore create\n+            \/\/ a test JVM. When this case occurs, it will inherit all specified\n+            \/\/ properties passed to the test JVM - debug flags, tls version, etc.\n+            try {\n+                new ServerSocketConfigTest(args[0]).run();\n+            }catch (Exception e){\n+                \/\/do nothing\n+            }\n+        } else {\n+            \/\/ We are in the test JVM that the test is being ran in.\n+            var testSrc = \"-Dtest.src=\" + System.getProperty(\"test.src\");\n+            var enabledDebug = \"-Djavax.net.debug=ssl,handshake\";\n+\n+\n+            \/\/ Testing protocol TSLv1.2,catch log message when no common cipher suite between client and server\n+            var output0 = ProcessTools.executeTestJvm(testSrc, enabledDebug, \"ServerSocketConfigTest\",\n+                    \"NO_COMMON_IN_CIPHERSUITE\"); \/\/ Ensuring args.length is greater than 0 when test JVM starts\n+\n+            output0.shouldContain(DEBUG_MESSAGE)\n+                    .shouldContain(SERVER_CS[0])\n+                    .shouldNotContain(LEGACY_CS)\n+                    .shouldContain(NO_COMMON_IN_CS_MSG);\n+\n+            \/\/ Testing protocol TSLv1.2,catch log message when key exchange failed between client and server\n+            var output1 = ProcessTools.executeTestJvm(testSrc, enabledDebug, \"ServerSocketConfigTest\",\n+                    PROTOCOLS[0]); \/\/ Ensuring args.length is greater than 0 when test JVM starts\n+\n+            output1.shouldContain(DEBUG_MESSAGE)\n+                    .shouldContain(SERVER_CS[0])\n+                    .shouldContain(LEGACY_CS)\n+                    .shouldContain(KEY_EXCHANGE_FAILED_MSG);\n+\n+            \/\/ Testing protocol TSLv1.3, catch log message when no common cipher suites between client and server\n+            var output2 = ProcessTools.executeTestJvm(testSrc, enabledDebug, \"ServerSocketConfigTest\",\n+                    PROTOCOLS[1]); \/\/ Ensuring args.length is greater than 0 when test JVM starts\n+\n+            output2.shouldContain(DEBUG_MESSAGE)\n+                   .shouldContain(SERVER_CS[6])\n+                   .shouldContain(NO_COMMON_IN_CS_MSG);\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSocketImpl\/ServerSocketConfigTest.java","additions":169,"deletions":0,"binary":false,"changes":169,"status":"added"}]}