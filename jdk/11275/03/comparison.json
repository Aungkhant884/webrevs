{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -432,1 +432,1 @@\n-            DiskChunk oldestChunk = chunks.getLast();\n+            DiskChunk oldestChunk = chunks.peekLast();\n@@ -443,1 +443,1 @@\n-        DiskChunk chunk = chunks.poll();\n+        DiskChunk chunk = chunks.pollLast();\n@@ -450,1 +450,1 @@\n-            DiskChunk oldestChunk = chunks.peek();\n+            DiskChunk oldestChunk = chunks.peekLast();\n@@ -463,1 +463,1 @@\n-        chunks.push(chunk);\n+        chunks.addFirst(chunk);\n@@ -503,1 +503,4 @@\n-        for (DiskChunk dc : chunks) {\n+        \/\/ replay history by iterating from oldest to most recent\n+        Iterator<DiskChunk> it = chunks.descendingIterator();\n+        while (it.hasNext()) {\n+            DiskChunk dc = it.next();\n@@ -506,0 +509,1 @@\n+\n","filename":"src\/jdk.management.jfr\/share\/classes\/jdk\/management\/jfr\/DiskRepository.java","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n-import java.util.Queue;\n+import java.util.Deque;\n@@ -37,1 +37,1 @@\n-    private final Queue<DiskChunk> chunks = new ArrayDeque<>();\n+    private final Deque<DiskChunk> chunks = new ArrayDeque<>();\n@@ -50,1 +50,1 @@\n-        chunks.add(dc);\n+        chunks.addFirst(dc);\n@@ -78,1 +78,1 @@\n-                    return chunks.poll();\n+                    return chunks.pollLast();\n@@ -89,0 +89,1 @@\n+        DiskChunk chunk = null;\n@@ -90,1 +91,0 @@\n-            DiskChunk chunk = null;\n@@ -95,0 +95,2 @@\n+                chunk.release();\n+                chunk = null;\n@@ -97,0 +99,3 @@\n+            if (chunk != null) {\n+                chunk.release();\n+            }\n","filename":"src\/jdk.management.jfr\/share\/classes\/jdk\/management\/jfr\/FileDump.java","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -159,1 +159,4 @@\n-    private boolean started; \/\/ always guarded by lock\n+    \/\/ always guarded by lock\n+    private boolean started;\n+    private Duration maxAge;\n+    private long maxSize;\n@@ -418,1 +421,5 @@\n-        repository.setMaxAge(maxAge);\n+        synchronized (lock) {\n+            repository.setMaxAge(maxAge);\n+            this.maxAge = maxAge;\n+            updateOnCompleteHandler();\n+        }\n@@ -444,1 +451,5 @@\n-        repository.setMaxSize(maxSize);\n+        synchronized (lock) {\n+            repository.setMaxSize(maxSize);\n+            this.maxSize = maxSize;\n+            updateOnCompleteHandler();\n+        }\n@@ -648,0 +659,9 @@\n+    private void updateOnCompleteHandler() {\n+        if (maxAge != null || maxSize != 0) {\n+            \/\/ User has set a chunk removal policy\n+            ManagementSupport.setOnChunkCompleteHandler(stream, null);\n+        } else {\n+            ManagementSupport.setOnChunkCompleteHandler(stream, new ChunkConsumer(repository));\n+        }\n+    }\n+\n","filename":"src\/jdk.management.jfr\/share\/classes\/jdk\/management\/jfr\/RemoteRecordingStream.java","additions":24,"deletions":4,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -0,0 +1,130 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.jmx.streaming;\n+\n+import java.lang.management.ManagementFactory;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import javax.management.MBeanServerConnection;\n+\n+import jdk.jfr.Event;\n+import jdk.jfr.StackTrace;\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.consumer.RecordingFile;\n+import jdk.management.jfr.RemoteRecordingStream;\n+\n+\/**\n+ * @test\n+ * @key jfr\n+ * @summary Tests that chunks arrive in the same order they were committed\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib \/test\/jdk\n+ * @run main\/othervm jdk.jfr.jmx.streaming.TestDumpOrder\n+ *\/\n+public class TestDumpOrder {\n+\n+    private static final MBeanServerConnection CONNECTION = ManagementFactory.getPlatformMBeanServer();\n+\n+    @StackTrace(false)\n+    static class Ant extends Event {\n+        long id;\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        \/\/ Set up the test so half of the events have been consumed\n+        \/\/ when the dump occurs.\n+        AtomicLong eventCount = new AtomicLong();\n+        CountDownLatch halfLatch = new CountDownLatch(1);\n+        CountDownLatch dumpLatch = new CountDownLatch(1);\n+        Path directory = Path.of(\"chunks\");\n+        Files.createDirectory(directory);\n+        try (var rs = new RemoteRecordingStream(CONNECTION, directory)) {\n+            rs.setMaxSize(100_000_000); \/\/ keep all data\n+            rs.onEvent(event -> {\n+                try {\n+                    eventCount.incrementAndGet();\n+                    if (eventCount.get() == 10) {\n+                        halfLatch.countDown();\n+                        dumpLatch.await();\n+                    }\n+                } catch (InterruptedException ie) {\n+                    ie.printStackTrace();\n+                }\n+            });\n+            rs.startAsync();\n+            long counter = 0;\n+            for (int i = 0; i < 10; i++) {\n+                try (Recording r = new Recording()) {\n+                    r.start();\n+                    Ant a = new Ant();\n+                    a.id = counter++;\n+                    a.commit();\n+                    Ant b = new Ant();\n+                    b.id = counter++;\n+                    b.commit();\n+                }\n+                if (counter == 10) {\n+                    halfLatch.await();\n+                }\n+            }\n+            Path file = Path.of(\"events.jfr\");\n+            \/\/ Wait for most (but not all) chunk files to be downloaded\n+            \/\/ before invoking dump()\n+            awaitChunkFiles(directory);\n+            \/\/ To stress the implementation, release consumer thread\n+            \/\/ during the dump\n+            dumpLatch.countDown();\n+            rs.dump(file);\n+            List<RecordedEvent> events = RecordingFile.readAllEvents(file);\n+            if (events.isEmpty()) {\n+                throw new AssertionError(\"No events found\");\n+            }\n+            \/\/ Print events for debugging purposes\n+            events.forEach(System.out::println);\n+            long expected = 0;\n+            for (var event : events) {\n+                long value = event.getLong(\"id\");\n+                if (value != expected) {\n+                    throw new Exception(\"Expected \" + expected + \", got \" + value);\n+                }\n+                expected++;\n+            }\n+            if (expected != counter) {\n+                throw new Exception(\"Not all events found\");\n+            }\n+        }\n+    }\n+\n+    private static void awaitChunkFiles(Path directory) throws Exception {\n+        while (Files.list(directory).count() < 7) {\n+            Thread.sleep(10);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/jmx\/streaming\/TestDumpOrder.java","additions":130,"deletions":0,"binary":false,"changes":130,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.util.List;\n@@ -34,0 +35,1 @@\n+import java.util.function.Consumer;\n@@ -39,0 +41,1 @@\n+import jdk.jfr.Recording;\n@@ -66,0 +69,3 @@\n+        testSetNoPolicy();\n+        testSetMaxAge();\n+        testSetMaxSize();\n@@ -94,0 +100,64 @@\n+    private static List<RecordedEvent> recordWithPolicy(String filename, Consumer<RemoteRecordingStream> policy) throws Exception {\n+        CountDownLatch latch1 = new CountDownLatch(1);\n+        CountDownLatch latch2 = new CountDownLatch(2);\n+        CountDownLatch latch3 = new CountDownLatch(3);\n+        try (var rs = new RemoteRecordingStream(CONNECTION)) {\n+            policy.accept(rs);\n+            rs.onEvent(e -> {\n+                latch1.countDown();\n+                latch2.countDown();\n+                latch3.countDown();\n+            });\n+            rs.startAsync();\n+            DumpEvent e1 = new DumpEvent();\n+            e1.commit();\n+            latch1.await();\n+            \/\/ Force chunk rotation\n+            try (Recording r = new Recording()) {\n+                r.start();\n+                DumpEvent e2 = new DumpEvent();\n+                e2.commit();\n+            }\n+            latch2.await();\n+            DumpEvent e3 = new DumpEvent();\n+            e3.commit();\n+            latch3.await();\n+            Path p = Path.of(filename);\n+            rs.dump(p);\n+            return RecordingFile.readAllEvents(p);\n+        }\n+    }\n+\n+    private static void testSetMaxSize() throws Exception {\n+        var events = recordWithPolicy(\"max-size.jfr\", rs -> {\n+            \/\/ keeps all events for the dump\n+            rs.setMaxSize(100_000_000);\n+        });\n+        if (events.size() != 3) {\n+            throw new Exception(\"Expected all 3 events to be in dump after setMaxSize\");\n+        }\n+\n+    }\n+\n+    private static void testSetMaxAge() throws Exception {\n+        var events = recordWithPolicy(\"max-age.jfr\", rs -> {\n+            \/\/ keeps all events for the dump\n+            rs.setMaxAge(Duration.ofDays(1));\n+        });\n+        if (events.size() != 3) {\n+            throw new Exception(\"Expected all 3 events to be in dump after setMaxAge\");\n+        }\n+\n+    }\n+\n+    private static void testSetNoPolicy() throws Exception {\n+        var events = recordWithPolicy(\"no-policy.jfr\", rs -> {\n+            \/\/ use default policy, remove after consumption\n+        });\n+        \/\/ Since latch3 have been triggered at least two events\/chunks\n+        \/\/ before must have been consumed, possibly 3, but it's a race.\n+        if (events.size() > 1) {\n+            throw new Exception(\"Expected at most one event to not be consumed\");\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/jfr\/jmx\/streaming\/TestRemoteDump.java","additions":71,"deletions":1,"binary":false,"changes":72,"status":"modified"}]}