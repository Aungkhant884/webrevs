{"files":[{"patch":"@@ -573,1 +573,1 @@\n-                    map = new HashMap<>((int)Math.ceil(names.length \/ 0.75));\n+                    map = HashMap.newHashMap(names.length);\n","filename":"src\/java.base\/macosx\/classes\/sun\/util\/locale\/provider\/HostLocaleProviderAdapterImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -747,2 +747,1 @@\n-        private static Map<String, UnicodeBlock> map =\n-                new HashMap<>((int)(NUM_ENTITIES \/ 0.75f + 1.0f));\n+        private static Map<String, UnicodeBlock> map = HashMap.newHashMap(NUM_ENTITIES);\n@@ -8575,1 +8574,1 @@\n-            aliases = new HashMap<>((int)(162 \/ 0.75f + 1.0f));\n+            aliases = HashMap.newHashMap(162);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Character.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -3913,1 +3913,1 @@\n-            directory = new HashMap<>((int)(universe.length \/ 0.75f) + 1);\n+            directory = HashMap.newHashMap(universe.length);\n@@ -4128,1 +4128,1 @@\n-                        annotations = new LinkedHashMap<>((Math.max(\n+                        annotations = LinkedHashMap.newLinkedHashMap(Math.max(\n@@ -4131,1 +4131,1 @@\n-                            ) * 4 + 2) \/ 3\n+                            )\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -983,1 +983,1 @@\n-            openPackages = new HashMap<>((4 * (concealedPkgs.size() + exportedPkgs.size()) \/ 3) + 1);\n+            openPackages = HashMap.newHashMap(concealedPkgs.size() + exportedPkgs.size());\n@@ -1136,2 +1136,1 @@\n-        int cap = (int)(numModules \/ 0.75f + 1.0f);\n-        Map<String, Module> nameToModule = new HashMap<>(cap);\n+        Map<String, Module> nameToModule = HashMap.newHashMap(numModules);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Module.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1658,1 +1658,1 @@\n-        Map<Thread, StackTraceElement[]> m = new HashMap<>(threads.length);\n+        Map<Thread, StackTraceElement[]> m = HashMap.newHashMap(threads.length);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Thread.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -293,1 +293,1 @@\n-        var convSpecMap = new HashMap<Object, int[]>(((4 * convCount) \/ 3) + 1);\n+        HashMap<Object, int[]> convSpecMap = HashMap.newHashMap(convCount);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -501,2 +501,1 @@\n-        \/\/ initial capacity of maps to avoid resizing\n-        int capacity = 1 + (4 * nameToReference.size())\/ 3;\n+        int moduleCount = nameToReference.size();\n@@ -506,1 +505,1 @@\n-        Map<ResolvedModule, Set<ResolvedModule>> g1 = new HashMap<>(capacity);\n+        Map<ResolvedModule, Set<ResolvedModule>> g1 = HashMap.newHashMap(moduleCount);\n@@ -515,1 +514,1 @@\n-            g2 = new HashMap<>(capacity);\n+            g2 = HashMap.newHashMap(moduleCount);\n@@ -542,1 +541,1 @@\n-        Map<String, ResolvedModule> nameToResolved = new HashMap<>(capacity);\n+        Map<String, ResolvedModule> nameToResolved = HashMap.newHashMap(moduleCount);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/module\/Resolver.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -248,1 +248,1 @@\n-            extensions = new HashMap<>(size > 20 ? 20 : size);\n+            extensions = HashMap.newHashMap(size > 20 ? 20 : size);\n","filename":"src\/java.base\/share\/classes\/java\/security\/cert\/CertificateRevokedException.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -200,1 +200,1 @@\n-            Map<X509Certificate, byte[]> copy = new HashMap<>(responses.size());\n+            Map<X509Certificate, byte[]> copy = HashMap.newHashMap(responses.size());\n@@ -219,1 +219,1 @@\n-        Map<X509Certificate, byte[]> copy = new HashMap<>(ocspResponses.size());\n+        Map<X509Certificate, byte[]> copy = HashMap.newHashMap(ocspResponses.size());\n","filename":"src\/java.base\/share\/classes\/java\/security\/cert\/PKIXRevocationChecker.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -436,0 +436,4 @@\n+     * @apiNote\n+     * To create a {@code HashMap} with an initial capacity that accommodates\n+     * an expected number of mappings, use {@link #newHashMap(int) newHashMap}.\n+     *\n@@ -458,0 +462,4 @@\n+     * @apiNote\n+     * To create a {@code HashMap} with an initial capacity that accommodates\n+     * an expected number of mappings, use {@link #newHashMap(int) newHashMap}.\n+     *\n@@ -2548,0 +2556,28 @@\n+    \/**\n+     * Calculate initial capacity for HashMap based classes, from expected size and default load factor (0.75).\n+     *\n+     * @param numMappings the expected number of mappings\n+     * @return initial capacity for HashMap based classes.\n+     * @since 19\n+     *\/\n+    static int calculateHashMapCapacity(int numMappings) {\n+        return (int) Math.ceil(numMappings \/ (double) DEFAULT_LOAD_FACTOR);\n+    }\n+\n+    \/**\n+     * Creates a new, empty HashMap suitable for the expected number of mappings.\n+     * The returned map uses the default load factor of 0.75, and its initial capacity is\n+     * generally large enough so that the expected number of mappings can be added\n+     * without resizing the map.\n+     *\n+     * @param numMappings the expected number of mappings\n+     * @param <K>         the type of keys maintained by this map\n+     * @param <V>         the type of mapped values\n+     * @return the newly created map\n+     * @throws IllegalArgumentException if numMappings is negative\n+     * @since 19\n+     *\/\n+    public static <K, V> HashMap<K, V> newHashMap(int numMappings) {\n+        return new HashMap<>(calculateHashMapCapacity(numMappings));\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/HashMap.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -120,1 +120,1 @@\n-        map = new HashMap<>(Math.max((int) (c.size()\/.75f) + 1, 16));\n+        map = HashMap.newHashMap(Math.max(c.size(), 12));\n","filename":"src\/java.base\/share\/classes\/java\/util\/HashSet.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -342,0 +342,4 @@\n+     * @apiNote\n+     * To create a {@code LinkedHashMap} with an initial capacity that accommodates\n+     * an expected number of mappings, use {@link #newLinkedHashMap(int) newLinkedHashMap}.\n+     *\n@@ -356,0 +360,4 @@\n+     * @apiNote\n+     * To create a {@code LinkedHashMap} with an initial capacity that accommodates\n+     * an expected number of mappings, use {@link #newLinkedHashMap(int) newLinkedHashMap}.\n+     *\n@@ -791,0 +799,16 @@\n+    \/**\n+     * Creates a new, empty, insertion-ordered LinkedHashMap suitable for the expected number of mappings.\n+     * The returned map uses the default load factor of 0.75, and its initial capacity is\n+     * generally large enough so that the expected number of mappings can be added\n+     * without resizing the map.\n+     *\n+     * @param numMappings the expected number of mappings\n+     * @param <K>         the type of keys maintained by this map\n+     * @param <V>         the type of mapped values\n+     * @return the newly created map\n+     * @throws IllegalArgumentException if numMappings is negative\n+     * @since 19\n+     *\/\n+    public static <K, V> LinkedHashMap<K, V> newLinkedHashMap(int numMappings) {\n+        return new LinkedHashMap<>(HashMap.calculateHashMapCapacity(numMappings));\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/util\/LinkedHashMap.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -196,1 +196,1 @@\n-        HashMap<String,Object> temp = new HashMap<>(contents.length);\n+        HashMap<String,Object> temp = HashMap.newHashMap(contents.length);\n","filename":"src\/java.base\/share\/classes\/java\/util\/ListResourceBundle.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -201,0 +201,4 @@\n+     * @apiNote\n+     * To create a {@code WeakHashMap} with an initial capacity that accommodates\n+     * an expected number of mappings, use {@link #newWeakHashMap(int) newWeakHashMap}.\n+     *\n@@ -226,0 +230,4 @@\n+     * @apiNote\n+     * To create a {@code WeakHashMap} with an initial capacity that accommodates\n+     * an expected number of mappings, use {@link #newWeakHashMap(int) newWeakHashMap}.\n+     *\n@@ -1338,0 +1346,17 @@\n+    \/**\n+     * Creates a new, empty WeakHashMap suitable for the expected number of mappings.\n+     * The returned map uses the default load factor of 0.75, and its initial capacity is\n+     * generally large enough so that the expected number of mappings can be added\n+     * without resizing the map.\n+     *\n+     * @param numMappings the expected number of mappings\n+     * @param <K>         the type of keys maintained by this map\n+     * @param <V>         the type of mapped values\n+     * @return the newly created map\n+     * @throws IllegalArgumentException if numMappings is negative\n+     * @since 19\n+     *\/\n+    public static <K, V> WeakHashMap<K, V> newWeakHashMap(int numMappings) {\n+        return new WeakHashMap<>(HashMap.calculateHashMapCapacity(numMappings));\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/WeakHashMap.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-        this(11);\n+        this(16);\n@@ -82,1 +82,1 @@\n-        map = new LinkedHashMap<>(size);\n+        map = LinkedHashMap.newLinkedHashMap(size);\n","filename":"src\/java.base\/share\/classes\/java\/util\/jar\/Attributes.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -675,1 +675,1 @@\n-            signerMap = new HashMap<>(verifiedSigners.size() + sigFileSigners.size());\n+            signerMap = HashMap.newHashMap(verifiedSigners.size() + sigFileSigners.size());\n","filename":"src\/java.base\/share\/classes\/java\/util\/jar\/JarVerifier.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -591,1 +591,1 @@\n-        Map<String, byte[]> map = new HashMap<>(hash_count);\n+        Map<String, byte[]> map = HashMap.newHashMap(hash_count);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/ModuleInfo.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -310,1 +310,1 @@\n-        singleResponseMap = new HashMap<>(singleResponseDer.length);\n+        singleResponseMap = HashMap.newHashMap(singleResponseDer.length);\n@@ -754,1 +754,1 @@\n-                new HashMap<>(extDer.length);\n+                HashMap.newHashMap(extDer.length);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/certpath\/OCSPResponse.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -484,1 +484,1 @@\n-        Map<K,V> kvmap = new HashMap<>(cacheMap.size());\n+        Map<K,V> kvmap = HashMap.newHashMap(cacheMap.size());\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/Cache.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -160,1 +160,1 @@\n-        return new HashMap<>(size);\n+        return HashMap.newHashMap(size);\n","filename":"src\/java.base\/share\/classes\/sun\/util\/resources\/OpenListResourceBundle.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -99,1 +99,1 @@\n-        return new LinkedHashMap<>(size);\n+        return LinkedHashMap.newLinkedHashMap(size);\n","filename":"src\/java.base\/share\/classes\/sun\/util\/resources\/TimeZoneNamesBundle.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-        theEnvironment = new HashMap<>(environ.length\/2 + 3);\n+        theEnvironment = HashMap.newHashMap(environ.length\/2 + 3);\n@@ -102,1 +102,1 @@\n-        return new StringEnvironment(new HashMap<>(capacity));\n+        return new StringEnvironment(HashMap.newHashMap(capacity));\n","filename":"src\/java.base\/unix\/classes\/java\/lang\/ProcessEnvironment.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -110,1 +110,1 @@\n-                    mimeTypeMap = new HashMap<>(lines.size());\n+                    mimeTypeMap = HashMap.newHashMap(lines.size());\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/MimeTypesFileTypeDetector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -111,1 +111,1 @@\n-                = new HashMap<>(STATIC_TABLE_LENGTH);\n+                = HashMap.newHashMap(STATIC_TABLE_LENGTH);\n@@ -119,1 +119,1 @@\n-        Map<String, Map<String, Integer>> copy = new HashMap<>(map.size());\n+        Map<String, Map<String, Integer>> copy = HashMap.newHashMap(map.size());\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/hpack\/HeaderTable.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -110,1 +110,1 @@\n-                    new HashMap<>(length);\n+                        HashMap.newHashMap(length);\n","filename":"src\/java.xml.crypto\/share\/classes\/org\/jcp\/xml\/dsig\/internal\/dom\/DOMXPathFilter2Transform.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -78,1 +78,1 @@\n-                new HashMap<>(length);\n+                    HashMap.newHashMap(length);\n","filename":"src\/java.xml.crypto\/share\/classes\/org\/jcp\/xml\/dsig\/internal\/dom\/DOMXPathTransform.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -171,1 +171,1 @@\n-        _references = new HashMap<>(_size+2);\n+        _references = HashMap.newHashMap(_size);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xalan\/internal\/xsltc\/dom\/DocumentCache.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -396,1 +396,1 @@\n-                reversedIdentifiers = new HashMap<>(identifiers.size());\n+                reversedIdentifiers = HashMap.newHashMap(identifiers.size());\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/dom\/CoreDocumentImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1819,1 +1819,1 @@\n-        items = new HashMap<>(size*2+1);\n+        items = HashMap.newHashMap(size*2+1);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/impl\/xs\/traversers\/XSAttributeChecker.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1564,1 +1564,1 @@\n-        inodes = new LinkedHashMap<>(end.centot + 1);\n+        inodes = LinkedHashMap.newLinkedHashMap(end.centot + 1);\n","filename":"src\/jdk.zipfs\/share\/classes\/jdk\/nio\/zipfs\/ZipFileSystem.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n- * @bug 8210280 8281631\n+ * @bug 8186958 8210280 8281631\n@@ -204,1 +204,1 @@\n-        for (int i = 2; i < 128; i++) {\n+        for (int i = 2; i < 64; i++) {\n@@ -283,1 +283,1 @@\n-                \/\/ pcc(\"fwm0pa\", size, cap, () -> new WeakHashMap<>(),                map -> { map.putAll(fakeMap(size)); }), \/\/ see note\n+             \/\/ pcc(\"fwm0pa\", size, cap, () -> new WeakHashMap<>(),                map -> { map.putAll(fakeMap(size)); }), \/\/ see note\n@@ -295,1 +295,0 @@\n-        cases.addAll(genPopulatedCapacityCases(11,  16));\n@@ -298,1 +297,4 @@\n-        cases.addAll(genPopulatedCapacityCases(64, 128));\n+        cases.addAll(genPopulatedCapacityCases(24,  32));\n+        cases.addAll(genPopulatedCapacityCases(25,  64));\n+        cases.addAll(genPopulatedCapacityCases(48,  64));\n+        cases.addAll(genPopulatedCapacityCases(49, 128));\n@@ -302,3 +304,4 @@\n-        cases.addAll(genFakePopulatedCapacityCases(25165824, 33554432));\n-        cases.addAll(genFakePopulatedCapacityCases(25165825, 67108864));\n-        cases.addAll(genFakePopulatedCapacityCases(25165826, 67108864));\n+        cases.addAll(genFakePopulatedCapacityCases(25165824,  33554432));\n+        cases.addAll(genFakePopulatedCapacityCases(25165825,  67108864));\n+        cases.addAll(genFakePopulatedCapacityCases(50331648,  67108864));\n+        cases.addAll(genFakePopulatedCapacityCases(50331649, 134217728));\n@@ -320,0 +323,49 @@\n+    \/*\n+     * tests for requested size (static factory methods)\n+     *\/\n+\n+    \/\/ helper method for one requested size case, to provide target types for lambda\n+    Object[] rsc(String label,\n+                 int size,\n+                 int expectedCapacity,\n+                 Supplier<Map<String, String>> supplier) {\n+        return new Object[]{label, size, expectedCapacity, supplier};\n+    }\n+\n+    List<Object[]> genRequestedSizeCases(int size, int cap) {\n+        return Arrays.asList(\n+                rsc(\"rshm\", size, cap, () -> HashMap.newHashMap(size)),\n+                rsc(\"rslm\", size, cap, () -> LinkedHashMap.newLinkedHashMap(size)),\n+                rsc(\"rswm\", size, cap, () -> WeakHashMap.newWeakHashMap(size))\n+        );\n+    }\n+\n+    @DataProvider(name = \"requestedSize\")\n+    public Iterator<Object[]> requestedSizeCases() {\n+        ArrayList<Object[]> cases = new ArrayList<>();\n+        cases.addAll(genRequestedSizeCases(12,  16));\n+        cases.addAll(genRequestedSizeCases(13,  32));\n+        cases.addAll(genRequestedSizeCases(24,  32));\n+        cases.addAll(genRequestedSizeCases(25,  64));\n+        cases.addAll(genRequestedSizeCases(48,  64));\n+        cases.addAll(genRequestedSizeCases(49, 128));\n+\n+        \/\/ numbers in this range are truncated by a float computation with 0.75f\n+        \/\/ but can get an exact result with a double computation with 0.75d\n+        cases.addAll(genRequestedSizeCases(25165824,  33554432));\n+        cases.addAll(genRequestedSizeCases(25165825,  67108864));\n+        cases.addAll(genRequestedSizeCases(50331648,  67108864));\n+        cases.addAll(genRequestedSizeCases(50331649, 134217728));\n+\n+        return cases.iterator();\n+    }\n+\n+    @Test(dataProvider = \"requestedSize\")\n+    public void requestedSize(String label,  \/\/ unused, included for diagnostics\n+                              int size,      \/\/ unused, included for diagnostics\n+                              int expectedCapacity,\n+                              Supplier<Map<String, String>> s) {\n+        Map<String, String> map = s.get();\n+        map.put(\"\", \"\");\n+        assertEquals(capacity(map), expectedCapacity);\n+    }\n","filename":"test\/jdk\/java\/util\/HashMap\/WhiteBoxResizeTest.java","additions":60,"deletions":8,"binary":false,"changes":68,"status":"modified"}]}