{"files":[{"patch":"@@ -617,3 +617,1 @@\n-\/\/ 2) reg_class compiler_method_reg        ( \/* as def'd in frame section *\/ )\n-\/\/ 2) reg_class interpreter_method_reg     ( \/* as def'd in frame section *\/ )\n-\/\/ 3) reg_class stack_slots( \/* one chunk of stack-based \"registers\" *\/ )\n+\/\/ 2) reg_class stack_slots( \/* one chunk of stack-based \"registers\" *\/ )\n@@ -2611,5 +2609,0 @@\n-\/\/ No-op on amd64\n-void Matcher::pd_implicit_null_fixup(MachNode *node, uint idx) {\n-  Unimplemented();\n-}\n-\n@@ -4093,3 +4086,0 @@\n-  \/\/ Method Register when calling interpreter.\n-  interpreter_method_reg(R12);\n-\n@@ -5683,10 +5673,0 @@\n-operand interpreter_method_RegP(iRegP reg)\n-%{\n-  constraint(ALLOC_IN_RC(method_reg)); \/\/ interpreter_method_reg\n-  match(reg);\n-  match(iRegPNoSp);\n-  op_cost(0);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":1,"deletions":21,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1162,4 +1162,0 @@\n-\/\/ No-op on ARM.\n-void Matcher::pd_implicit_null_fixup(MachNode *node, uint idx) {\n-}\n-\n@@ -1670,1 +1666,0 @@\n-  interpreter_method_reg(R_Rmethod);     \/\/ Method Register when calling interpreter\n@@ -2530,8 +2525,0 @@\n-operand interpreter_method_regP(iRegP reg) %{\n-  constraint(ALLOC_IN_RC(Rmethod_regP));\n-  match(reg);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -185,1 +185,1 @@\n-                   R_S0,  R_S1,  R_S2,  R_S3,  R_S4,  R_S5,  R_S6,  R_S7, \n+                   R_S0,  R_S1,  R_S2,  R_S3,  R_S4,  R_S5,  R_S6,  R_S7,\n@@ -187,3 +187,3 @@\n-                   R_D16, R_D16x,R_D17, R_D17x,R_D18, R_D18x,R_D19, R_D19x, \n-                   R_D20, R_D20x,R_D21, R_D21x,R_D22, R_D22x,R_D23, R_D23x, \n-                   R_D24, R_D24x,R_D25, R_D25x,R_D26, R_D26x,R_D27, R_D27x, \n+                   R_D16, R_D16x,R_D17, R_D17x,R_D18, R_D18x,R_D19, R_D19x,\n+                   R_D20, R_D20x,R_D21, R_D21x,R_D22, R_D22x,R_D23, R_D23x,\n+                   R_D24, R_D24x,R_D25, R_D25x,R_D26, R_D26x,R_D27, R_D27x,\n@@ -199,2 +199,1 @@\n-\/\/ 2) reg_class interpreter_method_reg     ( as defined in frame section )\n-\/\/ 3) reg_class stack_slots( \/* one chunk of stack-based \"registers\" *\/ )\n+\/\/ 2) reg_class stack_slots( \/* one chunk of stack-based \"registers\" *\/ )\n@@ -226,1 +225,0 @@\n-#define R_Rmethod  R_R9\n@@ -240,1 +238,0 @@\n-reg_class Rmethod_regP(R_Rmethod);\n@@ -445,1 +442,1 @@\n-  return (2 + (far ? 3 : 1)) * NativeInstruction::instruction_size; \n+  return (2 + (far ? 3 : 1)) * NativeInstruction::instruction_size;\n","filename":"src\/hotspot\/cpu\/arm\/arm_32.ad","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -538,3 +538,1 @@\n-\/\/ 2) reg_class compiler_method_reg        ( as defined in frame section )\n-\/\/ 2) reg_class interpreter_method_reg     ( as defined in frame section )\n-\/\/ 3) reg_class stack_slots( \/* one chunk of stack-based \"registers\" *\/ )\n+\/\/ 2) reg_class stack_slots( \/* one chunk of stack-based \"registers\" *\/ )\n@@ -2347,4 +2345,0 @@\n-void Matcher::pd_implicit_null_fixup(MachNode *node, uint idx) {\n- Unimplemented();\n-}\n-\n@@ -3862,3 +3856,0 @@\n-  \/\/ Method Register when calling interpreter.\n-  interpreter_method_reg(R19); \/\/ R19_method\n-\n@@ -4770,14 +4761,0 @@\n-%}\n-\n-operand compiler_method_regP(iRegPdst reg) %{\n-  constraint(ALLOC_IN_RC(rscratch1_bits64_reg)); \/\/ compiler_method_reg\n-  match(reg);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-operand interpreter_method_regP(iRegPdst reg) %{\n-  constraint(ALLOC_IN_RC(r19_bits64_reg)); \/\/ interpreter_method_reg\n-  match(reg);\n-  format %{ %}\n-  interface(REG_INTER);\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":1,"deletions":24,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -281,3 +281,1 @@\n-\/\/ 2) reg_class compiler_method_reg        (as defined in frame section)\n-\/\/ 2) reg_class interpreter_method_reg     (as defined in frame section)\n-\/\/ 3) reg_class stack_slots(\/* one chunk of stack-based \"registers\" *\/)\n+\/\/ 2) reg_class stack_slots(\/* one chunk of stack-based \"registers\" *\/)\n@@ -2469,6 +2467,0 @@\n-  \/\/ Temporary in compiled entry-points\n-  \/\/ compiler_method_reg(Z_R1);\/\/Z_R1_scratch\n-\n-  \/\/ Method Register when calling interpreter\n-  interpreter_method_reg(Z_R9);\/\/Z_method\n-\n@@ -3538,14 +3530,0 @@\n-operand compiler_method_regP(iRegP reg) %{\n-  constraint(ALLOC_IN_RC(z_r1_RegP)); \/\/ compiler_method_reg\n-  match(reg);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-operand interpreter_method_regP(iRegP reg) %{\n-  constraint(ALLOC_IN_RC(z_r9_regP)); \/\/ interpreter_method_reg\n-  match(reg);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":1,"deletions":23,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -134,3 +134,1 @@\n-\/\/ 2) reg_class compiler_method_reg        ( \/* as def'd in frame section *\/ )\n-\/\/ 2) reg_class interpreter_method_reg     ( \/* as def'd in frame section *\/ )\n-\/\/ 3) reg_class stack_slots( \/* one chunk of stack-based \"registers\" *\/ )\n+\/\/ 2) reg_class stack_slots( \/* one chunk of stack-based \"registers\" *\/ )\n@@ -153,1 +151,0 @@\n-\/\/ This register class can be used for implicit null checks on win95.\n@@ -1449,51 +1446,0 @@\n-\n-void Matcher::pd_implicit_null_fixup(MachNode *node, uint idx) {\n-  \/\/ Get the memory operand from the node\n-  uint numopnds = node->num_opnds();        \/\/ Virtual call for number of operands\n-  uint skipped  = node->oper_input_base();  \/\/ Sum of leaves skipped so far\n-  assert( idx >= skipped, \"idx too low in pd_implicit_null_fixup\" );\n-  uint opcnt     = 1;                 \/\/ First operand\n-  uint num_edges = node->_opnds[1]->num_edges(); \/\/ leaves for first operand\n-  while( idx >= skipped+num_edges ) {\n-    skipped += num_edges;\n-    opcnt++;                          \/\/ Bump operand count\n-    assert( opcnt < numopnds, \"Accessing non-existent operand\" );\n-    num_edges = node->_opnds[opcnt]->num_edges(); \/\/ leaves for next operand\n-  }\n-\n-  MachOper *memory = node->_opnds[opcnt];\n-  MachOper *new_memory = NULL;\n-  switch (memory->opcode()) {\n-  case DIRECT:\n-  case INDOFFSET32X:\n-    \/\/ No transformation necessary.\n-    return;\n-  case INDIRECT:\n-    new_memory = new indirect_win95_safeOper( );\n-    break;\n-  case INDOFFSET8:\n-    new_memory = new indOffset8_win95_safeOper(memory->disp(NULL, NULL, 0));\n-    break;\n-  case INDOFFSET32:\n-    new_memory = new indOffset32_win95_safeOper(memory->disp(NULL, NULL, 0));\n-    break;\n-  case INDINDEXOFFSET:\n-    new_memory = new indIndexOffset_win95_safeOper(memory->disp(NULL, NULL, 0));\n-    break;\n-  case INDINDEXSCALE:\n-    new_memory = new indIndexScale_win95_safeOper(memory->scale());\n-    break;\n-  case INDINDEXSCALEOFFSET:\n-    new_memory = new indIndexScaleOffset_win95_safeOper(memory->scale(), memory->disp(NULL, NULL, 0));\n-    break;\n-  case LOAD_LONG_INDIRECT:\n-  case LOAD_LONG_INDOFFSET32:\n-    \/\/ Does not use EBP as address register, use { EDX, EBX, EDI, ESI}\n-    return;\n-  default:\n-    assert(false, \"unexpected memory operand in pd_implicit_null_fixup()\");\n-    return;\n-  }\n-  node->_opnds[opcnt] = new_memory;\n-}\n-\n@@ -3193,1 +3139,0 @@\n-  interpreter_method_reg(EBX);          \/\/ Method Register when calling interpreter\n@@ -4407,92 +4352,0 @@\n-\/\/----------Memory Operands - Win95 Implicit Null Variants----------------\n-\/\/ Indirect Memory Operand\n-operand indirect_win95_safe(eRegP_no_EBP reg)\n-%{\n-  constraint(ALLOC_IN_RC(int_reg));\n-  match(reg);\n-\n-  op_cost(100);\n-  format %{ \"[$reg]\" %}\n-  interface(MEMORY_INTER) %{\n-    base($reg);\n-    index(0x4);\n-    scale(0x0);\n-    disp(0x0);\n-  %}\n-%}\n-\n-\/\/ Indirect Memory Plus Short Offset Operand\n-operand indOffset8_win95_safe(eRegP_no_EBP reg, immI8 off)\n-%{\n-  match(AddP reg off);\n-\n-  op_cost(100);\n-  format %{ \"[$reg + $off]\" %}\n-  interface(MEMORY_INTER) %{\n-    base($reg);\n-    index(0x4);\n-    scale(0x0);\n-    disp($off);\n-  %}\n-%}\n-\n-\/\/ Indirect Memory Plus Long Offset Operand\n-operand indOffset32_win95_safe(eRegP_no_EBP reg, immI off)\n-%{\n-  match(AddP reg off);\n-\n-  op_cost(100);\n-  format %{ \"[$reg + $off]\" %}\n-  interface(MEMORY_INTER) %{\n-    base($reg);\n-    index(0x4);\n-    scale(0x0);\n-    disp($off);\n-  %}\n-%}\n-\n-\/\/ Indirect Memory Plus Index Register Plus Offset Operand\n-operand indIndexOffset_win95_safe(eRegP_no_EBP reg, rRegI ireg, immI off)\n-%{\n-  match(AddP (AddP reg ireg) off);\n-\n-  op_cost(100);\n-  format %{\"[$reg + $off + $ireg]\" %}\n-  interface(MEMORY_INTER) %{\n-    base($reg);\n-    index($ireg);\n-    scale(0x0);\n-    disp($off);\n-  %}\n-%}\n-\n-\/\/ Indirect Memory Times Scale Plus Index Register\n-operand indIndexScale_win95_safe(eRegP_no_EBP reg, rRegI ireg, immI2 scale)\n-%{\n-  match(AddP reg (LShiftI ireg scale));\n-\n-  op_cost(100);\n-  format %{\"[$reg + $ireg << $scale]\" %}\n-  interface(MEMORY_INTER) %{\n-    base($reg);\n-    index($ireg);\n-    scale($scale);\n-    disp(0x0);\n-  %}\n-%}\n-\n-\/\/ Indirect Memory Times Scale Plus Index Register Plus Offset Operand\n-operand indIndexScaleOffset_win95_safe(eRegP_no_EBP reg, immI off, rRegI ireg, immI2 scale)\n-%{\n-  match(AddP (AddP reg (LShiftI ireg scale)) off);\n-\n-  op_cost(100);\n-  format %{\"[$reg + $off + $ireg << $scale]\" %}\n-  interface(MEMORY_INTER) %{\n-    base($reg);\n-    index($ireg);\n-    scale($scale);\n-    disp($off);\n-  %}\n-%}\n-\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":1,"deletions":148,"binary":false,"changes":149,"status":"modified"},{"patch":"@@ -164,3 +164,1 @@\n-\/\/ 2) reg_class compiler_method_reg        ( \/* as def'd in frame section *\/ )\n-\/\/ 2) reg_class interpreter_method_reg     ( \/* as def'd in frame section *\/ )\n-\/\/ 3) reg_class stack_slots( \/* one chunk of stack-based \"registers\" *\/ )\n+\/\/ 2) reg_class stack_slots( \/* one chunk of stack-based \"registers\" *\/ )\n@@ -1664,3 +1662,0 @@\n-\/\/ No-op on amd64\n-void Matcher::pd_implicit_null_fixup(MachNode *node, uint idx) {}\n-\n@@ -2745,2 +2740,0 @@\n-  interpreter_method_reg(RBX);          \/\/ Method Register when\n-                                        \/\/ calling interpreter\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1009,1 +1009,2 @@\n-        interpreter_method_parse(frame, false);\n+        parse_err(WARN, \"Using obsolete Token, interpreter_method_reg\");\n+        skipws();\n@@ -1137,5 +1138,0 @@\n-\/\/------------------------------interpreter_method_parse------------------\n-void ADLParser::interpreter_method_parse(FrameForm *frame, bool native) {\n-  frame->_interpreter_method_reg = parse_one_arg(\"method reg entry\");\n-}\n-\n","filename":"src\/hotspot\/share\/adlc\/adlparse.cpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -339,1 +339,0 @@\n-  char *_interpreter_method_reg;\n","filename":"src\/hotspot\/share\/adlc\/formsopt.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4195,8 +4195,1 @@\n-  \/\/ Interpreter's Method Register, mask definition, and encoding\n-  fprintf(fp_cpp,\"OptoReg::Name Matcher::interpreter_method_reg() {\");\n-  fprintf(fp_cpp,\" return OptoReg::Name(%s_num); }\\n\\n\",\n-          _frame->_interpreter_method_reg);\n-  fprintf(fp_cpp,\"int Matcher::interpreter_method_reg_encode() {\");\n-  fprintf(fp_cpp,\" return _regEncode[interpreter_method_reg()]; }\\n\\n\");\n-\n-  \/\/ Interpreter's Frame Pointer Register, mask definition, and encoding\n+  \/\/ Interpreter's Frame Pointer Register\n","filename":"src\/hotspot\/share\/adlc\/output_c.cpp","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -421,7 +421,0 @@\n-  static OptoReg::Name  interpreter_method_reg();\n-  static int            interpreter_method_reg_encode();\n-\n-  static OptoReg::Name  compiler_method_reg();\n-  static const RegMask &compiler_method_reg_mask();\n-  static int            compiler_method_reg_encode();\n-\n@@ -538,4 +531,0 @@\n-  \/\/ Perform a platform dependent implicit null fixup.  This is needed\n-  \/\/ on windows95 to take care of some unusual register constraints.\n-  void pd_implicit_null_fixup(MachNode *load, uint idx);\n-\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"}]}