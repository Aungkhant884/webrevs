{"files":[{"patch":"@@ -0,0 +1,602 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, IBM Corp.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.nio.fs;\n+\n+import java.nio.file.*;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+import java.io.IOException;\n+import jdk.internal.misc.Unsafe;\n+\n+import static sun.nio.fs.UnixNativeDispatcher.*;\n+import static sun.nio.fs.UnixConstants.*;\n+\n+\/**\n+ * AIX Poller Implementation\n+ *\/\n+public class AhafsPoller extends AbstractPoller\n+{\n+    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+    \/\/ The mount point for ahafs. Can be mounted at any point, but setup instructions recommend \/aha.\n+    private static final String AHA_MOUNT_POINT = \"\/aha\";\n+    \/\/ The following timeout controls the maximum time a worker thread will remain blocked before\n+    \/\/ picking up newly registered keys.\n+    private static final int POLL_TIMEOUT = 100; \/\/ ms\n+    \/\/ This affects the OPAQUE_BUFFER_SIZE.\n+    private static final int MAX_FDS = 2048;\n+    \/\/ See description of opaque buffer below.\n+    private static final int OPAQUE_BUFFER_SIZE = MAX_FDS*nPollfdSize();\n+    \/\/ Careful when changing the following buffer size. Keep in sync with the one in AixWatchService.c\n+    private static final int EVENT_BUFFER_SIZE = 2048;\n+\n+    private static final int SP_LISTEN = 0;\n+    private static final int SP_NOTIFY = 1;\n+\n+    private AixWatchService watcher;\n+    private HashMap<Integer, AixWatchKey> wdToKey;\n+    \/\/ A socket pair created by the native socket pair routine.\n+    private int[] sp_signal;\n+    \/\/ Native-memory buffer used by AIX Event Infrastructure (AHAFS)\n+    \/\/ to store file descriptors and other info.\n+    \/\/ Treated as an 'opaque memory store' on the JVM heap. Keeping it here allows the\n+    \/\/ native procedures to be functional (as in the paradigm).\n+    private NativeBuffer opaqueBuffer;\n+    \/\/ Number of open fds by the system. Managed by the native methods,\n+    \/\/ but stored here for the same reasons as above.\n+    private int[] nfds;\n+\n+    public AhafsPoller (AixWatchService watchService)\n+        throws AixWatchService.FatalException\n+    {\n+        this.watcher = watchService;\n+        this.wdToKey = new HashMap<Integer, AixWatchKey>();\n+        this.nfds = new int[1];\n+        this.opaqueBuffer = new NativeBuffer(OPAQUE_BUFFER_SIZE);\n+\n+        this. sp_signal = new int[2];\n+        try {\n+            nSocketpair(sp_signal);\n+        } catch (UnixException e) {\n+            throw new AixWatchService.FatalException(\"Could not create socketpair for Poller\", e);\n+        }\n+\n+        nInit(opaqueBuffer.address(), OPAQUE_BUFFER_SIZE, nfds, sp_signal[SP_LISTEN]);\n+    }\n+\n+    \/**\n+     * Wake up the Poller to process changes.\n+     *\/\n+    @Override\n+    void wakeup()\n+        throws IOException\n+    {\n+        \/\/ write to socketpair to wakeup polling thread\n+        try (NativeBuffer buffer = new NativeBuffer(1)) {\n+            write(sp_signal[SP_NOTIFY], buffer.address(), 1);\n+        } catch (UnixException x) {\n+            throw new IOException(\"Exception ocurred during poller wakeup \" + x.errorString());\n+        }\n+    }\n+\n+    private Path buildAhafsDirMonitorPath(Path path) { return buildAhafsMonitorPath(path, \"modDir.monFactory\"); }\n+\n+    private Path buildAhafsFileMonitorPath(Path path) { return buildAhafsMonitorPath(path, \"modFile.monFactory\"); }\n+\n+    \/**\n+     *  AHAFS works by creating a specific path in the AHA File System to monitor a target file elsewhere in the system.\n+     *  This method and it's two helpers, create the path to be used depending on which event producer is to be used.\n+     *  - modDir watches the contents of a directory for file or sub-directory create or delete events.\n+     *  - modFile watches the file for modify events.\n+     *  *\/\n+    private Path buildAhafsMonitorPath(Path path, String eventProducer)\n+    {\n+        \/\/ Create path AHA_MOUNT_POINT\/fs\/<event-producer>\/<parent-dir-path>\/<fname>.mon\n+        return Path.of(AHA_MOUNT_POINT, \"fs\", eventProducer,\n+                       path.getParent().toString(), path.getFileName().toString() + \".mon\");\n+    }\n+\n+    \/**\n+     * Create the resources required to monitor a new file, and add the system created\n+     * file descriptor to the opaque buffer to be watched with poll.\n+     *\n+     * The file descriptor returned by the system is used as a unique identifier for this key.\n+     *\/\n+    private int createNewWatchDescriptor(UnixPath ahafsMonitorPath)\n+        throws AixWatchService.FatalException\n+    {\n+        int wd = AixWatchKey.INVALID_WATCH_DESCRIPTOR;\n+\n+        \/\/ Create resources in AHAFS\n+        try {\n+            Files.createDirectories(ahafsMonitorPath.getParent());\n+        } catch (FileAlreadyExistsException e) {\n+            \/\/ Ignore. It's OK if the parent directory is already present in AHAFS.\n+        } catch (IOException e) {\n+            throw new AixWatchService.FatalException(\"Unable to create parent directory in AHAFS for \" + ahafsMonitorPath, e);\n+        }\n+\n+        try (NativeBuffer strBuff =\n+             NativeBuffers.asNativeBuffer(ahafsMonitorPath.getByteArrayForSysCalls())) {\n+            wd = nRegisterMonitorPath(opaqueBuffer.address(), nfds[0], strBuff.address());\n+        } catch (UnixException e) {\n+            throw new AixWatchService.FatalException(\"Invalid WatchDescriptor (\" + wd + \") returned by native procedure while attempting to register \" + ahafsMonitorPath);\n+        }\n+\n+        assert(wd != AixWatchKey.INVALID_WATCH_DESCRIPTOR);\n+\n+        nfds[0] += 1;\n+        return wd;\n+    }\n+\n+    \/**\n+     * Create a new SubKey.\n+     *\n+     * SubKeys are used to monitor a top level directory for modify events. This is required because\n+     * AHAFS only supports monitoring a directory for create and delete events directly.\n+     *\/\n+    private AixWatchKey.SubKey createSubKey(Path filePath, AixWatchKey.TopLevelKey topLevelKey)\n+        throws AixWatchService.FatalException\n+    {\n+        UnixPath monitorPath = (UnixPath) buildAhafsFileMonitorPath(filePath.normalize().toAbsolutePath());\n+\n+        int wd = createNewWatchDescriptor(monitorPath);\n+\n+        AixWatchKey.SubKey k = new AixWatchKey.SubKey(filePath, wd, topLevelKey);\n+        wdToKey.put(wd, k);\n+        return k;\n+    }\n+\n+    \/** Create SubKeys from a given root and add them to a given TopLevelKey\n+     *\/\n+    private void createSubKeys(Path root, AixWatchKey.TopLevelKey topLevelKey)\n+        throws AixWatchService.FatalException, IOException\n+    {\n+        HashSet<AixWatchKey.SubKey> subKeys = new HashSet<>();\n+\n+        for (Path filePath: Files.walk(root, 1)\n+                                 .filter((Path p) -> Files.isRegularFile(p))\n+                                 .collect(Collectors.toList())) {\n+            subKeys.add(createSubKey(filePath, topLevelKey));\n+        }\n+\n+        topLevelKey.addSubKeys(subKeys);\n+    }\n+\n+    Optional<? extends Exception> checkRegisterArgs(Path watchPath,\n+                                                    Set<? extends WatchEvent.Kind<?>> events,\n+                                                    WatchEvent.Modifier... modifiers)\n+    {\n+        UnixPath watchUnixPath = (UnixPath) watchPath;\n+        UnixFileAttributes attrs = null;\n+\n+        \/\/ Validate path\n+        if (watchPath == null) {\n+            return Optional.of(new NullPointerException(\"AixWatchSerice: Path was null\"));\n+        }\n+        try {\n+            attrs = UnixFileAttributes.get(watchUnixPath , true);\n+        } catch (UnixException x) {\n+            return Optional.of(x.asIOException(watchUnixPath));\n+        }\n+        if (!attrs.isDirectory()) {\n+            return Optional.of(new NotDirectoryException(watchUnixPath.getPathForExceptionMessage()));\n+        }\n+\n+        \/\/ Validate events\n+        if (events == null) {\n+            return Optional.of(new NullPointerException(\"AixWatchSerice: Watch events list was null\"));\n+        } else if (events.contains(null)) {\n+            return Optional.of(new NullPointerException(\"AixWatchSerice: Watch events list contains a null element\"));\n+        } else if (!(events.contains(StandardWatchEventKinds.ENTRY_CREATE) ||\n+                     events.contains(StandardWatchEventKinds.ENTRY_MODIFY) ||\n+                     events.contains(StandardWatchEventKinds.ENTRY_DELETE))) {\n+            return Optional.of(new UnsupportedOperationException(\"AixWatchService: No supported events in registration of \" + watchPath));\n+        }\n+\n+        \/\/ Validate modifiers\n+        if (modifiers.length > 0) {\n+            for (WatchEvent.Modifier modifier: modifiers) {\n+                if (modifier == null)\n+                    return Optional.of(new NullPointerException(\"AixWatchService: Modifier was null\"));\n+                if (!ExtendedOptions.SENSITIVITY_HIGH.matches(modifier) &&\n+                    !ExtendedOptions.SENSITIVITY_MEDIUM.matches(modifier) &&\n+                    !ExtendedOptions.SENSITIVITY_LOW.matches(modifier)) {\n+                    return Optional.of(new UnsupportedOperationException(\"AixWatchService: Modifiers not supported\"));\n+                }\n+            }\n+        }\n+\n+        return Optional.empty();\n+    }\n+\n+    \/**\n+     * Register a path with the Poller.\n+     *\n+     * @return [WatchKey | RuntimeException | IOException] the caller is expected to check\n+     * if the retuned object is an instance of either exception and act accordingly.\n+     *\/\n+    @Override\n+    Object implRegister(Path watchPath,\n+                        Set<? extends WatchEvent.Kind<?>> events,\n+                        WatchEvent.Modifier... modifiers)\n+    {\n+        Optional<? extends Exception> mError = checkRegisterArgs(watchPath, events, modifiers);\n+        if (mError.isPresent()) {\n+            return mError.get();\n+        }\n+\n+        \/\/ Create resources\n+        UnixPath ahafsMonitorPath = (UnixPath)buildAhafsDirMonitorPath(watchPath.toAbsolutePath());\n+        int wd = AixWatchKey.INVALID_WATCH_DESCRIPTOR;\n+        try {\n+            wd = createNewWatchDescriptor(ahafsMonitorPath);\n+        } catch (AixWatchService.FatalException e) {\n+            return new IOException(\"Invalid watch descriptor returned for \" + ahafsMonitorPath + \" during registration of \" + watchPath, e);\n+        }\n+\n+        AixWatchKey.TopLevelKey wk = new AixWatchKey.TopLevelKey(watchPath, wd, events, this.watcher);\n+        wdToKey.put(wd, wk);\n+\n+        \/\/ Directory modifications are not supported directly in AIX Event\n+        \/\/ Infrastructure. So the modify event is detected by monitoring\n+        \/\/ for changes to the individual files in the directory.\n+        if (wk.isWatching(StandardWatchEventKinds.ENTRY_MODIFY)) {\n+            try {\n+                createSubKeys(watchPath, wk);\n+            } catch (IOException e) {\n+                \/\/ See note about returning exceptions below.\n+                return new IOException(\"[AixWatchService] IO error reported during file registration\", e);\n+            } catch (AixWatchService.FatalException e) {\n+                \/\/ AbstractPolller checks if return type is insanceof IOE or RuntimeException\n+                \/\/ and then throws. To ensure client is informed of the error, we\n+                \/\/ map our internal exception to one checked by the caller and return.\n+                return new IOException(\"[AixWatchService] Error reported during file registration\", e);\n+            }\n+        }\n+\n+        return wk;\n+    }\n+\n+    \/**\n+     * Update an existing AixWatchKey registration.\n+     * Replace the currently watched events with the new event set,\n+     * and perform any necessary housekeeping.\n+     *\/\n+    WatchKey reRegister(AixWatchKey wk,\n+                        Set<? extends WatchEvent.Kind<?>> newEvents,\n+                        WatchEvent.Modifier... modifiers)\n+        throws AixWatchService.FatalException\n+    {\n+        AixWatchKey.TopLevelKey tlk = wk.resolve();\n+        if (newEvents.contains(StandardWatchEventKinds.ENTRY_MODIFY) &&\n+            !wk.isWatching(StandardWatchEventKinds.ENTRY_MODIFY)) {\n+            try {\n+                createSubKeys(wk.watchable(), tlk);\n+            } catch (IOException e) {\n+                throw new AixWatchService.FatalException(\"[AixWatchService] Error reported during file registration\", e);\n+            }\n+        }\n+        if (wk.isWatching(StandardWatchEventKinds.ENTRY_MODIFY) &&\n+            !newEvents.contains(StandardWatchEventKinds.ENTRY_MODIFY)) {\n+            for (AixWatchKey.SubKey sk : tlk.subKeys()) {\n+                tlk.removeSubKey(sk);\n+                cleanKeyResources(sk);\n+            }\n+        }\n+\n+        tlk.replaceEvents(newEvents);\n+        return tlk;\n+    }\n+\n+    \/**\n+     * Cancel an AixWatchKey.\n+     * This method performs two (slightly different) tasks:\n+     *\n+     * 1. Cancel the given primary key (provided by the client) and\n+     *      any subkeys.\n+     * 2. Cancel the given subkey (provided as an interal call). Do not\n+     *      resolve to TopLevelKey or cancel SubKeys.\n+     *\n+     *\/\n+    @Override\n+    void implCancelKey(WatchKey wk)\n+    {\n+        \/\/ Only cancel AixWatchKeys given out by this WatchService\n+        if (!(wk instanceof AixWatchKey))\n+            return;\n+\n+        AixWatchKey awk = (AixWatchKey) wk;\n+        awk.invalidate();\n+\n+        \/\/ If cancelling a TopLevelKey, also cancel any SubKeys\n+        if(wk instanceof AixWatchKey.TopLevelKey) {\n+            AixWatchKey.TopLevelKey tlk = awk.resolve();\n+            for (AixWatchKey.SubKey sk: tlk.subKeys()) {\n+                tlk.removeSubKey(sk);\n+                cleanKeyResources(sk);\n+            }\n+        }\n+\n+        \/\/ Cancel _this_ key regardless of whether it is a TopLevelKey or SubKey.\n+        cleanKeyResources(awk);\n+    }\n+\n+    \/**\n+     * Clean up Resources accociated with a given AixWatchKey\n+     *\/\n+    void cleanKeyResources(AixWatchKey awk)\n+    {\n+        nCancelWatchDescriptor(opaqueBuffer.address(), nfds[0], awk.watchDescriptor());\n+        try {\n+            Path monitorPath;\n+            if (awk instanceof AixWatchKey.TopLevelKey) {\n+                monitorPath = buildAhafsDirMonitorPath(awk.watchable());\n+            } else {\n+                monitorPath = buildAhafsFileMonitorPath(awk.watchable());\n+            }\n+            Files.deleteIfExists(monitorPath);\n+        } catch (IOException e) {\n+            System.err.println(\"Warn: Unable to remove monitor path in AixWatchService for key with (actual) path \"\n+                               + awk.watchable());\n+        }\n+        wdToKey.remove(awk.watchDescriptor());\n+    }\n+\n+    \/\/ Cancel all keys. Close poller\n+    @Override\n+    void implCloseAll()\n+    {\n+        List<AixWatchKey> topLevelKeys = wdToKey.values()\n+            .stream()\n+            .filter((AixWatchKey k) -> k instanceof AixWatchKey.TopLevelKey)\n+            .collect(Collectors.toList());\n+\n+        topLevelKeys.forEach(k -> implCancelKey(k));\n+\n+        UnixNativeDispatcher.close(sp_signal[SP_LISTEN], e -> null);\n+        UnixNativeDispatcher.close(sp_signal[SP_NOTIFY], e -> null);\n+\n+        nCloseAll(opaqueBuffer.address(), nfds[0]);\n+\n+        nfds[0] = 0;\n+        opaqueBuffer.close();\n+    }\n+\n+    private int parseWd(String wdLine)\n+    {\n+        \/\/ Expect: BEGIN_WD=<wd>\n+        return Integer.parseInt(wdLine.substring(9));\n+    }\n+\n+    private Optional<WatchEvent.Kind<?>> parseEventKind(String line, AixWatchKey key)\n+    {\n+        if (key instanceof AixWatchKey.TopLevelKey) {\n+            return parseTopLevelEventKind(line);\n+        } else {\n+            return parseSubKeyEventKind(line);\n+        }\n+    }\n+\n+    private Optional<WatchEvent.Kind<?>> parseTopLevelEventKind(String line)\n+    {\n+        if (line.equals(\"RC_FROM_EVPROD=1000\")) {\n+            return Optional.of(StandardWatchEventKinds.ENTRY_CREATE);\n+        } else if (line.equals(\"RC_FROM_EVPROD=1002\")) {\n+            return Optional.of(StandardWatchEventKinds.ENTRY_DELETE);\n+        } else if (line.equals(\"RC_FROM_EVPROD=1003\")) {\n+            \/\/ Listed an 'unavailable' in the documentation, but seen in\n+            \/\/ the wild. Indicates the monitored directory has been deleted.\n+            return Optional.of(StandardWatchEventKinds.ENTRY_DELETE);\n+        } else {\n+            return Optional.of(AixWatchService.POLL_ERROR);\n+        }\n+    }\n+\n+    static final int RC_LOWER = 1000;\n+    static final int RC_UPPER = 1007;\n+    static final int RC_PRE_LENGTH = \"RC_FROM_EVPROD=\".length();\n+\n+    private Optional<WatchEvent.Kind<?>> parseSubKeyEventKind(String line)\n+    {\n+        if (line.startsWith(\"RC_FROM_EVPROD=\")) {\n+            \/\/ Files watched by the modFile event producer may generate\n+            \/\/ an event when they are:\n+            \/\/ - Written to\n+            \/\/ - Mapped for writing by a process\n+            \/\/ - Cleared (by fclear)\n+            \/\/ - Truncated (by ftrunc)\n+            \/\/\n+            \/\/ The actual event code is umimportant as long as the value is\n+            \/\/ in the expected range since the above events become ENTRY_MODIFY\n+            \/\/ in the context of the WatchService API.\n+            int code = Integer.parseInt(line.substring(RC_PRE_LENGTH));\n+            if (code >= RC_LOWER && code <= RC_UPPER) {\n+                return Optional.of(StandardWatchEventKinds.ENTRY_MODIFY);\n+            }\n+        }\n+        return Optional.of(AixWatchService.POLL_ERROR);\n+    }\n+\n+    private Iterable<String> getLines(long cBuffer)\n+    {\n+        ArrayList<String> lines = new ArrayList<String>();\n+\n+        int start = 0;\n+        int pos = start;\n+        boolean atEnd = false;\n+        while(!atEnd) {\n+            byte b = UNSAFE.getByte(cBuffer + pos);\n+\n+            \/\/ Detect end of c-string\n+            atEnd |= (b == 0);\n+\n+            \/\/ Process new line\n+            if (b == '\\n' || b == 0) {\n+                byte[] bytes = new byte[pos - start];\n+\n+                for (int c = 0; c < pos - start; c++) {\n+                    bytes[c] = UNSAFE.getByte(cBuffer + start + c);\n+                }\n+\n+                String line = new String(bytes);\n+                lines.add(line);\n+\n+                start = pos + 1;\n+                pos = start;\n+            }\n+            \/\/ O.W. Advance cursor until line is complete\n+            else {\n+                pos++;\n+                atEnd |= (pos >= EVENT_BUFFER_SIZE);\n+            }\n+        }\n+        return lines;\n+    }\n+\n+    private Iterable<AixWatchService.PollEvent> parsePollEvents(long eventBuffer, int expCount)\n+    {\n+        ArrayList<AixWatchService.PollEvent> events = new ArrayList<>();\n+\n+        if (expCount <= 0)\n+            return events;\n+\n+        Optional<AixWatchKey> mKey = Optional.empty();\n+        Optional<WatchEvent.Kind<?>> mKind = Optional.empty();\n+        Optional<String> mFilename = Optional.empty();\n+\n+        Iterator<String> lines = getLines(eventBuffer).iterator();\n+        while (lines.hasNext()) {\n+            String line = lines.next();\n+            \/\/ Start parsing event.\n+            if (line.startsWith(\"BEGIN_WD\")) {\n+                int wd = parseWd(line);\n+                mKey = Optional.ofNullable(wdToKey.get(wd));\n+            }\n+            \/\/ Detect buffer overflow\n+            else if (line.equals(\"BUF_WRAP\")) {\n+                mKind = Optional.of(StandardWatchEventKinds.OVERFLOW);\n+            }\n+            \/\/ Parse return code\n+            else if (mKey.isPresent() && line.startsWith(\"RC_FROM_EVPROD\")) {\n+                mKind = parseEventKind(line, mKey.get());\n+            }\n+            \/\/ Parse additional info from event producer\n+            else if (line.startsWith(\"BEGIN_EVPROD_INFO\") && lines.hasNext()) {\n+                \/\/ Expect exactly:                     \/\/ BEGIN_EVPROD_INFO\n+                mFilename = Optional.of(lines.next()); \/\/ <filename>\n+                if (lines.hasNext()) lines.next();     \/\/ END_EVPROD_INFO\n+            }\n+            \/\/ Finish parsing event.\n+            else if (line.startsWith(\"END_WD\")) {\n+                if (mKey.isPresent() && mKind.isPresent()) {\n+                    events.add(new AixWatchService.PollEvent(mKey.get(), mKind.get(), mFilename));\n+                }\n+                mKey      = Optional.empty();\n+                mKind     = Optional.empty();\n+                mFilename = Optional.empty();\n+            }\n+        }\n+\n+        return events;\n+    }\n+\n+    private void processPollEvent(AixWatchService.PollEvent e)\n+        throws AixWatchService.FatalException\n+    {\n+        \/\/ Process all events via the parent event since this is the only\n+        \/\/ event expected by the client.\n+        AixWatchKey.TopLevelKey receiver = e.key().resolve();\n+\n+        \/\/ Notify client of changes.\n+        if (e.key().isWatching(e.kind())) {\n+            receiver.signalEvent(e.kind(),\n+                                 e.mContext().isPresent() ?\n+                                 Path.of(e.mContext().get()) : e.key().watchable().getFileName());\n+        } else if (e.kind().equals(AixWatchService.POLL_ERROR)) {\n+            implCancelKey(e.key());\n+            e.key().signal();\n+        }\n+\n+        \/\/ Clean up or create resources as required by key & event type.\n+        if (e.kind() == StandardWatchEventKinds.ENTRY_CREATE &&\n+            receiver.isWatching(StandardWatchEventKinds.ENTRY_MODIFY)) {\n+            String context = e.mContext().get();\n+            createSubKey(Path.of(receiver.watchable().toString(), context), receiver);\n+        } else if (e.kind() == StandardWatchEventKinds.ENTRY_DELETE &&\n+                   (e.key() instanceof AixWatchKey.SubKey)) {\n+            receiver.removeSubKey(e.key());\n+            implCancelKey(e.key());\n+        } else if (e.kind() == StandardWatchEventKinds.ENTRY_DELETE &&\n+                   (e.key() instanceof AixWatchKey.TopLevelKey)) {\n+            \/\/ 'Auto-Cancel' key and SubKeys if the directory that the TopLevelKey\n+            \/\/ is watching has been deleted. Detect this by checking whether the\n+            \/\/ event context (filename) matches the directory of the TopLevelKey\n+            if (Optional.of(e.key().watchable().getFileName().toString()).equals(e.mContext())) {\n+                implCancelKey(e.key());\n+            }\n+        }\n+    }\n+\n+    \/\/ Main poller loop\n+    @Override\n+    public void run()\n+    {\n+        while (!processRequests()) {\n+            int evcnt = 0;\n+\n+            try (NativeBuffer evbuf = new NativeBuffer(EVENT_BUFFER_SIZE)) {\n+                evcnt = nPoll(opaqueBuffer.address(), nfds[0], POLL_TIMEOUT, evbuf.address(), EVENT_BUFFER_SIZE);\n+                for (AixWatchService.PollEvent e: parsePollEvents(evbuf.address(), evcnt)) {\n+                    processPollEvent(e);\n+                }\n+            } catch (Throwable e) {\n+                \/\/ Warn, but don't stop processing events on error. Throwing here will stop all processing for\n+                \/\/ the poller.\n+                System.err.println(\"[AixWatchService] Caught exception in poll loop: \" + e);\n+                e.printStackTrace();\n+            }\n+        }\n+    }\n+\n+    private static native int nPollfdSize();\n+\n+    private static native void nInit(long buffer, int buff_size, int[] nv, int socketfd);\n+\n+    private static native void nCloseAll(long buffer, int nfds);\n+\n+    private static native void nSocketpair(int[] sv) throws UnixException;\n+\n+    private static native int nRegisterMonitorPath(long buffer, int nxt_fd, long pathv) throws UnixException;\n+\n+    private static native int nCancelWatchDescriptor(long buffer, int nfds, int wd);\n+\n+    private static native int nPoll(long buffer, int nfds, int timeout, long evbuf, int evbuf_size) throws UnixException;\n+\n+    static {\n+        jdk.internal.loader.BootLoader.loadLibrary(\"nio\");\n+    }\n+}\n","filename":"src\/java.base\/aix\/classes\/sun\/nio\/fs\/AhafsPoller.java","additions":602,"deletions":0,"binary":false,"changes":602,"status":"added"},{"patch":"@@ -49,1 +49,1 @@\n-        return new PollingWatchService();\n+        return new AixWatchService();\n","filename":"src\/java.base\/aix\/classes\/sun\/nio\/fs\/AixFileSystem.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,147 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, IBM Corp.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.nio.fs;\n+\n+import java.nio.file.*;\n+import java.util.*;\n+import java.io.IOException;\n+\n+import static sun.nio.fs.UnixConstants.*;\n+\n+\/**\n+ * AIX WatchKey Implementation\n+ *\/\n+public abstract class AixWatchKey extends AbstractWatchKey\n+{\n+    public static final int INVALID_WATCH_DESCRIPTOR = -1;\n+\n+    protected int watchDescriptor;\n+\n+    AixWatchKey(Path p, AbstractWatchService ws) { super(p, ws); }\n+\n+    public static class TopLevelKey extends AixWatchKey\n+    {\n+        private Set<AixWatchKey.SubKey> subKeys;\n+        private Set<WatchEvent.Kind<?>> watchEventKinds;\n+\n+        \/**\n+         * TopLevelKeys may contain SubKeys\n+         *\/\n+        public TopLevelKey(Path topLevelPath, int watchDescriptor, Set<? extends WatchEvent.Kind<?>> events, AixWatchService ws)\n+        {\n+            super(topLevelPath, ws);\n+            this.watchDescriptor = watchDescriptor;\n+            this.watchEventKinds = new HashSet<>(events);\n+            this.subKeys = new HashSet<>();\n+        }\n+\n+        public void replaceEvents(Set<? extends WatchEvent.Kind<?>> events)\n+        {\n+            this.watchEventKinds = new HashSet<>(events);\n+        }\n+\n+        public Iterable<AixWatchKey.SubKey> subKeys()\n+        {\n+            return Set.copyOf(subKeys);\n+        }\n+\n+        protected void addSubKeys(HashSet<AixWatchKey.SubKey> subKeys)\n+        {\n+            this.subKeys.addAll(subKeys);\n+        }\n+\n+        protected void removeSubKey(AixWatchKey key)\n+        {\n+            subKeys.remove(key);\n+        }\n+\n+        @Override\n+        protected TopLevelKey resolve()\n+        {\n+            return this;\n+        }\n+\n+        @Override\n+        public boolean isWatching(WatchEvent.Kind<?> kind)\n+        {\n+            return this.watchEventKinds.contains(kind) ||\n+                StandardWatchEventKinds.OVERFLOW.equals(kind);\n+        }\n+    }\n+\n+    public static class SubKey extends AixWatchKey\n+    {\n+        private TopLevelKey topLevelKey;\n+\n+        public SubKey(Path subKeyPath, int watchDescriptor, TopLevelKey topLevelKey)\n+        {\n+            super(subKeyPath, topLevelKey.watcher());\n+            this.watchDescriptor = watchDescriptor;\n+            this.topLevelKey = topLevelKey;\n+        }\n+\n+        @Override\n+        public TopLevelKey resolve()\n+        {\n+            return this.topLevelKey;\n+        }\n+\n+        @Override\n+        public boolean isWatching(WatchEvent.Kind<?> kind)\n+        {\n+            return topLevelKey.isWatching(kind);\n+        }\n+    }\n+\n+    protected abstract TopLevelKey resolve();\n+\n+    public abstract boolean isWatching(WatchEvent.Kind<?> kind);\n+\n+    public int watchDescriptor() { return Math.abs(this.watchDescriptor); }\n+\n+    @Override\n+    public boolean isValid()\n+    {\n+        return this.watchDescriptor > 0;\n+    }\n+\n+    public void invalidate()\n+    {\n+        this.watchDescriptor = -this.watchDescriptor;\n+    }\n+\n+    @Override\n+    public void cancel()\n+    {\n+        if (isValid()) {\n+            ((AixWatchService)watcher()).poller.cancel(this);\n+            invalidate();\n+        }\n+    }\n+\n+\n+}\n","filename":"src\/java.base\/aix\/classes\/sun\/nio\/fs\/AixWatchKey.java","additions":147,"deletions":0,"binary":false,"changes":147,"status":"added"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, IBM Corp.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.nio.fs;\n+\n+import java.nio.file.*;\n+import java.util.*;\n+import java.io.IOException;\n+import jdk.internal.misc.Unsafe;\n+\n+import static sun.nio.fs.UnixNativeDispatcher.*;\n+import static sun.nio.fs.UnixConstants.*;\n+\n+\/**\n+ * AIX WatchService Implementation\n+ *\/\n+public class AixWatchService extends AbstractWatchService\n+{\n+    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+    Map<Path,AixWatchKey> registeredKeys;\n+    AhafsPoller poller;\n+\n+    public static record PollEvent(AixWatchKey key, WatchEvent.Kind<?> kind, Optional<String> mContext) {}\n+    public static final WatchEvent.Kind<Path> POLL_ERROR = new WatchEvent.Kind<>() {\n+        @Override public String name() { return \"POLL_ERROR\"; }\n+        @Override public Class<Path> type() { return Path.class; }\n+        @Override public String toString() { return this.name(); }\n+    };\n+\n+    public static class FatalException extends Exception\n+    {\n+        private static final long serialVersionUID = 1L;\n+        FatalException(String msg) { super(msg); }\n+        FatalException(String msg, Throwable e) { super(msg, e); }\n+    }\n+\n+    public AixWatchService()\n+        throws IOException\n+    {\n+        super();\n+        this.registeredKeys = new HashMap<>();\n+        try {\n+            this.poller = new AhafsPoller(this);\n+            this.poller.start();\n+        } catch (FatalException e) {\n+            \/\/ Re-Throw as IOE so the exception conforms to the expected type\n+            throw new IOException(e);\n+        }\n+    }\n+\n+    @Override\n+    WatchKey register(Path dir,\n+                      WatchEvent.Kind<?>[] events,\n+                      WatchEvent.Modifier... modifiers)\n+         throws IOException\n+    {\n+        \/\/ If path is already registered with this WatchService, re-register existing key.\n+        if (registeredKeys.containsKey(dir)) {\n+            AixWatchKey existingKey = registeredKeys.get(dir);\n+            if (existingKey.isValid()) {\n+                try {\n+                    return poller.reRegister(existingKey,\n+                                             new HashSet<>(Arrays.asList(events)),\n+                                             modifiers);\n+                } catch (AixWatchService.FatalException e) {\n+                    throw new IOException(e);\n+                }\n+            } else {\n+                registeredKeys.remove(existingKey);\n+            }\n+        }\n+\n+        \/\/ O.W. create and register new key\n+        AixWatchKey key = (AixWatchKey)poller.register(dir, events, modifiers);\n+        registeredKeys.put(dir, key);\n+        return key;\n+    }\n+\n+    @Override\n+    void implClose() throws IOException\n+    { poller.close(); }\n+\n+ }\n","filename":"src\/java.base\/aix\/classes\/sun\/nio\/fs\/AixWatchService.java","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -0,0 +1,202 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, IBM Corp.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jni.h\"\n+#include \"jni_util.h\"\n+#include \"jvm.h\"\n+#include \"jlong.h\"\n+\n+#include <errno.h>\n+#include <stdlib.h>\n+#include <sys\/types.h>\n+#include <sys\/socket.h>\n+#include <poll.h>\n+#include <string.h>\n+#include <sys\/ahafs_evProds.h>\n+\n+#include \"sun_nio_fs_AhafsPoller.h\"\n+\n+#define INVALID_WD -1\n+#define EVENT_BUFFER_SIZE 2048 \/\/ Change in sync with below 'BUF_SIZE' parameter\n+#define AHA_INIT_STR \"CHANGED=YES WAIT_TYPE=WAIT_IN_SELECT BUF_SIZE=2048\"\n+#define SIZEOF_AHA_INIT_STR sizeof(AHA_INIT_STR)\n+\n+static void throwUnixException(JNIEnv* env, int errnum) {\n+    jobject x = JNU_NewObjectByName(env, \"sun\/nio\/fs\/UnixException\",\n+        \"(I)V\", errnum);\n+    if (x != NULL) {\n+        (*env)->Throw(env, x);\n+    }\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_fs_AhafsPoller_nPollfdSize(JNIEnv *env, jclass clazz)\n+{\n+    return (jint)sizeof(struct pollfd);\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_sun_nio_fs_AhafsPoller_nInit(JNIEnv* env, jclass clazz, jlong buf, jint buf_size, jintArray nv, jint socketfd)\n+{\n+    struct pollfd* fds = (struct pollfd*)jlong_to_ptr(buf);\n+\n+    memset(fds, 0, buf_size);\n+    fds[0].fd = (int)socketfd;\n+    fds[0].events = POLLIN;\n+\n+    int nfds[] = { 1 };\n+\n+    (*env)->SetIntArrayRegion(env, nv, 0, 1, &nfds[0]);\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_sun_nio_fs_AhafsPoller_nCloseAll(JNIEnv* env, jclass clazz, jlong buf, jint nfds)\n+{\n+    struct pollfd* fds = (struct pollfd*)jlong_to_ptr(buf);\n+\n+    \/\/ First fd is assumed to be the socketpair, which will be cancelled\n+    \/\/ in Java. Skip it here.\n+    for (struct pollfd* pfd = fds+1; pfd <= fds + nfds; pfd++) {\n+        close(pfd->fd);\n+        pfd->events  = 0;\n+        pfd->revents = 0;\n+        pfd->fd = INVALID_WD;\n+    }\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_sun_nio_fs_AhafsPoller_nSocketpair\n+    (JNIEnv* env, jclass clazz, jintArray sv)\n+{\n+    int sp[2];\n+    if (socketpair(PF_UNIX, SOCK_STREAM, 0, sp) == -1) {\n+        perror(\"Socketpair error\");\n+        throwUnixException(env, errno);\n+    } else {\n+        jint res[2];\n+        res[0] = (jint)sp[0];\n+        res[1] = (jint)sp[1];\n+        (*env)->SetIntArrayRegion(env, sv, 0, 2, &res[0]);\n+    }\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_fs_AhafsPoller_nRegisterMonitorPath\n+    (JNIEnv* env, jclass clazz, jlong buf, jint nxt_fd, jlong pathv)\n+{\n+    struct pollfd* fds = (struct pollfd*)jlong_to_ptr(buf);\n+    char* path = (char*)jlong_to_ptr(pathv);\n+\n+    int fd = open(path, O_CREAT | O_RDWR);\n+    if (fd < 0) {\n+        fprintf(stderr,\"[nRegisterMonitorPath] Fd invalid (%d) while opening %s\\n\", fd, path);\n+        perror(\"Open error\");\n+        throwUnixException(env, errno);\n+        return INVALID_WD;\n+    }\n+    \/\/ Write AIX Event Infrastructure monitor args\n+    int wlen = write(fd, AHA_INIT_STR, SIZEOF_AHA_INIT_STR);\n+    if (wlen <= 0) {\n+        perror(\"Write error\");\n+        throwUnixException(env, errno);\n+        return INVALID_WD;\n+    }\n+\n+    fds[nxt_fd].fd = fd;\n+    fds[nxt_fd].events = POLLIN; \/\/ TODO: Are other event types important?\n+\n+    return (jint)fd;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_fs_AhafsPoller_nCancelWatchDescriptor\n+    (JNIEnv* env, jclass clazz, jlong buf, jint nfds, jint wd)\n+{\n+    struct pollfd* fds = (struct pollfd*)jlong_to_ptr(buf);\n+\n+    for (struct pollfd* pfd = fds; pfd != fds + nfds; pfd += 1) {\n+        if (pfd->fd == wd) {\n+            if (close(pfd->fd) != 0) {\n+                perror(\"Close error\");\n+                fprintf(stderr,\"[nCancelWatchDescriptor] Close returned error while closing %d\\n\", wd);\n+                throwUnixException(env, errno);\n+                break;\n+            }\n+            pfd->fd = INVALID_WD;\n+            pfd->events  = 0;\n+            pfd->revents = 0;\n+            return wd;\n+        }\n+    }\n+\n+    return (jint)INVALID_WD;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_fs_AhafsPoller_nPoll\n+    (JNIEnv* env, jclass clazz, jlong fdsv, jint nfds, jint timeout, jlong evbufv, jint evbuf_size)\n+{\n+    char tmpbuf[evbuf_size];\n+    int evcnt;\n+    struct pollfd* fds = (struct pollfd*)jlong_to_ptr(fdsv);\n+    char*        evbuf = (char*)jlong_to_ptr(evbufv);\n+\n+    \/\/ Poll for changes\n+    if ((evcnt = poll(fds, nfds, timeout)) < 0) {\n+        perror(\"Poll error\");\n+        throwUnixException(env, errno);\n+        return (jint) evcnt;\n+    }\n+\n+    \/\/ The first fd in fds is assumed to be the socketpair. Detect\n+    \/\/ when the event count has included a wakeup event and remove it here.\n+    if (fds->revents != 0) {\n+        fds->revents = 0;\n+        evcnt--;\n+    }\n+\n+    \/\/ Iterate over fds (skipping the socketpair)\n+    for (struct pollfd* pfd = fds+1; pfd != fds + nfds; pfd += 1) {\n+        if (pfd->revents & POLLIN) {\n+            int rlen;\n+            if ((rlen = read(pfd->fd, tmpbuf, evbuf_size)) >= 0) {\n+                tmpbuf[rlen] = (char)NULL;\n+                \/\/ Wrap and write event data to provided buffer\n+                sprintf(evbuf, \"BEGIN_WD=%d\\n%sEND_WD=%d\\n\", pfd->fd, tmpbuf, pfd->fd);\n+            } else {\n+                perror(\"Read error\");\n+                fprintf(stderr,\"[nPoll] Read returned error while reading fd: %d. Got %s\\n\", pfd->fd, tmpbuf);\n+                throwUnixException(env, errno);\n+                break;\n+            }\n+\n+            \/\/ strip revent data to prevent re-read of an old update.\n+            pfd->revents = 0;\n+        }\n+    }\n+\n+    return (jint) evcnt;\n+}\n","filename":"src\/java.base\/aix\/native\/libnio\/fs\/AhafsPoller.c","additions":202,"deletions":0,"binary":false,"changes":202,"status":"added"}]}