{"files":[{"patch":"@@ -708,0 +708,1 @@\n+  assert(SafepointSynchronize::is_a_block_safe_state(state), \"Illegal threadstate encountered: %d\", state);\n@@ -711,10 +712,0 @@\n-  \/\/ Check that we have a valid thread_state at this point\n-  switch(state) {\n-    case _thread_in_vm_trans:\n-    case _thread_in_Java:        \/\/ From compiled code\n-    case _thread_in_native_trans:\n-    case _thread_blocked_trans:\n-    case _thread_new_trans:\n-\n-      \/\/ We have no idea where the VMThread is, it might even be at next safepoint.\n-      \/\/ So we can miss this poll, but stop at next.\n@@ -722,2 +713,2 @@\n-      \/\/ Load dependent store, it must not pass loading of safepoint_id.\n-      thread->safepoint_state()->set_safepoint_id(safepoint_id); \/\/ Release store\n+  \/\/ We have no idea where the VMThread is, it might even be at next safepoint.\n+  \/\/ So we can miss this poll, but stop at next.\n@@ -725,4 +716,2 @@\n-      \/\/ This part we can skip if we notice we miss or are in a future safepoint.\n-      OrderAccess::storestore();\n-      \/\/ Load in wait barrier should not float up\n-      thread->set_thread_state_fence(_thread_blocked);\n+  \/\/ Load dependent store, it must not pass loading of safepoint_id.\n+  thread->safepoint_state()->set_safepoint_id(safepoint_id); \/\/ Release store\n@@ -730,2 +719,4 @@\n-      _wait_barrier->wait(static_cast<int>(safepoint_id));\n-      assert(_state != _synchronized, \"Can't be\");\n+  \/\/ This part we can skip if we notice we miss or are in a future safepoint.\n+  OrderAccess::storestore();\n+  \/\/ Load in wait barrier should not float up\n+  thread->set_thread_state_fence(_thread_blocked);\n@@ -733,3 +724,2 @@\n-      \/\/ If barrier is disarmed stop store from floating above loads in barrier.\n-      OrderAccess::loadstore();\n-      thread->set_thread_state(state);\n+  _wait_barrier->wait(static_cast<int>(safepoint_id));\n+  assert(_state != _synchronized, \"Can't be\");\n@@ -737,2 +727,3 @@\n-      \/\/ Then we reset the safepoint id to inactive.\n-      thread->safepoint_state()->reset_safepoint_id(); \/\/ Release store\n+  \/\/ If barrier is disarmed stop store from floating above loads in barrier.\n+  OrderAccess::loadstore();\n+  thread->set_thread_state(state);\n@@ -740,1 +731,2 @@\n-      OrderAccess::fence();\n+  \/\/ Then we reset the safepoint id to inactive.\n+  thread->safepoint_state()->reset_safepoint_id(); \/\/ Release store\n@@ -742,1 +734,1 @@\n-      break;\n+  OrderAccess::fence();\n@@ -744,3 +736,0 @@\n-    default:\n-     fatal(\"Illegal threadstate encountered: %d\", state);\n-  }\n","filename":"src\/hotspot\/share\/runtime\/safepoint.cpp","additions":17,"deletions":28,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -129,0 +129,13 @@\n+  static bool is_a_block_safe_state(JavaThreadState state) {\n+    \/\/ Check that we have a valid thread_state before blocking for safepoints\n+    switch(state) {\n+      case _thread_in_vm_trans:\n+      case _thread_in_Java:        \/\/ From compiled code\n+      case _thread_in_native_trans:\n+      case _thread_blocked_trans:\n+      case _thread_new_trans:\n+        return true;\n+      default:\n+        return false;\n+    }\n+  }\n","filename":"src\/hotspot\/share\/runtime\/safepoint.hpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -121,0 +121,2 @@\n+    JavaThreadState state = thread->thread_state();\n+    guarantee(SafepointSynchronize::is_a_block_safe_state(state), \"Illegal threadstate encountered: %d\", state);\n","filename":"src\/hotspot\/share\/runtime\/safepointMechanism.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}