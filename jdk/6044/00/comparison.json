{"files":[{"patch":"@@ -1894,1 +1894,14 @@\n-C2V_VMENTRY_NULL(jobject, readFieldValue, (JNIEnv* env, jobject, jobject object, jobject expected_type, long displacement, jboolean is_volatile, jobject kind_object))\n+\/\/ Enforces volatile semantics for a non-volatile read.\n+class VolatileRead : public StackObj {\n+ public:\n+  VolatileRead() {\n+    \/\/ Ensures a possibly volatile read is not reordered with a prior\n+    \/\/ volatile write.\n+    OrderAccess::storeload();\n+  }\n+  ~VolatileRead() {\n+    OrderAccess::acquire();\n+  }\n+};\n+\n+C2V_VMENTRY_NULL(jobject, readFieldValue, (JNIEnv* env, jobject, jobject object, jobject expected_type, long displacement, jobject kind_object))\n@@ -1978,0 +1991,10 @@\n+\n+  \/\/ Treat all reads as volatile for simplicity as this function can be used\n+  \/\/ both for reading Java fields declared as volatile as well as for constant\n+  \/\/ folding Unsafe.get* methods with volatile semantics. This is done by\n+  \/\/ performing the volatile barrier operations around a call to an\n+  \/\/ oopDesc::<kind>_field method. The oopDesc::<kind>_field_acquire method\n+  \/\/ cannot be used since it does not support unaligned reads on all platforms\n+  \/\/ (e.g., an unaligned ldar on AArch64 causes a SIGBUS).\n+\n+\n@@ -1979,4 +2002,4 @@\n-    case T_BOOLEAN: value = is_volatile ? obj->bool_field_acquire(displacement)   : obj->bool_field(displacement);  break;\n-    case T_BYTE:    value = is_volatile ? obj->byte_field_acquire(displacement)   : obj->byte_field(displacement);  break;\n-    case T_SHORT:   value = is_volatile ? obj->short_field_acquire(displacement)  : obj->short_field(displacement); break;\n-    case T_CHAR:    value = is_volatile ? obj->char_field_acquire(displacement)   : obj->char_field(displacement);  break;\n+    case T_BOOLEAN: { VolatileRead vr; value = obj->bool_field(displacement); } break;\n+    case T_BYTE:    { VolatileRead vr; value = obj->byte_field(displacement); } break;\n+    case T_SHORT:   { VolatileRead vr; value = obj->short_field(displacement);} break;\n+    case T_CHAR:    { VolatileRead vr; value = obj->char_field(displacement); } break;\n@@ -1984,1 +2007,1 @@\n-    case T_INT:     value = is_volatile ? obj->int_field_acquire(displacement)    : obj->int_field(displacement);   break;\n+    case T_INT:     { VolatileRead vr; value = obj->int_field(displacement);  } break;\n@@ -1986,1 +2009,1 @@\n-    case T_LONG:    value = is_volatile ? obj->long_field_acquire(displacement)   : obj->long_field(displacement);  break;\n+    case T_LONG:    { VolatileRead vr; value = obj->long_field(displacement); } break;\n@@ -1996,1 +2019,3 @@\n-      oop value = is_volatile ? obj->obj_field_acquire(displacement) : obj->obj_field(displacement);\n+      oop value;\n+      { VolatileRead vr; value = obj->obj_field(displacement); }\n+\n@@ -2785,2 +2810,2 @@\n-  {CC \"readFieldValue\",                               CC \"(\" HS_RESOLVED_KLASS HS_RESOLVED_KLASS \"JZLjdk\/vm\/ci\/meta\/JavaKind;)\" JAVACONSTANT, FN_PTR(readFieldValue)},\n-  {CC \"readFieldValue\",                               CC \"(\" OBJECTCONSTANT HS_RESOLVED_KLASS \"JZLjdk\/vm\/ci\/meta\/JavaKind;)\" JAVACONSTANT,  FN_PTR(readFieldValue)},\n+  {CC \"readFieldValue\",                               CC \"(\" HS_RESOLVED_KLASS HS_RESOLVED_KLASS \"JLjdk\/vm\/ci\/meta\/JavaKind;)\" JAVACONSTANT, FN_PTR(readFieldValue)},\n+  {CC \"readFieldValue\",                               CC \"(\" OBJECTCONSTANT HS_RESOLVED_KLASS \"JLjdk\/vm\/ci\/meta\/JavaKind;)\" JAVACONSTANT,   FN_PTR(readFieldValue)},\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":35,"deletions":10,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -789,1 +789,1 @@\n-    native JavaConstant readFieldValue(HotSpotResolvedObjectTypeImpl object, HotSpotResolvedObjectTypeImpl expectedType, long offset, boolean isVolatile, JavaKind kind);\n+    native JavaConstant readFieldValue(HotSpotResolvedObjectTypeImpl object, HotSpotResolvedObjectTypeImpl expectedType, long offset, JavaKind kind);\n@@ -796,1 +796,1 @@\n-    native JavaConstant readFieldValue(HotSpotObjectConstantImpl object, HotSpotResolvedObjectTypeImpl expectedType, long offset, boolean isVolatile, JavaKind kind);\n+    native JavaConstant readFieldValue(HotSpotObjectConstantImpl object, HotSpotResolvedObjectTypeImpl expectedType, long offset, JavaKind kind);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/CompilerToVM.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -169,1 +169,1 @@\n-                return runtime().compilerToVm.readFieldValue(holder, (HotSpotResolvedObjectTypeImpl) hotspotField.getDeclaringClass(), hotspotField.getOffset(), field.isVolatile(),\n+                return runtime().compilerToVm.readFieldValue(holder, (HotSpotResolvedObjectTypeImpl) hotspotField.getDeclaringClass(), hotspotField.getOffset(),\n@@ -173,1 +173,1 @@\n-            return ((HotSpotObjectConstantImpl) receiver).readFieldValue(hotspotField, field.isVolatile());\n+            return ((HotSpotObjectConstantImpl) receiver).readFieldValue(hotspotField);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotConstantReflectionProvider.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -80,1 +80,2 @@\n-            JavaConstant result = runtime().compilerToVm.readFieldValue((HotSpotObjectConstantImpl) baseConstant, null, initialDisplacement, true, readKind);\n+            HotSpotObjectConstantImpl baseObject = (HotSpotObjectConstantImpl) baseConstant;\n+            JavaConstant result = runtime().compilerToVm.readFieldValue(baseObject, null, initialDisplacement, readKind);\n@@ -111,1 +112,1 @@\n-            return runtime.getCompilerToVM().readFieldValue((HotSpotObjectConstantImpl) base, null, displacement, true, JavaKind.Object);\n+            return runtime.getCompilerToVM().readFieldValue((HotSpotObjectConstantImpl) base, null, displacement, JavaKind.Object);\n@@ -133,1 +134,1 @@\n-            JavaConstant res = runtime.getCompilerToVM().readFieldValue((HotSpotObjectConstantImpl) base, null, displacement, true, JavaKind.Object);\n+            JavaConstant res = runtime.getCompilerToVM().readFieldValue((HotSpotObjectConstantImpl) base, null, displacement, JavaKind.Object);\n@@ -150,1 +151,0 @@\n-\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotMemoryAccessProviderImpl.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-        boolean isFrozen = readFieldValue(field, true \/* volatile *\/).asBoolean();\n+        boolean isFrozen = readFieldValue(field).asBoolean();\n@@ -83,1 +83,1 @@\n-        return (HotSpotObjectConstantImpl) readFieldValue(field, true \/* volatile *\/);\n+        return (HotSpotObjectConstantImpl) readFieldValue(field);\n@@ -187,1 +187,1 @@\n-    public JavaConstant readFieldValue(HotSpotResolvedJavaField field, boolean isVolatile) {\n+    public JavaConstant readFieldValue(HotSpotResolvedJavaField field) {\n@@ -196,1 +196,1 @@\n-        return runtime().compilerToVm.readFieldValue(this, (HotSpotResolvedObjectTypeImpl) field.getDeclaringClass(), field.getOffset(), isVolatile, field.getType().getJavaKind());\n+        return runtime().compilerToVm.readFieldValue(this, (HotSpotResolvedObjectTypeImpl) field.getDeclaringClass(), field.getOffset(), field.getType().getJavaKind());\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotObjectConstantImpl.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -80,0 +80,3 @@\n+            if (k.unalignedInstanceFieldValue != null) {\n+                result.add(new Object[] {k.kind, TEST_CONSTANT, k.instanceFieldOffset - 1, k.unalignedInstanceFieldValue, Math.max(8, k.kind.getBitCount())});\n+            }\n@@ -173,0 +176,1 @@\n+        final JavaConstant unalignedInstanceFieldValue;\n@@ -185,0 +189,11 @@\n+                if (kind == JavaKind.Long) {\n+                    unalignedInstanceFieldValue = JavaConstant.forLong(UNSAFE.getLongUnaligned(testObject, instanceFieldOffset - 1));\n+                } else if (kind == JavaKind.Int) {\n+                    unalignedInstanceFieldValue = JavaConstant.forInt(UNSAFE.getIntUnaligned(testObject, instanceFieldOffset - 1));\n+                } else if (kind == JavaKind.Char) {\n+                    unalignedInstanceFieldValue = JavaConstant.forChar(UNSAFE.getCharUnaligned(testObject, instanceFieldOffset - 1));\n+                } else if (kind == JavaKind.Short) {\n+                    unalignedInstanceFieldValue = JavaConstant.forShort(UNSAFE.getShortUnaligned(testObject, instanceFieldOffset - 1));\n+                } else {\n+                    unalignedInstanceFieldValue = null;\n+                }\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.hotspot.test\/src\/jdk\/vm\/ci\/hotspot\/test\/MemoryAccessProviderData.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"}]}