{"files":[{"patch":"@@ -34,1 +34,0 @@\n-  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXExec, thread));\n@@ -36,0 +35,4 @@\n+  \/\/ We need WXExec because we are about to call a generated stub. Like in VM\n+  \/\/ entries, the thread state should be changed while we are still in WXWrite.\n+  \/\/ See JDK-8265292.\n+  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXExec, thread));\n","filename":"src\/hotspot\/share\/prims\/universalNativeInvoker.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -293,0 +293,8 @@\n+\/\/ On macos\/aarch64 we need to maintain the W^X state of the thread.  So we\n+\/\/ take WXWrite on the enter to VM from the \"outside\" world, so the rest of JVM\n+\/\/ code can assume writing (but not executing) codecache is always possible\n+\/\/ without preliminary actions.\n+\/\/ JavaThread state should be changed only after taking WXWrite. The state\n+\/\/ change may trigger a safepoint, that would need WXWrite to do bookkeeping\n+\/\/ in the codecache.\n+\n","filename":"src\/hotspot\/share\/runtime\/interfaceSupport.inline.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -547,3 +547,0 @@\n-java\/foreign\/TestDowncall.java 8265292 macosx-aarch64\n-java\/foreign\/TestIntrinsics.java 8265183 macosx-aarch64\n-java\/foreign\/TestUpcall.java 8265182 macosx-aarch64\n","filename":"test\/jdk\/ProblemList.txt","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"}]}