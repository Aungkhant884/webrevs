{"files":[{"patch":"@@ -38,4 +38,0 @@\n-bool EdgeUtils::is_leak_edge(const Edge& edge) {\n-  return (const Edge*)edge.pointee()->mark().to_pointer() == &edge;\n-}\n-\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/edgeUtils.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-  static bool is_leak_edge(const Edge& edge);\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/edgeUtils.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,112 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"classfile\/classLoaderDataGraph.hpp\"\n-#include \"jfr\/leakprofiler\/utilities\/saveRestore.hpp\"\n-#include \"oops\/oop.inline.hpp\"\n-\n-MarkWordContext::MarkWordContext() : _obj(NULL), _mark_word(markWord::zero()) {}\n-\n-MarkWordContext::MarkWordContext(const oop obj) : _obj(obj), _mark_word(obj->mark()) {\n-  assert(_obj->mark() == _mark_word, \"invariant\");\n-  \/\/ now we will \"poison\" the mark word of the object\n-  \/\/ to the intermediate monitor INFLATING state.\n-  \/\/ This is an \"impossible\" state during a safepoint,\n-  \/\/ hence we will use it to quickly identify objects\n-  \/\/ during the reachability search from gc roots.\n-  assert(markWord::zero() == markWord::INFLATING(), \"invariant\");\n-  _obj->set_mark(markWord::INFLATING());\n-  assert(markWord::zero() == obj->mark(), \"invariant\");\n-}\n-\n-MarkWordContext::~MarkWordContext() {\n-  if (_obj != NULL) {\n-    _obj->set_mark(_mark_word);\n-    assert(_obj->mark() == _mark_word, \"invariant\");\n-  }\n-}\n-\n-MarkWordContext::MarkWordContext(const MarkWordContext& rhs) : _obj(NULL), _mark_word(markWord::zero()) {\n-  swap(const_cast<MarkWordContext&>(rhs));\n-}\n-\n-void MarkWordContext::operator=(MarkWordContext rhs) {\n-  swap(rhs);\n-}\n-\n-void MarkWordContext::swap(MarkWordContext& rhs) {\n-  oop temp_obj = rhs._obj;\n-  markWord temp_mark_word = rhs._mark_word;\n-  rhs._obj = _obj;\n-  rhs._mark_word = _mark_word;\n-  _obj = temp_obj;\n-  _mark_word = temp_mark_word;\n-}\n-\n-CLDClaimContext::CLDClaimContext() : _cld(NULL) {}\n-\n-CLDClaimContext::CLDClaimContext(ClassLoaderData* cld) : _cld(cld) {\n-  assert(_cld->claimed(), \"invariant\");\n-  _cld->clear_claim();\n-}\n-\n-CLDClaimContext::~CLDClaimContext() {\n-  if (_cld != NULL) {\n-    _cld->try_claim(ClassLoaderData::_claim_strong);\n-    assert(_cld->claimed(), \"invariant\");\n-  }\n-}\n-\n-CLDClaimContext::CLDClaimContext(const CLDClaimContext& rhs) : _cld(NULL) {\n-  swap(const_cast<CLDClaimContext&>(rhs));\n-}\n-\n-void CLDClaimContext::operator=(CLDClaimContext rhs) {\n-  swap(rhs);\n-}\n-\n-void CLDClaimContext::swap(CLDClaimContext& rhs) {\n-  ClassLoaderData* temp_cld = rhs._cld;\n-  rhs._cld = _cld;\n-  _cld = temp_cld;\n-}\n-\n-CLDClaimStateClosure::CLDClaimStateClosure() : CLDClosure(), _state() {}\n-\n-void CLDClaimStateClosure::do_cld(ClassLoaderData* cld) {\n-  assert(cld != NULL, \"invariant\");\n-  if (cld->claimed()) {\n-    _state.save(cld);\n-  }\n-}\n-\n-SaveRestoreCLDClaimBits::SaveRestoreCLDClaimBits() : _claim_state_closure() {\n-  \/\/ interferes with GC, so walk all oops that GC would.\n-  ClassLoaderDataGraph::cld_do(&_claim_state_closure);\n-}\n-\n-SaveRestoreCLDClaimBits::~SaveRestoreCLDClaimBits() {\n-  ClassLoaderDataGraph::clear_claimed_marks();\n-}\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/utilities\/saveRestore.cpp","additions":0,"deletions":112,"binary":false,"changes":112,"status":"deleted"},{"patch":"@@ -1,128 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_JFR_LEAKPROFILER_UTILITIES_SAVERESTORE_HPP\n-#define SHARE_JFR_LEAKPROFILER_UTILITIES_SAVERESTORE_HPP\n-\n-#include \"memory\/allocation.hpp\"\n-#include \"memory\/iterator.hpp\"\n-#include \"oops\/markWord.hpp\"\n-#include \"utilities\/growableArray.hpp\"\n-\n-template <typename T, typename Impl>\n-class SaveRestore {\n- private:\n-  Impl _impl;\n- public:\n-  SaveRestore() : _impl() {\n-    _impl.setup();\n-  }\n-\n-  void save(T const& value) {\n-    _impl.save(value);\n-  }\n-\n-  ~SaveRestore() {\n-    _impl.restore();\n-  }\n-};\n-\n-template <typename T, typename Context>\n-class ContextStore {\n-private:\n-  GrowableArray<Context>* _storage;\n-public:\n-  ContextStore() : _storage(NULL) {}\n-\n-  void setup() {\n-    assert(_storage == NULL, \"invariant\");\n-    _storage = new GrowableArray<Context>(16);\n-  }\n-\n-  void save(T const& value) {\n-    _storage->push(Context(value));\n-  }\n-\n-  void restore() {\n-    for (int i = 0; i < _storage->length(); ++i) {\n-      _storage->at(i).~Context();\n-    }\n-  }\n-};\n-\n-\/*\n-* This class will save the original mark oop of an object sample object.\n-* It will then install an \"identifier\" mark oop to be used for\n-* identification purposes in the search for reference chains.\n-* The destructor will restore the original mark oop.\n-*\/\n-\n-class MarkWordContext {\n- private:\n-  oop _obj;\n-  markWord _mark_word;\n-  void swap(MarkWordContext& rhs);\n- public:\n-  MarkWordContext();\n-  MarkWordContext(const oop obj);\n-  MarkWordContext(const MarkWordContext& rhs);\n-  void operator=(MarkWordContext rhs);\n-  ~MarkWordContext();\n-};\n-\n-typedef SaveRestore<oop, ContextStore<oop, MarkWordContext> > SaveRestoreMarkWords;\n-\n-class ClassLoaderData;\n-\n-class CLDClaimContext {\n- private:\n-  ClassLoaderData* _cld;\n-  void swap(CLDClaimContext& rhs);\n- public:\n-  CLDClaimContext();\n-  CLDClaimContext(ClassLoaderData* cld);\n-  CLDClaimContext(const CLDClaimContext& rhs);\n-  void operator=(CLDClaimContext rhs);\n-  ~CLDClaimContext();\n-};\n-\n-typedef SaveRestore<ClassLoaderData*, ContextStore<ClassLoaderData*, CLDClaimContext> > SaveRestoreCLDClaimState;\n-\n-class CLDClaimStateClosure : public CLDClosure {\n- private:\n-  SaveRestoreCLDClaimState _state;\n- public:\n-  CLDClaimStateClosure();\n-  void do_cld(ClassLoaderData* cld);\n-};\n-\n-class SaveRestoreCLDClaimBits : public StackObj {\n- private:\n-  CLDClaimStateClosure _claim_state_closure;\n- public:\n-  SaveRestoreCLDClaimBits();\n-  ~SaveRestoreCLDClaimBits();\n-};\n-\n-#endif \/\/ SHARE_JFR_LEAKPROFILER_UTILITIES_SAVERESTORE_HPP\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/utilities\/saveRestore.hpp","additions":0,"deletions":128,"binary":false,"changes":128,"status":"deleted"}]}