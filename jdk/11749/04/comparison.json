{"files":[{"patch":"@@ -45,0 +45,2 @@\n+#define __ masm.\n+\n@@ -52,1 +54,0 @@\n-  bool p_succeeded = true;\n@@ -54,10 +55,1 @@\n-    masm.set_code_section(cb->stubs());\n-    if (!is_aligned(masm.offset(), wordSize)) {\n-      if (cb->stubs()->maybe_expand_to_ensure_remaining(NativeInstruction::instruction_size) && cb->blob() == NULL) {\n-        ciEnv::current()->record_failure(\"CodeCache is full\");\n-        p_succeeded = false;\n-        return p_succeeded;\n-      }\n-      masm.align(wordSize);\n-    }\n-\n+    assert(cb->stubs()->remaining() >= MacroAssembler::max_trampoline_stub_size(), \"pre-allocated trampolines\");\n@@ -66,4 +58,2 @@\n-    for (; !it.is_empty(); offset = *it.next()) {\n-      masm.relocate(trampoline_stub_Relocation::spec(cb->insts()->start() + offset));\n-    }\n-    masm.set_code_section(cb->insts());\n+    address stub = __ emit_trampoline_stub(offset, dest);\n+    assert(stub, \"pre-allocated trampolines\");\n@@ -71,4 +61,5 @@\n-    address stub = masm.emit_trampoline_stub(offset, dest);\n-    if (stub == nullptr) {\n-      ciEnv::current()->record_failure(\"CodeCache is full\");\n-      p_succeeded = false;\n+    address reloc_pc = cb->stubs()->end() - NativeCallTrampolineStub::instruction_size;\n+    while (!it.is_empty()) {\n+      offset = *it.next();\n+      address caller_pc = cb->insts()->start() + offset;\n+      cb->stubs()->relocate(reloc_pc, trampoline_stub_Relocation::spec(caller_pc));\n@@ -76,2 +67,1 @@\n-\n-    return p_succeeded;\n+    return true;\n@@ -80,1 +70,6 @@\n-  requests->iterate(emit);\n+  assert(requests->number_of_entries() >= 1, \"at least one\");\n+  const int total_requested_size = MacroAssembler::max_trampoline_stub_size() * requests->number_of_entries();\n+  if (cb->stubs()->maybe_expand_to_ensure_remaining(total_requested_size) && cb->blob() == NULL) {\n+    ciEnv::current()->record_failure(\"CodeCache is full\");\n+    return false;\n+  }\n@@ -82,1 +77,2 @@\n-  return p_succeeded;\n+  requests->iterate(emit);\n+  return true;\n@@ -85,0 +81,2 @@\n+#undef __\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/codeBuffer_aarch64.cpp","additions":21,"deletions":23,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,2 +74,1 @@\n-  \/\/ isb; movk; movz; movz; movk; movz; movz; br\n-  return 8 * NativeInstruction::instruction_size;\n+  return MacroAssembler::static_call_stub_size();\n@@ -82,1 +81,1 @@\n-  return 3 * NativeInstruction::instruction_size + wordSize;\n+  return MacroAssembler::max_trampoline_stub_size();\n","filename":"src\/hotspot\/cpu\/aarch64\/compiledIC_aarch64.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -929,2 +929,1 @@\n-  address stub = start_a_stub(NativeInstruction::instruction_size\n-                   + NativeCallTrampolineStub::instruction_size);\n+  address stub = start_a_stub(max_trampoline_stub_size());\n@@ -962,0 +961,5 @@\n+int MacroAssembler::max_trampoline_stub_size() {\n+  \/\/ Max stub size: alignment nop, TrampolineStub.\n+  return NativeInstruction::instruction_size + NativeCallTrampolineStub::instruction_size;\n+}\n+\n@@ -974,0 +978,5 @@\n+int MacroAssembler::static_call_stub_size() {\n+  \/\/ isb; movk; movz; movz; movk; movz; movz; br\n+  return 8 * NativeInstruction::instruction_size;\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -641,0 +641,1 @@\n+  static int max_trampoline_stub_size();\n@@ -642,0 +643,1 @@\n+  static int static_call_stub_size();\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,0 +47,2 @@\n+#define __ masm.\n+\n@@ -54,1 +56,0 @@\n-  bool p_succeeded = true;\n@@ -56,10 +57,1 @@\n-    masm.set_code_section(cb->stubs());\n-    if (!is_aligned(masm.offset() + NativeCallTrampolineStub::data_offset, wordSize)) {\n-      if (cb->stubs()->maybe_expand_to_ensure_remaining(NativeInstruction::instruction_size) && cb->blob() == NULL) {\n-        ciEnv::current()->record_failure(\"CodeCache is full\");\n-        p_succeeded = false;\n-        return p_succeeded;\n-      }\n-      masm.align(wordSize, NativeCallTrampolineStub::data_offset);\n-    }\n-\n+    assert(cb->stubs()->remaining() >= MacroAssembler::max_trampoline_stub_size(), \"pre-allocated trampolines\");\n@@ -68,4 +60,2 @@\n-    for (; !it.is_empty(); offset = *it.next()) {\n-      masm.relocate(trampoline_stub_Relocation::spec(cb->insts()->start() + offset));\n-    }\n-    masm.set_code_section(cb->insts());\n+    address stub = __ emit_trampoline_stub(offset, dest);\n+    assert(stub, \"pre-allocated trampolines\");\n@@ -73,4 +63,5 @@\n-    address stub = masm.emit_trampoline_stub(offset, dest);\n-    if (stub == nullptr) {\n-      ciEnv::current()->record_failure(\"CodeCache is full\");\n-      p_succeeded = false;\n+    address reloc_pc = cb->stubs()->end() - NativeCallTrampolineStub::instruction_size;\n+    while (!it.is_empty()) {\n+      offset = *it.next();\n+      address caller_pc = cb->insts()->start() + offset;\n+      cb->stubs()->relocate(reloc_pc, trampoline_stub_Relocation::spec(caller_pc));\n@@ -78,2 +69,1 @@\n-\n-    return p_succeeded;\n+    return true;\n@@ -82,1 +72,6 @@\n-  requests->iterate(emit);\n+  assert(requests->number_of_entries() >= 1, \"at least one\");\n+  const int total_requested_size = MacroAssembler::max_trampoline_stub_size() * requests->number_of_entries();\n+  if (cb->stubs()->maybe_expand_to_ensure_remaining(total_requested_size) && cb->blob() == NULL) {\n+    ciEnv::current()->record_failure(\"CodeCache is full\");\n+    return false;\n+  }\n@@ -84,1 +79,2 @@\n-  return p_succeeded;\n+  requests->iterate(emit);\n+  return true;\n@@ -87,0 +83,2 @@\n+#undef __\n+\n","filename":"src\/hotspot\/cpu\/riscv\/codeBuffer_riscv.cpp","additions":21,"deletions":23,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,2 +72,1 @@\n-  \/\/ (lui, addi, slli, addi, slli, addi) + (lui, addi, slli, addi, slli) + jalr\n-  return 12 * NativeInstruction::instruction_size;\n+  return MacroAssembler::static_call_stub_size();\n@@ -80,1 +79,1 @@\n-  return NativeInstruction::instruction_size + NativeCallTrampolineStub::instruction_size;\n+  return MacroAssembler::max_trampoline_stub_size();\n","filename":"src\/hotspot\/cpu\/riscv\/compiledIC_riscv.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -3145,2 +3145,2 @@\n-  address stub = start_a_stub(NativeInstruction::instruction_size\n-                            + NativeCallTrampolineStub::instruction_size);\n+  \/\/ Max stub size: alignment nop, TrampolineStub.\n+  address stub = start_a_stub(max_trampoline_stub_size());\n@@ -3186,0 +3186,10 @@\n+int MacroAssembler::max_trampoline_stub_size() {\n+  \/\/ Max stub size: alignment nop, TrampolineStub.\n+  return NativeInstruction::instruction_size + NativeCallTrampolineStub::instruction_size;\n+}\n+\n+int MacroAssembler::static_call_stub_size() {\n+  \/\/ (lui, addi, slli, addi, slli, addi) + (lui, addi, slli, addi, slli) + jalr\n+  return 12 * NativeInstruction::instruction_size;\n+}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -415,0 +415,1 @@\n+  static int max_trampoline_stub_size();\n@@ -416,0 +417,1 @@\n+  static int static_call_stub_size();\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,0 +32,2 @@\n+#define __ masm.\n+\n@@ -49,1 +51,1 @@\n-    address stub = masm.start_a_stub(CompiledStaticCall::to_interp_stub_size());\n+    address stub = __ start_a_stub(CompiledStaticCall::to_interp_stub_size());\n@@ -58,1 +60,1 @@\n-      masm.relocate(static_stub_Relocation::spec(caller_pc), relocate_format);\n+      __ relocate(static_stub_Relocation::spec(caller_pc), relocate_format);\n@@ -61,2 +63,2 @@\n-    masm.emit_static_call_stub();\n-    masm.end_a_stub();\n+    __ emit_static_call_stub();\n+    __ end_a_stub();\n@@ -67,0 +69,2 @@\n+#undef __\n+\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.inline.hpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"}]}