{"files":[{"patch":"@@ -84,8 +84,0 @@\n-  \/\/ Someone could have modified the value of the static\n-  \/\/ field in the j.l.r.SoftReference class that holds the\n-  \/\/ soft reference timestamp clock using reflection or\n-  \/\/ Unsafe between GCs. Unconditionally update the static\n-  \/\/ field in ReferenceProcessor here so that we use the new\n-  \/\/ value during reference discovery.\n-\n-  _soft_ref_timestamp_clock = java_lang_ref_SoftReference::clock();\n@@ -159,2 +151,0 @@\n-  jlong soft_ref_clock = java_lang_ref_SoftReference::clock();\n-  assert(soft_ref_clock == _soft_ref_timestamp_clock, \"soft ref clocks out of sync\");\n@@ -204,10 +194,0 @@\n-  \/\/ If discovery was concurrent, someone could have modified\n-  \/\/ the value of the static field in the j.l.r.SoftReference\n-  \/\/ class that holds the soft reference timestamp clock using\n-  \/\/ reflection or Unsafe between when discovery was enabled and\n-  \/\/ now. Unconditionally update the static field in ReferenceProcessor\n-  \/\/ here so that we use the new value during processing of the\n-  \/\/ discovered soft refs.\n-\n-  _soft_ref_timestamp_clock = java_lang_ref_SoftReference::clock();\n-\n@@ -219,5 +199,0 @@\n-  {\n-    RefProcTotalPhaseTimesTracker tt(RefPhase1, &phase_times);\n-    process_soft_ref_reconsider(proxy_task, phase_times);\n-  }\n-\n@@ -332,31 +307,0 @@\n-size_t ReferenceProcessor::process_soft_ref_reconsider_work(DiscoveredList&    refs_list,\n-                                                            ReferencePolicy*   policy,\n-                                                            BoolObjectClosure* is_alive,\n-                                                            OopClosure*        keep_alive,\n-                                                            VoidClosure*       complete_gc) {\n-  assert(policy != NULL, \"Must have a non-NULL policy\");\n-  DiscoveredListIterator iter(refs_list, keep_alive, is_alive);\n-  \/\/ Decide which softly reachable refs should be kept alive.\n-  while (iter.has_next()) {\n-    iter.load_ptrs(DEBUG_ONLY(!discovery_is_atomic() \/* allow_null_referent *\/));\n-    bool referent_is_dead = (iter.referent() != NULL) && !iter.is_referent_alive();\n-    if (referent_is_dead &&\n-        !policy->should_clear_reference(iter.obj(), _soft_ref_timestamp_clock)) {\n-      log_dropped_ref(iter, \"by policy\");\n-      \/\/ Remove Reference object from list\n-      iter.remove();\n-      \/\/ keep the referent around\n-      iter.make_referent_alive();\n-      iter.move_to_next();\n-    } else {\n-      iter.next();\n-    }\n-  }\n-  \/\/ Close the reachable set\n-  complete_gc->do_void();\n-\n-  log_develop_trace(gc, ref)(\" Dropped \" SIZE_FORMAT \" dead Refs out of \" SIZE_FORMAT \" discovered Refs by policy, from list \" INTPTR_FORMAT,\n-                             iter.removed(), iter.processed(), p2i(&refs_list));\n-  return iter.removed();\n-}\n-\n@@ -511,28 +455,0 @@\n-\n-class RefProcPhase1Task : public RefProcTask {\n-public:\n-  RefProcPhase1Task(ReferenceProcessor& ref_processor,\n-                    ReferenceProcessorPhaseTimes* phase_times,\n-                    ReferencePolicy* policy)\n-    : RefProcTask(ref_processor,\n-                  phase_times),\n-      _policy(policy) { }\n-\n-  void rp_work(uint worker_id,\n-               BoolObjectClosure* is_alive,\n-               OopClosure* keep_alive,\n-               VoidClosure* complete_gc) override {\n-    ResourceMark rm;\n-    RefProcSubPhasesWorkerTimeTracker tt(ReferenceProcessor::SoftRefSubPhase1, _phase_times, tracker_id(worker_id));\n-    size_t const removed = _ref_processor.process_soft_ref_reconsider_work(_ref_processor._discoveredSoftRefs[worker_id],\n-                                                                           _policy,\n-                                                                           is_alive,\n-                                                                           keep_alive,\n-                                                                           complete_gc);\n-    _phase_times->add_ref_cleared(REF_SOFT, removed);\n-  }\n-\n-private:\n-  ReferencePolicy* _policy;\n-};\n-\n@@ -794,32 +710,0 @@\n-void ReferenceProcessor::process_soft_ref_reconsider(RefProcProxyTask& proxy_task,\n-                                                     ReferenceProcessorPhaseTimes& phase_times) {\n-\n-  size_t const num_soft_refs = total_count(_discoveredSoftRefs);\n-  phase_times.set_ref_discovered(REF_SOFT, num_soft_refs);\n-  phase_times.set_processing_is_mt(processing_is_mt());\n-\n-  if (num_soft_refs == 0) {\n-    log_debug(gc, ref)(\"Skipped phase 1 of Reference Processing: no references\");\n-    return;\n-  }\n-\n-  if (_current_soft_ref_policy == NULL) {\n-    log_debug(gc, ref)(\"Skipped phase 1 of Reference Processing: no policy\");\n-    return;\n-  }\n-\n-  RefProcMTDegreeAdjuster a(this, RefPhase1, num_soft_refs);\n-\n-  if (processing_is_mt()) {\n-    RefProcBalanceQueuesTimeTracker tt(RefPhase1, &phase_times);\n-    maybe_balance_queues(_discoveredSoftRefs);\n-  }\n-\n-  RefProcPhaseTimeTracker tt(RefPhase1, &phase_times);\n-\n-  log_reflist(\"Phase 1 Soft before\", _discoveredSoftRefs, _max_num_queues);\n-  RefProcPhase1Task phase1(*this, &phase_times, _current_soft_ref_policy);\n-  run_task(phase1, proxy_task, true);\n-  log_reflist(\"Phase 1 Soft after\", _discoveredSoftRefs, _max_num_queues);\n-}\n-\n@@ -1308,2 +1192,2 @@\n-  \/\/ Even a small number of references in either of those cases could produce large amounts of work.\n-  return (phase == ReferenceProcessor::RefPhase1 || phase == ReferenceProcessor::RefPhase3);\n+  \/\/ Even a small number of references in this phase could produce large amounts of work.\n+  return phase == ReferenceProcessor::RefPhase3;\n","filename":"src\/hotspot\/share\/gc\/shared\/referenceProcessor.cpp","additions":2,"deletions":118,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -163,1 +163,0 @@\n-  friend class RefProcPhase1Task;\n@@ -171,1 +170,0 @@\n-    SoftRefSubPhase1,\n@@ -182,1 +180,0 @@\n-    RefPhase1,\n@@ -240,4 +237,0 @@\n-  \/\/ Phase 1: Re-evaluate soft ref policy.\n-  void process_soft_ref_reconsider(RefProcProxyTask& proxy_task,\n-                                   ReferenceProcessorPhaseTimes& phase_times);\n-\n@@ -260,9 +253,0 @@\n-  \/\/ (SoftReferences only) Traverse the list and remove any SoftReferences whose\n-  \/\/ referents are not alive, but that should be kept alive for policy reasons.\n-  \/\/ Keep alive the transitive closure of all such referents.\n-  size_t process_soft_ref_reconsider_work(DiscoveredList&     refs_list,\n-                                          ReferencePolicy*    policy,\n-                                          BoolObjectClosure*  is_alive,\n-                                          OopClosure*         keep_alive,\n-                                          VoidClosure*        complete_gc);\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/referenceProcessor.hpp","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-#define ASSERT_PHASE(phase) assert((phase) >= ReferenceProcessor::RefPhase1 && \\\n+#define ASSERT_PHASE(phase) assert((phase) >= ReferenceProcessor::RefPhase2 && \\\n@@ -43,1 +43,1 @@\n-#define ASSERT_SUB_PHASE(phase) assert((phase) >= ReferenceProcessor::SoftRefSubPhase1 && \\\n+#define ASSERT_SUB_PHASE(phase) assert((phase) >= ReferenceProcessor::SoftRefSubPhase2 && \\\n@@ -48,1 +48,0 @@\n-       \"SoftRef (ms):\",\n@@ -59,1 +58,0 @@\n-       \"SoftRef:\",\n@@ -72,1 +70,0 @@\n-       \"Reconsider SoftReferences\",\n@@ -282,1 +279,0 @@\n-  print_phase(ReferenceProcessor::RefPhase1, next_indent);\n@@ -336,3 +332,0 @@\n-      case ReferenceProcessor::RefPhase1:\n-        print_sub_phase(&ls, ReferenceProcessor::SoftRefSubPhase1, indent + 1);\n-        break;\n","filename":"src\/hotspot\/share\/gc\/shared\/referenceProcessorPhaseTimes.cpp","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -53,1 +53,0 @@\n-    static final String phaseReconsiderSoftReferences = \"Reconsider SoftReferences\";\n@@ -140,1 +139,0 @@\n-        String phase1Regex = gcLogTimeRegex + phaseRegex(phaseReconsiderSoftReferences) + balanceRegex + subphaseRegex(\"SoftRef\", p);\n@@ -151,1 +149,0 @@\n-                           phase1Regex +\n@@ -223,1 +220,1 @@\n-        BigDecimal sumOfSubPhasesTime = getTimeValue(phaseReconsiderSoftReferences, 2);\n+        BigDecimal sumOfSubPhasesTime = BigDecimal.ZERO;\n@@ -228,3 +225,3 @@\n-        \/\/ If there are 4 phases, we should allow 0.2 tolerance.\n-        final BigDecimal toleranceFor4SubPhases = BigDecimal.valueOf(0.2);\n-        if (!greaterThanOrApproximatelyEqual(refProcTime, sumOfSubPhasesTime, toleranceFor4SubPhases)) {\n+        \/\/ If there are 3 phases, we should allow 0.2 tolerance.\n+        final BigDecimal toleranceFor3SubPhases = BigDecimal.valueOf(0.2);\n+        if (!greaterThanOrApproximatelyEqual(refProcTime, sumOfSubPhasesTime, toleranceFor3SubPhases)) {\n","filename":"test\/hotspot\/jtreg\/gc\/logging\/TestPrintReferences.java","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"}]}