{"files":[{"patch":"@@ -215,1 +215,0 @@\n-                    if (inputQ.isEmpty()) sched.stop();\n@@ -234,1 +233,0 @@\n-                        if (inputQ.isEmpty()) sched.stop();\n@@ -582,2 +580,0 @@\n-    \/\/ Logic here starts checking roughly in reverse order of the Stream's life-cycle i.e. check if closed, check if\n-    \/\/ closing or done sending, response received or waiting for expect continue, receiving reset on active stream...\n@@ -586,0 +582,1 @@\n+        \/\/ responseSubscriber will be null if readBodyAsync has not yet been called\n@@ -588,0 +585,1 @@\n+        \/\/ See RFC 9113 sec 5.1 Figure 2, life-cycle of a stream\n@@ -589,1 +587,1 @@\n-            \/\/ END_STREAM flag may have been seen in the queue before processing this ResetFrame\n+            \/\/ Stream is in a half closed or fully closed state, the RST_STREAM is ignored and logged.\n@@ -592,0 +590,1 @@\n+            \/\/ Stream is in a fully closed state, the RST_STREAM is ignored and logged.\n@@ -594,0 +593,1 @@\n+            \/\/ subscriber is null and the reader has not seen an END_STREAM flag, handle reset immediately\n@@ -596,0 +596,1 @@\n+            \/\/ Not done sending the body, complete exceptionally or normally based on RST_STREAM error code\n@@ -598,0 +599,1 @@\n+            \/\/ Complete response has not been received, handle reset immediately\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Stream.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"}]}