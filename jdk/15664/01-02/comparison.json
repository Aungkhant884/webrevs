{"files":[{"patch":"@@ -231,1 +231,4 @@\n-            connections.values().forEach(this::close);\n+            for (var entry : connections.entrySet()) {\n+                connections.values().forEach(this::close);\n+                connections.remove(entry.getKey(), entry.getValue());\n+            }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http2ClientImpl.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -164,0 +164,3 @@\n+    \/\/ Only accessed in all method calls from incoming(), no need for volatile\n+    private boolean endStreamSeen;\n+\n@@ -481,0 +484,1 @@\n+\/\/        endStreamSeen = endStreamSeen || frame.getFlag(HeaderFrame.END_STREAM);\n@@ -487,0 +491,1 @@\n+                endStreamSeen = true;\n@@ -491,0 +496,1 @@\n+            if (df.getFlag(DataFrame.END_STREAM)) endStreamSeen = true;\n@@ -574,0 +580,2 @@\n+    \/\/ Logic here starts checking roughly in reverse order of the Stream's life-cycle i.e. check if closed, check if\n+    \/\/ closing or done sending, response received or waiting for expect continue, receiving reset on active stream...\n@@ -576,0 +584,1 @@\n+        Flow.Subscriber<?> subscriber = responseSubscriber == null ? pendingResponseSubscriber : responseSubscriber;\n@@ -577,0 +586,1 @@\n+            \/\/ END_STREAM flag may have been seen in the queue before processing this ResetFrame\n@@ -580,0 +590,6 @@\n+        } else if (subscriber == null && !endStreamSeen) {\n+            handleReset(frame, null);\n+        } else if (!requestBodyCF.isDone()) {\n+            incompleteRequestBodyReset(frame, subscriber);\n+        } else if (response == null || !finalResponseCodeReceived) {\n+            handleReset(frame, null);\n@@ -581,19 +597,17 @@\n-            Flow.Subscriber<?> subscriber =\n-                    responseSubscriber == null ? pendingResponseSubscriber : responseSubscriber;\n-            if (!requestBodyCF.isDone()) {\n-                \/\/ If a RST_STREAM is received, complete the requestBody. This will allow the\n-                \/\/ response to be read before the Reset is handled in the case where the client's\n-                \/\/ input stream is partially consumed or not consumed at all by the server.\n-                if (frame.getErrorCode() != ResetFrame.NO_ERROR) {\n-                    if (debug.on()) {\n-                        debug.log(\"completing requestBodyCF exceptionally due to received\" +\n-                                \" RESET(%s) (stream=%s)\", frame.getErrorCode(), streamid);\n-                    }\n-                    requestBodyCF.completeExceptionally(new IOException(\"RST_STREAM received\"));\n-                } else {\n-                    if (debug.on()) {\n-                        debug.log(\"completing requestBodyCF normally due to received\" +\n-                                \" RESET(NO_ERROR) (stream=%s)\", streamid);\n-                    }\n-                    requestBodyCF.complete(null);\n-                }\n+            \/\/ Put ResetFrame into inputQ. Any frames already in the queue will be processed before the ResetFrame.\n+            receiveResetFrame(frame);\n+            Log.logTrace(\"RST_STREAM pushed in queue for stream {0}\", streamid);\n+        }\n+    }\n+\n+    void incompleteRequestBodyReset(ResetFrame frame, Flow.Subscriber<?> subscriber) {\n+        if (frame.getErrorCode() != ResetFrame.NO_ERROR) {\n+            if (debug.on()) {\n+                debug.log(\"completing requestBodyCF exceptionally due to received\" +\n+                        \" RESET(%s) (stream=%s)\", frame.getErrorCode(), streamid);\n+            }\n+            requestBodyCF.completeExceptionally(new IOException(\"RST_STREAM received\"));\n+        } else {\n+            if (debug.on()) {\n+                debug.log(\"completing requestBodyCF normally due to received\" +\n+                        \" RESET(NO_ERROR) (stream=%s)\", streamid);\n@@ -601,4 +615,3 @@\n-            if ((response == null || !finalResponseCodeReceived) && subscriber == null) {\n-                \/\/ we haven't received the headers yet, and won't receive any!\n-                \/\/ handle reset now.\n-                handleReset(frame, null);\n+            if (!endStreamSeen) {\n+                \/\/ If no END_STREAM flag seen, any RST_STREAM should be handled here immediately\n+                handleReset(frame, subscriber);\n@@ -606,10 +619,1 @@\n-                \/\/ put it in the input queue in order to read all\n-                \/\/ pending data frames first. Indeed, a server may send\n-                \/\/ RST_STREAM after sending END_STREAM, in which case we should\n-                \/\/ ignore it. However, we won't know if we have received END_STREAM\n-                \/\/ or not until all pending data frames are read.\n-                receiveResetFrame(frame);\n-                \/\/ RST_STREAM was pushed to the queue. It will be handled by\n-                \/\/ asyncReceive after all pending data frames have been\n-                \/\/ processed.\n-                Log.logTrace(\"RST_STREAM pushed in queue for stream {0}\", streamid);\n+                requestBodyCF.complete(null);\n@@ -631,1 +635,1 @@\n-                stateLock.lock();\n+                stateLock.unlock();\n@@ -644,0 +648,1 @@\n+                    if (debug.on()) debug.log(\"\\nHERE\");\n@@ -647,0 +652,1 @@\n+                    if (debug.on()) debug.log(\"\\nALSO HERE\");\n@@ -1084,0 +1090,1 @@\n+                \/\/ TODO: Maybe throw exception here to fix intermittent error?\n@@ -1105,0 +1112,1 @@\n+        \/\/ TODO: We could put the check for END_STREAM received here?\n@@ -1384,1 +1392,3 @@\n-            if (responseSubscriber != null || pendingResponseSubscriber != null) {\n+            var subscriber = this.responseSubscriber;\n+            if (subscriber == null) subscriber = this.pendingResponseSubscriber;\n+            if (subscriber != null) {\n@@ -1388,0 +1398,5 @@\n+                if (subscriber instanceof Http2StreamResponseSubscriber<?> rs) {\n+                    \/\/ make sure the subscriber is stopped.\n+                    if (debug.on()) debug.log(\"closing response subscriber stream %s\", streamid);\n+                    rs.complete(errorRef.get());\n+                }\n@@ -1391,1 +1406,1 @@\n-                        streamid, (Object)errorRef.get());\n+                            streamid, (Object)errorRef.get());\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Stream.java","additions":51,"deletions":36,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -33,1 +33,2 @@\n- * @run testng\/othervm -Djdk.internal.httpclient.debug=true -Djdk.httpclient.HttpClient.log=errors,headers ExpectContinueResetTest\n+ * @run testng\/othervm\/timeout=40  -Djdk.internal.httpclient.debug=true -Djdk.httpclient.HttpClient.log=trace,errors,headers\n+ *                              ExpectContinueResetTest\n@@ -45,1 +46,0 @@\n-import jdk.internal.net.http.frame.HeaderFrame;\n@@ -47,0 +47,1 @@\n+import org.testng.TestException;\n@@ -62,1 +63,1 @@\n-import java.util.concurrent.CompletableFuture;\n+import java.util.Iterator;\n@@ -72,4 +73,3 @@\n-    final String samplePost = \"Sample Post\";\n-\n-    URI warmup, postSuccessfully, postExceptionally;\n-    URI resetStreamAfter100NoError, resetStreamAfter100Error, resetStreamAfter200NoError, resetStreamAfter200Error;\n+    \/\/ \"NoError\" urls complete with an exception. \"NoError\" or \"Error\" here refers to the error code in the RST_STREAM frame\n+    \/\/ and not the outcome of the test.\n+    URI warmup, partialResponseResetNoError, partialResponseResetError, fullResponseResetNoError, fullResponseResetError;\n@@ -83,2 +83,4 @@\n-                { postSuccessfully, false }, \/\/ Checks RST_STREAM is ignored after client sees an END_STREAM\n-                { postExceptionally, true }  \/\/ Checks RST_STREAM is processed if client sees no END_STREAM\n+                { partialResponseResetNoError },\n+                { partialResponseResetError },  \/\/ Checks RST_STREAM is processed if client sees no END_STREAM\n+                { fullResponseResetNoError },\n+                { fullResponseResetError }\n@@ -88,10 +90,0 @@\n-    @DataProvider(name = \"testDataConsumedBody\")\n-    public Object[][] testDataConsumedBody() {\n-        return new Object[][] {\n-                \/\/ All client requests to these URIs should complete exceptionally\n-                { resetStreamAfter100NoError }, \/\/ Client receives RST_STREAM before END_STREAM and 200\n-                { resetStreamAfter100Error },  \/\/ Client receives RST_STREAM before END_STREAM and 200\n-                { resetStreamAfter200NoError }, \/\/ Client receives RST_STREAM after 200 but before server sends END_STREAM\n-                { resetStreamAfter200Error } \/\/ Client receives RST_STREAM after 200 but before server sends END_STREAM\n-        };\n-    }\n@@ -100,24 +92,4 @@\n-    public void testUnconsumedBody(URI uri, boolean exceptionally) {\n-        err.printf(\"\\nTesting with Version: %s, URI: %s\\n\", HTTP_2, uri);\n-        HttpRequest.BodyPublisher testPub = HttpRequest.BodyPublishers.ofString(samplePost);\n-        HttpResponse<String> resp = null;\n-        Throwable testThrowable = null;\n-        try {\n-            resp = performRequest(testPub, uri);\n-        } catch (Exception e) {\n-            testThrowable = e.getCause();\n-        }\n-        if (exceptionally) {\n-            assertNotNull(testThrowable, \"Request should have completed exceptionally but testThrowable is null\");\n-            assertEquals(testThrowable.getClass(), IOException.class, \"Test should have closed with an IOException\");\n-        } else {\n-            assertNull(testThrowable);\n-            assertNotNull(resp);\n-            assertEquals(resp.statusCode(), 200);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"testDataConsumedBody\")\n-    public void testConsumedBody(URI uri) {\n-        err.printf(\"\\nTesting with Version: %s, URI: %s\\n\", HTTP_2, uri);\n-        HttpRequest.BodyPublisher testPub = HttpRequest.BodyPublishers.ofString(samplePost);\n+    public void testUnconsumedBody(URI uri) {\n+        err.printf(\"\\nTesting with Version: %s, URI: %s\\n\", HTTP_2, uri.toASCIIString());\n+        Iterable<byte[]> iterable = EndlessDataChunks::new;\n+        HttpRequest.BodyPublisher testPub = HttpRequest.BodyPublishers.ofByteArrays(iterable);\n@@ -132,0 +104,18 @@\n+        testThrowable.printStackTrace();\n+    }\n+\n+    static public class EndlessDataChunks implements Iterator<byte[]> {\n+\n+        byte[] data = new byte[16];\n+        @Override\n+        public boolean hasNext() {\n+            return true;\n+        }\n+        @Override\n+        public byte[] next() {\n+            return data;\n+        }\n+        @Override\n+        public void remove() {\n+            throw new UnsupportedOperationException();\n+        }\n@@ -139,0 +129,4 @@\n+        http2TestServer.addHandler(new NoEndStreamOnPartialResponse(), \"\/partialResponse\/codeNoError\");\n+        http2TestServer.addHandler(new NoEndStreamOnPartialResponse(), \"\/partialResponse\/codeError\");\n+        http2TestServer.addHandler(new NoEndStreamOnFullResponse(), \"\/fullResponse\/codeNoError\");\n+        http2TestServer.addHandler(new NoEndStreamOnFullResponse(), \"\/fullResponse\/codeError\");\n@@ -140,7 +134,0 @@\n-        http2TestServer.addHandler(new PostHandlerHttp2(), \"\/http2\/resetStreamAfter100NoError\");\n-        http2TestServer.addHandler(new PostHandlerHttp2(), \"\/http2\/resetStreamAfter100Error\");\n-        http2TestServer.addHandler(new PostHandlerHttp2(), \"\/http2\/resetStreamAfter200Error\");\n-        http2TestServer.addHandler(new PostHandlerHttp2(), \"\/http2\/resetStreamAfter200NoError\");\n-\n-        http2TestServer.addHandler(new TestHandlerEndStreamOn200(), \"\/testHandlerSuccessfully\");\n-        http2TestServer.addHandler(new TestHandlerNoEndStreamOn200(), \"\/testHandlerExceptionally\");\n@@ -148,8 +135,4 @@\n-\n-        resetStreamAfter100NoError = URI.create(\"http:\/\/\" + http2TestServer.serverAuthority() + \"\/http2\/resetStreamAfter100NoError\");\n-        resetStreamAfter100Error = URI.create(\"http:\/\/\" + http2TestServer.serverAuthority() + \"\/http2\/resetStreamAfter100Error\");\n-        resetStreamAfter200NoError = URI.create(\"http:\/\/\" + http2TestServer.serverAuthority() + \"\/http2\/resetStreamAfter200NoError\");\n-        resetStreamAfter200Error = URI.create(\"http:\/\/\" + http2TestServer.serverAuthority() + \"\/http2\/resetStreamAfter200Error\");\n-\n-        postSuccessfully = URI.create(\"http:\/\/\" + http2TestServer.serverAuthority() + \"\/testHandlerSuccessfully\");\n-        postExceptionally = URI.create(\"http:\/\/\" + http2TestServer.serverAuthority() + \"\/testHandlerExceptionally\");\n+        partialResponseResetNoError = URI.create(\"http:\/\/\" + http2TestServer.serverAuthority() + \"\/partialResponse\/codeNoError\");\n+        partialResponseResetError = URI.create(\"http:\/\/\" + http2TestServer.serverAuthority() + \"\/partialResponse\/codeError\");\n+        fullResponseResetNoError = URI.create(\"http:\/\/\" + http2TestServer.serverAuthority() + \"\/fullResponse\/codeNoError\");\n+        fullResponseResetError = URI.create(\"http:\/\/\" + http2TestServer.serverAuthority() + \"\/fullResponse\/codeError\");\n@@ -164,1 +147,1 @@\n-    private HttpResponse<String> performRequest(HttpRequest.BodyPublisher bodyPublisher, URI uri)\n+    private void performRequest(HttpRequest.BodyPublisher bodyPublisher, URI uri)\n@@ -175,2 +158,2 @@\n-            CompletableFuture<HttpResponse<String>> cf = client.sendAsync(postRequest, HttpResponse.BodyHandlers.ofString());\n-            return cf.get();\n+            \/\/ TODO: when test is stable and complete, see then if fromSubscriber makes our subscriber non null\n+            client.sendAsync(postRequest, HttpResponse.BodyHandlers.ofString()).get();\n@@ -194,12 +177,1 @@\n-    static class PostHandlerHttp2 implements Http2Handler {\n-\n-        @Override\n-        public void handle(Http2TestExchange exchange) throws IOException {\n-            if (exchange instanceof ExpectContinueResetTestExchangeImpl impl) {\n-                String path = exchange.getRequestURI().getPath();\n-                impl.handleTestExchange(path);\n-            }\n-        }\n-    }\n-\n-    static class TestHandlerEndStreamOn200 implements Http2Handler {\n+    static class NoEndStreamOnPartialResponse implements Http2Handler {\n@@ -210,6 +182,12 @@\n-            exchange.sendResponseHeaders(100, -1);\n-            err.println(\"Sending 200\");\n-            exchange.sendResponseHeaders(200, -1);\n-            \/\/ Setting responseLength to -1, sets the END_STREAM flag on the ResponseHeaders before sending a RST_STREAM frame.\n-            \/\/ Therefore, there is no need to explicitly send a RST_STREAM here as this will be sent by the Server impl.\n-            err.println(\"Sending Reset\");\n+            exchange.sendResponseHeaders(100, 0);\n+            if (exchange instanceof ExpectContinueResetTestExchangeImpl testExchange) {\n+                err.println(\"Sending Reset\");\n+                err.println(exchange.getRequestURI().getPath());\n+                switch (exchange.getRequestURI().getPath()) {\n+                    case \"\/partialResponse\/codeNoError\" -> testExchange.addResetToOutputQ(ResetFrame.NO_ERROR);\n+                    case \"\/partialResponse\/codeError\" -> testExchange.addResetToOutputQ(ResetFrame.PROTOCOL_ERROR);\n+                    default -> throw new TestException(\"Invalid Request Path\");\n+                }\n+            } else {\n+                throw new TestException(\"Wrong Exchange type used\");\n+            }\n@@ -219,1 +197,1 @@\n-    static class TestHandlerNoEndStreamOn200 implements Http2Handler {\n+    static class NoEndStreamOnFullResponse implements Http2Handler {\n@@ -229,1 +207,5 @@\n-                testExchange.addResetToOutputQ(ResetFrame.NO_ERROR);\n+                switch (exchange.getRequestURI().getPath()) {\n+                    case \"\/fullResponse\/codeNoError\" -> testExchange.addResetToOutputQ(ResetFrame.NO_ERROR);\n+                    case \"\/fullResponse\/codeError\" -> testExchange.addResetToOutputQ(ResetFrame.PROTOCOL_ERROR);\n+                    default -> throw new TestException(\"Invalid Request Path\");\n+                }\n@@ -231,1 +213,1 @@\n-                throw new RuntimeException(\"Wrong Exchange type used\");\n+                throw new TestException(\"Wrong Exchange type used\");\n@@ -235,0 +217,1 @@\n+\n@@ -245,59 +228,0 @@\n-\n-        public void handleTestExchange(String path) throws IOException {\n-            \/\/Based on request path, execute a different response case\n-            try (InputStream reqBody = this.getRequestBody()) {\n-                switch (path) {\n-                    case \"\/http2\/endStream\" -> sendEndStreamHeaders();\n-                    case \"\/http2\/resetStreamAfter100NoError\" -> resetStreamAfter100NoError(reqBody);\n-                    case \"\/http2\/resetStreamAfter100Error\" -> resetStreamAfter100Error(reqBody);\n-                    case \"\/http2\/resetStreamAfter200NoError\" -> resetStreamAfter200NoError(reqBody);\n-                    case \"\/http2\/resetStreamAfter200Error\" -> resetStreamAfter200Error(reqBody);\n-                    default -> sendResponseHeaders(400, 0);\n-                }\n-            }\n-        }\n-\n-        private void sendEndStreamHeaders() throws IOException {\n-            this.responseLength = 0;\n-            rspheadersBuilder.setHeader(\":status\", Integer.toString(100));\n-            HttpHeaders headers = rspheadersBuilder.build();\n-            Http2TestServerConnection.ResponseHeaders response\n-                    = new Http2TestServerConnection.ResponseHeaders(headers);\n-            response.streamid(streamid);\n-            response.setFlag(HeaderFrame.END_HEADERS);\n-            response.setFlag(HeaderFrame.END_STREAM);\n-            sendResponseHeaders(response);\n-        }\n-\n-        private void resetStreamAfter100NoError(InputStream reqBody) throws IOException {\n-            err.println(\"IN HANDLER\");\n-            this.sendResponseHeaders(100, 0);\n-            reqBody.readAllBytes();\n-            \/\/ Send Reset Frame immediately after Response Headers\n-            addResetToOutputQ(ResetFrame.NO_ERROR);\n-        }\n-\n-        private void resetStreamAfter100Error(InputStream reqBody) throws IOException {\n-            this.sendResponseHeaders(100, 0);\n-            reqBody.readAllBytes();\n-            \/\/ Send Reset Frame immediately after Response Headers\n-            addResetToOutputQ(ResetFrame.PROTOCOL_ERROR);\n-        }\n-\n-        public void resetStreamAfter200NoError(InputStream reqBody) throws IOException {\n-            this.sendResponseHeaders(100, 0);\n-            reqBody.readAllBytes();\n-            this.sendResponseHeaders(200, 0);\n-            \/\/ Send Reset after reading data and 200 sent. This means the RST_STREAM will be received by the client before\n-            \/\/ an empty DATA_FRAME with the END_STREAM flag sent causing the exchange to complete exceptionally.\n-            addResetToOutputQ(ResetFrame.NO_ERROR);\n-        }\n-\n-        public void resetStreamAfter200Error(InputStream reqBody) throws IOException {\n-            this.sendResponseHeaders(100, 0);\n-            reqBody.readAllBytes();\n-            this.sendResponseHeaders(200, 0);\n-            \/\/ Send Reset after reading data and 200 sent. This means the RST_STREAM will be received by the client before\n-            \/\/ an empty DATA_FRAME with the END_STREAM flag sent causing the exchange to complete exceptionally.\n-            addResetToOutputQ(ResetFrame.PROTOCOL_ERROR);\n-        }\n","filename":"test\/jdk\/java\/net\/httpclient\/http2\/ExpectContinueResetTest.java","additions":65,"deletions":141,"binary":false,"changes":206,"status":"modified"}]}