{"files":[{"patch":"@@ -79,1 +79,1 @@\n-ThreadsList ThreadsSMRSupport::_bootstrap_list = ThreadsList(0);\n+ThreadsList ThreadsSMRSupport::_bootstrap_list{0};\n@@ -588,1 +588,15 @@\n-\/\/ 'entries + 1' so we always have at least one entry.\n+\/\/ Shared singleton data for all ThreadsList(0) instances.\n+\/\/ Used by _bootstrap_list to avoid static init time heap allocation.\n+\/\/ No real entries, just the final NULL terminator.\n+static JavaThread* const empty_threads_list_data[1] = {};\n+\n+\/\/ Result has 'entries + 1' elements, with the last being the NULL terminator.\n+static JavaThread* const* make_threads_list_data(int entries) {\n+  if (entries == 0) {\n+    return empty_threads_list_data;\n+  }\n+  JavaThread** data = NEW_C_HEAP_ARRAY(JavaThread*, entries + 1, mtThread);\n+  data[entries] = NULL;         \/\/ Make sure the final entry is NULL.\n+  return data;\n+}\n+\n@@ -592,1 +606,1 @@\n-  _threads(NEW_C_HEAP_ARRAY(JavaThread*, entries + 1, mtThread)),\n+  _threads(make_threads_list_data(entries)),\n@@ -594,3 +608,1 @@\n-{\n-  *(JavaThread**)(_threads + entries) = NULL;  \/\/ Make sure the extra entry is NULL.\n-}\n+{}\n@@ -599,1 +611,3 @@\n-  FREE_C_HEAP_ARRAY(JavaThread*, _threads);\n+  if (_threads != empty_threads_list_data) {\n+    FREE_C_HEAP_ARRAY(JavaThread*, _threads);\n+  }\n","filename":"src\/hotspot\/share\/runtime\/threadSMR.cpp","additions":21,"deletions":7,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -175,0 +175,2 @@\n+  NONCOPYABLE(ThreadsList);\n+\n","filename":"src\/hotspot\/share\/runtime\/threadSMR.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}