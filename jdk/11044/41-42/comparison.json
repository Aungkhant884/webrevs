{"files":[{"patch":"@@ -311,2 +311,2 @@\n-  static size_t min_dummy_object_size() {\n-    return min_fill_size();\n+  static constexpr size_t min_dummy_object_size() {\n+    return oopDesc::header_size();\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -360,1 +360,1 @@\n-    if (value \/ HeapWordSize > ThreadLocalAllocBuffer::max_size()) {\n+    if (value > (ThreadLocalAllocBuffer::max_size() * HeapWordSize)) {\n@@ -362,3 +362,3 @@\n-                          \"TLABSize (\" SIZE_FORMAT \" bytes) must be \"\n-                          \"less than or equal to ergonomic TLAB maximum size (\" SIZE_FORMAT \" words)\\n\",\n-                          value, ThreadLocalAllocBuffer::max_size());\n+                          \"TLABSize (\" SIZE_FORMAT \") must be \"\n+                          \"less than or equal to ergonomic TLAB maximum size (\" SIZE_FORMAT \")\\n\",\n+                          value, (ThreadLocalAllocBuffer::max_size() * HeapWordSize));\n","filename":"src\/hotspot\/share\/gc\/shared\/jvmFlagConstraintsGC.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-  if (!os::is_readable_range(obj, (char*)obj + oopDesc::base_offset_in_bytes())) {\n+  if (!os::is_readable_range(obj, (HeapWord*)obj + oopDesc::header_size())) {\n","filename":"src\/hotspot\/share\/gc\/shared\/locationPrinter.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -321,1 +321,1 @@\n-    \/\/ ...and zap just allocated tlab.\n+    \/\/ ...and zap just allocated object.\n@@ -323,1 +323,5 @@\n-    Copy::fill_to_words(mem, allocation._allocated_tlab_size, badHeapWordVal);\n+    \/\/ Skip mangling the space corresponding to the object header to\n+    \/\/ ensure that the returned space is not considered parsable by\n+    \/\/ any concurrent GC thread.\n+    size_t hdr_size = oopDesc::header_size();\n+    Copy::fill_to_words(mem + hdr_size, allocation._allocated_tlab_size - hdr_size, badHeapWordVal);\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-  return align_object_size(MAX2(MinTLABSize \/ HeapWordSize, checked_cast<size_t>(oopDesc::header_size()))) + CollectedHeap::lab_alignment_reserve();\n+  return align_object_size(MAX2(MinTLABSize \/ HeapWordSize, (size_t)oopDesc::header_size())) + CollectedHeap::lab_alignment_reserve();\n","filename":"src\/hotspot\/share\/gc\/shared\/plab.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -113,0 +113,1 @@\n+  static size_t max_size_in_bytes()              { return max_size() * BytesPerWord; }\n","filename":"src\/hotspot\/share\/gc\/shared\/threadLocalAllocBuffer.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -53,11 +53,1 @@\n-  int base_offset = arrayOopDesc::base_offset_in_bytes(element_type);\n-\n-  \/\/ Clear leading 32 bits, if necessary.\n-  if (!is_aligned(base_offset, HeapWordSize)) {\n-    assert(is_aligned(base_offset, BytesPerInt), \"array base must be 32 bit aligned\");\n-    *reinterpret_cast<jint*>(reinterpret_cast<char*>(mem) + base_offset) = 0;\n-    base_offset += BytesPerInt;\n-  }\n-  assert(is_aligned(base_offset, HeapWordSize), \"remaining array base must be 64 bit aligned\");\n-\n-  const size_t header = heap_word_size(base_offset);\n+  const size_t header = arrayOopDesc::header_size(element_type);\n@@ -65,0 +55,1 @@\n+\n","filename":"src\/hotspot\/share\/gc\/x\/xObjArrayAllocator.cpp","additions":2,"deletions":11,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -53,11 +53,1 @@\n-  int base_offset = arrayOopDesc::base_offset_in_bytes(element_type);\n-\n-  \/\/ Clear leading 32 bits, if necessary.\n-  if (!is_aligned(base_offset, HeapWordSize)) {\n-    assert(is_aligned(base_offset, BytesPerInt), \"array base must be 32 bit aligned\");\n-    *reinterpret_cast<jint*>(reinterpret_cast<char*>(mem) + base_offset) = 0;\n-    base_offset += BytesPerInt;\n-  }\n-  assert(is_aligned(base_offset, HeapWordSize), \"remaining array base must be 64 bit aligned\");\n-\n-  const size_t header = heap_word_size(base_offset);\n+  const size_t header = arrayOopDesc::header_size(element_type);\n@@ -65,0 +55,1 @@\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zObjArrayAllocator.cpp","additions":2,"deletions":11,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2004,0 +2004,1 @@\n+              oopDesc::set_klass_gap(result, 0);\n","filename":"src\/hotspot\/share\/interpreter\/zero\/bytecodeInterpreter.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -36,0 +36,3 @@\n+  \/\/ aligned header size.\n+  static int header_size() { return sizeof(instanceOopDesc)\/HeapWordSize; }\n+\n@@ -38,1 +41,4 @@\n-    return oopDesc::base_offset_in_bytes();\n+    return (UseCompressedClassPointers) ?\n+            klass_gap_offset_in_bytes() :\n+            sizeof(instanceOopDesc);\n+\n","filename":"src\/hotspot\/share\/oops\/instanceOop.hpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -99,7 +99,0 @@\n-  static int base_offset_in_bytes() {\n-    return (UseCompressedClassPointers) ?\n-            klass_gap_offset_in_bytes() :\n-            sizeof(oopDesc);\n-\n-  }\n-\n@@ -107,1 +100,1 @@\n-  static int header_size() { return checked_cast<int>(heap_word_size(base_offset_in_bytes())); }\n+  static constexpr int header_size() { return sizeof(oopDesc)\/HeapWordSize; }\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"}]}