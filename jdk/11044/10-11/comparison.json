{"files":[{"patch":"@@ -369,1 +369,1 @@\n-  \/\/ Elements are not dword aligned. Zero out leading word.\n+  \/\/ Zero first 4 bytes, if start offset is not word aligned.\n","filename":"src\/hotspot\/cpu\/ppc\/c1_MacroAssembler_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -276,1 +276,1 @@\n-  int      base_offset_in_bytes,       \/\/ offset of array elements in bytes\n+  int      base_offset_in_bytes,       \/\/ elements offset in bytes\n@@ -313,1 +313,1 @@\n-  z_aghi(arr_size, -(base_offset_in_bytes));\n+  z_aghi(arr_size, -base_offset_in_bytes);\n","filename":"src\/hotspot\/cpu\/s390\/c1_MacroAssembler_s390.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4136,1 +4136,2 @@\n-  \/\/ note: for the remaining code to work, index must be a multiple of BytesPerInt\n+  \/\/ For the remaining code to work, length must be a multiple of BytesPerInt.\n+  \/\/ Check that here.\n@@ -4152,1 +4153,0 @@\n-  \/\/ Emit single 32bit store to clear leading bytes, if necessary.\n@@ -4154,0 +4154,1 @@\n+\n@@ -4155,0 +4156,1 @@\n+  \/\/ Emit single 32bit store to clear leading bytes, if necessary.\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-#include \"gc\/shared\/collectedHeap.hpp\"\n+#include \"gc\/shared\/collectedHeap.inline.hpp\"\n@@ -112,2 +112,1 @@\n-              touched_words = MIN2((size_t)align_object_size(heap_word_size(typeArrayOopDesc::base_offset_in_bytes(T_INT))),\n-                touched_words);\n+              touched_words = MIN2(CollectedHeap::filler_array_min_size(), touched_words);\n","filename":"src\/hotspot\/share\/gc\/parallel\/mutableNUMASpace.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -256,4 +256,2 @@\n-  int header_size_in_bytes = arrayOopDesc::base_offset_in_bytes(T_INT);\n-  assert(is_aligned(header_size_in_bytes, BytesPerInt), \"must be aligned to int\");\n-  int header_size_in_ints = header_size_in_bytes \/ BytesPerInt;\n-  _filler_array_max_size = align_object_size((header_size_in_ints + max_len) \/ elements_per_word);\n+  int base_offset_in_ints = arrayOopDesc::base_offset_in_ints(T_INT);\n+  _filler_array_max_size = align_object_size((base_offset_in_ints + max_len) \/ elements_per_word);\n@@ -414,13 +412,1 @@\n-  \/\/ This restriction could be removed by enabling filling with multiple arrays.\n-  \/\/ If we compute that the reasonable way as\n-  \/\/    header_size + ((sizeof(jint) * max_jint) \/ HeapWordSize)\n-  \/\/ we'll overflow on the multiply, so we do the divide first.\n-  \/\/ We actually lose a little by dividing first,\n-  \/\/ but that just makes the TLAB  somewhat smaller than the biggest array,\n-  \/\/ which is fine, since we'll be able to fill that.\n-  int header_size_in_bytes = typeArrayOopDesc::base_offset_in_bytes(T_INT);\n-  assert(is_aligned(header_size_in_bytes, BytesPerInt), \"header size must align to int\");\n-  size_t max_int_size = header_size_in_bytes \/ HeapWordSize +\n-              sizeof(jint) *\n-              ((juint) max_jint \/ (size_t) HeapWordSize);\n-  return align_down(max_int_size, MinObjAlignment);\n+  return _filler_array_max_size;\n@@ -442,3 +428,3 @@\n-  payload_start = payload_start \/ HeapWordSize;\n-  Copy::fill_to_words(start + payload_start,\n-                      words - payload_start, value);\n+  int payload_start_in_words = payload_start \/ HeapWordSize;\n+  Copy::fill_to_words(start + payload_start_in_words,\n+                      words - payload_start_in_words, value);\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.cpp","additions":6,"deletions":20,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-  \/\/ Clear leading 32 bit, if necessary.\n+  \/\/ Clear leading 32 bits, if necessary.\n","filename":"src\/hotspot\/share\/gc\/z\/zObjArrayAllocator.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,2 +51,1 @@\n-  \/\/ Returns the aligned header_size_in_bytes.  This is not equivalent to\n-  \/\/ sizeof(arrayOopDesc) which should not appear in the code.\n+  \/\/ This is not equivalent to sizeof(arrayOopDesc) which should not appear in the code.\n@@ -93,1 +92,1 @@\n-    size_t typesize_in_bytes = header_size_in_bytes();\n+    size_t hs = header_size_in_bytes();\n@@ -95,2 +94,8 @@\n-                 ? align_up(typesize_in_bytes, BytesPerLong)\n-                 : typesize_in_bytes);\n+                 ? align_up(hs, BytesPerLong)\n+                 : hs);\n+  }\n+\n+  static int base_offset_in_ints(BasicType type) {\n+    int base_offset_in_bytes = arrayOopDesc::base_offset_in_bytes(type);\n+    assert(is_aligned(base_offset_in_bytes, BytesPerInt), \"must be aligned to int\");\n+    return base_offset_in_bytes \/ BytesPerInt;\n@@ -141,1 +146,1 @@\n-    int elem_size = type2aelembytes(type);\n+    const int elem_size = type2aelembytes(type);\n@@ -143,1 +148,1 @@\n-    assert(max_size_bytes % elem_size == 0, \"max_size_bytes should be aligned to element size\");\n+    assert(is_aligned(max_size_bytes, elem_size), \"max_size_bytes should be aligned to element size\");\n@@ -150,1 +155,1 @@\n-      size_t header_size_words = heap_word_size(base_offset_in_bytes(type));\n+      const size_t header_size_words = heap_word_size(base_offset_in_bytes(type));\n","filename":"src\/hotspot\/share\/oops\/arrayOop.hpp","additions":13,"deletions":8,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -53,6 +53,0 @@\n-private:\n-  \/\/ Give size of objArrayOop in bytes minus the header\n-  static size_t array_size_in_bytes(int length) {\n-    return (size_t)length * heapOopSize;\n-  }\n-\n@@ -80,1 +74,1 @@\n-    size_t asz = array_size_in_bytes(length);\n+    size_t asz = (size_t)length * heapOopSize;\n","filename":"src\/hotspot\/share\/oops\/objArrayOop.hpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -311,3 +311,2 @@\n-    const size_t hs_bytes = arrayOopDesc::base_offset_in_bytes(elem_type);\n-    \/\/ Align to next 8 bytes to avoid trashing arrays's length.\n-    const size_t aligned_hs_bytes = align_up(hs_bytes, BytesPerLong);\n+    size_t hs_bytes = arrayOopDesc::base_offset_in_bytes(elem_type);\n+    assert(is_aligned(hs_bytes, BytesPerInt), \"must be 4 byte aligned\");\n@@ -315,2 +314,3 @@\n-    if (aligned_hs_bytes > hs_bytes) {\n-      Copy::zero_to_bytes(obj + hs_bytes, aligned_hs_bytes - hs_bytes);\n+    if (!is_aligned(hs_bytes, HeapWordSize)) {\n+      *reinterpret_cast<jint*>(reinterpret_cast<char*>(obj + hs_bytes)) = 0;\n+      hs_bytes += BytesPerInt;\n@@ -318,0 +318,1 @@\n+\n@@ -319,1 +320,2 @@\n-    const size_t aligned_hs = aligned_hs_bytes \/ HeapWordSize;\n+    assert(is_aligned(hs_bytes, HeapWordSize), \"must be word aligned\");\n+    const size_t aligned_hs = hs_bytes \/ HeapWordSize;\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -83,1 +83,0 @@\n-\n","filename":"test\/hotspot\/gtest\/oops\/test_arrayOop.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}