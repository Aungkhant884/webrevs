{"files":[{"patch":"@@ -261,3 +261,2 @@\n-  int base_offset_in_ints = arrayOopDesc::base_offset_in_ints(T_INT);\n-  assert((uint32_t)base_offset_in_ints <= SIZE_MAX - max_len, \"must not overflow signed int\");\n-  _filler_array_max_size = align_object_size((base_offset_in_ints + max_len) \/ elements_per_word);\n+  _filler_array_max_size = align_object_size(filler_array_hdr_size() +\n+                                             max_len \/ elements_per_word);\n@@ -406,1 +405,19 @@\n-  return _filler_array_max_size;\n+  \/\/ This restriction could be removed by enabling filling with multiple arrays.\n+  \/\/ If we compute that the reasonable way as\n+  \/\/    header_size + ((sizeof(jint) * max_jint) \/ HeapWordSize)\n+  \/\/ we'll overflow on the multiply, so we do the divide first.\n+  \/\/ We actually lose a little by dividing first,\n+  \/\/ but that just makes the TLAB  somewhat smaller than the biggest array,\n+  \/\/ which is fine, since we'll be able to fill that.\n+  size_t max_int_size = typeArrayOopDesc::header_size(T_INT) +\n+              sizeof(jint) *\n+              ((juint) max_jint \/ (size_t) HeapWordSize);\n+  return align_down(max_int_size, MinObjAlignment);\n+}\n+\n+size_t CollectedHeap::filler_array_hdr_size() {\n+  return align_object_offset(arrayOopDesc::header_size(T_INT)); \/\/ align to Long\n+}\n+\n+size_t CollectedHeap::filler_array_min_size() {\n+  return align_object_size(filler_array_hdr_size()); \/\/ align to MinObjAlignment\n@@ -443,3 +460,2 @@\n-  const size_t payload_size_bytes = words * HeapWordSize - arrayOopDesc::base_offset_in_bytes(T_INT);\n-  assert(is_aligned(payload_size_bytes, BytesPerInt), \"must be 4-byte aligned\");\n-  const size_t len = payload_size_bytes \/ BytesPerInt;\n+  const size_t payload_size = words - filler_array_hdr_size();\n+  const size_t len = payload_size * HeapWordSize \/ sizeof(jint);\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.cpp","additions":23,"deletions":7,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -166,0 +166,4 @@\n+  \/\/ Filler object utilities.\n+  static inline size_t filler_array_hdr_size();\n+  static inline size_t filler_array_min_size();\n+\n@@ -207,3 +211,0 @@\n-  \/\/ Filler object utilities.\n-  static inline size_t filler_array_min_size();\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -49,5 +49,0 @@\n-inline size_t CollectedHeap::filler_array_min_size() {\n-  size_t header_size_words = heap_word_size(arrayOopDesc::base_offset_in_bytes(T_INT));\n-  return align_object_size(header_size_words); \/\/ align to MinObjAlignment\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.inline.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -340,1 +340,1 @@\n-  if (value \/ HeapWordSize > ThreadLocalAllocBuffer::max_size()) {\n+  if (value > (ThreadLocalAllocBuffer::max_size() * HeapWordSize)) {\n@@ -342,3 +342,3 @@\n-                        \"MinTLABSize (\" SIZE_FORMAT \" bytes) must be \"\n-                        \"less than or equal to ergonomic TLAB maximum (\" SIZE_FORMAT \" words)\\n\",\n-                        value, ThreadLocalAllocBuffer::max_size());\n+                        \"MinTLABSize (\" SIZE_FORMAT \") must be \"\n+                        \"less than or equal to ergonomic TLAB maximum (\" SIZE_FORMAT \")\\n\",\n+                        value, ThreadLocalAllocBuffer::max_size() * HeapWordSize);\n","filename":"src\/hotspot\/share\/gc\/shared\/jvmFlagConstraintsGC.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -136,0 +136,11 @@\n+  \/\/ Should only be called with constants as argument\n+  \/\/ (will not constant fold otherwise)\n+  \/\/ Returns the header size in words aligned to the requirements of the\n+  \/\/ array object type.\n+  static int header_size(BasicType type) {\n+    size_t typesize_in_bytes = header_size_in_bytes();\n+    return (int)(element_type_should_be_aligned(type)\n+      ? align_object_offset(typesize_in_bytes\/HeapWordSize)\n+      : align_up(typesize_in_bytes, HeapWordSize)\/HeapWordSize);\n+  }\n+\n@@ -144,4 +155,4 @@\n-    const int elem_size = type2aelembytes(type);\n-    const size_t max_size_bytes = align_down(SIZE_MAX - base_offset_in_bytes(type), MinObjAlignmentInBytes);\n-    assert(is_aligned(max_size_bytes, elem_size), \"max_size_bytes should be aligned to element size\");\n-    size_t max_elements_per_size_t = max_size_bytes \/ elem_size;\n+    const size_t max_element_words_per_size_t =\n+      align_down((SIZE_MAX\/HeapWordSize - header_size(type)), MinObjAlignment);\n+    const size_t max_elements_per_size_t =\n+      HeapWordSize * max_element_words_per_size_t \/ type2aelembytes(type);\n@@ -153,2 +164,1 @@\n-      const size_t header_size_words = heap_word_size(base_offset_in_bytes(type));\n-      max_elements_per_size_t = align_down(max_jint - static_cast<int>(header_size_words), MinObjAlignment);\n+      return align_down(max_jint - header_size(type), MinObjAlignment);\n@@ -156,3 +166,0 @@\n-    assert(max_elements_per_size_t <= (size_t)max_jint, \"must not overflow unsigned int\");\n-    assert(((jlong)max_elements_per_size_t * elem_size + base_offset_in_bytes(type)) \/ HeapWordSize <= (jlong)max_jint,\n-           \"total array size in words must not overflow signed int: \" SIZE_FORMAT, max_elements_per_size_t);\n","filename":"src\/hotspot\/share\/oops\/arrayOop.hpp","additions":16,"deletions":9,"binary":false,"changes":25,"status":"modified"}]}