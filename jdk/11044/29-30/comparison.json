{"files":[{"patch":"@@ -179,0 +179,4 @@\n+    if (!is_aligned(arrayOopDesc::header_size_in_bytes(), BytesPerLong)) {\n+      assert(is_aligned(arrayOopDesc::header_size_in_bytes(), BytesPerInt), \"must be 4-byte aligned\");\n+      strw(zr, Address(obj, arrayOopDesc::header_size_in_bytes()));\n+    }\n@@ -198,8 +202,0 @@\n-  \/\/ Zero first 4 bytes, if start offset is not word aligned.\n-  int start_offset = hdr_size_in_bytes;\n-  if (!is_aligned(start_offset, BytesPerWord)) {\n-    assert(is_aligned(start_offset, BytesPerInt), \"must be 32-bit-aligned\");\n-    strw(zr, Address(obj, start_offset));\n-    start_offset += BytesPerInt;\n-  }\n-\n@@ -208,1 +204,3 @@\n-  lea(t1, Address(obj, start_offset));\n+  \/\/ We align the hdr_size_in_bytes up to 8 bytes here because we clear the\n+  \/\/ possible alignment gap in initialize_header().\n+  lea(t1, Address(obj, align_up(hdr_size_in_bytes, BytesPerLong)));\n@@ -232,1 +230,0 @@\n-  \/\/ TODO: Initialization code should deal with int-aligned header size, and skip the klass-gap clearing.\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.cpp","additions":7,"deletions":10,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -181,1 +181,1 @@\n-  \/\/ We align up the hdr_size_in_bytes to 8 bytes here because we clear the\n+  \/\/ We align the hdr_size_in_bytes up to 8 bytes here because we clear the\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}