{"files":[{"patch":"@@ -221,3 +221,1 @@\n-  \/\/ We align the hdr_size_in_bytes up to 8 bytes here because we clear the\n-  \/\/ possible alignment gap in initialize_header().\n-  lea(t1, Address(obj, align_up(hdr_size_in_bytes, BytesPerLong)));\n+  lea(t1, Address(obj, hdr_size_in_bytes));\n@@ -247,1 +245,1 @@\n-  const int hdr_size_in_bytes = align_up(instanceOopDesc::base_offset_in_bytes(), HeapWordSize);\n+  const int hdr_size_in_bytes = instanceOopDesc::header_size() * HeapWordSize;\n@@ -302,1 +300,4 @@\n-  initialize_body(obj, arr_size, base_offset_in_bytes, t1, t2);\n+  \/\/ We align-up the header size to word-size, because we clear the\n+  \/\/ possible alignment gap in initialize_header().\n+  int hdr_size = align_up(base_offset_in_bytes, BytesPerWord);\n+  initialize_body(obj, arr_size, hdr_size, t1, t2);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.cpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -427,10 +427,2 @@\n-  int payload_offset = arrayOopDesc::base_offset_in_bytes(T_INT);\n-  if (!is_aligned(payload_offset, HeapWordSize)) {\n-    assert(is_aligned(payload_offset, BytesPerInt), \"must be 4-byte aligned\");\n-    *(reinterpret_cast<juint*>(start) + (payload_offset \/ BytesPerInt)) = value;\n-    payload_offset += BytesPerInt;\n-  }\n-  assert(is_aligned(payload_offset, HeapWordSize), \"payload start must be heap word aligned\");\n-  int payload_offset_in_words = payload_offset \/ HeapWordSize;\n-  Copy::fill_to_words(start + payload_offset_in_words,\n-                      words - payload_offset_in_words, value);\n+  Copy::fill_to_words(start + filler_array_hdr_size(),\n+                      words - filler_array_hdr_size(), value);\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.cpp","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -49,0 +49,16 @@\n+public:\n+  \/\/ Header size computation.\n+  \/\/ The header is considered the oop part of this type plus the length.\n+  \/\/ This is not equivalent to sizeof(arrayOopDesc) which should not appear in the code.\n+  static int header_size_in_bytes() {\n+    size_t hs = length_offset_in_bytes() + sizeof(int);\n+#ifdef ASSERT\n+    \/\/ make sure it isn't called before UseCompressedOops is initialized.\n+    static size_t arrayoopdesc_hs = 0;\n+    if (arrayoopdesc_hs == 0) arrayoopdesc_hs = hs;\n+    assert(arrayoopdesc_hs == hs, \"header size can't change\");\n+#endif \/\/ ASSERT\n+    return (int)hs;\n+  }\n+\n+private:\n@@ -76,14 +92,0 @@\n-  \/\/ Header size computation.\n-  \/\/ The header is considered the oop part of this type plus the length.\n-  \/\/ This is not equivalent to sizeof(arrayOopDesc) which should not appear in the code.\n-  static int header_size_in_bytes() {\n-    size_t hs = length_offset_in_bytes() + sizeof(int);\n-#ifdef ASSERT\n-    \/\/ make sure it isn't called before UseCompressedOops is initialized.\n-    static size_t arrayoopdesc_hs = 0;\n-    if (arrayoopdesc_hs == 0) arrayoopdesc_hs = hs;\n-    assert(arrayoopdesc_hs == hs, \"header size can't change\");\n-#endif \/\/ ASSERT\n-    return (int)hs;\n-  }\n-\n@@ -96,6 +98,0 @@\n-  static int base_offset_in_ints(BasicType type) {\n-    int base_offset_in_bytes = arrayOopDesc::base_offset_in_bytes(type);\n-    assert(is_aligned(base_offset_in_bytes, BytesPerInt), \"must be aligned to int\");\n-    return base_offset_in_bytes \/ BytesPerInt;\n-  }\n-\n@@ -147,1 +143,1 @@\n-  \/\/ Return the maximum number of elements of an array of BasicType.  The length can passed\n+  \/\/ Return the maximum length of an array of BasicType.  The length can passed\n@@ -168,0 +164,1 @@\n+\n","filename":"src\/hotspot\/share\/oops\/arrayOop.hpp","additions":18,"deletions":21,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-  ( arrayOopDesc::base_offset_in_bytes(T_DOUBLE) \\\n+  ( arrayOopDesc::header_size(T_DOUBLE) * HeapWordSize \\\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-    \/\/ Use only if top > start && used_words <= max_tlab_size_words.\n+    \/\/ Use only if top > start && used_bytes <= max_tlab_size_bytes.\n@@ -48,3 +48,3 @@\n-    const size_t used_words = pointer_delta(top, start);\n-    if (used_words <= ThreadLocalAllocBuffer::max_size()) {\n-      \/\/ Comparing used_words with the maximum allowed size will ensure\n+    const size_t used_bytes = pointer_delta(top, start, 1);\n+    if (used_bytes <= ThreadLocalAllocBuffer::max_size_in_bytes()) {\n+      \/\/ Comparing used_bytes with the maximum allowed size will ensure\n@@ -55,1 +55,1 @@\n-      return allocated_bytes + used_words * HeapWordSize;\n+      return allocated_bytes + used_bytes;\n","filename":"src\/hotspot\/share\/runtime\/thread.inline.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/hotspot\/gtest\/oops\/test_arrayOop.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/hotspot\/gtest\/oops\/test_objArrayOop.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022 Amazon.com Inc. or its affiliates. All rights reserved.\n+ * Copyright Amazon.com Inc. or its affiliates. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/gtest\/ObjArrayTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}