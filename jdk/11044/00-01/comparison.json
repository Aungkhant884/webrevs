{"files":[{"patch":"@@ -200,0 +200,1 @@\n+    assert(is_aligned(hdr_size_in_bytes, BytesPerInt), \"must be 32-bit-aligned\");\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -182,0 +182,1 @@\n+    assert(is_aligned(hdr_size_in_bytes, BytesPerInt), \"must be 32-bit-aligned\");\n","filename":"src\/hotspot\/cpu\/riscv\/c1_MacroAssembler_riscv.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4122,0 +4122,12 @@\n+\n+  \/\/ note: for the remaining code to work, index must be a multiple of BytesPerInt\n+#ifdef ASSERT\n+  {\n+    Label L;\n+    testptr(length_in_bytes, BytesPerInt - 1);\n+    jcc(Assembler::zero, L);\n+    stop(\"length must be a multiple of BytesPerInt\");\n+    bind(L);\n+  }\n+#endif\n+\n@@ -4131,0 +4143,1 @@\n+    assert(is_aligned(offset_in_bytes, BytesPerInt), \"must be 32-bit-aligned\");\n@@ -4135,1 +4148,1 @@\n-  assert((offset_in_bytes & (BytesPerWord - 1)) == 0, \"offset must be a multiple of BytesPerWord\");\n+  assert(is_aligned(offset_in_bytes, BytesPerWord), \"offset must be a multiple of BytesPerWord\");\n@@ -4141,10 +4154,0 @@\n-  \/\/ note: for the remaining code to work, index must be a multiple of BytesPerWord\n-#ifdef ASSERT\n-  {\n-    Label L;\n-    testptr(length_in_bytes, BytesPerWord - 1);\n-    jcc(Assembler::zero, L);\n-    stop(\"length must be a multiple of BytesPerWord\");\n-    bind(L);\n-  }\n-#endif\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":14,"deletions":11,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -112,1 +112,1 @@\n-              touched_words = MIN2((size_t)align_object_size(align_up(typeArrayOopDesc::base_offset_in_bytes(T_INT), HeapWordSize) \/ HeapWordSize),\n+              touched_words = MIN2((size_t)align_object_size(heap_word_size(typeArrayOopDesc::base_offset_in_bytes(T_INT))),\n","filename":"src\/hotspot\/share\/gc\/parallel\/mutableNUMASpace.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -257,2 +257,2 @@\n-  assert(header_size_in_bytes % sizeof(jint) == 0, \"must be aligned to int\");\n-  int header_size_in_ints = header_size_in_bytes \/ sizeof(jint);\n+  assert(is_aligned(header_size_in_bytes, BytesPerInt), \"must be aligned to int\");\n+  int header_size_in_ints = header_size_in_bytes \/ BytesPerInt;\n@@ -422,1 +422,1 @@\n-  assert(header_size_in_bytes % sizeof(jint) == 0, \"header size must align to int\");\n+  assert(is_aligned(header_size_in_bytes, BytesPerInt), \"header size must align to int\");\n@@ -430,1 +430,1 @@\n-  int aligned_header_size_words = align_up(arrayOopDesc::base_offset_in_bytes(T_INT), HeapWordSize) \/ HeapWordSize;\n+  int aligned_header_size_words = heap_word_size(arrayOopDesc::base_offset_in_bytes(T_INT));\n@@ -435,1 +435,8 @@\n-  int payload_start = align_up(arrayOopDesc::base_offset_in_bytes(T_INT), HeapWordSize) \/ HeapWordSize;\n+  int payload_start = arrayOopDesc::base_offset_in_bytes(T_INT);\n+  if (!is_aligned(payload_start, BytesPerWord)) {\n+    assert(is_aligned(payload_start, BytesPerInt), \"base offset must be 32-bit-aligned\");\n+    *(reinterpret_cast<juint*>(start) + (payload_start \/ BytesPerInt)) = value;\n+    payload_start += BytesPerInt;\n+  }\n+  assert(is_aligned(payload_start, HeapWordSize), \"payload start must be heap word aligned\");\n+  payload_start = payload_start \/ HeapWordSize;\n@@ -462,2 +469,2 @@\n-  assert(payload_size_bytes % sizeof(jint) == 0, \"must be int aligned\");\n-  const size_t len = payload_size_bytes \/ sizeof(jint);\n+  assert(is_aligned(payload_size_bytes, BytesPerInt), \"must be int aligned\");\n+  const size_t len = payload_size_bytes \/ BytesPerInt;\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.cpp","additions":14,"deletions":7,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -425,1 +425,1 @@\n-  const size_t hs = align_up(arrayOopDesc::base_offset_in_bytes(array_klass->element_type()), HeapWordSize) \/ HeapWordSize;\n+  const size_t hs = heap_word_size(arrayOopDesc::base_offset_in_bytes(array_klass->element_type()));\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-  const size_t segment_max = 64 * K;\n+  const size_t segment_max = ZUtils::bytes_to_words(64 * K);\n@@ -53,4 +53,4 @@\n-  const size_t header = arrayOopDesc::base_offset_in_bytes(element_type);\n-  size_t byte_size = _word_size * BytesPerWord;\n-  const size_t payload_size = byte_size - header;\n-\n+  int base_offset = arrayOopDesc::base_offset_in_bytes(element_type);\n+  assert(is_aligned(base_offset, HeapWordSize), \"obj array base offset should be word-aligned\");\n+  const size_t header = heap_word_size(base_offset);\n+  const size_t payload_size = _word_size - header;\n@@ -80,1 +80,1 @@\n-    char* const start = ((char*)mem) + header + processed;\n+    HeapWord* const start = (HeapWord*)(mem + header + processed);\n@@ -85,1 +85,1 @@\n-    Copy::zero_to_bytes(start, segment_size);\n+    Copy::zero_to_words(start, segment_size);\n","filename":"src\/hotspot\/share\/gc\/z\/zObjArrayAllocator.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -128,1 +128,1 @@\n-  check_array_allocation_length(length, arrayOopDesc::max_array_length(T_ARRAY), CHECK_NULL);\n+  check_array_allocation_length(length, arrayOopDesc::max_array_length(element_type()), CHECK_NULL);\n","filename":"src\/hotspot\/share\/oops\/arrayKlass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -53,1 +54,1 @@\n-  size_t hs = length_offset_in_bytes() + sizeof(int);\n+    size_t hs = length_offset_in_bytes() + sizeof(int);\n@@ -92,1 +93,1 @@\n-  size_t typesize_in_bytes = header_size_in_bytes();\n+    size_t typesize_in_bytes = header_size_in_bytes();\n@@ -132,1 +133,1 @@\n-  \/\/ Return the maximum length of an array of BasicType.  The length can passed\n+  \/\/ Return the maximum length (num elements) of an array of BasicType.  The length can passed\n@@ -140,0 +141,1 @@\n+    int elem_size = type2aelembytes(type);\n@@ -141,1 +143,2 @@\n-    const size_t max_elements_per_size_t = max_size_bytes \/ type2aelembytes(type);\n+    assert(max_size_bytes % elem_size == 0, \"max_size_bytes should be aligned to element size\");\n+    const size_t max_elements_per_size_t = max_size_bytes \/ elem_size;\n@@ -147,2 +150,11 @@\n-      int header_size_words = align_up(base_offset_in_bytes(type), HeapWordSize) \/ HeapWordSize;\n-      return align_down(max_jint - header_size_words, MinObjAlignment);\n+\n+      \/\/ How many words does each element take? For elements smaller than a full\n+      \/\/ word this will be 0 - which is correct because for such smaller elements\n+      \/\/ we would not trigger int overflow in word-sized calculations.\n+      int words_per_elem    = elem_size \/ HeapWordSize;\n+      \/\/ How many words does the header need? It's ok to ignore the alignment,\n+      \/\/ because elements are always aligned to their respective sizes, and\n+      \/\/ we really only care about (at least) word-sized elements here.\n+      int header_size_words = heap_word_size(base_offset_in_bytes(type));\n+      int header_size_elems = header_size_words * words_per_elem;\n+      return max_jint - header_size_elems;\n","filename":"src\/hotspot\/share\/oops\/arrayOop.hpp","additions":18,"deletions":6,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-                Object[] oa = new Object[Integer.MAX_VALUE];\n+                long[] oa = new long[Integer.MAX_VALUE];\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/TestCrashOnOutOfMemoryError.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-                Object[] oa = new Object[Integer.MAX_VALUE];\n+                long[] oa = new long[Integer.MAX_VALUE];\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/TestExitOnOutOfMemoryError.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-            Object[] oa = new Object[Integer.MAX_VALUE];\n+            long[] oa = new long[Integer.MAX_VALUE];\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/TestOnOutOfMemoryError.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}