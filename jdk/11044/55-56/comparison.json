{"files":[{"patch":"@@ -182,8 +182,0 @@\n-#ifdef _LP64\n-    if (!is_aligned(arrayOopDesc::header_size_in_bytes(), BytesPerWord)) {\n-      assert(is_aligned(arrayOopDesc::header_size_in_bytes(), BytesPerInt), \"must be 4-byte aligned\");\n-      movl(Address(obj, arrayOopDesc::header_size_in_bytes()), 0);\n-    }\n-#else\n-    assert(is_aligned(arrayOopDesc::header_size_in_bytes(), BytesPerInt), \"must be 4-byte aligned\");\n-#endif\n@@ -294,0 +286,13 @@\n+  \/\/ Clear leading 4 bytes, if necessary.\n+  \/\/ TODO: This could perhaps go into initialize_body() and also clear the leading 4 bytes\n+  \/\/ for non-array objects, thereby replacing the klass-gap clearing code in initialize_header().\n+  int base_offset = base_offset_in_bytes;\n+#ifdef _LP64\n+  if (!is_aligned(base_offset, BytesPerWord)) {\n+    assert(is_aligned(base_offset, BytesPerInt), \"must be 4-byte aligned\");\n+    movl(Address(obj, base_offset), 0);\n+    base_offset += BytesPerInt;\n+  }\n+#endif\n+  assert(is_aligned(base_offset, BytesPerWord), \"must be word aligned\");\n+\n@@ -296,4 +301,1 @@\n-  \/\/ We align-up the header size to word-size, because we clear the\n-  \/\/ possible alignment gap in initialize_header().\n-  int hdr_size = align_up(base_offset_in_bytes, BytesPerWord);\n-  initialize_body(obj, arr_size, hdr_size, len_zero);\n+  initialize_body(obj, arr_size, base_offset, len_zero);\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.cpp","additions":14,"deletions":12,"binary":false,"changes":26,"status":"modified"}]}