{"files":[{"patch":"@@ -974,1 +974,1 @@\n-                      align_up(arrayOopDesc::header_size_in_bytes(), HeapWordSize) \/ HeapWordSize,\n+                      arrayOopDesc::base_offset_in_bytes(),\n","filename":"src\/hotspot\/cpu\/arm\/c1_LIRAssembler_arm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -184,4 +184,0 @@\n-    if (!is_aligned(arrayOopDesc::header_size_in_bytes(), BytesPerWord)) {\n-      assert(is_aligned(arrayOopDesc::header_size_in_bytes(), BytesPerInt), \"must be 4-byte aligned\");\n-      sw(zr, Address(obj, arrayOopDesc::header_size_in_bytes()));\n-    }\n@@ -307,0 +303,11 @@\n+  \/\/ Clear leading 4 bytes, if necessary.\n+  \/\/ TODO: This could perhaps go into initialize_body() and also clear the leading 4 bytes\n+  \/\/ for non-array objects, thereby replacing the klass-gap clearing code in initialize_header().\n+  int base_offset = base_offset_in_bytes;\n+  if (!is_aligned(base_offset, BytesPerWord)) {\n+    assert(is_aligned(base_offset, BytesPerInt), \"must be 4-byte aligned\");\n+    sw(zr, Address(obj, base_offset));\n+    base_offset += BytesPerInt;\n+  }\n+  assert(is_aligned(base_offset, BytesPerWord), \"must be word-aligned\");\n+\n@@ -309,4 +316,1 @@\n-  \/\/ We align-up the header size to word-size, because we clear the\n-  \/\/ possible alignment gap in initialize_header().\n-  int hdr_size = align_up(base_offset_in_bytes, BytesPerWord);\n-  initialize_body(obj, arr_size, hdr_size, len_zero);\n+  initialize_body(obj, arr_size, base_offset, len_zero);\n","filename":"src\/hotspot\/cpu\/riscv\/c1_MacroAssembler_riscv.cpp","additions":12,"deletions":8,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -403,2 +403,0 @@\n-\/\/ Should only be called with constants as argument\n-\/\/ (will not constant fold otherwise)\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"}]}