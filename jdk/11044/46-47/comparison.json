{"files":[{"patch":"@@ -53,1 +53,11 @@\n-  const size_t header = arrayOopDesc::header_size(element_type);\n+\n+  \/\/ Clear leading 32 bits, if necessary.\n+  int base_offset = arrayOopDesc::base_offset_in_bytes(element_type);\n+  if (!is_aligned(base_offset, HeapWordSize)) {\n+    assert(is_aligned(base_offset, BytesPerInt), \"array base must be 32 bit aligned\");\n+    *reinterpret_cast<jint*>(reinterpret_cast<char*>(mem) + base_offset) = 0;\n+    base_offset += BytesPerInt;\n+  }\n+  assert(is_aligned(base_offset, HeapWordSize), \"remaining array base must be 64 bit aligned\");\n+\n+  const size_t header = heap_word_size(base_offset);\n","filename":"src\/hotspot\/share\/gc\/x\/xObjArrayAllocator.cpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -53,1 +53,11 @@\n-  const size_t header = arrayOopDesc::header_size(element_type);\n+\n+  \/\/ Clear leading 32 bits, if necessary.\n+  int base_offset = arrayOopDesc::base_offset_in_bytes(element_type);\n+  if (!is_aligned(base_offset, HeapWordSize)) {\n+    assert(is_aligned(base_offset, BytesPerInt), \"array base must be 32 bit aligned\");\n+    *reinterpret_cast<jint*>(reinterpret_cast<char*>(mem) + base_offset) = 0;\n+    base_offset += BytesPerInt;\n+  }\n+  assert(is_aligned(base_offset, HeapWordSize), \"remaining array base must be 64 bit aligned\");\n+\n+  const size_t header = heap_word_size(base_offset);\n","filename":"src\/hotspot\/share\/gc\/z\/zObjArrayAllocator.cpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"}]}