{"files":[{"patch":"@@ -628,1 +628,0 @@\n-#ifdef ASSERT\n@@ -630,1 +629,0 @@\n-#endif\n","filename":"src\/hotspot\/share\/opto\/block.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -458,2 +458,1 @@\n-static Block* raise_LCA_above_marks(Block* LCA, node_idx_t mark, Block* early, const PhaseCFG* cfg,\n-                                     Block_List* visited_list) {\n+static Block* raise_LCA_above_marks(Block* LCA, node_idx_t mark, Block* early, const PhaseCFG* cfg) {\n@@ -487,1 +486,0 @@\n-    visited_list->push(mid);\n@@ -545,4 +543,1 @@\n-#ifdef ASSERT\n-\/\/ This function is used by insert_anti_dependences to find unrelated loads\n-\/\/ stores(but aliases into same) in non-null, null blocks.\n-\/\/ and for the same reasons it doesn't requires an anti-dependence edge.\n+\/\/ This function is used by insert_anti_dependences to find unrelated loads for stores in implicit null checks.\n@@ -554,4 +549,8 @@\n-  \/\/ null block is only reached if 'store' tries to write to null.\n-  Node* store_null_check = store->find_out_with(Op_MachNullCheck);\n-  if (store_null_check != NULL) {\n-    Node* if_true = store_null_check->find_out_with(Op_IfTrue);\n+  \/\/ null block is only reached if 'store' tries to write to null object and\n+  \/\/ 'load' read from non-null object (there is preceding check for that)\n+  \/\/ These objects can't be the same.\n+  Block* store_block = get_block_for_node(store);\n+  Block* load_block = get_block_for_node(load);\n+  Node* end = store_block->end();\n+  if (end->is_MachNullCheck() && (end->in(1) == store) && store_block->dominates(load_block) ) {\n+    Node* if_true = end->find_out_with(Op_IfTrue);\n@@ -561,1 +560,1 @@\n-    return get_block_for_node(null_block_region)->dominates(get_block_for_node(load));\n+    return get_block_for_node(null_block_region) == load_block;\n@@ -565,14 +564,0 @@\n-#endif\n-\n-class Raise_LCA_visited_List : public StackObj {\n-  Block_List* _reset_list;\n- public:\n-  Raise_LCA_visited_List(Block_List* reset_list) :\n-    _reset_list(reset_list) {}\n-  ~Raise_LCA_visited_List() {\n-    while (_reset_list->size() > 0) {\n-      Block* reset_block = _reset_list->pop();\n-      reset_block->set_raise_LCA_visited(0);\n-    }\n-  }\n-};\n@@ -648,6 +633,0 @@\n-\n-  \/\/ Cases falling under unrelated_load_in_store_null_block can make\n-  \/\/ raise_LCA_above_marks in inconsistent state, so always reset the\n-  \/\/ visited blocks after use.\n-  Block_List raise_LCA_visited_list;\n-  Raise_LCA_visited_List reset_LCA_visited(&raise_LCA_visited_list);\n@@ -805,1 +784,1 @@\n-      if (LCA != early) {\n+      if (LCA != early && !unrelated_load_in_store_null_block(store, load)) {\n@@ -843,1 +822,1 @@\n-    LCA = raise_LCA_above_marks(LCA, load->_idx, early, this, &raise_LCA_visited_list);\n+    LCA = raise_LCA_above_marks(LCA, load->_idx, early, this);\n@@ -857,1 +836,1 @@\n-          assert(store->find_edge(load) != -1 || unrelated_load_in_store_null_block(store, load), \"missing precedence edge\");\n+          assert(store->find_edge(load) != -1, \"missing precedence edge\");\n","filename":"src\/hotspot\/share\/opto\/gcm.cpp","additions":14,"deletions":35,"binary":false,"changes":49,"status":"modified"}]}