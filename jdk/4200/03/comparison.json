{"files":[{"patch":"@@ -628,0 +628,4 @@\n+#ifdef ASSERT\n+  bool unrelated_load_in_store_null_block(Node* store, Node* load);\n+#endif\n+\n","filename":"src\/hotspot\/share\/opto\/block.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -458,1 +458,2 @@\n-static Block* raise_LCA_above_marks(Block* LCA, node_idx_t mark, Block* early, const PhaseCFG* cfg) {\n+static Block* raise_LCA_above_marks(Block* LCA, node_idx_t mark, Block* early, const PhaseCFG* cfg,\n+                                     Block_List* visited_list) {\n@@ -486,0 +487,1 @@\n+    visited_list->push(mid);\n@@ -543,0 +545,35 @@\n+#ifdef ASSERT\n+\/\/ This function is used by insert_anti_dependences to find unrelated loads\n+\/\/ stores(but aliases into same) in non-null, null blocks.\n+\/\/ and for the same reasons it doesn't requires an anti-dependence edge.\n+bool PhaseCFG::unrelated_load_in_store_null_block(Node* store, Node* load) {\n+  \/\/ We expect an anti-dependence edge from 'load' to 'store', except when\n+  \/\/ implicit_null_check() has hoisted 'store' above its early block to\n+  \/\/ perform an implicit null check, and 'load' is placed in the null\n+  \/\/ block. In this case it is safe to ignore the anti-dependence, as the\n+  \/\/ null block is only reached if 'store' tries to write to null.\n+  Node* store_null_check = store->find_out_with(Op_MachNullCheck);\n+  if (store_null_check != NULL) {\n+    Node* if_true = store_null_check->find_out_with(Op_IfTrue);\n+    assert(if_true != NULL, \"null check without null projection\");\n+    Node* null_block_region = if_true->find_out_with(Op_Region);\n+    assert(null_block_region != NULL, \"null check without null region\");\n+    return get_block_for_node(null_block_region)->dominates(get_block_for_node(load));\n+  }\n+  return false;\n+}\n+#endif\n+\n+class Raise_LCA_visited_List : public StackObj {\n+  Block_List* _reset_list;\n+ public:\n+  Raise_LCA_visited_List(Block_List* reset_list) :\n+    _reset_list(reset_list) {}\n+  ~Raise_LCA_visited_List() {\n+    while (_reset_list->size() > 0) {\n+      Block* reset_block = _reset_list->pop();\n+      reset_block->set_raise_LCA_visited(0);\n+    }\n+  }\n+};\n+\n@@ -611,0 +648,6 @@\n+\n+  \/\/ Cases falling under unrelated_load_in_store_null_block can make\n+  \/\/ raise_LCA_above_marks in inconsistent state, so always reset the\n+  \/\/ visited blocks after use.\n+  Block_List raise_LCA_visited_list;\n+  Raise_LCA_visited_List reset_LCA_visited(&raise_LCA_visited_list);\n@@ -773,17 +816,1 @@\n-#ifdef ASSERT\n-        \/\/ We expect an anti-dependence edge from 'load' to 'store', except when\n-        \/\/ implicit_null_check() has hoisted 'store' above its early block to\n-        \/\/ perform an implicit null check, and 'load' is placed in the null\n-        \/\/ block. In this case it is safe to ignore the anti-dependence, as the\n-        \/\/ null block is only reached if 'store' tries to write to null.\n-        Block* store_null_block = NULL;\n-        Node* store_null_check = store->find_out_with(Op_MachNullCheck);\n-        if (store_null_check != NULL) {\n-          Node* if_true = store_null_check->find_out_with(Op_IfTrue);\n-          assert(if_true != NULL, \"null check without null projection\");\n-          Node* null_block_region = if_true->find_out_with(Op_Region);\n-          assert(null_block_region != NULL, \"null check without null region\");\n-          store_null_block = get_block_for_node(null_block_region);\n-        }\n-#endif\n-        assert(LCA == store_null_block || store->find_edge(load) != -1,\n+        assert(store->find_edge(load) != -1 || unrelated_load_in_store_null_block(store, load),\n@@ -816,1 +843,1 @@\n-    LCA = raise_LCA_above_marks(LCA, load->_idx, early, this);\n+    LCA = raise_LCA_above_marks(LCA, load->_idx, early, this, &raise_LCA_visited_list);\n@@ -830,1 +857,1 @@\n-          assert(store->find_edge(load) != -1, \"missing precedence edge\");\n+          assert(store->find_edge(load) != -1 || unrelated_load_in_store_null_block(store, load), \"missing precedence edge\");\n","filename":"src\/hotspot\/share\/opto\/gcm.cpp","additions":47,"deletions":20,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @bug 8261730\n+ * @bug 8261730 8265132\n@@ -43,0 +43,1 @@\n+    private static MyInteger[] global = {new MyInteger()};\n@@ -44,1 +45,1 @@\n-    static void setFooToZero() {\n+    static void test1() {\n@@ -55,0 +56,6 @@\n+    static void test2(MyInteger a, MyInteger b) {\n+        global[0].val = a.val + b.val * 31;\n+        global[0].val = 0;\n+        return;\n+    }\n+\n@@ -57,1 +64,5 @@\n-            setFooToZero();\n+            test1();\n+        }\n+\n+        for (int i = 0; i < 10_000; i++) {\n+            test2(new MyInteger(), new MyInteger());\n@@ -59,0 +70,1 @@\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/uncommontrap\/TestNullCheckAntiDependence.java","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"}]}