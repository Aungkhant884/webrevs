{"files":[{"patch":"@@ -628,0 +628,4 @@\n+#ifdef ASSERT\n+  bool unrelated_load_in_store_null_block(Node* store, Node* load);\n+#endif\n+\n","filename":"src\/hotspot\/share\/opto\/block.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -543,0 +543,20 @@\n+\/\/ This function is used by insert_anti_dependences to find unrelated loads\n+\/\/ stores(but aliases into same) in non-null, null blocks.\n+\/\/ and for the same reasons it doesn't requires an anti-dependence edge.\n+bool PhaseCFG::unrelated_load_in_store_null_block(Node* store, Node* load) {\n+  \/\/ We expect an anti-dependence edge from 'load' to 'store', except when\n+  \/\/ implicit_null_check() has hoisted 'store' above its early block to\n+  \/\/ perform an implicit null check, and 'load' is placed in the null\n+  \/\/ block. In this case it is safe to ignore the anti-dependence, as the\n+  \/\/ null block is only reached if 'store' tries to write to null.\n+  Node* store_null_check = store->find_out_with(Op_MachNullCheck);\n+  if (store_null_check != NULL) {\n+    Node* if_true = store_null_check->find_out_with(Op_IfTrue);\n+    assert(if_true != NULL, \"null check without null projection\");\n+    Node* null_block_region = if_true->find_out_with(Op_Region);\n+    assert(null_block_region != NULL, \"null check without null region\");\n+    return get_block_for_node(null_block_region)->dominates(get_block_for_node(load));\n+  }\n+  return false;\n+}\n+\n@@ -762,1 +782,1 @@\n-      if (LCA != early) {\n+      if (LCA != early && !unrelated_load_in_store_null_block(store, load)) {\n@@ -773,17 +793,1 @@\n-#ifdef ASSERT\n-        \/\/ We expect an anti-dependence edge from 'load' to 'store', except when\n-        \/\/ implicit_null_check() has hoisted 'store' above its early block to\n-        \/\/ perform an implicit null check, and 'load' is placed in the null\n-        \/\/ block. In this case it is safe to ignore the anti-dependence, as the\n-        \/\/ null block is only reached if 'store' tries to write to null.\n-        Block* store_null_block = NULL;\n-        Node* store_null_check = store->find_out_with(Op_MachNullCheck);\n-        if (store_null_check != NULL) {\n-          Node* if_true = store_null_check->find_out_with(Op_IfTrue);\n-          assert(if_true != NULL, \"null check without null projection\");\n-          Node* null_block_region = if_true->find_out_with(Op_Region);\n-          assert(null_block_region != NULL, \"null check without null region\");\n-          store_null_block = get_block_for_node(null_block_region);\n-        }\n-#endif\n-        assert(LCA == store_null_block || store->find_edge(load) != -1,\n+        assert(store->find_edge(load) != -1 || unrelated_load_in_store_null_block(store, load),\n","filename":"src\/hotspot\/share\/opto\/gcm.cpp","additions":22,"deletions":18,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @bug 8261730\n+ * @bug 8261730 8265132\n@@ -43,0 +43,1 @@\n+    private static MyInteger[] global = {new MyInteger()};\n@@ -44,1 +45,1 @@\n-    static void setFooToZero() {\n+    static void test1() {\n@@ -55,0 +56,6 @@\n+    static void test2(MyInteger a, MyInteger b) {\n+        global[0].val = a.val + b.val * 31;\n+        global[0].val = 0;\n+        return;\n+    }\n+\n@@ -57,1 +64,5 @@\n-            setFooToZero();\n+            test1();\n+        }\n+\n+        for (int i = 0; i < 10_000; i++) {\n+            test2(new MyInteger(), new MyInteger());\n@@ -59,0 +70,1 @@\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/uncommontrap\/TestNullCheckAntiDependence.java","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"}]}