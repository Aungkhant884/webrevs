{"files":[{"patch":"@@ -199,1 +199,1 @@\n-                    return Class.forName(Util.toBinaryName(cd.descriptorString()), false, loader);\n+                    return Class.forName(Util.toBinaryName(cd), false, loader);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/ClassHierarchyResolver.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -123,1 +123,2 @@\n-        \/\/this instance should leak out, appears only in cache in order to utilize Map.computeIfAbsent\n+        \/\/ this instance should not leak out, appears only in cache in order to utilize Map.computeIfAbsent\n+        \/\/ is already an invalid combination, so it can be compared with equals or as value class safely\n@@ -224,1 +225,1 @@\n-                    return Class.forName(Util.toBinaryName(cd.descriptorString()), false, ClassLoader.getSystemClassLoader());\n+                    return Class.forName(Util.toBinaryName(cd), false, ClassLoader.getSystemClassLoader());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassHierarchyImpl.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -57,4 +57,0 @@\n-    public static String arrayOf(CharSequence s) {\n-        return \"[\" + s;\n-    }\n-\n@@ -88,7 +84,3 @@\n-     * Convert a descriptor of classes or interfaces or arrays, or an internal\n-     * name of a class or interface, into a fully qualified binary name, that can\n-     * be resolved by {@link Class#forName(String) Class::forName}. Primitive type\n-     * descriptors should never be passed into this method.\n-     *\n-     * @param descOrInternalName a descriptor or internal name\n-     * @return the fully qualified binary name\n+     * Converts a descriptor of classes or interfaces into\n+     * a binary name. Rejects primitive types or arrays.\n+     * This is an inverse of {@link ClassDesc#of(String)}.\n@@ -96,48 +88,2 @@\n-    public static String toBinaryName(String descOrInternalName) {\n-        if (descOrInternalName.startsWith(\"L\")) {\n-            \/\/ descriptors of classes or interfaces\n-            if (descOrInternalName.length() <= 2 || !descOrInternalName.endsWith(\";\")) {\n-                throw new IllegalArgumentException(descOrInternalName);\n-            }\n-            return descOrInternalName.substring(1, descOrInternalName.length() - 1).replace('\/', '.');\n-        } else {\n-            \/\/ arrays, classes or interfaces' internal names\n-            return descOrInternalName.replace('\/', '.');\n-        }\n-    }\n-\n-    public static Iterator<String> parameterTypes(String s) {\n-        \/\/TODO: gracefully non-method types\n-        return new Iterator<>() {\n-            int ch = 1;\n-\n-            @Override\n-            public boolean hasNext() {\n-                return s.charAt(ch) != ')';\n-            }\n-\n-            @Override\n-            public String next() {\n-                char curr = s.charAt(ch);\n-                switch (curr) {\n-                    case 'C', 'B', 'S', 'I', 'J', 'F', 'D', 'Z':\n-                        ch++;\n-                        return String.valueOf(curr);\n-                    case '[':\n-                        ch++;\n-                        return \"[\" + next();\n-                    case 'L': {\n-                        int start = ch;\n-                        while (s.charAt(++ch) != ';') { }\n-                        ++ch;\n-                        return s.substring(start, ch);\n-                    }\n-                    default:\n-                        throw new AssertionError(\"cannot parse string: \" + s);\n-                }\n-            }\n-        };\n-    }\n-\n-    public static String returnDescriptor(String s) {\n-        return s.substring(s.indexOf(')') + 1);\n+    public static String toBinaryName(ClassDesc cd) {\n+        return toInternalName(cd).replace('\/', '.');\n@@ -148,4 +94,3 @@\n-        return switch (desc.charAt(0)) {\n-            case 'L' -> desc.substring(1, desc.length() - 1);\n-            default -> throw new IllegalArgumentException(desc);\n-        };\n+        if (desc.charAt(0) == 'L')\n+            return desc.substring(1, desc.length() - 1);\n+        throw new IllegalArgumentException(desc);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/Util.java","additions":8,"deletions":63,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -49,2 +49,0 @@\n-            int[][].class,\n-            Object[].class,\n@@ -53,7 +51,3 @@\n-        if (!type.isArray()) {\n-            \/\/ Test internal name\n-            var internal = type.getName().replace('.', '\/');\n-            assertEquals(type, Class.forName(Util.toBinaryName(internal)));\n-        }\n-        \/\/ Test descriptor\n-        assertEquals(type, Class.forName(Util.toBinaryName(type.descriptorString())));\n+        var cd = type.describeConstable().orElseThrow();\n+        assertEquals(type, Class.forName(Util.toBinaryName(cd)));\n+        assertEquals(type.getName(), Util.toBinaryName(cd));\n@@ -62,1 +56,0 @@\n-\n","filename":"test\/jdk\/jdk\/classfile\/UtilTest.java","additions":3,"deletions":10,"binary":false,"changes":13,"status":"modified"}]}