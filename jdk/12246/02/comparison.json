{"files":[{"patch":"@@ -341,0 +341,1 @@\n+  NoSafepointVerifier nsv;\n","filename":"src\/hotspot\/share\/compiler\/compileTask.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n-import compiler.lib.ir_framework.driver.irmatching.parser.MethodCompilationParser;\n+import compiler.lib.ir_framework.driver.irmatching.parser.TestClassParser;\n@@ -750,3 +750,3 @@\n-                MethodCompilationParser methodCompilationParser = new MethodCompilationParser(testClass);\n-                Matchable testClassMatchable = methodCompilationParser.parse(testVMProcess.getHotspotPidFileName(),\n-                                                                             testVMProcess.getIrEncoding());\n+                TestClassParser testClassParser = new TestClassParser(testClass);\n+                Matchable testClassMatchable = testClassParser.parse(testVMProcess.getHotspotPidFileName(),\n+                                                                     testVMProcess.getIrEncoding());\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/TestFramework.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-import compiler.lib.ir_framework.driver.irmatching.parser.MethodCompilationParser;\n+import compiler.lib.ir_framework.driver.irmatching.parser.TestClassParser;\n@@ -31,1 +31,1 @@\n- * This class performs IR matching on the prepared {@link TestClass} object parsed by {@link MethodCompilationParser}.\n+ * This class performs IR matching on the prepared {@link TestClass} object parsed by {@link TestClassParser}.\n@@ -37,1 +37,0 @@\n-    public static final String SAFEPOINT_WHILE_PRINTING_MESSAGE = \"<!-- safepoint while printing -->\";\n@@ -45,1 +44,1 @@\n-     * Do an IR matching of all methods with applicable @IR rules prepared with by the {@link MethodCompilationParser}.\n+     * Do an IR matching of all methods with applicable @IR rules prepared with by the {@link TestClassParser}.\n@@ -61,15 +60,2 @@\n-        String compilationOutput =  new CompilationOutputBuilder(result).build();\n-        throwIfNoSafepointWhilePrinting(failureMsg, compilationOutput);\n-    }\n-\n-    \/**\n-     * In some very rare cases, the hotspot_pid* file to IR match on contains \"<!-- safepoint while printing -->\"\n-     * (emitted by ttyLocker::break_tty_for_safepoint) which might be the reason for a matching error.\n-     * Do not throw an exception in this case (i.e. bailout).\n-     *\/\n-    private void throwIfNoSafepointWhilePrinting(String failures, String compilations) {\n-        if (!compilations.contains(SAFEPOINT_WHILE_PRINTING_MESSAGE)) {\n-            throw new IRViolationException(failures, compilations);\n-        } else {\n-            System.out.println(\"Found \" + SAFEPOINT_WHILE_PRINTING_MESSAGE + \", bail out of IR matching\");\n-        }\n+        String compilationOutput = new CompilationOutputBuilder(result).build();\n+        throw new IRViolationException(failureMsg, compilationOutput);\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/IRMatcher.java","additions":6,"deletions":20,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1,88 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.lib.ir_framework.driver.irmatching.parser;\n-\n-import java.io.BufferedReader;\n-import java.io.IOException;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-\n-\/**\n- * Base class of a read line from the hotspot_pid* file.\n- *\/\n-abstract class AbstractLine {\n-    private final BufferedReader reader;\n-    protected String line;\n-    private final Pattern compileIdPatternForTestClass;\n-\n-    public AbstractLine(BufferedReader reader, Pattern compileIdPatternForTestClass) {\n-        this.reader = reader;\n-        this.compileIdPatternForTestClass = compileIdPatternForTestClass;\n-    }\n-\n-    public String getLine() {\n-        return line;\n-    }\n-\n-    \/**\n-     * Read next line and return it. If we've reached the end of the file, return NULL instead.\n-     *\/\n-    public boolean readLine() throws IOException {\n-        line = reader.readLine();\n-        return line != null;\n-    }\n-\n-    \/**\n-     * Is this line a start of a method in the test class? We only care about test class entries. There might be non-class\n-     * entries as well if the user specified additional compile commands. Ignore these.\n-     *\/\n-    public boolean isTestClassCompilation() {\n-        if (isCompilation()) {\n-            Matcher matcher = compileIdPatternForTestClass.matcher(line);\n-            return matcher.find();\n-        }\n-        return false;\n-    }\n-\n-    \/**\n-     * Is this header a C2 non-OSR compilation header entry?\n-     *\/\n-    public boolean isCompilation() {\n-        return line.startsWith(\"<task_queued\") && notOSRCompilation() && notC2Compilation();\n-    }\n-\n-    \/**\n-     * OSR compilations have compile_kind set.\n-     *\/\n-    protected boolean notOSRCompilation() {\n-        return !line.contains(\"compile_kind='\");\n-    }\n-\n-    \/**\n-     * Non-C2 compilations have level set.\n-     *\/\n-    private boolean notC2Compilation() {\n-        return !line.contains(\"level='\");\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/parser\/AbstractLine.java","additions":0,"deletions":88,"binary":false,"changes":88,"status":"deleted"},{"patch":"@@ -1,43 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.lib.ir_framework.driver.irmatching.parser;\n-\n-import java.util.List;\n-\n-\/**\n- * Class representing a PrintIdeal or PrintOptoAssembly output block read from the hotspot_pid* file.\n- *\/\n-record Block(String output, List<String> testClassCompilations) {\n-    public String getOutput() {\n-        return output;\n-    }\n-\n-    public boolean containsTestClassCompilations() {\n-        return !testClassCompilations.isEmpty();\n-    }\n-\n-    public List<String> getTestClassCompilations() {\n-        return testClassCompilations;\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/parser\/Block.java","additions":0,"deletions":43,"binary":false,"changes":43,"status":"deleted"},{"patch":"@@ -1,44 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.lib.ir_framework.driver.irmatching.parser;\n-\n-import java.io.BufferedReader;\n-import java.util.regex.Pattern;\n-\n-\/**\n- * Class representing a block line inside a PrintIdeal or PrintOptoAssembly output block read from the hotspot_pid* file.\n- *\/\n-class BlockLine extends AbstractLine {\n-\n-    public BlockLine(BufferedReader reader, Pattern compileIdPatternForTestClass) {\n-        super(reader, compileIdPatternForTestClass);\n-    }\n-\n-    \/**\n-     * Is this line an end of a PrintIdeal or PrintOptoAssembly output block?\n-     *\/\n-    public boolean isBlockEnd() {\n-        return line.startsWith(\"<\/\");\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/parser\/BlockLine.java","additions":0,"deletions":44,"binary":false,"changes":44,"status":"deleted"},{"patch":"@@ -1,73 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.lib.ir_framework.driver.irmatching.parser;\n-\n-import java.io.BufferedReader;\n-import java.io.IOException;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.regex.Pattern;\n-\n-\/**\n- * Class to read all lines of a PrintIdeal or PrintOptoAssembly block.\n- *\/\n-class BlockOutputReader {\n-    private final BlockLine line;\n-\n-    public BlockOutputReader(BufferedReader reader, Pattern compileIdPatternForTestClass) {\n-        this.line = new BlockLine(reader, compileIdPatternForTestClass);\n-    }\n-\n-    \/**\n-     * Read all lines belonging to a PrintIdeal or PrintOptoAssembly output block.\n-     *\/\n-    public Block readBlock() throws IOException {\n-        StringBuilder builder = new StringBuilder();\n-        List<String> testClassCompilations = new ArrayList<>();\n-        while (line.readLine() && !line.isBlockEnd()) {\n-            if (line.isTestClassCompilation()) {\n-                \/\/ Could have safepointed while writing the block (see IRMatcher.SAFEPOINT_WHILE_PRINTING_MESSAGE)\n-                \/\/ and enqueuing the next test class method for compilation during the interruption. Record this\n-                \/\/ method to ensure that we read the PrintIdeal\/PrintOptoAssembly blocks for that method later.\n-                testClassCompilations.add(line.getLine());\n-            }\n-            builder.append(escapeXML(line.getLine())).append(System.lineSeparator());\n-        }\n-        return new Block(builder.toString(), testClassCompilations);\n-    }\n-\n-    \/**\n-     * Need to escape XML special characters.\n-     *\/\n-    private static String escapeXML(String line) {\n-        if (line.contains(\"&\")) {\n-            line = line.replace(\"&lt;\", \"<\");\n-            line = line.replace(\"&gt;\", \">\");\n-            line = line.replace(\"&quot;\", \"\\\"\");\n-            line = line.replace(\"&apos;\", \"'\");\n-            line = line.replace(\"&amp;\", \"&\");\n-        }\n-        return line;\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/parser\/BlockOutputReader.java","additions":0,"deletions":73,"binary":false,"changes":73,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.lib.ir_framework.driver.irmatching.parser;\n-\n-\/**\n- * Exception thrown when facing an unexpected format during parsing of the hotspot-pid* file\n- *\/\n-class FileCorruptedException extends RuntimeException {\n-    public FileCorruptedException(String s) {\n-        super(s);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/parser\/FileCorruptedException.java","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,169 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.lib.ir_framework.driver.irmatching.parser;\n-\n-import compiler.lib.ir_framework.TestFramework;\n-import compiler.lib.ir_framework.driver.irmatching.TestClass;\n-import compiler.lib.ir_framework.driver.irmatching.irmethod.IRMethod;\n-import compiler.lib.ir_framework.driver.irmatching.irmethod.IRMethodMatchable;\n-import compiler.lib.ir_framework.shared.TestFormat;\n-import compiler.lib.ir_framework.shared.TestFrameworkException;\n-\n-import java.io.IOException;\n-import java.nio.file.Files;\n-import java.nio.file.Paths;\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.SortedSet;\n-import java.util.TreeSet;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-import java.util.stream.Collectors;\n-\n-\/**\n- * Class to parse the ideal compile phases and PrintOptoAssembly outputs of the test class from the hotspot_pid* file\n- * of all methods collected by {@link IREncodingParser}.\n- *\n- * @see IRMethod\n- * @see IREncodingParser\n- *\/\n-class HotSpotPidFileParser {\n-    private static final Pattern COMPILE_ID_PATTERN = Pattern.compile(\"compile_id='(\\\\d+)'\");\n-\n-    private final Pattern compileIdPatternForTestClass;\n-    \/**\n-     * \"Method name\" -> TestMethod map created by {@link IREncodingParser} which contains an entry for each method that\n-     * needs to be IR matched on.\n-     *\/\n-    private final Map<String, TestMethod> testMethodMap;\n-\n-    public HotSpotPidFileParser(String testClass, Map<String, TestMethod> testMethodMap) {\n-        this.compileIdPatternForTestClass = Pattern.compile(\"compile_id='(\\\\d+)'.*\" + Pattern.quote(testClass) + \" (\\\\S+)\");\n-        this.testMethodMap = testMethodMap;\n-    }\n-\n-    \/**\n-     * Parse the hotspot_pid*.log file from the test VM. Read the ideal compile phase and PrintOptoAssembly outputs for\n-     * all methods defined by the IR encoding.\n-     *\/\n-    public TestClass parse(String hotspotPidFileName) {\n-        try {\n-            parseHotSpotFile(hotspotPidFileName);\n-            SortedSet<IRMethodMatchable> irMethods = testMethodMap.values().stream()\n-                                                                  .map(TestMethod::createIRMethod)\n-                                                                  .collect(Collectors.toCollection(TreeSet::new));\n-            TestFormat.throwIfAnyFailures();\n-            return new TestClass(irMethods);\n-        } catch (IOException e) {\n-            throw new TestFrameworkException(\"Error while reading \" + hotspotPidFileName, e);\n-        } catch (FileCorruptedException e) {\n-            throw new TestFrameworkException(\"Unexpected format of \" + hotspotPidFileName, e);\n-        }\n-    }\n-\n-    private void parseHotSpotFile(String hotspotPidFileName) throws IOException {\n-        Map<Integer, TestMethod> compileIdMap = new HashMap<>();\n-        try (var reader = Files.newBufferedReader(Paths.get(hotspotPidFileName))) {\n-            Line line = new Line(reader, compileIdPatternForTestClass);\n-            BlockOutputReader blockOutputReader = new BlockOutputReader(reader, compileIdPatternForTestClass);\n-            while (line.readLine()) {\n-                if (line.isTestClassCompilation()) {\n-                    parseTestMethodCompileId(compileIdMap, line.getLine());\n-                } else if (isTestMethodBlockStart(line, compileIdMap)) {\n-                    processMethodBlock(compileIdMap, line, blockOutputReader);\n-                }\n-            }\n-        }\n-    }\n-\n-    private void processMethodBlock(Map<Integer, TestMethod> compileIdMap, Line line, BlockOutputReader blockOutputReader)\n-            throws IOException {\n-        Block block = blockOutputReader.readBlock();\n-        if (block.containsTestClassCompilations()) {\n-            \/\/ Register all test method compilations that could have been emitted during a rare safepoint while\n-            \/\/ dumping the ideal compile phase\/PrintOptoAssembly output.\n-            block.getTestClassCompilations().forEach(l -> parseTestMethodCompileId(compileIdMap, l));\n-        }\n-        setIRMethodOutput(block.getOutput(), line, compileIdMap);\n-    }\n-\n-    private void parseTestMethodCompileId(Map<Integer, TestMethod> compileIdMap, String line) {\n-        String methodName = parseMethodName(line);\n-        if (isTestAnnotatedMethod(methodName)) {\n-            compileIdMap.put(getCompileId(line), getTestMethod(methodName));\n-        }\n-    }\n-\n-    private String parseMethodName(String line) {\n-        Matcher matcher = compileIdPatternForTestClass.matcher(line);\n-        TestFramework.check(matcher.find(), \"must find match\");\n-        return matcher.group(2);\n-    }\n-\n-    \/**\n-     * Is this a @Test method?\n-     *\/\n-    private boolean isTestAnnotatedMethod(String testMethodName) {\n-        return testMethodMap.containsKey(testMethodName);\n-    }\n-\n-    private TestMethod getTestMethod(String testMethodName) {\n-        TestMethod testMethod = testMethodMap.get(testMethodName);\n-        testMethod.clearOutput();\n-        testMethod.setCompiled();\n-        return testMethod;\n-    }\n-\n-    private int getCompileId(String line) {\n-        Matcher matcher = COMPILE_ID_PATTERN.matcher(line);\n-        if (!matcher.find()) {\n-            throw new FileCorruptedException(\"Unexpected format found on this line: \" + line);\n-        }\n-        return Integer.parseInt(matcher.group(1));\n-    }\n-\n-    \/**\n-     * Is this line the start of a PrintIdeal\/PrintOptoAssembly output block of a @Test method?\n-     *\/\n-    private boolean isTestMethodBlockStart(Line line, Map<Integer, TestMethod> compileIdMap) {\n-      return line.isBlockStart() && isTestClassMethodBlock(line, compileIdMap);\n-    }\n-\n-    private boolean isTestClassMethodBlock(Line line, Map<Integer, TestMethod> compileIdMap) {\n-        return compileIdMap.containsKey(getCompileId(line.getLine()));\n-    }\n-\n-    private void setIRMethodOutput(String blockOutput, Line blockStartLine, Map<Integer, TestMethod> compileIdMap) {\n-        TestMethod testMethod = compileIdMap.get(getCompileId(blockStartLine.getLine()));\n-        setIRMethodOutput(blockOutput, blockStartLine, testMethod);\n-    }\n-\n-    private void setIRMethodOutput(String blockOutput, Line blockStartLine, TestMethod testMethod) {\n-        if (blockStartLine.isPrintIdealStart()) {\n-            testMethod.setIdealOutput(blockOutput, blockStartLine.getCompilePhase());\n-        } else {\n-            testMethod.setOptoAssemblyOutput(blockOutput);\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/parser\/HotSpotPidFileParser.java","additions":0,"deletions":169,"binary":false,"changes":169,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import compiler.lib.ir_framework.driver.irmatching.parser.hotspot.HotSpotPidFileParser;\n@@ -43,1 +44,1 @@\n-class IREncodingParser {\n+public class IREncodingParser {\n@@ -49,1 +50,1 @@\n-    private final Map<String, TestMethod> testMethodMap;\n+    private final Map<String, TestMethod> testMethods;\n@@ -54,1 +55,1 @@\n-        this.testMethodMap = new HashMap<>();\n+        this.testMethods = new HashMap<>();\n@@ -61,1 +62,1 @@\n-    public Map<String, TestMethod> parse(String irEncoding) {\n+    public TestMethods parse(String irEncoding) {\n@@ -69,1 +70,1 @@\n-        return testMethodMap;\n+        return new TestMethods(testMethods);\n@@ -137,1 +138,1 @@\n-                    testMethodMap.put(m.getName(), new TestMethod(m, irRuleIds));\n+                    testMethods.put(m.getName(), new TestMethod(m, irAnnos, irRuleIds));\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/parser\/IREncodingParser.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.parser;\n+\n+import compiler.lib.ir_framework.driver.irmatching.Compilation;\n+import compiler.lib.ir_framework.driver.irmatching.irmethod.IRMethod;\n+import compiler.lib.ir_framework.driver.irmatching.irmethod.IRMethodMatchable;\n+import compiler.lib.ir_framework.driver.irmatching.irmethod.NotCompiledIRMethod;\n+import compiler.lib.ir_framework.driver.irmatching.parser.hotspot.HotSpotPidFileParser;\n+import compiler.lib.ir_framework.driver.irmatching.parser.hotspot.LoggedMethod;\n+import compiler.lib.ir_framework.driver.irmatching.parser.hotspot.LoggedMethods;\n+\n+import java.util.Map;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+\n+\/**\n+ * Class to create {@link IRMethod} instances by combining the elements of {@link TestMethods} and {@link LoggedMethods}.\n+ *\/\n+class IRMethodBuilder {\n+    private final Map<String, LoggedMethod> loggedMethods;\n+    private final TestMethods testMethods;\n+\n+    public IRMethodBuilder(TestMethods testMethods, LoggedMethods loggedMethods) {\n+        this.testMethods = testMethods;\n+        this.loggedMethods = loggedMethods.loggedMethods();\n+    }\n+\n+    \/**\n+     * Create IR methods for all test methods identified by {@link IREncodingParser} by combining them with the parsed\n+     * compilation output from {@link HotSpotPidFileParser}.\n+     *\/\n+    public SortedSet<IRMethodMatchable> build() {\n+        SortedSet<IRMethodMatchable> irMethods = new TreeSet<>();\n+        testMethods.testMethods().forEach(\n+                (methodName, testMethod) -> irMethods.add(createIRMethod(methodName, testMethod)));\n+        return irMethods;\n+    }\n+\n+    private IRMethodMatchable createIRMethod(String methodName, TestMethod testMethod) {\n+        LoggedMethod loggedMethod = loggedMethods.get(methodName);\n+        if (loggedMethod != null) {\n+            return new IRMethod(testMethod.method(), testMethod.irRuleIds(), testMethod.irAnnos(),\n+                                new Compilation(loggedMethod.compilationOutput()));\n+        } else {\n+            return new NotCompiledIRMethod(testMethod.method(), testMethod.irRuleIds().length);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/parser\/IRMethodBuilder.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -1,71 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.lib.ir_framework.driver.irmatching.parser;\n-\n-import compiler.lib.ir_framework.CompilePhase;\n-import compiler.lib.ir_framework.TestFramework;\n-\n-import java.io.BufferedReader;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-\n-\/**\n- * Class representing a normal line read from the hotspot_pid* file.\n- *\/\n-class Line extends AbstractLine {\n-    private static final Pattern IDEAL_COMPILE_PHASE_PATTERN = Pattern.compile(\"<ideal.*compile_phase='(.*)'>\");\n-    public Line(BufferedReader reader, Pattern compileIdPatternForTestClass) {\n-        super(reader, compileIdPatternForTestClass);\n-    }\n-\n-    \/**\n-     * Is this line a start of a PrintIdeal or PrintOptoAssembly output block?\n-     *\/\n-    public boolean isBlockStart() {\n-        return isPrintIdealStart() || isPrintOptoAssemblyStart();\n-    }\n-\n-    \/**\n-     * Is this line a start of a PrintIdeal output block?\n-     *\/\n-    public boolean isPrintIdealStart() {\n-        \/\/ Ignore OSR compilations which have compile_kind set.\n-        return line.startsWith(\"<ideal\") && notOSRCompilation();\n-    }\n-\n-    \/**\n-     * Is this line a start of a PrintOptoAssembly output block?\n-     *\/\n-    private boolean isPrintOptoAssemblyStart() {\n-        \/\/ Ignore OSR compilations which have compile_kind set.\n-        return line.startsWith(\"<opto_assembly\") && notOSRCompilation();\n-    }\n-\n-    public CompilePhase getCompilePhase() {\n-        Matcher m = IDEAL_COMPILE_PHASE_PATTERN.matcher(line);\n-        TestFramework.check(m.find(), \"must always find \\\"compile_phase\\\" in ideal entry in \" + line);\n-        return CompilePhase.forName(m.group(1));\n-    }\n- }\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/parser\/Line.java","additions":0,"deletions":71,"binary":false,"changes":71,"status":"deleted"},{"patch":"@@ -1,58 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.lib.ir_framework.driver.irmatching.parser;\n-\n-import compiler.lib.ir_framework.driver.irmatching.Matchable;\n-import compiler.lib.ir_framework.driver.irmatching.NonIRTestClass;\n-import compiler.lib.ir_framework.driver.irmatching.irmethod.IRMethod;\n-\n-import java.util.Map;\n-\n-\/**\n- * Class to parse the ideal compile phase and PrintOptoAssembly outputs of the test class and store them into a\n- * collection of dedicated IRMethod objects used throughout IR matching.\n- *\n- * @see IRMethod\n- *\/\n-public class MethodCompilationParser {\n-    private final Class<?> testClass;\n-\n-    public MethodCompilationParser(Class<?> testClass) {\n-        this.testClass = testClass;\n-    }\n-\n-    \/**\n-     * Parse the IR encoding and hotspot_pid* file to create a collection of {@link IRMethod} objects.\n-     * Return a default\/empty TestClass object if there are no applicable @IR rules in any method of the test class.\n-     *\/\n-    public Matchable parse(String hotspotPidFileName, String irEncoding) {\n-        IREncodingParser irEncodingParser = new IREncodingParser(testClass);\n-        Map<String, TestMethod> testMethodMap = irEncodingParser.parse(irEncoding);\n-        if (!testMethodMap.isEmpty()) {\n-            HotSpotPidFileParser hotSpotPidFileParser = new HotSpotPidFileParser(testClass.getName(), testMethodMap);\n-            return hotSpotPidFileParser.parse(hotspotPidFileName);\n-        }\n-        return new NonIRTestClass();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/parser\/MethodCompilationParser.java","additions":0,"deletions":58,"binary":false,"changes":58,"status":"deleted"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.parser;\n+\n+import compiler.lib.ir_framework.driver.irmatching.Matchable;\n+import compiler.lib.ir_framework.driver.irmatching.NonIRTestClass;\n+import compiler.lib.ir_framework.driver.irmatching.TestClass;\n+import compiler.lib.ir_framework.driver.irmatching.irmethod.IRMethod;\n+import compiler.lib.ir_framework.driver.irmatching.irmethod.IRMethodMatchable;\n+import compiler.lib.ir_framework.driver.irmatching.parser.hotspot.HotSpotPidFileParser;\n+import compiler.lib.ir_framework.driver.irmatching.parser.hotspot.LoggedMethods;\n+import compiler.lib.ir_framework.shared.TestFormat;\n+\n+import java.util.SortedSet;\n+\n+\/**\n+ * Class to parse the ideal compile phase and PrintOptoAssembly outputs of the test class and store them into a\n+ * collection of dedicated IRMethod objects used throughout IR matching.\n+ *\n+ * @see IRMethod\n+ *\/\n+public class TestClassParser {\n+    private final Class<?> testClass;\n+\n+    public TestClassParser(Class<?> testClass) {\n+        this.testClass = testClass;\n+    }\n+\n+    \/**\n+     * Parse the IR encoding and hotspot_pid* file to create a collection of {@link IRMethod} objects.\n+     * Return a default\/empty TestClass object if there are no applicable @IR rules in any method of the test class.\n+     *\/\n+    public Matchable parse(String hotspotPidFileName, String irEncoding) {\n+        IREncodingParser irEncodingParser = new IREncodingParser(testClass);\n+        TestMethods testMethods = irEncodingParser.parse(irEncoding);\n+        if (testMethods.hasTestMethods()) {\n+            HotSpotPidFileParser hotSpotPidFileParser = new HotSpotPidFileParser(testClass.getName(), testMethods);\n+            LoggedMethods loggedMethods = hotSpotPidFileParser.parse(hotspotPidFileName);\n+            return createTestClass(testMethods, loggedMethods);\n+        }\n+        return new NonIRTestClass();\n+    }\n+\n+    \/**\n+     * Create test class with IR methods for all test methods identified by {@link IREncodingParser} by combining them\n+     * with the parsed compilation output from {@link HotSpotPidFileParser}.\n+     *\/\n+    private Matchable createTestClass(TestMethods testMethods, LoggedMethods loggedMethods) {\n+        IRMethodBuilder irMethodBuilder = new IRMethodBuilder(testMethods, loggedMethods);\n+        SortedSet<IRMethodMatchable> irMethods = irMethodBuilder.build();\n+        TestFormat.throwIfAnyFailures();\n+        return new TestClass(irMethods);\n+    }\n+\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/parser\/TestClassParser.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n-import compiler.lib.ir_framework.CompilePhase;\n@@ -28,2 +27,0 @@\n-import compiler.lib.ir_framework.TestFramework;\n-import compiler.lib.ir_framework.driver.irmatching.Compilation;\n@@ -31,2 +28,1 @@\n-import compiler.lib.ir_framework.driver.irmatching.irmethod.IRMethodMatchable;\n-import compiler.lib.ir_framework.driver.irmatching.irmethod.NotCompiledIRMethod;\n+import compiler.lib.ir_framework.driver.irmatching.parser.hotspot.LoggedMethod;\n@@ -35,2 +31,0 @@\n-import java.util.LinkedHashMap;\n-import java.util.Map;\n@@ -39,3 +33,2 @@\n- * This class represents a test method that is incrementally updated with new information parsed by {@link IREncodingParser}\n- * and {@link HotSpotPidFileParser}. Once the parsers are finished, an {@link IRMethod} object can be fetched from the\n- * collected data with {@link TestMethod#createIRMethod()}.\n+ * This class represents a test method parsed by {@link IREncodingParser}. In combination with the associated\n+ * {@link LoggedMethod}, a new {@link IRMethod} is created to IR match on later.\n@@ -44,1 +37,1 @@\n- * @see HotSpotPidFileParser\n+ * @see LoggedMethod\n@@ -49,0 +42,1 @@\n+    private final IR[] irAnnos;\n@@ -50,2 +44,0 @@\n-    private final Map<CompilePhase, String> compilationOutputMap;\n-    private boolean compiled; \/\/ Was this method compiled (i.e. found in hotspot_pid* file?)\n@@ -53,1 +45,1 @@\n-    public TestMethod(Method m, int[] irRuleIds) {\n+    public TestMethod(Method m, IR[] irAnnos, int[] irRuleIds) {\n@@ -55,0 +47,1 @@\n+        this.irAnnos = irAnnos;\n@@ -56,2 +49,0 @@\n-        this.compilationOutputMap = new LinkedHashMap<>(); \/\/ Keep order of insertion\n-        this.compiled = false;\n@@ -60,2 +51,2 @@\n-    public void setCompiled() {\n-        this.compiled = true;\n+    public Method method() {\n+        return method;\n@@ -64,9 +55,2 @@\n-    public IRMethodMatchable createIRMethod() {\n-        IR[] irAnnos = method.getAnnotationsByType(IR.class);\n-        TestFramework.check(irAnnos.length > 0, \"must have at least one IR rule\");\n-        TestFramework.check(irRuleIds.length > 0, \"must have at least one IR rule\");\n-        if (compiled) {\n-            return new IRMethod(method, irRuleIds, irAnnos, new Compilation(compilationOutputMap));\n-        } else {\n-            return new NotCompiledIRMethod(method, irRuleIds.length);\n-        }\n+    public IR[] irAnnos() {\n+        return irAnnos;\n@@ -75,26 +59,2 @@\n-    \/**\n-     * Clear the collected ideal and opto assembly output of all phases. This is necessary when having multiple\n-     * compilations of the same method. We only want to keep the very last compilation which is the one requested by\n-     * the framework.\n-     *\/\n-    public void clearOutput() {\n-        compilationOutputMap.clear();\n-    }\n-\n-    \/**\n-     * We might parse multiple C2 compilations of this method. Only keep the very last one by overriding the outputMap.\n-     *\/\n-    public void setIdealOutput(String idealOutput, CompilePhase compilePhase) {\n-        String idealOutputWithHeader = \"> Phase \\\"\" + compilePhase.getName()+ \"\\\":\" + System.lineSeparator()\n-                                       + idealOutput;\n-        if (!compilationOutputMap.containsKey(compilePhase) || compilePhase.overrideRepeatedPhase()) {\n-            compilationOutputMap.put(compilePhase, idealOutputWithHeader);\n-        }\n-    }\n-\n-    \/**\n-     * We might parse multiple C2 compilations of this method. Only keep the very last one by overriding the outputMap.\n-     *\/\n-    public void setOptoAssemblyOutput(String optoAssemblyOutput) {\n-        optoAssemblyOutput = \"> Phase \\\"PrintOptoAssembly\\\":\" + System.lineSeparator() + optoAssemblyOutput;\n-        compilationOutputMap.put(CompilePhase.PRINT_OPTO_ASSEMBLY, optoAssemblyOutput);\n+    public int[] irRuleIds() {\n+        return irRuleIds;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/parser\/TestMethod.java","additions":14,"deletions":54,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.parser;\n+\n+import compiler.lib.ir_framework.driver.irmatching.irmethod.IRMethod;\n+import compiler.lib.ir_framework.driver.irmatching.parser.hotspot.HotSpotPidFileParser;\n+\n+import java.util.Map;\n+\n+\/**\n+ * This class stores all test methods that need to be IR matched as identified by {@link IREncodingParser}.\n+ *\n+ * @see IREncodingParser\n+ * @see HotSpotPidFileParser\n+ * @see IRMethod\n+ *\/\n+public class TestMethods {\n+    \/**\n+     * \"Method name\" -> TestMethod map created by {@link IREncodingParser} which contains an entry for each method that\n+     * needs to be IR matched on.\n+     *\/\n+    private final Map<String, TestMethod> testMethods;\n+\n+    public TestMethods(Map<String, TestMethod> testMethods) {\n+        this.testMethods = testMethods;\n+    }\n+\n+    public Map<String, TestMethod> testMethods() {\n+        return testMethods;\n+    }\n+\n+    public boolean isTestMethod(String method) {\n+        return testMethods.containsKey(method);\n+    }\n+\n+    public boolean hasTestMethods() {\n+        return !testMethods.isEmpty();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/parser\/TestMethods.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -0,0 +1,134 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.parser.hotspot;\n+\n+import compiler.lib.ir_framework.CompilePhase;\n+\n+\/**\n+ * This class represents a single compile phase block of a {@link LoggedMethod}.\n+ *\/\n+class CompilePhaseBlock {\n+    public static final String SAFEPOINT_WHILE_PRINTING_MESSAGE = \"<!-- safepoint while printing -->\";\n+\n+    \/**\n+     * Dummy object for a block that we do not need to parse.\n+     *\/\n+    public static final CompilePhaseBlock DONT_CARE = new CompilePhaseBlock(CompilePhase.DEFAULT);\n+\n+    private final CompilePhase compilePhase;\n+    private final StringBuilder builder;\n+    \/**\n+     * Stores an incomplete line that was interrupted by a safepoint.\n+     * Needs to be merged with the immediately following line.\n+     *\/\n+    private String incompleteLine = \"\";\n+\n+    public CompilePhaseBlock(CompilePhase compilePhase) {\n+        this.compilePhase = compilePhase;\n+        String blockHeader = \"> Phase \\\"\" + compilePhase.getName() + \"\\\":\" + System.lineSeparator();\n+        this.builder = new StringBuilder(blockHeader);\n+    }\n+\n+    public CompilePhase compilePhase() {\n+        return compilePhase;\n+    }\n+\n+    \/**\n+     * Is this line a start of an ideal or opto assembly output block?\n+     *\/\n+    public static boolean isBlockStartLine(String line) {\n+        return (isPrintIdealStart(line) || isPrintOptoAssemblyStart(line)) && notOSRCompilation(line);\n+    }\n+\n+    \/**\n+     * Is this line a start of an ideal output block?\n+     *\/\n+    public static boolean isPrintIdealStart(String line) {\n+        \/\/ Ignore OSR compilations which have compile_kind set.\n+        return line.startsWith(\"<ideal\");\n+    }\n+\n+    \/**\n+     * Is this line a start of an opto assembly output block?\n+     *\/\n+    public static boolean isPrintOptoAssemblyStart(String line) {\n+        \/\/ Ignore OSR compilations which have compile_kind set.\n+        return line.startsWith(\"<opto_assembly\");\n+    }\n+\n+    \/**\n+     * OSR compilations have compile_kind set.\n+     *\/\n+    private static boolean notOSRCompilation(String content) {\n+        return !content.contains(\"compile_kind='\");\n+    }\n+\n+    \/**\n+     * Is this line an end of an ideal or opto assembly output block?\n+     *\/\n+    public static boolean isBlockEndLine(String line) {\n+        return line.startsWith(\"<\/ideal\") || line.startsWith(\"<\/opto_assembly\");\n+    }\n+\n+    public void addLine(String line) {\n+        line = mergeWithIncompleteLine(line);\n+        if (line.endsWith(SAFEPOINT_WHILE_PRINTING_MESSAGE)) {\n+            line = removeSafepointMessage(line);\n+            incompleteLine = line;\n+        } else {\n+            appendLine(line);\n+        }\n+    }\n+\n+    private String mergeWithIncompleteLine(String line) {\n+        if (!incompleteLine.isEmpty()) {\n+            line = incompleteLine + line;\n+            incompleteLine = \"\";\n+        }\n+        return line;\n+    }\n+\n+    private static String removeSafepointMessage(String line) {\n+        return line.substring(0, line.lastIndexOf(SAFEPOINT_WHILE_PRINTING_MESSAGE));\n+    }\n+\n+    public String content() {\n+        return builder.toString();\n+    }\n+\n+    private void appendLine(String line) {\n+        builder.append(escapeXML(line)).append(System.lineSeparator());\n+    }\n+\n+    private static String escapeXML(String line) {\n+        if (line.contains(\"&\")) {\n+            line = line.replace(\"&lt;\", \"<\");\n+            line = line.replace(\"&gt;\", \">\");\n+            line = line.replace(\"&quot;\", \"\\\"\");\n+            line = line.replace(\"&apos;\", \"'\");\n+            line = line.replace(\"&amp;\", \"&\");\n+        }\n+        return line;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/parser\/hotspot\/CompilePhaseBlock.java","additions":134,"deletions":0,"binary":false,"changes":134,"status":"added"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.parser.hotspot;\n+\n+import compiler.lib.ir_framework.TestFramework;\n+import compiler.lib.ir_framework.driver.irmatching.parser.IREncodingParser;\n+import compiler.lib.ir_framework.driver.irmatching.parser.TestMethods;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+\/**\n+ * This class parses compile queue messages found in the hotspot_pid* files and keeps track of those that need to be\n+ * IR matched (i.e. identified by {@link IREncodingParser}.\n+ *\n+ * @see IREncodingParser\n+ *\/\n+class CompileQueueMessages {\n+    private static final Pattern COMPILE_ID_PATTERN = Pattern.compile(\"compile_id='(\\\\d+)'\");\n+\n+    private final Pattern compileIdTestMethodPattern;\n+    private final Pattern testMethodPattern;\n+    private final TestMethods testMethods;\n+    Map<Integer, String> compileIdToMethodName = new HashMap<>();\n+\n+    public CompileQueueMessages(String testClassName, TestMethods testMethods) {\n+        this.compileIdTestMethodPattern = Pattern.compile(\"compile_id='(\\\\d+)'.*\" + Pattern.quote(testClassName) + \" (\\\\S+)\");\n+        this.testMethodPattern = Pattern.compile(Pattern.quote(testClassName) + \" (\\\\S+)\");\n+        this.testMethods = testMethods;\n+    }\n+\n+    public boolean isTestMethodQueuedLine(String line) {\n+        return isCompilation(line) && isTestMethod(line);\n+    }\n+\n+    \/**\n+     * Is this header a C2 non-OSR compilation header entry?\n+     *\/\n+    private boolean isCompilation(String line) {\n+        return line.startsWith(\"<task_queued\") && notOSRCompilation(line) && notC2Compilation(line);\n+    }\n+\n+    \/**\n+     * OSR compilations have compile_kind set.\n+     *\/\n+    private boolean notOSRCompilation(String line) {\n+        return !line.contains(\"compile_kind='\");\n+    }\n+\n+    \/**\n+     * Non-C2 compilations have level set.\n+     *\/\n+    private boolean notC2Compilation(String line) {\n+        return !line.contains(\"level='\");\n+    }\n+\n+    private boolean isTestMethod(String line) {\n+        Matcher matcher = testMethodPattern.matcher(line);\n+        if (matcher.find()) {\n+            return testMethods.isTestMethod(matcher.group(1));\n+        }\n+        return false;\n+    }\n+\n+    public String parse(String line) {\n+        Matcher matcher = compileIdTestMethodPattern.matcher(line);\n+        TestFramework.check(matcher.find(), \"must find match on line: \\\"\" + line + \"\\\"\");\n+        int compileId = Integer.parseInt(matcher.group(1)); \/\/ parse from line\n+        String methodName = matcher.group(2); \/\/ parse from line\n+        compileIdToMethodName.put(compileId, methodName);\n+        return methodName;\n+    }\n+\n+    \/**\n+     * Return the method name associated with the compile id contained in this line if the method is IR matched.\n+     * Otherwise, return an empty string.\n+     *\/\n+    public String findTestMethodName(String line) {\n+        int compileId = parseCompileId(line);\n+        return compileIdToMethodName.getOrDefault(compileId, \"\");\n+    }\n+\n+    private static int parseCompileId(String line) {\n+        Matcher matcher = COMPILE_ID_PATTERN.matcher(line);\n+        TestFramework.check(matcher.find(), \"must find compile id on line: \\\"\" + line + \"\\\"\");\n+        return Integer.parseInt(matcher.group(1));\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/parser\/hotspot\/CompileQueueMessages.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.parser.hotspot;\n+\n+import compiler.lib.ir_framework.driver.irmatching.irmethod.IRMethod;\n+import compiler.lib.ir_framework.driver.irmatching.parser.IREncodingParser;\n+import compiler.lib.ir_framework.driver.irmatching.parser.TestMethods;\n+import compiler.lib.ir_framework.shared.TestFrameworkException;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+\n+\/**\n+ * Class to parse the ideal compile phases and PrintOptoAssembly outputs of the test class from the hotspot_pid* file\n+ * of all methods identified by {@link IREncodingParser}.\n+ *\n+ * @see IRMethod\n+ * @see IREncodingParser\n+ *\/\n+public class HotSpotPidFileParser {\n+    private final State state;\n+\n+    public HotSpotPidFileParser(String testClass, TestMethods testMethods) {\n+        this.state = new State(testClass, testMethods);\n+    }\n+\n+    \/**\n+     * Parse the hotspot_pid*.log file from the test VM. Read the ideal compile phase and PrintOptoAssembly outputs for\n+     * all methods defined by the IR encoding.\n+     *\/\n+    public LoggedMethods parse(String hotspotPidFileName) {\n+        try (var reader = Files.newBufferedReader(Paths.get(hotspotPidFileName))) {\n+            String line;\n+            while ((line = reader.readLine()) != null) {\n+                state.update(line);\n+            }\n+            return state.loggedMethods();\n+        } catch (IOException e) {\n+            throw new TestFrameworkException(\"Error while reading \" + hotspotPidFileName, e);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/parser\/hotspot\/HotSpotPidFileParser.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.parser.hotspot;\n+\n+import compiler.lib.ir_framework.CompilePhase;\n+import compiler.lib.ir_framework.TestFramework;\n+\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+\/**\n+ * This class represents a currently parsed method in {@link HotSpotPidFileParser}. It stores all the different compile\n+ * phase outputs.\n+ *\/\n+public class LoggedMethod {\n+    \/**\n+     * Dummy object for methods that we do not need to parse.\n+     *\/\n+    public static final LoggedMethod DONT_CARE = new LoggedMethod();\n+    private static final Pattern IDEAL_COMPILE_PHASE_PATTERN = Pattern.compile(\"<ideal.*compile_phase='(.*)'>\");\n+\n+    private final Map<CompilePhase, String> compilationOutput = new LinkedHashMap<>();\n+    private CompilePhaseBlock compilePhaseBlock;\n+\n+    public LoggedMethod() {\n+        this.compilePhaseBlock = CompilePhaseBlock.DONT_CARE;\n+    }\n+\n+    public Map<CompilePhase, String> compilationOutput() {\n+        return compilationOutput;\n+    }\n+\n+    public boolean hasActiveBlock() {\n+        return compilePhaseBlock != CompilePhaseBlock.DONT_CARE;\n+    }\n+\n+    public void addLine(String line) {\n+        if (hasActiveBlock()) {\n+            compilePhaseBlock.addLine(line);\n+        }\n+    }\n+\n+    public void beginPrintIdealBlock(String line) {\n+        Matcher matcher = IDEAL_COMPILE_PHASE_PATTERN.matcher(line);\n+        TestFramework.check(matcher.find(), \"must always find \\\"compile_phase\\\" in ideal entry in \" + line);\n+        CompilePhase compilePhase = CompilePhase.forName(matcher.group(1));\n+        beginBlock(compilePhase);\n+    }\n+\n+    public void beginPrintOptoAssemblyBlock() {\n+        beginBlock(CompilePhase.PRINT_OPTO_ASSEMBLY);\n+    }\n+\n+    private void beginBlock(CompilePhase compilePhase) {\n+        if (compilationOutput.containsKey(compilePhase) && !compilePhase.overrideRepeatedPhase()) {\n+            \/\/ We only want to keep the first compilation output for this phase.\n+            compilePhaseBlock = CompilePhaseBlock.DONT_CARE;\n+        } else {\n+            compilePhaseBlock = new CompilePhaseBlock(compilePhase);\n+        }\n+    }\n+\n+    public void terminateBlock() {\n+        if (hasActiveBlock()) {\n+            compilationOutput.put(compilePhaseBlock.compilePhase(), compilePhaseBlock.content());\n+            compilePhaseBlock = CompilePhaseBlock.DONT_CARE;\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/parser\/hotspot\/LoggedMethod.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.parser.hotspot;\n+\n+import compiler.lib.ir_framework.TestFramework;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+\/**\n+ * This class keeps track of all {@link LoggedMethod} instances.\n+ *\/\n+public class LoggedMethods {\n+    private final Map<String, LoggedMethod> loggedMethods = new HashMap<>();\n+\n+    public Map<String, LoggedMethod> loggedMethods() {\n+        return loggedMethods;\n+    }\n+\n+    public LoggedMethod loggedMethod(String methodName) {\n+        LoggedMethod loggedMethod = loggedMethods.get(methodName);\n+        TestFramework.check(loggedMethod != null, \"must exist\");\n+        return loggedMethod;\n+    }\n+\n+    \/**\n+     * Always creates a new LoggedMethod to drop the already collected ideal and opto assembly outputs of the same method.\n+     * We only want to keep the very last compilation of a method which is the one requested by the framework.\n+     *\/\n+    public void registerMethod(String methodName) {\n+        loggedMethods.put(methodName, new LoggedMethod());\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/parser\/hotspot\/LoggedMethods.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.parser.hotspot;\n+\n+import compiler.lib.ir_framework.driver.irmatching.parser.TestMethods;\n+\n+\/**\n+ * This class holds the current state of the parsing of the hotspot_pid* file.\n+ *\/\n+class State {\n+    private final WriterThreads writerThreads;\n+    private WriterThread writerThread;\n+    private final CompileQueueMessages compileQueueMessages;\n+    private final LoggedMethods loggedMethods;\n+    private LoggedMethod loggedMethod = LoggedMethod.DONT_CARE;\n+\n+    public State(String testClassName, TestMethods testMethods) {\n+        this.compileQueueMessages = new CompileQueueMessages(testClassName, testMethods);\n+        this.loggedMethods = new LoggedMethods();\n+        this.writerThreads = new WriterThreads();\n+    }\n+\n+    public LoggedMethods loggedMethods() {\n+        return loggedMethods;\n+    }\n+\n+    public void update(String line) {\n+        if (WriterThread.isWriterThreadLine(line)) {\n+            processWriterThreadLine(line);\n+        } else if (compileQueueMessages.isTestMethodQueuedLine(line)) {\n+            processCompileQueueLine(line);\n+        } else if (CompilePhaseBlock.isBlockStartLine(line)) {\n+            processBlockStartLine(line);\n+        } else if (CompilePhaseBlock.isBlockEndLine(line)) {\n+            processBlockEndLine();\n+        } else {\n+            processNormalLine(line);\n+        }\n+    }\n+\n+    private void processWriterThreadLine(String line) {\n+        if (loggedMethod.hasActiveBlock()) {\n+            \/\/ The current compile phase block was interrupted due to a safepoint. Save and restore later.\n+            writerThread.saveLoggedMethod(loggedMethod);\n+        }\n+        writerThread = writerThreads.parse(line);\n+        loggedMethod = writerThread.restoreLoggedMethod();\n+    }\n+\n+    private void processCompileQueueLine(String line) {\n+        String methodName = compileQueueMessages.parse(line);\n+        loggedMethods.registerMethod(methodName);\n+    }\n+\n+    private void processBlockStartLine(String line) {\n+        String methodName = compileQueueMessages.findTestMethodName(line);\n+        if (!methodName.isEmpty()) {\n+            loggedMethod = loggedMethods.loggedMethod(methodName);\n+            if (CompilePhaseBlock.isPrintIdealStart(line)) {\n+                loggedMethod.beginPrintIdealBlock(line);\n+            } else {\n+                loggedMethod.beginPrintOptoAssemblyBlock();\n+            }\n+        }\n+    }\n+\n+    private void processBlockEndLine() {\n+        loggedMethod.terminateBlock();\n+    }\n+\n+    private void processNormalLine(String line) {\n+        loggedMethod.addLine(line);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/parser\/hotspot\/State.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.parser.hotspot;\n+\n+\/**\n+ * This class represents a writer thread that emits log messages with LogCompilation. It saves and restores a currently\n+ * parsed {@link LoggedMethod} if a {@link CompilePhaseBlock} was interrupted before reaching the block end tag.\n+ *\n+ * @see LoggedMethod\n+ * @see CompilePhaseBlock\n+ *\/\n+class WriterThread {\n+    private LoggedMethod loggedMethod = LoggedMethod.DONT_CARE;\n+\n+    public static boolean isWriterThreadLine(String line) {\n+        return line.startsWith(\"<writer\");\n+    }\n+\n+    public void saveLoggedMethod(LoggedMethod loggedMethod) {\n+        this.loggedMethod = loggedMethod;\n+    }\n+\n+    public LoggedMethod restoreLoggedMethod() {\n+        LoggedMethod restoredLoggedMethod = loggedMethod;\n+        if (restoredLoggedMethod != LoggedMethod.DONT_CARE) {\n+            loggedMethod = LoggedMethod.DONT_CARE;\n+        }\n+        return restoredLoggedMethod;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/parser\/hotspot\/WriterThread.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.parser.hotspot;\n+\n+import compiler.lib.ir_framework.TestFramework;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+\/**\n+ * This class keeps track of all {@link WriterThread} instances.\n+ *\/\n+class WriterThreads {\n+    private final Map<Integer, WriterThread> mapIdToThread = new HashMap<>();\n+\n+    WriterThread parse(String line) {\n+        int writerThreadId = parseWriterThreadId(line);\n+        return mapIdToThread.computeIfAbsent(writerThreadId, c -> new WriterThread());\n+    }\n+\n+    private static int parseWriterThreadId(String line) {\n+        Pattern pattern = Pattern.compile(\"='(\\\\d+)'\");\n+        Matcher matcher = pattern.matcher(line);\n+        TestFramework.check(matcher.find(), \"should find writer thread id\");\n+        return Integer.parseInt(matcher.group(1));\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/parser\/hotspot\/WriterThreads.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,1 @@\n-            Utils.shouldHaveThrownException(baos.toString());\n+            Asserts.fail(\"Should have thrown exception\");\n@@ -67,1 +67,1 @@\n-            Utils.shouldHaveThrownException(baos.toString());\n+            Asserts.fail(\"Should have thrown exception\");\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/TestCheckedTests.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -236,1 +236,1 @@\n-            Utils.shouldHaveThrownException(baos.toString());\n+            Asserts.fail(\"Should have thrown exception\");\n@@ -368,1 +368,1 @@\n-            Utils.shouldHaveThrownException(baos.toString());\n+            Asserts.fail(\"Should have thrown exception\");\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/TestIRMatching.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n-import compiler.lib.ir_framework.driver.irmatching.parser.MethodCompilationParser;\n+import compiler.lib.ir_framework.driver.irmatching.parser.TestClassParser;\n@@ -70,3 +70,3 @@\n-        MethodCompilationParser methodCompilationParser = new MethodCompilationParser(testClass);\n-        Matchable testClassMatchable = methodCompilationParser.parse(testVMProcess.getHotspotPidFileName(),\n-                                                                     testVMProcess.getIrEncoding());\n+        TestClassParser testClassParser = new TestClassParser(testClass);\n+        Matchable testClassMatchable = testClassParser.parse(testVMProcess.getHotspotPidFileName(),\n+                                                             testVMProcess.getIrEncoding());\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/TestPhaseIRMatching.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,1 @@\n-            Utils.shouldHaveThrownException(baos.toString());\n+            Asserts.fail(\"Should have thrown exception\");\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/TestRunTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,143 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.testlibrary_tests.ir_framework.tests;\n+\n+import compiler.lib.ir_framework.CompilePhase;\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.IRNode;\n+import compiler.lib.ir_framework.Test;\n+import compiler.lib.ir_framework.driver.irmatching.IRMatcher;\n+import compiler.lib.ir_framework.driver.irmatching.Matchable;\n+import compiler.lib.ir_framework.driver.irmatching.parser.TestClassParser;\n+import jdk.test.lib.Utils;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+\n+\/*\n+ * @test\n+ * @bug 8300273\n+ * @requires vm.debug == true & vm.flagless\n+ * @summary Test TestClassParser such that it correctly parses the hotspot_pid* files with safepoint interruption messages\n+ * @library \/test\/lib \/testlibrary_tests \/\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run junit\/othervm -Xbootclasspath\/a:. -DSkipWhiteBoxInstall=true -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions\n+ *                    -XX:+WhiteBoxAPI compiler.testlibrary_tests.ir_framework.tests.TestSafepointWhilePrinting\n+ *\/\n+public class TestSafepointWhilePrinting {\n+    static int iFld;\n+\n+    @org.junit.Test\n+    public void test() throws IOException {\n+        String hotspotPidFileName = \"safepoint_while_printing_hotspot_pid.log\";\n+        Path hotspotPidFilePath = Paths.get(Utils.TEST_SRC).resolve(hotspotPidFileName);\n+        \/\/ Copy file to current workdir\n+        Files.copy(hotspotPidFilePath, Paths.get(\"\").resolve(hotspotPidFileName),\n+                   StandardCopyOption.REPLACE_EXISTING);\n+\n+        String irEncoding =\n+                \"\"\"\n+                ##### IRMatchRulesEncoding - used by TestFramework #####\n+                <method>,{comma separated applied @IR rule ids}\n+                test1,1\n+                test2,1\n+                testSafepointInBlock,1\n+                testQueueInBlock1,1\n+                testQueueInBlock2,1\n+                testDoubleInterruptOuter,1\n+                testDoubleInterruptMiddle,1\n+                testDoubleInterruptInner,1\n+                testCompilePhaseBackToBackFirst,1\n+                testCompilePhaseBackToBackLast,1\n+                ----- END -----\n+                \"\"\";\n+        TestClassParser testClassParser = new TestClassParser(TestSafepointWhilePrinting.class);\n+        Matchable testClassMatchable = testClassParser.parse(hotspotPidFileName, irEncoding);\n+        IRMatcher matcher = new IRMatcher(testClassMatchable);\n+        matcher.match();\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CMP_UL3, \"1\"})\n+    public void test1() {\n+        iFld = 34;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CMP_UL3, \"1\"})\n+    public void test2() {\n+        iFld = 34;\n+    }\n+\n+    @Test\n+    @IR(counts = {\"testSafepointInBlock @ bci:-1\", \"1\"}, phase = CompilePhase.PRINT_IDEAL)\n+    public void testSafepointInBlock() {\n+        iFld = 34;\n+    }\n+\n+    @Test\n+    @IR(counts = {\"testQueueInBlock1 @ bci:-1\", \"1\"}, phase = CompilePhase.PRINT_IDEAL)\n+    public void testQueueInBlock1() {\n+        iFld = 34;\n+    }\n+\n+    @Test\n+    @IR(counts = {\"testQueueInBlock2 @ bci:-1\", \"1\"}, phase = CompilePhase.PRINT_IDEAL)\n+    public void testQueueInBlock2() {\n+        iFld = 34;\n+    }\n+    @Test\n+    @IR(counts = {\"!jvms: TestSafepointWhilePrinting::testDoubleInterruptOuter\", \"1\"}, phase = CompilePhase.PRINT_IDEAL)\n+    public void testDoubleInterruptOuter() {\n+        iFld = 34;\n+    }\n+\n+    @Test\n+    @IR(counts = {\"testDoubleInterruptMiddle @ bci:-1\", \"1\", IRNode.CMP_UL3, \"1\"}, phase = CompilePhase.PRINT_IDEAL)\n+    public void testDoubleInterruptMiddle() {\n+        iFld = 34;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CON_L, \"1\"}, phase = CompilePhase.PRINT_IDEAL)\n+    public void testDoubleInterruptInner() {\n+        iFld = 34;\n+    }\n+\n+    @Test\n+    @IR(counts = {\"(line 115)\", \"1\", IRNode.CMP_UL3, \"1\"}, phase = {CompilePhase.AFTER_PARSING, CompilePhase.BEFORE_MATCHING})\n+    public void testCompilePhaseBackToBackFirst() {\n+        iFld = 34;\n+    }\n+\n+    @Test\n+    @IR(counts = {\"(line 115)\", \"1\", IRNode.CMP_UL3, \"1\"}, phase = {CompilePhase.AFTER_PARSING, CompilePhase.BEFORE_MATCHING})\n+    public void testCompilePhaseBackToBackLast() {\n+        iFld = 34;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/TestSafepointWhilePrinting.java","additions":143,"deletions":0,"binary":false,"changes":143,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,1 +55,1 @@\n-            Utils.shouldHaveThrownException(baos.toString());\n+            Asserts.fail(\"Should have thrown exception\");\n@@ -58,1 +58,1 @@\n-                Utils.throwIfNoSafepointPrinting(baos.toString(), e);\n+                throw e;\n@@ -65,1 +65,1 @@\n-            Utils.shouldHaveThrownException(baos.toString());\n+            Asserts.fail(\"Should have thrown exception\");\n@@ -68,1 +68,1 @@\n-                Utils.throwIfNoSafepointPrinting(baos.toString(), e);\n+                throw e;\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/TestScenarios.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,43 +0,0 @@\n-\/*\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package ir_framework.tests;\n-\n-import compiler.lib.ir_framework.driver.irmatching.IRMatcher;\n-import jdk.test.lib.Asserts;\n-\n-public class Utils {\n-    public static void shouldHaveThrownException(String output) {\n-        \/\/ Do not throw an exception if we hit a safepoint while printing which could possibly let the IR matching fail.\n-        \/\/ This happens very rarely. If there is a problem with the test, then we will catch that on the next test invocation.\n-        if (!output.contains(IRMatcher.SAFEPOINT_WHILE_PRINTING_MESSAGE)) {\n-            Asserts.fail(\"Should have thrown exception\");\n-        }\n-    }\n-\n-    public static void throwIfNoSafepointPrinting(String output, RuntimeException e) {\n-        if (!output.contains(IRMatcher.SAFEPOINT_WHILE_PRINTING_MESSAGE)) {\n-            throw e;\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/Utils.java","additions":0,"deletions":43,"binary":false,"changes":43,"status":"deleted"},{"patch":"@@ -0,0 +1,163 @@\n+<writer thread='1683653'\/>\n+   1682  967    b  3       jdk.test.lib.Asserts::assertEquals (7 bytes)\n+<nmethod compile_id='967' compiler='c1' level='3' entry='0x00007f29791d6440' size='912' address='0x00007f29791d6290' relocation_offset='352' insts_offset='432' stub_offset='648' scopes_data_offset='768' scopes_pcs_offset='808' dependencies_offset='904' oops_offset='752' metadata_offset='760' method='jdk.test.lib.Asserts assertEquals (Ljava\/lang\/Object;Ljava\/lang\/Object;)V' bytes='7' count='256' iicount='256' stamp='1.683'\/>\n+<writer thread='1683665'\/>\n+<task_queued compile_id='1013' method='compiler.testlibrary_tests.ir_framework.tests.TestSafepointWhilePrinting test2 (J)I' bytes='8' count='1000' iicount='1000' blocking='1' stamp='1.715' comment='whitebox' hot_count='1000'\/>\n+<writer thread='1683661'\/>\n+<task_queued compile_id='1008' method='java.util.Arrays copyOfRange ([Ljava\/lang\/Object;IILjava\/lang\/Class;)[Ljava\/lang\/Object;' bytes='90' count='257' iicount='257' level='3' blocking='1' stamp='1.714' comment='tiered' hot_count='256'\/>\n+<writer thread='1683666'\/>\n+<task_queued compile_id='1018' method='compiler.testlibrary_tests.ir_framework.tests.TestSafepointWhilePrinting test1 (J)I' bytes='8' count='1000' iicount='1000' blocking='1' stamp='1.715' comment='whitebox' hot_count='1000'\/>\n+<writer thread='1683670'\/>\n+<make_not_entrant thread='1683670' compile_id='995' compiler='c1' level='3' stamp='1.716'\/>\n+   1716  995       3       compiler.testlibrary_tests.ir_framework.tests.TestSafepointWhilePrinting::compareLongWithImm5 (8 bytes)   made not entrant\n+<writer thread='1683652'\/>\n+   1716 1018    b  4       compiler.testlibrary_tests.ir_framework.tests.TestSafepointWhilePrinting::test1 (8 bytes)\n+<writer thread='1683665'\/>\n+<task_queued compile_id='53' method='compiler.testlibrary_tests.ir_framework.tests.TestSafepointWhilePrinting testSafepointInBlock (J)I' bytes='8' count='1000' iicount='1000' blocking='1' stamp='1.715' comment='whitebox' hot_count='1000'\/>\n+<writer thread='1683653'\/>\n+   1716 1008    b  3       java.util.Arrays::copyOfRange (90 bytes)\n+<writer thread='1683670'\/>\n+   1716 1013    b  4       compiler.testlibrary_tests.ir_framework.tests.TestSafepointWhilePrinting::test2 (8 bytes)\n+<writer thread='1683663'\/>\n+<task_queued compile_id='1019' method='compiler.testlibrary_tests.ir_framework.tests.TestSafepointWhilePrinting notATest (I)I' bytes='7' count='1000' iicount='1000' blocking='1' stamp='1.716' comment='whitebox' hot_count='1000'\/>\n+<writer thread='1683652'\/>\n+<ideal compile_id='1018' compile_phase='print_ideal'>\n+AFTER: print_ideal\n+  0  Root  === 0 26  [[ 0 1 3 24 ]] inner\n+  3  Start  === 3 0  [[ 3 5 6 7 8 9 11 ]]  #{0:control, 1:abIO, 2:memory, 3:rawptr:BotPTR, 4:return_address, 5:compiler\/intrinsics\/TestSafepointWhilePrinting:NotNull *, 6:long, 7:half}\n+  5  Parm  === 3  [[ 26 ]] Control !jvms: TestSafepointWhilePrinting::test1 @ bci:-1 (line 115)\n+  6  Parm  === 3  [[ 26 ]] I_O !jvms:<!-- safepoint while printing -->\n+<writer thread='1683670'\/>\n+<ideal compile_id='1013' compile_phase='print_ideal'>\n+AFTER: print_ideal\n+  0  Root  === 0 26  [[ 0 1 3 24 ]] inner\n+  3  Start  === 3 0  [[ 3 5 6 7 8 9 11 ]]  #{0:control, 1:abIO, 2:memory, 3:rawptr:BotPTR, 4:return_address, 5:compiler\/intrinsics\/TestSafepointWhilePrinting:NotNull *, 6:long, 7:half}\n+  5  Parm  === 3  [[ 26 ]] Control !jvms: TestSafepointWhilePrinting::test2 @ bci:-1 (line 109)\n+  6  Parm  === 3  [[ 26 ]] I_O !jvms: TestSafepointWhilePrinting::test2 @ bci:-1 (line 109)\n+  7  Parm  === 3  [[ 26 ]] Memory  Memory: @BotPTR *+bot, idx=Bot; !jvms: TestSafepointWhilePrinting::test2 @ bci:-1 (line 109)\n+  8  Parm  === 3  [[ 26 ]] FramePtr !jvms: TestSafepointWhilePrinting::test2 @ bci:-1 (line 109)\n+  9  Parm  === 3  [[ 26 ]] ReturnAdr !jvms: TestSafepointWhilePrinting::test2 @ bci:-1 (line 109)\n+ 11  Parm  === 3  [[ 25 ]] Parm1: long !jvms: TestSafepointWhilePrinting::test2 @ bci:-1 (line 109)\n+ 24  ConL  === 0  [[ 25 ]]  #long:42\n+ 25  CmpUL3  === _ 11 24  [[ 26 ]]  !jvms: TestSafepointWhilePrinting::test2 @ bci:4 (line 109)\n+ 26  Return  === 5 6 7 8 9 returns 25  [[ 0 ]]\n+<\/ideal>\n+<writer thread='1683652'\/>\n+ TestSafepointWhilePrinting::test1 @ bci:-1 (line 115)\n+  7  Parm  === 3  [[ 26 ]] Memory  Memory: @BotPTR *+bot, idx=Bot; !jvms: TestSafepointWhilePrinting::test1 @ bci:-1 (line 115)\n+  8  Parm  === 3  [[ 26 ]] FramePtr !jvms: TestSafepointWhilePrinting::test1 @ bci:-1 (line 115)\n+  9  Parm  === 3  [[ 26 ]] ReturnAdr !jvms: TestSafepointWhilePrinting::test1 @ bci:-1 (line 115)\n+ 11  Parm  === 3  [[ 25 ]] Parm1: long !jvms: TestSafepointWhilePrinting::test1 @ bci:-1 (line 115)\n+ 24  ConL  === 0  [[ 25 ]]  #long:172032\n+ 25  CmpUL3  === _ 11 24  [[ 26 ]]  !jvms: TestSafepointWhilePrinting::test1 @ bci:4 (line 115)\n+ 26  Return  === 5 6 7 8 9 returns 25  [[ 0 ]]\n+<\/ideal>\n+<writer thread='1875264'\/>\n+<nmethod compile_id='1017' compiler='c2' level='4' entry='0x00007fa74cc08ea0' size='664' address='0x00007fa74cc08d10' relocation_offset='352' insts_offset='400' stub_offset='536' scopes_data_offset='576'\n+ scopes_pcs_offset='592' dependencies_offset='656' oops_offset='560' metadata_offset='568' method='compiler.intrinsics.TestCompareUnsigned compareLongWithImm3 (J)I' bytes='8' count='1000' iicount='1000'\n+stamp='1.785'\/>\n+<make_not_entrant thread='1875264' compile_id='993' compiler='c1' level='3' stamp='1.785'\/>\n+   1784  993       3       compiler.intrinsics.TestCompareUnsigned::compareLongWithImm3 (8 bytes)   made not entrant\n+   1784 1013    b  4       compiler.intrinsics.TestCompareUnsigned::compareLongWithImm1 (8 bytes)\n+<ideal compile_id='53' compile_phase='print_ideal'>\n+AFTER: print_ideal\n+  0  Root  === 0 26  [[ 0 1 3 24 ]] inner\n+  8  Parm  === 3  [[ 26 ]] FramePtr !jvms: TestSafepointWhilePrinting::testSafepointInBlock<!-- safepoint while printing -->\n+ @ bci:-1 (line 109)\n+ 24  ConL  === 0  [[ 25 ]]  #long:42\n+ 26  Return  === 5 6 7 8 9 returns 25  [[ 0 ]]\n+<\/ideal>\n+<writer thread='5165446'\/>\n+<task_queued compile_id='54' method='compiler.testlibrary_tests.ir_framework.tests.TestSafepointWhilePrinting testQueueInBlock1 (J)I' bytes='8' count='1000' iicount='1000' blocking='1' stamp='1.715' comment='whitebox' hot_count='1000'\/>\n+<writer thread='234'\/>\n+<ideal compile_id='54' compile_phase='print_ideal'>\n+AFTER: print_ideal\n+  0  Root  === 0 26  [[ 0 1 3 24 ]] inner\n+  8  Parm  === 3  [[ 26 ]] FramePtr !jvms: TestSafepointWhilePrinting::testQueueInBlock1<!-- safepoint while printing -->\n+<writer thread='235'\/>\n+<task_queued compile_id='55' method='compiler.testlibrary_tests.ir_framework.tests.TestSafepointWhilePrinting testQueueInBlock2 (J)I' bytes='8' count='1000' iicount='1000' blocking='1' stamp='1.715' comment='whitebox' hot_count='1000'\/>\n+<writer thread='234'\/>\n+ @ bci:-1 (line 109)\n+ 24  ConL  === 0  [[ 25 ]]  #long:42\n+ 26  Return  === 5 6 7 8 9 returns 25  [[ 0 ]]\n+<\/ideal>\n+<ideal compile_id='55' compile_phase='print_ideal'>\n+AFTER: print_ideal\n+  0  Root  === 0 26  [[ 0 1 3 24 ]] inner\n+  8  Parm  === 3  [[ 26 ]] FramePtr !jvms: TestSafepointWhilePrinting::testQueueInBlock2<!-- safepoint while printing -->\n+ @ bci:-1 (line 109)\n+ 24  ConL  === 0  [[ 25 ]]  #long:42\n+ 26  Return  === 5 6 7 8 9 returns 25  [[ 0 ]]\n+<\/ideal>\n+<writer thread='343523525'\/>\n+<task_queued compile_id='61' method='compiler.testlibrary_tests.ir_framework.tests.TestSafepointWhilePrinting testDoubleInterruptOuter (J)I' bytes='8' count='1000' iicount='1000' blocking='1' stamp='1.715' comment='whitebox' hot_count='1000'\/>\n+<writer thread='343523525'\/>\n+<task_queued compile_id='62' method='compiler.testlibrary_tests.ir_framework.tests.TestSafepointWhilePrinting testDoubleInterruptMiddle (J)I' bytes='8' count='1000' iicount='1000' blocking='1' stamp='1.715' comment='whitebox' hot_count='1000'\/>\n+<writer thread='1001'\/>\n+<ideal compile_id='61' compile_phase='print_ideal'>\n+AFTER: print_ideal\n+  0  Root  === 0 26  [[ 0 1 3 24 ]] inner\n+  3  Start  === 3 0  [[ 3 5 6 7 8 9 11 ]]  #{0:control, 1:abIO, 2:memory, 3:rawptr:BotPTR, 4:return_address, 5:compiler\/intrinsics\/TestSafepointWhilePrinting:NotNull *, 6:long, 7:half}\n+  6  Parm  === 3  [[ 26 ]] I_O !jvms:<!-- safepoint while printing -->\n+<writer thread='1002'\/>\n+<ideal compile_id='62' compile_phase='print_ideal'>\n+AFTER: print_ideal\n+  0  Root  === 0 26  [[ 0 1 3 24 ]] inner\n+  8  Parm  === 3  [[ 26 ]] FramePtr !jvms: TestSafepointWhilePrinting::testDoubleInterruptMiddle<!-- safepoint while printing -->\n+ @ bci:-1 (line 109)\n+ 25  Cmp<!-- safepoint while printing -->\n+<writer thread='9999'\/>\n+<task_queued compile_id='63' method='compiler.testlibrary_tests.ir_framework.tests.TestSafepointWhilePrinting testDoubleInterruptInner (J)I' bytes='8' count='1000' iicount='1000' blocking='1' stamp='1.715' comment='whitebox' hot_count='1000'\/>\n+<writer thread='1003'\/>\n+<ideal compile_id='63' compile_phase='print_ideal'>\n+  24  ConL  === 0  [[ 25 ]]  #long:42\n+  26  Return  === 5 6 7 8 9 returns 25  [[ 0 ]]\n+<\/ideal>\n+<writer thread='1002'\/>\n+UL3  === _ 11 24  [[ 26 ]]  !jvms: TestSafepointWhilePrinting::test2 @ bci:4 (line 109)\n+ 26  Return  === 5 6 7 8 9 returns 25  [[ 0 ]]\n+<\/ideal>\n+<writer thread='1001'\/>\n+ TestSafepointWhilePrinting::testDoubleInterruptOuter @ bci:-1 (line 115)\n+  7  Parm  === 3  [[ 26 ]] Memory  Memory: @BotPTR *+bot, idx=Bot; !jvms: TestSafepointWhilePrinting::test1 @ bci:-1 (line 115)\n+  8  Parm  === 3  [[ 26 ]] FramePtr !jvms: TestSafepointWhilePrinting::test1 @ bci:-1 (line 115)\n+  9  Parm  === 3  [[ 26 ]] ReturnAdr !jvms: TestSafepointWhilePrinting::test1 @ bci:-1 (line 115)\n+ 11  Parm  === 3  [[ 25 ]] Parm1: long !jvms: TestSafepointWhilePrinting::test1 @ bci:-1 (line 115)\n+ 24  ConL  === 0  [[ 25 ]]  #long:172032\n+ 25  CmpUL3  === _ 11 24  [[ 26 ]]  !jvms: TestSafepointWhilePrinting::test1 @ bci:4 (line 115)\n+ 26  Return  === 5 6 7 8 9 returns 25  [[ 0 ]]\n+<\/ideal>\n+<writer thread='100000'\/>\n+<task_queued compile_id='72' method='compiler.testlibrary_tests.ir_framework.tests.TestSafepointWhilePrinting testCompilePhaseBackToBackFirst (J)I' bytes='8' count='1000' iicount='1000' blocking='1' stamp='1.715' comment='whitebox' hot_count='1000'\/>\n+<writer thread='72'\/>\n+<ideal compile_id='72' compile_phase='AFTER_PARSING'>\n+ 24  ConL  === 0  [[ 25 ]]  #long:172032\n+ 25  CmpUL<!-- safepoint while printing -->\n+<writer thread='71'\/>\n+<task_queued compile_id='71' method='compiler.testlibrary_tests.ir_framework.tests.TestSafepointWhilePrinting testCompilePhaseBackToBackLast (J)I' bytes='8' count='1000' iicount='1000' blocking='1' stamp='1.715' comment='whitebox' hot_count='1000'\/>\n+<ideal compile_id='71' compile_phase='AFTER_PARSING'>\n+ 24  ConL  === 0  [[ 25 ]]  #long:172032\n+ 25  CmpUL3  === _ 11 24  [[ 26 ]]  !jvms: TestSafepointWhilePrinting::test1 @ bci:4 (line 115)\n+<\/ideal>\n+<ideal compile_id='71' compile_phase='BEFORE_MATCHING'>\n+ 24  ConL  === 0  [[ 25 ]]  #long:172032\n+ 25  CmpU<!-- safepoint while printing -->\n+<writer thread='72'\/>\n+3  === _ 11 24  [[ 26 ]]  !jvms: TestSafepointWhilePrinting::test1 @ bci:4 (<!-- safepoint while printing -->\n+<writer thread='71'\/>\n+L3  === _ 11 24  [[ 26 ]]  !jvms: TestSafepointWhilePrinting::test1 @ bci:4 (line <!-- safepoint while printing -->\n+<writer thread='72'\/>\n+line 115)\n+<\/ideal>\n+<writer thread='9999'\/>\n+<task_queued compile_id='3333' method='compiler.testlibrary_tests.ir_framework.tests.TestSafepointWhilePrinting asdf (J)I' bytes='8' count='1000' iicount='1000' blocking='1' stamp='1.715' comment='whitebox' hot_count='1000'\/>\n+<writer thread='72'\/>\n+<ideal compile_id='72' compile_phase='BEFORE_MATCHING'>\n+ 24  ConL  === 0  [[ 25 ]]  #long:172032\n+ 25  CmpU<!-- safepoint while printing -->\n+<writer thread='71'\/>\n+115)\n+<\/ideal>\n+<writer thread='72'\/>\n+L3  === _ 11 24  [[ 26 ]]  !jvms: TestSafepointWhilePrinting::test1 @ bci:4 (line 115)\n+<\/ideal>\n\\ No newline at end of file\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/safepoint_while_printing_hotspot_pid.log","additions":163,"deletions":0,"binary":false,"changes":163,"status":"added"}]}