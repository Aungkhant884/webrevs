{"files":[{"patch":"@@ -304,1 +304,6 @@\n-                        return doInBackground();\n+                        try {\n+                            return doInBackground();\n+                        } finally {\n+                            doneEDT();\n+                            setState(StateValue.DONE);\n+                        }\n@@ -308,7 +313,1 @@\n-        future = new FutureTask<T>(callable) {\n-                       @Override\n-                       protected void done() {\n-                           doneEDT();\n-                           setState(StateValue.DONE);\n-                       }\n-                   };\n+       future = new FutureTask<T>(callable);\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/SwingWorker.java","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,147 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/*\n+ * @test\n+ * @bug 8081474\n+ * @summary  Verifies if SwingWorker calls 'done'\n+ *           before the 'doInBackground' is finished\n+ * @run main TestDoneBeforeDoInBackground\n+ *\/\n+import java.beans.PropertyChangeListener;\n+import java.beans.PropertyChangeEvent;\n+import javax.swing.SwingWorker;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+public class TestDoneBeforeDoInBackground {\n+\n+    private static final int WAIT_TIME = 200;\n+    private static final long CLEANUP_TIME = 1000;\n+\n+    private static final AtomicBoolean doInBackgroundStarted = new AtomicBoolean(false);\n+    private static final AtomicBoolean doInBackgroundFinished = new AtomicBoolean(false);\n+    private static final AtomicBoolean doneFinished = new AtomicBoolean(false);\n+    private static final CountDownLatch doneLatch = new CountDownLatch(1);\n+\n+    public static void main(String[] args) throws InterruptedException {\n+        SwingWorker<String, String> worker = new SwingWorker<>() {\n+            @Override\n+            protected String doInBackground() throws Exception {\n+                try {\n+                    while (!Thread.currentThread().isInterrupted()) {\n+                        System.out.println(\"Working...\");\n+                        Thread.sleep(WAIT_TIME);\n+                    }\n+                } catch (InterruptedException ex) {\n+                    System.out.println(\"Got interrupted!\");\n+                }\n+\n+                try {\n+                    doInBackgroundStarted.set(true);\n+                    System.out.println(\"Cleaning up\");\n+                    Thread.sleep(CLEANUP_TIME);\n+                    System.out.println(\"Done cleaning\");\n+                    doInBackgroundFinished.set(true);\n+                } catch (InterruptedException ex) {\n+                    System.out.println(\"Got interrupted second time!\");\n+                }\n+\n+                return null;\n+            }\n+\n+            @Override\n+            protected void done() {\n+                if (!doInBackgroundFinished.get()) {\n+                    throw new RuntimeException(\"done called before \" +\n+                                               \"doInBackground is finished\");\n+                }\n+                System.out.println(\"Done\");\n+                doneFinished.set(true);\n+                doneLatch.countDown();\n+            }\n+        };\n+\n+        worker.addPropertyChangeListener(\n+            new PropertyChangeListener() {\n+                public void propertyChange(PropertyChangeEvent evt) {\n+                    System.out.println(\"doInBackground started: \" +\n+                                        doInBackgroundStarted.get() +\n+                                        \" doInBackgroundFinished: \" +\n+                                        doInBackgroundFinished.get() +\n+                                        \" done: \" + doneFinished.get() +\n+                                        \" state: \" + worker.getState());\n+                    \/\/ Before doInBackground method is invoked,\n+                    \/\/ SwingWorker notifies PropertyChangeListeners about the\n+                    \/\/ property change to StateValue.STARTED\n+                    if (doInBackgroundStarted.get()\n+                        && worker.getState() == SwingWorker.StateValue.STARTED) {\n+                        throw new RuntimeException(\n+                               \"PropertyChangeListeners called with \" +\n+                               \"state STARTED after doInBackground is invoked\");\n+                    }\n+\n+                    \/\/ Ensure DONE state is notified AFTER\n+                    \/\/ doInBackground is finished AND done is invoked\n+                    if (doInBackgroundFinished.get() && !doneFinished.get()\n+                        && worker.getState() == SwingWorker.StateValue.DONE) {\n+                        throw new RuntimeException(\n+                              \"done method is NOT executed but state is DONE\");\n+                    }\n+\n+                    \/\/ After the doInBackground method is finished\n+                    \/\/ SwingWorker notifies PropertyChangeListeners\n+                    \/\/ property change to StateValue.DONE\n+                    if (worker.getState() != SwingWorker.StateValue.DONE\n+                        && doInBackgroundFinished.get()) {\n+                        throw new RuntimeException(\n+                            \"PropertyChangeListeners called after \" +\n+                            \"doInBackground is finished but before State changed to DONE\");\n+                    }\n+                }\n+            });\n+        worker.execute();\n+        Thread.sleep(WAIT_TIME * 3);\n+\n+        final long start = System.currentTimeMillis();\n+        worker.cancel(true);\n+        final long end = System.currentTimeMillis();\n+\n+        if ((end - start) > 100) {\n+            throw new RuntimeException(\"Cancel took too long: \"\n+                                       + ((end - start) \/ 1000.0d) + \" s\");\n+        }\n+        if (!doneLatch.await(CLEANUP_TIME + 1000L, TimeUnit.MILLISECONDS)) {\n+            throw new RuntimeException(\"done didn't complete in time\");\n+        }\n+        System.out.println(\"doInBackground \" + doInBackgroundFinished.get() +\n+                           \" getState \" + worker.getState());\n+        if (worker.getState() != SwingWorker.StateValue.DONE\n+            && doInBackgroundFinished.get()) {\n+            throw new RuntimeException(\"doInBackground is finished \" +\n+                                       \"but State is not DONE\");\n+        }\n+    }\n+}\n+\n+\n","filename":"test\/jdk\/javax\/swing\/SwingWorker\/TestDoneBeforeDoInBackground.java","additions":147,"deletions":0,"binary":false,"changes":147,"status":"added"}]}