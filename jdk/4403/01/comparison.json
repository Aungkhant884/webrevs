{"files":[{"patch":"@@ -157,8 +157,4 @@\n-                \/\/ Classes compiled prior to dynamic nestmate support invokes a private instance\n-                \/\/ method with REF_invokeSpecial.\n-                \/\/\n-                \/\/ invokespecial should only be used to invoke private nestmate constructors.\n-                \/\/ The lambda proxy class will be defined as a nestmate of targetClass.\n-                \/\/ If the method to be invoked is an instance method of targetClass, then\n-                \/\/ convert to use invokevirtual or invokeinterface.\n-                if (targetClass == implClass && !implInfo.getName().equals(\"<init>\")) {\n+                \/\/ Classes compiled prior to dynamic nestmate support invoke a private instance\n+                \/\/ method with REF_invokeSpecial. Newer classes use REF_invokeVirtual or\n+                \/\/ REF_invokeInterface, and we can use that instruction in the lambda class.\n+                if (targetClass == implClass) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/AbstractValidatingLambdaMetafactory.java","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -183,2 +183,9 @@\n-        useImplMethodHandle = !Modifier.isPublic(implInfo.getModifiers()) &&\n-                              !VerifyAccess.isSamePackage(implClass, implInfo.getDeclaringClass());\n+        \/\/ If the target class invokes a protected method inherited from a\n+        \/\/ superclass in a different package, or does 'invokespecial', the\n+        \/\/ lambda class has no access to the resolved method. Instead, we need\n+        \/\/ to pass the live implementation method handle to the proxy class\n+        \/\/ to invoke directly. (javac prefers to avoid this situation by\n+        \/\/ generating bridges in the target class)\n+        useImplMethodHandle = (Modifier.isProtected(implInfo.getModifiers()) &&\n+                               !VerifyAccess.isSamePackage(implClass, implInfo.getDeclaringClass())) ||\n+                               implKind == H_INVOKESPECIAL;\n@@ -397,7 +404,0 @@\n-                \/\/ If the target class invokes a method reference this::m which is\n-                \/\/ resolved to a protected method inherited from a superclass in a different\n-                \/\/ package, the target class does not have a bridge and this method reference\n-                \/\/ has been changed from public to protected after the target class was compiled.\n-                \/\/ This lambda proxy class has no access to the resolved method.\n-                \/\/ So this workaround by passing the live implementation method handle\n-                \/\/ to the proxy class to invoke directly.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -156,3 +156,2 @@\n-        \/\/ 8268192: these fail with a VerifyError, need to fix\n-        \/\/mfSucceed(C.lookup, \"m\", toI, cToString, C.invokeSpecialMH(), cToString);\n-        \/\/amfSucceed(C.lookup, \"m\", toI, arr(cToString, C.invokeSpecialMH(), cToString, flagSer));\n+        mfSucceed(C.lookup, \"m\", toI, cToString, C.invokeSpecialMH(), cToString);\n+        amfSucceed(C.lookup, \"m\", toI, arr(cToString, C.invokeSpecialMH(), cToString, flagSer));\n","filename":"test\/jdk\/java\/lang\/invoke\/lambda\/MetafactoryArgValidationTest.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"}]}