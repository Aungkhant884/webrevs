{"files":[{"patch":"@@ -330,1 +330,1 @@\n-            int hash = name.hashCode() * 43 + mods.hashCode();\n+            int hash = name.hashCode() * 43 + ordinalHashCode(mods);\n@@ -508,1 +508,1 @@\n-            int hash = mods.hashCode();\n+            int hash = ordinalHashCode(mods);\n@@ -711,1 +711,1 @@\n-            int hash = mods.hashCode();\n+            int hash = ordinalHashCode(mods);\n@@ -2264,1 +2264,1 @@\n-            hc = hc * 43 + Objects.hashCode(modifiers);\n+            hc = hc * 43 + ordinalHashCode(modifiers);\n@@ -2549,0 +2549,12 @@\n+    \/**\n+     * Generates and returns a hashcode for the enum instances. The returned hashcode\n+     * is a sum of each of the enum instances' {@link Enum#ordinal() ordinal} value.\n+     *\/\n+    private static int ordinalHashCode(Iterable<? extends Enum<?>> enums) {\n+        int h = 0;\n+        for (Enum<?> e : enums) {\n+            h += e.ordinal();\n+        }\n+        return h;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/module\/ModuleDescriptor.java","additions":16,"deletions":4,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -0,0 +1,138 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.lang.module.ModuleDescriptor;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+\/**\n+ * @test\n+ * @bug 8275509\n+ * @library \/test\/lib\n+ * @run driver ModuleDescriptorHashCodeTest\n+ * @summary Tests that the ModuleDescriptor.hashCode() method returns the same hash code\n+ * across multiple JVM runs, for the same module descriptor.\n+ *\/\n+public class ModuleDescriptorHashCodeTest {\n+\n+    \/**\n+     * Launches multiple instances of a Java program which verifies the hashCode() of a\n+     * ModuleDescriptor, which is loaded from the boot layer as well as constructed using\n+     * the ModuleDescriptor.Builder. It is expected that every single run of this program\n+     * will generate the exact same hash code for the module descriptor of the same module.\n+     *\/\n+    public static void main(String[] args) throws Exception {\n+        Set<Module> bootModules = ModuleLayer.boot().modules();\n+        for (Module bootModule : bootModules) {\n+            ModuleDescriptor md = bootModule.getDescriptor();\n+            int expectedHashCode = md.hashCode();\n+            System.out.println(\"Expected ModuleDescriptor.hashCode() of boot module \"\n+                    + bootModule.getName() + \" is \" + expectedHashCode);\n+            int numProcesses = 2;\n+            for (int i = 0; i < numProcesses; i++) {\n+                \/\/ run some with CDS enabled and some with CDS disabled\n+                boolean disableCDS = (i % 2 == 0);\n+                String[] processArgs;\n+                if (disableCDS) {\n+                    processArgs = new String[]{\"-Xshare:off\",\n+                            HashCodeChecker.class.getName(),\n+                            bootModule.getName(),\n+                            String.valueOf(expectedHashCode)};\n+                } else {\n+                    processArgs = new String[]{HashCodeChecker.class.getName(),\n+                            bootModule.getName(),\n+                            String.valueOf(expectedHashCode)};\n+                }\n+                ProcessBuilder processBuilder = ProcessTools.createJavaProcessBuilder(processArgs);\n+                long start = System.currentTimeMillis();\n+                OutputAnalyzer outputAnalyzer = ProcessTools.executeProcess(processBuilder);\n+                System.out.println(\"Process \" + outputAnalyzer.pid() + \" completed in \"\n+                        + (System.currentTimeMillis() - start) + \" milli seconds\");\n+                outputAnalyzer.shouldHaveExitValue(0);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Loads the passed module from the boot layer and compares the hashCode of that module's\n+     * descriptor with the expected hash code (which is passed as an argument).\n+     * Then uses the {@link ModuleDescriptor.Builder} to construct a module descriptor for the\n+     * same module and verifies that it too has the same hash code.\n+     *\/\n+    private static void assertExpectedHashCode(String moduleName, int expectedHashCode) throws Exception {\n+        Optional<Module> bootModule = ModuleLayer.boot().findModule(moduleName);\n+        if (bootModule.isEmpty()) {\n+            throw new RuntimeException(\"Boot module \" + moduleName + \" is missing\");\n+        }\n+        ModuleDescriptor bootMD = bootModule.get().getDescriptor();\n+        int actualHashCode = bootMD.hashCode();\n+        if (actualHashCode != expectedHashCode) {\n+            throw new RuntimeException(\"Expected hashCode \" + expectedHashCode + \" but got \" + actualHashCode\n+                    + \" from boot module descriptor \" + bootMD);\n+        }\n+        System.out.println(\"Got expected hashCode of \" + expectedHashCode + \" for boot module descriptor \" + bootMD);\n+        ModuleDescriptor mdFromBuilder = fromModuleInfoClass(bootModule.get());\n+        \/\/ verify that this object is indeed a different object instance than the boot module descriptor\n+        \/\/ to prevent any artificial passing of the test\n+        if (bootMD == mdFromBuilder) {\n+            throw new RuntimeException(\"ModuleDescriptor loaded from boot layer and \" +\n+                    \"one created from module-info.class unexpectedly returned the same instance: \" + bootMD);\n+        }\n+        int hashCode = mdFromBuilder.hashCode();\n+        if (expectedHashCode != hashCode) {\n+            throw new RuntimeException(\"Expected hashCode \" + expectedHashCode + \" but got \" + hashCode\n+                    + \" from module descriptor \" + mdFromBuilder);\n+        }\n+        \/\/ invoke a few times to make sure the hashCode doesn't change within the same JVM run\n+        for (int i = 0; i < 5; i++) {\n+            int h = mdFromBuilder.hashCode();\n+            if (expectedHashCode != h) {\n+                throw new RuntimeException(\"Expected hashCode \" + expectedHashCode + \" but got \" + h\n+                        + \" from module descriptor \" + mdFromBuilder);\n+            }\n+        }\n+    }\n+\n+    private static class HashCodeChecker {\n+        public static void main(String[] args) throws Exception {\n+            \/\/ args[0] is module name\n+            \/\/ args[1] is the expected hash code of that module descriptor\n+            ModuleDescriptorHashCodeTest.assertExpectedHashCode(args[0], Integer.parseInt(args[1]));\n+        }\n+    }\n+\n+    \/\/ Returns a ModuleDescriptor parsed out of the module-info.class of the passed Module\n+    private static ModuleDescriptor fromModuleInfoClass(Module module) throws IOException {\n+        try (InputStream moduleInfo = module.getResourceAsStream(\"module-info.class\")) {\n+            if (moduleInfo == null) {\n+                throw new RuntimeException(\"Could not locate module-info.class in \" + module);\n+            }\n+            return ModuleDescriptor.read(moduleInfo);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/module\/ModuleDescriptorHashCodeTest.java","additions":138,"deletions":0,"binary":false,"changes":138,"status":"added"}]}