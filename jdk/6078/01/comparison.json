{"files":[{"patch":"@@ -330,1 +330,1 @@\n-            int hash = name.hashCode() * 43 + mods.hashCode();\n+            int hash = name.hashCode() * 43 + ordinalHashCode(mods);\n@@ -508,1 +508,1 @@\n-            int hash = mods.hashCode();\n+            int hash = ordinalHashCode(mods);\n@@ -711,1 +711,1 @@\n-            int hash = mods.hashCode();\n+            int hash = ordinalHashCode(mods);\n@@ -2264,1 +2264,1 @@\n-            hc = hc * 43 + Objects.hashCode(modifiers);\n+            hc = hc * 43 + ordinalHashCode(modifiers);\n@@ -2549,0 +2549,12 @@\n+    \/**\n+     * Generates and returns a hashcode for the enum instances. The returned hashcode\n+     * is a sum of each of the enum instances' {@link Enum#ordinal() ordinal} value.\n+     *\/\n+    private static int ordinalHashCode(final Iterable<? extends Enum<?>> enums) {\n+        int h = 0;\n+        for (Enum<?> e : enums) {\n+            h += e.ordinal();\n+        }\n+        return h;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/module\/ModuleDescriptor.java","additions":16,"deletions":4,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -0,0 +1,159 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.lang.module.ModuleDescriptor;\n+import java.util.Optional;\n+\n+\/**\n+ * @test\n+ * @bug 8275509\n+ * @library \/test\/lib\n+ * @run driver ModuleDescriptorHashCodeTest\n+ * @summary Tests that the ModuleDescriptor.hashCode() method returns the same hash code\n+ * across multiple JVM runs, for the same module descriptor.\n+ *\/\n+public class ModuleDescriptorHashCodeTest {\n+\n+    \/**\n+     * Launches multiple instances of a Java program which verifies the hashCode() of a\n+     * ModuleDescriptor, which is loaded from the boot layer as well as constructed using\n+     * the ModuleDescriptor.Builder. It is expected that every single run of this program\n+     * will generate the exact same hash code for the module descriptor of the same module.\n+     *\/\n+    public static void main(final String[] args) throws Exception {\n+        final ModuleDescriptor md = fromBootLayer().getDescriptor();\n+        assertTestPrerequisite(md);\n+        final int expectedHashCode = md.hashCode();\n+        int numProcesses = 50;\n+        for (int i = 0; i < numProcesses; i++) {\n+            \/\/ run some with CDS enabled and some with CDS disabled\n+            final boolean disableCDS = (i % 2 == 0);\n+            final String[] processArgs;\n+            if (disableCDS) {\n+                processArgs = new String[]{\"-Xshare:off\",\n+                        HashCodeChecker.class.getName(),\n+                        String.valueOf(expectedHashCode)};\n+            } else {\n+                processArgs = new String[]{HashCodeChecker.class.getName(),\n+                        String.valueOf(expectedHashCode)};\n+            }\n+            final ProcessBuilder processBuilder = ProcessTools.createJavaProcessBuilder(processArgs);\n+            final long start = System.currentTimeMillis();\n+            final OutputAnalyzer outputAnalyzer = ProcessTools.executeProcess(processBuilder);\n+            System.out.println(\"Process \" + outputAnalyzer.pid() + \" completed in \"\n+                    + (System.currentTimeMillis() - start) + \" milli seconds\");\n+            outputAnalyzer.shouldHaveExitValue(0);\n+        }\n+    }\n+\n+    private static class HashCodeChecker {\n+\n+        \/**\n+         * Loads the java.sql module from boot layer and compares the hashCode of that module's\n+         * descriptor with the expected hash code (which is passed as an argument to the program).\n+         * Then uses the {@link ModuleDescriptor.Builder} to construct a module descriptor for the\n+         * same module and verifies that it too has the same hash code.\n+         *\/\n+        public static void main(final String[] args) throws Exception {\n+            final int expectedHashCode = Integer.parseInt(args[0]);\n+            final Module bootModule = fromBootLayer();\n+            final ModuleDescriptor bootMD = bootModule.getDescriptor();\n+            final int actualHashCode = bootMD.hashCode();\n+            if (actualHashCode != expectedHashCode) {\n+                throw new RuntimeException(\"Expected hashCode \" + expectedHashCode + \" but got \" + actualHashCode\n+                        + \" from boot module descriptor \" + bootMD);\n+            }\n+            System.out.println(\"Got expected hashCode of \" + expectedHashCode + \" for boot module descriptor \" + bootMD);\n+            final ModuleDescriptor mdFromBuilder = fromModuleInfoClass(bootModule);\n+            \/\/ verify that this object is indeed a different object instance than the boot module descriptor\n+            \/\/ to prevent any artificial passing of the test\n+            if (bootMD == mdFromBuilder) {\n+                throw new RuntimeException(\"ModuleDescriptor loaded from boot layer and \" +\n+                        \"one created from module-info.class unexpectedly returned the same instance: \" + bootMD);\n+            }\n+            \/\/ TODO: Enable this check once JDK-8275731 is fixed. Right now this check fails when CDS is enabled.\n+            \/\/if (!bootMD.equals(mdFromBuilder)) {\n+            \/\/    throw new RuntimeException(\"Expected \" + bootMD + \" and \" + mdFromBuilder\n+            \/\/            + \" to be equal, but they aren't\");\n+            \/\/}\n+            final int hashCode = mdFromBuilder.hashCode();\n+            if (expectedHashCode != hashCode) {\n+                throw new RuntimeException(\"Expected hashCode \" + expectedHashCode + \" but got \" + hashCode\n+                        + \" from module descriptor \" + mdFromBuilder);\n+            }\n+            \/\/ invoke a few times to make sure the hashCode doesn't change within the same JVM run\n+            for (int i = 0; i < 5; i++) {\n+                final int h = mdFromBuilder.hashCode();\n+                if (expectedHashCode != h) {\n+                    throw new RuntimeException(\"Expected hashCode \" + expectedHashCode + \" but got \" + h\n+                            + \" from module descriptor \" + mdFromBuilder);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void assertTestPrerequisite(final ModuleDescriptor moduleDescriptor) {\n+        \/\/ The test case needs a module whose descriptor has at least one \"requires\" with a \"modifier\"\n+        \/\/ set. This is to ensure that the hashCode tests that we run in this test case,\n+        \/\/ do indeed trigger the hashCode() calls against the \"modifier\" enums.\n+        \/\/ At the time of writing this test, the test does indeed use such a boot module which satisfies\n+        \/\/ that criteria. However, we want to be sure that any future\n+        \/\/ changes to that module definition don't create artificial success of the test case.\n+        for (ModuleDescriptor.Requires requirement : moduleDescriptor.requires()) {\n+            if (!requirement.modifiers().isEmpty()) {\n+                return;\n+            }\n+        }\n+        throw new RuntimeException(moduleDescriptor + \" doesn't have a \\\"requires\\\" with a \\\"modifier\\\"\");\n+    }\n+\n+    \/\/ Finds and returns the java.sql module from the boot layer\n+    private static Module fromBootLayer() {\n+        \/\/ we use \"java.sql\" as the module of choice because its module definition has\n+        \/\/ at least one \"requires\" with a \"modifier\":\n+        \/\/  requires transitive java.logging;\n+        \/\/  requires transitive java.transaction.xa;\n+        \/\/  requires transitive java.xml;\n+        final String moduleName = \"java.sql\";\n+        final Optional<Module> bootModule = ModuleLayer.boot().findModule(moduleName);\n+        if (bootModule.isEmpty()) {\n+            throw new RuntimeException(moduleName + \" module is missing in boot layer\");\n+        }\n+        return bootModule.get();\n+    }\n+\n+    \/\/ Returns a ModuleDescriptor parsed out of the module-info.class of the passed Module\n+    private static ModuleDescriptor fromModuleInfoClass(final Module module) throws IOException {\n+        try (final InputStream moduleInfo = module.getResourceAsStream(\"module-info.class\")) {\n+            if (moduleInfo == null) {\n+                throw new RuntimeException(\"Could not locate module-info.class in \" + module);\n+            }\n+            return ModuleDescriptor.read(moduleInfo);\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/lang\/module\/ModuleDescriptorHashCodeTest.java","additions":159,"deletions":0,"binary":false,"changes":159,"status":"added"}]}