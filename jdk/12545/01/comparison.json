{"files":[{"patch":"@@ -63,1 +63,3 @@\n-    private static final double TWO54   =  0x1.0p54; \/\/ 1.80143985094819840000e+16\n+    private static final double TWO54    = 0x1.0p54; \/\/ 1.80143985094819840000e+16\n+    private static final double HUGE     = 1.0e+300;\n+\n@@ -105,0 +107,290 @@\n+    \/** Returns the arcsine of x.\n+     *\n+     * Method :\n+     *      Since  asin(x) = x + x^3\/6 + x^5*3\/40 + x^7*15\/336 + ...\n+     *      we approximate asin(x) on [0,0.5] by\n+     *              asin(x) = x + x*x^2*R(x^2)\n+     *      where\n+     *              R(x^2) is a rational approximation of (asin(x)-x)\/x^3\n+     *      and its remez error is bounded by\n+     *              |(asin(x)-x)\/x^3 - R(x^2)| < 2^(-58.75)\n+     *\n+     *      For x in [0.5,1]\n+     *              asin(x) = pi\/2-2*asin(sqrt((1-x)\/2))\n+     *      Let y = (1-x), z = y\/2, s := sqrt(z), and pio2_hi+pio2_lo=pi\/2;\n+     *      then for x>0.98\n+     *              asin(x) = pi\/2 - 2*(s+s*z*R(z))\n+     *                      = pio2_hi - (2*(s+s*z*R(z)) - pio2_lo)\n+     *      For x<=0.98, let pio4_hi = pio2_hi\/2, then\n+     *              f = hi part of s;\n+     *              c = sqrt(z) - f = (z-f*f)\/(s+f)         ...f+c=sqrt(z)\n+     *      and\n+     *              asin(x) = pi\/2 - 2*(s+s*z*R(z))\n+     *                      = pio4_hi+(pio4-2s)-(2s*z*R(z)-pio2_lo)\n+     *                      = pio4_hi+(pio4-2f)-(2s*z*R(z)-(pio2_lo+2c))\n+     *\n+     * Special cases:\n+     *      if x is NaN, return x itself;\n+     *      if |x|>1, return NaN with invalid signal.\n+     *\n+     *\/\n+    static class Asin {\n+        private Asin() {throw new UnsupportedOperationException();}\n+\n+        private static final double\n+            pio2_hi = 0x1.921fb54442d18p0,   \/\/  1.57079632679489655800e+00\n+            pio2_lo = 0x1.1a62633145c07p-54, \/\/  6.12323399573676603587e-17\n+            pio4_hi = 0x1.921fb54442d18p-1,  \/\/  7.85398163397448278999e-01\n+        \/\/ coefficient for R(x^2)\n+            pS0 =  0x1.5555555555555p-3,     \/\/  1.66666666666666657415e-01\n+            pS1 = -0x1.4d61203eb6f7dp-2,     \/\/ -3.25565818622400915405e-01\n+            pS2 =  0x1.9c1550e884455p-3,     \/\/  2.01212532134862925881e-01\n+            pS3 = -0x1.48228b5688f3bp-5,     \/\/ -4.00555345006794114027e-02\n+            pS4 =  0x1.9efe07501b288p-11,    \/\/  7.91534994289814532176e-04\n+            pS5 =  0x1.23de10dfdf709p-15,    \/\/  3.47933107596021167570e-05\n+            qS1 = -0x1.33a271c8a2d4bp1,      \/\/ -2.40339491173441421878e+00\n+            qS2 =  0x1.02ae59c598ac8p1,      \/\/  2.02094576023350569471e+00\n+            qS3 = -0x1.6066c1b8d0159p-1,     \/\/ -6.88283971605453293030e-01\n+            qS4 =  0x1.3b8c5b12e9282p-4;     \/\/  7.70381505559019352791e-02\n+\n+        static double compute(double x) {\n+            double t = 0, w, p, q, c, r, s;\n+            int hx, ix;\n+            hx = __HI(x);\n+            ix = hx & 0x7fff_ffff;\n+            if (ix >= 0x3ff0_0000) {           \/\/ |x| >= 1\n+                if(((ix - 0x3ff0_0000) | __LO(x)) == 0) {\n+                    \/\/ asin(1) = +-pi\/2 with inexact\n+                    return x*pio2_hi + x*pio2_lo;\n+                }\n+                return (x - x)\/(x - x);         \/\/ asin(|x| > 1) is NaN\n+            } else if (ix < 0x3fe0_0000) {     \/\/ |x| < 0.5\n+                if (ix < 0x3e40_0000) {        \/\/ if |x| < 2**-27\n+                    if (HUGE + x > 1.0) {\/\/ return x with inexact if x != 0\n+                        return x;\n+                    }\n+                } else {\n+                    t = x*x;\n+                }\n+                p = t*(pS0 + t*(pS1 + t*(pS2 + t*(pS3 + t*(pS4 + t*pS5)))));\n+                q = 1.0 + t*(qS1 + t*(qS2 + t*(qS3 + t*qS4)));\n+                w = p\/q;\n+                return x + x*w;\n+            }\n+            \/\/ 1 > |x| >= 0.5\n+            w = 1.0 - Math.abs(x);\n+            t = w*0.5;\n+            p = t*(pS0 + t*(pS1 + t*(pS2 + t*(pS3 + t*(pS4 + t*pS5)))));\n+            q = 1.0 + t*(qS1 + t*(qS2 + t*(qS3 + t*qS4)));\n+            s = Math.sqrt(t);\n+            if (ix >= 0x3FEF_3333) {    \/\/ if |x| > 0.975\n+                w = p\/q;\n+                t = pio2_hi - (2.0*(s + s*w) - pio2_lo);\n+            } else {\n+                w  = s;\n+                w  = __LO(w, 0);\n+                c  = (t - w*w)\/(s + w);\n+                r  = p\/q;\n+                p  = 2.0*s*r - (pio2_lo - 2.0*c);\n+                q  = pio4_hi - 2.0*w;\n+                t  = pio4_hi - (p - q);\n+            }\n+            return (hx > 0) ? t : -t;\n+        }\n+    }\n+\n+    \/** Returns the arccosine of x.\n+     * Method :\n+     *      acos(x)  = pi\/2 - asin(x)\n+     *      acos(-x) = pi\/2 + asin(x)\n+     * For |x| <= 0.5\n+     *      acos(x) = pi\/2 - (x + x*x^2*R(x^2))     (see asin.c)\n+     * For x > 0.5\n+     *      acos(x) = pi\/2 - (pi\/2 - 2asin(sqrt((1-x)\/2)))\n+     *              = 2asin(sqrt((1-x)\/2))\n+     *              = 2s + 2s*z*R(z)        ...z=(1-x)\/2, s=sqrt(z)\n+     *              = 2f + (2c + 2s*z*R(z))\n+     *     where f=hi part of s, and c = (z-f*f)\/(s+f) is the correction term\n+     *     for f so that f+c ~ sqrt(z).\n+     * For x <- 0.5\n+     *      acos(x) = pi - 2asin(sqrt((1-|x|)\/2))\n+     *              = pi - 0.5*(s+s*z*R(z)), where z=(1-|x|)\/2,s=sqrt(z)\n+     *\n+     * Special cases:\n+     *      if x is NaN, return x itself;\n+     *      if |x|>1, return NaN with invalid signal.\n+     *\n+     * Function needed: sqrt\n+     *\/\n+    static class Acos {\n+        private Acos() {throw new UnsupportedOperationException();}\n+\n+        private static final double\n+            pio2_hi =  0x1.921fb54442d18p0,   \/\/  1.57079632679489655800e+00\n+            pio2_lo =  0x1.1a62633145c07p-54, \/\/  6.12323399573676603587e-17\n+            pS0     =  0x1.5555555555555p-3,  \/\/  1.66666666666666657415e-01\n+            pS1     = -0x1.4d61203eb6f7dp-2,  \/\/ -3.25565818622400915405e-01\n+            pS2     =  0x1.9c1550e884455p-3,  \/\/  2.01212532134862925881e-01\n+            pS3     = -0x1.48228b5688f3bp-5,  \/\/ -4.00555345006794114027e-02\n+            pS4     =  0x1.9efe07501b288p-11, \/\/  7.91534994289814532176e-04\n+            pS5     =  0x1.23de10dfdf709p-15, \/\/  3.47933107596021167570e-05\n+            qS1     = -0x1.33a271c8a2d4bp1,   \/\/ -2.40339491173441421878e+00\n+            qS2     =  0x1.02ae59c598ac8p1,   \/\/  2.02094576023350569471e+00\n+            qS3     = -0x1.6066c1b8d0159p-1,  \/\/ -6.88283971605453293030e-01\n+            qS4     =  0x1.3b8c5b12e9282p-4;  \/\/  7.70381505559019352791e-02\n+\n+        static double compute(double x) {\n+            double z, p, q, r, w, s, c, df;\n+            int hx, ix;\n+            hx = __HI(x);\n+            ix = hx & 0x7fff_ffff;\n+            if (ix >= 0x3ff0_0000) {    \/\/ |x| >= 1\n+                if (((ix - 0x3ff0_0000) | __LO(x)) == 0) {  \/\/ |x| == 1\n+                    if (hx > 0) {\/\/ acos(1) = 0\n+                        return 0.0;\n+                    }else {       \/\/ acos(-1)= pi\n+                        return Math.PI + 2.0*pio2_lo;\n+                    }\n+                }\n+                return (x-x)\/(x-x);         \/\/ acos(|x| > 1) is NaN\n+            }\n+            if (ix < 0x3fe0_0000) {     \/\/ |x| < 0.5\n+                if (ix <= 0x3c60_0000) {  \/\/ if |x| < 2**-57\n+                    return pio2_hi + pio2_lo;\n+                }\n+                z = x*x;\n+                p = z*(pS0 + z*(pS1 + z*(pS2 + z*(pS3 + z*(pS4 + z*pS5)))));\n+                q = 1.0 + z*(qS1 + z*(qS2 + z*(qS3 + z*qS4)));\n+                r = p\/q;\n+                return pio2_hi - (x - (pio2_lo - x*r));\n+            } else if (hx < 0) {             \/\/ x < -0.5\n+                z = (1.0 + x)*0.5;\n+                p = z*(pS0 + z*(pS1 + z*(pS2 + z*(pS3 + z*(pS4 + z*pS5)))));\n+                q = 1.0 + z*(qS1 + z*(qS2 + z*(qS3 + z*qS4)));\n+                s = Math.sqrt(z);\n+                r = p\/q;\n+                w = r*s - pio2_lo;\n+                return Math.PI - 2.0*(s+w);\n+            } else {                        \/\/ x > 0.5\n+                z = (1.0 - x)*0.5;\n+                s = Math.sqrt(z);\n+                df = s;\n+                df = __LO(df, 0);\n+                c  = (z - df*df)\/(s + df);\n+                p = z*(pS0 + z*(pS1 + z*(pS2 + z*(pS3 + z*(pS4 + z*pS5)))));\n+                q = 1.0 + z*(qS1 + z*(qS2 + z*(qS3 + z*qS4)));\n+                r = p\/q;\n+                w = r*s + c;\n+                return 2.0*(df + w);\n+            }\n+        }\n+    }\n+\n+    \/* Returns the arctangent of x.\n+     * Method\n+     *   1. Reduce x to positive by atan(x) = -atan(-x).\n+     *   2. According to the integer k=4t+0.25 chopped, t=x, the argument\n+     *      is further reduced to one of the following intervals and the\n+     *      arctangent of t is evaluated by the corresponding formula:\n+     *\n+     *      [0,7\/16]      atan(x) = t-t^3*(a1+t^2*(a2+...(a10+t^2*a11)...)\n+     *      [7\/16,11\/16]  atan(x) = atan(1\/2) + atan( (t-0.5)\/(1+t\/2) )\n+     *      [11\/16.19\/16] atan(x) = atan( 1 ) + atan( (t-1)\/(1+t) )\n+     *      [19\/16,39\/16] atan(x) = atan(3\/2) + atan( (t-1.5)\/(1+1.5t) )\n+     *      [39\/16,INF]   atan(x) = atan(INF) + atan( -1\/t )\n+     *\n+     * Constants:\n+     * The hexadecimal values are the intended ones for the following\n+     * constants. The decimal values may be used, provided that the\n+     * compiler will convert from decimal to binary accurately enough\n+     * to produce the hexadecimal values shown.\n+     *\/\n+    static class Atan {\n+        private Atan() {throw new UnsupportedOperationException();}\n+\n+        private static final double atanhi[] = {\n+            0x1.dac670561bb4fp-2,  \/\/ atan(0.5)hi 4.63647609000806093515e-01\n+            0x1.921fb54442d18p-1,  \/\/ atan(1.0)hi 7.85398163397448278999e-01\n+            0x1.f730bd281f69bp-1,  \/\/ atan(1.5)hi 9.82793723247329054082e-01\n+            0x1.921fb54442d18p0,   \/\/ atan(inf)hi 1.57079632679489655800e+00\n+        };\n+\n+        private static final double atanlo[] = {\n+            0x1.a2b7f222f65e2p-56, \/\/ atan(0.5)lo 2.26987774529616870924e-17\n+            0x1.1a62633145c07p-55, \/\/ atan(1.0)lo 3.06161699786838301793e-17\n+            0x1.007887af0cbbdp-56, \/\/ atan(1.5)lo 1.39033110312309984516e-17\n+            0x1.1a62633145c07p-54, \/\/ atan(inf)lo 6.12323399573676603587e-17\n+        };\n+\n+        private static final double aT[] = {\n+             0x1.555555555550dp-2, \/\/  3.33333333333329318027e-01\n+            -0x1.999999998ebc4p-3, \/\/ -1.99999999998764832476e-01\n+             0x1.24924920083ffp-3, \/\/  1.42857142725034663711e-01\n+            -0x1.c71c6fe231671p-4, \/\/ -1.11111104054623557880e-01\n+             0x1.745cdc54c206ep-4, \/\/  9.09088713343650656196e-02\n+            -0x1.3b0f2af749a6dp-4, \/\/ -7.69187620504482999495e-02\n+             0x1.10d66a0d03d51p-4, \/\/  6.66107313738753120669e-02\n+            -0x1.dde2d52defd9ap-5, \/\/ -5.83357013379057348645e-02\n+             0x1.97b4b24760debp-5, \/\/  4.97687799461593236017e-02\n+            -0x1.2b4442c6a6c2fp-5, \/\/ -3.65315727442169155270e-02\n+             0x1.0ad3ae322da11p-6, \/\/  1.62858201153657823623e-02\n+        };\n+\n+        static double compute(double x) {\n+            double w, s1, s2, z;\n+            int ix, hx, id;\n+\n+            hx = __HI(x);\n+            ix = hx & 0x7fff_ffff;\n+            if (ix >= 0x4410_0000) {    \/\/ if |x| >= 2^66\n+                if (ix > 0x7ff0_0000 ||\n+                    (ix == 0x7ff0_0000 && (__LO(x) != 0))) {\n+                    return x+x;             \/\/ NaN\n+                }\n+                if (hx > 0) {\n+                    return atanhi[3] + atanlo[3];\n+                } else {\n+                    return -atanhi[3] - atanlo[3];\n+                }\n+            } if (ix < 0x3fdc_0000) {        \/\/ |x| < 0.4375\n+                if (ix < 0x3e20_0000) {      \/\/ |x| < 2^-29\n+                    if (HUGE + x > 1.0) { \/\/ raise inexact\n+                        return x;\n+                    }\n+                }\n+                id = -1;\n+            } else {\n+                x = Math.abs(x);\n+                if (ix < 0x3ff3_0000) {         \/\/ |x| < 1.1875\n+                    if (ix < 0x3fe60000) {      \/\/ 7\/16 <= |x| < 11\/16\n+                        id = 0;\n+                        x = (2.0*x - 1.0)\/(2.0 + x);\n+                    } else {                    \/\/ 11\/16 <= |x| < 19\/16\n+                        id = 1;\n+                        x  = (x - 1.0)\/(x + 1.0);\n+                    }\n+                } else {\n+                    if (ix < 0x4003_8000) {      \/\/ |x| < 2.4375\n+                        id = 2;\n+                        x  = (x - 1.5)\/(1.0 + 1.5*x);\n+                    } else {                    \/\/ 2.4375 <= |x| < 2^66\n+                        id = 3;\n+                        x  = -1.0\/x;\n+                    }\n+                }\n+            }\n+            \/\/ end of argument reduction\n+            z = x*x;\n+            w = z*z;\n+            \/\/ break sum from i=0 to 10 aT[i]z**(i+1) into odd and even poly\n+            s1 = z*(aT[0] + w*(aT[2] + w*(aT[4] + w*(aT[6] + w*(aT[8] + w*aT[10])))));\n+            s2 = w*(aT[1] + w*(aT[3] + w*(aT[5] + w*(aT[7] + w*aT[9]))));\n+            if (id < 0) {\n+                return x - x*(s1 + s2);\n+            } else {\n+                z = atanhi[id] - ((x*(s1+s2) - atanlo[id]) - x);\n+                return (hx < 0) ? -z: z;\n+            }\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/FdLibm.java","additions":293,"deletions":1,"binary":false,"changes":294,"status":"modified"},{"patch":"@@ -167,1 +167,3 @@\n-    public static native double asin(double a);\n+    public static double asin(double a) {\n+        return FdLibm.Asin.compute(a);\n+    }\n@@ -180,1 +182,3 @@\n-    public static native double acos(double a);\n+    public static double acos(double a) {\n+        return FdLibm.Acos.compute(a);\n+    }\n@@ -196,1 +200,3 @@\n-    public static native double atan(double a);\n+    public static double atan(double a) {\n+        return FdLibm.Atan.compute(a);\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StrictMath.java","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,177 @@\n+\/*\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8302026\n+ * @build Tests\n+ * @build InverseTrigTests\n+ * @run main InverseTrigTests\n+ * @summary Tests for {Math, StrictMath}.{asin, acos, atan}\n+ *\/\n+\n+public class InverseTrigTests {\n+    private InverseTrigTests(){}\n+\n+    public static void main(String... args) {\n+        int failures = 0;\n+\n+        failures += testAsinSpecialCases();\n+        failures += testAcosSpecialCases();\n+        failures += testAtanSpecialCases();\n+\n+        if (failures > 0) {\n+            System.err.println(\"Testing inverse trig mthods incurred \"\n+                               + failures + \" failures.\");\n+            throw new RuntimeException();\n+        }\n+    }\n+\n+    private static final double InfinityD = Double.POSITIVE_INFINITY;\n+    private static final double NaNd = Double.NaN;\n+\n+    \/**\n+     * From the spec for Math.asin:\n+     *\n+     * \"Special cases:\n+     *\n+     * If the argument is NaN or its absolute value is greater than 1,\n+     * then the result is NaN.\n+     *\n+     * If the argument is zero, then the result is a zero with the\n+     * same sign as the argument.\"\n+     *\/\n+    private static int testAsinSpecialCases() {\n+        int failures = 0;\n+\n+        double [][] testCases = {\n+            {NaNd,                NaNd},\n+            {Math.nextUp(1.0),    NaNd},\n+            {Math.nextDown(-1.0), NaNd},\n+            { InfinityD,          NaNd},\n+            {-InfinityD,          NaNd},\n+\n+            {-0.0,                -0.0},\n+            {+0.0,                +0.0},\n+        };\n+\n+        for(int i = 0; i < testCases.length; i++) {\n+            failures += testAsinCase(testCases[i][0],\n+                                     testCases[i][1]);\n+        }\n+\n+        return failures;\n+    }\n+\n+    private static int testAsinCase(double input, double expected) {\n+        int failures=0;\n+\n+        failures+=Tests.test(\"Math.asin\",       input, Math::asin,       expected);\n+        failures+=Tests.test(\"StrictMath.asin\", input, StrictMath::asin, expected);\n+\n+        return failures;\n+    }\n+\n+    \/**\n+     * From the spec for Math.acos:\n+     *\n+     * \"Special case:\n+     *\n+     * If the argument is NaN or its absolute value is greater than 1,\n+     * then the result is NaN.\n+     *\n+     * If the argument is 1.0, the result is positive zero.\"\n+     *\/\n+    private static int testAcosSpecialCases() {\n+        int failures = 0;\n+\n+        double [][] testCases = {\n+            {NaNd,                NaNd},\n+            {Math.nextUp(1.0),    NaNd},\n+            {Math.nextDown(-1.0), NaNd},\n+            {InfinityD,           NaNd},\n+            {-InfinityD,          NaNd},\n+\n+            {1.0,                 +0.0},\n+        };\n+\n+        for(int i = 0; i < testCases.length; i++) {\n+            failures += testAcosCase(testCases[i][0],\n+                                     testCases[i][1]);\n+        }\n+\n+        return failures;\n+    }\n+\n+    private static int testAcosCase(double input, double expected) {\n+        int failures=0;\n+\n+        failures+=Tests.test(\"Math.acos\",       input, Math::acos,       expected);\n+        failures+=Tests.test(\"StrictMath.acos\", input, StrictMath::acos, expected);\n+\n+        return failures;\n+    }\n+\n+    \/**\n+     * From the spec for Math.atan:\n+     *\n+     * \"Special cases:\n+     *\n+     * If the argument is NaN, then the result is NaN.\n+     *\n+     * If the argument is zero, then the result is a zero with the\n+     * same sign as the argument.\n+     *\n+     * If the argument is infinite, then the result is the closest\n+     * value to pi\/2 with the same sign as the input.\"\n+     *\/\n+    private static int testAtanSpecialCases() {\n+        int failures = 0;\n+\n+        double [][] testCases = {\n+            {NaNd,       NaNd},\n+\n+            {-0.0,       -0.0},\n+            {+0.0,       +0.0},\n+\n+            { InfinityD, +Math.PI\/2.0},\n+            {-InfinityD, -Math.PI\/2.0},\n+        };\n+\n+        for(int i = 0; i < testCases.length; i++) {\n+            failures += testAtanCase(testCases[i][0],\n+                                     testCases[i][1]);\n+        }\n+\n+        return failures;\n+    }\n+\n+    private static int testAtanCase(double input, double expected) {\n+        int failures=0;\n+\n+        failures+=Tests.test(\"Math.atan\",       input, Math::atan,       expected);\n+        failures+=Tests.test(\"StrictMath.atan\", input, StrictMath::atan, expected);\n+\n+        return failures;\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Math\/InverseTrigTests.java","additions":177,"deletions":0,"binary":false,"changes":177,"status":"added"},{"patch":"@@ -87,3 +87,3 @@\n-         \/\/ new UnaryTestCase(\"asin\",  FdlibmTranslit::asin,  StrictMath::asin,  DEFAULT_SHIFT),\n-         \/\/ new UnaryTestCase(\"acos\",  FdlibmTranslit::acos,  StrictMath::acos,  DEFAULT_SHIFT),\n-         \/\/ new UnaryTestCase(\"atan\",  FdlibmTranslit::atan,  StrictMath::atan,  DEFAULT_SHIFT),\n+            new UnaryTestCase(\"asin\",  FdlibmTranslit::asin,  StrictMath::asin,  DEFAULT_SHIFT),\n+            new UnaryTestCase(\"acos\",  FdlibmTranslit::acos,  StrictMath::acos,  DEFAULT_SHIFT),\n+            new UnaryTestCase(\"atan\",  FdlibmTranslit::atan,  StrictMath::atan,  DEFAULT_SHIFT),\n","filename":"test\/jdk\/java\/lang\/StrictMath\/ExhaustingTests.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -73,0 +73,12 @@\n+    public static double asin(double x) {\n+        return Asin.compute(x);\n+    }\n+\n+    public static double acos(double x) {\n+        return Acos.compute(x);\n+    }\n+\n+    public static double atan(double x) {\n+        return Atan.compute(x);\n+    }\n+\n@@ -97,0 +109,273 @@\n+    \/** Returns the arcsine of x.\n+     *\n+     * Method :\n+     *      Since  asin(x) = x + x^3\/6 + x^5*3\/40 + x^7*15\/336 + ...\n+     *      we approximate asin(x) on [0,0.5] by\n+     *              asin(x) = x + x*x^2*R(x^2)\n+     *      where\n+     *              R(x^2) is a rational approximation of (asin(x)-x)\/x^3\n+     *      and its remez error is bounded by\n+     *              |(asin(x)-x)\/x^3 - R(x^2)| < 2^(-58.75)\n+     *\n+     *      For x in [0.5,1]\n+     *              asin(x) = pi\/2-2*asin(sqrt((1-x)\/2))\n+     *      Let y = (1-x), z = y\/2, s := sqrt(z), and pio2_hi+pio2_lo=pi\/2;\n+     *      then for x>0.98\n+     *              asin(x) = pi\/2 - 2*(s+s*z*R(z))\n+     *                      = pio2_hi - (2*(s+s*z*R(z)) - pio2_lo)\n+     *      For x<=0.98, let pio4_hi = pio2_hi\/2, then\n+     *              f = hi part of s;\n+     *              c = sqrt(z) - f = (z-f*f)\/(s+f)         ...f+c=sqrt(z)\n+     *      and\n+     *              asin(x) = pi\/2 - 2*(s+s*z*R(z))\n+     *                      = pio4_hi+(pio4-2s)-(2s*z*R(z)-pio2_lo)\n+     *                      = pio4_hi+(pio4-2f)-(2s*z*R(z)-(pio2_lo+2c))\n+     *\n+     * Special cases:\n+     *      if x is NaN, return x itself;\n+     *      if |x|>1, return NaN with invalid signal.\n+     *\n+     *\/\n+    static class Asin {\n+        private static final double\n+            one =  1.00000000000000000000e+00, \/* 0x3FF00000, 0x00000000 *\/\n+            huge =  1.000e+300,\n+            pio2_hi =  1.57079632679489655800e+00, \/* 0x3FF921FB, 0x54442D18 *\/\n+            pio2_lo =  6.12323399573676603587e-17, \/* 0x3C91A626, 0x33145C07 *\/\n+            pio4_hi =  7.85398163397448278999e-01, \/* 0x3FE921FB, 0x54442D18 *\/\n+        \/* coefficient for R(x^2) *\/\n+            pS0 =  1.66666666666666657415e-01, \/* 0x3FC55555, 0x55555555 *\/\n+            pS1 = -3.25565818622400915405e-01, \/* 0xBFD4D612, 0x03EB6F7D *\/\n+            pS2 =  2.01212532134862925881e-01, \/* 0x3FC9C155, 0x0E884455 *\/\n+            pS3 = -4.00555345006794114027e-02, \/* 0xBFA48228, 0xB5688F3B *\/\n+            pS4 =  7.91534994289814532176e-04, \/* 0x3F49EFE0, 0x7501B288 *\/\n+            pS5 =  3.47933107596021167570e-05, \/* 0x3F023DE1, 0x0DFDF709 *\/\n+            qS1 = -2.40339491173441421878e+00, \/* 0xC0033A27, 0x1C8A2D4B *\/\n+            qS2 =  2.02094576023350569471e+00, \/* 0x40002AE5, 0x9C598AC8 *\/\n+            qS3 = -6.88283971605453293030e-01, \/* 0xBFE6066C, 0x1B8D0159 *\/\n+            qS4 =  7.70381505559019352791e-02; \/* 0x3FB3B8C5, 0xB12E9282 *\/\n+\n+        static double compute(double x) {\n+            double t=0,w,p,q,c,r,s;\n+            int hx,ix;\n+            hx = __HI(x);\n+            ix = hx&0x7fffffff;\n+            if(ix>= 0x3ff00000) {           \/* |x|>= 1 *\/\n+                if(((ix-0x3ff00000)|__LO(x))==0)\n+                    \/* asin(1)=+-pi\/2 with inexact *\/\n+                    return x*pio2_hi+x*pio2_lo;\n+                return (x-x)\/(x-x);         \/* asin(|x|>1) is NaN *\/\n+            } else if (ix<0x3fe00000) {     \/* |x|<0.5 *\/\n+                if(ix<0x3e400000) {         \/* if |x| < 2**-27 *\/\n+                    if(huge+x>one) return x;\/* return x with inexact if x!=0*\/\n+                } else\n+                    t = x*x;\n+                p = t*(pS0+t*(pS1+t*(pS2+t*(pS3+t*(pS4+t*pS5)))));\n+                q = one+t*(qS1+t*(qS2+t*(qS3+t*qS4)));\n+                w = p\/q;\n+                return x+x*w;\n+            }\n+            \/* 1> |x|>= 0.5 *\/\n+            w = one-Math.abs(x);\n+            t = w*0.5;\n+            p = t*(pS0+t*(pS1+t*(pS2+t*(pS3+t*(pS4+t*pS5)))));\n+            q = one+t*(qS1+t*(qS2+t*(qS3+t*qS4)));\n+            s = Math.sqrt(t);\n+            if(ix>=0x3FEF3333) {    \/* if |x| > 0.975 *\/\n+                w = p\/q;\n+                t = pio2_hi-(2.0*(s+s*w)-pio2_lo);\n+            } else {\n+                w  = s;\n+                \/\/ __LO(w) = 0;\n+                w  = __LO(w, 0);\n+                c  = (t-w*w)\/(s+w);\n+                r  = p\/q;\n+                p  = 2.0*s*r-(pio2_lo-2.0*c);\n+                q  = pio4_hi-2.0*w;\n+                t  = pio4_hi-(p-q);\n+            }\n+            if(hx>0) return t; else return -t;\n+        }\n+    }\n+\n+    \/** Returns the arccosine of x.\n+     * Method :\n+     *      acos(x)  = pi\/2 - asin(x)\n+     *      acos(-x) = pi\/2 + asin(x)\n+     * For |x|<=0.5\n+     *      acos(x) = pi\/2 - (x + x*x^2*R(x^2))     (see asin.c)\n+     * For x>0.5\n+     *      acos(x) = pi\/2 - (pi\/2 - 2asin(sqrt((1-x)\/2)))\n+     *              = 2asin(sqrt((1-x)\/2))\n+     *              = 2s + 2s*z*R(z)        ...z=(1-x)\/2, s=sqrt(z)\n+     *              = 2f + (2c + 2s*z*R(z))\n+     *     where f=hi part of s, and c = (z-f*f)\/(s+f) is the correction term\n+     *     for f so that f+c ~ sqrt(z).\n+     * For x<-0.5\n+     *      acos(x) = pi - 2asin(sqrt((1-|x|)\/2))\n+     *              = pi - 0.5*(s+s*z*R(z)), where z=(1-|x|)\/2,s=sqrt(z)\n+     *\n+     * Special cases:\n+     *      if x is NaN, return x itself;\n+     *      if |x|>1, return NaN with invalid signal.\n+     *\n+     * Function needed: sqrt\n+     *\/\n+    static class Acos {\n+        private static final double\n+            one=  1.00000000000000000000e+00, \/* 0x3FF00000, 0x00000000 *\/\n+            pi =  3.14159265358979311600e+00, \/* 0x400921FB, 0x54442D18 *\/\n+            pio2_hi =  1.57079632679489655800e+00, \/* 0x3FF921FB, 0x54442D18 *\/\n+            pio2_lo =  6.12323399573676603587e-17, \/* 0x3C91A626, 0x33145C07 *\/\n+            pS0 =  1.66666666666666657415e-01, \/* 0x3FC55555, 0x55555555 *\/\n+            pS1 = -3.25565818622400915405e-01, \/* 0xBFD4D612, 0x03EB6F7D *\/\n+            pS2 =  2.01212532134862925881e-01, \/* 0x3FC9C155, 0x0E884455 *\/\n+            pS3 = -4.00555345006794114027e-02, \/* 0xBFA48228, 0xB5688F3B *\/\n+            pS4 =  7.91534994289814532176e-04, \/* 0x3F49EFE0, 0x7501B288 *\/\n+            pS5 =  3.47933107596021167570e-05, \/* 0x3F023DE1, 0x0DFDF709 *\/\n+            qS1 = -2.40339491173441421878e+00, \/* 0xC0033A27, 0x1C8A2D4B *\/\n+            qS2 =  2.02094576023350569471e+00, \/* 0x40002AE5, 0x9C598AC8 *\/\n+            qS3 = -6.88283971605453293030e-01, \/* 0xBFE6066C, 0x1B8D0159 *\/\n+            qS4 =  7.70381505559019352791e-02; \/* 0x3FB3B8C5, 0xB12E9282 *\/\n+\n+        static double compute(double x) {\n+            double z,p,q,r,w,s,c,df;\n+            int hx,ix;\n+            hx = __HI(x);\n+            ix = hx&0x7fffffff;\n+            if(ix>=0x3ff00000) {    \/* |x| >= 1 *\/\n+                if(((ix-0x3ff00000)|__LO(x))==0) {  \/* |x|==1 *\/\n+                    if(hx>0) return 0.0;            \/* acos(1) = 0  *\/\n+                    else return pi+2.0*pio2_lo;     \/* acos(-1)= pi *\/\n+                }\n+                return (x-x)\/(x-x);         \/* acos(|x|>1) is NaN *\/\n+            }\n+            if(ix<0x3fe00000) {     \/* |x| < 0.5 *\/\n+                if(ix<=0x3c600000) return pio2_hi+pio2_lo;\/*if|x|<2**-57*\/\n+                z = x*x;\n+                p = z*(pS0+z*(pS1+z*(pS2+z*(pS3+z*(pS4+z*pS5)))));\n+                q = one+z*(qS1+z*(qS2+z*(qS3+z*qS4)));\n+                r = p\/q;\n+                return pio2_hi - (x - (pio2_lo-x*r));\n+            } else  if (hx<0) {             \/* x < -0.5 *\/\n+                z = (one+x)*0.5;\n+                p = z*(pS0+z*(pS1+z*(pS2+z*(pS3+z*(pS4+z*pS5)))));\n+                q = one+z*(qS1+z*(qS2+z*(qS3+z*qS4)));\n+                s = Math.sqrt(z);\n+                r = p\/q;\n+                w = r*s-pio2_lo;\n+                return pi - 2.0*(s+w);\n+            } else {                        \/* x > 0.5 *\/\n+                z = (one-x)*0.5;\n+                s = Math.sqrt(z);\n+                df = s;\n+                \/\/ __LO(df) = 0;\n+                df = __LO(df, 0);\n+                c  = (z-df*df)\/(s+df);\n+                p = z*(pS0+z*(pS1+z*(pS2+z*(pS3+z*(pS4+z*pS5)))));\n+                q = one+z*(qS1+z*(qS2+z*(qS3+z*qS4)));\n+                r = p\/q;\n+                w = r*s+c;\n+                return 2.0*(df+w);\n+            }\n+        }\n+    }\n+\n+    \/* Returns the arctangent of x.\n+     * Method\n+     *   1. Reduce x to positive by atan(x) = -atan(-x).\n+     *   2. According to the integer k=4t+0.25 chopped, t=x, the argument\n+     *      is further reduced to one of the following intervals and the\n+     *      arctangent of t is evaluated by the corresponding formula:\n+     *\n+     *      [0,7\/16]      atan(x) = t-t^3*(a1+t^2*(a2+...(a10+t^2*a11)...)\n+     *      [7\/16,11\/16]  atan(x) = atan(1\/2) + atan( (t-0.5)\/(1+t\/2) )\n+     *      [11\/16.19\/16] atan(x) = atan( 1 ) + atan( (t-1)\/(1+t) )\n+     *      [19\/16,39\/16] atan(x) = atan(3\/2) + atan( (t-1.5)\/(1+1.5t) )\n+     *      [39\/16,INF]   atan(x) = atan(INF) + atan( -1\/t )\n+     *\n+     * Constants:\n+     * The hexadecimal values are the intended ones for the following\n+     * constants. The decimal values may be used, provided that the\n+     * compiler will convert from decimal to binary accurately enough\n+     * to produce the hexadecimal values shown.\n+     *\/\n+    static class Atan {\n+        private static final double atanhi[] = {\n+            4.63647609000806093515e-01, \/* atan(0.5)hi 0x3FDDAC67, 0x0561BB4F *\/\n+            7.85398163397448278999e-01, \/* atan(1.0)hi 0x3FE921FB, 0x54442D18 *\/\n+            9.82793723247329054082e-01, \/* atan(1.5)hi 0x3FEF730B, 0xD281F69B *\/\n+            1.57079632679489655800e+00, \/* atan(inf)hi 0x3FF921FB, 0x54442D18 *\/\n+        };\n+\n+        private static final double atanlo[] = {\n+            2.26987774529616870924e-17, \/* atan(0.5)lo 0x3C7A2B7F, 0x222F65E2 *\/\n+            3.06161699786838301793e-17, \/* atan(1.0)lo 0x3C81A626, 0x33145C07 *\/\n+            1.39033110312309984516e-17, \/* atan(1.5)lo 0x3C700788, 0x7AF0CBBD *\/\n+            6.12323399573676603587e-17, \/* atan(inf)lo 0x3C91A626, 0x33145C07 *\/\n+        };\n+\n+        private static final double aT[] = {\n+             3.33333333333329318027e-01, \/* 0x3FD55555, 0x5555550D *\/\n+            -1.99999999998764832476e-01, \/* 0xBFC99999, 0x9998EBC4 *\/\n+             1.42857142725034663711e-01, \/* 0x3FC24924, 0x920083FF *\/\n+            -1.11111104054623557880e-01, \/* 0xBFBC71C6, 0xFE231671 *\/\n+             9.09088713343650656196e-02, \/* 0x3FB745CD, 0xC54C206E *\/\n+            -7.69187620504482999495e-02, \/* 0xBFB3B0F2, 0xAF749A6D *\/\n+             6.66107313738753120669e-02, \/* 0x3FB10D66, 0xA0D03D51 *\/\n+            -5.83357013379057348645e-02, \/* 0xBFADDE2D, 0x52DEFD9A *\/\n+             4.97687799461593236017e-02, \/* 0x3FA97B4B, 0x24760DEB *\/\n+            -3.65315727442169155270e-02, \/* 0xBFA2B444, 0x2C6A6C2F *\/\n+             1.62858201153657823623e-02, \/* 0x3F90AD3A, 0xE322DA11 *\/\n+        };\n+\n+        private static final double\n+            one   = 1.0,\n+            huge   = 1.0e300;\n+\n+        static double compute(double x) {\n+            double w,s1,s2,z;\n+            int ix,hx,id;\n+\n+            hx = __HI(x);\n+            ix = hx&0x7fffffff;\n+            if(ix>=0x44100000) {    \/* if |x| >= 2^66 *\/\n+                if(ix>0x7ff00000||\n+                   (ix==0x7ff00000&&(__LO(x)!=0)))\n+                    return x+x;             \/* NaN *\/\n+                if(hx>0) return  atanhi[3]+atanlo[3];\n+                else     return -atanhi[3]-atanlo[3];\n+            } if (ix < 0x3fdc0000) {        \/* |x| < 0.4375 *\/\n+                if (ix < 0x3e200000) {      \/* |x| < 2^-29 *\/\n+                    if(huge+x>one) return x;        \/* raise inexact *\/\n+                }\n+                id = -1;\n+            } else {\n+                x = Math.abs(x);\n+                if (ix < 0x3ff30000) {          \/* |x| < 1.1875 *\/\n+                    if (ix < 0x3fe60000) {      \/* 7\/16 <=|x|<11\/16 *\/\n+                        id = 0; x = (2.0*x-one)\/(2.0+x);\n+                    } else {                    \/* 11\/16<=|x|< 19\/16 *\/\n+                        id = 1; x  = (x-one)\/(x+one);\n+                    }\n+                } else {\n+                    if (ix < 0x40038000) {      \/* |x| < 2.4375 *\/\n+                        id = 2; x  = (x-1.5)\/(one+1.5*x);\n+                    } else {                    \/* 2.4375 <= |x| < 2^66 *\/\n+                        id = 3; x  = -1.0\/x;\n+                    }\n+                }}\n+            \/* end of argument reduction *\/\n+            z = x*x;\n+            w = z*z;\n+            \/* break sum from i=0 to 10 aT[i]z**(i+1) into odd and even poly *\/\n+            s1 = z*(aT[0]+w*(aT[2]+w*(aT[4]+w*(aT[6]+w*(aT[8]+w*aT[10])))));\n+            s2 = w*(aT[1]+w*(aT[3]+w*(aT[5]+w*(aT[7]+w*aT[9]))));\n+            if (id<0) return x - x*(s1+s2);\n+            else {\n+                z = atanhi[id] - ((x*(s1+s2) - atanlo[id]) - x);\n+                return (hx<0)? -z:z;\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/StrictMath\/FdlibmTranslit.java","additions":285,"deletions":0,"binary":false,"changes":285,"status":"modified"},{"patch":"@@ -0,0 +1,226 @@\n+\/*\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+import jdk.test.lib.RandomFactory;\n+import java.util.function.DoubleUnaryOperator;\n+\n+\/*\n+ * @test\n+ * @bug 8302026\n+ * @key randomness\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.RandomFactory\n+ * @build Tests\n+ * @build FdlibmTranslit\n+ * @build InverseTrigTests\n+ * @run main InverseTrigTests\n+ * @summary Tests for StrictMath.{asin, acos, atan}\n+ *\/\n+\n+\/**\n+ * The tests in ..\/Math\/InverseTrigTests.java test properties that\n+ * should hold for any implementation of the inverse trig functions\n+ * ason, acos, and atan, including the FDLIBM-based ones required by\n+ * the StrictMath class.  Therefore, the test cases in\n+ * ..\/Math\/InverseTrig.java are run against both the Math and\n+ * StrictMath versions of the inverse trig methods.  The role of this\n+ * test is to verify that the FDLIBM algorithms are being used by\n+ * running golden file tests on values that may vary from one\n+ * conforming implementation of the hyperbolics to another.\n+ *\/\n+\n+public class InverseTrigTests {\n+    private InverseTrigTests(){}\n+\n+    public static void main(String... args) {\n+        int failures = 0;\n+\n+        failures += testAgainstTranslitCommon();\n+\n+        failures += testAgainstTranslitAsin();\n+        failures += testAgainstTranslitAcos();\n+        failures += testAgainstTranslitAtan();\n+\n+        if (failures > 0) {\n+            System.err.println(\"Testing the inverse trig functions incurred \"\n+                               + failures + \" failures.\");\n+            throw new RuntimeException();\n+        }\n+    }\n+\n+    \/**\n+     * Bundle together groups of testing methods.\n+     *\/\n+    private static enum InverseTrigTest {\n+        ASIN(InverseTrigTests::testAsinCase, FdlibmTranslit::asin),\n+        ACOS(InverseTrigTests::testAcosCase, FdlibmTranslit::acos),\n+        ATAN(InverseTrigTests::testAtanCase, FdlibmTranslit::atan);\n+\n+        private DoubleDoubleToInt testCase;\n+        private DoubleUnaryOperator transliteration;\n+\n+        InverseTrigTest(DoubleDoubleToInt testCase, DoubleUnaryOperator transliteration) {\n+            this.testCase = testCase;\n+            this.transliteration = transliteration;\n+        }\n+\n+        public DoubleDoubleToInt testCase() {return testCase;}\n+        public DoubleUnaryOperator transliteration() {return transliteration;}\n+    }\n+\n+    \/\/ Initialize shared random number generator\n+    private static java.util.Random random = RandomFactory.getRandom();\n+\n+    \/**\n+     * Test against shared points of interest.\n+     *\/\n+    private static int testAgainstTranslitCommon() {\n+        int failures = 0;\n+        double[] pointsOfInterest = {\n+            Double.MIN_NORMAL,\n+            1.0,\n+            Tests.createRandomDouble(random),\n+        };\n+\n+        for (var testMethods : InverseTrigTest.values()) {\n+            for (double testPoint : pointsOfInterest) {\n+                failures += testRangeMidpoint(testPoint, Math.ulp(testPoint), 1000, testMethods);\n+            }\n+        }\n+\n+        return failures;\n+    }\n+\n+    \/**\n+     * Test StrictMath.asin against transliteration port of asin.\n+     *\/\n+    private static int testAgainstTranslitAsin() {\n+        int failures = 0;\n+\n+        \/\/ Probe near decision points in the FDLIBM algorithm.\n+        double[] decisionPoints = {\n+             0x1p-27,\n+            -0x1p-27,\n+\n+             0.5,\n+            -0.5,\n+\n+             0.975,\n+            -0.975,\n+        };\n+\n+        for (double testPoint : decisionPoints) {\n+            failures += testRangeMidpoint(testPoint, Math.ulp(testPoint), 1000, InverseTrigTest.ASIN);\n+        }\n+\n+        return failures;\n+    }\n+\n+    \/**\n+     * Test StrictMath.acos against transliteration port of acos.\n+     *\/\n+    private static int testAgainstTranslitAcos() {\n+        int failures = 0;\n+\n+        \/\/ Probe near decision points in the FDLIBM algorithm.\n+        double[] decisionPoints = {\n+             0.5,\n+            -0.5,\n+\n+             0x1.0p-57,\n+            -0x1.0p-57,\n+        };\n+\n+        for (double testPoint : decisionPoints) {\n+            failures += testRangeMidpoint(testPoint, Math.ulp(testPoint), 1000, InverseTrigTest.ACOS);\n+        }\n+\n+        return failures;\n+    }\n+\n+    \/**\n+     * Test StrictMath.atan against transliteration port of atan\n+     *\/\n+    private static int testAgainstTranslitAtan() {\n+        int failures = 0;\n+\n+        \/\/ Probe near decision points in the FDLIBM algorithm.\n+        double[] decisionPoints = {\n+            0.0,\n+\n+            7.0\/16.0,\n+            11.0\/16.0,\n+            19.0\/16.0,\n+            39.0\/16.0,\n+\n+            0x1.0p66,\n+            0x1.0p-29,\n+        };\n+\n+        for (double testPoint : decisionPoints) {\n+            failures += testRangeMidpoint(testPoint, Math.ulp(testPoint), 1000,  InverseTrigTest.ATAN);\n+        }\n+\n+        return failures;\n+    }\n+\n+    private interface DoubleDoubleToInt {\n+        int apply(double x, double y);\n+    }\n+\n+    private static int testRange(double start, double increment, int count,\n+                             InverseTrigTest testMethods) {\n+        int failures = 0;\n+        double x = start;\n+        for (int i = 0; i < count; i++, x += increment) {\n+            failures +=\n+                testMethods.testCase().apply(x, testMethods.transliteration().applyAsDouble(x));\n+        }\n+        return failures;\n+    }\n+\n+    private static int testRangeMidpoint(double midpoint, double increment, int count,\n+                                         InverseTrigTest testMethods) {\n+        int failures = 0;\n+        double x = midpoint - increment*(count \/ 2) ;\n+        for (int i = 0; i < count; i++, x += increment) {\n+            failures +=\n+                testMethods.testCase().apply(x, testMethods.transliteration().applyAsDouble(x));\n+        }\n+        return failures;\n+    }\n+\n+    private static int testAsinCase(double input, double expected) {\n+        return Tests.test(\"StrictMath.asin(double)\", input,\n+                          StrictMath::asin, expected);\n+    }\n+\n+    private static int testAcosCase(double input, double expected) {\n+        return Tests.test(\"StrictMath.acos(double)\", input,\n+                          StrictMath::acos, expected);\n+    }\n+\n+    private static int testAtanCase(double input, double expected) {\n+        return Tests.test(\"StrictMath.atan(double)\", input,\n+                          StrictMath::atan, expected);\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/StrictMath\/InverseTrigTests.java","additions":226,"deletions":0,"binary":false,"changes":226,"status":"added"}]}