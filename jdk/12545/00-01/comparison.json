{"files":[{"patch":"@@ -24,0 +24,1 @@\n+import java.util.function.DoubleUnaryOperator;\n@@ -39,1 +40,1 @@\n- * The tests in ..\/Math\/InverseTripTests.java test properties that\n+ * The tests in ..\/Math\/InverseTrigTests.java test properties that\n@@ -56,0 +57,2 @@\n+        failures += testAgainstTranslitCommon();\n+\n@@ -67,0 +70,20 @@\n+    \/**\n+     * Bundle together groups of testing methods.\n+     *\/\n+    private static enum InverseTrigTest {\n+        ASIN(InverseTrigTests::testAsinCase, FdlibmTranslit::asin),\n+        ACOS(InverseTrigTests::testAcosCase, FdlibmTranslit::acos),\n+        ATAN(InverseTrigTests::testAtanCase, FdlibmTranslit::atan);\n+\n+        private DoubleDoubleToInt testCase;\n+        private DoubleUnaryOperator transliteration;\n+\n+        InverseTrigTest(DoubleDoubleToInt testCase, DoubleUnaryOperator transliteration) {\n+            this.testCase = testCase;\n+            this.transliteration = transliteration;\n+        }\n+\n+        public DoubleDoubleToInt testCase() {return testCase;}\n+        public DoubleUnaryOperator transliteration() {return transliteration;}\n+    }\n+\n@@ -71,1 +94,1 @@\n-     * Test StrictMath.asin against transliteration port of asin.\n+     * Test against shared points of interest.\n@@ -73,1 +96,1 @@\n-    private static int testAgainstTranslitAsin() {\n+    private static int testAgainstTranslitCommon() {\n@@ -75,9 +98,11 @@\n-        double x;\n-\n-        \/\/ Test just above subnormal threshold...\n-        x = Double.MIN_NORMAL;\n-        failures += testRangeAsin(x, Math.ulp(x), 1000);\n-\n-         \/\/ ... and just below subnormal threshold ...\n-          x = Math.nextDown(Double.MIN_NORMAL);\n-          failures += testRangeAsin(x, -Math.ulp(x), 1000);\n+        double[] pointsOfInterest = {\n+            Double.MIN_NORMAL,\n+            1.0,\n+            Tests.createRandomDouble(random),\n+        };\n+\n+        for (var testMethods : InverseTrigTest.values()) {\n+            for (double testPoint : pointsOfInterest) {\n+                failures += testRangeMidpoint(testPoint, Math.ulp(testPoint), 1000, testMethods);\n+            }\n+        }\n@@ -85,4 +110,2 @@\n-         \/\/ ... and near 1.0 ...\n-          failures += testRangeMidpointAsin(1.0, Math.ulp(x), 2000);\n-          \/\/ (Note: probes every-other value less than 1.0 due to\n-          \/\/ change in the size of an ulp at 1.0.\n+        return failures;\n+    }\n@@ -90,4 +113,5 @@\n-          \/\/ Probe near decision points in the FDLIBM algorithm.\n-          double[] decisionPoints = {\n-               0.5,\n-              -0.5,\n+    \/**\n+     * Test StrictMath.asin against transliteration port of asin.\n+     *\/\n+    private static int testAgainstTranslitAsin() {\n+        int failures = 0;\n@@ -95,3 +119,4 @@\n-               0.975,\n-              -0.975,\n-          };\n+        \/\/ Probe near decision points in the FDLIBM algorithm.\n+        double[] decisionPoints = {\n+             0x1p-27,\n+            -0x1p-27,\n@@ -99,3 +124,2 @@\n-          for (double testPoint : decisionPoints) {\n-              failures += testRangeMidpointAsin(testPoint, Math.ulp(testPoint), 1000);\n-          }\n+             0.5,\n+            -0.5,\n@@ -103,1 +127,3 @@\n-          x = Tests.createRandomDouble(random);\n+             0.975,\n+            -0.975,\n+        };\n@@ -105,5 +131,3 @@\n-          \/\/ Make the increment twice the ulp value in case the random\n-          \/\/ value is near an exponent threshold. Don't worry about test\n-          \/\/ elements overflowing to infinity if the starting value is\n-          \/\/ near Double.MAX_VALUE.\n-          failures += testRangeAsin(x, 2.0 * Math.ulp(x), 1000);\n+        for (double testPoint : decisionPoints) {\n+            failures += testRangeMidpoint(testPoint, Math.ulp(testPoint), 1000, InverseTrigTest.ASIN);\n+        }\n@@ -111,1 +135,1 @@\n-         return failures;\n+        return failures;\n@@ -119,5 +143,0 @@\n-        double x;\n-\n-        \/\/ Test just above subnormal threshold...\n-        x = Double.MIN_NORMAL;\n-        failures += testRangeAcos(x, Math.ulp(x), 1000);\n@@ -125,3 +144,4 @@\n-         \/\/ ... and just below subnormal threshold ...\n-          x = Math.nextDown(Double.MIN_NORMAL);\n-          failures += testRangeAcos(x, -Math.ulp(x), 1000);\n+        \/\/ Probe near decision points in the FDLIBM algorithm.\n+        double[] decisionPoints = {\n+             0.5,\n+            -0.5,\n@@ -129,4 +149,3 @@\n-         \/\/ ... and near 1.0 ...\n-          failures += testRangeMidpointAcos(1.0, Math.ulp(x), 2000);\n-          \/\/ (Note: probes every-other value less than 1.0 due to\n-          \/\/ change in the size of an ulp at 1.0.\n+             0x1.0p-57,\n+            -0x1.0p-57,\n+        };\n@@ -134,20 +153,3 @@\n-          \/\/ Probe near decision points in the FDLIBM algorithm.\n-          double[] decisionPoints = {\n-               0.5,\n-              -0.5,\n-\n-               0x1.0p-57,\n-              -0x1.0p-57,\n-          };\n-\n-          for (double testPoint : decisionPoints) {\n-              failures += testRangeMidpointAcos(testPoint, Math.ulp(testPoint), 1000);\n-          }\n-\n-          x = Tests.createRandomDouble(random);\n-\n-          \/\/ Make the increment twice the ulp value in case the random\n-          \/\/ value is near an exponent threshold. Don't worry about test\n-          \/\/ elements overflowing to infinity if the starting value is\n-          \/\/ near Double.MAX_VALUE.\n-          failures += testRangeAcos(x, 2.0 * Math.ulp(x), 1000);\n+        for (double testPoint : decisionPoints) {\n+            failures += testRangeMidpoint(testPoint, Math.ulp(testPoint), 1000, InverseTrigTest.ACOS);\n+        }\n@@ -155,1 +157,1 @@\n-         return failures;\n+        return failures;\n@@ -163,5 +165,0 @@\n-        double x;\n-\n-        \/\/ Test just above subnormal threshold...\n-        x = Double.MIN_NORMAL;\n-        failures += testRangeAtan(x, Math.ulp(x), 1000);\n@@ -169,3 +166,3 @@\n-         \/\/ ... and just below subnormal threshold ...\n-          x = Math.nextDown(Double.MIN_NORMAL);\n-          failures += testRangeAtan(x, -Math.ulp(x), 1000);\n+        \/\/ Probe near decision points in the FDLIBM algorithm.\n+        double[] decisionPoints = {\n+            0.0,\n@@ -173,4 +170,4 @@\n-         \/\/ ... and near 1.0 ...\n-          failures += testRangeMidpointAtan(1.0, Math.ulp(x), 2000);\n-          \/\/ (Note: probes every-other value less than 1.0 due to\n-          \/\/ change in the size of an ulp at 1.0.\n+            7.0\/16.0,\n+            11.0\/16.0,\n+            19.0\/16.0,\n+            39.0\/16.0,\n@@ -178,3 +175,3 @@\n-          \/\/ Probe near decision points in the FDLIBM algorithm.\n-          double[] decisionPoints = {\n-               0.0,\n+            0x1.0p66,\n+            0x1.0p-29,\n+        };\n@@ -182,38 +179,2 @@\n-               7.0\/16.0,\n-               11.0\/16.0,\n-               19.0\/16.0,\n-               39.0\/16.0,\n-\n-               0x1.0p66,\n-               0x1.0p-29,\n-          };\n-\n-          for (double testPoint : decisionPoints) {\n-              failures += testRangeMidpointAtan(testPoint, Math.ulp(testPoint), 1000);\n-          }\n-\n-          x = Tests.createRandomDouble(random);\n-\n-          \/\/ Make the increment twice the ulp value in case the random\n-          \/\/ value is near an exponent threshold. Don't worry about test\n-          \/\/ elements overflowing to infinity if the starting value is\n-          \/\/ near Double.MAX_VALUE.\n-          failures += testRangeAtan(x, 2.0 * Math.ulp(x), 1000);\n-\n-         return failures;\n-    }\n-\n-    private static int testRangeAsin(double start, double increment, int count) {\n-        int failures = 0;\n-        double x = start;\n-        for (int i = 0; i < count; i++, x += increment) {\n-            failures += testAsinCase(x, FdlibmTranslit.asin(x));\n-        }\n-        return failures;\n-    }\n-\n-    private static int testRangeAcos(double start, double increment, int count) {\n-        int failures = 0;\n-        double x = start;\n-        for (int i = 0; i < count; i++, x += increment) {\n-            failures += testAcosCase(x, FdlibmTranslit.acos(x));\n+        for (double testPoint : decisionPoints) {\n+            failures += testRangeMidpoint(testPoint, Math.ulp(testPoint), 1000,  InverseTrigTest.ATAN);\n@@ -221,2 +182,0 @@\n-        return failures;\n-    }\n@@ -224,6 +183,0 @@\n-    private static int testRangeAtan(double start, double increment, int count) {\n-        int failures = 0;\n-        double x = start;\n-        for (int i = 0; i < count; i++, x += increment) {\n-            failures += testAtanCase(x, FdlibmTranslit.atan(x));\n-        }\n@@ -233,7 +186,2 @@\n-    private static int testRangeMidpointAsin(double midpoint, double increment, int count) {\n-        int failures = 0;\n-        double x = midpoint - increment*(count \/ 2) ;\n-        for (int i = 0; i < count; i++, x += increment) {\n-            failures += testAsinCase(x, FdlibmTranslit.asin(x));\n-        }\n-        return failures;\n+    private interface DoubleDoubleToInt {\n+        int apply(double x, double y);\n@@ -242,1 +190,2 @@\n-    private static int testRangeMidpointAcos(double midpoint, double increment, int count) {\n+    private static int testRange(double start, double increment, int count,\n+                             InverseTrigTest testMethods) {\n@@ -244,1 +193,1 @@\n-        double x = midpoint - increment*(count \/ 2) ;\n+        double x = start;\n@@ -246,1 +195,2 @@\n-            failures += testAcosCase(x, FdlibmTranslit.acos(x));\n+            failures +=\n+                testMethods.testCase().apply(x, testMethods.transliteration().applyAsDouble(x));\n@@ -251,1 +201,2 @@\n-    private static int testRangeMidpointAtan(double midpoint, double increment, int count) {\n+    private static int testRangeMidpoint(double midpoint, double increment, int count,\n+                                         InverseTrigTest testMethods) {\n@@ -255,1 +206,2 @@\n-            failures += testAtanCase(x, FdlibmTranslit.atan(x));\n+            failures +=\n+                testMethods.testCase().apply(x, testMethods.transliteration().applyAsDouble(x));\n@@ -260,1 +212,1 @@\n-    static int testAsinCase(double input, double expected) {\n+    private static int testAsinCase(double input, double expected) {\n@@ -265,1 +217,1 @@\n-    static int testAcosCase(double input, double expected) {\n+    private static int testAcosCase(double input, double expected) {\n@@ -270,1 +222,1 @@\n-    static int testAtanCase(double input, double expected) {\n+    private static int testAtanCase(double input, double expected) {\n","filename":"test\/jdk\/java\/lang\/StrictMath\/InverseTrigTests.java","additions":94,"deletions":142,"binary":false,"changes":236,"status":"modified"}]}