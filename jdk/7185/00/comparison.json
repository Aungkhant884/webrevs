{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n-import java.util.concurrent.ConcurrentHashMap;\n@@ -187,2 +186,0 @@\n-        final ConcurrentHashMap<Method, MethodHandle> defaultMethodMap =\n-                hasDefaultMethods(intfc) ? new ConcurrentHashMap<>() : null;\n@@ -205,1 +202,1 @@\n-                        return callDefaultMethod(defaultMethodMap, proxy, intfc, method, args);\n+                        return InvocationHandler.invokeDefault(proxy, method, args);\n@@ -322,34 +319,0 @@\n-\n-    private static boolean hasDefaultMethods(Class<?> intfc) {\n-        for (Method m : intfc.getMethods()) {\n-            if (!isObjectMethod(m) &&\n-                !Modifier.isAbstract(m.getModifiers())) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    private static Object callDefaultMethod(ConcurrentHashMap<Method, MethodHandle> defaultMethodMap,\n-                             Object self, Class<?> intfc, Method m, Object[] args) throws Throwable {\n-        assert(isDefaultMethod(m) && !isObjectMethod(m)) : m;\n-\n-        \/\/ Lazily compute the associated method handle from the method\n-        MethodHandle dmh = defaultMethodMap.computeIfAbsent(m, mk -> {\n-            try {\n-                \/\/ Look up the default method for special invocation thereby\n-                \/\/ avoiding recursive invocation back to the proxy\n-                MethodHandle mh = MethodHandles.Lookup.IMPL_LOOKUP.findSpecial(\n-                        intfc, mk.getName(),\n-                        MethodType.methodType(mk.getReturnType(), mk.getParameterTypes()),\n-                        self.getClass());\n-                return mh.asSpreader(Object[].class, mk.getParameterCount());\n-            } catch (NoSuchMethodException | IllegalAccessException e) {\n-                \/\/ The method is known to exist and should be accessible, this\n-                \/\/ method would not be called unless the invokeinterface to the\n-                \/\/ default (public) method passed access control checks\n-                throw new InternalError(e);\n-            }\n-        });\n-        return dmh.invoke(self, args);\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleProxies.java","additions":2,"deletions":39,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n- * @bug 8206955 8269351\n+ * @bug 8206955 8269351 8280377\n@@ -36,0 +36,1 @@\n+import java.util.Arrays;\n@@ -45,0 +46,1 @@\n+        default String aConcat(Object... objs) { return Arrays.deepToString(objs); }\n@@ -51,0 +53,1 @@\n+        default String bConcat(Object[] objs) { return Arrays.deepToString(objs); }\n@@ -91,0 +94,5 @@\n+\n+        \/\/ test varargs\n+        assertEquals(proxy.aConcat(\"a\", \"b\", \"c\"), \"[a, b, c]\");\n+        assertEquals(proxy.aConcat(new Object[] { \"a\", \"b\", \"c\" }), \"[a, b, c]\");\n+        assertEquals(proxy.bConcat(new Object[] { \"a\", \"b\", \"c\" }), \"[a, b, c]\");\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandlesProxiesTest.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"}]}