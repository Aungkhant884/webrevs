{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -127,2 +127,2 @@\n-        \/\/ update the Sockets impl to the impl from the http Socket\n-        SocketImpl si = httpSocket.impl;\n+        \/\/ change Socket to use httpSocket's SocketImpl\n+        SocketImpl si = httpSocket.impl();\n","filename":"src\/java.base\/share\/classes\/java\/net\/HttpConnectSocketImpl.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -81,3 +81,1 @@\n-    \/**\n-     * The underlying SocketImpl\n-     *\/\n+    \/\/ the underlying SocketImpl\n@@ -86,3 +84,1 @@\n-    \/**\n-     * Various states of this socket, need stateLock to change.\n-     *\/\n+    \/\/ various states\n@@ -92,1 +88,10 @@\n-    private final Object stateLock = new Object();\n+\n+    \/\/ used to coordinate creating and closing underlying socket\n+    private final Object socketLock = new Object();\n+\n+    \/**\n+     * Creates a server socket with the given {@code SocketImpl}.\n+     *\/\n+    private ServerSocket(Void unused, SocketImpl impl) {\n+        this.impl = Objects.requireNonNull(impl);\n+    }\n@@ -107,3 +112,1 @@\n-        Objects.requireNonNull(impl);\n-        checkPermission();\n-        this.impl = impl;\n+        this(checkPermission(), impl);\n@@ -283,6 +286,16 @@\n-     * Get the {@code SocketImpl} attached to this socket, creating\n-     * it if necessary.\n-     *\n-     * @return  the {@code SocketImpl} attached to that ServerSocket.\n-     * @throws SocketException if creation fails.\n-     * @since 1.4\n+     * Create a SocketImpl for a server socket. The SocketImpl s created\n+     * without an underlying socket.\n+     *\/\n+    private static SocketImpl createImpl() {\n+        SocketImplFactory factory = ServerSocket.factory;\n+        if (factory != null) {\n+            return factory.createSocketImpl();\n+        } else {\n+            return SocketImpl.createPlatformSocketImpl(true);\n+        }\n+    }\n+\n+    \/**\n+     * Returns the {@code SocketImpl} for this ServerSocket, creating the\n+     * underlying socket if required.\n+     * @throws SocketException if creating the underlying socket fails\n@@ -292,1 +305,1 @@\n-            synchronized (stateLock) {\n+            synchronized (socketLock) {\n@@ -311,12 +324,0 @@\n-    \/**\n-     * Create a SocketImpl for a server socket.\n-     *\/\n-    private static SocketImpl createImpl() {\n-        SocketImplFactory factory = ServerSocket.factory;\n-        if (factory != null) {\n-            return factory.createSocketImpl();\n-        } else {\n-            return SocketImpl.createPlatformSocketImpl(true);\n-        }\n-    }\n-\n@@ -388,9 +389,5 @@\n-        synchronized (stateLock) {\n-            if (closed)\n-                throw new SocketException(\"Socket is closed\");\n-            if (bound)\n-                throw new SocketException(\"Already bound\");\n-            getImpl().bind(epoint.getAddress(), epoint.getPort());\n-            getImpl().listen(backlog);\n-            bound = true;\n-        }\n+        \/\/ SocketImpl bind+listen throw if already bound or closed\n+        SocketImpl impl = getImpl();\n+        impl.bind(epoint.getAddress(), epoint.getPort());\n+        impl.listen(backlog);\n+        bound = true;\n@@ -584,1 +581,1 @@\n-        SocketImpl si = s.impl;\n+        SocketImpl si = s.impl();\n@@ -589,2 +586,7 @@\n-            s.setImpl(si);\n-            s.postAccept();\n+            try {\n+                s.setConnectedImpl(si);\n+            } catch (SocketException e) {\n+                \/\/ s has been closed so newly accepted connection needs to be closed\n+                si.closeQuietly();\n+                throw e;\n+            }\n@@ -595,2 +597,2 @@\n-        if (si instanceof DelegatingSocketImpl) {\n-            si = ((DelegatingSocketImpl) si).delegate();\n+        if (si instanceof DelegatingSocketImpl dsi) {\n+            si = dsi.delegate();\n@@ -612,2 +614,7 @@\n-            s.setImpl(psi);\n-            si.closeQuietly();\n+            try {\n+                s.setConnectedImpl(psi);\n+            } catch (SocketException e) {\n+                \/\/ s has been closed so newly accepted connection needs to be closed\n+                psi.closeQuietly();\n+                throw e;\n+            }\n@@ -615,1 +622,1 @@\n-            s.impl = null; \/\/ temporarily break connection to impl\n+            s.setImpl(null);    \/\/ temporarily break connection to impl\n@@ -619,1 +626,1 @@\n-                s.impl = si;  \/\/ restore connection to impl\n+                s.setImpl(si);  \/\/ restore connection to impl\n@@ -621,0 +628,1 @@\n+            s.setConnected();\n@@ -622,1 +630,1 @@\n-        s.postAccept();\n+\n@@ -739,1 +747,1 @@\n-        synchronized (stateLock) {\n+        synchronized (socketLock) {\n@@ -833,2 +841,2 @@\n-        if (o instanceof Integer) {\n-            return ((Integer) o).intValue();\n+        if (o instanceof Integer i) {\n+            return i.intValue();\n@@ -1013,2 +1021,2 @@\n-     public void setReceiveBufferSize (int size) throws SocketException {\n-        if (!(size > 0)) {\n+    public void setReceiveBufferSize(int size) throws SocketException {\n+        if (size <= 0)\n@@ -1016,1 +1024,0 @@\n-        }\n","filename":"src\/java.base\/share\/classes\/java\/net\/ServerSocket.java","additions":62,"deletions":55,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -101,22 +101,1 @@\n-    \/**\n-     * Various states of this socket.\n-     *\/\n-    private boolean created = false;\n-    private boolean bound = false;\n-    private boolean connected = false;\n-    private boolean closed = false;\n-    private Object closeLock = new Object();\n-    private boolean shutIn = false;\n-    private boolean shutOut = false;\n-\n-    \/**\n-     * The implementation of this Socket.\n-     *\/\n-    SocketImpl impl;\n-\n-    \/**\n-     * Socket input\/output streams\n-     *\/\n-    private volatile InputStream in;\n-    private volatile OutputStream out;\n-    private static final VarHandle IN, OUT;\n+    private static final VarHandle STATE, IN, OUT;\n@@ -126,0 +105,1 @@\n+            STATE = l.findVarHandle(Socket.class, \"state\", int.class);\n@@ -133,0 +113,57 @@\n+    \/\/ the underlying SocketImpl, may be null, may be swapped when connecting\n+    private volatile SocketImpl impl;\n+\n+    \/\/ state bits\n+    private static final int SOCKET_CREATED = 1 << 0;   \/\/ impl.create(boolean) called\n+    private static final int BOUND          = 1 << 1;\n+    private static final int CONNECTED      = 1 << 2;\n+    private static final int CLOSED         = 1 << 3;\n+    private static final int SHUT_IN        = 1 << 9;\n+    private static final int SHUT_OUT       = 1 << 10;\n+    private volatile int state;\n+\n+    \/\/ used to coordinate creating and closing underlying socket\n+    private final Object socketLock = new Object();\n+\n+    \/\/ input\/output streams\n+    private volatile InputStream in;\n+    private volatile OutputStream out;\n+\n+    \/**\n+     * Atomically sets state to the result of a bitwise OR of the current value\n+     * and the given mask.\n+     * @return the previous state value\n+     *\/\n+    private int getAndBitwiseOrState(int mask) {\n+        return (int) STATE.getAndBitwiseOr(this, mask);\n+    }\n+\n+    private static boolean isBound(int s) {\n+        return (s & BOUND) != 0;\n+    }\n+\n+    private static boolean isConnected(int s) {\n+        return (s & CONNECTED) != 0;\n+    }\n+\n+    private static boolean isClosed(int s) {\n+        return (s & CLOSED) != 0;\n+    }\n+\n+    private static boolean isInputShutdown(int s) {\n+        return (s & SHUT_IN) != 0;\n+    }\n+\n+    private static boolean isOutputShutdown(int s) {\n+        return (s & SHUT_OUT) != 0;\n+    }\n+\n+    \/**\n+     * Creates an unconnected socket with the given {@code SocketImpl}.\n+     *\/\n+    private Socket(Void unused, SocketImpl impl) {\n+        if (impl != null) {\n+            this.impl = impl;\n+        }\n+    }\n+\n@@ -145,1 +182,1 @@\n-        setImpl();\n+        this.impl = createImpl();\n@@ -235,2 +272,1 @@\n-        checkPermission(impl);\n-        this.impl = impl;\n+        this(checkPermission(impl), impl);\n@@ -240,7 +276,6 @@\n-        if (impl == null) {\n-            return null;\n-        }\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            sm.checkPermission(SecurityConstants.SET_SOCKETIMPL_PERMISSION);\n+        if (impl != null) {\n+            @SuppressWarnings(\"removal\")\n+            SecurityManager sm = System.getSecurityManager();\n+            if (sm != null) {\n+                sm.checkPermission(SecurityConstants.SET_SOCKETIMPL_PERMISSION);\n+            }\n@@ -497,3 +532,12 @@\n-    private Socket(SocketAddress address, SocketAddress localAddr,\n-                   boolean stream) throws IOException {\n-        setImpl();\n+    \/**\n+     * Initialize a new Socket that is connected to the given remote address.\n+     * The socket is optionally bound to a local address before connecting.\n+     *\n+     * @param address the remote address to connect to\n+     * @param localAddr the local address to bind to, can be null\n+     * @param stream true for a stream socket, false for a datagram socket\n+     *\/\n+    private Socket(SocketAddress address, SocketAddress localAddr, boolean stream)\n+        throws IOException\n+    {\n+        Objects.requireNonNull(address);\n@@ -501,3 +545,6 @@\n-        \/\/ backward compatibility\n-        if (address == null)\n-            throw new NullPointerException();\n+        \/\/ create the SocketImpl and the underlying socket\n+        SocketImpl impl = createImpl();\n+        impl.create(stream);\n+\n+        this.impl = impl;\n+        this.state = SOCKET_CREATED;\n@@ -506,1 +553,0 @@\n-            createImpl(stream);\n@@ -521,6 +567,2 @@\n-     * Creates the socket implementation.\n-     *\n-     * @param stream a {@code boolean} value : {@code true} for a TCP socket,\n-     *               {@code false} for UDP.\n-     * @throws SocketException if creation fails\n-     * @since 1.4\n+     * Create a new SocketImpl for a connecting\/client socket. The SocketImpl\n+     * is created without an underlying socket.\n@@ -528,10 +570,8 @@\n-     void createImpl(boolean stream) throws SocketException {\n-        if (impl == null)\n-            setImpl();\n-        try {\n-            impl.create(stream);\n-            created = true;\n-        } catch (SocketException e) {\n-            throw e;\n-        } catch (IOException e) {\n-            throw new SocketException(e.getMessage(), e);\n+    private static SocketImpl createImpl() {\n+        SocketImplFactory factory = Socket.factory;\n+        if (factory != null) {\n+            return factory.createSocketImpl();\n+        } else {\n+            \/\/ create a SOCKS SocketImpl that delegates to a platform SocketImpl\n+            SocketImpl delegate = SocketImpl.createPlatformSocketImpl(false);\n+            return new SocksSocketImpl(delegate);\n@@ -541,2 +581,29 @@\n-    void setImpl(SocketImpl si) {\n-         impl = si;\n+    \/**\n+     * Returns the {@code SocketImpl} for this Socket, creating it, and the\n+     * underlying socket, if required.\n+     * @throws SocketException if creating the underlying socket fails\n+     *\/\n+    private SocketImpl getImpl() throws SocketException {\n+        if ((state & SOCKET_CREATED) == 0) {\n+            synchronized (socketLock) {\n+                int s = state;   \/\/ re-read state\n+                if ((s & SOCKET_CREATED) == 0) {\n+                    if (isClosed(s)) {\n+                        throw new SocketException(\"Socket is closed\");\n+                    }\n+                    SocketImpl impl = this.impl;\n+                    if (impl == null) {\n+                        this.impl = impl = createImpl();\n+                    }\n+                    try {\n+                        impl.create(true);\n+                    } catch (SocketException e) {\n+                        throw e;\n+                    } catch (IOException e) {\n+                        throw new SocketException(e.getMessage(), e);\n+                    }\n+                    getAndBitwiseOrState(SOCKET_CREATED);\n+                }\n+            }\n+        }\n+        return impl;\n@@ -546,2 +613,1 @@\n-     * Sets impl to the system-default type of SocketImpl.\n-     * @since 1.4\n+     * Returns the SocketImpl, may be null.\n@@ -549,8 +615,24 @@\n-    void setImpl() {\n-        SocketImplFactory factory = Socket.factory;\n-        if (factory != null) {\n-            impl = factory.createSocketImpl();\n-        } else {\n-            \/\/ create a SOCKS SocketImpl that delegates to a platform SocketImpl\n-            SocketImpl delegate = SocketImpl.createPlatformSocketImpl(false);\n-            impl = new SocksSocketImpl(delegate);\n+    SocketImpl impl() {\n+        return impl;\n+    }\n+\n+    \/**\n+     * Sets the SocketImpl. The SocketImpl is connected to a peer. The behavior for\n+     * the case that the Socket was not a newly created Socket is unspecified. If\n+     * there is an existing SocketImpl then it closed to avoid leaking resources.\n+     * @throws SocketException if the Socket is closed\n+     * @apiNote For ServerSocket use when accepting connections\n+     *\/\n+    void setConnectedImpl(SocketImpl si) throws SocketException {\n+        synchronized (socketLock) {\n+            if ((state & CLOSED) != 0) {\n+                throw new SocketException(\"Socket is closed\");\n+            }\n+            SocketImpl previous = impl;\n+            impl = si;\n+            state = (SOCKET_CREATED | BOUND | CONNECTED);\n+            if (previous != null) {\n+                in = null;\n+                out = null;\n+                previous.closeQuietly();\n+            }\n@@ -561,6 +643,2 @@\n-     * Get the {@code SocketImpl} attached to this socket, creating\n-     * it if necessary.\n-     *\n-     * @return  the {@code SocketImpl} attached to that ServerSocket.\n-     * @throws SocketException if creation fails\n-     * @since 1.4\n+     * Sets the SocketImpl.\n+     * @apiNote For ServerSocket use when accepting connections with a custom SocketImpl\n@@ -568,4 +646,10 @@\n-    SocketImpl getImpl() throws SocketException {\n-        if (!created)\n-            createImpl(true);\n-        return impl;\n+    void setImpl(SocketImpl si) {\n+        impl = si;\n+    }\n+\n+    \/**\n+     * Sets to Socket state for a newly accepted connection.\n+     * @apiNote For ServerSocket use when accepting connections with a custom SocketImpl\n+     *\/\n+    void setConnected() {\n+        getAndBitwiseOrState(SOCKET_CREATED | BOUND | CONNECTED);\n@@ -642,1 +726,1 @@\n-          throw new IllegalArgumentException(\"connect: timeout can't be negative\");\n+            throw new IllegalArgumentException(\"connect: timeout can't be negative\");\n@@ -644,1 +728,2 @@\n-        if (isClosed())\n+        int s = state;\n+        if (isClosed(s))\n@@ -646,2 +731,1 @@\n-\n-        if (isConnected())\n+        if (isConnected(s))\n@@ -653,1 +737,1 @@\n-        InetAddress addr = epoint.getAddress ();\n+        InetAddress addr = epoint.getAddress();\n@@ -665,2 +749,1 @@\n-        if (!created)\n-            createImpl(true);\n+\n@@ -668,1 +751,1 @@\n-            impl.connect(epoint, timeout);\n+            getImpl().connect(epoint, timeout);\n@@ -679,6 +762,3 @@\n-        connected = true;\n-        \/*\n-         * If the socket was not bound before the connect, it is now because\n-         * the kernel will have picked an ephemeral port & a local address\n-         *\/\n-        bound = true;\n+\n+        \/\/ connect will bind the socket if not previously bound\n+        getAndBitwiseOrState(BOUND | CONNECTED);\n@@ -706,1 +786,2 @@\n-        if (isClosed())\n+        int s = state;\n+        if (isClosed(s))\n@@ -708,1 +789,1 @@\n-        if (isBound())\n+        if (isBound(s))\n@@ -727,2 +808,2 @@\n-        getImpl().bind (addr, port);\n-        bound = true;\n+        getImpl().bind(addr, port);\n+        getAndBitwiseOrState(BOUND);\n@@ -731,1 +812,1 @@\n-    private void checkAddress (InetAddress addr, String op) {\n+    private void checkAddress(InetAddress addr, String op) {\n@@ -740,9 +821,0 @@\n-    \/**\n-     * set the flags after an accept() call.\n-     *\/\n-    final void postAccept() {\n-        connected = true;\n-        created = true;\n-        bound = true;\n-    }\n-\n@@ -899,1 +971,0 @@\n-\n@@ -987,1 +1058,2 @@\n-        if (isClosed())\n+        int s = state;\n+        if (isClosed(s))\n@@ -989,1 +1061,1 @@\n-        if (!isConnected())\n+        if (!isConnected(s))\n@@ -991,1 +1063,1 @@\n-        if (isInputShutdown())\n+        if (isInputShutdown(s))\n@@ -1083,1 +1155,2 @@\n-        if (isClosed())\n+        int s = state;\n+        if (isClosed(s))\n@@ -1085,1 +1158,1 @@\n-        if (!isConnected())\n+        if (!isConnected(s))\n@@ -1087,1 +1160,1 @@\n-        if (isOutputShutdown())\n+        if (isOutputShutdown(s))\n@@ -1221,2 +1294,2 @@\n-        if (o instanceof Integer) {\n-            return ((Integer) o).intValue();\n+        if (o instanceof Integer i) {\n+            return i.intValue();\n@@ -1238,2 +1311,2 @@\n-    public void sendUrgentData (int data) throws IOException  {\n-        if (!getImpl().supportsUrgentData ()) {\n+    public void sendUrgentData(int data) throws IOException  {\n+        if (!getImpl().supportsUrgentData()) {\n@@ -1310,1 +1383,1 @@\n-    public synchronized void setSoTimeout(int timeout) throws SocketException {\n+    public void setSoTimeout(int timeout) throws SocketException {\n@@ -1314,2 +1387,1 @@\n-          throw new IllegalArgumentException(\"timeout can't be negative\");\n-\n+            throw new IllegalArgumentException(\"timeout can't be negative\");\n@@ -1330,1 +1402,1 @@\n-    public synchronized int getSoTimeout() throws SocketException {\n+    public int getSoTimeout() throws SocketException {\n@@ -1335,2 +1407,2 @@\n-        if (o instanceof Integer) {\n-            return ((Integer) o).intValue();\n+        if (o instanceof Integer i) {\n+            return i.intValue();\n@@ -1365,3 +1437,2 @@\n-    public synchronized void setSendBufferSize(int size)\n-    throws SocketException{\n-        if (!(size > 0)) {\n+    public void setSendBufferSize(int size) throws SocketException {\n+        if (size <= 0)\n@@ -1369,1 +1440,0 @@\n-        }\n@@ -1388,1 +1458,1 @@\n-    public synchronized int getSendBufferSize() throws SocketException {\n+    public int getSendBufferSize() throws SocketException {\n@@ -1393,2 +1463,2 @@\n-        if (o instanceof Integer) {\n-            result = ((Integer)o).intValue();\n+        if (o instanceof Integer i) {\n+            result = i.intValue();\n@@ -1439,3 +1509,2 @@\n-    public synchronized void setReceiveBufferSize(int size)\n-    throws SocketException{\n-        if (size <= 0) {\n+    public void setReceiveBufferSize(int size) throws SocketException {\n+        if (size <= 0)\n@@ -1443,1 +1512,0 @@\n-        }\n@@ -1461,2 +1529,1 @@\n-    public synchronized int getReceiveBufferSize()\n-    throws SocketException{\n+    public int getReceiveBufferSize() throws SocketException {\n@@ -1467,2 +1534,2 @@\n-        if (o instanceof Integer) {\n-            result = ((Integer)o).intValue();\n+        if (o instanceof Integer i) {\n+            result = i.intValue();\n@@ -1553,1 +1620,0 @@\n-\n@@ -1556,8 +1622,1 @@\n-        try {\n-            getImpl().setOption(SocketOptions.IP_TOS, tc);\n-        } catch (SocketException se) {\n-            \/\/ not supported if socket already connected\n-            \/\/ Solaris returns error in such cases\n-            if(!isConnected())\n-                throw se;\n-        }\n+        getImpl().setOption(SocketOptions.IP_TOS, tc);\n@@ -1664,7 +1723,9 @@\n-    public synchronized void close() throws IOException {\n-        synchronized(closeLock) {\n-            if (isClosed())\n-                return;\n-            if (created)\n-                impl.close();\n-            closed = true;\n+    public void close() throws IOException {\n+        synchronized (socketLock) {\n+            if ((state & CLOSED) == 0) {\n+                int s = getAndBitwiseOrState(CLOSED);\n+                if ((s & (SOCKET_CREATED | CLOSED)) == SOCKET_CREATED) {\n+                    \/\/ close underlying socket if created\n+                    impl.close();\n+                }\n+            }\n@@ -1692,3 +1753,3 @@\n-    public void shutdownInput() throws IOException\n-    {\n-        if (isClosed())\n+    public void shutdownInput() throws IOException {\n+        int s = state;\n+        if (isClosed(s))\n@@ -1696,1 +1757,1 @@\n-        if (!isConnected())\n+        if (!isConnected(s))\n@@ -1698,1 +1759,1 @@\n-        if (isInputShutdown())\n+        if (isInputShutdown(s))\n@@ -1701,1 +1762,1 @@\n-        shutIn = true;\n+        getAndBitwiseOrState(SHUT_IN);\n@@ -1722,3 +1783,3 @@\n-    public void shutdownOutput() throws IOException\n-    {\n-        if (isClosed())\n+    public void shutdownOutput() throws IOException {\n+        int s = state;\n+        if (isClosed(s))\n@@ -1726,1 +1787,1 @@\n-        if (!isConnected())\n+        if (!isConnected(s))\n@@ -1728,1 +1789,1 @@\n-        if (isOutputShutdown())\n+        if (isOutputShutdown(s))\n@@ -1731,1 +1792,1 @@\n-        shutOut = true;\n+        getAndBitwiseOrState(SHUT_OUT);\n@@ -1762,1 +1823,1 @@\n-        return connected;\n+        return isConnected(state);\n@@ -1778,1 +1839,1 @@\n-        return bound;\n+        return isBound(state);\n@@ -1789,3 +1850,1 @@\n-        synchronized(closeLock) {\n-            return closed;\n-        }\n+        return isClosed(state);\n@@ -1802,1 +1861,1 @@\n-        return shutIn;\n+        return isInputShutdown(state);\n@@ -1813,1 +1872,1 @@\n-        return shutOut;\n+        return isOutputShutdown(state);\n","filename":"src\/java.base\/share\/classes\/java\/net\/Socket.java","additions":232,"deletions":173,"binary":false,"changes":405,"status":"modified"},{"patch":"@@ -0,0 +1,293 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8278326\n+ * @modules java.base\/java.net:+open\n+ * @run junit ImplAccept\n+ * @summary Test ServerSocket.implAccept with a Socket in different states.\n+ *\/\n+\n+import java.io.FileDescriptor;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.net.SocketImpl;\n+import java.net.SocketOption;\n+import java.net.StandardSocketOptions;\n+import java.io.IOException;\n+\n+import org.junit.*;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class ImplAccept {\n+\n+    \/**\n+     * Test ServerSocket.implAccept with an unbound Socket.\n+     *\/\n+    @Test\n+    public void testUnbound() throws Exception {\n+        try (Socket socket = new Socket()) {\n+\n+            \/\/ Socket.impl -> DelegatingSocketImpl\n+            SocketImpl si = getSocketImpl(socket);\n+            assertTrue(isDelegatingSocketImpl(si));\n+\n+            try (ServerSocket ss = serverSocketToAccept(socket);\n+                 Socket peer = new Socket(ss.getInetAddress(), ss.getLocalPort())) {\n+\n+                Socket s = ss.accept();\n+                assertTrue(s == socket);\n+\n+                \/\/ Socket.impl should be replaced with a new PlatformSocketImpl\n+                SocketImpl psi = getSocketImpl(socket);\n+                assertTrue(isPlatformSocketImpl(psi));\n+\n+                \/\/ socket and peer should be connected to each other\n+                pingPong(socket, peer);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test ServerSocket.implAccept with a bound Socket. The usage is nonsensical\n+     * but we can test that the accepted Socket is connected and the underlying\n+     * socket from the original SocketImpl is closed.\n+     *\/\n+    @Test\n+    public void testBound() throws Exception {\n+        try (Socket socket = new Socket()) {\n+\n+            \/\/ Socket.impl -> DelegatingSocketImpl -> PlatformSocketImpl\n+            SocketImpl si = getSocketImpl(socket);\n+            SocketImpl psi1 = getDelegate(si);\n+            assertTrue(isPlatformSocketImpl(psi1));\n+\n+            \/\/ bind to local address\n+            socket.bind(loopbackSocketAddress());\n+            assertTrue(isSocketOpen(psi1));\n+\n+            try (ServerSocket ss = serverSocketToAccept(socket);\n+                 Socket peer = new Socket(ss.getInetAddress(), ss.getLocalPort())) {\n+\n+                Socket s = ss.accept();\n+                assertTrue(s == socket);\n+\n+                \/\/ Socket.impl should be replaced with a new PlatformSocketImpl\n+                SocketImpl psi2 = getSocketImpl(socket);\n+                assertTrue(isPlatformSocketImpl(psi2));\n+\n+                \/\/ psi1 should be closed\n+                assertFalse(isSocketOpen(psi1));\n+\n+                \/\/ socket and peer should be connected to each other\n+                pingPong(socket, peer);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test ServerSocket.implAccept with a connected Socket. The usage is nonsensical\n+     * but we can test that the accepted Socket is connected and the underlying\n+     * socket from the original SocketImpl is closed.\n+     *\/\n+    @Test\n+    public void testConnected() throws Exception {\n+        Socket socket;\n+        Socket peer1;\n+        try (ServerSocket ss = new ServerSocket()) {\n+            ss.bind(loopbackSocketAddress());\n+            socket = new Socket(ss.getInetAddress(), ss.getLocalPort());\n+            peer1 = ss.accept();\n+        }\n+\n+        try {\n+            \/\/ Socket.impl -> DelegatingSocketImpl -> PlatformSocketImpl\n+            SocketImpl si = getSocketImpl(socket);\n+            SocketImpl psi1 = getDelegate(si);\n+            assertTrue(isPlatformSocketImpl(psi1));\n+\n+            try (ServerSocket ss = serverSocketToAccept(socket);\n+                 Socket peer2 = new Socket(ss.getInetAddress(), ss.getLocalPort())) {\n+\n+                Socket s = ss.accept();\n+                assertTrue(s == socket);\n+\n+                \/\/ Socket.impl should be replaced with a new PlatformSocketImpl\n+                SocketImpl psi2 = getSocketImpl(socket);\n+                assertTrue(isPlatformSocketImpl(psi2));\n+\n+                \/\/ psi1 should be closed and peer1 should read EOF\n+                assertFalse(isSocketOpen(psi1));\n+                assertTrue(peer1.getInputStream().read() == -1);\n+\n+                \/\/ socket and peer2 should be connected to each other\n+                pingPong(socket, peer2);\n+            }\n+        } finally {\n+            socket.close();\n+            peer1.close();\n+        }\n+    }\n+\n+    \/**\n+     * Test ServerSocket.implAccept with a closed Socket. The usage is nonsensical\n+     * but we can test ServerSocket.accept throws and that it closes the connection\n+     * to the peer.\n+     *\/\n+    @Test\n+    public void testClosed() throws Exception {\n+        Socket socket = new Socket();\n+        socket.close();\n+\n+        try (ServerSocket ss = serverSocketToAccept(socket);\n+             Socket peer = new Socket(ss.getInetAddress(), ss.getLocalPort())) {\n+\n+            SocketImpl si = getSocketImpl(socket);\n+\n+            \/\/ accept should throw and peer should read EOF\n+            assertThrows(IOException.class, ss::accept);\n+            assertTrue(peer.getInputStream().read() == -1);\n+\n+            \/\/ the SocketImpl should have not changed\n+            assertTrue(getSocketImpl(socket) == si);\n+        }\n+    }\n+\n+    \/**\n+     * Returns the socket's SocketImpl.\n+     *\/\n+    private static SocketImpl getSocketImpl(Socket s) {\n+        try {\n+            Field f = Socket.class.getDeclaredField(\"impl\");\n+            f.setAccessible(true);\n+            return (SocketImpl) f.get(s);\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    \/**\n+     * Returns the SocketImpl that the given SocketImpl delegates to.\n+     *\/\n+    private static SocketImpl getDelegate(SocketImpl si) {\n+        try {\n+            Class<?> clazz = Class.forName(\"java.net.DelegatingSocketImpl\");\n+            Field f = clazz.getDeclaredField(\"delegate\");\n+            f.setAccessible(true);\n+            return (SocketImpl) f.get(si);\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    \/**\n+     * Returns true if the SocketImpl is a DelegatingSocketImpl.\n+     *\/\n+    private static boolean isDelegatingSocketImpl(SocketImpl si) {\n+        try {\n+            Class<?> clazz = Class.forName(\"java.net.DelegatingSocketImpl\");\n+            return clazz.isInstance(si);\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    \/**\n+     * Returns true if the SocketImpl is a PlatformSocketImpl.\n+     *\/\n+    private static boolean isPlatformSocketImpl(SocketImpl si) {\n+        try {\n+            Class<?> clazz = Class.forName(\"sun.net.PlatformSocketImpl\");\n+            return clazz.isInstance(si);\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    \/**\n+     * Returns true if the SocketImpl has an open socket.\n+     *\/\n+    private static boolean isSocketOpen(SocketImpl si) throws Exception {\n+        assertTrue(isPlatformSocketImpl(si));\n+\n+        \/\/ check if SocketImpl.fd is set\n+        Field f = SocketImpl.class.getDeclaredField(\"fd\");\n+        f.setAccessible(true);\n+        FileDescriptor fd = (FileDescriptor) f.get(si);\n+        if (fd == null) {\n+            return false;  \/\/ not created\n+        }\n+\n+        \/\/ call getSocket to get the value of the SO_REUSEADDR socket option\n+        Method m = SocketImpl.class.getDeclaredMethod(\"getOption\", SocketOption.class);\n+        m.setAccessible(true);\n+        try {\n+            m.invoke(si, StandardSocketOptions.SO_REUSEADDR);\n+            return true; \/\/ socket is open\n+        } catch (InvocationTargetException e) {\n+            if (e.getCause() instanceof IOException) {\n+                return false; \/\/ assume socket is closed\n+            }\n+            throw e;\n+        }\n+    }\n+\n+    \/**\n+     * Test that two sockets are connected to each other.\n+     *\/\n+    private static void pingPong(Socket s1, Socket s2) throws Exception {\n+        s1.getOutputStream().write(11);\n+        s2.getOutputStream().write(22);\n+        assertTrue(s1.getInputStream().read() == 22);\n+        assertTrue(s2.getInputStream().read() == 11);\n+    }\n+\n+    \/**\n+     * Creates a ServerSocket that returns the given Socket from accept.\n+     *\/\n+    private static ServerSocket serverSocketToAccept(Socket s) throws IOException {\n+        ServerSocket ss = new ServerSocket() {\n+            @Override\n+            public Socket accept() throws IOException {\n+                implAccept(s);\n+                return s;\n+            }\n+        };\n+        ss.bind(loopbackSocketAddress());\n+        return ss;\n+    }\n+\n+    \/**\n+     * Returns a new InetSocketAddress with the loopback interface and port 0.\n+     *\/\n+    private static InetSocketAddress loopbackSocketAddress() {\n+        InetAddress loopback = InetAddress.getLoopbackAddress();\n+        return new InetSocketAddress(loopback, 0);\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/ServerSocket\/ImplAccept.java","additions":293,"deletions":0,"binary":false,"changes":293,"status":"added"},{"patch":"@@ -0,0 +1,230 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8278326\n+ * @modules java.base\/java.net:+open\n+ * @run junit Leaky\n+ * @summary Test async close when binding, connecting, or reading a socket option\n+ *\/\n+\n+import java.io.FileDescriptor;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.net.SocketImpl;\n+import java.net.SocketOption;\n+import java.net.StandardSocketOptions;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.junit.*;\n+import org.junit.jupiter.api.*;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class Leaky {\n+    private static ScheduledExecutorService executor;\n+    private static ServerSocket listener;\n+\n+    @BeforeAll\n+    public static void setup() throws Exception {\n+        listener = new ServerSocket();\n+        listener.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));\n+        executor = Executors.newScheduledThreadPool(2);\n+    }\n+\n+    @AfterAll\n+    public static void finish() throws Exception {\n+        executor.close();\n+        listener.close();\n+    }\n+\n+    \/**\n+     * Race Socket bind and close.\n+     *\/\n+    @RepeatedTest(100)\n+    public void raceBindAndClose() throws Exception {\n+        Socket socket = new Socket();\n+\n+        race(socket::close, () -> {\n+            try {\n+                socket.bind(new InetSocketAddress(0));\n+            } catch (IOException ioe) {\n+                if (!socket.isClosed()) {\n+                    throw ioe;\n+                }\n+            }\n+        });\n+\n+        \/\/ check that there isn't an open socket\n+        SocketImpl psi = getPlatformSocketImpl(socket);\n+        assertFalse(isSocketOpen(psi));\n+    }\n+\n+    \/**\n+     * Race Socket connect and close.\n+     *\/\n+    @RepeatedTest(100)\n+    public void raceConnectAndClose() throws Exception {\n+        Socket socket = new Socket();\n+\n+        race(socket::close, () -> {\n+            try {\n+                socket.connect(listener.getLocalSocketAddress());\n+                \/\/ if connected, need to close other end\n+                listener.accept().close();\n+            } catch (IOException ioe) {\n+                if (!socket.isClosed()) {\n+                    throw ioe;\n+                }\n+            }\n+        });\n+\n+        \/\/ check that there isn't an open socket\n+        SocketImpl psi = getPlatformSocketImpl(socket);\n+        assertFalse(isSocketOpen(psi));\n+    }\n+\n+    \/**\n+     * Race Socket getOption and close.\n+     *\/\n+    @RepeatedTest(100)\n+    public void raceGetOptionAndClose() throws Exception {\n+        Socket socket = new Socket();\n+\n+        race(socket::close, () -> {\n+            try {\n+                socket.getOption(StandardSocketOptions.SO_REUSEADDR);\n+            } catch (IOException ioe) {\n+                if (!socket.isClosed()) {\n+                    throw ioe;\n+                }\n+            }\n+        });\n+\n+        \/\/ check that there isn't an open socket\n+        SocketImpl psi = getPlatformSocketImpl(socket);\n+        assertFalse(isSocketOpen(psi));\n+    }\n+\n+    \/**\n+     * A task that may throw an exception.\n+     *\/\n+    private interface ThrowingRunnable {\n+        void run() throws Exception;\n+    }\n+\n+    \/**\n+     * Staggers two tasks to execute after random delays.\n+     *\/\n+    private void race(ThrowingRunnable task1, ThrowingRunnable task2) throws Exception {\n+        int delay1 = ThreadLocalRandom.current().nextInt(10);\n+        int delay2 = ThreadLocalRandom.current().nextInt(10);\n+\n+        Future<Void> future1 = executor.schedule(() -> {\n+            task1.run();\n+            return null;\n+        }, delay1, TimeUnit.MILLISECONDS);\n+\n+        Future<Void> future2 = executor.schedule(() -> {\n+            task2.run();\n+            return null;\n+        }, delay2, TimeUnit.MILLISECONDS);\n+\n+        try {\n+            future1.get();\n+        } finally {\n+            future2.get();\n+        }\n+    }\n+\n+    \/**\n+     * Return the underlying PlatformSocketImpl for the given socket.\n+     *\/\n+    private static SocketImpl getPlatformSocketImpl(Socket s) {\n+        SocketImpl si = getSocketImpl(s);\n+        return getDelegate(si);\n+    }\n+\n+    \/**\n+     * Returns the socket's SocketImpl.\n+     *\/\n+    private static SocketImpl getSocketImpl(Socket s) {\n+        try {\n+            Field f = Socket.class.getDeclaredField(\"impl\");\n+            f.setAccessible(true);\n+            return (SocketImpl) f.get(s);\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    \/**\n+     * Returns the SocketImpl that the given SocketImpl delegates to.\n+     *\/\n+    private static SocketImpl getDelegate(SocketImpl si) {\n+        try {\n+            Class<?> clazz = Class.forName(\"java.net.DelegatingSocketImpl\");\n+            Field f = clazz.getDeclaredField(\"delegate\");\n+            f.setAccessible(true);\n+            return (SocketImpl) f.get(si);\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    \/**\n+     * Returns true if the SocketImpl has an open socket.\n+     *\/\n+    private static boolean isSocketOpen(SocketImpl si) throws Exception {\n+        \/\/ check if SocketImpl.fd is set\n+        Field f = SocketImpl.class.getDeclaredField(\"fd\");\n+        f.setAccessible(true);\n+        FileDescriptor fd = (FileDescriptor) f.get(si);\n+        if (fd == null) {\n+            return false;  \/\/ not created\n+        }\n+\n+        \/\/ call getSocket to get the value of the SO_REUSEADDR socket option\n+        Method m = SocketImpl.class.getDeclaredMethod(\"getOption\", SocketOption.class);\n+        m.setAccessible(true);\n+        try {\n+            m.invoke(si, StandardSocketOptions.SO_REUSEADDR);\n+            return true; \/\/ socket is open\n+        } catch (InvocationTargetException e) {\n+            if (e.getCause() instanceof IOException) {\n+                return false; \/\/ assume socket is closed\n+            }\n+            throw e;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/Socket\/asyncClose\/Leaky.java","additions":230,"deletions":0,"binary":false,"changes":230,"status":"added"}]}