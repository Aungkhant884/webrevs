{"files":[{"patch":"@@ -2073,2 +2073,1 @@\n-  oop thread_oop = JNIHandles::resolve(thread_handle);\n-  if (thread_oop != NULL) {\n+  if (thread_handle != NULL) {\n@@ -2076,4 +2075,5 @@\n-    JavaThread* target = java_lang_Thread::thread(thread_oop);\n-    \/\/ Sometimes 'target' is NULL and this test code expects\n-    \/\/ Handshake::execute(HandshakeClosure,...) to handle it.\n-    Handshake::execute(&rmc, &tlh, target);\n+    JavaThread* target = nullptr;\n+    bool is_alive = tlh.cv_internal_thread_to_JavaThread(thread_handle, &target, NULL);\n+    if (is_alive) {\n+      Handshake::execute(&rmc, &tlh, target);\n+    }\n@@ -2107,7 +2107,5 @@\n-  } else {\n-    oop thread_oop = JNIHandles::resolve(thread_handle);\n-    if (thread_oop != NULL) {\n-      ThreadsListHandle tlh;\n-      JavaThread* target = java_lang_Thread::thread(thread_oop);\n-      \/\/ Sometimes 'target' is NULL and this test code expects\n-      \/\/ Handshake::execute(HandshakeClosure,...) to handle it.\n+  } else if (thread_handle != NULL) {\n+    ThreadsListHandle tlh;\n+    JavaThread* target = nullptr;\n+    bool is_alive = tlh.cv_internal_thread_to_JavaThread(thread_handle, &target, NULL);\n+    if (is_alive) {\n@@ -2138,2 +2136,1 @@\n-  oop thread_oop = JNIHandles::resolve(thread_handle);\n-  if (thread_oop != NULL) {\n+  if (thread_handle != NULL) {\n@@ -2141,5 +2138,6 @@\n-    JavaThread* target = java_lang_Thread::thread(thread_oop);\n-    \/\/ Sometimes 'target' is NULL and this test code expects\n-    \/\/ Handshake::execute(AsyncHandshakeClosure,...) to handle it.\n-    TraceSelfClosure* tsc = new TraceSelfClosure(target);\n-    Handshake::execute(tsc, target);\n+    JavaThread* target = nullptr;\n+    bool is_alive = tlh.cv_internal_thread_to_JavaThread(thread_handle, &target, NULL);\n+    if (is_alive) {\n+      TraceSelfClosure* tsc = new TraceSelfClosure(target);\n+      Handshake::execute(tsc, target);\n+    }\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":18,"deletions":20,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -356,3 +356,7 @@\n-  bool target_is_dead = false;\n-  if (target == nullptr) {\n-    target_is_dead = true;\n+  guarantee(target != nullptr, \"must be\");\n+  if (tlh_p == nullptr) {\n+    guarantee(Thread::is_JavaThread_protected(target, \/* checkTLHOnly *\/ true),\n+              \"missing ThreadsListHandle in calling context.\");\n+    target->handshake_state()->add_operation(&op);\n+  } else if (tlh_p->includes(target)) {\n+    target->handshake_state()->add_operation(&op);\n@@ -360,11 +364,0 @@\n-    if (tlh_p == nullptr) {\n-      guarantee(Thread::is_JavaThread_protected_by_my_ThreadsList(target),\n-                \"missing ThreadsListHandle in calling context.\");\n-      target->handshake_state()->add_operation(&op);\n-    } else if (tlh_p->includes(target)) {\n-      target->handshake_state()->add_operation(&op);\n-    } else {\n-      target_is_dead = true;\n-    }\n-  }\n-  if (target_is_dead) {\n@@ -416,6 +409,1 @@\n-  if (target == nullptr) {\n-    \/\/ Stress test that calls WB_AsyncHandshakeWalkStack() can get here:\n-    log_handshake_info(start_time_ns, op->name(), 0, 0, \"(thread dead)\");\n-    delete op;\n-    return;\n-  }\n+  guarantee(target != nullptr, \"must be\");\n@@ -427,1 +415,1 @@\n-    guarantee(Thread::is_JavaThread_protected_by_my_ThreadsList(target),\n+    guarantee(Thread::is_JavaThread_protected(target, \/* checkTLHOnly *\/ true),\n","filename":"src\/hotspot\/share\/runtime\/handshake.cpp","additions":9,"deletions":21,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -68,0 +68,2 @@\n+  \/\/ This version of execute() relies on a ThreadListHandle somewhere in\n+  \/\/ the caller's context to protect target (and we sanity check for that).\n@@ -69,0 +71,4 @@\n+  \/\/ This version of execute() is used when you have a ThreadListHandle in\n+  \/\/ hand and are using it to protect target. If tlh_p == nullptr, then we\n+  \/\/ sanity check for a ThreadListHandle somewhere in the caller's context\n+  \/\/ to verify that target is protected.\n@@ -70,0 +76,2 @@\n+  \/\/ This version of execute() relies on a ThreadListHandle somewhere in\n+  \/\/ the caller's context to protect target (and we sanity check for that).\n","filename":"src\/hotspot\/share\/runtime\/handshake.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -438,9 +438,16 @@\n-\/\/ Is the target JavaThread protected by the calling Thread\n-\/\/ or by some other mechanism:\n-bool Thread::is_JavaThread_protected(const JavaThread* p) {\n-  \/\/ Do the simplest check first:\n-  if (SafepointSynchronize::is_at_safepoint()) {\n-    \/\/ The target is protected since JavaThreads cannot exit\n-    \/\/ while we're at a safepoint.\n-    return true;\n-  }\n+\/\/ Is the target JavaThread protected by the calling Thread or by some other\n+\/\/ mechanism? If checkTLHOnly is true (default is false), then we only check\n+\/\/ if the target JavaThread is protected by a ThreadsList (if any) associated\n+\/\/ with the calling Thread.\n+\/\/\n+bool Thread::is_JavaThread_protected(const JavaThread* p, bool checkTLHOnly) {\n+  Thread* current_thread = nullptr;\n+  if (checkTLHOnly) {\n+    current_thread = Thread::current();\n+  } else {\n+    \/\/ Do the simplest check first:\n+    if (SafepointSynchronize::is_at_safepoint()) {\n+      \/\/ The target is protected since JavaThreads cannot exit\n+      \/\/ while we're at a safepoint.\n+      return true;\n+    }\n@@ -448,6 +455,6 @@\n-  \/\/ If the target hasn't been started yet then it is trivially\n-  \/\/ \"protected\". We assume the caller is the thread that will do\n-  \/\/ the starting.\n-  if (p->osthread() == NULL || p->osthread()->get_state() <= INITIALIZED) {\n-    return true;\n-  }\n+    \/\/ If the target hasn't been started yet then it is trivially\n+    \/\/ \"protected\". We assume the caller is the thread that will do\n+    \/\/ the starting.\n+    if (p->osthread() == NULL || p->osthread()->get_state() <= INITIALIZED) {\n+      return true;\n+    }\n@@ -455,7 +462,8 @@\n-  \/\/ Now make the simple checks based on who the caller is:\n-  Thread* current_thread = Thread::current();\n-  if (current_thread == p || Threads_lock->owner() == current_thread) {\n-    \/\/ Target JavaThread is self or calling thread owns the Threads_lock.\n-    \/\/ Second check is the same as Threads_lock->owner_is_self(),\n-    \/\/ but we already have the current thread so check directly.\n-    return true;\n+    \/\/ Now make the simple checks based on who the caller is:\n+    current_thread = Thread::current();\n+    if (current_thread == p || Threads_lock->owner() == current_thread) {\n+      \/\/ Target JavaThread is self or calling thread owns the Threads_lock.\n+      \/\/ Second check is the same as Threads_lock->owner_is_self(),\n+      \/\/ but we already have the current thread so check directly.\n+      return true;\n+    }\n@@ -474,10 +482,5 @@\n-  \/\/ Use this debug code with -XX:+UseNewCode to diagnose locations that\n-  \/\/ are missing a ThreadsListHandle or other protection mechanism:\n-  \/\/ guarantee(!UseNewCode, \"current_thread=\" INTPTR_FORMAT \" is not protecting p=\"\n-  \/\/           INTPTR_FORMAT, p2i(current_thread), p2i(p));\n-\n-  \/\/ Note: Since 'p' isn't protected by a TLH, the call to\n-  \/\/ p->is_handshake_safe_for() may crash, but we have debug bits so\n-  \/\/ we'll be able to figure out what protection mechanism is missing.\n-  assert(p->is_handshake_safe_for(current_thread), \"JavaThread=\" INTPTR_FORMAT\n-         \" is not protected and not handshake safe.\", p2i(p));\n+  if (!checkTLHOnly) {\n+    \/\/ Use this debug code with -XX:+UseNewCode to diagnose locations that\n+    \/\/ are missing a ThreadsListHandle or other protection mechanism:\n+    \/\/ guarantee(!UseNewCode, \"current_thread=\" INTPTR_FORMAT \" is not protecting p=\"\n+    \/\/           INTPTR_FORMAT, p2i(current_thread), p2i(p));\n@@ -485,21 +488,5 @@\n-  \/\/ The target JavaThread is not protected so it is not safe to query:\n-  return false;\n-}\n-\n-\/\/ Is the target JavaThread protected by a ThreadsList associated\n-\/\/ with the calling Thread.\n-\/\/\n-\/\/ Thread::is_JavaThread_protected() above is the more general check.\n-\/\/ This function ONLY checks the ThreadsLists (if any) associated with\n-\/\/ the calling thread in order to verify proper ThreadsListHandle\n-\/\/ placement somewhere in the calling context.\n-bool Thread::is_JavaThread_protected_by_my_ThreadsList(const JavaThread* p) {\n-  Thread* current_thread = Thread::current();\n-  \/\/ Check the ThreadsLists associated with the calling thread (if any)\n-  \/\/ to see if one of them protects the target JavaThread:\n-  for (SafeThreadsListPtr* stlp = current_thread->_threads_list_ptr;\n-       stlp != NULL; stlp = stlp->previous()) {\n-    if (stlp->list()->includes(p)) {\n-      \/\/ The target JavaThread is protected by this ThreadsList:\n-      return true;\n-    }\n+    \/\/ Note: Since 'p' isn't protected by a TLH, the call to\n+    \/\/ p->is_handshake_safe_for() may crash, but we have debug bits so\n+    \/\/ we'll be able to figure out what protection mechanism is missing.\n+    assert(p->is_handshake_safe_for(current_thread), \"JavaThread=\" INTPTR_FORMAT\n+           \" is not protected and not handshake safe.\", p2i(p));\n@@ -508,1 +495,1 @@\n-  \/\/ The target JavaThread is not protected.\n+  \/\/ The target JavaThread is not protected so it is not safe to query:\n@@ -1769,1 +1756,1 @@\n-  guarantee(Thread::is_JavaThread_protected_by_my_ThreadsList(this),\n+  guarantee(Thread::is_JavaThread_protected(this, \/* checkTLHOnly *\/ true),\n@@ -1771,4 +1758,0 @@\n-  if (is_exiting()) {\n-    log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" is exiting, no suspension\", p2i(this));\n-    return false;\n-  }\n@@ -1779,1 +1762,1 @@\n-  guarantee(Thread::is_JavaThread_protected_by_my_ThreadsList(this),\n+  guarantee(Thread::is_JavaThread_protected(this, \/* checkTLHOnly *\/ true),\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":43,"deletions":60,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -202,4 +202,3 @@\n-  \/\/ Is the target JavaThread protected by the calling Thread\n-  \/\/ or by some other mechanism:\n-  static bool is_JavaThread_protected(const JavaThread* p);\n-  \/\/ Is the target JavaThread protected by a ThreadsList associated\n+  \/\/ Is the target JavaThread protected by the calling Thread or by some other\n+  \/\/ mechanism? If checkTLHOnly is true (default is false), then we only check\n+  \/\/ if the target JavaThread is protected by a ThreadsList (if any) associated\n@@ -207,1 +206,1 @@\n-  static bool is_JavaThread_protected_by_my_ThreadsList(const JavaThread* p);\n+  static bool is_JavaThread_protected(const JavaThread* p, bool checkTLHOnly = false);\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"}]}