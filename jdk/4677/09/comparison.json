{"files":[{"patch":"@@ -1563,1 +1563,1 @@\n-    Handshake::execute(&op, java_thread);\n+    Handshake::execute(&op, &tlh, java_thread);\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -619,2 +619,8 @@\n-  for (JvmtiThreadState *state = JvmtiThreadState::first(); state != NULL; state = state->next()) {\n-    any_env_thread_enabled |= recompute_thread_enabled(state);\n+  JvmtiThreadState *state = JvmtiThreadState::first();\n+  if (state != nullptr) {\n+    \/\/ If we have a JvmtiThreadState, then we've reached the point where\n+    \/\/ threads can exist so create a ThreadsListHandle to protect them.\n+    ThreadsListHandle tlh;\n+    for (; state != nullptr; state = state->next()) {\n+      any_env_thread_enabled |= recompute_thread_enabled(state);\n+    }\n","filename":"src\/hotspot\/share\/prims\/jvmtiEventController.cpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2073,4 +2073,7 @@\n-  oop thread_oop = JNIHandles::resolve(thread_handle);\n-  if (thread_oop != NULL) {\n-    JavaThread* target = java_lang_Thread::thread(thread_oop);\n-    Handshake::execute(&rmc, target);\n+  if (thread_handle != NULL) {\n+    ThreadsListHandle tlh;\n+    JavaThread* target = nullptr;\n+    bool is_alive = tlh.cv_internal_thread_to_JavaThread(thread_handle, &target, NULL);\n+    if (is_alive) {\n+      Handshake::execute(&rmc, &tlh, target);\n+    }\n@@ -2104,5 +2107,6 @@\n-  } else {\n-    oop thread_oop = JNIHandles::resolve(thread_handle);\n-    if (thread_oop != NULL) {\n-      JavaThread* target = java_lang_Thread::thread(thread_oop);\n-      Handshake::execute(&tsc, target);\n+  } else if (thread_handle != NULL) {\n+    ThreadsListHandle tlh;\n+    JavaThread* target = nullptr;\n+    bool is_alive = tlh.cv_internal_thread_to_JavaThread(thread_handle, &target, NULL);\n+    if (is_alive) {\n+      Handshake::execute(&tsc, &tlh, target);\n@@ -2132,5 +2136,8 @@\n-  oop thread_oop = JNIHandles::resolve(thread_handle);\n-  if (thread_oop != NULL) {\n-    JavaThread* target = java_lang_Thread::thread(thread_oop);\n-    TraceSelfClosure* tsc = new TraceSelfClosure(target);\n-    Handshake::execute(tsc, target);\n+  if (thread_handle != NULL) {\n+    ThreadsListHandle tlh;\n+    JavaThread* target = nullptr;\n+    bool is_alive = tlh.cv_internal_thread_to_JavaThread(thread_handle, &target, NULL);\n+    if (is_alive) {\n+      TraceSelfClosure* tsc = new TraceSelfClosure(target);\n+      Handshake::execute(tsc, target);\n+    }\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":21,"deletions":14,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -345,0 +345,6 @@\n+  \/\/ tlh_p == nullptr means we rely on a ThreadsListHandle somewhere\n+  \/\/ in the caller's context (and we sanity check for that).\n+  Handshake::execute(hs_cl, nullptr, target);\n+}\n+\n+void Handshake::execute(HandshakeClosure* hs_cl, ThreadsListHandle* tlh_p, JavaThread* target) {\n@@ -350,2 +356,6 @@\n-  ThreadsListHandle tlh;\n-  if (tlh.includes(target)) {\n+  guarantee(target != nullptr, \"must be\");\n+  if (tlh_p == nullptr) {\n+    guarantee(Thread::is_JavaThread_protected(target, \/* checkTLHOnly *\/ true),\n+              \"missing ThreadsListHandle in calling context.\");\n+    target->handshake_state()->add_operation(&op);\n+  } else if (tlh_p->includes(target)) {\n@@ -399,6 +409,8 @@\n-  ThreadsListHandle tlh;\n-  if (tlh.includes(target)) {\n-    target->handshake_state()->add_operation(op);\n-  } else {\n-    log_handshake_info(start_time_ns, op->name(), 0, 0, \"(thread dead)\");\n-    delete op;\n+  guarantee(target != nullptr, \"must be\");\n+\n+  Thread* current = Thread::current();\n+  if (current != target) {\n+    \/\/ Another thread is handling the request and it must be protecting\n+    \/\/ the target.\n+    guarantee(Thread::is_JavaThread_protected(target, \/* checkTLHOnly *\/ true),\n+              \"missing ThreadsListHandle in calling context.\");\n@@ -406,0 +418,4 @@\n+  \/\/ Implied else:\n+  \/\/ The target is handling the request itself so it can't be dead.\n+\n+  target->handshake_state()->add_operation(op);\n","filename":"src\/hotspot\/share\/runtime\/handshake.cpp","additions":24,"deletions":8,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+class ThreadsListHandle;\n@@ -67,0 +68,2 @@\n+  \/\/ This version of execute() relies on a ThreadListHandle somewhere in\n+  \/\/ the caller's context to protect target (and we sanity check for that).\n@@ -68,0 +71,7 @@\n+  \/\/ This version of execute() is used when you have a ThreadListHandle in\n+  \/\/ hand and are using it to protect target. If tlh_p == nullptr, then we\n+  \/\/ sanity check for a ThreadListHandle somewhere in the caller's context\n+  \/\/ to verify that target is protected.\n+  static void execute(HandshakeClosure*       hs_cl, ThreadsListHandle* tlh_p, JavaThread* target);\n+  \/\/ This version of execute() relies on a ThreadListHandle somewhere in\n+  \/\/ the caller's context to protect target (and we sanity check for that).\n","filename":"src\/hotspot\/share\/runtime\/handshake.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -438,9 +438,16 @@\n-\/\/ Is the target JavaThread protected by the calling Thread\n-\/\/ or by some other mechanism:\n-bool Thread::is_JavaThread_protected(const JavaThread* p) {\n-  \/\/ Do the simplest check first:\n-  if (SafepointSynchronize::is_at_safepoint()) {\n-    \/\/ The target is protected since JavaThreads cannot exit\n-    \/\/ while we're at a safepoint.\n-    return true;\n-  }\n+\/\/ Is the target JavaThread protected by the calling Thread or by some other\n+\/\/ mechanism? If checkTLHOnly is true (default is false), then we only check\n+\/\/ if the target JavaThread is protected by a ThreadsList (if any) associated\n+\/\/ with the calling Thread.\n+\/\/\n+bool Thread::is_JavaThread_protected(const JavaThread* p, bool checkTLHOnly) {\n+  Thread* current_thread = nullptr;\n+  if (checkTLHOnly) {\n+    current_thread = Thread::current();\n+  } else {\n+    \/\/ Do the simplest check first:\n+    if (SafepointSynchronize::is_at_safepoint()) {\n+      \/\/ The target is protected since JavaThreads cannot exit\n+      \/\/ while we're at a safepoint.\n+      return true;\n+    }\n@@ -448,6 +455,6 @@\n-  \/\/ If the target hasn't been started yet then it is trivially\n-  \/\/ \"protected\". We assume the caller is the thread that will do\n-  \/\/ the starting.\n-  if (p->osthread() == NULL || p->osthread()->get_state() <= INITIALIZED) {\n-    return true;\n-  }\n+    \/\/ If the target hasn't been started yet then it is trivially\n+    \/\/ \"protected\". We assume the caller is the thread that will do\n+    \/\/ the starting.\n+    if (p->osthread() == NULL || p->osthread()->get_state() <= INITIALIZED) {\n+      return true;\n+    }\n@@ -455,7 +462,8 @@\n-  \/\/ Now make the simple checks based on who the caller is:\n-  Thread* current_thread = Thread::current();\n-  if (current_thread == p || Threads_lock->owner() == current_thread) {\n-    \/\/ Target JavaThread is self or calling thread owns the Threads_lock.\n-    \/\/ Second check is the same as Threads_lock->owner_is_self(),\n-    \/\/ but we already have the current thread so check directly.\n-    return true;\n+    \/\/ Now make the simple checks based on who the caller is:\n+    current_thread = Thread::current();\n+    if (current_thread == p || Threads_lock->owner() == current_thread) {\n+      \/\/ Target JavaThread is self or calling thread owns the Threads_lock.\n+      \/\/ Second check is the same as Threads_lock->owner_is_self(),\n+      \/\/ but we already have the current thread so check directly.\n+      return true;\n+    }\n@@ -474,4 +482,5 @@\n-  \/\/ Use this debug code with -XX:+UseNewCode to diagnose locations that\n-  \/\/ are missing a ThreadsListHandle or other protection mechanism:\n-  \/\/ guarantee(!UseNewCode, \"current_thread=\" INTPTR_FORMAT \" is not protecting p=\"\n-  \/\/           INTPTR_FORMAT, p2i(current_thread), p2i(p));\n+  if (!checkTLHOnly) {\n+    \/\/ Use this debug code with -XX:+UseNewCode to diagnose locations that\n+    \/\/ are missing a ThreadsListHandle or other protection mechanism:\n+    \/\/ guarantee(!UseNewCode, \"current_thread=\" INTPTR_FORMAT \" is not protecting p=\"\n+    \/\/           INTPTR_FORMAT, p2i(current_thread), p2i(p));\n@@ -479,5 +488,6 @@\n-  \/\/ Note: Since 'p' isn't protected by a TLH, the call to\n-  \/\/ p->is_handshake_safe_for() may crash, but we have debug bits so\n-  \/\/ we'll be able to figure out what protection mechanism is missing.\n-  assert(p->is_handshake_safe_for(current_thread), \"JavaThread=\" INTPTR_FORMAT\n-         \" is not protected and not handshake safe.\", p2i(p));\n+    \/\/ Note: Since 'p' isn't protected by a TLH, the call to\n+    \/\/ p->is_handshake_safe_for() may crash, but we have debug bits so\n+    \/\/ we'll be able to figure out what protection mechanism is missing.\n+    assert(p->is_handshake_safe_for(current_thread), \"JavaThread=\" INTPTR_FORMAT\n+           \" is not protected and not handshake safe.\", p2i(p));\n+  }\n@@ -1746,5 +1756,2 @@\n-  ThreadsListHandle tlh;\n-  if (!tlh.includes(this)) {\n-    log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" not on ThreadsList, no suspension\", p2i(this));\n-    return false;\n-  }\n+  guarantee(Thread::is_JavaThread_protected(this, \/* checkTLHOnly *\/ true),\n+            \"missing ThreadsListHandle in calling context.\");\n@@ -1755,3 +1762,4 @@\n-  ThreadsListHandle tlh;\n-  if (!tlh.includes(this)) {\n-    log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" not on ThreadsList, nothing to resume\", p2i(this));\n+  guarantee(Thread::is_JavaThread_protected(this, \/* checkTLHOnly *\/ true),\n+            \"missing ThreadsListHandle in calling context.\");\n+  if (is_exiting()) {\n+    log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" is exiting, nothing to resume\", p2i(this));\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":47,"deletions":39,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -202,3 +202,5 @@\n-  \/\/ Is the target JavaThread protected by the calling Thread\n-  \/\/ or by some other mechanism:\n-  static bool is_JavaThread_protected(const JavaThread* p);\n+  \/\/ Is the target JavaThread protected by the calling Thread or by some other\n+  \/\/ mechanism? If checkTLHOnly is true (default is false), then we only check\n+  \/\/ if the target JavaThread is protected by a ThreadsList (if any) associated\n+  \/\/ with the calling Thread.\n+  static bool is_JavaThread_protected(const JavaThread* p, bool checkTLHOnly = false);\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"}]}