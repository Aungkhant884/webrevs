{"files":[{"patch":"@@ -266,1 +266,1 @@\n-Node *AddINode::Ideal(PhaseGVN *phase, bool can_reshape) {\n+Node* AddNode::IdealIL(PhaseGVN* phase, bool can_reshape, BasicType bt) {\n@@ -272,1 +272,1 @@\n-  if ( op1 == Op_AddI && op2 == Op_SubI ) {\n+  if (op1 == Op_Add(bt) && op2 == Op_Sub(bt)) {\n@@ -279,5 +279,6 @@\n-  if( op1 == Op_SubI ) {\n-    const Type *t_sub1 = phase->type( in1->in(1) );\n-    const Type *t_2    = phase->type( in2        );\n-    if( t_sub1->singleton() && t_2->singleton() && t_sub1 != Type::TOP && t_2 != Type::TOP )\n-      return new SubINode(phase->makecon( add_ring( t_sub1, t_2 ) ), in1->in(2) );\n+  if (op1 == Op_Sub(bt)) {\n+    const Type* t_sub1 = phase->type(in1->in(1));\n+    const Type* t_2    = phase->type(in2       );\n+    if (t_sub1->singleton() && t_2->singleton() && t_sub1 != Type::TOP && t_2 != Type::TOP) {\n+      return SubNode::make(phase->makecon(add_ring(t_sub1, t_2)), in1->in(2), bt);\n+    }\n@@ -285,1 +286,1 @@\n-    if( op2 == Op_SubI ) {\n+    if (op2 == Op_Sub(bt)) {\n@@ -289,3 +290,3 @@\n-      Node *sub  = new SubINode(NULL, NULL);\n-      sub->init_req(1, phase->transform(new AddINode(in1->in(1), in2->in(1) ) ));\n-      sub->init_req(2, phase->transform(new AddINode(in1->in(2), in2->in(2) ) ));\n+      Node* sub = SubNode::make(NULL, NULL, bt);\n+      sub->init_req(1, phase->transform(AddNode::make(in1->in(1), in2->in(1), bt)));\n+      sub->init_req(2, phase->transform(AddNode::make(in1->in(2), in2->in(2), bt)));\n@@ -295,3 +296,3 @@\n-    if( op2 == Op_AddI && in1->in(2) == in2->in(1) ) {\n-      assert(in1->in(1) != this && in2->in(2) != this,\"dead loop in AddINode::Ideal\");\n-      return new AddINode(in1->in(1), in2->in(2));\n+    if (op2 == Op_Add(bt) && in1->in(2) == in2->in(1)) {\n+      assert(in1->in(1) != this && in2->in(2) != this,\"dead loop in AddINode::Ideal\/AddLNode::Ideal\");\n+      return AddNode::make(in1->in(1), in2->in(2), bt);\n@@ -300,3 +301,3 @@\n-    if( op2 == Op_AddI && in1->in(2) == in2->in(2) ) {\n-      assert(in1->in(1) != this && in2->in(1) != this,\"dead loop in AddINode::Ideal\");\n-      return new AddINode(in1->in(1), in2->in(1));\n+    if (op2 == Op_Add(bt) && in1->in(2) == in2->in(2)) {\n+      assert(in1->in(1) != this && in2->in(1) != this,\"dead loop in AddINode::Ideal\/AddLNode::Ideal\");\n+      return AddNode::make(in1->in(1), in2->in(1), bt);\n@@ -305,3 +306,3 @@\n-    if( op2 == Op_SubI && in1->in(2) == in2->in(1) ) {\n-      assert(in1->in(1) != this && in2->in(2) != this,\"dead loop in AddINode::Ideal\");\n-      return new SubINode(in1->in(1), in2->in(2));\n+    if (op2 == Op_Sub(bt) && in1->in(2) == in2->in(1)) {\n+      assert(in1->in(1) != this && in2->in(2) != this,\"dead loop in AddINode::Ideal\/AddLNode::Ideal\");\n+      return SubNode::make(in1->in(1), in2->in(2), bt);\n@@ -310,3 +311,3 @@\n-    if( op2 == Op_SubI && in1->in(1) == in2->in(2) ) {\n-      assert(in1->in(2) != this && in2->in(1) != this,\"dead loop in AddINode::Ideal\");\n-      return new SubINode(in2->in(1), in1->in(2));\n+    if (op2 == Op_Sub(bt) && in1->in(1) == in2->in(2)) {\n+      assert(in1->in(2) != this && in2->in(1) != this,\"dead loop in AddINode::Ideal\/AddLNode::Ideal\");\n+      return SubNode::make(in2->in(1), in1->in(2), bt);\n@@ -317,2 +318,3 @@\n-  if( op2 == Op_SubI && phase->type(in2->in(1)) == TypeInt::ZERO )\n-    return new SubINode(in1, in2->in(2) );\n+  if (op2 == Op_Sub(bt) && phase->type(in2->in(1)) == TypeInteger::zero(bt)) {\n+    return SubNode::make(in1, in2->in(2), bt);\n+  }\n@@ -321,2 +323,3 @@\n-  if( op1 == Op_SubI && phase->type(in1->in(1)) == TypeInt::ZERO )\n-    return new SubINode( in2, in1->in(2) );\n+  if (op1 == Op_Sub(bt) && phase->type(in1->in(1)) == TypeInteger::zero(bt)) {\n+    return SubNode::make(in2, in1->in(2), bt);\n+  }\n@@ -325,1 +328,1 @@\n-  if (op1 == Op_MulI && op2 == Op_MulI) {\n+  if (op1 == Op_Mul(bt) && op2 == Op_Mul(bt)) {\n@@ -353,27 +356,2 @@\n-      Node* add = phase->transform(new AddINode(add_in1, add_in2));\n-      return new MulINode(mul_in, add);\n-    }\n-  }\n-\n-  \/\/ Convert (x>>>z)+y into (x+(y<<z))>>>z for small constant z and y.\n-  \/\/ Helps with array allocation math constant folding\n-  \/\/ See 4790063:\n-  \/\/ Unrestricted transformation is unsafe for some runtime values of 'x'\n-  \/\/ ( x ==  0, z == 1, y == -1 ) fails\n-  \/\/ ( x == -5, z == 1, y ==  1 ) fails\n-  \/\/ Transform works for small z and small negative y when the addition\n-  \/\/ (x + (y << z)) does not cross zero.\n-  \/\/ Implement support for negative y and (x >= -(y << z))\n-  \/\/ Have not observed cases where type information exists to support\n-  \/\/ positive y and (x <= -(y << z))\n-  if( op1 == Op_URShiftI && op2 == Op_ConI &&\n-      in1->in(2)->Opcode() == Op_ConI ) {\n-    jint z = phase->type( in1->in(2) )->is_int()->get_con() & 0x1f; \/\/ only least significant 5 bits matter\n-    jint y = phase->type( in2 )->is_int()->get_con();\n-\n-    if( z < 5 && -5 < y && y < 0 ) {\n-      const Type *t_in11 = phase->type(in1->in(1));\n-      if( t_in11 != Type::TOP && (t_in11->is_int()->_lo >= -(y << z)) ) {\n-        Node *a = phase->transform( new AddINode( in1->in(1), phase->intcon(y<<z) ) );\n-        return new URShiftINode( a, in1->in(2) );\n-      }\n+      Node* add = phase->transform(AddNode::make(add_in1, add_in2, bt));\n+      return MulNode::make(mul_in, add, bt);\n@@ -385,1 +363,1 @@\n-      ((op1 == Op_URShiftI && op2 == Op_LShiftI) || (op1 == Op_LShiftI && op2 == Op_URShiftI)) &&\n+      ((op1 == Op_URShift(bt) && op2 == Op_LShift(bt)) || (op1 == Op_LShift(bt) && op2 == Op_URShift(bt))) &&\n@@ -387,2 +365,2 @@\n-    Node* rshift = op1 == Op_URShiftI ? in1->in(2) : in2->in(2);\n-    Node* lshift = op1 == Op_URShiftI ? in2->in(2) : in1->in(2);\n+    Node* rshift = op1 == Op_URShift(bt) ? in1->in(2) : in2->in(2);\n+    Node* lshift = op1 == Op_URShift(bt) ? in2->in(2) : in1->in(2);\n@@ -392,0 +370,2 @@\n+      int bits = bt == T_INT ? 32 : 64;\n+      int mask = bt == T_INT ? 0x1F : 0x3F;\n@@ -394,2 +374,2 @@\n-          ((lshift_t->get_con() & 0x1F) == (32 - (rshift_t->get_con() & 0x1F)))) {\n-        return new RotateRightNode(in1->in(1), phase->intcon(rshift_t->get_con() & 0x1F), TypeInt::INT);\n+          ((lshift_t->get_con() & mask) == (bits - (rshift_t->get_con() & mask)))) {\n+        return new RotateRightNode(in1->in(1), phase->intcon(rshift_t->get_con() & mask), TypeInteger::bottom(bt));\n@@ -403,3 +383,3 @@\n-  if (op1 == Op_XorI && phase->type(in2) == TypeInt::ONE &&\n-      phase->type(in1->in(2)) == TypeInt::MINUS_1) {\n-    return new SubINode(phase->makecon(TypeInt::ZERO), in1->in(1));\n+  if (op1 == Op_Xor(bt) && phase->type(in2) == TypeInteger::one(bt) &&\n+      phase->type(in1->in(2)) == TypeInteger::minus_1(bt)) {\n+    return SubNode::make(phase->makecon(TypeInteger::zero(bt)), in1->in(1), bt);\n@@ -411,0 +391,35 @@\n+Node* AddINode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  Node* in1 = in(1);\n+  Node* in2 = in(2);\n+  int op1 = in1->Opcode();\n+  int op2 = in2->Opcode();\n+\n+  \/\/ Convert (x>>>z)+y into (x+(y<<z))>>>z for small constant z and y.\n+  \/\/ Helps with array allocation math constant folding\n+  \/\/ See 4790063:\n+  \/\/ Unrestricted transformation is unsafe for some runtime values of 'x'\n+  \/\/ ( x ==  0, z == 1, y == -1 ) fails\n+  \/\/ ( x == -5, z == 1, y ==  1 ) fails\n+  \/\/ Transform works for small z and small negative y when the addition\n+  \/\/ (x + (y << z)) does not cross zero.\n+  \/\/ Implement support for negative y and (x >= -(y << z))\n+  \/\/ Have not observed cases where type information exists to support\n+  \/\/ positive y and (x <= -(y << z))\n+  if (op1 == Op_URShiftI && op2 == Op_ConI &&\n+      in1->in(2)->Opcode() == Op_ConI) {\n+    jint z = phase->type(in1->in(2))->is_int()->get_con() & 0x1f; \/\/ only least significant 5 bits matter\n+    jint y = phase->type(in2)->is_int()->get_con();\n+\n+    if (z < 5 && -5 < y && y < 0) {\n+      const Type* t_in11 = phase->type(in1->in(1));\n+      if( t_in11 != Type::TOP && (t_in11->is_int()->_lo >= -(y << z))) {\n+        Node* a = phase->transform(new AddINode( in1->in(1), phase->intcon(y<<z)));\n+        return new URShiftINode(a, in1->in(2));\n+      }\n+    }\n+  }\n+\n+  return AddNode::IdealIL(phase, can_reshape, T_INT);\n+}\n+\n+\n@@ -454,118 +469,2 @@\n-Node *AddLNode::Ideal(PhaseGVN *phase, bool can_reshape) {\n-  Node* in1 = in(1);\n-  Node* in2 = in(2);\n-  int op1 = in1->Opcode();\n-  int op2 = in2->Opcode();\n-  \/\/ Fold (con1-x)+con2 into (con1+con2)-x\n-  if ( op1 == Op_AddL && op2 == Op_SubL ) {\n-    \/\/ Swap edges to try optimizations below\n-    in1 = in2;\n-    in2 = in(1);\n-    op1 = op2;\n-    op2 = in2->Opcode();\n-  }\n-  \/\/ Fold (con1-x)+con2 into (con1+con2)-x\n-  if( op1 == Op_SubL ) {\n-    const Type *t_sub1 = phase->type( in1->in(1) );\n-    const Type *t_2    = phase->type( in2        );\n-    if( t_sub1->singleton() && t_2->singleton() && t_sub1 != Type::TOP && t_2 != Type::TOP )\n-      return new SubLNode(phase->makecon( add_ring( t_sub1, t_2 ) ), in1->in(2) );\n-    \/\/ Convert \"(a-b)+(c-d)\" into \"(a+c)-(b+d)\"\n-    if( op2 == Op_SubL ) {\n-      \/\/ Check for dead cycle: d = (a-b)+(c-d)\n-      assert( in1->in(2) != this && in2->in(2) != this,\n-              \"dead loop in AddLNode::Ideal\" );\n-      Node *sub  = new SubLNode(NULL, NULL);\n-      sub->init_req(1, phase->transform(new AddLNode(in1->in(1), in2->in(1) ) ));\n-      sub->init_req(2, phase->transform(new AddLNode(in1->in(2), in2->in(2) ) ));\n-      return sub;\n-    }\n-    \/\/ Convert \"(a-b)+(b+c)\" into \"(a+c)\"\n-    if( op2 == Op_AddL && in1->in(2) == in2->in(1) ) {\n-      assert(in1->in(1) != this && in2->in(2) != this,\"dead loop in AddLNode::Ideal\");\n-      return new AddLNode(in1->in(1), in2->in(2));\n-    }\n-    \/\/ Convert \"(a-b)+(c+b)\" into \"(a+c)\"\n-    if( op2 == Op_AddL && in1->in(2) == in2->in(2) ) {\n-      assert(in1->in(1) != this && in2->in(1) != this,\"dead loop in AddLNode::Ideal\");\n-      return new AddLNode(in1->in(1), in2->in(1));\n-    }\n-    \/\/ Convert \"(a-b)+(b-c)\" into \"(a-c)\"\n-    if( op2 == Op_SubL && in1->in(2) == in2->in(1) ) {\n-      assert(in1->in(1) != this && in2->in(2) != this,\"dead loop in AddLNode::Ideal\");\n-      return new SubLNode(in1->in(1), in2->in(2));\n-    }\n-    \/\/ Convert \"(a-b)+(c-a)\" into \"(c-b)\"\n-    if( op2 == Op_SubL && in1->in(1) == in2->in(2) ) {\n-      assert(in1->in(2) != this && in2->in(1) != this,\"dead loop in AddLNode::Ideal\");\n-      return new SubLNode(in2->in(1), in1->in(2));\n-    }\n-  }\n-\n-  \/\/ Convert \"x+(0-y)\" into \"(x-y)\"\n-  if( op2 == Op_SubL && phase->type(in2->in(1)) == TypeLong::ZERO )\n-    return new SubLNode( in1, in2->in(2) );\n-\n-  \/\/ Convert \"(0-y)+x\" into \"(x-y)\"\n-  if( op1 == Op_SubL && phase->type(in1->in(1)) == TypeLong::ZERO )\n-    return new SubLNode( in2, in1->in(2) );\n-\n-  \/\/ Associative\n-  if (op1 == Op_MulL && op2 == Op_MulL) {\n-    Node* add_in1 = NULL;\n-    Node* add_in2 = NULL;\n-    Node* mul_in = NULL;\n-\n-    if (in1->in(1) == in2->in(1)) {\n-      \/\/ Convert \"a*b+a*c into a*(b+c)\n-      add_in1 = in1->in(2);\n-      add_in2 = in2->in(2);\n-      mul_in = in1->in(1);\n-    } else if (in1->in(2) == in2->in(1)) {\n-      \/\/ Convert a*b+b*c into b*(a+c)\n-      add_in1 = in1->in(1);\n-      add_in2 = in2->in(2);\n-      mul_in = in1->in(2);\n-    } else if (in1->in(2) == in2->in(2)) {\n-      \/\/ Convert a*c+b*c into (a+b)*c\n-      add_in1 = in1->in(1);\n-      add_in2 = in2->in(1);\n-      mul_in = in1->in(2);\n-    } else if (in1->in(1) == in2->in(2)) {\n-      \/\/ Convert a*b+c*a into a*(b+c)\n-      add_in1 = in1->in(2);\n-      add_in2 = in2->in(1);\n-      mul_in = in1->in(1);\n-    }\n-\n-    if (mul_in != NULL) {\n-      Node* add = phase->transform(new AddLNode(add_in1, add_in2));\n-      return new MulLNode(mul_in, add);\n-    }\n-  }\n-\n-  \/\/ Convert (x >>> rshift) + (x << lshift) into RotateRight(x, rshift)\n-  if (Matcher::match_rule_supported(Op_RotateRight) &&\n-      ((op1 == Op_URShiftL && op2 == Op_LShiftL) || (op1 == Op_LShiftL && op2 == Op_URShiftL)) &&\n-      in1->in(1) != NULL && in1->in(1) == in2->in(1)) {\n-    Node* rshift = op1 == Op_URShiftL ? in1->in(2) : in2->in(2);\n-    Node* lshift = op1 == Op_URShiftL ? in2->in(2) : in1->in(2);\n-    if (rshift != NULL && lshift != NULL) {\n-      const TypeInt* rshift_t = phase->type(rshift)->isa_int();\n-      const TypeInt* lshift_t = phase->type(lshift)->isa_int();\n-      if (lshift_t != NULL && lshift_t->is_con() &&\n-          rshift_t != NULL && rshift_t->is_con() &&\n-          ((lshift_t->get_con() & 0x3F) == (64 - (rshift_t->get_con() & 0x3F)))) {\n-        return new RotateRightNode(in1->in(1), phase->intcon(rshift_t->get_con() & 0x3F), TypeLong::LONG);\n-      }\n-    }\n-  }\n-\n-  \/\/ Convert (~x+1) into -x. Note there isn't a bitwise not bytecode,\n-  \/\/ \"~x\" would typically represented as \"x^(-1)\", so (~x+1) will\n-  \/\/ be (x^(-1))+1\n-  if (op1 == Op_XorL && phase->type(in2) == TypeLong::ONE &&\n-      phase->type(in1->in(2)) == TypeLong::MINUS_1) {\n-    return new SubLNode(phase->makecon(TypeLong::ZERO), in1->in(1));\n-  }\n-  return AddNode::Ideal(phase, can_reshape);\n+Node* AddLNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  return AddNode::IdealIL(phase, can_reshape, T_LONG);\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":80,"deletions":181,"binary":false,"changes":261,"status":"modified"},{"patch":"@@ -54,1 +54,2 @@\n-  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n+  Node* IdealIL(PhaseGVN* phase, bool can_reshape, BasicType bt);\n@@ -77,4 +78,0 @@\n-  virtual bool operates_on(BasicType bt, bool signed_int) const {\n-    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n-    return false;\n-  }\n@@ -95,1 +92,1 @@\n-  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n@@ -97,4 +94,1 @@\n-  virtual bool operates_on(BasicType bt, bool signed_int) const {\n-    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n-    return bt == T_INT;\n-  }\n+\n@@ -115,1 +109,1 @@\n-  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n@@ -117,4 +111,1 @@\n-  virtual bool operates_on(BasicType bt, bool signed_int) const {\n-    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n-    return bt == T_LONG;\n-  }\n+\n","filename":"src\/hotspot\/share\/opto\/addnode.hpp","additions":6,"deletions":15,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -63,4 +63,0 @@\n-  virtual bool operates_on(BasicType bt, bool signed_int) const {\n-    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n-    return false;\n-  }\n@@ -107,4 +103,0 @@\n-  virtual bool operates_on(BasicType bt, bool signed_int) const {\n-    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n-    return bt == T_INT;\n-  }\n@@ -128,4 +120,1 @@\n-  virtual bool operates_on(BasicType bt, bool signed_int) const {\n-    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n-    return bt == T_LONG;\n-  }\n+\n","filename":"src\/hotspot\/share\/opto\/castnode.hpp","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2524,1 +2524,1 @@\n-          in(0)->as_BaseCountedLoop()->operates_on(bt, true) &&\n+          in(0)->as_BaseCountedLoop()->bt() == bt &&\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -744,1 +744,1 @@\n-  if (!(cmp->is_Cmp() && cmp->operates_on(bt, false))) {\n+  if (cmp->Opcode() != Op_Cmp_unsigned(bt)) {\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2524,1 +2524,1 @@\n-  if ((opc == Op_MulI || opc == Op_MulL) && exp->operates_on(bt, true)) {\n+  if (opc == Op_Mul(bt)) {\n@@ -2537,1 +2537,1 @@\n-  } else if (exp->is_LShift() && exp->operates_on(bt, true)) {\n+  } else if (opc == Op_LShift(bt)) {\n@@ -2566,1 +2566,2 @@\n-  if (exp->is_Add() && exp->operates_on(bt, true)) {\n+  int opc = exp->Opcode();\n+  if (opc == Op_Add(bt)) {\n@@ -2593,1 +2594,1 @@\n-  } else if (exp->is_Sub() && exp->operates_on(bt, true)) {\n+  } else if (opc == Op_Sub(bt)) {\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-  if (is_BaseCountedLoop() && operates_on(bt, false)) {\n+  if (is_BaseCountedLoop() && as_BaseCountedLoop()->bt() == bt) {\n@@ -1436,1 +1436,1 @@\n-  if (cmp == NULL || !(cmp->is_Cmp() && cmp->operates_on(iv_bt, true))) {\n+  if (cmp == NULL || cmp->Opcode() != Op_Cmp(iv_bt)) {\n@@ -1441,1 +1441,1 @@\n-  if (incr->is_ConstraintCast() && incr->operates_on(iv_bt, false)) {\n+  if (incr->Opcode() == Op_Cast(iv_bt)) {\n@@ -1458,1 +1458,1 @@\n-  assert(incr->is_Add() && incr->operates_on(iv_bt, false), \"wrong increment code\");\n+  assert(incr->Opcode() == Op_Add(iv_bt), \"wrong increment code\");\n@@ -1467,1 +1467,1 @@\n-  if (xphi->is_ConstraintCast() && xphi->operates_on(iv_bt, false)) {\n+  if (xphi->Opcode() == Op_Cast(iv_bt)) {\n@@ -2275,1 +2275,1 @@\n-  if (n1->is_Add() && n1->operates_on(bt, true)) {\n+  if (n1op == Op_Add(bt)) {\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -218,4 +218,0 @@\n-  virtual bool operates_on(BasicType bt, bool signed_int) const {\n-    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n-    return false;\n-  }\n@@ -345,4 +341,0 @@\n-  virtual bool operates_on(BasicType bt, bool signed_int) const {\n-    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n-    return bt == T_INT;\n-  }\n@@ -369,5 +361,0 @@\n-  virtual bool operates_on(BasicType bt, bool signed_int) const {\n-    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n-    return bt == T_LONG;\n-  }\n-\n@@ -426,1 +413,1 @@\n-    if (!ln->operates_on(bt(), true)) {\n+    if (ln->as_BaseCountedLoop()->bt() != bt()) {\n@@ -433,4 +420,0 @@\n-  virtual bool operates_on(BasicType bt, bool signed_int) const {\n-    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n-    return false;\n-  }\n@@ -456,4 +439,0 @@\n-  virtual bool operates_on(BasicType bt, bool signed_int) const {\n-    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n-    return bt == T_INT;\n-  }\n@@ -480,4 +459,1 @@\n-  virtual bool operates_on(BasicType bt, bool signed_int) const {\n-    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n-    return bt == T_LONG;\n-  }\n+\n@@ -501,1 +477,1 @@\n-  if (!result->operates_on(bt(), true)) {\n+  if (result->bt() != bt()) {\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":3,"deletions":27,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -225,0 +225,13 @@\n+MulNode* MulNode::make(Node* in1, Node* in2, BasicType bt) {\n+  switch (bt) {\n+    case T_INT:\n+      return new MulINode(in1, in2);\n+    case T_LONG:\n+      return new MulLNode(in1, in2);\n+    default:\n+      fatal(\"Not implemented for %s\", type2name(bt));\n+  }\n+  return NULL;\n+}\n+\n+\n@@ -495,0 +508,9 @@\n+const Type* AndINode::Value(PhaseGVN* phase) const {\n+  \/\/ patterns similar to (v << 2) & 3\n+  if (AndIL_shift_and_mask(phase, in(2), in(1), T_INT)) {\n+    return TypeInt::ZERO;\n+  }\n+\n+  return MulNode::Value(phase);\n+}\n+\n@@ -588,0 +610,6 @@\n+  \/\/ pattern similar to (v1 + (v2 << 2)) & 3 transformed to v1 & 3\n+  Node* progress = AndIL_add_shift_and_mask(phase, T_INT);\n+  if (progress != NULL) {\n+    return progress;\n+  }\n+\n@@ -619,0 +647,9 @@\n+const Type* AndLNode::Value(PhaseGVN* phase) const {\n+  \/\/ patterns similar to (v << 2) & 3\n+  if (AndIL_shift_and_mask(phase, in(2), in(1), T_LONG)) {\n+    return TypeLong::ZERO;\n+  }\n+\n+  return MulNode::Value(phase);\n+}\n+\n@@ -665,1 +702,1 @@\n-  uint op = in1->Opcode();\n+  int op = in1->Opcode();\n@@ -695,0 +732,6 @@\n+  \/\/ pattern similar to (v1 + (v2 << 2)) & 3 transformed to v1 & 3\n+  Node* progress = AndIL_add_shift_and_mask(phase, T_LONG);\n+  if (progress != NULL) {\n+    return progress;\n+  }\n+\n@@ -1673,0 +1716,61 @@\n+\n+\/\/ Helper method to transform:\n+\/\/ patterns similar to (v << 2) & 3 to 0\n+\/\/ and\n+\/\/ patterns similar to (v1 + (v2 << 2)) & 3 transformed to v1 & 3\n+bool MulNode::AndIL_shift_and_mask(PhaseGVN* phase, Node* mask, Node* shift, BasicType bt) {\n+  if (mask == NULL || shift == NULL) {\n+    return false;\n+  }\n+  const TypeInteger* mask_t = phase->type(mask)->isa_integer(bt);\n+  const TypeInteger* shift_t = phase->type(shift)->isa_integer(bt);\n+  if (mask_t == NULL || shift_t == NULL) {\n+    return false;\n+  }\n+  if (bt == T_LONG && shift != NULL && shift->Opcode() == Op_ConvI2L) {\n+    bt = T_INT;\n+    shift = shift->in(1);\n+    if (shift == NULL) {\n+      return false;\n+    }\n+  }\n+  if (shift->Opcode() != Op_LShift(bt)) {\n+    return false;\n+  }\n+  Node* shift2 = shift->in(2);\n+  if (shift2 == NULL) {\n+    return false;\n+  }\n+  const Type* shift2_t = phase->type(shift2);\n+  if (!shift2_t->isa_int() || !shift2_t->is_int()->is_con()) {\n+    return false;\n+  }\n+\n+  jint shift_con = shift2_t->is_int()->get_con() & ((bt == T_INT ? BitsPerJavaInteger : BitsPerJavaLong) - 1);\n+  if ((((long)1) << shift_con) > mask_t->hi_as_long() && mask_t->lo_as_long() >= 0) {\n+    return true;\n+  }\n+\n+  return false;\n+}\n+\n+\/\/ Helper method to transform:\n+\/\/ patterns similar to (v1 + (v2 << 2)) & 3 to v1 & 3\n+Node* MulNode::AndIL_add_shift_and_mask(PhaseGVN* phase, BasicType bt) {\n+  Node* in1 = in(1);\n+  Node* in2 = in(2);\n+  if (in1 != NULL && in2 != NULL && in1->Opcode() == Op_Add(bt)) {\n+    Node* add1 = in1->in(1);\n+    Node* add2 = in1->in(2);\n+    if (add1 != NULL && add2 != NULL) {\n+      if (AndIL_shift_and_mask(phase, in2, add1, bt)) {\n+        set_req_X(1, add2, phase);\n+        return this;\n+      } else if (AndIL_shift_and_mask(phase, in2, add2, bt)) {\n+        set_req_X(1, add1, phase);\n+        return this;\n+      }\n+    }\n+  }\n+  return NULL;\n+}\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":105,"deletions":1,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -78,5 +78,0 @@\n-  virtual bool operates_on(BasicType bt, bool signed_int) const {\n-    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n-    return false;\n-  }\n-\n@@ -88,0 +83,5 @@\n+\n+  static MulNode* make(Node* in1, Node* in2, BasicType bt);\n+\n+  static bool AndIL_shift_and_mask(PhaseGVN* phase, Node* mask, Node* shift, BasicType bt);\n+  Node* AndIL_add_shift_and_mask(PhaseGVN* phase, BasicType bt);\n@@ -106,4 +106,0 @@\n-  virtual bool operates_on(BasicType bt, bool signed_int) const {\n-    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n-    return bt == T_INT;\n-  }\n@@ -128,4 +124,0 @@\n-  virtual bool operates_on(BasicType bt, bool signed_int) const {\n-    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n-    return bt == T_LONG;\n-  }\n@@ -203,0 +195,1 @@\n+  virtual const Type* Value(PhaseGVN* phase) const;\n@@ -222,0 +215,1 @@\n+  virtual const Type* Value(PhaseGVN* phase) const;\n@@ -237,4 +231,0 @@\n-  virtual bool operates_on(BasicType bt, bool signed_int) const {\n-    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n-    return false;\n-  }\n@@ -254,4 +244,0 @@\n-  virtual bool operates_on(BasicType bt, bool signed_int) const {\n-    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n-    return bt == T_INT;\n-  }\n@@ -271,4 +257,0 @@\n-  virtual bool operates_on(BasicType bt, bool signed_int) const {\n-    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n-    return bt == T_LONG;\n-  }\n","filename":"src\/hotspot\/share\/opto\/mulnode.hpp","additions":7,"deletions":25,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -1268,6 +1268,0 @@\n-public:\n-  virtual bool operates_on(BasicType bt, bool signed_int) const {\n-    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n-    Unimplemented();\n-    return false;\n-  }\n@@ -1838,0 +1832,35 @@\n+#include \"opto\/opcodes.hpp\"\n+\n+#define Op_IL(op) \\\n+  inline int Op_ ## op(BasicType bt) { \\\n+  assert(bt == T_INT || bt == T_LONG, \"only for int or longs\"); \\\n+  if (bt == T_INT) { \\\n+    return Op_## op ## I; \\\n+  } \\\n+  return Op_## op ## L; \\\n+}\n+\n+Op_IL(Add)\n+Op_IL(Sub)\n+Op_IL(Mul)\n+Op_IL(URShift)\n+Op_IL(LShift)\n+Op_IL(Xor)\n+Op_IL(Cmp)\n+\n+inline int Op_Cmp_unsigned(BasicType bt) {\n+  assert(bt == T_INT || bt == T_LONG, \"only for int or longs\");\n+  if (bt == T_INT) {\n+    return Op_CmpU;\n+  }\n+  return Op_CmpUL;\n+}\n+\n+inline int Op_Cast(BasicType bt) {\n+  assert(bt == T_INT || bt == T_LONG, \"only for int or longs\");\n+  if (bt == T_INT) {\n+    return Op_CastII;\n+  }\n+  return Op_CastLL;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":35,"deletions":6,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -65,4 +65,0 @@\n-  virtual bool operates_on(BasicType bt, bool signed_int) const {\n-    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n-    return false;\n-  }\n@@ -84,4 +80,0 @@\n-  virtual bool operates_on(BasicType bt, bool signed_int) const {\n-    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n-    return bt == T_INT;\n-  }\n@@ -101,4 +93,0 @@\n-  virtual bool operates_on(BasicType bt, bool signed_int) const {\n-    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n-    return bt == T_LONG;\n-  }\n@@ -165,4 +153,0 @@\n-  virtual bool operates_on(BasicType bt, bool signed_int) const {\n-    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n-    return false;\n-  }\n@@ -179,4 +163,0 @@\n-  virtual bool operates_on(BasicType bt, bool signed_int) const {\n-    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n-    return bt == T_INT && signed_int;\n-  }\n@@ -194,4 +174,0 @@\n-  virtual bool operates_on(BasicType bt, bool signed_int) const {\n-    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n-    return bt == T_INT && !signed_int;\n-  }\n@@ -228,4 +204,0 @@\n-  virtual bool operates_on(BasicType bt, bool signed_int) const {\n-    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n-    return bt == T_LONG && signed_int;\n-  }\n@@ -241,4 +213,0 @@\n-  virtual bool operates_on(BasicType bt, bool signed_int) const {\n-    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n-    return bt == T_LONG && !signed_int;\n-  }\n","filename":"src\/hotspot\/share\/opto\/subnode.hpp","additions":0,"deletions":32,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -1416,0 +1416,24 @@\n+const TypeInteger* TypeInteger::zero(BasicType bt) {\n+  if (bt == T_INT) {\n+    return TypeInt::ZERO;\n+  }\n+  assert(bt == T_LONG, \"basic type not an int or long\");\n+  return TypeLong::ZERO;\n+}\n+\n+const TypeInteger* TypeInteger::one(BasicType bt) {\n+  if (bt == T_INT) {\n+    return TypeInt::ONE;\n+  }\n+  assert(bt == T_LONG, \"basic type not an int or long\");\n+  return TypeLong::ONE;\n+}\n+\n+const TypeInteger* TypeInteger::minus_1(BasicType bt) {\n+  if (bt == T_INT) {\n+    return TypeInt::MINUS_1;\n+  }\n+  assert(bt == T_LONG, \"basic type not an int or long\");\n+  return TypeLong::MINUS_1;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -561,0 +561,1 @@\n+  bool is_con() const { return lo_as_long() == hi_as_long(); }\n@@ -565,0 +566,3 @@\n+  static const TypeInteger* zero(BasicType type);\n+  static const TypeInteger* one(BasicType type);\n+  static const TypeInteger* minus_1(BasicType type);\n@@ -591,1 +595,1 @@\n-  int is_con() const { return _lo==_hi; }\n+  bool is_con() const { return _lo==_hi; }\n@@ -593,1 +597,1 @@\n-  jint get_con() const { assert( is_con(), \"\" );  return _lo; }\n+  jint get_con() const { assert(is_con(), \"\" );  return _lo; }\n@@ -659,1 +663,1 @@\n-  int is_con() const { return _lo==_hi; }\n+  bool is_con() const { return _lo==_hi; }\n@@ -661,1 +665,1 @@\n-  jlong get_con() const { assert( is_con(), \"\" ); return _lo; }\n+  jlong get_con() const { assert(is_con(), \"\" ); return _lo; }\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,108 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.irTests;\n+\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8277850\n+ * @summary C2: optimize mask checks in counted loops\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.TestShiftAndMask\n+ *\/\n+\n+public class TestShiftAndMask {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = { IRNode.AND_I, IRNode.LSHIFT_I })\n+    public static int shiftMaskInt(int i) {\n+        return (i << 2) & 3; \/\/ transformed to: return 0;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = { IRNode.AND_L, IRNode.LSHIFT_L })\n+    public static long shiftMaskLong(long i) {\n+        return (i << 2) & 3; \/\/ transformed to: return 0;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(counts = { IRNode.AND_I, \"1\" })\n+    @IR(failOn = { IRNode.ADD_I, IRNode.LSHIFT_I })\n+    public static int addShiftMaskInt(int i, int j) {\n+        return (j + (i << 2)) & 3; \/\/ transformed to: return j & 3;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(counts = { IRNode.AND_L, \"1\" })\n+    @IR(failOn = { IRNode.ADD_L, IRNode.LSHIFT_L })\n+    public static long addShiftMaskLong(long i, long j) {\n+        return (j + (i << 2)) & 3; \/\/ transformed to: return j & 3;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = { IRNode.AND_I, IRNode.ADD_I, IRNode.LSHIFT_I })\n+    public static int addShiftMaskInt2(int i, int j) {\n+        return ((j << 2) + (i << 2)) & 3; \/\/ transformed to: return 0;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = { IRNode.AND_L, IRNode.ADD_L, IRNode.LSHIFT_L })\n+    public static long addShiftMaskLong2(long i, long j) {\n+        return ((j << 2) + (i << 2)) & 3; \/\/ transformed to: return 0;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = { IRNode.AND_L, IRNode.LSHIFT_I })\n+    public static long shiftConvMask(int i) {\n+        return ((long)(i << 2)) & 3; \/\/ transformed to: return 0;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(counts = { IRNode.AND_L, \"1\" })\n+    @IR(failOn = { IRNode.ADD_L, IRNode.LSHIFT_I, IRNode.CONV_I2L })\n+    public static long addShiftConvMask(int i, long j) {\n+        return (j + (i << 2)) & 3; \/\/ transformed to: return j & 3;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = { IRNode.AND_L, IRNode.ADD_L, IRNode.LSHIFT_L })\n+    public static long addShiftConvMask2(int i, int j) {\n+        return (((long)(j << 2)) + ((long)(i << 2))) & 3; \/\/ transformed to: return 0;\n+    }\n+\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestShiftAndMask.java","additions":108,"deletions":0,"binary":false,"changes":108,"status":"added"},{"patch":"@@ -136,0 +136,8 @@\n+    public static final String AND_I = START + \"AndI\" + MID + END;\n+    public static final String AND_L = START + \"AndL\" + MID + END;\n+    public static final String LSHIFT_I = START + \"LShiftI\" + MID + END;\n+    public static final String LSHIFT_L = START + \"LShiftL\" + MID + END;\n+    public static final String ADD_I = START + \"AddI\" + MID + END;\n+    public static final String ADD_L = START + \"AddL\" + MID + END;\n+    public static final String CONV_I2L = START + \"ConvI2L\" + MID + END;\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"}]}