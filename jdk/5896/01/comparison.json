{"files":[{"patch":"@@ -306,0 +306,15 @@\n+\n+#ifndef PRODUCT\n+void Mutex::print_on(outputStream* st) const {\n+  st->print(\"Mutex: [\" PTR_FORMAT \"] %s - owner: \" PTR_FORMAT,\n+            p2i(this), _name, p2i(owner()));\n+#ifdef ASSERT\n+  if (_allow_vm_block) {\n+    st->print(\"%s\", \" allow_vm_block\");\n+  }\n+  st->print(\" %s\", rank_name());\n+#endif\n+  st->cr();\n+}\n+#endif \/\/ PRODUCT\n+\n@@ -334,1 +349,0 @@\n-\n@@ -346,13 +360,0 @@\n-#endif \/\/ ASSERT\n-\n-#ifndef PRODUCT\n-void Mutex::print_on(outputStream* st) const {\n-  st->print(\"Mutex: [\" PTR_FORMAT \"] %s - owner: \" PTR_FORMAT,\n-            p2i(this), _name, p2i(owner()));\n-  if (_allow_vm_block) {\n-    st->print(\"%s\", \" allow_vm_block\");\n-  }\n-  DEBUG_ONLY(st->print(\" %s\", rank_name()));\n-  st->cr();\n-}\n-#endif \/\/ PRODUCT\n@@ -360,1 +361,0 @@\n-#ifdef ASSERT\n@@ -458,0 +458,1 @@\n+#endif \/\/ ASSERT\n@@ -463,1 +464,1 @@\n-void Mutex::set_owner_implementation(Thread *new_owner) {\n+void Mutex::set_owner(Thread *new_owner) {\n@@ -485,0 +486,1 @@\n+#ifdef ASSERT\n@@ -491,0 +493,1 @@\n+#endif\n@@ -496,2 +499,2 @@\n-    _last_owner = old_owner;\n-    _skip_rank_check = false;\n+    DEBUG_ONLY(_last_owner = old_owner;)\n+    DEBUG_ONLY(_skip_rank_check = false;)\n@@ -524,0 +527,1 @@\n+#ifdef ASSERT\n@@ -528,0 +532,1 @@\n+#endif \/\/ ASSERT\n@@ -530,1 +535,0 @@\n-#endif \/\/ ASSERT\n","filename":"src\/hotspot\/share\/runtime\/mutex.cpp","additions":23,"deletions":19,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -90,0 +90,1 @@\n+  void link_locks(Thread* new_owner);\n@@ -94,0 +95,1 @@\n+  Mutex*  _next;                 \/\/ Used by a Thread to link up owned locks\n@@ -96,3 +98,0 @@\n-#ifndef PRODUCT\n-  bool    _allow_vm_block;\n-#endif\n@@ -101,1 +100,0 @@\n-  Mutex*  _next;                 \/\/ Used by a Thread to link up owned locks\n@@ -103,1 +101,2 @@\n-  bool _skip_rank_check;         \/\/ read only by owner when doing rank checks\n+  bool    _skip_rank_check;      \/\/ read only by owner when doing rank checks\n+  bool    _allow_vm_block;\n@@ -116,2 +115,0 @@\n-  Mutex* next()  const         { return _next; }\n-  void   set_next(Mutex *next) { _next = next; }\n@@ -121,1 +118,2 @@\n-  void set_owner_implementation(Thread* owner)                        NOT_DEBUG({ raw_set_owner(owner);});\n+  void set_next(Mutex *next)   { _next = next; }\n+\n@@ -187,1 +185,1 @@\n-  void set_owner(Thread* owner) { set_owner_implementation(owner); }\n+  void set_owner(Thread* owner);\n@@ -190,1 +188,2 @@\n-  const char *name() const                  { return _name; }\n+  const char *name() const      { return _name; }\n+  Mutex* next()  const          { return _next; }\n","filename":"src\/hotspot\/share\/runtime\/mutex.hpp","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -160,5 +160,0 @@\n-\n-#define MAX_NUM_MUTEX 128\n-static Mutex* _mutex_array[MAX_NUM_MUTEX];\n-static int _num_mutex;\n-\n@@ -197,5 +192,0 @@\n-static void add_mutex(Mutex* var) {\n-  assert(_num_mutex < MAX_NUM_MUTEX, \"increase MAX_NUM_MUTEX\");\n-  _mutex_array[_num_mutex++] = var;\n-}\n-\n@@ -204,1 +194,0 @@\n-  add_mutex(var);                             \\\n@@ -211,1 +200,0 @@\n-  add_mutex(var);                                      \\\n@@ -216,1 +204,0 @@\n-  add_mutex(var);                                      \\\n@@ -383,20 +370,0 @@\n-\n-\/\/ Print all mutexes\/monitors that are currently owned by a thread; called\n-\/\/ by fatal error handler.\n-void print_owned_locks_on_error(outputStream* st) {\n-  st->print(\"VM Mutex\/Monitor currently owned by a thread: \");\n-  bool none = true;\n-  for (int i = 0; i < _num_mutex; i++) {\n-     \/\/ see if it has an owner\n-     if (_mutex_array[i]->owner() != NULL) {\n-       if (none) {\n-          \/\/ print format used by Mutex::print_on_error()\n-          st->print_cr(\" ([mutex\/lock_event])\");\n-          none = false;\n-       }\n-       _mutex_array[i]->print_on_error(st);\n-       st->cr();\n-     }\n-  }\n-  if (none) st->print_cr(\"None\");\n-}\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":0,"deletions":33,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -172,6 +172,0 @@\n-\/\/ Print all mutexes\/monitors that are currently owned by a thread; called\n-\/\/ by fatal error handler.\n-void print_owned_locks_on_error(outputStream* st);\n-\n-char *lock_name(Mutex *mutex);\n-\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -239,1 +239,1 @@\n-  debug_only(_owned_locks = NULL;)\n+  _owned_locks = NULL;\n@@ -607,2 +607,0 @@\n-  st->print(\" \");\n-  debug_only(if (WizardMode) print_owned_locks_on(st);)\n@@ -642,1 +640,0 @@\n-#ifdef ASSERT\n@@ -646,1 +643,1 @@\n-    st->print(\" (no locks) \");\n+    st->print_cr(\" (no locks) \");\n@@ -648,1 +645,0 @@\n-    st->print_cr(\" Locks owned:\");\n@@ -650,1 +646,2 @@\n-      cur->print_on(st);\n+      cur->print_on_error(st);\n+      st->cr();\n@@ -655,1 +652,0 @@\n-#endif \/\/ ASSERT\n@@ -3850,0 +3846,28 @@\n+\/\/ Print all mutexes\/monitors that are currently owned by a thread; called\n+\/\/ by fatal error handler.\n+void Threads::print_owned_locks_on_error(outputStream* st) {\n+  class PrintLocksClosure : public ThreadClosure {\n+    outputStream* _st;\n+    bool* _printed;\n+   public:\n+    PrintLocksClosure(outputStream* st, bool* none) : _st(st), _printed(none) {}\n+    void do_thread(Thread* t) {\n+      if (t->owns_locks()) {\n+        t->print_owned_locks_on(_st);\n+      }\n+    }\n+  };\n+\n+  st->print_cr(\"VM Mutex\/Monitor currently owned by a thread: \");\n+  bool none = true;\n+  ALL_JAVA_THREADS(jt) {\n+    if (jt->owns_locks()) {\n+      jt->print_owned_locks_on(st);\n+      none = false;\n+    }\n+  }\n+\n+  PrintLocksClosure tc(st, &none);\n+  non_java_threads_do(&tc);\n+  if (none) st->print_cr(\"None\");\n+}\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":32,"deletions":8,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -577,2 +577,0 @@\n-  \/\/ Debug-only code\n-#ifdef ASSERT\n@@ -580,4 +578,2 @@\n-  \/\/ Deadlock detection support for Mutex locks. List of locks own by thread.\n-  Mutex* _owned_locks;\n-  \/\/ Mutex::set_owner_implementation is the only place where _owned_locks is modified,\n-  \/\/ thus the friendship\n+  \/\/ Deadlock detection support for Mutex locks, and help with crash handling.\n+  \/\/ List of locks own by thread.\n@@ -585,1 +581,1 @@\n-  friend class Monitor;\n+  Mutex* _owned_locks;\n@@ -588,0 +584,1 @@\n+  void print_owned_locks() const { print_owned_locks_on(tty); }\n@@ -589,3 +586,0 @@\n-  void print_owned_locks() const                 { print_owned_locks_on(tty);    }\n-  Mutex* owned_locks() const                     { return _owned_locks;          }\n-  bool owns_locks() const                        { return owned_locks() != NULL; }\n@@ -593,1 +587,5 @@\n-  \/\/ Deadlock detection\n+  \/\/ Debug-only code\n+  Mutex* owned_locks() const                     { return _owned_locks; }\n+  bool owns_locks() const                        { return _owned_locks != NULL; }\n+\n+#ifdef ASSERT\n@@ -1730,0 +1728,2 @@\n+  static void print_owned_locks_on_error(outputStream* st);\n+\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -998,1 +998,1 @@\n-       print_owned_locks_on_error(st);\n+       Threads::print_owned_locks_on_error(st);\n@@ -1896,0 +1896,6 @@\n+    case 3: {\n+      Mutex* ErrorTest_lock = new Mutex(Mutex::nosafepoint, \"ErrorTest_lock\");\n+      MutexLocker ml(ErrorTest_lock, Mutex::_no_safepoint_check_flag);\n+      assert(how == 0, \"test assert with lock\");\n+      break;\n+    }\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+\/*\n+ * @test\n+ * @bug 8274794\n+ * @summary Test that locks are printed in the Error file.\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ * @requires (vm.debug == true)\n+ * @run driver ErrorFileLocksTest\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import java.io.*;\n+import java.util.regex.Pattern;\n+\n+public class ErrorFileLocksTest {\n+\n+  public static void do_test() throws Exception {\n+\n+    ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n+            \"-Xmx64M\",\n+            \"-XX:-CreateCoredumpOnCrash\",\n+            \"-XX:ErrorHandlerTest=3\",\n+            \"-version\");\n+\n+    OutputAnalyzer output_detail = new OutputAnalyzer(pb.start());\n+    output_detail.shouldMatch(\"# A fatal error has been detected by the Java Runtime Environment:.*\");\n+\n+    File f = ErrorFileScanner.findHsErrorFileInOutput(output_detail);\n+    System.out.println(\"Found hs error file at \" + f.getAbsolutePath());\n+\n+    ErrorFileScanner.scanHsErrorFileForContent(f, new Pattern[] {\n+            Pattern.compile(\"# *Internal Error.*\"),\n+            Pattern.compile(\".*VM Mutex\/Monitor currently owned by a thread:.*\"),\n+            Pattern.compile(\".*ErrorTest_lock - owner thread:.*\"),\n+            Pattern.compile(\".*Threads_lock - owner thread:.*\")\n+    });\n+  }\n+\n+  public static void main(String[] args) throws Exception {\n+    do_test();\n+  }\n+\n+}\n+\n+\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/ErrorFileLocksTest.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,40 +45,0 @@\n-  private static File findHsErrorFileInOutput(OutputAnalyzer output) {\n-\n-    String hs_err_file = output.firstMatch(\"# *(\\\\S*hs_err_pid.*\\\\.log)\", 1);\n-    if(hs_err_file ==null) {\n-      throw new RuntimeException(\"Did not find hs-err file in output.\\n\");\n-    }\n-\n-    File f = new File(hs_err_file);\n-    if (!f.exists()) {\n-      throw new RuntimeException(\"hs-err file missing at \"\n-              + f.getAbsolutePath() + \".\\n\");\n-    }\n-\n-    return f;\n-\n-  }\n-\n-  private static void scanHsErrorFileForContent(File f, Pattern[] pattern) throws IOException {\n-    FileInputStream fis = new FileInputStream(f);\n-    BufferedReader br = new BufferedReader(new InputStreamReader(fis));\n-    String line = null;\n-\n-    int currentPattern = 0;\n-\n-    String lastLine = null;\n-    while ((line = br.readLine()) != null && currentPattern < pattern.length) {\n-      if (pattern[currentPattern].matcher(line).matches()) {\n-        System.out.println(\"Found: \" + line + \".\");\n-        currentPattern++;\n-      }\n-      lastLine = line;\n-    }\n-    br.close();\n-\n-    if (currentPattern < pattern.length) {\n-      throw new RuntimeException(\"hs-err file incomplete (first missing pattern: \" +  pattern[currentPattern] + \")\");\n-    }\n-\n-  }\n-\n@@ -113,1 +73,1 @@\n-    File f = findHsErrorFileInOutput(output_detail);\n+    File f = ErrorFileScanner.findHsErrorFileInOutput(output_detail);\n@@ -116,1 +76,1 @@\n-    scanHsErrorFileForContent(f, new Pattern[] {\n+    ErrorFileScanner.scanHsErrorFileForContent(f, new Pattern[] {\n@@ -139,1 +99,1 @@\n-    File f2 = findHsErrorFileInOutput(output_detail);\n+    File f2 = ErrorFileScanner.findHsErrorFileInOutput(output_detail);\n@@ -148,1 +108,1 @@\n-    scanHsErrorFileForContent(f2, new Pattern[] {\n+    ErrorFileScanner.scanHsErrorFileForContent(f2, new Pattern[] {\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/ErrorFileOverwriteTest.java","additions":5,"deletions":45,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.InputStreamReader;\n+import java.io.IOException;\n+\n+import java.util.regex.Pattern;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class ErrorFileScanner {\n+\n+  public static File findHsErrorFileInOutput(OutputAnalyzer output) {\n+\n+    String hs_err_file = output.firstMatch(\"# *(\\\\S*hs_err_pid.*\\\\.log)\", 1);\n+    if(hs_err_file ==null) {\n+      throw new RuntimeException(\"Did not find hs-err file in output.\\n\");\n+    }\n+\n+    File f = new File(hs_err_file);\n+    if (!f.exists()) {\n+      throw new RuntimeException(\"hs-err file missing at \"\n+              + f.getAbsolutePath() + \".\\n\");\n+    }\n+\n+    return f;\n+\n+  }\n+\n+  public static void scanHsErrorFileForContent(File f, Pattern[] pattern) throws IOException {\n+    FileInputStream fis = new FileInputStream(f);\n+    BufferedReader br = new BufferedReader(new InputStreamReader(fis));\n+    String line = null;\n+\n+    int currentPattern = 0;\n+\n+    String lastLine = null;\n+    while ((line = br.readLine()) != null && currentPattern < pattern.length) {\n+      if (pattern[currentPattern].matcher(line).matches()) {\n+        System.out.println(\"Found: \" + line + \".\");\n+        currentPattern++;\n+      }\n+      lastLine = line;\n+    }\n+    br.close();\n+\n+    if (currentPattern < pattern.length) {\n+      throw new RuntimeException(\"hs-err file incomplete (first missing pattern: \" +  pattern[currentPattern] + \")\");\n+    }\n+\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/ErrorFileScanner.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"}]}