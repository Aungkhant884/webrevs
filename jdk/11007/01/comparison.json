{"files":[{"patch":"@@ -0,0 +1,288 @@\n+\/*\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.jndi.dns;\n+\n+import java.io.IOException;\n+import java.net.DatagramSocket;\n+import java.net.ProtocolFamily;\n+import java.net.InetSocketAddress;\n+import java.nio.channels.DatagramChannel;\n+import java.security.AccessController;\n+import java.security.PrivilegedExceptionAction;\n+import java.util.Objects;\n+import java.util.Random;\n+\n+class DNSDatagramChannelFactory {\n+    static final int DEVIATION = 3;\n+    static final int THRESHOLD = 6;\n+    static final int BIT_DEVIATION = 2;\n+    static final int HISTORY = 32;\n+    static final int MAX_RANDOM_TRIES = 5;\n+    \/**\n+     * The dynamic allocation port range (aka ephemeral ports), as configured\n+     * on the system. Use nested class for lazy evaluation.\n+     *\/\n+    static final class EphemeralPortRange {\n+        private EphemeralPortRange() {}\n+        static final int LOWER = sun.net.PortConfig.getLower();\n+        static final int UPPER = sun.net.PortConfig.getUpper();\n+        static final int RANGE = UPPER - LOWER + 1;\n+    }\n+\n+    private static int findFirstFreePort() {\n+        PrivilegedExceptionAction<DatagramSocket> action = () -> new DatagramSocket(0);\n+        int port;\n+        try {\n+            @SuppressWarnings({\"deprecated\", \"removal\"})\n+            DatagramSocket ds = AccessController.doPrivileged(action);\n+            try (DatagramSocket ds1 = ds) {\n+                port = ds1.getLocalPort();\n+            }\n+        } catch (Exception x) {\n+            port = 0;\n+        }\n+        return port;\n+    }\n+\n+    \/\/ Records a subset of max {@code capacity} previously used ports\n+    static final class PortHistory {\n+        final int capacity;\n+        final int[] ports;\n+        final Random random;\n+        int index;\n+        PortHistory(int capacity, Random random) {\n+            this.random = random;\n+            this.capacity = capacity;\n+            this.ports = new int[capacity];\n+        }\n+        \/\/ returns true if the history contains the specified port.\n+        public boolean contains(int port) {\n+            int p = 0;\n+            for (int i=0; i<capacity; i++) {\n+                if ((p = ports[i]) == 0 || p == port) break;\n+            }\n+            return p == port;\n+        }\n+        \/\/ Adds the port to the history - doesn't check whether the port\n+        \/\/ is already present. Always adds the port and always return true.\n+        public boolean add(int port) {\n+            if (ports[index] != 0) { \/\/ at max capacity\n+                \/\/ remove one port at random and store the new port there\n+                \/\/ don't remove the last port\n+                int remove = random.nextInt(capacity);\n+                if ((remove +1) % capacity == index) remove = index;\n+                ports[index = remove] = port;\n+            } else { \/\/ there's a free slot\n+                ports[index] = port;\n+            }\n+            if (++index == capacity) index = 0;\n+            return true;\n+        }\n+        \/\/ Adds the port to the history if not already present.\n+        \/\/ Return true if the port was added, false if the port was already\n+        \/\/ present.\n+        public boolean offer(int port) {\n+            if (contains(port)) return false;\n+            else return add(port);\n+        }\n+    }\n+\n+    int lastport = findFirstFreePort();\n+    int lastSystemAllocated = lastport;\n+    int suitablePortCount;\n+    int unsuitablePortCount;\n+    final ProtocolFamily family; \/\/ null (default) means dual stack\n+    final int thresholdCount; \/\/ decision point\n+    final int deviation;\n+    final Random random;\n+    final PortHistory history;\n+\n+    DNSDatagramChannelFactory() {\n+        this(new Random());\n+    }\n+\n+    DNSDatagramChannelFactory(Random random) {\n+        this(Objects.requireNonNull(random), null, DEVIATION, THRESHOLD);\n+    }\n+    DNSDatagramChannelFactory(Random random,\n+                              ProtocolFamily family,\n+                              int deviation,\n+                              int threshold) {\n+        this.random = Objects.requireNonNull(random);\n+        this.history = new PortHistory(HISTORY, random);\n+        this.family = family;\n+        this.deviation = Math.max(1, deviation);\n+        this.thresholdCount = Math.max(2, threshold);\n+    }\n+\n+    \/**\n+     * Opens a datagram socket listening to the wildcard address on a\n+     * random port. If the underlying OS supports UDP port randomization\n+     * out of the box (if binding a socket to port 0 binds it to a random\n+     * port) then the underlying OS implementation is used. Otherwise, this\n+     * method will allocate and bind a socket on a randomly selected ephemeral\n+     * port in the dynamic range.\n+     *\n+     * @return A new DatagramChannel bound to a random port.\n+     * @throws IOException if the socket cannot be created.\n+     *\/\n+    public synchronized DatagramChannel open() throws IOException {\n+        int lastseen = lastport;\n+        DatagramChannel s;\n+\n+        boolean thresholdCrossed = unsuitablePortCount > thresholdCount;\n+        if (thresholdCrossed) {\n+            \/\/ Underlying stack does not support random UDP port out of the box.\n+            \/\/ Use our own algorithm to allocate a random UDP port\n+            s = openRandom();\n+            if (s != null) return s;\n+\n+            \/\/ couldn't allocate a random port: reset all counters and fall\n+            \/\/ through.\n+            unsuitablePortCount = 0; suitablePortCount = 0; lastseen = 0;\n+        }\n+\n+        \/\/ Allocate an ephemeral port (port 0)\n+        s = openDefault();\n+        lastport = getLocalPort(s);\n+        if (lastseen == 0) {\n+            lastSystemAllocated = lastport;\n+            history.offer(lastport);\n+            return s;\n+        }\n+\n+        thresholdCrossed = suitablePortCount > thresholdCount;\n+        boolean farEnough = farEnough(lastseen);\n+        if (farEnough && lastSystemAllocated > 0) {\n+            farEnough = farEnough(lastSystemAllocated);\n+        }\n+        boolean recycled = history.contains(lastport);\n+        boolean suitable = (thresholdCrossed || farEnough && !recycled);\n+        if (suitable && !recycled) history.add(lastport);\n+\n+        if (suitable) {\n+            if (!thresholdCrossed) {\n+                suitablePortCount++;\n+            } else if (!farEnough || recycled) {\n+                unsuitablePortCount = 1;\n+                suitablePortCount = thresholdCount\/2;\n+            }\n+            \/\/ Either the underlying stack supports random UDP port allocation,\n+            \/\/ or the new port is sufficiently distant from last port to make\n+            \/\/ it look like it is. Let's use it.\n+            lastSystemAllocated = lastport;\n+            return s;\n+        }\n+\n+        \/\/ Undecided... the new port was too close. Let's allocate a random\n+        \/\/ port using our own algorithm\n+        assert !thresholdCrossed;\n+        DatagramChannel ss = openRandom();\n+        if (ss == null) return s;\n+        unsuitablePortCount++;\n+        s.close();\n+        return ss;\n+    }\n+\n+    private DatagramChannel openDefault() throws IOException {\n+        DatagramChannel c = family != null ? DatagramChannel.open(family)\n+                                           : DatagramChannel.open();\n+        try {\n+            c.bind(null);\n+            return c;\n+        } catch (Throwable x) {\n+            c.close();\n+            throw x;\n+        }\n+    }\n+\n+    synchronized boolean isUsingNativePortRandomization() {\n+        return unsuitablePortCount <= thresholdCount\n+                && suitablePortCount > thresholdCount;\n+    }\n+\n+    synchronized boolean isUsingJavaPortRandomization() {\n+        return unsuitablePortCount > thresholdCount ;\n+    }\n+\n+    synchronized boolean isUndecided() {\n+        return !isUsingJavaPortRandomization()\n+                && !isUsingNativePortRandomization();\n+    }\n+\n+    private boolean farEnough(int port) {\n+        return Integer.bitCount(port ^ lastport) > BIT_DEVIATION\n+                && Math.abs(port - lastport) > deviation;\n+    }\n+\n+    private DatagramChannel openRandom() {\n+        int maxtries = MAX_RANDOM_TRIES;\n+        while (maxtries-- > 0) {\n+            int port;\n+            boolean suitable;\n+            boolean recycled;\n+            int maxrandom = MAX_RANDOM_TRIES;\n+            do {\n+                port = EphemeralPortRange.LOWER\n+                        + random.nextInt(EphemeralPortRange.RANGE);\n+                recycled = history.contains(port);\n+                suitable = lastport == 0 || (farEnough(port) && !recycled);\n+            } while (maxrandom-- > 0 && !suitable);\n+\n+            \/\/ if no suitable port was found, try again\n+            \/\/ this means we might call random MAX_RANDOM_TRIES x MAX_RANDOM_TRIES\n+            \/\/ times - but that should be OK with MAX_RANDOM_TRIES = 5.\n+            if (!suitable) continue;\n+\n+            try {\n+                if (family != null) {\n+                    DatagramChannel c = DatagramChannel.open(family);\n+                    try {\n+                        c.bind(new InetSocketAddress(port));\n+                        lastport = getLocalPort(c);\n+                        if (!recycled) history.add(port);\n+                        return c;\n+                    } catch (Throwable x) {\n+                        c.close();\n+                        throw x;\n+                    }\n+                }\n+                var dc = DatagramChannel.open();\n+                dc.bind(new InetSocketAddress(port));\n+                lastport = getLocalPort(dc);\n+                if (!recycled) history.add(port);\n+                return dc;\n+            } catch (IOException x) {\n+                \/\/ try again until maxtries == 0;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private static int getLocalPort(DatagramChannel dc) throws IOException {\n+        return ((InetSocketAddress) dc.getLocalAddress()).getPort();\n+    }\n+\n+}\n","filename":"src\/jdk.naming.dns\/share\/classes\/com\/sun\/jndi\/dns\/DNSDatagramChannelFactory.java","additions":288,"deletions":0,"binary":false,"changes":288,"status":"added"},{"patch":"@@ -1,293 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package com.sun.jndi.dns;\n-\n-import java.io.IOException;\n-import java.net.DatagramSocket;\n-import java.net.ProtocolFamily;\n-import java.net.SocketException;\n-import java.net.InetSocketAddress;\n-import java.nio.channels.DatagramChannel;\n-import java.security.AccessController;\n-import java.security.PrivilegedExceptionAction;\n-import java.util.Objects;\n-import java.util.Random;\n-\n-class DNSDatagramSocketFactory {\n-    static final int DEVIATION = 3;\n-    static final int THRESHOLD = 6;\n-    static final int BIT_DEVIATION = 2;\n-    static final int HISTORY = 32;\n-    static final int MAX_RANDOM_TRIES = 5;\n-    \/**\n-     * The dynamic allocation port range (aka ephemeral ports), as configured\n-     * on the system. Use nested class for lazy evaluation.\n-     *\/\n-    static final class EphemeralPortRange {\n-        private EphemeralPortRange() {}\n-        static final int LOWER = sun.net.PortConfig.getLower();\n-        static final int UPPER = sun.net.PortConfig.getUpper();\n-        static final int RANGE = UPPER - LOWER + 1;\n-    }\n-\n-    private static int findFirstFreePort() {\n-        PrivilegedExceptionAction<DatagramSocket> action = () -> new DatagramSocket(0);\n-        int port;\n-        try {\n-            @SuppressWarnings({\"deprecated\", \"removal\"})\n-            DatagramSocket ds = AccessController.doPrivileged(action);\n-            try (DatagramSocket ds1 = ds) {\n-                port = ds1.getLocalPort();\n-            }\n-        } catch (Exception x) {\n-            port = 0;\n-        }\n-        return port;\n-    }\n-\n-    \/\/ Records a subset of max {@code capacity} previously used ports\n-    static final class PortHistory {\n-        final int capacity;\n-        final int[] ports;\n-        final Random random;\n-        int index;\n-        PortHistory(int capacity, Random random) {\n-            this.random = random;\n-            this.capacity = capacity;\n-            this.ports = new int[capacity];\n-        }\n-        \/\/ returns true if the history contains the specified port.\n-        public boolean contains(int port) {\n-            int p = 0;\n-            for (int i=0; i<capacity; i++) {\n-                if ((p = ports[i]) == 0 || p == port) break;\n-            }\n-            return p == port;\n-        }\n-        \/\/ Adds the port to the history - doesn't check whether the port\n-        \/\/ is already present. Always adds the port and always return true.\n-        public boolean add(int port) {\n-            if (ports[index] != 0) { \/\/ at max capacity\n-                \/\/ remove one port at random and store the new port there\n-                \/\/ don't remove the last port\n-                int remove = random.nextInt(capacity);\n-                if ((remove +1) % capacity == index) remove = index;\n-                ports[index = remove] = port;\n-            } else { \/\/ there's a free slot\n-                ports[index] = port;\n-            }\n-            if (++index == capacity) index = 0;\n-            return true;\n-        }\n-        \/\/ Adds the port to the history if not already present.\n-        \/\/ Return true if the port was added, false if the port was already\n-        \/\/ present.\n-        public boolean offer(int port) {\n-            if (contains(port)) return false;\n-            else return add(port);\n-        }\n-    }\n-\n-    int lastport = findFirstFreePort();\n-    int lastSystemAllocated = lastport;\n-    int suitablePortCount;\n-    int unsuitablePortCount;\n-    final ProtocolFamily family; \/\/ null (default) means dual stack\n-    final int thresholdCount; \/\/ decision point\n-    final int deviation;\n-    final Random random;\n-    final PortHistory history;\n-\n-    DNSDatagramSocketFactory() {\n-        this(new Random());\n-    }\n-\n-    DNSDatagramSocketFactory(Random random) {\n-        this(Objects.requireNonNull(random), null, DEVIATION, THRESHOLD);\n-    }\n-    DNSDatagramSocketFactory(Random random,\n-                             ProtocolFamily family,\n-                             int deviation,\n-                             int threshold) {\n-        this.random = Objects.requireNonNull(random);\n-        this.history = new PortHistory(HISTORY, random);\n-        this.family = family;\n-        this.deviation = Math.max(1, deviation);\n-        this.thresholdCount = Math.max(2, threshold);\n-    }\n-\n-    \/**\n-     * Opens a datagram socket listening to the wildcard address on a\n-     * random port. If the underlying OS supports UDP port randomization\n-     * out of the box (if binding a socket to port 0 binds it to a random\n-     * port) then the underlying OS implementation is used. Otherwise, this\n-     * method will allocate and bind a socket on a randomly selected ephemeral\n-     * port in the dynamic range.\n-     * @return A new DatagramSocket bound to a random port.\n-     * @throws SocketException if the socket cannot be created.\n-     *\/\n-    public synchronized DatagramSocket open() throws SocketException {\n-        int lastseen = lastport;\n-        DatagramSocket s;\n-\n-        boolean thresholdCrossed = unsuitablePortCount > thresholdCount;\n-        if (thresholdCrossed) {\n-            \/\/ Underlying stack does not support random UDP port out of the box.\n-            \/\/ Use our own algorithm to allocate a random UDP port\n-            s = openRandom();\n-            if (s != null) return s;\n-\n-            \/\/ couldn't allocate a random port: reset all counters and fall\n-            \/\/ through.\n-            unsuitablePortCount = 0; suitablePortCount = 0; lastseen = 0;\n-        }\n-\n-        \/\/ Allocate an ephemeral port (port 0)\n-        s = openDefault();\n-        lastport = s.getLocalPort();\n-        if (lastseen == 0) {\n-            lastSystemAllocated = lastport;\n-            history.offer(lastport);\n-            return s;\n-        }\n-\n-        thresholdCrossed = suitablePortCount > thresholdCount;\n-        boolean farEnough = farEnough(lastseen);\n-        if (farEnough && lastSystemAllocated > 0) {\n-            farEnough = farEnough(lastSystemAllocated);\n-        }\n-        boolean recycled = history.contains(lastport);\n-        boolean suitable = (thresholdCrossed || farEnough && !recycled);\n-        if (suitable && !recycled) history.add(lastport);\n-\n-        if (suitable) {\n-            if (!thresholdCrossed) {\n-                suitablePortCount++;\n-            } else if (!farEnough || recycled) {\n-                unsuitablePortCount = 1;\n-                suitablePortCount = thresholdCount\/2;\n-            }\n-            \/\/ Either the underlying stack supports random UDP port allocation,\n-            \/\/ or the new port is sufficiently distant from last port to make\n-            \/\/ it look like it is. Let's use it.\n-            lastSystemAllocated = lastport;\n-            return s;\n-        }\n-\n-        \/\/ Undecided... the new port was too close. Let's allocate a random\n-        \/\/ port using our own algorithm\n-        assert !thresholdCrossed;\n-        DatagramSocket ss = openRandom();\n-        if (ss == null) return s;\n-        unsuitablePortCount++;\n-        s.close();\n-        return ss;\n-    }\n-\n-    private DatagramSocket openDefault() throws SocketException {\n-        if (family != null) {\n-            try {\n-                DatagramChannel c = DatagramChannel.open(family);\n-                try {\n-                    DatagramSocket s = c.socket();\n-                    s.bind(null);\n-                    return s;\n-                } catch (Throwable x) {\n-                    c.close();\n-                    throw x;\n-                }\n-            } catch (SocketException x) {\n-                throw x;\n-            } catch (IOException x) {\n-                throw new SocketException(x.getMessage(), x);\n-            }\n-        }\n-        return new DatagramSocket();\n-    }\n-\n-    synchronized boolean isUsingNativePortRandomization() {\n-        return  unsuitablePortCount <= thresholdCount\n-                && suitablePortCount > thresholdCount;\n-    }\n-\n-    synchronized boolean isUsingJavaPortRandomization() {\n-        return unsuitablePortCount > thresholdCount ;\n-    }\n-\n-    synchronized boolean isUndecided() {\n-        return !isUsingJavaPortRandomization()\n-                && !isUsingNativePortRandomization();\n-    }\n-\n-    private boolean farEnough(int port) {\n-        return Integer.bitCount(port ^ lastport) > BIT_DEVIATION\n-                && Math.abs(port - lastport) > deviation;\n-    }\n-\n-    private DatagramSocket openRandom() {\n-        int maxtries = MAX_RANDOM_TRIES;\n-        while (maxtries-- > 0) {\n-            int port;\n-            boolean suitable;\n-            boolean recycled;\n-            int maxrandom = MAX_RANDOM_TRIES;\n-            do {\n-                port = EphemeralPortRange.LOWER\n-                        + random.nextInt(EphemeralPortRange.RANGE);\n-                recycled = history.contains(port);\n-                suitable = lastport == 0 || (farEnough(port) && !recycled);\n-            } while (maxrandom-- > 0 && !suitable);\n-\n-            \/\/ if no suitable port was found, try again\n-            \/\/ this means we might call random MAX_RANDOM_TRIES x MAX_RANDOM_TRIES\n-            \/\/ times - but that should be OK with MAX_RANDOM_TRIES = 5.\n-            if (!suitable) continue;\n-\n-            try {\n-                if (family != null) {\n-                    DatagramChannel c = DatagramChannel.open(family);\n-                    try {\n-                        DatagramSocket s = c.socket();\n-                        s.bind(new InetSocketAddress(port));\n-                        lastport = s.getLocalPort();\n-                        if (!recycled) history.add(port);\n-                        return s;\n-                    } catch (Throwable x) {\n-                        c.close();\n-                        throw x;\n-                    }\n-                }\n-                DatagramSocket s = new DatagramSocket(port);\n-                lastport = s.getLocalPort();\n-                if (!recycled) history.add(port);\n-                return s;\n-            } catch (IOException x) {\n-                \/\/ try again until maxtries == 0;\n-            }\n-        }\n-        return null;\n-    }\n-\n-}\n","filename":"src\/jdk.naming.dns\/share\/classes\/com\/sun\/jndi\/dns\/DNSDatagramSocketFactory.java","additions":0,"deletions":293,"binary":false,"changes":293,"status":"deleted"},{"patch":"@@ -30,2 +30,0 @@\n-import java.net.DatagramSocket;\n-import java.net.DatagramPacket;\n@@ -37,0 +35,5 @@\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ClosedSelectorException;\n+import java.nio.channels.DatagramChannel;\n+import java.nio.channels.SelectionKey;\n+import java.nio.channels.Selector;\n@@ -38,2 +41,8 @@\n-import javax.naming.*;\n-\n+import javax.naming.CommunicationException;\n+import javax.naming.ConfigurationException;\n+import javax.naming.NameNotFoundException;\n+import javax.naming.NamingException;\n+import javax.naming.OperationNotSupportedException;\n+import javax.naming.ServiceUnavailableException;\n+\n+import java.util.Arrays;\n@@ -43,0 +52,1 @@\n+import java.util.concurrent.locks.ReentrantLock;\n@@ -86,0 +96,1 @@\n+    private static final int MIN_TIMEOUT = 50; \/\/ msec after which there are no retries.\n@@ -92,3 +103,6 @@\n-    private final Object udpSocketLock = new Object();\n-    private static final DNSDatagramSocketFactory factory =\n-            new DNSDatagramSocketFactory(random);\n+    private final ReentrantLock udpChannelLock = new ReentrantLock();\n+\n+    private final Selector udpChannelSelector;\n+\n+    private static final DNSDatagramChannelFactory factory =\n+            new DNSDatagramChannelFactory(random);\n@@ -138,0 +152,9 @@\n+\n+        try {\n+            udpChannelSelector = Selector.open();\n+        } catch (IOException e) {\n+            NamingException ne = new ConfigurationException(\n+                    \"Channel selector configuration error\");\n+            ne.setRootCause(e);\n+            throw ne;\n+        }\n@@ -143,1 +166,1 @@\n-    DatagramSocket getDatagramSocket() throws NamingException {\n+    DatagramChannel getDatagramChannel() throws NamingException {\n@@ -146,1 +169,1 @@\n-        } catch (java.net.SocketException e) {\n+        } catch (IOException e) {\n@@ -162,0 +185,4 @@\n+        try {\n+            udpChannelSelector.close();\n+        } catch (IOException ioException) {\n+        }\n@@ -215,17 +242,3 @@\n-                        byte[] msg = null;\n-                        msg = doUdpQuery(pkt, servers[i], serverPorts[i],\n-                                            retry, xid);\n-                        \/\/\n-                        \/\/ If the matching response is not got within the\n-                        \/\/ given timeout, check if the response was enqueued\n-                        \/\/ by some other thread, if not proceed with the next\n-                        \/\/ server or retry.\n-                        \/\/\n-                        if (msg == null) {\n-                            if (resps.size() > 0) {\n-                                msg = lookupResponse(xid);\n-                            }\n-                            if (msg == null) { \/\/ try next server or retry\n-                                continue;\n-                            }\n-                        }\n+                        byte[] msg = doUdpQuery(pkt, servers[i], serverPorts[i],\n+                                                retry, xid);\n+                        assert msg != null;\n@@ -297,0 +310,7 @@\n+                    } catch (ClosedSelectorException e) {\n+                        \/\/ ClosedSelectorException is thrown by blockingReceive if\n+                        \/\/ the datagram channel selector associated with DNS client\n+                        \/\/ is unexpectedly closed\n+                        var ce = new CommunicationException(\"DNS client closed\");\n+                        ce.setRootCause(e);\n+                        throw ce;\n@@ -405,7 +425,6 @@\n-        int minTimeout = 50; \/\/ msec after which there are no retries.\n-\n-        synchronized (udpSocketLock) {\n-            try (DatagramSocket udpSocket = getDatagramSocket()) {\n-                DatagramPacket opkt = new DatagramPacket(\n-                        pkt.getData(), pkt.length(), server, port);\n-                DatagramPacket ipkt = new DatagramPacket(new byte[8000], 8000);\n+        udpChannelLock.lock();\n+        try {\n+            try (DatagramChannel udpChannel = getDatagramChannel()) {\n+                ByteBuffer opkt = ByteBuffer.wrap(pkt.getData(), 0, pkt.length());\n+                byte[] data = new byte[8000];\n+                ByteBuffer ipkt = ByteBuffer.wrap(data);\n@@ -413,1 +432,2 @@\n-                udpSocket.connect(server, port);\n+                InetSocketAddress target = new InetSocketAddress(server, port);\n+                udpChannel.connect(target);\n@@ -415,1 +435,1 @@\n-                udpSocket.send(opkt);\n+                udpChannel.write(opkt);\n@@ -417,1 +437,1 @@\n-                \/\/ timeout remaining after successive 'receive()'\n+                \/\/ timeout remaining after successive 'blockingReceive()'\n@@ -420,0 +440,1 @@\n+                boolean gotData = false;\n@@ -421,0 +442,5 @@\n+                    \/\/ prepare for retry\n+                    if (gotData) {\n+                        Arrays.fill(data, 0, ipkt.position(), (byte) 0);\n+                        ipkt.clear();\n+                    }\n@@ -428,1 +454,0 @@\n-                    udpSocket.setSoTimeout(timeoutLeft);\n@@ -430,1 +455,1 @@\n-                    udpSocket.receive(ipkt);\n+                    gotData = blockingReceive(udpChannel, ipkt, timeoutLeft);\n@@ -432,3 +457,2 @@\n-\n-                    byte[] data = ipkt.getData();\n-                    if (isMatchResponse(data, xid)) {\n+                    assert gotData || ipkt.position() == 0;\n+                    if (gotData && isMatchResponse(data, xid)) {\n@@ -436,0 +460,8 @@\n+                    } else if (resps.size() > 0) {\n+                        \/\/ If the matching response is not found, check if\n+                        \/\/ the response was enqueued by some other thread,\n+                        \/\/ if not continue\n+                        byte[] cachedMsg = lookupResponse(xid);\n+                        if (cachedMsg != null) { \/\/ found in cache\n+                            return cachedMsg;\n+                        }\n@@ -438,2 +470,21 @@\n-                } while (timeoutLeft > minTimeout);\n-                return null; \/\/ no matching packet received within the timeout\n+                } while (timeoutLeft > MIN_TIMEOUT);\n+                \/\/ no matching packets received within the timeout\n+                throw new SocketTimeoutException();\n+            }\n+        } finally {\n+            udpChannelLock.unlock();\n+        }\n+    }\n+\n+    boolean blockingReceive(DatagramChannel dc, ByteBuffer buffer, long timeout) throws IOException {\n+        boolean dataReceived = false;\n+        \/\/ The provided datagram channel will be used by the caller only to receive data after\n+        \/\/ it is put to non-blocking mode\n+        dc.configureBlocking(false);\n+        var selectionKey = dc.register(udpChannelSelector, SelectionKey.OP_READ);\n+        try {\n+            udpChannelSelector.select(timeout);\n+            var keys = udpChannelSelector.selectedKeys();\n+            if (keys.contains(selectionKey) && selectionKey.isReadable()) {\n+                dc.receive(buffer);\n+                dataReceived = true;\n@@ -441,0 +492,5 @@\n+            keys.clear();\n+        } finally {\n+            selectionKey.cancel();\n+            \/\/ Flush the canceled key out of the selected key set\n+            udpChannelSelector.selectNow();\n@@ -442,0 +498,1 @@\n+        return dataReceived;\n@@ -632,1 +689,1 @@\n-                resps.put(hdr.xid, pkt);\n+                resps.put(hdr.xid, pkt.clone());\n","filename":"src\/jdk.naming.dns\/share\/classes\/com\/sun\/jndi\/dns\/DnsClient.java","additions":101,"deletions":44,"binary":false,"changes":145,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,3 @@\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n@@ -31,0 +34,2 @@\n+import jdk.test.lib.net.URIBuilder;\n+\n@@ -36,1 +41,1 @@\n- * @library ..\/lib\/\n+ * @library ..\/lib\/ \/test\/lib\n@@ -42,7 +47,0 @@\n-    \/\/ Host 10.0.0.0 is a bit bucket, used here to simulate a DNS server that\n-    \/\/ doesn't respond. 10.0.0.0 server shouldn't be reachable.\n-    \/\/ Ping to this address should not give any reply\n-    private static final String HOST = \"10.0.0.0\";\n-    \/\/ Port 9 is a bit bucket, used here to simulate a DNS server that\n-    \/\/ doesn't respond.\n-    private static final int PORT = 9;\n@@ -70,5 +68,14 @@\n-        String allQuietUrl = \"dns:\/\/\" + HOST + \":\" + PORT;\n-        env().put(Context.PROVIDER_URL, allQuietUrl);\n-        env().put(\"com.sun.jndi.dns.timeout.initial\", String.valueOf(TIMEOUT));\n-        env().put(\"com.sun.jndi.dns.timeout.retries\", String.valueOf(RETRIES));\n-        setContext(new InitialDirContext(env()));\n+        \/\/ Create a DatagramSocket and bind it to the loopback address to simulate\n+        \/\/ UDP DNS server that doesn't respond\n+        try (DatagramSocket ds = new DatagramSocket(\n+                new InetSocketAddress(InetAddress.getLoopbackAddress(), 0))) {\n+            String allQuietUrl = URIBuilder.newBuilder()\n+                    .scheme(\"dns\")\n+                    .loopback()\n+                    .port(ds.getLocalPort())\n+                    .build()\n+                    .toString();\n+            env().put(Context.PROVIDER_URL, allQuietUrl);\n+            env().put(\"com.sun.jndi.dns.timeout.initial\", String.valueOf(TIMEOUT));\n+            env().put(\"com.sun.jndi.dns.timeout.retries\", String.valueOf(RETRIES));\n+            setContext(new InitialDirContext(env()));\n@@ -76,3 +83,3 @@\n-        \/\/ Any request should fail after timeouts have expired.\n-        startTime = Instant.now();\n-        context().getAttributes(\"\");\n+            \/\/ Any request should fail after timeouts have expired.\n+            startTime = Instant.now();\n+            context().getAttributes(\"\");\n@@ -80,2 +87,3 @@\n-        throw new RuntimeException(\n-                \"Failed: getAttributes succeeded unexpectedly\");\n+            throw new RuntimeException(\n+                    \"Failed: getAttributes succeeded unexpectedly\");\n+        }\n","filename":"test\/jdk\/com\/sun\/jndi\/dns\/ConfigTests\/Timeout.java","additions":27,"deletions":19,"binary":false,"changes":46,"status":"modified"}]}