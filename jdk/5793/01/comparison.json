{"files":[{"patch":"@@ -52,0 +52,1 @@\n+import sun.security.util.Cache;\n@@ -73,0 +74,6 @@\n+    static Cache<Double, HandshakeContextCacheItem> handshakeContextCache;\n+\n+    static {\n+        handshakeContextCache = Cache.newHardMemoryCache(50);\n+    }\n+\n@@ -169,6 +176,31 @@\n-        this.activeProtocols = getActiveProtocols(sslConfig.enabledProtocols,\n-                sslConfig.enabledCipherSuites, algorithmConstraints);\n-        if (activeProtocols.isEmpty()) {\n-            throw new SSLHandshakeException(\n-                \"No appropriate protocol (protocol is disabled or \" +\n-                \"cipher suites are inappropriate)\");\n+        double hashCode = getHashCode(\n+                sslConfig.enabledProtocols,\n+                sslConfig.enabledCipherSuites,\n+                sslConfig.userSpecifiedAlgorithmConstraints);\n+        HandshakeContextCacheItem cacheItem;\n+        if ((cacheItem = handshakeContextCache.get(hashCode)) != null &&\n+                cacheItem.enabledProtocolVersions == sslConfig.enabledProtocols &&\n+                cacheItem.enabledCipherSuites == sslConfig.enabledCipherSuites &&\n+                cacheItem.constraints == sslConfig.userSpecifiedAlgorithmConstraints) {\n+            this.activeProtocols = cacheItem.protocolVersions;\n+            this.activeCipherSuites = cacheItem.cipherSuites;\n+        } else {\n+            this.activeProtocols = getActiveProtocols(sslConfig.enabledProtocols,\n+                    sslConfig.enabledCipherSuites, algorithmConstraints);\n+            if (activeProtocols.isEmpty()) {\n+                throw new SSLHandshakeException(\n+                        \"No appropriate protocol (protocol is disabled or \" +\n+                                \"cipher suites are inappropriate)\");\n+            }\n+            this.activeCipherSuites = getActiveCipherSuites(this.activeProtocols,\n+                    sslConfig.enabledCipherSuites, algorithmConstraints);\n+            if (activeCipherSuites.isEmpty()) {\n+                throw new SSLHandshakeException(\"No appropriate cipher suite\");\n+            }\n+            handshakeContextCache.put(hashCode,\n+                    new HandshakeContextCacheItem(\n+                            this.activeProtocols,\n+                            this.activeCipherSuites,\n+                            sslConfig.enabledProtocols,\n+                            sslConfig.enabledCipherSuites,\n+                            sslConfig.userSpecifiedAlgorithmConstraints));\n@@ -176,1 +208,0 @@\n-\n@@ -185,6 +216,0 @@\n-        this.activeCipherSuites = getActiveCipherSuites(this.activeProtocols,\n-                sslConfig.enabledCipherSuites, algorithmConstraints);\n-        if (activeCipherSuites.isEmpty()) {\n-            throw new SSLHandshakeException(\"No appropriate cipher suite\");\n-        }\n-\n@@ -593,0 +618,31 @@\n+\n+    static double getHashCode(List<ProtocolVersion> protocolVersions,\n+                           List<CipherSuite> cipherSuites,\n+                           AlgorithmConstraints constraints) {\n+        int a = protocolVersions.hashCode();\n+        int b = cipherSuites.hashCode();\n+        int c = constraints.hashCode();\n+        double cantor = 0.5 * (a + b) * (a + b + 1) + a;\n+        cantor = 0.5 * ( cantor + c) * (cantor + c + 1) + cantor;\n+        return cantor;\n+    }\n+\n+    static class HandshakeContextCacheItem {\n+        List<ProtocolVersion> protocolVersions;\n+        List<CipherSuite> cipherSuites;\n+        List<ProtocolVersion> enabledProtocolVersions;\n+        List<CipherSuite> enabledCipherSuites;\n+        AlgorithmConstraints constraints;\n+\n+        HandshakeContextCacheItem(List<ProtocolVersion> protocolVersions,\n+                                  List<CipherSuite> cipherSuites,\n+                                  List<ProtocolVersion> enabledProtocolVersions,\n+                                  List<CipherSuite> enabledCipherSuites,\n+                                  AlgorithmConstraints constraints) {\n+            this.cipherSuites = cipherSuites;\n+            this.protocolVersions = protocolVersions;\n+            this.enabledProtocolVersions = enabledProtocolVersions;\n+            this.enabledCipherSuites = enabledCipherSuites;\n+            this.constraints = constraints;\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/HandshakeContext.java","additions":69,"deletions":13,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -0,0 +1,277 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+package org.openjdk.bench.java.security;\n+\n+import org.openjdk.jmh.annotations.*;\n+\n+import javax.net.ssl.*;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.security.KeyFactory;\n+import java.security.KeyStore;\n+import java.security.PrivateKey;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateFactory;\n+import java.security.spec.PKCS8EncodedKeySpec;\n+import java.util.Base64;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode({Mode.AverageTime, Mode.Throughput})\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@Fork(jvmArgsAppend = {\"--add-exports\", \"java.base\/sun.security.util=ALL-UNNAMED\"})\n+public class SSLEngineStartHandshake {\n+\n+    @State(Scope.Benchmark)\n+    public static class SSLStartHandshakeState {\n+\n+        public static final ByteBuffer CLIENT_HELLO = ByteBuffer.allocate(32768);\n+        public static final ByteBuffer SERVER_HELLO = ByteBuffer.allocate(65536);\n+        public static final ByteBuffer EMPTY = ByteBuffer.allocate(0);\n+        public SSLContext context;\n+\n+        public enum Cert {\n+\n+            CA_ECDSA_SECP256R1(\n+                    \"EC\",\n+                    \/\/ SHA256withECDSA, curve secp256r1\n+                    \/\/ Validity\n+                    \/\/     Not Before: May 22 07:18:16 2018 GMT\n+                    \/\/     Not After : May 17 07:18:16 2038 GMT\n+                    \/\/ Subject Key Identifier:\n+                    \/\/     60:CF:BD:73:FF:FA:1A:30:D2:A4:EC:D3:49:71:46:EF:1A:35:A0:86\n+                    \"-----BEGIN CERTIFICATE-----\\n\" +\n+                            \"MIIBvjCCAWOgAwIBAgIJAIvFG6GbTroCMAoGCCqGSM49BAMCMDsxCzAJBgNVBAYT\\n\" +\n+                            \"AlVTMQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2VyaXZj\\n\" +\n+                            \"ZTAeFw0xODA1MjIwNzE4MTZaFw0zODA1MTcwNzE4MTZaMDsxCzAJBgNVBAYTAlVT\\n\" +\n+                            \"MQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2VyaXZjZTBZ\\n\" +\n+                            \"MBMGByqGSM49AgEGCCqGSM49AwEHA0IABBz1WeVb6gM2mh85z3QlvaB\/l11b5h0v\\n\" +\n+                            \"LIzmkC3DKlVukZT+ltH2Eq1oEkpXuf7QmbM0ibrUgtjsWH3mULfmcWmjUDBOMB0G\\n\" +\n+                            \"A1UdDgQWBBRgz71z\/\/oaMNKk7NNJcUbvGjWghjAfBgNVHSMEGDAWgBRgz71z\/\/oa\\n\" +\n+                            \"MNKk7NNJcUbvGjWghjAMBgNVHRMEBTADAQH\/MAoGCCqGSM49BAMCA0kAMEYCIQCG\\n\" +\n+                            \"6wluh1r2\/T6L31mZXRKf9JxeSf9pIzoLj+8xQeUChQIhAJ09wAi1kV8yePLh2FD9\\n\" +\n+                            \"2YEHlSQUAbwwqCDEVB5KxaqP\\n\" +\n+                            \"-----END CERTIFICATE-----\",\n+                    \"MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQg\/HcHdoLJCdq3haVd\\n\" +\n+                            \"XZTSKP00YzM3xX97l98vGL\/RI1KhRANCAAQc9VnlW+oDNpofOc90Jb2gf5ddW+Yd\\n\" +\n+                            \"LyyM5pAtwypVbpGU\/pbR9hKtaBJKV7n+0JmzNIm61ILY7Fh95lC35nFp\"),\n+            EE_ECDSA_SECP256R1(\n+                    \"EC\",\n+                    \/\/ SHA256withECDSA, curve secp256r1\n+                    \/\/ Validity\n+                    \/\/     Not Before: May 22 07:18:16 2018 GMT\n+                    \/\/     Not After : May 17 07:18:16 2038 GMT\n+                    \/\/ Authority Key Identifier:\n+                    \/\/     60:CF:BD:73:FF:FA:1A:30:D2:A4:EC:D3:49:71:46:EF:1A:35:A0:86\n+                    \"-----BEGIN CERTIFICATE-----\\n\" +\n+                            \"MIIBqjCCAVCgAwIBAgIJAPLY8qZjgNRAMAoGCCqGSM49BAMCMDsxCzAJBgNVBAYT\\n\" +\n+                            \"AlVTMQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2VyaXZj\\n\" +\n+                            \"ZTAeFw0xODA1MjIwNzE4MTZaFw0zODA1MTcwNzE4MTZaMFUxCzAJBgNVBAYTAlVT\\n\" +\n+                            \"MQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2VyaXZjZTEY\\n\" +\n+                            \"MBYGA1UEAwwPUmVncmVzc2lvbiBUZXN0MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcD\\n\" +\n+                            \"QgAEb+9n05qfXnfHUb0xtQJNS4JeSi6IjOfW5NqchvKnfJey9VkJzR7QHLuOESdf\\n\" +\n+                            \"xlR7q8YIWgih3iWLGfB+wxHiOqMjMCEwHwYDVR0jBBgwFoAUYM+9c\/\/6GjDSpOzT\\n\" +\n+                            \"SXFG7xo1oIYwCgYIKoZIzj0EAwIDSAAwRQIgWpRegWXMheiD3qFdd8kMdrkLxRbq\\n\" +\n+                            \"1zj8nQMEwFTUjjQCIQDRIrAjZX+YXHN9b0SoWWLPUq0HmiFIi8RwMnO\/\/wJIGQ==\\n\" +\n+                            \"-----END CERTIFICATE-----\",\n+                    \"MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgn5K03bpTLjEtFQRa\\n\" +\n+                            \"JUtx22gtmGEvvSUSQdimhGthdtihRANCAARv72fTmp9ed8dRvTG1Ak1Lgl5KLoiM\\n\" +\n+                            \"59bk2pyG8qd8l7L1WQnNHtAcu44RJ1\/GVHurxghaCKHeJYsZ8H7DEeI6\");\n+            final String keyAlgo;\n+            final String certStr;\n+            final String privKeyStr;\n+\n+            Cert(String keyAlgo, String certStr, String privKeyStr) {\n+                this.keyAlgo = keyAlgo;\n+                this.certStr = certStr;\n+                this.privKeyStr = privKeyStr;\n+            }\n+        }\n+\n+        \/*\n+         * The parameters used to configure SSLContext.\n+         *\/\n+        protected static final class ContextParameters {\n+            final String contextProtocol;\n+            final String tmAlgorithm;\n+            final String kmAlgorithm;\n+\n+            ContextParameters(String contextProtocol,\n+                              String tmAlgorithm, String kmAlgorithm) {\n+\n+                this.contextProtocol = contextProtocol;\n+                this.tmAlgorithm = tmAlgorithm;\n+                this.kmAlgorithm = kmAlgorithm;\n+            }\n+        }\n+\n+        \/*\n+         * =======================================\n+         * Certificates and keys used in the test.\n+         *\/\n+        \/\/ Trusted certificates.\n+        protected final static Cert[] TRUSTED_CERTS = {\n+                Cert.CA_ECDSA_SECP256R1 };\n+\n+        \/\/ End entity certificate.\n+        protected final static Cert[] END_ENTITY_CERTS = {\n+                Cert.EE_ECDSA_SECP256R1 };\n+\n+        \/*\n+         * Create an instance of SSLContext with the specified trust\/key materials.\n+         *\/\n+        public static SSLContext    createSSLContext(\n+                Cert[] trustedCerts,\n+                Cert[] endEntityCerts,\n+                ContextParameters params) throws Exception {\n+\n+            KeyStore ts = null;     \/\/ trust store\n+            KeyStore ks = null;     \/\/ key store\n+            char passphrase[] = \"passphrase\".toCharArray();\n+\n+            \/\/ Generate certificate from cert string.\n+            CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n+\n+            \/\/ Import the trused certs.\n+            ByteArrayInputStream is;\n+            if (trustedCerts != null && trustedCerts.length != 0) {\n+                ts = KeyStore.getInstance(\"JKS\");\n+                ts.load(null, null);\n+\n+                Certificate[] trustedCert = new Certificate[trustedCerts.length];\n+                for (int i = 0; i < trustedCerts.length; i++) {\n+                    is = new ByteArrayInputStream(trustedCerts[i].certStr.getBytes());\n+                    try {\n+                        trustedCert[i] = cf.generateCertificate(is);\n+                    } finally {\n+                        is.close();\n+                    }\n+\n+                    ts.setCertificateEntry(\n+                            \"trusted-cert-\" + trustedCerts[i].name(), trustedCert[i]);\n+                }\n+            }\n+\n+            \/\/ Import the key materials.\n+            if (endEntityCerts != null && endEntityCerts.length != 0) {\n+                ks = KeyStore.getInstance(\"JKS\");\n+                ks.load(null, null);\n+\n+                for (int i = 0; i < endEntityCerts.length; i++) {\n+                    \/\/ generate the private key.\n+                    PKCS8EncodedKeySpec priKeySpec = new PKCS8EncodedKeySpec(\n+                            Base64.getMimeDecoder().decode(endEntityCerts[i].privKeyStr));\n+                    KeyFactory kf =\n+                            KeyFactory.getInstance(\n+                                    endEntityCerts[i].keyAlgo);\n+                    PrivateKey priKey = kf.generatePrivate(priKeySpec);\n+\n+                    \/\/ generate certificate chain\n+                    is = new ByteArrayInputStream(\n+                            endEntityCerts[i].certStr.getBytes());\n+                    Certificate keyCert = null;\n+                    try {\n+                        keyCert = cf.generateCertificate(is);\n+                    } finally {\n+                        is.close();\n+                    }\n+\n+                    Certificate[] chain = new Certificate[] { keyCert };\n+\n+                    \/\/ import the key entry.\n+                    ks.setKeyEntry(\"cert-\" + endEntityCerts[i].name(),\n+                            priKey, passphrase, chain);\n+                }\n+            }\n+\n+            \/\/ Create an SSLContext object.\n+            TrustManagerFactory tmf =\n+                    TrustManagerFactory.getInstance(params.tmAlgorithm);\n+            tmf.init(ts);\n+\n+            SSLContext context = SSLContext.getInstance(params.contextProtocol);\n+            if (endEntityCerts != null && endEntityCerts.length != 0 && ks != null) {\n+                KeyManagerFactory kmf =\n+                        KeyManagerFactory.getInstance(params.kmAlgorithm);\n+                kmf.init(ks, passphrase);\n+\n+                context.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);\n+            } else {\n+                context.init(null, tmf.getTrustManagers(), null);\n+            }\n+\n+            return context;\n+        }\n+\n+        @Setup\n+        public void createClientHello() throws Exception {\n+            context = createSSLContext(TRUSTED_CERTS, END_ENTITY_CERTS,\n+                    new ContextParameters(\"TLS\", \"PKIX\", \"NewSunX509\"));\n+\n+            SSLEngine clientEngine = context.createSSLEngine(\"localhost\", 80);\n+            clientEngine.setUseClientMode(true);\n+            clientEngine.beginHandshake();\n+            SSLEngineResult result;\n+\n+            result = clientEngine.wrap(ByteBuffer.wrap(new byte[1]), CLIENT_HELLO);\n+            if (result.getHandshakeStatus() != SSLEngineResult.HandshakeStatus.NEED_UNWRAP) {\n+                throw new AssertionError(\"expected NEED_UNWRAP, got \" + result.getHandshakeStatus() + \" \" + result.getStatus());\n+            }\n+            CLIENT_HELLO.flip();\n+        }\n+\n+        public ByteBuffer runServerHandshake() throws IOException {\n+            CLIENT_HELLO.rewind();\n+            SERVER_HELLO.clear();\n+            SSLEngine serverEngine = context.createSSLEngine();\n+            serverEngine.setUseClientMode(false);\n+            serverEngine.setEnabledProtocols(new String[]{\"TLSv1.3\"});\n+            serverEngine.setEnabledCipherSuites(new String[]{\"TLS_AES_256_GCM_SHA384\"});\n+            serverEngine.beginHandshake();\n+            SSLEngineResult result = serverEngine.unwrap(CLIENT_HELLO, EMPTY);\n+            if (result.getHandshakeStatus() != SSLEngineResult.HandshakeStatus.NEED_TASK) {\n+                throw new AssertionError(\"expected NEED_TASK, got \" + result.getHandshakeStatus());\n+            }\n+            Runnable runnable;\n+            while ((runnable = serverEngine.getDelegatedTask()) != null) {\n+                runnable.run();\n+            }\n+            if (serverEngine.getHandshakeStatus() != SSLEngineResult.HandshakeStatus.NEED_WRAP) {\n+                throw new AssertionError(\"expected NEED_WRAP, got \" + serverEngine.getHandshakeStatus());\n+            }\n+            do {\n+                result = serverEngine.wrap(EMPTY, SERVER_HELLO);\n+            } while (result.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_WRAP);\n+            if (result.getHandshakeStatus() != SSLEngineResult.HandshakeStatus.NEED_UNWRAP) {\n+                throw new AssertionError(\"expected NEED_UNWRAP, got \" + result.getHandshakeStatus() + \" \" + result.getStatus());\n+            }\n+            return SERVER_HELLO;\n+        }\n+    }\n+\n+    @Benchmark\n+    public ByteBuffer handshakeBenchmark(SSLStartHandshakeState state) throws IOException {\n+        return state.runServerHandshake();\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/security\/SSLEngineStartHandshake.java","additions":277,"deletions":0,"binary":false,"changes":277,"status":"added"},{"patch":"@@ -0,0 +1,262 @@\n+package org.openjdk.bench.java.security;\n+\n+import org.openjdk.jmh.annotations.*;\n+\n+import javax.net.ServerSocketFactory;\n+import javax.net.ssl.*;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.net.ServerSocket;\n+import java.security.KeyFactory;\n+import java.security.KeyStore;\n+import java.security.PrivateKey;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateFactory;\n+import java.security.spec.PKCS8EncodedKeySpec;\n+import java.util.Base64;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode({Mode.AverageTime, Mode.Throughput})\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@Fork(jvmArgsAppend = {\"--add-exports\", \"java.base\/sun.security.util=ALL-UNNAMED\"})\n+public class SSLStartHandshake {\n+\n+\n+\n+    @State(Scope.Benchmark)\n+    public static class SSLStartHandshakeState {\n+        public int port;\n+        SSLSocketFactory socketFactory;\n+\n+        public enum Cert {\n+\n+            CA_ECDSA_SECP256R1(\n+                    \"EC\",\n+                    \/\/ SHA256withECDSA, curve secp256r1\n+                    \/\/ Validity\n+                    \/\/     Not Before: May 22 07:18:16 2018 GMT\n+                    \/\/     Not After : May 17 07:18:16 2038 GMT\n+                    \/\/ Subject Key Identifier:\n+                    \/\/     60:CF:BD:73:FF:FA:1A:30:D2:A4:EC:D3:49:71:46:EF:1A:35:A0:86\n+                    \"-----BEGIN CERTIFICATE-----\\n\" +\n+                            \"MIIBvjCCAWOgAwIBAgIJAIvFG6GbTroCMAoGCCqGSM49BAMCMDsxCzAJBgNVBAYT\\n\" +\n+                            \"AlVTMQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2VyaXZj\\n\" +\n+                            \"ZTAeFw0xODA1MjIwNzE4MTZaFw0zODA1MTcwNzE4MTZaMDsxCzAJBgNVBAYTAlVT\\n\" +\n+                            \"MQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2VyaXZjZTBZ\\n\" +\n+                            \"MBMGByqGSM49AgEGCCqGSM49AwEHA0IABBz1WeVb6gM2mh85z3QlvaB\/l11b5h0v\\n\" +\n+                            \"LIzmkC3DKlVukZT+ltH2Eq1oEkpXuf7QmbM0ibrUgtjsWH3mULfmcWmjUDBOMB0G\\n\" +\n+                            \"A1UdDgQWBBRgz71z\/\/oaMNKk7NNJcUbvGjWghjAfBgNVHSMEGDAWgBRgz71z\/\/oa\\n\" +\n+                            \"MNKk7NNJcUbvGjWghjAMBgNVHRMEBTADAQH\/MAoGCCqGSM49BAMCA0kAMEYCIQCG\\n\" +\n+                            \"6wluh1r2\/T6L31mZXRKf9JxeSf9pIzoLj+8xQeUChQIhAJ09wAi1kV8yePLh2FD9\\n\" +\n+                            \"2YEHlSQUAbwwqCDEVB5KxaqP\\n\" +\n+                            \"-----END CERTIFICATE-----\",\n+                    \"MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQg\/HcHdoLJCdq3haVd\\n\" +\n+                            \"XZTSKP00YzM3xX97l98vGL\/RI1KhRANCAAQc9VnlW+oDNpofOc90Jb2gf5ddW+Yd\\n\" +\n+                            \"LyyM5pAtwypVbpGU\/pbR9hKtaBJKV7n+0JmzNIm61ILY7Fh95lC35nFp\"),\n+            EE_ECDSA_SECP256R1(\n+                \"EC\",\n+                        \/\/ SHA256withECDSA, curve secp256r1\n+                        \/\/ Validity\n+                        \/\/     Not Before: May 22 07:18:16 2018 GMT\n+                        \/\/     Not After : May 17 07:18:16 2038 GMT\n+                        \/\/ Authority Key Identifier:\n+                        \/\/     60:CF:BD:73:FF:FA:1A:30:D2:A4:EC:D3:49:71:46:EF:1A:35:A0:86\n+                        \"-----BEGIN CERTIFICATE-----\\n\" +\n+                        \"MIIBqjCCAVCgAwIBAgIJAPLY8qZjgNRAMAoGCCqGSM49BAMCMDsxCzAJBgNVBAYT\\n\" +\n+                        \"AlVTMQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2VyaXZj\\n\" +\n+                        \"ZTAeFw0xODA1MjIwNzE4MTZaFw0zODA1MTcwNzE4MTZaMFUxCzAJBgNVBAYTAlVT\\n\" +\n+                        \"MQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2VyaXZjZTEY\\n\" +\n+                        \"MBYGA1UEAwwPUmVncmVzc2lvbiBUZXN0MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcD\\n\" +\n+                        \"QgAEb+9n05qfXnfHUb0xtQJNS4JeSi6IjOfW5NqchvKnfJey9VkJzR7QHLuOESdf\\n\" +\n+                        \"xlR7q8YIWgih3iWLGfB+wxHiOqMjMCEwHwYDVR0jBBgwFoAUYM+9c\/\/6GjDSpOzT\\n\" +\n+                        \"SXFG7xo1oIYwCgYIKoZIzj0EAwIDSAAwRQIgWpRegWXMheiD3qFdd8kMdrkLxRbq\\n\" +\n+                        \"1zj8nQMEwFTUjjQCIQDRIrAjZX+YXHN9b0SoWWLPUq0HmiFIi8RwMnO\/\/wJIGQ==\\n\" +\n+                        \"-----END CERTIFICATE-----\",\n+                        \"MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgn5K03bpTLjEtFQRa\\n\" +\n+                        \"JUtx22gtmGEvvSUSQdimhGthdtihRANCAARv72fTmp9ed8dRvTG1Ak1Lgl5KLoiM\\n\" +\n+                        \"59bk2pyG8qd8l7L1WQnNHtAcu44RJ1\/GVHurxghaCKHeJYsZ8H7DEeI6\");\n+            final String keyAlgo;\n+            final String certStr;\n+            final String privKeyStr;\n+\n+            Cert(String keyAlgo, String certStr, String privKeyStr) {\n+                this.keyAlgo = keyAlgo;\n+                this.certStr = certStr;\n+                this.privKeyStr = privKeyStr;\n+            }\n+        }\n+\n+        \/*\n+         * The parameters used to configure SSLContext.\n+         *\/\n+        protected static final class ContextParameters {\n+            final String contextProtocol;\n+            final String tmAlgorithm;\n+            final String kmAlgorithm;\n+\n+            ContextParameters(String contextProtocol,\n+                              String tmAlgorithm, String kmAlgorithm) {\n+\n+                this.contextProtocol = contextProtocol;\n+                this.tmAlgorithm = tmAlgorithm;\n+                this.kmAlgorithm = kmAlgorithm;\n+            }\n+        }\n+\n+        \/*\n+         * =======================================\n+         * Certificates and keys used in the test.\n+         *\/\n+        \/\/ Trusted certificates.\n+        protected final static Cert[] TRUSTED_CERTS = {\n+                Cert.CA_ECDSA_SECP256R1 };\n+\n+        \/\/ End entity certificate.\n+        protected final static Cert[] END_ENTITY_CERTS = {\n+                Cert.EE_ECDSA_SECP256R1 };\n+\n+        \/*\n+         * Create an instance of SSLContext with the specified trust\/key materials.\n+         *\/\n+        public static SSLContext    createSSLContext(\n+                Cert[] trustedCerts,\n+                Cert[] endEntityCerts,\n+                ContextParameters params) throws Exception {\n+\n+            KeyStore ts = null;     \/\/ trust store\n+            KeyStore ks = null;     \/\/ key store\n+            char passphrase[] = \"passphrase\".toCharArray();\n+\n+            \/\/ Generate certificate from cert string.\n+            CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n+\n+            \/\/ Import the trused certs.\n+            ByteArrayInputStream is;\n+            if (trustedCerts != null && trustedCerts.length != 0) {\n+                ts = KeyStore.getInstance(\"JKS\");\n+                ts.load(null, null);\n+\n+                Certificate[] trustedCert = new Certificate[trustedCerts.length];\n+                for (int i = 0; i < trustedCerts.length; i++) {\n+                    is = new ByteArrayInputStream(trustedCerts[i].certStr.getBytes());\n+                    try {\n+                        trustedCert[i] = cf.generateCertificate(is);\n+                    } finally {\n+                        is.close();\n+                    }\n+\n+                    ts.setCertificateEntry(\n+                            \"trusted-cert-\" + trustedCerts[i].name(), trustedCert[i]);\n+                }\n+            }\n+\n+            \/\/ Import the key materials.\n+            if (endEntityCerts != null && endEntityCerts.length != 0) {\n+                ks = KeyStore.getInstance(\"JKS\");\n+                ks.load(null, null);\n+\n+                for (int i = 0; i < endEntityCerts.length; i++) {\n+                    \/\/ generate the private key.\n+                    PKCS8EncodedKeySpec priKeySpec = new PKCS8EncodedKeySpec(\n+                            Base64.getMimeDecoder().decode(endEntityCerts[i].privKeyStr));\n+                    KeyFactory kf =\n+                            KeyFactory.getInstance(\n+                                    endEntityCerts[i].keyAlgo);\n+                    PrivateKey priKey = kf.generatePrivate(priKeySpec);\n+\n+                    \/\/ generate certificate chain\n+                    is = new ByteArrayInputStream(\n+                            endEntityCerts[i].certStr.getBytes());\n+                    Certificate keyCert = null;\n+                    try {\n+                        keyCert = cf.generateCertificate(is);\n+                    } finally {\n+                        is.close();\n+                    }\n+\n+                    Certificate[] chain = new Certificate[] { keyCert };\n+\n+                    \/\/ import the key entry.\n+                    ks.setKeyEntry(\"cert-\" + endEntityCerts[i].name(),\n+                            priKey, passphrase, chain);\n+                }\n+            }\n+\n+            \/\/ Create an SSLContext object.\n+            TrustManagerFactory tmf =\n+                    TrustManagerFactory.getInstance(params.tmAlgorithm);\n+            tmf.init(ts);\n+\n+            SSLContext context = SSLContext.getInstance(params.contextProtocol);\n+            if (endEntityCerts != null && endEntityCerts.length != 0 && ks != null) {\n+                KeyManagerFactory kmf =\n+                        KeyManagerFactory.getInstance(params.kmAlgorithm);\n+                kmf.init(ks, passphrase);\n+\n+                context.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);\n+            } else {\n+                context.init(null, tmf.getTrustManagers(), null);\n+            }\n+\n+            return context;\n+        }\n+\n+        @Setup\n+        public void startServer() throws Exception {\n+            SSLContext context = createSSLContext(TRUSTED_CERTS, END_ENTITY_CERTS,\n+                    new ContextParameters(\"TLS\", \"PKIX\", \"NewSunX509\"));\n+            SSLServerSocketFactory ssf = context.getServerSocketFactory();\n+            SSLServerSocket serverSocket = (SSLServerSocket) ssf.createServerSocket(0);\n+            serverSocket.setEnabledProtocols(new String[] { \"TLSv1.3\" });\n+            serverSocket.setEnabledCipherSuites(new String[] {\"TLS_AES_256_GCM_SHA384\"});\n+            this.socketFactory = context.getSocketFactory();\n+            this.port = serverSocket.getLocalPort();\n+            new ServerThread(serverSocket).start();\n+        }\n+        public class ServerProcessor extends Thread {\n+            SSLSocket socket;\n+\n+            ServerProcessor(SSLSocket socket) {\n+                this.socket = socket;\n+            }\n+\n+            public void run() {\n+                try {\n+                    socket.startHandshake();\n+                } catch (IOException e) {\n+                    throw new RuntimeException(\"Exception handshaking request\", e);\n+                }\n+            }\n+        }\n+\n+        public class ServerThread extends Thread {\n+            SSLServerSocket socket;\n+\n+            ServerThread(SSLServerSocket socket) {\n+                this.socket = socket;\n+            }\n+\n+            public void run() {\n+                try {\n+                    while(true) {\n+                        new ServerProcessor((SSLSocket) this.socket.accept()).start();\n+                    }\n+                } catch (IOException e) {\n+                    throw new RuntimeException(\"Exception when accepting connection\", e);\n+                }\n+            }\n+        }\n+\n+        public SSLSocket getSSLSocket() throws IOException {\n+            return (SSLSocket) socketFactory.createSocket(\"localhost\", this.port);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void handshakeBenchmark(SSLStartHandshakeState state) throws IOException {\n+        SSLSocket socket = state.getSSLSocket();\n+        socket.startHandshake();\n+    }\n+\n+\n+}\n\\ No newline at end of file\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/security\/SSLStartHandshake.java","additions":262,"deletions":0,"binary":false,"changes":262,"status":"added"}]}