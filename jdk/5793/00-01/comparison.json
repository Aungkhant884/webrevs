{"files":[{"patch":"@@ -52,0 +52,1 @@\n+import sun.security.util.Cache;\n@@ -73,0 +74,6 @@\n+    static Cache<Double, HandshakeContextCacheItem> handshakeContextCache;\n+\n+    static {\n+        handshakeContextCache = Cache.newHardMemoryCache(50);\n+    }\n+\n@@ -169,5 +176,31 @@\n-        this.activeProtocols = new LinkedList<ProtocolVersion>(sslConfig.activeProtocols);\n-        if (activeProtocols.isEmpty()) {\n-            throw new SSLHandshakeException(\n-                \"No appropriate protocol (protocol is disabled or \" +\n-                \"cipher suites are inappropriate)\");\n+        double hashCode = getHashCode(\n+                sslConfig.enabledProtocols,\n+                sslConfig.enabledCipherSuites,\n+                sslConfig.userSpecifiedAlgorithmConstraints);\n+        HandshakeContextCacheItem cacheItem;\n+        if ((cacheItem = handshakeContextCache.get(hashCode)) != null &&\n+                cacheItem.enabledProtocolVersions == sslConfig.enabledProtocols &&\n+                cacheItem.enabledCipherSuites == sslConfig.enabledCipherSuites &&\n+                cacheItem.constraints == sslConfig.userSpecifiedAlgorithmConstraints) {\n+            this.activeProtocols = cacheItem.protocolVersions;\n+            this.activeCipherSuites = cacheItem.cipherSuites;\n+        } else {\n+            this.activeProtocols = getActiveProtocols(sslConfig.enabledProtocols,\n+                    sslConfig.enabledCipherSuites, algorithmConstraints);\n+            if (activeProtocols.isEmpty()) {\n+                throw new SSLHandshakeException(\n+                        \"No appropriate protocol (protocol is disabled or \" +\n+                                \"cipher suites are inappropriate)\");\n+            }\n+            this.activeCipherSuites = getActiveCipherSuites(this.activeProtocols,\n+                    sslConfig.enabledCipherSuites, algorithmConstraints);\n+            if (activeCipherSuites.isEmpty()) {\n+                throw new SSLHandshakeException(\"No appropriate cipher suite\");\n+            }\n+            handshakeContextCache.put(hashCode,\n+                    new HandshakeContextCacheItem(\n+                            this.activeProtocols,\n+                            this.activeCipherSuites,\n+                            sslConfig.enabledProtocols,\n+                            sslConfig.enabledCipherSuites,\n+                            sslConfig.userSpecifiedAlgorithmConstraints));\n@@ -175,1 +208,0 @@\n-\n@@ -184,5 +216,0 @@\n-        this.activeCipherSuites = new LinkedList<CipherSuite>(sslConfig.activeCipherSuites);\n-        if (activeCipherSuites.isEmpty()) {\n-            throw new SSLHandshakeException(\"No appropriate cipher suite\");\n-        }\n-\n@@ -265,0 +292,79 @@\n+    private static List<ProtocolVersion> getActiveProtocols(\n+            List<ProtocolVersion> enabledProtocols,\n+            List<CipherSuite> enabledCipherSuites,\n+            AlgorithmConstraints algorithmConstraints) {\n+        boolean enabledSSL20Hello = false;\n+        ArrayList<ProtocolVersion> protocols = new ArrayList<>(4);\n+        for (ProtocolVersion protocol : enabledProtocols) {\n+            if (!enabledSSL20Hello && protocol == ProtocolVersion.SSL20Hello) {\n+                enabledSSL20Hello = true;\n+                continue;\n+            }\n+\n+            if (!algorithmConstraints.permits(\n+                    EnumSet.of(CryptoPrimitive.KEY_AGREEMENT),\n+                    protocol.name, null)) {\n+                \/\/ Ignore disabled protocol.\n+                continue;\n+            }\n+\n+            boolean found = false;\n+            Map<NamedGroupSpec, Boolean> cachedStatus =\n+                    new EnumMap<>(NamedGroupSpec.class);\n+            for (CipherSuite suite : enabledCipherSuites) {\n+                if (suite.isAvailable() && suite.supports(protocol)) {\n+                    if (isActivatable(suite,\n+                            algorithmConstraints, cachedStatus)) {\n+                        protocols.add(protocol);\n+                        found = true;\n+                        break;\n+                    }\n+                } else if (SSLLogger.isOn && SSLLogger.isOn(\"verbose\")) {\n+                    SSLLogger.fine(\n+                        \"Ignore unsupported cipher suite: \" + suite +\n+                             \" for \" + protocol.name);\n+                }\n+            }\n+\n+            if (!found && (SSLLogger.isOn) && SSLLogger.isOn(\"handshake\")) {\n+                SSLLogger.fine(\n+                    \"No available cipher suite for \" + protocol.name);\n+            }\n+        }\n+\n+        if (!protocols.isEmpty()) {\n+            if (enabledSSL20Hello) {\n+                protocols.add(ProtocolVersion.SSL20Hello);\n+            }\n+            Collections.sort(protocols);\n+        }\n+\n+        return Collections.unmodifiableList(protocols);\n+    }\n+\n+    private static List<CipherSuite> getActiveCipherSuites(\n+            List<ProtocolVersion> enabledProtocols,\n+            List<CipherSuite> enabledCipherSuites,\n+            AlgorithmConstraints algorithmConstraints) {\n+\n+        List<CipherSuite> suites = new LinkedList<>();\n+        if (enabledProtocols != null && !enabledProtocols.isEmpty()) {\n+            Map<NamedGroupSpec, Boolean> cachedStatus =\n+                    new EnumMap<>(NamedGroupSpec.class);\n+            for (CipherSuite suite : enabledCipherSuites) {\n+                if (!suite.isAvailable()) {\n+                    continue;\n+                }\n+\n+                boolean isSupported = false;\n+                for (ProtocolVersion protocol : enabledProtocols) {\n+                    if (!suite.supports(protocol)) {\n+                        continue;\n+                    }\n+                    if (isActivatable(suite,\n+                            algorithmConstraints, cachedStatus)) {\n+                        suites.add(suite);\n+                        isSupported = true;\n+                        break;\n+                    }\n+                }\n@@ -266,0 +372,10 @@\n+                if (!isSupported &&\n+                        SSLLogger.isOn && SSLLogger.isOn(\"verbose\")) {\n+                    SSLLogger.finest(\n+                            \"Ignore unsupported cipher suite: \" + suite);\n+                }\n+            }\n+        }\n+\n+        return Collections.unmodifiableList(suites);\n+    }\n@@ -446,0 +562,50 @@\n+    private static boolean isActivatable(CipherSuite suite,\n+            AlgorithmConstraints algorithmConstraints,\n+            Map<NamedGroupSpec, Boolean> cachedStatus) {\n+\n+        if (algorithmConstraints.permits(\n+                EnumSet.of(CryptoPrimitive.KEY_AGREEMENT), suite.name, null)) {\n+            if (suite.keyExchange == null) {\n+                \/\/ TLS 1.3, no definition of key exchange in cipher suite.\n+                return true;\n+            }\n+\n+            \/\/ Is at least one of the group types available?\n+            boolean groupAvailable, retval = false;\n+            NamedGroupSpec[] groupTypes = suite.keyExchange.groupTypes;\n+            for (NamedGroupSpec groupType : groupTypes) {\n+                if (groupType != NAMED_GROUP_NONE) {\n+                    Boolean checkedStatus = cachedStatus.get(groupType);\n+                    if (checkedStatus == null) {\n+                        groupAvailable = SupportedGroups.isActivatable(\n+                                algorithmConstraints, groupType);\n+                        cachedStatus.put(groupType, groupAvailable);\n+\n+                        if (!groupAvailable &&\n+                                SSLLogger.isOn && SSLLogger.isOn(\"verbose\")) {\n+                            SSLLogger.fine(\n+                                    \"No activated named group in \" + groupType);\n+                        }\n+                    } else {\n+                        groupAvailable = checkedStatus;\n+                    }\n+\n+                    retval |= groupAvailable;\n+                } else {\n+                    retval = true;\n+                }\n+            }\n+\n+            if (!retval && SSLLogger.isOn && SSLLogger.isOn(\"verbose\")) {\n+                SSLLogger.fine(\"No active named group(s), ignore \" + suite);\n+            }\n+\n+            return retval;\n+\n+        } else if (SSLLogger.isOn && SSLLogger.isOn(\"verbose\")) {\n+            SSLLogger.fine(\"Ignore disabled cipher suite: \" + suite);\n+        }\n+\n+        return false;\n+    }\n+\n@@ -452,0 +618,31 @@\n+\n+    static double getHashCode(List<ProtocolVersion> protocolVersions,\n+                           List<CipherSuite> cipherSuites,\n+                           AlgorithmConstraints constraints) {\n+        int a = protocolVersions.hashCode();\n+        int b = cipherSuites.hashCode();\n+        int c = constraints.hashCode();\n+        double cantor = 0.5 * (a + b) * (a + b + 1) + a;\n+        cantor = 0.5 * ( cantor + c) * (cantor + c + 1) + cantor;\n+        return cantor;\n+    }\n+\n+    static class HandshakeContextCacheItem {\n+        List<ProtocolVersion> protocolVersions;\n+        List<CipherSuite> cipherSuites;\n+        List<ProtocolVersion> enabledProtocolVersions;\n+        List<CipherSuite> enabledCipherSuites;\n+        AlgorithmConstraints constraints;\n+\n+        HandshakeContextCacheItem(List<ProtocolVersion> protocolVersions,\n+                                  List<CipherSuite> cipherSuites,\n+                                  List<ProtocolVersion> enabledProtocolVersions,\n+                                  List<CipherSuite> enabledCipherSuites,\n+                                  AlgorithmConstraints constraints) {\n+            this.cipherSuites = cipherSuites;\n+            this.protocolVersions = protocolVersions;\n+            this.enabledProtocolVersions = enabledProtocolVersions;\n+            this.enabledCipherSuites = enabledCipherSuites;\n+            this.constraints = constraints;\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/HandshakeContext.java","additions":208,"deletions":11,"binary":false,"changes":219,"status":"modified"},{"patch":"@@ -28,2 +28,9 @@\n-import java.security.*;\n-import java.util.*;\n+import java.security.AccessControlContext;\n+import java.security.AccessController;\n+import java.security.AlgorithmConstraints;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n@@ -43,2 +50,0 @@\n-import static sun.security.ssl.NamedGroup.NamedGroupSpec.NAMED_GROUP_NONE;\n-\n@@ -51,2 +56,2 @@\n-    private List<ProtocolVersion>       enabledProtocols;\n-    private List<CipherSuite>           enabledCipherSuites;\n+    List<ProtocolVersion>       enabledProtocols;\n+    List<CipherSuite>           enabledCipherSuites;\n@@ -61,3 +66,0 @@\n-    List<ProtocolVersion>       activeProtocols;\n-    List<CipherSuite>           activeCipherSuites;\n-    AlgorithmConstraints        algorithmConstraints;\n@@ -167,7 +169,0 @@\n-\n-        this.algorithmConstraints = new SSLAlgorithmConstraints(\n-                this.userSpecifiedAlgorithmConstraints);\n-        this.activeProtocols = getActiveProtocols(this.enabledProtocols,\n-                this.enabledCipherSuites, this.algorithmConstraints);\n-        this.activeCipherSuites = getActiveCipherSuites(this.activeProtocols,\n-                this.enabledCipherSuites, this.algorithmConstraints);\n@@ -272,7 +267,0 @@\n-\n-        this.algorithmConstraints = new SSLAlgorithmConstraints(\n-                this.userSpecifiedAlgorithmConstraints);\n-        this.activeProtocols = getActiveProtocols(this.enabledProtocols,\n-                this.enabledCipherSuites, this.algorithmConstraints);\n-        this.activeCipherSuites = getActiveCipherSuites(this.activeProtocols,\n-                this.enabledCipherSuites, this.algorithmConstraints);\n@@ -511,167 +499,0 @@\n-\n-    private static List<ProtocolVersion> getActiveProtocols(\n-            List<ProtocolVersion> enabledProtocols,\n-            List<CipherSuite> enabledCipherSuites,\n-            AlgorithmConstraints algorithmConstraints) {\n-        boolean enabledSSL20Hello = false;\n-        ArrayList<ProtocolVersion> protocols = new ArrayList<>(4);\n-        for (ProtocolVersion protocol : enabledProtocols) {\n-            if (!enabledSSL20Hello && protocol == ProtocolVersion.SSL20Hello) {\n-                enabledSSL20Hello = true;\n-                continue;\n-            }\n-\n-            if (!algorithmConstraints.permits(\n-                    EnumSet.of(CryptoPrimitive.KEY_AGREEMENT),\n-                    protocol.name, null)) {\n-                \/\/ Ignore disabled protocol.\n-                continue;\n-            }\n-\n-            boolean found = false;\n-            Map<NamedGroup.NamedGroupSpec, Boolean> cachedStatus =\n-                    new EnumMap<>(NamedGroup.NamedGroupSpec.class);\n-            for (CipherSuite suite : enabledCipherSuites) {\n-                if (suite.isAvailable() && suite.supports(protocol)) {\n-                    if (isActivatable(suite,\n-                            algorithmConstraints, cachedStatus)) {\n-                        protocols.add(protocol);\n-                        found = true;\n-                        break;\n-                    }\n-                } else if (SSLLogger.isOn && SSLLogger.isOn(\"verbose\")) {\n-                    SSLLogger.fine(\n-                            \"Ignore unsupported cipher suite: \" + suite +\n-                                    \" for \" + protocol.name);\n-                }\n-            }\n-\n-            if (!found && (SSLLogger.isOn) && SSLLogger.isOn(\"handshake\")) {\n-                SSLLogger.fine(\n-                        \"No available cipher suite for \" + protocol.name);\n-            }\n-        }\n-\n-        if (!protocols.isEmpty()) {\n-            if (enabledSSL20Hello) {\n-                protocols.add(ProtocolVersion.SSL20Hello);\n-            }\n-            Collections.sort(protocols);\n-        }\n-\n-        return Collections.unmodifiableList(protocols);\n-    }\n-\n-    private static List<CipherSuite> getActiveCipherSuites(\n-            List<ProtocolVersion> enabledProtocols,\n-            List<CipherSuite> enabledCipherSuites,\n-            AlgorithmConstraints algorithmConstraints) {\n-\n-        List<CipherSuite> suites = new LinkedList<>();\n-        if (enabledProtocols != null && !enabledProtocols.isEmpty()) {\n-            Map<NamedGroup.NamedGroupSpec, Boolean> cachedStatus =\n-                    new EnumMap<>(NamedGroup.NamedGroupSpec.class);\n-            for (CipherSuite suite : enabledCipherSuites) {\n-                if (!suite.isAvailable()) {\n-                    continue;\n-                }\n-\n-                boolean isSupported = false;\n-                for (ProtocolVersion protocol : enabledProtocols) {\n-                    if (!suite.supports(protocol)) {\n-                        continue;\n-                    }\n-                    if (isActivatable(suite,\n-                            algorithmConstraints, cachedStatus)) {\n-                        suites.add(suite);\n-                        isSupported = true;\n-                        break;\n-                    }\n-                }\n-\n-                if (!isSupported &&\n-                        SSLLogger.isOn && SSLLogger.isOn(\"verbose\")) {\n-                    SSLLogger.finest(\n-                            \"Ignore unsupported cipher suite: \" + suite);\n-                }\n-            }\n-        }\n-\n-        return Collections.unmodifiableList(suites);\n-    }\n-\n-    private static boolean isActivatable(CipherSuite suite,\n-                                         AlgorithmConstraints algorithmConstraints,\n-                                         Map<NamedGroup.NamedGroupSpec, Boolean> cachedStatus) {\n-\n-        if (algorithmConstraints.permits(\n-                EnumSet.of(CryptoPrimitive.KEY_AGREEMENT), suite.name, null)) {\n-            if (suite.keyExchange == null) {\n-                \/\/ TLS 1.3, no definition of key exchange in cipher suite.\n-                return true;\n-            }\n-\n-            \/\/ Is at least one of the group types available?\n-            boolean groupAvailable, retval = false;\n-            NamedGroup.NamedGroupSpec[] groupTypes = suite.keyExchange.groupTypes;\n-            for (NamedGroup.NamedGroupSpec groupType : groupTypes) {\n-                if (groupType != NAMED_GROUP_NONE) {\n-                    Boolean checkedStatus = cachedStatus.get(groupType);\n-                    if (checkedStatus == null) {\n-                        groupAvailable = SupportedGroupsExtension.SupportedGroups.isActivatable(\n-                                algorithmConstraints, groupType);\n-                        cachedStatus.put(groupType, groupAvailable);\n-\n-                        if (!groupAvailable &&\n-                                SSLLogger.isOn && SSLLogger.isOn(\"verbose\")) {\n-                            SSLLogger.fine(\n-                                    \"No activated named group in \" + groupType);\n-                        }\n-                    } else {\n-                        groupAvailable = checkedStatus;\n-                    }\n-\n-                    retval |= groupAvailable;\n-                } else {\n-                    retval = true;\n-                }\n-            }\n-\n-            if (!retval && SSLLogger.isOn && SSLLogger.isOn(\"verbose\")) {\n-                SSLLogger.fine(\"No active named group(s), ignore \" + suite);\n-            }\n-\n-            return retval;\n-\n-        } else if (SSLLogger.isOn && SSLLogger.isOn(\"verbose\")) {\n-            SSLLogger.fine(\"Ignore disabled cipher suite: \" + suite);\n-        }\n-\n-        return false;\n-    }\n-\n-    List<ProtocolVersion> getEnabledProtocols() {\n-        return enabledProtocols;\n-    }\n-\n-    List<CipherSuite> getEnabledCipherSuites() {\n-        return enabledCipherSuites;\n-    }\n-\n-    void setEnabledProtocols(List<ProtocolVersion> enabledProtocols) {\n-        this.enabledProtocols = enabledProtocols;\n-        this.activeProtocols = getActiveProtocols(this.enabledProtocols,\n-                this.enabledCipherSuites, this.algorithmConstraints);\n-        this.activeCipherSuites = getActiveCipherSuites(this.activeProtocols,\n-                this.enabledCipherSuites, this.algorithmConstraints);\n-\n-    }\n-\n-    void setEnabledCipherSuites(List<CipherSuite> enabledCipherSuites) {\n-        this.enabledCipherSuites = enabledCipherSuites;\n-        this.activeProtocols = getActiveProtocols(this.enabledProtocols,\n-                this.enabledCipherSuites, this.algorithmConstraints);\n-        this.activeCipherSuites = getActiveCipherSuites(this.activeProtocols,\n-                this.enabledCipherSuites, this.algorithmConstraints);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLConfiguration.java","additions":11,"deletions":190,"binary":false,"changes":201,"status":"modified"},{"patch":"@@ -853,1 +853,1 @@\n-            return CipherSuite.namesOf(conContext.sslConfig.getEnabledCipherSuites());\n+            return CipherSuite.namesOf(conContext.sslConfig.enabledCipherSuites);\n@@ -863,2 +863,2 @@\n-            conContext.sslConfig.setEnabledCipherSuites(\n-                    CipherSuite.validValuesOf(suites));\n+            conContext.sslConfig.enabledCipherSuites =\n+                    CipherSuite.validValuesOf(suites);\n@@ -881,1 +881,1 @@\n-                    conContext.sslConfig.getEnabledProtocols());\n+                    conContext.sslConfig.enabledProtocols);\n@@ -895,2 +895,2 @@\n-            conContext.sslConfig.setEnabledProtocols(\n-                    ProtocolVersion.namesOf(protocols));\n+            conContext.sslConfig.enabledProtocols =\n+                    ProtocolVersion.namesOf(protocols);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLEngineImpl.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -89,1 +89,1 @@\n-            return CipherSuite.namesOf(sslConfig.getEnabledCipherSuites());\n+            return CipherSuite.namesOf(sslConfig.enabledCipherSuites);\n@@ -99,2 +99,2 @@\n-            sslConfig.setEnabledCipherSuites(\n-                    CipherSuite.validValuesOf(suites));\n+            sslConfig.enabledCipherSuites =\n+                    CipherSuite.validValuesOf(suites);\n@@ -121,1 +121,1 @@\n-            return ProtocolVersion.toStringArray(sslConfig.getEnabledProtocols());\n+            return ProtocolVersion.toStringArray(sslConfig.enabledProtocols);\n@@ -135,1 +135,1 @@\n-            sslConfig.setEnabledProtocols(ProtocolVersion.namesOf(protocols));\n+            sslConfig.enabledProtocols = ProtocolVersion.namesOf(protocols);\n@@ -199,3 +199,3 @@\n-                        sslConfig.getEnabledProtocols())) {\n-                    sslConfig.setEnabledProtocols(\n-                        sslContext.getDefaultProtocolVersions(!useClientMode));\n+                        sslConfig.enabledProtocols)) {\n+                    sslConfig.enabledProtocols =\n+                        sslContext.getDefaultProtocolVersions(!useClientMode);\n@@ -205,3 +205,3 @@\n-                        sslConfig.getEnabledCipherSuites())) {\n-                    sslConfig.setEnabledCipherSuites(\n-                        sslContext.getDefaultCipherSuites(!useClientMode));\n+                        sslConfig.enabledCipherSuites)) {\n+                    sslConfig.enabledCipherSuites =\n+                        sslContext.getDefaultCipherSuites(!useClientMode);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLServerSocketImpl.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-    private final SSLConfiguration configuration;\n@@ -56,1 +55,0 @@\n-        this.configuration = new SSLConfiguration(this.context, true);\n@@ -64,1 +62,0 @@\n-        this.configuration = new SSLConfiguration(this.context, true);\n@@ -75,1 +72,1 @@\n-        return new SSLSocketImpl(context, this.configuration);\n+        return new SSLSocketImpl(context);\n@@ -91,1 +88,1 @@\n-        return new SSLSocketImpl(context, host, port, this.configuration);\n+        return new SSLSocketImpl(context, host, port);\n@@ -113,1 +110,1 @@\n-        return new SSLSocketImpl(context, s, host, port, autoClose, configuration);\n+        return new SSLSocketImpl(context, s, host, port, autoClose);\n@@ -140,1 +137,1 @@\n-        return new SSLSocketImpl(context, address, port, configuration);\n+        return new SSLSocketImpl(context, address, port);\n@@ -157,1 +154,1 @@\n-                clientAddress, clientPort, configuration);\n+                clientAddress, clientPort);\n@@ -173,1 +170,1 @@\n-                clientAddress, clientPort, configuration);\n+                clientAddress, clientPort);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLSocketFactoryImpl.java","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -161,23 +161,0 @@\n-    \/**\n-     * Constructs an SSL connection to a named host at a specified\n-     * port, using the authentication context provided.\n-     *\n-     * This endpoint acts as the client, and may rejoin an existing SSL session\n-     * if appropriate.\n-     *\/\n-    SSLSocketImpl(SSLContextImpl sslContext, String peerHost,\n-                  int peerPort, SSLConfiguration sslConfiguration) throws IOException {\n-        super();\n-        this.sslContext = sslContext;\n-        HandshakeHash handshakeHash = new HandshakeHash();\n-        this.conContext = new TransportContext(sslContext, this,\n-                sslConfiguration,\n-                new SSLSocketInputRecord(handshakeHash),\n-                new SSLSocketOutputRecord(handshakeHash));\n-        this.peerHost = peerHost;\n-        SocketAddress socketAddress =\n-                peerHost != null ? new InetSocketAddress(peerHost, peerPort) :\n-                        new InetSocketAddress(InetAddress.getByName(null), peerPort);\n-        connect(socketAddress, 0);\n-    }\n-\n@@ -205,23 +182,0 @@\n-    \/**\n-     * Constructs an SSL connection to a server at a specified\n-     * address, and TCP port, using the authentication context\n-     * provided.\n-     *\n-     * This endpoint acts as the client, and may rejoin an existing SSL\n-     * session if appropriate.\n-     *\/\n-    SSLSocketImpl(SSLContextImpl sslContext,\n-                  InetAddress address, int peerPort,\n-                  SSLConfiguration configuration) throws IOException {\n-        super();\n-        this.sslContext = sslContext;\n-        HandshakeHash handshakeHash = new HandshakeHash();\n-        this.conContext = new TransportContext(sslContext, this,\n-                configuration,\n-                new SSLSocketInputRecord(handshakeHash),\n-                new SSLSocketOutputRecord(handshakeHash));\n-\n-        SocketAddress socketAddress = new InetSocketAddress(address, peerPort);\n-        connect(socketAddress, 0);\n-    }\n-\n@@ -253,27 +207,0 @@\n-    \/**\n-     * Constructs an SSL connection to a named host at a specified\n-     * port, using the authentication context provided.\n-     *\n-     * This endpoint acts as the client, and may rejoin an existing SSL\n-     * session if appropriate.\n-     *\/\n-    SSLSocketImpl(SSLContextImpl sslContext,\n-                  String peerHost, int peerPort, InetAddress localAddr,\n-                  int localPort,\n-                  SSLConfiguration configuration) throws IOException {\n-        super();\n-        this.sslContext = sslContext;\n-        HandshakeHash handshakeHash = new HandshakeHash();\n-        this.conContext = new TransportContext(sslContext, this,\n-                configuration,\n-                new SSLSocketInputRecord(handshakeHash),\n-                new SSLSocketOutputRecord(handshakeHash));\n-        this.peerHost = peerHost;\n-\n-        bind(new InetSocketAddress(localAddr, localPort));\n-        SocketAddress socketAddress =\n-                peerHost != null ? new InetSocketAddress(peerHost, peerPort) :\n-                        new InetSocketAddress(InetAddress.getByName(null), peerPort);\n-        connect(socketAddress, 0);\n-    }\n-\n@@ -303,25 +230,0 @@\n-    \/**\n-     * Constructs an SSL connection to a server at a specified\n-     * address, and TCP port, using the authentication context\n-     * provided.\n-     *\n-     * This endpoint acts as the client, and may rejoin an existing SSL\n-     * session if appropriate.\n-     *\/\n-    SSLSocketImpl(SSLContextImpl sslContext,\n-                  InetAddress peerAddr, int peerPort,\n-                  InetAddress localAddr, int localPort,\n-                  SSLConfiguration configuration) throws IOException {\n-        super();\n-        this.sslContext = sslContext;\n-        HandshakeHash handshakeHash = new HandshakeHash();\n-        this.conContext = new TransportContext(sslContext, this,\n-                configuration,\n-                new SSLSocketInputRecord(handshakeHash),\n-                new SSLSocketOutputRecord(handshakeHash));\n-\n-        bind(new InetSocketAddress(localAddr, localPort));\n-        SocketAddress socketAddress = new InetSocketAddress(peerAddr, peerPort);\n-        connect(socketAddress, 0);\n-    }\n-\n@@ -384,35 +286,0 @@\n-    \/**\n-     * Layer SSL traffic over an existing connection, rather than\n-     * creating a new connection.\n-     *\n-     * The existing connection may be used only for SSL traffic (using this\n-     * SSLSocket) until the SSLSocket.close() call returns. However, if a\n-     * protocol error is detected, that existing connection is automatically\n-     * closed.\n-     * <p>\n-     * This particular constructor always uses the socket in the\n-     * role of an SSL client. It may be useful in cases which start\n-     * using SSL after some initial data transfers, for example in some\n-     * SSL tunneling applications or as part of some kinds of application\n-     * protocols which negotiate use of a SSL based security.\n-     *\/\n-    SSLSocketImpl(SSLContextImpl sslContext, Socket sock,\n-                  String peerHost, int port, boolean autoClose,\n-                  SSLConfiguration configuration) throws IOException {\n-        super(sock);\n-        \/\/ We always layer over a connected socket\n-        if (!sock.isConnected()) {\n-            throw new SocketException(\"Underlying socket is not connected\");\n-        }\n-\n-        this.sslContext = sslContext;\n-        HandshakeHash handshakeHash = new HandshakeHash();\n-        this.conContext = new TransportContext(sslContext, this,\n-                configuration,\n-                new SSLSocketInputRecord(handshakeHash),\n-                new SSLSocketOutputRecord(handshakeHash));\n-        this.peerHost = peerHost;\n-        this.autoClose = autoClose;\n-        doneConnect();\n-    }\n-\n@@ -446,1 +313,1 @@\n-                    conContext.sslConfig.getEnabledCipherSuites());\n+                    conContext.sslConfig.enabledCipherSuites);\n@@ -456,2 +323,2 @@\n-            conContext.sslConfig.setEnabledCipherSuites(\n-                    CipherSuite.validValuesOf(suites));\n+            conContext.sslConfig.enabledCipherSuites =\n+                    CipherSuite.validValuesOf(suites);\n@@ -474,1 +341,1 @@\n-                    conContext.sslConfig.getEnabledProtocols());\n+                    conContext.sslConfig.enabledProtocols);\n@@ -488,2 +355,2 @@\n-            conContext.sslConfig.setEnabledProtocols(\n-                    ProtocolVersion.namesOf(protocols));\n+            conContext.sslConfig.enabledProtocols =\n+                    ProtocolVersion.namesOf(protocols);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLSocketImpl.java","additions":6,"deletions":139,"binary":false,"changes":145,"status":"modified"},{"patch":"@@ -464,3 +464,3 @@\n-                    sslConfig.getEnabledProtocols())) {\n-                sslConfig.setEnabledProtocols(\n-                        sslContext.getDefaultProtocolVersions(!useClientMode));\n+                    sslConfig.enabledProtocols)) {\n+                sslConfig.enabledProtocols =\n+                        sslContext.getDefaultProtocolVersions(!useClientMode);\n@@ -470,3 +470,3 @@\n-                    sslConfig.getEnabledCipherSuites())) {\n-                sslConfig.setEnabledCipherSuites(\n-                        sslContext.getDefaultCipherSuites(!useClientMode));\n+                    sslConfig.enabledCipherSuites)) {\n+                sslConfig.enabledCipherSuites =\n+                        sslContext.getDefaultCipherSuites(!useClientMode);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/TransportContext.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,277 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+package org.openjdk.bench.java.security;\n+\n+import org.openjdk.jmh.annotations.*;\n+\n+import javax.net.ssl.*;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.security.KeyFactory;\n+import java.security.KeyStore;\n+import java.security.PrivateKey;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateFactory;\n+import java.security.spec.PKCS8EncodedKeySpec;\n+import java.util.Base64;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode({Mode.AverageTime, Mode.Throughput})\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@Fork(jvmArgsAppend = {\"--add-exports\", \"java.base\/sun.security.util=ALL-UNNAMED\"})\n+public class SSLEngineStartHandshake {\n+\n+    @State(Scope.Benchmark)\n+    public static class SSLStartHandshakeState {\n+\n+        public static final ByteBuffer CLIENT_HELLO = ByteBuffer.allocate(32768);\n+        public static final ByteBuffer SERVER_HELLO = ByteBuffer.allocate(65536);\n+        public static final ByteBuffer EMPTY = ByteBuffer.allocate(0);\n+        public SSLContext context;\n+\n+        public enum Cert {\n+\n+            CA_ECDSA_SECP256R1(\n+                    \"EC\",\n+                    \/\/ SHA256withECDSA, curve secp256r1\n+                    \/\/ Validity\n+                    \/\/     Not Before: May 22 07:18:16 2018 GMT\n+                    \/\/     Not After : May 17 07:18:16 2038 GMT\n+                    \/\/ Subject Key Identifier:\n+                    \/\/     60:CF:BD:73:FF:FA:1A:30:D2:A4:EC:D3:49:71:46:EF:1A:35:A0:86\n+                    \"-----BEGIN CERTIFICATE-----\\n\" +\n+                            \"MIIBvjCCAWOgAwIBAgIJAIvFG6GbTroCMAoGCCqGSM49BAMCMDsxCzAJBgNVBAYT\\n\" +\n+                            \"AlVTMQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2VyaXZj\\n\" +\n+                            \"ZTAeFw0xODA1MjIwNzE4MTZaFw0zODA1MTcwNzE4MTZaMDsxCzAJBgNVBAYTAlVT\\n\" +\n+                            \"MQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2VyaXZjZTBZ\\n\" +\n+                            \"MBMGByqGSM49AgEGCCqGSM49AwEHA0IABBz1WeVb6gM2mh85z3QlvaB\/l11b5h0v\\n\" +\n+                            \"LIzmkC3DKlVukZT+ltH2Eq1oEkpXuf7QmbM0ibrUgtjsWH3mULfmcWmjUDBOMB0G\\n\" +\n+                            \"A1UdDgQWBBRgz71z\/\/oaMNKk7NNJcUbvGjWghjAfBgNVHSMEGDAWgBRgz71z\/\/oa\\n\" +\n+                            \"MNKk7NNJcUbvGjWghjAMBgNVHRMEBTADAQH\/MAoGCCqGSM49BAMCA0kAMEYCIQCG\\n\" +\n+                            \"6wluh1r2\/T6L31mZXRKf9JxeSf9pIzoLj+8xQeUChQIhAJ09wAi1kV8yePLh2FD9\\n\" +\n+                            \"2YEHlSQUAbwwqCDEVB5KxaqP\\n\" +\n+                            \"-----END CERTIFICATE-----\",\n+                    \"MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQg\/HcHdoLJCdq3haVd\\n\" +\n+                            \"XZTSKP00YzM3xX97l98vGL\/RI1KhRANCAAQc9VnlW+oDNpofOc90Jb2gf5ddW+Yd\\n\" +\n+                            \"LyyM5pAtwypVbpGU\/pbR9hKtaBJKV7n+0JmzNIm61ILY7Fh95lC35nFp\"),\n+            EE_ECDSA_SECP256R1(\n+                    \"EC\",\n+                    \/\/ SHA256withECDSA, curve secp256r1\n+                    \/\/ Validity\n+                    \/\/     Not Before: May 22 07:18:16 2018 GMT\n+                    \/\/     Not After : May 17 07:18:16 2038 GMT\n+                    \/\/ Authority Key Identifier:\n+                    \/\/     60:CF:BD:73:FF:FA:1A:30:D2:A4:EC:D3:49:71:46:EF:1A:35:A0:86\n+                    \"-----BEGIN CERTIFICATE-----\\n\" +\n+                            \"MIIBqjCCAVCgAwIBAgIJAPLY8qZjgNRAMAoGCCqGSM49BAMCMDsxCzAJBgNVBAYT\\n\" +\n+                            \"AlVTMQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2VyaXZj\\n\" +\n+                            \"ZTAeFw0xODA1MjIwNzE4MTZaFw0zODA1MTcwNzE4MTZaMFUxCzAJBgNVBAYTAlVT\\n\" +\n+                            \"MQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2VyaXZjZTEY\\n\" +\n+                            \"MBYGA1UEAwwPUmVncmVzc2lvbiBUZXN0MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcD\\n\" +\n+                            \"QgAEb+9n05qfXnfHUb0xtQJNS4JeSi6IjOfW5NqchvKnfJey9VkJzR7QHLuOESdf\\n\" +\n+                            \"xlR7q8YIWgih3iWLGfB+wxHiOqMjMCEwHwYDVR0jBBgwFoAUYM+9c\/\/6GjDSpOzT\\n\" +\n+                            \"SXFG7xo1oIYwCgYIKoZIzj0EAwIDSAAwRQIgWpRegWXMheiD3qFdd8kMdrkLxRbq\\n\" +\n+                            \"1zj8nQMEwFTUjjQCIQDRIrAjZX+YXHN9b0SoWWLPUq0HmiFIi8RwMnO\/\/wJIGQ==\\n\" +\n+                            \"-----END CERTIFICATE-----\",\n+                    \"MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgn5K03bpTLjEtFQRa\\n\" +\n+                            \"JUtx22gtmGEvvSUSQdimhGthdtihRANCAARv72fTmp9ed8dRvTG1Ak1Lgl5KLoiM\\n\" +\n+                            \"59bk2pyG8qd8l7L1WQnNHtAcu44RJ1\/GVHurxghaCKHeJYsZ8H7DEeI6\");\n+            final String keyAlgo;\n+            final String certStr;\n+            final String privKeyStr;\n+\n+            Cert(String keyAlgo, String certStr, String privKeyStr) {\n+                this.keyAlgo = keyAlgo;\n+                this.certStr = certStr;\n+                this.privKeyStr = privKeyStr;\n+            }\n+        }\n+\n+        \/*\n+         * The parameters used to configure SSLContext.\n+         *\/\n+        protected static final class ContextParameters {\n+            final String contextProtocol;\n+            final String tmAlgorithm;\n+            final String kmAlgorithm;\n+\n+            ContextParameters(String contextProtocol,\n+                              String tmAlgorithm, String kmAlgorithm) {\n+\n+                this.contextProtocol = contextProtocol;\n+                this.tmAlgorithm = tmAlgorithm;\n+                this.kmAlgorithm = kmAlgorithm;\n+            }\n+        }\n+\n+        \/*\n+         * =======================================\n+         * Certificates and keys used in the test.\n+         *\/\n+        \/\/ Trusted certificates.\n+        protected final static Cert[] TRUSTED_CERTS = {\n+                Cert.CA_ECDSA_SECP256R1 };\n+\n+        \/\/ End entity certificate.\n+        protected final static Cert[] END_ENTITY_CERTS = {\n+                Cert.EE_ECDSA_SECP256R1 };\n+\n+        \/*\n+         * Create an instance of SSLContext with the specified trust\/key materials.\n+         *\/\n+        public static SSLContext    createSSLContext(\n+                Cert[] trustedCerts,\n+                Cert[] endEntityCerts,\n+                ContextParameters params) throws Exception {\n+\n+            KeyStore ts = null;     \/\/ trust store\n+            KeyStore ks = null;     \/\/ key store\n+            char passphrase[] = \"passphrase\".toCharArray();\n+\n+            \/\/ Generate certificate from cert string.\n+            CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n+\n+            \/\/ Import the trused certs.\n+            ByteArrayInputStream is;\n+            if (trustedCerts != null && trustedCerts.length != 0) {\n+                ts = KeyStore.getInstance(\"JKS\");\n+                ts.load(null, null);\n+\n+                Certificate[] trustedCert = new Certificate[trustedCerts.length];\n+                for (int i = 0; i < trustedCerts.length; i++) {\n+                    is = new ByteArrayInputStream(trustedCerts[i].certStr.getBytes());\n+                    try {\n+                        trustedCert[i] = cf.generateCertificate(is);\n+                    } finally {\n+                        is.close();\n+                    }\n+\n+                    ts.setCertificateEntry(\n+                            \"trusted-cert-\" + trustedCerts[i].name(), trustedCert[i]);\n+                }\n+            }\n+\n+            \/\/ Import the key materials.\n+            if (endEntityCerts != null && endEntityCerts.length != 0) {\n+                ks = KeyStore.getInstance(\"JKS\");\n+                ks.load(null, null);\n+\n+                for (int i = 0; i < endEntityCerts.length; i++) {\n+                    \/\/ generate the private key.\n+                    PKCS8EncodedKeySpec priKeySpec = new PKCS8EncodedKeySpec(\n+                            Base64.getMimeDecoder().decode(endEntityCerts[i].privKeyStr));\n+                    KeyFactory kf =\n+                            KeyFactory.getInstance(\n+                                    endEntityCerts[i].keyAlgo);\n+                    PrivateKey priKey = kf.generatePrivate(priKeySpec);\n+\n+                    \/\/ generate certificate chain\n+                    is = new ByteArrayInputStream(\n+                            endEntityCerts[i].certStr.getBytes());\n+                    Certificate keyCert = null;\n+                    try {\n+                        keyCert = cf.generateCertificate(is);\n+                    } finally {\n+                        is.close();\n+                    }\n+\n+                    Certificate[] chain = new Certificate[] { keyCert };\n+\n+                    \/\/ import the key entry.\n+                    ks.setKeyEntry(\"cert-\" + endEntityCerts[i].name(),\n+                            priKey, passphrase, chain);\n+                }\n+            }\n+\n+            \/\/ Create an SSLContext object.\n+            TrustManagerFactory tmf =\n+                    TrustManagerFactory.getInstance(params.tmAlgorithm);\n+            tmf.init(ts);\n+\n+            SSLContext context = SSLContext.getInstance(params.contextProtocol);\n+            if (endEntityCerts != null && endEntityCerts.length != 0 && ks != null) {\n+                KeyManagerFactory kmf =\n+                        KeyManagerFactory.getInstance(params.kmAlgorithm);\n+                kmf.init(ks, passphrase);\n+\n+                context.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);\n+            } else {\n+                context.init(null, tmf.getTrustManagers(), null);\n+            }\n+\n+            return context;\n+        }\n+\n+        @Setup\n+        public void createClientHello() throws Exception {\n+            context = createSSLContext(TRUSTED_CERTS, END_ENTITY_CERTS,\n+                    new ContextParameters(\"TLS\", \"PKIX\", \"NewSunX509\"));\n+\n+            SSLEngine clientEngine = context.createSSLEngine(\"localhost\", 80);\n+            clientEngine.setUseClientMode(true);\n+            clientEngine.beginHandshake();\n+            SSLEngineResult result;\n+\n+            result = clientEngine.wrap(ByteBuffer.wrap(new byte[1]), CLIENT_HELLO);\n+            if (result.getHandshakeStatus() != SSLEngineResult.HandshakeStatus.NEED_UNWRAP) {\n+                throw new AssertionError(\"expected NEED_UNWRAP, got \" + result.getHandshakeStatus() + \" \" + result.getStatus());\n+            }\n+            CLIENT_HELLO.flip();\n+        }\n+\n+        public ByteBuffer runServerHandshake() throws IOException {\n+            CLIENT_HELLO.rewind();\n+            SERVER_HELLO.clear();\n+            SSLEngine serverEngine = context.createSSLEngine();\n+            serverEngine.setUseClientMode(false);\n+            serverEngine.setEnabledProtocols(new String[]{\"TLSv1.3\"});\n+            serverEngine.setEnabledCipherSuites(new String[]{\"TLS_AES_256_GCM_SHA384\"});\n+            serverEngine.beginHandshake();\n+            SSLEngineResult result = serverEngine.unwrap(CLIENT_HELLO, EMPTY);\n+            if (result.getHandshakeStatus() != SSLEngineResult.HandshakeStatus.NEED_TASK) {\n+                throw new AssertionError(\"expected NEED_TASK, got \" + result.getHandshakeStatus());\n+            }\n+            Runnable runnable;\n+            while ((runnable = serverEngine.getDelegatedTask()) != null) {\n+                runnable.run();\n+            }\n+            if (serverEngine.getHandshakeStatus() != SSLEngineResult.HandshakeStatus.NEED_WRAP) {\n+                throw new AssertionError(\"expected NEED_WRAP, got \" + serverEngine.getHandshakeStatus());\n+            }\n+            do {\n+                result = serverEngine.wrap(EMPTY, SERVER_HELLO);\n+            } while (result.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_WRAP);\n+            if (result.getHandshakeStatus() != SSLEngineResult.HandshakeStatus.NEED_UNWRAP) {\n+                throw new AssertionError(\"expected NEED_UNWRAP, got \" + result.getHandshakeStatus() + \" \" + result.getStatus());\n+            }\n+            return SERVER_HELLO;\n+        }\n+    }\n+\n+    @Benchmark\n+    public ByteBuffer handshakeBenchmark(SSLStartHandshakeState state) throws IOException {\n+        return state.runServerHandshake();\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/security\/SSLEngineStartHandshake.java","additions":277,"deletions":0,"binary":false,"changes":277,"status":"added"},{"patch":"@@ -1,23 +0,0 @@\n-\/*\n- * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/security\/SSLStartHandshake.java","additions":0,"deletions":23,"binary":false,"changes":23,"status":"modified"}]}