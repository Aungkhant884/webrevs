{"files":[{"patch":"@@ -172,1 +172,1 @@\n-  \/\/ Removes entries as indicated by the given EVAL closure. Single-threaded.\n+  \/\/ Removes entries as indicated by the given EVAL closure.\n@@ -194,16 +194,1 @@\n-  struct G1CodeRootSetHashTableDeleteUnlinked : StackObj {\n-    size_t _num_retained;\n-\n-    G1CodeRootSetHashTableDeleteUnlinked() : _num_retained(0) {}\n-    bool operator()(G1CodeRootSetHashTableValue* value) {\n-      nmethod* unlinked_next = value->_nmethod->unlinked_next();\n-      if (unlinked_next != nullptr) {\n-        return true;\n-      } else {\n-        ++_num_retained;\n-        return false;\n-      }\n-    }\n-  };\n-\n-  \/\/ Removes unlinked entries, multi-threaded.\n+  \/\/ Removes dead\/unlinked entries.\n@@ -211,21 +196,5 @@\n-    assert_at_safepoint();\n-\n-    \/\/ A lot of code root sets are typically empty.\n-    if (is_empty()) {\n-      return;\n-    }\n-\n-    HashTable::BulkDeleteTask bdt(&_table);\n-\n-    bool locked = bdt.prepare(Thread::current());\n-    guarantee(locked, \"must be\");\n-\n-    G1CodeRootSetHashTableDeleteUnlinked delete_check;\n-    HashTableIgnore ignore;\n-    while (bdt.do_task(Thread::current(), delete_check, ignore)) {\n-      \/* do nothing *\/\n-    }\n-    bdt.done(Thread::current());\n-\n-    Atomic::store(&_num_entries, delete_check._num_retained);\n-    shrink_to_match(delete_check._num_retained);\n+    auto delete_check =\n+      [&] (G1CodeRootSetHashTableValue* value) {\n+        return value->_nmethod->unlinked_next() != nullptr;\n+      };\n+    clean(delete_check);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CodeRootSet.cpp","additions":7,"deletions":38,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-\/\/ This class is not thread safe, locks are needed.\n+\/\/ This class is thread safe.\n@@ -38,8 +38,0 @@\n-  friend class G1CodeRootSetTest;\n-  friend class G1CodeRootSetTest_g1_code_cache_rem_set_vm_Test;\n-\n- private:\n-  const static size_t SmallSize = 32;\n-  const static size_t Threshold = 24;\n-  const static size_t LargeSize = 512;\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CodeRootSet.hpp","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,9 +28,1 @@\n-class G1CodeRootSetTest : public ::testing::Test {\n- public:\n-\n-  size_t threshold() {\n-    return G1CodeRootSet::Threshold;\n-  }\n-};\n-\n-TEST_VM_F(G1CodeRootSetTest, g1_code_cache_rem_set) {\n+TEST_VM(G1CodeRootSet, g1_code_cache_rem_set) {\n@@ -46,1 +38,1 @@\n-  const size_t num_to_add = (size_t) threshold() + 1;\n+  const size_t num_to_add = 1000;\n@@ -76,1 +68,1 @@\n-          << \"should have grown to large hashtable\";\n+          << \"should be empty\";\n","filename":"test\/hotspot\/gtest\/gc\/g1\/test_g1CodeRootSet.cpp","additions":3,"deletions":11,"binary":false,"changes":14,"status":"modified"}]}