{"files":[{"patch":"@@ -221,5 +221,0 @@\n-      \/\/ Make sure the deoptee frame gets processed after a potential safepoint during\n-      \/\/ object reallocation. This is necessary because (a) deoptee_thread can be\n-      \/\/ different from the current thread and (b) the deoptee frame does not need to be\n-      \/\/ the top frame.\n-      StackWatermarkSet::finish_processing(deoptee_thread, NULL \/* context *\/, StackWatermarkKind::gc);\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"runtime\/keepStackGCProcessed.hpp\"\n@@ -77,0 +78,1 @@\n+    KeepStackGCProcessedMark ksgcpm(deoptee_thread());\n@@ -113,0 +115,1 @@\n+      KeepStackGCProcessedMark ksgcpm(jt);\n@@ -310,5 +313,1 @@\n-      if (!self_deopt()) {\n-        \/\/ Process stack of deoptee thread as we will access oops during object deoptimization.\n-        StackWatermarkSet::start_processing(deoptee, StackWatermarkKind::gc);\n-      }\n-      StackFrameStream fst(deoptee, true \/* update *\/, true \/* process_frames *\/);\n+      StackFrameStream fst(deoptee, true \/* update *\/, false \/* process_frames *\/);\n","filename":"src\/hotspot\/share\/runtime\/escapeBarrier.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"runtime\/safepoint.hpp\"\n+#include \"runtime\/stackWatermark.inline.hpp\"\n+#include \"runtime\/stackWatermarkSet.inline.hpp\"\n+#include \"runtime\/keepStackGCProcessed.hpp\"\n+\n+KeepStackGCProcessedMark::KeepStackGCProcessedMark(JavaThread* jt) :\n+  _active(true),\n+  _jt(jt) {\n+  finish_processing();\n+  if (!Thread::current()->is_Java_thread()) {\n+    assert(SafepointSynchronize::is_at_safepoint() && Thread::current()->is_VM_thread(),\n+           \"must be either Java thread or VM thread in a safepoint\");\n+    _active = false;\n+    return;\n+  }\n+  StackWatermark* our_watermark = StackWatermarkSet::get(JavaThread::current(), StackWatermarkKind::gc);\n+  if (our_watermark == NULL) {\n+    _active = false;\n+    return;\n+  }\n+  StackWatermark* their_watermark = StackWatermarkSet::get(jt, StackWatermarkKind::gc);\n+  our_watermark->link_watermark(their_watermark);\n+}\n+\n+KeepStackGCProcessedMark::~KeepStackGCProcessedMark() {\n+  if (!_active) {\n+    return;\n+  }\n+  StackWatermark* our_watermark = StackWatermarkSet::get(JavaThread::current(), StackWatermarkKind::gc);\n+  our_watermark->link_watermark(NULL);\n+}\n+\n+void KeepStackGCProcessedMark::finish_processing() {\n+  StackWatermarkSet::finish_processing(_jt, NULL \/* context *\/, StackWatermarkKind::gc);\n+}\n","filename":"src\/hotspot\/share\/runtime\/keepStackGCProcessed.cpp","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_RUNTIME_KEEPSTACKGCPROCESSED_HPP\n+#define SHARE_RUNTIME_KEEPSTACKGCPROCESSED_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"runtime\/stackWatermark.hpp\"\n+#include \"runtime\/stackWatermarkKind.hpp\"\n+#include \"runtime\/stackWatermarkSet.hpp\"\n+\n+\/\/ Use this class to mark a remote thread you are currently interested\n+\/\/ in examining the entire stack, without it slipping into an unprocessed\n+\/\/ state at safepoint polls.\n+class KeepStackGCProcessedMark : public StackObj {\n+  friend class StackWatermark;\n+  bool _active;\n+  JavaThread* _jt;\n+\n+  void finish_processing();\n+\n+public:\n+  KeepStackGCProcessedMark(JavaThread* jt);\n+  ~KeepStackGCProcessedMark();\n+};\n+\n+\n+#endif \/\/ SHARE_RUNTIME_KEEPSTACKGCPROCESSED_HPP\n","filename":"src\/hotspot\/share\/runtime\/keepStackGCProcessed.hpp","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -92,1 +92,1 @@\n-  StackWatermarkSet::start_processing(thread, StackWatermarkKind::gc);\n+  StackWatermarkSet::on_safepoint(thread);\n","filename":"src\/hotspot\/share\/runtime\/safepointMechanism.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -166,1 +166,2 @@\n-    _kind(kind) {\n+    _kind(kind),\n+    _linked_watermark(NULL) {\n@@ -283,0 +284,8 @@\n+void StackWatermark::on_safepoint() {\n+  start_processing();\n+  StackWatermark* linked_watermark = _linked_watermark;\n+  if (linked_watermark != NULL) {\n+    linked_watermark->finish_processing(NULL \/* context *\/);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/stackWatermark.cpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"runtime\/mutex.hpp\"\n@@ -95,0 +96,1 @@\n+  StackWatermark* _linked_watermark;\n@@ -130,0 +132,2 @@\n+  void link_watermark(StackWatermark* watermark) { _linked_watermark = watermark; }\n+\n@@ -142,0 +146,1 @@\n+  void on_safepoint();\n","filename":"src\/hotspot\/share\/runtime\/stackWatermark.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"code\/nmethod.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/stackWatermark.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -112,0 +112,7 @@\n+void StackWatermarkSet::on_safepoint(JavaThread* jt) {\n+  StackWatermark* watermark = get(jt, StackWatermarkKind::gc);\n+  if (watermark != NULL) {\n+    watermark->on_safepoint();\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/stackWatermarkSet.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -76,0 +76,3 @@\n+  \/\/ Called to ensure that processing of the thread is started when waking up from safepoint\n+  static void on_safepoint(JavaThread* jt);\n+\n","filename":"src\/hotspot\/share\/runtime\/stackWatermarkSet.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"}]}