{"files":[{"patch":"@@ -1656,11 +1656,3 @@\n-  if (eb.barrier_active()) {\n-    if (java_thread->frames_to_pop_failed_realloc() > 0) {\n-      \/\/ VM is in the process of popping the top frame because it has scalar replaced objects which\n-      \/\/ could not be reallocated on the heap.\n-      \/\/ Return JVMTI_ERROR_OUT_OF_MEMORY to avoid interfering with the VM.\n-      return JVMTI_ERROR_OUT_OF_MEMORY;\n-    }\n-    if (!eb.deoptimize_objects(1)) {\n-      \/\/ Reallocation of scalar replaced objects failed -> return with error\n-      return JVMTI_ERROR_OUT_OF_MEMORY;\n-    }\n+  if (!eb.deoptimize_objects(1)) {\n+    \/\/ Reallocation of scalar replaced objects failed -> return with error\n+    return JVMTI_ERROR_OUT_OF_MEMORY;\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":3,"deletions":11,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1381,11 +1381,3 @@\n-  if (eb.barrier_active()) {\n-    if (java_thread->frames_to_pop_failed_realloc() > 0) {\n-      \/\/ VM is in the process of popping the top frame because it has scalar replaced objects\n-      \/\/ which could not be reallocated on the heap.\n-      \/\/ Return JVMTI_ERROR_OUT_OF_MEMORY to avoid interfering with the VM.\n-      return JVMTI_ERROR_OUT_OF_MEMORY;\n-    }\n-    if (!eb.deoptimize_objects(0)) {\n-      \/\/ Reallocation of scalar replaced objects failed -> return with error\n-      return JVMTI_ERROR_OUT_OF_MEMORY;\n-    }\n+  if (!eb.deoptimize_objects(0)) {\n+    \/\/ Reallocation of scalar replaced objects failed -> return with error\n+    return JVMTI_ERROR_OUT_OF_MEMORY;\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":3,"deletions":11,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -631,6 +631,3 @@\n-\/\/ Revert optimizations based on escape analysis if this is an access to a local object\n-bool VM_GetOrSetLocal::deoptimize_objects(javaVFrame* jvf) {\n-#if COMPILER2_OR_JVMCI\n-  assert(_type == T_OBJECT, \"EscapeBarrier should not be active if _type != T_OBJECT\");\n-  if (_depth < _thread->frames_to_pop_failed_realloc()) {\n-    \/\/ cannot access frame with failed reallocations\n+bool VM_GetOrSetLocal::doit_prologue() {\n+  if (!_eb.deoptimize_objects(_depth, _depth)) {\n+    \/\/ The target frame is affected by a reallocation failure.\n@@ -640,43 +637,0 @@\n-  if (can_be_deoptimized(jvf)) {\n-    compiledVFrame* cf = compiledVFrame::cast(jvf);\n-    if (cf->has_ea_local_in_scope() && !_eb.deoptimize_objects(cf->fr().id())) {\n-      \/\/ reallocation of scalar replaced objects failed because heap is exhausted\n-      _result = JVMTI_ERROR_OUT_OF_MEMORY;\n-      return false;\n-    }\n-  }\n-\n-  \/\/ With this access the object could escape the thread changing its escape state from ArgEscape,\n-  \/\/ to GlobalEscape so we must deoptimize callers which could have optimized on the escape state.\n-  vframe* vf = jvf;\n-  do {\n-    \/\/ move to next physical frame\n-    while(!vf->is_top()) {\n-      vf = vf->sender();\n-    }\n-    vf = vf->sender();\n-\n-    if (vf != NULL && vf->is_compiled_frame()) {\n-      compiledVFrame* cvf = compiledVFrame::cast(vf);\n-      \/\/ Deoptimize objects if arg escape is being passed down the stack.\n-      \/\/ Note that deoptimizing the frame is not enough because objects need to be relocked\n-      if (cvf->arg_escape() && !_eb.deoptimize_objects(cvf->fr().id())) {\n-        \/\/ reallocation of scalar replaced objects failed because heap is exhausted\n-        _result = JVMTI_ERROR_OUT_OF_MEMORY;\n-        return false;\n-      }\n-    }\n-  } while(vf != NULL && !vf->is_entry_frame());\n-#endif \/\/ COMPILER2_OR_JVMCI\n-  return true;\n-}\n-\n-bool VM_GetOrSetLocal::doit_prologue() {\n-  if (_eb.barrier_active()) {\n-    _jvf = get_java_vframe();\n-    NULL_CHECK(_jvf, false);\n-\n-    if (!deoptimize_objects(_jvf)) {\n-      return false;\n-    }\n-  }\n","filename":"src\/hotspot\/share\/prims\/jvmtiImpl.cpp","additions":3,"deletions":49,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -337,1 +337,0 @@\n-  bool deoptimize_objects(javaVFrame* vf);\n","filename":"src\/hotspot\/share\/prims\/jvmtiImpl.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -221,5 +221,0 @@\n-      \/\/ Make sure the deoptee frame gets processed after a potential safepoint during\n-      \/\/ object reallocation. This is necessary because (a) deoptee_thread can be\n-      \/\/ different from the current thread and (b) the deoptee frame does not need to be\n-      \/\/ the top frame.\n-      StackWatermarkSet::finish_processing(deoptee_thread, NULL \/* context *\/, StackWatermarkKind::gc);\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"runtime\/keepStackGCProcessed.hpp\"\n@@ -65,11 +66,11 @@\n-\/\/ Object references of frames up to the given depth are about to be\n-\/\/ accessed. Frames with optimizations based on escape state that is potentially\n-\/\/ changed by the accesses need to be deoptimized and the referenced objects\n-\/\/ need to be reallocated and relocked.  Up to depth this is done for frames\n-\/\/ with not escaping objects in scope. For deeper frames it is done only if\n-\/\/ they pass not escaping objects as arguments because they potentially escape\n-\/\/ from callee frames within the given depth.\n-\/\/ The search for deeper frames is ended if an entry frame is found because\n-\/\/ arguments to native methods are considered to escape globally.\n-bool EscapeBarrier::deoptimize_objects(int depth) {\n-  if (barrier_active() && deoptee_thread()->has_last_Java_frame()) {\n+\/\/ Deoptimize objects of frames of the target thread at depth >= d1 and depth <= d2.\n+\/\/ Deoptimize objects of caller frames if they passed references to ArgEscape objects as arguments.\n+\/\/ Return false in the case of a reallocation failure and true otherwise.\n+bool EscapeBarrier::deoptimize_objects(int d1, int d2) {\n+  if (!barrier_active()) return true;\n+  if (d1 < deoptee_thread()->frames_to_pop_failed_realloc()) {\n+    \/\/ The deoptee thread has frames with reallocation failures on top of its stack.\n+    \/\/ These frames are about to be removed. We must not interfere with that and signal failure.\n+    return false;\n+  }\n+  if (deoptee_thread()->has_last_Java_frame()) {\n@@ -77,0 +78,1 @@\n+    KeepStackGCProcessedMark ksgcpm(deoptee_thread());\n@@ -82,1 +84,8 @@\n-    while (vf != NULL && ((cur_depth <= depth) || !vf->is_entry_frame())) {\n+\n+    \/\/ Skip frames at depth < d1\n+    while (vf != NULL && cur_depth < d1) {\n+      cur_depth++;\n+      vf = vf->sender();\n+    }\n+\n+    while (vf != NULL && ((cur_depth <= d2) || !vf->is_entry_frame())) {\n@@ -87,1 +96,1 @@\n-        bool should_deopt = cur_depth <= depth ? cvf->has_ea_local_in_scope() : cvf->arg_escape();\n+        bool should_deopt = cur_depth <= d2 ? cvf->has_ea_local_in_scope() : cvf->arg_escape();\n@@ -112,0 +121,5 @@\n+    if (jt->frames_to_pop_failed_realloc() > 0) {\n+      \/\/ The deoptee thread jt has frames with reallocation failures on top of its stack.\n+      \/\/ These frames are about to be removed. We must not interfere with that and signal failure.\n+      return false;\n+    }\n@@ -113,0 +127,1 @@\n+      KeepStackGCProcessedMark ksgcpm(jt);\n@@ -300,1 +315,1 @@\n-  if (!barrier_active()) return true;\n+  assert(barrier_active(), \"should not call\");\n@@ -310,5 +325,1 @@\n-      if (!self_deopt()) {\n-        \/\/ Process stack of deoptee thread as we will access oops during object deoptimization.\n-        StackWatermarkSet::start_processing(deoptee, StackWatermarkKind::gc);\n-      }\n-      StackFrameStream fst(deoptee, true \/* update *\/, true \/* process_frames *\/);\n+      StackFrameStream fst(deoptee, true \/* update *\/, false \/* process_frames *\/);\n","filename":"src\/hotspot\/share\/runtime\/escapeBarrier.cpp","additions":30,"deletions":19,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -64,0 +64,6 @@\n+  \/\/ Deoptimize objects, i.e. reallocate and relock them. The target frames are deoptimized.\n+  \/\/ The methods return false iff at least one reallocation failed.\n+  bool deoptimize_objects(intptr_t* fr_id) {\n+    return deoptimize_objects_internal(deoptee_thread(), fr_id);\n+  }\n+\n@@ -92,4 +98,5 @@\n-  \/\/ Deoptimize objects, i.e. reallocate and relock them. The target frames are deoptimized.\n-  \/\/ The methods return false iff at least one reallocation failed.\n-  bool deoptimize_objects(intptr_t* fr_id) {\n-    return true COMPILER2_OR_JVMCI_PRESENT(&& deoptimize_objects_internal(deoptee_thread(), fr_id));\n+  \/\/ Deoptimize objects of frames of the target thread up to the given depth.\n+  \/\/ Deoptimize objects of caller frames if they passed references to ArgEscape objects as arguments.\n+  \/\/ Return false in the case of a reallocation failure and true otherwise.\n+  bool deoptimize_objects(int depth) {\n+    return deoptimize_objects(0, depth);\n@@ -98,1 +105,4 @@\n-  bool deoptimize_objects(int depth)                           NOT_COMPILER2_OR_JVMCI_RETURN_(true);\n+  \/\/ Deoptimize objects of frames of the target thread at depth >= d1 and depth <= d2.\n+  \/\/ Deoptimize objects of caller frames if they passed references to ArgEscape objects as arguments.\n+  \/\/ Return false in the case of a reallocation failure and true otherwise.\n+  bool deoptimize_objects(int d1, int d2)                      NOT_COMPILER2_OR_JVMCI_RETURN_(true);\n","filename":"src\/hotspot\/share\/runtime\/escapeBarrier.hpp","additions":15,"deletions":5,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"runtime\/safepoint.hpp\"\n+#include \"runtime\/stackWatermark.inline.hpp\"\n+#include \"runtime\/stackWatermarkSet.inline.hpp\"\n+#include \"runtime\/keepStackGCProcessed.hpp\"\n+\n+KeepStackGCProcessedMark::KeepStackGCProcessedMark(JavaThread* jt) :\n+  _active(true),\n+  _jt(jt) {\n+  finish_processing();\n+  if (!Thread::current()->is_Java_thread()) {\n+    assert(SafepointSynchronize::is_at_safepoint() && Thread::current()->is_VM_thread(),\n+           \"must be either Java thread or VM thread in a safepoint\");\n+    _active = false;\n+    return;\n+  }\n+  StackWatermark* our_watermark = StackWatermarkSet::get(JavaThread::current(), StackWatermarkKind::gc);\n+  if (our_watermark == NULL) {\n+    _active = false;\n+    return;\n+  }\n+  StackWatermark* their_watermark = StackWatermarkSet::get(jt, StackWatermarkKind::gc);\n+  our_watermark->link_watermark(their_watermark);\n+}\n+\n+KeepStackGCProcessedMark::~KeepStackGCProcessedMark() {\n+  if (!_active) {\n+    return;\n+  }\n+  StackWatermark* our_watermark = StackWatermarkSet::get(JavaThread::current(), StackWatermarkKind::gc);\n+  our_watermark->link_watermark(NULL);\n+}\n+\n+void KeepStackGCProcessedMark::finish_processing() {\n+  StackWatermarkSet::finish_processing(_jt, NULL \/* context *\/, StackWatermarkKind::gc);\n+}\n","filename":"src\/hotspot\/share\/runtime\/keepStackGCProcessed.cpp","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_RUNTIME_KEEPSTACKGCPROCESSED_HPP\n+#define SHARE_RUNTIME_KEEPSTACKGCPROCESSED_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"runtime\/stackWatermark.hpp\"\n+#include \"runtime\/stackWatermarkKind.hpp\"\n+#include \"runtime\/stackWatermarkSet.hpp\"\n+\n+\/\/ Use this class to mark a remote thread you are currently interested\n+\/\/ in examining the entire stack, without it slipping into an unprocessed\n+\/\/ state at safepoint polls.\n+class KeepStackGCProcessedMark : public StackObj {\n+  friend class StackWatermark;\n+  bool _active;\n+  JavaThread* _jt;\n+\n+  void finish_processing();\n+\n+public:\n+  KeepStackGCProcessedMark(JavaThread* jt);\n+  ~KeepStackGCProcessedMark();\n+};\n+\n+\n+#endif \/\/ SHARE_RUNTIME_KEEPSTACKGCPROCESSED_HPP\n","filename":"src\/hotspot\/share\/runtime\/keepStackGCProcessed.hpp","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -86,1 +86,1 @@\n-  \/\/ The call to start_processing fixes the thread's oops and the first few frames.\n+  \/\/ The call to on_safepoint fixes the thread's oops and the first few frames.\n@@ -92,1 +92,1 @@\n-  StackWatermarkSet::start_processing(thread, StackWatermarkKind::gc);\n+  StackWatermarkSet::on_safepoint(thread);\n","filename":"src\/hotspot\/share\/runtime\/safepointMechanism.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -166,1 +166,2 @@\n-    _kind(kind) {\n+    _kind(kind),\n+    _linked_watermark(NULL) {\n@@ -250,0 +251,5 @@\n+void StackWatermark::link_watermark(StackWatermark* watermark) {\n+  assert(watermark == NULL || _linked_watermark == NULL, \"nesting not supported\");\n+  _linked_watermark = watermark;\n+}\n+\n@@ -283,0 +289,8 @@\n+void StackWatermark::on_safepoint() {\n+  start_processing();\n+  StackWatermark* linked_watermark = _linked_watermark;\n+  if (linked_watermark != NULL) {\n+    linked_watermark->finish_processing(NULL \/* context *\/);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/stackWatermark.cpp","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"runtime\/mutex.hpp\"\n@@ -95,0 +96,1 @@\n+  StackWatermark* _linked_watermark;\n@@ -130,0 +132,2 @@\n+  void link_watermark(StackWatermark* watermark);\n+\n@@ -142,0 +146,1 @@\n+  void on_safepoint();\n","filename":"src\/hotspot\/share\/runtime\/stackWatermark.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"code\/nmethod.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/stackWatermark.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -112,0 +112,7 @@\n+void StackWatermarkSet::on_safepoint(JavaThread* jt) {\n+  StackWatermark* watermark = get(jt, StackWatermarkKind::gc);\n+  if (watermark != NULL) {\n+    watermark->on_safepoint();\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/stackWatermarkSet.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -76,0 +76,3 @@\n+  \/\/ Called to ensure that processing of the thread is started when waking up from safepoint\n+  static void on_safepoint(JavaThread* jt);\n+\n","filename":"src\/hotspot\/share\/runtime\/stackWatermarkSet.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"}]}