{"files":[{"patch":"@@ -1656,11 +1656,3 @@\n-  if (eb.barrier_active()) {\n-    if (java_thread->frames_to_pop_failed_realloc() > 0) {\n-      \/\/ VM is in the process of popping the top frame because it has scalar replaced objects which\n-      \/\/ could not be reallocated on the heap.\n-      \/\/ Return JVMTI_ERROR_OUT_OF_MEMORY to avoid interfering with the VM.\n-      return JVMTI_ERROR_OUT_OF_MEMORY;\n-    }\n-    if (!eb.deoptimize_objects(1)) {\n-      \/\/ Reallocation of scalar replaced objects failed -> return with error\n-      return JVMTI_ERROR_OUT_OF_MEMORY;\n-    }\n+  if (!eb.deoptimize_objects(1)) {\n+    \/\/ Reallocation of scalar replaced objects failed -> return with error\n+    return JVMTI_ERROR_OUT_OF_MEMORY;\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":3,"deletions":11,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1381,11 +1381,3 @@\n-  if (eb.barrier_active()) {\n-    if (java_thread->frames_to_pop_failed_realloc() > 0) {\n-      \/\/ VM is in the process of popping the top frame because it has scalar replaced objects\n-      \/\/ which could not be reallocated on the heap.\n-      \/\/ Return JVMTI_ERROR_OUT_OF_MEMORY to avoid interfering with the VM.\n-      return JVMTI_ERROR_OUT_OF_MEMORY;\n-    }\n-    if (!eb.deoptimize_objects(0)) {\n-      \/\/ Reallocation of scalar replaced objects failed -> return with error\n-      return JVMTI_ERROR_OUT_OF_MEMORY;\n-    }\n+  if (!eb.deoptimize_objects(0)) {\n+    \/\/ Reallocation of scalar replaced objects failed -> return with error\n+    return JVMTI_ERROR_OUT_OF_MEMORY;\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":3,"deletions":11,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -631,6 +631,3 @@\n-\/\/ Revert optimizations based on escape analysis if this is an access to a local object\n-bool VM_GetOrSetLocal::deoptimize_objects(javaVFrame* jvf) {\n-#if COMPILER2_OR_JVMCI\n-  assert(_type == T_OBJECT, \"EscapeBarrier should not be active if _type != T_OBJECT\");\n-  if (_depth < _thread->frames_to_pop_failed_realloc()) {\n-    \/\/ cannot access frame with failed reallocations\n+bool VM_GetOrSetLocal::doit_prologue() {\n+  if (!_eb.deoptimize_objects(_depth, _depth)) {\n+    \/\/ The target frame is affected by a reallocation failure.\n@@ -640,43 +637,0 @@\n-  if (can_be_deoptimized(jvf)) {\n-    compiledVFrame* cf = compiledVFrame::cast(jvf);\n-    if (cf->has_ea_local_in_scope() && !_eb.deoptimize_objects(cf->fr().id())) {\n-      \/\/ reallocation of scalar replaced objects failed because heap is exhausted\n-      _result = JVMTI_ERROR_OUT_OF_MEMORY;\n-      return false;\n-    }\n-  }\n-\n-  \/\/ With this access the object could escape the thread changing its escape state from ArgEscape,\n-  \/\/ to GlobalEscape so we must deoptimize callers which could have optimized on the escape state.\n-  vframe* vf = jvf;\n-  do {\n-    \/\/ move to next physical frame\n-    while(!vf->is_top()) {\n-      vf = vf->sender();\n-    }\n-    vf = vf->sender();\n-\n-    if (vf != NULL && vf->is_compiled_frame()) {\n-      compiledVFrame* cvf = compiledVFrame::cast(vf);\n-      \/\/ Deoptimize objects if arg escape is being passed down the stack.\n-      \/\/ Note that deoptimizing the frame is not enough because objects need to be relocked\n-      if (cvf->arg_escape() && !_eb.deoptimize_objects(cvf->fr().id())) {\n-        \/\/ reallocation of scalar replaced objects failed because heap is exhausted\n-        _result = JVMTI_ERROR_OUT_OF_MEMORY;\n-        return false;\n-      }\n-    }\n-  } while(vf != NULL && !vf->is_entry_frame());\n-#endif \/\/ COMPILER2_OR_JVMCI\n-  return true;\n-}\n-\n-bool VM_GetOrSetLocal::doit_prologue() {\n-  if (_eb.barrier_active()) {\n-    _jvf = get_java_vframe();\n-    NULL_CHECK(_jvf, false);\n-\n-    if (!deoptimize_objects(_jvf)) {\n-      return false;\n-    }\n-  }\n","filename":"src\/hotspot\/share\/prims\/jvmtiImpl.cpp","additions":3,"deletions":49,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -337,1 +337,0 @@\n-  bool deoptimize_objects(javaVFrame* vf);\n","filename":"src\/hotspot\/share\/prims\/jvmtiImpl.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -66,11 +66,11 @@\n-\/\/ Object references of frames up to the given depth are about to be\n-\/\/ accessed. Frames with optimizations based on escape state that is potentially\n-\/\/ changed by the accesses need to be deoptimized and the referenced objects\n-\/\/ need to be reallocated and relocked.  Up to depth this is done for frames\n-\/\/ with not escaping objects in scope. For deeper frames it is done only if\n-\/\/ they pass not escaping objects as arguments because they potentially escape\n-\/\/ from callee frames within the given depth.\n-\/\/ The search for deeper frames is ended if an entry frame is found because\n-\/\/ arguments to native methods are considered to escape globally.\n-bool EscapeBarrier::deoptimize_objects(int depth) {\n-  if (barrier_active() && deoptee_thread()->has_last_Java_frame()) {\n+\/\/ Deoptimize objects of frames of the target thread at depth >= d1 and depth <= d2.\n+\/\/ Deoptimize objects of caller frames if they passed references to ArgEscape objects as arguments.\n+\/\/ Return false in the case of a reallocation failure and true otherwise.\n+bool EscapeBarrier::deoptimize_objects(int d1, int d2) {\n+  if (!barrier_active()) return true;\n+  if (d1 < deoptee_thread()->frames_to_pop_failed_realloc()) {\n+    \/\/ The deoptee thread has frames with reallocation failures on top of its stack.\n+    \/\/ These frames are about to be removed. We must not interfere with that and signal failure.\n+    return false;\n+  }\n+  if (deoptee_thread()->has_last_Java_frame()) {\n@@ -84,1 +84,8 @@\n-    while (vf != NULL && ((cur_depth <= depth) || !vf->is_entry_frame())) {\n+\n+    \/\/ Skip frames at depth < d1\n+    while (vf != NULL && cur_depth < d1) {\n+      cur_depth++;\n+      vf = vf->sender();\n+    }\n+\n+    while (vf != NULL && ((cur_depth <= d2) || !vf->is_entry_frame())) {\n@@ -89,1 +96,1 @@\n-        bool should_deopt = cur_depth <= depth ? cvf->has_ea_local_in_scope() : cvf->arg_escape();\n+        bool should_deopt = cur_depth <= d2 ? cvf->has_ea_local_in_scope() : cvf->arg_escape();\n@@ -114,0 +121,5 @@\n+    if (jt->frames_to_pop_failed_realloc() > 0) {\n+      \/\/ The deoptee thread jt has frames with reallocation failures on top of its stack.\n+      \/\/ These frames are about to be removed. We must not interfere with that and signal failure.\n+      return false;\n+    }\n@@ -303,1 +315,1 @@\n-  if (!barrier_active()) return true;\n+  assert(barrier_active(), \"should not call\");\n","filename":"src\/hotspot\/share\/runtime\/escapeBarrier.cpp","additions":26,"deletions":14,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -64,0 +64,6 @@\n+  \/\/ Deoptimize objects, i.e. reallocate and relock them. The target frames are deoptimized.\n+  \/\/ The methods return false iff at least one reallocation failed.\n+  bool deoptimize_objects(intptr_t* fr_id) {\n+    return deoptimize_objects_internal(deoptee_thread(), fr_id);\n+  }\n+\n@@ -92,4 +98,5 @@\n-  \/\/ Deoptimize objects, i.e. reallocate and relock them. The target frames are deoptimized.\n-  \/\/ The methods return false iff at least one reallocation failed.\n-  bool deoptimize_objects(intptr_t* fr_id) {\n-    return true COMPILER2_OR_JVMCI_PRESENT(&& deoptimize_objects_internal(deoptee_thread(), fr_id));\n+  \/\/ Deoptimize objects of frames of the target thread up to the given depth.\n+  \/\/ Deoptimize objects of caller frames if they passed references to ArgEscape objects as arguments.\n+  \/\/ Return false in the case of a reallocation failure and true otherwise.\n+  bool deoptimize_objects(int depth) {\n+    return deoptimize_objects(0, depth);\n@@ -98,1 +105,4 @@\n-  bool deoptimize_objects(int depth)                           NOT_COMPILER2_OR_JVMCI_RETURN_(true);\n+  \/\/ Deoptimize objects of frames of the target thread at depth >= d1 and depth <= d2.\n+  \/\/ Deoptimize objects of caller frames if they passed references to ArgEscape objects as arguments.\n+  \/\/ Return false in the case of a reallocation failure and true otherwise.\n+  bool deoptimize_objects(int d1, int d2)                      NOT_COMPILER2_OR_JVMCI_RETURN_(true);\n","filename":"src\/hotspot\/share\/runtime\/escapeBarrier.hpp","additions":15,"deletions":5,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-  \/\/ The call to start_processing fixes the thread's oops and the first few frames.\n+  \/\/ The call to on_safepoint fixes the thread's oops and the first few frames.\n","filename":"src\/hotspot\/share\/runtime\/safepointMechanism.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -251,0 +251,5 @@\n+void StackWatermark::link_watermark(StackWatermark* watermark) {\n+  assert(watermark == NULL || _linked_watermark == NULL, \"nesting not supported\");\n+  _linked_watermark = watermark;\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/stackWatermark.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -132,1 +132,1 @@\n-  void link_watermark(StackWatermark* watermark) { _linked_watermark = watermark; }\n+  void link_watermark(StackWatermark* watermark);\n","filename":"src\/hotspot\/share\/runtime\/stackWatermark.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}