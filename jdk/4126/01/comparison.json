{"files":[{"patch":"@@ -40,3 +40,8 @@\n-  \/\/ We use javaTimeMillis so this can be correlated with\n-  \/\/ external timestamps.\n-  const jlong now = os::javaTimeMillis() * JfrTimeConverter::NANOS_PER_MILLISEC;\n+\n+  jlong seconds;\n+  jlong nanos;\n+  \/\/ Use same clock source as Instant.now() to ensure\n+  \/\/ that Recording::getStopTime() returns an Instant that\n+  \/\/ is in sync.\n+  os::javaTimeSystemUTC(seconds, nanos);\n+  const jlong now = seconds * 1000000000 + nanos;\n@@ -45,2 +50,0 @@\n-  } else {\n-    ++last;\n@@ -127,1 +130,0 @@\n-  assert(_start_nanos != 0, \"invariant\");\n@@ -147,2 +149,2 @@\n-  assert(now > _start_nanos, \"invariant\");\n-  assert(now > _last_update_nanos, \"invariant\");\n+  assert(now >= _start_nanos, \"invariant\");\n+  assert(now >= _last_update_nanos, \"invariant\");\n@@ -154,1 +156,1 @@\n-  assert(now > _last_update_nanos, \"invariant\");\n+  assert(now >= _last_update_nanos, \"invariant\");\n","filename":"src\/hotspot\/share\/jfr\/recorder\/repository\/jfrChunk.cpp","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -257,1 +257,1 @@\n-  return this->is_valid() ? _chunk->start_nanos() : invalid_time;\n+  return _chunk->start_nanos();\n","filename":"src\/hotspot\/share\/jfr\/recorder\/repository\/jfrChunkWriter.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.nio.file.Path;\n@@ -36,0 +37,1 @@\n+import java.util.Objects;\n@@ -43,0 +45,1 @@\n+import jdk.jfr.RecordingState;\n@@ -404,0 +407,35 @@\n+    \/**\n+     * Writes recording data to a file.\n+     * <p>\n+     * The recording stream must be started, but not closed.\n+     * <p>\n+     * It's highly recommended that a max age or max size is set before\n+     * starting the stream. Otherwise, the dump may not contain any events.\n+     *\n+     * @param destination the location where recording data is written, not\n+     *        {@code null}\n+     *\n+     * @throws IOException if the recording data can't be copied to the specified\n+     *         location, or if the stream is closed, or not started.\n+     *\n+     * @throws SecurityException if a security manager exists and the caller doesn't\n+     *         have {@code FilePermission} to write to the destination path\n+     *\n+     * @see RecordingStream#setMaxAge(Duration)\n+     * @see RecordingStream#setMaxSize(Duration)\n+     *\/\n+    public void dump(Path destination) throws IOException {\n+        Objects.requireNonNull(destination);\n+        Object recorder = PrivateAccess.getInstance().getPlatformRecorder();\n+        synchronized (recorder) {\n+            RecordingState state = recording.getState();\n+            if (state == RecordingState.CLOSED) {\n+                throw new IOException(\"Recording stream has been closed, no content to write\");\n+            }\n+            if (state == RecordingState.NEW) {\n+                throw new IOException(\"Recording stream has not been started, no content to write\");\n+            }\n+            recording.dump(destination);\n+        }\n+    }\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/RecordingStream.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+import java.time.Instant;\n@@ -65,0 +66,1 @@\n+    private Instant outputChange;\n@@ -266,1 +268,1 @@\n-    synchronized void setOutput(String filename) {\n+    synchronized Instant setOutput(String filename) {\n@@ -270,0 +272,1 @@\n+        awaitUniqueTimestamp();\n@@ -271,0 +274,1 @@\n+        long nanos = jvm.getChunkStartNanos();\n@@ -281,0 +285,23 @@\n+        return Utils.epochNanosToInstant(nanos);\n+    }\n+\n+    \/\/ Each chunk needs a unique start timestamp and\n+    \/\/ if the clock resolution is low, two chunks may\n+    \/\/ get the same timestamp.\n+    private void awaitUniqueTimestamp() {\n+        if (outputChange == null) {\n+            outputChange = Instant.now();\n+            return;\n+        }\n+        while (true) {\n+            Instant time = Instant.now();\n+            if (!time.equals(outputChange)) {\n+                outputChange = time;\n+                return;\n+            }\n+            try {\n+                Thread.sleep(0, 100);\n+            } catch (InterruptedException iex) {\n+                \/\/ ignore\n+            }\n+        }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/MetadataRepository.java","additions":29,"deletions":2,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -224,8 +224,1 @@\n-        ZonedDateTime zdtNow = ZonedDateTime.now();\n-        Instant now = zdtNow.toInstant();\n-        recording.setStartTime(now);\n-        recording.updateTimer();\n-        Duration duration = recording.getDuration();\n-        if (duration != null) {\n-            recording.setStopTime(now.plus(duration));\n-        }\n+        Instant startTime = null;\n@@ -248,1 +241,1 @@\n-                newChunk = repository.newChunk(zdtNow);\n+                newChunk = repository.newChunk();\n@@ -259,0 +252,4 @@\n+            startTime = Utils.epochNanosToInstant(startNanos);\n+            if (currentChunk != null) {\n+                currentChunk.setStartTime(startTime);\n+            }\n@@ -261,0 +258,1 @@\n+            recording.setStartTime(startTime);\n@@ -265,1 +263,1 @@\n-                newChunk = repository.newChunk(zdtNow);\n+                newChunk = repository.newChunk();\n@@ -270,2 +268,3 @@\n-                MetadataRepository.getInstance().setOutput(newChunk.getFile().toString());\n-                startNanos = jvm.getChunkStartNanos();\n+                String p = newChunk.getFile().toString();\n+                startTime = MetadataRepository.getInstance().setOutput(p);\n+                newChunk.setStartTime(startTime);\n@@ -273,0 +272,3 @@\n+            startNanos = jvm.getChunkStartNanos();\n+            startTime = Utils.epochNanosToInstant(startNanos);\n+            recording.setStartTime(startTime);\n@@ -277,1 +279,1 @@\n-                finishChunk(currentChunk, now, recording);\n+                finishChunk(currentChunk, startTime, recording);\n@@ -285,1 +287,5 @@\n-\n+        Duration duration = recording.getDuration();\n+        if (duration != null) {\n+            recording.setStopTime(startTime.plus(duration));\n+        }\n+        recording.updateTimer();\n@@ -291,0 +297,1 @@\n+        Instant stopTime;\n@@ -298,2 +305,0 @@\n-        ZonedDateTime zdtNow = ZonedDateTime.now();\n-        Instant now = zdtNow.toInstant();\n@@ -319,7 +324,2 @@\n-                if (currentChunk != null) {\n-                    if (inShutdown) {\n-                        jvm.markChunkFinal();\n-                    }\n-                    MetadataRepository.getInstance().setOutput(null);\n-                    finishChunk(currentChunk, now, null);\n-                    currentChunk = null;\n+                if (inShutdown) {\n+                    jvm.markChunkFinal();\n@@ -327,0 +327,3 @@\n+                stopTime = MetadataRepository.getInstance().setOutput(null);\n+                finishChunk(currentChunk, stopTime, null);\n+                currentChunk = null;\n@@ -329,1 +332,1 @@\n-                dumpMemoryToDestination(recording);\n+                stopTime = dumpMemoryToDestination(recording);\n@@ -332,0 +335,1 @@\n+            recording.setStopTime(stopTime);\n@@ -337,0 +341,2 @@\n+\n+            String path = null;\n@@ -338,4 +344,6 @@\n-                newChunk = repository.newChunk(zdtNow);\n-                MetadataRepository.getInstance().setOutput(newChunk.getFile().toString());\n-            } else {\n-                MetadataRepository.getInstance().setOutput(null);\n+                newChunk = repository.newChunk();\n+                path = newChunk.getFile().toString();\n+            }\n+            stopTime = MetadataRepository.getInstance().setOutput(path);\n+            if (toDisk) {\n+                newChunk.setStartTime(stopTime);\n@@ -343,0 +351,1 @@\n+            recording.setStopTime(stopTime);\n@@ -345,1 +354,1 @@\n-                finishChunk(currentChunk, now, null);\n+                finishChunk(currentChunk, stopTime, null);\n@@ -362,1 +371,1 @@\n-    private void dumpMemoryToDestination(PlatformRecording recording)  {\n+    private Instant dumpMemoryToDestination(PlatformRecording recording)  {\n@@ -365,1 +374,1 @@\n-            MetadataRepository.getInstance().setOutput(dest.getRealPathText());\n+            Instant t = MetadataRepository.getInstance().setOutput(dest.getRealPathText());\n@@ -367,0 +376,1 @@\n+            return t;\n@@ -368,0 +378,1 @@\n+        return Instant.now();\n@@ -391,2 +402,1 @@\n-        ZonedDateTime now = ZonedDateTime.now();\n-        RepositoryChunk newChunk = repository.newChunk(now);\n+        RepositoryChunk newChunk = repository.newChunk();\n@@ -394,1 +404,3 @@\n-        MetadataRepository.getInstance().setOutput(newChunk.getFile().toString());\n+        String path = newChunk.getFile().toString();\n+        Instant timestamp = MetadataRepository.getInstance().setOutput(path);\n+        newChunk.setStartTime(timestamp);\n@@ -397,1 +409,1 @@\n-            finishChunk(currentChunk, now.toInstant(), null);\n+            finishChunk(currentChunk, timestamp, null);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/PlatformRecorder.java","additions":48,"deletions":36,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -167,1 +167,0 @@\n-            this.stopTime = Instant.now();\n@@ -318,1 +317,1 @@\n-            throw new IOException(\"Recording \\\"\" + name + \"\\\" (id=\" + id + \") has been closed, no contents to write\");\n+            throw new IOException(\"Recording \\\"\" + name + \"\\\" (id=\" + id + \") has been closed, no content to write\");\n@@ -321,1 +320,1 @@\n-            throw new IOException(\"Recording \\\"\" + name + \"\\\" (id=\" + id + \") has not started, no contents to write\");\n+            throw new IOException(\"Recording \\\"\" + name + \"\\\" (id=\" + id + \") has not started, no content to write\");\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/PlatformRecording.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -83,1 +83,2 @@\n-    synchronized RepositoryChunk newChunk(ZonedDateTime timestamp) {\n+    synchronized RepositoryChunk newChunk() {\n+        ZonedDateTime timestamp = ZonedDateTime.now();\n@@ -96,1 +97,1 @@\n-            return new RepositoryChunk(new SafePath(filename), timestamp.toInstant());\n+            return new RepositoryChunk(new SafePath(filename));\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/Repository.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -46,1 +46,0 @@\n-    private final Instant startTime;\n@@ -50,0 +49,1 @@\n+    private Instant startTime;\n@@ -53,2 +53,1 @@\n-    RepositoryChunk(SafePath path, Instant startTime) throws Exception {\n-        this.startTime = startTime;\n+    RepositoryChunk(SafePath path) throws Exception {\n@@ -80,0 +79,4 @@\n+    public void setStartTime(Instant timestamp) {\n+        this.startTime = timestamp;\n+    }\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/RepositoryChunk.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -822,3 +822,1 @@\n-        long epochSeconds = epochNanos \/ 1_000_000_000L;\n-        long nanoAdjustment = epochNanos - 1_000_000_000L * epochSeconds;\n-        return Instant.ofEpochSecond(epochSeconds, nanoAdjustment);\n+        return Instant.ofEpochSecond(0, epochNanos);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/Utils.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.nio.channels.FileChannel;\n@@ -34,0 +35,1 @@\n+import java.nio.file.StandardOpenOption;\n@@ -40,0 +42,2 @@\n+import java.util.ArrayList;\n+import java.util.Collections;\n@@ -42,0 +46,1 @@\n+import java.util.List;\n@@ -43,0 +48,1 @@\n+import java.util.Queue;\n@@ -52,0 +58,2 @@\n+        final DiskRepository repository;\n+        int referenceCount;\n@@ -54,0 +62,1 @@\n+        long endTimeNanos;\n@@ -55,1 +64,2 @@\n-        DiskChunk(Path path, long startNanos) {\n+        DiskChunk(DiskRepository repository, Path path, long startNanos) {\n+            this.repository = repository;\n@@ -58,0 +68,32 @@\n+            this.referenceCount = 1;\n+        }\n+\n+        public void acquire() {\n+            referenceCount++;\n+        }\n+\n+        public void release() {\n+            referenceCount--;\n+            if (referenceCount == 0) {\n+                destroy();\n+            }\n+            if (referenceCount < 0) {\n+                throw new InternalError(\"Reference count below zero\");\n+            }\n+        }\n+\n+        private void destroy() {\n+            try {\n+                Files.delete(path);\n+            } catch (IOException e) {\n+                \/\/ Schedule for deletion later.\n+                this.repository.deadChunks.add(this);\n+            }\n+        }\n+\n+        public boolean isDead() {\n+            return referenceCount == 0;\n+        }\n+\n+        public Path path() {\n+            return path;\n@@ -80,1 +122,1 @@\n-    private final Deque<DiskChunk> activeChunks = new ArrayDeque<>();\n+    private final Deque<DiskChunk> chunks = new ArrayDeque<>();\n@@ -82,0 +124,1 @@\n+    private final Deque<FileDump> fileDumps = new ArrayDeque<>();\n@@ -303,0 +346,1 @@\n+            currentChunk.endTimeNanos = endTimeNanos;\n@@ -333,1 +377,1 @@\n-        return new DiskChunk(Paths.get(filename), nanos);\n+        return new DiskChunk(this, Paths.get(filename), nanos);\n@@ -342,1 +386,4 @@\n-        deadChunks.addAll(activeChunks);\n+        for (FileDump dump: fileDumps) {\n+            dump.close();\n+        }\n+        deadChunks.addAll(chunks);\n@@ -371,1 +418,1 @@\n-        while (size > maxSize && activeChunks.size() > 1) {\n+        while (size > maxSize && chunks.size() > 1) {\n@@ -378,0 +425,1 @@\n+\n@@ -383,2 +431,2 @@\n-        while (activeChunks.size() > 1) {\n-            DiskChunk oldestChunk = activeChunks.getLast();\n+        while (chunks.size() > 1) {\n+            DiskChunk oldestChunk = chunks.getLast();\n@@ -394,0 +442,6 @@\n+    private void removeOldestChunk() {\n+        DiskChunk chunk = chunks.poll();\n+        chunk.release();\n+        size -= chunk.size;\n+    }\n+\n@@ -395,3 +449,2 @@\n-        int count = 0;\n-        while (!activeChunks.isEmpty()) {\n-            DiskChunk oldestChunk = activeChunks.peek();\n+        while (!chunks.isEmpty()) {\n+            DiskChunk oldestChunk = chunks.peek();\n@@ -400,1 +453,0 @@\n-                count++;\n@@ -405,1 +457,0 @@\n-        cleanUpDeadChunk(count + 10);\n@@ -412,1 +463,1 @@\n-        activeChunks.push(chunk);\n+        chunks.push(chunk);\n@@ -415,1 +466,0 @@\n-    }\n@@ -417,4 +467,4 @@\n-    private void removeOldestChunk() {\n-        DiskChunk chunk = activeChunks.poll();\n-        deadChunks.add(chunk);\n-        size -= chunk.size;\n+        for (FileDump fd : fileDumps) {\n+            fd.add(chunk);\n+        }\n+        fileDumps.removeIf(FileDump::isComplete);\n@@ -428,0 +478,1 @@\n+            count++;\n@@ -434,1 +485,0 @@\n-            count++;\n@@ -450,0 +500,11 @@\n+\n+    public synchronized FileDump newDump(long endTime) {\n+        FileDump fd = new FileDump(endTime);\n+        for (DiskChunk dc : chunks) {\n+            fd.add(dc);\n+        }\n+        if (!fd.isComplete()) {\n+            fileDumps.add(fd);\n+        }\n+        return fd;\n+    }\n","filename":"src\/jdk.management.jfr\/share\/classes\/jdk\/management\/jfr\/DiskRepository.java","additions":80,"deletions":19,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.management.jfr;\n+\n+import java.io.IOException;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.ArrayDeque;\n+import java.util.Queue;\n+\n+import jdk.management.jfr.DiskRepository.DiskChunk;\n+\n+final class FileDump {\n+    private final Queue<DiskChunk> chunks = new ArrayDeque<>();\n+    private final long stopTimeMillis;\n+    private boolean complete;\n+\n+    FileDump(long stopTimeMillis) {\n+        this.stopTimeMillis = stopTimeMillis;\n+    }\n+\n+    public synchronized void add(DiskChunk dc) {\n+        if (isComplete()) {\n+            return;\n+        }\n+        dc.acquire();\n+        chunks.add(dc);\n+        long endMillis = dc.endTimeNanos \/ 1_000_000;\n+        if (endMillis >= stopTimeMillis) {\n+            setComplete();\n+        }\n+    }\n+\n+    public synchronized boolean isComplete() {\n+        return complete;\n+    }\n+\n+    public synchronized void setComplete() {\n+        complete = true;\n+        this.notifyAll();\n+    }\n+\n+    public synchronized void close() {\n+        for (DiskChunk dc : chunks) {\n+            dc.release();\n+        }\n+        chunks.clear();\n+        complete = true;\n+    }\n+\n+    private DiskChunk oldestChunk() throws InterruptedException {\n+        while (true) {\n+            synchronized (this) {\n+                if (!chunks.isEmpty()) {\n+                    return chunks.poll();\n+                }\n+                if (complete) {\n+                    return null;\n+                }\n+                this.wait();\n+            }\n+        }\n+    }\n+\n+    public void write(Path path) throws IOException, InterruptedException {\n+        try (FileChannel out = FileChannel.open(path, StandardOpenOption.CREATE_NEW, StandardOpenOption.WRITE)) {\n+            DiskChunk chunk = null;\n+            while ((chunk = oldestChunk()) != null) {\n+                try (FileChannel in = FileChannel.open(chunk.path(), StandardOpenOption.READ)) {\n+                    in.transferTo(0, in.size(), out);\n+                }\n+            }\n+        } finally {\n+            close();\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/jdk.management.jfr\/share\/classes\/jdk\/management\/jfr\/FileDump.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -30,0 +30,1 @@\n+import java.nio.channels.FileChannel;\n@@ -33,0 +34,1 @@\n+import java.nio.file.StandardOpenOption;\n@@ -43,0 +45,1 @@\n+import java.util.concurrent.Future;\n@@ -53,0 +56,1 @@\n+import jdk.jfr.RecordingState;\n@@ -56,0 +60,1 @@\n+import jdk.jfr.consumer.RecordingStream;\n@@ -58,0 +63,1 @@\n+import jdk.management.jfr.DiskRepository.DiskChunk;\n@@ -148,0 +154,1 @@\n+    final Object lock = new Object();\n@@ -151,0 +158,1 @@\n+    private boolean started; \/\/ always guarded by lock\n@@ -464,2 +472,5 @@\n-        if (closed) {\n-            return;\n+        synchronized (lock) { \/\/ ensure one closer\n+            if (closed) {\n+                return;\n+            }\n+            closed = true;\n@@ -467,1 +478,0 @@\n-        closed = true;\n@@ -511,1 +521,2 @@\n-        try {\n+        synchronized (lock) { \/\/ ensure one starter\n+            ensureStartable();\n@@ -513,3 +524,10 @@\n-                mbean.startRecording(recordingId);\n-            } catch (IllegalStateException ise) {\n-                throw ise;\n+                try {\n+                    mbean.startRecording(recordingId);\n+                } catch (IllegalStateException ise) {\n+                    throw ise;\n+                }\n+                startDownload();\n+            } catch (Exception e) {\n+                ManagementSupport.logDebug(e.getMessage());\n+                close();\n+                return;\n@@ -517,5 +535,2 @@\n-            startDownload();\n-        } catch (Exception e) {\n-            ManagementSupport.logDebug(e.getMessage());\n-            close();\n-            return;\n+            stream.start();\n+            started = true;\n@@ -523,1 +538,0 @@\n-        stream.start();\n@@ -528,1 +542,46 @@\n-        stream.startAsync();\n+        synchronized (lock) { \/\/ ensure one starter\n+            ensureStartable();\n+            stream.startAsync();\n+            try {\n+                mbean.startRecording(recordingId);\n+                startDownload();\n+            } catch (Exception e) {\n+                ManagementSupport.logDebug(e.getMessage());\n+                close();\n+            }\n+            started = true;\n+        }\n+    }\n+\n+    private void ensureStartable() {\n+        if (closed) {\n+            throw new IllegalStateException(\"Event stream is closed\");\n+        }\n+        if (started) {\n+            throw new IllegalStateException(\"Event stream can only be started once\");\n+        }\n+    }\n+\n+    \/**\n+     * Writes recording data to a file.\n+     * <p>\n+     * The recording stream must be started, but not closed.\n+     * <p>\n+     * It's highly recommended that a max age or max size is set before\n+     * starting the stream. Otherwise, the dump may not contain any events.\n+     *\n+     * @param destination the location where recording data is written, not\n+     *        {@code null}\n+     *\n+     * @throws IOException if the recording data can't be copied to the specified\n+     *         location, or if the stream is closed, or not started.\n+     *\n+     * @throws SecurityException if a security manager exists and the caller doesn't\n+     *         have {@code FilePermission} to write to the destination path\n+     *\n+     * @see RemoteRecordingStream#setMaxAge(Duration)\n+     * @see RemoteRecordingStream#setMaxSize(Duration)\n+     *\/\n+    public void dump(Path destination) throws IOException {\n+        Objects.requireNonNull(destination);\n+        long id = -1;\n@@ -530,2 +589,20 @@\n-            mbean.startRecording(recordingId);\n-            startDownload();\n+            FileDump fileDump;\n+            synchronized (lock) { \/\/ ensure running state while preparing dump\n+                if (closed) {\n+                    throw new IOException(\"Recording stream has been closed, no content to write\");\n+                }\n+                if (!started) {\n+                    throw new IOException(\"Recording stream has not been started, no content to write\");\n+                }\n+                \/\/ Take repository lock to prevent new data to be flushed\n+                \/\/ client-side after clone has been created on the server.\n+                synchronized (repository) {\n+                    id = mbean.cloneRecording(recordingId, true);\n+                    RecordingInfo ri = getRecordingInfo(mbean.getRecordings(), id);\n+                    fileDump = repository.newDump(ri.getStopTime());\n+                }\n+            }\n+            \/\/ Write outside lock\n+            fileDump.write(destination);\n+        } catch (IOException ioe) {\n+            throw ioe;\n@@ -535,0 +612,17 @@\n+        } finally {\n+            if (id != -1) {\n+                try {\n+                    mbean.closeRecording(id);\n+                } catch (Exception e) {\n+                    ManagementSupport.logDebug(e.getMessage());\n+                    close();\n+                }\n+            }\n+        }\n+    }\n+\n+    private RecordingInfo getRecordingInfo(List<RecordingInfo> infos, long id) throws IOException {\n+        for (RecordingInfo info : infos) {\n+            if (info.getId() == id) {\n+                return info;\n+            }\n@@ -536,0 +630,1 @@\n+        throw new IOException(\"Unable to find id of dumped recording\");\n","filename":"src\/jdk.management.jfr\/share\/classes\/jdk\/management\/jfr\/RemoteRecordingStream.java","additions":111,"deletions":16,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -0,0 +1,162 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.api.consumer.recordingstream;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.time.Duration;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import jdk.jfr.Event;\n+import jdk.jfr.Name;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.consumer.RecordingFile;\n+import jdk.jfr.consumer.RecordingStream;\n+\n+\/**\n+ * @test\n+ * @summary Tests RecordingStream::dump(Path)\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @run main\/othervm jdk.jfr.api.consumer.recordingstream.TestDump\n+ *\/\n+public class TestDump {\n+\n+    @Name(\"DumpTest\")\n+    static class DumpEvent extends Event {\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        testUnstarted();\n+        testClosed();\n+        testOneDump();\n+        testMultipleDumps();\n+        testEventAfterDump();\n+    }\n+\n+    private static void testUnstarted() throws Exception {\n+        Path path = Path.of(\"recording.jfr\");\n+        var rs = new RecordingStream();\n+        rs.setMaxAge(Duration.ofHours(1));\n+        try {\n+            rs.dump(path);\n+            throw new Exception(\"Should not be able to dump unstarted recording\");\n+        } catch (IOException ise) {\n+            \/\/ OK, expected\n+        }\n+    }\n+\n+    private static void testClosed() throws Exception {\n+        Path path = Path.of(\"recording.jfr\");\n+        var rs = new RecordingStream();\n+        rs.setMaxAge(Duration.ofHours(1));\n+        rs.startAsync();\n+        rs.close();\n+        try {\n+            rs.dump(path);\n+            throw new Exception(\"Should not be able to dump closed recording\");\n+        } catch (IOException ise) {\n+            \/\/ OK, expected\n+        }\n+    }\n+\n+    private static void testMultipleDumps() throws Exception {\n+        CountDownLatch latch = new CountDownLatch(1);\n+        try (var rs = new RecordingStream()) {\n+            rs.setMaxAge(Duration.ofHours(1));\n+            rs.onEvent(e -> {\n+                latch.countDown();\n+            });\n+            rs.startAsync();\n+            while (latch.getCount() > 0) {\n+                DumpEvent e = new DumpEvent();\n+                e.commit();\n+                latch.await(10, TimeUnit.MILLISECONDS);\n+            }\n+            latch.await(); \/\/ Await first event\n+            AtomicInteger counter = new AtomicInteger();\n+            Callable<Boolean> f = () -> {\n+                try {\n+                    int id = counter.incrementAndGet();\n+                    Path p = Path.of(\"multiple-\" + id + \".jfr\");\n+                    rs.dump(p);\n+                    return !RecordingFile.readAllEvents(p).isEmpty();\n+                } catch (IOException ioe) {\n+                    ioe.printStackTrace();\n+                   return false;\n+                }\n+            };\n+            var service = Executors.newFixedThreadPool(3);\n+            var f1 = service.submit(f);\n+            var f2 = service.submit(f);\n+            var f3 = service.submit(f);\n+            if (!f1.get() && !f1.get() && !f3.get()) {\n+                throw new Exception(\"Failed to dump multiple recordings simultanously\");\n+            }\n+            service.shutdown();\n+        }\n+    }\n+\n+    private static void testOneDump() throws Exception {\n+        CountDownLatch latch = new CountDownLatch(1);\n+        try (var rs = new RecordingStream()) {\n+            rs.setMaxSize(5_000_000);\n+            rs.onEvent(e -> {\n+                latch.countDown();\n+            });\n+            rs.startAsync();\n+            while (latch.getCount() > 0) {\n+                DumpEvent e = new DumpEvent();\n+                e.commit();\n+                latch.await(10, TimeUnit.MILLISECONDS);\n+            }\n+            Path p = Path.of(\"one-dump.jfr\");\n+            rs.dump(p);\n+            if (RecordingFile.readAllEvents(p).isEmpty()) {\n+                throw new Exception(\"No events in dump\");\n+            }\n+        }\n+    }\n+\n+    private static void testEventAfterDump() throws Exception {\n+        CountDownLatch latch = new CountDownLatch(1);\n+        try (var rs = new RecordingStream()) {\n+            rs.setMaxAge(Duration.ofHours(1));\n+            rs.onEvent(e -> {\n+                latch.countDown();\n+            });\n+            rs.startAsync();\n+            Path p = Path.of(\"after-dump.jfr\");\n+            rs.dump(p);\n+            DumpEvent e = new DumpEvent();\n+            e.commit();\n+            latch.await();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/api\/consumer\/recordingstream\/TestDump.java","additions":162,"deletions":0,"binary":false,"changes":162,"status":"added"},{"patch":"@@ -0,0 +1,166 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.jmx.streaming;\n+\n+import java.io.IOException;\n+import java.lang.management.ManagementFactory;\n+import java.nio.file.Path;\n+import java.time.Duration;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import jdk.jfr.Event;\n+import jdk.jfr.Name;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.consumer.RecordingFile;\n+import jdk.jfr.consumer.RecordingStream;\n+import jdk.management.jfr.RemoteRecordingStream;\n+\n+\/**\n+ * @test\n+ * @summary Tests RecordingStream::dump(Path)\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @run main\/othervm jdk.jfr.jmx.streaming.TestRemoteDump\n+ *\/\n+public class TestRemoteDump {\n+\n+    @Name(\"RemoteDumpTest\")\n+    static class DumpEvent extends Event {\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        testUnstarted();\n+        testClosed();\n+        testOneDump();\n+        testMultipleDumps();\n+        testEventAfterDump();\n+    }\n+\n+    private static void testUnstarted() throws Exception {\n+        Path path = Path.of(\"recording.jfr\");\n+        var rs = new RecordingStream();\n+        rs.setMaxAge(Duration.ofHours(1));\n+        try {\n+            rs.dump(path);\n+            throw new Exception(\"Should not be able to dump unstarted recording\");\n+        } catch (IOException ise) {\n+            \/\/ OK, expected\n+        }\n+    }\n+\n+    private static void testClosed() throws Exception {\n+        Path path = Path.of(\"recording.jfr\");\n+        var rs = new RecordingStream();\n+        rs.setMaxAge(Duration.ofHours(1));\n+        rs.startAsync();\n+        rs.close();\n+        try {\n+            rs.dump(path);\n+            throw new Exception(\"Should not be able to dump closed recording\");\n+        } catch (IOException ise) {\n+            \/\/ OK, expected\n+        }\n+    }\n+\n+    private static void testMultipleDumps() throws Exception {\n+        CountDownLatch latch = new CountDownLatch(1);\n+        var conn = ManagementFactory.getPlatformMBeanServer();\n+        try (var rs = new RemoteRecordingStream(conn)) {\n+            rs.setMaxAge(Duration.ofHours(1));\n+            rs.onEvent(e -> {\n+                latch.countDown();\n+            });\n+            rs.startAsync();\n+            while (latch.getCount() > 0) {\n+                DumpEvent e = new DumpEvent();\n+                e.commit();\n+                latch.await(10, TimeUnit.MILLISECONDS);\n+            }\n+            latch.await(); \/\/ Await first event\n+            AtomicInteger counter = new AtomicInteger();\n+            Callable<Boolean> f = () -> {\n+                try {\n+                    int id = counter.incrementAndGet();\n+                    Path p = Path.of(\"multiple-\" + id + \".jfr\");\n+                    rs.dump(p);\n+                    return !RecordingFile.readAllEvents(p).isEmpty();\n+                } catch (IOException ioe) {\n+                    ioe.printStackTrace();\n+                   return false;\n+                }\n+            };\n+            var service = Executors.newFixedThreadPool(3);\n+            var f1 = service.submit(f);\n+            var f2 = service.submit(f);\n+            var f3 = service.submit(f);\n+            if (!f1.get() && !f1.get() && !f3.get()) {\n+                throw new Exception(\"Failed to dump multiple recordings simultanously\");\n+            }\n+            service.shutdown();\n+        }\n+    }\n+\n+    private static void testOneDump() throws Exception {\n+        CountDownLatch latch = new CountDownLatch(1);\n+        var conn = ManagementFactory.getPlatformMBeanServer();\n+        try (var rs = new RemoteRecordingStream(conn)) {\n+            rs.setMaxSize(5_000_000);\n+            rs.onEvent(e -> {\n+                latch.countDown();\n+            });\n+            rs.startAsync();\n+            while (latch.getCount() > 0) {\n+                DumpEvent e = new DumpEvent();\n+                e.commit();\n+                latch.await(10, TimeUnit.MILLISECONDS);\n+            }\n+            Path p = Path.of(\"one-dump.jfr\");\n+            rs.dump(p);\n+            if (RecordingFile.readAllEvents(p).isEmpty()) {\n+                throw new Exception(\"No events in dump\");\n+            }\n+        }\n+    }\n+\n+    private static void testEventAfterDump() throws Exception {\n+        CountDownLatch latch = new CountDownLatch(1);\n+        try (var rs = new RecordingStream()) {\n+            rs.setMaxAge(Duration.ofHours(1));\n+            rs.onEvent(e -> {\n+                latch.countDown();\n+            });\n+            rs.startAsync();\n+            Path p = Path.of(\"after-dump.jfr\");\n+            rs.dump(p);\n+            DumpEvent e = new DumpEvent();\n+            e.commit();\n+            latch.await();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/jmx\/streaming\/TestRemoteDump.java","additions":166,"deletions":0,"binary":false,"changes":166,"status":"added"}]}