{"files":[{"patch":"@@ -173,10 +173,1 @@\n-            if (resultType.isPrimitive()) {\n-                \/\/ Non-reference conversions are more than just plain casts.\n-                \/\/ By pushing the value through a funnel of the form (T x)->x,\n-                \/\/ the boxed result can be widened as needed.  See MH::asType.\n-                MethodHandle funnel = MethodHandles.identity(resultType);\n-                result = funnel.invoke(result);\n-                \/\/ Now it is the wrapper type for resultType.\n-                resultType = Wrapper.asWrapperType(resultType);\n-            }\n-            return resultType.cast(result);\n+            return widenAndCast(result, resultType);\n@@ -198,0 +189,32 @@\n+\n+    \/**\n+     * If resultType is a reference type, do Class::cast on the result through\n+     * an identity function of that type, as-type converted to return\n+     * the corresponding reference wrapper type for resultType.\n+     * Works like {@code MethodHandles.identity(resultType).invoke((Object)result)}.\n+     *\n+     * This utility function enforces type correctness of bootstrap method results.\n+     * It is also used to enforce type correctness in other dependently-typed\n+     * methods, such as classData.\n+     *\/\n+    static <T> T widenAndCast(Object result, Class<T> resultType) throws Throwable {\n+        if (!resultType.isPrimitive()) {\n+            return resultType.cast(result);\n+        }\n+\n+        Class<T> wrapperType = Wrapper.asWrapperType(resultType);\n+        if (wrapperType.isInstance(result)) {\n+            @SuppressWarnings(\"unchecked\")\n+            T wrapper = (T) result;\n+            return wrapper;\n+        }\n+        \/\/ Non-reference conversions are more than just plain casts.\n+        \/\/ By pushing the value through a funnel of the form (T x)->x,\n+        \/\/ the boxed result can be widened as needed.  See MH::asType.\n+        \/\/ Note that this might widen byte into int, float into double, etc\n+        MethodHandle funnel = MethodHandles.identity(resultType);\n+        result = funnel.invoke(result);\n+        \/\/ Now it is the wrapper type for resultType.\n+        return wrapperType.cast(result);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/BootstrapMethodInvoker.java","additions":33,"deletions":10,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-    private static final int CLASSFILE_VERSION = 52;\n+    private static final int CLASSFILE_VERSION = 59;\n@@ -74,1 +74,0 @@\n-    private static final String NAME_FIELD_IMPL_METHOD = \"protectedImplMethod\";\n@@ -79,1 +78,0 @@\n-    private static final String DESCR_METHOD_HANDLE = \"Ljava\/lang\/invoke\/MethodHandle;\";\n@@ -97,0 +95,3 @@\n+    \/\/ condy to load implMethod from class data\n+    private static final ConstantDynamic implMethodCondy;\n+\n@@ -104,0 +105,6 @@\n+\n+        \/\/ condy to load implMethod from class data\n+        MethodType classDataMType = MethodType.methodType(Object.class, MethodHandles.Lookup.class, String.class, Class.class);\n+        Handle classDataBsm = new Handle(H_INVOKESTATIC, Type.getInternalName(MethodHandles.class), \"classData\",\n+                                         classDataMType.descriptorString(), false);\n+        implMethodCondy = new ConstantDynamic(\"implMethod\", MethodHandle.class.descriptorString(), classDataBsm);\n@@ -364,8 +371,0 @@\n-        if (useImplMethodHandle) {\n-            FieldVisitor fv = cw.visitField(ACC_PRIVATE + ACC_STATIC,\n-                                            NAME_FIELD_IMPL_METHOD,\n-                                            DESCR_METHOD_HANDLE,\n-                                            null, null);\n-            fv.visitEnd();\n-        }\n-\n@@ -397,1 +396,1 @@\n-            Lookup lookup = caller.defineHiddenClass(classBytes, !disableEagerInitialization, NESTMATE, STRONG);\n+            Lookup lookup;\n@@ -406,2 +405,4 @@\n-                MethodHandle mh = lookup.findStaticSetter(lookup.lookupClass(), NAME_FIELD_IMPL_METHOD, MethodHandle.class);\n-                mh.invokeExact(implMethod);\n+                lookup = caller.defineHiddenClassWithClassData(classBytes, implMethod, !disableEagerInitialization,\n+                                                               NESTMATE, STRONG);\n+            } else {\n+                lookup = caller.defineHiddenClass(classBytes, !disableEagerInitialization, NESTMATE, STRONG);\n@@ -557,2 +558,1 @@\n-                visitVarInsn(ALOAD, 0);\n-                visitFieldInsn(GETSTATIC, lambdaClassName, NAME_FIELD_IMPL_METHOD, DESCR_METHOD_HANDLE);\n+                visitLdcInsn(implMethodCondy);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import static java.lang.invoke.MethodHandleStatics.UNSAFE;\n@@ -686,2 +687,4 @@\n-     * A convenient method for LambdaForms to get the class data of a given class.\n-     * LambdaForms cannot use condy via MethodHandles.classData\n+     * Returns the class data set by the VM in the Class::classData field.\n+     *\n+     * This is also invoked by LambdaForms as it cannot use condy via\n+     * MethodHandles.classData due to bootstrapping issue.\n@@ -690,0 +693,1 @@\n+        UNSAFE.ensureClassInitialized(c);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleNatives.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import jdk.internal.access.JavaLangAccess;\n@@ -104,0 +103,2 @@\n+     * This lookup object is created by the original lookup class\n+     * and has the {@link Lookup#ORIGINAL ORIGINAL} bit set.\n@@ -110,1 +111,2 @@\n-     * {@linkplain Lookup#hasFullPrivilegeAccess() full privilege access}\n+     * {@linkplain Lookup#ORIGINAL original} and\n+     * {@linkplain Lookup#hasFullPrivilegeAccess() full privilege access}.\n@@ -204,2 +206,2 @@\n-     * {@linkplain Lookup#hasFullPrivilegeAccess() full privilege access} and\n-     * {@code null} previous lookup class.\n+     * {@linkplain Lookup#hasFullPrivilegeAccess() full privilege access}\n+     * with {@code null} previous lookup class.\n@@ -209,2 +211,4 @@\n-     * the lookup class of the caller as the new previous lookup class and\n-     * drops {@code MODULE} access from the full privilege access.\n+     * the lookup class of the caller as the new previous lookup class with\n+     * {@code PRIVATE} access but no {@code MODULE} access.\n+     * <p>\n+     * The resulting {@code Lookup} object has no {@code ORIGINAL} access.\n@@ -235,1 +239,2 @@\n-        if (!caller.hasFullPrivilegeAccess())\n+        int requireAccess = Lookup.PRIVATE|Lookup.MODULE;\n+        if ((caller.lookupModes() & requireAccess) != requireAccess)\n@@ -245,1 +250,1 @@\n-        int newModes = Lookup.FULL_POWER_MODES;\n+        int newModes = Lookup.FULL_POWER_MODES & ~Lookup.ORIGINAL;\n@@ -273,1 +278,1 @@\n-     * of the specified {@code Lookup} object, or {@code null}.\n+     * of the given {@code caller} lookup object, or {@code null}.\n@@ -275,2 +280,2 @@\n-     * <p> Classes can be created with class data by calling\n-     * {@link Lookup#defineHiddenClassWithClassData(byte[], Object, Lookup.ClassOption...)\n+     * <p> A hidden class with class data can be created by calling\n+     * {@link Lookup#defineHiddenClassWithClassData(byte[], Object, boolean, Lookup.ClassOption...)\n@@ -278,5 +283,3 @@\n-     * A hidden class with a class data behaves as if the hidden class\n-     * has a private static final unnamed field pre-initialized with\n-     * the class data and this method is equivalent as if calling\n-     * {@link ConstantBootstraps#getStaticFinal(Lookup, String, Class)} to\n-     * obtain the value of such field corresponding to the class data.\n+     * This method will cause the static class initializer of the lookup\n+     * class of the given {@code caller} lookup object be executed if\n+     * it has not been initialized.\n@@ -285,2 +288,2 @@\n-     * must have {@link Lookup#ORIGINAL ORIGINAL} access in order to retrieve\n-     * the class data.\n+     * must have {@linkplain Lookup#ORIGINAL original access}\n+     * in order to retrieve the class data.\n@@ -291,2 +294,2 @@\n-     * example that can be {@code List.of(o1, o2, o3....)} containing more than\n-     * one live object.  The class data is accessible only to the lookup object\n+     * example that can be {@code Class} or {@code MethodHandle} object.\n+     * The class data is accessible only to the lookup object\n@@ -294,1 +297,1 @@\n-     * in the same nest.  If a framework passes security sensitive live objects\n+     * in the same nest.  If a framework passes security sensitive objects\n@@ -297,2 +300,2 @@\n-     * the live objects in private fields which are accessible to other\n-     * nestmates.\n+     * the class data in private static field(s) which are accessible to\n+     * other nestmates.\n@@ -303,1 +306,1 @@\n-     * @param name ignored\n+     * @param name unused\n@@ -308,1 +311,1 @@\n-     * original caller access\n+     * {@linkplain Lookup#ORIGINAL original} access\n@@ -310,3 +313,79 @@\n-     * the specified {@code type}\n-     * @see Lookup#defineHiddenClassWithClassData(byte[], Object, Lookup.ClassOption...)\n-     * @since 15\n+     * the given {@code type}\n+     * @throws NullPointerException if {@code caller} or {@code type} argument\n+     * is {@code null}\n+     * @see Lookup#defineHiddenClassWithClassData(byte[], Object, boolean, Lookup.ClassOption...)\n+     * @since 16\n+     * @jvms 5.5 Initialization\n+     *\/\n+     public static <T> T classData(Lookup caller, String name, Class<T> type) throws IllegalAccessException {\n+         Objects.requireNonNull(caller);\n+         Objects.requireNonNull(type);\n+\n+         if ((caller.lookupModes() & Lookup.ORIGINAL) != Lookup.ORIGINAL)  {\n+             throw new IllegalAccessException(caller + \" does not have ORIGINAL access\");\n+         }\n+\n+         Object classdata = MethodHandleNatives.classData(caller.lookupClass());\n+         if (classdata == null) return null;\n+\n+         try {\n+             return BootstrapMethodInvoker.widenAndCast(classdata, type);\n+         } catch (ClassCastException e) {\n+             throw e;\n+         } catch (Throwable e) {\n+             throw new InternalError(e);\n+         }\n+    }\n+\n+    \/**\n+     * Returns the element at the specified index in the\n+     * {@linkplain #classData(Lookup, String, Class) class data},\n+     * whose type is a {@code List}, associated with the lookup class\n+     * of the given {@code caller} lookup object.\n+     * If the class data is not present in this lookup class, this method\n+     * returns {@code null}.\n+     *\n+     * <p> A hidden class with class data can be created by calling\n+     * {@link Lookup#defineHiddenClassWithClassData(byte[], Object, boolean, Lookup.ClassOption...)\n+     * Lookup::defineHiddenClassWithClassData}.\n+     * This method will cause the static class initializer of the lookup\n+     * class of the given {@code caller} lookup object be executed if\n+     * it has not been initialized.\n+     *\n+     * <p> The {@linkplain Lookup#lookupModes() lookup modes} for this lookup\n+     * must have {@linkplain Lookup#ORIGINAL original access}\n+     * in order to retrieve the class data.\n+     *\n+     * @apiNote\n+     * This method can be called as a bootstrap method for a dynamically computed\n+     * constant.  A framework can create a hidden class with class data, for\n+     * example that can be {@code List.of(o1, o2, o3....)} containing more than\n+     * one object and use this method to load one element at a specific index.\n+     * The class data is accessible only to the lookup object\n+     * created by the original caller but inaccessible to other members\n+     * in the same nest.  If a framework passes security sensitive objects\n+     * to a hidden class via class data, it is recommended to load the value\n+     * of class data as a dynamically computed constant instead of storing\n+     * the class data in private static field(s) which are accessible to other\n+     * nestmates.\n+     *\n+     * @param <T> the type to cast the result object to\n+     * @param caller the lookup context describing the class performing the\n+     * operation (normally stacked by the JVM)\n+     * @param name unused\n+     * @param type the type of the element at the given index in the class data\n+     * @param index index of the element in the class data\n+     * @return the element at the given index in the class data\n+     * if the class data is present; otherwise {@code null}\n+     * @throws IllegalAccessException if the lookup context does not have\n+     * {@linkplain Lookup#ORIGINAL original} access\n+     * @throws ClassCastException if the class data cannot be converted to {@code List}\n+     * or the element at the specified index cannot be converted to the given type\n+     * @throws IndexOutOfBoundsException if the index is out of range\n+     * @throws NullPointerException if {@code caller} or {@code type} argument is\n+     * {@code null}; or if unboxing operation fails because\n+     * the element at the given index is {@code null}\n+     *\n+     * @since 16\n+     * @see #classData(Lookup, String, Class)\n+     * @see Lookup#defineHiddenClassWithClassData(byte[], Object, boolean, Lookup.ClassOption...)\n@@ -314,3 +393,14 @@\n-    static <T> T classData(Lookup caller, String name, Class<T> type) throws IllegalAccessException {\n-        if (!caller.hasFullPrivilegeAccess()) {\n-            throw new IllegalAccessException(caller + \" does not have full privilege access\");\n+    \/* package-private *\/ static <T> T classDataAt(Lookup caller, String name, Class<T> type, int index)\n+            throws IllegalAccessException\n+    {\n+        @SuppressWarnings(\"unchecked\")\n+        List<Object> classdata = (List<Object>)classData(caller, name, List.class);\n+        if (classdata == null) return null;\n+\n+        try {\n+            Object element = classdata.get(index);\n+            return BootstrapMethodInvoker.widenAndCast(element, type);\n+        } catch (ClassCastException|NullPointerException|IndexOutOfBoundsException e) {\n+            throw e;\n+        } catch (Throwable e) {\n+            throw new InternalError(e);\n@@ -318,2 +408,0 @@\n-        Object classData = MethodHandleNatives.classData(caller.lookupClass);\n-        return type.cast(classData);\n@@ -639,2 +727,6 @@\n-     * possess {@linkplain #hasFullPrivilegeAccess() full privilege access}.  Such a lookup has\n-     * the following additional capability:\n+     * possess {@linkplain #hasFullPrivilegeAccess() full privilege access}.\n+     * <p style=\"font-size:smaller;\">\n+     * A lookup with <em>original access<\/em> ensures that this lookup is created by\n+     * the original lookup class and the bootstrap method invoked by the VM.\n+     * Such a lookup with original access also has private and module access\n+     * which has the following additional capability:\n@@ -644,0 +736,2 @@\n+     * <li>obtain the {@linkplain MethodHandles#classData(Lookup, String, Class)\n+     * class data} associated with the lookup class<\/li>\n@@ -814,0 +908,1 @@\n+     * <th style=\"text-align:center\">original<\/th>\n@@ -824,0 +919,1 @@\n+     * <td style=\"text-align:center\">ORI<\/td>\n@@ -834,0 +930,1 @@\n+     * <td><\/td>\n@@ -843,0 +940,1 @@\n+     * <td><\/td>\n@@ -852,0 +950,1 @@\n+     * <td><\/td>\n@@ -860,0 +959,1 @@\n+     * <td><\/td>\n@@ -864,0 +964,1 @@\n+     * <td><\/td>\n@@ -872,0 +973,1 @@\n+     * <td><\/td>\n@@ -882,0 +984,1 @@\n+     * <td><\/td>\n@@ -891,0 +994,1 @@\n+     * <td><\/td>\n@@ -900,0 +1004,1 @@\n+     * <td><\/td>\n@@ -905,0 +1010,1 @@\n+     * <td><\/td>\n@@ -914,0 +1020,1 @@\n+     * <td><\/td>\n@@ -923,0 +1030,1 @@\n+     * <td><\/td>\n@@ -932,0 +1040,1 @@\n+     * <td><\/td>\n@@ -940,0 +1049,1 @@\n+     * <td><\/td>\n@@ -943,0 +1053,1 @@\n+     * <td><\/td>\n@@ -951,0 +1062,1 @@\n+     * <td><\/td>\n@@ -963,0 +1075,1 @@\n+     * <td><\/td>\n@@ -969,0 +1082,1 @@\n+     * <td><\/td>\n@@ -979,0 +1093,1 @@\n+     * <td><\/td>\n@@ -987,0 +1102,1 @@\n+     * <td><\/td>\n@@ -995,0 +1111,1 @@\n+     * <td><\/td>\n@@ -1000,0 +1117,1 @@\n+     * <td><\/td>\n@@ -1009,0 +1127,1 @@\n+     * <td><\/td>\n@@ -1019,0 +1138,1 @@\n+     * <td><\/td>\n@@ -1027,0 +1147,1 @@\n+     * <td><\/td>\n@@ -1035,0 +1156,1 @@\n+     * <td><\/td>\n@@ -1040,0 +1162,1 @@\n+     * <td><\/td>\n@@ -1049,0 +1172,1 @@\n+     * <td><\/td>\n@@ -1058,0 +1182,1 @@\n+     * <td><\/td>\n@@ -1067,0 +1192,1 @@\n+     * <td><\/td>\n@@ -1075,0 +1201,1 @@\n+     * <td><\/td>\n@@ -1083,0 +1210,1 @@\n+     * <td><\/td>\n@@ -1091,0 +1219,1 @@\n+     * <td><\/td>\n@@ -1099,0 +1228,1 @@\n+     * <td><\/td>\n@@ -1107,0 +1237,1 @@\n+     * <td><\/td>\n@@ -1115,0 +1246,1 @@\n+     * <td><\/td>\n@@ -1123,0 +1255,1 @@\n+     * <td><\/td>\n@@ -1135,1 +1268,2 @@\n-     * <li>{@code PRO} indicates {@link #PROTECTED} bit set,\n+     * <li>{@code ORI} indicates {@link #ORIGINAL} bit set,\n+     *     {@code PRO} indicates {@link #PROTECTED} bit set,\n@@ -1220,1 +1354,4 @@\n-     * {@link #defineClass(byte[]) defineClass}\n+     * {@link #defineClass(byte[]) defineClass},\n+     * {@link #defineHiddenClass(byte[], boolean, ClassOption...) defineHiddenClass},\n+     * {@link #defineHiddenClassWithClassData(byte[], Object, boolean, ClassOption...)\n+     * defineHiddenClassWithClassData}\n@@ -1243,1 +1380,1 @@\n-     * {@linkplain #hasFullPrivilegeAccess() full privilege access},\n+     * {@linkplain #ORIGINAL original access},\n@@ -1354,2 +1491,18 @@\n-        private static final int ALL_MODES = (PUBLIC | PRIVATE | PROTECTED | PACKAGE | MODULE | UNCONDITIONAL);\n-        private static final int FULL_POWER_MODES = (ALL_MODES & ~UNCONDITIONAL);\n+        \/** A single-bit mask representing {@code original} access\n+         *  which may contribute to the result of {@link #lookupModes lookupModes}.\n+         *  The value is {@code 0x40}, which does not correspond meaningfully to\n+         *  any particular {@linkplain java.lang.reflect.Modifier modifier bit}.\n+         *\n+         *  <p>\n+         *  If this lookup mode is set, the {@code Lookup} object must be\n+         *  created by the original lookup class by calling\n+         *  {@link MethodHandles#lookup()} method or by a bootstrap method\n+         *  invoked by the VM.  The {@code Lookup} object with this lookup\n+         *  mode has {@linkplain #hasFullPrivilegeAccess() full privilege access}.\n+         *\n+         *  @since 16\n+         *\/\n+        public static final int ORIGINAL = PACKAGE << 3;\n+\n+        private static final int ALL_MODES = (PUBLIC | PRIVATE | PROTECTED | PACKAGE | MODULE | UNCONDITIONAL | ORIGINAL);\n+        private static final int FULL_POWER_MODES = (ALL_MODES & ~UNCONDITIONAL);   \/\/ with original access\n@@ -1359,1 +1512,1 @@\n-         * Adjust PUBLIC => PUBLIC|MODULE|UNCONDITIONAL\n+         * Adjust PUBLIC => PUBLIC|MODULE|ORIGINAL|UNCONDITIONAL\n@@ -1363,1 +1516,1 @@\n-            mods &= (ALL_MODES - PACKAGE - MODULE - UNCONDITIONAL);\n+            mods &= (ALL_MODES - PACKAGE - MODULE - ORIGINAL - UNCONDITIONAL);\n@@ -1419,1 +1572,2 @@\n-         *  and {@linkplain #UNCONDITIONAL UNCONDITIONAL (0x20)}.\n+         *  {@linkplain #UNCONDITIONAL UNCONDITIONAL (0x20)},\n+         *  and {@linkplain #ORIGINAL ORIGINAL (0x40)}.\n@@ -1476,0 +1630,2 @@\n+         * <li>If the new lookup class is different from the old lookup class,\n+         * i.e. {@link #ORIGINAL ORIGINAL} access is lost.\n@@ -1531,1 +1687,1 @@\n-            int newModes = (allowedModes & FULL_POWER_MODES);\n+            int newModes = (allowedModes & FULL_POWER_MODES) & ~ORIGINAL;\n@@ -1572,1 +1728,2 @@\n-         * {@link #PRIVATE PRIVATE}, or {@link #UNCONDITIONAL UNCONDITIONAL}.\n+         * {@link #PRIVATE PRIVATE}, {@link #ORIGINAL ORIGINAL}, or\n+         * {@link #UNCONDITIONAL UNCONDITIONAL}.\n@@ -1581,2 +1738,3 @@\n-         * {@link #PROTECTED PROTECTED} is always dropped and so the resulting lookup\n-         * mode will never have this access capability. When dropping {@code PACKAGE}\n+         * {@link #PROTECTED PROTECTED} and {@link #ORIGINAL ORIGINAL} are always\n+         * dropped and so the resulting lookup mode will never have these access\n+         * capability. When dropping {@code PACKAGE}\n@@ -1603,1 +1761,2 @@\n-         * {@code MODULE}, {@code PACKAGE}, {@code PROTECTED}, {@code PRIVATE} or {@code UNCONDITIONAL}\n+         * {@code MODULE}, {@code PACKAGE}, {@code PROTECTED}, {@code PRIVATE}, {@code ORIGINAL}\n+         * or {@code UNCONDITIONAL}\n@@ -1609,1 +1768,1 @@\n-            int newModes = oldModes & ~(modeToDrop | PROTECTED);\n+            int newModes = oldModes & ~(modeToDrop | PROTECTED | ORIGINAL);\n@@ -1616,0 +1775,1 @@\n+                case ORIGINAL:\n@@ -1961,5 +2121,5 @@\n-         * {@link #defineHiddenClass(byte[], boolean, ClassOption...) defineHiddenClass(bytes, true, options)}\n-         * as if the hidden class has a private static final unnamed field whose value\n-         * is initialized to {@code classData} right before the class initializer is\n-         * executed.  The newly created class is linked and initialized by the Java\n-         * Virtual Machine.\n+         * {@link #defineHiddenClass(byte[], boolean, ClassOption...) defineHiddenClass(bytes, initialize, options)}\n+         * as if the hidden class is injected with a private static final <i>unnamed<\/i>\n+         * field which is initialized with the given {@code classData} at\n+         * the first instruction of the class initializer.\n+         * The newly created class is linked by the Java Virtual Machine.\n@@ -1972,0 +2132,1 @@\n+         * @param initialize if {@code true} the class will be initialized.\n@@ -1993,1 +2154,1 @@\n-         * @since 15\n+         * @since 16\n@@ -1996,0 +2157,11 @@\n+         * @see MethodHandles#classData(Lookup, String, Class)\n+         * @jvms 4.2.1 Binary Class and Interface Names\n+         * @jvms 4.2.2 Unqualified Names\n+         * @jvms 4.7.28 The {@code NestHost} Attribute\n+         * @jvms 4.7.29 The {@code NestMembers} Attribute\n+         * @jvms 5.4.3.1 Class and Interface Resolution\n+         * @jvms 5.4.4 Access Control\n+         * @jvms 5.3.5 Deriving a {@code Class} from a {@code class} File Representation\n+         * @jvms 5.4 Linking\n+         * @jvms 5.5 Initialization\n+         * @jls 12.7 Unloading of Classes and Interface\n@@ -1997,1 +2169,1 @@\n-        \/* package-private *\/ Lookup defineHiddenClassWithClassData(byte[] bytes, Object classData, ClassOption... options)\n+        public Lookup defineHiddenClassWithClassData(byte[] bytes, Object classData, boolean initialize, ClassOption... options)\n@@ -2010,1 +2182,1 @@\n-                       .defineClassAsLookup(true, classData);\n+                       .defineClassAsLookup(initialize, classData);\n@@ -2241,2 +2413,0 @@\n-                \/\/ initialize must be true if classData is non-null\n-                assert classData == null || initialize == true;\n@@ -2298,1 +2468,2 @@\n-         * If none of the above cases apply, it is the case that full access\n+         * If none of the above cases apply, it is the case that\n+         * {@linkplain #hasFullPrivilegeAccess() full privilege access}\n@@ -2332,3 +2503,5 @@\n-            case FULL_POWER_MODES & (~PROTECTED):\n-            case FULL_POWER_MODES & ~(PROTECTED|MODULE):\n-                return cname + \"\/private\";\n+            case PUBLIC|PACKAGE|PRIVATE:\n+            case PUBLIC|MODULE|PACKAGE|PRIVATE:\n+                    return cname + \"\/private\";\n+            case PUBLIC|PACKAGE|PRIVATE|PROTECTED:\n+            case PUBLIC|MODULE|PACKAGE|PRIVATE|PROTECTED:\n@@ -2336,2 +2509,1 @@\n-            case FULL_POWER_MODES & (~MODULE):\n-                return cname;\n+                    return cname;\n@@ -3483,1 +3655,1 @@\n-         * If this lookup object has full privilege access, then the caller class is the lookupClass.\n+         * If this lookup object has original full privilege access, then the caller class is the lookupClass.\n@@ -3487,1 +3659,1 @@\n-            if (MethodHandleNatives.isCallerSensitive(m) && !hasFullPrivilegeAccess()) {\n+            if (MethodHandleNatives.isCallerSensitive(m) && (lookupModes() & ORIGINAL) == 0) {\n@@ -3513,1 +3685,2 @@\n-         * access all members that are allowed to the {@linkplain #lookupClass() lookup class}.\n+         * access all members that are allowed to the\n+         * {@linkplain #lookupClass() lookup class}.\n@@ -3534,2 +3707,2 @@\n-            boolean fullPowerLookup = hasFullPrivilegeAccess();\n-            if (!fullPowerLookup ||\n+            boolean fullPrivilegeLookup = hasFullPrivilegeAccess();\n+            if (!fullPrivilegeLookup ||\n@@ -3541,1 +3714,1 @@\n-            if (!fullPowerLookup) {\n+            if (!fullPrivilegeLookup) {\n@@ -3549,1 +3722,5 @@\n-         * If this lookup object has full privilege access, then the caller class is the lookupClass.\n+         * If this lookup object has full privilege access except original access,\n+         * then the caller class is the lookupClass.\n+         *\n+         * Lookup object created by {@link MethodHandles#privateLookupIn(Class, Lookup)}\n+         * from the same module skips the security permission check.\n@@ -3561,2 +3738,2 @@\n-            boolean fullPowerLookup = hasFullPrivilegeAccess();\n-            if (!fullPowerLookup ||\n+            boolean fullPrivilegeLookup = hasFullPrivilegeAccess();\n+            if (!fullPrivilegeLookup ||\n@@ -3569,1 +3746,1 @@\n-            if (!fullPowerLookup) {\n+            if (!fullPrivilegeLookup) {\n@@ -3575,1 +3752,1 @@\n-            if (!fullPowerLookup && defc != refc) {\n+            if (!fullPrivilegeLookup && defc != refc) {\n@@ -3790,1 +3967,1 @@\n-            if (!boundCaller.hasFullPrivilegeAccess())\n+            if ((boundCaller.lookupModes() & ORIGINAL) == 0)\n@@ -3793,0 +3970,2 @@\n+            assert boundCaller.hasFullPrivilegeAccess();\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":256,"deletions":77,"binary":false,"changes":333,"status":"modified"},{"patch":"@@ -1348,0 +1348,1 @@\n+    @Deprecated(since = \"15\", forRemoval = true)\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/Unsafe.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+    private static final int ORIGINAL_ALLOWED = java.lang.invoke.MethodHandles.Lookup.ORIGINAL;\n@@ -102,1 +103,1 @@\n-        assert((allowedModes & ~(ALL_ACCESS_MODES|PACKAGE_ALLOWED|MODULE_ALLOWED|UNCONDITIONAL_ALLOWED)) == 0);\n+        assert((allowedModes & ~(ALL_ACCESS_MODES|PACKAGE_ALLOWED|MODULE_ALLOWED|UNCONDITIONAL_ALLOWED|ORIGINAL_ALLOWED)) == 0);\n@@ -192,1 +193,1 @@\n-        assert((allowedModes & ~(ALL_ACCESS_MODES|PACKAGE_ALLOWED|MODULE_ALLOWED|UNCONDITIONAL_ALLOWED)) == 0);\n+        assert((allowedModes & ~(ALL_ACCESS_MODES|PACKAGE_ALLOWED|MODULE_ALLOWED|UNCONDITIONAL_ALLOWED|ORIGINAL_ALLOWED)) == 0);\n","filename":"src\/java.base\/share\/classes\/sun\/invoke\/util\/VerifyAccess.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -870,2 +870,3 @@\n-     * @deprecated Use the {@link java.lang.invoke.MethodHandles.Lookup#defineHiddenClass(byte[], boolean, MethodHandles.Lookup.ClassOption...)}\n-     * method.\n+     * @deprecated Use {@link java.lang.invoke.MethodHandles.Lookup#defineHiddenClass(byte[], boolean, MethodHandles.Lookup.ClassOption...)}\n+     * or {@link java.lang.invoke.MethodHandles.Lookup#defineHiddenClassWithClassData(byte[], Object, boolean, MethodHandles.Lookup.ClassOption...)}\n+     * instead.\n@@ -878,1 +879,2 @@\n-    @Deprecated(since = \"15\", forRemoval = false)\n+    @Deprecated(since = \"15\", forRemoval = true)\n+    @SuppressWarnings(\"removal\")\n","filename":"src\/jdk.unsupported\/share\/classes\/sun\/misc\/Unsafe.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -151,1 +151,2 @@\n-                     || lookupModes == (PUBLIC|MODULE|PACKAGE|PRIVATE|PROTECTED))\n+                     || lookupModes == (PUBLIC|MODULE|PACKAGE|PRIVATE|PROTECTED)\n+                     || lookupModes == (PUBLIC|MODULE|PACKAGE|PRIVATE|PROTECTED|ORIGINAL))\n@@ -163,1 +164,1 @@\n-         * [A2] However, the resulting {@code Lookup} object is guaranteed\n+         * [A1-a] However, the resulting {@code Lookup} object is guaranteed\n@@ -166,0 +167,2 @@\n+         * [A2] If the new lookup class is not the same as the old lookup class,\n+         * then {@link #ORIGINAL ORIGINAL} access is lost.\n@@ -230,1 +233,4 @@\n-                changed |= (PUBLIC|MODULE|PACKAGE|PRIVATE|PROTECTED|UNCONDITIONAL);  \/\/ [A6]\n+                changed |= (PUBLIC|MODULE|PACKAGE|PRIVATE|PROTECTED|UNCONDITIONAL);  \/\/ [A7]\n+            }\n+            if (!sameClass) {\n+                changed |= ORIGINAL;  \/\/ [A2]\n@@ -234,1 +240,1 @@\n-                changed |= (PUBLIC|MODULE|PACKAGE|PRIVATE|PROTECTED);  \/\/ [A7]\n+                changed |= (PUBLIC|MODULE|PACKAGE|PRIVATE|PROTECTED);  \/\/ [A8]\n@@ -257,1 +263,1 @@\n-            assert((modes1 | modes2) == modes1);    \/\/ [A2] (no elevation of access)\n+            assert((modes1 | modes2) == modes1);    \/\/ [A1-a] (no elevation of access)\n@@ -264,1 +270,1 @@\n-            int newModes = oldModes & ~(modeToDrop | PROTECTED);\n+            int newModes = oldModes & ~(modeToDrop | PROTECTED | ORIGINAL);\n@@ -271,0 +277,1 @@\n+                case ORIGINAL:\n","filename":"test\/jdk\/java\/lang\/invoke\/AccessControlTest.java","additions":13,"deletions":6,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-        assertTrue(fullPowerLookup.lookupModes() == (PUBLIC|MODULE|PACKAGE|PROTECTED|PRIVATE));\n+        assertTrue(fullPowerLookup.lookupModes() == (PUBLIC|MODULE|PACKAGE|PROTECTED|PRIVATE|ORIGINAL));\n@@ -81,1 +81,1 @@\n-        assertTrue(lookup.lookupModes() == (PUBLIC|MODULE|PACKAGE|PROTECTED|PRIVATE));\n+        assertTrue(lookup.lookupModes() == (PUBLIC|MODULE|PACKAGE|PROTECTED|PRIVATE|ORIGINAL));\n","filename":"test\/jdk\/java\/lang\/invoke\/DropLookupModeTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,474 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8230501\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.org.objectweb.asm\n+ * @build java.base\/*\n+ * @run testng\/othervm ClassDataTest\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.UncheckedIOException;\n+import java.lang.invoke.ClassDataHelper;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+import jdk.internal.org.objectweb.asm.*;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import static java.lang.invoke.MethodHandles.Lookup.*;\n+import static jdk.internal.org.objectweb.asm.Opcodes.*;\n+import static org.testng.Assert.*;\n+\n+public class ClassDataTest {\n+    private static final Lookup LOOKUP = MethodHandles.lookup();\n+\n+    @Test\n+    public void testOriginalAccess() throws Throwable {\n+        Lookup lookup = hiddenClass(20);\n+        assertTrue(lookup.hasFullPrivilegeAccess());\n+\n+        int value = MethodHandles.classData(lookup, \"dummy\", int.class);\n+        assertEquals(value, 20);\n+\n+        Integer i = MethodHandles.classData(lookup, \"dummy\", Integer.class);\n+        assertEquals(i.intValue(), 20);\n+    }\n+\n+    \/*\n+     * A lookup class with no class data.\n+     *\/\n+    @Test\n+    public void noClassData() throws Throwable {\n+        assertNull(MethodHandles.classData(LOOKUP, \"dummy\", Object.class));\n+    }\n+\n+    @DataProvider(name = \"teleportedLookup\")\n+    private Object[][] teleportedLookup() throws Throwable {\n+        Lookup lookup = hiddenClass(30);\n+        Class<?> hc = lookup.lookupClass();\n+        assertClassData(lookup, 30);\n+\n+        int fullAccess = PUBLIC|PROTECTED|PACKAGE|MODULE|PRIVATE;\n+        return new Object[][] {\n+                new Object[] { MethodHandles.privateLookupIn(hc, LOOKUP), fullAccess},\n+                new Object[] { LOOKUP.in(hc), fullAccess & ~(PROTECTED|PRIVATE) },\n+                new Object[] { lookup.dropLookupMode(PRIVATE), fullAccess & ~(PROTECTED|PRIVATE) },\n+        };\n+    }\n+\n+    @Test(dataProvider = \"teleportedLookup\", expectedExceptions = { IllegalAccessException.class })\n+    public void illegalAccess(Lookup lookup, int access) throws Throwable {\n+        int lookupModes = lookup.lookupModes();\n+        assertTrue((lookupModes & ORIGINAL) == 0);\n+        assertEquals(lookupModes, access);\n+        MethodHandles.classData(lookup, \"no original access\", int.class);\n+    }\n+\n+    @Test(expectedExceptions = { ClassCastException.class })\n+    public void incorrectType() throws Throwable {\n+        Lookup lookup = hiddenClass(20);\n+        MethodHandles.classData(lookup, \"incorrect type\", Long.class);\n+    }\n+\n+    @Test(expectedExceptions = { IndexOutOfBoundsException.class })\n+    public void invalidIndex() throws Throwable {\n+        Lookup lookup = hiddenClass(List.of());\n+        ClassDataHelper.classDataAt(lookup, \"OOB\", Object.class, 0);\n+    }\n+\n+    @Test(expectedExceptions = { NullPointerException.class })\n+    public void unboxNull() throws Throwable {\n+        List<Integer> list = new ArrayList<>();\n+        list.add(null);\n+        Lookup lookup = hiddenClass(list);\n+        ClassDataHelper.classDataAt(lookup, \"null element\", int.class, 0);\n+    }\n+\n+    @Test\n+    public void nullElement() throws Throwable {\n+        List<Object> list = new ArrayList<>();\n+        list.add(null);\n+        Lookup lookup = hiddenClass(list);\n+        assertTrue(ClassDataHelper.classDataAt(lookup, \"null\", Object.class, 0) == null);\n+    }\n+\n+    @Test\n+    public void intClassData() throws Throwable {\n+        ClassByteBuilder builder = new ClassByteBuilder(\"T1-int\");\n+        byte[] bytes = builder.classData(ACC_PUBLIC|ACC_STATIC, int.class).build();\n+        Lookup lookup = LOOKUP.defineHiddenClassWithClassData(bytes, 100, true);\n+        int value = MethodHandles.classData(lookup, \"dummy\", int.class);\n+        assertEquals(value, 100);\n+        \/\/ call through condy\n+        assertClassData(lookup, 100);\n+    }\n+\n+    @Test\n+    public void floatClassData() throws Throwable {\n+        ClassByteBuilder builder = new ClassByteBuilder(\"T1-float\");\n+        byte[] bytes = builder.classData(ACC_PUBLIC|ACC_STATIC, float.class).build();\n+        Lookup lookup = LOOKUP.defineHiddenClassWithClassData(bytes, 0.1234f, true);\n+        float value = MethodHandles.classData(lookup, \"dummy\", float.class);\n+        assertEquals(value, 0.1234f);\n+        \/\/ call through condy\n+        assertClassData(lookup, 0.1234f);\n+    }\n+\n+    @Test\n+    public void classClassData() throws Throwable {\n+        Class<?> hc = hiddenClass(100).lookupClass();\n+        ClassByteBuilder builder = new ClassByteBuilder(\"T2\");\n+        byte[] bytes = builder.classData(ACC_PUBLIC|ACC_STATIC, Class.class).build();\n+        Lookup lookup = LOOKUP.defineHiddenClassWithClassData(bytes, hc, true);\n+        Class<?> value = MethodHandles.classData(lookup, \"dummy\", Class.class);\n+        assertEquals(value, hc);\n+        \/\/ call through condy\n+        assertClassData(lookup, hc);\n+    }\n+\n+    @Test\n+    public void arrayClassData() throws Throwable {\n+        ClassByteBuilder builder = new ClassByteBuilder(\"T3\");\n+        byte[] bytes = builder.classData(ACC_PUBLIC|ACC_STATIC, String[].class).build();\n+        String[] colors = new String[] { \"red\", \"yellow\", \"blue\"};\n+        Lookup lookup = LOOKUP.defineHiddenClassWithClassData(bytes, colors, true);\n+        assertClassData(lookup, colors.clone());\n+        \/\/ class data is modifiable and not a constant\n+        colors[0] = \"black\";\n+        \/\/ it will get back the modified class data\n+        String[] value = MethodHandles.classData(lookup, \"dummy\", String[].class);\n+        assertEquals(value, colors);\n+        \/\/ even call through condy as it's not a constant\n+        assertClassData(lookup, colors);\n+    }\n+\n+    @Test\n+    public void listClassData() throws Throwable {\n+        ClassByteBuilder builder = new ClassByteBuilder(\"T4\");\n+        byte[] bytes = builder.classDataAt(ACC_PUBLIC|ACC_STATIC, Integer.class, 2).build();\n+        List<Integer> cd = List.of(100, 101, 102, 103);\n+        int expected = 102;  \/\/ element at index=2\n+        Lookup lookup = LOOKUP.defineHiddenClassWithClassData(bytes, cd, true);\n+        int value = ClassDataHelper.classDataAt(lookup, \"2\", int.class, 2);\n+        assertEquals(value, expected);\n+        \/\/ call through condy\n+        assertClassData(lookup, expected);\n+    }\n+\n+    @Test\n+    public void arrayListClassData() throws Throwable {\n+        ClassByteBuilder builder = new ClassByteBuilder(\"T4\");\n+        byte[] bytes = builder.classDataAt(ACC_PUBLIC|ACC_STATIC, Integer.class, 1).build();\n+        ArrayList<Integer> cd = new ArrayList<>();\n+        Stream.of(100, 101, 102, 103).forEach(cd::add);\n+        int expected = 101;  \/\/ element at index=1\n+        Lookup lookup = LOOKUP.defineHiddenClassWithClassData(bytes, cd, true);\n+        int value = ClassDataHelper.classDataAt(lookup, \"1\", int.class, 1);\n+        assertEquals(value, expected);\n+        \/\/ call through condy\n+        assertClassData(lookup, expected);\n+    }\n+\n+    private static Lookup hiddenClass(int value) {\n+        ClassByteBuilder builder = new ClassByteBuilder(\"HC\");\n+        byte[] bytes = builder.classData(ACC_PUBLIC|ACC_STATIC, int.class).build();\n+        try {\n+            return LOOKUP.defineHiddenClassWithClassData(bytes, value, true);\n+        } catch (Throwable e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+    private static Lookup hiddenClass(List<?> list) {\n+        ClassByteBuilder builder = new ClassByteBuilder(\"HC\");\n+        byte[] bytes = builder.classData(ACC_PUBLIC|ACC_STATIC, List.class).build();\n+        try {\n+            return LOOKUP.defineHiddenClassWithClassData(bytes, list, true);\n+        } catch (Throwable e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    @Test\n+    public void condyInvokedFromVirtualMethod() throws Throwable {\n+        ClassByteBuilder builder = new ClassByteBuilder(\"T5\");\n+        \/\/ generate classData instance method\n+        byte[] bytes = builder.classData(ACC_PUBLIC, Class.class).build();\n+        Lookup hcLookup = hiddenClass(100);\n+        assertClassData(hcLookup, 100);\n+        Class<?> hc = hcLookup.lookupClass();\n+        Lookup lookup = LOOKUP.defineHiddenClassWithClassData(bytes, hc, true);\n+        Class<?> value = MethodHandles.classData(lookup, \"dummy\", Class.class);\n+        assertEquals(value, hc);\n+        \/\/ call through condy\n+        Class<?> c = lookup.lookupClass();\n+        assertClassData(lookup, c.newInstance(), hc);\n+    }\n+\n+    @Test\n+    public void immutableListClassData() throws Throwable {\n+        ClassByteBuilder builder = new ClassByteBuilder(\"T6\");\n+        \/\/ generate classDataAt instance method\n+        byte[] bytes = builder.classDataAt(ACC_PUBLIC, Integer.class, 2).build();\n+        List<Integer> cd = List.of(100, 101, 102, 103);\n+        int expected = 102;  \/\/ element at index=2\n+        Lookup lookup = LOOKUP.defineHiddenClassWithClassData(bytes, cd, true);\n+        int value = ClassDataHelper.classDataAt(lookup, \"2\", int.class, 2);\n+        assertEquals(value, expected);\n+        \/\/ call through condy\n+        Class<?> c = lookup.lookupClass();\n+        assertClassData(lookup, c.newInstance() ,expected);\n+    }\n+\n+    \/*\n+     * The return value of MethodHandles::classDataAt is the element\n+     * contained in the list when the method is called.\n+     * If MethodHandles::classDataAt is called via condy, the value\n+     * will be captured as a constant.  If the class data is modified\n+     * after the element at the given index is computed via condy,\n+     * subsequent LDC of such ConstantDynamic entry will return the same\n+     * value. However, direct invocation of MethodHandles::classDataAt\n+     * will return the modified value.\n+     *\/\n+    @Test\n+    public void mutableListClassData() throws Throwable {\n+        ClassByteBuilder builder = new ClassByteBuilder(\"T7\");\n+        \/\/ generate classDataAt instance method\n+        byte[] bytes = builder.classDataAt(ACC_PUBLIC, MethodType.class, 0).build();\n+        MethodType mtype = MethodType.methodType(int.class, String.class);\n+        List<MethodType> cd = new ArrayList<>(List.of(mtype));\n+        Lookup lookup = LOOKUP.defineHiddenClassWithClassData(bytes, cd, true);\n+        \/\/ call through condy\n+        Class<?> c = lookup.lookupClass();\n+        assertClassData(lookup, c.newInstance(), mtype);\n+        \/\/ modify the class data\n+        assertTrue(cd.remove(0) == mtype);\n+        cd.add(0,  MethodType.methodType(void.class));\n+        MethodType newMType = cd.get(0);\n+        \/\/ loading the element using condy returns the original value\n+        assertClassData(lookup, c.newInstance(), mtype);\n+        \/\/ direct invocation of MethodHandles.classDataAt returns the modified value\n+        assertEquals(ClassDataHelper.classDataAt(lookup, \"new MethodType\", MethodType.class, 0), newMType);\n+    }\n+\n+    static class ClassByteBuilder {\n+        private static final String OBJECT_CLS = \"java\/lang\/Object\";\n+        private static final String MHS_CLS = \"java\/lang\/invoke\/MethodHandles\";\n+        private static final String CLASS_DATA_BSM_DESCR =\n+                \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/Class;)Ljava\/lang\/Object;\";\n+        private final ClassWriter cw;\n+        private final String classname;\n+\n+        \/**\n+         * A builder to generate a class file to access class data\n+         * @param classname\n+         *\/\n+        ClassByteBuilder(String classname) {\n+            this.classname = classname;\n+            this.cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES);\n+            cw.visit(V14, ACC_FINAL, classname, null, OBJECT_CLS, null);\n+            MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, \"<init>\", \"()V\", null, null);\n+            mv.visitCode();\n+            mv.visitVarInsn(ALOAD, 0);\n+            mv.visitMethodInsn(INVOKESPECIAL, OBJECT_CLS, \"<init>\", \"()V\", false);\n+            mv.visitInsn(RETURN);\n+            mv.visitMaxs(0, 0);\n+            mv.visitEnd();\n+        }\n+\n+        byte[] build() {\n+            cw.visitEnd();\n+            byte[] bytes = cw.toByteArray();\n+            Path p = Paths.get(classname + \".class\");\n+                try (OutputStream os = Files.newOutputStream(p)) {\n+                os.write(bytes);\n+            } catch (IOException e) {\n+                throw new UncheckedIOException(e);\n+            }\n+            return bytes;\n+        }\n+\n+        \/*\n+         * Generate classData method to load class data via condy\n+         *\/\n+        ClassByteBuilder classData(int accessFlags, Class<?> returnType) {\n+            MethodType mtype = MethodType.methodType(returnType);\n+            MethodVisitor mv = cw.visitMethod(accessFlags,\n+                                             \"classData\",\n+                                              mtype.descriptorString(), null, null);\n+            mv.visitCode();\n+            Handle bsm = new Handle(H_INVOKESTATIC, MHS_CLS, \"classData\",\n+                                    CLASS_DATA_BSM_DESCR,\n+                                    false);\n+            ConstantDynamic dynamic = new ConstantDynamic(\"dummy\", Type.getDescriptor(returnType), bsm);\n+            mv.visitLdcInsn(dynamic);\n+            mv.visitInsn(returnType == int.class ? IRETURN :\n+                            (returnType == float.class ? FRETURN : ARETURN));\n+            mv.visitMaxs(0, 0);\n+            mv.visitEnd();\n+            return this;\n+        }\n+\n+        \/*\n+         * Generate classDataAt method to load an element from class data via condy\n+         *\/\n+        ClassByteBuilder classDataAt(int accessFlags, Class<?> returnType, int index) {\n+            MethodType mtype = MethodType.methodType(returnType);\n+            MethodVisitor mv = cw.visitMethod(accessFlags,\n+                                              \"classData\",\n+                                               mtype.descriptorString(), null, null);\n+            mv.visitCode();\n+            Handle bsm = new Handle(H_INVOKESTATIC, \"java\/lang\/invoke\/ClassDataHelper\", \"classDataAt\",\n+                        \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/Class;I)Ljava\/lang\/Object;\",\n+                        false);\n+            ConstantDynamic dynamic = new ConstantDynamic(\"classDataAt\", Type.getDescriptor(returnType), bsm, index);\n+            mv.visitLdcInsn(dynamic);\n+            mv.visitInsn(returnType == int.class? IRETURN : ARETURN);\n+            mv.visitMaxs(0, 0);\n+            mv.visitEnd();\n+            return this;\n+        }\n+    }\n+\n+    \/*\n+     * Load an int constant from class data via condy and\n+     * verify it matches the given value.\n+     *\/\n+    private void assertClassData(Lookup lookup, int value) throws Throwable {\n+        try {\n+            Class<?> c = lookup.lookupClass();\n+            Method m = c.getMethod(\"classData\");\n+            int v = (int)m.invoke(null);\n+            assertEquals(value, v);\n+        } catch (InvocationTargetException e) {\n+            throw e.getCause();\n+        }\n+    }\n+\n+    \/*\n+     * Load an int constant from class data via condy and\n+     * verify it matches the given value.\n+     *\/\n+    private void assertClassData(Lookup lookup, Object o, int value) throws Throwable {\n+        try {\n+            Class<?> c = lookup.lookupClass();\n+            Method m = c.getMethod(\"classData\");\n+            int v = (int)m.invoke(o);\n+            assertEquals(value, v);\n+        } catch (InvocationTargetException e) {\n+            throw e.getCause();\n+        }\n+    }\n+\n+    \/*\n+     * Load a float constant from class data via condy and\n+     * verify it matches the given value.\n+     *\/\n+    private void assertClassData(Lookup lookup, float value) throws Throwable {\n+        try {\n+            Class<?> c = lookup.lookupClass();\n+            Method m = c.getMethod(\"classData\");\n+            float v = (float)m.invoke(null);\n+            assertEquals(value, v);\n+        } catch (InvocationTargetException e) {\n+            throw e.getCause();\n+        }\n+    }\n+\n+    \/*\n+     * Load a Class constant from class data via condy and\n+     * verify it matches the given value.\n+     *\/\n+    private void assertClassData(Lookup lookup, Class<?> value) throws Throwable {\n+        try {\n+            Class<?> c = lookup.lookupClass();\n+            Method m = c.getMethod(\"classData\");\n+            Class<?> v = (Class<?>)m.invoke(null);\n+            assertEquals(value, v);\n+        } catch (InvocationTargetException e) {\n+            throw e.getCause();\n+        }\n+    }\n+\n+    \/*\n+     * Load a Class from class data via condy and\n+     * verify it matches the given value.\n+     *\/\n+    private void assertClassData(Lookup lookup, Object o, Class<?> value) throws Throwable {\n+        try {\n+            Class<?> c = lookup.lookupClass();\n+            Method m = c.getMethod(\"classData\");\n+            Object v = m.invoke(o);\n+            assertEquals(value, v);\n+        } catch (InvocationTargetException e) {\n+            throw e.getCause();\n+        }\n+    }\n+\n+    \/*\n+     * Load an Object from class data via condy and\n+     * verify it matches the given value.\n+     *\/\n+    private void assertClassData(Lookup lookup, Object value) throws Throwable {\n+        try {\n+            Class<?> c = lookup.lookupClass();\n+            Method m = c.getMethod(\"classData\");\n+            Object v = m.invoke(null);\n+            assertEquals(value, v);\n+        } catch (InvocationTargetException e) {\n+            throw e.getCause();\n+        }\n+    }\n+\n+    \/*\n+     * Load an Object from class data via condy and\n+     * verify it matches the given value.\n+     *\/\n+    private void assertClassData(Lookup lookup, Object o, Object value) throws Throwable {\n+        try {\n+            Class<?> c = lookup.lookupClass();\n+            Method m = c.getMethod(\"classData\");\n+            Object v = m.invoke(o);\n+            assertEquals(value, v);\n+        } catch (InvocationTargetException e) {\n+            throw e.getCause();\n+        }\n+    }\n+}\n+\n+\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandles\/classData\/ClassDataTest.java","additions":474,"deletions":0,"binary":false,"changes":474,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.invoke;\n+\n+import java.lang.invoke.MethodHandles.Lookup;\n+\n+\/**\n+ * Helper class to inject into java.lang.invoke that provides access to\n+ * package-private methods in this package.\n+ *\/\n+public class ClassDataHelper {\n+    private ClassDataHelper() { }\n+    public static <T> T classDataAt(Lookup caller, String key, Class<T> type, int index) throws IllegalAccessException {\n+        return MethodHandles.classDataAt(caller, key, type, index);\n+    }\n+}\n+\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandles\/classData\/java.base\/java\/lang\/invoke\/ClassDataHelper.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -42,1 +42,0 @@\n-\n@@ -78,0 +77,1 @@\n+        assertTrue((lookup.lookupModes() & ORIGINAL) == 0);\n@@ -91,0 +91,1 @@\n+        assertTrue((caller.lookupModes() & ORIGINAL) == 0);\n@@ -116,2 +117,2 @@\n-        assertTrue((lookup.lookupModes() & PRIVATE) != 0);\n-        assertFalse(lookup.hasFullPrivilegeAccess());\n+        assertTrue((lookup.lookupModes() & PRIVATE) == PRIVATE);\n+        assertTrue((lookup.lookupModes() & MODULE) == 0);\n@@ -141,1 +142,2 @@\n-        assertTrue((lookup.lookupModes() & PRIVATE) != 0);\n+        assertTrue((lookup.lookupModes() & PRIVATE) == PRIVATE);\n+        assertTrue((lookup.lookupModes() & MODULE) == 0);\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandles\/privateLookupIn\/test\/p\/PrivateLookupInTests.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -75,0 +75,1 @@\n+        assertTrue((lookup.lookupModes() & ORIGINAL) == ORIGINAL);\n@@ -140,0 +141,2 @@\n+        assertTrue((lc.lookupModes() & ORIGINAL) == 0);\n+\n","filename":"test\/jdk\/java\/lang\/invoke\/defineHiddenClass\/HiddenNestmateTest.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -94,1 +94,1 @@\n-     * [A2] PROTECTED and PRIVATE are dropped\n+     * [A2] PROTECTED, PRIVATE and ORIGINAL are dropped\n@@ -105,1 +105,1 @@\n-        assertTrue(lookup2.lookupModes() == (lookup.lookupModes() & ~(PROTECTED|PRIVATE)));  \/\/ [A2]\n+        assertTrue(lookup2.lookupModes() == (lookup.lookupModes() & ~(PROTECTED|PRIVATE|ORIGINAL)));  \/\/ [A2]\n@@ -122,1 +122,1 @@\n-     * [A2] PROTECTED, PRIVATE and PACKAGE are dropped\n+     * [A2] PROTECTED, PRIVATE, PACKAGE and ORIGINAL are dropped\n@@ -133,1 +133,1 @@\n-        assertTrue(lookup2.lookupModes() == (lookup.lookupModes() & ~(PROTECTED|PRIVATE|PACKAGE))); \/\/ [A2]\n+        assertTrue(lookup2.lookupModes() == (lookup.lookupModes() & ~(PROTECTED|PRIVATE|PACKAGE|ORIGINAL))); \/\/ [A2]\n@@ -151,1 +151,1 @@\n-     * [A2] PROTECTED, PRIVATE, PACKAGE, and MODULE are dropped\n+     * [A2] PROTECTED, PRIVATE, PACKAGE, MODULE and ORIGINAL are dropped\n@@ -171,1 +171,1 @@\n-        assertTrue(lookup2.lookupModes() == (lookup.lookupModes() & ~(PROTECTED|PRIVATE|PACKAGE|MODULE)));  \/\/ [A2]\n+        assertTrue(lookup2.lookupModes() == (lookup.lookupModes() & ~(PROTECTED|PRIVATE|PACKAGE|MODULE|ORIGINAL)));  \/\/ [A2]\n@@ -292,1 +292,1 @@\n-        assertTrue(lookup1.lookupModes() == (lookup.lookupModes() & ~(PROTECTED|PRIVATE|PACKAGE|MODULE)));\n+        assertTrue(lookup1.lookupModes() == (lookup.lookupModes() & ~(PROTECTED|PRIVATE|PACKAGE|MODULE|ORIGINAL)));\n","filename":"test\/jdk\/java\/lang\/invoke\/modules\/m3\/jdk\/test\/ModuleAccessTest.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -233,1 +233,1 @@\n-        @SuppressWarnings(\"deprecation\")\n+        @SuppressWarnings(\"removal\")\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/invoke\/LookupDefineClass.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}