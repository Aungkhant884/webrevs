{"files":[{"patch":"@@ -416,2 +416,2 @@\n-        } catch (ClassCastException e) {\n-            throw e; \/\/ specified, let CCE through\n+        } catch (RuntimeException|Error e) {\n+            throw e; \/\/ let specified CCE and other runtime exceptions\/errors through\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/ConstantBootstraps.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -288,0 +288,5 @@\n+     * <p> A hidden class created by {@link Lookup#defineHiddenClass(byte[], boolean, Lookup.ClassOption...)\n+     * Lookup::defineHiddenClass} and non-hidden classes have no class data.\n+     * {@code null} is returned if this method is called on the lookup object\n+     * on these classes.\n+     *\n@@ -340,2 +345,2 @@\n-         } catch (ClassCastException e) {\n-             throw e;\n+         } catch (RuntimeException|Error e) {\n+             throw e; \/\/ let CCE and other runtime exceptions through\n@@ -362,0 +367,5 @@\n+     * <p> A hidden class created by {@link Lookup#defineHiddenClass(byte[], boolean, Lookup.ClassOption...)\n+     * Lookup::defineHiddenClass} and non-hidden classes have no class data.\n+     * {@code null} is returned if this method is called on the lookup object\n+     * on these classes.\n+     *\n@@ -412,2 +422,2 @@\n-        } catch (ClassCastException|NullPointerException|IndexOutOfBoundsException e) {\n-            throw e;\n+        } catch (RuntimeException|Error e) {\n+            throw e; \/\/ let specified exceptions and other runtime exceptions\/errors through\n@@ -2149,2 +2159,4 @@\n-         * If you use a {@code List}, it is a good practice to make it unmodifiable\n-         * for example via {@link List#of List::of}.\n+         * Changing any value stored at the class data at runtime may lead to\n+         * unpredictable behavior.\n+         * If the class data is a {@code List}, it is a good practice to make it\n+         * unmodifiable for example via {@link List#of List::of}.\n@@ -3613,1 +3625,1 @@\n-                if (!hasFullPrivilegeAccess() || callerClass != lookupClass())\n+                if ((lookupModes() & ORIGINAL) == 0 || callerClass != lookupClass())\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":19,"deletions":7,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -120,0 +120,31 @@\n+    \/**\n+     * Using a Lookup with no original access that can't lookup caller-sensitive\n+     * method\n+     *\/\n+    @Test(dataProvider = \"callerSensitiveMethods\",\n+            expectedExceptions = IllegalAccessException.class)\n+    public void testLookupNoOriginalAccessFind(@NoInjection Method method, String desc) throws Exception {\n+        Lookup lookup = MethodHandles.lookup().dropLookupMode(Lookup.ORIGINAL);\n+        assertTrue(lookup.hasFullPrivilegeAccess());\n+        Class<?> refc = method.getDeclaringClass();\n+        String name = method.getName();\n+        MethodType mt = MethodType.methodType(method.getReturnType(), method.getParameterTypes());\n+        if (Modifier.isStatic(method.getModifiers())) {\n+            lookup.findStatic(refc, name, mt);\n+        } else {\n+            lookup.findVirtual(refc, name, mt);\n+        }\n+    }\n+\n+    \/**\n+     * Using a Lookup with no original access that can't unreflect caller-sensitive\n+     * method\n+     *\/\n+    @Test(dataProvider = \"callerSensitiveMethods\",\n+            expectedExceptions = IllegalAccessException.class)\n+    public void testLookupNoOriginalAccessUnreflect(@NoInjection Method method, String desc) throws Exception {\n+        Lookup lookup = MethodHandles.lookup().dropLookupMode(Lookup.ORIGINAL);\n+        assertTrue(lookup.hasFullPrivilegeAccess());\n+        lookup.unreflect(method);\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/invoke\/CallerSensitiveAccess.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-import java.lang.reflect.InvocationTargetException;\n@@ -50,1 +49,0 @@\n-import org.testng.annotations.BeforeTest;\n@@ -62,1 +60,1 @@\n-    public void testOriginalAccess() throws Throwable {\n+    public void testOriginalAccess() throws IllegalAccessException {\n@@ -77,1 +75,1 @@\n-    public void noClassData() throws Throwable {\n+    public void noClassData() throws IllegalAccessException {\n@@ -82,1 +80,1 @@\n-    private Object[][] teleportedLookup() throws Throwable {\n+    private Object[][] teleportedLookup() throws ReflectiveOperationException {\n@@ -96,1 +94,1 @@\n-    public void illegalAccess(Lookup lookup, int access) throws Throwable {\n+    public void illegalAccess(Lookup lookup, int access) throws IllegalAccessException {\n@@ -104,1 +102,1 @@\n-    public void incorrectType() throws Throwable {\n+    public void incorrectType() throws IllegalAccessException {\n@@ -110,1 +108,1 @@\n-    public void invalidIndex() throws Throwable {\n+    public void invalidIndex() throws IllegalAccessException {\n@@ -116,1 +114,1 @@\n-    public void unboxNull() throws Throwable {\n+    public void unboxNull() throws IllegalAccessException {\n@@ -124,1 +122,1 @@\n-    public void nullElement() throws Throwable {\n+    public void nullElement() throws IllegalAccessException {\n@@ -132,1 +130,1 @@\n-    public void intClassData() throws Throwable {\n+    public void intClassData() throws ReflectiveOperationException {\n@@ -143,1 +141,1 @@\n-    public void floatClassData() throws Throwable {\n+    public void floatClassData() throws ReflectiveOperationException {\n@@ -154,1 +152,1 @@\n-    public void classClassData() throws Throwable {\n+    public void classClassData() throws ReflectiveOperationException {\n@@ -166,1 +164,1 @@\n-    public void arrayClassData() throws Throwable {\n+    public void arrayClassData() throws ReflectiveOperationException {\n@@ -182,1 +180,1 @@\n-    public void listClassData() throws Throwable {\n+    public void listClassData() throws ReflectiveOperationException {\n@@ -195,1 +193,1 @@\n-    public void arrayListClassData() throws Throwable {\n+    public void arrayListClassData() throws ReflectiveOperationException {\n@@ -228,1 +226,1 @@\n-    public void condyInvokedFromVirtualMethod() throws Throwable {\n+    public void condyInvokedFromVirtualMethod() throws ReflectiveOperationException {\n@@ -244,1 +242,1 @@\n-    public void immutableListClassData() throws Throwable {\n+    public void immutableListClassData() throws ReflectiveOperationException {\n@@ -269,1 +267,1 @@\n-    public void mutableListClassData() throws Throwable {\n+    public void mutableListClassData() throws ReflectiveOperationException {\n@@ -290,1 +288,1 @@\n-    public static <T> T getClassDataEntry(Lookup lookup, String key, Class<T> type) throws Throwable {\n+    public static <T> T getClassDataEntry(Lookup lookup, String key, Class<T> type) throws IllegalAccessException {\n@@ -296,1 +294,1 @@\n-    public void classDataMap() throws Throwable {\n+    public void classDataMap() throws ReflectiveOperationException {\n@@ -322,14 +320,7 @@\n-        try {\n-            Method m = c.getMethod(\"getClass\");\n-            Class<?> v = (Class<?>)m.invoke(null);\n-            assertEquals(hc, v);\n-        } catch (InvocationTargetException e) {\n-            throw e.getCause();\n-        }\n-        try {\n-            Method m = c.getMethod(\"getMethod\");\n-            MethodHandle v = (MethodHandle)m.invoke(null);\n-            assertEquals(mh, v);\n-        } catch (InvocationTargetException e) {\n-            throw e.getCause();\n-        }\n+        Method m = c.getMethod(\"getClass\");\n+        Class<?> v = (Class<?>)m.invoke(null);\n+        assertEquals(hc, v);\n+\n+        Method m1 = c.getMethod(\"getMethod\");\n+        MethodHandle v1 = (MethodHandle) m1.invoke(null);\n+        assertEquals(mh, v1);\n@@ -339,1 +330,1 @@\n-    public void nonDefaultName() throws Throwable {\n+    public void nonDefaultName() throws ReflectiveOperationException {\n@@ -445,9 +436,5 @@\n-    private void assertClassData(Lookup lookup, int value) throws Throwable {\n-        try {\n-            Class<?> c = lookup.lookupClass();\n-            Method m = c.getMethod(\"classData\");\n-            int v = (int)m.invoke(null);\n-            assertEquals(value, v);\n-        } catch (InvocationTargetException e) {\n-            throw e.getCause();\n-        }\n+    private void assertClassData(Lookup lookup, int value) throws ReflectiveOperationException {\n+        Class<?> c = lookup.lookupClass();\n+        Method m = c.getMethod(\"classData\");\n+        int v = (int) m.invoke(null);\n+        assertEquals(value, v);\n@@ -460,9 +447,5 @@\n-    private void assertClassData(Lookup lookup, Object o, int value) throws Throwable {\n-        try {\n-            Class<?> c = lookup.lookupClass();\n-            Method m = c.getMethod(\"classData\");\n-            int v = (int)m.invoke(o);\n-            assertEquals(value, v);\n-        } catch (InvocationTargetException e) {\n-            throw e.getCause();\n-        }\n+    private void assertClassData(Lookup lookup, Object o, int value) throws ReflectiveOperationException {\n+        Class<?> c = lookup.lookupClass();\n+        Method m = c.getMethod(\"classData\");\n+        int v = (int) m.invoke(o);\n+        assertEquals(value, v);\n@@ -475,9 +458,5 @@\n-    private void assertClassData(Lookup lookup, float value) throws Throwable {\n-        try {\n-            Class<?> c = lookup.lookupClass();\n-            Method m = c.getMethod(\"classData\");\n-            float v = (float)m.invoke(null);\n-            assertEquals(value, v);\n-        } catch (InvocationTargetException e) {\n-            throw e.getCause();\n-        }\n+    private void assertClassData(Lookup lookup, float value) throws ReflectiveOperationException {\n+        Class<?> c = lookup.lookupClass();\n+        Method m = c.getMethod(\"classData\");\n+        float v = (float) m.invoke(null);\n+        assertEquals(value, v);\n@@ -490,9 +469,5 @@\n-    private void assertClassData(Lookup lookup, Class<?> value) throws Throwable {\n-        try {\n-            Class<?> c = lookup.lookupClass();\n-            Method m = c.getMethod(\"classData\");\n-            Class<?> v = (Class<?>)m.invoke(null);\n-            assertEquals(value, v);\n-        } catch (InvocationTargetException e) {\n-            throw e.getCause();\n-        }\n+    private void assertClassData(Lookup lookup, Class<?> value) throws ReflectiveOperationException {\n+        Class<?> c = lookup.lookupClass();\n+        Method m = c.getMethod(\"classData\");\n+        Class<?> v = (Class<?>)m.invoke(null);\n+        assertEquals(value, v);\n@@ -505,9 +480,5 @@\n-    private void assertClassData(Lookup lookup, Object o, Class<?> value) throws Throwable {\n-        try {\n-            Class<?> c = lookup.lookupClass();\n-            Method m = c.getMethod(\"classData\");\n-            Object v = m.invoke(o);\n-            assertEquals(value, v);\n-        } catch (InvocationTargetException e) {\n-            throw e.getCause();\n-        }\n+    private void assertClassData(Lookup lookup, Object o, Class<?> value) throws ReflectiveOperationException {\n+        Class<?> c = lookup.lookupClass();\n+        Method m = c.getMethod(\"classData\");\n+        Object v = m.invoke(o);\n+        assertEquals(value, v);\n@@ -520,9 +491,5 @@\n-    private void assertClassData(Lookup lookup, Object value) throws Throwable {\n-        try {\n-            Class<?> c = lookup.lookupClass();\n-            Method m = c.getMethod(\"classData\");\n-            Object v = m.invoke(null);\n-            assertEquals(value, v);\n-        } catch (InvocationTargetException e) {\n-            throw e.getCause();\n-        }\n+    private void assertClassData(Lookup lookup, Object value) throws ReflectiveOperationException {\n+        Class<?> c = lookup.lookupClass();\n+        Method m = c.getMethod(\"classData\");\n+        Object v = m.invoke(null);\n+        assertEquals(value, v);\n@@ -535,9 +502,5 @@\n-    private void assertClassData(Lookup lookup, Object o, Object value) throws Throwable {\n-        try {\n-            Class<?> c = lookup.lookupClass();\n-            Method m = c.getMethod(\"classData\");\n-            Object v = m.invoke(o);\n-            assertEquals(value, v);\n-        } catch (InvocationTargetException e) {\n-            throw e.getCause();\n-        }\n+    private void assertClassData(Lookup lookup, Object o, Object value) throws ReflectiveOperationException {\n+        Class<?> c = lookup.lookupClass();\n+        Method m = c.getMethod(\"classData\");\n+        Object v = m.invoke(o);\n+        assertEquals(value, v);\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandles\/classData\/ClassDataTest.java","additions":62,"deletions":99,"binary":false,"changes":161,"status":"modified"},{"patch":"@@ -161,0 +161,4 @@\n+        \/\/ CS methods have to have original access\n+        Lookup lookup = Simple.localLookup().dropLookupMode(Lookup.ORIGINAL);\n+        testOnMembersNoLookup(\"testCallerSensitiveNegative\/4\", mems, lookup);\n+        testOnMembersNoReveal(\"testCallerSensitiveNegative\/5\", mems, Simple.localLookup(), lookup);\n","filename":"test\/jdk\/java\/lang\/invoke\/RevealDirectTest.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"}]}