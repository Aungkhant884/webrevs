{"files":[{"patch":"@@ -0,0 +1,154 @@\n+\/*\n+ * Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+  @test\n+  @bug 4722671\n+  @summary Accessibility problem in JRE Finder\n+  @key headful\n+  @run main FocusForRemovedComponentTest\n+*\/\n+\n+import java.awt.AWTException;\n+import java.awt.BorderLayout;\n+import java.awt.Button;\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Point;\n+import java.awt.Robot;\n+\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.event.FocusAdapter;\n+import java.awt.event.FocusEvent;\n+import java.awt.event.InputEvent;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+public class FocusForRemovedComponentTest\n+        implements ActionListener {\n+    static int ACTIVATION_TIMEOUT = 2000;\n+    static long WAIT_TIMEOUT = 3000;\n+    volatile Frame frame;\n+    volatile Button btnFirst;\n+    volatile Button btnSecond;\n+    volatile Button btnThird;\n+\n+    public void start() throws InterruptedException, InvocationTargetException {\n+        try {\n+            EventQueue.invokeAndWait(() -> {\n+                frame = new Frame(\"FocusForRemovedComponentTest\");\n+                btnFirst = new Button(\"First Button\");\n+                btnSecond = new Button(\"Second Button\");\n+                btnThird = new Button(\"Third Button\");\n+                frame.add(btnFirst, BorderLayout.NORTH);\n+                frame.add(btnSecond, BorderLayout.CENTER);\n+                btnFirst.addActionListener(this);\n+                btnFirst.requestFocusInWindow();\n+                frame.pack();\n+                frame.setVisible(true);\n+            });\n+\n+            try {\n+                Robot robot = new Robot();\n+                robot.delay(ACTIVATION_TIMEOUT);\n+                int[] location = new int[2];\n+                EventQueue.invokeAndWait(() -> {\n+                    Point button_location = btnFirst.getLocationOnScreen();\n+                    Dimension button_size = btnFirst.getSize();\n+                    location[0] = button_location.x + button_size.width \/ 2;\n+                    location[1] = button_location.y + button_size.height \/ 2;\n+                });\n+                robot.mouseMove(location[0], location[1]);\n+                robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+                robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+\n+                Object monitor = new Object();\n+                final MonitoredFocusListener monitorer = new MonitoredFocusListener(monitor);\n+                AtomicBoolean isFocused = new AtomicBoolean(false);\n+                synchronized (monitor) {\n+                    EventQueue.invokeAndWait(() -> {\n+                        btnThird.addFocusListener(monitorer);\n+                        isFocused.set(btnThird.isFocusOwner());\n+                    });\n+\n+                    if (!isFocused.get()) {\n+                        monitor.wait(WAIT_TIMEOUT);\n+                        EventQueue.invokeAndWait(() -> {\n+                            isFocused.set(btnThird.isFocusOwner());\n+                        });\n+                    }\n+                }\n+\n+                if (!isFocused.get()) {\n+                    throw new RuntimeException(\"TEST FAILED. The third button is not focus owner.\");\n+                } else {\n+                    System.out.println(\"TEST PASSED.\");\n+                }\n+            } catch (AWTException e) {\n+                e.printStackTrace();\n+                throw new RuntimeException(\"Some AWTException occurred.\");\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+                throw new RuntimeException(\"Test was interrupted.\");\n+            }\n+        } finally {\n+            if (frame != null) {\n+                EventQueue.invokeAndWait(frame::dispose);\n+            }\n+        }\n+    }\n+\n+    public void actionPerformed(ActionEvent e) {\n+        if (btnSecond.isVisible()) {\n+            btnFirst.setEnabled(false);\n+            frame.remove(btnSecond);\n+            frame.add(btnThird, BorderLayout.CENTER);\n+            btnThird.requestFocusInWindow();\n+            btnFirst.setEnabled(true);\n+            frame.validate();\n+            frame.repaint();\n+        }\n+    }\n+\n+    public static void main(String[] args) throws InterruptedException,\n+            InvocationTargetException {\n+        FocusForRemovedComponentTest test = new FocusForRemovedComponentTest();\n+        test.start();\n+    }\n+}\n+\n+class MonitoredFocusListener extends FocusAdapter {\n+    Object monitor;\n+\n+    public MonitoredFocusListener(Object monitor) {\n+        this.monitor = monitor;\n+    }\n+\n+    public void focusGained(FocusEvent fe) {\n+        synchronized (monitor) {\n+            monitor.notify();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Focus\/FocusForRemovedComponentTest.java","additions":154,"deletions":0,"binary":false,"changes":154,"status":"added"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+  @test\n+  @bug 6225100\n+  @summary FocusTraversalPolicy.getInitialComponent does not work as expected\n+  @run main FocusTraversalPolicyIAE\n+*\/\n+\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.FocusTraversalPolicy;\n+\n+public class FocusTraversalPolicyIAE {\n+    public static void main(String[] args) {\n+        CustomFocusTraversalPolicy cftp = new CustomFocusTraversalPolicy();\n+        try {\n+            cftp.getInitialComponent(null);\n+            throw new RuntimeException(\"Test failed. No exceptions thrown.\");\n+        } catch (IllegalArgumentException iae) {\n+            System.out.println(\"Test passed.\");\n+        } catch (NullPointerException npe) {\n+            throw new RuntimeException(\"Test failed. Unexpected NPE thrown: \" + npe);\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Test failed. Unexpected exception thrown: \" + e);\n+        }\n+    }\n+}\n+\n+class CustomFocusTraversalPolicy extends FocusTraversalPolicy {\n+    public Component getComponentAfter(Container focusCycleRoot,\n+                                       Component aComponent) {\n+        return null;\n+    }\n+\n+    public Component getComponentBefore(Container focusCycleRoot,\n+                                        Component aComponent) {\n+        return null;\n+    }\n+\n+    public Component getDefaultComponent(Container focusCycleRoot) {\n+        return null;\n+    }\n+\n+    public Component getFirstComponent(Container focusCycleRoot) {\n+        return null;\n+    }\n+\n+    public Component getLastComponent(Container focusCycleRoot) {\n+        return null;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Focus\/FocusTraversalPolicyIAE.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,144 @@\n+\/*\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+  @test\n+  @bug 4150021\n+  @summary if user requests focus on some component, it must become a focus owner after activation\n+  @key headful\n+  @run main InitialFocusTest\n+*\/\n+\n+import java.awt.AWTException;\n+import java.awt.Button;\n+import java.awt.DefaultKeyboardFocusManager;\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.Insets;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.event.InputEvent;\n+import java.beans.PropertyChangeEvent;\n+import java.beans.PropertyChangeListener;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+public class InitialFocusTest implements PropertyChangeListener {\n+    \/\/Declare things used in the test, like buttons and labels here\n+    final static String FOCUSED_WINDOW_PROP = \"focusedWindow\";\n+    final static int ACTION_TIMEOUT = 2000;\n+\n+    volatile Frame frame;\n+    volatile Button btn1;\n+    volatile Button btn2;\n+\n+    public void start() throws InterruptedException, InvocationTargetException {\n+        DefaultKeyboardFocusManager.getCurrentKeyboardFocusManager().\n+                addPropertyChangeListener(FOCUSED_WINDOW_PROP, this);\n+        try {\n+            EventQueue.invokeAndWait(() -> {\n+                frame = new Frame(\"InitialFocusTest\");\n+                frame.setLayout(new FlowLayout());\n+                btn1 = new Button(\"First Button\");\n+                frame.add(btn1);\n+                btn2 = new Button(\"Second Button\");\n+                frame.add(btn2);\n+                frame.setLocationRelativeTo(null);\n+                frame.pack();\n+                frame.setVisible(true);\n+            });\n+            try {\n+                Robot robot = new Robot();\n+                robot.delay(ACTION_TIMEOUT);\n+                if (!activateFrame(frame, robot, ACTION_TIMEOUT)) {\n+                    throw new RuntimeException(\"Frame was not activated.\");\n+                }\n+                robot.delay(ACTION_TIMEOUT);\n+                AtomicBoolean isFocused = new AtomicBoolean(false);\n+                EventQueue.invokeAndWait(() -> {\n+                    isFocused.set(frame.isFocused());\n+                });\n+                if (!isFocused.get()) {\n+                    throw new RuntimeException(\"Frame didn't become focused.\");\n+                }\n+                EventQueue.invokeAndWait(() -> {\n+                    isFocused.set(btn2.isFocusOwner());\n+                });\n+                if (!isFocused.get()) {\n+                    throw new RuntimeException(\"Btn2 didn't receive focus.\");\n+                }\n+            } catch (AWTException e) {\n+                e.printStackTrace();\n+            }\n+            System.out.printf(\"Test passed.\");\n+        } finally {\n+            if (frame != null) {\n+                EventQueue.invokeAndWait(frame::dispose);\n+            }\n+        }\n+    }\n+\n+    public void propertyChange(PropertyChangeEvent pce) {\n+        if (FOCUSED_WINDOW_PROP.equals(pce.getPropertyName())) {\n+            if (pce.getNewValue() == frame) {\n+                System.out.println(\"requesting focus on btn2\");\n+                btn2.requestFocusInWindow();\n+            }\n+        }\n+    }\n+\n+    boolean activateFrame(Frame frame, Robot robot, int timeout)\n+            throws InterruptedException, InvocationTargetException {\n+        AtomicBoolean isActive = new AtomicBoolean(false);\n+        EventQueue.invokeAndWait(() -> {\n+            isActive.set(frame.isActive());\n+        });\n+        if (!isActive.get()) {\n+            int[] point = new int[2];\n+            EventQueue.invokeAndWait(() -> {\n+                Point origin = frame.getLocationOnScreen();\n+                Dimension dim = frame.getSize();\n+                Insets insets = frame.getInsets();\n+                point[0] = origin.x + dim.width \/ 2;\n+                point[1] = origin.y + insets.top \/ 2;\n+            });\n+            robot.mouseMove(point[0], point[1]);\n+            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.waitForIdle();\n+            robot.delay(timeout);\n+            EventQueue.invokeAndWait(() -> {\n+                isActive.set(frame.isActive());\n+            });\n+        }\n+        return frame.isActive();\n+    }\n+\n+    public static void main(String[] args) throws InterruptedException,\n+            InvocationTargetException {\n+        InitialFocusTest test = new InitialFocusTest();\n+        test.start();\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Focus\/InitialFocusTest.java","additions":144,"deletions":0,"binary":false,"changes":144,"status":"added"},{"patch":"@@ -0,0 +1,180 @@\n+\/*\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+  @test\n+  @bug 4027897\n+  @summary Test that Label can't be made focused by the mouse, while ScrollBar should become focused.\n+  @key headful\n+  @run main LabelScrollBarFocus\n+*\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.EventQueue;\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.Label;\n+import java.awt.Panel;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.Scrollbar;\n+import java.awt.event.FocusAdapter;\n+import java.awt.event.FocusEvent;\n+import java.awt.event.InputEvent;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+public class LabelScrollBarFocus extends Panel {\n+    static final Semaphore sema = new Semaphore();\n+    Label lab;\n+    Scrollbar scr;\n+    static Frame frame;\n+\n+    public void init() {\n+        this.setLayout(new FlowLayout());\n+        FocusAdapter fa = new FocusAdapter() {\n+            public void focusGained(FocusEvent e) {\n+                sema.raise();\n+            }\n+        };\n+\n+        lab = new Label(\"Label\");\n+        scr = new Scrollbar(Scrollbar.HORIZONTAL);\n+        lab.addFocusListener(fa);\n+        scr.addFocusListener(fa);\n+        add(lab);\n+        add(scr);\n+        setSize(200, 200);\n+        validate();\n+        setVisible(true);\n+    }\n+\n+    public void start() throws InterruptedException,\n+            InvocationTargetException {\n+        Robot robot = null;\n+        try {\n+            robot = new Robot();\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Can't create robot instance\");\n+        }\n+        int[] point = new int[2];\n+        EventQueue.invokeAndWait(() -> {\n+            Point labLoc = lab.getLocationOnScreen();\n+            point[0] = labLoc.x + 5;\n+            point[1] = labLoc.y + 5;\n+        });\n+        robot.mouseMove(point[0], point[1]);\n+        robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+        robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+        robot.delay(1000);\n+        robot.waitForIdle();\n+        try {\n+            sema.doWait(2000);\n+        } catch (InterruptedException ie) {\n+            throw new RuntimeException(\"Interrupted\");\n+        }\n+\n+        AtomicBoolean isFocusOwner = new AtomicBoolean(false);\n+        EventQueue.invokeAndWait(() -> {\n+            isFocusOwner.set(lab.isFocusOwner());\n+        });\n+        if (isFocusOwner.get()) {\n+            throw new RuntimeException(\"Label is focused\");\n+        }\n+\n+        EventQueue.invokeAndWait(() -> {\n+            Point scrLoc = scr.getLocationOnScreen();\n+            point[0] = scrLoc.x + 20;\n+            point[1] = scrLoc.y + 5;\n+        });\n+        robot.mouseMove(point[0], point[1]);\n+        robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+        robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+        robot.delay(1000);\n+        robot.waitForIdle();\n+        try {\n+            sema.doWait(2000);\n+        } catch (InterruptedException ie) {\n+            throw new RuntimeException(\"Interrupted\");\n+        }\n+\n+        EventQueue.invokeAndWait(() -> {\n+            isFocusOwner.set(scr.isFocusOwner());\n+        });\n+        if (!isFocusOwner.get()) {\n+            throw new RuntimeException(\"Scroll bar is not focused\");\n+        }\n+        System.out.println(\"Test passed\");\n+    }\n+\n+    public static void main(String[] args) throws InterruptedException,\n+            InvocationTargetException {\n+        try {\n+            LabelScrollBarFocus test = new LabelScrollBarFocus();\n+            EventQueue.invokeAndWait(() -> {\n+                frame = new Frame(\"LabelScrollBarFocus\");\n+                test.init();\n+                frame.setLayout(new BorderLayout());\n+                frame.add(test, BorderLayout.CENTER);\n+                frame.setLocationRelativeTo(null);\n+                frame.pack();\n+                frame.setVisible(true);\n+            });\n+            test.start();\n+        } finally {\n+            if (frame != null) {\n+                EventQueue.invokeAndWait(frame::dispose);\n+            }\n+        }\n+    }\n+}\n+\n+class Semaphore {\n+    boolean state = false;\n+    Object lock = new Object();\n+    int waiting = 0;\n+\n+    public Semaphore() {\n+    }\n+\n+    public void doWait(int timeout) throws InterruptedException {\n+        synchronized (lock) {\n+            waiting++;\n+            synchronized (this) {\n+                wait(timeout);\n+            }\n+            waiting--;\n+        }\n+    }\n+\n+    public void raise() {\n+        synchronized (lock) {\n+            state = true;\n+            if (waiting > 0) {\n+                synchronized (this) {\n+                    notifyAll();\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Focus\/LabelScrollBarFocus.java","additions":180,"deletions":0,"binary":false,"changes":180,"status":"added"},{"patch":"@@ -0,0 +1,414 @@\n+\/*\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+  test\n+  @bug 4531693 4636269 4681908 4688142 4691646 4721470\n+  @summary Showing modal dialog during dispatching SequencedEvent\n+  @key headful\n+  @run main AutomaticAppletTest\n+*\/\n+\n+import java.awt.AWTEvent;\n+import java.awt.AWTException;\n+import java.awt.Button;\n+import java.awt.Dialog;\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Insets;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.event.FocusEvent;\n+import java.awt.event.FocusListener;\n+import java.awt.event.InputEvent;\n+import java.awt.event.WindowAdapter;\n+import java.awt.event.WindowEvent;\n+import java.awt.event.WindowFocusListener;\n+import java.awt.event.WindowListener;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+public class ModalDialogInFocusEventTest\n+        implements ActionListener, Runnable, WindowListener,\n+        WindowFocusListener, FocusListener {\n+    static final int CLICK_DELAY = 50;\n+    static final int ACTIVATION_TIMEOUT = 2000;\n+    static final long STAGE_TIMEOUT = 3 * ACTIVATION_TIMEOUT;\n+    static final StageInfo[] stages = {\n+            new StageInfo(WindowEvent.WINDOW_ACTIVATED, \"Window Activated\", false),\n+            new StageInfo(WindowEvent.WINDOW_GAINED_FOCUS, \"Window Gained Focus\", false),\n+            new StageInfo(FocusEvent.FOCUS_GAINED, \"Focus Gained\", false),\n+            new StageInfo(FocusEvent.FOCUS_LOST, \"Focus Lost\", true),\n+            new StageInfo(WindowEvent.WINDOW_LOST_FOCUS, \"Window Lost Focus\", true),\n+            new StageInfo(WindowEvent.WINDOW_DEACTIVATED, \"Window Deactivated\", true)\n+    };\n+    static final int MAX_STAGE_NUM = stages.length;\n+    static final Object stageMonitor = new Object();\n+\n+    Robot robot = null;\n+    Frame frame;\n+    Frame oppositeFrame;\n+    Dialog dialog;\n+    Button closeButton;\n+    int nStage = MAX_STAGE_NUM;\n+\n+    public void start() throws InterruptedException, InvocationTargetException {\n+        try {\n+            FocusListener focusEventTracker = new FocusListener() {\n+                public void focusGained(FocusEvent e) {\n+                    System.out.println(e);\n+                }\n+\n+                public void focusLost(FocusEvent e) {\n+                    System.out.println(e);\n+                }\n+            };\n+\n+            WindowAdapter windowEventTracker = new WindowAdapter() {\n+                public void windowActivated(WindowEvent e) {\n+                    System.out.println(e);\n+                }\n+\n+                public void windowDeactivated(WindowEvent e) {\n+                    System.out.println(e);\n+                }\n+\n+                public void windowGainedFocus(WindowEvent e) {\n+                    System.out.println(e);\n+                }\n+\n+                public void windowLostFocus(WindowEvent e) {\n+                    System.out.println(e);\n+                }\n+            };\n+            EventQueue.invokeAndWait(() -> {\n+                frame = new Frame(\"ModalDialogInFocusEventTest Main Frame\");\n+                oppositeFrame = new Frame(\"ModalDialogInFocusEventTest Opposite Frame\");\n+                dialog = new Dialog(frame, \"ModalDialogInFocusEventTest Modal Dialog\", true);\n+                closeButton = new Button(\"Close Button\");\n+                closeButton.addActionListener(this);\n+                dialog.add(closeButton);\n+                dialog.setBounds(10, 200, 300, 100);\n+\n+                dialog.addFocusListener(focusEventTracker);\n+                dialog.addWindowListener(windowEventTracker);\n+                dialog.addWindowFocusListener(windowEventTracker);\n+                oppositeFrame.addFocusListener(focusEventTracker);\n+                oppositeFrame.addWindowListener(windowEventTracker);\n+                oppositeFrame.addWindowFocusListener(windowEventTracker);\n+\n+                frame.setName(\"ModalDialogInFocusEventTest MainFrame\");\n+                frame.addFocusListener(this);\n+                frame.addWindowListener(this);\n+                frame.addWindowFocusListener(this);\n+                frame.setSize(300, 100);\n+\n+                oppositeFrame.setName(\"ModalDialogInFocusEventTest OppositeName\");\n+                oppositeFrame.setBounds(350, 200, 300, 100);\n+            });\n+\n+\n+            try {\n+                robot = new Robot();\n+                robot.setAutoDelay(CLICK_DELAY);\n+\n+                for (int i = 0; i < MAX_STAGE_NUM; i++) {\n+                    StageInfo stage = stages[i];\n+                    if (stage.shouldActivateOpposite()) {\n+                        EventQueue.invokeAndWait(() -> {\n+                            oppositeFrame.setVisible(true);\n+                            frame.setVisible(true);\n+                        });\n+                        robot.delay(ACTIVATION_TIMEOUT);\n+                        AtomicBoolean isActive = new AtomicBoolean(false);\n+                        EventQueue.invokeAndWait(() -> {\n+                            isActive.set(frame.isActive());\n+                        });\n+                        if (!isActive.get()) {\n+                            clickOnFrameTitle(frame);\n+                            robot.delay(ACTIVATION_TIMEOUT);\n+                        }\n+                    } else {\n+                        EventQueue.invokeAndWait(() -> {\n+                            frame.setVisible(true);\n+                            oppositeFrame.setVisible(true);\n+                        });\n+                        robot.delay(ACTIVATION_TIMEOUT);\n+                        AtomicBoolean isActive = new AtomicBoolean(false);\n+                        EventQueue.invokeAndWait(() -> {\n+                            isActive.set(oppositeFrame.isActive());\n+                        });\n+                        if (!isActive.get()) {\n+                            clickOnFrameTitle(oppositeFrame);\n+                            robot.delay(ACTIVATION_TIMEOUT);\n+                        }\n+                    }\n+\n+                    nStage = i;\n+                    System.out.println(\"Stage \" + i + \" started.\");\n+\n+                    synchronized (stageMonitor) {\n+                        if (stage.shouldActivateOpposite()) {\n+                            clickOnFrameTitle(oppositeFrame);\n+                        } else {\n+                            clickOnFrameTitle(frame);\n+                        }\n+                        stageMonitor.wait(STAGE_TIMEOUT);\n+                        if (!stage.isFinished()) {\n+                            throw new RuntimeException(stages[nStage].toString());\n+                        }\n+                    }\n+                    EventQueue.invokeAndWait(() -> {\n+                        oppositeFrame.setVisible(false);\n+                        frame.setVisible(false);\n+                    });\n+                    robot.delay(ACTIVATION_TIMEOUT);\n+                }\n+            } catch (AWTException e) {\n+                throw new RuntimeException(\"Some AWT-Robot problem occurred\", e);\n+            } catch (InterruptedException ie) {\n+                ie.printStackTrace();\n+                throw new RuntimeException(\"Test was interrupted\");\n+            }\n+        } finally {\n+            if (frame != null) {\n+                EventQueue.invokeAndWait(frame::dispose);\n+            }\n+            if (oppositeFrame != null) {\n+                EventQueue.invokeAndWait(oppositeFrame::dispose);\n+            }\n+            if (dialog != null) {\n+                EventQueue.invokeAndWait(dialog::dispose);\n+            }\n+        }\n+        System.out.println(\"Test passed.\");\n+    }\n+\n+    void clickOnFrameTitle(Frame frame) throws InterruptedException,\n+            InvocationTargetException {\n+        System.out.println(\"click on title of \" + frame.getName());\n+        int[] point = new int[2];\n+        EventQueue.invokeAndWait(() -> {\n+            Point location = frame.getLocationOnScreen();\n+            Insets insets = frame.getInsets();\n+            int width = frame.getWidth();\n+            point[0] = location.x + width \/ 2;\n+            point[1] = location.y + insets.top \/ 2;\n+        });\n+        robot.mouseMove(point[0], point[1]);\n+        robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+        robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+        EventQueue.invokeAndWait(frame::requestFocusInWindow);\n+    }\n+\n+    void openAndCloseModalDialog() throws InterruptedException,\n+            InvocationTargetException {\n+        (new Thread(this)).start();\n+        dialog.setVisible(true);\n+    }\n+\n+    void performStage(AWTEvent e) throws InterruptedException,\n+            InvocationTargetException {\n+        if (nStage < MAX_STAGE_NUM &&\n+                e.getID() == stages[nStage].getEventID() &&\n+                !stages[nStage].isStarted()) {\n+            stages[nStage].start();\n+            openAndCloseModalDialog();\n+            stages[nStage].finish();\n+            synchronized (stageMonitor) {\n+                stageMonitor.notifyAll();\n+            }\n+        }\n+    }\n+\n+    public void actionPerformed(ActionEvent ae) {\n+        System.out.println(ae);\n+        dialog.setVisible(false);\n+    }\n+\n+    public void run() {\n+        try {\n+            Thread.sleep(ACTIVATION_TIMEOUT);\n+            int[] point = new int[2];\n+            EventQueue.invokeAndWait(() -> {\n+                Point location = closeButton.getLocationOnScreen();\n+                Dimension dim = closeButton.getSize();\n+                point[0] = location.x + dim.width \/ 2;\n+                point[1] = location.y + dim.height \/ 2;\n+            });\n+            robot.mouseMove(point[0], point[1]);\n+            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+            System.out.println(\"click\");\n+        } catch (InterruptedException | InvocationTargetException ie) {\n+            throw new RuntimeException(\"Test was interrupted\", ie);\n+        }\n+    }\n+\n+    public void windowOpened(WindowEvent e) {\n+        \/* Empty. Unneeded for this test *\/\n+    }\n+\n+    public void windowClosing(WindowEvent e) {\n+        \/* Empty. Unneeded for this test *\/\n+    }\n+\n+    public void windowClosed(WindowEvent e) {\n+        \/* Empty. Unneeded for this test *\/\n+    }\n+\n+    public void windowIconified(WindowEvent e) {\n+        \/* Empty. Unneeded for this test *\/\n+    }\n+\n+    public void windowDeiconified(WindowEvent e) {\n+        \/* Empty. Unneeded for this test *\/\n+    }\n+\n+    public void windowActivated(WindowEvent e) {\n+        System.out.println(e);\n+        try {\n+            performStage(e);\n+        } catch (InterruptedException | InvocationTargetException ex) {\n+            throw new RuntimeException(ex);\n+        }\n+    }\n+\n+    public void windowDeactivated(WindowEvent e) {\n+        System.out.println(e);\n+        try {\n+            performStage(e);\n+        } catch (InterruptedException | InvocationTargetException ex) {\n+            throw new RuntimeException(ex);\n+        }\n+    }\n+\n+    public void windowGainedFocus(WindowEvent e) {\n+        System.out.println(e);\n+        try {\n+            performStage(e);\n+        } catch (InterruptedException | InvocationTargetException ex) {\n+            throw new RuntimeException(ex);\n+        }\n+    }\n+\n+    public void windowLostFocus(WindowEvent e) {\n+        System.out.println(e);\n+        try {\n+            performStage(e);\n+        } catch (InterruptedException | InvocationTargetException ex) {\n+            throw new RuntimeException(ex);\n+        }\n+    }\n+\n+    public void focusGained(FocusEvent e) {\n+        System.out.println(e);\n+        try {\n+            performStage(e);\n+        } catch (InterruptedException | InvocationTargetException ex) {\n+            throw new RuntimeException(ex);\n+        }\n+    }\n+\n+    public void focusLost(FocusEvent e) {\n+        System.out.println(e);\n+        try {\n+            performStage(e);\n+        } catch (InterruptedException | InvocationTargetException ex) {\n+            throw new RuntimeException(ex);\n+        }\n+    }\n+\n+    public static void main(String[] args) throws InterruptedException,\n+            InvocationTargetException {\n+        ModalDialogInFocusEventTest test = new ModalDialogInFocusEventTest();\n+        test.start();\n+    }\n+}\n+\n+class StageInfo {\n+    private String name;\n+    private int eventID;\n+    private boolean started = false;\n+    private boolean finished = false;\n+\n+    \/*\n+     * whether we should activate opposite frame during this stage.\n+     * Note: we need to activate \"another\" frame BEFORE stage\n+     * i.e. if we should activate frame during  stage then we\n+     * need to activate oppositeFrame before it and vice versa.\n+     *\/\n+    private boolean activateOpposite;\n+\n+    StageInfo(int eventID, String name, boolean activateOpposite) {\n+        this.eventID = eventID;\n+        this.name = name;\n+        this.activateOpposite = activateOpposite;\n+    }\n+\n+    public String toString() {\n+        String str = \"Stage [\\\"\" + name + \"\\\"\";\n+        if (!started) {\n+            str += \" not\";\n+        }\n+        str += \" started, \";\n+        if (!finished) {\n+            str += \" not\";\n+        }\n+        str += \" finished\";\n+        if (activateOpposite) {\n+            str += \", activate opposite\";\n+        }\n+        str += \"]\";\n+        return str;\n+    }\n+\n+    int getEventID() {\n+        return eventID;\n+    }\n+\n+    boolean isStarted() {\n+        return started;\n+    }\n+\n+    void start() {\n+        started = true;\n+        System.out.println(this.toString());\n+    }\n+\n+    boolean isFinished() {\n+        return finished;\n+    }\n+\n+    void finish() {\n+        finished = true;\n+        System.out.println(this.toString());\n+    }\n+\n+    boolean shouldActivateOpposite() {\n+        return activateOpposite;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Focus\/ModalDialogInFocusEventTest.java","additions":414,"deletions":0,"binary":false,"changes":414,"status":"added"}]}