{"files":[{"patch":"@@ -227,9 +227,2 @@\n-ObjectValue* ObjectMergeValue::select(frame* fr, RegisterMap* reg_map) {\n-  assert(fr != nullptr && reg_map != nullptr, \"sanity\");\n-\n-  \/\/ If we call select again on the same merge we should return the same result\n-  if (_selected != nullptr) {\n-    return _selected;\n-  }\n-\n-  StackValue* sv_selector = StackValue::create_stack_value(fr, reg_map, _selector);\n+ObjectValue* ObjectMergeValue::select(frame& fr, RegisterMap& reg_map) {\n+  StackValue* sv_selector = StackValue::create_stack_value(&fr, &reg_map, _selector);\n@@ -243,1 +236,1 @@\n-    StackValue* sv_merge_pointer = StackValue::create_stack_value(fr, reg_map, _merge_pointer);\n+    StackValue* sv_merge_pointer = StackValue::create_stack_value(&fr, &reg_map, _merge_pointer);\n@@ -250,3 +243,2 @@\n-    \/\/ No need to allocate the object or do field reassignment since\n-    \/\/ the object wasn't really scalar replaced.\n-    _selected->set_skip_rematerialization();\n+    \/\/ No need to rematerialize\n+    return nullptr;\n@@ -257,2 +249,13 @@\n-    \/\/ Candidate is not candidate anymore.\n-    _selected->set_only_merge_candidate(false);\n+    \/\/ Set it to true so that the object will get rematerialized\n+    if (_selected->is_only_merge_candidate()) {\n+      _selected->set_only_merge_candidate(false);\n+\n+      \/\/ We can't assume that 'select(...)' will be called before we check if\n+      \/\/ the candidate needs to be rematerialized or not. Therefore, we need to\n+      \/\/ return the candidate, now set to 'not only merge candidate', and try to\n+      \/\/ rematerialize it.\n+      return _selected;\n+    } else {\n+      \/\/ Since the object was not only a candidate it will already be rematerialized on its own.\n+      return nullptr;\n+    }\n@@ -260,2 +263,0 @@\n-\n-  return _selected;\n@@ -295,4 +296,0 @@\n-  st->print(\"merge: ID=%d, N.Candidates=%d\", _id, _possible_objects.length());\n-}\n-\n-void ObjectMergeValue::print_candidates_on(outputStream* st) const {\n@@ -300,2 +297,4 @@\n-  for (int i = 0; i < ncandidates; i++) {\n-    _possible_objects.at(i)->as_ObjectValue()->print_on(st);\n+  st->print(\"merge: ID=%d, Candidates excluding potential NSR pointer: \", _id);\n+  st->print(\"%d\", _possible_objects.at(0)->as_ObjectValue()->id());\n+  for (int i = 1; i < ncandidates; i++) {\n+    st->print(\", %d\", _possible_objects.at(i)->as_ObjectValue()->id());\n","filename":"src\/hotspot\/share\/code\/debugInfo.cpp","additions":22,"deletions":23,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -166,5 +166,5 @@\n-  ScopeValue*                 klass() const                       { return _klass; }\n-  GrowableArray<ScopeValue*>* field_values()                      { return &_field_values; }\n-  ScopeValue*                 field_at(int i) const               { return _field_values.at(i); }\n-  int                         field_size()                        { return _field_values.length(); }\n-  Handle                      value() const                       { return _value; }\n+  virtual ScopeValue*         klass() const                       { return _klass; }\n+  virtual GrowableArray<ScopeValue*>* field_values()              { return &_field_values; }\n+  virtual ScopeValue*         field_at(int i) const               { return _field_values.at(i); }\n+  virtual int                 field_size()                        { return _field_values.length(); }\n+  virtual Handle              value() const                       { return _value; }\n@@ -173,1 +173,0 @@\n-  bool                        skip_rematerialization() const      { return _skip_rematerialization; }\n@@ -176,1 +175,1 @@\n-  void                        set_value(oop value);\n+  virtual void                set_value(oop value);\n@@ -179,1 +178,0 @@\n-  void                        set_skip_rematerialization()        { _skip_rematerialization = true; }\n@@ -224,2 +222,9 @@\n-  ObjectValue*                select(frame* fr, RegisterMap* reg_map) ;\n-  ObjectValue*                selected()                      { assert(_selected != nullptr, \"not yet.\"); return _selected; };\n+  ObjectValue*                select(frame& fr, RegisterMap& reg_map) ;\n+\n+  ScopeValue*                 klass() const                   { ShouldNotReachHere(); return nullptr; }\n+  GrowableArray<ScopeValue*>* field_values()                  { ShouldNotReachHere(); return nullptr; }\n+  ScopeValue*                 field_at(int i) const           { ShouldNotReachHere(); return nullptr; }\n+  int                         field_size()                    { ShouldNotReachHere(); return -1; }\n+\n+  Handle                      value() const                   { assert(_selected != nullptr, \"Should call select() first.\"); return _selected->value(); }\n+  void                        set_value(oop value)            { assert(_selected != nullptr, \"Should call select() first.\"); _selected->set_value(value); }\n@@ -233,1 +238,0 @@\n-  void print_candidates_on(outputStream* st) const;\n","filename":"src\/hotspot\/share\/code\/debugInfo.hpp","additions":15,"deletions":11,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -132,0 +132,35 @@\n+GrowableArray<ScopeValue*>* ScopeDesc::objects_to_rematerialize(frame& frm, RegisterMap& map) {\n+  if (_objects == nullptr) {\n+    return nullptr;\n+  }\n+\n+  GrowableArray<ScopeValue*>* result = new GrowableArray<ScopeValue*>();\n+  for (int i = 0; i < _objects->length(); i++) {\n+    assert(_objects->at(i)->is_object(), \"invalid debug information\");\n+    ObjectValue* sv = nullptr;\n+\n+    if (_objects->at(i)->is_object_merge()) {\n+      ObjectMergeValue* merged = _objects->at(i)->as_ObjectMergeValue();\n+      sv = merged->select(frm, map);\n+\n+      if (sv == nullptr) {\n+        continue;\n+      }\n+    } else if (_objects->at(i)->is_object()) {\n+      sv = _objects->at(i)->as_ObjectValue();\n+\n+      \/\/ We skip allocation if the object is only a candidate inside an\n+      \/\/ ObjectMergeValue or if it already has an allocation.\n+      if (sv->is_only_merge_candidate()) {\n+        continue;\n+      }\n+    } else {\n+      assert(false, \"sanity\");\n+    }\n+\n+    result->append_if_missing(sv);\n+  }\n+\n+  return result;\n+}\n+\n@@ -240,0 +275,1 @@\n+      st->print(\"    - %d: \", i);\n@@ -242,0 +278,1 @@\n+        st->cr();\n","filename":"src\/hotspot\/share\/code\/scopeDesc.cpp","additions":37,"deletions":0,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -137,0 +137,1 @@\n+  GrowableArray<ScopeValue*>* objects_to_rematerialize(frame& frm, RegisterMap& map);\n","filename":"src\/hotspot\/share\/code\/scopeDesc.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2305,1 +2305,0 @@\n-      if (major_progress()) print_method(PHASE_PHASEIDEAL_BEFORE_EA, 2);\n@@ -2309,0 +2308,1 @@\n+    print_method(PHASE_PHASEIDEAL_BEFORE_EA, 2);\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -515,0 +515,1 @@\n+    NOT_PRODUCT(if (TraceReduceAllocationMerges) { tty->print_cr(\"Can NOT reduce Phi %d during invocation %d because it's nullable.\", ophi->_idx, _invocation); })\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -294,2 +294,1 @@\n-                          GrowableArray<ScopeValue*>* objects, bool realloc_failures,\n-                          frame* frame, RegisterMap* reg_map) {\n+                          GrowableArray<ScopeValue*>* objects, bool realloc_failures) {\n@@ -302,17 +301,2 @@\n-    ObjectValue* sv = nullptr;\n-    Klass* k = nullptr;\n-\n-    if (objects->at(i)->is_object_merge()) {\n-      ObjectMergeValue* merged = objects->at(i)->as_ObjectMergeValue();\n-      sv = merged->select(frame, reg_map);\n-      \/\/ Klass may be null if the object was actually a NSR input of a merge.\n-      k = (sv->klass() != nullptr) ? java_lang_Class::as_Klass(sv->klass()->as_ConstantOopReadValue()->value()()) : nullptr;\n-    } else if (objects->at(i)->is_object()) {\n-      sv = objects->at(i)->as_ObjectValue();\n-      \/\/ This object is only a candidate inside an ObjectMergeValue\n-      if (sv->is_only_merge_candidate()) {\n-        continue;\n-      }\n-      k = java_lang_Class::as_Klass(sv->klass()->as_ConstantOopReadValue()->value()());\n-    }\n-\n+    ObjectValue* sv = (ObjectValue*) objects->at(i);\n+    Klass* k = java_lang_Class::as_Klass(sv->klass()->as_ConstantOopReadValue()->value()());\n@@ -321,7 +305,2 @@\n-    st.print(\"     object <\" INTPTR_FORMAT \">\", p2i(sv->value()()));\n-    if (k == nullptr) {\n-      st.print(\" NSR input from an allocation merge.\");\n-    } else {\n-      st.print(\" of type \");\n-      k->print_value_on(&st);\n-    }\n+    st.print(\"     object <\" INTPTR_FORMAT \"> of type \", p2i(sv->value()()));\n+    k->print_value_on(&st);\n@@ -336,1 +315,1 @@\n-    if (Verbose && !obj.is_null() && k != nullptr) {\n+    if (Verbose && !obj.is_null()) {\n@@ -353,1 +332,1 @@\n-  GrowableArray<ScopeValue*>* objects = chunk->at(0)->scope()->objects();\n+  GrowableArray<ScopeValue*>* objects = chunk->at(0)->scope()->objects_to_rematerialize(deoptee, map);\n@@ -394,1 +373,1 @@\n-      print_objects(deoptee_thread, objects, realloc_failures, &deoptee, &map);\n+      print_objects(deoptee_thread, objects, realloc_failures);\n@@ -1233,28 +1212,1 @@\n-    ObjectValue* sv = nullptr;\n-\n-    if (objects->at(i)->is_object_merge()) {\n-      ObjectMergeValue* merged = objects->at(i)->as_ObjectMergeValue();\n-      sv = merged->select(fr, reg_map);\n-\n-      \/\/ 'skip_rematerialization' will be true whenever the object was a NSR\n-      \/\/ input of an allocation merge.\n-      \/\/ 'value' will be not null if the object selected in the merge was a\n-      \/\/ 'not_only_candidate' and it was visited by this loop before the current\n-      \/\/ iteration.\n-      if (sv->skip_rematerialization() || sv->value().not_null()) {\n-        continue;\n-      }\n-    } else if (objects->at(i)->is_object()) {\n-      sv = objects->at(i)->as_ObjectValue();\n-\n-      \/\/ We skip allocation if the object is only a candidate inside an\n-      \/\/ ObjectMergeValue or if it already has an allocation. The object may\n-      \/\/ already be allocated if it was the result of a 'select' on an\n-      \/\/ ObjectMergeValue.\n-      if (sv->is_only_merge_candidate() || sv->value().not_null()) {\n-        continue;\n-      }\n-    } else {\n-      assert(false, \"sanity\");\n-    }\n-\n+    ObjectValue* sv = (ObjectValue*) objects->at(i);\n@@ -1614,20 +1566,1 @@\n-    ObjectValue* sv = nullptr;\n-\n-    if (objects->at(i)->is_object_merge()) {\n-      \/\/ Merge objects don't need field reassignment\n-      continue;\n-    } else if (objects->at(i)->is_object()) {\n-      sv = objects->at(i)->as_ObjectValue();\n-\n-      \/\/ If the object is only a candidate inside an ObjectMergeValue we\n-      \/\/ skip processing it.\n-      \/\/\n-      \/\/ If the pointer didn't come from a scalar replaced object then\n-      \/\/ we don't need to do field reassignment.\n-      if (sv->is_only_merge_candidate() || sv->skip_rematerialization()) {\n-        continue;\n-      }\n-    } else {\n-      assert(false, \"sanity\");\n-    }\n-\n+    ObjectValue* sv = (ObjectValue*) objects->at(i);\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":10,"deletions":77,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -250,6 +250,0 @@\n-  } else if (sv->is_object_merge()) {\n-    ObjectValue* ov = ((ObjectMergeValue *)sv)->selected();\n-    Handle hdl = ov->value();\n-    \/\/ If the object didn't have to rematerialize it might have actually been a\n-    \/\/ pointer to null.\n-    return new StackValue(hdl, (!ov->skip_rematerialization() && hdl.is_null()) ? 1 : 0);\n@@ -257,5 +251,2 @@\n-    ObjectValue* ov = (ObjectValue *)sv;\n-    Handle hdl = ov->value();\n-    \/\/ If the object didn't have to rematerialize it might have actually been a\n-    \/\/ pointer to null.\n-    return new StackValue(hdl, (!ov->skip_rematerialization() && hdl.is_null()) ? 1 : 0);\n+    Handle ov = ((ObjectValue *)sv)->value();\n+    return new StackValue(ov, (ov.is_null()) ? 1 : 0);\n","filename":"src\/hotspot\/share\/runtime\/stackValue.cpp","additions":2,"deletions":11,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -153,1 +153,0 @@\n-      assert(!scopedValues->at(i2)->is_object_merge(), \"sanity\");\n@@ -168,1 +167,0 @@\n-      assert(!scopeExpressions->at(i2)->is_object_merge(), \"sanity\");\n@@ -272,1 +270,0 @@\n-    assert(!ov->is_object_merge(), \"sanity\");\n","filename":"src\/hotspot\/share\/runtime\/vframe_hp.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+    private int invocations = 0;\n@@ -787,0 +788,37 @@\n+    @Test\n+    @Arguments({ Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH })\n+    @IR(counts = { IRNode.ALLOC, \"2\" }, phase = CompilePhase.PHASEIDEAL_BEFORE_EA)\n+    @IR(counts = { IRNode.ALLOC, \"1\" }, phase = CompilePhase.ITER_GVN_AFTER_ELIMINATION)\n+    int testSRAndNSR_NoTrap(boolean cond1, int x, int y) {\n+        Point p = new Point(x, y);\n+\n+        if (cond1) {\n+            p = new Point(x+1, y+1);\n+            global_escape = p;\n+        }\n+\n+        return p.y;\n+    }\n+\n+    @Test\n+    @Warmup(2000)\n+    @Arguments({ Argument.RANDOM_EACH, Argument.FALSE, Argument.RANDOM_EACH, Argument.RANDOM_EACH })\n+    @IR(counts = { IRNode.ALLOC, \"2\" }, phase = CompilePhase.PHASEIDEAL_BEFORE_EA)\n+    @IR(counts = { IRNode.ALLOC, \"1\" }, phase = CompilePhase.ITER_GVN_AFTER_ELIMINATION)\n+    int testSRAndNSR_Trap(boolean cond1, boolean cond2, int x, int y) {\n+        invocations++;\n+        Point p = new Point(x, y);\n+\n+        if (cond1) {\n+            p = new Point(x+1, y+1);\n+            global_escape = p;\n+        }\n+\n+        if (invocations == 2001) {\n+            \/\/ This will show up to C2 as a trap.\n+            new ADefaults();\n+        }\n+\n+        return p.y;\n+    }\n+\n@@ -843,1 +881,1 @@\n-   static class ADefaults {\n+    static class ADefaults {\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/scalarReplacement\/AllocationMergesTests.java","additions":39,"deletions":1,"binary":false,"changes":40,"status":"modified"}]}