{"files":[{"patch":"@@ -104,5 +104,3 @@\n-    ScopeValue* sv = _obj_pool->at(i);\n-    if (sv->is_object() && sv->as_ObjectValue()->id() == id) {\n-      return sv->as_ObjectValue();\n-    } else if (sv->is_object_merge() && sv->as_ObjectMergeValue()->id() == id) {\n-      return sv->as_ObjectMergeValue();\n+    ObjectValue* ov = _obj_pool->at(i)->as_ObjectValue();\n+    if (ov->id() == id) {\n+      return ov;\n@@ -173,0 +171,1 @@\n+  _only_merge_sr_candidate = stream->read_bool();\n@@ -190,0 +189,1 @@\n+    stream->write_bool(_only_merge_sr_candidate);\n@@ -202,1 +202,1 @@\n-            _merge_candidate, _skip_field_assignment, _field_values.length());\n+            _only_merge_sr_candidate, _skip_field_assignment, _field_values.length());\n@@ -276,4 +276,0 @@\n-void ObjectMergeValue::set_value(oop value) {\n-  _value = Handle(Thread::current(), value);\n-}\n-\n","filename":"src\/hotspot\/share\/code\/debugInfo.cpp","additions":6,"deletions":10,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -136,1 +136,1 @@\n-  bool                       _merge_candidate;        \/\/ Will be true if this object is just representing\n+  bool                       _only_merge_sr_candidate;\/\/ Will be true if this object is just representing\n@@ -143,1 +143,1 @@\n-  ObjectValue(int id, ScopeValue* klass)\n+  ObjectValue(int id, ScopeValue* klass, bool only_merge_sr_candidate = false)\n@@ -149,1 +149,1 @@\n-     , _merge_candidate(false)\n+     , _only_merge_sr_candidate(only_merge_sr_candidate)\n@@ -160,1 +160,1 @@\n-     , _merge_candidate(false)\n+     , _only_merge_sr_candidate(false)\n@@ -164,12 +164,12 @@\n-  bool                        is_object() const              { return true; }\n-  int                         id() const                     { return _id; }\n-  ScopeValue*                 klass() const                  { return _klass; }\n-  GrowableArray<ScopeValue*>* field_values()                 { return &_field_values; }\n-  ScopeValue*                 field_at(int i) const          { return _field_values.at(i); }\n-  int                         field_size()                   { return _field_values.length(); }\n-  Handle                      value() const                  { return _value; }\n-  bool                        is_visited() const             { return _visited; }\n-  bool                        is_merge_candidate() const     { return _merge_candidate; }\n-  bool                        skip_field_assignment() const  { return _skip_field_assignment; }\n-\n-  void                        set_id(int id)                 { _id = id; }\n+  bool                        is_object() const                   { return true; }\n+  int                         id() const                          { return _id; }\n+  ScopeValue*                 klass() const                       { return _klass; }\n+  GrowableArray<ScopeValue*>* field_values()                      { return &_field_values; }\n+  ScopeValue*                 field_at(int i) const               { return _field_values.at(i); }\n+  int                         field_size()                        { return _field_values.length(); }\n+  Handle                      value() const                       { return _value; }\n+  bool                        is_visited() const                  { return _visited; }\n+  bool                        is_only_merge_sr_candidate() const  { return _only_merge_sr_candidate; }\n+  bool                        skip_field_assignment() const       { return _skip_field_assignment; }\n+\n+  void                        set_id(int id)                      { _id = id; }\n@@ -177,3 +177,3 @@\n-  void                        set_visited(bool visited)      { _visited = visited; }\n-  void                        set_merge_candidate(bool cnd)  { _merge_candidate = cnd; }\n-  void                        set_skip_field_assignment()    { _skip_field_assignment = true; }\n+  void                        set_visited(bool visited)           { _visited = visited; }\n+  void                        set_merge_candidate(bool cnd)       { _only_merge_sr_candidate = cnd; }\n+  void                        set_skip_field_assignment()         { _skip_field_assignment = true; }\n@@ -199,1 +199,1 @@\n-class ObjectMergeValue: public ScopeValue {\n+class ObjectMergeValue: public ObjectValue {\n@@ -201,1 +201,0 @@\n-  int                        _id;\n@@ -206,2 +205,0 @@\n-  Handle                     _value;\n-  bool                       _visited;\n@@ -210,1 +207,1 @@\n-     : _id(id)\n+     : ObjectValue(id)\n@@ -213,3 +210,2 @@\n-     , _selected(nullptr)\n-     , _value()\n-     , _visited(false) {}\n+     , _possible_objects()\n+     , _selected(nullptr) {}\n@@ -218,1 +214,1 @@\n-     : _id(id)\n+     : ObjectValue(id)\n@@ -221,3 +217,2 @@\n-     , _selected(nullptr)\n-     , _value()\n-     , _visited(false) {}\n+     , _possible_objects()\n+     , _selected(nullptr) {}\n@@ -226,1 +221,0 @@\n-  int                         id() const                      { return _id; }\n@@ -230,2 +224,0 @@\n-  Handle                      value() const                   { return _value; }\n-  bool                        is_visited() const              { return _visited; }\n@@ -235,3 +227,0 @@\n-  void                        set_value(oop value);\n-  void                        set_visited(bool visited)       { _visited = visited; }\n-\n@@ -253,1 +242,1 @@\n-  AutoBoxObjectValue(int id, ScopeValue* klass) : ObjectValue(id, klass), _cached(false) { }\n+  AutoBoxObjectValue(int id, ScopeValue* klass, bool only_merge_candidate = false) : ObjectValue(id, klass, only_merge_candidate), _cached(false) { }\n","filename":"src\/hotspot\/share\/code\/debugInfo.hpp","additions":27,"deletions":38,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -357,12 +357,1 @@\n-      ScopeValue* sv = objects->at(i);\n-      if (sv->is_object()) {\n-        sv->as_ObjectValue()->set_visited(false);\n-      } else if (sv->is_object_merge()) {\n-        ObjectMergeValue* obj = sv->as_ObjectMergeValue();\n-        obj->set_visited(false);\n-        for (int j = 0; j < obj->possible_objects()->length(); j++) {\n-          obj->possible_objects()->at(j)->as_ObjectValue()->set_visited(false);\n-        }\n-      } else {\n-        assert(false, \"Unknown object type in object pool.\");\n-      }\n+      objects->at(i)->as_ObjectValue()->set_visited(false);\n","filename":"src\/hotspot\/share\/code\/debugInfoRec.cpp","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -240,3 +240,1 @@\n-      if (sv->is_object()) {\n-        sv->as_ObjectValue()->print_on(st);\n-      } else if (sv->is_object_merge()) {\n+      if (sv->is_object_merge()) {\n@@ -244,0 +242,2 @@\n+      } else if (sv->is_object()) {\n+        sv->as_ObjectValue()->print_on(st);\n","filename":"src\/hotspot\/share\/code\/scopeDesc.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1401,0 +1401,1 @@\n+              assert(!value->is_object_merge(), \"Should not be.\");\n@@ -1636,0 +1637,1 @@\n+        assert(!scopedValues->at(i2)->is_object_merge(), \"Should not be.\");\n@@ -1649,0 +1651,1 @@\n+        assert(!scopeExpressions->at(i2)->is_object_merge(), \"Should not be.\");\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1466,8 +1466,1 @@\n-SafePointScalarObjectNode::SafePointScalarObjectNode(const TypeOopPtr* tp,\n-#ifdef ASSERT\n-                                                     Node* alloc,\n-#endif\n-                                                     uint first_index,\n-                                                     uint n_fields,\n-                                                     int merge_pointer_idx,\n-                                                     uint number_of_objects) :\n+SafePointScalarObjectNode::SafePointScalarObjectNode(const TypeOopPtr* tp, Node* alloc, uint first_index, uint n_fields, bool only_merge_sr_candidate) :\n@@ -1477,1 +1470,0 @@\n-#ifdef ASSERT\n@@ -1479,3 +1471,1 @@\n-#endif\n-  _merge_pointer_idx(merge_pointer_idx),\n-  _number_of_objects(number_of_objects)\n+  _only_merge_sr_candidate(only_merge_sr_candidate)\n@@ -1484,2 +1474,1 @@\n-  if (merge_pointer_idx < 0 && \/\/ not a merge\n-      !alloc->is_Allocate() && !(alloc->Opcode() == Op_VectorBox)) {\n+  if (!alloc->is_Allocate() && !(alloc->Opcode() == Op_VectorBox)) {\n@@ -1532,1 +1521,45 @@\n-  st->print(\"merge_ptr_idx=%d, number_of_objects=%d\", _merge_pointer_idx, _number_of_objects);\n+}\n+#endif\n+\n+\/\/==============  SafePointScalarMergeNode  ==============\n+\n+SafePointScalarMergeNode::SafePointScalarMergeNode(const TypeOopPtr* tp, int merge_pointer_idx) :\n+  TypeNode(tp, 1), \/\/ 1 control input -- seems required.  Get from root.\n+  _merge_pointer_idx(merge_pointer_idx)\n+{\n+  init_class_id(Class_SafePointScalarMerge);\n+}\n+\n+\/\/ Do not allow value-numbering for SafePointScalarMerge node.\n+uint SafePointScalarMergeNode::hash() const { return NO_HASH; }\n+bool SafePointScalarMergeNode::cmp( const Node &n ) const {\n+  return (&n == this); \/\/ Always fail except on self\n+}\n+\n+uint SafePointScalarMergeNode::ideal_reg() const {\n+  return 0; \/\/ No matching to machine instruction\n+}\n+\n+const RegMask &SafePointScalarMergeNode::in_RegMask(uint idx) const {\n+  return *(Compile::current()->matcher()->idealreg2debugmask[in(idx)->ideal_reg()]);\n+}\n+\n+const RegMask &SafePointScalarMergeNode::out_RegMask() const {\n+  return RegMask::Empty;\n+}\n+\n+uint SafePointScalarMergeNode::match_edge(uint idx) const {\n+  return 0;\n+}\n+\n+SafePointScalarMergeNode*\n+SafePointScalarMergeNode::clone(Dict* sosn_map, bool& new_node) const {\n+  void* cached = (*sosn_map)[(void*)this];\n+  if (cached != nullptr) {\n+    new_node = false;\n+    return (SafePointScalarMergeNode*)cached;\n+  }\n+  new_node = true;\n+  SafePointScalarMergeNode* res = (SafePointScalarMergeNode*)Node::clone();\n+  sosn_map->Insert((void*)this, (void*)res);\n+  return res;\n@@ -1535,0 +1568,4 @@\n+#ifndef PRODUCT\n+void SafePointScalarMergeNode::dump_spec(outputStream *st) const {\n+  st->print(\" # merge_pointer_idx=%d, scalarized_objects=%d\", _merge_pointer_idx, req()-1);\n+}\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":52,"deletions":15,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -506,49 +506,2 @@\n-\/\/ A SafePointScalarObjectNode (aka spobj) represents the state of one or more\n-\/\/ scalarized objects at a SafePointNode. There are two scenarios where a\n-\/\/ 'spobj' is created: 1) A scalar replaced (SR) object is directly referenced\n-\/\/ by a SafePoint; 2) A scalar replaced object is participating in an allocation\n-\/\/ merge (Phi) and the Phi is referenced by a SafePoint. The schematics of how\n-\/\/ 'spobj' is used in both scenarios are described below.\n-\/\/\n-\/\/ Scenario 1: Representing an object directly referenced by a SafePoint.\n-\/\/   Only the _first_index, _n_fields and _alloc fields are required.\n-\/\/   _first_index : relative index in the SafePoint node's input array where pointers\n-\/\/                  to the values of the fields of the SR object are going to be stored.\n-\/\/   _nfields     : how many fields the SR object has.\n-\/\/   _alloc       : pointer to the Allocate object that previously created the SR object.\n-\/\/                  Only used for debug purposes.\n-\/\/\n-\/\/ Scenario 2: Representing SR objects participating in merges.\n-\/\/  Only the _merge_pointer_idx and _number_of_objects fields are required.\n-\/\/  _number_of_objects : how many objects participating in the merge were SR\n-\/\/                       and are represented in this 'sobj'.\n-\/\/  _merge_pointer_idx : relative index in the SafePoint node's input array\n-\/\/                       where the description of the SR _allocation merge_\n-\/\/                       starts. The two entries in the SafePoint node's input\n-\/\/                       array starting at '_merge_pointer_idx` are Phi nodes\n-\/\/                       representing: 1) a pointer to any non-SR'ed object\n-\/\/                       participating in the merge, and 2) a \"selector\" Phi\n-\/\/                       identifying the input of the original allocation merge\n-\/\/                       that should be used during execution.\n-\/\/\n-\/\/    SafePoint->in(_merge_pointer_idx + 0) ----> Phi(Region, ccpp, nullptr, nullptr)\n-\/\/    SafePoint->in(_merge_pointer_idx + 1) ----> Phi(Region,   -1,    0,    1)\n-\/\/\n-\/\/    In the example above the last two objects participating in the merge were\n-\/\/    scalar replaced. Additional entries in the SafePoint node's input array\n-\/\/    are used to represent the scalar replaced objects in a similar fashion\n-\/\/    as in Scenario 1 above. The only difference is that we add a reference\n-\/\/    to the Klass of the SR'ed object before the list of fields.\n-\/\/\n-\/\/    SafePoint->in(_merge_pointer_idx + 0) ----> Phi(Region, ccpp, nullptr, nullptr)\n-\/\/    SafePoint->in(_merge_pointer_idx + 1) ----> Phi(Region,   -1,    0,    1)\n-\/\/    SafePoint->in(_merge_pointer_idx + 2) ----> \"Point#Klass\"\n-\/\/    SafePoint->in(_merge_pointer_idx + 3) --------> Parm4\n-\/\/    SafePoint->in(_merge_pointer_idx + 4) --------> Parm5\n-\/\/    SafePoint->in(_merge_pointer_idx + 5) ----> \"Point#Klass\"\n-\/\/    SafePoint->in(_merge_pointer_idx + 6) --------> Parm6\n-\/\/    SafePoint->in(_merge_pointer_idx + 6) --------> Parm7\n-\/\/\n-\/\/    The example above assumes that two objects of the class Point were scalar\n-\/\/    replaced. Each object has two non-static field.\n-\n+\/\/ A SafePointScalarObjectNode represents the state of a scalarized object\n+\/\/ at a safepoint.\n@@ -559,2 +512,0 @@\n-                                  \/\/ It will be zero if the Spobj is from a merge.\n-\n@@ -562,1 +513,0 @@\n-                                  \/\/ It will be zero if the Spobj is from a merge.\n@@ -564,1 +514,1 @@\n-  DEBUG_ONLY(Node* _alloc;)       \/\/ Just for debugging purposes.\n+  Node* _alloc;                   \/\/ Just for debugging purposes.\n@@ -566,6 +516,2 @@\n-  int _merge_pointer_idx;         \/\/ Only used when the Spobj is representing the scalar replacement\n-                                  \/\/ of an allocation merge. This is the first input edge relative\n-                                  \/\/ index of a SafePoint node where metadata information relative\n-                                  \/\/ to restoring the merge is stored. The corresponding input\n-                                  \/\/ in the associated SafePoint will point to a Phi representing\n-                                  \/\/ potential non-scalar replaced objects.\n+  bool _only_merge_sr_candidate;  \/\/ Will be true if the object described by this Node is only\n+                                  \/\/ used as part of a reduced allocation merge.\n@@ -573,5 +519,1 @@\n-  uint _number_of_objects;        \/\/ How many scalar replaced objects this Spobj represents.\n-                                  \/\/ It will always be >= 1. It can be more than 1 when Spobj\n-                                  \/\/ was created for an allocation merge.\n-\n-  virtual uint hash() const ; \/\/ { return NO_HASH; }\n+  virtual uint hash() const;\n@@ -583,8 +525,1 @@\n-  SafePointScalarObjectNode(const TypeOopPtr* tp,\n-#ifdef ASSERT\n-                            Node* alloc,\n-#endif\n-                            uint first_index,\n-                            uint n_fields,\n-                            int merge_pointer_idx = -1,\n-                            uint number_of_objects = 1);\n+  SafePointScalarObjectNode(const TypeOopPtr* tp, Node* alloc, uint first_index, uint n_fields, bool only_merge_sr_candidate = false);\n@@ -604,0 +539,3 @@\n+  bool is_only_merge_sr_candidate()           { return _only_merge_sr_candidate; }\n+  void set_only_merge_sr_candidate(bool only) { _only_merge_sr_candidate = only; }\n+\n@@ -610,1 +548,76 @@\n-  bool is_from_merge() const { return _merge_pointer_idx >= 0; }\n+  \/\/ Assumes that \"this\" is an argument to a safepoint node \"s\", and that\n+  \/\/ \"new_call\" is being created to correspond to \"s\".  But the difference\n+  \/\/ between the start index of the jvmstates of \"new_call\" and \"s\" is\n+  \/\/ \"jvms_adj\".  Produce and return a SafePointScalarObjectNode that\n+  \/\/ corresponds appropriately to \"this\" in \"new_call\".  Assumes that\n+  \/\/ \"sosn_map\" is a map, specific to the translation of \"s\" to \"new_call\",\n+  \/\/ mapping old SafePointScalarObjectNodes to new, to avoid multiple copies.\n+  SafePointScalarObjectNode* clone(Dict* sosn_map, bool& new_node) const;\n+\n+#ifndef PRODUCT\n+  virtual void              dump_spec(outputStream *st) const;\n+#endif\n+};\n+\n+\/\/------------------------------SafePointScalarMergeNode----------------------\n+\/\/\n+\/\/ This class represents an allocation merge that is used as debug information\n+\/\/ and had at least one of its input scalar replaced.\n+\/\/\n+\/\/ The required inputs of this node, except the control, are pointers to\n+\/\/ SafePointScalarObjectNodes that describe scalarized inputs of the original\n+\/\/ allocation merge. The other(s) properties of the class are described below.\n+\/\/\n+\/\/ _merge_pointer_idx : index in the SafePointNode's input array where the\n+\/\/   description of the _allocation merge_ starts. The index is zero based and\n+\/\/   relative to the SafePoint's scloff. The two entries in the SafePointNode's\n+\/\/   input array starting at '_merge_pointer_idx` are Phi nodes representing:\n+\/\/\n+\/\/   1) The original merge Phi. During rematerialization this input will only be\n+\/\/   used if the \"selector Phi\" (see below) indicates that the execution of the\n+\/\/   Phi took the path of a non scalarized input.\n+\/\/\n+\/\/   2) A \"selector Phi\". The output of this Phi will be '-1' if the execution\n+\/\/   of the method exercised a non scalarized input of the original Phi.\n+\/\/   Otherwise, the output will be >=0, and it will indicate the index-1 in the\n+\/\/   SafePointScalarMergeNode input array where the description of the\n+\/\/   scalarized object that should be used is.\n+\/\/\n+\/\/ As an example, consider a Phi merging 3 inputs, of which the last 2 are\n+\/\/ scalar replaceable.\n+\/\/\n+\/\/    Phi(Region, NSR, SR, SR)\n+\/\/\n+\/\/ During scalar replacement the SR inputs will be changed to null:\n+\/\/\n+\/\/    Phi(Region, NSR, nullptr, nullptr)\n+\/\/\n+\/\/ A corresponding selector Phi will be created with a configuration like this:\n+\/\/\n+\/\/    Phi(Region, -1, 0, 1)\n+\/\/\n+\/\/ During execution of the compiled method, if the execution reaches a Trap, the\n+\/\/ output of the selector Phi will tell if we need to rematerialize one of the\n+\/\/ scalar replaced inputs or if we should just use the pointer returned by the\n+\/\/ original Phi.\n+\n+class SafePointScalarMergeNode: public TypeNode {\n+  int _merge_pointer_idx;         \/\/ This is the first input edge relative\n+                                  \/\/ index of a SafePoint node where metadata information relative\n+                                  \/\/ to restoring the merge is stored. The corresponding input\n+                                  \/\/ in the associated SafePoint will point to a Phi representing\n+                                  \/\/ potential non-scalar replaced objects.\n+\n+  virtual uint hash() const;\n+  virtual bool cmp( const Node &n ) const;\n+\n+public:\n+  SafePointScalarMergeNode(const TypeOopPtr* tp, int merge_pointer_idx);\n+\n+  virtual int            Opcode() const;\n+  virtual uint           ideal_reg() const;\n+  virtual const RegMask &in_RegMask(uint) const;\n+  virtual const RegMask &out_RegMask() const;\n+  virtual uint           match_edge(uint idx) const;\n+\n+  virtual uint size_of() const { return sizeof(*this); }\n@@ -622,2 +635,0 @@\n-  uint number_of_objects() const { return _number_of_objects; }\n-\n@@ -631,1 +642,1 @@\n-  SafePointScalarObjectNode* clone(Dict* sosn_map, bool& new_node) const;\n+  SafePointScalarMergeNode* clone(Dict* sosn_map, bool& new_node) const;\n@@ -638,1 +649,0 @@\n-\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":87,"deletions":77,"binary":false,"changes":164,"status":"modified"},{"patch":"@@ -314,0 +314,1 @@\n+macro(SafePointScalarMerge)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -444,1 +444,1 @@\n-      NOT_PRODUCT(if (TraceReduceAllocationMerges) tty->print(\"Can NOT reduce Phi %d on invocation %d. Input %d is nullable.\", ophi->_idx, _invocation, i);)\n+      NOT_PRODUCT(if (TraceReduceAllocationMerges) tty->print_cr(\"Can NOT reduce Phi %d on invocation %d. Input %d is nullable.\", ophi->_idx, _invocation, i);)\n@@ -462,1 +462,1 @@\n-  NOT_PRODUCT(if (TraceReduceAllocationMerges && !found_sr_allocate) tty->print_cr(\"\\tCan NOT reduce Phi %d on invocation %d. No SR Allocate as input.\", ophi->_idx, _invocation);)\n+  NOT_PRODUCT(if (TraceReduceAllocationMerges && !found_sr_allocate) tty->print_cr(\"Can NOT reduce Phi %d on invocation %d. No SR Allocate as input.\", ophi->_idx, _invocation);)\n@@ -604,101 +604,109 @@\n- \/\/ Fill in the 'selector' Phi. If index 'i' of the selector is:\n- \/\/ -> a '-1' constant, the i'th input of the original Phi is NSR.\n- \/\/ -> a 'x' constant >=0, the i'th input of of original Phi will be SR and the\n- \/\/    info about the scalarized object will be at index x of\n- \/\/    ObjectMergeValue::possible_objects\n- for (uint i = 1; i < ophi->req(); i++) {\n-   Node* base          = ophi->in(i);\n-   JavaObjectNode* ptn = unique_java_object(base);\n-\n-   if (ptn != nullptr && ptn->scalar_replaceable()) {\n-     Node* sr_obj_idx = _igvn->register_new_node_with_optimizer(ConINode::make(number_of_sr_objects));\n-     selector->set_req(i, sr_obj_idx);\n-     number_of_sr_objects++;\n-   }\n- }\n-\n- \/\/ Update the debug information of all safepoints in turn\n- for (uint spi = 0; spi < safepoints->size(); spi++ ) {\n-   Node* call               = safepoints->at(spi);\n-   Node* ctrl               = call->in(TypeFunc::Control);\n-   Node* memory             = call->in(TypeFunc::Memory);\n-   JVMState *jvms           = call->jvms();\n-   uint scalar_fields_index = (call->req() - jvms->scloff());\n-   int debug_start          = jvms->debug_start();\n-   int debug_end            = jvms->debug_end();\n-\n-   \/\/ Keep a copy of the original pointer to NSR objects\n-   call->add_req(ophi);\n-   \/\/ Add the selector so we know which direction the execution took\n-   call->add_req(selector);\n-\n-   for (uint i = 1; i < ophi->req(); i++) {\n-     Node* base               = ophi->in(i);\n-     JavaObjectNode* ptn      = unique_java_object(base);\n-\n-     \/\/ If the base is not scalar replaceable we don't need to register information about\n-     \/\/ it at this time.\n-     if (ptn == nullptr || !ptn->scalar_replaceable()) {\n-       continue;\n-     }\n-\n-     const TypeOopPtr* base_t   = _igvn->type(base)->make_oopptr();\n-     ciInstanceKlass* iklass    = base_t->is_instptr()->instance_klass();\n-     int nfields                = iklass->nof_nonstatic_fields();\n-     AllocateNode* alloc        = ptn->ideal_node()->as_Allocate();\n-     Node* ccpp                 = alloc->result_cast();\n-     const TypeOopPtr* res_type = _igvn->type(ccpp)->isa_oopptr();\n-     Node* base_klass_node      = alloc->in(AllocateNode::KlassNode);\n-     assert(base_klass_node != nullptr, \"This shouldn't happen.\");\n-\n-     call->add_req(base_klass_node);\n-\n-     for (int j = 0; j < nfields; j++) {\n-       ciField* field            = iklass->nonstatic_field_at(j);\n-       ciType* elem_type         = field->type();\n-       BasicType basic_elem_type = field->layout_type();\n-       const Type* field_type    = nullptr;\n-       const TypeOopPtr *field_adr_type = res_type->add_offset(field->offset())->isa_oopptr();\n-\n-       if (is_reference_type(basic_elem_type)) {\n-         if (!elem_type->is_loaded()) {\n-           field_type = TypeInstPtr::BOTTOM;\n-         } else {\n-           field_type = TypeOopPtr::make_from_klass(elem_type->as_klass());\n-         }\n-\n-         if (UseCompressedOops) {\n-           field_type = field_type->make_narrowoop();\n-           basic_elem_type = T_NARROWOOP;\n-         }\n-       } else {\n-         field_type = Type::get_const_basic_type(basic_elem_type);\n-       }\n-\n-       Node* field_val = PhaseMacroExpand::value_from_mem(_compile, _igvn, memory, ctrl, basic_elem_type, field_type, field_adr_type, alloc);\n-       assert(field_val != nullptr, \"field_val is null\");\n-\n-       call->add_req(field_val);\n-     }\n-\n-     JVMState *jvms = call->jvms();\n-     jvms->set_endoff(call->req());\n-   }\n-\n-   SafePointScalarObjectNode* sobj = new SafePointScalarObjectNode(merge_t,\n-#ifdef ASSERT\n-   NOT_PRODUCT(nullptr),\n-#endif\n-                                                                   \/* first_index *\/ 0,\n-                                                                   \/* n_fields *\/ 0,\n-                                                                   scalar_fields_index,\n-                                                                   number_of_sr_objects);\n-   assert(sobj->is_from_merge(), \"sanity\");\n-\n-   sobj->init_req(0, _compile->root());\n-   _igvn->register_new_node_with_optimizer(sobj);\n-\n-   \/\/ Replaces debug information references to \"ophi\" in \"call\" with references to \"sobj\"\n-   call->replace_edges_in_range(ophi, sobj, debug_start, debug_end, _igvn);\n-   _igvn->_worklist.push(call);\n- }\n+  \/\/ Fill in the 'selector' Phi. If index 'i' of the selector is:\n+  \/\/ -> a '-1' constant, the i'th input of the original Phi is NSR.\n+  \/\/ -> a 'x' constant >=0, the i'th input of of original Phi will be SR and the\n+  \/\/    info about the scalarized object will be at index x of\n+  \/\/    ObjectMergeValue::possible_objects\n+  for (uint i = 1; i < ophi->req(); i++) {\n+    Node* base          = ophi->in(i);\n+    JavaObjectNode* ptn = unique_java_object(base);\n+\n+    if (ptn != nullptr && ptn->scalar_replaceable()) {\n+      Node* sr_obj_idx = _igvn->register_new_node_with_optimizer(ConINode::make(number_of_sr_objects));\n+      selector->set_req(i, sr_obj_idx);\n+      number_of_sr_objects++;\n+    }\n+  }\n+\n+  \/\/ Update the debug information of all safepoints in turn\n+  for (uint spi = 0; spi < safepoints->size(); spi++) {\n+    Node* call      = safepoints->at(spi);\n+    Node* ctrl      = call->in(TypeFunc::Control);\n+    Node* memory    = call->in(TypeFunc::Memory);\n+    JVMState *jvms  = call->jvms();\n+    uint merge_idx  = (call->req() - jvms->scloff());\n+    int debug_start = jvms->debug_start();\n+\n+    SafePointScalarMergeNode* smerge = new SafePointScalarMergeNode(merge_t, merge_idx);\n+    smerge->init_req(0, _compile->root());\n+    _igvn->register_new_node_with_optimizer(smerge);\n+\n+    \/\/ Keep a copy of the original pointer to NSR objects\n+    call->add_req(ophi);\n+\n+    \/\/ Add the selector so we know which direction the execution took\n+    call->add_req(selector);\n+\n+    for (uint i = 1; i < ophi->req(); i++) {\n+      Node* base          = ophi->in(i);\n+      JavaObjectNode* ptn = unique_java_object(base);\n+\n+      \/\/ If the base is not scalar replaceable we don't need to register information about\n+      \/\/ it at this time.\n+      if (ptn == nullptr || !ptn->scalar_replaceable()) {\n+        continue;\n+      }\n+\n+      const TypeOopPtr* base_t   = _igvn->type(base)->make_oopptr();\n+      ciInstanceKlass* iklass    = base_t->is_instptr()->instance_klass();\n+      int nfields                = iklass->nof_nonstatic_fields();\n+      AllocateNode* alloc        = ptn->ideal_node()->as_Allocate();\n+      Node* ccpp                 = alloc->result_cast();\n+      const TypeOopPtr* res_type = _igvn->type(ccpp)->isa_oopptr();\n+      Node* base_klass_node      = alloc->in(AllocateNode::KlassNode);\n+      uint first_ind             = (call->req() - jvms->scloff());\n+\n+      SafePointScalarObjectNode* sobj = new SafePointScalarObjectNode(res_type, alloc, first_ind, nfields);\n+      sobj->init_req(0, _compile->root());\n+      _igvn->register_new_node_with_optimizer(sobj);\n+\n+      for (int j = 0; j < nfields; j++) {\n+        ciField* field            = iklass->nonstatic_field_at(j);\n+        ciType* elem_type         = field->type();\n+        BasicType basic_elem_type = field->layout_type();\n+        const Type* field_type    = nullptr;\n+        const TypeOopPtr *field_adr_type = res_type->add_offset(field->offset())->isa_oopptr();\n+\n+        if (is_reference_type(basic_elem_type)) {\n+          if (!elem_type->is_loaded()) {\n+            field_type = TypeInstPtr::BOTTOM;\n+          } else {\n+            field_type = TypeOopPtr::make_from_klass(elem_type->as_klass());\n+          }\n+\n+          if (UseCompressedOops) {\n+            field_type = field_type->make_narrowoop();\n+            basic_elem_type = T_NARROWOOP;\n+          }\n+        } else {\n+          field_type = Type::get_const_basic_type(basic_elem_type);\n+        }\n+\n+        Node* field_val = PhaseMacroExpand::value_from_mem(_compile, _igvn, memory, ctrl, basic_elem_type, field_type, field_adr_type, alloc);\n+        assert(field_val != nullptr, \"field_val is null\");\n+\n+        call->add_req(field_val);\n+      }\n+\n+      jvms->set_endoff(call->req());\n+\n+      \/\/ Now make a pass over the debug information replacing any references\n+      \/\/ to the allocated object with \"sobj\"\n+      int debug_end = jvms->debug_end();\n+      int reps = call->replace_edges_in_range(ccpp, sobj, debug_start, debug_end, _igvn);\n+\n+      \/\/ If the call was NOT using the scalarized object directly then this SOBJ\n+      \/\/ is just a candidate for rematerialization.\n+      if (reps == 0) {\n+        sobj->set_only_merge_sr_candidate(true);\n+      }\n+\n+      \/\/ Register the scalarized object as a candidate for reallocation\n+      smerge->add_req(sobj);\n+    }\n+\n+    \/\/ Replaces debug information references to \"ophi\" in \"call\" with references to \"smerge\"\n+    int debug_end = jvms->debug_end();\n+    call->replace_edges_in_range(ophi, smerge, debug_start, debug_end, _igvn);\n+    call->set_req(smerge->merge_pointer_idx(jvms), ophi);\n+    _igvn->_worklist.push(call);\n+  }\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":111,"deletions":103,"binary":false,"changes":214,"status":"modified"},{"patch":"@@ -726,5 +726,1 @@\n-    SafePointScalarObjectNode* sobj = new SafePointScalarObjectNode(res_type,\n-#ifdef ASSERT\n-                                                 alloc,\n-#endif\n-                                                 first_ind, nfields);\n+    SafePointScalarObjectNode* sobj = new SafePointScalarObjectNode(res_type, alloc, first_ind, nfields);\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -159,0 +159,1 @@\n+class SafePointScalarMergeNode;\n@@ -717,0 +718,1 @@\n+      DEFINE_CLASS_ID(SafePointScalarMerge, Type, 9)\n@@ -942,0 +944,1 @@\n+  DEFINE_CLASS_QUERY(SafePointScalarMerge)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -709,1 +709,1 @@\n-ScopeValue*\n+ObjectValue*\n@@ -712,12 +712,4 @@\n-    if (objs->at(i)->is_object()) {\n-      ObjectValue* sv = (ObjectValue*) objs->at(i);\n-      if (sv->id() == id) {\n-        return sv;\n-      }\n-    } else if (objs->at(i)->is_object_merge()) {\n-      ObjectMergeValue* sv = (ObjectMergeValue*) objs->at(i);\n-      if (sv->id() == id) {\n-        return sv;\n-      }\n-    } else {\n-      assert(false, \"corrupt object cache\");\n+    assert(objs->at(i)->is_object(), \"corrupt object cache\");\n+    ObjectValue* sv = (ObjectValue*) objs->at(i);\n+    if (sv->id() == id) {\n+      return sv;\n@@ -730,3 +722,3 @@\n-void PhaseOutput::set_sv_for_object_node(GrowableArray<ScopeValue*> *objs, ScopeValue* sv ) {\n-  assert(!sv->is_object() || (sv_for_node_id(objs, sv->as_ObjectValue()->id()) == nullptr), \"Precondition\");\n-  assert(!sv->is_object_merge() || (sv_for_node_id(objs, sv->as_ObjectMergeValue()->id()) == nullptr), \"Precondition\");\n+void PhaseOutput::set_sv_for_object_node(GrowableArray<ScopeValue*> *objs,\n+                                     ObjectValue* sv) {\n+  assert(sv_for_node_id(objs, sv->id()) == nullptr, \"Precondition\");\n@@ -759,16 +751,14 @@\n-\n-    if (!spobj->is_from_merge()) {\n-      ObjectValue* sv = (ObjectValue*) sv_for_node_id(objs, spobj->_idx);\n-      if (sv == nullptr) {\n-        ciKlass* cik = t->is_oopptr()->exact_klass();\n-        assert(cik->is_instance_klass() ||\n-              cik->is_array_klass(), \"Not supported allocation.\");\n-        sv = new ObjectValue(spobj->_idx,\n-                            new ConstantOopWriteValue(cik->java_mirror()->constant_encoding()));\n-        set_sv_for_object_node(objs, sv);\n-\n-        uint first_ind = spobj->first_index(sfpt->jvms());\n-        for (uint i = 0; i < spobj->n_fields(); i++) {\n-          Node* fld_node = sfpt->in(first_ind+i);\n-          (void)FillLocArray(sv->field_values()->length(), sfpt, fld_node, sv->field_values(), objs);\n-        }\n+    ObjectValue* sv = (ObjectValue*) sv_for_node_id(objs, spobj->_idx);\n+    if (sv == nullptr) {\n+      ciKlass* cik = t->is_oopptr()->exact_klass();\n+      assert(cik->is_instance_klass() ||\n+            cik->is_array_klass(), \"Not supported allocation.\");\n+      sv = new ObjectValue(spobj->_idx,\n+                           new ConstantOopWriteValue(cik->java_mirror()->constant_encoding()),\n+                           spobj->is_only_merge_sr_candidate());\n+      set_sv_for_object_node(objs, sv);\n+\n+      uint first_ind = spobj->first_index(sfpt->jvms());\n+      for (uint i = 0; i < spobj->n_fields(); i++) {\n+        Node* fld_node = sfpt->in(first_ind+i);\n+        (void)FillLocArray(sv->field_values()->length(), sfpt, fld_node, sv->field_values(), objs);\n@@ -776,0 +766,1 @@\n+    }\n@@ -777,37 +768,12 @@\n-      array->append(sv);\n-    } else if (spobj->is_from_merge()) {\n-      ObjectMergeValue* sv = (ObjectMergeValue*) sv_for_node_id(objs, spobj->_idx);\n-      if (sv == NULL) {\n-        GrowableArray<ScopeValue*> deps;\n-\n-        int merge_pointer_idx = spobj->merge_pointer_idx(sfpt->jvms());\n-        (void)FillLocArray(0, NULL, sfpt->in(merge_pointer_idx), &deps, NULL);\n-        assert(deps.length() == 1, \"missing value\");\n-\n-        int selector_idx = spobj->selector_idx(sfpt->jvms());\n-        (void)FillLocArray(1, NULL, sfpt->in(selector_idx), &deps, NULL);\n-        assert(deps.length() == 2, \"missing value\");\n-\n-        sv = new ObjectMergeValue(spobj->_idx, deps.at(0), deps.at(1));\n-        set_sv_for_object_node(objs, sv);\n-\n-        uint number_of_sr_objects = spobj->number_of_objects();\n-        uint field_index = selector_idx+1;\n-        const uint CANDIDATE_OBJ_BASE_IDX = 100000;\n-        for (uint i = 0; i < number_of_sr_objects; i++) {\n-          Node* klass_node = sfpt->in(field_index++);\n-          const Type *t = klass_node->bottom_type();\n-          assert(t->is_instklassptr(), \"Not supported allocation.\");\n-          ciInstanceKlass* cik = t->isa_instklassptr()->instance_klass();\n-\n-          ObjectValue* sv_o = new ObjectValue(CANDIDATE_OBJ_BASE_IDX + spobj->_idx + i,\n-                              new ConstantOopWriteValue(cik->java_mirror()->constant_encoding()));\n-          set_sv_for_object_node(sv->possible_objects(), sv_o);\n-\n-          uint nfields = cik->nof_nonstatic_fields();\n-          for (uint j = 0; j < nfields; j++) {\n-            Node* fld_node = sfpt->in(field_index++);\n-            (void)FillLocArray(sv_o->field_values()->length(), sfpt, fld_node, sv_o->field_values(), sv->possible_objects());\n-          }\n-        }\n-      }\n+    array->append(sv);\n+    return;\n+  } else if (local->is_SafePointScalarMerge()) {\n+    SafePointScalarMergeNode* smerge = local->as_SafePointScalarMerge();\n+    ObjectMergeValue* sv = (ObjectMergeValue*) sv_for_node_id(objs, smerge->_idx);\n+\n+    if (sv == NULL) {\n+      GrowableArray<ScopeValue*> deps;\n+\n+      int merge_pointer_idx = smerge->merge_pointer_idx(sfpt->jvms());\n+      (void)FillLocArray(0, NULL, sfpt->in(merge_pointer_idx), &deps, NULL);\n+      assert(deps.length() == 1, \"missing value\");\n@@ -815,1 +781,11 @@\n-      array->append(sv);\n+      int selector_idx = smerge->selector_idx(sfpt->jvms());\n+      (void)FillLocArray(1, NULL, sfpt->in(selector_idx), &deps, NULL);\n+      assert(deps.length() == 2, \"missing value\");\n+\n+      sv = new ObjectMergeValue(smerge->_idx, deps.at(0), deps.at(1));\n+      set_sv_for_object_node(objs, sv);\n+\n+      for (uint i = 1; i < smerge->req(); i++) {\n+        Node* fld_node = smerge->in(i);\n+        (void)FillLocArray(sv->possible_objects()->length(), sfpt, fld_node, sv->possible_objects(), objs);\n+      }\n@@ -817,0 +793,1 @@\n+    array->append(sv);\n@@ -1085,1 +1062,2 @@\n-                                            new ConstantOopWriteValue(cik->java_mirror()->constant_encoding()));\n+                                            new ConstantOopWriteValue(cik->java_mirror()->constant_encoding()),\n+                                            spobj->is_only_merge_sr_candidate());\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":49,"deletions":71,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -143,3 +143,3 @@\n-  \/\/ If \"objs\" contains an ObjectValue\/ObjectMergeValue whose id is \"id\", returns it, else null.\n-  static ScopeValue* sv_for_node_id(GrowableArray<ScopeValue*> *objs, int id);\n-  static void set_sv_for_object_node(GrowableArray<ScopeValue*> *objs, ScopeValue* sv);\n+  \/\/ If \"objs\" contains an ObjectValue whose id is \"id\", returns it, else null.\n+  static ObjectValue* sv_for_node_id(GrowableArray<ScopeValue*> *objs, int id);\n+  static void set_sv_for_object_node(GrowableArray<ScopeValue*> *objs, ObjectValue* sv);\n","filename":"src\/hotspot\/share\/opto\/output.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -280,5 +280,1 @@\n-    Node* sobj = new SafePointScalarObjectNode(vec_box->box_type(),\n-#ifdef ASSERT\n-                                               vec_box,\n-#endif \/\/ ASSERT\n-                                               first_ind, n_fields);\n+    Node* sobj = new SafePointScalarObjectNode(vec_box->box_type(), vec_box, first_ind, n_fields);\n","filename":"src\/hotspot\/share\/opto\/vector.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -305,1 +305,6 @@\n-    if (objects->at(i)->is_object()) {\n+    if (objects->at(i)->is_object_merge()) {\n+      ObjectMergeValue* merged = objects->at(i)->as_ObjectMergeValue();\n+      sv = merged->select(frame, reg_map);\n+      \/\/ Klass may be null if the object was actually a NSR input of a merge.\n+      k = sv->klass() != nullptr ? java_lang_Class::as_Klass(sv->klass()->as_ConstantOopReadValue()->value()()) : nullptr;\n+    } else if (objects->at(i)->is_object()) {\n@@ -308,1 +313,1 @@\n-      if (sv->is_merge_candidate()) {\n+      if (sv->is_only_merge_sr_candidate()) {\n@@ -312,5 +317,0 @@\n-    } else if (objects->at(i)->is_object_merge()) {\n-      ObjectMergeValue* merged = objects->at(i)->as_ObjectMergeValue();\n-      sv = merged->select(frame, reg_map);\n-      \/\/ Klass may be null if the object was actually a NSR input of a merge.\n-      k = sv->klass() != nullptr ? java_lang_Class::as_Klass(sv->klass()->as_ConstantOopReadValue()->value()()) : nullptr;\n@@ -323,1 +323,1 @@\n-      st.print(\" from an allocation merge.\");\n+      st.print(\" NSR input from an allocation merge.\");\n@@ -1211,1 +1211,1 @@\n-    assert(objects->at(i)->is_object() || objects->at(i)->is_object_merge(), \"invalid debug information\");\n+    assert(objects->at(i)->is_object(), \"invalid debug information\");\n@@ -1214,8 +1214,1 @@\n-    if (objects->at(i)->is_object()) {\n-      sv = objects->at(i)->as_ObjectValue();\n-\n-      \/\/ This object is only a candidate inside an ObjectMergeValue\n-      if (sv->is_merge_candidate()) {\n-        continue;\n-      }\n-    } else {\n+    if (objects->at(i)->is_object_merge()) {\n@@ -1237,0 +1230,9 @@\n+    } else if (objects->at(i)->is_object()) {\n+      sv = objects->at(i)->as_ObjectValue();\n+\n+      \/\/ This object is only a candidate inside an ObjectMergeValue\n+      if (sv->is_only_merge_sr_candidate()) {\n+        continue;\n+      }\n+    } else {\n+      assert(false, \"sanity\");\n@@ -1586,1 +1588,1 @@\n-    assert(objects->at(i)->is_object() || objects->at(i)->is_object_merge(), \"invalid debug information\");\n+    assert(objects->at(i)->is_object(), \"invalid debug information\");\n@@ -1589,1 +1591,4 @@\n-    if (objects->at(i)->is_object()) {\n+    if (objects->at(i)->is_object_merge()) {\n+      \/\/ Merge objects don't need field reassignment\n+      continue;\n+    } else if (objects->at(i)->is_object()) {\n@@ -1597,1 +1602,1 @@\n-      if (sv->is_merge_candidate() || sv->skip_field_assignment()) {\n+      if (sv->is_only_merge_sr_candidate() || sv->skip_field_assignment()) {\n@@ -1601,2 +1606,1 @@\n-      \/\/ Merge objects don't need field reassignment\n-      continue;\n+      assert(false, \"sanity\");\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":26,"deletions":22,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -226,3 +226,0 @@\n-  } else if (sv->is_object()) { \/\/ Scalar replaced object in compiled frame\n-    Handle ov = ((ObjectValue *)sv)->value();\n-    return new StackValue(ov, (ov.is_null()) ? 1 : 0);\n@@ -232,0 +229,3 @@\n+  } else if (sv->is_object()) { \/\/ Scalar replaced object in compiled frame\n+    Handle ov = ((ObjectValue *)sv)->value();\n+    return new StackValue(ov, (ov.is_null()) ? 1 : 0);\n","filename":"src\/hotspot\/share\/runtime\/stackValue.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -153,0 +153,1 @@\n+      assert(!scopedValues->at(i2)->is_object_merge(), \"sanity\");\n@@ -167,0 +168,1 @@\n+      assert(!scopeExpressions->at(i2)->is_object_merge(), \"sanity\");\n@@ -270,0 +272,1 @@\n+    assert(!ov->is_object_merge(), \"sanity\");\n","filename":"src\/hotspot\/share\/runtime\/vframe_hp.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * @requires vm.compiler2.enabled\n+ * @requires vm.bits == 64 & vm.compiler2.enabled & vm.opt.final.UseCompressedOops & vm.opt.final.EliminateAllocations\n@@ -486,1 +486,1 @@\n-    @IR(counts = { IRNode.ALLOC, \"2\" }, applyIf = { \"UseCompressedOops\", \"false\" })\n+    @IR(counts = { IRNode.ALLOC, \"2\" } )\n@@ -489,2 +489,1 @@\n-    \/\/ currently isn't supported. The 'applyIf' directive is needed to make the\n-    \/\/ test pass on x86_32 VMs.\n+    \/\/ currently isn't supported.\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/scalarReplacement\/AllocationMergesTests.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"}]}