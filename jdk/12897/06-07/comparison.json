{"files":[{"patch":"@@ -74,2 +74,1 @@\n-    assert(!_obj_pool->at(i)->is_object() || _obj_pool->at(i)->as_ObjectValue()->id() != id, \"should not be read twice\");\n-    assert(!_obj_pool->at(i)->is_object_merge() || _obj_pool->at(i)->as_ObjectMergeValue()->id() != id, \"should not be read twice\");\n+    assert(_obj_pool->at(i)->as_ObjectValue()->id() != id, \"should not be read twice\");\n@@ -90,2 +89,1 @@\n-    assert(!_obj_pool->at(i)->is_object() || _obj_pool->at(i)->as_ObjectValue()->id() != id, \"should not be read twice\");\n-    assert(!_obj_pool->at(i)->is_object_merge() || _obj_pool->at(i)->as_ObjectMergeValue()->id() != id, \"should not be read twice\");\n+    assert(_obj_pool->at(i)->as_ObjectValue()->id() != id, \"should not be read twice\");\n@@ -171,1 +169,1 @@\n-  _only_merge_sr_candidate = stream->read_bool();\n+  _only_merge_candidate = stream->read_bool();\n@@ -189,1 +187,1 @@\n-    stream->write_bool(_only_merge_sr_candidate);\n+    stream->write_bool(_only_merge_candidate);\n@@ -202,1 +200,1 @@\n-            _only_merge_sr_candidate, _skip_field_assignment, _field_values.length());\n+            _only_merge_candidate, _skip_rematerialization, _field_values.length());\n@@ -252,2 +250,3 @@\n-    \/\/ No need for field assignment as the object wasn't really scalar replaced\n-    _selected->set_skip_field_assignment();\n+    \/\/ No need to allocate the object or do field reassignment since\n+    \/\/ the object wasn't really scalar replaced.\n+    _selected->set_skip_rematerialization();\n","filename":"src\/hotspot\/share\/code\/debugInfo.cpp","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -136,1 +136,1 @@\n-  bool                       _only_merge_sr_candidate;\/\/ Will be true if this object is just representing\n+  bool                       _only_merge_candidate;   \/\/ Will be true if this object is just representing\n@@ -139,1 +139,1 @@\n-  bool                       _skip_field_assignment;  \/\/ Will be true if the _value field of this object\n+  bool                       _skip_rematerialization; \/\/ Will be true if the _value field of this object\n@@ -143,1 +143,1 @@\n-  ObjectValue(int id, ScopeValue* klass, bool only_merge_sr_candidate = false)\n+  ObjectValue(int id, ScopeValue* klass, bool only_merge_candidate = false)\n@@ -149,2 +149,2 @@\n-     , _only_merge_sr_candidate(only_merge_sr_candidate)\n-     , _skip_field_assignment(false) {\n+     , _only_merge_candidate(only_merge_candidate)\n+     , _skip_rematerialization(false) {\n@@ -160,2 +160,2 @@\n-     , _only_merge_sr_candidate(false)\n-     , _skip_field_assignment(false) {}\n+     , _only_merge_candidate(false)\n+     , _skip_rematerialization(false) {}\n@@ -172,2 +172,2 @@\n-  bool                        is_only_merge_sr_candidate() const  { return _only_merge_sr_candidate; }\n-  bool                        skip_field_assignment() const       { return _skip_field_assignment; }\n+  bool                        is_only_merge_candidate() const     { return _only_merge_candidate; }\n+  bool                        skip_rematerialization() const      { return _skip_rematerialization; }\n@@ -178,2 +178,2 @@\n-  void                        set_merge_candidate(bool cnd)       { _only_merge_sr_candidate = cnd; }\n-  void                        set_skip_field_assignment()         { _skip_field_assignment = true; }\n+  void                        set_merge_candidate(bool cnd)       { _only_merge_candidate = cnd; }\n+  void                        set_skip_rematerialization()        { _skip_rematerialization = true; }\n","filename":"src\/hotspot\/share\/code\/debugInfo.hpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -55,0 +55,3 @@\n+const char* C2Compiler::retry_no_reduce_allocation_merges() {\n+  return \"retry without reducing allocation merges\";\n+}\n@@ -112,0 +115,1 @@\n+  bool do_reduce_allocation_merges = ReduceAllocationMerges;\n@@ -117,1 +121,1 @@\n-    Options options(subsume_loads, do_escape_analysis, do_iterative_escape_analysis, eliminate_boxing, do_locks_coarsening, install_code);\n+    Options options(subsume_loads, do_escape_analysis, do_iterative_escape_analysis, do_reduce_allocation_merges, eliminate_boxing, do_locks_coarsening, install_code);\n@@ -144,0 +148,6 @@\n+      if (C.failure_reason_is(retry_no_reduce_allocation_merges())) {\n+        assert(do_reduce_allocation_merges, \"must make progress\");\n+        do_reduce_allocation_merges = false;\n+        env->report_failure(C.failure_reason());\n+        continue;  \/\/ retry\n+      }\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+  static const char* retry_no_reduce_allocation_merges();\n","filename":"src\/hotspot\/share\/opto\/c2compiler.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1466,1 +1466,1 @@\n-SafePointScalarObjectNode::SafePointScalarObjectNode(const TypeOopPtr* tp, Node* alloc, uint first_index, uint n_fields, bool only_merge_sr_candidate) :\n+SafePointScalarObjectNode::SafePointScalarObjectNode(const TypeOopPtr* tp, Node* alloc, uint first_index, uint n_fields, bool only_merge_candidate) :\n@@ -1471,1 +1471,1 @@\n-  _only_merge_sr_candidate(only_merge_sr_candidate)\n+  _only_merge_candidate(only_merge_candidate)\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -516,1 +516,1 @@\n-  bool _only_merge_sr_candidate;  \/\/ Will be true if the object described by this Node is only\n+  bool _only_merge_candidate;     \/\/ Will be true if the object described by this Node is only\n@@ -539,2 +539,2 @@\n-  bool is_only_merge_sr_candidate()           { return _only_merge_sr_candidate; }\n-  void set_only_merge_sr_candidate(bool only) { _only_merge_sr_candidate = only; }\n+  bool is_only_merge_candidate()           { return _only_merge_candidate; }\n+  void set_only_merge_candidate(bool only) { _only_merge_candidate = only; }\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -520,0 +520,6 @@\n+  }\n+  if (do_reduce_allocation_merges() != ReduceAllocationMerges && PrintOpto) {\n+    \/\/ Recompiling without reducing allocation merges\n+    tty->print_cr(\"*********************************************************\");\n+    tty->print_cr(\"** Bailout: Recompile without reduce allocation merges **\");\n+    tty->print_cr(\"*********************************************************\");\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -177,0 +177,1 @@\n+  const bool _do_reduce_allocation_merges;  \/\/ Do try to reduce allocation merges.\n@@ -183,0 +184,1 @@\n+          bool do_reduce_allocation_merges,\n@@ -188,0 +190,1 @@\n+          _do_reduce_allocation_merges(do_reduce_allocation_merges),\n@@ -198,0 +201,1 @@\n+       \/* do_reduce_allocation_merges = *\/ false,\n@@ -545,0 +549,1 @@\n+  bool              do_reduce_allocation_merges() const  { return _options._do_reduce_allocation_merges; }\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -407,0 +407,4 @@\n+      if (C->failing()) {\n+        NOT_PRODUCT(escape_state_statistics(java_objects_worklist);)\n+        return false;\n+      }\n@@ -500,0 +504,7 @@\n+  \/\/ If there was an error attempting to reduce allocation merges for this\n+  \/\/ method we might have disabled the compilation and be retrying\n+  \/\/ with RAM disabled.\n+  if (!_compile->do_reduce_allocation_merges()) {\n+    return false;\n+  }\n+\n@@ -636,1 +647,5 @@\n-    \/\/ Keep a copy of the original pointer to NSR objects\n+    \/\/ The next two inputs are:\n+    \/\/  (1) A copy of the original pointer to NSR objects.\n+    \/\/  (2) A selector, used to decide if we need to rematerialize an object\n+    \/\/      or use the pointer to a NSR object.\n+    \/\/ See more details of these fields in the declaration of SafePointScalarMergeNode\n@@ -638,2 +653,0 @@\n-\n-    \/\/ Add the selector so we know which direction the execution took\n@@ -655,1 +668,2 @@\n-        fatal(\"Failed to create SafePointScalarObjectNode!\");\n+        C2Compiler::retry_no_reduce_allocation_merges();\n+        return;\n@@ -658,2 +672,0 @@\n-      jvms->set_endoff(sfpt->req());\n-\n@@ -669,1 +681,1 @@\n-        sobj->set_only_merge_sr_candidate(true);\n+        sobj->set_only_merge_candidate(true);\n@@ -679,0 +691,4 @@\n+\n+    \/\/ The call to 'replace_edges_in_range' above might have removed the\n+    \/\/ reference to ophi that we need at _merge_pointer_idx. The line below make\n+    \/\/ sure the reference is maintained.\n@@ -2237,2 +2253,7 @@\n-        if (ReduceAllocationMerges && use_n->is_Phi() &&\n-            (reducible_merges.member(use_n) || can_reduce_this_phi(use_n->as_Phi()))) {\n+\n+        \/\/ If it's already a candidate or confirmed reducible merge we can skip verification\n+        if (candidates.member(use_n) || reducible_merges.member(use_n)) {\n+          continue;\n+        }\n+\n+        if (ReduceAllocationMerges && use_n->is_Phi() && can_reduce_this_phi(use_n->as_Phi())) {\n@@ -2241,1 +2262,1 @@\n-          \/\/ Mark all objects as NSR & NonUnique if we can't remove the merge\n+          \/\/ Mark all objects as NSR if we can't remove the merge\n@@ -2319,0 +2340,4 @@\n+\n+      if (!jobj->scalar_replaceable()) {\n+        return;\n+      }\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":35,"deletions":10,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -848,0 +848,2 @@\n+  sfpt->jvms()->set_endoff(sfpt->req());\n+\n@@ -867,3 +869,0 @@\n-    JVMState *jvms = sfpt->jvms();\n-    jvms->set_endoff(sfpt->req());\n-\n@@ -872,3 +871,2 @@\n-    int start = jvms->debug_start();\n-    int end   = jvms->debug_end();\n-    sfpt->replace_edges_in_range(res, sobj, start, end, &_igvn);\n+    JVMState *jvms = sfpt->jvms();\n+    sfpt->replace_edges_in_range(res, sobj, jvms->debug_start(), jvms->debug_end(), &_igvn);\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -758,1 +758,1 @@\n-                           spobj->is_only_merge_sr_candidate());\n+                           spobj->is_only_merge_candidate());\n@@ -778,1 +778,1 @@\n-      (void)FillLocArray(0, NULL, sfpt->in(merge_pointer_idx), &deps, NULL);\n+      (void)FillLocArray(0, sfpt, sfpt->in(merge_pointer_idx), &deps, objs);\n@@ -789,2 +789,2 @@\n-        Node* fld_node = smerge->in(i);\n-        (void)FillLocArray(sv->possible_objects()->length(), sfpt, fld_node, sv->possible_objects(), objs);\n+        Node* obj_node = smerge->in(i);\n+        (void)FillLocArray(sv->possible_objects()->length(), sfpt, obj_node, sv->possible_objects(), objs);\n@@ -1063,1 +1063,1 @@\n-                                            spobj->is_only_merge_sr_candidate());\n+                                            spobj->is_only_merge_candidate());\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -309,1 +309,1 @@\n-      k = sv->klass() != nullptr ? java_lang_Class::as_Klass(sv->klass()->as_ConstantOopReadValue()->value()()) : nullptr;\n+      k = (sv != nullptr && sv->klass() != nullptr) ? java_lang_Class::as_Klass(sv->klass()->as_ConstantOopReadValue()->value()()) : nullptr;\n@@ -313,1 +313,1 @@\n-      if (sv->is_only_merge_sr_candidate()) {\n+      if (sv->is_only_merge_candidate()) {\n@@ -1246,3 +1246,2 @@\n-      \/\/ Will be non-null when it's a pointer from a merge where the\n-      \/\/ executed path is of an object NOT scalar replaced.\n-      if (!sv->value().is_null()) {\n+      \/\/ Will be true whenever the object was a NSR input of an allocation merge\n+      if (sv->skip_rematerialization()) {\n@@ -1255,1 +1254,1 @@\n-      if (sv->is_only_merge_sr_candidate()) {\n+      if (sv->is_only_merge_candidate()) {\n@@ -1628,1 +1627,1 @@\n-      if (sv->is_only_merge_sr_candidate() || sv->skip_field_assignment()) {\n+      if (sv->is_only_merge_candidate() || sv->skip_rematerialization()) {\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -227,2 +227,5 @@\n-    Handle ov = ((ObjectMergeValue *)sv)->selected()->value();\n-    return new StackValue(ov, (ov.is_null()) ? 1 : 0);\n+    ObjectValue* ov = ((ObjectMergeValue *)sv)->selected();\n+    Handle hdl = ov->value();\n+    \/\/ If the object didn't have to rematerialize it might have actually been a\n+    \/\/ pointer to null.\n+    return new StackValue(hdl, (!ov->skip_rematerialization() && hdl.is_null()) ? 1 : 0);\n@@ -230,2 +233,5 @@\n-    Handle ov = ((ObjectValue *)sv)->value();\n-    return new StackValue(ov, (ov.is_null()) ? 1 : 0);\n+    ObjectValue* ov = (ObjectValue *)sv;\n+    Handle hdl = ov->value();\n+    \/\/ If the object didn't have to rematerialize it might have actually been a\n+    \/\/ pointer to null.\n+    return new StackValue(hdl, (!ov->skip_rematerialization() && hdl.is_null()) ? 1 : 0);\n","filename":"src\/hotspot\/share\/runtime\/stackValue.cpp","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"}]}