{"files":[{"patch":"@@ -454,1 +454,1 @@\n-      if (PhaseMacroExpand::can_eliminate_allocation(_igvn, alloc, nullptr, true)) {\n+      if (PhaseMacroExpand::can_eliminate_allocation(_igvn, alloc, nullptr)) {\n@@ -590,2 +590,4 @@\n-\/\/ Each SafePointScalarObjectNode created here may describe multiple scalar\n-\/\/ replaced objects - check detailed description in SafePointScalarObjectNode\n+\/\/ The method will create a SafePointScalarMERGEnode for each combination of\n+\/\/ 'ophi' and SafePoint node in 'safepoints'.\n+\/\/ Each SafePointScalarMergeNode created here may describe multiple scalar\n+\/\/ replaced objects - check detailed description in SafePointScalarMergeNode\n@@ -601,0 +603,1 @@\n+  PhaseMacroExpand mexp(*_igvn);\n@@ -622,6 +625,6 @@\n-    Node* call      = safepoints->at(spi);\n-    Node* ctrl      = call->in(TypeFunc::Control);\n-    Node* memory    = call->in(TypeFunc::Memory);\n-    JVMState *jvms  = call->jvms();\n-    uint merge_idx  = (call->req() - jvms->scloff());\n-    int debug_start = jvms->debug_start();\n+    SafePointNode* sfpt = safepoints->at(spi)->as_SafePoint();\n+    Node* ctrl          = sfpt->in(TypeFunc::Control);\n+    Node* memory        = sfpt->in(TypeFunc::Memory);\n+    JVMState *jvms      = sfpt->jvms();\n+    uint merge_idx      = (sfpt->req() - jvms->scloff());\n+    int debug_start     = jvms->debug_start();\n@@ -634,1 +637,1 @@\n-    call->add_req(ophi);\n+    sfpt->add_req(ophi);\n@@ -637,1 +640,1 @@\n-    call->add_req(selector);\n+    sfpt->add_req(selector);\n@@ -649,39 +652,4 @@\n-      const TypeOopPtr* base_t   = _igvn->type(base)->make_oopptr();\n-      ciInstanceKlass* iklass    = base_t->is_instptr()->instance_klass();\n-      int nfields                = iklass->nof_nonstatic_fields();\n-      AllocateNode* alloc        = ptn->ideal_node()->as_Allocate();\n-      Node* ccpp                 = alloc->result_cast();\n-      const TypeOopPtr* res_type = _igvn->type(ccpp)->isa_oopptr();\n-      Node* base_klass_node      = alloc->in(AllocateNode::KlassNode);\n-      uint first_ind             = (call->req() - jvms->scloff());\n-\n-      SafePointScalarObjectNode* sobj = new SafePointScalarObjectNode(res_type, alloc, first_ind, nfields);\n-      sobj->init_req(0, _compile->root());\n-      _igvn->register_new_node_with_optimizer(sobj);\n-\n-      for (int j = 0; j < nfields; j++) {\n-        ciField* field            = iklass->nonstatic_field_at(j);\n-        ciType* elem_type         = field->type();\n-        BasicType basic_elem_type = field->layout_type();\n-        const Type* field_type    = nullptr;\n-        const TypeOopPtr *field_adr_type = res_type->add_offset(field->offset())->isa_oopptr();\n-\n-        if (is_reference_type(basic_elem_type)) {\n-          if (!elem_type->is_loaded()) {\n-            field_type = TypeInstPtr::BOTTOM;\n-          } else {\n-            field_type = TypeOopPtr::make_from_klass(elem_type->as_klass());\n-          }\n-\n-          if (UseCompressedOops) {\n-            field_type = field_type->make_narrowoop();\n-            basic_elem_type = T_NARROWOOP;\n-          }\n-        } else {\n-          field_type = Type::get_const_basic_type(basic_elem_type);\n-        }\n-\n-        Node* field_val = PhaseMacroExpand::value_from_mem(_compile, _igvn, memory, ctrl, basic_elem_type, field_type, field_adr_type, alloc);\n-        assert(field_val != nullptr, \"field_val is null\");\n-\n-        call->add_req(field_val);\n+      AllocateNode* alloc = ptn->ideal_node()->as_Allocate();\n+      SafePointScalarObjectNode* sobj = mexp.create_scalarized_object_description(alloc, sfpt);\n+      if (sobj == nullptr) {\n+        fatal(\"Failed to create SafePointScalarObjectNode!\");\n@@ -690,1 +658,1 @@\n-      jvms->set_endoff(call->req());\n+      jvms->set_endoff(sfpt->req());\n@@ -694,0 +662,1 @@\n+      Node* ccpp = alloc->result_cast();\n@@ -695,1 +664,1 @@\n-      int reps = call->replace_edges_in_range(ccpp, sobj, debug_start, debug_end, _igvn);\n+      int reps = sfpt->replace_edges_in_range(ccpp, sobj, debug_start, debug_end, _igvn);\n@@ -697,1 +666,1 @@\n-      \/\/ If the call was NOT using the scalarized object directly then this SOBJ\n+      \/\/ If the sfpt was NOT using the scalarized object directly then this SOBJ\n@@ -707,1 +676,1 @@\n-    \/\/ Replaces debug information references to \"ophi\" in \"call\" with references to \"smerge\"\n+    \/\/ Replaces debug information references to \"ophi\" in \"sfpt\" with references to \"smerge\"\n@@ -709,3 +678,3 @@\n-    call->replace_edges_in_range(ophi, smerge, debug_start, debug_end, _igvn);\n-    call->set_req(smerge->merge_pointer_idx(jvms), ophi);\n-    _igvn->_worklist.push(call);\n+    sfpt->replace_edges_in_range(ophi, smerge, debug_start, debug_end, _igvn);\n+    sfpt->set_req(smerge->merge_pointer_idx(jvms), ophi);\n+    _igvn->_worklist.push(sfpt);\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":26,"deletions":57,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -277,1 +277,1 @@\n-Node* PhaseMacroExpand::make_arraycopy_load(Compile* comp, PhaseIterGVN* igvn, ArrayCopyNode* ac, intptr_t offset, Node* ctl, Node* mem, BasicType ft, const Type *ftype, AllocateNode *alloc) {\n+Node* PhaseMacroExpand::make_arraycopy_load(ArrayCopyNode* ac, intptr_t offset, Node* ctl, Node* mem, BasicType ft, const Type *ftype, AllocateNode *alloc) {\n@@ -288,3 +288,3 @@\n-    Node* adr = igvn->transform(new AddPNode(base, base, igvn->MakeConX(offset)));\n-    const TypePtr* adr_type = igvn->type(base)->is_ptr()->add_offset(offset);\n-    MergeMemNode* mergemen = igvn->transform(MergeMemNode::make(mem))->as_MergeMem();\n+    Node* adr = _igvn.transform(new AddPNode(base, base, _igvn.MakeConX(offset)));\n+    const TypePtr* adr_type = _igvn.type(base)->is_ptr()->add_offset(offset);\n+    MergeMemNode* mergemen = _igvn.transform(MergeMemNode::make(mem))->as_MergeMem();\n@@ -292,1 +292,1 @@\n-    res = ArrayCopyNode::load(bs, igvn, ctl, mergemen, adr, adr_type, type, bt);\n+    res = ArrayCopyNode::load(bs, &_igvn, ctl, mergemen, adr, adr_type, type, bt);\n@@ -294,1 +294,1 @@\n-    if (ac->modifies(offset, offset, igvn, true)) {\n+    if (ac->modifies(offset, offset, &_igvn, true)) {\n@@ -299,2 +299,2 @@\n-      const TypeInt* src_pos_t = igvn->type(src_pos)->is_int();\n-      const TypeInt* dest_pos_t = igvn->type(dest_pos)->is_int();\n+      const TypeInt* src_pos_t = _igvn.type(src_pos)->is_int();\n+      const TypeInt* dest_pos_t = _igvn.type(dest_pos)->is_int();\n@@ -307,2 +307,2 @@\n-        adr = igvn->transform(new AddPNode(base, base, igvn->MakeConX(off)));\n-        adr_type = igvn->type(base)->is_ptr()->add_offset(off);\n+        adr = _igvn.transform(new AddPNode(base, base, _igvn.MakeConX(off)));\n+        adr_type = _igvn.type(base)->is_ptr()->add_offset(off);\n@@ -311,1 +311,1 @@\n-          return value_from_mem(comp, igvn, ac->in(TypeFunc::Memory), ctl, ft, ftype, adr_type->isa_oopptr(), alloc);\n+          return value_from_mem(ac->in(TypeFunc::Memory), ctl, ft, ftype, adr_type->isa_oopptr(), alloc);\n@@ -314,1 +314,1 @@\n-        Node* diff = igvn->transform(new SubINode(ac->in(ArrayCopyNode::SrcPos), ac->in(ArrayCopyNode::DestPos)));\n+        Node* diff = _igvn.transform(new SubINode(ac->in(ArrayCopyNode::SrcPos), ac->in(ArrayCopyNode::DestPos)));\n@@ -316,1 +316,1 @@\n-        diff = igvn->transform(new ConvI2LNode(diff));\n+        diff = _igvn.transform(new ConvI2LNode(diff));\n@@ -318,1 +318,1 @@\n-        diff = igvn->transform(new LShiftXNode(diff, igvn->intcon(shift)));\n+        diff = _igvn.transform(new LShiftXNode(diff, _igvn.intcon(shift)));\n@@ -320,1 +320,1 @@\n-        Node* off = igvn->transform(new AddXNode(igvn->MakeConX(offset), diff));\n+        Node* off = _igvn.transform(new AddXNode(_igvn.MakeConX(offset), diff));\n@@ -322,2 +322,2 @@\n-        adr = igvn->transform(new AddPNode(base, base, off));\n-        adr_type = igvn->type(base)->is_ptr()->add_offset(Type::OffsetBot);\n+        adr = _igvn.transform(new AddPNode(base, base, off));\n+        adr_type = _igvn.type(base)->is_ptr()->add_offset(Type::OffsetBot);\n@@ -330,1 +330,1 @@\n-      MergeMemNode* mergemen = igvn->transform(MergeMemNode::make(mem))->as_MergeMem();\n+      MergeMemNode* mergemen = _igvn.transform(MergeMemNode::make(mem))->as_MergeMem();\n@@ -332,1 +332,1 @@\n-      res = ArrayCopyNode::load(bs, igvn, ctl, mergemen, adr, adr_type, type, bt);\n+      res = ArrayCopyNode::load(bs, &_igvn, ctl, mergemen, adr, adr_type, type, bt);\n@@ -338,1 +338,1 @@\n-      res = igvn->transform(new EncodePNode(res, ftype));\n+      res = _igvn.transform(new EncodePNode(res, ftype));\n@@ -350,1 +350,1 @@\n-Node *PhaseMacroExpand::value_from_mem_phi(Compile* comp, PhaseIterGVN* igvn, Node *mem, BasicType ft, const Type *phi_type, const TypeOopPtr *adr_t, AllocateNode *alloc, Node_Stack *value_phis, int level) {\n+Node *PhaseMacroExpand::value_from_mem_phi(Node *mem, BasicType ft, const Type *phi_type, const TypeOopPtr *adr_t, AllocateNode *alloc, Node_Stack *value_phis, int level) {\n@@ -352,1 +352,1 @@\n-  int alias_idx = comp->get_alias_index(adr_t);\n+  int alias_idx = C->get_alias_index(adr_t);\n@@ -373,1 +373,1 @@\n-  Node *start_mem = comp->start()->proj_out_or_null(TypeFunc::Memory);\n+  Node *start_mem = C->start()->proj_out_or_null(TypeFunc::Memory);\n@@ -381,1 +381,1 @@\n-  igvn->register_new_node_with_optimizer(phi);\n+  transform_later(phi);\n@@ -389,1 +389,1 @@\n-      Node *val = scan_mem_chain(in, alias_idx, offset, start_mem, alloc, igvn);\n+      Node *val = scan_mem_chain(in, alias_idx, offset, start_mem, alloc, &_igvn);\n@@ -392,1 +392,1 @@\n-        values.at_put(j, igvn->zerocon(ft));\n+        values.at_put(j, _igvn.zerocon(ft));\n@@ -396,1 +396,1 @@\n-        val = val->as_Initialize()->find_captured_store(offset, type2aelembytes(ft), igvn);\n+        val = val->as_Initialize()->find_captured_store(offset, type2aelembytes(ft), &_igvn);\n@@ -408,1 +408,1 @@\n-          n = Compile::narrow_value(ft, n, phi_type, igvn, true);\n+          n = Compile::narrow_value(ft, n, phi_type, &_igvn, true);\n@@ -412,1 +412,1 @@\n-        values.at_put(j, igvn->zerocon(ft));\n+        values.at_put(j, _igvn.zerocon(ft));\n@@ -414,1 +414,1 @@\n-        val = value_from_mem_phi(comp, igvn, val, ft, phi_type, adr_t, alloc, value_phis, level-1);\n+        val = value_from_mem_phi(val, ft, phi_type, adr_t, alloc, value_phis, level-1);\n@@ -426,1 +426,1 @@\n-        Node* res = make_arraycopy_load(comp, igvn, val->as_ArrayCopy(), offset, val->in(0), val->in(TypeFunc::Memory), ft, phi_type, alloc);\n+        Node* res = make_arraycopy_load(val->as_ArrayCopy(), offset, val->in(0), val->in(TypeFunc::Memory), ft, phi_type, alloc);\n@@ -450,1 +450,1 @@\n-Node *PhaseMacroExpand::value_from_mem(Compile* comp, PhaseIterGVN* igvn, Node *sfpt_mem, Node *sfpt_ctl, BasicType ft, const Type *ftype, const TypeOopPtr *adr_t, AllocateNode *alloc) {\n+Node *PhaseMacroExpand::value_from_mem(Node *sfpt_mem, Node *sfpt_ctl, BasicType ft, const Type *ftype, const TypeOopPtr *adr_t, AllocateNode *alloc) {\n@@ -455,1 +455,1 @@\n-  int alias_idx = comp->get_alias_index(adr_t);\n+  int alias_idx = C->get_alias_index(adr_t);\n@@ -457,1 +457,1 @@\n-  Node *start_mem = comp->start()->proj_out_or_null(TypeFunc::Memory);\n+  Node *start_mem = C->start()->proj_out_or_null(TypeFunc::Memory);\n@@ -468,1 +468,1 @@\n-    mem = scan_mem_chain(mem, alias_idx, offset, start_mem, alloc, igvn);\n+    mem = scan_mem_chain(mem, alias_idx, offset, start_mem, alloc, &_igvn);\n@@ -472,1 +472,1 @@\n-      mem = mem->as_Initialize()->find_captured_store(offset, type2aelembytes(ft), igvn);\n+      mem = mem->as_Initialize()->find_captured_store(offset, type2aelembytes(ft), &_igvn);\n@@ -477,1 +477,1 @@\n-        assert(comp->get_alias_index(atype) == Compile::AliasIdxRaw, \"store is correct memory slice\");\n+        assert(C->get_alias_index(atype) == Compile::AliasIdxRaw, \"store is correct memory slice\");\n@@ -483,1 +483,1 @@\n-      assert(comp->get_alias_index(atype) == alias_idx &&\n+      assert(C->get_alias_index(atype) == alias_idx &&\n@@ -490,1 +490,1 @@\n-      Node *top = comp->top();\n+      Node *top = C->top();\n@@ -492,1 +492,1 @@\n-        Node *n = scan_mem_chain(mem->in(i), alias_idx, offset, start_mem, alloc, igvn);\n+        Node *n = scan_mem_chain(mem->in(i), alias_idx, offset, start_mem, alloc, &_igvn);\n@@ -517,1 +517,1 @@\n-      return igvn->zerocon(ft);\n+      return _igvn.zerocon(ft);\n@@ -526,1 +526,1 @@\n-      Node* phi = value_from_mem_phi(comp, igvn, mem, ft, ftype, adr_t, alloc, &value_phis, ValueSearchLimit);\n+      Node* phi = value_from_mem_phi(mem, ft, ftype, adr_t, alloc, &value_phis, ValueSearchLimit);\n@@ -533,1 +533,1 @@\n-          igvn->replace_node(n, comp->top());\n+          _igvn.replace_node(n, C->top());\n@@ -545,1 +545,1 @@\n-      return make_arraycopy_load(comp, igvn, mem->as_ArrayCopy(), offset, ctl, m, ft, ftype, alloc);\n+      return make_arraycopy_load(mem->as_ArrayCopy(), offset, ctl, m, ft, ftype, alloc);\n@@ -553,1 +553,1 @@\n-bool PhaseMacroExpand::can_eliminate_allocation(PhaseIterGVN* igvn, AllocateNode *alloc, GrowableArray <SafePointNode *>* safepoints, bool ignore_merges) {\n+bool PhaseMacroExpand::can_eliminate_allocation(PhaseIterGVN* igvn, AllocateNode *alloc, GrowableArray <SafePointNode *>* safepoints) {\n@@ -558,1 +558,2 @@\n-  bool  can_eliminate = true;\n+  bool can_eliminate = true;\n+  bool reduce_merge_precheck = (safepoints == nullptr);\n@@ -629,1 +630,1 @@\n-        } else if (safepoints != nullptr) {\n+        } else if (!reduce_merge_precheck) {\n@@ -632,1 +633,1 @@\n-      } else if (ignore_merges && (use->is_Phi() || use->is_EncodeP() || use->Opcode() == Op_MemBarRelease)) {\n+      } else if (reduce_merge_precheck && (use->is_Phi() || use->is_EncodeP() || use->Opcode() == Op_MemBarRelease)) {\n@@ -681,11 +682,1 @@\n-\/\/ Do scalar replacement.\n-bool PhaseMacroExpand::scalar_replacement(AllocateNode *alloc, GrowableArray <SafePointNode *>& safepoints) {\n-  GrowableArray <SafePointNode *> safepoints_done;\n-\n-  ciInstanceKlass* iklass = nullptr;\n-  int nfields = 0;\n-  int array_base = 0;\n-  int element_size = 0;\n-  BasicType basic_elem_type = T_ILLEGAL;\n-  const Type* field_type = nullptr;\n-\n+void PhaseMacroExpand::undo_previous_scalarizations(GrowableArray <SafePointNode *> safepoints_done, AllocateNode* alloc) {\n@@ -693,0 +684,1 @@\n+  int nfields = 0;\n@@ -694,0 +686,50 @@\n+\n+  if (res != nullptr) {\n+    const TypeOopPtr* res_type = _igvn.type(res)->isa_oopptr();\n+\n+    if (res_type->isa_instptr()) {\n+      \/\/ find the fields of the class which will be needed for safepoint debug information\n+      ciInstanceKlass* iklass = res_type->is_instptr()->instance_klass();\n+      nfields = iklass->nof_nonstatic_fields();\n+    } else {\n+      \/\/ find the array's elements which will be needed for safepoint debug information\n+      nfields = alloc->in(AllocateNode::ALength)->find_int_con(-1);\n+      assert(nfields >= 0, \"must be an array klass.\");\n+    }\n+  }\n+\n+  \/\/ rollback processed safepoints\n+  while (safepoints_done.length() > 0) {\n+    SafePointNode* sfpt_done = safepoints_done.pop();\n+    \/\/ remove any extra entries we added to the safepoint\n+    uint last = sfpt_done->req() - 1;\n+    for (int k = 0;  k < nfields; k++) {\n+      sfpt_done->del_req(last--);\n+    }\n+    JVMState *jvms = sfpt_done->jvms();\n+    jvms->set_endoff(sfpt_done->req());\n+    \/\/ Now make a pass over the debug information replacing any references\n+    \/\/ to SafePointScalarObjectNode with the allocated object.\n+    int start = jvms->debug_start();\n+    int end   = jvms->debug_end();\n+    for (int i = start; i < end; i++) {\n+      if (sfpt_done->in(i)->is_SafePointScalarObject()) {\n+        SafePointScalarObjectNode* scobj = sfpt_done->in(i)->as_SafePointScalarObject();\n+        if (scobj->first_index(jvms) == sfpt_done->req() &&\n+            scobj->n_fields() == (uint)nfields) {\n+          assert(scobj->alloc() == alloc, \"sanity\");\n+          sfpt_done->set_req(i, res);\n+        }\n+      }\n+    }\n+    _igvn._worklist.push(sfpt_done);\n+  }\n+}\n+\n+SafePointScalarObjectNode* PhaseMacroExpand::create_scalarized_object_description(AllocateNode *alloc, SafePointNode* sfpt) {\n+  \/\/ Fields of scalar objs are referenced only at the end\n+  \/\/ of regular debuginfo at the last (youngest) JVMS.\n+  \/\/ Record relative start index.\n+  ciInstanceKlass* iklass    = nullptr;\n+  BasicType basic_elem_type  = T_ILLEGAL;\n+  const Type* field_type     = nullptr;\n@@ -695,0 +737,9 @@\n+  int nfields                = 0;\n+  int array_base             = 0;\n+  int element_size           = 0;\n+  uint first_ind             = (sfpt->req() - sfpt->jvms()->scloff());\n+  Node* res                  = alloc->result_cast();\n+\n+  assert(res == nullptr || res->is_CheckCastPP(), \"unexpected AllocateNode result\");\n+  assert(sfpt->jvms() != nullptr, \"missed JVMS\");\n+\n@@ -697,1 +748,0 @@\n-  }\n@@ -699,1 +749,0 @@\n-  if (res != nullptr) {\n@@ -714,43 +763,25 @@\n-  \/\/\n-  \/\/ Process the safepoint uses\n-  \/\/\n-  while (safepoints.length() > 0) {\n-    SafePointNode* sfpt = safepoints.pop();\n-    Node* mem = sfpt->memory();\n-    Node* ctl = sfpt->control();\n-    assert(sfpt->jvms() != nullptr, \"missed JVMS\");\n-    \/\/ Fields of scalar objs are referenced only at the end\n-    \/\/ of regular debuginfo at the last (youngest) JVMS.\n-    \/\/ Record relative start index.\n-    uint first_ind = (sfpt->req() - sfpt->jvms()->scloff());\n-    SafePointScalarObjectNode* sobj = new SafePointScalarObjectNode(res_type, alloc, first_ind, nfields);\n-    sobj->init_req(0, C->root());\n-    transform_later(sobj);\n-\n-    \/\/ Scan object's fields adding an input to the safepoint for each field.\n-    for (int j = 0; j < nfields; j++) {\n-      intptr_t offset;\n-      ciField* field = nullptr;\n-      if (iklass != nullptr) {\n-        field = iklass->nonstatic_field_at(j);\n-        offset = field->offset();\n-        ciType* elem_type = field->type();\n-        basic_elem_type = field->layout_type();\n-\n-        \/\/ The next code is taken from Parse::do_get_xxx().\n-        if (is_reference_type(basic_elem_type)) {\n-          if (!elem_type->is_loaded()) {\n-            field_type = TypeInstPtr::BOTTOM;\n-          } else if (field != nullptr && field->is_static_constant()) {\n-            ciObject* con = field->constant_value().as_object();\n-            \/\/ Do not \"join\" in the previous type; it doesn't add value,\n-            \/\/ and may yield a vacuous result if the field is of interface type.\n-            field_type = TypeOopPtr::make_from_constant(con)->isa_oopptr();\n-            assert(field_type != nullptr, \"field singleton type must be consistent\");\n-          } else {\n-            field_type = TypeOopPtr::make_from_klass(elem_type->as_klass());\n-          }\n-          if (UseCompressedOops) {\n-            field_type = field_type->make_narrowoop();\n-            basic_elem_type = T_NARROWOOP;\n-          }\n+\n+  SafePointScalarObjectNode* sobj = new SafePointScalarObjectNode(res_type, alloc, first_ind, nfields);\n+  sobj->init_req(0, C->root());\n+  transform_later(sobj);\n+\n+  \/\/ Scan object's fields adding an input to the safepoint for each field.\n+  for (int j = 0; j < nfields; j++) {\n+    intptr_t offset;\n+    ciField* field = nullptr;\n+    if (iklass != nullptr) {\n+      field = iklass->nonstatic_field_at(j);\n+      offset = field->offset();\n+      ciType* elem_type = field->type();\n+      basic_elem_type = field->layout_type();\n+\n+      \/\/ The next code is taken from Parse::do_get_xxx().\n+      if (is_reference_type(basic_elem_type)) {\n+        if (!elem_type->is_loaded()) {\n+          field_type = TypeInstPtr::BOTTOM;\n+        } else if (field != nullptr && field->is_static_constant()) {\n+          ciObject* con = field->constant_value().as_object();\n+          \/\/ Do not \"join\" in the previous type; it doesn't add value,\n+          \/\/ and may yield a vacuous result if the field is of interface type.\n+          field_type = TypeOopPtr::make_from_constant(con)->isa_oopptr();\n+          assert(field_type != nullptr, \"field singleton type must be consistent\");\n@@ -758,1 +789,5 @@\n-          field_type = Type::get_const_basic_type(basic_elem_type);\n+          field_type = TypeOopPtr::make_from_klass(elem_type->as_klass());\n+        }\n+        if (UseCompressedOops) {\n+          field_type = field_type->make_narrowoop();\n+          basic_elem_type = T_NARROWOOP;\n@@ -761,1 +796,1 @@\n-        offset = array_base + j * (intptr_t)element_size;\n+        field_type = Type::get_const_basic_type(basic_elem_type);\n@@ -763,0 +798,3 @@\n+    } else {\n+      offset = array_base + j * (intptr_t)element_size;\n+    }\n@@ -764,1 +802,1 @@\n-      const TypeOopPtr *field_addr_type = res_type->add_offset(offset)->isa_oopptr();\n+    const TypeOopPtr *field_addr_type = res_type->add_offset(offset)->isa_oopptr();\n@@ -766,4 +804,10 @@\n-      Node *field_val = value_from_mem(C, &_igvn, mem, ctl, basic_elem_type, field_type, field_addr_type, alloc);\n-      if (field_val == nullptr) {\n-        \/\/ We weren't able to find a value for this field,\n-        \/\/ give up on eliminating this allocation.\n+    Node *field_val = value_from_mem(sfpt->memory(), sfpt->control(), basic_elem_type, field_type, field_addr_type, alloc);\n+\n+    \/\/ We weren't able to find a value for this field,\n+    \/\/ give up on eliminating this allocation.\n+    if (field_val == nullptr) {\n+      uint last = sfpt->req() - 1;\n+      for (int k = 0;  k < j; k++) {\n+        sfpt->del_req(last--);\n+      }\n+      _igvn._worklist.push(sfpt);\n@@ -771,32 +815,0 @@\n-        \/\/ Remove any extra entries we added to the safepoint.\n-        uint last = sfpt->req() - 1;\n-        for (int k = 0;  k < j; k++) {\n-          sfpt->del_req(last--);\n-        }\n-        _igvn._worklist.push(sfpt);\n-        \/\/ rollback processed safepoints\n-        while (safepoints_done.length() > 0) {\n-          SafePointNode* sfpt_done = safepoints_done.pop();\n-          \/\/ remove any extra entries we added to the safepoint\n-          last = sfpt_done->req() - 1;\n-          for (int k = 0;  k < nfields; k++) {\n-            sfpt_done->del_req(last--);\n-          }\n-          JVMState *jvms = sfpt_done->jvms();\n-          jvms->set_endoff(sfpt_done->req());\n-          \/\/ Now make a pass over the debug information replacing any references\n-          \/\/ to SafePointScalarObjectNode with the allocated object.\n-          int start = jvms->debug_start();\n-          int end   = jvms->debug_end();\n-          for (int i = start; i < end; i++) {\n-            if (sfpt_done->in(i)->is_SafePointScalarObject()) {\n-              SafePointScalarObjectNode* scobj = sfpt_done->in(i)->as_SafePointScalarObject();\n-              if (scobj->first_index(jvms) == sfpt_done->req() &&\n-                  scobj->n_fields() == (uint)nfields) {\n-                assert(scobj->alloc() == alloc, \"sanity\");\n-                sfpt_done->set_req(i, res);\n-              }\n-            }\n-          }\n-          _igvn._worklist.push(sfpt_done);\n-        }\n@@ -804,16 +816,8 @@\n-        if (PrintEliminateAllocations) {\n-          if (field != nullptr) {\n-            tty->print(\"=== At SafePoint node %d can't find value of Field: \",\n-                       sfpt->_idx);\n-            field->print();\n-            int field_idx = C->get_alias_index(field_addr_type);\n-            tty->print(\" (alias_idx=%d)\", field_idx);\n-          } else { \/\/ Array's element\n-            tty->print(\"=== At SafePoint node %d can't find value of array element [%d]\",\n-                       sfpt->_idx, j);\n-          }\n-          tty->print(\", which prevents elimination of: \");\n-          if (res == nullptr)\n-            alloc->dump();\n-          else\n-            res->dump();\n+      if (PrintEliminateAllocations) {\n+        if (field != nullptr) {\n+          tty->print(\"=== At SafePoint node %d can't find value of field: \", sfpt->_idx);\n+          field->print();\n+          int field_idx = C->get_alias_index(field_addr_type);\n+          tty->print(\" (alias_idx=%d)\", field_idx);\n+        } else { \/\/ Array's element\n+          tty->print(\"=== At SafePoint node %d can't find value of array element [%d]\", sfpt->_idx, j);\n@@ -821,2 +825,5 @@\n-#endif\n-        return false;\n+        tty->print(\", which prevents elimination of: \");\n+        if (res == nullptr)\n+          alloc->dump();\n+        else\n+          res->dump();\n@@ -824,8 +831,12 @@\n-      if (UseCompressedOops && field_type->isa_narrowoop()) {\n-        \/\/ Enable \"DecodeN(EncodeP(Allocate)) --> Allocate\" transformation\n-        \/\/ to be able scalar replace the allocation.\n-        if (field_val->is_EncodeP()) {\n-          field_val = field_val->in(1);\n-        } else {\n-          field_val = transform_later(new DecodeNNode(field_val, field_val->get_ptr_type()));\n-        }\n+#endif\n+\n+      return nullptr;\n+    }\n+\n+    if (UseCompressedOops && field_type->isa_narrowoop()) {\n+      \/\/ Enable \"DecodeN(EncodeP(Allocate)) --> Allocate\" transformation\n+      \/\/ to be able scalar replace the allocation.\n+      if (field_val->is_EncodeP()) {\n+        field_val = field_val->in(1);\n+      } else {\n+        field_val = transform_later(new DecodeNNode(field_val, field_val->get_ptr_type()));\n@@ -833,1 +844,0 @@\n-      sfpt->add_req(field_val);\n@@ -835,0 +845,22 @@\n+    sfpt->add_req(field_val);\n+  }\n+\n+  return sobj;\n+}\n+\n+\/\/ Do scalar replacement.\n+bool PhaseMacroExpand::scalar_replacement(AllocateNode *alloc, GrowableArray <SafePointNode *>& safepoints) {\n+  GrowableArray <SafePointNode *> safepoints_done;\n+  Node* res = alloc->result_cast();\n+  assert(res == nullptr || res->is_CheckCastPP(), \"unexpected AllocateNode result\");\n+\n+  \/\/ Process the safepoint uses\n+  while (safepoints.length() > 0) {\n+    SafePointNode* sfpt = safepoints.pop();\n+    SafePointScalarObjectNode* sobj = create_scalarized_object_description(alloc, sfpt);\n+\n+    if (sobj == nullptr) {\n+      undo_previous_scalarizations(safepoints_done, alloc);\n+      return false;\n+    }\n+\n@@ -837,0 +869,1 @@\n+\n@@ -843,1 +876,3 @@\n-    safepoints_done.append_if_missing(sfpt); \/\/ keep it for rollback\n+\n+    \/\/ keep it for rollback\n+    safepoints_done.append_if_missing(sfpt);\n@@ -845,0 +880,1 @@\n+\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":207,"deletions":171,"binary":false,"changes":378,"status":"modified"},{"patch":"@@ -100,1 +100,2 @@\n-  bool scalar_replacement(AllocateNode *alloc, GrowableArray <SafePointNode *>& safepoints_done);\n+  void undo_previous_scalarizations(GrowableArray <SafePointNode *> safepoints_done, AllocateNode* alloc);\n+  bool scalar_replacement(AllocateNode *alloc, GrowableArray <SafePointNode *>& safepoints);\n@@ -196,1 +197,1 @@\n-  static Node* make_arraycopy_load(Compile* comp, PhaseIterGVN* igvn, ArrayCopyNode* ac, intptr_t offset, Node* ctl, Node* mem, BasicType ft, const Type *ftype, AllocateNode *alloc);\n+  Node* make_arraycopy_load(ArrayCopyNode* ac, intptr_t offset, Node* ctl, Node* mem, BasicType ft, const Type *ftype, AllocateNode *alloc);\n@@ -205,3 +206,4 @@\n-  static bool can_eliminate_allocation(PhaseIterGVN *igvn, AllocateNode *alloc, GrowableArray <SafePointNode *> *safepoints, bool ignore_merges = false);\n-  static Node *value_from_mem(Compile *comp, PhaseIterGVN *igvn, Node *mem, Node *ctl, BasicType ft, const Type *ftype, const TypeOopPtr *adr_t, AllocateNode *alloc);\n-  static Node *value_from_mem_phi(Compile *comp, PhaseIterGVN *igvn, Node *mem, BasicType ft, const Type *ftype, const TypeOopPtr *adr_t, AllocateNode *alloc, Node_Stack *value_phis, int level);\n+  SafePointScalarObjectNode* create_scalarized_object_description(AllocateNode *alloc, SafePointNode* sfpt);\n+  static bool can_eliminate_allocation(PhaseIterGVN *igvn, AllocateNode *alloc, GrowableArray <SafePointNode *> *safepoints);\n+  Node *value_from_mem(Node *mem, Node *ctl, BasicType ft, const Type *ftype, const TypeOopPtr *adr_t, AllocateNode *alloc);\n+  Node *value_from_mem_phi(Node *mem, BasicType ft, const Type *ftype, const TypeOopPtr *adr_t, AllocateNode *alloc, Node_Stack *value_phis, int level);\n","filename":"src\/hotspot\/share\/opto\/macro.hpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"}]}