{"files":[{"patch":"@@ -198,7 +198,1 @@\n-  st->print(\"%s: ID=%d, is_root=%d, N.Fields=%d\",\n-            is_auto_box() ? \"box_obj\" : \"obj\", _id,\n-            _is_root, _field_values.length());\n-  st->print_cr(\", klass: %s \", java_lang_Class::as_Klass(_klass->as_ConstantOopReadValue()->value()())->external_name());\n-  st->print(\"Fields: \");\n-  print_fields_on(st);\n-  st->cr();\n+  st->print(\"%s[%d]\", is_auto_box() ? \"box_obj\" : is_object_merge() ? \"merge_obj\" : \"obj\", _id);\n@@ -209,6 +203,28 @@\n-  if (_field_values.length() > 0) {\n-    _field_values.at(0)->print_on(st);\n-  }\n-  for (int i = 1; i < _field_values.length(); i++) {\n-    st->print(\", \");\n-    _field_values.at(i)->print_on(st);\n+  if (is_object_merge()) {\n+    ObjectMergeValue* omv = (ObjectMergeValue*)this;\n+    st->print(\"selector=\\\"\");\n+    omv->selector()->print_on(st);\n+    st->print(\"\\\"\");\n+    ScopeValue* merge_pointer = omv->merge_pointer();\n+    if (!(merge_pointer->is_object() && merge_pointer->as_ObjectValue()->value()() == nullptr) &&\n+        !(merge_pointer->is_constant_oop() && merge_pointer->as_ConstantOopReadValue()->value()() == nullptr)) {\n+      st->print(\", merge_pointer=\\\"\");\n+      merge_pointer->print_on(st);\n+      st->print(\"\\\"\");\n+    }\n+    GrowableArray<ScopeValue*>* possible_objects = omv->possible_objects();\n+    st->print(\", candidate_objs=[%d\", possible_objects->at(0)->as_ObjectValue()->id());\n+    int ncandidates = possible_objects->length();\n+    for (int i = 1; i < ncandidates; i++) {\n+      st->print(\", %d\", possible_objects->at(i)->as_ObjectValue()->id());\n+    }\n+    st->print(\"]\");\n+  } else {\n+    st->print(\"\\n        Fields: \");\n+    if (_field_values.length() > 0) {\n+      _field_values.at(0)->print_on(st);\n+    }\n+    for (int i = 1; i < _field_values.length(); i++) {\n+      st->print(\", \");\n+      _field_values.at(i)->print_on(st);\n+    }\n@@ -248,14 +264,1 @@\n-\n-    \/\/ Set it to true so that the object will get rematerialized\n-    if (!_selected->is_root()) {\n-      _selected->set_root(true);\n-\n-      \/\/ We can't assume that 'select(...)' will be called before we check if\n-      \/\/ the candidate needs to be rematerialized or not. Therefore, we need to\n-      \/\/ return the candidate, now set to 'not only merge candidate', and try to\n-      \/\/ rematerialize it.\n-      return _selected;\n-    } else {\n-      \/\/ Since the object was not only a candidate it will already be rematerialized on its own.\n-      return nullptr;\n-    }\n+    return _selected;\n@@ -295,22 +298,0 @@\n-void ObjectMergeValue::print_on(outputStream* st) const {\n-  st->print(\"merge: ID=%d\", _id);\n-}\n-\n-void ObjectMergeValue::print_detailed(outputStream* st) const {\n-  st->print(\"merge: ID=%d\", _id);\n-#ifndef PRODUCT\n-  st->print(\", selector=\\\"\");\n-    _selector->print_on(st);\n-    st->print(\"\\\"\");\n-  st->print(\", merge_pointer=\\\"\");\n-    _merge_pointer->print_on(st);\n-    st->print(\"\\\"\");\n-#endif\n-  st->print(\", candidate objs=[%d\", _possible_objects.at(0)->as_ObjectValue()->id());\n-  int ncandidates = _possible_objects.length();\n-  for (int i = 1; i < ncandidates; i++) {\n-    st->print(\", %d\", _possible_objects.at(i)->as_ObjectValue()->id());\n-  }\n-  st->print(\"]\");\n-}\n-\n","filename":"src\/hotspot\/share\/code\/debugInfo.cpp","additions":30,"deletions":49,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -241,4 +241,0 @@\n-\n-  \/\/ Printing\n-  void print_on(outputStream* st) const ;\n-  void print_detailed(outputStream* st) const;\n","filename":"src\/hotspot\/share\/code\/debugInfo.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -271,9 +271,6 @@\n-      ScopeValue* sv = (ScopeValue*) _objects->at(i);\n-      st->print(\"    - %d: \", i);\n-      if (sv->is_object_merge()) {\n-        sv->as_ObjectMergeValue()->print_detailed(st);\n-        st->cr();\n-      } else if (sv->is_object()) {\n-        sv->as_ObjectValue()->print_on(st);\n-      } else {\n-        st->print_cr(\"Unknown Object Type in Object Pool\");\n+      ObjectValue* sv = (ObjectValue*) _objects->at(i);\n+      st->print(\"    - %d: %c \", i, sv->is_root() ? 'R' : ' ');\n+      sv->print_on(st);\n+      st->print(\", \");\n+      if (!sv->is_object_merge()) {\n+        st->print(\"%s\", java_lang_Class::as_Klass(sv->klass()->as_ConstantOopReadValue()->value()())->external_name());\n@@ -281,0 +278,2 @@\n+      sv->print_fields_on(st);\n+      st->cr();\n","filename":"src\/hotspot\/share\/code\/scopeDesc.cpp","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2332,1 +2332,1 @@\n-      NOT_PRODUCT(ConnectionGraph::verify_ram_nodes(this, root());)\n+      ConnectionGraph::verify_ram_nodes(this, root());\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -959,0 +959,12 @@\n+\/\/ Determine if there is a monitor that has 'ov' as its owner.\n+bool PhaseOutput::contains_as_owner(GrowableArray<MonitorValue*> *monarray, ObjectValue *ov) const {\n+  for (int k = 0; k < monarray->length(); k++) {\n+    MonitorValue* mv = monarray->at(k);\n+    if (mv->owner() == ov) {\n+      return true;\n+    }\n+  }\n+\n+  return false;\n+}\n+\n@@ -1098,12 +1110,1 @@\n-          bool is_root = locarray->contains(ov) || exparray->contains(ov);\n-\n-          if (!is_root) {\n-            for (int k = 0; k < monarray->length(); k++) {\n-              MonitorValue* mv = monarray->at(k);\n-              if (mv->owner() == ov) {\n-                is_root = true;\n-                break;\n-              }\n-            }\n-          }\n-\n+          bool is_root = locarray->contains(ov) || exparray->contains(ov) || contains_as_owner(monarray, ov);\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":13,"deletions":12,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -213,0 +213,1 @@\n+  bool contains_as_owner(GrowableArray<MonitorValue*> *monarray, ObjectValue *ov) const;\n","filename":"src\/hotspot\/share\/opto\/output.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}