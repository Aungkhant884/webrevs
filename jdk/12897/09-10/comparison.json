{"files":[{"patch":"@@ -198,1 +198,1 @@\n-  st->print(\"%s: ID=%d, is_merge_candidate=%d, skip_field_assignment=%d, N.Fields=%d\",\n+  st->print(\"%s: ID=%d, only_merge_candidate=%d, skip_field_assignment=%d, N.Fields=%d\",\n@@ -253,2 +253,0 @@\n-\n-    return _selected;\n@@ -259,13 +257,2 @@\n-    \/\/ Exchange the id of the selected object and the merge object.\n-    \/\/ I.e., the candidate essentially becomes the real deal.\n-    int tmp = _selected->id();\n-    _selected->set_id(id());\n-    _id = tmp;\n-\n-    \/\/ Candidate is not candidate anymore, it's the real object\n-    _selected->set_merge_candidate(false);\n-\n-    \/\/ Returns null and that should indicate to the caller that\n-    \/\/ one of the candidate objects, inside this merge, became\n-    \/\/ a real object.\n-    return nullptr;\n+    \/\/ Candidate is not candidate anymore.\n+    _selected->set_only_merge_candidate(false);\n@@ -273,0 +260,2 @@\n+\n+  return _selected;\n@@ -283,1 +272,0 @@\n-    obj->set_merge_candidate(true);\n","filename":"src\/hotspot\/share\/code\/debugInfo.cpp","additions":5,"deletions":17,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -178,1 +178,1 @@\n-  void                        set_merge_candidate(bool cnd)       { _only_merge_candidate = cnd; }\n+  void                        set_only_merge_candidate(bool cnd)  { _only_merge_candidate = cnd; }\n@@ -242,1 +242,1 @@\n-  AutoBoxObjectValue(int id, ScopeValue* klass, bool only_merge_candidate = false) : ObjectValue(id, klass, only_merge_candidate), _cached(false) { }\n+  AutoBoxObjectValue(int id, ScopeValue* klass) : ObjectValue(id, klass), _cached(false) { }\n","filename":"src\/hotspot\/share\/code\/debugInfo.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1520,1 +1520,4 @@\n-  st->print(\" # fields@[%d..%d], \", first_index(), first_index() + n_fields() - 1);\n+  st->print(\" # fields@[%d..%d], only_candidate=%d\",\n+            first_index(),\n+            first_index() + n_fields() - 1,\n+            _only_merge_candidate);\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -406,1 +406,1 @@\n-      reduce_this_phi(n->as_Phi());\n+      reduce_phi(n->as_Phi());\n@@ -440,1 +440,1 @@\n-bool ConnectionGraph::can_reduce_this_phi_check_inputs(PhiNode* ophi) const {\n+bool ConnectionGraph::can_reduce_phi_check_inputs(PhiNode* ophi) const {\n@@ -472,1 +472,1 @@\n-bool ConnectionGraph::can_reduce_this_phi_check_users(PhiNode* ophi) const {\n+bool ConnectionGraph::can_reduce_phi_check_users(PhiNode* ophi) const {\n@@ -501,1 +501,1 @@\n-\/\/ 'can_reduce_this_phi_inputs' and 'can_reduce_this_phi_users' for more\n+\/\/ 'can_reduce_phi_inputs' and 'can_reduce_phi_users' for more\n@@ -503,1 +503,1 @@\n-bool ConnectionGraph::can_reduce_this_phi(PhiNode* ophi) const {\n+bool ConnectionGraph::can_reduce_phi(PhiNode* ophi) const {\n@@ -518,1 +518,1 @@\n-  if (!can_reduce_this_phi_check_inputs(ophi) || !can_reduce_this_phi_check_users(ophi)) {\n+  if (!can_reduce_phi_check_inputs(ophi) || !can_reduce_phi_check_users(ophi)) {\n@@ -526,1 +526,1 @@\n-void ConnectionGraph::reduce_this_phi_on_field_access(PhiNode* ophi, GrowableArray<Node *>  &alloc_worklist) {\n+void ConnectionGraph::reduce_phi_on_field_access(PhiNode* ophi, GrowableArray<Node *>  &alloc_worklist) {\n@@ -608,1 +608,1 @@\n-void ConnectionGraph::reduce_this_phi_on_safepoints(PhiNode* ophi, Unique_Node_List* safepoints) {\n+void ConnectionGraph::reduce_phi_on_safepoints(PhiNode* ophi, Unique_Node_List* safepoints) {\n@@ -719,1 +719,1 @@\n-void ConnectionGraph::reduce_this_phi(PhiNode* ophi) {\n+void ConnectionGraph::reduce_phi(PhiNode* ophi) {\n@@ -737,1 +737,1 @@\n-    reduce_this_phi_on_safepoints(ophi, &safepoints);\n+    reduce_phi_on_safepoints(ophi, &safepoints);\n@@ -2210,1 +2210,1 @@\n-  \/\/ A Phi 'x' is a _candidate_ to be reducible if 'can_reduce_this_phi(x)'\n+  \/\/ A Phi 'x' is a _candidate_ to be reducible if 'can_reduce_phi(x)'\n@@ -2266,1 +2266,1 @@\n-        if (ReduceAllocationMerges && use_n->is_Phi() && can_reduce_this_phi(use_n->as_Phi())) {\n+        if (ReduceAllocationMerges && use_n->is_Phi() && can_reduce_phi(use_n->as_Phi())) {\n@@ -3743,1 +3743,1 @@\n-        reduce_this_phi_on_field_access(n->as_Phi(), alloc_worklist);\n+        reduce_phi_on_field_access(n->as_Phi(), alloc_worklist);\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -593,3 +593,3 @@\n-  bool can_reduce_this_phi(PhiNode* ophi) const;\n-  bool can_reduce_this_phi_check_users(PhiNode* ophi) const;\n-  bool can_reduce_this_phi_check_inputs(PhiNode* ophi) const;\n+  bool can_reduce_phi(PhiNode* ophi) const;\n+  bool can_reduce_phi_check_users(PhiNode* ophi) const;\n+  bool can_reduce_phi_check_inputs(PhiNode* ophi) const;\n@@ -597,3 +597,3 @@\n-  void reduce_this_phi_on_field_access(PhiNode* ophi, GrowableArray<Node *>  &alloc_worklist);\n-  void reduce_this_phi_on_safepoints(PhiNode* ophi, Unique_Node_List* safepoints);\n-  void reduce_this_phi(PhiNode* ophi);\n+  void reduce_phi_on_field_access(PhiNode* ophi, GrowableArray<Node *>  &alloc_worklist);\n+  void reduce_phi_on_safepoints(PhiNode* ophi, Unique_Node_List* safepoints);\n+  void reduce_phi(PhiNode* ophi);\n","filename":"src\/hotspot\/share\/opto\/escape.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -772,1 +772,1 @@\n-    ObjectMergeValue* sv = (ObjectMergeValue*) sv_for_node_id(objs, smerge->_idx);\n+    ObjectMergeValue* mv = (ObjectMergeValue*) sv_for_node_id(objs, smerge->_idx);\n@@ -774,1 +774,1 @@\n-    if (sv == NULL) {\n+    if (mv == NULL) {\n@@ -785,2 +785,2 @@\n-      sv = new ObjectMergeValue(smerge->_idx, deps.at(0), deps.at(1));\n-      set_sv_for_object_node(objs, sv);\n+      mv = new ObjectMergeValue(smerge->_idx, deps.at(0), deps.at(1));\n+      set_sv_for_object_node(objs, mv);\n@@ -790,1 +790,1 @@\n-        (void)FillLocArray(sv->possible_objects()->length(), sfpt, obj_node, sv->possible_objects(), objs);\n+        (void)FillLocArray(mv->possible_objects()->length(), sfpt, obj_node, mv->possible_objects(), objs);\n@@ -793,1 +793,1 @@\n-    array->append(sv);\n+    array->append(mv);\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -309,1 +309,1 @@\n-      k = (sv != nullptr && sv->klass() != nullptr) ? java_lang_Class::as_Klass(sv->klass()->as_ConstantOopReadValue()->value()()) : nullptr;\n+      k = (sv->klass() != nullptr) ? java_lang_Class::as_Klass(sv->klass()->as_ConstantOopReadValue()->value()()) : nullptr;\n@@ -1239,9 +1239,6 @@\n-      \/\/ If this is true it means that a candidate object became a\n-      \/\/ real object and we are going to reach that object in a later\n-      \/\/ iteration of the outer loop.\n-      if (sv == nullptr) {\n-        continue;\n-      }\n-\n-      \/\/ Will be true whenever the object was a NSR input of an allocation merge\n-      if (sv->skip_rematerialization()) {\n+      \/\/ 'skip_rematerialization' will be true whenever the object was a NSR\n+      \/\/ input of an allocation merge.\n+      \/\/ 'value' will be not null if the object selected in the merge was a\n+      \/\/ 'not_only_candidate' and it was visited by this loop before the current\n+      \/\/ iteration.\n+      if (sv->skip_rematerialization() || sv->value().not_null()) {\n@@ -1253,2 +1250,5 @@\n-      \/\/ This object is only a candidate inside an ObjectMergeValue\n-      if (sv->is_only_merge_candidate()) {\n+      \/\/ We skip allocation if the object is only a candidate inside an\n+      \/\/ ObjectMergeValue or if it already has an allocation. The object may\n+      \/\/ already be allocated if it was the result of a 'select' on an\n+      \/\/ ObjectMergeValue.\n+      if (sv->is_only_merge_candidate() || sv->value().not_null()) {\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -819,0 +819,7 @@\n+        \/\/ The 'getStackAccessControlContext' call inside 'isPrivileged'\n+        \/\/ requires that no Local was scalar replaced. However, in some\n+        \/\/ situations, after inlining, 'result' (or part of a possibly\n+        \/\/ allocation merge Phi leading to it) might become NonEscaping and get\n+        \/\/ scalar replaced. The call below enforces 'result' to always escape.\n+        ensureMaterializedForStackWalk(result);\n+\n","filename":"src\/java.base\/share\/classes\/java\/security\/AccessController.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"}]}