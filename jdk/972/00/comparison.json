{"files":[{"patch":"@@ -589,1 +589,1 @@\n-                    JPECoffRelocObject pecoffobj = new JPECoffRelocObject(this, outputFileName);\n+                    JPECoffRelocObject pecoffobj = JPECoffRelocObject.newInstance(this, outputFileName);\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc.binformat\/src\/jdk\/tools\/jaotc\/binformat\/BinaryContainer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+\n+package jdk.tools.jaotc.binformat.pecoff;\n+\n+import jdk.tools.jaotc.binformat.BinaryContainer;\n+import jdk.tools.jaotc.binformat.Relocation;\n+import jdk.tools.jaotc.binformat.Relocation.RelocType;\n+import jdk.tools.jaotc.binformat.Symbol;\n+import jdk.tools.jaotc.binformat.pecoff.PECoff.IMAGE_FILE_HEADER;\n+import jdk.tools.jaotc.binformat.pecoff.PECoff.IMAGE_RELOCATION;\n+\n+public class AArch64JPECoffRelocObject extends JPECoffRelocObject {\n+\n+    AArch64JPECoffRelocObject(BinaryContainer binContainer, String outputFileName) {\n+        super (binContainer, outputFileName);\n+    }\n+\n+    @Override\n+    protected void createRelocation(Symbol symbol, Relocation reloc, PECoffRelocTable pecoffRelocTable) {\n+        RelocType relocType = reloc.getType();\n+\n+        PECoffSymbol sym = (PECoffSymbol) symbol.getNativeSymbol();\n+        int symno = sym.getIndex();\n+        int sectindex = reloc.getSection().getSectionId();\n+        int offset = reloc.getOffset();\n+\n+        switch (relocType) {\n+            case STUB_CALL_DIRECT:\n+            case JAVA_CALL_DIRECT: {\n+                break;\n+            }\n+            case EXTERNAL_PLT_TO_GOT:\n+                offset -= 16;\n+                pecoffRelocTable.createRelocationEntry(sectindex, offset, symno, IMAGE_RELOCATION.IMAGE_REL_ARM64_PAGEBASE_REL21);\n+                pecoffRelocTable.createRelocationEntry(sectindex, offset + 4, symno, IMAGE_RELOCATION.IMAGE_REL_ARM64_PAGEOFFSET_12A);\n+                return;\n+\n+            case FOREIGN_CALL_INDIRECT_GOT: {\n+                break;\n+            }\n+            case METASPACE_GOT_REFERENCE: {\n+                offset -= 4;\n+\n+                pecoffRelocTable.createRelocationEntry(sectindex, offset, symno, IMAGE_RELOCATION.IMAGE_REL_ARM64_PAGEBASE_REL21);\n+                pecoffRelocTable.createRelocationEntry(sectindex, offset + 4, symno, IMAGE_RELOCATION.IMAGE_REL_ARM64_PAGEOFFSET_12A);\n+                return;\n+            }\n+            \/\/ break;\n+            case JAVA_CALL_INDIRECT: {\n+                offset -= 4;\n+                break;\n+            }\n+            case EXTERNAL_GOT_TO_PLT: {\n+                \/\/ this is load time relocations\n+                break;\n+            }\n+            default:\n+                throw new InternalError(\"Unhandled relocation type: \" + relocType);\n+        }\n+        int pecoffRelocType = getPECoffRelocationType(relocType);\n+        pecoffRelocTable.createRelocationEntry(sectindex, offset, symno, pecoffRelocType);\n+    }\n+\n+    \/\/ Return IMAGE_RELOCATION Type based on relocType\n+    private static int getPECoffRelocationType(RelocType relocType) {\n+        int pecoffRelocType = 0; \/\/ R_<ARCH>_NONE if #define'd to 0 for all values of ARCH\n+        switch (PECoffTargetInfo.getPECoffArch()) {\n+            case IMAGE_FILE_HEADER.IMAGE_FILE_MACHINE_ARM64:\n+                if (relocType == RelocType.JAVA_CALL_DIRECT) {\n+                    pecoffRelocType = IMAGE_RELOCATION.IMAGE_REL_ARM64_BRANCH26;\n+                } else if (relocType == RelocType.FOREIGN_CALL_INDIRECT_GOT) {\n+                    pecoffRelocType = IMAGE_RELOCATION.IMAGE_REL_ARM64_BRANCH26;\n+                } else if (relocType == RelocType.STUB_CALL_DIRECT) {\n+                    pecoffRelocType = IMAGE_RELOCATION.IMAGE_REL_ARM64_BRANCH26;\n+                } else if (relocType == RelocType.JAVA_CALL_INDIRECT) {\n+                    pecoffRelocType = IMAGE_RELOCATION.IMAGE_REL_ARM64_BRANCH26;\n+                } else if (relocType == RelocType.METASPACE_GOT_REFERENCE || relocType == RelocType.EXTERNAL_PLT_TO_GOT) {\n+                    assert false : \"Should have been handled already\";\n+                    \/\/ pecoffRelocType = IMAGE_RELOCATION.IMAGE_REL_ARM64_ABSOLUTE;\n+                } else if (relocType == RelocType.EXTERNAL_GOT_TO_PLT) {\n+                    pecoffRelocType = IMAGE_RELOCATION.IMAGE_REL_ARM64_ADDR64;\n+                } else {\n+                    assert false : \"Unhandled relocation type: \" + relocType;\n+                }\n+                break;\n+            default:\n+                System.out.println(\"Relocation Type mapping: Unhandled architecture\");\n+        }\n+        return pecoffRelocType;\n+    }\n+}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc.binformat\/src\/jdk\/tools\/jaotc\/binformat\/pecoff\/AArch64JPECoffRelocObject.java","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"},{"patch":"@@ -0,0 +1,113 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+\n+package jdk.tools.jaotc.binformat.pecoff;\n+\n+import jdk.tools.jaotc.binformat.BinaryContainer;\n+import jdk.tools.jaotc.binformat.Relocation;\n+import jdk.tools.jaotc.binformat.Relocation.RelocType;\n+import jdk.tools.jaotc.binformat.Symbol;\n+import jdk.tools.jaotc.binformat.pecoff.PECoff.IMAGE_FILE_HEADER;\n+import jdk.tools.jaotc.binformat.pecoff.PECoff.IMAGE_RELOCATION;\n+\n+public class AMD64JPECoffRelocObject extends JPECoffRelocObject {\n+\n+    AMD64JPECoffRelocObject(BinaryContainer binContainer, String outputFileName) {\n+        super (binContainer, outputFileName);\n+    }\n+\n+    @Override\n+    protected void createRelocation(Symbol symbol, Relocation reloc, PECoffRelocTable pecoffRelocTable) {\n+        RelocType relocType = reloc.getType();\n+\n+        int pecoffRelocType = getPECoffRelocationType(relocType);\n+        PECoffSymbol sym = (PECoffSymbol) symbol.getNativeSymbol();\n+        int symno = sym.getIndex();\n+        int sectindex = reloc.getSection().getSectionId();\n+        int offset = reloc.getOffset();\n+        int addend = 0;\n+\n+        switch (relocType) {\n+            case JAVA_CALL_DIRECT:\n+            case STUB_CALL_DIRECT:\n+            case FOREIGN_CALL_INDIRECT_GOT: {\n+                \/\/ Create relocation entry\n+                addend = -4; \/\/ Size in bytes of the patch location\n+                \/\/ Relocation should be applied at the location after call operand\n+                offset = offset + reloc.getSize() + addend;\n+                break;\n+            }\n+            case JAVA_CALL_INDIRECT: {\n+                \/\/ Do nothing.\n+                return;\n+            }\n+            case METASPACE_GOT_REFERENCE:\n+            case EXTERNAL_PLT_TO_GOT: {\n+                addend = -4; \/\/ Size of 32-bit address of the GOT\n+                \/*\n+                 * Relocation should be applied before the test instruction to the move instruction.\n+                 * reloc.getOffset() points to the test instruction after the instruction that loads\n+                 * the address of polling page. So set the offset appropriately.\n+                 *\/\n+                offset = offset + addend;\n+                break;\n+            }\n+            case EXTERNAL_GOT_TO_PLT: {\n+                \/\/ this is load time relocations\n+                break;\n+            }\n+            default:\n+                throw new InternalError(\"Unhandled relocation type: \" + relocType);\n+        }\n+        pecoffRelocTable.createRelocationEntry(sectindex, offset, symno, pecoffRelocType);\n+    }\n+\n+    \/\/ Return IMAGE_RELOCATION Type based on relocType\n+    private static int getPECoffRelocationType(RelocType relocType) {\n+        int pecoffRelocType = 0; \/\/ R_<ARCH>_NONE if #define'd to 0 for all values of ARCH\n+        switch (PECoffTargetInfo.getPECoffArch()) {\n+            case IMAGE_FILE_HEADER.IMAGE_FILE_MACHINE_AMD64:\n+                if (relocType == RelocType.JAVA_CALL_DIRECT ||\n+                                relocType == RelocType.FOREIGN_CALL_INDIRECT_GOT) {\n+                    pecoffRelocType = IMAGE_RELOCATION.IMAGE_REL_AMD64_REL32;\n+                } else if (relocType == RelocType.STUB_CALL_DIRECT) {\n+                    pecoffRelocType = IMAGE_RELOCATION.IMAGE_REL_AMD64_REL32;\n+                } else if (relocType == RelocType.JAVA_CALL_INDIRECT) {\n+                    pecoffRelocType = IMAGE_RELOCATION.IMAGE_REL_AMD64_ABSOLUTE;\n+                } else if (relocType == RelocType.METASPACE_GOT_REFERENCE ||\n+                                relocType == RelocType.EXTERNAL_PLT_TO_GOT) {\n+                    pecoffRelocType = IMAGE_RELOCATION.IMAGE_REL_AMD64_REL32;\n+                } else if (relocType == RelocType.EXTERNAL_GOT_TO_PLT) {\n+                    pecoffRelocType = IMAGE_RELOCATION.IMAGE_REL_AMD64_ADDR64;\n+                } else {\n+                    assert false : \"Unhandled relocation type: \" + relocType;\n+                }\n+                break;\n+            default:\n+                System.out.println(\"Relocation Type mapping: Unhandled architecture\");\n+        }\n+        return pecoffRelocType;\n+    }\n+}\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc.binformat\/src\/jdk\/tools\/jaotc\/binformat\/pecoff\/AMD64JPECoffRelocObject.java","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"},{"patch":"@@ -48,1 +48,1 @@\n-public class JPECoffRelocObject {\n+public abstract class JPECoffRelocObject {\n@@ -62,0 +62,10 @@\n+    public static JPECoffRelocObject newInstance(BinaryContainer binContainer, String outputFileName) {\n+        String archStr = System.getProperty(\"os.arch\").toLowerCase();\n+        if (archStr.equals(\"amd64\") || archStr.equals(\"x86_64\")) {\n+            return new AMD64JPECoffRelocObject(binContainer, outputFileName);\n+        } else if (archStr.equals(\"aarch64\")) {\n+            return new AArch64JPECoffRelocObject(binContainer, outputFileName);\n+        }\n+        throw new InternalError(\"Unsupported platform: \" + archStr);\n+    }\n+\n@@ -294,71 +304,1 @@\n-    private static void createRelocation(Symbol symbol, Relocation reloc, PECoffRelocTable pecoffRelocTable) {\n-        RelocType relocType = reloc.getType();\n-\n-        int pecoffRelocType = getPECoffRelocationType(relocType);\n-        PECoffSymbol sym = (PECoffSymbol) symbol.getNativeSymbol();\n-        int symno = sym.getIndex();\n-        int sectindex = reloc.getSection().getSectionId();\n-        int offset = reloc.getOffset();\n-        int addend = 0;\n-\n-        switch (relocType) {\n-            case JAVA_CALL_DIRECT:\n-            case STUB_CALL_DIRECT:\n-            case FOREIGN_CALL_INDIRECT_GOT: {\n-                \/\/ Create relocation entry\n-                addend = -4; \/\/ Size in bytes of the patch location\n-                \/\/ Relocation should be applied at the location after call operand\n-                offset = offset + reloc.getSize() + addend;\n-                break;\n-            }\n-            case JAVA_CALL_INDIRECT: {\n-                \/\/ Do nothing.\n-                return;\n-            }\n-            case METASPACE_GOT_REFERENCE:\n-            case EXTERNAL_PLT_TO_GOT: {\n-                addend = -4; \/\/ Size of 32-bit address of the GOT\n-                \/*\n-                 * Relocation should be applied before the test instruction to the move instruction.\n-                 * reloc.getOffset() points to the test instruction after the instruction that loads\n-                 * the address of polling page. So set the offset appropriately.\n-                 *\/\n-                offset = offset + addend;\n-                break;\n-            }\n-            case EXTERNAL_GOT_TO_PLT: {\n-                \/\/ this is load time relocations\n-                break;\n-            }\n-            default:\n-                throw new InternalError(\"Unhandled relocation type: \" + relocType);\n-        }\n-        pecoffRelocTable.createRelocationEntry(sectindex, offset, symno, pecoffRelocType);\n-    }\n-\n-    \/\/ Return IMAGE_RELOCATION Type based on relocType\n-    private static int getPECoffRelocationType(RelocType relocType) {\n-        int pecoffRelocType = 0; \/\/ R_<ARCH>_NONE if #define'd to 0 for all values of ARCH\n-        switch (PECoffTargetInfo.getPECoffArch()) {\n-            case IMAGE_FILE_HEADER.IMAGE_FILE_MACHINE_AMD64:\n-                if (relocType == RelocType.JAVA_CALL_DIRECT ||\n-                                relocType == RelocType.FOREIGN_CALL_INDIRECT_GOT) {\n-                    pecoffRelocType = IMAGE_RELOCATION.IMAGE_REL_AMD64_REL32;\n-                } else if (relocType == RelocType.STUB_CALL_DIRECT) {\n-                    pecoffRelocType = IMAGE_RELOCATION.IMAGE_REL_AMD64_REL32;\n-                } else if (relocType == RelocType.JAVA_CALL_INDIRECT) {\n-                    pecoffRelocType = IMAGE_RELOCATION.IMAGE_REL_AMD64_ABSOLUTE;\n-                } else if (relocType == RelocType.METASPACE_GOT_REFERENCE ||\n-                                relocType == RelocType.EXTERNAL_PLT_TO_GOT) {\n-                    pecoffRelocType = IMAGE_RELOCATION.IMAGE_REL_AMD64_REL32;\n-                } else if (relocType == RelocType.EXTERNAL_GOT_TO_PLT) {\n-                    pecoffRelocType = IMAGE_RELOCATION.IMAGE_REL_AMD64_ADDR64;\n-                } else {\n-                    assert false : \"Unhandled relocation type: \" + relocType;\n-                }\n-                break;\n-            default:\n-                System.out.println(\"Relocation Type mapping: Unhandled architecture\");\n-        }\n-        return pecoffRelocType;\n-    }\n+    abstract void createRelocation(Symbol symbol, Relocation reloc, PECoffRelocTable pecoffRelocTable);\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc.binformat\/src\/jdk\/tools\/jaotc\/binformat\/pecoff\/JPECoffRelocObject.java","additions":12,"deletions":72,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * Support for the creation of Coff files. Current support is limited to 64 bit x86_64.\n+ * Support for the creation of Coff files. Current support is limited to 64 bit x86_64 and ARM64.\n@@ -67,0 +67,1 @@\n+        static final char IMAGE_FILE_MACHINE_ARM64   = 0xaa64;\n@@ -205,0 +206,6 @@\n+        static final int IMAGE_REL_ARM64_ABSOLUTE       = 0x0;\n+        static final int IMAGE_REL_ARM64_BRANCH26       = 0x3;\n+        static final int IMAGE_REL_ARM64_PAGEBASE_REL21 = 0x4;\n+        static final int IMAGE_REL_ARM64_REL21          = 0x5;\n+        static final int IMAGE_REL_ARM64_PAGEOFFSET_12A = 0x6;\n+        static final int IMAGE_REL_ARM64_ADDR64         = 0xe;\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc.binformat\/src\/jdk\/tools\/jaotc\/binformat\/pecoff\/PECoff.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-        header.putChar(IMAGE_FILE_HEADER.Machine.off, IMAGE_FILE_HEADER.IMAGE_FILE_MACHINE_AMD64);\n+        header.putChar(IMAGE_FILE_HEADER.Machine.off, PECoffTargetInfo.getPECoffArch());\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc.binformat\/src\/jdk\/tools\/jaotc\/binformat\/pecoff\/PECoffHeader.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,0 +55,2 @@\n+        } else if (archStr.equals(\"aarch64\")) {\n+            arch = IMAGE_FILE_HEADER.IMAGE_FILE_MACHINE_ARM64;\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc.binformat\/src\/jdk\/tools\/jaotc\/binformat\/pecoff\/PECoffTargetInfo.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -199,0 +199,2 @@\n+        String archStr = System.getProperty(\"os.arch\").toLowerCase();\n+\n@@ -209,0 +211,1 @@\n+        String vcarch = archStr.equals(\"aarch64\") ? \"arm64\" : \"x86.x64\";\n@@ -210,1 +213,1 @@\n-                        \"Microsoft.VisualStudio.Component.VC.Tools.x86.x64\", \"-property\", \"installationPath\", \"-latest\");\n+                        \"Microsoft.VisualStudio.Component.VC.Tools.\" + vcarch, \"-property\", \"installationPath\", \"-latest\");\n@@ -230,1 +233,8 @@\n-        Path linkPath = Paths.get(installationPath, \"VC\\\\Tools\\\\MSVC\", vcToolsVersion, \"bin\\\\Hostx64\\\\x64\\\\link.exe\");\n+\n+        Path linkPath = null;\n+        if (archStr.equals(\"aarch64\")) {\n+            \/* run binaries via xtajit *\/\n+            linkPath = Paths.get(installationPath, \"VC\\\\Tools\\\\MSVC\", vcToolsVersion, \"bin\\\\Hostx86\\\\arm64\\\\link.exe\");\n+        } else {\n+            linkPath = Paths.get(installationPath, \"VC\\\\Tools\\\\MSVC\", vcToolsVersion, \"bin\\\\Hostx64\\\\x64\\\\link.exe\");\n+        }\n@@ -242,1 +252,3 @@\n-        VS2012(\"VS110COMNTOOLS\", \"C:\\\\Program Files (x86)\\\\Microsoft Visual Studio 11.0\\\\VC\\\\bin\\\\amd64\\\\link.exe\");\n+        VS2012(\"VS110COMNTOOLS\", \"C:\\\\Program Files (x86)\\\\Microsoft Visual Studio 11.0\\\\VC\\\\bin\\\\amd64\\\\link.exe\"),\n+        \/* TODO: hack when `ProgramFiles(x86)` is not exported properly *\/\n+        VS2017(\"ASDF\", \"C:\\\\Program Files (x86)\\\\Microsoft Visual Studio\\\\2019\\\\Community\\\\VC\\\\Tools\\\\MSVC\\\\14.27.29110\\\\bin\\\\Hostx86\\\\arm64\\\\link.exe\");\n","filename":"src\/jdk.aot\/share\/classes\/jdk.tools.jaotc\/src\/jdk\/tools\/jaotc\/Linker.java","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -119,1 +119,1 @@\n-        masm.bl(before);\n+        masm.bl(0);\n","filename":"src\/jdk.internal.vm.compiler\/share\/classes\/org.graalvm.compiler.hotspot.aarch64\/src\/org\/graalvm\/compiler\/hotspot\/aarch64\/AArch64HotSpotConstantRetrievalOp.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}