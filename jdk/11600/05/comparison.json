{"files":[{"patch":"@@ -31,1 +31,2 @@\n-import static sun.nio.fs.BsdNativeDispatcher.setattrlist;\n+import static sun.nio.fs.BsdNativeDispatcher.*;\n+import static sun.nio.fs.UnixNativeDispatcher.lutimes;\n@@ -52,10 +53,6 @@\n-        int commonattr = 0;\n-        long modValue = 0L;\n-        if (lastModifiedTime != null) {\n-            modValue = lastModifiedTime.to(TimeUnit.NANOSECONDS);\n-            commonattr |= UnixConstants.ATTR_CMN_MODTIME;\n-        }\n-        long accValue = 0L;\n-        if (lastAccessTime != null) {\n-            accValue = lastAccessTime.to(TimeUnit.NANOSECONDS);\n-            commonattr |= UnixConstants.ATTR_CMN_ACCTIME;\n+        boolean useLutimes = false;\n+        try {\n+            useLutimes = !followLinks &&\n+                UnixFileAttributes.get(path, false).isSymbolicLink();\n+        } catch (UnixException x) {\n+            x.rethrowAsIOException(path);\n@@ -63,4 +60,8 @@\n-        long createValue = 0L;\n-        if (createTime != null) {\n-            createValue = createTime.to(TimeUnit.NANOSECONDS);\n-            commonattr |= UnixConstants.ATTR_CMN_CRTIME;\n+\n+        int fd = -1;\n+        if (!useLutimes) {\n+            try {\n+                fd = path.openForAttributeAccess(followLinks);\n+            } catch (UnixException x) {\n+                x.rethrowAsIOException(path);\n+            }\n@@ -70,4 +71,70 @@\n-            setattrlist(path, commonattr, modValue, accValue, createValue,\n-                        followLinks ?  0 : UnixConstants.FSOPT_NOFOLLOW);\n-        } catch (UnixException x) {\n-            x.rethrowAsIOException(path);\n+            \/\/ not all volumes support setattrlist(2), so set the last\n+            \/\/ modified and last access times using futimens(2)\n+            if (lastModifiedTime != null || lastAccessTime != null) {\n+                \/\/ if not changing both attributes then need existing attributes\n+                if (lastModifiedTime == null || lastAccessTime == null) {\n+                    try {\n+                        UnixFileAttributes attrs = UnixFileAttributes.get(fd);\n+                        if (lastModifiedTime == null)\n+                            lastModifiedTime = attrs.lastModifiedTime();\n+                        if (lastAccessTime == null)\n+                            lastAccessTime = attrs.lastAccessTime();\n+                    } catch (UnixException x) {\n+                        x.rethrowAsIOException(path);\n+                    }\n+                }\n+\n+                \/\/ update times\n+                TimeUnit timeUnit = useLutimes ?\n+                    TimeUnit.MICROSECONDS : TimeUnit.NANOSECONDS;\n+                long modValue = lastModifiedTime.to(timeUnit);\n+                long accessValue= lastAccessTime.to(timeUnit);\n+\n+                boolean retry = false;\n+                try {\n+                    if (useLutimes)\n+                        lutimes(path, accessValue, modValue);\n+                    else\n+                        futimens(fd, accessValue, modValue);\n+                } catch (UnixException x) {\n+                    \/\/ if futimens fails with EINVAL and one\/both of the times is\n+                    \/\/ negative then we adjust the value to the epoch and retry.\n+                    if (x.errno() == UnixConstants.EINVAL &&\n+                        (modValue < 0L || accessValue < 0L)) {\n+                        retry = true;\n+                    } else {\n+                        x.rethrowAsIOException(path);\n+                    }\n+                }\n+                if (retry) {\n+                    if (modValue < 0L) modValue = 0L;\n+                    if (accessValue < 0L) accessValue= 0L;\n+                    try {\n+                        if (useLutimes)\n+                            lutimes(path, accessValue, modValue);\n+                        else\n+                            futimens(fd, accessValue, modValue);\n+                    } catch (UnixException x) {\n+                        x.rethrowAsIOException(path);\n+                    }\n+                }\n+            }\n+\n+            \/\/ set the creation time using setattrlist\n+            if (createTime != null) {\n+                long createValue = createTime.to(TimeUnit.NANOSECONDS);\n+                int commonattr = UnixConstants.ATTR_CMN_CRTIME;\n+                try {\n+                    if (useLutimes)\n+                        setattrlist(path, commonattr, 0L, 0L, createValue,\n+                            followLinks ?  0 : UnixConstants.FSOPT_NOFOLLOW);\n+                    else\n+                        fsetattrlist(fd, commonattr, 0L, 0L, createValue,\n+                            followLinks ?  0 : UnixConstants.FSOPT_NOFOLLOW);\n+                } catch (UnixException x) {\n+                    x.rethrowAsIOException(path);\n+                }\n+            }\n+        } finally {\n+            if (!useLutimes)\n+                close(fd, e -> null);\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/fs\/BsdFileAttributeViews.java","additions":86,"deletions":19,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -107,0 +107,21 @@\n+    \/**\n+     * fsetattrlist(int fd, struct attrlist* attrList, void* attrBuf,\n+     *              size_t attrBufSize, unsigned long options)\n+     *\/\n+    static void fsetattrlist(int fd, int commonattr, long modTime,\n+                             long accTime, long createTime, long options)\n+        throws UnixException\n+    {\n+        long comp = Blocker.begin();\n+        try {\n+            fsetattrlist0(fd, commonattr, modTime, accTime,\n+                          createTime, options);\n+        } finally {\n+            Blocker.end(comp);\n+        }\n+    }\n+    private static native void fsetattrlist0(int fd, int commonattr,\n+                                             long modTime, long accTime,\n+                                             long createTime, long options)\n+        throws UnixException;\n+\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/fs\/BsdNativeDispatcher.java","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+#include <unistd.h>\n@@ -246,4 +247,2 @@\n-JNIEXPORT void JNICALL\n-Java_sun_nio_fs_BsdNativeDispatcher_setattrlist0(JNIEnv* env, jclass this,\n-    jlong pathAddress, int commonattr, jlong modTime, jlong accTime,\n-    jlong createTime, jlong options)\n+size_t initattrlist(jint commonattr, jlong modTime, jlong accTime,\n+    jlong createTime, const int attrsize, char* buf, struct attrlist *attrList)\n@@ -251,5 +250,0 @@\n-    const char* path = (const char*)jlong_to_ptr(pathAddress);\n-    \/\/ attributes must align on 4-byte boundaries per the getattrlist(2) spec\n-    const int attrsize = ((sizeof(struct timespec) + 3)\/4)*4;\n-    char buf[3*attrsize];\n-\n@@ -257,0 +251,1 @@\n+\n@@ -277,0 +272,35 @@\n+    memset(attrList, 0, sizeof(struct attrlist));\n+    attrList->bitmapcount = ATTR_BIT_MAP_COUNT;\n+    attrList->commonattr = commonattr;\n+\n+    return count*attrsize;\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_sun_nio_fs_BsdNativeDispatcher_setattrlist0(JNIEnv* env, jclass this,\n+    jlong pathAddress, int commonattr, jlong modTime, jlong accTime,\n+    jlong createTime, jlong options)\n+{\n+    const char* path = (const char*)jlong_to_ptr(pathAddress);\n+    \/\/ attributes must align on 4-byte boundaries per the getattrlist(2) spec\n+    const int attrsize = ((sizeof(struct timespec) + 3)\/4)*4;\n+    char buf[3*attrsize];\n+\n+    struct attrlist attrList;\n+    size_t attrBufSize = initattrlist(commonattr, modTime, accTime, createTime,\n+                                      attrsize, buf, &attrList);\n+\n+    if (setattrlist(path, &attrList, (void*)buf, attrBufSize, options) != 0) {\n+        throwUnixException(env, errno);\n+    }\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_sun_nio_fs_BsdNativeDispatcher_fsetattrlist0(JNIEnv* env, jclass this,\n+    jint fd, int commonattr, jlong modTime, jlong accTime,\n+    jlong createTime, jlong options)\n+{\n+    \/\/ attributes must align on 4-byte boundaries per the getattrlist(2) spec\n+    const int attrsize = ((sizeof(struct timespec) + 3)\/4)*4;\n+    char buf[3*attrsize];\n+\n@@ -278,3 +308,2 @@\n-    memset(&attrList, 0, sizeof(struct attrlist));\n-    attrList.bitmapcount = ATTR_BIT_MAP_COUNT;\n-    attrList.commonattr = commonattr;\n+    size_t attrBufSize = initattrlist(commonattr, modTime, accTime, createTime,\n+                                      attrsize, buf, &attrList);\n@@ -282,1 +311,1 @@\n-    if (setattrlist(path, &attrList, (void*)buf, count*attrsize, options) != 0) {\n+    if (fsetattrlist(fd, &attrList, (void*)buf, attrBufSize, options) != 0) {\n","filename":"src\/java.base\/macosx\/native\/libnio\/fs\/BsdNativeDispatcher.c","additions":42,"deletions":13,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -137,1 +137,1 @@\n-     * Converting from finer to coarser granularities result in precision loss.\n+     * Converting from finer to coarser granularities results in precision loss.\n","filename":"src\/java.base\/share\/classes\/java\/nio\/file\/attribute\/BasicFileAttributeView.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -156,1 +156,1 @@\n-    \/\/ flags used with setattrlist\n+    \/\/ flags used with fsetattrlist\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixConstants.java.template","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}