{"files":[{"patch":"@@ -139,2 +139,0 @@\n-    \/\/ The first 8 double-words are never passed on stack.\n-    n_regs_not_on_stack_c = 8,\n","filename":"src\/hotspot\/cpu\/ppc\/assembler_ppc.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -784,11 +784,2 @@\n-  \/\/ `Stk' counts stack slots. Due to alignment, 32 bit values occupy\n-  \/\/ 2 such slots, like 64 bit values do.\n-  const int inc_stk_for_intfloat   = 2; \/\/ 2 slots for ints and floats\n-  const int inc_stk_for_longdouble = 2; \/\/ 2 slots for longs and doubles\n-\n-  int i;\n-  VMReg reg;\n-  \/\/ Leave room for C-compatible ABI_REG_ARGS.\n-  int stk = (frame::native_abi_reg_args_size - frame::jit_out_preserve_size) \/ VMRegImpl::stack_slot_size;\n-  int arg = 0;\n-  int freg = 0;\n+  const int additional_frame_header_slots = ((frame::native_abi_minframe_size - frame::jit_out_preserve_size)\n+                                            \/ VMRegImpl::stack_slot_size);\n@@ -796,4 +787,1 @@\n-  \/\/ Avoid passing C arguments in the wrong stack slots.\n-#if defined(ABI_ELFv2)\n-  assert((SharedRuntime::out_preserve_stack_slots() + stk) * VMRegImpl::stack_slot_size == 96,\n-         \"passing C arguments in wrong stack slots\");\n+#ifdef VM_LITTLE_ENDIAN\n@@ -803,2 +791,0 @@\n-  assert((SharedRuntime::out_preserve_stack_slots() + stk) * VMRegImpl::stack_slot_size == 112,\n-         \"passing C arguments in wrong stack slots\");\n@@ -809,0 +795,6 @@\n+\n+  VMReg reg;\n+  int arg = 0;\n+  int freg = 0;\n+  bool stack_used = false;\n+\n@@ -810,1 +802,2 @@\n-    switch(sig_bt[i]) {\n+    \/\/ Each argument corresponds to a slot in the Parameter Save Area (if not omitted)\n+    int stk = (arg * 2) + additional_frame_header_slots;\n@@ -812,0 +805,1 @@\n+    switch(sig_bt[i]) {\n@@ -833,1 +827,1 @@\n-        stk += inc_stk_for_longdouble;\n+        stack_used = true;\n@@ -849,4 +843,0 @@\n-        if (arg >= Argument::n_regs_not_on_stack_c) {\n-          \/\/ Reserve additional spill slot on stack (Parameter Save Area).\n-          stk += inc_stk_for_intfloat;\n-        }\n@@ -856,1 +846,1 @@\n-        stk += inc_stk_for_intfloat;\n+        stack_used = true;\n@@ -866,4 +856,0 @@\n-        if (arg >= Argument::n_regs_not_on_stack_c) {\n-          \/\/ Reserve additional spill slot on stack (Parameter Save Area).\n-          stk += inc_stk_for_longdouble;\n-        }\n@@ -873,1 +859,1 @@\n-        stk += inc_stk_for_longdouble;\n+        stack_used = true;\n@@ -890,0 +876,1 @@\n+  assert(additional_frame_header_slots == 0, \"ABIv2 shouldn't use extra slots\");\n@@ -892,2 +879,1 @@\n-  STATIC_ASSERT((int)frame::native_abi_minframe_size == (int)frame::jit_out_preserve_size); \/\/ no correction needed\n-  return ((arg > Argument::n_regs_not_on_stack_c) ? arg : 0) * 2;\n+  return stack_used ? (arg * 2) : 0;\n@@ -896,3 +882,2 @@\n-  \/\/ We have to add extra slots because ABIv1 uses a larger header. See initial \"stk\" computation above.\n-  return (MAX2(arg, (int)Argument::n_regs_not_on_stack_c) * 2) +\n-         ((frame::native_abi_minframe_size - frame::jit_out_preserve_size) \/ VMRegImpl::stack_slot_size);\n+  \/\/ We have to add extra slots because ABIv1 uses a larger header.\n+  return MAX2(arg, 8) * 2 + additional_frame_header_slots;\n","filename":"src\/hotspot\/cpu\/ppc\/sharedRuntime_ppc.cpp","additions":19,"deletions":34,"binary":false,"changes":53,"status":"modified"}]}