{"files":[{"patch":"@@ -1859,2 +1859,0 @@\n-  \/\/ Copy attributes from scratch_cp to merge_cp\n-  merge_cp->copy_fields(scratch_cp());\n@@ -1867,0 +1865,3 @@\n+    \/\/ Copy attributes from scratch_cp to merge_cp\n+    merge_cp->copy_fields(scratch_cp());\n+\n@@ -1920,0 +1921,3 @@\n+    \/\/ Copy attributes from scratch_cp to merge_cp (should be done after rewrite_cp_refs())\n+    merge_cp->copy_fields(scratch_cp());\n+\n@@ -3495,4 +3499,3 @@\n-\/\/ Change the constant pool associated with klass scratch_class to\n-\/\/ scratch_cp. If shrink is true, then scratch_cp_length elements\n-\/\/ are copied from scratch_cp to a smaller constant pool and the\n-\/\/ smaller constant pool is associated with scratch_class.\n+\/\/ Change the constant pool associated with klass scratch_class to scratch_cp.\n+\/\/ scratch_cp_length elements are copied from scratch_cp to a smaller constant pool\n+\/\/ and the smaller constant pool is associated with scratch_class.\n@@ -4360,4 +4363,0 @@\n-  \/\/ Copy the \"source file name\" attribute from new class version\n-  the_class->set_source_file_name_index(\n-    scratch_class->source_file_name_index());\n-\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -0,0 +1,233 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8282241\n+ * @summary Verifies class retransformation correctly updates generic_signature and source_file_name attributes\n+ *\n+ * @library \/test\/lib\n+ * @run compile -g RetransformGenericSignatureTest.java\n+ * @run shell MakeJAR.sh retransformAgent\n+ *\n+ * @run main\/othervm -javaagent:retransformAgent.jar --add-opens=java.base\/java.lang=ALL-UNNAMED RetransformGenericSignatureTest\n+ *\/\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.lang.instrument.ClassFileTransformer;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.Type;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.security.ProtectionDomain;\n+import java.util.List;\n+\n+import jdk.test.lib.JDKToolLauncher;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.util.ClassTransformer;\n+\n+\n+class GenericSignatureTester {\n+    public GenericSignatureTarget<List<String>> method1() {\n+        return null;\n+    }\n+}\n+\n+\/\/ See ClassTransformer.transform(int) comment for @1 tag explanations.\n+\/\/ @1 uncomment class GenericSignatureTarget<T> {\n+class GenericSignatureTarget<T extends List<?>>  { \/\/ @1 commentout\n+    public GenericSignatureTarget<T> method1(GenericSignatureTarget<?> a) {\n+        \/\/ the following line changes CP and this causes mapping during CP merge\n+        \/\/ @1 uncomment System.out.println(a);\n+        return null;\n+    }\n+\n+    public static void throwException() {\n+        throw new RuntimeException();\n+    }\n+}\n+\n+public class RetransformGenericSignatureTest extends ATransformerManagementTestCase {\n+\n+    public RetransformGenericSignatureTest() {\n+        super(\"RetransformGenericSignatureTest\");\n+    }\n+\n+    public static void main (String[] args) throws Throwable {\n+        ATestCaseScaffold test = new RetransformGenericSignatureTest();\n+        test.runTest();\n+    }\n+\n+    private final Transformer transformer = new Transformer();\n+    private final static String sourceFileName = \"RetransformGenericSignatureTest.java\";\n+    private final static String sourceFileNameNew = \"RetransformGenericSignatureTestNew.java\";\n+    \/\/ expected signature of GenericSignatureTester.method1 return type\n+    private final static String expectedRetType = \"GenericSignatureTarget<java.util.List<java.lang.String>>\";\n+    \/\/ expected generic signature of the original GenericSignatureTarget\n+    private final static String expectedSigOld = \"<T::Ljava\/util\/List<*>;>Ljava\/lang\/Object;\";\n+    \/\/ expected generic signature of the retransformed GenericSignatureTarget\n+    private final static String expectedSigNew = \"<T:Ljava\/lang\/Object;>Ljava\/lang\/Object;\";\n+\n+    private void log(Object o) {\n+        System.out.println(o);\n+    }\n+\n+    private String getTargetGenSig() throws Throwable {\n+        MethodHandles.Lookup lookup = MethodHandles.lookup();\n+        MethodHandles.Lookup classLookup = MethodHandles.privateLookupIn(Class.class, lookup);\n+        MethodHandle getGenericSignature0 = classLookup.findVirtual(\n+                Class.class, \"getGenericSignature0\", MethodType.methodType(String.class));\n+        Object genericSignature = getGenericSignature0.invoke(GenericSignatureTarget.class);\n+        return String.valueOf(genericSignature);\n+    }\n+\n+    private String getTesterRetType() throws Throwable {\n+        Type type = GenericSignatureTester.class.getDeclaredMethod(\"method1\").getGenericReturnType();\n+        return String.valueOf(type);\n+    }\n+\n+    private String getTargetSourceFilename() {\n+        try {\n+            GenericSignatureTarget.throwException();\n+        } catch (RuntimeException ex) {\n+            return ex.getStackTrace()[0].getFileName();\n+        }\n+        return \"Cannot get source file name\";\n+    }\n+\n+    \/\/ Retransforms the class using provided class bytes;\n+    \/\/ Returns class bytes passed to the transformer.\n+    private byte[] retransform(Class cls, byte[] classBytes) throws Throwable {\n+        transformer.targetClassName = cls.getName();\n+        transformer.seenClassBytes = null;\n+        transformer.newClassBytes = classBytes;\n+        fInst.retransformClasses(cls);\n+        assertTrue(transformer.targetClassName + \" was not seen by transform()\",\n+                transformer.seenClassBytes != null);\n+        return transformer.seenClassBytes;\n+    }\n+\n+    \/\/ Prints dissassembled class bytes.\n+    private void printDisassembled(String description, Class cls, byte[] bytes) throws Exception {\n+        log(description + \" -------------------\");\n+\n+        File f = new File(cls.getSimpleName()+\".class\");\n+        try (FileOutputStream fos = new FileOutputStream(f)) {\n+            fos.write(bytes);\n+        }\n+        JDKToolLauncher javap = JDKToolLauncher.create(\"javap\")\n+                .addToolArg(\"-verbose\")\n+                .addToolArg(\"-p\")       \/\/ Shows all classes and members.\n+                \/\/.addToolArg(\"-c\")       \/\/ Prints out disassembled code\n+                .addToolArg(\"-s\")       \/\/ Prints internal type signatures.\n+                .addToolArg(f.toString());\n+        ProcessBuilder pb = new ProcessBuilder(javap.getCommand());\n+        OutputAnalyzer out = ProcessTools.executeProcess(pb);\n+        out.shouldHaveExitValue(0);\n+        try {\n+            Files.delete(f.toPath());\n+        } catch (Exception ex) {\n+            \/\/ ignore\n+        }\n+        out.asLines().forEach(s -> log(s));\n+        log(\"==========================================\");\n+        Files.deleteIfExists(f.toPath());\n+    }\n+\n+    private void retransformTargetClass() throws Throwable {\n+        Class targetClass = GenericSignatureTarget.class;\n+        log(\"Retransforming \" + targetClass.getName() + \" class\");\n+        String origSource = Files.readString(Paths.get(System.getProperty(\"test.src\")).resolve(sourceFileName));\n+        \/\/ replace main class name to avoid compilation errors\n+        String newSource = origSource.replaceAll(\n+                \"RetransformGenericSignatureTest\", \"RetransformGenericSignatureTestNew\");\n+\n+        String transformedClassFile = ClassTransformer.fromString(newSource)\n+                .setFileName(sourceFileNameNew)\n+                .transform(1, targetClass.getName(), \"-g\");\n+        byte[] classBytes = Files.readAllBytes(Paths.get(transformedClassFile));\n+        byte[] oldClassBytes = retransform(targetClass, classBytes);\n+\n+        printDisassembled(\"Old \" + targetClass.getName(), targetClass, oldClassBytes);\n+        printDisassembled(\"New \" + targetClass.getName(), targetClass, classBytes);\n+    }\n+\n+    protected final void doRunTest() throws Throwable {\n+        beVerbose();\n+\n+        String oldSig = getTargetGenSig();\n+        log(\"old target class sig: \\\"\" + oldSig + \"\\\"\");\n+\n+        addTransformerToManager(fInst, transformer, true);\n+\n+        retransformTargetClass();\n+\n+        String newSig = getTargetGenSig();\n+        log(\"new target class sig: \\\"\" + newSig + \"\\\"\");\n+\n+        String newRetType = getTesterRetType();\n+        log(\"new tester ret type: \\\"\" + newRetType + \"\\\"\");\n+\n+        String newSrcFileName = getTargetSourceFilename();\n+        log(\"new source file name: \\\"\" + newSrcFileName + \"\\\"\");\n+\n+        assertEquals(\"wrong old generic signature\", expectedSigOld, oldSig);\n+        assertEquals(\"wrong new generic signature\", expectedSigNew, newSig);\n+        assertEquals(\"wrong ret type\", expectedRetType, newRetType);\n+        assertEquals(\"wrong new source file name\", sourceFileNameNew, newSrcFileName);\n+    }\n+\n+    public class Transformer implements ClassFileTransformer {\n+        public Transformer() {\n+        }\n+\n+        public String toString() {\n+            return Transformer.this.getClass().getName();\n+        }\n+\n+        String targetClassName;\n+        byte[] seenClassBytes;\n+        byte[] newClassBytes;\n+\n+        public byte[] transform(ClassLoader loader, String className,\n+            Class<?> classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) {\n+\n+            if (className.equals(targetClassName)) {\n+                log(this + \".transform() sees '\" + className\n+                        + \"' of \" + classfileBuffer.length + \" bytes.\");\n+                seenClassBytes = classfileBuffer;\n+                if (newClassBytes != null) {\n+                    log(this + \".transform() sets new classbytes for '\" + className\n+                            + \"' of \" + newClassBytes.length + \" bytes.\");\n+                }\n+                return newClassBytes;\n+            }\n+\n+            return null;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/instrument\/RetransformGenericSignatureTest.java","additions":233,"deletions":0,"binary":false,"changes":233,"status":"added"}]}