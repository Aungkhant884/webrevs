{"files":[{"patch":"@@ -0,0 +1,196 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8282241\n+ * @summary Verifies class redefinition correctly updates generic_signature and source_file_name attributes\n+ * @requires vm.jvmti\n+ * @modules java.base\/jdk.internal.org.objectweb.asm\n+ *          java.instrument\n+ * @library \/test\/lib\n+ * @run compile -g RedefineGenericSignatureTest.java\n+ * @run main RedefineClassHelper\n+ * @run main\/othervm -javaagent:redefineagent.jar --add-opens=java.base\/java.lang=ALL-UNNAMED RedefineGenericSignatureTest\n+ *\/\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.Type;\n+import java.nio.file.Files;\n+import java.util.List;\n+\n+import jdk.internal.org.objectweb.asm.ClassReader;\n+import jdk.internal.org.objectweb.asm.ClassVisitor;\n+import jdk.internal.org.objectweb.asm.ClassWriter;\n+import jdk.internal.org.objectweb.asm.Opcodes;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.JDKToolLauncher;\n+import jdk.test.lib.compiler.InMemoryJavaCompiler;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+class GenericSignatureTester {\n+    public GenericSignatureTarget<List<String>> method1() {\n+        return null;\n+    }\n+}\n+\n+class GenericSignatureTarget<T extends List<?>>  {\n+    public GenericSignatureTarget<T> foo() { return null; }\n+    public static void throwException() { throw new RuntimeException(); }\n+}\n+\n+public class RedefineGenericSignatureTest {\n+    private static final String newTargetClassSource =\n+            \"class GenericSignatureTarget<T> {\\n\" +\n+            \"    public GenericSignatureTarget<T> foo() { return null; }\\n\" +\n+            \"    public static void throwException() { throw new RuntimeException(); }\\n\" +\n+            \"}\\n\";\n+\n+    public static void main (String[] args) throws Throwable {\n+        RedefineGenericSignatureTest test = new RedefineGenericSignatureTest();\n+        test.runTest();\n+    }\n+\n+    private final static String sourceFileName = \"RedefineGenericSignatureTest.java\";\n+    private final static String sourceFileNameNew = \"RedefineGenericSignatureTestNew.java\";\n+    \/\/ expected signature of GenericSignatureTester.method1 return type\n+    private final static String expectedRetType = \"GenericSignatureTarget<java.util.List<java.lang.String>>\";\n+    \/\/ expected generic signature of the original GenericSignatureTarget\n+    private final static String expectedSigOld = \"<T::Ljava\/util\/List<*>;>Ljava\/lang\/Object;\";\n+    \/\/ expected generic signature of the redefined GenericSignatureTarget\n+    private final static String expectedSigNew = \"<T:Ljava\/lang\/Object;>Ljava\/lang\/Object;\";\n+\n+    private static void log(Object o) {\n+        System.out.println(o);\n+    }\n+\n+    private String getTargetGenSig() throws Throwable {\n+        MethodHandles.Lookup lookup = MethodHandles.lookup();\n+        MethodHandles.Lookup classLookup = MethodHandles.privateLookupIn(Class.class, lookup);\n+        MethodHandle getGenericSignature0 = classLookup.findVirtual(\n+                Class.class, \"getGenericSignature0\", MethodType.methodType(String.class));\n+        Object genericSignature = getGenericSignature0.invoke(GenericSignatureTarget.class);\n+        return String.valueOf(genericSignature);\n+    }\n+\n+    private String getTesterRetType() throws Throwable {\n+        Type type = GenericSignatureTester.class.getDeclaredMethod(\"method1\").getGenericReturnType();\n+        return String.valueOf(type);\n+    }\n+\n+    private String getTargetSourceFilename() {\n+        try {\n+            GenericSignatureTarget.throwException();\n+        } catch (RuntimeException ex) {\n+            return ex.getStackTrace()[0].getFileName();\n+        }\n+        return \"Cannot get source file name\";\n+    }\n+\n+    \/\/ Prints dissassembled class bytes.\n+    private void printDisassembled(String description, Class cls, byte[] bytes) throws Exception {\n+        log(description + \" -------------------\");\n+\n+        File f = new File(cls.getSimpleName()+\".class\");\n+        try (FileOutputStream fos = new FileOutputStream(f)) {\n+            fos.write(bytes);\n+        }\n+        JDKToolLauncher javap = JDKToolLauncher.create(\"javap\")\n+                .addToolArg(\"-verbose\")\n+                .addToolArg(\"-p\")       \/\/ Shows all classes and members.\n+                \/\/.addToolArg(\"-c\")       \/\/ Prints out disassembled code\n+                .addToolArg(\"-s\")       \/\/ Prints internal type signatures.\n+                .addToolArg(f.toString());\n+        ProcessBuilder pb = new ProcessBuilder(javap.getCommand());\n+        OutputAnalyzer out = ProcessTools.executeProcess(pb);\n+        out.shouldHaveExitValue(0);\n+        try {\n+            Files.delete(f.toPath());\n+        } catch (Exception ex) {\n+            \/\/ ignore\n+        }\n+        out.asLines().forEach(s -> log(s));\n+        log(\"==========================================\");\n+        Files.deleteIfExists(f.toPath());\n+    }\n+\n+    private byte[] getNewClassBytes() {\n+        byte[] bytecode = InMemoryJavaCompiler.compile(GenericSignatureTarget.class.getName(), newTargetClassSource, \"-g\");\n+\n+        ClassWriter cw = new ClassWriter(0);\n+        ClassReader cr = new ClassReader(bytecode);\n+        cr.accept(new ClassVisitor(Opcodes.ASM7, cw) {\n+            private boolean sourceSet = false;\n+            @Override\n+            public void visitSource(String source, String debug) {\n+                sourceSet = true;\n+                log(\"Changing source: \\\"\" + source + \"\\\" -> \\\"\" + sourceFileNameNew + \"\\\"\");\n+                super.visitSource(sourceFileNameNew, debug);\n+            }\n+\n+            @Override\n+            public void visitEnd() {\n+                if (!sourceSet) {\n+                    log(\"Set source: \\\"\" + sourceFileNameNew + \"\\\"\");\n+                    super.visitSource(sourceFileNameNew, null);\n+                }\n+                super.visitEnd();\n+            }\n+        }, 0);\n+        return cw.toByteArray();\n+    }\n+\n+    private void runTest() throws Throwable {\n+        Class targetClass = GenericSignatureTarget.class;\n+\n+        String oldSig = getTargetGenSig();\n+        log(\"old target class sig: \\\"\" + oldSig + \"\\\"\");\n+\n+        byte[] oldClassBytes = targetClass.getResourceAsStream(targetClass.getName() + \".class\").readAllBytes();\n+        printDisassembled(\"Old \" + targetClass.getName(), targetClass, oldClassBytes);\n+\n+        log(\"Redefining \" + targetClass.getName() + \" class\");\n+        byte[] newClassBytes = getNewClassBytes();\n+        printDisassembled(\"New \" + targetClass.getName(), targetClass, newClassBytes);\n+        RedefineClassHelper.redefineClass(targetClass, newClassBytes);\n+\n+        String newSig = getTargetGenSig();\n+        log(\"new target class sig: \\\"\" + newSig + \"\\\"\");\n+\n+        String newRetType = getTesterRetType();\n+        log(\"new tester ret type: \\\"\" + newRetType + \"\\\"\");\n+\n+        String newSrcFileName = getTargetSourceFilename();\n+        log(\"new source file name: \\\"\" + newSrcFileName + \"\\\"\");\n+\n+        Asserts.assertStringsEqual(expectedSigOld, oldSig, \"wrong old generic signature\");\n+        Asserts.assertStringsEqual(expectedSigNew, newSig, \"wrong new generic signature\");\n+        Asserts.assertStringsEqual(expectedRetType, newRetType, \"wrong ret type\");\n+        Asserts.assertStringsEqual(sourceFileNameNew, newSrcFileName, \"wrong new source file name\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/RedefineClasses\/RedefineGenericSignatureTest.java","additions":196,"deletions":0,"binary":false,"changes":196,"status":"added"},{"patch":"@@ -1,233 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8282241\n- * @summary Verifies class retransformation correctly updates generic_signature and source_file_name attributes\n- *\n- * @library \/test\/lib\n- * @run compile -g RetransformGenericSignatureTest.java\n- * @run shell MakeJAR.sh retransformAgent\n- *\n- * @run main\/othervm -javaagent:retransformAgent.jar --add-opens=java.base\/java.lang=ALL-UNNAMED RetransformGenericSignatureTest\n- *\/\n-\n-import java.io.File;\n-import java.io.FileOutputStream;\n-import java.lang.instrument.ClassFileTransformer;\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-import java.lang.reflect.Type;\n-import java.nio.file.Files;\n-import java.nio.file.Paths;\n-import java.security.ProtectionDomain;\n-import java.util.List;\n-\n-import jdk.test.lib.JDKToolLauncher;\n-import jdk.test.lib.process.ProcessTools;\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.util.ClassTransformer;\n-\n-\n-class GenericSignatureTester {\n-    public GenericSignatureTarget<List<String>> method1() {\n-        return null;\n-    }\n-}\n-\n-\/\/ See ClassTransformer.transform(int) comment for @1 tag explanations.\n-\/\/ @1 uncomment class GenericSignatureTarget<T> {\n-class GenericSignatureTarget<T extends List<?>>  { \/\/ @1 commentout\n-    public GenericSignatureTarget<T> method1(GenericSignatureTarget<?> a) {\n-        \/\/ the following line changes CP and this causes mapping during CP merge\n-        \/\/ @1 uncomment System.out.println(a);\n-        return null;\n-    }\n-\n-    public static void throwException() {\n-        throw new RuntimeException();\n-    }\n-}\n-\n-public class RetransformGenericSignatureTest extends ATransformerManagementTestCase {\n-\n-    public RetransformGenericSignatureTest() {\n-        super(\"RetransformGenericSignatureTest\");\n-    }\n-\n-    public static void main (String[] args) throws Throwable {\n-        ATestCaseScaffold test = new RetransformGenericSignatureTest();\n-        test.runTest();\n-    }\n-\n-    private final Transformer transformer = new Transformer();\n-    private final static String sourceFileName = \"RetransformGenericSignatureTest.java\";\n-    private final static String sourceFileNameNew = \"RetransformGenericSignatureTestNew.java\";\n-    \/\/ expected signature of GenericSignatureTester.method1 return type\n-    private final static String expectedRetType = \"GenericSignatureTarget<java.util.List<java.lang.String>>\";\n-    \/\/ expected generic signature of the original GenericSignatureTarget\n-    private final static String expectedSigOld = \"<T::Ljava\/util\/List<*>;>Ljava\/lang\/Object;\";\n-    \/\/ expected generic signature of the retransformed GenericSignatureTarget\n-    private final static String expectedSigNew = \"<T:Ljava\/lang\/Object;>Ljava\/lang\/Object;\";\n-\n-    private void log(Object o) {\n-        System.out.println(o);\n-    }\n-\n-    private String getTargetGenSig() throws Throwable {\n-        MethodHandles.Lookup lookup = MethodHandles.lookup();\n-        MethodHandles.Lookup classLookup = MethodHandles.privateLookupIn(Class.class, lookup);\n-        MethodHandle getGenericSignature0 = classLookup.findVirtual(\n-                Class.class, \"getGenericSignature0\", MethodType.methodType(String.class));\n-        Object genericSignature = getGenericSignature0.invoke(GenericSignatureTarget.class);\n-        return String.valueOf(genericSignature);\n-    }\n-\n-    private String getTesterRetType() throws Throwable {\n-        Type type = GenericSignatureTester.class.getDeclaredMethod(\"method1\").getGenericReturnType();\n-        return String.valueOf(type);\n-    }\n-\n-    private String getTargetSourceFilename() {\n-        try {\n-            GenericSignatureTarget.throwException();\n-        } catch (RuntimeException ex) {\n-            return ex.getStackTrace()[0].getFileName();\n-        }\n-        return \"Cannot get source file name\";\n-    }\n-\n-    \/\/ Retransforms the class using provided class bytes;\n-    \/\/ Returns class bytes passed to the transformer.\n-    private byte[] retransform(Class cls, byte[] classBytes) throws Throwable {\n-        transformer.targetClassName = cls.getName();\n-        transformer.seenClassBytes = null;\n-        transformer.newClassBytes = classBytes;\n-        fInst.retransformClasses(cls);\n-        assertTrue(transformer.targetClassName + \" was not seen by transform()\",\n-                transformer.seenClassBytes != null);\n-        return transformer.seenClassBytes;\n-    }\n-\n-    \/\/ Prints dissassembled class bytes.\n-    private void printDisassembled(String description, Class cls, byte[] bytes) throws Exception {\n-        log(description + \" -------------------\");\n-\n-        File f = new File(cls.getSimpleName()+\".class\");\n-        try (FileOutputStream fos = new FileOutputStream(f)) {\n-            fos.write(bytes);\n-        }\n-        JDKToolLauncher javap = JDKToolLauncher.create(\"javap\")\n-                .addToolArg(\"-verbose\")\n-                .addToolArg(\"-p\")       \/\/ Shows all classes and members.\n-                \/\/.addToolArg(\"-c\")       \/\/ Prints out disassembled code\n-                .addToolArg(\"-s\")       \/\/ Prints internal type signatures.\n-                .addToolArg(f.toString());\n-        ProcessBuilder pb = new ProcessBuilder(javap.getCommand());\n-        OutputAnalyzer out = ProcessTools.executeProcess(pb);\n-        out.shouldHaveExitValue(0);\n-        try {\n-            Files.delete(f.toPath());\n-        } catch (Exception ex) {\n-            \/\/ ignore\n-        }\n-        out.asLines().forEach(s -> log(s));\n-        log(\"==========================================\");\n-        Files.deleteIfExists(f.toPath());\n-    }\n-\n-    private void retransformTargetClass() throws Throwable {\n-        Class targetClass = GenericSignatureTarget.class;\n-        log(\"Retransforming \" + targetClass.getName() + \" class\");\n-        String origSource = Files.readString(Paths.get(System.getProperty(\"test.src\")).resolve(sourceFileName));\n-        \/\/ replace main class name to avoid compilation errors\n-        String newSource = origSource.replaceAll(\n-                \"RetransformGenericSignatureTest\", \"RetransformGenericSignatureTestNew\");\n-\n-        String transformedClassFile = ClassTransformer.fromString(newSource)\n-                .setFileName(sourceFileNameNew)\n-                .transform(1, targetClass.getName(), \"-g\");\n-        byte[] classBytes = Files.readAllBytes(Paths.get(transformedClassFile));\n-        byte[] oldClassBytes = retransform(targetClass, classBytes);\n-\n-        printDisassembled(\"Old \" + targetClass.getName(), targetClass, oldClassBytes);\n-        printDisassembled(\"New \" + targetClass.getName(), targetClass, classBytes);\n-    }\n-\n-    protected final void doRunTest() throws Throwable {\n-        beVerbose();\n-\n-        String oldSig = getTargetGenSig();\n-        log(\"old target class sig: \\\"\" + oldSig + \"\\\"\");\n-\n-        addTransformerToManager(fInst, transformer, true);\n-\n-        retransformTargetClass();\n-\n-        String newSig = getTargetGenSig();\n-        log(\"new target class sig: \\\"\" + newSig + \"\\\"\");\n-\n-        String newRetType = getTesterRetType();\n-        log(\"new tester ret type: \\\"\" + newRetType + \"\\\"\");\n-\n-        String newSrcFileName = getTargetSourceFilename();\n-        log(\"new source file name: \\\"\" + newSrcFileName + \"\\\"\");\n-\n-        assertEquals(\"wrong old generic signature\", expectedSigOld, oldSig);\n-        assertEquals(\"wrong new generic signature\", expectedSigNew, newSig);\n-        assertEquals(\"wrong ret type\", expectedRetType, newRetType);\n-        assertEquals(\"wrong new source file name\", sourceFileNameNew, newSrcFileName);\n-    }\n-\n-    public class Transformer implements ClassFileTransformer {\n-        public Transformer() {\n-        }\n-\n-        public String toString() {\n-            return Transformer.this.getClass().getName();\n-        }\n-\n-        String targetClassName;\n-        byte[] seenClassBytes;\n-        byte[] newClassBytes;\n-\n-        public byte[] transform(ClassLoader loader, String className,\n-            Class<?> classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) {\n-\n-            if (className.equals(targetClassName)) {\n-                log(this + \".transform() sees '\" + className\n-                        + \"' of \" + classfileBuffer.length + \" bytes.\");\n-                seenClassBytes = classfileBuffer;\n-                if (newClassBytes != null) {\n-                    log(this + \".transform() sets new classbytes for '\" + className\n-                            + \"' of \" + newClassBytes.length + \" bytes.\");\n-                }\n-                return newClassBytes;\n-            }\n-\n-            return null;\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/instrument\/RetransformGenericSignatureTest.java","additions":0,"deletions":233,"binary":false,"changes":233,"status":"deleted"}]}