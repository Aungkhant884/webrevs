{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+\n@@ -85,0 +86,158 @@\n+\n+    \/**\n+     * Class used to wrap a {@link java.util.random.RandomGenerator} to\n+     * {@link java.util.Random}.\n+     *\/\n+\n+    @SuppressWarnings(\"serial\")\n+    private static final class RandomWrapper extends Random implements RandomGenerator {\n+        private final RandomGenerator generator;\n+        \/\/randomToWrap must never be null\n+        private RandomWrapper(RandomGenerator randomToWrap) {\n+            super(null);\n+            this.generator = randomToWrap;\n+        }\n+\n+        \/**\n+         * Throws {@code NotSerializableException}.\n+         *\n+         * @param s the object input stream\n+         * @throws NotSerializableException always\n+         *\/\n+        @Serial\n+        private void readObject(ObjectInputStream s) throws NotSerializableException {\n+            throw new NotSerializableException(\"not serializable\");\n+        }\n+\n+        \/**\n+         * Throws {@code NotSerializableException}.\n+         *\n+         * @param s the object output stream\n+         * @throws NotSerializableException always\n+         *\/\n+        @Serial\n+        private void writeObject(ObjectOutputStream s) throws NotSerializableException {\n+            throw new NotSerializableException(\"not serializable\");\n+        }\n+\n+        \/**\n+         * setSeed does not exist in {@link java.util.random.RandomGenerator} so can't\n+         * use it.\n+         *\/\n+        @Override\n+        public void setSeed(long seed) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public void nextBytes(byte[] bytes) {\n+            this.generator.nextBytes(bytes);\n+        }\n+\n+        @Override\n+        public int nextInt() {\n+            return this.generator.nextInt();\n+        }\n+\n+        @Override\n+        public int nextInt(int bound) {\n+            return this.generator.nextInt(bound);\n+        }\n+\n+        @Override\n+        public long nextLong() {\n+            return this.generator.nextLong();\n+        }\n+\n+        @Override\n+        public boolean nextBoolean() {\n+            return this.generator.nextBoolean();\n+        }\n+\n+        @Override\n+        public float nextFloat() {\n+            return this.generator.nextFloat();\n+        }\n+\n+        @Override\n+        public double nextDouble() {\n+            return this.generator.nextDouble();\n+        }\n+\n+        @Override\n+        public double nextGaussian() {\n+            return this.generator.nextGaussian();\n+        }\n+\n+        @Override\n+        public IntStream ints(long streamSize) {\n+            return this.generator.ints(streamSize);\n+        }\n+\n+        @Override\n+        public IntStream ints() {\n+            return this.generator.ints();\n+        }\n+\n+        @Override\n+        public IntStream ints(long streamSize, int randomNumberOrigin, int randomNumberBound) {\n+            return this.generator.ints(streamSize, randomNumberOrigin, randomNumberBound);\n+        }\n+\n+        @Override\n+        public IntStream ints(int randomNumberOrigin, int randomNumberBound) {\n+            return this.generator.ints(randomNumberOrigin, randomNumberBound);\n+        }\n+\n+        @Override\n+        public LongStream longs(long streamSize) {\n+            return this.generator.longs(streamSize);\n+        }\n+\n+        @Override\n+        public LongStream longs() {\n+            return this.generator.longs();\n+        }\n+\n+        @Override\n+        public LongStream longs(long streamSize, long randomNumberOrigin, long randomNumberBound) {\n+            return this.generator.longs(streamSize, randomNumberOrigin, randomNumberBound);\n+        }\n+\n+        @Override\n+        public LongStream longs(long randomNumberOrigin, long randomNumberBound) {\n+            return this.generator.longs(randomNumberOrigin, randomNumberBound);\n+        }\n+\n+        @Override\n+        public DoubleStream doubles(long streamSize) {\n+            return this.generator.doubles(streamSize);\n+        }\n+\n+        @Override\n+        public DoubleStream doubles() {\n+            return this.generator.doubles();\n+        }\n+\n+        @Override\n+        public DoubleStream doubles(long streamSize, double randomNumberOrigin, double randomNumberBound) {\n+            return this.generator.doubles(streamSize, randomNumberOrigin, randomNumberBound);\n+        }\n+\n+        @Override\n+        public DoubleStream doubles(double randomNumberOrigin, double randomNumberBound) {\n+            return this.generator.doubles(randomNumberOrigin, randomNumberBound);\n+        }\n+\n+        \/\/This method should never be reached unless done by reflection so we should throw when tried\n+        @Override\n+        protected int next(int bits) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"RandomWrapper[\" + generator + \"]\";\n+        }\n+    }\n+\n@@ -111,0 +270,4 @@\n+    private Random(Void unused) {\n+        this.seed = null;\n+    }\n+\n@@ -154,10 +317,22 @@\n-     * Sets the seed of this random number generator using a single\n-     * {@code long} seed. The general contract of {@code setSeed} is\n-     * that it alters the state of this random number generator object\n-     * so as to be in exactly the same state as if it had just been\n-     * created with the argument {@code seed} as a seed. The method\n-     * {@code setSeed} is implemented by class {@code Random} by\n-     * atomically updating the seed to\n-     *  <pre>{@code (seed ^ 0x5DEECE66DL) & ((1L << 48) - 1)}<\/pre>\n-     * and clearing the {@code haveNextNextGaussian} flag used by {@link\n-     * #nextGaussian}.\n+     * Returns an instance of {@code Random} that delegates method calls to the {@link RandomGenerator}\n+     * argument. If the generator is an instance of {@code Random}, it is returned. Otherwise, this method\n+     * returns an instance of {@code Random} that delegates all methods except {@code setSeed} to the generator.\n+     * The returned instance's {@code setSeed} method always throws {@link UnsupportedOperationException}.\n+     * The returned instance is not serializable.\n+     *\n+     * @param generator the {@code RandomGenerator} calls are delegated to\n+     * @return the delegating {@code Random} instance\n+     * @throws NullPointerException if generator is null\n+     * @since 19\n+     *\/\n+    public static Random from(RandomGenerator generator) {\n+        Objects.requireNonNull(generator);\n+        if (generator instanceof Random rand)\n+            return rand;\n+\n+        return new RandomWrapper(generator);\n+    }\n+\n+    \/**\n+     * Sets or updates the seed of this random number generator using the\n+     * provided {@code long} seed value (optional operation).\n@@ -165,4 +340,7 @@\n-     * <p>The implementation of {@code setSeed} by class {@code Random}\n-     * happens to use only 48 bits of the given seed. In general, however,\n-     * an overriding method may use all 64 bits of the {@code long}\n-     * argument as a seed value.\n+     * @implSpec\n+     * The implementation in this class alters the state of this random number\n+     * generator so that it is in the same state as if it had just been created with\n+     * {@link #Random(long) new Random(seed)}. It atomically updates the seed to\n+     *  <pre>{@code (seed ^ 0x5DEECE66DL) & ((1L << 48) - 1)}<\/pre>\n+     * and clears the {@code haveNextNextGaussian} flag used by {@link #nextGaussian}.\n+     * Note that this uses only 48 bits of the given seed value.\n@@ -170,1 +348,3 @@\n-     * @param seed the initial seed\n+     * @param seed the seed value\n+     * @throws UnsupportedOperationException if the {@code setSeed}\n+     *         operation is not supported by this random number generator\n@@ -178,5 +358,2 @@\n-     * Generates the next pseudorandom number. Subclasses should\n-     * override this, as this is used by all other methods.\n-     *\n-     * <p>The general contract of {@code next} is that it returns an\n-     * {@code int} value and if the argument {@code bits} is between\n+     * Generates the next pseudorandom number. This method returns an\n+     * {@code int} value such that, if the argument {@code bits} is between\n@@ -186,2 +363,10 @@\n-     * likely to be {@code 0} or {@code 1}. The method {@code next} is\n-     * implemented by class {@code Random} by atomically updating the seed to\n+     * likely to be {@code 0} or {@code 1}.\n+     *\n+     * @apiNote\n+     * The other random-producing methods in this class are implemented\n+     * in terms of this method, so subclasses can override just this\n+     * method to provide a different source of pseudorandom numbers for\n+     * the entire class.\n+     *\n+     * @implSpec\n+     * The implementation in this class atomically updates the seed to\n@@ -189,1 +374,1 @@\n-     * and returning\n+     * and returns\n@@ -192,1 +377,1 @@\n-     * This is a linear congruential pseudorandom number generator, as\n+     * <p>This is a linear congruential pseudorandom number generator, as\n","filename":"src\/java.base\/share\/classes\/java\/util\/Random.java","additions":210,"deletions":25,"binary":false,"changes":235,"status":"modified"},{"patch":"@@ -28,0 +28,3 @@\n+import java.util.random.RandomGenerator;\n+import java.util.ArrayList;\n+import java.util.Collections;\n@@ -413,0 +416,32 @@\n+    \/**\n+     * Test shuffling a list with Random.from()\n+     *\/\n+    public void testShufflingList() {\n+        final var listTest = new ArrayList<Integer>();\n+        final RandomGenerator randomGenerator = RandomGenerator.getDefault();\n+        final Random random = Random.from(randomGenerator);\n+\n+        for (int i = 0; i < 100; i++) {\n+            listTest.add(i * 2);\n+        }\n+        final var listCopy = new ArrayList<Integer>(listTest);\n+\n+        Collections.shuffle(listCopy, random);\n+\n+        assertFalse(listCopy.equals(listTest));\n+    }\n+\n+    \/**\n+     * Test if Random.from returns this\n+     *\/\n+    public void testRandomFromInstance() {\n+        final RandomGenerator randomGenerator = RandomGenerator.getDefault();\n+\n+        final Random randomInstance = Random.from(randomGenerator);\n+\n+        \/\/ we wrap the same instance again\n+        final Random randomInstanceCopy = Random.from(randomInstance);\n+\n+        assertSame(randomInstance, randomInstanceCopy);\n+    }\n+\n","filename":"test\/jdk\/java\/util\/Random\/RandomTest.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import java.lang.reflect.Modifier;\n@@ -575,0 +576,1 @@\n+            .filter(method -> (method.getModifiers() & Modifier.STATIC) == 0)\n","filename":"test\/jdk\/java\/util\/concurrent\/tck\/SplittableRandomTest.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}