{"files":[{"patch":"@@ -126,34 +126,0 @@\n-class ZMarkRootsIteratorClosure : public ZRootsIteratorClosure {\n-public:\n-  virtual void do_oop(oop* p) {\n-    ZBarrier::mark_barrier_on_root_oop_field(p);\n-  }\n-\n-  virtual void do_oop(narrowOop* p) {\n-    ShouldNotReachHere();\n-  }\n-};\n-\n-class ZMarkRootsTask : public ZTask {\n-private:\n-  ZMark* const              _mark;\n-  ZRootsIterator            _roots;\n-  ZMarkRootsIteratorClosure _cl;\n-\n-public:\n-  ZMarkRootsTask(ZMark* mark) :\n-      ZTask(\"ZMarkRootsTask\"),\n-      _mark(mark),\n-      _roots(false \/* visit_jvmti_weak_export *\/) {}\n-\n-  virtual void work() {\n-    _roots.oops_do(&_cl);\n-\n-    \/\/ Flush and free worker stacks. Needed here since\n-    \/\/ the set of workers executing during root scanning\n-    \/\/ can be different from the set of workers executing\n-    \/\/ during mark.\n-    _mark->flush_and_free();\n-  }\n-};\n-\n@@ -168,4 +134,0 @@\n-\n-  \/\/ Mark roots\n-  ZMarkRootsTask task(this);\n-  _workers->run_parallel(&task);\n","filename":"src\/hotspot\/share\/gc\/z\/zMark.cpp","additions":0,"deletions":38,"binary":false,"changes":38,"status":"modified"}]}