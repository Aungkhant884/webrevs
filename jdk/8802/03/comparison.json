{"files":[{"patch":"@@ -1262,1 +1262,1 @@\n-void fill_continuation_entry(MacroAssembler* masm);\n+void fill_continuation_entry(MacroAssembler* masm, Register reg_cont_obj, Register reg_flags);\n@@ -1265,4 +1265,9 @@\n-\/\/ enterSpecial(Continuation c, boolean isContinue, boolean isVirtualThread)\n-\/\/ On entry: c_rarg1 -- the continuation object\n-\/\/           c_rarg2 -- isContinue\n-\/\/           c_rarg3 -- isVirtualThread\n+static void check_continuation_enter_argument(VMReg actual_vmreg,\n+                                              Register expected_reg,\n+                                              const char* name) {\n+  assert(!actual_vmreg->is_stack(), \"%s cannot be on stack\", name);\n+  assert(actual_vmreg->as_Register() == expected_reg,\n+         \"%s is in unexpected register: %s instead of %s\",\n+         name, actual_vmreg->as_Register()->name(), expected_reg->name());\n+}\n+\n@@ -1274,1 +1279,1 @@\n-                                 OopMapSet*oop_maps,\n+                                 OopMapSet* oop_maps,\n@@ -1277,3 +1282,0 @@\n-  \/\/verify_oop_args(masm, method, sig_bt, regs);\n-  AddressLiteral resolve(SharedRuntime::get_resolve_static_call_stub(),\n-                         relocInfo::static_call_type);\n@@ -1281,2 +1283,12 @@\n-  stack_slots = 2; \/\/ will be overwritten\n-  address start = __ pc();\n+  \/\/ enterSpecial(Continuation c, boolean isContinue, boolean isVirtualThread)\n+  int pos_cont_obj   = 0;\n+  int pos_is_cont    = 1;\n+  int pos_is_virtual = 2;\n+\n+  \/\/ The platform-specific calling convention may present the arguments in various registers.\n+  \/\/ To simplify the rest of the code, we expect the arguments to reside at these known\n+  \/\/ registers, and we additionally check the placement here in case calling convention ever\n+  \/\/ changes.\n+  Register reg_cont_obj   = c_rarg1;\n+  Register reg_is_cont    = c_rarg2;\n+  Register reg_is_virtual = c_rarg3;\n@@ -1284,1 +1296,8 @@\n-  Label call_thaw, exit;\n+  check_continuation_enter_argument(regs[pos_cont_obj].first(),   reg_cont_obj,   \"Continuation object\");\n+  check_continuation_enter_argument(regs[pos_is_cont].first(),    reg_is_cont,    \"isContinue\");\n+  check_continuation_enter_argument(regs[pos_is_virtual].first(), reg_is_virtual, \"isVirtualThread\");\n+\n+  \/\/ Utility methods kill rax, make sure there are no collisions\n+  assert_different_registers(rax, reg_cont_obj, reg_is_cont, reg_is_virtual);\n+\n+  address start = __ pc();\n@@ -1288,3 +1307,2 @@\n-  \/\/BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n-  \/\/bs->nmethod_entry_barrier(masm);\n-  OopMap* map = continuation_enter_setup(masm, stack_slots);  \/\/ kills rax\n+  stack_slots = 2; \/\/ will be adjusted in setup\n+  OopMap* map = continuation_enter_setup(masm, stack_slots);\n@@ -1293,4 +1311,9 @@\n-  frame_complete =__ pc() - start;\n-  \/\/ if isContinue == 0\n-  \/\/   _enterSP = sp\n-  \/\/ end\n+  frame_complete = __ pc() - start;\n+\n+  fill_continuation_entry(masm, reg_cont_obj, reg_is_virtual);\n+\n+  Label L_thaw, L_exit;\n+\n+  \/\/ If continuation, call to thaw. Otherwise, resolve the call and exit.\n+  __ testptr(reg_is_cont, reg_is_cont);\n+  __ jccb(Assembler::notZero, L_thaw);\n@@ -1298,1 +1321,1 @@\n-  fill_continuation_entry(masm); \/\/ kills rax\n+  \/\/ --- Resolve path\n@@ -1300,2 +1323,2 @@\n-  __ cmpl(c_rarg2, 0);\n-  __ jcc(Assembler::notEqual, call_thaw);\n+  \/\/ Make sure the call is patchable\n+  __ align(BytesPerWord, __ offset() + NativeCall::displacement_offset);\n@@ -1303,3 +1326,5 @@\n-  int up = align_up((intptr_t) __ pc() + 1, 4) - (intptr_t) (__ pc() + 1);\n-  if (up > 0) {\n-    __ nop(up);\n+  \/\/ Emit stub for static call\n+  CodeBuffer* cbuf = masm->code_section()->outer();\n+  address stub = CompiledStaticCall::emit_to_interp_stub(*cbuf, __ pc());\n+  if (stub == nullptr) {\n+    fatal(\"CodeCache is full at gen_continuation_enter\");\n@@ -1308,1 +1333,3 @@\n-  address mark = __ pc();\n+  \/\/ Call the resolve stub\n+  AddressLiteral resolve(SharedRuntime::get_resolve_static_call_stub(),\n+                         relocInfo::static_call_type);\n@@ -1310,0 +1337,1 @@\n+\n@@ -1313,1 +1341,1 @@\n-  __ jmp(exit);\n+  __ jmpb(L_exit);\n@@ -1315,1 +1343,5 @@\n-  __ bind(call_thaw);\n+  \/\/ --- Thawing path\n+\n+  __ bind(L_thaw);\n+\n+  __ call(RuntimeAddress(StubRoutines::cont_thaw()));\n@@ -1317,3 +1349,0 @@\n-  __ movptr(rbx, (intptr_t) StubRoutines::cont_thaw());\n-  __ call(rbx);\n-  oop_maps->add_gc_map(__ pc() - start, map->deep_copy());\n@@ -1321,0 +1350,1 @@\n+  oop_maps->add_gc_map(__ pc() - start, map->deep_copy());\n@@ -1323,1 +1353,4 @@\n-  __ bind(exit);\n+  \/\/ --- Normal exit (resolve\/thawing)\n+\n+  __ bind(L_exit);\n+\n@@ -1328,1 +1361,1 @@\n-  \/\/\/ exception handling\n+  \/\/ --- Exception handling path\n@@ -1335,2 +1368,2 @@\n-  __ movptr(rbx, rax); \/\/ save the exception\n-  __ movptr(c_rarg0, Address(rsp, 0));\n+  __ movptr(c_rarg0, r15_thread);\n+  __ movptr(c_rarg1, Address(rsp, 0)); \/\/ return address\n@@ -1338,7 +1371,2 @@\n-  __ call_VM_leaf(CAST_FROM_FN_PTR(address,\n-        SharedRuntime::exception_handler_for_return_address),\n-      r15_thread, c_rarg0);\n-  __ mov(rdi, rax);\n-  __ movptr(rax, rbx);\n-  __ mov(rbx, rdi);\n-  __ pop(rdx);\n+  \/\/ rax still holds the original exception oop, save it before the call\n+  __ push(rax);\n@@ -1346,4 +1374,8 @@\n-  \/\/ continue at exception handler (return address removed)\n-  \/\/ rax: exception\n-  \/\/ rbx: exception handler\n-  \/\/ rdx: throwing pc\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::exception_handler_for_return_address), 2);\n+  __ movptr(rbx, rax);\n+\n+  \/\/ Continue at exception handler:\n+  \/\/   rax: exception oop\n+  \/\/   rbx: exception handler\n+  \/\/   rdx: exception pc\n+  __ pop(rax);\n@@ -1351,0 +1383,1 @@\n+  __ pop(rdx);\n@@ -1352,3 +1385,0 @@\n-\n-  CodeBuffer* cbuf = masm->code_section()->outer();\n-  address stub = CompiledStaticCall::emit_to_interp_stub(*cbuf, mark);\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":79,"deletions":49,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -7669,5 +7669,8 @@\n-      \/\/ rbx now holds the exception handler.\n-      \/\/ Prepare for its invocation; see OptoRuntime::generate_exception_blob.\n-      __ pop(rax); \/\/ exception oop\n-      __ pop(rbp);\n-      __ pop(rdx); \/\/ exception pc\n+      \/\/ Continue at exception handler:\n+      \/\/   rax: exception oop\n+      \/\/   rbx: exception handler\n+      \/\/   rdx: exception pc\n+      __ pop(rax);\n+      __ verify_oop(rax);\n+      __ pop(rbp); \/\/ pop out RBP here too\n+      __ pop(rdx);\n@@ -8312,2 +8315,2 @@\n-\/\/   c_rarg1: pointer to the continuation\n-\/\/   c_rarg3: flags\n+\/\/   reg_cont_obj: pointer to the continuation\n+\/\/   reg_flags: flags\n@@ -8321,1 +8324,3 @@\n-void fill_continuation_entry(MacroAssembler* masm) {\n+void fill_continuation_entry(MacroAssembler* masm, Register reg_cont_obj, Register reg_flags) {\n+  assert_different_registers(rax, reg_cont_obj, reg_flags);\n+\n@@ -8324,2 +8329,2 @@\n-  __ movptr(Address(rsp, ContinuationEntry::cont_offset()), c_rarg1);\n-  __ movl  (Address(rsp, ContinuationEntry::flags_offset()), c_rarg3);\n+  __ movptr(Address(rsp, ContinuationEntry::cont_offset()), reg_cont_obj);\n+  __ movl  (Address(rsp, ContinuationEntry::flags_offset()), reg_flags);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":15,"deletions":10,"binary":false,"changes":25,"status":"modified"}]}