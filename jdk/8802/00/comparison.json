{"files":[{"patch":"@@ -1260,1 +1260,1 @@\n-void fill_continuation_entry(MacroAssembler* masm);\n+void fill_continuation_entry(MacroAssembler* masm, Register reg_cont_obj, Register reg_flags);\n@@ -1263,4 +1263,9 @@\n-\/\/ enterSpecial(Continuation c, boolean isContinue, boolean isVirtualThread)\n-\/\/ On entry: c_rarg1 -- the continuation object\n-\/\/           c_rarg2 -- isContinue\n-\/\/           c_rarg3 -- isVirtualThread\n+static void check_continuation_enter_argument(VMReg actual_vmreg,\n+                                              Register expected_reg,\n+                                              const char* name) {\n+  assert(!actual_vmreg->is_stack(), \"%s cannot be on stack\", name);\n+  assert(actual_vmreg->as_Register() == expected_reg,\n+         \"%s is in unexpected register: %s instead of %s\",\n+         name, actual_vmreg->as_Register()->name(), expected_reg->name());\n+}\n+\n@@ -1272,1 +1277,1 @@\n-                                 OopMapSet*oop_maps,\n+                                 OopMapSet* oop_maps,\n@@ -1275,3 +1280,0 @@\n-  \/\/verify_oop_args(masm, method, sig_bt, regs);\n-  AddressLiteral resolve(SharedRuntime::get_resolve_static_call_stub(),\n-                         relocInfo::static_call_type);\n@@ -1279,2 +1281,16 @@\n-  stack_slots = 2; \/\/ will be overwritten\n-  address start = __ pc();\n+  \/\/ enterSpecial(Continuation c, boolean isContinue, boolean isVirtualThread)\n+  int pos_cont_obj   = 0;\n+  int pos_is_cont    = 1;\n+  int pos_is_virtual = 2;\n+\n+  \/\/ The platform-specific calling convention may present the arguments in various registers.\n+  \/\/ To simplify the rest of the code, we expect the arguments to reside at these known\n+  \/\/ registers, and we additionally check the placement here in case calling convention ever\n+  \/\/ changes.\n+  Register reg_cont_obj   = c_rarg1;\n+  Register reg_is_cont    = c_rarg2;\n+  Register reg_is_virtual = c_rarg3;\n+\n+  check_continuation_enter_argument(regs[pos_cont_obj].first(),   reg_cont_obj,   \"Continuation object\");\n+  check_continuation_enter_argument(regs[pos_is_cont].first(),    reg_is_cont,    \"isContinue\");\n+  check_continuation_enter_argument(regs[pos_is_virtual].first(), reg_is_virtual, \"isVirtualThread\");\n@@ -1282,1 +1298,4 @@\n-  Label call_thaw, exit;\n+  \/\/ Utility methods kill rax, make sure there are no collisions\n+  assert_different_registers(rax, reg_cont_obj, reg_is_cont, reg_is_virtual);\n+\n+  address start = __ pc();\n@@ -1286,3 +1305,2 @@\n-  \/\/BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n-  \/\/bs->nmethod_entry_barrier(masm);\n-  OopMap* map = continuation_enter_setup(masm, stack_slots);  \/\/ kills rax\n+  stack_slots = 2; \/\/ will be adjusted in setup\n+  OopMap* map = continuation_enter_setup(masm, stack_slots);\n@@ -1291,4 +1309,5 @@\n-  frame_complete =__ pc() - start;\n-  \/\/ if isContinue == 0\n-  \/\/   _enterSP = sp\n-  \/\/ end\n+  frame_complete = __ pc() - start;\n+\n+  fill_continuation_entry(masm, reg_cont_obj, reg_is_virtual);\n+\n+  Label L_thaw, L_exit;\n@@ -1296,1 +1315,3 @@\n-  fill_continuation_entry(masm); \/\/ kills rax\n+  \/\/ If continuation, call to thaw. Otherwise, resolve the call and exit.\n+  __ testptr(reg_is_cont, reg_is_cont);\n+  __ jccb(Assembler::notZero, L_thaw);\n@@ -1298,2 +1319,1 @@\n-  __ cmpl(c_rarg2, 0);\n-  __ jcc(Assembler::notEqual, call_thaw);\n+  \/\/ --- Resolve path\n@@ -1301,3 +1321,8 @@\n-  int up = align_up((intptr_t) __ pc() + 1, 4) - (intptr_t) (__ pc() + 1);\n-  if (up > 0) {\n-    __ nop(up);\n+  \/\/ Make sure the call is patchable\n+  __ align(BytesPerWord, __ offset() + NativeCall::displacement_offset);\n+\n+  \/\/ Emit stub for static call\n+  CodeBuffer* cbuf = masm->code_section()->outer();\n+  address stub = CompiledStaticCall::emit_to_interp_stub(*cbuf, __ pc());\n+  if (stub == nullptr) {\n+    fatal(\"CodeCache is full at gen_continuation_enter\");\n@@ -1306,1 +1331,3 @@\n-  address mark = __ pc();\n+  \/\/ Call the resolve stub\n+  AddressLiteral resolve(SharedRuntime::get_resolve_static_call_stub(),\n+                         relocInfo::static_call_type);\n@@ -1308,0 +1335,1 @@\n+\n@@ -1311,1 +1339,1 @@\n-  __ jmp(exit);\n+  __ jmpb(L_exit);\n@@ -1313,1 +1341,5 @@\n-  __ bind(call_thaw);\n+  \/\/ --- Thawing path\n+\n+  __ bind(L_thaw);\n+\n+  __ call(RuntimeAddress(StubRoutines::cont_thaw()));\n@@ -1315,3 +1347,0 @@\n-  __ movptr(rbx, (intptr_t) StubRoutines::cont_thaw());\n-  __ call(rbx);\n-  oop_maps->add_gc_map(__ pc() - start, map->deep_copy());\n@@ -1319,0 +1348,1 @@\n+  oop_maps->add_gc_map(__ pc() - start, map->deep_copy());\n@@ -1321,1 +1351,4 @@\n-  __ bind(exit);\n+  \/\/ --- Normal exit (resolve\/thawing)\n+\n+  __ bind(L_exit);\n+\n@@ -1326,1 +1359,1 @@\n-  \/\/\/ exception handling\n+  \/\/ --- Exception handling path\n@@ -1333,15 +1366,13 @@\n-  __ movptr(rbx, rax); \/\/ save the exception\n-  __ movptr(c_rarg0, Address(rsp, 0));\n-\n-  __ call_VM_leaf(CAST_FROM_FN_PTR(address,\n-        SharedRuntime::exception_handler_for_return_address),\n-      r15_thread, c_rarg0);\n-  __ mov(rdi, rax);\n-  __ movptr(rax, rbx);\n-  __ mov(rbx, rdi);\n-  __ pop(rdx);\n-\n-  \/\/ continue at exception handler (return address removed)\n-  \/\/ rax: exception\n-  \/\/ rbx: exception handler\n-  \/\/ rdx: throwing pc\n+  __ movptr(c_rarg0, r15_thread);\n+  __ movptr(c_rarg1, Address(rsp, 0)); \/\/ return address\n+\n+  \/\/ rax still holds the original exception oop, save it before the call\n+  __ push(rax);\n+\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::exception_handler_for_return_address), 2);\n+  __ movptr(rbx, rax);\n+\n+  \/\/ rbx now holds the exception handler.\n+  \/\/ Prepare for its invocation; see OptoRuntime::generate_exception_blob.\n+  __ pop(rax); \/\/ exception oop\n+  __ pop(rdx); \/\/ exception pc\n@@ -1350,3 +1381,0 @@\n-\n-  CodeBuffer* cbuf = masm->code_section()->outer();\n-  address stub = CompiledStaticCall::emit_to_interp_stub(*cbuf, mark);\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":79,"deletions":51,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -8232,2 +8232,2 @@\n-\/\/   c_rarg1: pointer to the continuation\n-\/\/   c_rarg3: flags\n+\/\/   reg_cont_obj: pointer to the continuation\n+\/\/   reg_flags: flags\n@@ -8241,1 +8241,3 @@\n-void fill_continuation_entry(MacroAssembler* masm) {\n+void fill_continuation_entry(MacroAssembler* masm, Register reg_cont_obj, Register reg_flags) {\n+  assert_different_registers(rax, reg_cont_obj, reg_flags);\n+\n@@ -8244,2 +8246,2 @@\n-  __ movptr(Address(rsp, ContinuationEntry::cont_offset()), c_rarg1);\n-  __ movl  (Address(rsp, ContinuationEntry::flags_offset()), c_rarg3);\n+  __ movptr(Address(rsp, ContinuationEntry::cont_offset()), reg_cont_obj);\n+  __ movl  (Address(rsp, ContinuationEntry::flags_offset()), reg_flags);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"}]}