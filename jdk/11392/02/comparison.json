{"files":[{"patch":"@@ -30,0 +30,1 @@\n+#include \"utilities\/resourceHash.hpp\"\n@@ -119,1 +120,0 @@\n-    BasicType arg_bt   = move.bt;\n@@ -123,1 +123,1 @@\n-    os->print(\"Move a %s from \", null_safe_string(type2name(arg_bt)));\n+    os->print(\"Move from \");\n@@ -185,0 +185,18 @@\n+  class MoveOperation;\n+\n+  static inline unsigned hash(const VMStorage& vms) {\n+    \/\/ segment_mask_or_size is not taken into account since\n+    \/\/ VMStorages that differ only in mask or size can still\n+    \/\/ conflict\n+    return static_cast<unsigned int>(vms.type()) ^ vms.index_or_offset();\n+  }\n+\n+  using KillerTable = ResourceHashtable<\n+    VMStorage, MoveOperation*,\n+    32, \/\/ doesn't need to be big. don't have that many argument registers (in known ABIs)\n+    AnyObj::RESOURCE_AREA,\n+    mtInternal,\n+    ComputeMoveOrder::hash,\n+    ::operator==\n+    >;\n+\n@@ -188,3 +206,3 @@\n-    VMStorage        _src;\n-    VMStorage        _dst;\n-    bool             _processed;\n+    VMStorage       _src;\n+    VMStorage       _dst;\n+    bool            _processed;\n@@ -193,7 +211,0 @@\n-    BasicType       _bt;\n-\n-    static int get_id(VMStorage r) {\n-      assert((r.index_or_offset() & 0xFF000000) == 0, \"index or offset too large\");\n-      \/\/ assuming mask and size doesn't matter for now\n-      return ((int) r.type()) | (r.index_or_offset() << 8);\n-    }\n@@ -202,2 +213,2 @@\n-    MoveOperation(VMStorage src, VMStorage dst, BasicType bt):\n-      _src(src), _dst(dst), _processed(false), _next(NULL), _prev(NULL), _bt(bt) {}\n+    MoveOperation(VMStorage src, VMStorage dst):\n+      _src(src), _dst(dst), _processed(false), _next(nullptr), _prev(nullptr) {}\n@@ -205,6 +216,6 @@\n-    int src_id() const          { return get_id(_src); }\n-    int dst_id() const          { return get_id(_dst); }\n-    MoveOperation* next() const { return _next; }\n-    MoveOperation* prev() const { return _prev; }\n-    void set_processed()        { _processed = true; }\n-    bool is_processed() const   { return _processed; }\n+    const VMStorage& src() const { return _src; }\n+    const VMStorage& dst() const { return _dst; }\n+    MoveOperation* next()  const { return _next; }\n+    MoveOperation* prev()  const { return _prev; }\n+    void set_processed()         { _processed = true; }\n+    bool is_processed()    const { return _processed; }\n@@ -216,1 +227,1 @@\n-      MoveOperation* new_store = new MoveOperation(temp_register, _dst, _bt);\n+      MoveOperation* new_store = new MoveOperation(temp_register, _dst);\n@@ -222,1 +233,1 @@\n-      _prev = NULL;\n+      _prev = nullptr;\n@@ -230,1 +241,1 @@\n-    void link(GrowableArray<MoveOperation*>& killer) {\n+    void link(KillerTable& killer) {\n@@ -232,5 +243,6 @@\n-      MoveOperation* n = killer.at_grow(src_id(), NULL);\n-      if (n != NULL) {\n-        assert(_next == NULL && n->_prev == NULL, \"shouldn't have been set yet\");\n-        _next = n;\n-        n->_prev = this;\n+      MoveOperation** n = killer.get(_src);\n+      if (n != nullptr) {\n+        MoveOperation* src_killer = *n;\n+        assert(_next == nullptr && src_killer->_prev == nullptr, \"shouldn't have been set yet\");\n+        _next = src_killer;\n+        src_killer->_prev = this;\n@@ -241,1 +253,1 @@\n-      return {_bt, _src, _dst};\n+      return {_src, _dst};\n@@ -283,1 +295,1 @@\n-      if (out_reg.is_stack()) {\n+      if (out_reg.is_stack() || out_reg.is_frame_data()) {\n@@ -287,1 +299,1 @@\n-        Move move{bt, in_reg, out_reg};\n+        Move move{in_reg, out_reg};\n@@ -297,1 +309,1 @@\n-        _edges.append(new MoveOperation(in_reg, out_reg, bt));\n+        _edges.append(new MoveOperation(in_reg, out_reg));\n@@ -308,3 +320,2 @@\n-    \/\/ Record which moves kill which values\n-    \/\/ FIXME should be a map\n-    GrowableArray<MoveOperation*> killer; \/\/ essentially a map of register id -> MoveOperation*\n+    \/\/ Record which moves kill which registers\n+    KillerTable killer; \/\/ a map of VMStorage -> MoveOperation*\n@@ -313,1 +324,1 @@\n-      assert(killer.at_grow(s->dst_id(), NULL) == NULL,\n+      assert(!killer.contains(s->dst()),\n@@ -315,1 +326,1 @@\n-      killer.at_put_grow(s->dst_id(), s, NULL);\n+      killer.put(s->dst(), s);\n@@ -317,1 +328,1 @@\n-    assert(killer.at_grow(MoveOperation::get_id(temp_register), NULL) == NULL,\n+    assert(!killer.contains(temp_register),\n@@ -335,1 +346,1 @@\n-        while (start->prev() != NULL && start->prev() != s) {\n+        while (start->prev() != nullptr && start->prev() != s) {\n@@ -342,1 +353,1 @@\n-        while (start != NULL) {\n+        while (start != nullptr) {\n","filename":"src\/hotspot\/share\/prims\/foreignGlobals.cpp","additions":51,"deletions":40,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -119,1 +119,0 @@\n-  BasicType bt;\n","filename":"src\/hotspot\/share\/prims\/foreignGlobals.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}