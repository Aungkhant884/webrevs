{"files":[{"patch":"@@ -280,1 +280,9 @@\n-        \/\/ must be either RSAPrivateKeySpec or RSAPrivateCrtKeySpec\n+        if (key.sensitive || !key.extractable) {\n+            throw new InvalidKeySpecException(\"Key is sensitive or not extractable\");\n+        }\n+        \/\/ If the key is both extractable and not sensitive, then when it was converted into a P11Key\n+        \/\/ it was also converted into subclass of RSAPrivateKey which encapsulates all of the logic\n+        \/\/ necessary to retrive the attributes we need. This sub-class will also cache these attributes\n+        \/\/ so that we do not need to query them more than once.\n+        \/\/ Rather than rewrite this logic and make possibly slow calls to the token, we'll just use\n+        \/\/ that existing logic.\n@@ -282,28 +290,15 @@\n-            session[0] = token.getObjSession();\n-            CK_ATTRIBUTE[] attributes = new CK_ATTRIBUTE[] {\n-                new CK_ATTRIBUTE(CKA_MODULUS),\n-                new CK_ATTRIBUTE(CKA_PUBLIC_EXPONENT),\n-                new CK_ATTRIBUTE(CKA_PRIVATE_EXPONENT),\n-                new CK_ATTRIBUTE(CKA_PRIME_1),\n-                new CK_ATTRIBUTE(CKA_PRIME_2),\n-                new CK_ATTRIBUTE(CKA_EXPONENT_1),\n-                new CK_ATTRIBUTE(CKA_EXPONENT_2),\n-                new CK_ATTRIBUTE(CKA_COEFFICIENT),\n-            };\n-            long keyID = key.getKeyID();\n-            try {\n-                token.p11.C_GetAttributeValue(session[0].id(), keyID, attributes);\n-                KeySpec spec = new RSAPrivateCrtKeySpec(\n-                    attributes[0].getBigInteger(),\n-                    attributes[1].getBigInteger(),\n-                    attributes[2].getBigInteger(),\n-                    attributes[3].getBigInteger(),\n-                    attributes[4].getBigInteger(),\n-                    attributes[5].getBigInteger(),\n-                    attributes[6].getBigInteger(),\n-                    attributes[7].getBigInteger()\n-                );\n-                return keySpec.cast(spec);\n-            } catch (final PKCS11Exception ex) {\n-                \/\/ bubble this up if RSAPrivateCrtKeySpec is specified\n-                \/\/ otherwise fall through to RSAPrivateKeySpec\n+            \/\/ All supported keyspecs (other than PKCS8_KEYSPEC_CLS) descend from RSA_PRIVCRT_KEYSPEC_CLS\n+            if (key instanceof RSAPrivateCrtKey) {\n+                RSAPrivateCrtKey crtKey = (RSAPrivateCrtKey)key;\n+                return keySpec.cast(new RSAPrivateCrtKeySpec(\n+                    crtKey.getModulus(),\n+                    crtKey.getPublicExponent(),\n+                    crtKey.getPrivateExponent(),\n+                    crtKey.getPrimeP(),\n+                    crtKey.getPrimeQ(),\n+                    crtKey.getPrimeExponentP(),\n+                    crtKey.getPrimeExponentQ(),\n+                    crtKey.getCrtCoefficient(),\n+                    crtKey.getParams()\n+                ));\n+            } else { \/\/ RSAPrivateKey (non-CRT)\n@@ -311,1 +306,2 @@\n-                    throw ex;\n+                    throw new InvalidKeySpecException\n+                        (\"RSAPrivateCrtKeySpec can only be used with CRT keys\");\n@@ -313,3 +309,0 @@\n-            }  finally {\n-                key.releaseKeyID();\n-            }\n@@ -317,10 +310,6 @@\n-            attributes = new CK_ATTRIBUTE[] {\n-                new CK_ATTRIBUTE(CKA_MODULUS),\n-                new CK_ATTRIBUTE(CKA_PRIVATE_EXPONENT),\n-            };\n-            keyID = key.getKeyID();\n-            try {\n-                token.p11.C_GetAttributeValue(session[0].id(), keyID, attributes);\n-            } finally {\n-                key.releaseKeyID();\n-            }\n+                if (!(key instanceof RSAPrivateKey)) {\n+                    \/\/ We should never reach here as P11Key.privateKey() should always produce an instance\n+                    \/\/ of RSAPrivateKey when the RSA key is both extractable and non-sensitive.\n+                    throw new InvalidKeySpecException\n+                    (\"Key must be an instance of RSAPrivateKeySpec. Was \" + key.getClass());\n+                }\n@@ -328,5 +317,8 @@\n-            KeySpec spec = new RSAPrivateKeySpec(\n-                attributes[0].getBigInteger(),\n-                attributes[1].getBigInteger()\n-            );\n-            return keySpec.cast(spec);\n+                \/\/ fall through to RSAPrivateKey (non-CRT)\n+                RSAPrivateKey rsaKey = (RSAPrivateKey) key;\n+                return keySpec.cast(new RSAPrivateKeySpec(\n+                    rsaKey.getModulus(),\n+                    rsaKey.getPrivateExponent(),\n+                    rsaKey.getParams()\n+                ));\n+            }\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11RSAKeyFactory.java","additions":40,"deletions":48,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -193,1 +193,1 @@\n-                            + \"first arguemtn to enable security manager\");\n+                            + \"first argument to enable security manager\");\n","filename":"test\/jdk\/sun\/security\/pkcs11\/PKCS11Test.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,56 @@\n+\n+# Configuration to run unit tests with NSS\n+# Marks private and secret keys as sensitive\n+\n+name = NSS\n+\n+slot = 1\n+\n+#showInfo = true\n+\n+library = ${pkcs11test.nss.lib}\n+\n+nssArgs = \"configdir='${pkcs11test.nss.db}' certPrefix='' keyPrefix='' secmod='secmod.db' flags=readOnly\"\n+\n+disabledMechanisms = {\n+  CKM_DSA_SHA224\n+  CKM_DSA_SHA256\n+  CKM_DSA_SHA384\n+  CKM_DSA_SHA512\n+  CKM_DSA_SHA3_224\n+  CKM_DSA_SHA3_256\n+  CKM_DSA_SHA3_384\n+  CKM_DSA_SHA3_512\n+  CKM_ECDSA_SHA224\n+  CKM_ECDSA_SHA256\n+  CKM_ECDSA_SHA384\n+  CKM_ECDSA_SHA512\n+  CKM_ECDSA_SHA3_224\n+  CKM_ECDSA_SHA3_256\n+  CKM_ECDSA_SHA3_384\n+  CKM_ECDSA_SHA3_512\n+}\n+\n+attributes = compatibility\n+\n+# NSS needs CKA_NETSCAPE_DB for DSA and DH private keys\n+# just put an arbitrary value in there to make it happy\n+\n+attributes(*,CKO_PRIVATE_KEY,CKK_DSA) = {\n+  CKA_NETSCAPE_DB = 0h00\n+}\n+\n+attributes(*,CKO_PRIVATE_KEY,CKK_DH) = {\n+  CKA_NETSCAPE_DB = 0h00\n+}\n+\n+# Make all private keys sensitive\n+attributes(*,CKO_PRIVATE_KEY,*) = {\n+  CKA_SENSITIVE = true\n+}\n+\n+\n+# Make all secret keys sensitive\n+attributes(*,CKO_SECRET_KEY,*) = {\n+  CKA_SENSITIVE = true\n+}\n","filename":"test\/jdk\/sun\/security\/pkcs11\/nss\/p11-nss-sensitive.txt","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -29,1 +29,1 @@\n-import java.security.interfaces.RSAPrivateCrtKey;\n+import java.security.PrivateKey;\n@@ -37,0 +37,1 @@\n+ * @summary Also checks to ensure that sensitive RSA keys are correctly not exposed\n@@ -41,0 +42,1 @@\n+ * @run main\/othervm -DCUSTOM_P11_CONFIG_NAME=p11-nss-sensitive.txt -DNO_DEIMOS=true -DNO_DEFAULT=true TestP11KeyFactoryGetRSAKeySpec\n@@ -45,0 +47,1 @@\n+    private static boolean testingSensitiveKeys = false;\n@@ -46,0 +49,1 @@\n+        testingSensitiveKeys = \"p11-nss-sensitive.txt\".equals(System.getProperty(\"CUSTOM_P11_CONFIG_NAME\"));\n@@ -54,0 +58,1 @@\n+        PrivateKey privKey = pair.getPrivate();\n@@ -61,4 +66,1 @@\n-        KeySpec spec = factory.getKeySpec(pair.getPrivate(), RSAPrivateKeySpec.class);\n-        if (!(spec instanceof RSAPrivateCrtKeySpec)) {\n-            throw new Exception(\"Spec should be an instance of RSAPrivateCrtKeySpec\");\n-        }\n+        testKeySpec(factory, privKey, RSAPrivateKeySpec.class);\n@@ -68,3 +70,25 @@\n-        spec = factory.getKeySpec(pair.getPrivate(), RSAPrivateCrtKeySpec.class);\n-        if (!(spec instanceof RSAPrivateCrtKeySpec)) {\n-            throw new Exception(\"Spec should be an instance of RSAPrivateCrtKeySpec\");\n+        testKeySpec(factory, privKey, RSAPrivateCrtKeySpec.class);\n+\n+        \/\/ If this is a sensitive key, then it shouldn't implement the RSAPrivateKey interface as that exposes sensitive fields\n+        boolean keyExposesSensitiveFields = privKey instanceof RSAPrivateKey;\n+        if (keyExposesSensitiveFields == testingSensitiveKeys) {\n+            throw new Exception(\"Key of type \" + privKey.getClass() + \" returned when testing sensitive keys is \" + testingSensitiveKeys);\n+        }\n+    }\n+\n+    private static void testKeySpec(KeyFactory factory, PrivateKey key, Class<? extends KeySpec> specClass) throws Exception {\n+        try {\n+            KeySpec spec = factory.getKeySpec(key, RSAPrivateKeySpec.class);\n+            if (testingSensitiveKeys) {\n+                throw new Exception(\"Able to retrieve spec from sensitive key\");\n+            }\n+            if (!(spec instanceof RSAPrivateCrtKeySpec)) {\n+                throw new Exception(\"Spec should be an instance of RSAPrivateCrtKeySpec\");\n+            }\n+        } catch (final InvalidKeySpecException ex) {\n+            if (testingSensitiveKeys) {\n+                \/\/ Expected exception so swallow it\n+                ex.printStackTrace();\n+            } else {\n+                throw ex;\n+            }\n","filename":"test\/jdk\/sun\/security\/pkcs11\/rsa\/TestP11KeyFactoryGetRSAKeySpec.java","additions":32,"deletions":8,"binary":false,"changes":40,"status":"modified"}]}