{"files":[{"patch":"@@ -40,1 +40,1 @@\n-ciMethodData::ciMethodData(MethodData* md) : ciMetadata(md) {\n+ciMethodData::ciMethodData(MethodData* md) : ciMetadata(md), _orig() {\n@@ -42,1 +42,0 @@\n-  Copy::zero_to_words((HeapWord*) &_orig, sizeof(_orig) \/ sizeof(HeapWord));\n@@ -63,2 +62,1 @@\n-ciMethodData::ciMethodData() : ciMetadata(NULL) {\n-  Copy::zero_to_words((HeapWord*) &_orig, sizeof(_orig) \/ sizeof(HeapWord));\n+ciMethodData::ciMethodData() : ciMetadata(NULL), _orig() {\n@@ -229,1 +227,2 @@\n-  Copy::disjoint_words_atomic((HeapWord*) mdo,\n+  assert(sizeof(_orig) % HeapWordSize == 0, \"align\");\n+  Copy::disjoint_words_atomic((HeapWord*) &mdo->_header,\n","filename":"src\/hotspot\/share\/ci\/ciMethodData.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -408,1 +408,1 @@\n-  MethodData _orig;\n+  MethodData::MDHeader _orig;\n@@ -410,2 +410,1 @@\n-  \/\/ Area dedicated to parameters. NULL if no parameter profiling for\n-  \/\/ this method.\n+  \/\/ Area dedicated to parameters. NULL if no parameter profiling for this method.\n@@ -547,2 +546,2 @@\n-  uint trap_reason_limit() const { return _orig.trap_reason_limit(); }\n-  uint trap_count_limit()  const { return _orig.trap_count_limit(); }\n+  uint trap_reason_limit() const { return MethodData::trap_reason_limit(); }\n+  uint trap_count_limit()  const { return MethodData::trap_count_limit(); }\n","filename":"src\/hotspot\/share\/ci\/ciMethodData.hpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -289,1 +289,1 @@\n-    int actual_size = sizeof(MethodData);\n+    int actual_size = sizeof(MethodData::MDHeader);\n","filename":"src\/hotspot\/share\/ci\/ciReplay.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -240,4 +240,4 @@\n-  nonstatic_field(MethodData,                  _nof_decompiles,                               uint)                                  \\\n-  nonstatic_field(MethodData,                  _nof_overflow_recompiles,                      uint)                                  \\\n-  nonstatic_field(MethodData,                  _nof_overflow_traps,                           uint)                                  \\\n-  nonstatic_field(MethodData,                  _trap_hist._array[0],                          u1)                                    \\\n+  nonstatic_field(MethodData,                  _header._nof_decompiles,                       uint)                                  \\\n+  nonstatic_field(MethodData,                  _header._nof_overflow_recompiles,              uint)                                  \\\n+  nonstatic_field(MethodData,                  _header._nof_overflow_traps,                   uint)                                  \\\n+  nonstatic_field(MethodData,                  _header._trap_hist._array[0],                  u1)                                    \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"ci\/ciMethodData.hpp\"\n@@ -659,1 +660,1 @@\n-    MethodData(method, size, THREAD);\n+    MethodData(method);\n@@ -1205,2 +1206,3 @@\n-MethodData::MethodData(const methodHandle& method, int size, TRAPS)\n-  : _extra_data_lock(Mutex::leaf, \"MDO extra data lock\"),\n+MethodData::MethodData(const methodHandle& method)\n+  : _method(method()),\n+    _extra_data_lock(Mutex::leaf, \"MDO extra data lock\"),\n@@ -1208,2 +1210,0 @@\n-  \/\/ Set the method back-pointer.\n-  _method = method();\n@@ -1321,4 +1321,1 @@\n-  \/\/ Initialize flags and trap history.\n-  _nof_decompiles = 0;\n-  _nof_overflow_recompiles = 0;\n-  _nof_overflow_traps = 0;\n+  \/\/ Initialize escape flags.\n@@ -1326,3 +1323,0 @@\n-  assert(sizeof(_trap_hist) % sizeof(HeapWord) == 0, \"align\");\n-  Copy::zero_to_words((HeapWord*) &_trap_hist,\n-                      sizeof(_trap_hist) \/ sizeof(HeapWord));\n","filename":"src\/hotspot\/share\/oops\/methodData.cpp","additions":6,"deletions":12,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"utilities\/copy.hpp\"\n@@ -1933,0 +1934,2 @@\n+class ciMethodData;\n+\n@@ -1939,0 +1942,1 @@\n+  friend class ciMethodData;\n@@ -1954,1 +1958,1 @@\n-  MethodData(const methodHandle& method, int size, TRAPS);\n+  MethodData(const methodHandle& method);\n@@ -1957,1 +1961,0 @@\n-  MethodData() : _extra_data_lock(Mutex::leaf, \"MDO extra data lock\") {}; \/\/ For ciMethodData\n@@ -1968,0 +1971,65 @@\n+\n+  class MDHeader : public StackObj {\n+    friend class VMStructs;\n+    friend class JVMCIVMStructs;\n+\n+    int  _creation_mileage;           \/\/ method mileage at MDO creation\n+    uint _nof_decompiles;             \/\/ count of all nmethod removals\n+    uint _nof_overflow_recompiles;    \/\/ recompile count, excluding recomp. bits\n+    uint _nof_overflow_traps;         \/\/ trap count, excluding _trap_hist\n+    union {\n+      intptr_t _align;\n+      u1 _array[JVMCI_ONLY(2 *) MethodData::_trap_hist_limit];\n+    } _trap_hist;\n+\n+  public:\n+    MDHeader() : _nof_decompiles(0), _nof_overflow_recompiles(0), _nof_overflow_traps(0) {\n+      assert(sizeof(_trap_hist) % sizeof(HeapWord) == 0, \"align\");\n+      uint size_in_words = sizeof(_trap_hist) \/ HeapWordSize;\n+      Copy::zero_to_words((HeapWord*) &_trap_hist, size_in_words);\n+    }\n+\n+    int      creation_mileage() const { return _creation_mileage; }\n+    void set_creation_mileage(int x)  { _creation_mileage = x; }\n+\n+    \/\/ Return (uint)-1 for overflow.\n+    uint trap_count(int reason) const {\n+      assert((uint)reason < JVMCI_ONLY(2*) _trap_hist_limit, \"oob\");\n+      return (int)((_trap_hist._array[reason]+1) & _trap_hist_mask) - 1;\n+    }\n+\n+    uint inc_trap_count(int reason) {\n+      \/\/ Count another trap, anywhere in this method.\n+      assert(reason >= 0, \"must be single trap\");\n+      assert((uint)reason < JVMCI_ONLY(2*) _trap_hist_limit, \"oob\");\n+      uint cnt1 = 1 + _trap_hist._array[reason];\n+      if ((cnt1 & _trap_hist_mask) != 0) {  \/\/ if no counter overflow...\n+        _trap_hist._array[reason] = cnt1;\n+        return cnt1;\n+      } else {\n+        return _trap_hist_mask + (++_nof_overflow_traps);\n+      }\n+    }\n+\n+    uint overflow_trap_count() const {\n+      return _nof_overflow_traps;\n+    }\n+    uint overflow_recompile_count() const {\n+      return _nof_overflow_recompiles;\n+    }\n+    uint inc_overflow_recompile_count() {\n+      return ++_nof_overflow_recompiles;\n+    }\n+    uint decompile_count() const {\n+      return _nof_decompiles;\n+    }\n+    uint inc_decompile_count() {\n+      return ++_nof_decompiles;\n+    }\n+\n+    \/\/ Support for code generation\n+    static ByteSize trap_history_offset() {\n+      return byte_offset_of(MethodData, _header._trap_hist._array);\n+    }\n+  };\n+\n@@ -1969,7 +2037,1 @@\n-  uint _nof_decompiles;             \/\/ count of all nmethod removals\n-  uint _nof_overflow_recompiles;    \/\/ recompile count, excluding recomp. bits\n-  uint _nof_overflow_traps;         \/\/ trap count, excluding _trap_hist\n-  union {\n-    intptr_t _align;\n-    u1 _array[JVMCI_ONLY(2 *) _trap_hist_limit];\n-  } _trap_hist;\n+  MDHeader _header;\n@@ -1983,2 +2045,0 @@\n-  int _creation_mileage;              \/\/ method mileage at MDO creation\n-\n@@ -2129,2 +2189,2 @@\n-  int      creation_mileage() const  { return _creation_mileage; }\n-  void set_creation_mileage(int x)   { _creation_mileage = x; }\n+  int      creation_mileage() const { return _header.creation_mileage(); }\n+  void set_creation_mileage(int x)  { _header.set_creation_mileage(x); }\n@@ -2305,2 +2365,1 @@\n-    assert((uint)reason < JVMCI_ONLY(2*) _trap_hist_limit, \"oob\");\n-    return (int)((_trap_hist._array[reason]+1) & _trap_hist_mask) - 1;\n+    return _header.trap_count(reason);\n@@ -2312,10 +2371,1 @@\n-    \/\/ Count another trap, anywhere in this method.\n-    assert(reason >= 0, \"must be single trap\");\n-    assert((uint)reason < JVMCI_ONLY(2*) _trap_hist_limit, \"oob\");\n-    uint cnt1 = 1 + _trap_hist._array[reason];\n-    if ((cnt1 & _trap_hist_mask) != 0) {  \/\/ if no counter overflow...\n-      _trap_hist._array[reason] = cnt1;\n-      return cnt1;\n-    } else {\n-      return _trap_hist_mask + (++_nof_overflow_traps);\n-    }\n+    return _header.inc_trap_count(reason);\n@@ -2325,1 +2375,1 @@\n-    return _nof_overflow_traps;\n+    return _header.overflow_trap_count();\n@@ -2328,1 +2378,1 @@\n-    return _nof_overflow_recompiles;\n+    return _header.overflow_recompile_count();\n@@ -2330,2 +2380,2 @@\n-  void inc_overflow_recompile_count() {\n-    _nof_overflow_recompiles += 1;\n+  uint inc_overflow_recompile_count() {\n+    return _header.inc_overflow_recompile_count();\n@@ -2334,1 +2384,1 @@\n-    return _nof_decompiles;\n+    return _header.decompile_count();\n@@ -2336,3 +2386,3 @@\n-  void inc_decompile_count() {\n-    _nof_decompiles += 1;\n-    if (decompile_count() > (uint)PerMethodRecompilationCutoff) {\n+  uint inc_decompile_count() {\n+    uint dec_count = _header.inc_decompile_count();\n+    if (dec_count > (uint)PerMethodRecompilationCutoff) {\n@@ -2341,0 +2391,1 @@\n+    return dec_count;\n@@ -2366,1 +2417,1 @@\n-    return byte_offset_of(MethodData, _trap_hist._array);\n+    return MDHeader::trap_history_offset();\n","filename":"src\/hotspot\/share\/oops\/methodData.hpp","additions":85,"deletions":34,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -273,4 +273,4 @@\n-  nonstatic_field(MethodData,                  _nof_decompiles,                               uint)                                  \\\n-  nonstatic_field(MethodData,                  _nof_overflow_recompiles,                      uint)                                  \\\n-  nonstatic_field(MethodData,                  _nof_overflow_traps,                           uint)                                  \\\n-  nonstatic_field(MethodData,                  _trap_hist._array[0],                          u1)                                    \\\n+  nonstatic_field(MethodData,                  _header._nof_decompiles,                       uint)                                  \\\n+  nonstatic_field(MethodData,                  _header._nof_overflow_recompiles,              uint)                                  \\\n+  nonstatic_field(MethodData,                  _header._nof_overflow_traps,                   uint)                                  \\\n+  nonstatic_field(MethodData,                  _header._trap_hist._array[0],                  u1)                                    \\\n@@ -859,1 +859,1 @@\n-  nonstatic_field(ciMethodData,                _orig,                                         MethodData)                            \\\n+  nonstatic_field(ciMethodData,                _orig,                                         MethodData::MDHeader)                  \\\n@@ -1267,0 +1267,2 @@\n+  declare_type(MethodData::MDHeader, StackObj)                            \\\n+                                                                          \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -180,1 +180,1 @@\n-    final int methodDataOopTrapHistoryOffset = getFieldOffset(\"MethodData::_trap_hist._array[0]\", Integer.class, \"u1\");\n+    final int methodDataOopTrapHistoryOffset = getFieldOffset(\"MethodData::_header._trap_hist._array[0]\", Integer.class, \"u1\");\n@@ -183,3 +183,3 @@\n-    final int methodDataDecompiles = getFieldOffset(\"MethodData::_nof_decompiles\", Integer.class, \"uint\");\n-    final int methodDataOverflowRecompiles = getFieldOffset(\"MethodData::_nof_overflow_recompiles\", Integer.class, \"uint\");\n-    final int methodDataOverflowTraps = getFieldOffset(\"MethodData::_nof_overflow_traps\", Integer.class, \"uint\");\n+    final int methodDataDecompiles = getFieldOffset(\"MethodData::_header._nof_decompiles\", Integer.class, \"uint\");\n+    final int methodDataOverflowRecompiles = getFieldOffset(\"MethodData::_header._nof_overflow_recompiles\", Integer.class, \"uint\");\n+    final int methodDataOverflowTraps = getFieldOffset(\"MethodData::_header._nof_overflow_traps\", Integer.class, \"uint\");\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotVMConfig.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"}]}