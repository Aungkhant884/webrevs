{"files":[{"patch":"@@ -40,11 +40,3 @@\n-ciMethodData::ciMethodData(MethodData* md) : ciMetadata(md) {\n-  assert(md != NULL, \"no null method data\");\n-  Copy::zero_to_words((HeapWord*) &_orig, sizeof(_orig) \/ sizeof(HeapWord));\n-  _data = NULL;\n-  _data_size = 0;\n-  _extra_data_size = 0;\n-  _current_mileage = 0;\n-  _invocation_counter = 0;\n-  _backedge_counter = 0;\n-  _state = empty_state;\n-  _saw_free_extra_data = false;\n+ciMethodData::ciMethodData(MethodData* md)\n+: ciMetadata(md),\n+  _data_size(0), _extra_data_size(0), _data(NULL),\n@@ -53,1 +45,3 @@\n-  _hint_di = first_di();\n+  _hint_di(first_di()),\n+  _state(empty_state),\n+  _saw_free_extra_data(false),\n@@ -55,25 +49,6 @@\n-  _eflags = _arg_local = _arg_stack = _arg_returned = 0;\n-  _parameters = NULL;\n-}\n-\n-\/\/ ------------------------------------------------------------------\n-\/\/ ciMethodData::ciMethodData\n-\/\/\n-\/\/ No MethodData*.\n-ciMethodData::ciMethodData() : ciMetadata(NULL) {\n-  Copy::zero_to_words((HeapWord*) &_orig, sizeof(_orig) \/ sizeof(HeapWord));\n-  _data = NULL;\n-  _data_size = 0;\n-  _extra_data_size = 0;\n-  _current_mileage = 0;\n-  _invocation_counter = 0;\n-  _backedge_counter = 0;\n-  _state = empty_state;\n-  _saw_free_extra_data = false;\n-  \/\/ Set an initial hint. Don't use set_hint_di() because\n-  \/\/ first_di() may be out of bounds if data_size is 0.\n-  _hint_di = first_di();\n-  \/\/ Initialize the escape information (to \"don't know.\");\n-  _eflags = _arg_local = _arg_stack = _arg_returned = 0;\n-  _parameters = NULL;\n-}\n+  _eflags(0), _arg_local(0), _arg_stack(0), _arg_returned(0),\n+  _current_mileage(0),\n+  _invocation_counter(0),\n+  _backedge_counter(0),\n+  _orig(),\n+  _parameters(NULL) {}\n@@ -229,1 +204,2 @@\n-  Copy::disjoint_words_atomic((HeapWord*) mdo,\n+  static_assert(sizeof(_orig) % HeapWordSize == 0, \"align\");\n+  Copy::disjoint_words_atomic((HeapWord*) &mdo->_compiler_counters,\n","filename":"src\/hotspot\/share\/ci\/ciMethodData.cpp","additions":14,"deletions":38,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -393,4 +393,4 @@\n-  intx              _eflags;          \/\/ flags on escape information\n-  intx              _arg_local;       \/\/ bit set of non-escaping arguments\n-  intx              _arg_stack;       \/\/ bit set of stack-allocatable arguments\n-  intx              _arg_returned;    \/\/ bit set of returned arguments\n+  intx _eflags;       \/\/ flags on escape information\n+  intx _arg_local;    \/\/ bit set of non-escaping arguments\n+  intx _arg_stack;    \/\/ bit set of stack-allocatable arguments\n+  intx _arg_returned; \/\/ bit set of returned arguments\n@@ -408,1 +408,1 @@\n-  MethodData _orig;\n+  MethodData::CompilerCounters _orig;\n@@ -410,2 +410,1 @@\n-  \/\/ Area dedicated to parameters. NULL if no parameter profiling for\n-  \/\/ this method.\n+  \/\/ Area dedicated to parameters. NULL if no parameter profiling for this method.\n@@ -417,2 +416,1 @@\n-  ciMethodData(MethodData* md);\n-  ciMethodData();\n+  ciMethodData(MethodData* md = NULL);\n@@ -547,2 +545,2 @@\n-  uint trap_reason_limit() const { return _orig.trap_reason_limit(); }\n-  uint trap_count_limit()  const { return _orig.trap_count_limit(); }\n+  uint trap_reason_limit() const { return MethodData::trap_reason_limit(); }\n+  uint trap_count_limit()  const { return MethodData::trap_count_limit(); }\n","filename":"src\/hotspot\/share\/ci\/ciMethodData.hpp","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -289,1 +289,1 @@\n-    int actual_size = sizeof(MethodData);\n+    int actual_size = sizeof(MethodData::CompilerCounters);\n","filename":"src\/hotspot\/share\/ci\/ciReplay.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -240,4 +240,4 @@\n-  nonstatic_field(MethodData,                  _nof_decompiles,                               uint)                                  \\\n-  nonstatic_field(MethodData,                  _nof_overflow_recompiles,                      uint)                                  \\\n-  nonstatic_field(MethodData,                  _nof_overflow_traps,                           uint)                                  \\\n-  nonstatic_field(MethodData,                  _trap_hist._array[0],                          u1)                                    \\\n+  nonstatic_field(MethodData,                  _compiler_counters._nof_decompiles,            uint)                                  \\\n+  nonstatic_field(MethodData,                  _compiler_counters._nof_overflow_recompiles,   uint)                                  \\\n+  nonstatic_field(MethodData,                  _compiler_counters._nof_overflow_traps,        uint)                                  \\\n+  nonstatic_field(MethodData,                  _compiler_counters._trap_hist._array[0],       u1)                                    \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"ci\/ciMethodData.hpp\"\n@@ -659,1 +660,1 @@\n-    MethodData(method, size, THREAD);\n+    MethodData(method);\n@@ -1205,2 +1206,3 @@\n-MethodData::MethodData(const methodHandle& method, int size, TRAPS)\n-  : _extra_data_lock(Mutex::leaf, \"MDO extra data lock\"),\n+MethodData::MethodData(const methodHandle& method)\n+  : _method(method()),\n+    _extra_data_lock(Mutex::leaf, \"MDO extra data lock\"),\n@@ -1208,2 +1210,0 @@\n-  \/\/ Set the method back-pointer.\n-  _method = method();\n@@ -1321,4 +1321,1 @@\n-  \/\/ Initialize flags and trap history.\n-  _nof_decompiles = 0;\n-  _nof_overflow_recompiles = 0;\n-  _nof_overflow_traps = 0;\n+  \/\/ Initialize escape flags.\n@@ -1326,3 +1323,0 @@\n-  assert(sizeof(_trap_hist) % sizeof(HeapWord) == 0, \"align\");\n-  Copy::zero_to_words((HeapWord*) &_trap_hist,\n-                      sizeof(_trap_hist) \/ sizeof(HeapWord));\n","filename":"src\/hotspot\/share\/oops\/methodData.cpp","additions":6,"deletions":12,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"utilities\/copy.hpp\"\n@@ -1933,0 +1934,2 @@\n+class ciMethodData;\n+\n@@ -1939,0 +1942,1 @@\n+  friend class ciMethodData;\n@@ -1954,1 +1958,1 @@\n-  MethodData(const methodHandle& method, int size, TRAPS);\n+  MethodData(const methodHandle& method);\n@@ -1957,1 +1961,0 @@\n-  MethodData() : _extra_data_lock(Mutex::leaf, \"MDO extra data lock\") {}; \/\/ For ciMethodData\n@@ -1968,0 +1971,66 @@\n+\n+  \/\/ Compiler-related counters.\n+  class CompilerCounters {\n+    friend class VMStructs;\n+    friend class JVMCIVMStructs;\n+\n+    int  _creation_mileage;           \/\/ method mileage at MDO creation\n+    uint _nof_decompiles;             \/\/ count of all nmethod removals\n+    uint _nof_overflow_recompiles;    \/\/ recompile count, excluding recomp. bits\n+    uint _nof_overflow_traps;         \/\/ trap count, excluding _trap_hist\n+    union {\n+      intptr_t _align;\n+      u1 _array[JVMCI_ONLY(2 *) MethodData::_trap_hist_limit];\n+    } _trap_hist;\n+\n+  public:\n+    CompilerCounters() : _nof_decompiles(0), _nof_overflow_recompiles(0), _nof_overflow_traps(0) {\n+      static_assert(sizeof(_trap_hist) % HeapWordSize == 0, \"align\");\n+      uint size_in_words = sizeof(_trap_hist) \/ HeapWordSize;\n+      Copy::zero_to_words((HeapWord*) &_trap_hist, size_in_words);\n+    }\n+\n+    int      creation_mileage() const { return _creation_mileage; }\n+    void set_creation_mileage(int x)  { _creation_mileage = x; }\n+\n+    \/\/ Return (uint)-1 for overflow.\n+    uint trap_count(int reason) const {\n+      assert((uint)reason < JVMCI_ONLY(2*) _trap_hist_limit, \"oob\");\n+      return (int)((_trap_hist._array[reason]+1) & _trap_hist_mask) - 1;\n+    }\n+\n+    uint inc_trap_count(int reason) {\n+      \/\/ Count another trap, anywhere in this method.\n+      assert(reason >= 0, \"must be single trap\");\n+      assert((uint)reason < JVMCI_ONLY(2*) _trap_hist_limit, \"oob\");\n+      uint cnt1 = 1 + _trap_hist._array[reason];\n+      if ((cnt1 & _trap_hist_mask) != 0) {  \/\/ if no counter overflow...\n+        _trap_hist._array[reason] = cnt1;\n+        return cnt1;\n+      } else {\n+        return _trap_hist_mask + (++_nof_overflow_traps);\n+      }\n+    }\n+\n+    uint overflow_trap_count() const {\n+      return _nof_overflow_traps;\n+    }\n+    uint overflow_recompile_count() const {\n+      return _nof_overflow_recompiles;\n+    }\n+    uint inc_overflow_recompile_count() {\n+      return ++_nof_overflow_recompiles;\n+    }\n+    uint decompile_count() const {\n+      return _nof_decompiles;\n+    }\n+    uint inc_decompile_count() {\n+      return ++_nof_decompiles;\n+    }\n+\n+    \/\/ Support for code generation\n+    static ByteSize trap_history_offset() {\n+      return byte_offset_of(CompilerCounters, _trap_hist._array);\n+    }\n+  };\n+\n@@ -1969,7 +2038,1 @@\n-  uint _nof_decompiles;             \/\/ count of all nmethod removals\n-  uint _nof_overflow_recompiles;    \/\/ recompile count, excluding recomp. bits\n-  uint _nof_overflow_traps;         \/\/ trap count, excluding _trap_hist\n-  union {\n-    intptr_t _align;\n-    u1 _array[JVMCI_ONLY(2 *) _trap_hist_limit];\n-  } _trap_hist;\n+  CompilerCounters _compiler_counters;\n@@ -1983,2 +2046,0 @@\n-  int _creation_mileage;              \/\/ method mileage at MDO creation\n-\n@@ -2129,2 +2190,2 @@\n-  int      creation_mileage() const  { return _creation_mileage; }\n-  void set_creation_mileage(int x)   { _creation_mileage = x; }\n+  int      creation_mileage() const { return _compiler_counters.creation_mileage(); }\n+  void set_creation_mileage(int x)  { _compiler_counters.set_creation_mileage(x); }\n@@ -2305,2 +2366,1 @@\n-    assert((uint)reason < JVMCI_ONLY(2*) _trap_hist_limit, \"oob\");\n-    return (int)((_trap_hist._array[reason]+1) & _trap_hist_mask) - 1;\n+    return _compiler_counters.trap_count(reason);\n@@ -2312,10 +2372,1 @@\n-    \/\/ Count another trap, anywhere in this method.\n-    assert(reason >= 0, \"must be single trap\");\n-    assert((uint)reason < JVMCI_ONLY(2*) _trap_hist_limit, \"oob\");\n-    uint cnt1 = 1 + _trap_hist._array[reason];\n-    if ((cnt1 & _trap_hist_mask) != 0) {  \/\/ if no counter overflow...\n-      _trap_hist._array[reason] = cnt1;\n-      return cnt1;\n-    } else {\n-      return _trap_hist_mask + (++_nof_overflow_traps);\n-    }\n+    return _compiler_counters.inc_trap_count(reason);\n@@ -2325,1 +2376,1 @@\n-    return _nof_overflow_traps;\n+    return _compiler_counters.overflow_trap_count();\n@@ -2328,1 +2379,1 @@\n-    return _nof_overflow_recompiles;\n+    return _compiler_counters.overflow_recompile_count();\n@@ -2330,2 +2381,2 @@\n-  void inc_overflow_recompile_count() {\n-    _nof_overflow_recompiles += 1;\n+  uint inc_overflow_recompile_count() {\n+    return _compiler_counters.inc_overflow_recompile_count();\n@@ -2334,1 +2385,1 @@\n-    return _nof_decompiles;\n+    return _compiler_counters.decompile_count();\n@@ -2336,3 +2387,3 @@\n-  void inc_decompile_count() {\n-    _nof_decompiles += 1;\n-    if (decompile_count() > (uint)PerMethodRecompilationCutoff) {\n+  uint inc_decompile_count() {\n+    uint dec_count = _compiler_counters.inc_decompile_count();\n+    if (dec_count > (uint)PerMethodRecompilationCutoff) {\n@@ -2341,0 +2392,1 @@\n+    return dec_count;\n@@ -2366,1 +2418,1 @@\n-    return byte_offset_of(MethodData, _trap_hist._array);\n+    return byte_offset_of(MethodData, _compiler_counters) + CompilerCounters::trap_history_offset();\n","filename":"src\/hotspot\/share\/oops\/methodData.hpp","additions":86,"deletions":34,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -273,4 +273,4 @@\n-  nonstatic_field(MethodData,                  _nof_decompiles,                               uint)                                  \\\n-  nonstatic_field(MethodData,                  _nof_overflow_recompiles,                      uint)                                  \\\n-  nonstatic_field(MethodData,                  _nof_overflow_traps,                           uint)                                  \\\n-  nonstatic_field(MethodData,                  _trap_hist._array[0],                          u1)                                    \\\n+  nonstatic_field(MethodData,                  _compiler_counters._nof_decompiles,            uint)                                  \\\n+  nonstatic_field(MethodData,                  _compiler_counters._nof_overflow_recompiles,   uint)                                  \\\n+  nonstatic_field(MethodData,                  _compiler_counters._nof_overflow_traps,        uint)                                  \\\n+  nonstatic_field(MethodData,                  _compiler_counters._trap_hist._array[0],       u1)                                    \\\n@@ -859,1 +859,1 @@\n-  nonstatic_field(ciMethodData,                _orig,                                         MethodData)                            \\\n+  nonstatic_field(ciMethodData,                _orig,                                         MethodData::CompilerCounters)          \\\n@@ -1267,0 +1267,2 @@\n+  declare_toplevel_type(MethodData::CompilerCounters)                     \\\n+                                                                          \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -180,1 +180,1 @@\n-    final int methodDataOopTrapHistoryOffset = getFieldOffset(\"MethodData::_trap_hist._array[0]\", Integer.class, \"u1\");\n+    final int methodDataOopTrapHistoryOffset = getFieldOffset(\"MethodData::_compiler_counters._trap_hist._array[0]\", Integer.class, \"u1\");\n@@ -183,3 +183,3 @@\n-    final int methodDataDecompiles = getFieldOffset(\"MethodData::_nof_decompiles\", Integer.class, \"uint\");\n-    final int methodDataOverflowRecompiles = getFieldOffset(\"MethodData::_nof_overflow_recompiles\", Integer.class, \"uint\");\n-    final int methodDataOverflowTraps = getFieldOffset(\"MethodData::_nof_overflow_traps\", Integer.class, \"uint\");\n+    final int methodDataDecompiles = getFieldOffset(\"MethodData::_compiler_counters._nof_decompiles\", Integer.class, \"uint\");\n+    final int methodDataOverflowRecompiles = getFieldOffset(\"MethodData::_compiler_counters._nof_overflow_recompiles\", Integer.class, \"uint\");\n+    final int methodDataOverflowTraps = getFieldOffset(\"MethodData::_compiler_counters._nof_overflow_traps\", Integer.class, \"uint\");\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotVMConfig.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"}]}