{"files":[{"patch":"@@ -2254,0 +2254,1 @@\n+            TestFormat.checkNoReport(s > 1, \"Vector node size must be 2 or larger, but got \\\"\" + sizes[i] + \"\\\", in \\\"\" + sizeString + \"\\\"\");\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1057,1 +1057,1 @@\n-    @FailCount(2)\n+    @FailCount(8)\n@@ -1068,0 +1068,12 @@\n+    @IR(counts = {IRNode.LOAD_VI, IRNode.VECTOR_SIZE + \"min()\", \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    @IR(counts = {IRNode.LOAD_VI, IRNode.VECTOR_SIZE + \"min(max_for_type)\", \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    @IR(counts = {IRNode.LOAD_VI, IRNode.VECTOR_SIZE + \"2,4,8,16,32,64,max_int\", \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    @IR(counts = {IRNode.LOAD_VI, IRNode.VECTOR_SIZE + \"2,4,8,16,32,64,-3\", \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    @IR(counts = {IRNode.LOAD_VI, IRNode.VECTOR_SIZE + \"min(max_for_type, xxx)\", \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    @IR(counts = {IRNode.LOAD_VI, IRNode.VECTOR_SIZE + \"min(max_for_type, min(max_for_type, max_for_type))\", \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/TestBadFormat.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -45,1 +45,0 @@\n-\n@@ -49,1 +48,6 @@\n-\n+    \/\/ Explicitly take the maximum size for this type (here int)\n+    @IR(counts = {IRNode.LOAD_VI, IRNode.VECTOR_SIZE + \"max_for_type\", \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Exlicitly take the maximum size for the int type\n+    @IR(counts = {IRNode.LOAD_VI, IRNode.VECTOR_SIZE + \"max_int\", \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n@@ -53,3 +57,2 @@\n- \n-    \/\/ \n-    @IR(counts = {IRNode.LOAD_VI, IRNode.VECTOR_SIZE + \"\", \"> 0\"},\n+    \/\/ Specify comma separated list of numbers, match for any of them\n+    @IR(counts = {IRNode.LOAD_VI, IRNode.VECTOR_SIZE + \"2,4,8,16,32,64\", \"> 0\"},\n@@ -57,3 +60,2 @@\n-\n-    \/\/ \n-    @IR(counts = {IRNode.LOAD_VI, IRNode.VECTOR_SIZE + \"xxx\", \"> 0\"},\n+    \/\/ Two or more arguments to min(...): the minimal value is applied\n+    @IR(counts = {IRNode.LOAD_VI, IRNode.VECTOR_SIZE + \"min(max_for_type, max_int, LoopMaxUnroll, 64)\", \"> 0\"},\n@@ -61,1 +63,0 @@\n-\n@@ -69,3 +70,0 @@\n-}\n-\n-\n@@ -73,0 +71,22 @@\n+    @Test\n+    \/\/ By default, we search for the maximal size possible\n+    @IR(counts = {IRNode.LOAD_VF, \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    \/\/ In some cases, we can know the exact size, here 16\n+    @IR(counts = {IRNode.LOAD_VF, IRNode.VECTOR_SIZE_16, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \"=64\"},\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    @IR(counts = {IRNode.LOAD_VF, IRNode.VECTOR_SIZE_8, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \"=32\"},\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    \/\/ In some cases, we can know the exact size, here 4\n+    @IR(counts = {IRNode.LOAD_VF, IRNode.VECTOR_SIZE_4, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \"=16\"},\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    static float[] test1() {\n+        float[] a = new float[1024*8];\n+        for (int i = 0; i < a.length; i++) {\n+            a[i]++;\n+        }\n+        return a;\n+    }\n@@ -74,0 +94,25 @@\n+    @Test\n+    \/\/ In some cases, we can know the exact size, here 4\n+    @IR(counts = {IRNode.LOAD_VF, IRNode.VECTOR_SIZE_4, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">=16\"},\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Hence, we know any other sizes are impossible.\n+    \/\/ We can also specify that explicitly for failOn\n+    @IR(failOn = {IRNode.LOAD_VF, IRNode.VECTOR_SIZE_2,\n+                  IRNode.LOAD_VF, IRNode.VECTOR_SIZE_8,\n+                  IRNode.LOAD_VF, IRNode.VECTOR_SIZE_16,\n+                  IRNode.LOAD_VF, IRNode.VECTOR_SIZE_32,\n+                  IRNode.LOAD_VF, IRNode.VECTOR_SIZE_64,\n+                  IRNode.LOAD_VF, IRNode.VECTOR_SIZE + \"2,8,16,32,64\"},\n+        applyIf = {\"MaxVectorSize\", \">=16\"},\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    static float[] test2() {\n+        float[] a = new float[1024*8];\n+        for (int i = 0; i < a.length\/8; i++) {\n+            a[i*8 + 0]++; \/\/ block of 4, then gap of 4\n+            a[i*8 + 1]++;\n+            a[i*8 + 2]++;\n+            a[i*8 + 3]++;\n+        }\n+        return a;\n+    }\n@@ -75,0 +120,21 @@\n+    @Test\n+    \/\/ Here, we can pack at most 8 given the 8-blocks and 8-gaps.\n+    \/\/ But we can also never pack more than max_float\n+    @IR(counts = {IRNode.LOAD_VF, IRNode.VECTOR_SIZE + \"min(8, max_float)\", \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">=16\"},\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    static float[] test3() {\n+        float[] a = new float[1024*8];\n+        for (int i = 0; i < a.length\/16; i++) {\n+            a[i*16 + 0]++; \/\/ block of 8, then gap of 8\n+            a[i*16 + 1]++;\n+            a[i*16 + 2]++;\n+            a[i*16 + 3]++;\n+            a[i*16 + 4]++;\n+            a[i*16 + 5]++;\n+            a[i*16 + 6]++;\n+            a[i*16 + 7]++;\n+        }\n+        return a;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/TestVectorNode.java","additions":78,"deletions":12,"binary":false,"changes":90,"status":"modified"}]}