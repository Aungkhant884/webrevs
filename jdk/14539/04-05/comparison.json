{"files":[{"patch":"@@ -2286,22 +2286,12 @@\n-        switch (sizeTagString) {\n-        case \"max_for_type\":\n-            return String.valueOf(getMaxElementsForType(typeString, vmInfo));\n-        case \"max_byte\":\n-            return parseVectorNodeSizeTag(\"max_for_type\", \"byte\", vmInfo);\n-        case \"max_char\":\n-            return parseVectorNodeSizeTag(\"max_for_type\", \"char\", vmInfo);\n-        case \"max_short\":\n-            return parseVectorNodeSizeTag(\"max_for_type\", \"short\", vmInfo);\n-        case \"max_int\":\n-            return parseVectorNodeSizeTag(\"max_for_type\", \"int\", vmInfo);\n-        case \"max_long\":\n-            return parseVectorNodeSizeTag(\"max_for_type\", \"long\", vmInfo);\n-        case \"max_float\":\n-            return parseVectorNodeSizeTag(\"max_for_type\", \"float\", vmInfo);\n-        case \"max_double\":\n-            return parseVectorNodeSizeTag(\"max_for_type\", \"double\", vmInfo);\n-        case \"LoopMaxUnroll\":\n-            return String.valueOf(vmInfo.getLong(\"LoopMaxUnroll\", -1));\n-        default:\n-            return sizeTagString;\n-        }\n+        return switch (sizeTagString) {\n+            case \"max_for_type\"  -> String.valueOf(getMaxElementsForType(typeString, vmInfo));\n+            case \"max_byte\"      -> String.valueOf(getMaxElementsForType(\"byte\", vmInfo));\n+            case \"max_char\"      -> String.valueOf(getMaxElementsForType(\"char\", vmInfo));\n+            case \"max_short\"     -> String.valueOf(getMaxElementsForType(\"short\", vmInfo));\n+            case \"max_int\"       -> String.valueOf(getMaxElementsForType(\"int\", vmInfo));\n+            case \"max_long\"      -> String.valueOf(getMaxElementsForType(\"long\", vmInfo));\n+            case \"max_float\"     -> String.valueOf(getMaxElementsForType(\"float\", vmInfo));\n+            case \"max_double\"    -> String.valueOf(getMaxElementsForType(\"double\", vmInfo));\n+            case \"LoopMaxUnroll\" -> String.valueOf(vmInfo.getLong(\"LoopMaxUnroll\", -1));\n+            default              -> sizeTagString;\n+        };\n@@ -2349,15 +2339,7 @@\n-        switch (typeString) {\n-        case \"byte\":\n-            return 1;\n-        case \"char\":\n-        case \"short\":\n-            return 2;\n-        case \"int\":\n-        case \"float\":\n-            return 4;\n-        case \"long\":\n-        case \"double\":\n-            return 8;\n-        default:\n-            return 0;\n-        }\n+        return switch (typeString) {\n+            case \"byte\"           -> 1;\n+            case \"char\", \"short\"  -> 2;\n+            case \"int\", \"float\"   -> 4;\n+            case \"long\", \"double\" -> 8;\n+            default               -> 0;\n+        };\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":19,"deletions":37,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -63,8 +63,1 @@\n-            String irNode = IRNode.getIRNodeAccessString(node);\n-            int nextIndex = iterator.nextIndex();\n-            TestFormat.checkNoReport(iterator.hasNext(), \"Must provide additional value at index \" +\n-                                                         nextIndex + \" right after \" + irNode);\n-            CheckAttributeString userPostfix = new CheckAttributeString(iterator.next());\n-            TestFormat.checkNoReport(userPostfix.isValidUserPostfix(), \"Provided empty string for composite node \" +\n-                                                                       irNode + \" at index \" + nextIndex);\n-            return userPostfix;\n+            return readUserPostfixForCompositeIRNode(node);\n@@ -72,10 +65,1 @@\n-            String irNode = IRNode.getIRNodeAccessString(node);\n-            if (iterator.hasNext()) {\n-                String maybe_vt = iterator.next();\n-                if (IRNode.isVectorSize(maybe_vt)) {\n-                    return new CheckAttributeString(maybe_vt);\n-                }\n-                \/\/ If we do not find that pattern, then revert the iterator once\n-                iterator.previous();\n-            }\n-            return CheckAttributeString.invalid();\n+            return readUserPostfixForVectorIRNode(node);\n@@ -86,0 +70,23 @@\n+\n+    private final CheckAttributeString readUserPostfixForCompositeIRNode(String node) {\n+        String irNode = IRNode.getIRNodeAccessString(node);\n+        int nextIndex = iterator.nextIndex();\n+        TestFormat.checkNoReport(iterator.hasNext(), \"Must provide additional value at index \" +\n+                                                     nextIndex + \" right after \" + irNode);\n+        CheckAttributeString userPostfix = new CheckAttributeString(iterator.next());\n+        TestFormat.checkNoReport(userPostfix.isValidUserPostfix(), \"Provided empty string for composite node \" +\n+                                                                   irNode + \" at index \" + nextIndex);\n+        return userPostfix;\n+    }\n+\n+    private final CheckAttributeString readUserPostfixForVectorIRNode(String node) {\n+        if (iterator.hasNext()) {\n+            String maybeVectorType = iterator.next();\n+            if (IRNode.isVectorSize(maybeVectorType)) {\n+                return new CheckAttributeString(maybeVectorType);\n+            }\n+            \/\/ If we do not find that pattern, then revert the iterator once\n+            iterator.previous();\n+        }\n+        return CheckAttributeString.invalid();\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/checkattribute\/parsing\/CheckAttributeReader.java","additions":25,"deletions":18,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -61,16 +61,3 @@\n-                String type = IRNode.getVectorNodeType(node);\n-                TestFormat.checkNoReport(IRNode.getTypeSizeInBytes(type) > 0, \"Vector node's type must have valid type, got \\\"\" + type + \"\\\" for \\\"\" + node + \"\\\"\");\n-                String size;\n-                if (userPostfix.isValid()) {\n-                    String value = userPostfix.value();\n-                    TestFormat.checkNoReport(value.startsWith(IRNode.VECTOR_SIZE), \"Vector node's vector size must start with IRNode.VECTOR_SIZE, got: \\\"\" + value + \"\\\"\");\n-                    size = value.substring(2);\n-                } else {\n-                    size = vectorSizeDefault;\n-                }\n-                String size_regex = IRNode.parseVectorNodeSize(size, type, vmInfo);\n-                nodeRegex = nodeRegex.replaceAll(IRNode.IS_REPLACED, \"vector[A-Za-z]\\\\\\\\[\" + size_regex + \"\\\\\\\\]:\\\\\\\\{\" + type + \"\\\\\\\\}\");\n-            } else {\n-                if (userPostfix.isValid()) {\n-                    nodeRegex = nodeRegex.replaceAll(IRNode.IS_REPLACED, userPostfix.value());\n-                }\n+                nodeRegex = regexForVectorIRNode(nodeRegex, vmInfo, vectorSizeDefault);\n+            } else if (userPostfix.isValid()) {\n+                nodeRegex = nodeRegex.replaceAll(IRNode.IS_REPLACED, userPostfix.value());\n@@ -81,0 +68,18 @@\n+\n+    private String regexForVectorIRNode(String nodeRegex, VMInfo vmInfo, String vectorSizeDefault) {\n+        String type = IRNode.getVectorNodeType(node);\n+        TestFormat.checkNoReport(IRNode.getTypeSizeInBytes(type) > 0,\n+                                 \"Vector node's type must have valid type, got \\\"\" + type + \"\\\" for \\\"\" + node + \"\\\"\");\n+        String size;\n+        if (userPostfix.isValid()) {\n+            String value = userPostfix.value();\n+            TestFormat.checkNoReport(value.startsWith(IRNode.VECTOR_SIZE),\n+                                     \"Vector node's vector size must start with IRNode.VECTOR_SIZE, got: \\\"\" + value + \"\\\"\");\n+            size = value.substring(2);\n+        } else {\n+            size = vectorSizeDefault;\n+        }\n+        String size_regex = IRNode.parseVectorNodeSize(size, type, vmInfo);\n+        return nodeRegex.replaceAll(IRNode.IS_REPLACED,\n+                                    \"vector[A-Za-z]\\\\\\\\[\" + size_regex + \"\\\\\\\\]:\\\\\\\\{\" + type + \"\\\\\\\\}\");\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/checkattribute\/parsing\/RawIRNode.java","additions":21,"deletions":16,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import compiler.lib.ir_framework.shared.TestFormatException;\n@@ -59,21 +60,26 @@\n-        case \"<\":\n-            TestFormat.checkNoReport(comparison.getGivenValue() > 1, \"Node count comparison \\\"<\" + comparison.getGivenValue() + \"\\\" should be rewritten as \\\"=0\\\"\");\n-            return false; \/\/ any\n-        case \"<=\":\n-            TestFormat.checkNoReport(comparison.getGivenValue() >= 1, \"Node count comparison \\\"<=\" + comparison.getGivenValue() + \"\\\" should be rewritten as \\\"=0\\\"\");\n-            return false; \/\/ any\n-        case \"=\":\n-            \/\/ if 0, we expect none -> expect to not find any with any size\n-            return comparison.getGivenValue() > 0;\n-        case \">\":\n-            TestFormat.checkNoReport(comparison.getGivenValue() >= 0, \"Node count comparison \\\">\" + comparison.getGivenValue() + \"\\\" is useless, please only use positive numbers.\");\n-            return true; \/\/ max\n-        case \">=\":\n-            TestFormat.checkNoReport(comparison.getGivenValue() > 0, \"Node count comparison \\\">=\" + comparison.getGivenValue() + \"\\\" is useless, please only use strictly positive numbers with greater-equal.\");\n-            return true; \/\/ max\n-        case \"!=\":\n-            TestFormat.checkNoReport(false, \"Not-equal comparator not supported for node count: \\\"\" + comparison.getComparator() + \"\\\". Please rewrite the rule.\");\n-            return false; \/\/ any\n-        default:\n-            TestFormat.checkNoReport(false, \"Comparator not handled: \" + comparison.getComparator());\n-            return false; \/\/ any\n+            case \"<\" -> {\n+                TestFormat.checkNoReport(comparison.getGivenValue() > 1, \"Node count comparison \\\"<\" + comparison.getGivenValue() + \"\\\" should be rewritten as \\\"=0\\\"\");\n+                return false; \/\/ any\n+            }\n+            case \"<=\" -> {\n+                TestFormat.checkNoReport(comparison.getGivenValue() >= 1, \"Node count comparison \\\"<=\" + comparison.getGivenValue() + \"\\\" should be rewritten as \\\"=0\\\"\");\n+                return false; \/\/ any\n+            }\n+            case \"=\" -> {\n+                \/\/ if 0, we expect none -> expect to not find any with any size\n+                return comparison.getGivenValue() > 0;\n+            }\n+            case \">\" -> {\n+                TestFormat.checkNoReport(comparison.getGivenValue() >= 0, \"Node count comparison \\\">\" + comparison.getGivenValue() + \"\\\" is useless, please only use positive numbers.\");\n+                return true; \/\/ max\n+            }\n+            case \">=\" -> {\n+                TestFormat.checkNoReport(comparison.getGivenValue() > 0, \"Node count comparison \\\">=\" + comparison.getGivenValue() + \"\\\" is useless, please only use strictly positive numbers with greater-equal.\");\n+                return true; \/\/ max\n+            }\n+            case \"!=\" -> {\n+                throw new TestFormatException(\"Not-equal comparator not supported for node count: \\\"\" + comparison.getComparator() + \"\\\". Please rewrite the rule.\");\n+            }\n+            default -> {\n+                throw new TestFormatException(\"Comparator not handled: \" + comparison.getComparator());\n+            }\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/constraint\/raw\/RawCountsConstraint.java","additions":27,"deletions":21,"binary":false,"changes":48,"status":"modified"}]}