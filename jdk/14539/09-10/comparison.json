{"files":[{"patch":"@@ -75,9 +75,9 @@\n- *                              be directly specified in {@link #vectorNode}. For IR rules that are looking for a\n- *                              non-zero count of this node, the size is assumed to be the maximal number of elements\n- *                              that can fit in a vector of the specified type. This depends on the VM flag MaxVectorSize\n- *                              and CPU features. For IR rules that are looking for zero such nodes, or use failOn,\n- *                              there we match for any {@link #VECTOR_SIZE_ANY} size. This should be helpful in most cases\n- *                              to either check that there is vectorization at the widest vector-width possible, or no\n- *                              vectorization at all. If this is not sufficient, then one can use an additional argument\n- *                              to specify the size with {@link #VECTOR_SIZE}, followed by a size tag or comma separated\n- *                              list of sizes.\n+ *                              be directly specified in {@link #vectorNode}. The size can be specified directly with\n+ *                              an additional argument using {@link #VECTOR_SIZE}, followed by a size tag or a comma\n+ *                              separated list of sizes. If the size argument is not given, then a default size of\n+ *                              {@link #VECTOR_SIZE_MAX} is taken, which is the number of elements that can fit in a\n+ *                              vector of the specified type (depends on the VM flag MaxVectorSize and CPU features).\n+ *                              However, when using {@link IR#failOn} or {@link IR#counts()} with comparison {@code <},\n+ *                              or {@code <=} or {@code =0}, the default size is {@link #VECTOR_SIZE_ANY}, allowing any\n+ *                              size. The motivation for these default values is that in most cases one wants to have\n+ *                              vectorization with maximal vector width, or no vectorization of any vectro width.\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -74,0 +74,20 @@\n+#### Vector IR Nodes\n+For vector nodes, we not only check for the presence of the node, but also its type and size (number of elements in the vector). Every node has an associated type, for example `IRNode.LOAD_VI` has type `int` and `IRNode.LOAD_VF` has type `float`. The size can be explicitly specified as an additional argument. For example:\n+\n+```\n+@IR(counts = {IRNode.LOAD_VF, IRNode.VECTOR_SIZE_16, \"> 0\"},\n+    applyIf = {\"MaxVectorSize\", \"=64\"},\n+    applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+static float[] test() {\n+    float[] a = new float[1024*8];\n+    for (int i = 0; i < a.length; i++) {\n+        a[i]++;\n+    }\n+    return a;\n+}\n+```\n+\n+However, the size does not have to be specified. In most cases, one either wants to have vectorization at the maximal possible vector width, or no vectorization at all. Hence, the default size is `IRNode.VECTOR_SIZE_MAX`, except when using `failOn` or `counts` with comparisons `<`, `<=` or `=0`, where we have a default of `IRNode.VECTOR_SIZE_ANY`.\n+\n+More examples can be found in [IRExample](..\/..\/..\/testlibrary_tests\/ir_framework\/examples\/IRExample.java). You can also find many examples in the Vector API and SuperWord tests, when searching for `IRNode.VECTOR_SIZE` or `IRNode.LOAD_V`.\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/README.md","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -122,0 +122,103 @@\n+\n+    \/\/ Rules for vector nodes.\n+    @Test\n+    \/\/ By default, we search for the maximal size possible\n+    @IR(counts = {IRNode.LOAD_VI, \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    \/\/ We can also specify that we want the maximum explicitly\n+    @IR(counts = {IRNode.LOAD_VI, IRNode.VECTOR_SIZE_MAX, \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Explicitly take the maximum size for this type (here int)\n+    @IR(counts = {IRNode.LOAD_VI, IRNode.VECTOR_SIZE + \"max_for_type\", \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Exlicitly take the maximum size for the int type\n+    @IR(counts = {IRNode.LOAD_VI, IRNode.VECTOR_SIZE + \"max_int\", \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    \/\/ As a last resort, we can match with any size\n+    @IR(counts = {IRNode.LOAD_VI, IRNode.VECTOR_SIZE_ANY, \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Specify comma separated list of numbers, match for any of them\n+    @IR(counts = {IRNode.LOAD_VI, IRNode.VECTOR_SIZE + \"2,4,8,16,32,64\", \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Two or more arguments to min(...): the minimal value is applied\n+    @IR(counts = {IRNode.LOAD_VI, IRNode.VECTOR_SIZE + \"min(max_for_type, max_int, LoopMaxUnroll, 64)\", \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    static int[] testVectorNode() {\n+        int[] a = new int[1024*8];\n+        for (int i = 0; i < a.length; i++) {\n+            a[i]++;\n+        }\n+        return a;\n+    }\n+\n+    \/\/ Rules for vector nodes.\n+    @Test\n+    \/\/ By default, we search for the maximal size possible\n+    @IR(counts = {IRNode.LOAD_VF, \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    \/\/ In some cases, we can know the exact size, here 16\n+    @IR(counts = {IRNode.LOAD_VF, IRNode.VECTOR_SIZE_16, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \"=64\"},\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    @IR(counts = {IRNode.LOAD_VF, IRNode.VECTOR_SIZE_8, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \"=32\"},\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    \/\/ In some cases, we can know the exact size, here 4\n+    @IR(counts = {IRNode.LOAD_VF, IRNode.VECTOR_SIZE_4, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \"=16\"},\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    static float[] testVectorNodeExactSize1() {\n+        float[] a = new float[1024*8];\n+        for (int i = 0; i < a.length; i++) {\n+            a[i]++;\n+        }\n+        return a;\n+    }\n+\n+    \/\/ Rules for vector nodes. Same as badTestVectorNodeSize but with good rules.\n+    @Test\n+    \/\/ In some cases, we can know the exact size, here 4\n+    @IR(counts = {IRNode.LOAD_VF, IRNode.VECTOR_SIZE_4, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">=16\"},\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Hence, we know any other sizes are impossible.\n+    \/\/ We can also specify that explicitly for failOn\n+    @IR(failOn = {IRNode.LOAD_VF, IRNode.VECTOR_SIZE_2,\n+                  IRNode.LOAD_VF, IRNode.VECTOR_SIZE_8,\n+                  IRNode.LOAD_VF, IRNode.VECTOR_SIZE_16,\n+                  IRNode.LOAD_VF, IRNode.VECTOR_SIZE_32,\n+                  IRNode.LOAD_VF, IRNode.VECTOR_SIZE_64,\n+                  IRNode.LOAD_VF, IRNode.VECTOR_SIZE + \"2,8,16,32,64\"},\n+        applyIf = {\"MaxVectorSize\", \">=16\"},\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    static float[] testVectorNodeExactSize2() {\n+        float[] a = new float[1024*8];\n+        for (int i = 0; i < a.length\/8; i++) {\n+            a[i*8 + 0]++; \/\/ block of 4, then gap of 4\n+            a[i*8 + 1]++;\n+            a[i*8 + 2]++;\n+            a[i*8 + 3]++;\n+        }\n+        return a;\n+    }\n+\n+    @Test\n+    \/\/ Here, we can pack at most 8 given the 8-blocks and 8-gaps.\n+    \/\/ But we can also never pack more than max_float\n+    @IR(counts = {IRNode.LOAD_VF, IRNode.VECTOR_SIZE + \"min(8, max_float)\", \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">=16\"},\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    static float[] testVectorNodeSizeMinClause() {\n+        float[] a = new float[1024*8];\n+        for (int i = 0; i < a.length\/16; i++) {\n+            a[i*16 + 0]++; \/\/ block of 8, then gap of 8\n+            a[i*16 + 1]++;\n+            a[i*16 + 2]++;\n+            a[i*16 + 3]++;\n+            a[i*16 + 4]++;\n+            a[i*16 + 5]++;\n+            a[i*16 + 6]++;\n+            a[i*16 + 7]++;\n+        }\n+        return a;\n+    }\n@@ -197,0 +300,21 @@\n+\n+    \/\/ Failing rules for vector nodes. Same as testVectorNodeExactSize2 but with bad rules.\n+    @Test\n+    \/\/ By default we look for the IRNode.VECTOR_SIZE_MAX, which is more than 4.\n+    @IR(counts = {IRNode.LOAD_VF, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">16\"},\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    \/\/ By default, we look for IRNode.VECTOR_SIZE_ANY. But there is one of size 4.\n+    @IR(failOn = {IRNode.LOAD_VF},\n+        applyIf = {\"MaxVectorSize\", \">=16\"},\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    static float[] badTestVectorNodeSize() {\n+        float[] a = new float[1024*8];\n+        for (int i = 0; i < a.length\/8; i++) {\n+            a[i*8 + 0]++; \/\/ block of 4, then gap of 4\n+            a[i*8 + 1]++;\n+            a[i*8 + 2]++;\n+            a[i*8 + 3]++;\n+        }\n+        return a;\n+    }\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/examples\/IRExample.java","additions":124,"deletions":0,"binary":false,"changes":124,"status":"modified"},{"patch":"@@ -1,140 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8310308\n- * @summary Basic examples for vector node type and size verification\n- * @requires vm.compiler2.enabled\n- * @library \/test\/lib \/\n- * @run driver TestVectorNode\n- *\/\n-\n-import compiler.lib.ir_framework.*;\n-\n-public class TestVectorNode {\n-    public static void main(String args[]) {\n-        TestFramework.run();\n-    }\n-\n-    @Test\n-    \/\/ By default, we search for the maximal size possible\n-    @IR(counts = {IRNode.LOAD_VI, \"> 0\"},\n-        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n-    \/\/ We can also specify that we want the maximum explicitly\n-    @IR(counts = {IRNode.LOAD_VI, IRNode.VECTOR_SIZE_MAX, \"> 0\"},\n-        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n-    \/\/ Explicitly take the maximum size for this type (here int)\n-    @IR(counts = {IRNode.LOAD_VI, IRNode.VECTOR_SIZE + \"max_for_type\", \"> 0\"},\n-        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n-    \/\/ Exlicitly take the maximum size for the int type\n-    @IR(counts = {IRNode.LOAD_VI, IRNode.VECTOR_SIZE + \"max_int\", \"> 0\"},\n-        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n-    \/\/ As a last resort, we can match with any size\n-    @IR(counts = {IRNode.LOAD_VI, IRNode.VECTOR_SIZE_ANY, \"> 0\"},\n-        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n-    \/\/ Specify comma separated list of numbers, match for any of them\n-    @IR(counts = {IRNode.LOAD_VI, IRNode.VECTOR_SIZE + \"2,4,8,16,32,64\", \"> 0\"},\n-        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n-    \/\/ Two or more arguments to min(...): the minimal value is applied\n-    @IR(counts = {IRNode.LOAD_VI, IRNode.VECTOR_SIZE + \"min(max_for_type, max_int, LoopMaxUnroll, 64)\", \"> 0\"},\n-        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n-    static int[] test0() {\n-        int[] a = new int[1024*8];\n-        for (int i = 0; i < a.length; i++) {\n-            a[i]++;\n-        }\n-        return a;\n-    }\n-\n-    @Test\n-    \/\/ By default, we search for the maximal size possible\n-    @IR(counts = {IRNode.LOAD_VF, \"> 0\"},\n-        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n-    \/\/ In some cases, we can know the exact size, here 16\n-    @IR(counts = {IRNode.LOAD_VF, IRNode.VECTOR_SIZE_16, \"> 0\"},\n-        applyIf = {\"MaxVectorSize\", \"=64\"},\n-        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n-    @IR(counts = {IRNode.LOAD_VF, IRNode.VECTOR_SIZE_8, \"> 0\"},\n-        applyIf = {\"MaxVectorSize\", \"=32\"},\n-        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n-    \/\/ In some cases, we can know the exact size, here 4\n-    @IR(counts = {IRNode.LOAD_VF, IRNode.VECTOR_SIZE_4, \"> 0\"},\n-        applyIf = {\"MaxVectorSize\", \"=16\"},\n-        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n-    static float[] test1() {\n-        float[] a = new float[1024*8];\n-        for (int i = 0; i < a.length; i++) {\n-            a[i]++;\n-        }\n-        return a;\n-    }\n-\n-    @Test\n-    \/\/ In some cases, we can know the exact size, here 4\n-    @IR(counts = {IRNode.LOAD_VF, IRNode.VECTOR_SIZE_4, \"> 0\"},\n-        applyIf = {\"MaxVectorSize\", \">=16\"},\n-        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n-    \/\/ Hence, we know any other sizes are impossible.\n-    \/\/ We can also specify that explicitly for failOn\n-    @IR(failOn = {IRNode.LOAD_VF, IRNode.VECTOR_SIZE_2,\n-                  IRNode.LOAD_VF, IRNode.VECTOR_SIZE_8,\n-                  IRNode.LOAD_VF, IRNode.VECTOR_SIZE_16,\n-                  IRNode.LOAD_VF, IRNode.VECTOR_SIZE_32,\n-                  IRNode.LOAD_VF, IRNode.VECTOR_SIZE_64,\n-                  IRNode.LOAD_VF, IRNode.VECTOR_SIZE + \"2,8,16,32,64\"},\n-        applyIf = {\"MaxVectorSize\", \">=16\"},\n-        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n-    static float[] test2() {\n-        float[] a = new float[1024*8];\n-        for (int i = 0; i < a.length\/8; i++) {\n-            a[i*8 + 0]++; \/\/ block of 4, then gap of 4\n-            a[i*8 + 1]++;\n-            a[i*8 + 2]++;\n-            a[i*8 + 3]++;\n-        }\n-        return a;\n-    }\n-\n-    @Test\n-    \/\/ Here, we can pack at most 8 given the 8-blocks and 8-gaps.\n-    \/\/ But we can also never pack more than max_float\n-    @IR(counts = {IRNode.LOAD_VF, IRNode.VECTOR_SIZE + \"min(8, max_float)\", \"> 0\"},\n-        applyIf = {\"MaxVectorSize\", \">=16\"},\n-        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n-    static float[] test3() {\n-        float[] a = new float[1024*8];\n-        for (int i = 0; i < a.length\/16; i++) {\n-            a[i*16 + 0]++; \/\/ block of 8, then gap of 8\n-            a[i*16 + 1]++;\n-            a[i*16 + 2]++;\n-            a[i*16 + 3]++;\n-            a[i*16 + 4]++;\n-            a[i*16 + 5]++;\n-            a[i*16 + 6]++;\n-            a[i*16 + 7]++;\n-        }\n-        return a;\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/TestVectorNode.java","additions":0,"deletions":140,"binary":false,"changes":140,"status":"deleted"}]}