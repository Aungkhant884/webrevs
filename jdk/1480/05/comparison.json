{"files":[{"patch":"@@ -125,0 +125,1 @@\n+import com.sun.tools.classfile.MethodParameters_attribute;\n@@ -134,0 +135,2 @@\n+import com.sun.tools.classfile.Record_attribute;\n+import com.sun.tools.classfile.Record_attribute.ComponentInfo;\n@@ -962,0 +965,16 @@\n+        if (header.isRecord) {\n+            assert header.recordComponents != null;\n+            int attributeString = addString(constantPool, Attribute.Record);\n+            ComponentInfo[] recordComponents = new ComponentInfo[header.recordComponents.size()];\n+            int i = 0;\n+            for (RecordComponentDescription rcd : header.recordComponents) {\n+                int name = addString(constantPool, rcd.name);\n+                Descriptor desc = new Descriptor(addString(constantPool, rcd.descriptor));\n+                Map<String, Attribute> nestedAttrs = new HashMap<>();\n+                addGenericAttributes(rcd, constantPool, nestedAttrs);\n+                Attributes attrs = new Attributes(nestedAttrs);\n+                recordComponents[i++] = new ComponentInfo(name, desc, attrs);\n+            }\n+            attributes.put(Attribute.Record,\n+                           new Record_attribute(attributeString, recordComponents));\n+        }\n@@ -1020,0 +1039,12 @@\n+        if (desc.methodParameters != null && !desc.methodParameters.isEmpty()) {\n+            int attributeString =\n+                    addString(constantPool, Attribute.MethodParameters);\n+            MethodParameters_attribute.Entry[] entries =\n+                    desc.methodParameters\n+                        .stream()\n+                        .map(p -> new MethodParameters_attribute.Entry(addString(constantPool, p.name),\n+                                                                        p.flags))\n+                        .toArray(s -> new MethodParameters_attribute.Entry[s]);\n+            attributes.put(Attribute.MethodParameters,\n+                           new MethodParameters_attribute(attributeString, entries));\n+        }\n@@ -1598,1 +1629,3 @@\n-                        module.write(data, desc.basePlatform, desc.version);\n+                        if (module != null) { \/\/module == null should only be in tests.\n+                            module.write(data, desc.basePlatform, desc.version);\n+                        }\n@@ -2156,0 +2189,31 @@\n+            case Attribute.Record: {\n+                assert feature instanceof ClassHeaderDescription;\n+                Record_attribute record = (Record_attribute) attr;\n+                List<RecordComponentDescription> components = new ArrayList<>();\n+                for (ComponentInfo info : record.component_info_arr) {\n+                    RecordComponentDescription rcd = new RecordComponentDescription();\n+                    rcd.name = info.getName(cf.constant_pool);\n+                    rcd.descriptor = info.descriptor.getValue(cf.constant_pool);\n+                    for (Attribute nestedAttr : info.attributes) {\n+                        readAttribute(cf, rcd, nestedAttr);\n+                    }\n+                    components.add(rcd);\n+                }\n+                ClassHeaderDescription chd = (ClassHeaderDescription) feature;\n+                chd.isRecord = true;\n+                chd.recordComponents = components;\n+                break;\n+            }\n+            case Attribute.MethodParameters: {\n+                assert feature instanceof MethodDescription;\n+                MethodParameters_attribute params = (MethodParameters_attribute) attr;\n+                MethodDescription method = (MethodDescription) feature;\n+                method.methodParameters = new ArrayList<>();\n+                for (MethodParameters_attribute.Entry e : params.method_parameter_table) {\n+                    String name = cf.constant_pool.getUTF8Value(e.name_index);\n+                    MethodDescription.MethodParam param =\n+                            new MethodDescription.MethodParam(e.flags, name);\n+                    method.methodParameters.add(param);\n+                }\n+                break;\n+            }\n@@ -3002,0 +3066,2 @@\n+        boolean isRecord;\n+        List<RecordComponentDescription> recordComponents;\n@@ -3010,0 +3076,2 @@\n+            hash = 17 * hash + Objects.hashCode(this.isRecord);\n+            hash = 17 * hash + Objects.hashCode(this.recordComponents);\n@@ -3034,0 +3102,6 @@\n+            if (this.isRecord != other.isRecord) {\n+                return false;\n+            }\n+            if (!listEquals(this.recordComponents, other.recordComponents)) {\n+                return false;\n+            }\n@@ -3051,0 +3125,3 @@\n+            if (isRecord) {\n+                output.append(\" record true\");\n+            }\n@@ -3053,0 +3130,1 @@\n+            writeRecordComponents(output, baselineVersion, version);\n@@ -3068,0 +3146,1 @@\n+            isRecord = reader.attributes.containsKey(\"record\");\n@@ -3071,0 +3150,3 @@\n+            if (isRecord) {\n+                readRecordComponents(reader);\n+            }\n@@ -3076,0 +3158,19 @@\n+        protected void writeRecordComponents(Appendable output,\n+                                              String baselineVersion,\n+                                              String version) throws IOException {\n+            if (recordComponents != null) {\n+                for (RecordComponentDescription rcd : recordComponents) {\n+                    rcd.write(output, \"\", \"\");\n+                }\n+            }\n+        }\n+\n+        protected void readRecordComponents(LineBasedReader reader) throws IOException {\n+            recordComponents = new ArrayList<>();\n+\n+            while (\"recordcomponent\".equals(reader.lineKey)) {\n+                RecordComponentDescription rcd = new RecordComponentDescription();\n+                rcd.read(reader);\n+                recordComponents.add(rcd);\n+            }\n+        }\n@@ -3148,0 +3249,1 @@\n+        List<MethodParam> methodParameters;\n@@ -3224,0 +3326,9 @@\n+            if (methodParameters != null && !methodParameters.isEmpty()) {\n+                Function<MethodParam, String> param2String =\n+                        p -> Integer.toHexString(p.flags) + \":\" + p.name;\n+                List<String> paramsAsStrings =\n+                        methodParameters.stream()\n+                                         .map(param2String)\n+                                         .collect(Collectors.toList());\n+                output.append(\" methodParameters \" + serializeList(paramsAsStrings));\n+            }\n@@ -3271,0 +3382,14 @@\n+            String inMethodParameters = reader.attributes.get(\"methodParameters\");\n+            if (inMethodParameters != null) {\n+                Function<String, MethodParam> string2Param =\n+                        p -> {\n+                            int sep = p.indexOf(':');\n+                            return new MethodParam(Integer.parseInt(p.substring(0, sep)),\n+                                                    p.substring(sep + 1));\n+                        };\n+                methodParameters =\n+                        deserializeList(inMethodParameters).stream()\n+                                                          .map(string2Param)\n+                                                          .collect(Collectors.toList());\n+            }\n+\n@@ -3276,0 +3401,9 @@\n+        public static class MethodParam {\n+            public final int flags;\n+            public final String name;\n+\n+            public MethodParam(int flags, String name) {\n+                this.flags = flags;\n+                this.name = name;\n+            }\n+        }\n@@ -3282,0 +3416,1 @@\n+        String keyName = \"field\";\n@@ -3318,1 +3453,1 @@\n-                output.append(\"-field\");\n+                output.append(\"-\" + keyName);\n@@ -3324,1 +3459,1 @@\n-            output.append(\"field\");\n+            output.append(keyName);\n@@ -3336,1 +3471,1 @@\n-            if (!\"field\".equals(reader.lineKey))\n+            if (!keyName.equals(reader.lineKey))\n@@ -3369,0 +3504,13 @@\n+    static final class RecordComponentDescription extends FieldDescription {\n+\n+        public RecordComponentDescription() {\n+            this.keyName = \"recordcomponent\";\n+        }\n+\n+        @Override\n+        protected boolean shouldIgnore(String baselineVersion, String version) {\n+            return false;\n+        }\n+\n+    }\n+\n","filename":"make\/langtools\/src\/classes\/build\/tools\/symbolgenerator\/CreateSymbols.java","additions":152,"deletions":4,"binary":false,"changes":156,"status":"modified"},{"patch":"@@ -1,132 +0,0 @@\n-\/*\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8072480\n- * @summary Unit test for CreateSymbols\n- * @clean *\n- * @run main CreateSymbolsTest\n- *\/\n-\n-import java.io.IOException;\n-import java.net.URL;\n-import java.net.URLClassLoader;\n-import java.nio.file.FileVisitResult;\n-import java.nio.file.FileVisitor;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.nio.file.attribute.BasicFileAttributes;\n-import java.util.Arrays;\n-import javax.tools.JavaCompiler;\n-import javax.tools.StandardJavaFileManager;\n-import javax.tools.ToolProvider;\n-\n-public class CreateSymbolsTest {\n-\n-    static final String CREATE_SYMBOLS_NAME = \"symbolgenerator.CreateSymbols\";\n-\n-    public static void main(String... args) throws Exception {\n-        new CreateSymbolsTest().doRun();\n-    }\n-\n-    void doRun() throws Exception {\n-        Path testClasses = Paths.get(System.getProperty(\"test.classes\"));\n-        Path compileDir = testClasses.resolve(\"data\");\n-        deleteRecursively(compileDir);\n-        Files.createDirectories(compileDir);\n-        Path createSymbols = findFile(\"..\/..\/make\/src\/classes\/build\/tools\/symbolgenerator\/CreateSymbols.java\");\n-\n-        if (createSymbols == null) {\n-            System.err.println(\"Warning: cannot find CreateSymbols, skipping.\");\n-            return ;\n-        }\n-\n-        Path createTestImpl = findFile(\"..\/..\/make\/test\/sym\/CreateSymbolsTestImpl.java\");\n-\n-        if (createTestImpl == null) {\n-            System.err.println(\"Warning: cannot find CreateSymbolsTestImpl, skipping.\");\n-            return ;\n-        }\n-\n-        Path toolBox = findFile(\"..\/..\/test\/tools\/lib\/ToolBox.java\");\n-\n-        if (toolBox == null) {\n-            System.err.println(\"Warning: cannot find ToolBox, skipping.\");\n-            return ;\n-        }\n-\n-        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();\n-\n-        try (StandardJavaFileManager fm = compiler.getStandardFileManager(null, null, null)) {\n-            compiler.getTask(null,\n-                             null,\n-                             null,\n-                             Arrays.asList(\"-d\", compileDir.toAbsolutePath().toString()),\n-                             null,\n-                             fm.getJavaFileObjects(createSymbols, createTestImpl, toolBox)\n-                            ).call();\n-        }\n-\n-        URLClassLoader cl = new URLClassLoader(new URL[] {testClasses.toUri().toURL(), compileDir.toUri().toURL()});\n-        Class<?> createSymbolTest = cl.loadClass(\"CreateSymbolsTestImpl\");\n-\n-        createSymbolTest.getMethod(\"main\", String[].class).invoke(null, (Object) new String[0]);\n-    }\n-\n-    Path findFile(String path) {\n-        Path testSrc = Paths.get(System.getProperty(\"test.src\", \".\"));\n-\n-        for (Path d = testSrc; d != null; d = d.getParent()) {\n-            if (Files.exists(d.resolve(\"TEST.ROOT\"))) {\n-                Path createSymbols = d.resolve(path);\n-                if (Files.exists(createSymbols)) {\n-                    return createSymbols;\n-                }\n-            }\n-        }\n-\n-        return null;\n-    }\n-\n-    void deleteRecursively(Path dir) throws IOException {\n-        Files.walkFileTree(dir, new FileVisitor<Path>() {\n-            @Override\n-            public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {\n-                return FileVisitResult.CONTINUE;\n-            }\n-            @Override public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n-                Files.delete(file);\n-                return FileVisitResult.CONTINUE;\n-            }\n-            @Override public FileVisitResult visitFileFailed(Path file, IOException exc) throws IOException {\n-                return FileVisitResult.CONTINUE;\n-            }\n-            @Override public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {\n-                Files.delete(dir);\n-                return FileVisitResult.CONTINUE;\n-            }\n-        });\n-    }\n-}\n","filename":"make\/langtools\/test\/sym\/CreateSymbolsTest.java","additions":0,"deletions":132,"binary":false,"changes":132,"status":"deleted"},{"patch":"@@ -1,611 +0,0 @@\n-\/*\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.io.File;\n-import java.io.InputStream;\n-import java.io.Writer;\n-import java.lang.annotation.Retention;\n-import java.lang.annotation.RetentionPolicy;\n-import java.lang.reflect.Method;\n-import java.util.Arrays;\n-import java.util.List;\n-import com.sun.tools.javac.file.ZipFileIndexCache;\n-import java.io.IOException;\n-import java.nio.file.FileVisitResult;\n-import java.nio.file.FileVisitor;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.nio.file.attribute.BasicFileAttributes;\n-import java.util.HashSet;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-import build.tools.symbolgenerator.CreateSymbols;\n-import build.tools.symbolgenerator.CreateSymbols.ClassDescription;\n-import build.tools.symbolgenerator.CreateSymbols.ClassList;\n-import build.tools.symbolgenerator.CreateSymbols.CtSymKind;\n-import build.tools.symbolgenerator.CreateSymbols.ExcludeIncludeList;\n-import build.tools.symbolgenerator.CreateSymbols.VersionDescription;\n-\n-public class CreateSymbolsTestImpl {\n-\n-    static final String CREATE_SYMBOLS_NAME = \"symbolgenerator.CreateSymbols\";\n-\n-    public static void main(String... args) throws Exception {\n-        new CreateSymbolsTestImpl().doTest();\n-    }\n-\n-    void doTest() throws Exception {\n-        boolean testRun = false;\n-        for (Method m : CreateSymbolsTestImpl.class.getDeclaredMethods()) {\n-            if (!\"testIncluded\".equals(m.getName()))\n-                continue;\n-            if (m.isAnnotationPresent(Test.class)) {\n-                m.invoke(this);\n-                testRun = true;\n-            }\n-        }\n-        if (!testRun) {\n-            throw new IllegalStateException(\"No tests found.\");\n-        }\n-    }\n-\n-    @Test\n-    void testMethodRemoved() throws Exception {\n-        doTest(\"package t; public class T { public void m() { } }\",\n-               \"package t; public class T { }\",\n-               \"package t; public class Test { { T t = null; t.m(); } }\",\n-               ToolBox.Expect.SUCCESS,\n-               ToolBox.Expect.FAIL);\n-        doTest(\"package t; public class T { public void b() { } public void m() { } public void a() { } }\",\n-               \"package t; public class T { public void b() { }                     public void a() { } }\",\n-               \"package t; public class Test { { T t = null; t.b(); t.a(); } }\",\n-               ToolBox.Expect.SUCCESS,\n-               ToolBox.Expect.SUCCESS);\n-        \/\/with additional attribute (need to properly skip the member):\n-        doTest(\"package t; public class T { public void m() throws IllegalStateException { } public void a() { } }\",\n-               \"package t; public class T {                                                  public void a() { } }\",\n-               \"package t; public class Test { { T t = null; t.a(); } }\",\n-               ToolBox.Expect.SUCCESS,\n-               ToolBox.Expect.SUCCESS);\n-    }\n-\n-    @Test\n-    void testMethodAdded() throws Exception {\n-        doTest(\"package t; public class T { }\",\n-               \"package t; public class T { public void m() { } }\",\n-               \"package t; public class Test { { T t = null; t.m(); } }\",\n-               ToolBox.Expect.FAIL,\n-               ToolBox.Expect.SUCCESS);\n-        doTest(\"package t; public class T { public void b() { }                     public void a() { } }\",\n-               \"package t; public class T { public void b() { } public void m() { } public void a() { } }\",\n-               \"package t; public class Test { { T t = null; t.b(); t.a(); } }\",\n-               ToolBox.Expect.SUCCESS,\n-               ToolBox.Expect.SUCCESS);\n-    }\n-\n-    \/\/verify fields added\/modified\/removed\n-\n-    @Test\n-    void testClassAdded() throws Exception {\n-        doTest(\"class Dummy {}\",\n-               \"package t; public class T { }\",\n-               \"package t; public class Test { { T t = new T(); } }\",\n-               ToolBox.Expect.FAIL,\n-               ToolBox.Expect.SUCCESS);\n-    }\n-\n-    @Test\n-    void testClassModified() throws Exception {\n-        doTest(\"package t; public class T { public void m() { } }\",\n-               \"package t; public class T implements java.io.Serializable { public void m() { } }\",\n-               \"package t; public class Test { { java.io.Serializable t = new T(); } }\",\n-               ToolBox.Expect.FAIL,\n-               ToolBox.Expect.SUCCESS);\n-    }\n-\n-    @Test\n-    void testClassRemoved() throws Exception {\n-        doTest(\"package t; public class T { }\",\n-               \"class Dummy {}\",\n-               \"package t; public class Test { { T t = new T(); } }\",\n-               ToolBox.Expect.SUCCESS,\n-               ToolBox.Expect.FAIL);\n-    }\n-\n-    @Test\n-    void testInnerClassAttributes() throws Exception {\n-        doTest(\"package t; public class T { public static class Inner { } }\",\n-               \"package t; public class T { public static class Inner { } }\",\n-               \"package t; import t.T.Inner; public class Test { Inner i; }\",\n-               ToolBox.Expect.SUCCESS,\n-               ToolBox.Expect.SUCCESS);\n-    }\n-\n-    @Test\n-    void testConstantAdded() throws Exception {\n-        doTest(\"package t; public class T { }\",\n-               \"package t; public class T { public static final int A = 0; }\",\n-               \"package t; public class Test { void t(int i) { switch (i) { case T.A: break;} } }\",\n-               ToolBox.Expect.FAIL,\n-               ToolBox.Expect.SUCCESS);\n-    }\n-\n-    @Test\n-    void testAnnotationAttributeDefaultvalue() throws Exception {\n-        \/\/TODO: this only verifies that there is *some* value, but we should also verify there is a specific value:\n-        doTest(\"package t; public @interface T { }\",\n-               \"package t;\\n\" +\n-               \"public @interface T {\\n\" +\n-               \"    public boolean booleanValue() default true;\\n\" +\n-               \"    public byte byteValue() default 1;\\n\" +\n-               \"    public char charValue() default 2;\\n\" +\n-               \"    public short shortValue() default 3;\\n\" +\n-               \"    public int intValue() default 4;\\n\" +\n-               \"    public long longValue() default 5;\\n\" +\n-               \"    public float floatValue() default 6;\\n\" +\n-               \"    public double doubleValue() default 7;\\n\" +\n-               \"    public String stringValue() default \\\"8\\\";\\n\" +\n-               \"    public java.lang.annotation.RetentionPolicy enumValue() default java.lang.annotation.RetentionPolicy.RUNTIME;\\n\" +\n-               \"    public Class classValue() default Number.class;\\n\" +\n-               \"    public int[] arrayValue() default {1, 2};\\n\" +\n-               \"    public SuppressWarnings annotationValue() default @SuppressWarnings(\\\"cast\\\");\\n\" +\n-               \"}\\n\",\n-               \"package t; public @T class Test { }\",\n-               ToolBox.Expect.SUCCESS,\n-               ToolBox.Expect.SUCCESS);\n-    }\n-\n-    @Test\n-    void testConstantTest() throws Exception {\n-        \/\/XXX: other constant types (String in particular) - see testStringConstant\n-        doPrintElementTest(\"package t; public class T { public static final int A = 1; }\",\n-                           \"package t; public class T { public static final int A = 2; }\",\n-                           \"t.T\",\n-                           \"package t;\\n\\n\" +\n-                           \"public class T {\\n\" +\n-                           \"  public static final int A = 1;\\n\\n\" +\n-                           \"  public T();\\n\" +\n-                           \"}\\n\",\n-                           \"t.T\",\n-                           \"package t;\\n\\n\" +\n-                           \"public class T {\\n\" +\n-                           \"  public static final int A = 2;\\n\\n\" +\n-                           \"  public T();\\n\" +\n-                           \"}\\n\");\n-        doPrintElementTest(\"package t; public class T { public static final boolean A = false; }\",\n-                           \"package t; public class T { public static final boolean A = true; }\",\n-                           \"t.T\",\n-                           \"package t;\\n\\n\" +\n-                           \"public class T {\\n\" +\n-                           \"  public static final boolean A = false;\\n\\n\" +\n-                           \"  public T();\\n\" +\n-                           \"}\\n\",\n-                           \"t.T\",\n-                           \"package t;\\n\\n\" +\n-                           \"public class T {\\n\" +\n-                           \"  public static final boolean A = true;\\n\\n\" +\n-                           \"  public T();\\n\" +\n-                           \"}\\n\");\n-    }\n-\n-    @Test\n-    void testAnnotations() throws Exception {\n-        doPrintElementTest(\"package t;\" +\n-                           \"import java.lang.annotation.*;\" +\n-                           \"public @Visible @Invisible class T { }\" +\n-                           \"@Retention(RetentionPolicy.RUNTIME) @interface Visible { }\" +\n-                           \"@Retention(RetentionPolicy.CLASS) @interface Invisible { }\",\n-                           \"package t;\" +\n-                           \"import java.lang.annotation.*;\" +\n-                           \"public @Visible @Invisible class T { }\" +\n-                           \"@Retention(RetentionPolicy.RUNTIME) @interface Visible { }\" +\n-                           \"@Retention(RetentionPolicy.CLASS) @interface Invisible { }\",\n-                           \"t.T\",\n-                           \"package t;\\n\\n\" +\n-                           \"@t.Invisible\\n\" +\n-                           \"@t.Visible\\n\" +\n-                           \"public class T {\\n\\n\" +\n-                           \"  public T();\\n\" +\n-                           \"}\\n\",\n-                           \"t.Visible\",\n-                           \"package t;\\n\\n\" +\n-                           \"@java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME)\\n\" +\n-                           \"@interface Visible {\\n\" +\n-                           \"}\\n\");\n-        doPrintElementTest(\"package t;\" +\n-                           \"import java.lang.annotation.*;\" +\n-                           \"import java.util.*;\" +\n-                           \"public class T {\" +\n-                           \"    public void test(int h, @Invisible int i, @Visible List<String> j, int k) { }\" +\n-                           \"}\" +\n-                           \"@Retention(RetentionPolicy.RUNTIME) @interface Visible { }\" +\n-                           \"@Retention(RetentionPolicy.CLASS) @interface Invisible { }\",\n-                           \"package t;\" +\n-                           \"import java.lang.annotation.*;\" +\n-                           \"import java.util.*;\" +\n-                           \"public class T {\" +\n-                           \"    public void test(int h, @Invisible int i, @Visible List<String> j, int k) { }\" +\n-                           \"}\" +\n-                           \"@Retention(RetentionPolicy.RUNTIME) @interface Visible { }\" +\n-                           \"@Retention(RetentionPolicy.CLASS) @interface Invisible { }\",\n-                           \"t.T\",\n-                           \"package t;\\n\\n\" +\n-                           \"public class T {\\n\\n\" +\n-                           \"  public T();\\n\\n\" +\n-                           \"  public void test(int arg0,\\n\" +\n-                           \"    @t.Invisible int arg1,\\n\" +\n-                           \"    @t.Visible java.util.List<java.lang.String> arg2,\\n\" +\n-                           \"    int arg3);\\n\" +\n-                           \"}\\n\",\n-                           \"t.Visible\",\n-                           \"package t;\\n\\n\" +\n-                           \"@java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME)\\n\" +\n-                           \"@interface Visible {\\n\" +\n-                           \"}\\n\");\n-        doPrintElementTest(\"package t;\" +\n-                           \"import java.lang.annotation.*;\" +\n-                           \"public class T {\" +\n-                           \"    public void test(@Ann(v=\\\"url\\\", dv=\\\"\\\\\\\"\\\\\\\"\\\") String str) { }\" +\n-                           \"}\" +\n-                           \"@Retention(RetentionPolicy.RUNTIME) @interface Ann {\" +\n-                           \"    public String v();\" +\n-                           \"    public String dv();\" +\n-                           \"}\",\n-                           \"package t;\" +\n-                           \"public class T { }\",\n-                           \"t.T\",\n-                           \"package t;\\n\\n\" +\n-                           \"public class T {\\n\\n\" +\n-                           \"  public T();\\n\\n\" +\n-                           \"  public void test(@t.Ann(dv=\\\"\\\\\\\"\\\\\\\"\\\", v=\\\"url\\\") java.lang.String arg0);\\n\" +\n-                           \"}\\n\",\n-                           \"t.T\",\n-                           \"package t;\\n\\n\" +\n-                           \"public class T {\\n\\n\" +\n-                           \"  public T();\\n\" +\n-                           \"}\\n\");\n-    }\n-\n-    @Test\n-    void testStringConstant() throws Exception {\n-        doTest(\"package t; public class T { public static final String C = \\\"\\\"; }\",\n-               \"package t; public class T { public static final String C = \\\"\\\"; }\",\n-               \"package t; public class Test { { System.err.println(T.C); } }\",\n-                ToolBox.Expect.SUCCESS,\n-                ToolBox.Expect.SUCCESS);\n-    }\n-\n-    @Test\n-    void testCopyProfileAnnotation() throws Exception {\n-        String oldProfileAnnotation = CreateSymbols.PROFILE_ANNOTATION;\n-        try {\n-            CreateSymbols.PROFILE_ANNOTATION = \"Lt\/Ann;\";\n-            doTestEquivalence(\"package t; public class T { public void t() {} } @interface Ann { }\",\n-                              \"package t; public @Ann class T { public void t() {} } @interface Ann { }\",\n-                              \"t.T\");\n-        } finally {\n-            CreateSymbols.PROFILE_ANNOTATION = oldProfileAnnotation;\n-        }\n-    }\n-\n-    @Test\n-    void testParseAnnotation() throws Exception {\n-        CreateSymbols.parseAnnotations(\"@Lsun\/Proprietary+Annotation;@Ljdk\/Profile+Annotation;(value=I1)\", new int[1]);\n-        CreateSymbols.parseAnnotations(\"@Ltest;(value={\\\"\\\"})\", new int[1]);\n-        CreateSymbols.parseAnnotations(\"@Ljava\/beans\/ConstructorProperties;(value={\\\"path\\\"})\", new int[1]);\n-        CreateSymbols.parseAnnotations(\"@Ljava\/beans\/ConstructorProperties;(value=I-2)\", new int[1]);\n-    }\n-\n-    @Test\n-    void testStringCharLiterals() throws Exception {\n-        doPrintElementTest(\"package t;\" +\n-                           \"public class T {\" +\n-                           \"    public static final String STR = \\\"\\\\u0000\\\\u0001\\\\uffff\\\";\" +\n-                           \"    public static final String EMPTY = \\\"\\\";\" +\n-                           \"    public static final String AMP = \\\"&amp;&&lt;<&gt;>&apos;'\\\";\" +\n-                           \"}\",\n-                           \"package t;\" +\n-                           \"    public class T {\" +\n-                           \"    public static final char c = '\\\\uffff';\" +\n-                           \"}\",\n-                           \"t.T\",\n-                           \"package t;\\n\\n\" +\n-                           \"public class T {\\n\" +\n-                           \"  public static final java.lang.String STR = \\\"\\\\u0000\\\\u0001\\\\uffff\\\";\\n\" +\n-                           \"  public static final java.lang.String EMPTY = \\\"\\\";\\n\" +\n-                           \"  public static final java.lang.String AMP = \\\"&amp;&&lt;<&gt;>&apos;\\\\'\\\";\\n\\n\" +\n-                           \"  public T();\\n\" +\n-                           \"}\\n\",\n-                           \"t.T\",\n-                           \"package t;\\n\\n\" +\n-                           \"public class T {\\n\" +\n-                           \"  public static final char c = '\\\\uffff';\\n\\n\" +\n-                           \"  public T();\\n\" +\n-                           \"}\\n\");\n-    }\n-\n-    @Test\n-    void testGenerification() throws Exception {\n-        doTest(\"package t; public class T { public class TT { public Object t() { return null; } } }\",\n-               \"package t; public class T<E> { public class TT { public E t() { return null; } } }\",\n-               \"package t; public class Test { { T.TT tt = null; tt.t(); } }\",\n-               ToolBox.Expect.SUCCESS,\n-               ToolBox.Expect.SUCCESS);\n-    }\n-\n-    int i = 0;\n-\n-    void doTest(String code7, String code8, String testCode, ToolBox.Expect result7, ToolBox.Expect result8) throws Exception {\n-        ToolBox tb = new ToolBox();\n-        Path classes = prepareVersionedCTSym(code7, code8);\n-        Path output = classes.getParent();\n-        Path scratch = output.resolve(\"scratch\");\n-\n-        Files.createDirectories(scratch);\n-\n-        tb.new JavacTask()\n-          .sources(testCode)\n-          .options(\"-d\", scratch.toAbsolutePath().toString(), \"-classpath\", computeClassPath(classes, \"7\"), \"-XDuseOptimizedZip=false\")\n-          .run(result7)\n-          .writeAll();\n-        tb.new JavacTask()\n-          .sources(testCode)\n-          .options(\"-d\", scratch.toAbsolutePath().toString(), \"-classpath\", computeClassPath(classes, \"8\"), \"-XDuseOptimizedZip=false\")\n-          .run(result8)\n-          .writeAll();\n-    }\n-\n-    private static String computeClassPath(Path classes, String version) throws IOException {\n-        try (Stream<Path> elements = Files.list(classes)) {\n-            return elements.map(el -> el.toAbsolutePath().toString())\n-                           .collect(Collectors.joining(File.pathSeparator));\n-        }\n-    }\n-\n-    void doPrintElementTest(String code7, String code8, String className7, String printed7, String className8, String printed8) throws Exception {\n-        ToolBox tb = new ToolBox();\n-        Path classes = prepareVersionedCTSym(code7, code8);\n-        Path output = classes.getParent();\n-        Path scratch = output.resolve(\"scratch\");\n-\n-        Files.createDirectories(scratch);\n-\n-        String out;\n-        out = tb.new JavacTask(ToolBox.Mode.CMDLINE)\n-                .options(\"-d\", scratch.toAbsolutePath().toString(), \"-classpath\", computeClassPath(classes, \"7\"), \"-XDuseOptimizedZip=false\", \"-Xprint\", className7)\n-                .run(ToolBox.Expect.SUCCESS)\n-                .getOutput(ToolBox.OutputKind.STDOUT);\n-        if (!out.equals(printed7)) {\n-            throw new AssertionError(\"out=\" + out + \"; printed7=\" + printed7);\n-        }\n-        out = tb.new JavacTask(ToolBox.Mode.CMDLINE)\n-                .options(\"-d\", scratch.toAbsolutePath().toString(), \"-classpath\", computeClassPath(classes, \"8\"), \"-XDuseOptimizedZip=false\", \"-Xprint\", className8)\n-                .run(ToolBox.Expect.SUCCESS)\n-                .getOutput(ToolBox.OutputKind.STDOUT);\n-        if (!out.equals(printed8)) {\n-            throw new AssertionError(\"out=\" + out + \"; printed8=\" + printed8);\n-        }\n-    }\n-\n-    void doTestEquivalence(String code7, String code8, String testClass) throws Exception {\n-        Path classes = prepareVersionedCTSym(code7, code8);\n-        Path classfile = classes.resolve(\"78\").resolve(testClass.replace('.', '\/') + \".class\");\n-\n-        if (!Files.isReadable(classfile)) {\n-            throw new AssertionError(\"Cannot find expected class.\");\n-        }\n-    }\n-\n-    @Test\n-    void testIncluded() throws Exception {\n-        doTestIncluded(\"package t;\\n\" +\n-                       \"public class Test extends PP1<PP2> implements PP3<PP4>, PP5<PP6> {\\n\" +\n-                       \"     public PP7 m1(PP8 p) { return null;}\\n\" +\n-                       \"     public PP9<PPA> m2(PPB<PPC> p) { return null;}\\n\" +\n-                       \"     public PPD f1;\\n\" +\n-                       \"     public PPE<PPF> f2;\\n\" +\n-                       \"     public Test2 aux;\\n\" +\n-                       \"}\\n\" +\n-                       \"class Test2 extends PPG implements PPH, PPI {\\n\" +\n-                       \"}\\n\" +\n-                       \"class PP1<T> {}\\n\" +\n-                       \"class PP2 {}\\n\" +\n-                       \"interface PP3<T> {}\\n\" +\n-                       \"class PP4 {}\\n\" +\n-                       \"interface PP5<T> {}\\n\" +\n-                       \"class PP6 {}\\n\" +\n-                       \"class PP7 {}\\n\" +\n-                       \"class PP8 {}\\n\" +\n-                       \"class PP9<T> {}\\n\" +\n-                       \"class PPA {}\\n\" +\n-                       \"class PPB<T> {}\\n\" +\n-                       \"class PPC {}\\n\" +\n-                       \"class PPD {}\\n\" +\n-                       \"class PPE<T> {}\\n\" +\n-                       \"class PPF {}\\n\" +\n-                       \"class PPG {}\\n\" +\n-                       \"interface PPH {}\\n\" +\n-                       \"interface PPI {}\\n\",\n-                       \"t.Test\",\n-                       \"t.Test2\",\n-                       \"t.PP1\",\n-                       \"t.PP2\",\n-                       \"t.PP3\",\n-                       \"t.PP4\",\n-                       \"t.PP5\",\n-                       \"t.PP6\",\n-                       \"t.PP7\",\n-                       \"t.PP8\",\n-                       \"t.PP9\",\n-                       \"t.PPA\",\n-                       \"t.PPB\",\n-                       \"t.PPC\",\n-                       \"t.PPD\",\n-                       \"t.PPE\",\n-                       \"t.PPF\",\n-                       \"t.PPG\",\n-                       \"t.PPH\",\n-                       \"t.PPI\");\n-    }\n-\n-    void doTestIncluded(String code, String... includedClasses) throws Exception {\n-        boolean oldIncludeAll = includeAll;\n-        try {\n-            includeAll = false;\n-            Path classes = prepareVersionedCTSym(code, \"package other; public class Other {}\");\n-            Path root = classes.resolve(\"7\");\n-            try (Stream<Path> classFiles = Files.walk(root)) {\n-                Set<String> names = classFiles.map(p -> root.relativize(p))\n-                                              .map(p -> p.toString())\n-                                              .map(n -> {System.err.println(\"n= \" + n); return n;})\n-                                              .filter(n -> n.endsWith(\".class\"))\n-                                              .map(n -> n.substring(0, n.lastIndexOf('.')))\n-                                              .map(n -> n.replace(File.separator, \".\"))\n-                                              .collect(Collectors.toSet());\n-\n-                if (!names.equals(new HashSet<>(Arrays.asList(includedClasses))))\n-                    throw new AssertionError(\"Expected classes not included: \" + names);\n-            }\n-        } finally {\n-            includeAll = oldIncludeAll;\n-        }\n-    }\n-\n-    Path prepareVersionedCTSym(String code7, String code8) throws Exception {\n-        String testClasses = System.getProperty(\"test.classes\");\n-        Path output = Paths.get(testClasses, \"test-data\" + i++);\n-        deleteRecursively(output);\n-        Files.createDirectories(output);\n-        Path ver7Jar = output.resolve(\"7.jar\");\n-        compileAndPack(output, ver7Jar, code7);\n-        Path ver8Jar = output.resolve(\"8.jar\");\n-        compileAndPack(output, ver8Jar, code8);\n-\n-        ZipFileIndexCache.getSharedInstance().clearCache();\n-\n-        Path classes = output.resolve(\"classes\");\n-\n-        Files.createDirectories(classes);\n-\n-        Path ctSym = output.resolve(\"ct.sym\");\n-\n-        deleteRecursively(ctSym);\n-\n-        CreateSymbols.ALLOW_NON_EXISTING_CLASSES = true;\n-        CreateSymbols.EXTENSION = \".class\";\n-\n-        testGenerate(ver7Jar, ver8Jar, ctSym, \"8\", classes.toAbsolutePath().toString());\n-\n-        return classes;\n-    }\n-\n-    boolean includeAll = true;\n-\n-    void testGenerate(Path jar7, Path jar8, Path descDest, String version, String classDest) throws IOException {\n-        deleteRecursively(descDest);\n-\n-        List<VersionDescription> versions =\n-                Arrays.asList(new VersionDescription(jar7.toAbsolutePath().toString(), \"7\", null),\n-                              new VersionDescription(jar8.toAbsolutePath().toString(), \"8\", \"7\"));\n-\n-        ExcludeIncludeList acceptAll = new ExcludeIncludeList(null, null) {\n-            @Override public boolean accepts(String className) {\n-                return true;\n-            }\n-        };\n-        new CreateSymbols() {\n-            @Override\n-            protected boolean includeEffectiveAccess(ClassList classes, ClassDescription clazz) {\n-                return includeAll ? true : super.includeEffectiveAccess(classes, clazz);\n-            }\n-        }.createBaseLine(versions, acceptAll, descDest, null);\n-        Path symbolsDesc = descDest.resolve(\"symbols\");\n-        try (Writer symbolsFile = Files.newBufferedWriter(symbolsDesc)) {\n-            symbolsFile.write(\"generate platforms 7:8\");\n-            symbolsFile.write(System.lineSeparator());\n-            symbolsFile.write(\"platform version 7 files java.base-7.sym.txt\");\n-            symbolsFile.write(System.lineSeparator());\n-            symbolsFile.write(\"platform version 8 base 7 files java.base-8.sym.txt\");\n-            symbolsFile.write(System.lineSeparator());\n-        }\n-        new CreateSymbols().createSymbols(symbolsDesc.toAbsolutePath().toString(), classDest, CtSymKind.JOINED_VERSIONS);\n-    }\n-\n-    void compileAndPack(Path output, Path outputFile, String... code) throws Exception {\n-        ToolBox tb = new ToolBox();\n-        Path scratch = output.resolve(\"temp\");\n-        deleteRecursively(scratch);\n-        Files.createDirectories(scratch);\n-        System.err.println(Arrays.asList(code));\n-        tb.new JavacTask().sources(code).options(\"-d\", scratch.toAbsolutePath().toString()).run(ToolBox.Expect.SUCCESS);\n-        List<String> classFiles = collectClassFile(scratch);\n-        try (Writer out = Files.newBufferedWriter(outputFile)) {\n-            for (String classFile : classFiles) {\n-                try (InputStream in = Files.newInputStream(scratch.resolve(classFile))) {\n-                    int read;\n-\n-                    while ((read = in.read()) != (-1)) {\n-                        out.write(String.format(\"%02x\", read));\n-                    }\n-\n-                    out.write(\"\\n\");\n-                }\n-            }\n-        }\n-    }\n-\n-    List<String> collectClassFile(Path root) throws IOException {\n-        try (Stream<Path> files = Files.walk(root)) {\n-            return files.filter(p -> Files.isRegularFile(p))\n-                        .filter(p -> p.getFileName().toString().endsWith(\".class\"))\n-                        .map(p -> root.relativize(p).toString())\n-                        .collect(Collectors.toList());\n-        }\n-    }\n-\n-    void deleteRecursively(Path dir) throws IOException {\n-        Files.walkFileTree(dir, new FileVisitor<Path>() {\n-            @Override\n-            public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {\n-                return FileVisitResult.CONTINUE;\n-            }\n-            @Override public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n-                Files.delete(file);\n-                return FileVisitResult.CONTINUE;\n-            }\n-            @Override public FileVisitResult visitFileFailed(Path file, IOException exc) throws IOException {\n-                return FileVisitResult.CONTINUE;\n-            }\n-            @Override public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {\n-                Files.delete(dir);\n-                return FileVisitResult.CONTINUE;\n-            }\n-        });\n-    }\n-\n-    @Retention(RetentionPolicy.RUNTIME)\n-    @interface Test {\n-    }\n-}\n","filename":"make\/langtools\/test\/sym\/CreateSymbolsTestImpl.java","additions":0,"deletions":611,"binary":false,"changes":611,"status":"deleted"},{"patch":"@@ -1519,1 +1519,1 @@\n-                recordComponents = recordComponents.append(rc = new RecordComponent(var, annotations));\n+                recordComponents = recordComponents.append(rc = new RecordComponent(var.sym, annotations));\n@@ -1530,0 +1530,4 @@\n+        public void setRecordComponents(List<RecordComponent> recordComponents) {\n+            this.recordComponents = recordComponents;\n+        }\n+\n@@ -1793,2 +1797,9 @@\n-        public RecordComponent(JCVariableDecl fieldDecl, List<JCAnnotation> annotations) {\n-            super(PUBLIC, fieldDecl.sym.name, fieldDecl.sym.type, fieldDecl.sym.owner);\n+        public RecordComponent(Name name, Type type, Symbol owner) {\n+            super(PUBLIC, name, type, owner);\n+            pos = -1;\n+            originalAnnos = List.nil();\n+            isVarargs = false;\n+        }\n+\n+        public RecordComponent(VarSymbol field, List<JCAnnotation> annotations) {\n+            super(PUBLIC, field.name, field.type, field.owner);\n@@ -1796,1 +1807,1 @@\n-            this.pos = fieldDecl.pos;\n+            this.pos = field.pos;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -1208,1 +1208,10 @@\n-                    bp = bp + attrLen;\n+                    int componentCount = nextChar();\n+                    ListBuffer<RecordComponent> components = new ListBuffer<>();\n+                    for (int i = 0; i < componentCount; i++) {\n+                        Name name = poolReader.getName(nextChar());\n+                        Type type = poolReader.getType(nextChar());\n+                        RecordComponent c = new RecordComponent(name, type, sym);\n+                        readAttrs(c, AttributeKind.MEMBER);\n+                        components.add(c);\n+                    }\n+                    ((ClassSymbol) sym).setRecordComponents(components.toList());\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -232,1 +232,1 @@\n-                                 .map(recordDes -> recordDes.asType().toString() + \" \" + recordDes.getSimpleName())\n+                                 .map(recordDes -> annotationsToString(recordDes) + recordDes.asType().toString() + \" \" + recordDes.getSimpleName())\n@@ -451,1 +451,1 @@\n-            if (kind == PARAMETER) {\n+            if (kind == PARAMETER || kind == RECORD_COMPONENT) {\n@@ -459,1 +459,1 @@\n-            if (kind == ENUM_CONSTANT)\n+            if (kind == ENUM_CONSTANT || kind == RECORD_COMPONENT)\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/processing\/PrintingProcessor.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -365,1 +365,0 @@\n-        \/\/ Note: due to the use of shared resources, this method is not reentrant.\n@@ -368,4 +367,4 @@\n-            sharedOut.reset();\n-            attr.accept(this, sharedOut);\n-            out.writeInt(sharedOut.size());\n-            sharedOut.writeTo(out);\n+            ClassOutputStream nestedOut = new ClassOutputStream();\n+            attr.accept(this, nestedOut);\n+            out.writeInt(nestedOut.size());\n+            nestedOut.writeTo(out);\n@@ -374,1 +373,0 @@\n-        protected ClassOutputStream sharedOut = new ClassOutputStream();\n@@ -759,2 +757,2 @@\n-        protected void writeAccessFlags(AccessFlags flags, ClassOutputStream p) {\n-            sharedOut.writeShort(flags.flags);\n+        protected void writeAccessFlags(AccessFlags flags, ClassOutputStream out) {\n+            out.writeShort(flags.flags);\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/ClassWriter.java","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -79,0 +79,5 @@\n+        public Entry(int name_index, int flags) {\n+            this.name_index = name_index;\n+            this.flags = flags;\n+        }\n+\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/MethodParameters_attribute.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -47,0 +47,6 @@\n+    public Record_attribute(int name_index, ComponentInfo[] component_info_arr) {\n+        super(name_index, 2);\n+        this.component_count = component_info_arr.length;\n+        this.component_info_arr = component_info_arr;\n+    }\n+\n@@ -62,0 +68,6 @@\n+        public ComponentInfo(int name_index, Descriptor descriptor, Attributes attributes) {\n+            this.name_index = name_index;\n+            this.descriptor = descriptor;\n+            this.attributes = attributes;\n+        }\n+\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/Record_attribute.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,160 @@\n+\/*\n+ * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8072480\n+ * @summary Unit test for CreateSymbols\n+ * @modules java.compiler\n+ *          jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.jvm\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ *          jdk.jdeps\/com.sun.tools.classfile\n+ * @clean *\n+ * @run main\/othervm CreateSymbolsTest\n+ *\/\n+\n+import java.io.IOException;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.FileVisitor;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.tools.JavaCompiler;\n+import javax.tools.StandardJavaFileManager;\n+import javax.tools.ToolProvider;\n+\n+public class CreateSymbolsTest {\n+\n+    static final String CREATE_SYMBOLS_NAME = \"symbolgenerator.CreateSymbols\";\n+\n+    public static void main(String... args) throws Exception {\n+        new CreateSymbolsTest().doRun();\n+    }\n+\n+    void doRun() throws Exception {\n+        Path testClasses = Paths.get(System.getProperty(\"test.classes\"));\n+        Path compileDir = testClasses.resolve(\"data\");\n+        deleteRecursively(compileDir);\n+        Files.createDirectories(compileDir);\n+        Path createSymbols = findFile(\"..\/..\/make\/langtools\/src\/classes\/build\/tools\/symbolgenerator\/CreateSymbols.java\");\n+\n+        if (createSymbols == null) {\n+            System.err.println(\"Warning: cannot find CreateSymbols, skipping.\");\n+            return ;\n+        }\n+\n+        Path createTestImpl = findFile(\"tools\/javac\/platform\/createsymbols\/CreateSymbolsTestImpl.java\");\n+\n+        if (createTestImpl == null) {\n+            throw new AssertionError(\"Warning: cannot find CreateSymbolsTestImpl, skipping.\");\n+        }\n+\n+        Path toolBox = findFile(\"tools\/lib\/toolbox\/\");\n+\n+        if (toolBox == null) {\n+            throw new AssertionError(\"Warning: cannot find ToolBox, skipping.\");\n+        }\n+\n+        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();\n+\n+        try (StandardJavaFileManager fm = compiler.getStandardFileManager(null, null, null)) {\n+            List<Path> files = new ArrayList<>();\n+\n+            files.add(createSymbols);\n+            files.add(createTestImpl);\n+\n+            files.add(toolBox.resolve(\"AbstractTask.java\"));\n+            files.add(toolBox.resolve(\"JavacTask.java\"));\n+            files.add(toolBox.resolve(\"Task.java\"));\n+            files.add(toolBox.resolve(\"ToolBox.java\"));\n+\n+            Boolean res =\n+                    compiler.getTask(null,\n+                                      null,\n+                                      null,\n+                                      List.of(\"-d\",\n+                                              compileDir.toAbsolutePath().toString(),\n+                                              \"-g\",\n+                                              \"--add-modules\", \"jdk.jdeps\",\n+                                              \"--add-exports\", \"jdk.compiler\/com.sun.tools.javac.api=ALL-UNNAMED\",\n+                                              \"--add-exports\", \"jdk.compiler\/com.sun.tools.javac.file=ALL-UNNAMED\",\n+                                              \"--add-exports\", \"jdk.compiler\/com.sun.tools.javac.jvm=ALL-UNNAMED\",\n+                                              \"--add-exports\", \"jdk.compiler\/com.sun.tools.javac.main=ALL-UNNAMED\",\n+                                              \"--add-exports\", \"jdk.compiler\/com.sun.tools.javac.util=ALL-UNNAMED\",\n+                                              \"--add-exports\", \"jdk.jdeps\/com.sun.tools.classfile=ALL-UNNAMED\"),\n+                                      null,\n+                                      fm.getJavaFileObjectsFromPaths(files)\n+                                    ).call();\n+            if (!res) {\n+                throw new IllegalStateException(\"Cannot compile test.\");\n+            }\n+        }\n+\n+        URLClassLoader cl = new URLClassLoader(new URL[] {testClasses.toUri().toURL(), compileDir.toUri().toURL()});\n+        Class<?> createSymbolTest = cl.loadClass(\"CreateSymbolsTestImpl\");\n+\n+        createSymbolTest.getMethod(\"main\", String[].class).invoke(null, (Object) new String[0]);\n+    }\n+\n+    Path findFile(String path) {\n+        Path testSrc = Paths.get(System.getProperty(\"test.src\", \".\"));\n+\n+        for (Path d = testSrc; d != null; d = d.getParent()) {\n+            if (Files.exists(d.resolve(\"TEST.ROOT\"))) {\n+                Path file = d.resolve(path);\n+                if (Files.exists(file)) {\n+                    return file;\n+                }\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    void deleteRecursively(Path dir) throws IOException {\n+        Files.walkFileTree(dir, new FileVisitor<Path>() {\n+            @Override\n+            public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {\n+                return FileVisitResult.CONTINUE;\n+            }\n+            @Override public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n+                Files.delete(file);\n+                return FileVisitResult.CONTINUE;\n+            }\n+            @Override public FileVisitResult visitFileFailed(Path file, IOException exc) throws IOException {\n+                return FileVisitResult.CONTINUE;\n+            }\n+            @Override public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {\n+                Files.delete(dir);\n+                return FileVisitResult.CONTINUE;\n+            }\n+        });\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/platform\/createsymbols\/CreateSymbolsTest.java","additions":160,"deletions":0,"binary":false,"changes":160,"status":"added"},{"patch":"@@ -0,0 +1,724 @@\n+\/*\n+ * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.File;\n+import java.io.InputStream;\n+import java.io.Writer;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.io.IOException;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.FileVisitor;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarFile;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import toolbox.JavacTask;\n+import toolbox.Task;\n+import toolbox.Task.Expect;\n+import toolbox.ToolBox;\n+import build.tools.symbolgenerator.CreateSymbols;\n+import build.tools.symbolgenerator.CreateSymbols.ClassDescription;\n+import build.tools.symbolgenerator.CreateSymbols.ClassList;\n+import build.tools.symbolgenerator.CreateSymbols.ExcludeIncludeList;\n+import build.tools.symbolgenerator.CreateSymbols.VersionDescription;\n+\n+public class CreateSymbolsTestImpl {\n+\n+    static final String CREATE_SYMBOLS_NAME = \"symbolgenerator.CreateSymbols\";\n+\n+    public static void main(String... args) throws Exception {\n+        new CreateSymbolsTestImpl().doTest();\n+    }\n+\n+    void doTest() throws Exception {\n+        boolean testRun = false;\n+        for (Method m : CreateSymbolsTestImpl.class.getDeclaredMethods()) {\n+            if (m.isAnnotationPresent(Test.class)) {\n+                m.invoke(this);\n+                testRun = true;\n+            }\n+        }\n+        if (!testRun) {\n+            throw new IllegalStateException(\"No tests found.\");\n+        }\n+    }\n+\n+    @Test\n+    void testMethodRemoved() throws Exception {\n+        doTest(\"package t; public class T { public void m() { } }\",\n+               \"package t; public class T { }\",\n+               \"package t; public class Test { { T t = null; t.m(); } }\",\n+               Expect.SUCCESS,\n+               Expect.FAIL);\n+        doTest(\"package t; public class T { public void b() { } public void m() { } public void a() { } }\",\n+               \"package t; public class T { public void b() { }                     public void a() { } }\",\n+               \"package t; public class Test { { T t = null; t.b(); t.a(); } }\",\n+               Expect.SUCCESS,\n+               Expect.SUCCESS);\n+        \/\/with additional attribute (need to properly skip the member):\n+        doTest(\"package t; public class T { public void m() throws IllegalStateException { } public void a() { } }\",\n+               \"package t; public class T {                                                  public void a() { } }\",\n+               \"package t; public class Test { { T t = null; t.a(); } }\",\n+               Expect.SUCCESS,\n+               Expect.SUCCESS);\n+    }\n+\n+    @Test\n+    void testMethodAdded() throws Exception {\n+        doTest(\"package t; public class T { }\",\n+               \"package t; public class T { public void m() { } }\",\n+               \"package t; public class Test { { T t = null; t.m(); } }\",\n+               Expect.FAIL,\n+               Expect.SUCCESS);\n+        doTest(\"package t; public class T { public void b() { }                     public void a() { } }\",\n+               \"package t; public class T { public void b() { } public void m() { } public void a() { } }\",\n+               \"package t; public class Test { { T t = null; t.b(); t.a(); } }\",\n+               Expect.SUCCESS,\n+               Expect.SUCCESS);\n+    }\n+\n+    \/\/verify fields added\/modified\/removed\n+\n+    @Test\n+    void testClassAdded() throws Exception {\n+        doTest(\"class Dummy {}\",\n+               \"package t; public class T { }\",\n+               \"package t; public class Test { { T t = new T(); } }\",\n+               Expect.FAIL,\n+               Expect.SUCCESS);\n+    }\n+\n+    @Test\n+    void testClassModified() throws Exception {\n+        doTest(\"package t; public class T { public void m() { } }\",\n+               \"package t; public class T implements java.io.Serializable { public void m() { } }\",\n+               \"package t; public class Test { { java.io.Serializable t = new T(); } }\",\n+               Expect.FAIL,\n+               Expect.SUCCESS);\n+    }\n+\n+    @Test\n+    void testClassRemoved() throws Exception {\n+        doTest(\"package t; public class T { }\",\n+               \"class Dummy {}\",\n+               \"package t; public class Test { { T t = new T(); } }\",\n+               Expect.SUCCESS,\n+               Expect.FAIL);\n+    }\n+\n+    @Test\n+    void testInnerClassAttributes() throws Exception {\n+        doTest(\"package t; public class T { public static class Inner { } }\",\n+               \"package t; public class T { public static class Inner { } public void extra() {} }\",\n+               \"package t; import t.T.Inner; public class Test { Inner i; }\",\n+               Expect.SUCCESS,\n+               Expect.SUCCESS);\n+    }\n+\n+    @Test\n+    void testConstantAdded() throws Exception {\n+        doTest(\"package t; public class T { }\",\n+               \"package t; public class T { public static final int A = 0; }\",\n+               \"package t; public class Test { void t(int i) { switch (i) { case T.A: break;} } }\",\n+               Expect.FAIL,\n+               Expect.SUCCESS);\n+    }\n+\n+    @Test\n+    void testAnnotationAttributeDefaultvalue() throws Exception {\n+        \/\/TODO: this only verifies that there is *some* value, but we should also verify there is a specific value:\n+        doTest(\"package t; public @interface T { }\",\n+               \"package t;\\n\" +\n+               \"public @interface T {\\n\" +\n+               \"    public boolean booleanValue() default true;\\n\" +\n+               \"    public byte byteValue() default 1;\\n\" +\n+               \"    public char charValue() default 2;\\n\" +\n+               \"    public short shortValue() default 3;\\n\" +\n+               \"    public int intValue() default 4;\\n\" +\n+               \"    public long longValue() default 5;\\n\" +\n+               \"    public float floatValue() default 6;\\n\" +\n+               \"    public double doubleValue() default 7;\\n\" +\n+               \"    public String stringValue() default \\\"8\\\";\\n\" +\n+               \"    public java.lang.annotation.RetentionPolicy enumValue() default java.lang.annotation.RetentionPolicy.RUNTIME;\\n\" +\n+               \"    public Class classValue() default Number.class;\\n\" +\n+               \"    public int[] arrayValue() default {1, 2};\\n\" +\n+               \"    public SuppressWarnings annotationValue() default @SuppressWarnings(\\\"cast\\\");\\n\" +\n+               \"}\\n\",\n+               \"package t; public @T class Test { }\",\n+               Expect.SUCCESS,\n+               Expect.SUCCESS);\n+    }\n+\n+    @Test\n+    void testConstantTest() throws Exception {\n+        \/\/XXX: other constant types (String in particular) - see testStringConstant\n+        doPrintElementTest(\"package t; public class T { public static final int A = 1; }\",\n+                           \"package t; public class T { public static final int A = 2; }\",\n+                           \"t.T\",\n+                           \"package t;\\n\\n\" +\n+                           \"public class T {\\n\" +\n+                           \"  public static final int A = 1;\\n\\n\" +\n+                           \"  public T();\\n\" +\n+                           \"}\\n\",\n+                           \"t.T\",\n+                           \"package t;\\n\\n\" +\n+                           \"public class T {\\n\" +\n+                           \"  public static final int A = 2;\\n\\n\" +\n+                           \"  public T();\\n\" +\n+                           \"}\\n\");\n+        doPrintElementTest(\"package t; public class T { public static final boolean A = false; }\",\n+                           \"package t; public class T { public static final boolean A = true; }\",\n+                           \"t.T\",\n+                           \"package t;\\n\\n\" +\n+                           \"public class T {\\n\" +\n+                           \"  public static final boolean A = false;\\n\\n\" +\n+                           \"  public T();\\n\" +\n+                           \"}\\n\",\n+                           \"t.T\",\n+                           \"package t;\\n\\n\" +\n+                           \"public class T {\\n\" +\n+                           \"  public static final boolean A = true;\\n\\n\" +\n+                           \"  public T();\\n\" +\n+                           \"}\\n\");\n+    }\n+\n+    @Test\n+    void testAnnotations() throws Exception {\n+        doPrintElementTest(\"package t;\" +\n+                           \"import java.lang.annotation.*;\" +\n+                           \"public @Visible @Invisible class T { public void extra() { } }\" +\n+                           \"@Retention(RetentionPolicy.RUNTIME) @interface Visible { }\" +\n+                           \"@Retention(RetentionPolicy.CLASS) @interface Invisible { }\",\n+                           \"package t;\" +\n+                           \"import java.lang.annotation.*;\" +\n+                           \"public @Visible @Invisible class T { }\" +\n+                           \"@Retention(RetentionPolicy.RUNTIME) @interface Visible { }\" +\n+                           \"@Retention(RetentionPolicy.CLASS) @interface Invisible { }\",\n+                           \"t.T\",\n+                           \"package t;\\n\\n\" +\n+                           \"@t.Invisible\\n\" +\n+                           \"@t.Visible\\n\" +\n+                           \"public class T {\\n\\n\" +\n+                           \"  public T();\\n\\n\" +\n+                           \"  public void extra();\\n\" +\n+                           \"}\\n\",\n+                           \"t.Visible\",\n+                           \"package t;\\n\\n\" +\n+                           \"@java.lang.annotation.Retention(RUNTIME)\\n\" +\n+                           \"@interface Visible {\\n\" +\n+                           \"}\\n\");\n+        doPrintElementTest(\"package t;\" +\n+                           \"import java.lang.annotation.*;\" +\n+                           \"import java.util.*;\" +\n+                           \"public class T {\" +\n+                           \"    public void test(int h, @Invisible int i, @Visible List<String> j, int k) { }\" +\n+                           \"}\" +\n+                           \"@Retention(RetentionPolicy.RUNTIME) @interface Visible { }\" +\n+                           \"@Retention(RetentionPolicy.CLASS) @interface Invisible { }\",\n+                           \"package t;\" +\n+                           \"import java.lang.annotation.*;\" +\n+                           \"import java.util.*;\" +\n+                           \"public class T {\" +\n+                           \"    public void test(int h, @Invisible int i, @Visible List<String> j, int k) { }\" +\n+                           \"    public void extra() { }\" +\n+                           \"}\" +\n+                           \"@Retention(RetentionPolicy.RUNTIME) @interface Visible { }\" +\n+                           \"@Retention(RetentionPolicy.CLASS) @interface Invisible { }\",\n+                           \"t.T\",\n+                           \"package t;\\n\\n\" +\n+                           \"public class T {\\n\\n\" +\n+                           \"  public T();\\n\\n\" +\n+                           \"  public void test(int arg0,\\n\" +\n+                           \"    @t.Invisible int arg1,\\n\" +\n+                           \"    @t.Visible java.util.List<java.lang.String> arg2,\\n\" +\n+                           \"    int arg3);\\n\" +\n+                           \"}\\n\",\n+                           \"t.Visible\",\n+                           \"package t;\\n\\n\" +\n+                           \"@java.lang.annotation.Retention(RUNTIME)\\n\" +\n+                           \"@interface Visible {\\n\" +\n+                           \"}\\n\");\n+        doPrintElementTest(\"package t;\" +\n+                           \"import java.lang.annotation.*;\" +\n+                           \"public class T {\" +\n+                           \"    public void test(@Ann(v=\\\"url\\\", dv=\\\"\\\\\\\"\\\\\\\"\\\") String str) { }\" +\n+                           \"}\" +\n+                           \"@Retention(RetentionPolicy.RUNTIME) @interface Ann {\" +\n+                           \"    public String v();\" +\n+                           \"    public String dv();\" +\n+                           \"}\",\n+                           \"package t;\" +\n+                           \"public class T { }\",\n+                           \"t.T\",\n+                           \"package t;\\n\\n\" +\n+                           \"public class T {\\n\\n\" +\n+                           \"  public T();\\n\\n\" +\n+                           \"  public void test(@t.Ann(dv=\\\"\\\\\\\"\\\\\\\"\\\", v=\\\"url\\\") java.lang.String arg0);\\n\" +\n+                           \"}\\n\",\n+                           \"t.T\",\n+                           \"package t;\\n\\n\" +\n+                           \"public class T {\\n\\n\" +\n+                           \"  public T();\\n\" +\n+                           \"}\\n\");\n+    }\n+\n+    @Test\n+    void testStringConstant() throws Exception {\n+        doTest(\"package t; public class T { public static final String C = \\\"\\\"; }\",\n+               \"package t; public class T { public static final String C = \\\"\\\"; public void extra() { } }\",\n+               \"package t; public class Test { { System.err.println(T.C); } }\",\n+                Expect.SUCCESS,\n+                Expect.SUCCESS);\n+    }\n+\n+    @Test\n+    void testCopyProfileAnnotation() throws Exception {\n+        String oldProfileAnnotation = CreateSymbols.PROFILE_ANNOTATION;\n+        try {\n+            CreateSymbols.PROFILE_ANNOTATION = \"Lt\/Ann;\";\n+            doTestEquivalence(\"package t; public @Ann class T { public void t() {} } @interface Ann { }\",\n+                              \"package t; public class T { public void t() {} }\",\n+                              \"t.T\");\n+        } finally {\n+            CreateSymbols.PROFILE_ANNOTATION = oldProfileAnnotation;\n+        }\n+    }\n+\n+    @Test\n+    void testParseAnnotation() throws Exception {\n+        CreateSymbols.parseAnnotations(\"@Lsun\/Proprietary+Annotation;@Ljdk\/Profile+Annotation;(value=I1)\", new int[1]);\n+        CreateSymbols.parseAnnotations(\"@Ltest;(value={\\\"\\\"})\", new int[1]);\n+        CreateSymbols.parseAnnotations(\"@Ljava\/beans\/ConstructorProperties;(value={\\\"path\\\"})\", new int[1]);\n+        CreateSymbols.parseAnnotations(\"@Ljava\/beans\/ConstructorProperties;(value=I-2)\", new int[1]);\n+    }\n+\n+    @Test\n+    void testStringCharLiterals() throws Exception {\n+        doPrintElementTest(\"package t;\" +\n+                           \"public class T {\" +\n+                           \"    public static final String STR = \\\"\\\\u0000\\\\u0001\\\\uffff\\\";\" +\n+                           \"    public static final String EMPTY = \\\"\\\";\" +\n+                           \"    public static final String AMP = \\\"&amp;&&lt;<&gt;>&apos;'\\\";\" +\n+                           \"}\",\n+                           \"package t;\" +\n+                           \"    public class T {\" +\n+                           \"    public static final char c = '\\\\uffff';\" +\n+                           \"}\",\n+                           \"t.T\",\n+                           \"package t;\\n\\n\" +\n+                           \"public class T {\\n\" +\n+                           \"  public static final java.lang.String STR = \\\"\\\\u0000\\\\u0001\\\\uffff\\\";\\n\" +\n+                           \"  public static final java.lang.String EMPTY = \\\"\\\";\\n\" +\n+                           \"  public static final java.lang.String AMP = \\\"&amp;&&lt;<&gt;>&apos;\\\\'\\\";\\n\\n\" +\n+                           \"  public T();\\n\" +\n+                           \"}\\n\",\n+                           \"t.T\",\n+                           \"package t;\\n\\n\" +\n+                           \"public class T {\\n\" +\n+                           \"  public static final char c = '\\\\uffff';\\n\\n\" +\n+                           \"  public T();\\n\" +\n+                           \"}\\n\");\n+    }\n+\n+    @Test\n+    void testGenerification() throws Exception {\n+        doTest(\"package t; public class T { public class TT { public Object t() { return null; } } }\",\n+               \"package t; public class T<E> { public class TT { public E t() { return null; } } }\",\n+               \"package t; public class Test { { T.TT tt = null; tt.t(); } }\",\n+               Expect.SUCCESS,\n+               Expect.SUCCESS);\n+    }\n+\n+    int i = 0;\n+\n+    void doTest(String code7, String code8, String testCode, Expect result7, Expect result8) throws Exception {\n+        ToolBox tb = new ToolBox();\n+        Path classes = prepareVersionedCTSym(code7, code8);\n+        Path output = classes.getParent();\n+        Path scratch = output.resolve(\"scratch\");\n+\n+        Files.createDirectories(scratch);\n+\n+        new JavacTask(tb)\n+          .sources(testCode)\n+          .options(\"-d\", scratch.toAbsolutePath().toString(), \"-classpath\", computeClassPath(classes, \"7\"))\n+          .run(result7)\n+          .writeAll();\n+        new JavacTask(tb)\n+          .sources(testCode)\n+          .options(\"-d\", scratch.toAbsolutePath().toString(), \"-classpath\", computeClassPath(classes, \"8\"))\n+          .run(result8)\n+          .writeAll();\n+    }\n+\n+    private static String computeClassPath(Path classes, String version) throws IOException {\n+        try (Stream<Path> elements = Files.list(classes)) {\n+            return elements.filter(el -> el.getFileName().toString().contains(version))\n+                            .map(el -> el.resolve(\"java.base\"))\n+                            .map(el -> el.toAbsolutePath().toString())\n+                            .collect(Collectors.joining(File.pathSeparator));\n+        }\n+    }\n+\n+    void doPrintElementTest(String code7, String code8, String className7, String printed7, String className8, String printed8) throws Exception {\n+        ToolBox tb = new ToolBox();\n+        Path classes = prepareVersionedCTSym(code7, code8);\n+        Path output = classes.getParent();\n+        Path scratch = output.resolve(\"scratch\");\n+\n+        Files.createDirectories(scratch);\n+\n+        String out;\n+        out = new JavacTask(tb, Task.Mode.CMDLINE)\n+                .options(\"-d\", scratch.toAbsolutePath().toString(), \"-classpath\", computeClassPath(classes, \"7\"), \"-Xprint\", className7)\n+                .run(Expect.SUCCESS)\n+                .getOutput(Task.OutputKind.STDOUT)\n+                .replaceAll(\"\\\\R\", \"\\n\");\n+        if (!out.equals(printed7)) {\n+            throw new AssertionError(\"out=\" + out + \"; printed7=\" + printed7);\n+        }\n+        out = new JavacTask(tb, Task.Mode.CMDLINE)\n+                .options(\"-d\", scratch.toAbsolutePath().toString(), \"-classpath\", computeClassPath(classes, \"8\"), \"-Xprint\", className8)\n+                .run(Expect.SUCCESS)\n+                .getOutput(Task.OutputKind.STDOUT)\n+                .replaceAll(\"\\\\R\", \"\\n\");\n+        if (!out.equals(printed8)) {\n+            throw new AssertionError(\"out=\" + out + \"; printed8=\" + printed8);\n+        }\n+    }\n+\n+    void doTestEquivalence(String code7, String code8, String testClass) throws Exception {\n+        Path classes = prepareVersionedCTSym(code7, code8);\n+        Path classfile = classes.resolve(\"78\").resolve(\"java.base\").resolve(testClass.replace('.', '\/') + \".class\");\n+\n+        if (!Files.isReadable(classfile)) {\n+            throw new AssertionError(\"Cannot find expected class.\");\n+        }\n+    }\n+\n+    @Test\n+    void testIncluded() throws Exception {\n+        doTestIncluded(\"package t;\\n\" +\n+                       \"public class Test extends PP1<PP2> implements PP3<PP4>, PP5<PP6> {\\n\" +\n+                       \"     public PP7 m1(PP8 p) { return null;}\\n\" +\n+                       \"     public PP9<PPA> m2(PPB<PPC> p) { return null;}\\n\" +\n+                       \"     public PPD f1;\\n\" +\n+                       \"     public PPE<PPF> f2;\\n\" +\n+                       \"     public Test2 aux;\\n\" +\n+                       \"}\\n\" +\n+                       \"class Test2 extends PPG implements PPH, PPI {\\n\" +\n+                       \"}\\n\" +\n+                       \"class PP1<T> {}\\n\" +\n+                       \"class PP2 {}\\n\" +\n+                       \"interface PP3<T> {}\\n\" +\n+                       \"class PP4 {}\\n\" +\n+                       \"interface PP5<T> {}\\n\" +\n+                       \"class PP6 {}\\n\" +\n+                       \"class PP7 {}\\n\" +\n+                       \"class PP8 {}\\n\" +\n+                       \"class PP9<T> {}\\n\" +\n+                       \"class PPA {}\\n\" +\n+                       \"class PPB<T> {}\\n\" +\n+                       \"class PPC {}\\n\" +\n+                       \"class PPD {}\\n\" +\n+                       \"class PPE<T> {}\\n\" +\n+                       \"class PPF {}\\n\" +\n+                       \"class PPG {}\\n\" +\n+                       \"interface PPH {}\\n\" +\n+                       \"interface PPI {}\\n\",\n+                       \"t.Test\",\n+                       \"t.Test2\",\n+                       \"t.PP1\",\n+                       \"t.PP2\",\n+                       \"t.PP3\",\n+                       \"t.PP4\",\n+                       \"t.PP5\",\n+                       \"t.PP6\",\n+                       \"t.PP7\",\n+                       \"t.PP8\",\n+                       \"t.PP9\",\n+                       \"t.PPA\",\n+                       \"t.PPB\",\n+                       \"t.PPC\",\n+                       \"t.PPD\",\n+                       \"t.PPE\",\n+                       \"t.PPF\",\n+                       \"t.PPG\",\n+                       \"t.PPH\",\n+                       \"t.PPI\");\n+    }\n+\n+    @Test\n+    void testRecords() throws Exception {\n+        doPrintElementTest(\"package t;\" +\n+                           \"public class T {\" +\n+                           \"    public record R(int i, java.util.List<String> l) { }\" +\n+                           \"}\",\n+                           \"package t;\" +\n+                           \"public class T {\" +\n+                           \"    public record R(@Ann int i, long j, java.util.List<String> l) { }\" +\n+                           \"    public @interface Ann {} \" +\n+                           \"}\",\n+                           \"t.T$R\",\n+                           \"\"\"\n+\n+                           public static record R(int i, java.util.List<java.lang.String> l) {\n+\n+                             public R(int i,\n+                               java.util.List<java.lang.String> l);\n+\n+                             public final java.lang.String toString();\n+\n+                             public final int hashCode();\n+\n+                             public final boolean equals(java.lang.Object arg0);\n+\n+                             public int i();\n+\n+                             public java.util.List<java.lang.String> l();\n+                           }\n+                           \"\"\",\n+                           \"t.T$R\",\n+                           \"\"\"\n+\n+                           public static record R(@t.T.Ann int i, long j, java.util.List<java.lang.String> l) {\n+\n+                             public final java.lang.String toString();\n+\n+                             public final int hashCode();\n+\n+                             public final boolean equals(java.lang.Object arg0);\n+\n+                             public java.util.List<java.lang.String> l();\n+\n+                             public R(@t.T.Ann int i,\n+                               long j,\n+                               java.util.List<java.lang.String> l);\n+\n+                             @t.T.Ann\n+                             public int i();\n+\n+                             public long j();\n+                           }\n+                           \"\"\");\n+        doPrintElementTest(\"package t;\" +\n+                           \"public record R() {\" +\n+                           \"}\",\n+                           \"package t;\" +\n+                           \"public record R(int i) {\" +\n+                           \"}\",\n+                           \"t.R\",\n+                           \"\"\"\n+                           package t;\n+                           \\n\\\n+                           public record R() {\n+                           \\n\\\n+                             public R();\n+                           \\n\\\n+                             public final java.lang.String toString();\n+                           \\n\\\n+                             public final int hashCode();\n+                           \\n\\\n+                             public final boolean equals(java.lang.Object arg0);\n+                           }\n+                           \"\"\",\n+                           \"t.R\",\n+                           \"\"\"\n+                           package t;\n+                           \\n\\\n+                           public record R(int i) {\n+                           \\n\\\n+                             public final java.lang.String toString();\n+                           \\n\\\n+                             public final int hashCode();\n+                           \\n\\\n+                             public final boolean equals(java.lang.Object arg0);\n+                           \\n\\\n+                             public R(int i);\n+                           \\n\\\n+                             public int i();\n+                           }\n+                           \"\"\");\n+    }\n+\n+    void doTestIncluded(String code, String... includedClasses) throws Exception {\n+        boolean oldIncludeAll = includeAll;\n+        try {\n+            includeAll = false;\n+            Path classes = prepareVersionedCTSym(code, \"package other; public class Other {}\");\n+            Path root = classes.resolve(\"7\").resolve(\"java.base\");\n+            try (Stream<Path> classFiles = Files.walk(root)) {\n+                Set<String> names = classFiles.map(p -> root.relativize(p))\n+                                              .map(p -> p.toString())\n+                                              .map(n -> {System.err.println(\"n= \" + n); return n;})\n+                                              .filter(n -> n.endsWith(\".class\"))\n+                                              .map(n -> n.substring(0, n.lastIndexOf('.')))\n+                                              .map(n -> n.replace(File.separator, \".\"))\n+                                              .collect(Collectors.toSet());\n+\n+                if (!names.equals(new HashSet<>(Arrays.asList(includedClasses))))\n+                    throw new AssertionError(\"Expected classes not included: \" + names);\n+            }\n+        } finally {\n+            includeAll = oldIncludeAll;\n+        }\n+    }\n+\n+    Path prepareVersionedCTSym(String code7, String code8) throws Exception {\n+        String testClasses = System.getProperty(\"test.classes\");\n+        Path output = Paths.get(testClasses, \"test-data\" + i++);\n+        deleteRecursively(output);\n+        Files.createDirectories(output);\n+        Path ver7Jar = output.resolve(\"7.jar\");\n+        compileAndPack(output, ver7Jar, code7);\n+        Path ver8Jar = output.resolve(\"8.jar\");\n+        compileAndPack(output, ver8Jar, code8);\n+\n+        Path classes = output.resolve(\"classes.zip\");\n+\n+        Path ctSym = output.resolve(\"ct.sym\");\n+\n+        deleteRecursively(ctSym);\n+\n+        CreateSymbols.ALLOW_NON_EXISTING_CLASSES = true;\n+        CreateSymbols.EXTENSION = \".class\";\n+\n+        testGenerate(ver7Jar, ver8Jar, ctSym, \"8\", classes.toAbsolutePath().toString());\n+\n+        Path classesDir = output.resolve(\"classes\");\n+\n+        try (JarFile jf = new JarFile(classes.toFile())) {\n+            Enumeration<JarEntry> en = jf.entries();\n+\n+            while (en.hasMoreElements()) {\n+                JarEntry je = en.nextElement();\n+                if (je.isDirectory()) continue;\n+                Path target = classesDir.resolve(je.getName());\n+                Files.createDirectories(target.getParent());\n+                Files.copy(jf.getInputStream(je), target);\n+            }\n+        }\n+\n+        return classesDir;\n+    }\n+\n+    boolean includeAll = true;\n+\n+    void testGenerate(Path jar7, Path jar8, Path descDest, String version, String classDest) throws IOException {\n+        deleteRecursively(descDest);\n+\n+        List<VersionDescription> versions =\n+                Arrays.asList(new VersionDescription(jar7.toAbsolutePath().toString(), \"7\", null),\n+                              new VersionDescription(jar8.toAbsolutePath().toString(), \"8\", \"7\"));\n+\n+        ExcludeIncludeList acceptAll = new ExcludeIncludeList(null, null) {\n+            @Override public boolean accepts(String className) {\n+                return true;\n+            }\n+        };\n+        new CreateSymbols() {\n+            @Override\n+            protected boolean includeEffectiveAccess(ClassList classes, ClassDescription clazz) {\n+                return includeAll ? true : super.includeEffectiveAccess(classes, clazz);\n+            }\n+        }.createBaseLine(versions, acceptAll, descDest, new String[0]);\n+        Path symbolsDesc = descDest.resolve(\"symbols\");\n+        Path systemModules = descDest.resolve(\"systemModules\");\n+\n+        Files.newBufferedWriter(systemModules).close();\n+\n+        try {\n+        new CreateSymbols().createSymbols(null, symbolsDesc.toAbsolutePath().toString(), classDest, 0, \"8\", systemModules.toString());\n+        } catch (Throwable t) {\n+            t.printStackTrace();\n+            throw t;\n+        }\n+    }\n+\n+    void compileAndPack(Path output, Path outputFile, String... code) throws Exception {\n+        ToolBox tb = new ToolBox();\n+        Path scratch = output.resolve(\"temp\");\n+        deleteRecursively(scratch);\n+        Files.createDirectories(scratch);\n+        System.err.println(Arrays.asList(code));\n+        new JavacTask(tb).sources(code).options(\"-d\", scratch.toAbsolutePath().toString()).run(Expect.SUCCESS);\n+        List<String> classFiles = collectClassFile(scratch);\n+        try (Writer out = Files.newBufferedWriter(outputFile)) {\n+            for (String classFile : classFiles) {\n+                try (InputStream in = Files.newInputStream(scratch.resolve(classFile))) {\n+                    int read;\n+\n+                    while ((read = in.read()) != (-1)) {\n+                        out.write(String.format(\"%02x\", read));\n+                    }\n+\n+                    out.write(\"\\n\");\n+                }\n+            }\n+        }\n+    }\n+\n+    List<String> collectClassFile(Path root) throws IOException {\n+        try (Stream<Path> files = Files.walk(root)) {\n+            return files.filter(p -> Files.isRegularFile(p))\n+                        .filter(p -> p.getFileName().toString().endsWith(\".class\"))\n+                        .map(p -> root.relativize(p).toString())\n+                        .collect(Collectors.toList());\n+        }\n+    }\n+\n+    void deleteRecursively(Path dir) throws IOException {\n+        Files.walkFileTree(dir, new FileVisitor<Path>() {\n+            @Override\n+            public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {\n+                return FileVisitResult.CONTINUE;\n+            }\n+            @Override public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n+                Files.delete(file);\n+                return FileVisitResult.CONTINUE;\n+            }\n+            @Override public FileVisitResult visitFileFailed(Path file, IOException exc) throws IOException {\n+                return FileVisitResult.CONTINUE;\n+            }\n+            @Override public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {\n+                Files.delete(dir);\n+                return FileVisitResult.CONTINUE;\n+            }\n+        });\n+    }\n+\n+    @Retention(RetentionPolicy.RUNTIME)\n+    @interface Test {\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/platform\/createsymbols\/CreateSymbolsTestImpl.java","additions":724,"deletions":0,"binary":false,"changes":724,"status":"added"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary test the records can be read by javac properly\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @run main RecordReading\n+ *\/\n+\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Objects;\n+import toolbox.TestRunner;\n+import toolbox.ToolBox;\n+import toolbox.JavacTask;\n+import toolbox.Task;\n+\n+public class RecordReading extends TestRunner {\n+    ToolBox tb;\n+\n+    RecordReading() {\n+        super(System.err);\n+        tb = new ToolBox();\n+    }\n+\n+    protected void runTests() throws Exception {\n+        runTests(m -> new Object[]{Paths.get(m.getName())});\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        RecordReading t = new RecordReading();\n+        t.runTests();\n+    }\n+\n+    Path[] findJavaFiles(Path... paths) throws IOException {\n+        return tb.findJavaFiles(paths);\n+    }\n+\n+    @Test\n+    public void testRecordClassFileReading(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+\n+        tb.writeJavaFiles(src,\n+                           \"\"\"\n+                           public record R(int i, @A long j, java.util.List<String> l) {}\n+                           \"\"\",\n+                           \"\"\"\n+                           public @interface A {}\n+                           \"\"\");\n+\n+        Path out = base.resolve(\"out\");\n+        Files.createDirectories(out);\n+\n+        new JavacTask(tb)\n+                .outdir(out)\n+                .files(findJavaFiles(src))\n+                .run();\n+\n+        \/\/read the class file back, to verify javac's ClassReader\n+        \/\/reads the Record attribute properly:\n+        String output = new JavacTask(tb)\n+                .options(\"-Xprint\")\n+                .classpath(out.toString())\n+                .classes(\"R\")\n+                .run()\n+                .writeAll()\n+                .getOutput(Task.OutputKind.STDOUT)\n+                .replaceAll(\"\\\\R\", \"\\n\");\n+\n+        String expected =\n+                \"\"\"\n+                \\n\\\n+                public record R(int i, @A long j, java.util.List<java.lang.String> l) {\n+                  private final int i;\n+                  @A\n+                  private final long j;\n+                  private final java.util.List<java.lang.String> l;\n+                \\n\\\n+                  public R(int i,\n+                    @A long j,\n+                    java.util.List<java.lang.String> l);\n+                \\n\\\n+                  public final java.lang.String toString();\n+                \\n\\\n+                  public final int hashCode();\n+                \\n\\\n+                  public final boolean equals(java.lang.Object arg0);\n+                \\n\\\n+                  public int i();\n+                \\n\\\n+                  @A\n+                  public long j();\n+                \\n\\\n+                  public java.util.List<java.lang.String> l();\n+                }\n+                \"\"\";\n+        if (!Objects.equals(expected, output)) {\n+            throw new AssertionError(\"Unexpected output: \" + output);\n+        }\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/records\/RecordReading.java","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"}]}