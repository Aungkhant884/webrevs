{"files":[{"patch":"@@ -1984,0 +1984,5 @@\n+\n+        \/\/ register the shared secrets - do this first, since SystemProps.initProperties\n+        \/\/ might initialize CharsetDecoders that rely on it\n+        setJavaLangAccess();\n+\n@@ -2139,125 +2144,122 @@\n-    \/\/ Allow privileged classes outside of java.lang\n-    private static class JavaLangAccessImpl implements JavaLangAccess {\n-        private JavaLangAccessImpl() {}\n-        static {\n-            SharedSecrets.setJavaLangAccess(new JavaLangAccessImpl());\n-        }\n-        public List<Method> getDeclaredPublicMethods(Class<?> klass, String name, Class<?>... parameterTypes) {\n-            return klass.getDeclaredPublicMethods(name, parameterTypes);\n-        }\n-        public jdk.internal.reflect.ConstantPool getConstantPool(Class<?> klass) {\n-            return klass.getConstantPool();\n-        }\n-        public boolean casAnnotationType(Class<?> klass, AnnotationType oldType, AnnotationType newType) {\n-            return klass.casAnnotationType(oldType, newType);\n-        }\n-        public AnnotationType getAnnotationType(Class<?> klass) {\n-            return klass.getAnnotationType();\n-        }\n-        public Map<Class<? extends Annotation>, Annotation> getDeclaredAnnotationMap(Class<?> klass) {\n-            return klass.getDeclaredAnnotationMap();\n-        }\n-        public byte[] getRawClassAnnotations(Class<?> klass) {\n-            return klass.getRawAnnotations();\n-        }\n-        public byte[] getRawClassTypeAnnotations(Class<?> klass) {\n-            return klass.getRawTypeAnnotations();\n-        }\n-        public byte[] getRawExecutableTypeAnnotations(Executable executable) {\n-            return Class.getExecutableTypeAnnotationBytes(executable);\n-        }\n-        public <E extends Enum<E>>\n-        E[] getEnumConstantsShared(Class<E> klass) {\n-            return klass.getEnumConstantsShared();\n-        }\n-        public void blockedOn(Interruptible b) {\n-            Thread.blockedOn(b);\n-        }\n-        public void registerShutdownHook(int slot, boolean registerShutdownInProgress, Runnable hook) {\n-            Shutdown.add(slot, registerShutdownInProgress, hook);\n-        }\n-        public Thread newThreadWithAcc(Runnable target, AccessControlContext acc) {\n-            return new Thread(target, acc);\n-        }\n-        @SuppressWarnings(\"deprecation\")\n-        public void invokeFinalize(Object o) throws Throwable {\n-            o.finalize();\n-        }\n-        public ConcurrentHashMap<?, ?> createOrGetClassLoaderValueMap(ClassLoader cl) {\n-            return cl.createOrGetClassLoaderValueMap();\n-        }\n-        public Class<?> defineClass(ClassLoader loader, String name, byte[] b, ProtectionDomain pd, String source) {\n-            return ClassLoader.defineClass1(loader, name, b, 0, b.length, pd, source);\n-        }\n-        public Class<?> defineClass(ClassLoader loader, Class<?> lookup, String name, byte[] b, ProtectionDomain pd,\n-        boolean initialize, int flags, Object classData) {\n-            return ClassLoader.defineClass0(loader, lookup, name, b, 0, b.length, pd, initialize, flags, classData);\n-        }\n-        public Class<?> findBootstrapClassOrNull(ClassLoader cl, String name) {\n-            return cl.findBootstrapClassOrNull(name);\n-        }\n-        public Package definePackage(ClassLoader cl, String name, Module module) {\n-            return cl.definePackage(name, module);\n-        }\n-        public String fastUUID(long lsb, long msb) {\n-            return Long.fastUUID(lsb, msb);\n-        }\n-        public void addNonExportedPackages(ModuleLayer layer) {\n-            SecurityManager.addNonExportedPackages(layer);\n-        }\n-        public void invalidatePackageAccessCache() {\n-            SecurityManager.invalidatePackageAccessCache();\n-        }\n-        public Module defineModule(ClassLoader loader,\n-                ModuleDescriptor descriptor,\n-                URI uri) {\n-            return new Module(null, loader, descriptor, uri);\n-        }\n-        public Module defineUnnamedModule(ClassLoader loader) {\n-            return new Module(loader);\n-        }\n-        public void addReads(Module m1, Module m2) {\n-            m1.implAddReads(m2);\n-        }\n-        public void addReadsAllUnnamed(Module m) {\n-            m.implAddReadsAllUnnamed();\n-        }\n-        public void addExports(Module m, String pn) {\n-            m.implAddExports(pn);\n-        }\n-        public void addExports(Module m, String pn, Module other) {\n-            m.implAddExports(pn, other);\n-        }\n-        public void addExportsToAllUnnamed(Module m, String pn) {\n-            m.implAddExportsToAllUnnamed(pn);\n-        }\n-        public void addOpens(Module m, String pn, Module other) {\n-            m.implAddOpens(pn, other);\n-        }\n-        public void addOpensToAllUnnamed(Module m, String pn) {\n-            m.implAddOpensToAllUnnamed(pn);\n-        }\n-        public void addOpensToAllUnnamed(Module m, Set<String> concealedPackages, Set<String> exportedPackages) {\n-            m.implAddOpensToAllUnnamed(concealedPackages, exportedPackages);\n-        }\n-        public void addUses(Module m, Class<?> service) {\n-            m.implAddUses(service);\n-        }\n-        public boolean isReflectivelyExported(Module m, String pn, Module other) {\n-            return m.isReflectivelyExported(pn, other);\n-        }\n-        public boolean isReflectivelyOpened(Module m, String pn, Module other) {\n-            return m.isReflectivelyOpened(pn, other);\n-        }\n-        public ServicesCatalog getServicesCatalog(ModuleLayer layer) {\n-            return layer.getServicesCatalog();\n-        }\n-        public void bindToLoader(ModuleLayer layer, ClassLoader loader) {\n-            layer.bindToLoader(loader);\n-        }\n-        public Stream<ModuleLayer> layers(ModuleLayer layer) {\n-            return layer.layers();\n-        }\n-        public Stream<ModuleLayer> layers(ClassLoader loader) {\n-            return ModuleLayer.layers(loader);\n-        }\n+    private static void setJavaLangAccess() {\n+        \/\/ Allow privileged classes outside of java.lang\n+        SharedSecrets.setJavaLangAccess(new JavaLangAccess() {\n+            public List<Method> getDeclaredPublicMethods(Class<?> klass, String name, Class<?>... parameterTypes) {\n+                return klass.getDeclaredPublicMethods(name, parameterTypes);\n+            }\n+            public jdk.internal.reflect.ConstantPool getConstantPool(Class<?> klass) {\n+                return klass.getConstantPool();\n+            }\n+            public boolean casAnnotationType(Class<?> klass, AnnotationType oldType, AnnotationType newType) {\n+                return klass.casAnnotationType(oldType, newType);\n+            }\n+            public AnnotationType getAnnotationType(Class<?> klass) {\n+                return klass.getAnnotationType();\n+            }\n+            public Map<Class<? extends Annotation>, Annotation> getDeclaredAnnotationMap(Class<?> klass) {\n+                return klass.getDeclaredAnnotationMap();\n+            }\n+            public byte[] getRawClassAnnotations(Class<?> klass) {\n+                return klass.getRawAnnotations();\n+            }\n+            public byte[] getRawClassTypeAnnotations(Class<?> klass) {\n+                return klass.getRawTypeAnnotations();\n+            }\n+            public byte[] getRawExecutableTypeAnnotations(Executable executable) {\n+                return Class.getExecutableTypeAnnotationBytes(executable);\n+            }\n+            public <E extends Enum<E>>\n+            E[] getEnumConstantsShared(Class<E> klass) {\n+                return klass.getEnumConstantsShared();\n+            }\n+            public void blockedOn(Interruptible b) {\n+                Thread.blockedOn(b);\n+            }\n+            public void registerShutdownHook(int slot, boolean registerShutdownInProgress, Runnable hook) {\n+                Shutdown.add(slot, registerShutdownInProgress, hook);\n+            }\n+            public Thread newThreadWithAcc(Runnable target, AccessControlContext acc) {\n+                return new Thread(target, acc);\n+            }\n+            @SuppressWarnings(\"deprecation\")\n+            public void invokeFinalize(Object o) throws Throwable {\n+                o.finalize();\n+            }\n+            public ConcurrentHashMap<?, ?> createOrGetClassLoaderValueMap(ClassLoader cl) {\n+                return cl.createOrGetClassLoaderValueMap();\n+            }\n+            public Class<?> defineClass(ClassLoader loader, String name, byte[] b, ProtectionDomain pd, String source) {\n+                return ClassLoader.defineClass1(loader, name, b, 0, b.length, pd, source);\n+            }\n+            public Class<?> defineClass(ClassLoader loader, Class<?> lookup, String name, byte[] b, ProtectionDomain pd,\n+                                        boolean initialize, int flags, Object classData) {\n+                return ClassLoader.defineClass0(loader, lookup, name, b, 0, b.length, pd, initialize, flags, classData);\n+            }\n+            public Class<?> findBootstrapClassOrNull(ClassLoader cl, String name) {\n+                return cl.findBootstrapClassOrNull(name);\n+            }\n+            public Package definePackage(ClassLoader cl, String name, Module module) {\n+                return cl.definePackage(name, module);\n+            }\n+            public String fastUUID(long lsb, long msb) {\n+                return Long.fastUUID(lsb, msb);\n+            }\n+            public void addNonExportedPackages(ModuleLayer layer) {\n+                SecurityManager.addNonExportedPackages(layer);\n+            }\n+            public void invalidatePackageAccessCache() {\n+                SecurityManager.invalidatePackageAccessCache();\n+            }\n+            public Module defineModule(ClassLoader loader,\n+                                       ModuleDescriptor descriptor,\n+                                       URI uri) {\n+                return new Module(null, loader, descriptor, uri);\n+            }\n+            public Module defineUnnamedModule(ClassLoader loader) {\n+                return new Module(loader);\n+            }\n+            public void addReads(Module m1, Module m2) {\n+                m1.implAddReads(m2);\n+            }\n+            public void addReadsAllUnnamed(Module m) {\n+                m.implAddReadsAllUnnamed();\n+            }\n+            public void addExports(Module m, String pn) {\n+                m.implAddExports(pn);\n+            }\n+            public void addExports(Module m, String pn, Module other) {\n+                m.implAddExports(pn, other);\n+            }\n+            public void addExportsToAllUnnamed(Module m, String pn) {\n+                m.implAddExportsToAllUnnamed(pn);\n+            }\n+            public void addOpens(Module m, String pn, Module other) {\n+                m.implAddOpens(pn, other);\n+            }\n+            public void addOpensToAllUnnamed(Module m, String pn) {\n+                m.implAddOpensToAllUnnamed(pn);\n+            }\n+            public void addOpensToAllUnnamed(Module m, Set<String> concealedPackages, Set<String> exportedPackages) {\n+                m.implAddOpensToAllUnnamed(concealedPackages, exportedPackages);\n+            }\n+            public void addUses(Module m, Class<?> service) {\n+                m.implAddUses(service);\n+            }\n+            public boolean isReflectivelyExported(Module m, String pn, Module other) {\n+                return m.isReflectivelyExported(pn, other);\n+            }\n+            public boolean isReflectivelyOpened(Module m, String pn, Module other) {\n+                return m.isReflectivelyOpened(pn, other);\n+            }\n+            public ServicesCatalog getServicesCatalog(ModuleLayer layer) {\n+                return layer.getServicesCatalog();\n+            }\n+            public void bindToLoader(ModuleLayer layer, ClassLoader loader) {\n+                layer.bindToLoader(loader);\n+            }\n+            public Stream<ModuleLayer> layers(ModuleLayer layer) {\n+                return layer.layers();\n+            }\n+            public Stream<ModuleLayer> layers(ClassLoader loader) {\n+                return ModuleLayer.layers(loader);\n+            }\n@@ -2265,3 +2267,3 @@\n-        public String newStringNoRepl(byte[] bytes, Charset cs) throws CharacterCodingException  {\n-            return String.newStringNoRepl(bytes, cs);\n-        }\n+            public String newStringNoRepl(byte[] bytes, Charset cs) throws CharacterCodingException  {\n+                return String.newStringNoRepl(bytes, cs);\n+            }\n@@ -2269,3 +2271,3 @@\n-        public byte[] getBytesNoRepl(String s, Charset cs) throws CharacterCodingException {\n-            return String.getBytesNoRepl(s, cs);\n-        }\n+            public byte[] getBytesNoRepl(String s, Charset cs) throws CharacterCodingException {\n+                return String.getBytesNoRepl(s, cs);\n+            }\n@@ -2273,3 +2275,3 @@\n-        public String newStringUTF8NoRepl(byte[] bytes, int off, int len) {\n-            return String.newStringUTF8NoRepl(bytes, off, len);\n-        }\n+            public String newStringUTF8NoRepl(byte[] bytes, int off, int len) {\n+                return String.newStringUTF8NoRepl(bytes, off, len);\n+            }\n@@ -2277,3 +2279,3 @@\n-        public byte[] getBytesUTF8NoRepl(String s) {\n-            return String.getBytesUTF8NoRepl(s);\n-        }\n+            public byte[] getBytesUTF8NoRepl(String s) {\n+                return String.getBytesUTF8NoRepl(s);\n+            }\n@@ -2281,3 +2283,3 @@\n-        public void inflateBytesToChars(byte[] src, int srcOff, char[] dst, int dstOff, int len) {\n-            StringLatin1.inflate(src, srcOff, dst, dstOff, len);\n-        }\n+            public void inflateBytesToChars(byte[] src, int srcOff, char[] dst, int dstOff, int len) {\n+                StringLatin1.inflate(src, srcOff, dst, dstOff, len);\n+            }\n@@ -2285,3 +2287,3 @@\n-        public int decodeASCII(byte[] src, int srcOff, char[] dst, int dstOff, int len) {\n-            return String.decodeASCII(src, srcOff, dst, dstOff, len);\n-        }\n+            public int decodeASCII(byte[] src, int srcOff, char[] dst, int dstOff, int len) {\n+                return String.decodeASCII(src, srcOff, dst, dstOff, len);\n+            }\n@@ -2289,3 +2291,3 @@\n-        public void setCause(Throwable t, Throwable cause) {\n-            t.setCause(cause);\n-        }\n+            public void setCause(Throwable t, Throwable cause) {\n+                t.setCause(cause);\n+            }\n@@ -2293,3 +2295,3 @@\n-        public ProtectionDomain protectionDomain(Class<?> c) {\n-            return c.protectionDomain();\n-        }\n+            public ProtectionDomain protectionDomain(Class<?> c) {\n+                return c.protectionDomain();\n+            }\n@@ -2297,3 +2299,3 @@\n-        public MethodHandle stringConcatHelper(String name, MethodType methodType) {\n-            return StringConcatHelper.lookupStatic(name, methodType);\n-        }\n+            public MethodHandle stringConcatHelper(String name, MethodType methodType) {\n+                return StringConcatHelper.lookupStatic(name, methodType);\n+            }\n@@ -2301,3 +2303,3 @@\n-        public long stringConcatInitialCoder() {\n-            return StringConcatHelper.initialCoder();\n-        }\n+            public long stringConcatInitialCoder() {\n+                return StringConcatHelper.initialCoder();\n+            }\n@@ -2305,3 +2307,3 @@\n-        public long stringConcatMix(long lengthCoder, String constant) {\n-            return StringConcatHelper.mix(lengthCoder, constant);\n-        }\n+            public long stringConcatMix(long lengthCoder, String constant) {\n+                return StringConcatHelper.mix(lengthCoder, constant);\n+            }\n@@ -2309,3 +2311,4 @@\n-        public Object classData(Class<?> c) {\n-            return c.getClassData();\n-        }\n+            public Object classData(Class<?> c) {\n+                return c.getClassData();\n+            }\n+        });\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":164,"deletions":161,"binary":false,"changes":325,"status":"modified"},{"patch":"@@ -91,1 +91,1 @@\n-            } catch (ClassNotFoundException e) {};\n+            } catch (ClassNotFoundException e) {}\n@@ -116,8 +116,1 @@\n-        var access = javaLangAccess;\n-        if (access == null) {\n-            try {\n-                Class.forName(\"java.lang.System$JavaLangAccessImpl\", true, null);\n-                access = javaLangAccess;\n-            } catch (ClassNotFoundException e) {}\n-        }\n-        return access;\n+        return javaLangAccess;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/SharedSecrets.java","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"}]}