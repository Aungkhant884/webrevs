{"files":[{"patch":"@@ -1011,0 +1011,21 @@\n+    \/**\n+     * Decodes ASCII from the source byte array into the destination\n+     * char array. Used via JavaLangAccess from UTF_8 and other charset\n+     * decoders.\n+     *\n+     * @return the number of bytes successfully decoded, at most len\n+     *\/\n+    \/* package-private *\/\n+    static int decodeASCII(byte[] sa, int sp, char[] da, int dp, int len) {\n+        if (!StringCoding.hasNegatives(sa, sp, len)) {\n+            StringLatin1.inflate(sa, sp, da, dp, len);\n+            return len;\n+        } else {\n+            int start = sp;\n+            int end = sp + len;\n+            while (sp < end && sa[sp] >= 0) {\n+                da[dp++] = (char) sa[sp++];\n+            }\n+            return sp - start;\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/String.java","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2029,2 +2029,0 @@\n-        \/\/ register shared secrets\n-        setJavaLangAccess();\n@@ -2141,122 +2139,125 @@\n-    private static void setJavaLangAccess() {\n-        \/\/ Allow privileged classes outside of java.lang\n-        SharedSecrets.setJavaLangAccess(new JavaLangAccess() {\n-            public List<Method> getDeclaredPublicMethods(Class<?> klass, String name, Class<?>... parameterTypes) {\n-                return klass.getDeclaredPublicMethods(name, parameterTypes);\n-            }\n-            public jdk.internal.reflect.ConstantPool getConstantPool(Class<?> klass) {\n-                return klass.getConstantPool();\n-            }\n-            public boolean casAnnotationType(Class<?> klass, AnnotationType oldType, AnnotationType newType) {\n-                return klass.casAnnotationType(oldType, newType);\n-            }\n-            public AnnotationType getAnnotationType(Class<?> klass) {\n-                return klass.getAnnotationType();\n-            }\n-            public Map<Class<? extends Annotation>, Annotation> getDeclaredAnnotationMap(Class<?> klass) {\n-                return klass.getDeclaredAnnotationMap();\n-            }\n-            public byte[] getRawClassAnnotations(Class<?> klass) {\n-                return klass.getRawAnnotations();\n-            }\n-            public byte[] getRawClassTypeAnnotations(Class<?> klass) {\n-                return klass.getRawTypeAnnotations();\n-            }\n-            public byte[] getRawExecutableTypeAnnotations(Executable executable) {\n-                return Class.getExecutableTypeAnnotationBytes(executable);\n-            }\n-            public <E extends Enum<E>>\n-            E[] getEnumConstantsShared(Class<E> klass) {\n-                return klass.getEnumConstantsShared();\n-            }\n-            public void blockedOn(Interruptible b) {\n-                Thread.blockedOn(b);\n-            }\n-            public void registerShutdownHook(int slot, boolean registerShutdownInProgress, Runnable hook) {\n-                Shutdown.add(slot, registerShutdownInProgress, hook);\n-            }\n-            public Thread newThreadWithAcc(Runnable target, AccessControlContext acc) {\n-                return new Thread(target, acc);\n-            }\n-            @SuppressWarnings(\"deprecation\")\n-            public void invokeFinalize(Object o) throws Throwable {\n-                o.finalize();\n-            }\n-            public ConcurrentHashMap<?, ?> createOrGetClassLoaderValueMap(ClassLoader cl) {\n-                return cl.createOrGetClassLoaderValueMap();\n-            }\n-            public Class<?> defineClass(ClassLoader loader, String name, byte[] b, ProtectionDomain pd, String source) {\n-                return ClassLoader.defineClass1(loader, name, b, 0, b.length, pd, source);\n-            }\n-            public Class<?> defineClass(ClassLoader loader, Class<?> lookup, String name, byte[] b, ProtectionDomain pd,\n-                                        boolean initialize, int flags, Object classData) {\n-                return ClassLoader.defineClass0(loader, lookup, name, b, 0, b.length, pd, initialize, flags, classData);\n-            }\n-            public Class<?> findBootstrapClassOrNull(ClassLoader cl, String name) {\n-                return cl.findBootstrapClassOrNull(name);\n-            }\n-            public Package definePackage(ClassLoader cl, String name, Module module) {\n-                return cl.definePackage(name, module);\n-            }\n-            public String fastUUID(long lsb, long msb) {\n-                return Long.fastUUID(lsb, msb);\n-            }\n-            public void addNonExportedPackages(ModuleLayer layer) {\n-                SecurityManager.addNonExportedPackages(layer);\n-            }\n-            public void invalidatePackageAccessCache() {\n-                SecurityManager.invalidatePackageAccessCache();\n-            }\n-            public Module defineModule(ClassLoader loader,\n-                                       ModuleDescriptor descriptor,\n-                                       URI uri) {\n-                return new Module(null, loader, descriptor, uri);\n-            }\n-            public Module defineUnnamedModule(ClassLoader loader) {\n-                return new Module(loader);\n-            }\n-            public void addReads(Module m1, Module m2) {\n-                m1.implAddReads(m2);\n-            }\n-            public void addReadsAllUnnamed(Module m) {\n-                m.implAddReadsAllUnnamed();\n-            }\n-            public void addExports(Module m, String pn) {\n-                m.implAddExports(pn);\n-            }\n-            public void addExports(Module m, String pn, Module other) {\n-                m.implAddExports(pn, other);\n-            }\n-            public void addExportsToAllUnnamed(Module m, String pn) {\n-                m.implAddExportsToAllUnnamed(pn);\n-            }\n-            public void addOpens(Module m, String pn, Module other) {\n-                m.implAddOpens(pn, other);\n-            }\n-            public void addOpensToAllUnnamed(Module m, String pn) {\n-                m.implAddOpensToAllUnnamed(pn);\n-            }\n-            public void addOpensToAllUnnamed(Module m, Set<String> concealedPackages, Set<String> exportedPackages) {\n-                m.implAddOpensToAllUnnamed(concealedPackages, exportedPackages);\n-            }\n-            public void addUses(Module m, Class<?> service) {\n-                m.implAddUses(service);\n-            }\n-            public boolean isReflectivelyExported(Module m, String pn, Module other) {\n-                return m.isReflectivelyExported(pn, other);\n-            }\n-            public boolean isReflectivelyOpened(Module m, String pn, Module other) {\n-                return m.isReflectivelyOpened(pn, other);\n-            }\n-            public ServicesCatalog getServicesCatalog(ModuleLayer layer) {\n-                return layer.getServicesCatalog();\n-            }\n-            public void bindToLoader(ModuleLayer layer, ClassLoader loader) {\n-                layer.bindToLoader(loader);\n-            }\n-            public Stream<ModuleLayer> layers(ModuleLayer layer) {\n-                return layer.layers();\n-            }\n-            public Stream<ModuleLayer> layers(ClassLoader loader) {\n-                return ModuleLayer.layers(loader);\n-            }\n+    \/\/ Allow privileged classes outside of java.lang\n+    private static class JavaLangAccessImpl implements JavaLangAccess {\n+        private JavaLangAccessImpl() {}\n+        static {\n+            SharedSecrets.setJavaLangAccess(new JavaLangAccessImpl());\n+        }\n+        public List<Method> getDeclaredPublicMethods(Class<?> klass, String name, Class<?>... parameterTypes) {\n+            return klass.getDeclaredPublicMethods(name, parameterTypes);\n+        }\n+        public jdk.internal.reflect.ConstantPool getConstantPool(Class<?> klass) {\n+            return klass.getConstantPool();\n+        }\n+        public boolean casAnnotationType(Class<?> klass, AnnotationType oldType, AnnotationType newType) {\n+            return klass.casAnnotationType(oldType, newType);\n+        }\n+        public AnnotationType getAnnotationType(Class<?> klass) {\n+            return klass.getAnnotationType();\n+        }\n+        public Map<Class<? extends Annotation>, Annotation> getDeclaredAnnotationMap(Class<?> klass) {\n+            return klass.getDeclaredAnnotationMap();\n+        }\n+        public byte[] getRawClassAnnotations(Class<?> klass) {\n+            return klass.getRawAnnotations();\n+        }\n+        public byte[] getRawClassTypeAnnotations(Class<?> klass) {\n+            return klass.getRawTypeAnnotations();\n+        }\n+        public byte[] getRawExecutableTypeAnnotations(Executable executable) {\n+            return Class.getExecutableTypeAnnotationBytes(executable);\n+        }\n+        public <E extends Enum<E>>\n+        E[] getEnumConstantsShared(Class<E> klass) {\n+            return klass.getEnumConstantsShared();\n+        }\n+        public void blockedOn(Interruptible b) {\n+            Thread.blockedOn(b);\n+        }\n+        public void registerShutdownHook(int slot, boolean registerShutdownInProgress, Runnable hook) {\n+            Shutdown.add(slot, registerShutdownInProgress, hook);\n+        }\n+        public Thread newThreadWithAcc(Runnable target, AccessControlContext acc) {\n+            return new Thread(target, acc);\n+        }\n+        @SuppressWarnings(\"deprecation\")\n+        public void invokeFinalize(Object o) throws Throwable {\n+            o.finalize();\n+        }\n+        public ConcurrentHashMap<?, ?> createOrGetClassLoaderValueMap(ClassLoader cl) {\n+            return cl.createOrGetClassLoaderValueMap();\n+        }\n+        public Class<?> defineClass(ClassLoader loader, String name, byte[] b, ProtectionDomain pd, String source) {\n+            return ClassLoader.defineClass1(loader, name, b, 0, b.length, pd, source);\n+        }\n+        public Class<?> defineClass(ClassLoader loader, Class<?> lookup, String name, byte[] b, ProtectionDomain pd,\n+        boolean initialize, int flags, Object classData) {\n+            return ClassLoader.defineClass0(loader, lookup, name, b, 0, b.length, pd, initialize, flags, classData);\n+        }\n+        public Class<?> findBootstrapClassOrNull(ClassLoader cl, String name) {\n+            return cl.findBootstrapClassOrNull(name);\n+        }\n+        public Package definePackage(ClassLoader cl, String name, Module module) {\n+            return cl.definePackage(name, module);\n+        }\n+        public String fastUUID(long lsb, long msb) {\n+            return Long.fastUUID(lsb, msb);\n+        }\n+        public void addNonExportedPackages(ModuleLayer layer) {\n+            SecurityManager.addNonExportedPackages(layer);\n+        }\n+        public void invalidatePackageAccessCache() {\n+            SecurityManager.invalidatePackageAccessCache();\n+        }\n+        public Module defineModule(ClassLoader loader,\n+                ModuleDescriptor descriptor,\n+                URI uri) {\n+            return new Module(null, loader, descriptor, uri);\n+        }\n+        public Module defineUnnamedModule(ClassLoader loader) {\n+            return new Module(loader);\n+        }\n+        public void addReads(Module m1, Module m2) {\n+            m1.implAddReads(m2);\n+        }\n+        public void addReadsAllUnnamed(Module m) {\n+            m.implAddReadsAllUnnamed();\n+        }\n+        public void addExports(Module m, String pn) {\n+            m.implAddExports(pn);\n+        }\n+        public void addExports(Module m, String pn, Module other) {\n+            m.implAddExports(pn, other);\n+        }\n+        public void addExportsToAllUnnamed(Module m, String pn) {\n+            m.implAddExportsToAllUnnamed(pn);\n+        }\n+        public void addOpens(Module m, String pn, Module other) {\n+            m.implAddOpens(pn, other);\n+        }\n+        public void addOpensToAllUnnamed(Module m, String pn) {\n+            m.implAddOpensToAllUnnamed(pn);\n+        }\n+        public void addOpensToAllUnnamed(Module m, Set<String> concealedPackages, Set<String> exportedPackages) {\n+            m.implAddOpensToAllUnnamed(concealedPackages, exportedPackages);\n+        }\n+        public void addUses(Module m, Class<?> service) {\n+            m.implAddUses(service);\n+        }\n+        public boolean isReflectivelyExported(Module m, String pn, Module other) {\n+            return m.isReflectivelyExported(pn, other);\n+        }\n+        public boolean isReflectivelyOpened(Module m, String pn, Module other) {\n+            return m.isReflectivelyOpened(pn, other);\n+        }\n+        public ServicesCatalog getServicesCatalog(ModuleLayer layer) {\n+            return layer.getServicesCatalog();\n+        }\n+        public void bindToLoader(ModuleLayer layer, ClassLoader loader) {\n+            layer.bindToLoader(loader);\n+        }\n+        public Stream<ModuleLayer> layers(ModuleLayer layer) {\n+            return layer.layers();\n+        }\n+        public Stream<ModuleLayer> layers(ClassLoader loader) {\n+            return ModuleLayer.layers(loader);\n+        }\n@@ -2264,3 +2265,3 @@\n-            public String newStringNoRepl(byte[] bytes, Charset cs) throws CharacterCodingException  {\n-                return String.newStringNoRepl(bytes, cs);\n-            }\n+        public String newStringNoRepl(byte[] bytes, Charset cs) throws CharacterCodingException  {\n+            return String.newStringNoRepl(bytes, cs);\n+        }\n@@ -2268,3 +2269,3 @@\n-            public byte[] getBytesNoRepl(String s, Charset cs) throws CharacterCodingException {\n-                return String.getBytesNoRepl(s, cs);\n-            }\n+        public byte[] getBytesNoRepl(String s, Charset cs) throws CharacterCodingException {\n+            return String.getBytesNoRepl(s, cs);\n+        }\n@@ -2272,3 +2273,3 @@\n-            public String newStringUTF8NoRepl(byte[] bytes, int off, int len) {\n-                return String.newStringUTF8NoRepl(bytes, off, len);\n-            }\n+        public String newStringUTF8NoRepl(byte[] bytes, int off, int len) {\n+            return String.newStringUTF8NoRepl(bytes, off, len);\n+        }\n@@ -2276,3 +2277,3 @@\n-            public byte[] getBytesUTF8NoRepl(String s) {\n-                return String.getBytesUTF8NoRepl(s);\n-            }\n+        public byte[] getBytesUTF8NoRepl(String s) {\n+            return String.getBytesUTF8NoRepl(s);\n+        }\n@@ -2280,3 +2281,3 @@\n-            public void setCause(Throwable t, Throwable cause) {\n-                t.setCause(cause);\n-            }\n+        public void inflateBytesToChars(byte[] src, int srcOff, char[] dst, int dstOff, int len) {\n+            StringLatin1.inflate(src, srcOff, dst, dstOff, len);\n+        }\n@@ -2284,3 +2285,3 @@\n-            public ProtectionDomain protectionDomain(Class<?> c) {\n-                return c.protectionDomain();\n-            }\n+        public int decodeASCII(byte[] src, int srcOff, char[] dst, int dstOff, int len) {\n+            return String.decodeASCII(src, srcOff, dst, dstOff, len);\n+        }\n@@ -2288,3 +2289,3 @@\n-            public MethodHandle stringConcatHelper(String name, MethodType methodType) {\n-                return StringConcatHelper.lookupStatic(name, methodType);\n-            }\n+        public void setCause(Throwable t, Throwable cause) {\n+            t.setCause(cause);\n+        }\n@@ -2292,3 +2293,3 @@\n-            public long stringConcatInitialCoder() {\n-                return StringConcatHelper.initialCoder();\n-            }\n+        public ProtectionDomain protectionDomain(Class<?> c) {\n+            return c.protectionDomain();\n+        }\n@@ -2296,3 +2297,3 @@\n-            public long stringConcatMix(long lengthCoder, String constant) {\n-                return StringConcatHelper.mix(lengthCoder, constant);\n-            }\n+        public MethodHandle stringConcatHelper(String name, MethodType methodType) {\n+            return StringConcatHelper.lookupStatic(name, methodType);\n+        }\n@@ -2300,4 +2301,11 @@\n-            public Object classData(Class<?> c) {\n-                return c.getClassData();\n-            }\n-        });\n+        public long stringConcatInitialCoder() {\n+            return StringConcatHelper.initialCoder();\n+        }\n+\n+        public long stringConcatMix(long lengthCoder, String constant) {\n+            return StringConcatHelper.mix(lengthCoder, constant);\n+        }\n+\n+        public Object classData(Class<?> c) {\n+            return c.getClassData();\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":163,"deletions":155,"binary":false,"changes":318,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -331,0 +331,13 @@\n+    \/**\n+     * Inflated copy from byte[] to char[], as defined by StringLatin1.inflate\n+     *\/\n+    void inflateBytesToChars(byte[] src, int srcOff, char[] dst, int dstOff, int len);\n+\n+    \/**\n+     * Decodes ASCII from the source byte array into the destination\n+     * char array.\n+     *\n+     * @return the number of bytes successfully decoded, at most len\n+     *\/\n+    int decodeASCII(byte[] src, int srcOff, char[] dst, int dstOff, int len);\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -116,1 +116,8 @@\n-        return javaLangAccess;\n+        var access = javaLangAccess;\n+        if (access == null) {\n+            try {\n+                Class.forName(\"java.lang.System$JavaLangAccessImpl\", true, null);\n+                access = javaLangAccess;\n+            } catch (ClassNotFoundException e) {}\n+        }\n+        return access;\n@@ -129,1 +136,1 @@\n-            } catch (ClassNotFoundException e) {};\n+            } catch (ClassNotFoundException e) {}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/SharedSecrets.java","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n+\n@@ -78,0 +81,3 @@\n+\n+        private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n+\n@@ -99,21 +105,0 @@\n-\n-        \/\/  [F0]     [90..BF] [80..BF] [80..BF]\n-        \/\/  [F1..F3] [80..BF] [80..BF] [80..BF]\n-        \/\/  [F4]     [80..8F] [80..BF] [80..BF]\n-        \/\/  only check 80-be range here, the [0xf0,0x80...] and [0xf4,0x90-...]\n-        \/\/  will be checked by Character.isSupplementaryCodePoint(uc)\n-        private static boolean isMalformed4(int b2, int b3, int b4) {\n-            return (b2 & 0xc0) != 0x80 || (b3 & 0xc0) != 0x80 ||\n-                   (b4 & 0xc0) != 0x80;\n-        }\n-\n-        \/\/ only used when there is less than 4 bytes left in src buffer\n-        private static boolean isMalformed4_2(int b1, int b2) {\n-            return (b1 == 0xf0 && b2 == 0x90) ||\n-                   (b2 & 0xc0) != 0x80;\n-        }\n-\n-        private static boolean isMalformed4_3(int b3) {\n-            return (b3 & 0xc0) != 0x80;\n-        }\n-\n@@ -205,2 +190,3 @@\n-            int sp = src.arrayOffset() + src.position();\n-            int sl = src.arrayOffset() + src.limit();\n+            int soff = src.arrayOffset();\n+            int sp = soff + src.position();\n+            int sl = soff + src.limit();\n@@ -209,3 +195,7 @@\n-            int dp = dst.arrayOffset() + dst.position();\n-            int dl = dst.arrayOffset() + dst.limit();\n-            int dlASCII = dp + Math.min(sl - sp, dl - dp);\n+            int doff = dst.arrayOffset();\n+            int dp = doff + dst.position();\n+            int dl = doff + dst.limit();\n+\n+            int n = JLA.decodeASCII(sa, sp, da, dp, Math.min(sl - sp, dl - dp));\n+            sp += n;\n+            dp += n;\n@@ -213,3 +203,0 @@\n-            \/\/ ASCII only loop\n-            while (dp < dlASCII && sa[sp] >= 0)\n-                da[dp++] = (char) sa[sp++];\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/cs\/CESU_8.java","additions":17,"deletions":30,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,3 @@\n+\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -114,0 +117,2 @@\n+        private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n+\n@@ -157,2 +162,3 @@\n-            int sp = src.arrayOffset() + src.position();\n-            int sl = src.arrayOffset() + src.limit();\n+            int soff = src.arrayOffset();\n+            int sp = soff + src.position();\n+            int sl = soff + src.limit();\n@@ -161,2 +167,3 @@\n-            int dp = dst.arrayOffset() + dst.position();\n-            int dl = dst.arrayOffset() + dst.limit();\n+            int doff = dst.arrayOffset();\n+            int dp = doff + dst.position();\n+            int dl = doff + dst.limit();\n@@ -165,0 +172,5 @@\n+                if (isASCIICompatible) {\n+                    int n = JLA.decodeASCII(sa, sp, da, dp, Math.min(dl - dp, sl - sp));\n+                    dp += n;\n+                    sp += n;\n+                }\n@@ -186,2 +198,2 @@\n-                src.position(sp - src.arrayOffset());\n-                dst.position(dp - dst.arrayOffset());\n+                src.position(sp - soff);\n+                dst.position(dp - doff);\n@@ -345,1 +357,1 @@\n-                        char c =  UNMAPPABLE_DECODING;\n+                        char c;\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/cs\/DoubleByte.java","additions":20,"deletions":8,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,2 @@\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -67,0 +69,2 @@\n+        private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n+\n@@ -75,4 +79,4 @@\n-            int sp = src.arrayOffset() + src.position();\n-            int sl = src.arrayOffset() + src.limit();\n-            assert (sp <= sl);\n-            sp = (sp <= sl ? sp : sl);\n+            int soff = src.arrayOffset();\n+            int sp = soff + src.position();\n+            int sl = soff + src.limit();\n+\n@@ -80,4 +84,3 @@\n-            int dp = dst.arrayOffset() + dst.position();\n-            int dl = dst.arrayOffset() + dst.limit();\n-            assert (dp <= dl);\n-            dp = (dp <= dl ? dp : dl);\n+            int doff = dst.arrayOffset();\n+            int dp = doff + dst.position();\n+            int dl = doff + dst.limit();\n@@ -85,12 +88,8 @@\n-            try {\n-                while (sp < sl) {\n-                    byte b = sa[sp];\n-                    if (dp >= dl)\n-                        return CoderResult.OVERFLOW;\n-                    da[dp++] = (char)(b & 0xff);\n-                    sp++;\n-                }\n-                return CoderResult.UNDERFLOW;\n-            } finally {\n-                src.position(sp - src.arrayOffset());\n-                dst.position(dp - dst.arrayOffset());\n+            int decodeLen = Math.min(sl - sp, dl - dp);\n+            JLA.inflateBytesToChars(sa, sp, da, dp, decodeLen);\n+            sp += decodeLen;\n+            dp += decodeLen;\n+            src.position(sp - soff);\n+            dst.position(dp - doff);\n+            if (sl - sp > dl - dp) {\n+                return CoderResult.OVERFLOW;\n@@ -98,0 +97,1 @@\n+            return CoderResult.UNDERFLOW;\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/cs\/ISO_8859_1.java","additions":21,"deletions":21,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n+\n@@ -51,0 +54,3 @@\n+\n+        private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n+\n@@ -91,0 +97,5 @@\n+            if (isASCIICompatible) {\n+                int n = JLA.decodeASCII(sa, sp, da, dp, Math.min(dl - dp, sl - sp));\n+                sp += n;\n+                dp += n;\n+            }\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/cs\/SingleByte.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-import java.io.FileInputStream;\n@@ -45,0 +44,1 @@\n+import java.nio.charset.UnsupportedCharsetException;\n@@ -46,2 +46,1 @@\n-public class StreamDecoder extends Reader\n-{\n+public class StreamDecoder extends Reader {\n@@ -75,1 +74,1 @@\n-        if (csn == null)\n+        if (csn == null) {\n@@ -77,0 +76,1 @@\n+        }\n@@ -78,4 +78,4 @@\n-            if (Charset.isSupported(csn))\n-                return new StreamDecoder(in, lock, Charset.forName(csn));\n-        } catch (IllegalCharsetNameException x) { }\n-        throw new UnsupportedEncodingException (csn);\n+            return new StreamDecoder(in, lock, Charset.forName(csn));\n+        } catch (IllegalCharsetNameException | UnsupportedCharsetException x) {\n+            throw new UnsupportedEncodingException (csn);\n+        }\n@@ -136,1 +136,1 @@\n-            char cb[] = new char[2];\n+            char[] cb = new char[2];\n@@ -154,1 +154,1 @@\n-    public int read(char cbuf[], int offset, int length) throws IOException {\n+    public int read(char[] cbuf, int offset, int length) throws IOException {\n@@ -218,20 +218,3 @@\n-    \/\/ In the early stages of the build we haven't yet built the NIO native\n-    \/\/ code, so guard against that by catching the first UnsatisfiedLinkError\n-    \/\/ and setting this flag so that later attempts fail quickly.\n-    \/\/\n-    private static volatile boolean channelsAvailable = true;\n-\n-    private static FileChannel getChannel(FileInputStream in) {\n-        if (!channelsAvailable)\n-            return null;\n-        try {\n-            return in.getChannel();\n-        } catch (UnsatisfiedLinkError x) {\n-            channelsAvailable = false;\n-            return null;\n-        }\n-    }\n-\n-    private Charset cs;\n-    private CharsetDecoder decoder;\n-    private ByteBuffer bb;\n+    private final Charset cs;\n+    private final CharsetDecoder decoder;\n+    private final ByteBuffer bb;\n@@ -240,2 +223,2 @@\n-    private InputStream in;\n-    private ReadableByteChannel ch;\n+    private final InputStream in;\n+    private final ReadableByteChannel ch;\n@@ -245,3 +228,3 @@\n-         cs.newDecoder()\n-         .onMalformedInput(CodingErrorAction.REPLACE)\n-         .onUnmappableCharacter(CodingErrorAction.REPLACE));\n+            cs.newDecoder()\n+                .onMalformedInput(CodingErrorAction.REPLACE)\n+                .onUnmappableCharacter(CodingErrorAction.REPLACE));\n@@ -254,8 +237,0 @@\n-\n-        \/\/ This path disabled until direct buffers are faster\n-        if (false && in instanceof FileInputStream) {\n-        ch = getChannel((FileInputStream)in);\n-        if (ch != null)\n-            bb = ByteBuffer.allocateDirect(DEFAULT_BYTE_BUFFER_SIZE);\n-        }\n-        if (ch == null) {\n@@ -265,1 +240,0 @@\n-        }\n@@ -285,20 +259,19 @@\n-        if (ch != null) {\n-            \/\/ Read from the channel\n-            int n = ch.read(bb);\n-            if (n < 0)\n-                return n;\n-        } else {\n-            \/\/ Read from the input stream, and then update the buffer\n-            int lim = bb.limit();\n-            int pos = bb.position();\n-            assert (pos <= lim);\n-            int rem = (pos <= lim ? lim - pos : 0);\n-            assert rem > 0;\n-            int n = in.read(bb.array(), bb.arrayOffset() + pos, rem);\n-            if (n < 0)\n-                return n;\n-            if (n == 0)\n-                throw new IOException(\"Underlying input stream returned zero bytes\");\n-            assert (n <= rem) : \"n = \" + n + \", rem = \" + rem;\n-            bb.position(pos + n);\n-        }\n+            if (ch != null) {\n+                \/\/ Read from the channel\n+                int n = ch.read(bb);\n+                if (n < 0)\n+                    return n;\n+            } else {\n+                \/\/ Read from the input stream, and then update the buffer\n+                int lim = bb.limit();\n+                int pos = bb.position();\n+                assert (pos <= lim);\n+                int rem = (pos <= lim ? lim - pos : 0);\n+                int n = in.read(bb.array(), bb.arrayOffset() + pos, rem);\n+                if (n < 0)\n+                    return n;\n+                if (n == 0)\n+                    throw new IOException(\"Underlying input stream returned zero bytes\");\n+                assert (n <= rem) : \"n = \" + n + \", rem = \" + rem;\n+                bb.position(pos + n);\n+            }\n@@ -306,3 +279,3 @@\n-        \/\/ Flip even when an IOException is thrown,\n-        \/\/ otherwise the stream will stutter\n-        bb.flip();\n+            \/\/ Flip even when an IOException is thrown,\n+            \/\/ otherwise the stream will stutter\n+            bb.flip();\n@@ -312,2 +285,2 @@\n-            assert (rem != 0) : rem;\n-            return rem;\n+        assert (rem != 0) : rem;\n+        return rem;\n@@ -325,3 +298,4 @@\n-        if (cb.position() != 0)\n-        \/\/ Ensure that cb[0] == cbuf[off]\n-        cb = cb.slice();\n+        if (cb.position() != 0) {\n+            \/\/ Ensure that cb[0] == cbuf[off]\n+            cb = cb.slice();\n+        }\n@@ -331,12 +305,5 @@\n-        CoderResult cr = decoder.decode(bb, cb, eof);\n-        if (cr.isUnderflow()) {\n-            if (eof)\n-                break;\n-            if (!cb.hasRemaining())\n-                break;\n-            if ((cb.position() > 0) && !inReady())\n-                break;          \/\/ Block at most once\n-            int n = readBytes();\n-            if (n < 0) {\n-                eof = true;\n-                if ((cb.position() == 0) && (!bb.hasRemaining()))\n+            CoderResult cr = decoder.decode(bb, cb, eof);\n+            if (cr.isUnderflow()) {\n+                if (eof)\n+                    break;\n+                if (!cb.hasRemaining())\n@@ -344,1 +311,10 @@\n-                decoder.reset();\n+                if ((cb.position() > 0) && !inReady())\n+                    break;          \/\/ Block at most once\n+                int n = readBytes();\n+                if (n < 0) {\n+                    eof = true;\n+                    if ((cb.position() == 0) && (!bb.hasRemaining()))\n+                        break;\n+                    decoder.reset();\n+                }\n+                continue;\n@@ -346,7 +322,5 @@\n-            continue;\n-        }\n-        if (cr.isOverflow()) {\n-            assert cb.position() > 0;\n-            break;\n-        }\n-        cr.throwException();\n+            if (cr.isOverflow()) {\n+                assert cb.position() > 0;\n+                break;\n+            }\n+            cr.throwException();\n@@ -356,2 +330,2 @@\n-        \/\/ ## Need to flush decoder\n-        decoder.reset();\n+            \/\/ ## Need to flush decoder\n+            decoder.reset();\n@@ -361,1 +335,1 @@\n-            if (eof)\n+            if (eof) {\n@@ -363,0 +337,1 @@\n+            }\n@@ -376,2 +351,2 @@\n-        return (((in != null) && (in.available() > 0))\n-                || (ch instanceof FileChannel)); \/\/ ## RBC.available()?\n+            return (((in != null) && (in.available() > 0))\n+                    || (ch instanceof FileChannel)); \/\/ ## RBC.available()?\n@@ -379,1 +354,1 @@\n-        return false;\n+            return false;\n@@ -384,1 +359,1 @@\n-            return bb.hasRemaining() || inReady();\n+        return bb.hasRemaining() || inReady();\n@@ -388,4 +363,5 @@\n-        if (ch != null)\n-        ch.close();\n-        else\n-        in.close();\n+        if (ch != null) {\n+            ch.close();\n+        } else {\n+            in.close();\n+        }\n@@ -393,1 +369,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/cs\/StreamDecoder.java","additions":80,"deletions":105,"binary":false,"changes":185,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.io.FileOutputStream;\n@@ -41,0 +40,1 @@\n+import java.nio.charset.UnsupportedCharsetException;\n@@ -61,1 +61,1 @@\n-        if (csn == null)\n+        if (csn == null) {\n@@ -63,0 +63,1 @@\n+        }\n@@ -64,4 +65,4 @@\n-            if (Charset.isSupported(csn))\n-                return new StreamEncoder(out, lock, Charset.forName(csn));\n-        } catch (IllegalCharsetNameException x) { }\n-        throw new UnsupportedEncodingException (csn);\n+            return new StreamEncoder(out, lock, Charset.forName(csn));\n+        } catch (IllegalCharsetNameException | UnsupportedCharsetException x) {\n+            throw new UnsupportedEncodingException (csn);\n+        }\n@@ -117,1 +118,1 @@\n-        char cbuf[] = new char[1];\n+        char[] cbuf = new char[1];\n@@ -122,1 +123,1 @@\n-    public void write(char cbuf[], int off, int len) throws IOException {\n+    public void write(char[] cbuf, int off, int len) throws IOException {\n@@ -139,1 +140,1 @@\n-        char cbuf[] = new char[len];\n+        char[] cbuf = new char[len];\n@@ -182,3 +183,3 @@\n-    private Charset cs;\n-    private CharsetEncoder encoder;\n-    private ByteBuffer bb;\n+    private final Charset cs;\n+    private final CharsetEncoder encoder;\n+    private final ByteBuffer bb;\n@@ -188,1 +189,1 @@\n-    private WritableByteChannel ch;\n+    private final WritableByteChannel ch;\n@@ -197,3 +198,3 @@\n-         cs.newEncoder()\n-         .onMalformedInput(CodingErrorAction.REPLACE)\n-         .onUnmappableCharacter(CodingErrorAction.REPLACE));\n+            cs.newEncoder()\n+                .onMalformedInput(CodingErrorAction.REPLACE)\n+                .onUnmappableCharacter(CodingErrorAction.REPLACE));\n@@ -208,10 +209,1 @@\n-\n-        \/\/ This path disabled until direct buffers are faster\n-        if (false && out instanceof FileOutputStream) {\n-                ch = ((FileOutputStream)out).getChannel();\n-        if (ch != null)\n-                    bb = ByteBuffer.allocateDirect(DEFAULT_BYTE_BUFFER_SIZE);\n-        }\n-            if (ch == null) {\n-        bb = ByteBuffer.allocate(DEFAULT_BYTE_BUFFER_SIZE);\n-        }\n+        this.bb = ByteBuffer.allocate(DEFAULT_BYTE_BUFFER_SIZE);\n@@ -237,7 +229,7 @@\n-            if (rem > 0) {\n-        if (ch != null) {\n-            if (ch.write(bb) != rem)\n-                assert false : rem;\n-        } else {\n-            out.write(bb.array(), bb.arrayOffset() + pos, rem);\n-        }\n+        if (rem > 0) {\n+            if (ch != null) {\n+                int wc = ch.write(bb);\n+                assert wc == rem : rem;\n+            } else {\n+                out.write(bb.array(), bb.arrayOffset() + pos, rem);\n+            }\n@@ -246,1 +238,1 @@\n-        }\n+    }\n@@ -286,1 +278,1 @@\n-    void implWrite(char cbuf[], int off, int len)\n+    void implWrite(char[] cbuf, int off, int len)\n@@ -320,2 +312,3 @@\n-        if (bb.position() > 0)\n-        writeBytes();\n+        if (bb.position() > 0) {\n+            writeBytes();\n+        }\n@@ -326,2 +319,3 @@\n-        if (out != null)\n-        out.flush();\n+        if (out != null) {\n+            out.flush();\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/cs\/StreamEncoder.java","additions":34,"deletions":40,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n+\n@@ -63,0 +66,2 @@\n+        private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n+\n@@ -71,4 +76,4 @@\n-            int sp = src.arrayOffset() + src.position();\n-            int sl = src.arrayOffset() + src.limit();\n-            assert (sp <= sl);\n-            sp = (sp <= sl ? sp : sl);\n+            int soff = src.arrayOffset();\n+            int sp = soff + src.position();\n+            int sl = soff + src.limit();\n+\n@@ -76,4 +81,3 @@\n-            int dp = dst.arrayOffset() + dst.position();\n-            int dl = dst.arrayOffset() + dst.limit();\n-            assert (dp <= dl);\n-            dp = (dp <= dl ? dp : dl);\n+            int doff = dst.arrayOffset();\n+            int dp = doff + dst.position();\n+            int dl = doff + dst.limit();\n@@ -81,11 +85,9 @@\n-            try {\n-                while (sp < sl) {\n-                    byte b = sa[sp];\n-                    if (b >= 0) {\n-                        if (dp >= dl)\n-                            return CoderResult.OVERFLOW;\n-                        da[dp++] = (char)b;\n-                        sp++;\n-                        continue;\n-                    }\n-                    return CoderResult.malformedForLength(1);\n+            \/\/ ASCII only loop\n+            int n = JLA.decodeASCII(sa, sp, da, dp, Math.min(sl - sp, dl - dp));\n+            sp += n;\n+            dp += n;\n+            src.position(sp - soff);\n+            dst.position(dp - doff);\n+            if (sp < sl) {\n+                if (dp >= dl) {\n+                    return CoderResult.OVERFLOW;\n@@ -93,4 +95,1 @@\n-                return CoderResult.UNDERFLOW;\n-            } finally {\n-                src.position(sp - src.arrayOffset());\n-                dst.position(dp - dst.arrayOffset());\n+                return CoderResult.malformedForLength(1);\n@@ -98,0 +97,1 @@\n+            return CoderResult.UNDERFLOW;\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/cs\/US_ASCII.java","additions":24,"deletions":24,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n+\n@@ -85,0 +88,2 @@\n+        private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n+\n@@ -132,9 +137,0 @@\n-        private static CoderResult lookupN(ByteBuffer src, int n)\n-        {\n-            for (int i = 1; i < n; i++) {\n-               if (isNotContinuation(src.get()))\n-                   return CoderResult.malformedForLength(i);\n-            }\n-            return CoderResult.malformedForLength(n);\n-        }\n-\n@@ -226,2 +222,3 @@\n-            int sp = src.arrayOffset() + src.position();\n-            int sl = src.arrayOffset() + src.limit();\n+            int soff = src.arrayOffset();\n+            int sp = soff + src.position();\n+            int sl = soff + src.limit();\n@@ -230,3 +227,7 @@\n-            int dp = dst.arrayOffset() + dst.position();\n-            int dl = dst.arrayOffset() + dst.limit();\n-            int dlASCII = dp + Math.min(sl - sp, dl - dp);\n+            int doff = dst.arrayOffset();\n+            int dp = doff + dst.position();\n+            int dl = doff + dst.limit();\n+\n+            int n = JLA.decodeASCII(sa, sp, da, dp, Math.min(sl - sp, dl - dp));\n+            sp += n;\n+            dp += n;\n@@ -234,3 +235,0 @@\n-            \/\/ ASCII only loop\n-            while (dp < dlASCII && sa[sp] >= 0)\n-                da[dp++] = (char) sa[sp++];\n@@ -418,8 +416,0 @@\n-\n-        private static ByteBuffer getByteBuffer(ByteBuffer bb, byte[] ba, int sp)\n-        {\n-            if (bb == null)\n-                bb = ByteBuffer.wrap(ba);\n-            bb.position(sp);\n-            return bb;\n-        }\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/cs\/UTF_8.java","additions":16,"deletions":26,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -0,0 +1,176 @@\n+\/*\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.io;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.nio.charset.Charset;\n+import java.util.concurrent.TimeUnit;\n+\n+\/**\n+ * Tests the overheads of reading encoded byte arrays via StreamDecoder\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(time=2, iterations=5)\n+@Measurement(time=3, iterations=5)\n+@Fork(value=2, jvmArgs=\"-Xmx1g\")\n+public class ByteStreamDecoder {\n+\n+    @Param({\"US-ASCII\", \"ISO-8859-1\", \"UTF-8\", \"ISO-8859-6\", \"MS932\"})\n+    private String charsetName;\n+\n+    @Param({\"256\", \"4096\", \"25000\"})\n+    private int length;\n+\n+    private byte[] bytes;\n+\n+    private byte[] nonASCIIBytesEnd;\n+\n+    private byte[] nonASCIIBytesStart;\n+\n+    private byte[] nonASCIIBytesEveryOther;\n+\n+    private char[] chars;\n+\n+    private Charset cs;\n+\n+    @Setup\n+    public void setup() throws IOException {\n+        var s = \"\"\"\n+            Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed non\n+            magna augue. Sed tristique ante id maximus interdum. Suspendisse\n+            potenti. Aliquam molestie metus vitae magna gravida egestas.\n+            Phasellus eleifend tortor sit amet neque euismod, vitae luctus\n+            ante viverra. Sed quis justo ultrices, eleifend dui sed, egestas\n+            lorem. Mauris ipsum ex, interdum eu turpis sed, fermentum efficitur\n+            lorem. Sed vel imperdiet libero, eget ullamcorper sem. Praesent\n+            gravida arcu quis ipsum viverra tristique. Quisque maximus\n+            elit nec nisi vulputate tempor. Integer aliquet tortor vel\n+            vehicula efficitur. Sed neque felis, ultricies eu leo ultricies,\n+            egestas placerat dolor. Etiam iaculis magna quis lacinia\n+            tincidunt. Donec in tellus volutpat, semper nunc ornare,\n+            tempus erat. Donec volutpat mauris in arcu mattis sollicitudin.\n+            Morbi vestibulum ipsum sed erat porta, mollis commodo nisi\n+            gravida.\n+            \"\"\";\n+        int n = length \/ s.length();\n+        String full = \"\";\n+        if (n > 0) {\n+            full = s.repeat(n);\n+        }\n+        n = length % s.length();\n+        if (n > 0) {\n+            full += s.substring(0, n);\n+        }\n+        cs = Charset.forName(charsetName);\n+        bytes = full.getBytes(cs);\n+        nonASCIIBytesEnd = (full + \"\\u00e5\").getBytes(cs);\n+        nonASCIIBytesStart = (\"\\u00e5\" + full).getBytes(cs);\n+\n+        \/\/ string hostile to ASCII fast-path optimizations: every other char is ASCII\n+        StringBuilder sb = new StringBuilder();\n+        for (int i = 0; i < full.length(); i++) {\n+            sb.append(i % 2 == 0 ? full.charAt(i) : '\\u00e5');\n+        }\n+        nonASCIIBytesEveryOther = sb.toString().getBytes(cs);\n+        chars = new char[full.length() + 2];\n+\n+        try {\n+            if (!readStringDirect().equals(readStringReader())) {\n+                System.out.println(\"direct: \" + readStringDirect());\n+                System.out.println(\"reader: \" + readStringReader());\n+                throw new RuntimeException(\"Unexpectedly different\");\n+            }\n+            if (!readStringDirect_NonASCIIEnd().equals(readStringReader_NonASCIIEnd())) {\n+                throw new RuntimeException(\"Unexpectedly different\");\n+            }\n+            if (!readStringDirect_NonASCIIStart().equals(readStringReader_NonASCIIStart())) {\n+                throw new RuntimeException(\"Unexpectedly different\");\n+            }\n+            if (!readStringDirect_NonASCIIEveryOther().equals(readStringReader_NonASCIIEveryOther())) {\n+                throw new RuntimeException(\"Unexpectedly different\");\n+            }\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    @Benchmark\n+    public String readStringReader() throws Exception {\n+        int len = new InputStreamReader(new ByteArrayInputStream(bytes), cs).read(chars);\n+        return new String(chars, 0, len);\n+    }\n+\n+    @Benchmark\n+    public String readStringReader_NonASCIIEnd() throws Exception {\n+        int len = new InputStreamReader(new ByteArrayInputStream(nonASCIIBytesEnd), cs).read(chars);\n+        return new String(chars, 0, len);\n+    }\n+\n+    @Benchmark\n+    public String readStringReader_NonASCIIStart() throws Exception {\n+        int len = new InputStreamReader(new ByteArrayInputStream(nonASCIIBytesStart), cs).read(chars);\n+        return new String(chars, 0, len);\n+    }\n+\n+    @Benchmark\n+    public String readStringReader_NonASCIIEveryOther() throws Exception {\n+        int len = new InputStreamReader(new ByteArrayInputStream(nonASCIIBytesEveryOther), cs).read(chars);\n+        return new String(chars, 0, len);\n+    }\n+\n+    @Benchmark\n+    public String readStringDirect() throws Exception {\n+        return new String(bytes, cs);\n+    }\n+\n+    @Benchmark\n+    public String readStringDirect_NonASCIIEnd() throws Exception {\n+        return new String(nonASCIIBytesEnd, cs);\n+    }\n+\n+    @Benchmark\n+    public String readStringDirect_NonASCIIStart() throws Exception {\n+        return new String(nonASCIIBytesStart, cs);\n+    }\n+\n+    @Benchmark\n+    public String readStringDirect_NonASCIIEveryOther() throws Exception {\n+        return new String(nonASCIIBytesEveryOther, cs);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/io\/ByteStreamDecoder.java","additions":176,"deletions":0,"binary":false,"changes":176,"status":"added"}]}