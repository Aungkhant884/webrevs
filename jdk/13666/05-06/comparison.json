{"files":[{"patch":"@@ -34,2 +34,2 @@\n-void G1CollectionCandidateList::merge(G1CollectionCandidateList::CandidateInfo* candidate_infos, uint num_infos) {\n-  bool was_empty = _candidates.is_empty();\n+void G1CollectionCandidateList::set(G1CollectionCandidateList::CandidateInfo* candidate_infos, uint num_infos) {\n+  assert(_candidates.is_empty(), \"must be\");\n@@ -39,6 +39,0 @@\n-\n-  if (!was_empty) {\n-    \/\/ Just sort everything if there were already regions in the candidates to maintain\n-    \/\/ order. This should be a rare case.\n-    _candidates.sort(order_regions);\n-  }\n@@ -55,2 +49,1 @@\n-  other->verify();\n-\n+  size_t reclaimable_bytes_removed = 0;\n@@ -69,0 +62,1 @@\n+      reclaimable_bytes_removed += _candidates.at(candidate_idx)._r->reclaimable_bytes();\n@@ -76,1 +70,1 @@\n-  return other->reclaimable_bytes();\n+  return reclaimable_bytes_removed;\n@@ -136,3 +130,1 @@\n-G1CollectionSetRegionList::G1CollectionSetRegionList() :\n-  _regions(2, mtGC), _reclaimable_bytes(0) {\n-}\n+G1CollectionSetRegionList::G1CollectionSetRegionList() : _regions(2, mtGC) { }\n@@ -143,1 +135,0 @@\n-  _reclaimable_bytes += r->reclaimable_bytes();\n@@ -160,1 +151,0 @@\n-  _reclaimable_bytes -= other->reclaimable_bytes();\n@@ -169,1 +159,0 @@\n-  _reclaimable_bytes = 0;\n@@ -172,13 +161,0 @@\n-#ifndef PRODUCT\n-void G1CollectionSetRegionList::verify() {\n-  \/\/ We can't verify sorting because this list does not store efficiencies which\n-  \/\/ can change between invocations.\n-\n-  size_t reclaimable_bytes = 0;\n-  for (HeapRegion* r : _regions) {\n-    reclaimable_bytes += r->reclaimable_bytes();\n-  }\n-  assert(_reclaimable_bytes == reclaimable_bytes, \"Mismatch between calculated and stored reclaimable bytes\");\n-}\n-#endif\n-\n@@ -198,1 +174,1 @@\n-  _marking_regions(), _contains_map(nullptr), _max_regions(0), _last_merge_length(0), _reclaimable_bytes(0) { }\n+  _marking_regions(), _contains_map(nullptr), _max_regions(0), _last_marking_candidates_length(0), _reclaimable_bytes(0) { }\n@@ -222,1 +198,1 @@\n-  _last_merge_length = 0;\n+  _last_marking_candidates_length = 0;\n@@ -225,1 +201,3 @@\n-void G1CollectionSetCandidates::merge_candidates_from_marking(G1CollectionCandidateList::CandidateInfo* candidate_infos, uint num_infos, size_t reclaimable_bytes) {\n+void G1CollectionSetCandidates::set_candidates_from_marking(G1CollectionCandidateList::CandidateInfo* candidate_infos,\n+                                                            uint num_infos,\n+                                                            size_t reclaimable_bytes) {\n@@ -230,1 +208,1 @@\n-  _marking_regions.merge(candidate_infos, num_infos);\n+  _marking_regions.set(candidate_infos, num_infos);\n@@ -236,1 +214,1 @@\n-  _last_merge_length = num_infos;\n+  _last_marking_candidates_length = num_infos;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetCandidates.cpp","additions":13,"deletions":35,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -46,1 +46,0 @@\n-  size_t _reclaimable_bytes;\n@@ -64,2 +63,0 @@\n-  size_t reclaimable_bytes() const { return _reclaimable_bytes; }\n-\n@@ -108,2 +105,2 @@\n-  \/\/ Merge the given set of candidates into this list, preserving the efficiency ordering.\n-  void merge(CandidateInfo* candidate_infos, uint num_infos);\n+  \/\/ Put the given set of candidates into this list, preserving the efficiency ordering.\n+  void set(CandidateInfo* candidate_infos, uint num_infos);\n@@ -183,1 +180,1 @@\n-  uint _last_merge_length;\n+  uint _last_marking_candidates_length;\n@@ -201,3 +198,3 @@\n-  void merge_candidates_from_marking(G1CollectionCandidateList::CandidateInfo* candidate_infos,\n-                                     uint num_infos,\n-                                     size_t reclaimable_bytes);\n+  void set_candidates_from_marking(G1CollectionCandidateList::CandidateInfo* candidate_infos,\n+                                   uint num_infos,\n+                                   size_t reclaimable_bytes);\n@@ -205,1 +202,1 @@\n-  \/\/ merge_candidates_from_marking(). Used for calculating minimum collection set\n+  \/\/ set_candidates_from_marking(). Used for calculating minimum collection set\n@@ -207,1 +204,1 @@\n-  uint last_merge_length() const { return _last_merge_length; }\n+  uint last_marking_candidates_length() const { return _last_marking_candidates_length; }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetCandidates.hpp","additions":8,"deletions":11,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -114,39 +114,0 @@\n-    \/\/ Early prune (remove) regions meeting the G1HeapWastePercent criteria. That\n-    \/\/ is, either until only the minimum amount of old collection set regions are\n-    \/\/ available (for forward progress in evacuation) or the waste accumulated by the\n-    \/\/ removed regions is above the maximum allowed waste.\n-    void prune(uint num_candidates, uint& num_pruned, size_t& wasted_bytes) {\n-      G1Policy* p = G1CollectedHeap::heap()->policy();\n-\n-      uint min_old_cset_length = p->calc_min_old_cset_length(num_candidates);\n-      num_pruned = 0;\n-      wasted_bytes = 0;\n-\n-      if (min_old_cset_length >= num_candidates) {\n-        \/\/ We take all of the candidate regions to provide some forward progress.\n-        return;\n-      }\n-\n-      size_t allowed_waste = p->allowed_waste_in_collection_set();\n-      uint max_to_prune = num_candidates - min_old_cset_length;\n-\n-      while (true) {\n-        HeapRegion* r = _data[num_candidates - num_pruned - 1]._r;\n-        size_t const reclaimable = r->reclaimable_bytes();\n-        if (num_pruned >= max_to_prune ||\n-            wasted_bytes + reclaimable > allowed_waste) {\n-          break;\n-        }\n-        r->rem_set()->clear(true \/* cardset_only *\/);\n-\n-        wasted_bytes += reclaimable;\n-        num_pruned++;\n-      }\n-\n-      log_debug(gc, ergo, cset)(\"Pruned %u regions out of %u, leaving \" SIZE_FORMAT \" bytes waste (allowed \" SIZE_FORMAT \")\",\n-                                num_pruned,\n-                                num_candidates,\n-                                wasted_bytes,\n-                                allowed_waste);\n-    }\n-\n@@ -198,3 +159,2 @@\n-      } else if (r->is_old() && !r->is_collection_set_candidate()) {\n-        \/\/ Keep remembered sets for humongous regions and regions in the collection\n-        \/\/ set candidates, otherwise clean them out.\n+      } else if (r->is_old()) {\n+        \/\/ Keep remembered sets for humongous regions, otherwise clean them out.\n@@ -232,0 +192,45 @@\n+  \/\/ Early prune (remove) regions meeting the G1HeapWastePercent criteria. That\n+  \/\/ is, either until only the minimum amount of old collection set regions are\n+  \/\/ available (for forward progress in evacuation) or the waste accumulated by the\n+  \/\/ removed regions is above the maximum allowed waste.\n+  \/\/ Updates number of candidates and reclaimable bytes given.\n+  void prune(CandidateInfo* data) {\n+    G1Policy* p = G1CollectedHeap::heap()->policy();\n+\n+    uint num_candidates = Atomic::load(&_num_regions_added);\n+\n+    uint min_old_cset_length = p->calc_min_old_cset_length(num_candidates);\n+    uint num_pruned = 0;\n+    size_t wasted_bytes = 0;\n+\n+    if (min_old_cset_length >= num_candidates) {\n+      \/\/ We take all of the candidate regions to provide some forward progress.\n+      return;\n+    }\n+\n+    size_t allowed_waste = p->allowed_waste_in_collection_set();\n+    uint max_to_prune = num_candidates - min_old_cset_length;\n+\n+    while (true) {\n+      HeapRegion* r = data[num_candidates - num_pruned - 1]._r;\n+      size_t const reclaimable = r->reclaimable_bytes();\n+      if (num_pruned >= max_to_prune ||\n+          wasted_bytes + reclaimable > allowed_waste) {\n+        break;\n+      }\n+      r->rem_set()->clear(true \/* cardset_only *\/);\n+\n+      wasted_bytes += reclaimable;\n+      num_pruned++;\n+    }\n+\n+    log_debug(gc, ergo, cset)(\"Pruned %u regions out of %u, leaving \" SIZE_FORMAT \" bytes waste (allowed \" SIZE_FORMAT \")\",\n+                              num_pruned,\n+                              num_candidates,\n+                              wasted_bytes,\n+                              allowed_waste);\n+\n+    Atomic::sub(&_num_regions_added, num_pruned, memory_order_relaxed);\n+    Atomic::sub(&_reclaimable_bytes_added, wasted_bytes, memory_order_relaxed);\n+  }\n+\n@@ -249,8 +254,4 @@\n-\n-    uint num_pruned;\n-    size_t pruned_wasted_bytes;\n-\n-    _result.prune(_num_regions_added, num_pruned, pruned_wasted_bytes);\n-    candidates->merge_candidates_from_marking(_result.array(),\n-                                              _num_regions_added - num_pruned,\n-                                              _reclaimable_bytes_added - pruned_wasted_bytes);\n+    prune(_result.array());\n+    candidates->set_candidates_from_marking(_result.array(),\n+                                            _num_regions_added,\n+                                            _reclaimable_bytes_added);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetChooser.cpp","additions":51,"deletions":50,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -488,1 +488,1 @@\n-  uint min_marking_candidates = MIN2(calc_min_old_cset_length(candidates()->last_merge_length()),\n+  uint min_marking_candidates = MIN2(calc_min_old_cset_length(candidates()->last_marking_candidates_length()),\n@@ -1430,1 +1430,1 @@\n-  const uint min_old_cset_length = calc_min_old_cset_length(candidates()->last_merge_length());\n+  const uint min_old_cset_length = calc_min_old_cset_length(candidates()->last_marking_candidates_length());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -298,2 +298,1 @@\n-  \/\/ Retained regions are not going to be scanned through.\n-  if (is_old_or_humongous() && !is_collection_set_candidate()) {\n+  if (is_old_or_humongous()) {\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.inline.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"}]}