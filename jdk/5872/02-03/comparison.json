{"files":[{"patch":"@@ -0,0 +1,288 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.io;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.lang.ref.SoftReference;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+\/**\n+ * Benchmark for {@link InputStream} skip functions.\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Warmup(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Fork(value = 3, jvmArgsAppend = {\"-Xms1g\", \"-Xmx1g\"})\n+public class InputStreamSkipBenchmark {\n+\n+    @Benchmark\n+    public long testSkip0(Data data) throws IOException {\n+        TestBaseInputStream0 testBaseInputStream = new TestBaseInputStream0(data.inputStreamSize);\n+        long res;\n+        do {\n+            res = testBaseInputStream.skip(data.skipLength);\n+        } while (res != 0);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public long testSkip1(Data data) throws IOException {\n+        TestBaseInputStream1 testBaseInputStream = new TestBaseInputStream1(data.inputStreamSize);\n+        long res;\n+        do {\n+            res = testBaseInputStream.skip(data.skipLength);\n+        } while (res != 0);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public long testSkip2(Data data) throws IOException {\n+        TestBaseInputStream2 testBaseInputStream = new TestBaseInputStream2(data.inputStreamSize);\n+        long res;\n+        do {\n+            res = testBaseInputStream.skip(data.skipLength);\n+        } while (res != 0);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public long testSkip3(Data data) throws IOException {\n+        TestBaseInputStream3 testBaseInputStream = new TestBaseInputStream3(data.inputStreamSize);\n+        long res;\n+        do {\n+            res = testBaseInputStream.skip(data.skipLength);\n+        } while (res != 0);\n+        return res;\n+    }\n+\n+    @State(Scope.Thread)\n+    public static class Data {\n+\n+        @Param({\"1000000\"})\n+        private int inputStreamSize;\n+\n+        @Param({\"1\", \"8\", \"32\", \"128\", \"512\", \"2048\", \"8192\"})\n+        private int skipLength;\n+\n+        @Setup\n+        public void setup() {\n+\n+        }\n+    }\n+\n+    static class TestBaseInputStream extends InputStream {\n+\n+        protected static final int MAX_SKIP_BUFFER_SIZE = 2048;\n+\n+        private int length;\n+\n+        public TestBaseInputStream(int length) {\n+            this.length = length;\n+        }\n+\n+        @Override\n+        public int read() throws IOException {\n+            if (length > 0) {\n+                --length;\n+                return 0;\n+            }\n+            return -1;\n+        }\n+\n+        @Override\n+        public int read(byte[] b, int off, int len) throws IOException {\n+            if (length > len) {\n+                length -= len;\n+                return len;\n+            } else if (length > 0) {\n+                len = length;\n+                length = 0;\n+                return len;\n+            } else {\n+                return -1;\n+            }\n+        }\n+\n+    }\n+\n+    static class TestBaseInputStream0 extends TestBaseInputStream {\n+\n+        public TestBaseInputStream0(int length) {\n+            super(length);\n+        }\n+\n+        public long skip(long n) throws IOException {\n+            long remaining = n;\n+            int nr;\n+\n+            if (n <= 0) {\n+                return 0;\n+            }\n+\n+            int size = (int) Math.min(MAX_SKIP_BUFFER_SIZE, remaining);\n+            byte[] skipBuffer = new byte[size];\n+            while (remaining > 0) {\n+                nr = read(skipBuffer, 0, (int) Math.min(size, remaining));\n+                if (nr < 0) {\n+                    break;\n+                }\n+                remaining -= nr;\n+            }\n+\n+            return n - remaining;\n+        }\n+    }\n+\n+    static class TestBaseInputStream1 extends TestBaseInputStream {\n+\n+        public TestBaseInputStream1(int length) {\n+            super(length);\n+        }\n+\n+        private byte[] skipBuffer;\n+\n+        @Override\n+        public long skip(long n) throws IOException {\n+            long remaining = n;\n+\n+            if (n <= 0) {\n+                return 0;\n+            }\n+\n+            int size = (int) Math.min(MAX_SKIP_BUFFER_SIZE, remaining);\n+\n+            byte[] skipBuffer = this.skipBuffer;\n+            if ((skipBuffer == null) || (skipBuffer.length < size)) {\n+                this.skipBuffer = skipBuffer = new byte[size];\n+            }\n+\n+            while (remaining > 0) {\n+                int nr = read(skipBuffer, 0, (int) Math.min(size, remaining));\n+                if (nr < 0) {\n+                    break;\n+                }\n+                remaining -= nr;\n+            }\n+\n+            return n - remaining;\n+        }\n+    }\n+\n+    static class TestBaseInputStream2 extends TestBaseInputStream {\n+\n+        public TestBaseInputStream2(int length) {\n+            super(length);\n+        }\n+\n+        private static final int MIN_SKIP_BUFFER_SIZE = 128;\n+\n+        private byte[] skipBuffer;\n+\n+        @Override\n+        public long skip(long n) throws IOException {\n+            long remaining = n;\n+\n+            if (n <= 0) {\n+                return 0;\n+            }\n+\n+            int size = (int) Math.min(MAX_SKIP_BUFFER_SIZE, remaining);\n+\n+            byte[] skipBuffer = this.skipBuffer;\n+            if ((skipBuffer == null) || (skipBuffer.length < size)) {\n+                this.skipBuffer = skipBuffer = new byte[size < MIN_SKIP_BUFFER_SIZE ? MIN_SKIP_BUFFER_SIZE :\n+                        MAX_SKIP_BUFFER_SIZE];\n+            }\n+\n+            while (remaining > 0) {\n+                int nr = read(skipBuffer, 0, (int) Math.min(size, remaining));\n+                if (nr < 0) {\n+                    break;\n+                }\n+                remaining -= nr;\n+            }\n+\n+            return n - remaining;\n+        }\n+    }\n+\n+    static class TestBaseInputStream3 extends TestBaseInputStream {\n+\n+        public TestBaseInputStream3(int length) {\n+            super(length);\n+        }\n+\n+        private static final int MIN_SKIP_BUFFER_SIZE = 128;\n+\n+        private SoftReference<byte[]> skipBufferReference;\n+\n+        private byte[] skipBufferReference(long remaining) {\n+            int size = (int) Math.min(MAX_SKIP_BUFFER_SIZE, remaining);\n+            SoftReference<byte[]> ref = this.skipBufferReference;\n+            byte[] buffer;\n+            if (ref == null || (buffer = ref.get()) == null || buffer.length < size) {\n+                buffer = new byte[size];\n+                this.skipBufferReference = new SoftReference<>(buffer);\n+            }\n+            return buffer;\n+        }\n+\n+        @Override\n+        public long skip(long n) throws IOException {\n+            long remaining = n;\n+\n+            if (n <= 0) {\n+                return 0;\n+            }\n+\n+            int size = (int) Math.min(MAX_SKIP_BUFFER_SIZE, remaining);\n+\n+            byte[] skipBuffer = this.skipBufferReference(size);\n+\n+            while (remaining > 0) {\n+                int nr = read(skipBuffer, 0, (int) Math.min(size, remaining));\n+                if (nr < 0) {\n+                    break;\n+                }\n+                remaining -= nr;\n+            }\n+\n+            return n - remaining;\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/io\/InputStreamSkipBenchmark.java","additions":288,"deletions":0,"binary":false,"changes":288,"status":"added"}]}