{"files":[{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.ref.SoftReference;\n@@ -58,0 +59,19 @@\n+    \/**\n+     * Only used in {@link #skip(long)}, for avoiding multiple times byte array allocation for a same InputStream Object.\n+     *\n+     * Making this static would increase performance,\n+     * but would make it possible to build a malicious subclass of InputStream to steal data from other InputStream Objects.\n+     * So DO NOT try to make it static, for the sake of security.\n+     *\/\n+    private SoftReference<byte[]> skipBufferReference;\n+\n+    private byte[] skipBufferReference(int size) {\n+        SoftReference<byte[]> ref = this.skipBufferReference;\n+        byte[] buffer;\n+        if (ref == null || (buffer = ref.get()) == null || buffer.length < size) {\n+            buffer = new byte[size];\n+            this.skipBufferReference = new SoftReference<>(buffer);\n+        }\n+        return buffer;\n+    }\n+\n@@ -538,1 +558,0 @@\n-        int nr;\n@@ -544,2 +563,4 @@\n-        int size = (int)Math.min(MAX_SKIP_BUFFER_SIZE, remaining);\n-        byte[] skipBuffer = new byte[size];\n+        int size = (int) Math.min(MAX_SKIP_BUFFER_SIZE, remaining);\n+\n+        byte[] skipBuffer = this.skipBufferReference(size);\n+\n@@ -547,1 +568,1 @@\n-            nr = read(skipBuffer, 0, (int)Math.min(size, remaining));\n+            int nr = read(skipBuffer, 0, (int) Math.min(size, remaining));\n","filename":"src\/java.base\/share\/classes\/java\/io\/InputStream.java","additions":25,"deletions":4,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -0,0 +1,282 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.io;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.lang.ref.SoftReference;\n+import java.util.Arrays;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+\/**\n+ * Benchmark for {@link InputStream} skip functions.\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Warmup(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Fork(value = 3, jvmArgsAppend = {\"-Xms1g\", \"-Xmx1g\"})\n+public class InputStreamSkipBenchmark {\n+\n+    @Benchmark\n+    public long testSkip(Data data) throws IOException {\n+        InputStream testBaseInputStream = data.inputStreamProvider.apply(data.inputStreamSize);\n+        long res;\n+        do {\n+            res = testBaseInputStream.skip(data.skipLength);\n+        } while (res != 0);\n+        return res;\n+    }\n+\n+    @State(Scope.Thread)\n+    public static class Data {\n+\n+        @Param({\"1000000\"})\n+        private int inputStreamSize;\n+\n+        @Param({\"1\", \"8\", \"32\", \"128\", \"512\", \"2048\", \"8192\"})\n+        private int skipLength;\n+\n+        @Param({\"LOCAL_VARIABLE\", \"FIELD\", \"FIELD_ONLY_MIN_MAX\", \"SOFT_REFERENCE\"})\n+        private String inputStreamType;\n+\n+        private Function<Integer, ? extends InputStream> inputStreamProvider;\n+\n+        @Setup\n+        public void setup() {\n+            switch (inputStreamType) {\n+                case \"LOCAL_VARIABLE\": {\n+                    this.inputStreamProvider = TestBaseInputStream0::new;\n+                    break;\n+                }\n+                case \"FIELD\": {\n+                    this.inputStreamProvider = TestBaseInputStream1::new;\n+                    break;\n+                }\n+                case \"FIELD_ONLY_MIN_MAX\": {\n+                    this.inputStreamProvider = TestBaseInputStream2::new;\n+                    break;\n+                }\n+                case \"SOFT_REFERENCE\": {\n+                    this.inputStreamProvider = TestBaseInputStream3::new;\n+                    break;\n+                }\n+                default:\n+                    \/\/ never\n+            }\n+        }\n+    }\n+\n+    static class TestBaseInputStream extends InputStream {\n+\n+        protected static final int MAX_SKIP_BUFFER_SIZE = 2048;\n+\n+        private int length;\n+\n+        public TestBaseInputStream(int length) {\n+            this.length = length;\n+        }\n+\n+        @Override\n+        public int read() throws IOException {\n+            if (length > 0) {\n+                --length;\n+                return 0;\n+            }\n+            return -1;\n+        }\n+\n+        @Override\n+        public int read(byte[] b, int off, int len) throws IOException {\n+            if (length <= 0) {\n+                return -1;\n+            }\n+            if (length < len) {\n+                len = length;\n+            }\n+            Arrays.fill(b, off, off + len, (byte) ThreadLocalRandom.current().nextInt());\n+            length -= len;\n+            return len;\n+        }\n+\n+    }\n+\n+    static class TestBaseInputStream0 extends TestBaseInputStream {\n+\n+        public TestBaseInputStream0(int length) {\n+            super(length);\n+        }\n+\n+        public long skip(long n) throws IOException {\n+            long remaining = n;\n+            int nr;\n+\n+            if (n <= 0) {\n+                return 0;\n+            }\n+\n+            int size = (int) Math.min(MAX_SKIP_BUFFER_SIZE, remaining);\n+            byte[] skipBuffer = new byte[size];\n+            while (remaining > 0) {\n+                nr = read(skipBuffer, 0, (int) Math.min(size, remaining));\n+                if (nr < 0) {\n+                    break;\n+                }\n+                remaining -= nr;\n+            }\n+\n+            return n - remaining;\n+        }\n+    }\n+\n+    static class TestBaseInputStream1 extends TestBaseInputStream {\n+\n+        public TestBaseInputStream1(int length) {\n+            super(length);\n+        }\n+\n+        private byte[] skipBuffer;\n+\n+        @Override\n+        public long skip(long n) throws IOException {\n+            long remaining = n;\n+\n+            if (n <= 0) {\n+                return 0;\n+            }\n+\n+            int size = (int) Math.min(MAX_SKIP_BUFFER_SIZE, remaining);\n+\n+            byte[] skipBuffer = this.skipBuffer;\n+            if ((skipBuffer == null) || (skipBuffer.length < size)) {\n+                this.skipBuffer = skipBuffer = new byte[size];\n+            }\n+\n+            while (remaining > 0) {\n+                int nr = read(skipBuffer, 0, (int) Math.min(size, remaining));\n+                if (nr < 0) {\n+                    break;\n+                }\n+                remaining -= nr;\n+            }\n+\n+            return n - remaining;\n+        }\n+    }\n+\n+    static class TestBaseInputStream2 extends TestBaseInputStream {\n+\n+        public TestBaseInputStream2(int length) {\n+            super(length);\n+        }\n+\n+        private static final int MIN_SKIP_BUFFER_SIZE = 128;\n+\n+        private byte[] skipBuffer;\n+\n+        @Override\n+        public long skip(long n) throws IOException {\n+            long remaining = n;\n+\n+            if (n <= 0) {\n+                return 0;\n+            }\n+\n+            int size = (int) Math.min(MAX_SKIP_BUFFER_SIZE, remaining);\n+\n+            byte[] skipBuffer = this.skipBuffer;\n+            if ((skipBuffer == null) || (skipBuffer.length < size)) {\n+                this.skipBuffer = skipBuffer = new byte[size < MIN_SKIP_BUFFER_SIZE ? MIN_SKIP_BUFFER_SIZE :\n+                        MAX_SKIP_BUFFER_SIZE];\n+            }\n+\n+            while (remaining > 0) {\n+                int nr = read(skipBuffer, 0, (int) Math.min(size, remaining));\n+                if (nr < 0) {\n+                    break;\n+                }\n+                remaining -= nr;\n+            }\n+\n+            return n - remaining;\n+        }\n+    }\n+\n+    static class TestBaseInputStream3 extends TestBaseInputStream {\n+\n+        public TestBaseInputStream3(int length) {\n+            super(length);\n+        }\n+\n+        private SoftReference<byte[]> skipBufferReference;\n+\n+        private byte[] skipBufferReference(long remaining) {\n+            int size = (int) Math.min(MAX_SKIP_BUFFER_SIZE, remaining);\n+            SoftReference<byte[]> ref = this.skipBufferReference;\n+            byte[] buffer;\n+            if (ref == null || (buffer = ref.get()) == null || buffer.length < size) {\n+                buffer = new byte[size];\n+                this.skipBufferReference = new SoftReference<>(buffer);\n+            }\n+            return buffer;\n+        }\n+\n+        @Override\n+        public long skip(long n) throws IOException {\n+            long remaining = n;\n+\n+            if (n <= 0) {\n+                return 0;\n+            }\n+\n+            int size = (int) Math.min(MAX_SKIP_BUFFER_SIZE, remaining);\n+\n+            byte[] skipBuffer = this.skipBufferReference(size);\n+\n+            while (remaining > 0) {\n+                int nr = read(skipBuffer, 0, (int) Math.min(size, remaining));\n+                if (nr < 0) {\n+                    break;\n+                }\n+                remaining -= nr;\n+            }\n+\n+            return n - remaining;\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/io\/InputStreamSkipBenchmark.java","additions":282,"deletions":0,"binary":false,"changes":282,"status":"added"}]}