{"files":[{"patch":"@@ -76,0 +76,1 @@\n+    unsigned int pendingAppResumeBreakpoint : 1;\n@@ -741,0 +742,9 @@\n+\/*\n+ * The caller must own handlerLock and threadLock.\n+ * The current thread waits on threadLock if the suspendCount of the given\n+ * thread is greather than 0 but before it releases the handlerLock. This is\n+ * necessary because threadControl_resumeThread() and threadControl_resumeAll()\n+ * need it.\n+ * handlerLock and threadLock are owned when returning and the suspendCount of\n+ * the given thread is 0.\n+ *\/\n@@ -749,0 +759,2 @@\n+            \/* handlerLock is needed for resume *\/\n+            eventHandler_unlock();\n@@ -750,0 +762,4 @@\n+\n+            debugMonitorExit(threadLock);\n+            eventHandler_lock(); \/* for proper lock order *\/\n+            debugMonitorEnter(threadLock);\n@@ -803,1 +819,1 @@\n-    jthread resumee = getResumee(resumer);\n+    ThreadNode *node;\n@@ -806,7 +822,0 @@\n-    if (resumee != NULL) {\n-        \/*\n-         * Hold up any attempt to resume as long as the debugger\n-         * has suspended the resumee.\n-         *\/\n-        blockOnDebuggerSuspend(resumee);\n-    }\n@@ -814,0 +823,6 @@\n+    \/*\n+     * We cannot call blockOnDebuggerSuspend() here because an event handler\n+     * must not release the handlerLock because the caller function is iterating\n+     * the handler chain which is protected by handlerLock. Instead handling is\n+     * deferred and done in doPendingTasks() where we do not hold handlerLock.\n+     *\/\n@@ -815,10 +830,4 @@\n-        \/*\n-         * Track the resuming thread by marking it as being within\n-         * a resume and by setting up for notification on\n-         * a frame pop or exception. We won't allow the debugger\n-         * to suspend threads while any thread is within a\n-         * call to resume. This (along with the block above)\n-         * ensures that when the debugger\n-         * suspends a thread it will remain suspended.\n-         *\/\n-        trackAppResume(resumer);\n+        node = findThread(&runningThreads, resumer);\n+        if (node != NULL) {\n+            node->pendingAppResumeBreakpoint = JNI_TRUE;\n+        }\n@@ -2182,0 +2191,34 @@\n+    \/* Deferred breakpoint handling for Thread.resume() *\/\n+    if (node->pendingAppResumeBreakpoint) {\n+        jthread resumer = node->thread;\n+        jthread resumee = getResumee(resumer);\n+\n+        node->pendingAppResumeBreakpoint = JNI_FALSE;\n+\n+        \/* trackAppResume() needs handlerLock *\/\n+        debugMonitorExit(threadLock);\n+        eventHandler_lock(); \/* for proper lock order *\/\n+        debugMonitorEnter(threadLock);\n+        if (resumee != NULL) {\n+            \/*\n+             * Hold up any attempt to resume as long as the debugger\n+             * has suspended the resumee.\n+             *\/\n+            blockOnDebuggerSuspend(resumee);\n+        }\n+\n+        if (resumer != NULL) {\n+            \/*\n+             * Track the resuming thread by marking it as being within\n+             * a resume and by setting up for notification on\n+             * a frame pop or exception. We won't allow the debugger\n+             * to suspend threads while any thread is within a\n+             * call to resume. This (along with the block above)\n+             * ensures that when the debugger\n+             * suspends a thread it will remain suspended.\n+             *\/\n+            trackAppResume(resumer);\n+        }\n+        eventHandler_unlock();\n+    }\n+\n@@ -2482,0 +2525,2 @@\n+    \/* Threads could be waiting in blockOnDebuggerSuspend *\/\n+    debugMonitorNotifyAll(threadLock);\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/threadControl.c","additions":63,"deletions":18,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -0,0 +1,222 @@\n+\/*\n+ * Copyright (c) 2021 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8274687\n+ * @summary Test the special handling in the JDWP agent of threads that call\n+ *          j.l.Thread.resume().\n+ *\n+ *          This is the sequence of actions by the debugger and the threads\n+ *          \"main\" and \"resumee\" in the target vm.\n+ *\n+ *          \"resumee\": Reaches breakpoint in methodWithBreakpoint() and is\n+ *                     suspended then.\n+ *\n+ *          \"main\": Calls j.l.Thread.resume() for \"resumee\". There is an internal\n+ *                  breakpoint in Thread.resume() so the JDWP agent receives a\n+ *                  breakpoint event. It finds that \"resumee\" is suspended because\n+ *                  of JDWP actions. The resume() call would interfere with the\n+ *                  debugger therefore \"main\" is blocked.\n+ *\n+ *          Debugger: Resumes \"resumee\" by calling ThreadReference.resume().\n+ *                    Notifies \"main\" about it.\n+ *\n+ *          \"resumee\": Continues execution.\n+ *\n+ *          \"main\": Receives the notification, finds that \"resumee\" is not\n+ *                  suspended anymore and continues execution.\n+ *\n+ * @author Richard Reingruber richard DOT reingruber AT sap DOT com\n+ *\n+ * @library \/test\/lib\n+ *\n+ * @run build TestScaffold VMConnection TargetListener TargetAdapter\n+ * @run compile -g ResumeAfterThreadResumeCallTest.java\n+ * @run driver ResumeAfterThreadResumeCallTest\n+ *\/\n+import com.sun.jdi.*;\n+import com.sun.jdi.event.*;\n+import jdk.test.lib.Asserts;\n+\n+import java.util.*;\n+\n+\/\/ Target program for the debugger\n+class ResumeAfterThreadResumeCallTarg extends Thread {\n+\n+    public boolean reachedBreakpoint;\n+    public boolean mainThreadReturnedFromResumeCall;\n+    public boolean testFinished;\n+\n+    public ResumeAfterThreadResumeCallTarg(String name) {\n+        super(name);\n+    }\n+\n+    public static void log(String m) {\n+        String threadName = Thread.currentThread().getName();\n+        System.out.println();\n+        System.out.println(\"###(Target,\"+ threadName +\") \" + m);\n+        System.out.println();\n+    }\n+\n+    public static void main(String[] args) {\n+        log(\"Entered main()\");\n+\n+        \/\/ Start \"resumee\" thread.\n+        ResumeAfterThreadResumeCallTarg resumee = new ResumeAfterThreadResumeCallTarg(\"resumee\");\n+        resumee.start();\n+\n+        \/\/ Wait for \"resumee\" to reach the breakpoint in methodWithBreakpoint().\n+        while (!resumee.reachedBreakpoint) {\n+            try {\n+                Thread.sleep(100);\n+            } catch (InterruptedException e) { \/* ignored *\/ }\n+        }\n+\n+        \/\/ \"resumee\" is suspended now because of the breakpoint\n+        \/\/ Calling Thread.resume() will block this thread.\n+\n+        log(\"Calling Thread.resume()\");\n+        resumee.resume();\n+        resumee.mainThreadReturnedFromResumeCall = true;\n+        log(\"Thread.resume() returned\");\n+\n+        \/\/ Wait for debugger\n+        while (!resumee.testFinished) {\n+            try {\n+                Thread.sleep(100);\n+            } catch (InterruptedException e) { \/* ignored *\/ }\n+        }\n+    }\n+\n+    public void run() {\n+        log(\"up and running.\");\n+        methodWithBreakpoint();\n+    }\n+\n+    public void methodWithBreakpoint() {\n+        log(\"Entered methodWithBreakpoint()\");\n+    }\n+}\n+\n+\n+\/\/ Debugger program\n+\n+public class ResumeAfterThreadResumeCallTest extends TestScaffold {\n+    public static final String TARGET_CLS_NAME = ResumeAfterThreadResumeCallTarg.class.getName();\n+    public static final long UNBLOCK_TIMEOUT = 10000;\n+\n+    ResumeAfterThreadResumeCallTest (String args[]) {\n+        super(args);\n+    }\n+\n+    public static void main(String[] args)      throws Exception {\n+        new ResumeAfterThreadResumeCallTest(args).startTests();\n+    }\n+\n+    \/**\n+     * Set a breakpoint in the given method and resume all threads. The\n+     * breakpoint is configured to suspend just the thread that reaches it\n+     * instead of all threads.\n+     *\/\n+    public BreakpointEvent resumeTo(String clsName, String methodName, String signature) {\n+        boolean suspendThreadOnly = true;\n+        return resumeTo(clsName, methodName, signature, suspendThreadOnly);\n+    }\n+\n+    protected void runTests() throws Exception {\n+        BreakpointEvent bpe = startToMain(TARGET_CLS_NAME);\n+        mainThread = bpe.thread();\n+\n+        log(\"Resuming to methodWithBreakpoint()\");\n+        bpe = resumeTo(TARGET_CLS_NAME, \"methodWithBreakpoint\", \"()V\");\n+\n+        log(\"Thread \\\"resumee\\\" has reached the breakpoint and is suspended now.\");\n+        ThreadReference resumee = bpe.thread();\n+        ObjectReference resumeeThreadObj = resumee.frame(1).thisObject();\n+        printStack(resumee);\n+        log(\"resumee.isSuspended() -> \" + resumee.isSuspended());\n+        log(\"mainThread.isSuspended() -> \" + mainThread.isSuspended());\n+        log(\"Notify target main thread to continue by setting reachedBreakpoint = true.\");\n+        setField(resumeeThreadObj, \"reachedBreakpoint\", vm().mirrorOf(true));\n+\n+        log(\"Sleeping 500ms shows that the main thread is blocked calling Thread.resume() on \\\"resumee\\\" Thread.\");\n+        Thread.sleep(500);\n+        log(\"After sleep.\");\n+\n+        boolean mainThreadReturnedFromResumeCall = false;\n+        boolean resumedResumee = false;\n+        for (long sleepTime = 50; sleepTime < UNBLOCK_TIMEOUT && !mainThreadReturnedFromResumeCall; sleepTime <<= 1) {\n+            log(\"mainThread.isSuspended() -> \" + mainThread.isSuspended());\n+            Value v = getField(resumeeThreadObj, \"mainThreadReturnedFromResumeCall\");\n+            mainThreadReturnedFromResumeCall = ((PrimitiveValue) v).booleanValue();\n+            if (!resumedResumee) {\n+                \/\/ main thread should be still blocked.\n+                Asserts.assertFalse(mainThreadReturnedFromResumeCall, \"main Thread was not blocked\");\n+                log(\"Resuming \\\"resumee\\\" will unblock the main thread.\");\n+                resumee.resume();\n+                resumedResumee = true;\n+            }\n+            log(\"Sleeping \" + sleepTime + \"ms\");\n+            Thread.sleep(sleepTime);\n+        }\n+        Asserts.assertTrue(mainThreadReturnedFromResumeCall, \"main Thread was not unblocked\");\n+\n+        setField(resumeeThreadObj, \"testFinished\", vm().mirrorOf(true));\n+\n+        \/\/ Resume the target listening for events\n+        listenUntilVMDisconnect();\n+    }\n+\n+    public void printStack(ThreadReference thread) throws Exception {\n+        log(\"Stack of thread '\" + thread.name() + \"':\");\n+        List<StackFrame> stack_frames = thread.frames();\n+        int i = 0;\n+        for (StackFrame ff : stack_frames) {\n+            System.out.println(\"frame[\" + i++ +\"]: \" + ff.location().method() + \" (bci:\" + ff.location().codeIndex() + \")\");\n+        }\n+    }\n+\n+    public void setField(ObjectReference obj, String fName, Value val) throws Exception {\n+        log(\"set field \" + fName + \" = \" + val);\n+        ReferenceType rt = obj.referenceType();\n+        Field fld = rt.fieldByName(fName);\n+        obj.setValue(fld, val);\n+        log(\"ok\");\n+    }\n+\n+    public Value getField(ObjectReference obj, String fName) throws Exception {\n+        log(\"get field \" + fName);\n+        ReferenceType rt = obj.referenceType();\n+        Field fld = rt.fieldByName(fName);\n+        Value val = obj.getValue(fld);\n+        log(\"result : \" + val);\n+        return val;\n+    }\n+\n+    public void log(String m) {\n+        System.out.println();\n+        System.out.println(\"###(Debugger) \" + m);\n+        System.out.println();\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/jdi\/ResumeAfterThreadResumeCallTest.java","additions":222,"deletions":0,"binary":false,"changes":222,"status":"added"}]}