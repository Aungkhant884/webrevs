{"files":[{"patch":"@@ -760,1 +760,3 @@\n- * The caller is expected to hold threadLock. It will be temporarily released though.\n+ * The caller is expected to hold threadLock and handlerLock.\n+ * eventHandler_createInternalThreadOnly() can deadlock because of\n+ * wrong lock ordering if the caller does not hold handlerLock.\n@@ -769,9 +771,0 @@\n-    \/*\n-     * Set up the tracking of the Thread.resume() call.\n-     * This requires handlerLock during eventHandler_createInternalThreadOnly()\n-     * calls. For proper lock order handlerLock has to be acquired before threadLock.\n-     *\/\n-    debugMonitorExit(threadLock);\n-    eventHandler_lock();\n-    debugMonitorEnter(threadLock);\n-\n@@ -810,2 +803,0 @@\n-\n-    eventHandler_unlock();\n@@ -2197,0 +2188,8 @@\n+        \/*\n+         * trackAppResume() (indirectly) aquires handlerLock. For proper lock\n+         * ordering handlerLock has to be acquired before threadLock.\n+         *\/\n+        debugMonitorExit(threadLock);\n+        eventHandler_lock();\n+        debugMonitorEnter(threadLock);\n+\n@@ -2211,4 +2210,3 @@\n-         * blockOnDebuggerSuspend() must be called after trackAppResume()\n-         * because the latter releases threadLock which would allow the debugger\n-         * to suspend resumee after return from blockOnDebuggerSuspend() which\n-         * would invalidate this block's exit condition.\n+         * handlerLock is not needed anymore. We release it before calling\n+         * blockOnDebuggerSuspend() because it is required for resumes by the\n+         * debugger so we cannot wait for that holding handlerLock.\n@@ -2216,0 +2214,2 @@\n+        eventHandler_unlock();\n+\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/threadControl.c","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"}]}