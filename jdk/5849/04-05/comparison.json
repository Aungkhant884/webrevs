{"files":[{"patch":"@@ -2197,0 +2197,13 @@\n+        \/*\n+         * The current thread \"resumer\" is about to call j.l.Thread.resume() for\n+         * \"resumee\". The call has been intercepted by means of an internal\n+         * breakpoint in Thread.resume() because the resume has to be\n+         * synchronized with suspend\/resumes performed by the debugger: in\n+         * blockOnDebuggerSuspend() \"resumer\" checks suspendCount under\n+         * threadLock and waits on it if necessary to become 0. It returns from\n+         * blockOnDebuggerSuspend() still holding threadLock in order to prevent\n+         * the debugger from suspending resumee again. trackAppResume() installs\n+         * tracking of the Thread.resume() call and only after this threadLock\n+         * can be released. Subsequent suspend requests by the debugger block\n+         * as long as any Thread.resume() call is active (see pendingAppResume()).\n+         *\/\n@@ -2199,1 +2212,6 @@\n-        \/* trackAppResume() needs handlerLock *\/\n+        \/*\n+         * As explained above the current thread acquires threadLock to\n+         * synchronize with the debugger (see above). In addition handlerLock is\n+         * required by trackAppResume(). For proper lock ordering we have to\n+         * acquire it already here before threadLock.\n+         *\/\n@@ -2201,1 +2219,1 @@\n-        eventHandler_lock(); \/* for proper lock order *\/\n+        eventHandler_lock();\n@@ -2211,0 +2229,6 @@\n+        \/*\n+         * Reaching here we know that resumee is not suspended by the\n+         * debugger. We still hold threadLock and we only release it after\n+         * trackAppResume() has installed the tracking\n+         *\/\n+\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/threadControl.c","additions":26,"deletions":2,"binary":false,"changes":28,"status":"modified"}]}