{"files":[{"patch":"@@ -76,1 +76,1 @@\n-    unsigned int pendingAppResumeBreakpoint : 1;\n+    unsigned int handlingAppResume : 1;\n@@ -683,1 +683,4 @@\n-                if (!(state & JVMTI_THREAD_STATE_SUSPENDED)) {\n+                \/* !node->handlingAppResume && resumeFrameDepth > 0\n+                 * means the thread has entered Thread.resume() *\/\n+                if (!(state & JVMTI_THREAD_STATE_SUSPENDED) &&\n+                    !node->handlingAppResume) {\n@@ -742,10 +745,0 @@\n-\/*\n- * The caller must own handlerLock and threadLock.\n- * If the suspendCount of the given thread is greater than 0, then the\n- * current thread will release the handlerLock and wait on the threadLock. It\n- * must release the handlerLock first, because threadControl_resumeThread()\n- * and threadControl_resumeAll() need it, and calling them is how suspendCount\n- * will eventually be decremented to 0.\n- * handlerLock and threadLock are owned when returning and the suspendCount of\n- * the given thread is 0.\n- *\/\n@@ -760,2 +753,0 @@\n-            \/* handlerLock is needed for resume *\/\n-            eventHandler_unlock();\n@@ -763,4 +754,0 @@\n-\n-            debugMonitorExit(threadLock);\n-            eventHandler_lock(); \/* for proper lock order *\/\n-            debugMonitorEnter(threadLock);\n@@ -779,0 +766,8 @@\n+    \/*\n+     * Set up the tracking of the Thread.resume() call. This requires\n+     * handlerLock which has to be acquired before threadLock.\n+     *\/\n+    debugMonitorExit(threadLock);\n+    eventHandler_lock(); \/* for proper lock order *\/\n+    debugMonitorEnter(threadLock);\n+\n@@ -811,0 +806,2 @@\n+\n+    eventHandler_unlock();\n@@ -825,4 +822,3 @@\n-     * We cannot call blockOnDebuggerSuspend() here because an event handler\n-     * must not release the handlerLock because the caller function is iterating\n-     * the handler chain which is protected by handlerLock. Instead handling is\n-     * deferred and done in doPendingTasks() where we do not hold handlerLock.\n+     * Actual handling has to be deferred. We cannot block right here if the\n+     * target of the resume call is suspended by the debugger since we are\n+     * holding handlerLock which must not be released. See doPendingTasks().\n@@ -833,1 +829,1 @@\n-            node->pendingAppResumeBreakpoint = JNI_TRUE;\n+            node->handlingAppResume = JNI_TRUE;\n@@ -2193,1 +2189,1 @@\n-    if (node->pendingAppResumeBreakpoint) {\n+    if (node->handlingAppResume) {\n@@ -2197,14 +2193,12 @@\n-        \/*\n-         * The current thread \"resumer\" is about to call j.l.Thread.resume() for\n-         * \"resumee\". The call has been intercepted by means of an internal\n-         * breakpoint in Thread.resume() because the resume has to be\n-         * synchronized with suspend\/resumes performed by the debugger: in\n-         * blockOnDebuggerSuspend() \"resumer\" checks suspendCount under\n-         * threadLock and waits on it if necessary to become 0. It returns from\n-         * blockOnDebuggerSuspend() still holding threadLock in order to prevent\n-         * the debugger from suspending resumee again. trackAppResume() installs\n-         * tracking of the Thread.resume() call and only after this threadLock\n-         * can be released. Subsequent suspend requests by the debugger block\n-         * as long as any Thread.resume() call is active (see pendingAppResume()).\n-         *\/\n-        node->pendingAppResumeBreakpoint = JNI_FALSE;\n+        if (resumer != NULL) {\n+            \/*\n+             * Track the resuming thread by marking it as being within\n+             * a resume and by setting up for notification on\n+             * a frame pop or exception. We won't allow the debugger\n+             * to suspend threads while any thread is within a\n+             * call to resume. This (along with the block below)\n+             * ensures that when the debugger\n+             * suspends a thread it will remain suspended.\n+             *\/\n+            trackAppResume(resumer);\n+        }\n@@ -2213,4 +2207,4 @@\n-         * As explained above the current thread acquires threadLock to\n-         * synchronize with the debugger (see above). In addition handlerLock is\n-         * required by trackAppResume(). For proper lock ordering we have to\n-         * acquire it already here before threadLock.\n+         * blockOnDebuggerSuspend() must be called after trackAppResume()\n+         * because the latter releases threadLock which would allow the debugger\n+         * to suspend resumee after return from blockOnDebuggerSuspend() which\n+         * would invalidate this block's exit condition.\n@@ -2218,3 +2212,0 @@\n-        debugMonitorExit(threadLock);\n-        eventHandler_lock();\n-        debugMonitorEnter(threadLock);\n@@ -2229,0 +2220,2 @@\n+        node->handlingAppResume = JNI_FALSE;\n+\n@@ -2230,3 +2223,4 @@\n-         * Reaching here we know that resumee is not suspended by the\n-         * debugger. We still hold threadLock and we only release it after\n-         * trackAppResume() has installed the tracking\n+         * The blocks exit condition: resumee's suspendCount == 0.\n+         *\n+         * Debugger suspends are blocked if any thread is executing\n+         * Thread.resume(), i.e. !handlingAppResume && frameDepth > 0.\n@@ -2234,14 +2228,0 @@\n-\n-        if (resumer != NULL) {\n-            \/*\n-             * Track the resuming thread by marking it as being within\n-             * a resume and by setting up for notification on\n-             * a frame pop or exception. We won't allow the debugger\n-             * to suspend threads while any thread is within a\n-             * call to resume. This (along with the block above)\n-             * ensures that when the debugger\n-             * suspends a thread it will remain suspended.\n-             *\/\n-            trackAppResume(resumer);\n-        }\n-        eventHandler_unlock();\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/threadControl.c","additions":42,"deletions":62,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -40,1 +40,4 @@\n- *                  debugger therefore \"main\" is blocked in JDWP's blockOnDebuggerSuspend().\n+ *                  debugger therefore \"main\" is blocked.\n+ *\n+ *          Debugger: Tests if the suspended \"resumee\" can be suspended a second\n+ *                    time and resumes it again.\n@@ -181,1 +184,12 @@\n-                log(\"Resuming \\\"resumee\\\" will unblock the main thread.\");\n+\n+                \/\/ Test suspending the already suspended resumee thread.\n+                Asserts.assertTrue(resumee.isSuspended(), \"\\\"resumee\\\" is not suspended.\");\n+                log(\"Check if suspended \\\"resumee\\\" can be suspended a 2nd time.\");\n+                resumee.suspend();\n+                log(\"resumee.isSuspended() -> \" + resumee.isSuspended());\n+                log(\"Resuming \\\"resumee\\\"\");\n+                resumee.resume();\n+                Asserts.assertTrue(resumee.isSuspended(), \"\\\"resumee\\\" is not suspended.\");\n+\n+                \/\/ Really resume the resumee thread.\n+                log(\"Resuming \\\"resumee\\\" a 2nd time will unblock the main thread.\");\n@@ -183,0 +197,1 @@\n+                Asserts.assertFalse(resumee.isSuspended(), \"\\\"resumee\\\" is still suspended.\");\n","filename":"test\/jdk\/com\/sun\/jdi\/ResumeAfterThreadResumeCallTest.java","additions":17,"deletions":2,"binary":false,"changes":19,"status":"modified"}]}