{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n@@ -37,0 +40,1 @@\n+import java.util.stream.Collectors;\n@@ -60,2 +64,2 @@\n-            \"short.CompactNumberPatterns\",\n-            \"long.CompactNumberPatterns\"\n+        \"short.CompactNumberPatterns\",\n+        \"long.CompactNumberPatterns\"\n@@ -107,0 +111,4 @@\n+    \/\/ DateFormatItem prefix\n+    final static String DATEFORMATITEM_KEY_PREFIX = \"DateFormatItem.\";\n+    final static String DATEFORMATITEM_INPUT_REGIONS_PREFIX = \"DateFormatItemInputRegions.\";\n+\n@@ -265,1 +273,1 @@\n-        if (\"root\".equals(id)) {\n+        if (isRoot()) {\n@@ -290,0 +298,8 @@\n+\n+            \/\/ Skeleton\n+            handleSkeletonPatterns(myMap, calendarType);\n+        }\n+\n+        \/\/ Skeleton input regions\n+        if (isRoot()) {\n+            skeletonInputRegions(myMap);\n@@ -650,2 +666,3 @@\n-                \/\/ Change cldr letter 'u' to 'y', as 'u' is interpreted as\n-                \/\/ \"Extended year (numeric)\" in CLDR\/LDML,\n+            case 'U':\n+                \/\/ Change cldr letter 'u'\/'U' to 'y', as 'u' is interpreted as\n+                \/\/ \"Extended year (numeric)\", and 'U' as \"Cyclic year\" in CLDR\/LDML,\n@@ -745,0 +762,13 @@\n+    private void handleSkeletonPatterns(Map<String, Object> myMap, CalendarType calendarType) {\n+        String calendarPrefix = calendarType.keyElementName();\n+        myMap.putAll(myMap.entrySet().stream()\n+            .filter(e -> e.getKey().startsWith(Bundle.DATEFORMATITEM_KEY_PREFIX))\n+            .collect(Collectors.toMap(\n+                e -> calendarPrefix + e.getKey(),\n+                e -> translateDateFormatLetters(calendarType,\n+                        (String)e.getValue(),\n+                        this::convertDateTimePatternLetter)\n+            ))\n+        );\n+    }\n+\n@@ -793,0 +823,10 @@\n+\n+    private static void skeletonInputRegions(Map<String, Object> myMap) {\n+        myMap.putAll(myMap.entrySet().stream()\n+                .filter(e -> e.getKey().startsWith(Bundle.DATEFORMATITEM_INPUT_REGIONS_PREFIX))\n+                .collect(Collectors.toMap(\n+                        e -> e.getKey(),\n+                        e -> ((String)e.getValue()).trim()\n+                ))\n+        );\n+    }\n","filename":"make\/jdk\/src\/classes\/build\/tools\/cldrconverter\/Bundle.java","additions":46,"deletions":6,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -850,0 +850,1 @@\n+        \"DateFormatItem\",\n@@ -855,3 +856,0 @@\n-            if (calendarType == CalendarType.GENERIC) {\n-                continue;\n-            }\n@@ -859,5 +857,6 @@\n-            for (String element : FORMAT_DATA_ELEMENTS) {\n-                String key = prefix + element;\n-                copyIfPresent(map, \"java.time.\" + key, formatData);\n-                copyIfPresent(map, key, formatData);\n-            }\n+            Arrays.stream(FORMAT_DATA_ELEMENTS)\n+                .flatMap(elem -> map.keySet().stream().filter(k -> k.startsWith(prefix + elem)))\n+                .forEach(key -> {\n+                    copyIfPresent(map, \"java.time.\" + key, formatData);\n+                    copyIfPresent(map, key, formatData);\n+                });\n@@ -871,3 +870,0 @@\n-                    if (calendarType == CalendarType.GENERIC) {\n-                        continue;\n-                    }\n","filename":"make\/jdk\/src\/classes\/build\/tools\/cldrconverter\/CLDRConverter.java","additions":8,"deletions":12,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -759,0 +759,8 @@\n+        case \"dateFormatItem\":\n+            {\n+                \/\/ for FormatData\n+                String prefix = (currentCalendarType == null) ? \"\" : currentCalendarType.keyElementName();\n+                pushStringEntry(qName, attributes,\n+                        prefix + Bundle.DATEFORMATITEM_KEY_PREFIX + attributes.getValue(\"id\"));\n+            }\n+            break;\n@@ -1116,1 +1124,1 @@\n-                return put(entry.getKey(), value);\n+                return put(key, value);\n","filename":"make\/jdk\/src\/classes\/build\/tools\/cldrconverter\/LDMLParseHandler.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.util.Arrays;\n@@ -32,0 +33,3 @@\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+import java.util.stream.Collectors;\n@@ -65,0 +69,4 @@\n+    \/\/ Input Skeleton map for \"preferred\" and \"allowed\"\n+    \/\/ Map<\"preferred\"\/\"allowed\", Map<\"skeleton\", SortedSet<\"regions\">>>\n+    private final Map<String, Map<String, SortedSet<String>>> inputSkeletonMap;\n+\n@@ -69,0 +77,1 @@\n+        inputSkeletonMap = new HashMap<>();\n@@ -79,0 +88,4 @@\n+     *\n+     * This method also returns Maps for \"preferred\" and \"allowed\" skeletons,\n+     * which are grouped by regions. E.g, \"h:XX YY ZZ;\" which means 'h' pattern\n+     * is \"preferred\"\/\"allowed\" in \"XX\", \"YY\", and \"ZZ\" regions.\n@@ -83,12 +96,11 @@\n-            parentLocalesMap.keySet().forEach(key -> {\n-            values.put(CLDRConverter.PARENT_LOCALE_PREFIX+key,\n-                parentLocalesMap.get(key));\n-            });\n-            firstDayMap.keySet().forEach(key -> {\n-            values.put(CLDRConverter.CALENDAR_FIRSTDAY_PREFIX+firstDayMap.get(key),\n-                key);\n-            });\n-            minDaysMap.keySet().forEach(key -> {\n-            values.put(CLDRConverter.CALENDAR_MINDAYS_PREFIX+minDaysMap.get(key),\n-                key);\n-            });\n+            parentLocalesMap.forEach((k, v) -> values.put(CLDRConverter.PARENT_LOCALE_PREFIX + k, v));\n+            firstDayMap.forEach((k, v) -> values.put(CLDRConverter.CALENDAR_FIRSTDAY_PREFIX + v, k));\n+            minDaysMap.forEach((k, v) -> values.put(CLDRConverter.CALENDAR_MINDAYS_PREFIX + v, k));\n+            inputSkeletonMap.get(\"preferred\").forEach((k, v) ->\n+                    values.merge(Bundle.DATEFORMATITEM_INPUT_REGIONS_PREFIX + \"preferred\",\n+                            k + \":\" + v.stream().collect(Collectors.joining(\" \")) + \";\",\n+                            (old, newVal) -> old + (String)newVal));\n+            inputSkeletonMap.get(\"allowed\").forEach((k, v) ->\n+                    values.merge(Bundle.DATEFORMATITEM_INPUT_REGIONS_PREFIX + \"allowed\",\n+                            k + \":\" + v.stream().collect(Collectors.joining(\" \")) + \";\",\n+                            (old, newVal) -> old + (String)newVal));\n@@ -161,0 +173,13 @@\n+        case \"hours\":\n+            if (!isIgnored(attributes)) {\n+                var preferred = attributes.getValue(\"preferred\");\n+                var allowed = attributes.getValue(\"allowed\").replaceFirst(\" .*\", \"\").replaceFirst(\"b\", \"B\"); \/\/ take only the first one, \"b\" -> \"B\"\n+                var regions = Arrays.stream(attributes.getValue(\"regions\").split(\" \"))\n+                        .map(r -> r.replaceAll(\"_\", \"-\"))\n+                        .collect(Collectors.toSet());\n+                var pmap = inputSkeletonMap.computeIfAbsent(\"preferred\", k -> new HashMap<>());\n+                var amap = inputSkeletonMap.computeIfAbsent(\"allowed\", k -> new HashMap<>());\n+                pmap.computeIfAbsent(preferred, k -> new TreeSet<>()).addAll(regions);\n+                amap.computeIfAbsent(allowed, k -> new TreeSet<>()).addAll(regions);\n+            }\n+            break;\n@@ -167,1 +192,0 @@\n-\n","filename":"make\/jdk\/src\/classes\/build\/tools\/cldrconverter\/SupplementDataParseHandler.java","additions":38,"deletions":14,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -84,1 +84,0 @@\n-import java.time.chrono.ChronoZonedDateTime;\n@@ -721,0 +720,51 @@\n+    \/\/-----------------------------------------------------------------------\n+    \/**\n+     * Creates a locale specific formatter derived from the requested template for\n+     * the ISO chronology. The requested template is a series of typical pattern\n+     * symbols in canonical order from the largest date or time unit to the smallest,\n+     * which can be expressed with the following regular expression:\n+     * {@snippet :\n+     *      \"G{0,5}\" +        \/\/ Era\n+     *      \"y*\" +            \/\/ Year\n+     *      \"Q{0,5}\" +        \/\/ Quarter\n+     *      \"M{0,5}\" +        \/\/ Month\n+     *      \"w*\" +            \/\/ Week of Week Based Year\n+     *      \"E{0,5}\" +        \/\/ Day of Week\n+     *      \"d{0,2}\" +        \/\/ Day of Month\n+     *      \"B{0,5}\" +        \/\/ Period\/AmPm of Day\n+     *      \"[hHjC]{0,2}\" +   \/\/ Hour of Day\/AmPm (refer to LDML for 'j' and 'C')\n+     *      \"m{0,2}\" +        \/\/ Minute of Hour\n+     *      \"s{0,2}\" +        \/\/ Second of Minute\n+     *      \"[vz]{0,4}\"       \/\/ Zone\n+     * }\n+     * All pattern symbols are optional, and each pattern symbol represents the field it is in,\n+     * e.g., 'M' represents the Month field. The number of the pattern symbol letters follows the\n+     * same presentation, such as \"number\" or \"text\" as in the <a href=\"#patterns\">Patterns for\n+     * Formatting and Parsing<\/a> section. Other pattern symbols in the requested template are\n+     * invalid.\n+     * <p>\n+     * The mapping of the requested template to the closest of the available localized formats\n+     * is defined by the\n+     * <a href=\"https:\/\/www.unicode.org\/reports\/tr35\/tr35-dates.html#availableFormats_appendItems\">\n+     * Unicode LDML specification<\/a>. For example, the formatter created from the requested template\n+     * {@code yMMM} will format the date '2020-06-16' to 'Jun 2020' in the {@link Locale#US US locale}.\n+     * <p>\n+     * The locale is determined from the formatter. The formatter returned directly by\n+     * this method will use the {@link Locale#getDefault() default FORMAT locale}.\n+     * The locale can be controlled using {@link DateTimeFormatter#withLocale(Locale) withLocale(Locale)}\n+     * on the result of this method.\n+     * <p>\n+     * The returned formatter has no override zone.\n+     * It uses {@link ResolverStyle#SMART SMART} resolver style.\n+     *\n+     * @param requestedTemplate the requested template, not null\n+     * @return the formatter based on the {@code requestedTemplate} pattern, not null\n+     * @throws IllegalArgumentException if {@code requestedTemplate} is invalid\n+     * @see #ofPattern(String)\n+     * @since 19\n+     *\/\n+    public static DateTimeFormatter ofLocalizedPattern(String requestedTemplate) {\n+        return new DateTimeFormatterBuilder().appendLocalized(requestedTemplate)\n+                .toFormatter(ResolverStyle.SMART, IsoChronology.INSTANCE);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/time\/format\/DateTimeFormatter.java","additions":52,"deletions":2,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -230,0 +230,35 @@\n+    \/**\n+     * Gets the formatting pattern for the requested template for a locale and chronology.\n+     * The locale and chronology are used to lookup the locale specific format\n+     * for the requested template.\n+     * <p>\n+     * If the locale contains the \"rg\" (region override)\n+     * <a href=\"..\/..\/util\/Locale.html#def_locale_extension\">Unicode extensions<\/a>,\n+     * the formatting pattern is overridden with the one appropriate for the region.\n+     * <p>\n+     * Refer to {@link #appendLocalized(String)} for the detail of {@code requestedTemplate}\n+     * argument.\n+     *\n+     * @param requestedTemplate the requested template, not null\n+     * @param chrono  the Chronology, non-null\n+     * @param locale  the locale, non-null\n+     * @return the locale and Chronology specific formatting pattern\n+     * @throws IllegalArgumentException if {@code requestedTemplate} is invalid\n+     * @throws DateTimeException if a match for the localized pattern for\n+     *      {@code requestedTemplate} is not available\n+     * @see #appendLocalized(String)\n+     * @since 19\n+     *\/\n+    public static String getLocalizedDateTimePattern(String requestedTemplate,\n+                                                     Chronology chrono, Locale locale) {\n+        Objects.requireNonNull(requestedTemplate, \"requestedTemplate\");\n+        Objects.requireNonNull(chrono, \"chrono\");\n+        Objects.requireNonNull(locale, \"locale\");\n+        Locale override = CalendarDataUtility.findRegionOverride(locale);\n+        LocaleProviderAdapter adapter = LocaleProviderAdapter.getAdapter(JavaTimeDateTimePatternProvider.class, override);\n+        JavaTimeDateTimePatternProvider provider = adapter.getJavaTimeDateTimePatternProvider();\n+        return provider.getJavaTimeDateTimePattern(requestedTemplate,\n+                chrono.getCalendarType(),\n+                override);\n+    }\n+\n@@ -1426,0 +1461,78 @@\n+    \/\/-----------------------------------------------------------------------\n+    \/\/ RegEx pattern for skeleton validity checking\n+    private static final Pattern VALID_TEMPLATE_PATTERN = Pattern.compile(\n+        \"G{0,5}\" +        \/\/ Era\n+        \"y*\" +            \/\/ Year\n+        \"Q{0,5}\" +        \/\/ Quarter\n+        \"M{0,5}\" +        \/\/ Month\n+        \"w*\" +            \/\/ Week of Week Based Year\n+        \"E{0,5}\" +        \/\/ Day of Week\n+        \"d{0,2}\" +        \/\/ Day of Month\n+        \"B{0,5}\" +        \/\/ Period\/AmPm of Day\n+        \"[hHjC]{0,2}\" +   \/\/ Hour of Day\/AmPm\n+        \"m{0,2}\" +        \/\/ Minute of Hour\n+        \"s{0,2}\" +        \/\/ Second of Minute\n+        \"[vz]{0,4}\");     \/\/ Zone\n+    \/**\n+     * Appends a localized pattern to the formatter using the requested template.\n+     * <p>\n+     * This appends a localized section to the builder, suitable for outputting\n+     * a date, time or date-time combination. The format of the localized\n+     * section is lazily looked up based on three items:\n+     * <ul>\n+     * <li>the {@code requestedTemplate} specified to this method\n+     * <li>the {@code Locale} of the {@code DateTimeFormatter}\n+     * <li>the {@code Chronology}, selecting the best available\n+     * <\/ul>\n+     * During formatting, the chronology is obtained from the temporal object\n+     * being formatted, which may have been overridden by\n+     * {@link DateTimeFormatter#withChronology(Chronology)}.\n+     * <p>\n+     * During parsing, if a chronology has already been parsed, then it is used.\n+     * Otherwise the default from {@code DateTimeFormatter.withChronology(Chronology)}\n+     * is used, with {@code IsoChronology} as the fallback.\n+     * <p>\n+     * The requested template is a series of typical pattern\n+     * symbols in canonical order from the largest date or time unit to the smallest,\n+     * which can be expressed with the following regular expression:\n+     * {@snippet :\n+     *      \"G{0,5}\" +        \/\/ Era\n+     *      \"y*\" +            \/\/ Year\n+     *      \"Q{0,5}\" +        \/\/ Quarter\n+     *      \"M{0,5}\" +        \/\/ Month\n+     *      \"w*\" +            \/\/ Week of Week Based Year\n+     *      \"E{0,5}\" +        \/\/ Day of Week\n+     *      \"d{0,2}\" +        \/\/ Day of Month\n+     *      \"B{0,5}\" +        \/\/ Period\/AmPm of Day\n+     *      \"[hHjC]{0,2}\" +   \/\/ Hour of Day\/AmPm (refer to LDML for 'j' and 'C')\n+     *      \"m{0,2}\" +        \/\/ Minute of Hour\n+     *      \"s{0,2}\" +        \/\/ Second of Minute\n+     *      \"[vz]{0,4}\"       \/\/ Zone\n+     * }\n+     * All pattern symbols are optional, and each pattern symbol represents the field it is in,\n+     * e.g., 'M' represents the Month field. The number of the pattern symbol letters follows the\n+     * same presentation, such as \"number\" or \"text\" as in the\n+     * <a href=\".\/DateTimeFormatter.html#patterns\">Patterns for Formatting and Parsing<\/a> section.\n+     * Other pattern symbols in the requested template are invalid.\n+     * <p>\n+     * The mapping of the requested template to the closest of the available localized formats\n+     * is defined by the\n+     * <a href=\"https:\/\/www.unicode.org\/reports\/tr35\/tr35-dates.html#availableFormats_appendItems\">\n+     * Unicode LDML specification<\/a>. For example, the formatter created from the requested template\n+     * {@code yMMM} will format the date '2020-06-16' to 'Jun 2020' in the {@link Locale#US US locale}.\n+     *\n+     * @param requestedTemplate the requested template to use, not null\n+     * @return this, for chaining, not null\n+     * @throws IllegalArgumentException if {@code requestedTemplate} is invalid\n+     * @see #appendPattern(String)\n+     * @since 19\n+     *\/\n+    public DateTimeFormatterBuilder appendLocalized(String requestedTemplate) {\n+        Objects.requireNonNull(requestedTemplate, \"requestedTemplate\");\n+        if (!VALID_TEMPLATE_PATTERN.matcher(requestedTemplate).matches()) {\n+            throw new IllegalArgumentException(\"Requested template is invalid: \" + requestedTemplate);\n+        }\n+        appendInternal(new LocalizedPrinterParser(requestedTemplate));\n+        return this;\n+    }\n+\n@@ -4981,0 +5094,1 @@\n+        private final String requestedTemplate;\n@@ -4989,1 +5103,1 @@\n-            \/\/ validated by caller\n+            \/\/ params validated by caller\n@@ -4992,0 +5106,13 @@\n+            this.requestedTemplate = null;\n+        }\n+\n+        \/**\n+         * Constructor.\n+         *\n+         * @param requestedTemplate the requested template to use, not null\n+         *\/\n+        LocalizedPrinterParser(String requestedTemplate) {\n+            \/\/ param validated by caller\n+            this.dateStyle = null;\n+            this.timeStyle = null;\n+            this.requestedTemplate = requestedTemplate;\n@@ -5009,1 +5136,2 @@\n-         * The formatter will be the most appropriate to use for the date and time style in the locale.\n+         * The formatter will be the most appropriate to use for the date and time style, or\n+         * the requested template for the locale.\n@@ -5018,11 +5146,10 @@\n-            String key = chrono.getId() + '|' + locale.toString() + '|' + dateStyle + timeStyle;\n-            DateTimeFormatter formatter = FORMATTER_CACHE.get(key);\n-            if (formatter == null) {\n-                String pattern = getLocalizedDateTimePattern(dateStyle, timeStyle, chrono, locale);\n-                formatter = new DateTimeFormatterBuilder().appendPattern(pattern).toFormatter(locale);\n-                DateTimeFormatter old = FORMATTER_CACHE.putIfAbsent(key, formatter);\n-                if (old != null) {\n-                    formatter = old;\n-                }\n-            }\n-            return formatter;\n+            var useRequestedTemplate = requestedTemplate != null;\n+            String key = chrono.getId() + '|' + locale.toString() + '|' +\n+                    (useRequestedTemplate ? requestedTemplate : Objects.toString(dateStyle) + timeStyle);\n+\n+            return FORMATTER_CACHE.computeIfAbsent(key, k ->\n+                new DateTimeFormatterBuilder()\n+                    .appendPattern(useRequestedTemplate ?\n+                        getLocalizedDateTimePattern(requestedTemplate, chrono, locale) :\n+                        getLocalizedDateTimePattern(dateStyle, timeStyle, chrono, locale))\n+                    .toFormatter(locale));\n","filename":"src\/java.base\/share\/classes\/java\/time\/format\/DateTimeFormatterBuilder.java","additions":141,"deletions":14,"binary":false,"changes":155,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.time.DateTimeException;\n@@ -61,0 +62,19 @@\n+\n+    \/**\n+     * Gets the formatting pattern for the requested template, calendarType, and locale.\n+     * Concrete implementation of this method will retrieve\n+     * a java.time specific pattern from selected Locale Provider.\n+     *\n+     * @param requestedTemplate requested template defined in CLDR\n+     * @param calType a {@code String}, non-null representing CalendarType such as \"japanese\",\n+     * \"iso8601\"\n+     * @param locale {@code locale}, non-null\n+     * @throws IllegalArgumentException if {@code requested} is invalid\n+     * @throws DateTimeException if the formatter for the given {@code requested} is not available\n+     * @return  formatting pattern {@code String}\n+     * @since 19\n+     *\/\n+    public String getJavaTimeDateTimePattern(String requestedTemplate, String calType, Locale locale) {\n+        \/\/ default implementation throws exception\n+        throw new DateTimeException(\"Formatter is not available for the requested template: \" + requestedTemplate);\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/text\/spi\/JavaTimeDateTimePatternProvider.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import java.time.DateTimeException;\n@@ -28,0 +29,2 @@\n+import java.util.Objects;\n+import java.util.Optional;\n@@ -66,1 +69,1 @@\n-        String pattern = lr.getJavaTimeDateTimePattern(\n+        return lr.getJavaTimeDateTimePattern(\n@@ -68,1 +71,1 @@\n-        return pattern;\n+    }\n@@ -70,0 +73,12 @@\n+    @Override\n+    public String getJavaTimeDateTimePattern(String requestedTemplate, String calType, Locale locale) {\n+        LocaleProviderAdapter lpa = LocaleProviderAdapter.getResourceBundleBased();\n+        return ((ResourceBundleBasedAdapter)lpa).getCandidateLocales(\"\", locale).stream()\n+                .map(lpa::getLocaleResources)\n+                .map(lr -> lr.getLocalizedPattern(requestedTemplate, calType))\n+                .filter(Objects::nonNull)\n+                .findFirst()\n+                .or(() -> calType.equals(\"generic\") ? Optional.empty():\n+                        Optional.of(getJavaTimeDateTimePattern(requestedTemplate, \"generic\", locale)))\n+                .orElseThrow(() -> new DateTimeException(\"Requested template \\\"\" + requestedTemplate +\n+                        \"\\\" cannot be resolved in the locale \\\"\" + locale + \"\\\"\"));\n","filename":"src\/java.base\/share\/classes\/sun\/util\/locale\/provider\/JavaTimeDateTimePatternImpl.java","additions":18,"deletions":3,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,0 +49,1 @@\n+import java.util.HashMap;\n@@ -51,0 +52,1 @@\n+import java.util.List;\n@@ -52,0 +54,1 @@\n+import java.util.Map;\n@@ -58,0 +61,3 @@\n+import java.util.regex.Pattern;\n+import java.util.stream.Stream;\n+\n@@ -94,0 +100,4 @@\n+    private static final String SKELETON_PATTERN = \"SP.\";\n+\n+    \/\/ ResourceBundle key names for skeletons\n+    private static final String SKELETON_INPUT_REGIONS_KEY = \"DateFormatItemInputRegions\";\n@@ -101,0 +111,25 @@\n+    \/\/ RegEx pattern for skeleton validity checking\n+    private static final Pattern VALID_SKELETON_PATTERN = Pattern.compile(\n+        \"(?<date>\" +\n+        \"G{0,5}\" +        \/\/ Era\n+        \"y*\" +            \/\/ Year\n+        \"Q{0,5}\" +        \/\/ Quarter\n+        \"M{0,5}\" +        \/\/ Month\n+        \"w*\" +            \/\/ Week of Week Based Year\n+        \"E{0,5}\" +        \/\/ Day of Week\n+        \"d{0,2})\" +       \/\/ Day of Month\n+        \"(?<time>\" +\n+        \"B{0,5}\" +        \/\/ Period\/AmPm of Day\n+        \"[hHjC]{0,2}\" +   \/\/ Hour of Day\/AmPm\n+        \"m{0,2}\" +        \/\/ Minute of Hour\n+        \"s{0,2}\" +        \/\/ Second of Minute\n+        \"[vz]{0,4})\");    \/\/ Zone\n+\n+    \/\/ Input Skeleton map for \"preferred\" and \"allowed\"\n+    \/\/ Map<\"preferred\"\/\"allowed\", Map<\"region\", \"skeleton\">>\n+    private static Map<String, Map<String, String>> inputSkeletons;\n+\n+    \/\/ Skeletons for \"j\" and \"C\" input skeleton symbols for this locale\n+    private String jPattern;\n+    private String CPattern;\n+\n@@ -534,0 +569,196 @@\n+    \/**\n+     * Returns the actual format pattern string based on the requested template\n+     * and calendar type for this locale.\n+     *\n+     * @param requestedTemplate requested template\n+     * @param calType calendar type\n+     * @throws IllegalArgumentException if the requested template is invalid\n+     * @return format pattern string for this locale, null if not found\n+     *\/\n+    public String getLocalizedPattern(String requestedTemplate, String calType) {\n+        String pattern;\n+        String cacheKey = SKELETON_PATTERN + calType + \".\" + requestedTemplate;\n+\n+        removeEmptyReferences();\n+        ResourceReference data = cache.get(cacheKey);\n+\n+        if (data == null || ((pattern = (String) data.get()) == null)) {\n+            pattern = getLocalizedPatternImpl(requestedTemplate, calType);\n+            cache.put(cacheKey,\n+                new ResourceReference(cacheKey, pattern != null ? pattern : \"\", referenceQueue));\n+        } else if (\"\".equals(pattern)) {\n+            \/\/ non-existent pattern\n+            pattern = null;\n+        }\n+\n+        return pattern;\n+    }\n+\n+    private String getLocalizedPatternImpl(String requestedTemplate, String calType) {\n+        initSkeletonIfNeeded();\n+\n+        \/\/ input skeleton substitution\n+        var skeleton = substituteInputSkeletons(requestedTemplate);\n+\n+        \/\/ validity check\n+        var matcher = VALID_SKELETON_PATTERN.matcher(skeleton);\n+        if (!matcher.matches()) {\n+            throw new IllegalArgumentException(\"Requested template \\\"%s\\\" is invalid\".formatted(requestedTemplate) +\n+                    (requestedTemplate.equals(skeleton) ? \".\" : \", which translated into \\\"%s\\\"\".formatted(skeleton) +\n+                            \" after the 'j' or 'C' substitution.\"));\n+        }\n+\n+        \/\/ try to match entire requested template first\n+        String matched = matchSkeleton(skeleton, calType);\n+        if (matched == null) {\n+            \/\/ 2.6.2.2 Missing Skeleton Fields\n+            var dateMatched = matchSkeleton(matcher.group(\"date\"), calType);\n+            var timeMatched = matchSkeleton(matcher.group(\"time\"), calType);\n+            if (dateMatched != null && timeMatched != null) {\n+                \/\/ combine both matches\n+                var style = switch (requestedTemplate.replaceAll(\"[^M]+\", \"\").length()) {\n+                    case 4 -> requestedTemplate.indexOf('E') >= 0 ? 0 : 1;\n+                    case 3 -> 2;\n+                    default -> 3;\n+                };\n+                var dateTimePattern = getDateTimePattern(null, \"DateTimePatterns\", style, calType);\n+                matched = MessageFormat.format(dateTimePattern.replaceAll(\"'\", \"''\"), timeMatched, dateMatched);\n+            }\n+        }\n+\n+        trace(\"requested: %s, locale: %s, calType: %s, matched: %s\\n\", requestedTemplate, locale, calType, matched);\n+\n+        return matched;\n+    }\n+\n+    private String matchSkeleton(String skeleton, String calType) {\n+        \/\/ Expand it with possible inferred skeleton stream based on its priority\n+        var inferred = possibleInferred(skeleton);\n+\n+        \/\/ Search the closest format pattern string from the resource bundle\n+        ResourceBundle r = localeData.getDateFormatData(locale);\n+        return inferred\n+            .map(s -> (\"gregory\".equals(calType) ? \"\" : calType + \".\") + \"DateFormatItem.\" + s)\n+            .map(key -> r.containsKey(key) ? r.getString(key) : null)\n+            .filter(Objects::nonNull)\n+            .findFirst()\n+            .orElse(null);\n+    }\n+\n+    private void initSkeletonIfNeeded() {\n+        \/\/ \"preferred\"\/\"allowed\" input skeleton maps\n+        if (inputSkeletons == null) {\n+            inputSkeletons = new HashMap<>();\n+            Pattern p = Pattern.compile(\"([^:]+):([^;]+);\");\n+            ResourceBundle r = localeData.getDateFormatData(Locale.ROOT);\n+            Stream.of(\"preferred\", \"allowed\").forEach(type -> {\n+                var inputRegionsKey = SKELETON_INPUT_REGIONS_KEY + \".\" + type;\n+                Map<String, String> typeMap = new HashMap<>();\n+\n+                if (r.containsKey(inputRegionsKey)) {\n+                    p.matcher(r.getString(inputRegionsKey)).results()\n+                        .forEach(mr ->\n+                            Arrays.stream(mr.group(2).split(\" \"))\n+                                .forEach(region -> typeMap.put(region, mr.group(1))));\n+                }\n+                inputSkeletons.put(type, typeMap);\n+            });\n+        }\n+\n+        \/\/ j\/C patterns for this locale\n+        if (jPattern == null) {\n+            jPattern = resolveInputSkeleton(\"preferred\");\n+            CPattern = resolveInputSkeleton(\"allowed\");\n+            \/\/ hack: \"allowed\" contains reversed order for hour\/period, e.g, \"hB\" which should be \"Bh\" as a skeleton\n+            if (CPattern.length() == 2) {\n+                var ba = new byte[2];\n+                ba[0] = (byte)CPattern.charAt(1);\n+                ba[1] = (byte)CPattern.charAt(0);\n+                CPattern = new String(ba);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Resolve locale specific input skeletons. Fall back method is different from usual\n+     * resource bundle's, as it has to be \"lang-region\" -> \"region\" -> \"lang-001\" -> \"001\"\n+     * @param type type of the input skeleton\n+     * @return resolved skeletons for this locale, defaults to \"h\" if none found.\n+     *\/\n+    private String resolveInputSkeleton(String type) {\n+        var regionToSkeletonMap = inputSkeletons.get(type);\n+        return regionToSkeletonMap.getOrDefault(locale.getLanguage() + \"-\" + locale.getCountry(),\n+            regionToSkeletonMap.getOrDefault(locale.getCountry(),\n+                regionToSkeletonMap.getOrDefault(locale.getLanguage() + \"-001\",\n+                    regionToSkeletonMap.getOrDefault(\"001\", \"h\"))));\n+    }\n+\n+    \/**\n+     * Replace 'j' and 'C' input skeletons with locale specific patterns. Note that 'j'\n+     * is guaranteed to be replaced with one char [hkHK], while 'C' may be replaced with\n+     * multiple chars. Repeat each as much as 'C' count.\n+     * @param requestedTemplate requested skeleton\n+     * @return skeleton with j\/C substituted with concrete patterns\n+     *\/\n+    private String substituteInputSkeletons(String requestedTemplate) {\n+        var cCount = requestedTemplate.chars().filter(c -> c == 'C').count();\n+        return requestedTemplate.replaceAll(\"j\", jPattern)\n+                .replaceFirst(\"C+\", CPattern.replaceAll(\"([hkHK])\", \"$1\".repeat((int)cCount)));\n+    }\n+\n+    \/**\n+     * Returns a stream of possible skeletons, inferring standalone\/format (M\/L and\/or E\/c) patterns\n+     * and their styles. (cf. 2.6.2.1 Matching Skeletons)\n+     *\n+     * @param skeleton original skeleton\n+     * @return inferred Stream of skeletons in its priority order\n+     *\/\n+    private Stream<String> possibleInferred(String skeleton) {\n+        return priorityList(skeleton, \"M\", \"L\").stream()\n+                .flatMap(s -> priorityList(s, \"E\", \"c\").stream())\n+                .distinct();\n+    }\n+\n+    \/**\n+     * Inferring the possible format styles in priority order, based on the original\n+     * skeleton length.\n+     *\n+     * @param skeleton skeleton\n+     * @param pChar pattern character string\n+     * @param subChar substitute character string\n+     * @return list of skeletons\n+     *\/\n+    private List<String> priorityList(String skeleton, String pChar, String subChar) {\n+        int first = skeleton.indexOf(pChar);\n+        int last = skeleton.lastIndexOf(pChar);\n+\n+        if (first >= 0) {\n+            var prefix = skeleton.substring(0, first);\n+            var suffix = skeleton.substring(last + 1);\n+\n+            \/\/ Priority are based on this chart. First column is the original count of `pChar`,\n+            \/\/ then it is followed by inferred skeletons base on priority.\n+            \/\/\n+            \/\/ 1->2->3->4 (number form (1-digit) -> number form (2-digit) -> Abbr. form -> Full form)\n+            \/\/ 2->1->3->4\n+            \/\/ 3->4->2->1\n+            \/\/ 4->3->2->1\n+            var o1 = prefix + pChar + suffix;\n+            var o2 = prefix + pChar.repeat(2) + suffix;\n+            var o3 = prefix + pChar.repeat(3) + suffix;\n+            var o4 = prefix + pChar.repeat(4) + suffix;\n+            var s1 = prefix + subChar + suffix;\n+            var s2 = prefix + subChar.repeat(2) + suffix;\n+            var s3 = prefix + subChar.repeat(3) + suffix;\n+            var s4 = prefix + subChar.repeat(4) + suffix;\n+            return switch (last - first) {\n+                case 1 -> List.of(skeleton, o1, o2, o3, o4, s1, s2, s3, s4);\n+                case 2 -> List.of(skeleton, o2, o1, o3, o4, s2, s1, s3, s4);\n+                case 3 -> List.of(skeleton, o3, o4, o2, o1, s3, s4, s2, s1);\n+                default -> List.of(skeleton, o4, o3, o2, o1, s4, s3, s2, s1);\n+            };\n+        } else {\n+            return List.of(skeleton);\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/util\/locale\/provider\/LocaleResources.java","additions":232,"deletions":1,"binary":false,"changes":233,"status":"modified"},{"patch":"@@ -0,0 +1,51 @@\n+H=15\n+h=3 PM\n+j=3 PM\n+C=3 PM\n+Hm=15:32\n+hm=3:32 PM\n+jm=3:32 PM\n+Cm=3:32 PM\n+Hms=15:32:39\n+hms=3:32:39 PM\n+jms=3:32:39 PM\n+Cms=3:32:39 PM\n+Hmv=15:32 PT\n+hmv=3:32 PM PT\n+jmv=3:32 PM PT\n+Cmv=3:32 PM PT\n+Hmsv=15:32:39 PT\n+hmsv=3:32:39 PM PT\n+jmsv=3:32:39 PM PT\n+Cmsv=3:32:39 PM PT\n+Bh=3 in the afternoon\n+Bj=3 in the afternoon\n+BC=3 in the afternoon\n+Bhm=3:32 in the afternoon\n+Bjm=3:32 in the afternoon\n+BCm=3:32 in the afternoon\n+Bhms=3:32:39 in the afternoon\n+Bjms=3:32:39 in the afternoon\n+BCms=3:32:39 in the afternoon\n+\n+M=1\n+MMM=Jan\n+MEd=Wed, 1\/26\n+MMMMEd=Wed, Jan 26\n+d=26\n+y=2022\n+yM=1\/2022\n+yMEd=Wed, 1\/26\/2022\n+yMMM=Jan 2022\n+yMMMMEd=Wed, Jan 26, 2022\n+GyM=Jan 2022 AD\n+GyMEd=Wed, Jan 26, 2022 AD\n+GyMMM=Jan 2022 AD\n+GyMMMMEd=Wed, Jan 26, 2022 AD\n+yQQQ=Q1 2022\n+yQQQQ=1st quarter 2022\n+\n+MMMMEdBh=Wed, Jan 26 at 3 in the afternoon\n+MMMMdBh=January 26 at 3 in the afternoon\n+MMMdBh=Jan 26, 3 in the afternoon\n+MdBh=1\/26, 3 in the afternoon\n","filename":"test\/jdk\/java\/time\/test\/java\/time\/format\/Skeletons_en_US.properties","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+H=15時\n+h=午後3時\n+j=15時\n+C=15時\n+Hm=15:32\n+hm=午後3:32\n+jm=15:32\n+Cm=15:32\n+Hms=15:32:39\n+hms=午後3:32:39\n+jms=15:32:39\n+Cms=15:32:39\n+Hmv=15:32 PT\n+hmv=午後3:32 PT\n+jmv=15:32 PT\n+Cmv=15:32 PT\n+Hmsv=15:32:39 PT\n+hmsv=午後3:32:39 PT\n+jmsv=15:32:39 PT\n+Cmsv=15:32:39 PT\n+Bh=昼3時\n+Bhm=昼3:32\n+Bhms=昼3:32:39\n+\n+M=1月\n+MMM=1月\n+MEd=1\/26(水)\n+MMMMEd=1月26日(水)\n+d=26日\n+y=4年\n+yM=4\/1\n+yMEd=4\/1\/26(水)\n+yMMM=4年1月\n+yMMMMEd=4年1月26日(水)\n+GyM=令和4年1月\n+GyMEd=令和4年1月26日(水)\n+GyMMM=令和4年1月\n+GyMMMMEd=令和4年1月26日(水)\n+\n+MMMMEdBh=1月26日(水) 昼3時\n+MMMMdBh=1月26日 昼3時\n+MMMdBh=1月26日 昼3時\n+MdBh=1\/26 昼3時\n","filename":"test\/jdk\/java\/time\/test\/java\/time\/format\/Skeletons_ja.properties","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package test.java.time.format;\n+\n+import static org.testng.Assert.assertEquals;\n+\n+import java.time.DateTimeException;\n+import java.time.ZonedDateTime;\n+import java.time.ZoneId;\n+import java.time.chrono.IsoChronology;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeFormatterBuilder;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.ResourceBundle;\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+\/**\n+ * Test DateTimeFormatter.ofLocalizedPattern() related methods.\n+ * @bug 8176706\n+ *\/\n+@Test\n+public class TestLocalizedPattern {\n+\n+    private static final ZonedDateTime ZDT =\n+            ZonedDateTime.of(2022, 1, 26, 15, 32, 39, 0, ZoneId.of(\"America\/Los_Angeles\"));\n+\n+    private final static List<Locale> SAMPLE_LOCALES = List.of(\n+            Locale.US,\n+            Locale.forLanguageTag(\"ja-JP-u-ca-japanese\")\n+    );\n+\n+    @DataProvider(name = \"validSkeletons\")\n+    Object[][] data_validSkeletons() {\n+        return SAMPLE_LOCALES.stream()\n+                .flatMap(l -> {\n+                    var rb = ResourceBundle.getBundle(\"test.java.time.format.Skeletons\", l);\n+                    return rb.keySet().stream().map(key -> new Object[]{key, rb.getString(key), l});\n+                })\n+                .toList()\n+                .toArray(new Object[0][0]);\n+    }\n+\n+    @DataProvider(name = \"invalidSkeletons\")\n+    Object[][] data_invalidSkeletons() {\n+        return new Object[][] {\n+            {\"afo\"}, {\"hB\"}, {\"uMMM\"}, {\"MMMMMM\"}, {\"BhmsyMMM\"},\n+        };\n+    }\n+\n+    @DataProvider(name = \"unavailableSkeletons\")\n+    Object[][] data_unavailableSkeletons() {\n+        return new Object[][] {\n+            {\"yyyyyy\"}, {\"BBh\"}, {\"yMMMMEdBBh\"},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"validSkeletons\")\n+    public void test_ofLocalizedPattern(String skeleton, String expected, Locale l) {\n+        var dtf = DateTimeFormatter.ofLocalizedPattern(skeleton).localizedBy(l);\n+        assertEquals(dtf.format(ZDT), expected);\n+    }\n+\n+    @Test(dataProvider = \"invalidSkeletons\", expectedExceptions = IllegalArgumentException.class)\n+    public void test_ofLocalizedPattern_invalid(String skeleton) {\n+        DateTimeFormatter.ofLocalizedPattern(skeleton);\n+    }\n+\n+    @Test(dataProvider = \"invalidSkeletons\", expectedExceptions = IllegalArgumentException.class)\n+    public void test_appendLocalized_invalid(String skeleton) {\n+        new DateTimeFormatterBuilder().appendLocalized(skeleton);\n+    }\n+\n+    @Test(dataProvider = \"unavailableSkeletons\", expectedExceptions = DateTimeException.class)\n+    public void test_ofLocalizedPattern_unavailable(String skeleton) {\n+        DateTimeFormatter.ofLocalizedPattern(skeleton).format(ZDT);\n+    }\n+\n+    @Test(dataProvider = \"unavailableSkeletons\", expectedExceptions = DateTimeException.class)\n+    public void test_getLocalizedDateTimePattern_unavailable(String skeleton) {\n+        DateTimeFormatterBuilder.getLocalizedDateTimePattern(skeleton, IsoChronology.INSTANCE, Locale.US);\n+    }\n+}\n","filename":"test\/jdk\/java\/time\/test\/java\/time\/format\/TestLocalizedPattern.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"}]}