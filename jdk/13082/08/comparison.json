{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -30,0 +31,1 @@\n+import java.util.HashMap;\n@@ -32,1 +34,1 @@\n-import jdk.internal.classfile.impl.Util;\n+import java.util.function.Supplier;\n@@ -35,0 +37,5 @@\n+import jdk.internal.classfile.impl.ClassHierarchyImpl.ClassLoadingClassHierarchyResolver;\n+import jdk.internal.classfile.impl.ClassHierarchyImpl.StaticClassHierarchyResolver;\n+import jdk.internal.classfile.impl.Util;\n+\n+import static java.lang.constant.ConstantDescs.CD_Object;\n@@ -44,3 +51,4 @@\n-     * Default singleton instance of {@linkplain ClassHierarchyResolver}\n-     * using {@link ClassLoader#getSystemResourceAsStream(String)}\n-     * as the {@code ClassStreamResolver}\n+     * Returns a default instance of {@linkplain ClassHierarchyResolver}\n+     * that reads from system class loader with\n+     * {@link ClassLoader#getSystemResourceAsStream(String)} and falls\n+     * back to reflection if a class is not found.\n@@ -48,8 +56,3 @@\n-    ClassHierarchyResolver DEFAULT_CLASS_HIERARCHY_RESOLVER\n-            = new ClassHierarchyImpl.CachedClassHierarchyResolver(\n-            new Function<ClassDesc, InputStream>() {\n-                @Override\n-                public InputStream apply(ClassDesc classDesc) {\n-                    return ClassLoader.getSystemResourceAsStream(Util.toInternalName(classDesc) + \".class\");\n-                }\n-            });\n+    static ClassHierarchyResolver defaultResolver() {\n+        return ClassHierarchyImpl.DEFAULT_RESOLVER;\n+    }\n@@ -64,0 +67,25 @@\n+    \/**\n+     * Information about a resolved class.\n+     *\/\n+    sealed interface ClassHierarchyInfo permits ClassHierarchyImpl.ClassHierarchyInfoImpl {\n+\n+        \/**\n+         * Indicates that a class is a declared class, with the specific given super class.\n+         *\n+         * @param superClass descriptor of the super class, may be {@code null}\n+         * @return the info indicating the super class\n+         *\/\n+        static ClassHierarchyInfo ofClass(ClassDesc superClass) {\n+            return new ClassHierarchyImpl.ClassHierarchyInfoImpl(superClass, false);\n+        }\n+\n+        \/**\n+         * Indicates that a class is an interface.\n+         *\n+         * @return the info indicating an interface\n+         *\/\n+        static ClassHierarchyInfo ofInterface() {\n+            return new ClassHierarchyImpl.ClassHierarchyInfoImpl(CD_Object, true);\n+        }\n+    }\n+\n@@ -77,1 +105,1 @@\n-                    chi = other.getClassInfo(classDesc);\n+                    return other.getClassInfo(classDesc);\n@@ -84,4 +112,7 @@\n-     * Information about a resolved class.\n-     * @param thisClass descriptor of this class\n-     * @param isInterface whether this class is an interface\n-     * @param superClass descriptor of the superclass (not relevant for interfaces)\n+     * Returns a ClassHierarchyResolver that caches class hierarchy information from this\n+     * resolver. The returned resolver will not update if delegate resolver returns differently.\n+     * The thread safety of the returned resolver depends on the thread safety of the map\n+     * returned by the {@code cacheFactory}.\n+     *\n+     * @param cacheFactory the factory for the cache\n+     * @return the ClassHierarchyResolver with caching\n@@ -89,1 +120,2 @@\n-    public record ClassHierarchyInfo(ClassDesc thisClass, boolean isInterface, ClassDesc superClass) {\n+    default ClassHierarchyResolver cached(Supplier<Map<ClassDesc, ClassHierarchyInfo>> cacheFactory) {\n+        return new ClassHierarchyImpl.CachedClassHierarchyResolver(this, cacheFactory.get());\n@@ -93,2 +125,25 @@\n-     * Returns a {@linkplain  ClassHierarchyResolver} that extracts class hierarchy\n-     * information from classfiles located by a mapping function\n+     * Returns a ClassHierarchyResolver that caches class hierarchy information from this\n+     * resolver. The returned resolver will not update if delegate resolver returns differently.\n+     * The returned resolver is not thread-safe.\n+     * {@snippet file=\"PackageSnippets.java\" region=\"lookup-class-hierarchy-resolver\"}\n+     *\n+     * @return the ClassHierarchyResolver\n+     *\/\n+    default ClassHierarchyResolver cached() {\n+        record Factory() implements Supplier<Map<ClassDesc, ClassHierarchyInfo>> {\n+            \/\/ uses a record as we cannot declare a local class static\n+            static final Factory INSTANCE = new Factory();\n+\n+            @Override\n+            public Map<ClassDesc, ClassHierarchyInfo> get() {\n+                return new HashMap<>();\n+            }\n+        }\n+        return cached(Factory.INSTANCE);\n+    }\n+\n+    \/**\n+     * Returns a {@linkplain ClassHierarchyResolver} that extracts class hierarchy\n+     * information from classfiles located by a mapping function. The mapping function\n+     * should return null if it cannot provide a mapping for a classfile. Any IOException\n+     * from the provided input stream is rethrown as an UncheckedIOException.\n@@ -99,2 +154,18 @@\n-    public static ClassHierarchyResolver ofCached(Function<ClassDesc, InputStream> classStreamResolver) {\n-        return new ClassHierarchyImpl.CachedClassHierarchyResolver(classStreamResolver);\n+    static ClassHierarchyResolver ofResourceParsing(Function<ClassDesc, InputStream> classStreamResolver) {\n+        return new ClassHierarchyImpl.ResourceParsingClassHierarchyResolver(classStreamResolver);\n+    }\n+\n+    \/**\n+     * Returns a {@linkplain ClassHierarchyResolver} that extracts class hierarchy\n+     * information from classfiles located by a class loader.\n+     *\n+     * @param loader the class loader, to find class files\n+     * @return the {@linkplain ClassHierarchyResolver}\n+     *\/\n+    static ClassHierarchyResolver ofResourceParsing(ClassLoader loader) {\n+        return ofResourceParsing(new Function<>() {\n+            @Override\n+            public InputStream apply(ClassDesc classDesc) {\n+                return loader.getResourceAsStream(Util.toInternalName(classDesc) + \".class\");\n+            }\n+        });\n@@ -111,1 +182,1 @@\n-    public static ClassHierarchyResolver of(Collection<ClassDesc> interfaces,\n+    static ClassHierarchyResolver of(Collection<ClassDesc> interfaces,\n@@ -113,1 +184,45 @@\n-        return new ClassHierarchyImpl.StaticClassHierarchyResolver(interfaces, classToSuperClass);\n+        return new StaticClassHierarchyResolver(interfaces, classToSuperClass);\n+    }\n+\n+    \/**\n+     * Returns a ClassHierarchyResolver that extracts class hierarchy information via\n+     * the Reflection API with a {@linkplain ClassLoader}.\n+     *\n+     * @param loader the class loader\n+     * @return the class hierarchy resolver\n+     *\/\n+    static ClassHierarchyResolver ofClassLoading(ClassLoader loader) {\n+        return new ClassLoadingClassHierarchyResolver(new Function<>() {\n+            @Override\n+            public Class<?> apply(ClassDesc cd) {\n+                try {\n+                    return Class.forName(Util.toBinaryName(cd.descriptorString()), false, loader);\n+                } catch (ClassNotFoundException ex) {\n+                    return null;\n+                }\n+            }\n+        });\n+    }\n+\n+    \/**\n+     * Returns a ClassHierarchyResolver that extracts class hierarchy information via\n+     * the Reflection API with a {@linkplain MethodHandles.Lookup Lookup}. If the class\n+     * resolved is inaccessible to the given lookup, it throws {@link\n+     * IllegalArgumentException} instead of returning {@code null}.\n+     *\n+     * @param lookup the lookup, must be able to access classes to resolve\n+     * @return the class hierarchy resolver\n+     *\/\n+    static ClassHierarchyResolver ofClassLoading(MethodHandles.Lookup lookup) {\n+        return new ClassLoadingClassHierarchyResolver(new Function<>() {\n+            @Override\n+            public Class<?> apply(ClassDesc cd) {\n+                try {\n+                    return cd.resolveConstantDesc(lookup);\n+                } catch (IllegalAccessException ex) {\n+                    throw new IllegalArgumentException(ex);\n+                } catch (ReflectiveOperationException ex) {\n+                    return null;\n+                }\n+            }\n+        });\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/ClassHierarchyResolver.java","additions":140,"deletions":25,"binary":false,"changes":165,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.io.IOException;\n@@ -29,0 +30,1 @@\n+import java.io.UncheckedIOException;\n@@ -30,1 +32,0 @@\n-import java.lang.constant.ConstantDescs;\n@@ -32,1 +33,0 @@\n-import java.util.Collections;\n@@ -35,0 +35,1 @@\n+import java.util.concurrent.ConcurrentHashMap;\n@@ -36,0 +37,1 @@\n+import java.util.function.Supplier;\n@@ -39,0 +41,3 @@\n+import static java.lang.constant.ConstantDescs.CD_Object;\n+import static jdk.internal.classfile.Classfile.*;\n+\n@@ -46,0 +51,14 @@\n+    public record ClassHierarchyInfoImpl(ClassDesc superClass, boolean isInterface) implements ClassHierarchyResolver.ClassHierarchyInfo {\n+        static final ClassHierarchyResolver.ClassHierarchyInfo OBJECT_INFO = new ClassHierarchyInfoImpl(null, false);\n+    }\n+\n+    public static final ClassHierarchyResolver DEFAULT_RESOLVER = ClassHierarchyResolver\n+            .ofResourceParsing(ResourceParsingClassHierarchyResolver.SYSTEM_STREAM_PROVIDER)\n+            .orElse(new ClassLoadingClassHierarchyResolver(ClassLoadingClassHierarchyResolver.SYSTEM_CLASS_PROVIDER))\n+            .cached(new Supplier<>() {\n+                @Override\n+                public Map<ClassDesc, ClassHierarchyResolver.ClassHierarchyInfo> get() {\n+                    return new ConcurrentHashMap<>();\n+                }\n+            });\n+\n@@ -56,1 +75,1 @@\n-    private ClassHierarchyResolver.ClassHierarchyInfo resolve(ClassDesc classDesc) {\n+    private ClassHierarchyInfoImpl resolve(ClassDesc classDesc) {\n@@ -58,1 +77,1 @@\n-        if (res != null) return res;\n+        if (res != null) return (ClassHierarchyInfoImpl) res;\n@@ -82,1 +101,1 @@\n-        if (isInterface(symbol1) || isInterface(symbol2)) return ConstantDescs.CD_Object;\n+        if (isInterface(symbol1) || isInterface(symbol2)) return CD_Object;\n@@ -104,2 +123,1 @@\n-\n-        \/\/this instance should never appear in the cache nor leak out\n+        \/\/this instance should leak out, appears only in cache in order to utilize Map.computeIfAbsent\n@@ -107,1 +125,15 @@\n-                new ClassHierarchyResolver.ClassHierarchyInfo(null, false, null);\n+                new ClassHierarchyInfoImpl(null, true);\n+\n+        private final Map<ClassDesc, ClassHierarchyInfo> resolvedCache;\n+        private final Function<ClassDesc, ClassHierarchyInfo> delegateFunction;\n+\n+        public CachedClassHierarchyResolver(ClassHierarchyResolver delegate, Map<ClassDesc, ClassHierarchyInfo> resolvedCache) {\n+            this.resolvedCache = resolvedCache;\n+            this.delegateFunction = new Function<>() {\n+                @Override\n+                public ClassHierarchyInfo apply(ClassDesc classDesc) {\n+                    var ret = delegate.getClassInfo(classDesc);\n+                    return ret == null ? NOPE : ret;\n+                }\n+            };\n+        }\n@@ -109,0 +141,14 @@\n+        @Override\n+        public ClassHierarchyInfo getClassInfo(ClassDesc classDesc) {\n+            var ret = resolvedCache.computeIfAbsent(classDesc, delegateFunction);\n+            return ret == NOPE ? null : ret;\n+        }\n+    }\n+\n+    public static final class ResourceParsingClassHierarchyResolver implements ClassHierarchyResolver {\n+        public static final Function<ClassDesc, InputStream> SYSTEM_STREAM_PROVIDER = new Function<>() {\n+            @Override\n+            public InputStream apply(ClassDesc cd) {\n+                return ClassLoader.getSystemClassLoader().getResourceAsStream(Util.toInternalName(cd) + \".class\");\n+            }\n+        };\n@@ -110,1 +156,0 @@\n-        private final Map<ClassDesc, ClassHierarchyResolver.ClassHierarchyInfo> resolvedCache;\n@@ -112,1 +157,1 @@\n-        public CachedClassHierarchyResolver(Function<ClassDesc, InputStream> classStreamProvider) {\n+        public ResourceParsingClassHierarchyResolver(Function<ClassDesc, InputStream> classStreamProvider) {\n@@ -114,1 +159,0 @@\n-            this.resolvedCache = Collections.synchronizedMap(new HashMap<>());\n@@ -117,1 +161,0 @@\n-\n@@ -123,21 +166,19 @@\n-            \/\/using NOPE to distinguish between null value and non-existent record in the cache\n-            \/\/this code is on JDK bootstrap critical path, so cannot use lambdas here\n-            var res = resolvedCache.getOrDefault(classDesc, NOPE);\n-            if (res == NOPE) {\n-                res = null;\n-                var ci = streamProvider.apply(classDesc);\n-                if (ci != null) {\n-                    try (var in = new DataInputStream(new BufferedInputStream(ci))) {\n-                        in.skipBytes(8);\n-                        int cpLength = in.readUnsignedShort();\n-                        String[] cpStrings = new String[cpLength];\n-                        int[] cpClasses = new int[cpLength];\n-                        for (int i=1; i<cpLength; i++) {\n-                            switch (in.readUnsignedByte()) {\n-                                case 1 -> cpStrings[i] = in.readUTF();\n-                                case 7 -> cpClasses[i] = in.readUnsignedShort();\n-                                case 8, 16, 19, 20 -> in.skipBytes(2);\n-                                case 15 -> in.skipBytes(3);\n-                                case 3, 4, 9, 10, 11, 12, 17, 18 -> in.skipBytes(4);\n-                                case 5, 6 -> {in.skipBytes(8); i++;}\n-                            }\n+            var ci = streamProvider.apply(classDesc);\n+            if (ci == null) return null;\n+            try (var in = new DataInputStream(new BufferedInputStream(ci))) {\n+                in.skipBytes(8);\n+                int cpLength = in.readUnsignedShort();\n+                String[] cpStrings = new String[cpLength];\n+                int[] cpClasses = new int[cpLength];\n+                for (int i = 1; i < cpLength; i++) {\n+                    int tag;\n+                    switch (tag = in.readUnsignedByte()) {\n+                        case TAG_UTF8 -> cpStrings[i] = in.readUTF();\n+                        case TAG_CLASS -> cpClasses[i] = in.readUnsignedShort();\n+                        case TAG_STRING, TAG_METHODTYPE, TAG_MODULE, TAG_PACKAGE -> in.skipBytes(2);\n+                        case TAG_METHODHANDLE -> in.skipBytes(3);\n+                        case TAG_INTEGER, TAG_FLOAT, TAG_FIELDREF, TAG_METHODREF, TAG_INTERFACEMETHODREF,\n+                                TAG_NAMEANDTYPE, TAG_CONSTANTDYNAMIC, TAG_INVOKEDYNAMIC -> in.skipBytes(4);\n+                        case TAG_LONG, TAG_DOUBLE -> {\n+                            in.skipBytes(8);\n+                            i++;\n@@ -145,13 +186,1 @@\n-                        boolean isInterface = (in.readUnsignedShort() & 0x0200) != 0;\n-                        in.skipBytes(2);\n-                        int superIndex = in.readUnsignedShort();\n-                        var superClass = superIndex > 0 ? ClassDesc.ofInternalName(cpStrings[cpClasses[superIndex]]) : null;\n-                        res = new ClassHierarchyInfo(classDesc, isInterface, superClass);\n-                        int interfCount = in.readUnsignedShort();\n-                        for (int i=0; i<interfCount; i++) {\n-                            \/\/all listed interfaces are cached without resolution\n-                            var intDesc = ClassDesc.ofInternalName(cpStrings[cpClasses[in.readUnsignedShort()]]);\n-                            resolvedCache.put(intDesc, new ClassHierarchyResolver.ClassHierarchyInfo(intDesc, true, null));\n-                        }\n-                    } catch (Exception ignore) {\n-                        \/\/ignore\n+                        default -> throw new IllegalStateException(\"Bad tag (\" + tag + \") at index (\" + i + \")\");\n@@ -160,2 +189,7 @@\n-                \/\/null ClassHierarchyInfo value is also cached to avoid repeated resolution attempts\n-                resolvedCache.put(classDesc, res);\n+                boolean isInterface = (in.readUnsignedShort() & ACC_INTERFACE) != 0;\n+                in.skipBytes(2);\n+                int superIndex = in.readUnsignedShort();\n+                var superClass = superIndex > 0 ? ClassDesc.ofInternalName(cpStrings[cpClasses[superIndex]]) : null;\n+                return new ClassHierarchyInfoImpl(superClass, isInterface);\n+            } catch (IOException ioe) {\n+                throw new UncheckedIOException(ioe);\n@@ -163,1 +197,0 @@\n-            return res;\n@@ -169,3 +202,0 @@\n-        private static final ClassHierarchyInfo CHI_Object =\n-                new ClassHierarchyInfo(ConstantDescs.CD_Object, false, null);\n-\n@@ -176,1 +206,1 @@\n-            map.put(ConstantDescs.CD_Object, CHI_Object);\n+            map.put(CD_Object, ClassHierarchyInfoImpl.OBJECT_INFO);\n@@ -178,1 +208,1 @@\n-                map.put(e.getKey(), new ClassHierarchyInfo(e.getKey(), false, e.getValue()));\n+                map.put(e.getKey(), ClassHierarchyInfo.ofClass(e.getValue()));\n@@ -180,1 +210,1 @@\n-                map.put(i, new ClassHierarchyInfo(i, true, null));\n+                map.put(i, ClassHierarchyInfo.ofInterface());\n@@ -188,0 +218,35 @@\n+\n+    public static final class ClassLoadingClassHierarchyResolver implements ClassHierarchyResolver {\n+        public static final Function<ClassDesc, Class<?>> SYSTEM_CLASS_PROVIDER = new Function<>() {\n+            @Override\n+            public Class<?> apply(ClassDesc cd) {\n+                try {\n+                    return Class.forName(Util.toBinaryName(cd.descriptorString()), false, ClassLoader.getSystemClassLoader());\n+                } catch (ClassNotFoundException ex) {\n+                    return null;\n+                }\n+            }\n+        };\n+        private final Function<ClassDesc, Class<?>> classProvider;\n+\n+        public ClassLoadingClassHierarchyResolver(Function<ClassDesc, Class<?>> classProvider) {\n+            this.classProvider = classProvider;\n+        }\n+\n+        @Override\n+        public ClassHierarchyInfo getClassInfo(ClassDesc cd) {\n+            if (!cd.isClassOrInterface())\n+                return null;\n+\n+            if (cd.equals(CD_Object))\n+                return ClassHierarchyInfo.ofClass(null);\n+\n+            var cl = classProvider.apply(cd);\n+            if (cl == null) {\n+                return null;\n+            }\n+\n+            return cl.isInterface() ? ClassHierarchyInfo.ofInterface()\n+                    : ClassHierarchyInfo.ofClass(cl.getSuperclass().describeConstable().orElseThrow());\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassHierarchyImpl.java","additions":121,"deletions":56,"binary":false,"changes":177,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import static jdk.internal.classfile.ClassHierarchyResolver.DEFAULT_CLASS_HIERARCHY_RESOLVER;\n+import static jdk.internal.classfile.ClassHierarchyResolver.defaultResolver;\n@@ -55,1 +55,1 @@\n-    public ClassHierarchyResolver classHierarchyResolver = DEFAULT_CLASS_HIERARCHY_RESOLVER;\n+    public ClassHierarchyResolver classHierarchyResolver = defaultResolver();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/Options.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -87,3 +87,20 @@\n-    public static String toClassString(String desc) {\n-        \/\/TODO: this doesn't look right L ... ;\n-        return desc.replace('\/', '.');\n+    \/**\n+     * Convert a descriptor of classes or interfaces or arrays, or an internal\n+     * name of a class or interface, into a fully qualified binary name, that can\n+     * be resolved by {@link Class#forName(String) Class::forName}. Primitive type\n+     * descriptors should never be passed into this method.\n+     *\n+     * @param descOrInternalName a descriptor or internal name\n+     * @return the fully qualified binary name\n+     *\/\n+    public static String toBinaryName(String descOrInternalName) {\n+        if (descOrInternalName.startsWith(\"L\")) {\n+            \/\/ descriptors of classes or interfaces\n+            if (descOrInternalName.length() <= 2 || !descOrInternalName.endsWith(\";\")) {\n+                throw new IllegalArgumentException(descOrInternalName);\n+            }\n+            return descOrInternalName.substring(1, descOrInternalName.length() - 1).replace('\/', '.');\n+        } else {\n+            \/\/ arrays, classes or interfaces' internal names\n+            return descOrInternalName.replace('\/', '.');\n+        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/Util.java","additions":21,"deletions":4,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -108,1 +108,1 @@\n-        return verify(classModel, ClassHierarchyResolver.DEFAULT_CLASS_HIERARCHY_RESOLVER, logger);\n+        return verify(classModel, ClassHierarchyResolver.defaultResolver(), logger);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/verifier\/VerifierImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -36,0 +37,2 @@\n+import java.util.stream.Stream;\n+\n@@ -37,0 +40,1 @@\n+import jdk.internal.classfile.ClassHierarchyResolver;\n@@ -110,1 +114,1 @@\n-                .flatMap(ce -> ce instanceof MethodMethod mm ? mm.elementStream() : Stream.empty())\n+                .flatMap(ce -> ce instanceof MethodModel mm ? mm.elementStream() : Stream.empty())\n@@ -306,0 +310,7 @@\n+\n+    void resolverExample() {\n+        \/\/ @start region=\"lookup-class-hierarchy-resolver\"\n+        MethodHandles.Lookup lookup = MethodHandles.lookup(); \/\/ @replace regex=\"MethodHandles\\.lookup\\(\\)\" replacement=\"...\"\n+        ClassHierarchyResolver resolver = ClassHierarchyResolver.ofClassLoading(lookup).cached();\n+        \/\/ @end\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/snippet-files\/PackageSnippets.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -122,1 +122,1 @@\n-                                          .orElse(ClassHierarchyResolver.DEFAULT_CLASS_HIERARCHY_RESOLVER)\n+                                          .orElse(ClassHierarchyResolver.defaultResolver())\n","filename":"test\/jdk\/jdk\/classfile\/AdvancedTransformationsTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,10 @@\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.impl\n+ *          java.base\/jdk.internal.classfile.impl.verifier\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/java.util:open\n+ * @comment Opens java.util so HashMap bytecode generation can access its nested\n+ *          classes with a proper Lookup object\n@@ -34,0 +44,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -38,0 +49,1 @@\n+import java.util.HashMap;\n@@ -68,1 +80,1 @@\n-    void testBreakDefaulClassHierarchy() throws Exception {\n+    void testBreakDefaultClassHierarchy() throws Exception {\n@@ -72,1 +84,1 @@\n-                Map.of(ClassDesc.of(\"java.util.HashMap$Node\"), ClassDesc.of(\"java.util.HashMap$TreeNode\"))).orElse(ClassHierarchyResolver.DEFAULT_CLASS_HIERARCHY_RESOLVER))\n+                Map.of(ClassDesc.of(\"java.util.HashMap$Node\"), ClassDesc.of(\"java.util.HashMap$TreeNode\"))).orElse(ClassHierarchyResolver.defaultResolver()))\n@@ -79,1 +91,1 @@\n-        transformAndVerify(ClassHierarchyResolver.ofCached(classDesc -> {\n+        transformAndVerify(ClassHierarchyResolver.ofResourceParsing(classDesc -> {\n@@ -88,0 +100,24 @@\n+    @Test\n+    void testClassLoaderParsingResolver() throws Exception {\n+        transformAndVerify(ClassHierarchyResolver.ofResourceParsing(ClassLoader.getSystemClassLoader()));\n+    }\n+\n+    @Test\n+    void testClassLoaderReflectionResolver() throws Exception {\n+        transformAndVerify(ClassHierarchyResolver.ofClassLoading(ClassLoader.getSystemClassLoader()));\n+    }\n+\n+    @Test\n+    void testLookupResolver() throws Exception {\n+        \/\/ A lookup must be able to access all the classes involved in the class file generation\n+        var privilegedLookup = MethodHandles.privateLookupIn(HashMap.class, MethodHandles.lookup());\n+        transformAndVerify(ClassHierarchyResolver.ofClassLoading(privilegedLookup));\n+    }\n+\n+    @Test\n+    void testLookupResolver_IllegalAccess() throws Exception {\n+        \/\/ A lookup from this test class, cannot access nested classes in HashMap\n+        var lookup = MethodHandles.lookup();\n+        assertThrows(IllegalArgumentException.class, () -> transformAndVerify(ClassHierarchyResolver.ofClassLoading(lookup)));\n+    }\n+\n@@ -89,0 +125,5 @@\n+        transformAndVerifySingle(res);\n+        transformAndVerifySingle(res.cached());\n+    }\n+\n+    void transformAndVerifySingle(ClassHierarchyResolver res) throws Exception {\n@@ -106,1 +147,6 @@\n-        if (!errors.isEmpty()) throw errors.iterator().next();\n+        if (!errors.isEmpty()) {\n+            var itr = errors.iterator();\n+            var thrown = itr.next();\n+            itr.forEachRemaining(thrown::addSuppressed);\n+            throw thrown;\n+        }\n","filename":"test\/jdk\/jdk\/classfile\/ClassHierarchyInfoTest.java","additions":51,"deletions":5,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,2 @@\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n@@ -41,0 +43,19 @@\n+    @ParameterizedTest\n+    @ValueSource(classes = {\n+            Long.class,\n+            Object.class,\n+            Util.class,\n+            Test.class,\n+            int[][].class,\n+            Object[].class,\n+    })\n+    void testDescToBinaryName(Class<?> type) throws ReflectiveOperationException {\n+        if (!type.isArray()) {\n+            \/\/ Test internal name\n+            var internal = type.getName().replace('.', '\/');\n+            assertEquals(type, Class.forName(Util.toBinaryName(internal)));\n+        }\n+        \/\/ Test descriptor\n+        assertEquals(type, Class.forName(Util.toBinaryName(type.descriptorString())));\n+    }\n+\n","filename":"test\/jdk\/jdk\/classfile\/UtilTest.java","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-                className -> new ClassHierarchyResolver.ClassHierarchyInfo(className, false, null)));\n+                className -> ClassHierarchyResolver.ClassHierarchyInfo.ofClass(null)));\n","filename":"test\/jdk\/jdk\/classfile\/VerifierSelfTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}