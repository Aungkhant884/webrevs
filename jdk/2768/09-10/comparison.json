{"files":[{"patch":"@@ -2441,0 +2441,1 @@\n+\n@@ -2444,0 +2445,1 @@\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2008, 2020, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -995,0 +995,1 @@\n+\n@@ -998,0 +999,1 @@\n+\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2162,0 +2162,1 @@\n+\n@@ -2165,0 +2166,1 @@\n+\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1548,0 +1548,1 @@\n+\n@@ -1551,0 +1552,1 @@\n+\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -149,12 +149,0 @@\n-  const int opmask_size = 8;\n-  if (UseAVX > 2) {\n-    __ subptr(rsp, 7*opmask_size);\n-    __ kmovql(Address(rsp, opmask_size * 6), k7);\n-    __ kmovql(Address(rsp, opmask_size * 5), k6);\n-    __ kmovql(Address(rsp, opmask_size * 4), k5);\n-    __ kmovql(Address(rsp, opmask_size * 3), k4);\n-    __ kmovql(Address(rsp, opmask_size * 2), k3);\n-    __ kmovql(Address(rsp, opmask_size * 1), k2);\n-    __ kmovql(Address(rsp, opmask_size * 0), k1);\n-  }\n-\n@@ -164,12 +152,0 @@\n-  \/\/ Restore registers\n-  if (UseAVX > 2) {\n-    __ kmovql(k1, Address(rsp, opmask_size * 0));\n-    __ kmovql(k2, Address(rsp, opmask_size * 1));\n-    __ kmovql(k3, Address(rsp, opmask_size * 2));\n-    __ kmovql(k4, Address(rsp, opmask_size * 3));\n-    __ kmovql(k5, Address(rsp, opmask_size * 4));\n-    __ kmovql(k6, Address(rsp, opmask_size * 5));\n-    __ kmovql(k7, Address(rsp, opmask_size * 6));\n-    __ addptr(rsp, 7*opmask_size);\n-  }\n-\n@@ -505,9 +481,0 @@\n-    if (UseAVX > 2) {\n-      caller_saved.Insert(OptoReg::as_OptoReg(k1->as_VMReg()));\n-      caller_saved.Insert(OptoReg::as_OptoReg(k2->as_VMReg()));\n-      caller_saved.Insert(OptoReg::as_OptoReg(k3->as_VMReg()));\n-      caller_saved.Insert(OptoReg::as_OptoReg(k4->as_VMReg()));\n-      caller_saved.Insert(OptoReg::as_OptoReg(k5->as_VMReg()));\n-      caller_saved.Insert(OptoReg::as_OptoReg(k6->as_VMReg()));\n-      caller_saved.Insert(OptoReg::as_OptoReg(k7->as_VMReg()));\n-    }\n@@ -538,4 +505,4 @@\n-        if (caller_saved.Member(opto_reg)) {\n-          _opmask_registers.append(vm_reg->as_KRegister());\n-          opmask_spill_size += 8;\n-        }\n+        \/\/ All opmask registers are caller saved, thus spill the ones\n+        \/\/ which are live.\n+        _opmask_registers.append(vm_reg->as_KRegister());\n+        opmask_spill_size += 8;\n@@ -630,1 +597,1 @@\n-    \/\/ Save opmask purpose registers\n+    \/\/ Save opmask registers\n","filename":"src\/hotspot\/cpu\/x86\/gc\/z\/zBarrierSetAssembler_x86.cpp","additions":5,"deletions":38,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n-  return ::as_KRegister((value() - ConcreteRegisterImpl::max_xmm));\n+  return ::as_KRegister((value() - ConcreteRegisterImpl::max_xmm) >> 1);\n","filename":"src\/hotspot\/cpu\/x86\/vmreg_x86.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-  return VMRegImpl::as_VMReg(encoding() + ConcreteRegisterImpl::max_xmm);\n+  return VMRegImpl::as_VMReg((encoding() << 1) + ConcreteRegisterImpl::max_xmm);\n","filename":"src\/hotspot\/cpu\/x86\/vmreg_x86.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1425,0 +1425,1 @@\n+  const bool is_LP64 = LP64_ONLY(true) NOT_LP64(false);\n@@ -1585,2 +1586,1 @@\n-#ifdef _LP64\n-      if (UseAVX < 3 || !VM_Version::supports_bmi2()) {\n+      if (!is_LP64  || UseAVX < 3 || !VM_Version::supports_bmi2()) {\n@@ -1589,3 +1589,0 @@\n-#else\n-      return false;\n-#endif\n@@ -1896,0 +1893,1 @@\n+\n@@ -1899,0 +1897,1 @@\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -264,1 +264,1 @@\n-  if(Matcher::has_predicated_vectors()) {\n+  if (Matcher::has_predicated_vectors()) {\n@@ -266,0 +266,6 @@\n+    const_cast<RegMask*>(&_OPMASK_REG_mask)->Remove(OptoReg::as_OptoReg(k0->as_VMReg()->next()));\n+    \/\/ Post-loop multi-versioning expects mask to be present in K1 register, till the time\n+    \/\/ its fixed, RA should not be allocting K1 register, this shall prevent any accidental\n+    \/\/ curruption of value held in K1 register.\n+    const_cast<RegMask*>(&_OPMASK_REG_mask)->Remove(OptoReg::as_OptoReg(k1->as_VMReg()));\n+    const_cast<RegMask*>(&_OPMASK_REG_mask)->Remove(OptoReg::as_OptoReg(k1->as_VMReg()->next()));\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -430,0 +430,6 @@\n+    const_cast<RegMask*>(&_OPMASK_REG_mask)->Remove(OptoReg::as_OptoReg(k0->as_VMReg()->next()));\n+    \/\/ Post-loop multi-versioning expects mask to be present in K1 register, till the time\n+    \/\/ its fixed, RA should not be allocting K1 register, this shall prevent any accidental\n+    \/\/ curruption of value held in K1 register.\n+    const_cast<RegMask*>(&_OPMASK_REG_mask)->Remove(OptoReg::as_OptoReg(k1->as_VMReg()));\n+    const_cast<RegMask*>(&_OPMASK_REG_mask)->Remove(OptoReg::as_OptoReg(k1->as_VMReg()->next()));\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2268,1 +2268,1 @@\n-    if (strcmp(rep_var,\"$KRegister\") == 0)      return \"as_KRegister\";\n+    if (strcmp(rep_var,\"$KRegister\") == 0)     return \"as_KRegister\";\n","filename":"src\/hotspot\/share\/adlc\/output_c.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -412,2 +412,2 @@\n-        ( lrg.mask().overlap(*Matcher::idealreg2regmask[Op_RegI]) ||\n-          lrg.mask().overlap(*Matcher::idealreg2regmask[Op_RegVMask]))) {\n+        (lrg.mask().overlap(*Matcher::idealreg2regmask[Op_RegI]) ||\n+         lrg.mask().overlap(*Matcher::idealreg2regmask[Op_RegVMask]))) {\n","filename":"src\/hotspot\/share\/opto\/ifg.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -992,5 +992,1 @@\n-  if (Matcher::has_predicated_vectors()) {\n-    idealreg2regmask[Op_RegVMask] = regmask_for_ideal_register(Op_RegVMask, ret);\n-  } else {\n-    idealreg2regmask[Op_RegVMask] = idealreg2regmask[Op_RegI];\n-  }\n+  idealreg2regmask[Op_RegVMask] = regmask_for_ideal_register(Op_RegVMask, ret);\n@@ -2591,3 +2587,1 @@\n-    case Op_RegVMask: {\n-       return Matcher::predicate_reg_mask();\n-    } break;\n+    case Op_RegVMask: return Matcher::predicate_reg_mask();\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -696,0 +696,1 @@\n+        DEFINE_CLASS_ID(VectorMaskCmp, Vector, 0)\n@@ -740,1 +741,0 @@\n-      DEFINE_CLASS_ID(VectorMaskCmp, Vector, 0)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -664,2 +664,1 @@\n-#if defined(X86)\n-  TypeVect::VMASK = (TypeVect*)(Matcher::predicate_reg_type(TypeInt::BOOL, MaxVectorSize))->hashcons();\n+  TypeVect::VMASK = (TypeVect*)(new TypeVectMask(TypeInt::BOOL, MaxVectorSize))->hashcons();\n@@ -667,1 +666,0 @@\n-#endif\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -89,1 +89,1 @@\n-void VectorSupport::init_payload_element(typeArrayOop arr, bool is_mask, BasicType elem_bt, int index, address addr, Location loc) {\n+void VectorSupport::init_payload_element(typeArrayOop arr, bool is_mask, BasicType elem_bt, int index, address addr) {\n@@ -142,1 +142,1 @@\n-      init_payload_element(arr, is_mask, elem_bt, i, elem_addr, location);\n+      init_payload_element(arr, is_mask, elem_bt, i, elem_addr);\n@@ -148,1 +148,1 @@\n-      init_payload_element(arr, is_mask, elem_bt, i, base_addr + i * elem_size, location);\n+      init_payload_element(arr, is_mask, elem_bt, i, base_addr + i * elem_size);\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-  static void init_payload_element(typeArrayOop arr, bool is_mask, BasicType elem_bt, int index, address addr, Location location);\n+  static void init_payload_element(typeArrayOop arr, bool is_mask, BasicType elem_bt, int index, address addr);\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}