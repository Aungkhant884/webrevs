{"files":[{"patch":"@@ -133,1 +133,0 @@\n-  int opmask_state_bytes = KRegisterImpl::number_of_registers * 8;\n@@ -135,0 +134,1 @@\n+  int opmask_state_bytes = KRegisterImpl::number_of_registers * 8;\n@@ -143,0 +143,1 @@\n+      additional_frame_words += opmask_state_bytes \/ wordSize;\n@@ -146,3 +147,0 @@\n-  if(UseAVX > 2) {\n-    additional_frame_words += opmask_state_bytes \/ wordSize;\n-  }\n@@ -236,0 +234,5 @@\n+      __ subptr(rsp, opmask_state_bytes);\n+      \/\/ Save opmask registers\n+      for (int n = 0; n < KRegisterImpl::number_of_registers; n++) {\n+        __ kmovql(Address(rsp, n*8), as_KRegister(n));\n+      }\n@@ -238,9 +241,0 @@\n-#ifdef COMPILER2\n-  if (UseAVX > 2) {\n-    __ subptr(rsp, opmask_state_bytes);\n-    \/\/ Save opmask registers\n-    for (int n = 0; n < KRegisterImpl::number_of_registers; n++) {\n-      __ kmovql(Address(rsp, n*8), as_KRegister(n));\n-    }\n-  }\n-#endif\n@@ -307,0 +301,2 @@\n+      opmask_state_bytes = KRegisterImpl::number_of_registers * 8;\n+      additional_frame_bytes += opmask_state_bytes;\n@@ -309,4 +305,0 @@\n-  if (UseAVX > 2) {\n-    opmask_state_bytes = KRegisterImpl::number_of_registers * 8;\n-    additional_frame_bytes += opmask_state_bytes;\n-  }\n@@ -350,1 +342,0 @@\n-#ifdef COMPILER2\n@@ -354,1 +345,0 @@\n-#endif\n@@ -357,9 +347,0 @@\n-  } else {\n-#ifdef COMPILER2\n-    if (UseAVX > 2) {\n-      for (int n = 0; n < KRegisterImpl::number_of_registers; n++) {\n-        __ kmovql(as_KRegister(n), Address(rsp, n*8));\n-      }\n-      __ addptr(rsp, additional_frame_bytes);\n-    }\n-#endif\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_32.cpp","additions":9,"deletions":28,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -110,1 +110,1 @@\n-    \/\/ 2..7 are implied in range usage\n+    \/\/ 2..15 are implied in range usage\n@@ -114,1 +114,7 @@\n-    \/\/ 2..15 are implied in range usage\n+    DEF_OPMASK_OFFS(2),\n+    DEF_OPMASK_OFFS(3),\n+    DEF_OPMASK_OFFS(4),\n+    DEF_OPMASK_OFFS(5),\n+    DEF_OPMASK_OFFS(6),\n+    DEF_OPMASK_OFFS(7),\n+    \/\/ 2..7 are implied in range usage\n@@ -294,0 +300,7 @@\n+    map->set_callee_saved(STACK_OFFSET( opmask1_off ), k1->as_VMReg());\n+    map->set_callee_saved(STACK_OFFSET( opmask2_off ), k2->as_VMReg());\n+    map->set_callee_saved(STACK_OFFSET( opmask3_off ), k3->as_VMReg());\n+    map->set_callee_saved(STACK_OFFSET( opmask4_off ), k4->as_VMReg());\n+    map->set_callee_saved(STACK_OFFSET( opmask5_off ), k5->as_VMReg());\n+    map->set_callee_saved(STACK_OFFSET( opmask6_off ), k6->as_VMReg());\n+    map->set_callee_saved(STACK_OFFSET( opmask7_off ), k7->as_VMReg());\n@@ -354,0 +367,7 @@\n+      map->set_callee_saved(STACK_OFFSET( opmask1H_off ), k1->as_VMReg()->next());\n+      map->set_callee_saved(STACK_OFFSET( opmask2H_off ), k2->as_VMReg()->next());\n+      map->set_callee_saved(STACK_OFFSET( opmask3H_off ), k3->as_VMReg()->next());\n+      map->set_callee_saved(STACK_OFFSET( opmask4H_off ), k4->as_VMReg()->next());\n+      map->set_callee_saved(STACK_OFFSET( opmask5H_off ), k5->as_VMReg()->next());\n+      map->set_callee_saved(STACK_OFFSET( opmask6H_off ), k6->as_VMReg()->next());\n+      map->set_callee_saved(STACK_OFFSET( opmask7H_off ), k7->as_VMReg()->next());\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":22,"deletions":2,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -428,1 +428,1 @@\n-  if(Matcher::has_predicated_vectors()) {\n+  if (Matcher::has_predicated_vectors()) {\n@@ -1407,1 +1407,1 @@\n-      \/\/ 64-bit\n+        \/\/ 64-bit\n@@ -1544,1 +1544,1 @@\n-    } else if(dst_first_rc == rc_int) {\n+    } else if (dst_first_rc == rc_int) {\n@@ -1561,1 +1561,1 @@\n-    } else if(dst_first_rc == rc_kreg) {\n+    } else if (dst_first_rc == rc_kreg) {\n@@ -1577,1 +1577,1 @@\n-    } else if(dst_first_rc == rc_float) {\n+    } else if (dst_first_rc == rc_float) {\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -53,0 +53,2 @@\n+  case vector:       st->print(\",vector\");     break;\n+  case vectorpred:   st->print(\",vectorpred\"); break;\n","filename":"src\/hotspot\/share\/code\/location.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+    vectorpred,                 \/\/ Predicated register in one register\n","filename":"src\/hotspot\/share\/code\/location.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -922,1 +922,1 @@\n-          lrg.set_num_regs(RegMask::SlotsPerRegVmask);\n+          lrg.set_num_regs(RegMask::SlotsPerRegVMask);\n","filename":"src\/hotspot\/share\/opto\/chaitin.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -900,0 +900,2 @@\n+    } else if ( t->base() == Type::VectorM ) {\n+      array->append(new_loc_value( C->regalloc(), regnum, Location::vectorpred ));\n@@ -986,0 +988,8 @@\n+    case Type::VectorA:\n+    case Type::VectorS:\n+    case Type::VectorD:\n+    case Type::VectorX:\n+    case Type::VectorY:\n+    case Type::VectorZ:\n+    case Type::VectorM:\n+      \/\/ Vector payload should always be present in a physical vector register location.\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-      return SlotsPerRegVmask;\n+      return SlotsPerRegVMask;\n","filename":"src\/hotspot\/share\/opto\/regmask.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -108,1 +108,1 @@\n-         SlotsPerRegVmask = X86_ONLY(2) NOT_X86(1)\n+         SlotsPerRegVMask = X86_ONLY(2) NOT_X86(1)\n","filename":"src\/hotspot\/share\/opto\/regmask.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -664,1 +664,1 @@\n-#if defined(AMD64) || defined(IA32)\n+#if defined(X86)\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -306,1 +306,1 @@\n-  const TypeVectMask *isa_vectmask() const;      \/\/ Returns NULL if not a Predicate\/Mask Vector\n+  const TypeVectMask *isa_vectmask() const;      \/\/ Returns NULL if not a Vector Predicate\/Mask\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -89,1 +89,1 @@\n-void VectorSupport::init_payload_element(typeArrayOop arr, bool is_mask, BasicType elem_bt, int index, address addr) {\n+void VectorSupport::init_payload_element(typeArrayOop arr, bool is_mask, BasicType elem_bt, int index, address addr, Location loc) {\n@@ -91,16 +91,26 @@\n-    \/\/ Masks require special handling: when boxed they are packed and stored in boolean\n-    \/\/ arrays, but in scalarized form they have the same size as corresponding vectors.\n-    \/\/ For example, Int512Mask is represented in memory as boolean[16], but\n-    \/\/ occupies the whole 512-bit vector register when scalarized.\n-    \/\/ (In generated code, the conversion is performed by VectorStoreMask.)\n-    \/\/\n-    \/\/ TODO: revisit when predicate registers are fully supported.\n-    switch (elem_bt) {\n-      case T_BYTE:   arr->bool_at_put(index,  (*(jbyte*)addr) != 0); break;\n-      case T_SHORT:  arr->bool_at_put(index, (*(jshort*)addr) != 0); break;\n-      case T_INT:    \/\/ fall-through\n-      case T_FLOAT:  arr->bool_at_put(index,   (*(jint*)addr) != 0); break;\n-      case T_LONG:   \/\/ fall-through\n-      case T_DOUBLE: arr->bool_at_put(index,  (*(jlong*)addr) != 0); break;\n-\n-      default: fatal(\"unsupported: %s\", type2name(elem_bt));\n+    if ( loc.type() == Location::vectorpred ) {\n+#if defined(X86)\n+      \/\/ For targets supporting X86-AVX512 feature, opmask\/predicate register is 8 byte(64 bits) wide,\n+      \/\/ where each bit location corresponds to a lane element in vector register. This is different\n+      \/\/ for non-AVX512 targets where mask vector has same shape as that of the vector register its operating on.\n+      assert(Matcher::has_predicated_vectors() , \"\");\n+      arr->bool_at_put(index,  ((*(jlong*)addr) & (1 << index)) != 0);\n+      return;\n+#endif\n+    } else {\n+      \/\/ Masks require special handling: when boxed they are packed and stored in boolean\n+      \/\/ arrays, but in scalarized form they have the same size as corresponding vectors.\n+      \/\/ For example, Int512Mask is represented in memory as boolean[16], but\n+      \/\/ occupies the whole 512-bit vector register when scalarized.\n+      \/\/ (In generated code, the conversion is performed by VectorStoreMask.)\n+      \/\/\n+      switch (elem_bt) {\n+        case T_BYTE:   arr->bool_at_put(index,  (*(jbyte*)addr) != 0); break;\n+        case T_SHORT:  arr->bool_at_put(index, (*(jshort*)addr) != 0); break;\n+        case T_INT:    \/\/ fall-through\n+        case T_FLOAT:  arr->bool_at_put(index,   (*(jint*)addr) != 0); break;\n+        case T_LONG:   \/\/ fall-through\n+        case T_DOUBLE: arr->bool_at_put(index,  (*(jlong*)addr) != 0); break;\n+\n+        default: fatal(\"unsupported: %s\", type2name(elem_bt));\n+      }\n@@ -138,6 +148,16 @@\n-    for (int i = 0; i < num_elem; i++) {\n-      int vslot = (i * elem_size) \/ VMRegImpl::stack_slot_size;\n-      int off   = (i * elem_size) % VMRegImpl::stack_slot_size;\n-\n-      address elem_addr = reg_map->location(vreg, vslot) + off; \/\/ assumes little endian element order\n-      init_payload_element(arr, is_mask, elem_bt, i, elem_addr);\n+    if (location.type() == Location::vectorpred) {\n+#if defined(X86)\n+      \/\/ For X86 two adjacent stack slots hold 64 bit opmask register value.\n+      address elem_addr = reg_map->location(vreg, 0); \/\/ assumes little endian element order\n+      for (int i = 0; i < num_elem; i++) {\n+        init_payload_element(arr, is_mask, elem_bt, i, elem_addr, location);\n+      }\n+#endif\n+    } else {\n+      for (int i = 0; i < num_elem; i++) {\n+        int vslot = (i * elem_size) \/ VMRegImpl::stack_slot_size;\n+        int off   = (i * elem_size) % VMRegImpl::stack_slot_size;\n+\n+        address elem_addr = reg_map->location(vreg, vslot) + off; \/\/ assumes little endian element order\n+        init_payload_element(arr, is_mask, elem_bt, i, elem_addr, location);\n+      }\n@@ -148,2 +168,11 @@\n-    for (int i = 0; i < num_elem; i++) {\n-      init_payload_element(arr, is_mask, elem_bt, i, base_addr + i * elem_size);\n+    if (location.type() == Location::vectorpred) {\n+#if defined(X86)\n+      \/\/ For X86 two adjacent stack slots hold 64 bit opmask register value.\n+      for (int i = 0; i < num_elem; i++) {\n+        init_payload_element(arr, is_mask, elem_bt, i, base_addr, location);\n+      }\n+#endif\n+    } else {\n+      for (int i = 0; i < num_elem; i++) {\n+        init_payload_element(arr, is_mask, elem_bt, i, base_addr + i * elem_size, location);\n+      }\n@@ -157,1 +186,2 @@\n-      payload->as_LocationValue()->location().type() == Location::vector) {\n+      (payload->as_LocationValue()->location().type() == Location::vector    ||\n+       payload->as_LocationValue()->location().type() == Location::vectorpred)) {\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.cpp","additions":56,"deletions":26,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-  static void init_payload_element(typeArrayOop arr, bool is_mask, BasicType elem_bt, int index, address addr);\n+  static void init_payload_element(typeArrayOop arr, bool is_mask, BasicType elem_bt, int index, address addr, Location location);\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -156,0 +156,1 @@\n+    case Location::vectorpred:\n","filename":"src\/hotspot\/share\/runtime\/stackValue.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}