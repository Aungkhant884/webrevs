{"files":[{"patch":"@@ -114,6 +114,0 @@\n-    DEF_OPMASK_OFFS(2),\n-    DEF_OPMASK_OFFS(3),\n-    DEF_OPMASK_OFFS(4),\n-    DEF_OPMASK_OFFS(5),\n-    DEF_OPMASK_OFFS(6),\n-    DEF_OPMASK_OFFS(7),\n@@ -303,7 +297,0 @@\n-    map->set_callee_saved(STACK_OFFSET( opmask1_off ), k1->as_VMReg());\n-    map->set_callee_saved(STACK_OFFSET( opmask2_off ), k2->as_VMReg());\n-    map->set_callee_saved(STACK_OFFSET( opmask3_off ), k3->as_VMReg());\n-    map->set_callee_saved(STACK_OFFSET( opmask4_off ), k4->as_VMReg());\n-    map->set_callee_saved(STACK_OFFSET( opmask5_off ), k5->as_VMReg());\n-    map->set_callee_saved(STACK_OFFSET( opmask6_off ), k6->as_VMReg());\n-    map->set_callee_saved(STACK_OFFSET( opmask7_off ), k7->as_VMReg());\n@@ -370,7 +357,0 @@\n-      map->set_callee_saved(STACK_OFFSET( opmask1H_off ), k1->as_VMReg()->next());\n-      map->set_callee_saved(STACK_OFFSET( opmask2H_off ), k2->as_VMReg()->next());\n-      map->set_callee_saved(STACK_OFFSET( opmask3H_off ), k3->as_VMReg()->next());\n-      map->set_callee_saved(STACK_OFFSET( opmask4H_off ), k4->as_VMReg()->next());\n-      map->set_callee_saved(STACK_OFFSET( opmask5H_off ), k5->as_VMReg()->next());\n-      map->set_callee_saved(STACK_OFFSET( opmask6H_off ), k6->as_VMReg()->next());\n-      map->set_callee_saved(STACK_OFFSET( opmask7H_off ), k7->as_VMReg()->next());\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":0,"deletions":20,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -54,1 +54,0 @@\n-  case vectorpred:   st->print(\",vectorpred\"); break;\n","filename":"src\/hotspot\/share\/code\/location.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -62,1 +62,0 @@\n-    vectorpred,                 \/\/ Predicated register in one register\n","filename":"src\/hotspot\/share\/code\/location.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -900,2 +900,0 @@\n-    } else if ( t->base() == Type::VectorM ) {\n-      array->append(new_loc_value( C->regalloc(), regnum, Location::vectorpred ));\n@@ -988,8 +986,0 @@\n-    case Type::VectorA:\n-    case Type::VectorS:\n-    case Type::VectorD:\n-    case Type::VectorX:\n-    case Type::VectorY:\n-    case Type::VectorZ:\n-    case Type::VectorM:\n-      \/\/ Vector payload should always be present in a physical vector register location.\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -91,28 +91,15 @@\n-    if ( loc.type() == Location::vectorpred ) {\n-#if defined(X86)\n-      \/\/ For targets supporting X86-AVX512 feature, opmask\/predicate register is 8 byte(64 bits) wide,\n-      \/\/ where each bit location corresponds to a lane element in vector register. This is different\n-      \/\/ for non-AVX512 targets where mask vector has same shape as that of the vector register its operating on.\n-#if defined(COMPILER2)\n-      assert(Matcher::has_predicated_vectors() , \"\");\n-#endif\n-      arr->bool_at_put(index,  ((*(jlong*)addr) & (UCONST64(1) << index)) != UCONST64(0));\n-      return;\n-#endif\n-    } else {\n-      \/\/ Masks require special handling: when boxed they are packed and stored in boolean\n-      \/\/ arrays, but in scalarized form they have the same size as corresponding vectors.\n-      \/\/ For example, Int512Mask is represented in memory as boolean[16], but\n-      \/\/ occupies the whole 512-bit vector register when scalarized.\n-      \/\/ (In generated code, the conversion is performed by VectorStoreMask.)\n-      \/\/\n-      switch (elem_bt) {\n-        case T_BYTE:   arr->bool_at_put(index,  (*(jbyte*)addr) != 0); break;\n-        case T_SHORT:  arr->bool_at_put(index, (*(jshort*)addr) != 0); break;\n-        case T_INT:    \/\/ fall-through\n-        case T_FLOAT:  arr->bool_at_put(index,   (*(jint*)addr) != 0); break;\n-        case T_LONG:   \/\/ fall-through\n-        case T_DOUBLE: arr->bool_at_put(index,  (*(jlong*)addr) != 0); break;\n-\n-        default: fatal(\"unsupported: %s\", type2name(elem_bt));\n-      }\n+    \/\/ Masks require special handling: when boxed they are packed and stored in boolean\n+    \/\/ arrays, but in scalarized form they have the same size as corresponding vectors.\n+    \/\/ For example, Int512Mask is represented in memory as boolean[16], but\n+    \/\/ occupies the whole 512-bit vector register when scalarized.\n+    \/\/ (In generated code, the conversion is performed by VectorStoreMask.)\n+    \/\/\n+    switch (elem_bt) {\n+      case T_BYTE:   arr->bool_at_put(index,  (*(jbyte*)addr) != 0); break;\n+      case T_SHORT:  arr->bool_at_put(index, (*(jshort*)addr) != 0); break;\n+      case T_INT:    \/\/ fall-through\n+      case T_FLOAT:  arr->bool_at_put(index,   (*(jint*)addr) != 0); break;\n+      case T_LONG:   \/\/ fall-through\n+      case T_DOUBLE: arr->bool_at_put(index,  (*(jlong*)addr) != 0); break;\n+\n+      default: fatal(\"unsupported: %s\", type2name(elem_bt));\n@@ -150,16 +137,6 @@\n-    if (location.type() == Location::vectorpred) {\n-#if defined(X86)\n-      \/\/ For X86 two adjacent stack slots hold 64 bit opmask register value.\n-      address elem_addr = reg_map->location(vreg, 0); \/\/ assumes little endian element order\n-      for (int i = 0; i < num_elem; i++) {\n-        init_payload_element(arr, is_mask, elem_bt, i, elem_addr, location);\n-      }\n-#endif\n-    } else {\n-      for (int i = 0; i < num_elem; i++) {\n-        int vslot = (i * elem_size) \/ VMRegImpl::stack_slot_size;\n-        int off   = (i * elem_size) % VMRegImpl::stack_slot_size;\n-\n-        address elem_addr = reg_map->location(vreg, vslot) + off; \/\/ assumes little endian element order\n-        init_payload_element(arr, is_mask, elem_bt, i, elem_addr, location);\n-      }\n+    for (int i = 0; i < num_elem; i++) {\n+      int vslot = (i * elem_size) \/ VMRegImpl::stack_slot_size;\n+      int off   = (i * elem_size) % VMRegImpl::stack_slot_size;\n+\n+      address elem_addr = reg_map->location(vreg, vslot) + off; \/\/ assumes little endian element order\n+      init_payload_element(arr, is_mask, elem_bt, i, elem_addr, location);\n@@ -170,11 +147,2 @@\n-    if (location.type() == Location::vectorpred) {\n-#if defined(X86)\n-      \/\/ For X86 two adjacent stack slots hold 64 bit opmask register value.\n-      for (int i = 0; i < num_elem; i++) {\n-        init_payload_element(arr, is_mask, elem_bt, i, base_addr, location);\n-      }\n-#endif\n-    } else {\n-      for (int i = 0; i < num_elem; i++) {\n-        init_payload_element(arr, is_mask, elem_bt, i, base_addr + i * elem_size, location);\n-      }\n+    for (int i = 0; i < num_elem; i++) {\n+      init_payload_element(arr, is_mask, elem_bt, i, base_addr + i * elem_size, location);\n@@ -188,2 +156,1 @@\n-      (payload->as_LocationValue()->location().type() == Location::vector    ||\n-       payload->as_LocationValue()->location().type() == Location::vectorpred)) {\n+      payload->as_LocationValue()->location().type() == Location::vector) {\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.cpp","additions":24,"deletions":57,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -156,1 +156,0 @@\n-    case Location::vectorpred:\n","filename":"src\/hotspot\/share\/runtime\/stackValue.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}