{"files":[{"patch":"@@ -2441,3 +2441,0 @@\n-const bool Matcher::is_predicate_operand(int opcode) {\n-  return false;\n-}\n@@ -2447,4 +2444,0 @@\n-const Type* Matcher::predicate_reg_type() {\n-  assert(has_predicated_vectors(), \"\");\n-  return Type::BOTTOM;\n-}\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -995,3 +995,0 @@\n-const bool Matcher::is_predicate_operand(int opcode) {\n-  return false;\n-}\n@@ -1001,4 +998,0 @@\n-const Type* Matcher::predicate_reg_type() {\n-  assert(has_predicated_vectors(), \"\");\n-  return Type::BOTTOM;\n-}\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2162,3 +2162,0 @@\n-const bool Matcher::is_predicate_operand(int opcode) {\n-  return false;\n-}\n@@ -2168,4 +2165,0 @@\n-const Type* Matcher::predicate_reg_type() {\n-  assert(has_predicated_vectors(), \"\");\n-  return Type::BOTTOM;\n-}\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1548,3 +1548,0 @@\n-const bool Matcher::is_predicate_operand(int opcode) {\n-  return false;\n-}\n@@ -1554,4 +1551,0 @@\n-const Type* Matcher::predicate_reg_type() {\n-  assert(has_predicated_vectors(), \"\");\n-  return Type::BOTTOM;\n-}\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -34,2 +34,2 @@\n-  void setvectmask(Register dst, Register src, KRegister mask = k1);\n-  void restorevectmask(KRegister mask = k1);\n+  void setvectmask(Register dst, Register src, KRegister mask);\n+  void restorevectmask(KRegister mask);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -292,0 +292,2 @@\n+  int opmask_state_bytes = 0;\n+  int additional_frame_bytes = 0;\n@@ -295,1 +297,0 @@\n-  int opmask_state_bytes = KRegisterImpl::number_of_registers * 8;\n@@ -297,1 +298,0 @@\n-  int additional_frame_bytes = 0;\n@@ -310,0 +310,1 @@\n+    opmask_state_bytes = KRegisterImpl::number_of_registers * 8;\n@@ -349,0 +350,1 @@\n+#ifdef COMPILER2\n@@ -352,0 +354,1 @@\n+#endif\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_32.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1901,24 +1901,0 @@\n-const bool Matcher::is_predicate_operand(int opcode) {\n-  if (!has_predicated_vectors()) {\n-    return false;\n-  }\n-  switch(opcode) {\n-    case KREG:\n-    case KREG_K0:\n-    case KREG_K1:\n-    case KREG_K2:\n-    case KREG_K3:\n-    case KREG_K4:\n-    case KREG_K5:\n-    case KREG_K6:\n-    case KREG_K7:\n-      return true;\n-    default:\n-      return false;\n-  }\n-}\n-\n-const Type* Matcher::predicate_reg_type() {\n-  return TypeLong::LONG;\n-}\n-\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":0,"deletions":24,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -1059,1 +1059,1 @@\n-  if (bottom_type()->isa_vect() != NULL) {\n+  if (bottom_type()->isa_vect() != NULL && bottom_type()->isa_vectmask() == NULL) {\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1151,1 +1151,1 @@\n-  if (bottom_type()->isa_vect() != NULL) {\n+  if (bottom_type()->isa_vect() != NULL && bottom_type()->isa_vectmask() == NULL) {\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -949,1 +949,1 @@\n-    return \"Matcher::predicate_reg_type()\";\n+    return \"TypeVect::VMASK\";\n","filename":"src\/hotspot\/share\/adlc\/archDesc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -125,61 +125,0 @@\n-\n-void PhiNode::add_req(Node *n) {\n-  Node::add_req(n);\n-  if (Matcher::is_mask_generating_node(n)) {\n-    set_has_masked_inputs(true);\n-  }\n-}\n-\n-void PhiNode::add_req_batch(Node* n, uint m) {\n-  Node::add_req_batch(n, m);\n-  if (Matcher::is_mask_generating_node(n)) {\n-    set_has_masked_inputs(true);\n-  }\n-}\n-void PhiNode::del_req(uint idx) {\n-  Node::del_req(idx);\n-  bool remove_masked_inputs_flags = true;\n-  for(uint i = 0; i < req() ; i++) {\n-     if(Matcher::is_mask_generating_node(in(i))) {\n-        remove_masked_inputs_flags = false;\n-     }\n-  }\n-  if (remove_masked_inputs_flags) {\n-     set_has_masked_inputs(false);\n-  }\n-}\n-\n-void PhiNode::del_req_ordered(uint idx) {\n-  Node::del_req_ordered(idx);\n-  bool remove_masked_inputs_flags = true;\n-  for(uint i = 0; i < req() ; i++) {\n-     if(Matcher::is_mask_generating_node(in(i))) {\n-        remove_masked_inputs_flags = false;\n-     }\n-  }\n-  if (remove_masked_inputs_flags) {\n-     set_has_masked_inputs(false);\n-  }\n-}\n-\n-void PhiNode::ins_req(uint i, Node *n) {\n-  Node::ins_req(i, n);\n-  if (Matcher::is_mask_generating_node(n)) {\n-    set_has_masked_inputs(true);\n-  }\n-}\n-\n-void PhiNode::set_req(uint i, Node *n) {\n-  Node::set_req(i, n);\n-  if (Matcher::is_mask_generating_node(n)) {\n-    set_has_masked_inputs(true);\n-  }\n-}\n-\n-void PhiNode::init_req(uint i, Node *n) {\n-  Node::init_req(i, n);\n-  if (Matcher::is_mask_generating_node(n)) {\n-    set_has_masked_inputs(true);\n-  }\n-}\n-\n@@ -2520,3 +2459,0 @@\n-  if (_has_masked_inputs) {\n-    ideal_reg = Op_RegVMask;\n-  }\n@@ -2529,16 +2465,0 @@\n-uint PhiNode::ideal_reg() const {\n-  if (_has_masked_inputs) {\n-    return Op_RegVMask;\n-  } else {\n-    return _type->ideal_reg();\n-  }\n-}\n-\n-const Type* PhiNode::bottom_type() const {\n-  if (_has_masked_inputs) {\n-    return Matcher::predicate_reg_type();\n-  } else {\n-    return type();\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":0,"deletions":80,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -137,1 +137,0 @@\n-  bool _has_masked_inputs;\n@@ -163,2 +162,1 @@\n-      _inst_offset(ioffs),\n-      _has_masked_inputs(false)\n+      _inst_offset(ioffs)\n@@ -185,2 +183,0 @@\n-  bool has_masked_inputs() { return _has_masked_inputs;}\n-  void set_has_masked_inputs(bool val = true) { _has_masked_inputs = val;}\n@@ -207,9 +203,0 @@\n-  virtual uint  ideal_reg() const;\n-\n-  virtual void add_req(Node *n);\n-  virtual void add_req_batch(Node* n, uint m);\n-  virtual void del_req(uint idx);\n-  virtual void del_req_ordered(uint idx);\n-  virtual void ins_req(uint i, Node *n);\n-  virtual void set_req(uint i, Node *n);\n-  virtual void init_req(uint i, Node *n);\n@@ -230,1 +217,0 @@\n-  virtual const Type *bottom_type() const;\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":1,"deletions":15,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -898,3 +898,0 @@\n-#if defined(IA32) || defined(AMD64)\n-        case Op_RegVMask:\n-#endif\n@@ -906,1 +903,1 @@\n-          if( ireg == Op_RegL  || ireg == Op_RegVMask ) {\n+          if( ireg == Op_RegL) {\n@@ -924,0 +921,4 @@\n+        case Op_RegVMask:\n+          lrg.set_num_regs(RegMask::SlotsPerRegVmask);\n+          lrg.set_reg_pressure(1);\n+          break;\n","filename":"src\/hotspot\/share\/opto\/chaitin.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -325,2 +325,0 @@\n-    } else if (Matcher::is_mask_generating_oper(ideal_Opcode())) {\n-      return Op_RegVMask;\n@@ -1094,8 +1092,0 @@\n-  virtual uint ideal_reg() const {\n-    if (Matcher::is_predicate_operand(_opnd_array[0]->opcode())) {\n-      return Op_RegVMask;\n-    } else {\n-      return MachNode::ideal_reg();\n-    }\n-  }\n-\n","filename":"src\/hotspot\/share\/opto\/machnode.hpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -236,1 +236,1 @@\n-  Node* mask_gen =  new VectorMaskGenNode(length, Matcher::predicate_reg_type(), Type::get_const_basic_type(type));\n+  Node* mask_gen =  new VectorMaskGenNode(length, TypeVect::VMASK, Type::get_const_basic_type(type));\n","filename":"src\/hotspot\/share\/opto\/macroArrayCopy.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2862,23 +2862,0 @@\n-\n-bool Matcher::is_mask_generating_node(Node* n) {\n-  if(!Matcher::has_predicated_vectors() || !n) {\n-    return false;\n-  }\n-  if (n->is_Phi()) {\n-    return reinterpret_cast<PhiNode*>(n)->has_masked_inputs();\n-  }\n-  return is_mask_generating_oper(n->Opcode());\n-}\n-\n-bool Matcher::is_mask_generating_oper(int opcode) {\n-  \/\/TODO: Other mask generating nodes are VectorLoadMask\n-  \/\/and VectorMaskCmp, will be handled along with changes\n-  \/\/to corresponding instruction patterns.\n-  switch(opcode) {\n-    case Op_VectorMaskGen:\n-      return true;\n-    default:\n-      return false;\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":0,"deletions":23,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -323,5 +323,0 @@\n-  static const bool is_predicate_operand(int opcode);\n-  static bool is_mask_generating_node(Node* n);\n-  static bool is_mask_generating_oper(int opcode);\n-\n-  static const Type* predicate_reg_type();\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -413,1 +413,1 @@\n-  virtual void add_req( Node *n ); \/\/ Append a NEW required input\n+  void add_req( Node *n ); \/\/ Append a NEW required input\n@@ -418,5 +418,5 @@\n-  virtual void add_req_batch( Node* n, uint m ); \/\/ Append m NEW required inputs (all n).\n-  virtual void del_req( uint idx ); \/\/ Delete required edge & compact\n-  virtual void del_req_ordered( uint idx ); \/\/ Delete required edge & compact with preserved order\n-  virtual void ins_req( uint i, Node *n ); \/\/ Insert a NEW required input\n-  virtual void set_req( uint i, Node *n ) {\n+  void add_req_batch( Node* n, uint m ); \/\/ Append m NEW required inputs (all n).\n+  void del_req( uint idx ); \/\/ Delete required edge & compact\n+  void del_req_ordered( uint idx ); \/\/ Delete required edge & compact with preserved order\n+  void ins_req( uint i, Node *n ); \/\/ Insert a NEW required input\n+  void set_req( uint i, Node *n ) {\n@@ -434,1 +434,1 @@\n-  virtual void init_req( uint i, Node *n ) {\n+  void init_req( uint i, Node *n ) {\n@@ -1025,1 +1025,0 @@\n-  virtual const void* meta_data() const { return NULL; }\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1358,3 +1358,0 @@\n-      if (def->ideal_reg() == Op_RegVMask) {\n-        static_cast<PhiNode*>(phi)->set_has_masked_inputs();\n-      }\n","filename":"src\/hotspot\/share\/opto\/reg_split.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -70,1 +70,0 @@\n-#if defined(AMD64) || defined(IA32)\n@@ -72,1 +71,1 @@\n-#endif\n+      return SlotsPerRegVmask;\n","filename":"src\/hotspot\/share\/opto\/regmask.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -108,0 +108,1 @@\n+         SlotsPerRegVmask = X86_ONLY(2) NOT_X86(1)\n","filename":"src\/hotspot\/share\/opto\/regmask.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -66,0 +66,1 @@\n+  { Bad,             T_ILLEGAL,    \"vectorm:\",      false, Op_RegVMask,          relocInfo::none          },  \/\/ VectorM.\n@@ -73,0 +74,1 @@\n+  { Bad,             T_ILLEGAL,    \"vectorm:\",      false, Op_RegVMask,          relocInfo::none          },  \/\/ VectorM.\n@@ -80,0 +82,1 @@\n+  { Bad,             T_ILLEGAL,    \"vectorm:\",      false, Op_RegVMask,          relocInfo::none          },  \/\/ VectorM.\n@@ -563,3 +566,0 @@\n-  if (Matcher::has_predicated_vectors()) {\n-    mreg2type[Op_RegVMask] = Matcher::predicate_reg_type();\n-  }\n@@ -664,0 +664,5 @@\n+#if defined(AMD64) || defined(IA32)\n+  TypeVect::VMASK = (TypeVect*)(new TypeVectMask(get_const_basic_type(T_BOOLEAN), MaxVectorSize))->hashcons();\n+  mreg2type[Op_RegVMask] = TypeVect::VMASK;\n+#endif\n+\n@@ -2382,0 +2387,1 @@\n+const TypeVect *TypeVect::VMASK = NULL; \/\/ predicate\/mask vector\n@@ -2409,0 +2415,8 @@\n+const TypeVect *TypeVect::makemask(const BasicType elem_bt, uint length) {\n+  if (Matcher::has_predicated_vectors()) {\n+    return (TypeVect*)(new TypeVectMask(get_const_basic_type(T_BOOLEAN), MaxVectorSize))->hashcons();\n+  } else {\n+    return make(get_const_basic_type(elem_bt), length);\n+  }\n+}\n+\n@@ -2423,0 +2437,1 @@\n+  case VectorM:\n@@ -2490,0 +2505,2 @@\n+  case VectorM:\n+    st->print(\"vectorm[\"); break;\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":20,"deletions":3,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+class     TypeVectMask;\n@@ -92,0 +93,2 @@\n+\n+    VectorM,                    \/\/ Vector predicate\/mask type\n@@ -302,0 +305,2 @@\n+  const TypeVectMask *is_vectmask() const;       \/\/ Predicate\/Mask Vector\n+  const TypeVectMask *isa_vectmask() const;      \/\/ Returns NULL if not a Predicate\/Mask Vector\n@@ -800,0 +805,2 @@\n+  static const TypeVect *makemask(const BasicType elem_bt, uint length);\n+\n@@ -812,0 +819,1 @@\n+  static const TypeVect *VMASK;\n@@ -848,0 +856,6 @@\n+class TypeVectMask : public TypeVect {\n+public:\n+  friend class TypeVect;\n+  TypeVectMask(const Type* elem, uint length) : TypeVect(VectorM, elem, length) {}\n+};\n+\n@@ -1685,0 +1699,9 @@\n+inline const TypeVectMask *Type::is_vectmask() const {\n+  assert( _base == VectorM, \"Not a Vector Mask\" );\n+  return (TypeVectMask*)this;\n+}\n+\n+inline const TypeVectMask *Type::isa_vectmask() const {\n+  return (_base == VectorM) ? (TypeVectMask*)this : NULL;\n+}\n+\n@@ -1686,1 +1709,1 @@\n-  assert( _base >= VectorA && _base <= VectorZ, \"Not a Vector\" );\n+  assert( _base >= VectorM && _base <= VectorZ, \"Not a Vector\" );\n@@ -1691,1 +1714,1 @@\n-  return (_base >= VectorA && _base <= VectorZ) ? (TypeVect*)this : NULL;\n+  return (_base >= VectorM && _base <= VectorZ) ? (TypeVect*)this : NULL;\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":25,"deletions":2,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -787,1 +787,1 @@\n-    assert(mask->bottom_type()->is_long(), \"sanity\");\n+    assert(mask->bottom_type()->is_vectmask(), \"sanity\");\n@@ -805,1 +805,1 @@\n-    assert(mask->bottom_type()->is_long(), \"sanity\");\n+    assert(mask->bottom_type()->is_vectmask(), \"sanity\");\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}