{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,5 +28,1 @@\n-import java.math.BigInteger;\n-import java.util.*;\n-\n-import java.security.SecureRandom;\n-import java.security.interfaces.*;\n+import sun.security.jca.JCAUtil;\n@@ -35,2 +31,10 @@\n-\n-import sun.security.jca.JCAUtil;\n+import java.math.BigInteger;\n+import java.security.SecureRandom;\n+import java.security.interfaces.RSAKey;\n+import java.security.interfaces.RSAPrivateCrtKey;\n+import java.security.interfaces.RSAPrivateKey;\n+import java.security.interfaces.RSAPublicKey;\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.WeakHashMap;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n@@ -41,1 +45,1 @@\n- * also support blinding to twart timing attacks.\n+ * also support blinding to thwart timing attacks.\n@@ -56,4 +60,6 @@\n-    \/\/ cache for blinding parameters. Map<BigInteger, BlindingParameters>\n-    \/\/ use a weak hashmap so that cached values are automatically cleared\n-    \/\/ when the modulus is GC'ed\n-    private static final Map<BigInteger, BlindingParameters>\n+    \/\/ cache for blinding parameters. Map<BigInteger,\n+    \/\/ ConcurrentLinkedQueue<BlindingParameters>> use a weak hashmap so that,\n+    \/\/ cached values are automatically cleared when the modulus is GC'ed.\n+    \/\/ Multiple BlindingParameters can be queued during times of heavy load,\n+    \/\/ like performance testing.\n+    private static final Map<BigInteger, ConcurrentLinkedQueue<BlindingParameters>>\n@@ -405,17 +411,9 @@\n-                BlindingRandomPair brp = null;\n-                synchronized (this) {\n-                    if (!u.equals(BigInteger.ZERO) &&\n-                        !v.equals(BigInteger.ZERO)) {\n-\n-                        brp = new BlindingRandomPair(u, v);\n-                        if (u.compareTo(BigInteger.ONE) <= 0 ||\n-                            v.compareTo(BigInteger.ONE) <= 0) {\n-\n-                            \/\/ need to reset the random pair next time\n-                            u = BigInteger.ZERO;\n-                            v = BigInteger.ZERO;\n-                        } else {\n-                            u = u.modPow(BIG_TWO, n);\n-                            v = v.modPow(BIG_TWO, n);\n-                        }\n-                    } \/\/ Otherwise, need to reset the random pair.\n+                BlindingRandomPair brp = new BlindingRandomPair(u, v);\n+                if (u.compareTo(BigInteger.ONE) <= 0 ||\n+                    v.compareTo(BigInteger.ONE) <= 0) {\n+                    \/\/ Reset so the parameters will be not queued later\n+                    u = BigInteger.ZERO;\n+                    v = BigInteger.ZERO;\n+                } else {\n+                    u = u.modPow(BIG_TWO, n);\n+                    v = v.modPow(BIG_TWO, n);\n@@ -423,0 +421,1 @@\n+\n@@ -428,0 +427,5 @@\n+\n+        \/\/ Check if reusable, return true if both u & v are not zero.\n+        boolean isReusable() {\n+            return !u.equals(BigInteger.ZERO) && !v.equals(BigInteger.ZERO);\n+        }\n@@ -433,3 +437,15 @@\n-        BlindingParameters bps = null;\n-        synchronized (blindingCache) {\n-            bps = blindingCache.get(n);\n+        ConcurrentLinkedQueue<BlindingParameters> queue = blindingCache.get(n);\n+\n+        if (queue == null) {\n+            \/\/ Create another queue if none is available, if there is another\n+            \/\/ thread creating a queue, putIfAbsent() get the established queue\n+            \/\/ and the created one will be discarded. If two threads happen to\n+            \/\/ get a null value for queue, the one will be set in the Map,\n+            \/\/ and the other will only be used for the life of this method.\n+            \/\/ This could only happen during queue initialization with\n+            \/\/ minimal cost of some CPU cycles.\n+            ConcurrentLinkedQueue<BlindingParameters> newQueue =\n+                new ConcurrentLinkedQueue<>();\n+            if ((queue = blindingCache.putIfAbsent(n, newQueue)) == null) {\n+                queue = newQueue;\n+            }\n@@ -438,0 +454,1 @@\n+        BlindingParameters bps = queue.poll();\n@@ -440,3 +457,0 @@\n-            synchronized (blindingCache) {\n-                blindingCache.putIfAbsent(n, bps);\n-            }\n@@ -445,7 +459,5 @@\n-        BlindingRandomPair brp = bps.getBlindingRandomPair(e, d, n);\n-        if (brp == null) {\n-            \/\/ need to reset the blinding parameters\n-            bps = new BlindingParameters(e, d, n);\n-            synchronized (blindingCache) {\n-                blindingCache.replace(n, bps);\n-            }\n+        BlindingRandomPair brp = null;\n+\n+        \/\/ Loops to get a valid pair, going through the queue or create a new\n+        \/\/ parameters if needed.\n+        while (brp == null) {\n@@ -453,0 +465,8 @@\n+            if (brp == null) {\n+                \/\/ need to reset the blinding parameters, first check for\n+                \/\/ another in the queue.\n+                bps = queue.poll();\n+                if (bps == null) {\n+                    bps = new BlindingParameters(e, d, n);\n+                }\n+            }\n@@ -455,0 +475,3 @@\n+        if (bps.isReusable()) {\n+            queue.add(bps);\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/rsa\/RSACore.java","additions":66,"deletions":43,"binary":false,"changes":109,"status":"modified"}]}