{"files":[{"patch":"@@ -41,0 +41,1 @@\n+import java.util.concurrent.locks.ReentrantLock;\n@@ -67,0 +68,1 @@\n+    private static final ReentrantLock lock = new ReentrantLock();\n@@ -437,1 +439,8 @@\n-        ConcurrentLinkedQueue<BlindingParameters> queue = blindingCache.get(n);\n+        ConcurrentLinkedQueue<BlindingParameters> queue;\n+\n+        lock.lock();\n+        try {\n+            queue = blindingCache.get(n);\n+        } finally {\n+            lock.unlock();\n+        }\n@@ -440,11 +449,11 @@\n-            \/\/ Create another queue if none is available, if there is another\n-            \/\/ thread creating a queue, putIfAbsent() get the established queue\n-            \/\/ and the created one will be discarded. If two threads happen to\n-            \/\/ get a null value for queue, the one will be set in the Map,\n-            \/\/ and the other will only be used for the life of this method.\n-            \/\/ This could only happen during queue initialization with\n-            \/\/ minimal cost of some CPU cycles.\n-            ConcurrentLinkedQueue<BlindingParameters> newQueue =\n-                new ConcurrentLinkedQueue<>();\n-            if ((queue = blindingCache.putIfAbsent(n, newQueue)) == null) {\n-                queue = newQueue;\n+            \/\/ If the value is null on the second get(n), create a queue,\n+            \/\/ place it in the map, and continue on using it\n+            lock.lock();\n+            try {\n+                queue = blindingCache.get(n);\n+                if (queue == null) {\n+                    queue = new ConcurrentLinkedQueue<>();\n+                    blindingCache.put(n, queue);\n+                }\n+            } finally {\n+                lock.unlock();\n","filename":"src\/java.base\/share\/classes\/sun\/security\/rsa\/RSACore.java","additions":21,"deletions":12,"binary":false,"changes":33,"status":"modified"}]}