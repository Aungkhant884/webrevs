{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,5 +28,1 @@\n-import java.math.BigInteger;\n-import java.util.*;\n-\n-import java.security.SecureRandom;\n-import java.security.interfaces.*;\n+import sun.security.jca.JCAUtil;\n@@ -35,2 +31,11 @@\n-\n-import sun.security.jca.JCAUtil;\n+import java.math.BigInteger;\n+import java.security.SecureRandom;\n+import java.security.interfaces.RSAKey;\n+import java.security.interfaces.RSAPrivateCrtKey;\n+import java.security.interfaces.RSAPrivateKey;\n+import java.security.interfaces.RSAPublicKey;\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.WeakHashMap;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.locks.ReentrantLock;\n@@ -41,1 +46,1 @@\n- * also support blinding to twart timing attacks.\n+ * also support blinding to thwart timing attacks.\n@@ -56,4 +61,6 @@\n-    \/\/ cache for blinding parameters. Map<BigInteger, BlindingParameters>\n-    \/\/ use a weak hashmap so that cached values are automatically cleared\n-    \/\/ when the modulus is GC'ed\n-    private static final Map<BigInteger, BlindingParameters>\n+    \/\/ cache for blinding parameters. Map<BigInteger,\n+    \/\/ ConcurrentLinkedQueue<BlindingParameters>> use a weak hashmap so that,\n+    \/\/ cached values are automatically cleared when the modulus is GC'ed.\n+    \/\/ Multiple BlindingParameters can be queued during times of heavy load,\n+    \/\/ like performance testing.\n+    private static final Map<BigInteger, ConcurrentLinkedQueue<BlindingParameters>>\n@@ -61,0 +68,1 @@\n+    private static final ReentrantLock lock = new ReentrantLock();\n@@ -405,17 +413,9 @@\n-                BlindingRandomPair brp = null;\n-                synchronized (this) {\n-                    if (!u.equals(BigInteger.ZERO) &&\n-                        !v.equals(BigInteger.ZERO)) {\n-\n-                        brp = new BlindingRandomPair(u, v);\n-                        if (u.compareTo(BigInteger.ONE) <= 0 ||\n-                            v.compareTo(BigInteger.ONE) <= 0) {\n-\n-                            \/\/ need to reset the random pair next time\n-                            u = BigInteger.ZERO;\n-                            v = BigInteger.ZERO;\n-                        } else {\n-                            u = u.modPow(BIG_TWO, n);\n-                            v = v.modPow(BIG_TWO, n);\n-                        }\n-                    } \/\/ Otherwise, need to reset the random pair.\n+                BlindingRandomPair brp = new BlindingRandomPair(u, v);\n+                if (u.compareTo(BigInteger.ONE) <= 0 ||\n+                    v.compareTo(BigInteger.ONE) <= 0) {\n+                    \/\/ Reset so the parameters will be not queued later\n+                    u = BigInteger.ZERO;\n+                    v = BigInteger.ZERO;\n+                } else {\n+                    u = u.modPow(BIG_TWO, n);\n+                    v = v.modPow(BIG_TWO, n);\n@@ -423,0 +423,1 @@\n+\n@@ -428,0 +429,5 @@\n+\n+        \/\/ Check if reusable, return true if both u & v are not zero.\n+        boolean isReusable() {\n+            return !u.equals(BigInteger.ZERO) && !v.equals(BigInteger.ZERO);\n+        }\n@@ -433,3 +439,9 @@\n-        BlindingParameters bps = null;\n-        synchronized (blindingCache) {\n-            bps = blindingCache.get(n);\n+        ConcurrentLinkedQueue<BlindingParameters> queue;\n+\n+        \/\/ Get queue from map, if there is none then create one\n+        lock.lock();\n+        try {\n+            queue = blindingCache.computeIfAbsent(n,\n+                ignored -> new ConcurrentLinkedQueue<>());\n+        } finally {\n+            lock.unlock();\n@@ -438,0 +450,1 @@\n+        BlindingParameters bps = queue.poll();\n@@ -440,3 +453,0 @@\n-            synchronized (blindingCache) {\n-                blindingCache.putIfAbsent(n, bps);\n-            }\n@@ -445,7 +455,5 @@\n-        BlindingRandomPair brp = bps.getBlindingRandomPair(e, d, n);\n-        if (brp == null) {\n-            \/\/ need to reset the blinding parameters\n-            bps = new BlindingParameters(e, d, n);\n-            synchronized (blindingCache) {\n-                blindingCache.replace(n, bps);\n-            }\n+        BlindingRandomPair brp = null;\n+\n+        \/\/ Loops to get a valid pair, going through the queue or create a new\n+        \/\/ parameters if needed.\n+        while (brp == null) {\n@@ -453,0 +461,8 @@\n+            if (brp == null) {\n+                \/\/ need to reset the blinding parameters, first check for\n+                \/\/ another in the queue.\n+                bps = queue.poll();\n+                if (bps == null) {\n+                    bps = new BlindingParameters(e, d, n);\n+                }\n+            }\n@@ -455,0 +471,4 @@\n+        \/\/ If this parameters are still usable, put them back into the queue.\n+        if (bps.isReusable()) {\n+            queue.add(bps);\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/rsa\/RSACore.java","additions":63,"deletions":43,"binary":false,"changes":106,"status":"modified"}]}