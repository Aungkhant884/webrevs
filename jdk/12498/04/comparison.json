{"files":[{"patch":"@@ -1150,1 +1150,3 @@\n-        if (s.getClass() == UnmodifiableSet.class) {\n+        if (s.getClass() == UnmodifiableSet.class\n+                || s.getClass() == UnmodifiableRegularEnumSet.class\n+                || s.getClass() == UnmodifiableJumboEnumSet.class) {\n@@ -1153,0 +1155,6 @@\n+        if (s instanceof RegularEnumSetCompatible<?> res) {\n+            return (Set<T>)new UnmodifiableRegularEnumSet<>(res);\n+        }\n+        if (s instanceof JumboEnumSetCompatible<?> jes) {\n+            return (Set<T>)new UnmodifiableJumboEnumSet<>(jes);\n+        }\n@@ -1167,0 +1175,73 @@\n+\n+        @java.io.Serial\n+        private Object readResolve() {\n+            if (c instanceof RegularEnumSetCompatible<?> es) {\n+                return new UnmodifiableRegularEnumSet<>(es);\n+            }\n+            if (c instanceof JumboEnumSetCompatible<?> es) {\n+                return new UnmodifiableJumboEnumSet<>(es);\n+            }\n+            return this;\n+        }\n+    }\n+\n+    \/**\n+     * @serial include\n+     *\/\n+    static final class UnmodifiableRegularEnumSet<E extends Enum<E>> extends UnmodifiableSet<E>\n+            implements RegularEnumSetCompatible<E> {\n+        @java.io.Serial\n+        private static final long serialVersionUID = -1110577510253015312L;\n+\n+        final RegularEnumSetCompatible<E> es;\n+\n+        UnmodifiableRegularEnumSet(RegularEnumSetCompatible<E> es) {\n+            super(es);\n+            this.es = es;\n+        }\n+\n+        @Override\n+        public Class<E> elementType() {\n+            return es.elementType();\n+        }\n+\n+        @Override\n+        public long elements() {\n+            return es.elements();\n+        }\n+\n+        @java.io.Serial\n+        private Object writeReplace() {\n+            return new UnmodifiableSet<>(es);\n+        }\n+    }\n+\n+    \/**\n+     * @serial include\n+     *\/\n+    static final class UnmodifiableJumboEnumSet<E extends Enum<E>> extends UnmodifiableSet<E>\n+            implements JumboEnumSetCompatible<E> {\n+        @java.io.Serial\n+        private static final long serialVersionUID = 1730197349714300593L;\n+\n+        final JumboEnumSetCompatible<E> es;\n+\n+        UnmodifiableJumboEnumSet(JumboEnumSetCompatible<E> es) {\n+            super(es);\n+            this.es = es;\n+        }\n+\n+        @Override\n+        public Class<E> elementType() {\n+            return es.elementType();\n+        }\n+\n+        @Override\n+        public long[] elements() {\n+            return es.elements();\n+        }\n+\n+        @java.io.Serial\n+        private Object writeReplace() {\n+            return new UnmodifiableSet<>(es);\n+        }\n@@ -2199,0 +2280,1 @@\n+    @SuppressWarnings(\"unchecked\")\n@@ -2200,0 +2282,6 @@\n+        if (s instanceof RegularEnumSetCompatible<?> es) {\n+            return (Set<T>)new SynchronizedRegularEnumSet<>(es);\n+        }\n+        if (s instanceof JumboEnumSetCompatible<?> es) {\n+            return (Set<T>)new SynchronizedJumboEnumSet<>(es);\n+        }\n@@ -2203,0 +2291,1 @@\n+    @SuppressWarnings(\"unchecked\")\n@@ -2204,0 +2293,6 @@\n+        if (s instanceof RegularEnumSetCompatible<?> es) {\n+            return (Set<T>)new SynchronizedRegularEnumSet<>(es, mutex);\n+        }\n+        if (s instanceof JumboEnumSetCompatible<?> es) {\n+            return (Set<T>)new SynchronizedJumboEnumSet<>(es, mutex);\n+        }\n@@ -2231,0 +2326,91 @@\n+\n+        @java.io.Serial\n+        private Object readResolve() {\n+            if (c instanceof RegularEnumSetCompatible<?> es) {\n+                return new SynchronizedRegularEnumSet<>(es);\n+            }\n+            if (c instanceof JumboEnumSetCompatible<?> es) {\n+                return new SynchronizedJumboEnumSet<>(es);\n+            }\n+            return this;\n+        }\n+    }\n+\n+    \/**\n+     * @serial include\n+     *\/\n+    static final class SynchronizedRegularEnumSet<E extends Enum<E>>\n+          extends SynchronizedSet<E>\n+          implements RegularEnumSetCompatible<E> {\n+        @java.io.Serial\n+        private static final long serialVersionUID = -5185717517664879222L;\n+\n+        final RegularEnumSetCompatible<E> es;\n+\n+        SynchronizedRegularEnumSet(RegularEnumSetCompatible<E> es) {\n+            super(es);\n+            this.es = es;\n+        }\n+\n+        SynchronizedRegularEnumSet(RegularEnumSetCompatible<E> es, Object mutex) {\n+            super(es, mutex);\n+            this.es = es;\n+        }\n+\n+        @Override\n+        public Class<E> elementType() {\n+            \/\/ No need to be synchronized since elementType is never modified.\n+            return es.elementType();\n+        }\n+\n+        @Override\n+        public long elements() {\n+            synchronized (mutex) {\n+                return es.elements();\n+            }\n+        }\n+\n+        @java.io.Serial\n+        private Object writeReplace() {\n+            return new SynchronizedSet<E>(es);\n+        }\n+    }\n+\n+    \/**\n+     * @serial include\n+     *\/\n+    static final class SynchronizedJumboEnumSet<E extends Enum<E>>\n+          extends SynchronizedSet<E>\n+          implements JumboEnumSetCompatible<E> {\n+        @java.io.Serial\n+        private static final long serialVersionUID = -2197803204861808334L;\n+\n+        final JumboEnumSetCompatible<E> es;\n+\n+        SynchronizedJumboEnumSet(JumboEnumSetCompatible<E> es) {\n+            super(es);\n+            this.es = es;\n+        }\n+\n+        SynchronizedJumboEnumSet(JumboEnumSetCompatible<E> es, Object mutex) {\n+            super(es, mutex);\n+            this.es = es;\n+        }\n+\n+        @Override\n+        public Class<E> elementType() {\n+            \/\/ No need to be synchronized since elementType is never modified.\n+            return es.elementType();\n+        }\n+\n+        @Override\n+        public long[] elements() {\n+            synchronized (mutex) {\n+                return es.elements().clone();   \/\/ defensive copy\n+            }\n+        }\n+\n+        @java.io.Serial\n+        private Object writeReplace() {\n+            return new SynchronizedSet<>(es);\n+        }\n@@ -3341,0 +3527,8 @@\n+        \/\/ All implementing classes of RegularEnumSetCompatible and JumboEnumSetCompatible\n+        \/\/ always reject wrong types.\n+        if (s instanceof RegularEnumSetCompatible<?> es && type == es.elementType()) {\n+            return s;\n+        }\n+        if (s instanceof JumboEnumSetCompatible<?> es && type == es.elementType()) {\n+            return s;\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/util\/Collections.java","additions":195,"deletions":1,"binary":false,"changes":196,"status":"modified"},{"patch":"@@ -173,0 +173,1 @@\n+        \/\/ Only treat empty EnumSets specially for compatibility.\n@@ -181,2 +182,1 @@\n-            while (i.hasNext())\n-                result.add(i.next());\n+            result.addAll(c);   \/\/ optimized for compatible sets\n","filename":"src\/java.base\/share\/classes\/java\/util\/EnumSet.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import jdk.internal.access.JavaLangAccess;\n@@ -893,0 +894,39 @@\n+    \/**\n+     * Creates a new Set from an untrusted array and checking for and\n+     * rejecting null and duplicate elements.\n+     *\n+     * @param <E> the Set's element type\n+     * @param input the non-empty input array\n+     * @return the new set\n+     *\/\n+    @SafeVarargs\n+    @SuppressWarnings({\"unchecked\", \"varargs\"})\n+    static <E> Set<E> setFromArray(E... input) {\n+        \/\/ assert input.length > 2;\n+        if (!(input[0] instanceof Enum<?> enum0)) {\n+            return new SetN<>(input);\n+        }\n+        @SuppressWarnings(\"rawtypes\")\n+        EnumSet es = EnumSet.<Enum>of(enum0);\n+        Class<?> esElementType = es.elementType;\n+        for (int i = 1; i < input.length; i++) {\n+            Object element = input[i];\n+            if (element == null) {\n+                throw new NullPointerException();\n+            }\n+            if (!esElementType.isInstance(element)) {\n+                return new SetN<>(input);\n+            }\n+            if (!es.add(element)) {\n+                throw new IllegalArgumentException(\"duplicate element: \" + element);\n+            }\n+        }\n+        if (es instanceof RegularEnumSet<?> res) {\n+            return (Set<E>)new ImmutableRegularEnumSet<>(res.elements(), res.elementType());\n+        }\n+        if (es instanceof JumboEnumSet<?> jes) {\n+            return (Set<E>)new ImmutableJumboEnumSet<>(jes.elements(), jes.elementType(), jes.size());\n+        }\n+        \/\/ Should not be reached here. This is a fallback.\n+        return new SetN<>(input);\n+    }\n@@ -1065,0 +1105,260 @@\n+    @jdk.internal.ValueBased\n+    abstract static sealed class AbstractImmutableEnumSet<E extends Enum<E>> extends AbstractImmutableSet<E>\n+            implements Serializable permits ImmutableRegularEnumSet, ImmutableJumboEnumSet {\n+        static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n+\n+        @Stable\n+        final Class<E> elementType;\n+\n+        AbstractImmutableEnumSet(Class<E> elementType) {\n+            this.elementType = elementType;\n+        }\n+\n+        \/\/ Overrides elementType() in RegularEnumSetCompatible and JumboEnumSetCompatible\n+        public final Class<E> elementType() {\n+            return elementType;\n+        }\n+\n+        abstract boolean containsOrdinal(int ordinal);\n+\n+        @Override\n+        public final boolean contains(Object e) {\n+            if (e == null)\n+                throw new NullPointerException();\n+            Class<?> eClass = e.getClass();\n+            if (eClass != elementType && eClass.getSuperclass() != elementType)\n+                return false;\n+\n+            return containsOrdinal(((Enum<?>)e).ordinal());\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            int h = 0;\n+            for (Object o : this) {\n+                h += o.hashCode();\n+            }\n+            return h;\n+        }\n+\n+        @Override\n+        public Object[] toArray() {\n+            Object[] result = new Object[size()];\n+            int i = 0;\n+            for (Object o : this) {\n+                result[i++] = o;\n+            }\n+            return result;\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"unchecked\")\n+        public <T> T[] toArray(T[] a) {\n+            int size = size();\n+            T[] result = a.length >= size ? a :\n+                    (T[])Array.newInstance(a.getClass().getComponentType(), size);\n+            int i = 0;\n+            for (Object o : this) {\n+                result[i++] = (T)o;\n+            }\n+            if (result.length > size) {\n+                result[i] = null;\n+            }\n+            return result;\n+        }\n+    }\n+\n+    @jdk.internal.ValueBased\n+    static final class ImmutableRegularEnumSet<E extends Enum<E>> extends AbstractImmutableEnumSet<E>\n+            implements RegularEnumSetCompatible<E>, Serializable {\n+        @Stable\n+        final long elements;\n+\n+        ImmutableRegularEnumSet(long elements, Class<E> elementType) {\n+            super(elementType);\n+            this.elements = elements;\n+        }\n+\n+        @Override\n+        public long elements() {\n+            return elements;\n+        }\n+\n+        @Override\n+        public Iterator<E> iterator() {\n+            return new ImmutableRESIterator();\n+        }\n+\n+        private final class ImmutableRESIterator implements Iterator<E> {\n+            long unseen = elements;\n+            long lastReturned = 0;\n+            final Enum<?>[] universe = JLA.getEnumConstantsShared(elementType);\n+\n+            @Override\n+            public boolean hasNext() {\n+                return unseen != 0;\n+            }\n+\n+            @Override\n+            @SuppressWarnings(\"unchecked\")\n+            public E next() {\n+                if (unseen == 0)\n+                    throw new NoSuchElementException();\n+                lastReturned = unseen & -unseen;\n+                unseen -= lastReturned;\n+                return (E) universe[Long.numberOfTrailingZeros(lastReturned)];\n+            }\n+        }\n+\n+        @Override\n+        public int size() {\n+            return Long.bitCount(elements);\n+        }\n+\n+        @Override\n+        public boolean isEmpty() {\n+            return elements == 0;\n+        }\n+\n+        @Override\n+        boolean containsOrdinal(int ordinal) {\n+            return (elements & (1L << ordinal)) != 0;\n+        }\n+\n+        @Override\n+        public boolean containsAll(Collection<?> c) {\n+            if ((c instanceof RegularEnumSetCompatible<?> es)) {\n+                if (es.elementType() != elementType)\n+                    return es.isEmpty();\n+\n+                return (es.elements() & ~elements) == 0;\n+            } else {\n+                return super.containsAll(c);\n+            }\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (!(o instanceof RegularEnumSetCompatible<?> es))\n+                return super.equals(o);\n+\n+            if (es.elementType() != elementType)\n+                return elements == 0 && es.elements() == 0;\n+            return es.elements() == elements;\n+        }\n+\n+        @java.io.Serial\n+        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+            throw new InvalidObjectException(\"not serial proxy\");\n+        }\n+\n+        @java.io.Serial\n+        private Object writeReplace() {\n+            return new CollSer(CollSer.IMM_SET, toArray());\n+        }\n+    }\n+\n+    @jdk.internal.ValueBased\n+    static final class ImmutableJumboEnumSet<E extends Enum<E>> extends AbstractImmutableEnumSet<E>\n+            implements JumboEnumSetCompatible<E>, Serializable {\n+        @Stable\n+        final long[] elements;\n+\n+        @Stable\n+        final int size;\n+\n+        ImmutableJumboEnumSet(long[] elements, Class<E> elementType, int size) {\n+            super(elementType);\n+            this.elements = elements;\n+            this.size = size;\n+        }\n+\n+        @Override\n+        public long[] elements() {\n+            return elements;\n+        }\n+\n+        @Override\n+        public Iterator<E> iterator() {\n+            return new ImmutableJESIterator();\n+        }\n+\n+        private final class ImmutableJESIterator implements Iterator<E> {\n+            long unseen = elements[0];\n+            int unseenIndex = 0;\n+            long lastReturned = 0;\n+            int lastReturnedIndex = 0;\n+            final Enum<?>[] universe = JLA.getEnumConstantsShared(elementType);\n+\n+            @Override\n+            public boolean hasNext() {\n+                while (unseen == 0 && unseenIndex < elements.length - 1)\n+                    unseen = elements[++unseenIndex];\n+                return unseen != 0;\n+            }\n+\n+            @Override\n+            @SuppressWarnings(\"unchecked\")\n+            public E next() {\n+                if (!hasNext())\n+                    throw new NoSuchElementException();\n+                lastReturned = unseen & -unseen;\n+                lastReturnedIndex = unseenIndex;\n+                unseen -= lastReturned;\n+                return (E) universe[(lastReturnedIndex << 6)\n+                                    + Long.numberOfTrailingZeros(lastReturned)];\n+            }\n+        }\n+\n+        @Override\n+        public int size() {\n+            return size;\n+        }\n+\n+        @Override\n+        public boolean isEmpty() {\n+            return size == 0L;\n+        }\n+\n+        @Override\n+        boolean containsOrdinal(int ordinal) {\n+            return (elements[ordinal >>> 6] & (1L << ordinal)) != 0;\n+        }\n+\n+        @Override\n+        public boolean containsAll(Collection<?> c) {\n+            if (!(c instanceof JumboEnumSetCompatible<?> es))\n+                return super.containsAll(c);\n+\n+            if (es.elementType() != elementType)\n+                return es.isEmpty();\n+\n+            long[] esElements = es.elements();\n+            for (int i = 0; i < elements.length; i++)\n+                if ((esElements[i] & ~elements[i]) != 0)\n+                    return false;\n+            return true;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (!(o instanceof JumboEnumSetCompatible<?> es))\n+                return super.equals(o);\n+\n+            if (es.elementType() != elementType)\n+                return size == 0 && es.size() == 0;\n+\n+            return Arrays.equals(es.elements(), elements);\n+        }\n+\n+        @java.io.Serial\n+        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+            throw new InvalidObjectException(\"not serial proxy\");\n+        }\n+\n+        @java.io.Serial\n+        private Object writeReplace() {\n+            return new CollSer(CollSer.IMM_SET, toArray());\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/ImmutableCollections.java","additions":300,"deletions":0,"binary":false,"changes":300,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-final class JumboEnumSet<E extends Enum<E>> extends EnumSet<E> {\n+final class JumboEnumSet<E extends Enum<E>> extends EnumSet<E> implements JumboEnumSetCompatible<E> {\n@@ -47,0 +47,10 @@\n+    @Override\n+    public long[] elements() {\n+        return elements;\n+    }\n+\n+    @Override\n+    public Class<E> elementType() {\n+        return elementType;\n+    }\n+\n@@ -251,1 +261,1 @@\n-        if (!(c instanceof JumboEnumSet<?> es))\n+        if (!(c instanceof JumboEnumSetCompatible<?> es))\n@@ -254,1 +264,1 @@\n-        if (es.elementType != elementType)\n+        if (es.elementType() != elementType)\n@@ -257,0 +267,1 @@\n+        long[] esElements = es.elements();\n@@ -258,1 +269,1 @@\n-            if ((es.elements[i] & ~elements[i]) != 0)\n+            if ((esElements[i] & ~elements[i]) != 0)\n@@ -272,1 +283,1 @@\n-        if (!(c instanceof JumboEnumSet<?> es))\n+        if (!(c instanceof JumboEnumSetCompatible<?> es))\n@@ -275,1 +286,1 @@\n-        if (es.elementType != elementType) {\n+        if (es.elementType() != elementType) {\n@@ -280,1 +291,1 @@\n-                    es.elementType + \" != \" + elementType);\n+                    es.elementType() + \" != \" + elementType);\n@@ -283,0 +294,1 @@\n+        long[] esElements = es.elements();\n@@ -284,1 +296,1 @@\n-            elements[i] |= es.elements[i];\n+            elements[i] |= esElements[i];\n@@ -297,1 +309,1 @@\n-        if (!(c instanceof JumboEnumSet<?> es))\n+        if (!(c instanceof JumboEnumSetCompatible<?> es))\n@@ -300,1 +312,1 @@\n-        if (es.elementType != elementType)\n+        if (es.elementType() != elementType)\n@@ -303,0 +315,1 @@\n+        long[] esElements = es.elements();\n@@ -304,1 +317,1 @@\n-            elements[i] &= ~es.elements[i];\n+            elements[i] &= ~esElements[i];\n@@ -317,1 +330,1 @@\n-        if (!(c instanceof JumboEnumSet<?> es))\n+        if (!(c instanceof JumboEnumSetCompatible<?> es))\n@@ -320,1 +333,1 @@\n-        if (es.elementType != elementType) {\n+        if (es.elementType() != elementType) {\n@@ -326,0 +339,1 @@\n+        long[] esElements = es.elements();\n@@ -327,1 +341,1 @@\n-            elements[i] &= es.elements[i];\n+            elements[i] &= esElements[i];\n@@ -349,1 +363,1 @@\n-        if (!(o instanceof JumboEnumSet<?> es))\n+        if (!(o instanceof JumboEnumSetCompatible<?> es))\n@@ -352,2 +366,2 @@\n-        if (es.elementType != elementType)\n-            return size == 0 && es.size == 0;\n+        if (es.elementType() != elementType)\n+            return size == 0 && es.size() == 0;\n@@ -355,1 +369,1 @@\n-        return Arrays.equals(es.elements, elements);\n+        return Arrays.equals(es.elements(), elements);\n","filename":"src\/java.base\/share\/classes\/java\/util\/JumboEnumSet.java","additions":32,"deletions":18,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.util;\n+\n+import java.io.Serializable;\n+\n+\/\/ Implementing classes are compatible with JumboEnumSet.\n+sealed interface JumboEnumSetCompatible<E extends Enum<E>>\n+        extends Set<E>, Serializable\n+        permits JumboEnumSet,\n+                Collections.UnmodifiableJumboEnumSet,\n+                Collections.SynchronizedJumboEnumSet,\n+                ImmutableCollections.ImmutableJumboEnumSet {\n+    Class<E> elementType();\n+\n+    \/\/ Note that this method may return a mutable array, so\n+    \/\/ defensive copies should be made if immutable or thread-safe\n+    \/\/ set is needed.\n+    long[] elements();\n+}\n","filename":"src\/java.base\/share\/classes\/java\/util\/JumboEnumSetCompatible.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-final class RegularEnumSet<E extends Enum<E>> extends EnumSet<E> {\n+final class RegularEnumSet<E extends Enum<E>> extends EnumSet<E> implements RegularEnumSetCompatible<E> {\n@@ -45,0 +45,10 @@\n+    @Override\n+    public long elements() {\n+        return elements;\n+    }\n+\n+    @Override\n+    public Class<E> elementType() {\n+        return elementType;\n+    }\n+\n@@ -199,1 +209,1 @@\n-        if (!(c instanceof RegularEnumSet<?> es))\n+        if (!(c instanceof RegularEnumSetCompatible<?> es))\n@@ -202,1 +212,1 @@\n-        if (es.elementType != elementType)\n+        if (es.elementType() != elementType)\n@@ -205,1 +215,1 @@\n-        return (es.elements & ~elements) == 0;\n+        return (es.elements() & ~elements) == 0;\n@@ -217,1 +227,1 @@\n-        if (!(c instanceof RegularEnumSet<?> es))\n+        if (!(c instanceof RegularEnumSetCompatible<?> es))\n@@ -220,1 +230,1 @@\n-        if (es.elementType != elementType) {\n+        if (es.elementType() != elementType) {\n@@ -225,1 +235,1 @@\n-                    es.elementType + \" != \" + elementType);\n+                    es.elementType() + \" != \" + elementType);\n@@ -229,1 +239,1 @@\n-        elements |= es.elements;\n+        elements |= es.elements();\n@@ -242,1 +252,1 @@\n-        if (!(c instanceof RegularEnumSet<?> es))\n+        if (!(c instanceof RegularEnumSetCompatible<?> es))\n@@ -245,1 +255,1 @@\n-        if (es.elementType != elementType)\n+        if (es.elementType() != elementType)\n@@ -249,1 +259,1 @@\n-        elements &= ~es.elements;\n+        elements &= ~es.elements();\n@@ -262,1 +272,1 @@\n-        if (!(c instanceof RegularEnumSet<?> es))\n+        if (!(c instanceof RegularEnumSetCompatible<?> es))\n@@ -265,1 +275,1 @@\n-        if (es.elementType != elementType) {\n+        if (es.elementType() != elementType) {\n@@ -272,1 +282,1 @@\n-        elements &= es.elements;\n+        elements &= es.elements();\n@@ -293,1 +303,1 @@\n-        if (!(o instanceof RegularEnumSet<?> es))\n+        if (!(o instanceof RegularEnumSetCompatible<?> es))\n@@ -296,3 +306,3 @@\n-        if (es.elementType != elementType)\n-            return elements == 0 && es.elements == 0;\n-        return es.elements == elements;\n+        if (es.elementType() != elementType)\n+            return elements == 0 && es.elements() == 0;\n+        return es.elements() == elements;\n","filename":"src\/java.base\/share\/classes\/java\/util\/RegularEnumSet.java","additions":29,"deletions":19,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.util;\n+\n+import java.io.Serializable;\n+\n+\/\/ Implementing classes are compatible with RegularEnumSet.\n+sealed interface RegularEnumSetCompatible<E extends Enum<E>>\n+        extends Set<E>, Serializable\n+        permits RegularEnumSet,\n+                Collections.UnmodifiableRegularEnumSet,\n+                Collections.SynchronizedRegularEnumSet,\n+                ImmutableCollections.ImmutableRegularEnumSet {\n+    Class<E> elementType();\n+    long elements();\n+}\n","filename":"src\/java.base\/share\/classes\/java\/util\/RegularEnumSetCompatible.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -505,1 +505,1 @@\n-        return new ImmutableCollections.SetN<>(e1, e2, e3);\n+        return ImmutableCollections.setFromArray(e1, e2, e3);\n@@ -524,1 +524,1 @@\n-        return new ImmutableCollections.SetN<>(e1, e2, e3, e4);\n+        return ImmutableCollections.setFromArray(e1, e2, e3, e4);\n@@ -544,1 +544,1 @@\n-        return new ImmutableCollections.SetN<>(e1, e2, e3, e4, e5);\n+        return ImmutableCollections.setFromArray(e1, e2, e3, e4, e5);\n@@ -565,1 +565,1 @@\n-        return new ImmutableCollections.SetN<>(e1, e2, e3, e4, e5,\n+        return ImmutableCollections.setFromArray(e1, e2, e3, e4, e5,\n@@ -588,1 +588,1 @@\n-        return new ImmutableCollections.SetN<>(e1, e2, e3, e4, e5,\n+        return ImmutableCollections.setFromArray(e1, e2, e3, e4, e5,\n@@ -612,1 +612,1 @@\n-        return new ImmutableCollections.SetN<>(e1, e2, e3, e4, e5,\n+        return ImmutableCollections.setFromArray(e1, e2, e3, e4, e5,\n@@ -637,1 +637,1 @@\n-        return new ImmutableCollections.SetN<>(e1, e2, e3, e4, e5,\n+        return ImmutableCollections.setFromArray(e1, e2, e3, e4, e5,\n@@ -663,1 +663,1 @@\n-        return new ImmutableCollections.SetN<>(e1, e2, e3, e4, e5,\n+        return ImmutableCollections.setFromArray(e1, e2, e3, e4, e5,\n@@ -706,1 +706,1 @@\n-                return new ImmutableCollections.SetN<>(elements);\n+                return ImmutableCollections.setFromArray(elements);\n@@ -731,1 +731,2 @@\n-        } else if (coll.isEmpty()) { \/\/ Implicit nullcheck of coll\n+        }\n+        if (coll.isEmpty()) {\n@@ -733,2 +734,0 @@\n-        } else {\n-            return (Set<E>)Set.of(new HashSet<>(coll).toArray());\n@@ -736,0 +735,7 @@\n+        if (coll instanceof RegularEnumSetCompatible<?> res && res.size() > 2) {\n+            return (Set<E>)new ImmutableCollections.ImmutableRegularEnumSet<>(res.elements(), res.elementType());\n+        }\n+        if (coll instanceof JumboEnumSetCompatible<?> jes && jes.size() > 2) {\n+            return (Set<E>)new ImmutableCollections.ImmutableJumboEnumSet<>(jes.elements().clone(), jes.elementType(), jes.size());\n+        }\n+        return (Set<E>)Set.of(new HashSet<>(coll).toArray());\n","filename":"src\/java.base\/share\/classes\/java\/util\/Set.java","additions":18,"deletions":12,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.util.EnumSet;\n@@ -51,1 +52,1 @@\n- * @bug 8048330\n+ * @bug 8048330 8302818\n@@ -73,1 +74,2 @@\n-    static Set<String> hashSetOf(String... args) {\n+    @SafeVarargs\n+    static <E> Set<E> hashSetOf(E... args) {\n@@ -345,0 +347,72 @@\n+\n+    \/\/ Test enum elements\n+\n+    enum Enum1 {\n+        E0, E1, E2, E3, E4, E5, E6, E7, E8, E9\n+    }\n+\n+    enum Enum2 {\n+        E0, E1, E2, E3, E4, E5, E6, E7, E8, E9,\n+        E10, E11, E12, E13, E14, E15, E16, E17, E18, E19,\n+        E20, E21, E22, E23, E24, E25, E26, E27, E28, E29,\n+        E30, E31, E32, E33, E34, E35, E36, E37, E38, E39,\n+        E40, E41, E42, E43, E44, E45, E46, E47, E48, E49,\n+        E50, E51, E52, E53, E54, E55, E56, E57, E58, E59,\n+        E60, E61, E62, E63, E64, E65, E66, E67, E68, E69,\n+        E70, E71, E72, E73, E74, E75, E76, E77, E78, E79\n+    }\n+\n+    @Test\n+    public void setOfPureLittleEnums() {\n+        Set<Enum1> set = Set.of(Enum1.E0, Enum1.E1, Enum1.E2, Enum1.E3);\n+        assertEquals(set, EnumSet.of(Enum1.E0, Enum1.E1, Enum1.E2, Enum1.E3));\n+        assertTrue(set.contains(Enum1.E0));\n+        assertFalse(set.contains(Enum1.E4));\n+        assertFalse(set.contains(Enum2.E0));\n+        assertFalse(set.contains(\"I'm not a enum\"));\n+    }\n+\n+    @Test\n+    public void setOfPureBigEnums() {\n+        Set<Enum2> set = Set.of(Enum2.E0, Enum2.E1, Enum2.E2, Enum2.E3, Enum2.E4,\n+                Enum2.E5, Enum2.E6, Enum2.E7, Enum2.E8, Enum2.E9,\n+                Enum2.E10, Enum2.E11, Enum2.E12, Enum2.E13, Enum2.E14,\n+                Enum2.E15, Enum2.E16, Enum2.E17, Enum2.E18, Enum2.E19);\n+        assertEquals(set, EnumSet.of(Enum2.E0, Enum2.E1, Enum2.E2, Enum2.E3, Enum2.E4,\n+                Enum2.E5, Enum2.E6, Enum2.E7, Enum2.E8, Enum2.E9, Enum2.E10,\n+                Enum2.E11, Enum2.E12, Enum2.E13, Enum2.E14, Enum2.E15,\n+                Enum2.E16, Enum2.E17, Enum2.E18, Enum2.E19));\n+        assertTrue(set.contains(Enum2.E0));\n+        assertFalse(set.contains(Enum2.E20));\n+        assertFalse(set.contains(Enum1.E0));\n+        assertFalse(set.contains(\"I'm not a enum\"));\n+    }\n+\n+    @Test\n+    public void setOfDifferentEnums() {\n+        Object[] objs = {Enum1.E0, Enum1.E1, Enum2.E0, Enum2.E1};\n+        Set<Object> set = Set.of(objs);\n+        assertEquals(set, hashSetOf(objs));\n+    }\n+\n+    @Test\n+    public void setOfEnumsAndRegularObjects() {\n+        Object[] objs = {Enum1.E0, Enum2.E1, Integer.valueOf(42), \"I'm not a enum either\"};\n+        Set<Object> set = Set.of(objs);\n+        assertEquals(set, hashSetOf(objs));\n+    }\n+\n+    @Test(expectedExceptions=IllegalArgumentException.class)\n+    public void enumDupsDisallowed1() {\n+        Set<Enum1> set = Set.of(Enum1.E0, Enum1.E1, Enum1.E0);\n+    }\n+\n+    @Test(expectedExceptions=IllegalArgumentException.class)\n+    public void enumDupsDisallowed2() {\n+        Set<Enum2> set = Set.of(Enum2.E0, Enum2.E1, Enum2.E0);\n+    }\n+\n+    @Test(expectedExceptions=NullPointerException.class)\n+    public void enumNullsDisallowed() {\n+        Set<Enum2> set = Set.of(Enum2.E0, Enum2.E1, null, Enum2.E2);\n+    }\n","filename":"test\/jdk\/java\/util\/Collection\/SetFactories.java","additions":76,"deletions":2,"binary":false,"changes":78,"status":"modified"}]}