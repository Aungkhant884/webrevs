{"files":[{"patch":"@@ -116,4 +116,6 @@\n-  MutexLocker ml(MetaspaceCritical_lock, Mutex::_no_safepoint_check_flag);\n-  if (_requests_head == request) {\n-    \/\/ The first request can't opportunistically ride on a previous GC\n-    return false;\n+  {\n+    MutexLocker ml(MetaspaceCritical_lock, Mutex::_no_safepoint_check_flag);\n+    if (_requests_head == request) {\n+      \/\/ The first request can't opportunistically ride on a previous GC\n+      return false;\n+    }\n@@ -127,1 +129,1 @@\n-  while (!request->has_result()) {\n+  for (;;) {\n@@ -129,0 +131,4 @@\n+    MutexLocker ml(MetaspaceCritical_lock, Mutex::_no_safepoint_check_flag);\n+    if (request->has_result()) {\n+      break;\n+    }\n","filename":"src\/hotspot\/share\/memory\/metaspaceCriticalAllocation.cpp","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -48,0 +48,24 @@\n+\/*\n+ * @test\n+ * @key stress\n+ *\n+ * @summary converted from VM Testbase gc\/gctests\/LoadUnloadGC.\n+ * VM Testbase keywords: [gc, stress, stressopt, nonconcurrent, monitoring]\n+ * VM Testbase readme:\n+ * In this test a 1000 classes are loaded and unloaded in a loop.\n+ * Class0 gets loaded which results in Class1 getting loaded and so on all\n+ * the way uptill class1000.  The classes should be unloaded whenever a\n+ * garbage collection takes place because their classloader is made unreachable\n+ * at the end of the each loop iteration. The loop is repeated 1000 times.\n+ *\n+ * @requires vm.opt.final.ClassUnloading\n+ * @library \/vmTestbase\n+ *          \/test\/lib\n+ * @build nsk.share.gc.ClassChain\n+ * @run main\/othervm\n+ *      -XX:MaxMetaspaceSize=64M\n+ *      -XX:MetaspaceSize=64M\n+ *      -XX:CompressedClassSpaceSize=32M\n+ *      gc.gctests.LoadUnloadGC.LoadUnloadGC\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/LoadUnloadGC\/LoadUnloadGC.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"}]}