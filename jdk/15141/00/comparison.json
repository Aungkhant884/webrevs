{"files":[{"patch":"@@ -35,0 +35,1 @@\n+import java.nio.file.FileSystemException;\n@@ -668,0 +669,3 @@\n+                if (x.errno() == EEXIST)\n+                    throw new FileSystemException(target.toString(), null,\n+                        \"File exists\");\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixFileSystem.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,113 @@\n+\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 8114830\n+ * @summary Verify FileAlreadyExistsException is not thrown for REPLACE_EXISTING\n+ *\/\n+import java.io.InputStream;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.FileAlreadyExistsException;\n+import java.nio.file.Files;\n+import java.nio.file.FileSystemException;\n+import java.nio.file.Path;\n+import java.nio.file.StandardCopyOption;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+public class CopyInterference {\n+\n+    private static final int N_THREADS = 2;\n+\n+    private static final Path SOURCE;\n+    private static final Path TARGET;\n+\n+    private static final AtomicBoolean running = new AtomicBoolean(true);\n+\n+    static {\n+        try {\n+            Path dir = Path.of(System.getProperty(\"test.dir\", \".\"));\n+            SOURCE = Files.createTempFile(dir, \"foo\", \"baz\");\n+            Files.delete(SOURCE);\n+            TARGET = Files.createTempFile(dir, \"fu\", \"bar\");\n+            Files.delete(TARGET);\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+\n+    private static final Runnable copyTask = new Runnable() {\n+        @Override\n+        public void run() {\n+            try {\n+                while (running.get()) {\n+                    Files.copy(SOURCE, TARGET,\n+                               StandardCopyOption.REPLACE_EXISTING);\n+                }\n+            } catch (FileAlreadyExistsException e) {\n+                running.set(false);\n+                throw new RuntimeException(\"Unexpected exception\", e);\n+            } catch (FileSystemException e) {\n+                System.out.printf(\"Expected FileSystemException: \\\"%s\\\"%n\",\n+                                  e.getMessage());\n+            } catch (IOException e) {\n+                running.set(false);\n+                throw new RuntimeException(\"Unexpected exception\", e);\n+            }\n+            running.set(false);\n+        }\n+    };\n+\n+    public static void main(String[] args) throws Exception {\n+        Class c = CopyInterference.class;\n+        String name = \"CopyInterference.class\";\n+\n+        try (InputStream in = c.getResourceAsStream(name)) {\n+            Files.copy(in, SOURCE, StandardCopyOption.REPLACE_EXISTING);\n+            Files.deleteIfExists(TARGET);\n+\n+            ExecutorService es = Executors.newFixedThreadPool(N_THREADS);\n+            Future<?>[] results = new Future<?>[N_THREADS];\n+            for (int i = 0; i < N_THREADS; i++)\n+                results[i] = es.submit(copyTask);\n+\n+            es.shutdown();\n+            es.awaitTermination(5, TimeUnit.SECONDS);\n+\n+            \/\/ Check results\n+            for (Future<?> res : results) {\n+                try {\n+                    res.get();\n+                } catch (ExecutionException e) {\n+                    throw new RuntimeException(res.exceptionNow());\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/file\/Files\/CopyInterference.java","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"}]}