{"files":[{"patch":"@@ -35,0 +35,1 @@\n+import java.nio.file.FileSystemException;\n@@ -522,0 +523,2 @@\n+            if (x.errno() == EEXIST && flags.replaceExisting)\n+                throw new FileSystemException(target.toString());\n@@ -668,0 +671,2 @@\n+                if (x.errno() == EEXIST && flags.replaceExisting)\n+                    throw new FileSystemException(target.toString());\n@@ -786,0 +791,2 @@\n+            if (x.errno() == EEXIST && flags.replaceExisting)\n+                throw new FileSystemException(target.toString());\n@@ -800,0 +807,2 @@\n+            if (x.errno() == EEXIST && flags.replaceExisting)\n+                throw new FileSystemException(target.toString());\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixFileSystem.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,153 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 8114830\n+ * @summary Verify FileAlreadyExistsException is not thrown for REPLACE_EXISTING\n+ * @run junit CopyInterference\n+ *\/\n+import java.io.InputStream;\n+import java.io.IOException;\n+import java.nio.file.CopyOption;\n+import java.nio.file.FileAlreadyExistsException;\n+import java.nio.file.Files;\n+import java.nio.file.FileSystemException;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Stream;\n+\n+import static java.nio.file.StandardCopyOption.*;\n+import static java.nio.file.LinkOption.*;\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+public class CopyInterference {\n+\n+    private static final int N_THREADS = 2;\n+\n+    private static final AtomicBoolean running = new AtomicBoolean(true);\n+\n+    private static class CopyTask implements Runnable {\n+        final Path source;\n+        final Path target;\n+        final CopyOption[] options;\n+\n+        CopyTask(Path source, Path target, CopyOption[] options) {\n+            this.source = source;\n+            this.target = target;\n+            this.options = options;\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                while (running.get()) {\n+                    Files.copy(source, target, options);\n+                }\n+            } catch (FileAlreadyExistsException e) {\n+                running.set(false);\n+                throw new RuntimeException(\"Unexpected exception\", e);\n+            } catch (FileSystemException e) {\n+                System.out.printf(\"Expected FileSystemException: \\\"%s\\\"%n\",\n+                                  e.getMessage());\n+            } catch (IOException e) {\n+                running.set(false);\n+                throw new RuntimeException(\"Unexpected exception\", e);\n+            } finally {\n+                running.set(false);\n+            }\n+        }\n+    }\n+\n+    private static Stream<Arguments> pathAndOptionsProvider()\n+        throws IOException {\n+        Path parent = Path.of(System.getProperty(\"test.dir\", \".\"));\n+        Path dir = Files.createTempDirectory(parent, \"foobargus\");\n+        dir.toFile().deleteOnExit();\n+\n+        List<Arguments> list = new ArrayList<Arguments>();\n+\n+        \/\/ regular file\n+        Path sourceFile = Files.createTempFile(dir, \"foo\", \"baz\");\n+        Class c = CopyInterference.class;\n+        String name = \"CopyInterference.class\";\n+\n+        try (InputStream in = c.getResourceAsStream(name)) {\n+            Files.copy(in, sourceFile, REPLACE_EXISTING);\n+        }\n+\n+        Arguments args = Arguments.of(sourceFile, dir.resolve(\"targetFile\"),\n+                                      new CopyOption[] {REPLACE_EXISTING});\n+        list.add(args);\n+\n+        \/\/ directory\n+        Path sourceDirectory = Files.createTempDirectory(dir, \"fubar\");\n+        args = Arguments.of(sourceDirectory, dir.resolve(\"targetDir\"),\n+                            new CopyOption[] {REPLACE_EXISTING});\n+        list.add(args);\n+\n+        \/\/ symblic link, followed\n+        Path link = dir.resolve(\"link\");\n+        Files.createSymbolicLink(link, sourceFile);\n+        args = Arguments.of(link, dir.resolve(\"linkFollowed\"),\n+                            new CopyOption[] {REPLACE_EXISTING});\n+        list.add(args);\n+\n+        \/\/ symblic link, not followed\n+        args = Arguments.of(link, dir.resolve(\"linkNotFollowed\"),\n+                            new CopyOption[] {REPLACE_EXISTING, NOFOLLOW_LINKS});\n+        list.add(args);\n+\n+        return list.stream();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"pathAndOptionsProvider\")\n+    void copy(Path source, Path target, CopyOption[] options)\n+        throws InterruptedException, IOException {\n+\n+        Future<?>[] results = new Future<?>[N_THREADS];\n+        try (ExecutorService es = Executors.newFixedThreadPool(N_THREADS)) {\n+            CopyTask copyTask = new CopyTask(source, target, options);\n+            for (int i = 0; i < N_THREADS; i++)\n+                results[i] = es.submit(copyTask);\n+        }\n+\n+        for (Future<?> res : results) {\n+            try {\n+                res.get();\n+            } catch (ExecutionException e) {\n+                throw new RuntimeException(res.exceptionNow());\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/file\/Files\/CopyInterference.java","additions":153,"deletions":0,"binary":false,"changes":153,"status":"added"}]}