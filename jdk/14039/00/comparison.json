{"files":[{"patch":"@@ -28,1 +28,0 @@\n-import java.lang.ref.Reference;\n@@ -47,1 +46,1 @@\n-interface ReferenceKey<T> {\n+sealed interface ReferenceKey<T> permits StrongReferenceKey, WeakReferenceKey, SoftReferenceKey {\n@@ -58,172 +57,0 @@\n-    \/**\n-     * {@link WeakReference} wrapper key for entries in the backing map.\n-     *\n-     * @param <T> key type\n-     *\n-     * @since 21\n-     *\/\n-    class WeakKey<T> extends WeakReference<T> implements ReferenceKey<T> {\n-        \/**\n-         * Saved hashcode of the key. Used when {@link WeakReference} is\n-         * null.\n-         *\/\n-        private final int hashcode;\n-\n-        \/**\n-         * Private constructor.\n-         *\n-         * @param key   unwrapped key value\n-         * @param queue reference queue\n-         *\/\n-        WeakKey(T key, ReferenceQueue<T> queue) {\n-            super(key, queue);\n-            this.hashcode = Objects.hashCode(key);\n-        }\n-\n-        \/**\n-         * Cleanup unused key. No need to enqueue since the key did not make it\n-         * into the map.\n-         *\/\n-        @Override\n-        public void unused() {\n-            clear();\n-        }\n-\n-        @Override\n-        public boolean equals(Object obj) {\n-            \/\/ Necessary when removing a null reference\n-            if (obj == this) {\n-                return true;\n-            }\n-            \/\/ Necessary when comparing an unwrapped key\n-            if (obj instanceof ReferenceKey<?> key) {\n-                obj = key.get();\n-            }\n-            return Objects.equals(get(), obj);\n-        }\n-\n-        @Override\n-        public int hashCode() {\n-            \/\/ Use saved hashcode\n-            return hashcode;\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return this.getClass().getCanonicalName() + \"#\" + System.identityHashCode(this);\n-        }\n-    }\n-\n-    \/**\n-     * {@link SoftReference} wrapper key for entries in the backing map.\n-     *\n-     * @param <T> key type\n-     *\n-     * @since 21\n-     *\/\n-    class SoftKey<T> extends SoftReference<T> implements ReferenceKey<T> {\n-        \/**\n-         * Saved hashcode of the key. Used when {@link SoftReference} is\n-         * null.\n-         *\/\n-        private final int hashcode;\n-\n-        \/**\n-         * Private constructor.\n-         *\n-         * @param key   unwrapped key value\n-         * @param queue reference queue\n-         *\/\n-        SoftKey(T key, ReferenceQueue<T> queue) {\n-            super(key, queue);\n-            this.hashcode = Objects.hashCode(key);\n-        }\n-\n-        \/**\n-         * Cleanup unused key. No need to enqueue since the key did not make it\n-         * into the map.\n-         *\/\n-        @Override\n-        public void unused() {\n-            clear();\n-        }\n-\n-        @Override\n-        public boolean equals(Object obj) {\n-            \/\/ Necessary when removing a null reference\n-            if (obj == this) {\n-                return true;\n-            }\n-            \/\/ Necessary when comparing an unwrapped key\n-            if (obj instanceof ReferenceKey<?> key) {\n-                obj = key.get();\n-            }\n-            return Objects.equals(get(), obj);\n-        }\n-\n-        @Override\n-        public int hashCode() {\n-            \/\/ Use saved hashcode\n-            return hashcode;\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return this.getClass().getCanonicalName() + \"#\" + System.identityHashCode(this);\n-        }\n-    }\n-\n-    \/**\n-     * Wrapper for querying the backing map. Avoids the overhead of an\n-     * {@link Reference} object.\n-     *\n-     * @param <T> key type\n-     *\n-     * @since 21\n-     *\/\n-    class StrongKey<T> implements ReferenceKey<T> {\n-        T key;\n-\n-        \/**\n-         * Private constructor.\n-         *\n-         * @param key unwrapped key value\n-         *\/\n-        StrongKey(T key) {\n-            this.key = key;\n-        }\n-\n-        \/**\n-         * {@return the unwrapped key}\n-         *\/\n-        @Override\n-        public T get() {\n-            return key;\n-        }\n-\n-        @Override\n-        public void unused() {\n-            key = null;\n-        }\n-\n-        @Override\n-        public boolean equals(Object obj) {\n-            \/\/ Necessary when comparing an unwrapped key\n-            if (obj instanceof ReferenceKey<?> key) {\n-                obj = key.get();\n-            }\n-            return Objects.equals(get(), obj);\n-        }\n-\n-        @Override\n-        public int hashCode() {\n-            \/\/ Use unwrapped key hash code\n-            return get().hashCode();\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return this.getClass().getCanonicalName() + \"#\" + System.identityHashCode(this);\n-        }\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/ReferenceKey.java","additions":1,"deletions":174,"binary":false,"changes":175,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-     * {@link ReferenceQueue} for cleaning up {@link ReferenceKey.WeakKey EntryKeys}.\n+     * {@link ReferenceQueue} for cleaning up {@link WeakReferenceKey EntryKeys}.\n@@ -156,1 +156,1 @@\n-            return new ReferenceKey.SoftKey<>((K)key, stale);\n+            return new SoftReferenceKey<>((K)key, stale);\n@@ -158,1 +158,1 @@\n-            return new ReferenceKey.WeakKey<>((K)key, stale);\n+            return new WeakReferenceKey<>((K)key, stale);\n@@ -169,1 +169,1 @@\n-        return new ReferenceKey.StrongKey<>((K)key);\n+        return new StrongReferenceKey<>((K)key);\n@@ -326,1 +326,1 @@\n-            ReferenceKey.WeakKey<K> key = (ReferenceKey.WeakKey<K>)stale.poll();\n+            WeakReferenceKey<K> key = (WeakReferenceKey<K>)stale.poll();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/ReferencedKeyMap.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.runtime;\n+\n+import java.lang.ref.ReferenceQueue;\n+import java.lang.ref.SoftReference;\n+import java.util.Objects;\n+\n+\/**\n+ * {@link SoftReference} wrapper key for entries in the backing map.\n+ *\n+ * @param <T> key type\n+ *\n+ * @since 21\n+ *\n+ * Warning: This class is part of PreviewFeature.Feature.STRING_TEMPLATES.\n+ *          Do not rely on its availability.\n+ *\/\n+final class SoftReferenceKey<T> extends SoftReference<T> implements ReferenceKey<T> {\n+    \/**\n+     * Saved hashcode of the key. Used when {@link SoftReference} is\n+     * null.\n+     *\/\n+    private final int hashcode;\n+\n+    \/**\n+     * Package-Protected constructor.\n+     *\n+     * @param key   unwrapped key value\n+     * @param queue reference queue\n+     *\/\n+    SoftReferenceKey(T key, ReferenceQueue<T> queue) {\n+        super(key, queue);\n+        this.hashcode = Objects.hashCode(key);\n+    }\n+\n+    \/**\n+     * Cleanup unused key. No need to enqueue since the key did not make it\n+     * into the map.\n+     *\/\n+    @Override\n+    public void unused() {\n+        clear();\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        \/\/ Necessary when removing a null reference\n+        if (obj == this) {\n+            return true;\n+        }\n+        \/\/ Necessary when comparing an unwrapped key\n+        if (obj instanceof ReferenceKey<?> key) {\n+            obj = key.get();\n+        }\n+        return Objects.equals(get(), obj);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        \/\/ Use saved hashcode\n+        return hashcode;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return this.getClass().getCanonicalName() + \"#\" + System.identityHashCode(this);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/SoftReferenceKey.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.runtime;\n+\n+import java.util.Objects;\n+\n+\/**\n+ * Wrapper for querying the backing map. Avoids the overhead of an\n+ * {@link java.lang.ref.Reference} object.\n+ *\n+ * @param <T> key type\n+ *\n+ * @since 21\n+ *\n+ * Warning: This class is part of PreviewFeature.Feature.STRING_TEMPLATES.\n+ *          Do not rely on its availability.\n+ *\/\n+final class StrongReferenceKey<T> implements ReferenceKey<T> {\n+    T key;\n+\n+    \/**\n+     * Package-Protected constructor.\n+     *\n+     * @param key unwrapped key value\n+     *\/\n+    StrongReferenceKey(T key) {\n+        this.key = key;\n+    }\n+\n+    \/**\n+     * {@return the unwrapped key}\n+     *\/\n+    @Override\n+    public T get() {\n+        return key;\n+    }\n+\n+    @Override\n+    public void unused() {\n+        key = null;\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        \/\/ Necessary when comparing an unwrapped key\n+        if (obj instanceof ReferenceKey<?> key) {\n+            obj = key.get();\n+        }\n+        return Objects.equals(get(), obj);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        \/\/ Use unwrapped key hash code\n+        return get().hashCode();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return this.getClass().getCanonicalName() + \"#\" + System.identityHashCode(this);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/StrongReferenceKey.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.runtime;\n+\n+import java.lang.ref.ReferenceQueue;\n+import java.lang.ref.WeakReference;\n+import java.util.Objects;\n+\n+\/**\n+ * {@link WeakReference} wrapper key for entries in the backing map.\n+ *\n+ * @param <T> key type\n+ *\n+ * @since 21\n+ *\n+ * Warning: This class is part of PreviewFeature.Feature.STRING_TEMPLATES.\n+ *          Do not rely on its availability.\n+ *\/\n+final class WeakReferenceKey<T> extends WeakReference<T> implements ReferenceKey<T> {\n+    \/**\n+     * Saved hashcode of the key. Used when {@link WeakReference} is\n+     * null.\n+     *\/\n+    private final int hashcode;\n+\n+    \/**\n+     * Package-Protected constructor.\n+     *\n+     * @param key   unwrapped key value\n+     * @param queue reference queue\n+     *\/\n+    WeakReferenceKey(T key, ReferenceQueue<T> queue) {\n+        super(key, queue);\n+        this.hashcode = Objects.hashCode(key);\n+    }\n+\n+    \/**\n+     * Cleanup unused key. No need to enqueue since the key did not make it\n+     * into the map.\n+     *\/\n+    @Override\n+    public void unused() {\n+        clear();\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        \/\/ Necessary when removing a null reference\n+        if (obj == this) {\n+            return true;\n+        }\n+        \/\/ Necessary when comparing an unwrapped key\n+        if (obj instanceof ReferenceKey<?> key) {\n+            obj = key.get();\n+        }\n+        return Objects.equals(get(), obj);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        \/\/ Use saved hashcode\n+        return hashcode;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return this.getClass().getCanonicalName() + \"#\" + System.identityHashCode(this);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/WeakReferenceKey.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"},{"patch":"@@ -0,0 +1,134 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.util;\n+\n+import java.lang.invoke.MethodHandle;\n+\n+import jdk.internal.vm.annotation.Stable;\n+\n+\/**\n+ * Digits class for decimal digits.\n+ *\n+ * @since 21\n+ *\/\n+final class DecimalDigits implements Digits {\n+    @Stable\n+    private static final short[] DIGITS;\n+\n+    \/**\n+     * Singleton instance of DecimalDigits.\n+     *\/\n+    static final Digits INSTANCE = new DecimalDigits();\n+\n+    static {\n+        short[] digits = new short[10 * 10];\n+\n+        for (int i = 0; i < 10; i++) {\n+            short hi = (short) ((i + '0') << 8);\n+\n+            for (int j = 0; j < 10; j++) {\n+                short lo = (short) (j + '0');\n+                digits[i * 10 + j] = (short) (hi | lo);\n+            }\n+        }\n+\n+        DIGITS = digits;\n+    }\n+\n+    \/**\n+     * Constructor.\n+     *\/\n+    private DecimalDigits() {\n+    }\n+\n+    @Override\n+    public int digits(long value, byte[] buffer, int index,\n+                      MethodHandle putCharMH) throws Throwable {\n+        boolean negative = value < 0;\n+        if (!negative) {\n+            value = -value;\n+        }\n+\n+        long q;\n+        int r;\n+        while (value <= Integer.MIN_VALUE) {\n+            q = value \/ 100;\n+            r = (int)((q * 100) - value);\n+            value = q;\n+            int digits = DIGITS[r];\n+\n+            putCharMH.invokeExact(buffer, --index, digits & 0xFF);\n+            putCharMH.invokeExact(buffer, --index, digits >> 8);\n+        }\n+\n+        int iq, ivalue = (int)value;\n+        while (ivalue <= -100) {\n+            iq = ivalue \/ 100;\n+            r = (iq * 100) - ivalue;\n+            ivalue = iq;\n+            int digits = DIGITS[r];\n+            putCharMH.invokeExact(buffer, --index, digits & 0xFF);\n+            putCharMH.invokeExact(buffer, --index, digits >> 8);\n+        }\n+\n+        if (ivalue < 0) {\n+            ivalue = -ivalue;\n+        }\n+\n+        int digits = DIGITS[ivalue];\n+        putCharMH.invokeExact(buffer, --index, digits & 0xFF);\n+\n+        if (9 < ivalue) {\n+            putCharMH.invokeExact(buffer, --index, digits >> 8);\n+        }\n+\n+        if (negative) {\n+            putCharMH.invokeExact(buffer, --index, (int)'-');\n+        }\n+\n+        return index;\n+    }\n+\n+    @Override\n+    public int size(long value) {\n+        boolean negative = value < 0;\n+        int sign = negative ? 1 : 0;\n+\n+        if (!negative) {\n+            value = -value;\n+        }\n+\n+        long precision = -10;\n+        for (int i = 1; i < 19; i++) {\n+            if (value > precision)\n+                return i + sign;\n+\n+            precision = 10 * precision;\n+        }\n+\n+        return 19 + sign;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/util\/DecimalDigits.java","additions":134,"deletions":0,"binary":false,"changes":134,"status":"added"},{"patch":"@@ -30,2 +30,0 @@\n-import jdk.internal.vm.annotation.Stable;\n-\n@@ -38,1 +36,1 @@\n-sealed interface Digits permits Digits.DecimalDigits, Digits.HexDigits, Digits.OctalDigits {\n+sealed interface Digits permits DecimalDigits, HexDigits, OctalDigits {\n@@ -63,220 +61,0 @@\n-    \/**\n-     * Digits class for decimal digits.\n-     *\/\n-    final class DecimalDigits implements Digits {\n-        @Stable\n-        private static final short[] DIGITS;\n-\n-        \/**\n-         * Singleton instance of DecimalDigits.\n-         *\/\n-        static final Digits INSTANCE = new DecimalDigits();\n-\n-        static {\n-            short[] digits = new short[10 * 10];\n-\n-            for (int i = 0; i < 10; i++) {\n-                short hi = (short) ((i + '0') << 8);\n-\n-                for (int j = 0; j < 10; j++) {\n-                    short lo = (short) (j + '0');\n-                    digits[i * 10 + j] = (short) (hi | lo);\n-                }\n-            }\n-\n-            DIGITS = digits;\n-        }\n-\n-        \/**\n-         * Constructor.\n-         *\/\n-        private DecimalDigits() {\n-        }\n-\n-        @Override\n-        public int digits(long value, byte[] buffer, int index,\n-                          MethodHandle putCharMH) throws Throwable {\n-            boolean negative = value < 0;\n-            if (!negative) {\n-                value = -value;\n-            }\n-\n-            long q;\n-            int r;\n-            while (value <= Integer.MIN_VALUE) {\n-                q = value \/ 100;\n-                r = (int)((q * 100) - value);\n-                value = q;\n-                int digits = DIGITS[r];\n-\n-                putCharMH.invokeExact(buffer, --index, digits & 0xFF);\n-                putCharMH.invokeExact(buffer, --index, digits >> 8);\n-            }\n-\n-            int iq, ivalue = (int)value;\n-            while (ivalue <= -100) {\n-                iq = ivalue \/ 100;\n-                r = (iq * 100) - ivalue;\n-                ivalue = iq;\n-                int digits = DIGITS[r];\n-                putCharMH.invokeExact(buffer, --index, digits & 0xFF);\n-                putCharMH.invokeExact(buffer, --index, digits >> 8);\n-            }\n-\n-            if (ivalue < 0) {\n-                ivalue = -ivalue;\n-            }\n-\n-            int digits = DIGITS[ivalue];\n-            putCharMH.invokeExact(buffer, --index, digits & 0xFF);\n-\n-            if (9 < ivalue) {\n-                putCharMH.invokeExact(buffer, --index, digits >> 8);\n-            }\n-\n-            if (negative) {\n-                putCharMH.invokeExact(buffer, --index, (int)'-');\n-            }\n-\n-            return index;\n-        }\n-\n-        @Override\n-        public int size(long value) {\n-            boolean negative = value < 0;\n-            int sign = negative ? 1 : 0;\n-\n-            if (!negative) {\n-                value = -value;\n-            }\n-\n-            long precision = -10;\n-            for (int i = 1; i < 19; i++) {\n-                if (value > precision)\n-                    return i + sign;\n-\n-                precision = 10 * precision;\n-            }\n-\n-            return 19 + sign;\n-        }\n-    }\n-\n-    \/**\n-     * Digits class for hexadecimal digits.\n-     *\/\n-    final class HexDigits implements Digits {\n-        @Stable\n-        private static final short[] DIGITS;\n-\n-        \/**\n-         * Singleton instance of HexDigits.\n-         *\/\n-        static final Digits INSTANCE = new HexDigits();\n-\n-        static {\n-            short[] digits = new short[16 * 16];\n-\n-            for (int i = 0; i < 16; i++) {\n-                short hi = (short) ((i < 10 ? i + '0' : i - 10 + 'a') << 8);\n-\n-                for (int j = 0; j < 16; j++) {\n-                    short lo = (short) (j < 10 ? j + '0' : j - 10 + 'a');\n-                    digits[(i << 4) + j] = (short) (hi | lo);\n-                }\n-            }\n-\n-            DIGITS = digits;\n-        }\n-\n-        \/**\n-         * Constructor.\n-         *\/\n-        private HexDigits() {\n-        }\n-\n-        @Override\n-        public int digits(long value, byte[] buffer, int index,\n-                          MethodHandle putCharMH) throws Throwable {\n-            while ((value & ~0xFF) != 0) {\n-                int digits = DIGITS[(int) (value & 0xFF)];\n-                value >>>= 8;\n-                putCharMH.invokeExact(buffer, --index, digits & 0xFF);\n-                putCharMH.invokeExact(buffer, --index, digits >> 8);\n-            }\n-\n-            int digits = DIGITS[(int) (value & 0xFF)];\n-            putCharMH.invokeExact(buffer, --index, digits & 0xFF);\n-\n-            if (0xF < value) {\n-                putCharMH.invokeExact(buffer, --index, digits >> 8);\n-            }\n-\n-            return index;\n-        }\n-\n-        @Override\n-        public int size(long value) {\n-            return value == 0 ? 1 :\n-                    67 - Long.numberOfLeadingZeros(value) >> 2;\n-        }\n-    }\n-\n-    \/**\n-     * Digits class for octal digits.\n-     *\/\n-    final class OctalDigits implements Digits {\n-        @Stable\n-        private static final short[] DIGITS;\n-\n-        \/**\n-         * Singleton instance of OctalDigits.\n-         *\/\n-        static final Digits INSTANCE = new OctalDigits();\n-\n-        static {\n-            short[] digits = new short[8 * 8];\n-\n-            for (int i = 0; i < 8; i++) {\n-                short hi = (short) ((i + '0') << 8);\n-\n-                for (int j = 0; j < 8; j++) {\n-                    short lo = (short) (j + '0');\n-                    digits[(i << 3) + j] = (short) (hi | lo);\n-                }\n-            }\n-\n-            DIGITS = digits;\n-        }\n-\n-        \/**\n-         * Constructor.\n-         *\/\n-        private OctalDigits() {\n-        }\n-\n-        @Override\n-        public int digits(long value, byte[] buffer, int index,\n-                          MethodHandle putCharMH) throws Throwable {\n-            while ((value & ~0x3F) != 0) {\n-                int digits = DIGITS[(int) (value & 0x3F)];\n-                value >>>= 6;\n-                putCharMH.invokeExact(buffer, --index, digits & 0xFF);\n-                putCharMH.invokeExact(buffer, --index, digits >> 8);\n-            }\n-\n-            int digits = DIGITS[(int) (value & 0x3F)];\n-            putCharMH.invokeExact(buffer, --index, digits & 0xFF);\n-\n-            if (7 < value) {\n-                putCharMH.invokeExact(buffer, --index, digits >> 8);\n-            }\n-\n-            return index;\n-        }\n-\n-        @Override\n-        public int size(long value) {\n-            return (66 - Long.numberOfLeadingZeros(value)) \/ 3;\n-        }\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/util\/Digits.java","additions":1,"deletions":223,"binary":false,"changes":224,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import java.util.Digits.*;\n","filename":"src\/java.base\/share\/classes\/java\/util\/FormatItem.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.util;\n+\n+import java.lang.invoke.MethodHandle;\n+\n+import jdk.internal.vm.annotation.Stable;\n+\n+\/**\n+ * Digits class for hexadecimal digits.\n+ *\n+ * @since 21\n+ *\/\n+final class HexDigits implements Digits {\n+    @Stable\n+    private static final short[] DIGITS;\n+\n+    \/**\n+     * Singleton instance of HexDigits.\n+     *\/\n+    static final Digits INSTANCE = new HexDigits();\n+\n+    static {\n+        short[] digits = new short[16 * 16];\n+\n+        for (int i = 0; i < 16; i++) {\n+            short hi = (short) ((i < 10 ? i + '0' : i - 10 + 'a') << 8);\n+\n+            for (int j = 0; j < 16; j++) {\n+                short lo = (short) (j < 10 ? j + '0' : j - 10 + 'a');\n+                digits[(i << 4) + j] = (short) (hi | lo);\n+            }\n+        }\n+\n+        DIGITS = digits;\n+    }\n+\n+    \/**\n+     * Constructor.\n+     *\/\n+    private HexDigits() {\n+    }\n+\n+    @Override\n+    public int digits(long value, byte[] buffer, int index,\n+                      MethodHandle putCharMH) throws Throwable {\n+        while ((value & ~0xFF) != 0) {\n+            int digits = DIGITS[(int) (value & 0xFF)];\n+            value >>>= 8;\n+            putCharMH.invokeExact(buffer, --index, digits & 0xFF);\n+            putCharMH.invokeExact(buffer, --index, digits >> 8);\n+        }\n+\n+        int digits = DIGITS[(int) (value & 0xFF)];\n+        putCharMH.invokeExact(buffer, --index, digits & 0xFF);\n+\n+        if (0xF < value) {\n+            putCharMH.invokeExact(buffer, --index, digits >> 8);\n+        }\n+\n+        return index;\n+    }\n+\n+    @Override\n+    public int size(long value) {\n+        return value == 0 ? 1 :\n+                67 - Long.numberOfLeadingZeros(value) >> 2;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/util\/HexDigits.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.util;\n+\n+import java.lang.invoke.MethodHandle;\n+\n+import jdk.internal.vm.annotation.Stable;\n+\n+\/**\n+ * Digits class for octal digits.\n+ *\n+ * @since 21\n+ *\/\n+final class OctalDigits implements Digits {\n+    @Stable\n+    private static final short[] DIGITS;\n+\n+    \/**\n+     * Singleton instance of OctalDigits.\n+     *\/\n+    static final Digits INSTANCE = new OctalDigits();\n+\n+    static {\n+        short[] digits = new short[8 * 8];\n+\n+        for (int i = 0; i < 8; i++) {\n+            short hi = (short) ((i + '0') << 8);\n+\n+            for (int j = 0; j < 8; j++) {\n+                short lo = (short) (j + '0');\n+                digits[(i << 3) + j] = (short) (hi | lo);\n+            }\n+        }\n+\n+        DIGITS = digits;\n+    }\n+\n+    \/**\n+     * Constructor.\n+     *\/\n+    private OctalDigits() {\n+    }\n+\n+    @Override\n+    public int digits(long value, byte[] buffer, int index,\n+                      MethodHandle putCharMH) throws Throwable {\n+        while ((value & ~0x3F) != 0) {\n+            int digits = DIGITS[(int) (value & 0x3F)];\n+            value >>>= 6;\n+            putCharMH.invokeExact(buffer, --index, digits & 0xFF);\n+            putCharMH.invokeExact(buffer, --index, digits >> 8);\n+        }\n+\n+        int digits = DIGITS[(int) (value & 0x3F)];\n+        putCharMH.invokeExact(buffer, --index, digits & 0xFF);\n+\n+        if (7 < value) {\n+            putCharMH.invokeExact(buffer, --index, digits >> 8);\n+        }\n+\n+        return index;\n+    }\n+\n+    @Override\n+    public int size(long value) {\n+        return (66 - Long.numberOfLeadingZeros(value)) \/ 3;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/util\/OctalDigits.java","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"}]}