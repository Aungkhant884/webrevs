{"files":[{"patch":"@@ -231,1 +231,1 @@\n-      forwardee = cast_to_oop(m.decode_pointer());\n+      forwardee = obj->forwardee(m);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1OopClosures.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -209,1 +209,1 @@\n-    obj = cast_to_oop(m.decode_pointer());\n+    obj = obj->forwardee(m);\n@@ -623,1 +623,1 @@\n-  oop forward_ptr = old->forward_to_atomic(old, m, memory_order_relaxed);\n+  oop forward_ptr = old->forward_failed_atomic(m, memory_order_relaxed);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -331,1 +331,1 @@\n-  if (obj->forward_to_atomic(obj, obj_mark) == nullptr) {\n+  if (obj->forward_failed_atomic(obj_mark) == nullptr) {\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -150,1 +150,1 @@\n-    return cast_to_oop(m.decode_pointer());\n+    return o->forwardee(m);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -908,2 +908,1 @@\n-  \/\/ forward to self\n-  old->forward_to(old);\n+  old->forward_failed();\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-    guarantee((_heap_start_region_bias << _region_size_bytes_shift) == (uintptr_t)_heap_start, \"must be aligned\");\n+    guarantee((_heap_start_region_bias << _region_size_bytes_shift) == (uintptr_t)_heap_start, \"must be aligned: _heap_start_region_bias: \" SIZE_FORMAT \", _region_size_byte_shift: %u, _heap_start: \" PTR_FORMAT, _heap_start_region_bias, _region_size_bytes_shift, p2i(_heap_start));\n","filename":"src\/hotspot\/share\/gc\/shared\/slidingForwarding.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/shared\/gc_globals.hpp\"\n@@ -106,2 +107,2 @@\n-  static const int first_unused_gap_bits          = 1;\n-  static const int max_hash_bits                  = BitsPerWord - age_bits - lock_bits - first_unused_gap_bits;\n+  static const int forward_failed_bits            = 1;\n+  static const int max_hash_bits                  = BitsPerWord - age_bits - lock_bits - forward_failed_bits;\n@@ -109,1 +110,1 @@\n-  static const int second_unused_gap_bits         = LP64_ONLY(1) NOT_LP64(0);\n+  static const int unused_gap_bits                = LP64_ONLY(1) NOT_LP64(0);\n@@ -112,2 +113,3 @@\n-  static const int age_shift                      = lock_bits + first_unused_gap_bits;\n-  static const int hash_shift                     = age_shift + age_bits + second_unused_gap_bits;\n+  static const int forward_failed_shift           = lock_shift + lock_bits;\n+  static const int age_shift                      = forward_failed_shift + forward_failed_bits;\n+  static const int hash_shift                     = age_shift + age_bits + unused_gap_bits;\n@@ -117,0 +119,2 @@\n+  static const uintptr_t forward_failed_mask      = right_n_bits(forward_failed_bits);\n+  static const uintptr_t forward_failed_mask_in_place = forward_failed_mask << forward_failed_shift;\n@@ -263,0 +267,11 @@\n+\n+  inline bool forward_failed() const {\n+    bool fwd_failed = mask_bits(value(), forward_failed_mask_in_place) != 0;\n+    assert(!fwd_failed || UseAltGCForwarding, \"Only set fwd-failed bit when using alt GC forwarding\");\n+    return fwd_failed;\n+  }\n+\n+  inline markWord set_forward_failed() const {\n+    assert(UseAltGCForwarding, \"Only call this with alt GC forwarding\");\n+    return markWord(value() | forward_failed_mask_in_place | marked_value);\n+  }\n","filename":"src\/hotspot\/share\/oops\/markWord.hpp","additions":20,"deletions":5,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -261,0 +261,1 @@\n+  inline void forward_failed();\n@@ -267,0 +268,1 @@\n+  inline oop forward_failed_atomic(markWord compare, atomic_memory_order order = memory_order_conservative);\n@@ -269,0 +271,1 @@\n+  inline oop forwardee(markWord header) const;\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"runtime\/safepoint.hpp\"\n@@ -269,0 +270,1 @@\n+  assert(p != cast_to_oop(this) || !UseAltGCForwarding, \"Must not be called with self-forwarding\");\n@@ -270,1 +272,1 @@\n-  assert(m.decode_pointer() == p, \"encoding must be reversible\");\n+  assert(forwardee(m) == p, \"encoding must be reversible\");\n@@ -274,0 +276,17 @@\n+void oopDesc::forward_failed() {\n+  if (UseAltGCForwarding) {\n+    markWord m = mark();\n+    \/\/ If mark is displaced, we need to preserve the real header during GC.\n+    \/\/ It will be restored to the displaced header after GC.\n+    assert(SafepointSynchronize::is_at_safepoint(), \"we can only safely fetch the displaced header at safepoint\");\n+    if (m.has_displaced_mark_helper()) {\n+      m = m.displaced_mark_helper();\n+    }\n+    m = m.set_forward_failed();\n+    assert(forwardee(m) == cast_to_oop(this), \"encoding must be reversible\");\n+    set_mark(m);\n+  } else {\n+    forward_to(oop(this));\n+  }\n+}\n+\n@@ -275,0 +294,1 @@\n+  assert(p != cast_to_oop(this) || !UseAltGCForwarding, \"Must not be called with self-forwarding\");\n@@ -281,1 +301,33 @@\n-    return cast_to_oop(old_mark.decode_pointer());\n+    return forwardee(old_mark);\n+  }\n+}\n+\n+oop oopDesc::forward_failed_atomic(markWord compare, atomic_memory_order order) {\n+  if (UseAltGCForwarding) {\n+    markWord m = compare;\n+    \/\/ If mark is displaced, we need to preserve the real header during GC.\n+    \/\/ It will be restored to the displaced header after GC.\n+    assert(SafepointSynchronize::is_at_safepoint(), \"we can only safely fetch the displaced header at safepoint\");\n+    if (m.has_displaced_mark_helper()) {\n+      m = m.displaced_mark_helper();\n+    }\n+    m = m.set_forward_failed();\n+    assert(forwardee(m) == cast_to_oop(this), \"encoding must be reversible\");\n+    markWord old_mark = cas_set_mark(m, compare, order);\n+    if (old_mark == compare) {\n+      return nullptr;\n+    } else {\n+      assert(old_mark.is_marked(), \"must be marked here\");\n+      return forwardee(old_mark);\n+    }\n+  } else {\n+    return forward_to_atomic(cast_to_oop(this), compare, order);\n+  }\n+}\n+\n+oop oopDesc::forwardee(markWord header) const {\n+  assert(header.is_marked(), \"only decode when actually forwarded\");\n+  if (header.forward_failed()) {\n+    return cast_to_oop(this);\n+  } else {\n+    return cast_to_oop(header.decode_pointer());\n@@ -289,2 +341,1 @@\n-  assert(is_forwarded(), \"only decode when actually forwarded\");\n-  return cast_to_oop(mark().decode_pointer());\n+  return forwardee(mark());\n","filename":"src\/hotspot\/share\/oops\/oop.inline.hpp","additions":55,"deletions":4,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"utilities\/align.hpp\"\n@@ -45,1 +46,2 @@\n-  alignas(8 * sizeof(HeapWord*)) HeapWord heap[16] = { nullptr };\n+  HeapWord fakeheap[32] = { nullptr };\n+  HeapWord* heap = align_up(fakeheap, 8 * sizeof(HeapWord));\n@@ -62,1 +64,2 @@\n-  alignas(8 * sizeof(HeapWord*)) HeapWord heap[16] = { nullptr };\n+  HeapWord fakeheap[32] = { nullptr };\n+  HeapWord* heap = align_up(fakeheap, 8 * sizeof(HeapWord));\n@@ -84,1 +87,2 @@\n-  alignas(8 * sizeof(HeapWord*)) HeapWord heap[16] = { nullptr };\n+  HeapWord fakeheap[32] = { nullptr };\n+  HeapWord* heap = align_up(fakeheap, 8 * sizeof(HeapWord));\n","filename":"test\/hotspot\/gtest\/gc\/shared\/test_slidingForwarding.cpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"}]}