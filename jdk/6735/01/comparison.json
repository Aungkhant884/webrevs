{"files":[{"patch":"@@ -51,0 +51,101 @@\n+\n+#if 1 \/\/ support for debug tracing\n+\n+#define LOG(...) \\\n+  { \\\n+    printf(__VA_ARGS__); \\\n+    fflush(stdout); \\\n+  }\n+\n+#define MAX_FRAME_COUNT_PRINT_STACK_TRACE 200\n+\n+static void\n+check_jvmti_status(JNIEnv* jni, jvmtiError err, const char* msg) {\n+  if (err != JVMTI_ERROR_NONE) {\n+    LOG(\"check_jvmti_status: JVMTI function returned error: %s (%d)\\n\", TranslateError(err), err);\n+    jni->FatalError(msg);\n+  }\n+}\n+\n+static void\n+deallocate(jvmtiEnv *jvmti, JNIEnv* jni, void* ptr) {\n+  jvmtiError err;\n+\n+  err = jvmti->Deallocate((unsigned char*)ptr);\n+  check_jvmti_status(jni, err, \"deallocate: error in JVMTI Deallocate call\");\n+}\n+\n+static char*\n+get_method_class_name(jvmtiEnv *jvmti, JNIEnv* jni, jmethodID method) {\n+  jclass klass = NULL;\n+  char*  cname = NULL;\n+  char*  result = NULL;\n+  jvmtiError err;\n+\n+  err = jvmti->GetMethodDeclaringClass(method, &klass);\n+  check_jvmti_status(jni, err, \"get_method_class_name: error in JVMTI GetMethodDeclaringClass\");\n+\n+  err = jvmti->GetClassSignature(klass, &cname, NULL);\n+  check_jvmti_status(jni, err, \"get_method_class_name: error in JVMTI GetClassSignature\");\n+\n+  size_t len = strlen(cname) - 2; \/\/ get rid of leading 'L' and trailing ';'\n+\n+  err = jvmti->Allocate((jlong)(len + 1), (unsigned char**)&result);\n+  check_jvmti_status(jni, err, \"get_method_class_name: error in JVMTI Allocate\");\n+\n+  strncpy(result, cname + 1, len); \/\/ skip leading 'L'\n+  result[len] = '\\0';\n+  deallocate(jvmti, jni, (void*)cname);\n+  return result;\n+}\n+\n+static void\n+print_method(jvmtiEnv *jvmti, JNIEnv* jni, jmethodID method, jint depth) {\n+  char*  cname = NULL;\n+  char*  mname = NULL;\n+  char*  msign = NULL;\n+  jvmtiError err;\n+\n+  cname = get_method_class_name(jvmti, jni, method);\n+\n+  err = jvmti->GetMethodName(method, &mname, &msign, NULL);\n+  check_jvmti_status(jni, err, \"print_method: error in JVMTI GetMethodName\");\n+\n+  LOG(\"%2d: %s: %s%s\\n\", depth, cname, mname, msign);\n+  fflush(0);\n+  deallocate(jvmti, jni, (void*)cname);\n+  deallocate(jvmti, jni, (void*)mname);\n+  deallocate(jvmti, jni, (void*)msign);\n+}\n+\n+static char*\n+get_thread_name(jvmtiEnv *jvmti, JNIEnv* jni, jthread thread) {\n+  jvmtiThreadInfo thr_info;\n+  jvmtiError err;\n+\n+  memset(&thr_info, 0, sizeof(thr_info));\n+  err = jvmti->GetThreadInfo(thread, &thr_info);\n+  check_jvmti_status(jni, err, \"get_thread_name: error in JVMTI GetThreadInfo call\");\n+\n+  return thr_info.name == NULL ? (char*)\"<Unnamed thread>\" : thr_info.name;\n+}\n+\n+static void\n+print_stack_trace(jvmtiEnv *jvmti, JNIEnv* jni, jthread thread) {\n+  jvmtiFrameInfo frames[MAX_FRAME_COUNT_PRINT_STACK_TRACE];\n+  char* tname = get_thread_name(jvmti, jni, thread);\n+  jint count = 0;\n+  jvmtiError err;\n+\n+  err = jvmti->GetStackTrace(thread, 0, MAX_FRAME_COUNT_PRINT_STACK_TRACE, frames, &count);\n+  check_jvmti_status(jni, err, \"print_stack_trace: error in JVMTI GetStackTrace\");\n+\n+  LOG(\"JVMTI Stack Trace for thread %s: frame count: %d\\n\", tname, count);\n+  for (int depth = 0; depth < count; depth++) {\n+    print_method(jvmti, jni, frames[depth].method, depth);\n+  }\n+  deallocate(jvmti, jni, (void*)tname);\n+  LOG(\"\\n\");\n+}\n+#endif \/\/ support for debug tracing\n+\n@@ -340,0 +441,3 @@\n+#ifdef DBG\n+            print_stack_trace(jvmti, env, thr_ptr);\n+#endif\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetThreadState\/thrstat002\/thrstat002.cpp","additions":104,"deletions":0,"binary":false,"changes":104,"status":"modified"}]}