{"files":[{"patch":"@@ -98,0 +98,1 @@\n+            handle = SharedUtils.maybeCheckCaptureSegment(handle, linkRequest.options());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/AbstractLinker.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -81,0 +81,1 @@\n+    private static final MethodHandle MH_CHECK_CAPTURE_SEGMENT;\n@@ -113,0 +114,2 @@\n+            MH_CHECK_CAPTURE_SEGMENT = lookup.findStatic(SharedUtils.class, \"checkCaptureSegment\",\n+                    methodType(MemorySegment.class, MemorySegment.class));\n@@ -346,0 +349,17 @@\n+    public static MethodHandle maybeCheckCaptureSegment(MethodHandle handle, LinkerOptions options) {\n+        if (options.hasCapturedCallState()) {\n+            \/\/ (<target address>, SegmentAllocator, <capture segment>, ...) -> ...\n+            handle = MethodHandles.filterArguments(handle, 2, MH_CHECK_CAPTURE_SEGMENT);\n+        }\n+        return handle;\n+    }\n+\n+    @ForceInline\n+    public static MemorySegment checkCaptureSegment(MemorySegment captureSegment) {\n+        Objects.requireNonNull(captureSegment);\n+        if (captureSegment.equals(MemorySegment.NULL)) {\n+            throw new IllegalArgumentException(\"Capture segment is NULL: \" + captureSegment);\n+        }\n+        return captureSegment.asSlice(0, CapturableState.LAYOUT);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -52,1 +52,0 @@\n-import static java.lang.foreign.ValueLayout.JAVA_LONG;\n@@ -155,1 +154,1 @@\n-                capturedState = (MemorySegment) args[argStart++];\n+                capturedState = SharedUtils.checkCaptureSegment((MemorySegment) args[argStart++]);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/fallback\/FallbackLinker.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+import static org.testng.Assert.assertTrue;\n@@ -88,0 +89,15 @@\n+    @Test(dataProvider = \"invalidCaptureSegmentCases\")\n+    public void testInvalidCaptureSegment(MemorySegment captureSegment,\n+                                          Class<?> expectedExceptionType, String expectedExceptionMessage) {\n+        Linker.Option stl = Linker.Option.captureCallState(\"errno\");\n+        MethodHandle handle = downcallHandle(\"set_errno_V\", FunctionDescriptor.ofVoid(C_INT), stl);\n+\n+        try {\n+            int testValue = 42;\n+            handle.invoke(captureSegment, testValue); \/\/ should throw\n+        } catch (Throwable t) {\n+            assertTrue(expectedExceptionType.isInstance(t));\n+            assertTrue(t.getMessage().matches(expectedExceptionMessage));\n+        }\n+    }\n+\n@@ -131,0 +147,9 @@\n+    @DataProvider\n+    public static Object[][] invalidCaptureSegmentCases() {\n+        return new Object[][]{\n+            {Arena.ofAuto().allocate(1), IndexOutOfBoundsException.class, \".*Out of bound access on segment.*\"},\n+            {MemorySegment.NULL, IllegalArgumentException.class, \".*Capture segment is NULL.*\"},\n+            {Arena.ofAuto().allocate(Linker.Option.captureStateLayout().byteSize() + 3).asSlice(3), \/\/ misaligned\n+                    IllegalArgumentException.class, \".*Target offset incompatible with alignment constraints.*\"},\n+        };\n+    }\n","filename":"test\/jdk\/java\/foreign\/capturecallstate\/TestCaptureCallState.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"}]}