{"files":[{"patch":"@@ -2441,4 +2441,0 @@\n-const int Matcher::float_pressure(int default_pressure_threshold) {\n-  return default_pressure_threshold;\n-}\n-\n@@ -2557,0 +2553,16 @@\n+uint Matcher::int_pressure_limit()\n+{\n+  \/\/ 8183543: on AArch64 C2 compilation often fails\n+  \/\/ with \"failed spill-split-recycle sanity check\".\n+  \/\/ A call is considered a high register pressure area\n+  \/\/ and force spilling around the call.\n+  uint int_pressure_threshold = _NO_SPECIAL_REG32_mask.Size() - 1;\n+  return (INTPRESSURE == -1) ? int_pressure_threshold : INTPRESSURE;\n+}\n+\n+uint Matcher::float_pressure_limit()\n+{\n+  \/\/ _FLOAT_REG_mask is generated by adlc from the float_reg register class.\n+  return (FLOATPRESSURE == -1) ? _FLOAT_REG_mask.Size() : FLOATPRESSURE;\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":16,"deletions":4,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-define_pd_global(intx, FLOATPRESSURE,                32);\n@@ -50,1 +49,0 @@\n-define_pd_global(intx, INTPRESSURE,                  24);\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_globals_aarch64.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1004,4 +1004,0 @@\n-const int Matcher::float_pressure(int default_pressure_threshold) {\n-  return default_pressure_threshold;\n-}\n-\n@@ -1103,0 +1099,10 @@\n+uint Matcher::int_pressure_limit()\n+{\n+  return (INTPRESSURE == -1) ? 12 : INTPRESSURE;\n+}\n+\n+uint Matcher::float_pressure_limit()\n+{\n+  return (FLOATPRESSURE == -1) ? 30 : FLOATPRESSURE;\n+}\n+\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n-define_pd_global(intx, FLOATPRESSURE,                30);\n@@ -50,1 +49,0 @@\n-define_pd_global(intx, INTPRESSURE,                  12);\n","filename":"src\/hotspot\/cpu\/arm\/c2_globals_arm.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-define_pd_global(intx, FLOATPRESSURE,                28);\n@@ -50,1 +49,0 @@\n-define_pd_global(intx, INTPRESSURE,                  26);\n","filename":"src\/hotspot\/cpu\/ppc\/c2_globals_ppc.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2196,4 +2196,0 @@\n-const int Matcher::float_pressure(int default_pressure_threshold) {\n-  return default_pressure_threshold;\n-}\n-\n@@ -2366,0 +2362,10 @@\n+uint Matcher::int_pressure_limit()\n+{\n+  return (INTPRESSURE == -1) ? 26 : INTPRESSURE;\n+}\n+\n+uint Matcher::float_pressure_limit()\n+{\n+  return (FLOATPRESSURE == -1) ? 28 : FLOATPRESSURE;\n+}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-define_pd_global(intx, FLOATPRESSURE,                15);\n@@ -50,1 +49,0 @@\n-define_pd_global(intx, INTPRESSURE,                  10); \/\/ Medium size register set, 6 special purpose regs, 3 SOE regs.\n","filename":"src\/hotspot\/cpu\/s390\/c2_globals_s390.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1557,4 +1557,0 @@\n-const int Matcher::float_pressure(int default_pressure_threshold) {\n-  return default_pressure_threshold;\n-}\n-\n@@ -1668,0 +1664,11 @@\n+uint Matcher::int_pressure_limit()\n+{\n+  \/\/ Medium size register set, 6 special purpose regs, 3 SOE regs.\n+  return (INTPRESSURE == -1) ? 10 : INTPRESSURE;\n+}\n+\n+uint Matcher::float_pressure_limit()\n+{\n+  return (FLOATPRESSURE == -1) ? 15 : FLOATPRESSURE;\n+}\n+\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -49,2 +49,0 @@\n-define_pd_global(intx,  INTPRESSURE,                 13);\n-define_pd_global(intx,  FLOATPRESSURE,               14);\n@@ -61,2 +59,0 @@\n-define_pd_global(intx,  INTPRESSURE,                 6);\n-define_pd_global(intx,  FLOATPRESSURE,               6);\n","filename":"src\/hotspot\/cpu\/x86\/c2_globals_x86.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1901,12 +1901,0 @@\n-const int Matcher::float_pressure(int default_pressure_threshold) {\n-  int float_pressure_threshold = default_pressure_threshold;\n-#ifdef _LP64\n-  if (UseAVX > 2) {\n-    \/\/ Increase pressure threshold on machines with AVX3 which have\n-    \/\/ 2x more XMM registers.\n-    float_pressure_threshold = default_pressure_threshold * 2;\n-  }\n-#endif\n-  return float_pressure_threshold;\n-}\n-\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1443,0 +1443,10 @@\n+uint Matcher::int_pressure_limit()\n+{\n+  return (INTPRESSURE == -1) ? 6 : INTPRESSURE;\n+}\n+\n+uint Matcher::float_pressure_limit()\n+{\n+  return (FLOATPRESSURE == -1) ? 6 : FLOATPRESSURE;\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -325,0 +325,1 @@\n+extern RegMask _FLOAT_REG_mask;\n@@ -353,0 +354,1 @@\n+RegMask _FLOAT_REG_mask;\n@@ -428,0 +430,4 @@\n+  \/\/ _FLOAT_REG_LEGACY_mask\/_FLOAT_REG_EVEX_mask is generated by adlc\n+  \/\/ from the float_reg_legacy\/float_reg_evex register class.\n+  _FLOAT_REG_mask = VM_Version::supports_evex() ? _FLOAT_REG_EVEX_mask : _FLOAT_REG_LEGACY_mask;\n+\n@@ -1761,0 +1767,10 @@\n+uint Matcher::int_pressure_limit()\n+{\n+  return (INTPRESSURE == -1) ? _INT_REG_mask.Size() : INTPRESSURE;\n+}\n+\n+uint Matcher::float_pressure_limit()\n+{\n+  return (FLOATPRESSURE == -1) ? (_FLOAT_REG_mask.Size() - 2) : FLOATPRESSURE;\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -290,7 +290,11 @@\n-  develop_pd(intx, FLOATPRESSURE,                                           \\\n-          \"Number of float LRG's that constitute high register pressure\")   \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  develop_pd(intx, INTPRESSURE,                                             \\\n-          \"Number of integer LRG's that constitute high register pressure\") \\\n-          range(0, max_jint)                                                \\\n+  develop(intx, FLOATPRESSURE, -1,                                          \\\n+          \"Number of float LRG's that constitute high register pressure.\"   \\\n+          \"-1: means the threshold is determined by number of available \"   \\\n+          \"float register for allocation\")                                  \\\n+          range(-1, max_jint)                                               \\\n+                                                                            \\\n+  develop(intx, INTPRESSURE, -1,                                            \\\n+          \"Number of integer LRG's that constitute high register pressure.\" \\\n+          \"-1: means the threshold is determined by number of available \"   \\\n+          \"integer register for allocation\")                                \\\n+          range(-1, max_jint)                                               \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":11,"deletions":7,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -213,4 +213,4 @@\n-  , _sched_int_pressure(0, INTPRESSURE)\n-  , _sched_float_pressure(0, FLOATPRESSURE)\n-  , _scratch_int_pressure(0, INTPRESSURE)\n-  , _scratch_float_pressure(0, FLOATPRESSURE)\n+  , _sched_int_pressure(0, Matcher::int_pressure_limit())\n+  , _sched_float_pressure(0, Matcher::float_pressure_limit())\n+  , _scratch_int_pressure(0, Matcher::int_pressure_limit())\n+  , _scratch_float_pressure(0, Matcher::float_pressure_limit())\n","filename":"src\/hotspot\/share\/opto\/chaitin.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -859,2 +859,2 @@\n-    Pressure int_pressure(last_inst + 1, INTPRESSURE);\n-    Pressure float_pressure(last_inst + 1, FLOATPRESSURE);\n+    Pressure int_pressure(last_inst + 1, Matcher::int_pressure_limit());\n+    Pressure float_pressure(last_inst + 1, Matcher::float_pressure_limit());\n","filename":"src\/hotspot\/share\/opto\/ifg.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1079,5 +1079,4 @@\n-    uint float_pressure = Matcher::float_pressure(FLOATPRESSURE);\n-    _regalloc->_sched_int_pressure.init(INTPRESSURE);\n-    _regalloc->_sched_float_pressure.init(float_pressure);\n-    _regalloc->_scratch_int_pressure.init(INTPRESSURE);\n-    _regalloc->_scratch_float_pressure.init(float_pressure);\n+    _regalloc->_sched_int_pressure.init(Matcher::int_pressure_limit());\n+    _regalloc->_sched_float_pressure.init(Matcher::float_pressure_limit());\n+    _regalloc->_scratch_int_pressure.init(Matcher::int_pressure_limit());\n+    _regalloc->_scratch_float_pressure.init(Matcher::float_pressure_limit());\n","filename":"src\/hotspot\/share\/opto\/lcm.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -236,0 +236,4 @@\n+  \/\/ Number of integer live ranges that constitute high register pressure\n+  static uint int_pressure_limit();\n+  \/\/ Number of float live ranges that constitute high register pressure\n+  static uint float_pressure_limit();\n@@ -331,3 +335,0 @@\n-  \/\/ Some uarchs have different sized float register resources\n-  static const int float_pressure(int default_pressure_threshold);\n-\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -450,1 +450,1 @@\n-  int bound_pres = is_float_or_vector ? FLOATPRESSURE : INTPRESSURE;\n+  int bound_pres = is_float_or_vector ? Matcher::float_pressure_limit() : Matcher::int_pressure_limit();\n@@ -803,1 +803,1 @@\n-              (b->_reg_pressure < (uint)INTPRESSURE) ||\n+              (b->_reg_pressure < Matcher::int_pressure_limit()) ||\n@@ -808,1 +808,1 @@\n-              (b->_freg_pressure < (uint)FLOATPRESSURE) ||\n+              (b->_freg_pressure < Matcher::float_pressure_limit()) ||\n","filename":"src\/hotspot\/share\/opto\/reg_split.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2697,1 +2697,1 @@\n-          if (FLOATPRESSURE > 8) {\n+          if (Matcher::float_pressure_limit() > 8) {\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8183543\n+ * @summary C2 compilation often fails with \"failed spill-split-recycle sanity check\"\n+ *\n+ * @library \/test\/lib\n+ *\n+ * @build sun.hotspot.WhiteBox\n+ *\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ *\n+ * @run main\/othervm -Xbatch\n+ *                   -XX:-Inline\n+ *                   -XX:-TieredCompilation\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *                   compiler.c2.Test8183543\n+ *\/\n+\n+package compiler.c2;\n+\n+import sun.hotspot.WhiteBox;\n+\n+public class Test8183543 {\n+\n+  static volatile int vol_f;\n+\n+  static int test(Test8183543 arg) {\n+    Test8183543 a = arg;\n+    int res = 0;\n+    not_inlined();\n+    res = a.vol_f;\n+    return res;\n+  }\n+\n+  static void not_inlined() {\n+    for (int i = 0; i < 5000; i++) {\n+      vol_f += 2;\n+    }\n+  }\n+\n+  public static void main(String args[]) {\n+    Test8183543 arg = new Test8183543();\n+    for (int i = 0; i < 10000; i++) {\n+      Test8183543.test(arg);\n+    }\n+    try {\n+      var method = Test8183543.class.getDeclaredMethod(\"test\", Test8183543.class);\n+      if (!WhiteBox.getWhiteBox().isMethodCompiled(method)) {\n+        throw new Error(\"test method didn't get compiled\");\n+      }\n+    } catch (NoSuchMethodException e) {\n+      throw new Error(\"TESTBUG : \" + e, e);\n+    }\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/Test8183543.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"}]}