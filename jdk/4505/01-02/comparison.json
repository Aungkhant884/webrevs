{"files":[{"patch":"@@ -2555,2 +2555,2 @@\n-  \/\/ JDK-8183543: Take the number of available registers as int register\n-  \/\/ pressure threshold, the jtreg test:\n+  \/\/ JDK-8183543: When taking the number of available registers as int\n+  \/\/ register pressure threshold, the jtreg test:\n@@ -2560,4 +2560,10 @@\n-  \/\/ Lowering the default value to (_NO_SPECIAL_REG32_mask.Size() minus 1)\n-  \/\/ fixes this bug. See JDK-8183543.\n-  uint int_pressure_threshold = _NO_SPECIAL_REG32_mask.Size() - 1;\n-  return (INTPRESSURE == -1) ? int_pressure_threshold : INTPRESSURE;\n+  \/\/\n+  \/\/ A derived pointer is live at CallNode and then is flagged by RA\n+  \/\/ as a spilled LRG. Spilling heuristics(Spill-USE) explicitly skip\n+  \/\/ derived pointers and lastly fail to spill after reaching maximum\n+  \/\/ number of iterations. Lowering the default pressure threshold to\n+  \/\/ (_NO_SPECIAL_REG32_mask.Size() minus 1) forces CallNode to become\n+  \/\/ a high register pressure area of the code so that split_DEF can\n+  \/\/ generate DefinitionSpillCopy for the derived pointer.\n+  uint default_int_pressure_threshold = _NO_SPECIAL_REG32_mask.Size() - 1;\n+  return (INTPRESSURE == -1) ? default_int_pressure_threshold : INTPRESSURE;\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1774,3 +1774,4 @@\n-  \/\/ The following default threshold works best for LCM's register pressure\n-  \/\/ scheduling on x64.\n-  uint default_float_pressure_threshold = _FLOAT_REG_mask.Size() - 2;\n+  \/\/ After experiment around with different values, the following default threshold\n+  \/\/ works best for LCM's register pressure scheduling on x64.\n+  uint dec_count  = VM_Version::supports_evex() ? 4 : 2;\n+  uint default_float_pressure_threshold = _FLOAT_REG_mask.Size() - dec_count;\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"}]}