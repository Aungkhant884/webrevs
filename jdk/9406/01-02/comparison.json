{"files":[{"patch":"@@ -732,1 +732,0 @@\n-\n@@ -742,18 +741,3 @@\n-    \/\/ We now have a file name that converts to a valid integer\n-    \/\/ that could represent a process id.\n-    \/\/\n-    \/\/ On Linux, we first try to flock() on the file to check\n-    \/\/ for JVM processes in other containers that share the same\n-    \/\/ \/tmp directory as the current process. If it's already\n-    \/\/ locked by another process, then obviously it's not stale.\n-    \/\/\n-    \/\/ Otherwise, if this process id matches the current process id or\n-    \/\/ the process is not running, we treat it as a stale file and remove it.\n-    \/\/\n-    \/\/ Process liveness is detected by sending signal number 0 to\n-    \/\/ the process id (see kill(2)). If kill determines that the\n-    \/\/ process does not exist, then the file is removed.\n-    \/\/ If kill determines that that we don't have permission to\n-    \/\/ signal the process, then the file is assumed to\n-    \/\/ be stale and is removed because the files for such a\n-    \/\/ process should be in a different user specific directory.\n+#if defined(LINUX)\n+    \/\/ Special case on Linux, if multiple containers share the\n+    \/\/ same \/tmp directory:\n@@ -761,6 +745,6 @@\n-\n-    bool is_locked_by_another_process = false;\n- #if defined(LINUX)\n-    \/\/ The locking protocol works only with JVMs that have the JDK-8286030 fix.\n-    \/\/ If you are sharing the \/tmp difrectory among different containers, do not\n-    \/\/ use older JVMs that don't have this fix.\n+    \/\/ - All the JVMs must have the JDK-8286030 fix, or the behavior\n+    \/\/   is undefined.\n+    \/\/ - We cannot rely on the values of the pid, because it could\n+    \/\/   be a process in a different namespace. We must use the flock\n+    \/\/   protocol to determine if a live process is using this file.\n+    \/\/   See create_sharedmem_file().\n@@ -772,0 +756,1 @@\n+      errno = 0;\n@@ -774,0 +759,1 @@\n+\n@@ -777,12 +763,7 @@\n-      if (errno == EWOULDBLOCK) {\n-        \/\/ Another process holds the exclusive lock on this file.\n-        is_locked_by_another_process = true;\n-      } else {\n-        \/\/ Something wrong happened. Ignore the error and don't try to remove the\n-        \/\/ file.\n-        ::close(fd);\n-        continue;\n-      }\n-    } else {\n-      \/\/ I have successfully locked the file. No other process will try to write to\n-      \/\/ it, so I can safely remove it below.\n+      \/\/ Either another process holds the exclusive lock on this file, or\n+      \/\/ something wrong happened. Ignore the error and don't try to remove the\n+      \/\/ file.\n+      log_debug(perf, memops)(\"flock for stale file check failed for %s\/%s\", dirname, filename);\n+      ::close(fd);\n+      errno = 0;\n+      continue;\n@@ -790,2 +771,3 @@\n-    log_info(perf, memops)(\"is_locked_by_another_process %s\/%s = %s\", dirname, filename,\n-                            is_locked_by_another_process ? \"true\" : \"false\");\n+    \/\/ We are able to lock the file, but this file might have been created\n+    \/\/ by an older JVM that doesn't use the flock prototol, so we must do\n+    \/\/ the folowing checks (which are also done by older JVMs).\n@@ -794,6 +776,16 @@\n-    if (!is_locked_by_another_process) {\n-      if ((pid == os::current_process_id()) ||\n-          (kill(pid, 0) == OS_ERR && (errno == ESRCH || errno == EPERM))) {\n-        \/\/ kill() is needed to be compatible with older JVMs that don't do flock ...\n-        log_info(perf, memops)(\"Remove stale file %s\/%s\", dirname, filename);\n-        unlink(filename);\n+    \/\/ The following code assumes that pid must be in the same\n+    \/\/ namespace as the current process.\n+    bool stale = false;\n+\n+    if (pid == os::current_process_id()) {\n+      \/\/ The file was created by a terminated process that happened\n+      \/\/ to have the same pid as the current process.\n+      stale = true;\n+    } else if (kill(pid, 0) == OS_ERR) {\n+      if (errno == ESRCH) {\n+        \/\/ The target process does not exist.\n+        stale = true;\n+      } else if (errno == EPERM) {\n+        \/\/ The file was created by a terminated process that happened\n+        \/\/ to have the same pid as a process not owned by the current user.\n+        stale = true;\n@@ -803,0 +795,5 @@\n+    if (stale) {\n+      log_info(perf, memops)(\"Remove stale file %s\/%s\", dirname, filename);\n+      unlink(filename);\n+    }\n+\n@@ -804,2 +801,2 @@\n-    \/\/ LINUX: hold the lock to prevent other JVMs from using this file while we\n-    \/\/ are in the middle of deleting it.\n+    \/\/ Hold the lock until here to prevent other JVMs from using this file\n+    \/\/ while we are in the middle of deleting it.\n@@ -915,0 +912,4 @@\n+  \/\/\n+  \/\/ The locking protocol works only with other JVMs that have the JDK-8286030\n+  \/\/ fix. If you are sharing the \/tmp difrectory among different containers,\n+  \/\/ do not use older JVMs that don't have this fix, or the behavior is undefined.\n","filename":"src\/hotspot\/os\/posix\/perfMemory_posix.cpp","additions":48,"deletions":47,"binary":false,"changes":95,"status":"modified"}]}