{"files":[{"patch":"@@ -51,0 +51,4 @@\n+#if defined(LINUX)\n+# include <sys\/file.h>\n+#endif\n+\n@@ -79,12 +83,0 @@\n-\/\/ delete the PerfData memory region\n-\/\/\n-static void delete_standard_memory(char* addr, size_t size) {\n-\n-  \/\/ there are no persistent external resources to cleanup for standard\n-  \/\/ memory. since DestroyJavaVM does not support unloading of the JVM,\n-  \/\/ cleanup of the memory resource is not performed. The memory will be\n-  \/\/ reclaimed by the OS upon termination of the process.\n-  \/\/\n-  return;\n-}\n-\n@@ -710,0 +702,19 @@\n+static bool is_locked_by_another_process(const char* dirname, const char* filename, int& fd) {\n+  bool is_locked = false;\n+\n+#if defined(LINUX)\n+  fd = ::open(filename, O_RDONLY);\n+  if (fd >= 0) {\n+    is_locked = (flock(fd, LOCK_EX|LOCK_NB) != 0);\n+    \/\/ The locking protocol works only with JVMs that have the JDK-8286030 fix.\n+    \/\/ If you are sharing the \/tmp difrectory among different containers, do not\n+    \/\/ use older JVMs that don't have this fix.\n+    if (!is_locked) {\n+      ::close(fd);\n+    }\n+  }\n+  log_info(perf, memops)(\"is_locked %s\/%s (fd = %d) = %s\", dirname, filename, fd, is_locked ? \"true\" : \"false\");\n+#endif\n+\n+  return is_locked;\n+}\n@@ -711,1 +722,1 @@\n-\/\/ cleanup stale shared memory resources\n+\/\/ cleanup stale shared memory files\n@@ -715,4 +726,1 @@\n-\/\/ for files matching the pattern ^$[0-9]*$. For each file found, the\n-\/\/ process id is extracted from the file name and a test is run to\n-\/\/ determine if the process is alive. If the process is not alive,\n-\/\/ any stale file resources are removed.\n+\/\/ for files matching the pattern ^$[0-9]*$.\n@@ -720,1 +728,1 @@\n-static void cleanup_sharedmem_resources(const char* dirname) {\n+static void cleanup_sharedmem_files(const char* dirname) {\n@@ -730,7 +738,6 @@\n-  \/\/ for each entry in the directory that matches the expected file\n-  \/\/ name pattern, determine if the file resources are stale and if\n-  \/\/ so, remove the file resources. Note, instrumented HotSpot processes\n-  \/\/ for this user may start and\/or terminate during this search and\n-  \/\/ remove or create new files in this directory. The behavior of this\n-  \/\/ loop under these conditions is dependent upon the implementation of\n-  \/\/ opendir\/readdir.\n+  \/\/ For each entry in the directory that matches the expected file\n+  \/\/ name pattern, remove the file if it's determine to be stale\n+  \/\/ Note, instrumented HotSpot processes for this user may start and\/or\n+  \/\/ terminate during this search and remove or create new files in this\n+  \/\/ directory. The behavior of this loop under these conditions is dependent\n+  \/\/ upon the implementation of opendir\/readdir.\n@@ -755,4 +762,2 @@\n-    \/\/ we now have a file name that converts to a valid integer\n-    \/\/ that could represent a process id . if this process id\n-    \/\/ matches the current process id or the process is not running,\n-    \/\/ then remove the stale file resources.\n+    \/\/ We now have a file name that converts to a valid integer\n+    \/\/ that could represent a process id.\n@@ -760,6 +765,16 @@\n-    \/\/ process liveness is detected by sending signal number 0 to\n-    \/\/ the process id (see kill(2)). if kill determines that the\n-    \/\/ process does not exist, then the file resources are removed.\n-    \/\/ if kill determines that that we don't have permission to\n-    \/\/ signal the process, then the file resources are assumed to\n-    \/\/ be stale and are removed because the resources for such a\n+    \/\/ On Linux, we first try to flock() on the file to check\n+    \/\/ for JVM processes in other containers that share the same\n+    \/\/ \/tmp directory as the current process. See comments in\n+    \/\/ create_sharedmem_file() and is_locked_by_another_process().\n+    \/\/ If it's already locked by another process, then obviously it's\n+    \/\/ not stale\n+    \/\/\n+    \/\/ Otherwise, if this process id matches the current process id or\n+    \/\/ the process is not running, we treat it as a stale file and remove it.\n+    \/\/\n+    \/\/ Process liveness is detected by sending signal number 0 to\n+    \/\/ the process id (see kill(2)). If kill determines that the\n+    \/\/ process does not exist, then the file is removed.\n+    \/\/ If kill determines that that we don't have permission to\n+    \/\/ signal the process, then the file is assumed to\n+    \/\/ be stale and is removed because the files for such a\n@@ -768,2 +783,5 @@\n-    if ((pid == os::current_process_id()) ||\n-        (kill(pid, 0) == OS_ERR && (errno == ESRCH || errno == EPERM))) {\n+    int fd = -1;\n+    if (!is_locked_by_another_process(dirname, entry->d_name, fd)) {\n+      if ((pid == os::current_process_id()) ||\n+          (kill(pid, 0) == OS_ERR && (errno == ESRCH || errno == EPERM))) {\n+        \/\/ kill() is needed to be compatible with older JVMs that don't do flock ...\n@@ -771,0 +789,6 @@\n+      }\n+    }\n+    if (fd >= 0) {\n+      \/\/ LINUX: hold the lock to prevent other JVMs from using this file while we\n+      \/\/ are in the middle of deleting it.\n+      ::close(fd);\n@@ -817,1 +841,1 @@\n-\/\/ create the shared memory file resources\n+\/\/ create the shared memory file\n@@ -823,1 +847,1 @@\n-static int create_sharedmem_resources(const char* dirname, const char* filename, size_t size) {\n+static int create_sharedmem_file(const char* dirname, const char* filename, size_t size) {\n@@ -868,0 +892,18 @@\n+#if defined(LINUX)\n+  \/\/ On Linux, different containerized processes that share the same \/tmp\n+  \/\/ directory (e.g., with \"docker --volume ...\") may have the same pid and\n+  \/\/ try to use the same file. To avoid conflicts among such\n+  \/\/ processes, we allow only one of them (the winner of the flock() call)\n+  \/\/ to write to the file. All the other processes will give up and will\n+  \/\/ have perfdata disabled.\n+  \/\/\n+  \/\/ Note that the flock will be automatically given up when the winner\n+  \/\/ process exits.\n+  int n = flock(fd, LOCK_EX|LOCK_NB);\n+  if (n != 0) {\n+    log_warning(perf, memops)(\"Cannot use file %s\/%s because it is locked by another process\", dirname, filename);\n+    ::close(fd);\n+    return -1;\n+  }\n+#endif\n+\n@@ -984,1 +1026,1 @@\n-  cleanup_sharedmem_resources(dirname);\n+  cleanup_sharedmem_files(dirname);\n@@ -989,1 +1031,2 @@\n-  fd = create_sharedmem_resources(dirname, short_filename, size);\n+  log_info(perf, memops)(\"Trying to open %s\/%s\", dirname, short_filename);\n+  fd = create_sharedmem_file(dirname, short_filename, size);\n@@ -1022,0 +1065,2 @@\n+  log_info(perf, memops)(\"Successfully opened\");\n+\n@@ -1056,2 +1101,2 @@\n-  \/\/ cleanup the persistent shared memory resources. since DestroyJavaVM does\n-  \/\/ not support unloading of the JVM, unmapping of the memory resource is\n+  \/\/ Remove the shared memory file. Since DestroyJavaVM does\n+  \/\/ not support unloading of the JVM, unmapping of the memory region is\n@@ -1059,1 +1104,1 @@\n-  \/\/ the process. The backing store file is deleted from the file system.\n+  \/\/ the process.\n@@ -1235,4 +1280,1 @@\n-  if (PerfDisableSharedMem) {\n-    delete_standard_memory(start(), capacity());\n-  }\n-  else {\n+  if (!PerfDisableSharedMem) {\n","filename":"src\/hotspot\/os\/posix\/perfMemory_posix.cpp","additions":90,"deletions":48,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -0,0 +1,132 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+\/*\n+ * @test\n+ * @bug 8286030\n+ * @key cgroups\n+ * @summary Test for hsperfdata file name conflict when two containers share the same \/tmp directory\n+ * @requires docker.support\n+ * @library \/test\/lib\n+ * @build WaitForFlagFile\n+ * @run driver ShareTmpDir\n+ *\/\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.util.regex.Pattern;\n+import java.util.regex.Matcher;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.containers.docker.Common;\n+import jdk.test.lib.containers.docker.DockerRunOptions;\n+import jdk.test.lib.containers.docker.DockerTestUtils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jtreg.SkippedException;\n+\n+public class ShareTmpDir {\n+    private static final String imageName = Common.imageName(\"sharetmpdir\");\n+\n+    public static void main(String[] args) throws Exception {\n+        if (!DockerTestUtils.canTestDocker()) {\n+            return;\n+        }\n+\n+        DockerTestUtils.buildJdkContainerImage(imageName);\n+\n+        try {\n+            test();\n+        } finally {\n+            if (!DockerTestUtils.RETAIN_IMAGE_AFTER_TEST) {\n+                DockerTestUtils.removeDockerImage(imageName);\n+            }\n+        }\n+    }\n+\n+    static OutputAnalyzer out1, out2;\n+\n+    private static void test() throws Exception {\n+        File sharedtmpdir = new File(\"sharedtmpdir\");\n+        File flag = new File(sharedtmpdir, \"flag\");\n+        File started = new File(sharedtmpdir, \"started\");\n+        sharedtmpdir.mkdir();\n+        flag.delete();\n+        started.delete();\n+        DockerRunOptions opts = new DockerRunOptions(imageName, \"\/jdk\/bin\/java\", \"WaitForFlagFile\");\n+        opts.addDockerOpts(\"--volume\", Utils.TEST_CLASSES + \":\/test-classes\/\");\n+        opts.addDockerOpts(\"--volume\", sharedtmpdir.getAbsolutePath() + \":\/tmp\/\");\n+        opts.addJavaOpts(\"-Xlog:os+container=trace\", \"-Xlog:perf+memops\", \"-cp\", \"\/test-classes\/\");\n+\n+        Thread t1 = new Thread() {\n+                public void run() {\n+                    try { out1 = Common.run(opts); } catch (Exception e) { e.printStackTrace(); }\n+                }\n+            };\n+        t1.start();\n+\n+        Thread t2 = new Thread() {\n+                public void run() {\n+                    try { out2 = Common.run(opts); } catch (Exception e) { e.printStackTrace(); }\n+                }\n+            };\n+        t2.start();\n+\n+        while (!started.exists()) {\n+            System.out.println(\"Wait for at least one JVM to start\");\n+            Thread.sleep(1000);\n+        }\n+\n+        \/\/ Set the flag for the two JVMs to exit\n+        FileOutputStream fout = new FileOutputStream(flag);\n+        fout.close();\n+\n+        t1.join();\n+        t2.join();\n+\n+        Pattern pattern = Pattern.compile(\"perf,memops.*Trying to open (\/tmp\/hsperfdata_[a-z0-9]*\/[0-9]*)\");\n+        Matcher matcher;\n+\n+        matcher = pattern.matcher(out1.getStdout());\n+        Asserts.assertTrue(matcher.find());\n+        String file1 =  matcher.group(1);\n+\n+        matcher = pattern.matcher(out2.getStdout());\n+        Asserts.assertTrue(matcher.find());\n+        String file2 =  matcher.group(1);\n+\n+        Asserts.assertTrue(file1 != null);\n+        Asserts.assertTrue(file2 != null);\n+\n+        if (file1.equals(file2)) {\n+            \/\/ This should be the common case -- the first started process in a container should\n+            \/\/ have pid==1.\n+            \/\/ One of the two contains must fail to create the hsperf file.\n+            String s = \"Cannot use file \" + file1 + \" because it is locked by another process\";\n+            Asserts.assertTrue(out1.getStdout().contains(s) ||\n+                               out2.getStdout().contains(s));\n+        } else {\n+            throw new SkippedException(\"Java in the two containers don't have the same pid: \" + file1 + \" vs \" + file2);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/ShareTmpDir.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+\n+public class WaitForFlagFile {\n+    public static void main(String[] args) throws Exception {\n+        System.out.println(\"WaitForFlagFile: Entering\");\n+\n+        File started = new File(\"\/tmp\/started\");\n+        FileOutputStream fout = new FileOutputStream(started);\n+        fout.close();\n+\n+        File flag = new File(\"\/tmp\/flag\");\n+        while (!flag.exists()) {\n+            System.out.println(\"WaitForFlagFile: Waiting\");\n+            Thread.sleep(500);\n+        }\n+        System.out.println(\"WaitForFlagFile: Exiting\");\n+\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/WaitForFlagFile.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"}]}