{"files":[{"patch":"@@ -0,0 +1,210 @@\n+\/*\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jni.h\"\n+#include \"jni_util.h\"\n+#include \"jvm.h\"\n+#include \"jlong.h\"\n+#include \"java_nio_MappedMemoryUtils.h\"\n+#include <assert.h>\n+#include <sys\/mman.h>\n+#include <stddef.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <sys\/procfs.h>\n+#include <unistd.h>\n+\n+typedef char mincore_vec_t;\n+\n+static long calculate_number_of_pages_in_range(void* address, size_t len, size_t pagesize) {\n+    uintptr_t address_unaligned = (uintptr_t) address;\n+    uintptr_t address_aligned = address_unaligned & (~(pagesize - 1));\n+    size_t len2 = len + (address_unaligned - address_aligned);\n+    long numPages = (len2 + pagesize - 1) \/ pagesize;\n+    return numPages;\n+}\n+\n+JNIEXPORT jboolean JNICALL\n+Java_java_nio_MappedMemoryUtils_isLoaded0(JNIEnv *env, jobject obj, jlong address,\n+                                         jlong len, jlong numPages)\n+{\n+    jboolean loaded = JNI_TRUE;\n+    int result = 0;\n+    long i = 0;\n+    void *a = (void *) jlong_to_ptr(address);\n+    mincore_vec_t* vec = NULL;\n+\n+    \/* See JDK-8186665 *\/\n+    size_t pagesize = (size_t)sysconf(_SC_PAGESIZE);\n+    if ((long)pagesize == -1) {\n+        return JNI_FALSE;\n+    }\n+    numPages = (jlong) calculate_number_of_pages_in_range(a, len, pagesize);\n+\n+    \/* Include space for one sentinel byte at the end of the buffer\n+     * to catch overflows. *\/\n+    vec = (mincore_vec_t*) malloc(numPages + 1);\n+\n+    if (vec == NULL) {\n+        JNU_ThrowOutOfMemoryError(env, NULL);\n+        return JNI_FALSE;\n+    }\n+\n+    vec[numPages] = '\\x7f'; \/* Write sentinel. *\/\n+    result = mincore(a, (size_t)len, vec);\n+    assert(vec[numPages] == '\\x7f'); \/* Check sentinel. *\/\n+\n+    if (result == -1) {\n+        JNU_ThrowIOExceptionWithLastError(env, \"mincore failed\");\n+        free(vec);\n+        return JNI_FALSE;\n+    }\n+\n+    for (i=0; i<numPages; i++) {\n+        if (vec[i] == 0) {\n+            loaded = JNI_FALSE;\n+            break;\n+        }\n+    }\n+    free(vec);\n+    return loaded;\n+}\n+\n+\n+JNIEXPORT void JNICALL\n+Java_java_nio_MappedMemoryUtils_load0(JNIEnv *env, jobject obj, jlong address,\n+                                     jlong len)\n+{\n+    char *a = (char *)jlong_to_ptr(address);\n+    int result = madvise((caddr_t)a, (size_t)len, MADV_WILLNEED);\n+    if (result == -1) {\n+        JNU_ThrowIOExceptionWithMessageAndLastError(env, \"madvise with advise MADV_WILLNEED failed\");\n+    }\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_java_nio_MappedMemoryUtils_unload0(JNIEnv *env, jobject obj, jlong address,\n+                                     jlong len)\n+{\n+    char *a = (char *)jlong_to_ptr(address);\n+    int result = madvise((caddr_t)a, (size_t)len, MADV_DONTNEED);\n+    if (result == -1) {\n+        JNU_ThrowIOExceptionWithMessageAndLastError(env, \"madvise with advise MADV_DONTNEED failed\");\n+    }\n+}\n+\n+static void set_error_if_shared(JNIEnv* env, prmap_t* map_entry)\n+{\n+    if (map_entry->pr_mflags & MA_SHARED) {\n+        \/\/ MA_SHARED => MAP_SHARED => !MAP_PRIVATE. This error is valid and should be thrown.\n+        JNU_ThrowIOExceptionWithMessageAndLastError(env, \"msync with parameter MS_SYNC failed (MAP_SHARED)\");\n+        return;\n+    } else {\n+        \/\/ O.W. MAP_PRIVATE or no flag was specified and EINVAL is the expected behaviour.\n+        return;\n+    }\n+}\n+\n+static void check_proc_map_array(JNIEnv* env, FILE* proc_file, prmap_t* map_entry, void* end_address)\n+{\n+    while (!feof(proc_file)) {\n+        memset(map_entry, '\\0', sizeof(prmap_t));\n+        fread((char*)map_entry, sizeof(prmap_t), 1, proc_file);\n+        if (ferror(proc_file)) {\n+            JNU_ThrowIOExceptionWithMessageAndLastError(env,\n+                        \"msync with parameter MS_SYNC failed (could not read \/proc\/<pid>\/map)\");\n+            return;\n+        } else if (map_entry->pr_vaddr <= end_address &&\n+                   end_address <= map_entry->pr_vaddr + map_entry->pr_size) {\n+            set_error_if_shared(env, map_entry);\n+            return;\n+        }\n+    }\n+    JNU_ThrowIOExceptionWithMessageAndLastError(env,\n+                                    \"msync with parameter MS_SYNC failed (address not found)\");\n+}\n+\n+\/\/ '\/proc\/' + <pid> + '\/map' + '\\0'\n+#define PFNAME_LEN 32\n+static void check_aix_einval(JNIEnv* env, void* end_address)\n+{\n+    \/\/ If EINVAL is set for a mmap address on AIX, additional validation is required.\n+    \/\/ AIX will set EINVAL when msync is called on a mmap address that didn't receive MAP_SHARED\n+    \/\/ as a flag (since MAP_PRIVATE is the default).\n+    \/\/ https:\/\/www.ibm.com\/docs\/en\/aix\/7.2?topic=m-msync-subroutine\n+\n+    FILE* proc_file;\n+    {\n+        char* fname = (char*) malloc(sizeof(char) * PFNAME_LEN);\n+        pid_t the_pid = getpid();\n+        jio_snprintf(fname, PFNAME_LEN, \"\/proc\/%d\/map\", the_pid);\n+        proc_file = fopen(fname, \"r\");\n+        free(fname);\n+    }\n+    if (!proc_file) {\n+        JNU_ThrowIOExceptionWithMessageAndLastError(env,\n+                        \"msync with parameter MS_SYNC failed (could not open \/proc\/<pid>\/map)\");\n+        return;\n+    }\n+    {\n+        prmap_t* map_entry = (prmap_t*) malloc(sizeof(prmap_t));\n+        check_proc_map_array(env, proc_file, map_entry, end_address);\n+        free(map_entry);\n+    }\n+    fclose(proc_file);\n+}\n+\n+\/\/ Normally we would just let msync handle this, but since we'll be (potentially) ignoring\n+\/\/ the error code returned by msync, we check the args before the call instead.\n+static int validate_msync_address(size_t address)\n+{\n+    size_t pagesize = (size_t)sysconf(_SC_PAGESIZE);\n+    if (address % pagesize != 0) {\n+        errno = EINVAL;\n+        return -1;\n+    }\n+    return 0;\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_java_nio_MappedMemoryUtils_force0(JNIEnv *env, jobject obj, jobject fdo,\n+                                      jlong address, jlong len)\n+{\n+    void* a = (void *)jlong_to_ptr(address);\n+    if (validate_msync_address((size_t)a) > 0) {\n+        JNU_ThrowIOExceptionWithMessageAndLastError(env,\n+            \"msync with parameter MS_SYNC failed (arguments invalid)\");\n+        return;\n+    }\n+    int result = msync(a, (size_t)len, MS_SYNC);\n+    if (result == -1) {\n+        void* end_address = (void*)jlong_to_ptr(address + len);\n+        if (errno == EINVAL) {\n+            check_aix_einval(env, end_address);\n+            return;\n+        }\n+        JNU_ThrowIOExceptionWithMessageAndLastError(env, \"msync with parameter MS_SYNC failed\");\n+    }\n+}\n","filename":"src\/java.base\/aix\/native\/libnio\/MappedMemoryUtils.c","additions":210,"deletions":0,"binary":false,"changes":210,"status":"added"},{"patch":"@@ -36,4 +36,0 @@\n-#ifdef _AIX\n-#include <unistd.h>\n-#endif\n-\n@@ -47,10 +43,0 @@\n-#ifdef _AIX\n-static long calculate_number_of_pages_in_range(void* address, size_t len, size_t pagesize) {\n-    uintptr_t address_unaligned = (uintptr_t) address;\n-    uintptr_t address_aligned = address_unaligned & (~(pagesize - 1));\n-    size_t len2 = len + (address_unaligned - address_aligned);\n-    long numPages = (len2 + pagesize - 1) \/ pagesize;\n-    return numPages;\n-}\n-#endif\n-\n@@ -67,9 +53,0 @@\n-#ifdef _AIX\n-    \/* See JDK-8186665 *\/\n-    size_t pagesize = (size_t)sysconf(_SC_PAGESIZE);\n-    if ((long)pagesize == -1) {\n-        return JNI_FALSE;\n-    }\n-    numPages = (jlong) calculate_number_of_pages_in_range(a, len, pagesize);\n-#endif\n-\n","filename":"src\/java.base\/unix\/native\/libnio\/MappedMemoryUtils.c","additions":0,"deletions":23,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -790,5 +790,0 @@\n-\n-############################################################################\n-# java\/foreign\n-\n-java\/foreign\/TestByteBuffer.java 8309475 aix-ppc64\n","filename":"test\/jdk\/ProblemList.txt","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"}]}