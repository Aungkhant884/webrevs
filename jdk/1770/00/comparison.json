{"files":[{"patch":"@@ -33,0 +33,1 @@\n+#include \"app.h\"\n@@ -127,1 +128,1 @@\n-    return AppLauncher::launch(std::nothrow, launchApp);\n+    return app::launch(std::nothrow, launchApp);\n","filename":"src\/jdk.jpackage\/linux\/native\/applauncher\/LinuxLauncher.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"app.h\"\n@@ -77,1 +78,1 @@\n-        return AppLauncher::launch(std::nothrow, launchJvm);\n+        return app::launch(std::nothrow, launchJvm);\n@@ -82,1 +83,1 @@\n-    return AppLauncher::launch(std::nothrow, initJvmLauncher);\n+    return app::launch(std::nothrow, initJvmLauncher);\n","filename":"src\/jdk.jpackage\/macosx\/native\/applauncher\/MacLauncher.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -139,155 +139,0 @@\n-\n-\n-namespace {\n-const std::string* theLastErrorMsg = 0;\n-\n-NopLogAppender nopLogAppender;\n-\n-class StandardLogAppender : public LogAppender {\n-public:\n-    virtual void append(const LogEvent& v) {\n-        std::cerr << \"[\" << v.logLevel << \"] \"\n-            << v.fileName\n-            << \":\" << v.lineNum\n-            << \": \" << v.message\n-            << std::endl;\n-    }\n-} standardLogAppender;\n-\n-class LastErrorLogAppender : public LogAppender {\n-public:\n-    virtual void append(const LogEvent& v) {\n-        std::cerr << AppLauncher::lastErrorMsg() << std::endl;\n-    }\n-} lastErrorLogAppender;\n-} \/\/ namespace\n-\n-LogAppender& AppLauncher::defaultLastErrorLogAppender() {\n-    return lastErrorLogAppender;\n-}\n-\n-\n-std::string AppLauncher::lastErrorMsg() {\n-    if (theLastErrorMsg) {\n-        return *theLastErrorMsg;\n-    }\n-    return \"\";\n-}\n-\n-\n-bool AppLauncher::isWithLogging() {\n-    \/\/ If JPACKAGE_DEBUG environment variable is set to \"true\"\n-    \/\/ logging is enabled.\n-    return SysInfo::getEnvVariable(\n-            std::nothrow, _T(\"JPACKAGE_DEBUG\")) == _T(\"true\");\n-}\n-\n-\n-namespace {\n-\n-class ResetLastErrorMsgAtEndOfScope {\n-public:\n-    ~ResetLastErrorMsgAtEndOfScope() {\n-        JP_NO_THROW(theLastErrorMsg = 0);\n-    }\n-};\n-\n-class SetLoggerAtEndOfScope {\n-public:\n-    SetLoggerAtEndOfScope(\n-            std::unique_ptr<WithExtraLogAppender>& withLogAppender,\n-            LogAppender* lastErrorLogAppender):\n-                withLogAppender(withLogAppender),\n-                lastErrorLogAppender(lastErrorLogAppender) {\n-    }\n-\n-    ~SetLoggerAtEndOfScope() {\n-        JP_TRY;\n-        std::unique_ptr<WithExtraLogAppender> other(\n-                new WithExtraLogAppender(*lastErrorLogAppender));\n-        withLogAppender.swap(other);\n-        JP_CATCH_ALL;\n-    }\n-\n-private:\n-    std::unique_ptr<WithExtraLogAppender>& withLogAppender;\n-    LogAppender* lastErrorLogAppender;\n-};\n-\n-} \/\/ namespace\n-\n-int AppLauncher::launch(const std::nothrow_t&,\n-        LauncherFunc func, LogAppender* lastErrorLogAppender) {\n-    if (isWithLogging()) {\n-        Logger::defaultLogger().setAppender(standardLogAppender);\n-    } else {\n-        Logger::defaultLogger().setAppender(nopLogAppender);\n-    }\n-\n-    LOG_TRACE_FUNCTION();\n-\n-    if (!lastErrorLogAppender) {\n-        lastErrorLogAppender = &defaultLastErrorLogAppender();\n-    }\n-    std::unique_ptr<WithExtraLogAppender> withLogAppender;\n-    std::string errorMsg;\n-    const ResetLastErrorMsgAtEndOfScope resetLastErrorMsg;\n-\n-    JP_TRY;\n-\n-    \/\/ This will temporary change log appenders of the default logger\n-    \/\/ to save log messages in the default and additional log appenders.\n-    \/\/ Log appenders config of the default logger will be restored to\n-    \/\/ the original state at function exit automatically.\n-    const SetLoggerAtEndOfScope setLogger(withLogAppender, lastErrorLogAppender);\n-    func();\n-    return 0;\n-\n-    \/\/ The point of all these redefines is to save the last raw error message in\n-    \/\/ 'AppLauncher::theLastErrorMsg' variable.\n-    \/\/ By default error messages are saved in exception instances with the details\n-    \/\/ of error origin (source file, function name, line number).\n-    \/\/ We don't want these details in user error messages. However we still want to\n-    \/\/ save full information about the last error in the default log appender.\n-#undef JP_HANDLE_ERROR\n-#undef JP_HANDLE_UNKNOWN_ERROR\n-#undef JP_CATCH_EXCEPTIONS\n-#define JP_HANDLE_ERROR(e) \\\n-    do { \\\n-        errorMsg = (tstrings::any() << e.what()).str(); \\\n-        theLastErrorMsg = &errorMsg; \\\n-        reportError(JP_SOURCE_CODE_POS, e); \\\n-    } while(0)\n-#define JP_HANDLE_UNKNOWN_ERROR \\\n-    do { \\\n-        errorMsg = \"Unknown error\"; \\\n-        theLastErrorMsg = &errorMsg; \\\n-        reportUnknownError(JP_SOURCE_CODE_POS); \\\n-    } while(0)\n-#define JP_CATCH_EXCEPTIONS \\\n-    catch (const JpErrorBase& e) { \\\n-        errorMsg = (tstrings::any() << e.rawMessage()).str(); \\\n-        theLastErrorMsg = &errorMsg; \\\n-        try { \\\n-            throw; \\\n-        } catch (const std::runtime_error& e) { \\\n-            reportError(JP_SOURCE_CODE_POS, e); \\\n-        } \\\n-    } catch (const std::runtime_error& e) { \\\n-        errorMsg = lastCRTError(); \\\n-        theLastErrorMsg = &errorMsg; \\\n-        reportError(JP_SOURCE_CODE_POS, e); \\\n-    } \\\n-    JP_CATCH_UNKNOWN_EXCEPTION\n-\n-    JP_CATCH_ALL;\n-\n-#undef JP_HANDLE_ERROR\n-#undef JP_HANDLE_UNKNOWN_ERROR\n-#undef JP_CATCH_EXCEPTIONS\n-#define JP_HANDLE_ERROR(e)      JP_REPORT_ERROR(e)\n-#define JP_HANDLE_UNKNOWN_ERROR JP_REPORT_UNKNOWN_ERROR\n-#define JP_CATCH_EXCEPTIONS     JP_DEFAULT_CATCH_EXCEPTIONS\n-\n-    return 1;\n-}\n","filename":"src\/jdk.jpackage\/share\/native\/applauncher\/AppLauncher.cpp","additions":0,"deletions":155,"binary":false,"changes":155,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-class LogAppender;\n@@ -68,11 +67,0 @@\n-    static LogAppender& defaultLastErrorLogAppender();\n-\n-    static bool isWithLogging();\n-\n-    typedef void (*LauncherFunc) ();\n-\n-    static int launch(const std::nothrow_t&, LauncherFunc func,\n-            LogAppender* lastErrorLogAppender = 0);\n-\n-    static std::string lastErrorMsg();\n-\n","filename":"src\/jdk.jpackage\/share\/native\/applauncher\/AppLauncher.h","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,186 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <memory>\n+#include \"app.h\"\n+#include \"Log.h\"\n+#include \"SysInfo.h\"\n+#include \"ErrorHandling.h\"\n+\n+\n+namespace {\n+const std::string* theLastErrorMsg = 0;\n+\n+NopLogAppender nopLogAppender;\n+\n+class StandardLogAppender : public LogAppender {\n+public:\n+    virtual void append(const LogEvent& v) {\n+        std::cerr << \"[\" << v.logLevel << \"] \"\n+            << v.fileName\n+            << \":\" << v.lineNum\n+            << \": \" << v.message\n+            << std::endl;\n+    }\n+} standardLogAppender;\n+\n+class LastErrorLogAppender : public LogAppender {\n+public:\n+    virtual void append(const LogEvent& v) {\n+        std::cerr << app::lastErrorMsg() << std::endl;\n+    }\n+} lastErrorLogAppender;\n+\n+\n+class ResetLastErrorMsgAtEndOfScope {\n+public:\n+    ~ResetLastErrorMsgAtEndOfScope() {\n+        JP_NO_THROW(theLastErrorMsg = 0);\n+    }\n+};\n+\n+class SetLoggerAtEndOfScope {\n+public:\n+    SetLoggerAtEndOfScope(\n+            std::unique_ptr<WithExtraLogAppender>& withLogAppender,\n+            LogAppender* lastErrorLogAppender):\n+                withLogAppender(withLogAppender),\n+                lastErrorLogAppender(lastErrorLogAppender) {\n+    }\n+\n+    ~SetLoggerAtEndOfScope() {\n+        JP_TRY;\n+        std::unique_ptr<WithExtraLogAppender> other(\n+                new WithExtraLogAppender(*lastErrorLogAppender));\n+        withLogAppender.swap(other);\n+        JP_CATCH_ALL;\n+    }\n+\n+private:\n+    std::unique_ptr<WithExtraLogAppender>& withLogAppender;\n+    LogAppender* lastErrorLogAppender;\n+};\n+\n+} \/\/ namespace\n+\n+\n+namespace app {\n+LogAppender& defaultLastErrorLogAppender() {\n+    return lastErrorLogAppender;\n+}\n+\n+\n+std::string lastErrorMsg() {\n+    if (theLastErrorMsg) {\n+        return *theLastErrorMsg;\n+    }\n+    return \"\";\n+}\n+\n+\n+bool isWithLogging() {\n+    \/\/ If JPACKAGE_DEBUG environment variable is set to \"true\"\n+    \/\/ logging is enabled.\n+    return SysInfo::getEnvVariable(\n+            std::nothrow, _T(\"JPACKAGE_DEBUG\")) == _T(\"true\");\n+}\n+\n+\n+int launch(const std::nothrow_t&,\n+        LauncherFunc func, LogAppender* lastErrorLogAppender) {\n+    if (isWithLogging()) {\n+        Logger::defaultLogger().setAppender(standardLogAppender);\n+    } else {\n+        Logger::defaultLogger().setAppender(nopLogAppender);\n+    }\n+\n+    LOG_TRACE_FUNCTION();\n+\n+    if (!lastErrorLogAppender) {\n+        lastErrorLogAppender = &defaultLastErrorLogAppender();\n+    }\n+    std::unique_ptr<WithExtraLogAppender> withLogAppender;\n+    std::string errorMsg;\n+    const ResetLastErrorMsgAtEndOfScope resetLastErrorMsg;\n+\n+    JP_TRY;\n+\n+    \/\/ This will temporary change log appenders of the default logger\n+    \/\/ to save log messages in the default and additional log appenders.\n+    \/\/ Log appenders config of the default logger will be restored to\n+    \/\/ the original state at function exit automatically.\n+    const SetLoggerAtEndOfScope setLogger(withLogAppender, lastErrorLogAppender);\n+    func();\n+    return 0;\n+\n+    \/\/ The point of all these redefines is to save the last raw error message in\n+    \/\/ 'theLastErrorMsg' variable.\n+    \/\/ By default error messages are saved in exception instances with the details\n+    \/\/ of error origin (source file, function name, line number).\n+    \/\/ We don't want these details in user error messages. However we still want to\n+    \/\/ save full information about the last error in the default log appender.\n+#undef JP_HANDLE_ERROR\n+#undef JP_HANDLE_UNKNOWN_ERROR\n+#undef JP_CATCH_EXCEPTIONS\n+#define JP_HANDLE_ERROR(e) \\\n+    do { \\\n+        errorMsg = (tstrings::any() << e.what()).str(); \\\n+        theLastErrorMsg = &errorMsg; \\\n+        reportError(JP_SOURCE_CODE_POS, e); \\\n+    } while(0)\n+#define JP_HANDLE_UNKNOWN_ERROR \\\n+    do { \\\n+        errorMsg = \"Unknown error\"; \\\n+        theLastErrorMsg = &errorMsg; \\\n+        reportUnknownError(JP_SOURCE_CODE_POS); \\\n+    } while(0)\n+#define JP_CATCH_EXCEPTIONS \\\n+    catch (const JpErrorBase& e) { \\\n+        errorMsg = (tstrings::any() << e.rawMessage()).str(); \\\n+        theLastErrorMsg = &errorMsg; \\\n+        try { \\\n+            throw; \\\n+        } catch (const std::runtime_error& e) { \\\n+            reportError(JP_SOURCE_CODE_POS, e); \\\n+        } \\\n+    } catch (const std::runtime_error& e) { \\\n+        errorMsg = lastCRTError(); \\\n+        theLastErrorMsg = &errorMsg; \\\n+        reportError(JP_SOURCE_CODE_POS, e); \\\n+    } \\\n+    JP_CATCH_UNKNOWN_EXCEPTION\n+\n+    JP_CATCH_ALL;\n+\n+#undef JP_HANDLE_ERROR\n+#undef JP_HANDLE_UNKNOWN_ERROR\n+#undef JP_CATCH_EXCEPTIONS\n+#define JP_HANDLE_ERROR(e)      JP_REPORT_ERROR(e)\n+#define JP_HANDLE_UNKNOWN_ERROR JP_REPORT_UNKNOWN_ERROR\n+#define JP_CATCH_EXCEPTIONS     JP_DEFAULT_CATCH_EXCEPTIONS\n+\n+    return 1;\n+}\n+} \/\/ namespace app\n","filename":"src\/jdk.jpackage\/share\/native\/common\/app.cpp","additions":186,"deletions":0,"binary":false,"changes":186,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+#ifndef app_h\n+#define app_h\n+\n+#include \"tstrings.h\"\n+\n+class LogAppender;\n+\n+namespace app {\n+\n+LogAppender& defaultLastErrorLogAppender();\n+\n+bool isWithLogging();\n+\n+typedef void (*LauncherFunc) ();\n+\n+int launch(const std::nothrow_t&, LauncherFunc func,\n+        LogAppender* lastErrorLogAppender = 0);\n+\n+std::string lastErrorMsg();\n+\n+} \/\/ namespace app\n+\n+#endif \/\/ app_h\n","filename":"src\/jdk.jpackage\/share\/native\/common\/app.h","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -290,0 +290,31 @@\n+\/\/ converts utf16-encoded string to Windows encoded string (WIDECHAR or ACP)\n+tstring toWinString(const std::wstring& utf16) {\n+#if defined(_UNICODE) || defined(UNICODE)\n+    return utf16;\n+#else\n+    return toMultiByte(utf16, CP_ACP);\n+#endif\n+}\n+\n+\/\/ converts utf8-encoded string to Windows encoded string (WIDECHAR or ACP)\n+tstring toWinString(const std::string& utf8) {\n+    return toWinString(tstrings::toUtf16(utf8));\n+}\n+\n+\n+std::string winStringToUtf8(const std::wstring& winStr) {\n+    return toUtf8(winStr);\n+}\n+\n+std::string winStringToUtf8(const std::string& winStr) {\n+    return toUtf8(fromMultiByte(winStr, CP_ACP));\n+}\n+\n+std::wstring winStringToUtf16(const std::wstring& winStr) {\n+    return winStr;\n+}\n+\n+std::wstring winStringToUtf16(const std::string& winStr) {\n+    return fromMultiByte(winStr, CP_ACP);\n+}\n+\n","filename":"src\/jdk.jpackage\/share\/native\/common\/tstrings.cpp","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -146,0 +146,10 @@\n+    \/\/ conversion from windows-encoding string (WIDECHAR or ACP) to utf8\/utf16\n+    std::string winStringToUtf8(const std::wstring& winStr);\n+    std::string winStringToUtf8(const std::string& winStr);\n+    std::wstring winStringToUtf16(const std::wstring& winStr);\n+    std::wstring winStringToUtf16(const std::string& winStr);\n+\n+    \/\/ conversion from utf8\/utf16 to windows-encoding string (WIDECHAR or ACP)\n+    tstring toWinString(const std::wstring& utf16);\n+    tstring toWinString(const std::string& utf8);\n+\n@@ -156,0 +166,4 @@\n+    inline tstring fromUtf16(const std::wstring& utf16str) {\n+        return utf16str;\n+    }\n+\n","filename":"src\/jdk.jpackage\/share\/native\/common\/tstrings.h","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"WinApp.h\"\n@@ -173,1 +174,1 @@\n-    return AppLauncher::launch(std::nothrow, launchApp);\n+    return app::launch(std::nothrow, launchApp);\n@@ -178,97 +179,0 @@\n-namespace {\n-\n-class LastErrorGuiLogAppender : public LogAppender {\n-public:\n-    virtual void append(const LogEvent& v) {\n-        JP_TRY;\n-\n-        const std::wstring msg = (tstrings::any()\n-                << AppLauncher::lastErrorMsg()).wstr();\n-        MessageBox(0, msg.c_str(),\n-            FileUtils::basename(SysInfo::getProcessModulePath()).c_str(),\n-            MB_ICONERROR | MB_OK);\n-\n-        JP_CATCH_ALL;\n-    }\n-};\n-\n-\n-class Console {\n-public:\n-    Console() {\n-        if (!AttachConsole(ATTACH_PARENT_PROCESS)) {\n-            \/\/ Failed to connect to parent's console. Create our own.\n-            if (!AllocConsole()) {\n-                \/\/ We already have a console, no need to redirect std I\/O.\n-                return;\n-            }\n-        }\n-\n-        stdoutChannel = std::unique_ptr<Channel>(new Channel(stdout));\n-        stderrChannel = std::unique_ptr<Channel>(new Channel(stderr));\n-    }\n-\n-    struct FileCloser {\n-        typedef FILE* pointer;\n-\n-        void operator()(pointer h) {\n-            ::fclose(h);\n-        }\n-    };\n-\n-    typedef std::unique_ptr<\n-        FileCloser::pointer,\n-        FileCloser\n-    > UniqueFILEHandle;\n-\n-private:\n-    class Channel {\n-    public:\n-        Channel(FILE* stdFILEHandle): stdFILEHandle(stdFILEHandle) {\n-            const char* stdFileName = \"CONOUT$\";\n-            const char* openMode = \"w\";\n-            if (stdFILEHandle == stdin) {\n-                stdFileName = \"CONIN$\";\n-                openMode = \"r\";\n-            }\n-\n-            FILE* fp = 0;\n-            freopen_s(&fp, stdFileName, openMode, stdFILEHandle);\n-\n-            fileHandle = UniqueFILEHandle(fp);\n-\n-            std::ios_base::sync_with_stdio();\n-        }\n-\n-        virtual ~Channel() {\n-            JP_TRY;\n-\n-            FILE* fp = 0;\n-            fileHandle = UniqueFILEHandle(fp);\n-            std::ios_base::sync_with_stdio();\n-\n-            JP_CATCH_ALL;\n-        }\n-\n-    private:\n-        UniqueFILEHandle fileHandle;\n-        FILE *stdFILEHandle;\n-    };\n-\n-    std::unique_ptr<Channel> stdoutChannel;\n-    std::unique_ptr<Channel> stderrChannel;\n-};\n-\n-\n-void launchAppW() {\n-    std::unique_ptr<Console> console;\n-    if (AppLauncher::isWithLogging()) {\n-        console = std::unique_ptr<Console>(new Console());\n-    }\n-\n-    launchApp();\n-}\n-\n-} \/\/ namespace\n-\n-\n@@ -276,4 +180,1 @@\n-    LastErrorGuiLogAppender lastErrorLogAppender;\n-    TeeLogAppender logAppender(&AppLauncher::defaultLastErrorLogAppender(),\n-            &lastErrorLogAppender);\n-    return AppLauncher::launch(std::nothrow, launchAppW, &logAppender);\n+    return app::wlaunch(std::nothrow, launchApp);\n","filename":"src\/jdk.jpackage\/windows\/native\/applauncher\/WinLauncher.cpp","additions":3,"deletions":102,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef Flag_h\n+#define Flag_h\n+\n+\n+template <class T, class T2=int, int Id=0>\n+class Flag {\n+public:\n+    explicit Flag(T2 v): val(v) {}\n+\n+    bool operator == (const Flag& other) const {\n+        return val == other.val;\n+    }\n+    bool operator != (const Flag& other) const {\n+        return ! *this == other;\n+    }\n+\n+    T2 value() const {\n+        return val;\n+    }\n+\n+private:\n+    T2 val;\n+};\n+\n+#endif \/\/ #ifndef Flag_h\n","filename":"src\/jdk.jpackage\/windows\/native\/common\/Flag.h","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,137 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <algorithm>\n+#include <Objbase.h>\n+\n+#include \"Guid.h\"\n+#include \"ErrorHandling.h\"\n+\n+\n+#pragma comment(lib, \"ole32\")\n+\n+\n+Guid::Guid(const std::string& str) {\n+    *this = Guid(std::wstring(str.begin(), str.end()));\n+}\n+\n+\n+namespace {\n+\n+void initGuid(const std::wstring& str, GUID& v) {\n+    if (S_OK != IIDFromString(str.c_str(), &v)) {\n+        JP_THROW(tstrings::any() << \"IIDFromString(\" << str << \") failed\");\n+    }\n+}\n+\n+} \/\/namespace\n+\n+Guid::Guid(const std::wstring& str) {\n+    enum { StdGuildLength = 38 };\n+\n+    if ((str.size() == StdGuildLength && str.front() == L'{' && str.back() == L'}')) {\n+        initGuid(str, value);\n+        return;\n+    }\n+\n+    enum { BracketCount = 2 };\n+    enum { DashCount = 4 };\n+\n+    std::wstring buf(str);\n+\n+    if (str.size() >= (StdGuildLength - (BracketCount + DashCount))) {\n+        if (str.front() != L'{' && str.back() != L'}') {\n+            buf = L\"{\" + str + L\"}\";\n+        }\n+\n+        if (str.find(L'-') == std::wstring::npos) {\n+            const size_t positions[] = { 9, 14, 19, 24 };\n+            for (int i = 0; i < DashCount; ++i) {\n+                buf.insert(positions[i], 1, L'-');\n+            }\n+        }\n+\n+        if (buf.size() != StdGuildLength) {\n+            \/\/ Still no good, drop all tweaks.\n+            \/\/ Let parsing function fail on the original string.\n+            buf = str;\n+        }\n+    }\n+    initGuid(buf, value);\n+}\n+\n+\n+Guid::Guid(const GUID& v): value(v) {\n+}\n+\n+\n+Guid::Guid() {\n+    memset(&value, 0, sizeof(value));\n+}\n+\n+\n+bool Guid::operator < (const Guid& other) const {\n+    return toString() < other.toString();\n+}\n+\n+\n+bool Guid::operator == (const Guid& other) const {\n+    return IsEqualGUID(value, other.value) != FALSE;\n+}\n+\n+\n+tstring Guid::toString(int flags) const {\n+    wchar_t buffer[128];\n+    const int chars = StringFromGUID2(value, buffer, _countof(buffer));\n+    if (chars < 3 \/* strlen(\"{}\") + 1 *\/) {\n+        JP_THROW(\"StringFromGUID2() failed\");\n+    }\n+\n+    tstring reply(tstrings::fromUtf16(buffer));\n+\n+    if (flags & NoCurlyBrackets) {\n+        reply = reply.substr(1, reply.size() - 2);\n+    }\n+\n+    if (flags & NoDashes) {\n+        \/\/ Drop all '-'.\n+        reply = tstring(reply.begin(), std::remove(reply.begin(), reply.end(), _T('-')));\n+    }\n+\n+    if (flags & LowerCase) {\n+        reply = tstrings::toLower(reply);\n+    }\n+\n+    return reply;\n+}\n+\n+\n+Guid Guid::generate() {\n+    GUID guid = { 0 };\n+    if (S_OK != CoCreateGuid(&guid)) {\n+        JP_THROW(\"CoCreateGuid() failed\");\n+    }\n+    return Guid(guid);\n+}\n","filename":"src\/jdk.jpackage\/windows\/native\/common\/Guid.cpp","additions":137,"deletions":0,"binary":false,"changes":137,"status":"added"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef Guid_h\n+#define Guid_h\n+\n+#include <windows.h>\n+#include \"tstrings.h\"\n+\n+\n+class Guid {\n+public:\n+    Guid(const std::string& str);\n+    Guid(const std::wstring& str);\n+    Guid(const GUID& v);\n+    Guid();\n+\n+    \/\/ Comparison for equality is the only comparison operation that make\n+    \/\/ sense for GUIDs. However in order to use STL algorithms with\n+    \/\/ Guid class need to define less operator.\n+    bool operator < (const Guid& other) const;\n+    bool operator == (const Guid& other) const;\n+    bool operator != (const Guid& other) const {\n+        return ! (*this == other);\n+    }\n+\n+    enum StringifyFlags {\n+        WithCurlyBrackets = 0x0,\n+        WithDashes = 0x0,\n+        UpperCase = 0x0,\n+        StringifyDefaults = WithCurlyBrackets | UpperCase | WithDashes,\n+        NoCurlyBrackets = 0x1,\n+        NoDashes = 0x2,\n+        LowerCase = 0x4,\n+    };\n+\n+    tstring toString(int flags=StringifyDefaults) const;\n+\n+    \/**\n+     * Returns string GUID representation of this instance compatible with\n+     * Windows MSI API.\n+     *\/\n+    tstring toMsiString() const {\n+        return toString(UpperCase | WithCurlyBrackets | WithDashes);\n+    }\n+\n+    static Guid generate();\n+\n+private:\n+    GUID value;\n+};\n+\n+#endif \/\/ #ifndef Guid_h\n","filename":"src\/jdk.jpackage\/windows\/native\/common\/Guid.h","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -0,0 +1,282 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"MsiDb.h\"\n+#include \"FileUtils.h\"\n+#include \"WinFileUtils.h\"\n+#include \"Log.h\"\n+\n+\n+#pragma comment(lib, \"msi.lib\")\n+\n+\n+namespace msi {\n+\n+void closeDatabaseView(MSIHANDLE hView) {\n+    if (hView) {\n+        const auto status = MsiViewClose(hView);\n+        if (status != ERROR_SUCCESS) {\n+            LOG_WARNING(tstrings::any() << \"MsiViewClose(\"\n+                                << hView << \") failed with error=\" << status);\n+            return;\n+        }\n+        closeMSIHANDLE(hView);\n+    }\n+}\n+\n+\n+namespace {\n+UniqueMSIHANDLE openDatabase(const tstring& msiPath) {\n+    MSIHANDLE h = 0;\n+    const UINT status = MsiOpenDatabase(msiPath.c_str(),\n+                                                    MSIDBOPEN_READONLY, &h);\n+    if (status != ERROR_SUCCESS) {\n+        JP_THROW(Error(tstrings::any()\n+                                << \"MsiOpenDatabase(\" << msiPath\n+                                << \", MSIDBOPEN_READONLY) failed\", status));\n+    }\n+    return UniqueMSIHANDLE(h);\n+}\n+\n+} \/\/ namespace\n+\n+Database::Database(const Guid& productCode):\n+        msiPath(getProductInfo(productCode, INSTALLPROPERTY_LOCALPACKAGE)),\n+                                            dbHandle(openDatabase(msiPath)) {\n+}\n+\n+\n+Database::Database(const tstring& msiPath): msiPath(msiPath),\n+                                            dbHandle(openDatabase(msiPath)) {\n+}\n+\n+\n+tstring Database::getProperty(const tstring& name) const {\n+    \/\/ Query value of a property with the given name from 'Property' MSI table.\n+    const tstring sqlQuery = (tstrings::any()\n+                    << \"SELECT Value FROM Property WHERE Property = '\"\n+                    << name << \"'\").tstr();\n+\n+    DatabaseView view(*this, sqlQuery);\n+    const DatabaseRecord record(view);\n+\n+    \/\/ Data is stored in a record object. SQL query is constructed in a way\n+    \/\/ this record object contains a single field.\n+    \/\/ Verify record contains exactly one field.\n+    if (record.getFieldCount() != 1) {\n+        JP_THROW(Error(\n+                    tstrings::any() << \"record.getFieldCount(\" << msiPath\n+                                    << \", \" << sqlQuery\n+                                    << \") returned unexpected value\",\n+                    ERROR_SUCCESS));\n+    }\n+\n+    \/\/ Field identifier. They start with 1, not from 0.\n+    const unsigned field = 1;\n+    return record.getString(field);\n+}\n+\n+\n+tstring Database::getProperty(const std::nothrow_t&, const tstring& name) const {\n+    try {\n+        return getProperty(name);\n+    } catch (const NoMoreItemsError&) {\n+    }\n+    JP_CATCH_EXCEPTIONS;\n+    return tstring();\n+}\n+\n+\n+DatabaseRecord::DatabaseRecord(unsigned fieldCount) {\n+    MSIHANDLE h = MsiCreateRecord(fieldCount);\n+    if (!h) {\n+        JP_THROW(msi::Error(tstrings::any() << \"MsiCreateRecord(\"\n+                        << fieldCount << \") failed\", ERROR_FUNCTION_FAILED));\n+    }\n+    handle = UniqueMSIHANDLE(h);\n+}\n+\n+\n+DatabaseRecord& DatabaseRecord::operator=(const DatabaseRecord& other) {\n+    DatabaseRecord tmp(other);\n+    std::swap(handle, tmp.handle);\n+    return *this;\n+}\n+\n+\n+DatabaseRecord& DatabaseRecord::fetch(DatabaseView& view) {\n+    *this = view.fetch();\n+    return *this;\n+}\n+\n+\n+DatabaseRecord& DatabaseRecord::tryFetch(DatabaseView& view) {\n+    *this = view.tryFetch();\n+    return *this;\n+}\n+\n+\n+DatabaseRecord& DatabaseRecord::setString(unsigned idx, const tstring& v) {\n+    const UINT status = MsiRecordSetString(handle.get(), idx, v.c_str());\n+    if (status != ERROR_SUCCESS) {\n+        JP_THROW(Error(tstrings::any() << \"MsiRecordSetString(\" << idx\n+                                        << \", \" << v << \") failed\", status));\n+    }\n+    return *this;\n+}\n+\n+\n+DatabaseRecord& DatabaseRecord::setInteger(unsigned idx, int v) {\n+    const UINT status = MsiRecordSetInteger(handle.get(), idx, v);\n+    if (status != ERROR_SUCCESS) {\n+        JP_THROW(Error(tstrings::any() << \"MsiRecordSetInteger(\" << idx\n+                                        << \", \" << v << \") failed\", status));\n+    }\n+    return *this;\n+}\n+\n+\n+DatabaseRecord& DatabaseRecord::setStreamFromFile(unsigned idx,\n+                                                        const tstring& v) {\n+    const UINT status = MsiRecordSetStream(handle.get(), idx, v.c_str());\n+    if (status != ERROR_SUCCESS) {\n+        JP_THROW(Error(tstrings::any() << \"MsiRecordSetStream(\" << idx\n+                                        << \", \" << v << \") failed\", status));\n+    }\n+    return *this;\n+}\n+\n+\n+unsigned DatabaseRecord::getFieldCount() const {\n+    const unsigned reply = MsiRecordGetFieldCount(handle.get());\n+    if (int(reply) <= 0) {\n+        JP_THROW(Error(std::string(\"MsiRecordGetFieldCount() failed\"),\n+                                                    ERROR_FUNCTION_FAILED));\n+    }\n+    return reply;\n+}\n+\n+\n+int DatabaseRecord::getInteger(unsigned idx) const {\n+    int const reply = MsiRecordGetInteger(handle.get(), idx);\n+    if (reply == MSI_NULL_INTEGER) {\n+        JP_THROW(Error(tstrings::any() << \"MsiRecordGetInteger(\" << idx\n+                                        << \") failed\", ERROR_FUNCTION_FAILED));\n+    }\n+    return reply;\n+}\n+\n+\n+void DatabaseRecord::saveStreamToFile(unsigned idx,\n+                                                const tstring& path) const {\n+    enum { ReadStreamBufferBytes = 1024 * 1024 };\n+\n+    FileUtils::FileWriter writer(path);\n+\n+    std::vector<char> buffer(ReadStreamBufferBytes);\n+    DWORD bytes;\n+    do {\n+        bytes = ReadStreamBufferBytes;\n+        const UINT status = MsiRecordReadStream(handle.get(), UINT(idx),\n+                                                    buffer.data(), &bytes);\n+        if (status != ERROR_SUCCESS) {\n+            JP_THROW(Error(std::string(\"MsiRecordReadStream() failed\"),\n+                                                                    status));\n+        }\n+        writer.write(buffer.data(), bytes);\n+    } while(bytes == ReadStreamBufferBytes);\n+    writer.finalize();\n+}\n+\n+\n+DatabaseView::DatabaseView(const Database& db, const tstring& sqlQuery,\n+            const DatabaseRecord& queryParam): db(db), sqlQuery(sqlQuery) {\n+    MSIHANDLE h = 0;\n+\n+    \/\/ Create SQL query.\n+    for (const UINT status = MsiDatabaseOpenView(db.dbHandle.get(),\n+                            sqlQuery.c_str(), &h); status != ERROR_SUCCESS; ) {\n+        JP_THROW(Error(tstrings::any() << \"MsiDatabaseOpenView(\"\n+                                        << sqlQuery << \") failed\", status));\n+    }\n+\n+    UniqueMSIHANDLE tmp(h);\n+\n+    \/\/ Run SQL query.\n+    for (const UINT status = MsiViewExecute(h, queryParam.handle.get());\n+                                                status != ERROR_SUCCESS; ) {\n+        JP_THROW(Error(tstrings::any() << \"MsiViewExecute(\"\n+                                        << sqlQuery << \") failed\", status));\n+    }\n+\n+    \/\/ MsiViewClose should be called only after\n+    \/\/ successful MsiViewExecute() call.\n+    handle = UniqueDbView(h);\n+    tmp.release();\n+}\n+\n+\n+DatabaseRecord DatabaseView::fetch() {\n+    DatabaseRecord reply = tryFetch();\n+    if (reply.empty()) {\n+        JP_THROW(NoMoreItemsError(tstrings::any() << \"No more items in [\"\n+                                                << sqlQuery << \"] query\"));\n+    }\n+    return reply;\n+}\n+\n+\n+DatabaseRecord DatabaseView::tryFetch() {\n+    MSIHANDLE h = 0;\n+\n+    \/\/ Fetch data from executed SQL query.\n+    \/\/ Data is stored in a record object.\n+    for (const UINT status = MsiViewFetch(handle.get(), &h);\n+                                                status != ERROR_SUCCESS; ) {\n+        if (status == ERROR_NO_MORE_ITEMS) {\n+            return DatabaseRecord();\n+        }\n+\n+        JP_THROW(Error(tstrings::any() << \"MsiViewFetch(\" << sqlQuery\n+                                                    << \") failed\", status));\n+    }\n+\n+    DatabaseRecord reply;\n+    reply.handle = UniqueMSIHANDLE(h);\n+    return reply;\n+}\n+\n+\n+DatabaseView& DatabaseView::modify(const DatabaseRecord& record,\n+                                                        MSIMODIFY mode) {\n+    const UINT status = MsiViewModify(handle.get(), mode, record.handle.get());\n+    if (status != ERROR_SUCCESS) {\n+        JP_THROW(Error(tstrings::any() << \"MsiViewModify(mode=\" << mode\n+                                                    << \") failed\", status));\n+    }\n+    return *this;\n+}\n+\n+} \/\/ namespace msi\n","filename":"src\/jdk.jpackage\/windows\/native\/common\/MsiDb.cpp","additions":282,"deletions":0,"binary":false,"changes":282,"status":"added"},{"patch":"@@ -0,0 +1,194 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef MsiDb_h\n+#define MsiDb_h\n+\n+#include <windows.h>\n+#include <msiquery.h>\n+\n+#include \"MsiUtils.h\"\n+\n+\n+class Guid;\n+\n+\/**\n+ * Helpers to interact with MSI through database interface.\n+ *\/\n+\n+namespace msi {\n+void closeDatabaseView(MSIHANDLE h);\n+\n+struct MsiDbViewDeleter {\n+    typedef MSIHANDLE pointer;\n+\n+    void operator()(MSIHANDLE h) {\n+        closeDatabaseView(h);\n+    }\n+};\n+} \/\/ namespace msi\n+\n+\n+typedef std::unique_ptr<MSIHANDLE, msi::MsiDbViewDeleter> UniqueDbView;\n+\n+\n+namespace msi {\n+\n+class CA;\n+class DatabaseView;\n+class DatabaseRecord;\n+\n+\n+\/**\n+ * Opens product's database to query properties.\n+ * The database is opened in R\/O mode, i.e. it is safe to call this method\n+ * even if there is active install\/uninstall session. Unlike MsiOpenProduct(),\n+ * it never fails with 1618 ('Another installation is\n+ * already in progress') error code.\n+ *\n+ * Database can be opened from product code GUID, path to msi package or from\n+ * custom action.\n+ *\n+ * If opened from CA the database is opened in R\/W mode, however only adding\n+ * new temporary records is supported. It is forbidden to change data in\n+ * existing records.\n+ *\/\n+class Database {\n+public:\n+    \/**\n+     * Opens msi database from the given product code GUID.\n+     * Throws exception if fails.\n+     *\/\n+    explicit Database(const Guid& productCode);\n+\n+    \/**\n+     * Opens msi database from the given path to .msi file.\n+     * Throws exception if fails.\n+     *\/\n+    explicit Database(const tstring& msiPath);\n+\n+    \/**\n+     * Opens msi database from the given custom action.\n+     * Throws exception if fails.\n+     *\/\n+    explicit Database(const CA& ca);\n+\n+    \/**\n+     * Returns value of property with the given name.\n+     * Throws NoMoreItemsError if property with the given name doesn't exist\n+     * or Error if some error occurred.\n+     *\/\n+    tstring getProperty(const tstring& name) const;\n+\n+    \/**\n+     * Returns value of property with the given name.\n+     * Returns empty string if property with the given name doesn't exist or\n+     * if some error occurred.\n+     *\/\n+    tstring getProperty(const std::nothrow_t&, const tstring& name) const;\n+\n+    friend class DatabaseView;\n+\n+private:\n+    Database(const Database&);\n+    Database& operator=(const Database&);\n+private:\n+    const tstring msiPath;\n+    UniqueMSIHANDLE dbHandle;\n+};\n+\n+typedef std::unique_ptr<Database> DatabasePtr;\n+\n+\n+class DatabaseRecord {\n+public:\n+    DatabaseRecord(): handle(MSIHANDLE(0)) {\n+    }\n+\n+    DatabaseRecord(const DatabaseRecord& other): handle(MSIHANDLE(0)) {\n+        handle.swap(other.handle);\n+    }\n+\n+    DatabaseRecord& operator=(const DatabaseRecord& other);\n+\n+    friend class DatabaseView;\n+\n+    explicit DatabaseRecord(unsigned fieldCount);\n+\n+    explicit DatabaseRecord(DatabaseView& view) {\n+        fetch(view);\n+    }\n+\n+    DatabaseRecord& fetch(DatabaseView& view);\n+\n+    DatabaseRecord& tryFetch(DatabaseView& view);\n+\n+    DatabaseRecord& setString(unsigned idx, const tstring& v);\n+\n+    DatabaseRecord& setInteger(unsigned idx, int v);\n+\n+    DatabaseRecord& setStreamFromFile(unsigned idx, const tstring& v);\n+\n+    unsigned getFieldCount() const;\n+\n+    tstring getString(unsigned idx) const;\n+\n+    int getInteger(unsigned idx) const;\n+\n+    void saveStreamToFile(unsigned idx, const tstring& path) const;\n+\n+    bool empty() const {\n+        return 0 == handle.get();\n+    }\n+\n+    MSIHANDLE getHandle() const {\n+        return handle.get();\n+    }\n+\n+private:\n+    mutable UniqueMSIHANDLE handle;\n+};\n+\n+\n+class DatabaseView {\n+public:\n+    DatabaseView(const Database& db, const tstring& sqlQuery,\n+                        const DatabaseRecord& queryParam=DatabaseRecord());\n+\n+    DatabaseRecord fetch();\n+\n+    DatabaseRecord tryFetch();\n+\n+    DatabaseView& modify(const DatabaseRecord& record, MSIMODIFY mode);\n+\n+private:\n+    tstring sqlQuery;\n+    const Database& db;\n+    UniqueDbView handle;\n+};\n+\n+} \/\/ namespace msi\n+\n+#endif \/\/ #ifndef MsiDb_h\n","filename":"src\/jdk.jpackage\/windows\/native\/common\/MsiDb.h","additions":194,"deletions":0,"binary":false,"changes":194,"status":"added"},{"patch":"@@ -0,0 +1,420 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"MsiUtils.h\"\n+#include \"MsiDb.h\"\n+#include \"Resources.h\"\n+#include \"Dll.h\"\n+#include \"UniqueHandle.h\"\n+#include \"FileUtils.h\"\n+#include \"WinErrorHandling.h\"\n+\n+\n+#pragma comment(lib, \"msi.lib\")\n+\n+\n+namespace msi {\n+\n+namespace {\n+\n+template <class Func, class Arg1Type, class Arg2Type>\n+tstring getProperty(Func func, const LPCSTR funcName, Arg1Type arg1,\n+                                                            Arg2Type arg2) {\n+\n+    std::vector<TCHAR> buf(20);\n+    DWORD size = static_cast<DWORD>(buf.size());\n+\n+    UINT status = ERROR_MORE_DATA;\n+    while (ERROR_MORE_DATA ==\n+                    (status = func(arg1, arg2, &*buf.begin(), &size))) {\n+        buf.resize(buf.size() * 2);\n+        size = static_cast<DWORD>(buf.size());\n+    }\n+\n+    if (status != ERROR_SUCCESS) {\n+        JP_THROW(Error(tstrings::any() << funcName << \"(\" << arg1\n+                                    << \", \" << arg2 << \") failed\", status));\n+    }\n+    return tstring(buf.begin(), buf.begin() + size);\n+}\n+\n+template <class Func, class Arg1Type, class Arg2Type>\n+tstring getProperty(const std::nothrow_t&, Func func, const LPCSTR funcName,\n+                                                Arg1Type arg1, Arg2Type arg2) {\n+    try {\n+        return getProperty(func, funcName, arg1, arg2);\n+    } catch (const std::exception&) {\n+    }\n+    return tstring();\n+}\n+\n+\n+tstring escapePropertyValue(const tstring& value) {\n+    \/\/ Escape quotes as described in\n+    \/\/ http:\/\/msdn.microsoft.com\/en-us\/library\/aa367988.aspx\n+    tstring reply = tstrings::replace(value, _T(\"\\\"\"), _T(\"\\\"\\\"\"));\n+\n+    if (reply.empty()) {\n+        \/\/ MSDN: To clear a public property by using the command line,\n+        \/\/       set its value to an empty string.\n+        reply = _T(\"\\\"\\\"\");\n+    }\n+\n+    if (reply.find_first_of(_T(\" \\t\")) != tstring::npos) {\n+        reply = _T('\"') + reply + _T('\"');\n+    }\n+\n+    return reply;\n+}\n+\n+template <class It>\n+tstring stringifyProperties(It b, It e) {\n+    tostringstream buf;\n+    for (; b != e; ++b) {\n+        const tstring value = escapePropertyValue(b->second);\n+        buf << _T(\" \") << b->first << _T(\"=\") << value;\n+    }\n+\n+    tstring reply = tstrings::trim(buf.str());\n+    return reply;\n+}\n+\n+\n+class CallbackTrigger {\n+    CallbackTrigger(const CallbackTrigger&);\n+    CallbackTrigger& operator=(const CallbackTrigger&);\n+\n+    enum { MESSAGE_FILTER = 0xffffffff };\n+\n+    static int WINAPI adapter(LPVOID ctx, UINT type, LPCWSTR msg) {\n+        Callback* callback = reinterpret_cast<Callback*>(ctx);\n+        if (!callback) {\n+            return 0;\n+        }\n+\n+        JP_TRY;\n+\n+        \/\/ MSDN: Handling Progress Messages Using MsiSetExternalUI\n+        \/\/ http:\/\/msdn.microsoft.com\/en-us\/library\/aa368786(v=vs.85).aspx\n+        const INSTALLMESSAGE mt = (INSTALLMESSAGE)(0xFF000000 & type);\n+        const UINT flags = 0x00FFFFFF & type;\n+\n+        if (msg) {\n+            callback->notify(mt, flags, tstrings::toWinString(msg));\n+        }\n+\n+        JP_CATCH_ALL;\n+\n+        return 0;\n+    }\n+\n+public:\n+    explicit CallbackTrigger(Callback& cb) {\n+        MsiSetExternalUIW(adapter, DWORD(MESSAGE_FILTER), &cb);\n+    }\n+\n+    ~CallbackTrigger() {\n+        \/\/ Not restoring the original callback.\n+        \/\/ Just because the original message filter is unknown.\n+        MsiSetExternalUIW(0, 0, 0);\n+    }\n+};\n+\n+class LogFileTrigger {\n+    LogFileTrigger(const LogFileTrigger&);\n+    LogFileTrigger& operator=(const LogFileTrigger&);\n+\n+public:\n+    explicit LogFileTrigger(const tstring& path) {\n+        if (path.empty()) {\n+            MsiEnableLog(0, NULL, 0);\n+        } else {\n+            MsiEnableLog(INSTALLLOGMODE_VERBOSE, path.c_str(), 0);\n+        }\n+    }\n+\n+    ~LogFileTrigger() {\n+        \/\/ Disable log\n+        MsiEnableLog(0, NULL, 0);\n+    }\n+};\n+\n+struct SuppressUI: public OverrideUI {\n+    SuppressUI(): OverrideUI(withoutUI()) {\n+    }\n+};\n+\n+class StateImpl: public ActionData::State {\n+    const OverrideUI overrideUi;\n+    LogFileTrigger logGuard;\n+    std::unique_ptr<CallbackTrigger> callbackGuard;\n+\n+public:\n+    explicit StateImpl(const ActionData& data): overrideUi(data.uiMode),\n+                                                    logGuard(data.logFile) {\n+        if (data.callback) {\n+            callbackGuard = std::unique_ptr<CallbackTrigger>(\n+                                        new CallbackTrigger(*data.callback));\n+        }\n+    }\n+};\n+\n+} \/\/ namespace\n+\n+\n+void closeMSIHANDLE(MSIHANDLE h) {\n+    if (h) {\n+        const auto status = MsiCloseHandle(h);\n+        if (status != ERROR_SUCCESS) {\n+            LOG_WARNING(tstrings::any() << \"MsiCloseHandle(\"\n+                                << h << \") failed with error=\" << status);\n+        }\n+    }\n+}\n+\n+\n+\/\/ DatabaseRecord::getString() should live in MsiDb.cpp.\n+\/\/ However it can't access handy msi::getProperty() from that location.\n+tstring DatabaseRecord::getString(unsigned idx) const {\n+    return ::msi::getProperty(MsiRecordGetString, \"MsiRecordGetString\",\n+                                                    handle.get(), UINT(idx));\n+}\n+\n+\n+tstring getProductInfo(const Guid& productCode, const tstring& prop) {\n+    const tstring id = productCode.toMsiString();\n+    return getProperty(MsiGetProductInfo, \"MsiGetProductInfo\", id.c_str(),\n+                                                                prop.c_str());\n+}\n+\n+\n+tstring getProductInfo(const std::nothrow_t&, const Guid& productCode,\n+                                                        const tstring& prop) {\n+    const tstring id = productCode.toMsiString();\n+    return getProperty(std::nothrow, MsiGetProductInfo, \"MsiGetProductInfo\",\n+                                                    id.c_str(), prop.c_str());\n+}\n+\n+\n+tstring getPropertyFromCustomAction(MSIHANDLE h, const tstring& prop) {\n+    return getProperty(MsiGetProperty, \"MsiGetProperty\", h, prop.c_str());\n+}\n+\n+\n+tstring getPropertyFromCustomAction(const std::nothrow_t&, MSIHANDLE h,\n+                                                        const tstring& prop) {\n+    return getProperty(std::nothrow, MsiGetProperty,\"MsiGetProperty\", h,\n+                                                                prop.c_str());\n+}\n+\n+\n+namespace {\n+std::string makeMessage(const std::string& msg, UINT errorCode) {\n+    std::ostringstream err;\n+    err << \"MSI error [\" << errorCode << \"]\";\n+\n+    const std::wstring msimsg_dll = tstrings::winStringToUtf16(FileUtils::combinePath(\n+                                                SysInfo::getSystem32Dir(), _T(\"msimsg.dll\")));\n+\n+    \/\/ Convert MSI Error Code to Description String\n+    \/\/ http:\/\/msdn.microsoft.com\/en-us\/library\/aa370315(v=vs.85).aspx\n+    Dll::Handle lib(LoadLibraryExW(msimsg_dll.c_str(), NULL,\n+                                                LOAD_LIBRARY_AS_DATAFILE));\n+    if (!lib.get()) {\n+        JP_THROW(SysError(tstrings::any() << \"LoadLibraryExW(\" <<\n+                                            msimsg_dll << \") failed\", LoadLibraryExW));\n+    } else {\n+        tstring descr;\n+        try {\n+            descr = StringResource(errorCode, lib.get()).string();\n+        } catch (const std::exception &) {\n+            descr = _T(\"No description\");\n+        }\n+        err << \"(\" << descr << \")\";\n+    }\n+\n+    return joinErrorMessages(msg, err.str());\n+}\n+} \/\/ namespace\n+\n+Error::Error(const tstrings::any& msg, UINT ec): std::runtime_error(\n+                                makeMessage(msg.str(), ec)), errorCode(ec) {\n+}\n+\n+\n+Error::Error(const std::string& msg, UINT ec): std::runtime_error(\n+                                        makeMessage(msg, ec)), errorCode(ec) {\n+}\n+\n+\n+tstring ActionData::getCmdLineArgs() const {\n+    tstring raw = tstrings::trim(rawCmdLineArgs);\n+    tstring strProperties = stringifyProperties(props.begin(), props.end());\n+    if (!raw.empty() && !strProperties.empty()) {\n+        raw += _T(' ');\n+    }\n+    return raw + strProperties;\n+}\n+\n+\n+std::unique_ptr<ActionData::State> ActionData::createState() const {\n+    return std::unique_ptr<ActionData::State>(new StateImpl(*this));\n+}\n+\n+\n+namespace {\n+\n+bool isMsiStatusSuccess(const UINT status) {\n+    switch (status) {\n+    case ERROR_SUCCESS:\n+    case ERROR_SUCCESS_REBOOT_INITIATED:\n+    case ERROR_SUCCESS_REBOOT_REQUIRED:\n+        return true;\n+    default:\n+        break;\n+    }\n+    return false;\n+}\n+\n+ActionStatus handleMsiStatus(tstrings::any& logMsg, const UINT status) {\n+    if (!isMsiStatusSuccess(status)) {\n+        logMsg << \"failed [\" << status << \"]\";\n+        return ActionStatus(status, logMsg.str());\n+    }\n+\n+    logMsg << \"succeeded\";\n+    if (status != ERROR_SUCCESS) {\n+        logMsg << \" [\" << status << \"]\";\n+    }\n+    LOG_INFO(logMsg);\n+    return ActionStatus(status);\n+}\n+\n+} \/\/ namespace\n+\n+\n+ActionStatus::operator bool() const {\n+    return isMsiStatusSuccess(value);\n+}\n+\n+\n+void ActionStatus::throwIt() const {\n+    JP_THROW(Error(comment, value));\n+}\n+\n+\n+namespace {\n+template <class T>\n+ActionStatus msiAction(const T& obj, INSTALLSTATE state,\n+                                                const tstring& cmdLineArgs) {\n+    const tstring id = obj.getProductCode().toMsiString();\n+    const int level = INSTALLLEVEL_MAXIMUM;\n+    const UINT status = MsiConfigureProductEx(id.c_str(), level, state,\n+                                                        cmdLineArgs.c_str());\n+\n+    tstrings::any logMsg;\n+    logMsg  << \"MsiConfigureProductEx(\"\n+            << id\n+            << \", \" << level\n+            << \", \" << state\n+            << \", \" << cmdLineArgs\n+            << \") \";\n+\n+    return handleMsiStatus(logMsg, status);\n+}\n+} \/\/ namespace\n+\n+\n+template <>\n+ActionStatus action<uninstall>::execute(const uninstall& obj,\n+                                                const tstring& cmdLineArgs) {\n+    return msiAction(obj, INSTALLSTATE_ABSENT, cmdLineArgs);\n+}\n+\n+\n+template <>\n+ActionStatus action<update>::execute(const update& obj,\n+                                                const tstring& cmdLineArgs) {\n+    return msiAction(obj, INSTALLSTATE_LOCAL, cmdLineArgs);\n+}\n+\n+\n+template <>\n+ActionStatus action<install>::execute(const install& obj,\n+                                                const tstring& cmdLineArgs) {\n+    const tstring& msiPath = obj.getMsiPath();\n+\n+    const UINT status = MsiInstallProduct(msiPath.c_str(),\n+                                                        cmdLineArgs.c_str());\n+\n+    tstrings::any logMsg;\n+    logMsg  << \"MsiInstallProduct(\" << msiPath << \", \" << cmdLineArgs << \") \";\n+\n+    return handleMsiStatus(logMsg, status);\n+}\n+\n+\n+uninstall::uninstall() {\n+    \/\/ Uninstall default behavior is to never reboot.\n+    setProperty(_T(\"REBOOT\"), _T(\"ReallySuppress\"));\n+}\n+\n+\n+bool waitForInstallationCompletion(DWORD timeoutMS)\n+{\n+    \/\/ \"_MSIExecute\" mutex is used by the MSI installer service to prevent multiple installations at the same time\n+    \/\/ http:\/\/msdn.microsoft.com\/en-us\/library\/aa372909(VS.85).aspx\n+    LPCTSTR mutexName = _T(\"Global\\\\_MSIExecute\");\n+    UniqueHandle h(OpenMutex(SYNCHRONIZE, FALSE, mutexName));\n+    if (h.get() != NULL) {\n+        DWORD res = WaitForSingleObject(h.get(), timeoutMS);\n+        \/\/ log only if timeout != 0\n+        if (timeoutMS != 0) {\n+            LOG_INFO(tstrings::any() << \"finish waiting for mutex: \" << res);\n+        }\n+        if (res == WAIT_TIMEOUT) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+\n+bool isProductInstalled(const Guid& productCode) {\n+    \/\/ Query any property. If product exists, query should succeed.\n+    try {\n+        getProductInfo(productCode, INSTALLPROPERTY_VERSIONSTRING);\n+    } catch (const Error& e) {\n+        switch (e.getReason()) {\n+        case ERROR_UNKNOWN_PRODUCT:\n+        \/\/ if the application being queried is advertised and not installed.\n+        case ERROR_UNKNOWN_PROPERTY:\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+} \/\/ namespace msi\n","filename":"src\/jdk.jpackage\/windows\/native\/common\/MsiUtils.cpp","additions":420,"deletions":0,"binary":false,"changes":420,"status":"added"},{"patch":"@@ -0,0 +1,337 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef MsiUtils_h\n+#define MsiUtils_h\n+\n+#include <windows.h>\n+#include <Msi.h>\n+#include <iterator>\n+#include <stdexcept>\n+#include <new>\n+#include <map>\n+#include <memory>\n+\n+#include \"ErrorHandling.h\"\n+#include \"Toolbox.h\"\n+#include \"Guid.h\"\n+#include \"Flag.h\"\n+#include \"Log.h\"\n+\n+\n+namespace msi {\n+\n+void closeMSIHANDLE(MSIHANDLE h);\n+\n+struct MsiHandleDeleter {\n+    typedef MSIHANDLE pointer;\n+\n+    void operator()(MSIHANDLE h) {\n+        closeMSIHANDLE(h);\n+    }\n+};\n+\n+} \/\/ namespace msi\n+\n+typedef std::unique_ptr<MSIHANDLE, msi::MsiHandleDeleter> UniqueMSIHANDLE;\n+\n+namespace msi {\n+\n+tstring getProductInfo(const Guid& productCode, const tstring& prop);\n+\n+tstring getProductInfo(const std::nothrow_t&, const Guid& productCode,\n+                                                        const tstring& prop);\n+\n+tstring getPropertyFromCustomAction(MSIHANDLE h, const tstring& prop);\n+\n+tstring getPropertyFromCustomAction(const std::nothrow_t&, MSIHANDLE h,\n+                                                        const tstring& prop);\n+\n+inline tstring getPropertyFromDeferredCustomAction(MSIHANDLE h) {\n+    return getPropertyFromCustomAction(h, _T(\"CustomActionData\"));\n+}\n+\n+inline tstring getPropertyFromDeferredCustomAction(const std::nothrow_t&,\n+                                                              MSIHANDLE h) {\n+    return getPropertyFromCustomAction(std::nothrow, h,\n+                                                    _T(\"CustomActionData\"));\n+}\n+\n+\n+\/\/ UI level flags\n+class Tag {};\n+typedef Flag<Tag, INSTALLUILEVEL> UiModeFlag;\n+\n+inline UiModeFlag defaultUI() {\n+    return UiModeFlag(INSTALLUILEVEL_DEFAULT);\n+}\n+\n+inline UiModeFlag withoutUI() {\n+    return UiModeFlag(INSTALLUILEVEL_NONE);\n+}\n+\n+\n+\/\/ UI level control\n+struct OverrideUI {\n+    explicit OverrideUI(const UiModeFlag& uiMode):\n+        origMsiUiLevel(MsiSetInternalUI(uiMode.value(), 0)) {\n+    }\n+\n+    ~OverrideUI() {\n+        MsiSetInternalUI(origMsiUiLevel, 0);\n+    }\n+\n+private:\n+    const INSTALLUILEVEL origMsiUiLevel;\n+};\n+\n+struct SuppressUI: public OverrideUI {\n+    SuppressUI(): OverrideUI(withoutUI()) {\n+    }\n+};\n+\n+\n+\/\/ MSI Properties (KEY=VALUE)\n+typedef std::pair<tstring, tstring> Property;\n+typedef std::vector<Property> Properties;\n+\n+\n+\/\/ Callback for MSI functions\n+class Callback {\n+public:\n+    virtual ~Callback() {}\n+\n+    virtual void notify(INSTALLMESSAGE msgType, UINT flags,\n+                                                    const tstring& msg) = 0;\n+};\n+\n+\n+\/\/ MSI Error\n+class Error : public std::runtime_error {\n+public:\n+    Error(const tstrings::any& msg, UINT errorCode);\n+    Error(const std::string& msg, UINT errorCode);\n+    UINT getReason() const {\n+        return errorCode;\n+    }\n+private:\n+    UINT errorCode;\n+};\n+\n+\/\/ \"No more items\" exception\n+class NoMoreItemsError : public Error {\n+public:\n+    NoMoreItemsError(const tstrings::any& msg)\n+        : Error(msg, ERROR_NO_MORE_ITEMS)\n+    {}\n+};\n+\n+struct ActionData {\n+    typedef std::map<tstring, tstring> PropertyMap;\n+    PropertyMap props;\n+    tstring rawCmdLineArgs;\n+    UiModeFlag uiMode;\n+    Callback* callback;\n+    tstring logFile;\n+\n+    struct State {\n+        virtual ~State() {}\n+    };\n+\n+    std::unique_ptr<State> createState() const;\n+\n+    tstring getCmdLineArgs() const;\n+\n+    ActionData(): uiMode(withoutUI()), callback(0) {\n+    }\n+};\n+\n+\n+\/\/ MSI function execution status.\n+class ActionStatus {\n+public:\n+    ActionStatus(UINT value=ERROR_SUCCESS, const std::string& comment=\"\"):\n+                                            value(value), comment(comment) {\n+    }\n+\n+    explicit operator bool() const;\n+\n+    UINT getValue() const {\n+        return value;\n+    }\n+\n+    \/\/ Unconditionally converts this instance into msi::Error instance and\n+    \/\/ throws it.\n+    void throwIt() const;\n+\n+    const std::string& getComment() const {\n+        return comment;\n+    }\n+\n+private:\n+    std::string comment;\n+    UINT value;\n+};\n+\n+\n+\/\/ Some MSI action.\n+template <class T>\n+class action {\n+public:\n+    T& setProperty(const Property& prop) {\n+        data.props[prop.first] = prop.second;\n+        return *static_cast<T*>(this);\n+    }\n+\n+    T& setProperty(const tstring& name, const tstring& value) {\n+        return setProperty(Property(name, value));\n+    }\n+\n+    template <class It>\n+    T& setProperties(It b, It e) {\n+        std::copy(b, e, std::inserter(data.props, data.props.end()));\n+        return *static_cast<T*>(this);\n+    }\n+\n+    T& setRawCmdLineArgs(const tstring& value) {\n+        data.rawCmdLineArgs = value;\n+        return *static_cast<T*>(this);\n+    }\n+\n+    T& setUiMode(const UiModeFlag& flag) {\n+        data.uiMode = flag;\n+        return *static_cast<T*>(this);\n+    }\n+\n+    T& setLogFile(const tstring& path=tstring()) {\n+        data.logFile = path;\n+        return *static_cast<T*>(this);\n+    }\n+\n+    T& setCallback(Callback* cb) {\n+        data.callback = cb;\n+        return *static_cast<T*>(this);\n+    }\n+\n+    tstring getCmdLineArgs() const {\n+        return data.getCmdLineArgs();\n+    }\n+\n+    void operator () () const {\n+        std::unique_ptr<ActionData::State> state(data.createState());\n+        const ActionStatus status = execute(*static_cast<const T*>(this),\n+                                                        data.getCmdLineArgs());\n+        if (!status) {\n+            status.throwIt();\n+        }\n+    }\n+\n+    ActionStatus operator () (const std::nothrow_t&) const {\n+        JP_TRY;\n+        std::unique_ptr<ActionData::State> state(data.createState());\n+        const ActionStatus status = execute(*static_cast<const T*>(this),\n+                                                        data.getCmdLineArgs());\n+        if (!status) {\n+            LOG_ERROR(status.getComment());\n+        }\n+        return status;\n+        JP_CATCH_ALL;\n+        return ActionStatus(ERROR_INTERNAL_ERROR, \"Unknown error\");\n+    }\n+\n+private:\n+    static ActionStatus execute(const T& obj, const tstring& cmdLineArgs);\n+\n+    ActionData data;\n+};\n+\n+\n+\/\/ Function object to uninstall product with the given GUID\n+class uninstall: public action<uninstall> {\n+    Guid productCode;\n+public:\n+    uninstall();\n+\n+    uninstall& setProductCode(const Guid& pc) {\n+        productCode = pc;\n+        return *this;\n+    }\n+\n+    const Guid& getProductCode() const {\n+        return productCode;\n+    }\n+};\n+\n+\n+\/\/ Function object to update installed product with the given GUID\n+class update: public action<update> {\n+    Guid productCode;\n+public:\n+    update& setProductCode(const Guid& pc) {\n+        productCode = pc;\n+        return *this;\n+    }\n+\n+    const Guid& getProductCode() const {\n+        return productCode;\n+    }\n+};\n+\n+\n+\/\/ Function object to install package from the given msi file\n+class install: public action<install> {\n+    tstring msiPath;\n+public:\n+    install& setMsiPath(const tstring& path) {\n+        msiPath = path;\n+        return *this;\n+    }\n+\n+    const tstring& getMsiPath() const {\n+        return msiPath;\n+    }\n+};\n+\n+\n+\/\/ Checks if there is some installation is in progress and waits until it completes.\n+\/\/ returns true if there is no installation is in progress or the installation is completed.\n+\/\/ returns false if timeout exceeded.\n+\/\/ If timeout == 0, just checks that Windows Installer service is free.\n+bool waitForInstallationCompletion(DWORD timeoutMS);\n+\n+\/\/ Checks if there is some installation is in progress.\n+inline bool isInstallationInProgress() {\n+    return !waitForInstallationCompletion(0);\n+}\n+\n+\n+\/**\n+ * Returns true if product with the given product code is installed.\n+ *\/\n+bool isProductInstalled(const Guid& productCode);\n+\n+} \/\/ namespace msi\n+\n+#endif \/\/ #ifndef MsiUtils_h\n","filename":"src\/jdk.jpackage\/windows\/native\/common\/MsiUtils.h","additions":337,"deletions":0,"binary":false,"changes":337,"status":"added"},{"patch":"@@ -151,0 +151,18 @@\n+\n+\n+tstring StringResource::string() const\n+{\n+    DWORD size = 0;\n+    \/\/ string are stored as UNICODE\n+    LPWSTR resPtr = reinterpret_cast<LPWSTR>(impl.getPtr(size));\n+    \/\/ size is in bytes;\n+    return tstrings::fromUtf16(std::wstring(resPtr, size \/ sizeof(wchar_t)));\n+}\n+\n+tstring StringResource::string(const std::nothrow_t &, const tstring &defValue) const throw()\n+{\n+    JP_TRY;\n+    return string();\n+    JP_CATCH_ALL;\n+    return defValue;\n+}\n","filename":"src\/jdk.jpackage\/windows\/native\/common\/Resources.cpp","additions":18,"deletions":0,"binary":false,"changes":18,"previous_filename":"src\/jdk.jpackage\/windows\/native\/msiwrapper\/Resources.cpp","status":"renamed"},{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef RESOURCES_H\n+#define RESOURCES_H\n+\n+#include \"WinSysInfo.h\"\n+\n+\n+class StringResource;\n+\n+\/**\n+ * Classes for resource loading.\n+ * Common use cases:\n+ *  - check if resource is available and save it to file:\n+ *      Resource res(_T(\"MyResource\"), _T(\"CustomResourceType\"));\n+ *      if (res.available()) {\n+ *          res.saveToFile(_T(\"c:\\\\temp\\\\my_resource.bin\"));\n+ *      }\n+ *\n+ *  - get string resource:\n+ *      1) if the resource is not available, exception is thrown:\n+ *          tstring str = StringResource(MAKEINTRESOURCE(resID)).string();\n+ *\n+ *      2) nothrow method (returns default value if the resource is not available):\n+ *          a) returns empty string on error:\n+ *              tstring str = StringResource(MAKEINTRESOURCE(resID)).string(std::nothrow);\n+ *\n+ *          b) returns provided default value on error:\n+ *              tstring str = StringResource(MAKEINTRESOURCE(resID)).string(std::nothrow, _T(\"defaultValue\"));\n+ *\/\n+\n+class Resource {\n+public:\n+    \/\/ name and type can be specified by string id,\n+    \/\/ by integer id (RT_* constants or MAKEINTRESOURCE)\n+    Resource(LPCWSTR name, LPCWSTR type,\n+            HINSTANCE module = SysInfo::getCurrentModuleHandle());\n+    Resource(UINT id, LPCWSTR type,\n+            HINSTANCE module = SysInfo::getCurrentModuleHandle());\n+\n+    bool available() const;\n+\n+    \/\/ all this methods throw exception if the resource is not available\n+    unsigned size() const;\n+    \/\/ gets raw pointer to the resource data\n+    LPCVOID rawData() const;\n+\n+    \/\/ save the resource to a file\n+    void saveToFile(const std::wstring &filePath) const;\n+\n+    typedef std::vector<BYTE> ByteArray;\n+    \/\/ returns the resource as byte array\n+    ByteArray binary() const;\n+\n+    friend class StringResource;\n+\n+private:\n+    std::wstring nameStr;\n+    LPCWSTR namePtr;    \/\/ can be integer value or point to nameStr.c_str()\n+    std::wstring typeStr;\n+    LPCWSTR typePtr;    \/\/ can be integer value or point to nameStr.c_str()\n+    HINSTANCE instance;\n+\n+    void init(LPCWSTR name, LPCWSTR type, HINSTANCE module);\n+\n+    \/\/ generates error message\n+    std::string getErrMsg(const std::string &descr) const;\n+    HRSRC findResource() const;\n+    LPVOID getPtr(DWORD &size) const;\n+\n+private:\n+    \/\/ disable copying\n+    Resource(const Resource&);\n+    Resource& operator = (const Resource&);\n+};\n+\n+\n+\/\/ Note: string resources are returned utf16 or utf8 encoded.\n+\/\/ To get Windows-encoded string (utf16\/ACP) use tstrings::toWinString().\n+class StringResource {\n+public:\n+    \/\/ string resource is always identified by integer id\n+    StringResource(UINT resourceId, HINSTANCE moduleHandle = SysInfo::getCurrentModuleHandle())\n+        : impl(resourceId, RT_STRING, moduleHandle) {}\n+\n+    \/\/ returns the resource as string\n+    tstring string() const;\n+    \/\/ nothrow version (logs error)\n+    tstring string(const std::nothrow_t &, const tstring &defValue = tstring()) const throw();\n+\n+    bool available() const throw() {\n+        return impl.available();\n+    }\n+\n+    unsigned size() const {\n+        return impl.size();\n+    }\n+\n+    static tstring load(UINT resourceId,\n+                    HINSTANCE moduleHandle = SysInfo::getCurrentModuleHandle()) {\n+        return StringResource(resourceId, moduleHandle).string();\n+    }\n+\n+    static tstring load(const std::nothrow_t &, UINT resourceId,\n+                    HINSTANCE moduleHandle = SysInfo::getCurrentModuleHandle()) throw () {\n+        return StringResource(resourceId, moduleHandle).string(std::nothrow);\n+    }\n+\n+private:\n+    Resource impl;\n+};\n+\n+#endif \/\/ RESOURCES_H\n","filename":"src\/jdk.jpackage\/windows\/native\/common\/Resources.h","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"},{"patch":"@@ -0,0 +1,139 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <memory>\n+#include \"WinApp.h\"\n+#include \"Log.h\"\n+#include \"SysInfo.h\"\n+#include \"FileUtils.h\"\n+#include \"ErrorHandling.h\"\n+\n+\n+\/\/ MessageBox\n+#pragma comment(lib, \"user32\")\n+\n+\n+namespace {\n+\n+class LastErrorGuiLogAppender : public LogAppender {\n+public:\n+    virtual void append(const LogEvent& v) {\n+        JP_TRY;\n+\n+        const std::wstring msg = (tstrings::any()\n+                << app::lastErrorMsg()).wstr();\n+        MessageBox(0, msg.c_str(),\n+            FileUtils::basename(SysInfo::getProcessModulePath()).c_str(),\n+            MB_ICONERROR | MB_OK);\n+\n+        JP_CATCH_ALL;\n+    }\n+};\n+\n+\n+class Console {\n+public:\n+    Console() {\n+        if (!AttachConsole(ATTACH_PARENT_PROCESS)) {\n+            \/\/ Failed to connect to parent's console. Create our own.\n+            if (!AllocConsole()) {\n+                \/\/ We already have a console, no need to redirect std I\/O.\n+                return;\n+            }\n+        }\n+\n+        stdoutChannel = std::unique_ptr<Channel>(new Channel(stdout));\n+        stderrChannel = std::unique_ptr<Channel>(new Channel(stderr));\n+    }\n+\n+    struct FileCloser {\n+        typedef FILE* pointer;\n+\n+        void operator()(pointer h) {\n+            ::fclose(h);\n+        }\n+    };\n+\n+    typedef std::unique_ptr<\n+        FileCloser::pointer,\n+        FileCloser\n+    > UniqueFILEHandle;\n+\n+private:\n+    class Channel {\n+    public:\n+        Channel(FILE* stdFILEHandle): stdFILEHandle(stdFILEHandle) {\n+            const char* stdFileName = \"CONOUT$\";\n+            const char* openMode = \"w\";\n+            if (stdFILEHandle == stdin) {\n+                stdFileName = \"CONIN$\";\n+                openMode = \"r\";\n+            }\n+\n+            FILE* fp = 0;\n+            freopen_s(&fp, stdFileName, openMode, stdFILEHandle);\n+\n+            fileHandle = UniqueFILEHandle(fp);\n+\n+            std::ios_base::sync_with_stdio();\n+        }\n+\n+        virtual ~Channel() {\n+            JP_TRY;\n+\n+            FILE* fp = 0;\n+            fileHandle = UniqueFILEHandle(fp);\n+            std::ios_base::sync_with_stdio();\n+\n+            JP_CATCH_ALL;\n+        }\n+\n+    private:\n+        UniqueFILEHandle fileHandle;\n+        FILE *stdFILEHandle;\n+    };\n+\n+    std::unique_ptr<Channel> stdoutChannel;\n+    std::unique_ptr<Channel> stderrChannel;\n+};\n+\n+} \/\/ namespace\n+\n+\n+namespace app {\n+int wlaunch(const std::nothrow_t&, LauncherFunc func) {\n+    std::unique_ptr<Console> console;\n+    JP_TRY;\n+    if (app::isWithLogging()) {\n+        console = std::unique_ptr<Console>(new Console());\n+    }\n+    JP_CATCH_ALL;\n+\n+    LastErrorGuiLogAppender lastErrorLogAppender;\n+    TeeLogAppender logAppender(&app::defaultLastErrorLogAppender(),\n+            &lastErrorLogAppender);\n+    return app::launch(std::nothrow, func, &logAppender);\n+}\n+} \/\/ namespace app\n","filename":"src\/jdk.jpackage\/windows\/native\/common\/WinApp.cpp","additions":139,"deletions":0,"binary":false,"changes":139,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+#ifndef WinApp_h\n+#define WinApp_h\n+\n+#include \"app.h\"\n+\n+namespace app {\n+\n+int wlaunch(const std::nothrow_t&, LauncherFunc func);\n+\n+} \/\/ namespace app\n+\n+#endif \/\/ WinApp_h\n","filename":"src\/jdk.jpackage\/windows\/native\/common\/WinApp.h","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -29,0 +29,1 @@\n+#include <memory>\n","filename":"src\/jdk.jpackage\/windows\/native\/libjpackage\/JniUtils.h","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -96,1 +96,1 @@\n-     * Relaces resource configured in the given binary with the given data stream.\n+     * Replaces resource configured in the given binary with the given data stream.\n@@ -101,1 +101,1 @@\n-     * Relaces resource configured in the given binary with contents of\n+     * Replaces resource configured in the given binary with contents of\n","filename":"src\/jdk.jpackage\/windows\/native\/libjpackage\/ResourceEditor.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -199,1 +199,2 @@\n-        const std::wstring strLangId = (std::wstringstream()\n+        std::wstringstream strLangIdBuf;\n+        strLangIdBuf\n@@ -204,1 +205,2 @@\n-            << engLangId).str();\n+            << engLangId;\n+        const std::wstring strLangId = strLangIdBuf.str();\n","filename":"src\/jdk.jpackage\/windows\/native\/libjpackage\/VersionInfo.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"MsiDb.h\"\n@@ -143,0 +144,1 @@\n+        \/\/ Put msi file in resources.\n@@ -146,0 +148,7 @@\n+        \/\/ Get product code of the msi being embedded\n+        const Guid productCode = Guid(msi::Database(msiPath).getProperty(L\"ProductCode\"));\n+\n+        \/\/ Save product code in resources\n+        std::istringstream in(tstrings::toUtf8(productCode.toString()));\n+        ResourceEditor().id(L\"product_code\").type(RT_RCDATA).apply(lock, in);\n+\n","filename":"src\/jdk.jpackage\/windows\/native\/libjpackage\/jpackage.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+#include \"WinApp.h\"\n+#include \"Guid.h\"\n@@ -30,0 +32,1 @@\n+#include \"MsiUtils.h\"\n@@ -34,1 +37,0 @@\n-#include \"WinErrorHandling.h\"\n@@ -37,3 +39,18 @@\n-int __stdcall WinMain(HINSTANCE, HINSTANCE, LPSTR lpCmdLine, int nShowCmd)\n-{\n-    JP_TRY;\n+namespace {\n+int exitCode = -1;\n+\n+void launchApp() {\n+    const auto cmdline = SysInfo::getCommandArgs();\n+    if (std::find(cmdline.begin(), cmdline.end(), L\"uninstall\") != cmdline.end()) {\n+        \/\/ This is uninstall request.\n+\n+        \/\/ Get product code of the product to uninstall.\n+        const auto productCodeUtf8 = Resource(L\"product_code\", RT_RCDATA).binary();\n+        const Guid productCode = Guid(std::string(\n+                (const char*)productCodeUtf8.data(), productCodeUtf8.size()));\n+\n+        \/\/ Uninstall product.\n+        msi::uninstall().setProductCode(productCode)();\n+        exitCode = 0;\n+        return;\n+    }\n@@ -63,1 +80,3 @@\n-    return msiExecutor.execAndWaitForExit();\n+    exitCode = msiExecutor.execAndWaitForExit();\n+}\n+} \/\/ namespace\n@@ -65,1 +84,0 @@\n-    JP_CATCH_ALL;\n@@ -67,1 +85,3 @@\n-    return -1;\n+int __stdcall WinMain(HINSTANCE, HINSTANCE, LPSTR lpCmdLine, int nShowCmd) {\n+    app::wlaunch(std::nothrow, launchApp);\n+    return exitCode;\n","filename":"src\/jdk.jpackage\/windows\/native\/msiwrapper\/MsiWrapper.cpp","additions":27,"deletions":7,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -1,85 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#ifndef RESOURCES_H\n-#define RESOURCES_H\n-\n-#include \"WinSysInfo.h\"\n-\n-\n-\/**\n- * Classes for resource loading.\n- * Common use cases:\n- *  - check if resource is available and save it to file:\n- *      Resource res(_T(\"MyResource\"), _T(\"CustomResourceType\"));\n- *      if (res.available()) {\n- *          res.saveToFile(_T(\"c:\\\\temp\\\\my_resource.bin\"));\n- *      }\n- *\/\n-\n-class Resource {\n-public:\n-    \/\/ name and type can be specified by string id,\n-    \/\/ by integer id (RT_* constants or MAKEINTRESOURCE)\n-    Resource(LPCWSTR name, LPCWSTR type,\n-            HINSTANCE module = SysInfo::getCurrentModuleHandle());\n-    Resource(UINT id, LPCWSTR type,\n-            HINSTANCE module = SysInfo::getCurrentModuleHandle());\n-\n-    bool available() const;\n-\n-    \/\/ all this methods throw exception if the resource is not available\n-    unsigned size() const;\n-    \/\/ gets raw pointer to the resource data\n-    LPCVOID rawData() const;\n-\n-    \/\/ save the resource to a file\n-    void saveToFile(const std::wstring &filePath) const;\n-\n-    typedef std::vector<BYTE> ByteArray;\n-    \/\/ returns the resource as byte array\n-    ByteArray binary() const;\n-\n-private:\n-    std::wstring nameStr;\n-    LPCWSTR namePtr;    \/\/ can be integer value or point to nameStr.c_str()\n-    std::wstring typeStr;\n-    LPCWSTR typePtr;    \/\/ can be integer value or point to nameStr.c_str()\n-    HINSTANCE instance;\n-\n-    void init(LPCWSTR name, LPCWSTR type, HINSTANCE module);\n-\n-    \/\/ generates error message\n-    std::string getErrMsg(const std::string &descr) const;\n-    HRSRC findResource() const;\n-    LPVOID getPtr(DWORD &size) const;\n-\n-private:\n-    \/\/ disable copying\n-    Resource(const Resource&);\n-    Resource& operator = (const Resource&);\n-};\n-\n-#endif \/\/ RESOURCES_H\n","filename":"src\/jdk.jpackage\/windows\/native\/msiwrapper\/Resources.h","additions":0,"deletions":85,"binary":false,"changes":85,"status":"deleted"},{"patch":"@@ -117,7 +117,8 @@\n-        PackageHandlers exe = new PackageHandlers();\n-        \/\/ can't have install handler without also having uninstall handler\n-        \/\/ so following is commented out for now\n-        \/\/ exe.installHandler = cmd -> {\n-        \/\/     cmd.verifyIsOfType(PackageType.WIN_EXE);\n-        \/\/     new Executor().setExecutable(cmd.outputBundle()).execute();\n-        \/\/ };\n+        BiConsumer<JPackageCommand, Boolean> installExe = (cmd, install) -> {\n+            cmd.verifyIsOfType(PackageType.WIN_EXE);\n+            Executor exec = new Executor().setExecutable(cmd.outputBundle());\n+            if (!install) {\n+                exec.addArgument(\"uninstall\");\n+            }\n+            runMsiexecWithRetries(exec);\n+        };\n@@ -125,0 +126,3 @@\n+        PackageHandlers exe = new PackageHandlers();\n+        exe.installHandler = cmd -> installExe.accept(cmd, true);\n+        exe.uninstallHandler = cmd -> installExe.accept(cmd, false);\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/WindowsHelper.java","additions":11,"deletions":7,"binary":false,"changes":18,"status":"modified"}]}