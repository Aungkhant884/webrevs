{"files":[{"patch":"@@ -950,102 +950,13 @@\n-\n-    if (AvoidUnalignedAccesses) {\n-      if (str1_isL == str2_isL) { \/\/ LL or UU\n-        Label TAIL02, TAIL01, TAIL08;\n-        beqz(cnt2, TAIL08); \/\/ if cnt2 is zero then we need to copy one more aligned long\n-        \/\/ add to str1\/str2 what we have already read\n-        add(str1, str1, cnt2);\n-        add(str2, str2, cnt2);\n-        sub(cnt2, zr, cnt2);\n-        addi(cnt2, cnt2, 8); \/\/ now str1\/2 is aligned, cnt2 has amounts of bytes left to read\n-        \/\/ read 4 if needed, then read 2 if needed, then read 1 if needed and if isLL,\n-        \/\/ str1 is 8 bytes aligned now,\n-        test_bit(tmp1, cnt2, 2);\n-        beqz(tmp1, TAIL02);\n-        {\n-          lwu(tmp1, Address(str1));\n-          add(str1, str1, 4);\n-          lwu(tmp2, Address(str2));\n-          add(str2, str2, 4);\n-          bne(tmp1, tmp2, DIFFERENCE);\n-        }\n-        bind(TAIL02);\n-        \/\/ load two bytes if (address & 2) is not 0\n-        test_bit(tmp1, cnt2, 1);\n-        beqz(tmp1, isLL ? TAIL01 : DONE);\n-        {\n-          lhu(tmp1, Address(str1));\n-          add(str1, str1, 2);\n-          lhu(tmp2, Address(str2));\n-          add(str2, str2, 2);\n-          bne(tmp1, tmp2, DIFFERENCE);\n-        }\n-        if (isLL) {\n-          bind(TAIL01);\n-          \/\/ only if isLL, load one byte if address is odd\n-          test_bit(tmp1, cnt2, 0);\n-          beqz(tmp1, DONE);\n-          {\n-            lbu(tmp1, Address(str1));\n-            lbu(tmp2, Address(str2));\n-            bne(tmp1, tmp2, DIFFERENCE);\n-          }\n-        }\n-        j(DONE);\n-        bind(TAIL08);\n-        ld(tmp1, Address(str1));\n-        ld(tmp2, Address(str2));\n-        bne(tmp1, tmp2, DIFFERENCE);\n-        j(DONE);\n-      } else {\n-        \/\/  LU and UL\n-        Label TAIL08;\n-\n-        beqz(cnt2, TAIL08); \/\/ if cnt2 is zero then we need to copy one more aligned long\/word\n-\n-        add(str1, str1, cnt1);\n-        add(str2, str2, cnt2);\n-\n-        sub(cnt1, zr, cnt1);\n-        sub(cnt2, zr, cnt2);\n-\n-        addi(cnt1, cnt1, isLU ? 4 : 8);\n-        addi(cnt2, cnt2, isLU ? 8 : 4);\n-        \/\/ SHORT_STRING operates on characters, not bytes, set cnt2 to min(cnt1, cnt2)\n-        \/\/ but we already know cnt1=2*cnt2 for isLU or cnt2=2*cnt1 for isUL\n-        if(isLU) {\n-          mv(cnt2, cnt1);\n-        }\n-        j(SHORT_STRING);\n-\n-        bind(TAIL08);\n-        if(isLU) {\n-          lwu(tmp1, Address(str1));\n-          ld(tmp2, Address(str2));\n-          inflate_lo32(tmp3, tmp1);\n-          mv(tmp1, tmp3);\n-          bne(tmp1, tmp2, DIFFERENCE);\n-          j(DONE);\n-        } else {\n-          ld(tmp1, Address(str1));\n-          lwu(tmp2, Address(str2));\n-          inflate_lo32(tmp3, tmp2);\n-          mv(tmp2, tmp3);\n-          bne(tmp1, tmp2, DIFFERENCE);\n-          j(DONE);\n-        }\n-      }\n-    } else {\n-      if (str1_isL == str2_isL) { \/\/ LL or UU\n-        ld(tmp1, Address(str1));\n-        ld(tmp2, Address(str2));\n-      } else if (isLU) { \/\/ LU case\n-        lwu(tmp1, Address(str1));\n-        ld(tmp2, Address(str2));\n-        inflate_lo32(tmp3, tmp1);\n-        mv(tmp1, tmp3);\n-      } else { \/\/ UL case\n-        lwu(tmp2, Address(str2));\n-        ld(tmp1, Address(str1));\n-        inflate_lo32(tmp3, tmp2);\n-        mv(tmp2, tmp3);\n-      }\n+    if (str1_isL == str2_isL) { \/\/ LL or UU\n+      load_long_misaligned(tmp1, Address(str1), tmp3, isLL ? 1 : 2);\n+      load_long_misaligned(tmp2, Address(str2), tmp3, isLL ? 1 : 2);\n+    } else if (isLU) { \/\/ LU case\n+      load_int_misaligned(tmp1, Address(str1), tmp3, false);\n+      load_long_misaligned(tmp2, Address(str2), tmp3, 2);\n+      inflate_lo32(tmp3, tmp1);\n+      mv(tmp1, tmp3);\n+    } else { \/\/ UL case\n+      load_int_misaligned(tmp2, Address(str2), tmp3, false);\n+      load_long_misaligned(tmp1, Address(str1), tmp3, 2);\n+      inflate_lo32(tmp3, tmp2);\n+      mv(tmp2, tmp3);\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":13,"deletions":102,"binary":false,"changes":115,"status":"modified"}]}