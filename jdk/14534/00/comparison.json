{"files":[{"patch":"@@ -871,0 +871,2 @@\n+      \/\/ check if str1 and str2 is same pointer\n+      beq(str1, str2, DONE);\n@@ -873,1 +875,0 @@\n-      beq(str1, str2, DONE);\n@@ -916,0 +917,1 @@\n+    bne(tmp1, tmp2, DIFFERENCE);\n@@ -917,2 +919,0 @@\n-    xorr(tmp3, tmp1, tmp2);\n-    bnez(tmp3, DIFFERENCE);\n@@ -947,5 +947,2 @@\n-    bgez(cnt2, TAIL);\n-\n-    xorr(tmp3, tmp1, tmp2);\n-    beqz(tmp3, NEXT_WORD);\n-    j(DIFFERENCE);\n+    bne(tmp1, tmp2, DIFFERENCE);\n+    bltz(cnt2, NEXT_WORD);\n@@ -953,18 +950,102 @@\n-    xorr(tmp3, tmp1, tmp2);\n-    bnez(tmp3, DIFFERENCE);\n-    \/\/ Last longword.  In the case where length == 4 we compare the\n-    \/\/ same longword twice, but that's still faster than another\n-    \/\/ conditional branch.\n-    if (str1_isL == str2_isL) { \/\/ LL or UU\n-      ld(tmp1, Address(str1));\n-      ld(tmp2, Address(str2));\n-    } else if (isLU) { \/\/ LU case\n-      lwu(tmp1, Address(str1));\n-      ld(tmp2, Address(str2));\n-      inflate_lo32(tmp3, tmp1);\n-      mv(tmp1, tmp3);\n-    } else { \/\/ UL case\n-      lwu(tmp2, Address(str2));\n-      ld(tmp1, Address(str1));\n-      inflate_lo32(tmp3, tmp2);\n-      mv(tmp2, tmp3);\n+\n+    if (AvoidUnalignedAccesses) {\n+      if (str1_isL == str2_isL) { \/\/ LL or UU\n+        Label TAIL02, TAIL01, TAIL08;\n+        beqz(cnt2, TAIL08); \/\/ if cnt2 is zero then we need to copy one more aligned long\n+        \/\/ add to str1\/str2 what we have already read\n+        add(str1, str1, cnt2);\n+        add(str2, str2, cnt2);\n+        sub(cnt2, zr, cnt2);\n+        addi(cnt2, cnt2, 8); \/\/ now str1\/2 is aligned, cnt2 has amounts of bytes left to read\n+        \/\/ read 4 if needed, then read 2 if needed, then read 1 if needed and if isLL,\n+        \/\/ str1 is 8 bytes aligned now,\n+        test_bit(tmp1, cnt2, 2);\n+        beqz(tmp1, TAIL02);\n+        {\n+          lwu(tmp1, Address(str1));\n+          add(str1, str1, 4);\n+          lwu(tmp2, Address(str2));\n+          add(str2, str2, 4);\n+          bne(tmp1, tmp2, DIFFERENCE);\n+        }\n+        bind(TAIL02);\n+        \/\/ load two bytes if (address & 2) is not 0\n+        test_bit(tmp1, cnt2, 1);\n+        beqz(tmp1, isLL ? TAIL01 : DONE);\n+        {\n+          lhu(tmp1, Address(str1));\n+          add(str1, str1, 2);\n+          lhu(tmp2, Address(str2));\n+          add(str2, str2, 2);\n+          bne(tmp1, tmp2, DIFFERENCE);\n+        }\n+        if (isLL) {\n+          bind(TAIL01);\n+          \/\/ only if isLL, load one byte if address is odd\n+          test_bit(tmp1, cnt2, 0);\n+          beqz(tmp1, DONE);\n+          {\n+            lbu(tmp1, Address(str1));\n+            lbu(tmp2, Address(str2));\n+            bne(tmp1, tmp2, DIFFERENCE);\n+          }\n+        }\n+        j(DONE);\n+        bind(TAIL08);\n+        ld(tmp1, Address(str1));\n+        ld(tmp2, Address(str2));\n+        bne(tmp1, tmp2, DIFFERENCE);\n+        j(DONE);\n+      } else {\n+        \/\/  LU and UL\n+        Label TAIL08;\n+\n+        beqz(cnt2, TAIL08); \/\/ if cnt2 is zero then we need to copy one more aligned long\/word\n+\n+        add(str1, str1, cnt1);\n+        add(str2, str2, cnt2);\n+\n+        sub(cnt1, zr, cnt1);\n+        sub(cnt2, zr, cnt2);\n+\n+        addi(cnt1, cnt1, isLU ? 4 : 8);\n+        addi(cnt2, cnt2, isLU ? 8 : 4);\n+        \/\/ SHORT_STRING operates on characters, not bytes, set cnt2 to min(cnt1, cnt2)\n+        \/\/ but we already know cnt1=2*cnt2 for isLU or cnt2=2*cnt1 for isUL\n+        if(isLU) {\n+          mv(cnt2, cnt1);\n+        }\n+        j(SHORT_STRING);\n+\n+        bind(TAIL08);\n+        if(isLU) {\n+          lwu(tmp1, Address(str1));\n+          ld(tmp2, Address(str2));\n+          inflate_lo32(tmp3, tmp1);\n+          mv(tmp1, tmp3);\n+          bne(tmp1, tmp2, DIFFERENCE);\n+          j(DONE);\n+        } else {\n+          ld(tmp1, Address(str1));\n+          lwu(tmp2, Address(str2));\n+          inflate_lo32(tmp3, tmp2);\n+          mv(tmp2, tmp3);\n+          bne(tmp1, tmp2, DIFFERENCE);\n+          j(DONE);\n+        }\n+      }\n+    } else {\n+      if (str1_isL == str2_isL) { \/\/ LL or UU\n+        ld(tmp1, Address(str1));\n+        ld(tmp2, Address(str2));\n+      } else if (isLU) { \/\/ LU case\n+        lwu(tmp1, Address(str1));\n+        ld(tmp2, Address(str2));\n+        inflate_lo32(tmp3, tmp1);\n+        mv(tmp1, tmp3);\n+      } else { \/\/ UL case\n+        lwu(tmp2, Address(str2));\n+        ld(tmp1, Address(str1));\n+        inflate_lo32(tmp3, tmp2);\n+        mv(tmp2, tmp3);\n+      }\n@@ -973,2 +1054,1 @@\n-    xorr(tmp3, tmp1, tmp2);\n-    beqz(tmp3, DONE);\n+    beq(tmp1, tmp2, DONE);\n@@ -979,0 +1059,1 @@\n+    xorr(tmp3, tmp1, tmp2);\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":109,"deletions":28,"binary":false,"changes":137,"status":"modified"},{"patch":"@@ -3971,3 +3971,5 @@\n-  mv(tmp1, 0xFF);\n-  mv(Rd, zr);\n-  for (int i = 0; i <= 3; i++) {\n+  mv(tmp1, 0xFF000000); \/\/ first byte mask at lower word\n+  andr(Rd, Rs, tmp1);\n+  for (int i = 0; i < 2; i++) {\n+    slli(Rd, Rd, wordSize);\n+    srli(tmp1, tmp1, wordSize);\n@@ -3975,3 +3977,0 @@\n-    if (i) {\n-      slli(tmp2, tmp2, i * 8);\n-    }\n@@ -3979,3 +3978,0 @@\n-    if (i != 3) {\n-      slli(tmp1, tmp1, 8);\n-    }\n@@ -3983,0 +3979,3 @@\n+  slli(Rd, Rd, wordSize);\n+  andi(tmp2, Rs, 0xFF); \/\/ last byte mask at lower word\n+  orr(Rd, Rd, tmp2);\n@@ -3991,11 +3990,2 @@\n-\n-  mv(tmp1, 0xFF00000000);\n-  mv(Rd, zr);\n-  for (int i = 0; i <= 3; i++) {\n-    andr(tmp2, Rs, tmp1);\n-    orr(Rd, Rd, tmp2);\n-    srli(Rd, Rd, 8);\n-    if (i != 3) {\n-      slli(tmp1, tmp1, 8);\n-    }\n-  }\n+  srli(Rs, Rs, 32);   \/\/ only upper 32 bits are needed\n+  inflate_lo32(Rd, Rs, tmp1, tmp2);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":10,"deletions":20,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2313,3 +2313,2 @@\n-  void compare_string_8_x_LU(Register tmpL, Register tmpU, Label &DIFF1,\n-                              Label &DIFF2) {\n-    const Register strU = x12, curU = x7, strL = x29, tmp = x30;\n+  void compare_string_8_x_LU(Register tmpL, Register tmpU, Register strL, Register strU, Label& DIFF) {\n+    const Register tmp = x30;\n@@ -2317,1 +2316,1 @@\n-    __ addi(strL, strL, 8);\n+    __ addi(strL, strL, wordSize);\n@@ -2319,1 +2318,1 @@\n-    __ addi(strU, strU, 8);\n+    __ addi(strU, strU, wordSize);\n@@ -2322,2 +2321,2 @@\n-    __ xorr(tmp, curU, t0);\n-    __ bnez(tmp, DIFF2);\n+    __ xorr(tmp, tmpU, t0);\n+    __ bnez(tmp, DIFF);\n@@ -2325,2 +2324,2 @@\n-    __ ld(curU, Address(strU));\n-    __ addi(strU, strU, 8);\n+    __ ld(tmpU, Address(strU));\n+    __ addi(strU, strU, wordSize);\n@@ -2330,1 +2329,1 @@\n-    __ bnez(tmp, DIFF1);\n+    __ bnez(tmp, DIFF);\n@@ -2345,2 +2344,1 @@\n-    Label SMALL_LOOP, TAIL, TAIL_LOAD_16, LOAD_LAST, DIFF1, DIFF2,\n-          DONE, CALCULATE_DIFFERENCE;\n+    Label SMALL_LOOP, TAIL, LOAD_LAST, DIFF, DONE, CALCULATE_DIFFERENCE;\n@@ -2357,1 +2355,1 @@\n-    __ sub(cnt2, cnt2, 8); \/\/ Already loaded 4 symbols. Last 4 is special case.\n+    __ sub(cnt2, cnt2, wordSize \/ 2); \/\/ Already loaded 4 symbols\n@@ -2360,7 +2358,0 @@\n-    if (isLU) {\n-      __ add(str1, str1, cnt2);\n-      __ shadd(str2, cnt2, str2, t0, 1);\n-    } else {\n-      __ shadd(str1, cnt2, str1, t0, 1);\n-      __ add(str2, str2, cnt2);\n-    }\n@@ -2376,3 +2367,11 @@\n-    __ sub(tmp2, strL, cnt2); \/\/ strL pointer to load from\n-    __ slli(t0, cnt2, 1);\n-    __ sub(cnt1, strU, t0); \/\/ strU pointer to load from\n+    \/\/ make sure main loop is 8 byte-aligned, we should load another 4 bytes from strL\n+    __ beqz(cnt2, DONE);  \/\/ no characters left\n+    __ lwu(tmpL, Address(strL));\n+    __ addi(strL, strL, wordSize \/ 2);\n+    __ ld(tmpU, Address(strU));\n+    __ addi(strU, strU, wordSize);\n+    __ inflate_lo32(tmp3, tmpL);\n+    __ mv(tmpL, tmp3);\n+    __ xorr(tmp3, tmpU, tmpL);\n+    __ bnez(tmp3, CALCULATE_DIFFERENCE);\n+    __ addi(cnt2, cnt2, -wordSize \/ 2);\n@@ -2380,4 +2379,3 @@\n-    __ ld(tmp4, Address(cnt1));\n-    __ addi(cnt1, cnt1, 8);\n-    __ beqz(cnt2, LOAD_LAST); \/\/ no characters left except last load\n-    __ sub(cnt2, cnt2, 16);\n+    __ beqz(cnt2, DONE);  \/\/ no character left\n+    \/\/ we are now 8-bytes aligned on strL\n+    __ sub(cnt2, cnt2, wordSize * 2);\n@@ -2386,3 +2384,3 @@\n-      __ sub(cnt2, cnt2, 16);\n-      compare_string_8_x_LU(tmpL, tmpU, DIFF1, DIFF2);\n-      compare_string_8_x_LU(tmpL, tmpU, DIFF1, DIFF2);\n+      __ sub(cnt2, cnt2, wordSize * 2);\n+      compare_string_8_x_LU(tmpL, tmpU, strL, strU, DIFF);\n+      compare_string_8_x_LU(tmpL, tmpU, strL, strU, DIFF);\n@@ -2390,15 +2388,65 @@\n-      __ addi(t0, cnt2, 16);\n-      __ beqz(t0, LOAD_LAST);\n-    __ bind(TAIL); \/\/ 1..15 characters left until last load (last 4 characters)\n-      \/\/ Address of 8 bytes before last 4 characters in UTF-16 string\n-      __ shadd(cnt1, cnt2, cnt1, t0, 1);\n-      \/\/ Address of 16 bytes before last 4 characters in Latin1 string\n-      __ add(tmp2, tmp2, cnt2);\n-      __ ld(tmp4, Address(cnt1, -8));\n-      \/\/ last 16 characters before last load\n-      compare_string_8_x_LU(tmpL, tmpU, DIFF1, DIFF2);\n-      compare_string_8_x_LU(tmpL, tmpU, DIFF1, DIFF2);\n-      __ j(LOAD_LAST);\n-    __ bind(DIFF2);\n-      __ mv(tmpU, tmp4);\n-    __ bind(DIFF1);\n+      __ addi(t0, cnt2, wordSize * 2);\n+      __ beqz(t0, DONE);\n+    __ bind(TAIL);  \/\/ 1..15 characters left\n+    if (AvoidUnalignedAccesses) {\n+      \/\/ Aligned access. Load bytes in portions - 4, 2, 1.\n+      Label LOAD_LAST, WORD_CMP, TAIL01, TAIL02;\n+\n+      __ addi(t0, cnt2, wordSize);\n+      __ addi(cnt2, cnt2, wordSize*2); \/\/ amount of characters left to process\n+      __ bltz(t0, LOAD_LAST);\n+      \/\/ remaining characters are greater than or equals to 8, we can do one compare_string_8_x_LU\n+      compare_string_8_x_LU(tmpL, tmpU, strL, strU, DIFF);\n+      __ addi(cnt2, cnt2, -wordSize);\n+      __ beqz(cnt2, DONE);  \/\/ no character left\n+      __ bind(LOAD_LAST);   \/\/ cnt2 = 1..7 characters left\n+      \/\/ load four bytes if (cnt2 & 4) is not 0\n+      __ test_bit(t0, cnt2, 2);\n+      __ beqz(t0, TAIL02);\n+      {\n+        __ lwu(tmpL, Address(strL));\n+        __ addi(strL, strL, wordSize \/ 2);\n+        __ ld(tmpU, Address(strU));\n+        __ addi(strU, strU, wordSize);\n+        __ inflate_lo32(tmp3, tmpL);\n+        __ mv(tmpL, tmp3);\n+        __ xorr(tmp3, tmpU, tmpL);\n+        __ bnez(tmp3, CALCULATE_DIFFERENCE);\n+        __ addi(cnt2, cnt2, -wordSize \/ 2);\n+      }\n+      __ bind(TAIL02);\n+      \/\/ load two bytes if (cnt2 & 2) is not 0\n+      __ test_bit(t0, cnt2, 1);\n+      __ beqz(t0, TAIL01);\n+      {\n+        __ lhu(tmpL, Address(strL));\n+        __ addi(strL, strL, wordSize \/ 4);\n+        __ lwu(tmpU, Address(strU));\n+        __ addi(strU, strU, wordSize \/ 2);\n+        __ inflate_lo32(tmp3, tmpL);\n+        __ mv(tmpL, tmp3);\n+        __ xorr(tmp3, tmpU, tmpL);\n+        __ bnez(tmp3, CALCULATE_DIFFERENCE);\n+        __ addi(cnt2, cnt2, -wordSize \/ 4);\n+      }\n+      __ bind(TAIL01);\n+      \/\/ load one byte if anything left in cnt2\n+      __ beqz(cnt2, DONE);\n+      {\n+        __ lbu(tmpL, Address(strL)); \/\/ when only one byte left - no need to inflate\n+        __ lhu(tmpU, Address(strU));\n+        __ xorr(tmp3, tmpU, tmpL);\n+        __ bnez(tmp3, CALCULATE_DIFFERENCE);\n+      }\n+      __ j(DONE); \/\/ no character left\n+    } else {\n+      \/\/ Unaligned accesses. Load from non-byte aligned address.\n+      __ slli(t0, cnt2, 1);     \/\/ now in bytes\n+      __ add(strU, strU, t0);   \/\/ Address of last 8 bytes in UTF-16 string\n+      __ add(strL, strL, cnt2); \/\/ Address of last 16 bytes in Latin1 string\n+      \/\/ last 16 characters\n+      compare_string_8_x_LU(tmpL, tmpU, strL, strU, DIFF);\n+      compare_string_8_x_LU(tmpL, tmpU, strL, strU, DIFF);\n+      __ j(DONE);\n+    }\n+    __ bind(DIFF);\n@@ -2406,10 +2454,0 @@\n-      __ j(CALCULATE_DIFFERENCE);\n-    __ bind(LOAD_LAST);\n-      \/\/ Last 4 UTF-16 characters are already pre-loaded into tmp4 by compare_string_8_x_LU.\n-      \/\/ No need to load it again\n-      __ mv(tmpU, tmp4);\n-      __ ld(tmpL, Address(strL));\n-      __ inflate_lo32(tmp3, tmpL);\n-      __ mv(tmpL, tmp3);\n-      __ xorr(tmp3, tmpU, tmpL);\n-      __ beqz(tmp3, DONE);\n@@ -2532,0 +2570,1 @@\n+      __ beqz(cnt2, LAST_CHECK_AND_LENGTH_DIFF);\n@@ -2540,1 +2579,1 @@\n-      __ ld(tmp5, Address(str1));\n+      __ load_long_misaligned(tmp5, Address(str1), tmp3, isLL ? 1 : 2);\n@@ -2542,1 +2581,1 @@\n-      __ ld(cnt1, Address(str2));\n+      __ load_long_misaligned(cnt1, Address(str2), tmp3, isLL ? 1 : 2);\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":96,"deletions":57,"binary":false,"changes":153,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @requires os.arch==\"aarch64\"\n+ * @requires os.arch==\"aarch64\" | os.arch==\"riscv64\"\n@@ -33,1 +33,1 @@\n- *          Input parameters for this test are set according to Aarch64\n+ *          Input parameters for this test are set according to Aarch64\/RISC-V\n@@ -36,1 +36,1 @@\n- *          16, 32, 64 -characters loops for length >= 72. Code is also affected\n+ *          16, 32, 64 -characters loops for length >= 72. Aarch64 Code is also affected\n@@ -38,3 +38,3 @@\n- * @run main\/othervm -XX:SoftwarePrefetchHintDistance=192 compiler.intrinsics.string.TestStringCompareToDifferentLength 4 2 5 10 13 17 20 23 24 25 71 72 73 88 90 192 193 208 209\n- * @run main\/othervm -XX:SoftwarePrefetchHintDistance=16 compiler.intrinsics.string.TestStringCompareToDifferentLength 4 2 5 10 13 17 20 23 24 25 71 72 73 88 90\n- * @run main\/othervm -XX:SoftwarePrefetchHintDistance=-1 compiler.intrinsics.string.TestStringCompareToDifferentLength 4 2 5 10 13 17 20 23 24 25 71 72 73 88 90\n+ * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:SoftwarePrefetchHintDistance=192 compiler.intrinsics.string.TestStringCompareToDifferentLength 4 2 5 10 13 17 20 23 24 25 71 72 73 88 90 192 193 208 209\n+ * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:SoftwarePrefetchHintDistance=16 compiler.intrinsics.string.TestStringCompareToDifferentLength 4 2 5 10 13 17 20 23 24 25 71 72 73 88 90\n+ * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:SoftwarePrefetchHintDistance=-1 compiler.intrinsics.string.TestStringCompareToDifferentLength 4 2 5 10 13 17 20 23 24 25 71 72 73 88 90\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/string\/TestStringCompareToDifferentLength.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"}]}