{"files":[{"patch":"@@ -74,0 +74,12 @@\n+\n+        tstring homeDir;\n+        JP_TRY;\n+        homeDir = SysInfo::getEnvVariable(\"HOME\");\n+        JP_CATCH_ALL;\n+\n+        if (!homeDir.empty()) {\n+            appLauncher.addCfgFileLookupDir(FileUtils::mkpath()\n+                    << homeDir << \".local\" << ownerPackage.name());\n+            appLauncher.addCfgFileLookupDir(FileUtils::mkpath()\n+                    << homeDir << \".\" + ownerPackage.name());\n+        }\n","filename":"src\/jdk.jpackage\/linux\/native\/libapplauncher\/LinuxLauncherLib.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-    public final BundlerParamInfo<Path> APP_IMAGE_TEMP_ROOT =\n+    private final BundlerParamInfo<Path> APP_IMAGE_TEMP_ROOT =\n@@ -159,1 +159,3 @@\n-            throws PackagerException {\n+            throws PackagerException, IOException {\n+        Path appDir;\n+        Path appImageRoot = APP_IMAGE_TEMP_ROOT.fetchFrom(params);\n@@ -163,1 +165,10 @@\n-            return predefinedImage;\n+            appDir = appImageRoot.resolve(APP_NAME.fetchFrom(params) + \".app\");\n+            IOUtils.copyRecursive(predefinedImage, appDir);\n+        } else {\n+            appDir = appImageBundler.execute(params, appImageRoot);\n+        }\n+\n+        if (!StandardBundlerParam.isRuntimeInstaller(params)) {\n+            new PackageFile(APP_NAME.fetchFrom(params)).save(\n+                    ApplicationLayout.macAppImage().resolveAt(appDir));\n+           Files.deleteIfExists(AppImageFile.getPathInAppImage(appDir));\n@@ -165,1 +176,0 @@\n-        Path appImageRoot = APP_IMAGE_TEMP_ROOT.fetchFrom(params);\n@@ -167,1 +177,1 @@\n-        return appImageBundler.execute(params, appImageRoot);\n+        return appDir;\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacBaseInstallerBundler.java","additions":15,"deletions":5,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -280,5 +280,2 @@\n-        Path srcFolder = APP_IMAGE_TEMP_ROOT.fetchFrom(params);\n-        Path predefinedImage = StandardBundlerParam.getPredefinedAppImage(params);\n-        if (predefinedImage != null) {\n-            srcFolder = predefinedImage;\n-        } else if (StandardBundlerParam.isRuntimeInstaller(params)) {\n+        Path srcFolder = appLocation.getParent();\n+        if (StandardBundlerParam.isRuntimeInstaller(params)) {\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacDmgBundler.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"PackageFile.h\"\n@@ -31,0 +32,1 @@\n+#include \"ErrorHandling.h\"\n@@ -52,0 +54,5 @@\n+    const tstring appDirPath = FileUtils::mkpath() << appImageRoot\n+            << _T(\"Contents\/app\");\n+\n+    const PackageFile pkgFile = PackageFile::loadFromAppDir(appDirPath);\n+\n@@ -53,1 +60,1 @@\n-    jvmLauncher = AppLauncher()\n+    AppLauncher appLauncher = AppLauncher()\n@@ -58,1 +65,1 @@\n-        .setAppDir(FileUtils::mkpath() << appImageRoot << _T(\"Contents\/app\"))\n+        .setAppDir(appDirPath)\n@@ -61,2 +68,16 @@\n-                << _T(\"Contents\/runtime\"))\n-        .createJvmLauncher();\n+                << _T(\"Contents\/runtime\"));\n+\n+    if (!pkgFile.getPackageName().empty()) {\n+        tstring homeDir;\n+        JP_TRY;\n+        homeDir = SysInfo::getEnvVariable(\"HOME\");\n+        JP_CATCH_ALL;\n+\n+        if (!homeDir.empty()) {\n+            appLauncher.addCfgFileLookupDir(FileUtils::mkpath()\n+                    << homeDir << \"Library\/Application Support\"\n+                    << pkgFile.getPackageName());\n+        }\n+    }\n+\n+    jvmLauncher = appLauncher.createJvmLauncher();\n","filename":"src\/jdk.jpackage\/macosx\/native\/applauncher\/MacLauncher.cpp","additions":26,"deletions":5,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+public final class PackageFile {\n+\n+    \/**\n+     * Returns path to package file.\n+     * @param appImageDir - path to application image\n+     *\/\n+    public static Path getPathInAppImage(Path appImageDir) {\n+        return ApplicationLayout.platformAppImage()\n+                .resolveAt(appImageDir)\n+                .appDirectory()\n+                .resolve(FILENAME);\n+    }\n+\n+    PackageFile(String packageName) {\n+        Objects.requireNonNull(packageName);\n+        this.packageName = packageName;\n+    }\n+\n+    void save(ApplicationLayout appLayout) throws IOException {\n+        Path dst = Optional.ofNullable(appLayout.appDirectory()).map(appDir -> {\n+            return appDir.resolve(FILENAME);\n+        }).orElse(null);\n+\n+        if (dst != null) {\n+            Files.createDirectories(dst.getParent());\n+            Files.writeString(dst, packageName);\n+        }\n+    }\n+\n+    private final String packageName;\n+\n+    private final static String FILENAME = \".package\";\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/PackageFile.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -113,3 +113,1 @@\n-    const tstring cfgFilePath = FileUtils::mkpath()\n-        << appDirPath << FileUtils::stripExeSuffix(\n-            FileUtils::basename(launcherPath)) + _T(\".cfg\");\n+    const tstring cfgFilePath = getCfgFilePath();\n@@ -163,0 +161,17 @@\n+\n+\n+tstring AppLauncher::getCfgFilePath() const {\n+    tstring_array::const_iterator it = cfgFileLookupDirs.begin();\n+    tstring_array::const_iterator end = cfgFileLookupDirs.end();\n+    const tstring cfgFileName = FileUtils::stripExeSuffix(\n+            FileUtils::basename(launcherPath)) + _T(\".cfg\");\n+    for (; it != end; ++it) {\n+        const tstring cfgFilePath = FileUtils::mkpath() << *it << cfgFileName;\n+        LOG_TRACE(tstrings::any() << \"Check [\" << cfgFilePath << \"] file exit\");\n+        if (FileUtils::isFileExists(cfgFilePath)) {\n+            return cfgFilePath;\n+        }\n+    }\n+\n+    return FileUtils::mkpath() << appDirPath << cfgFileName;\n+}\n","filename":"src\/jdk.jpackage\/share\/native\/applauncher\/AppLauncher.cpp","additions":19,"deletions":4,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,0 +48,5 @@\n+    AppLauncher& addCfgFileLookupDir(const tstring& v) {\n+        cfgFileLookupDirs.push_back(v);\n+        return *this;\n+    }\n+\n@@ -74,0 +79,3 @@\n+private:\n+  tstring getCfgFilePath() const;\n+\n@@ -82,0 +90,1 @@\n+    tstring_array cfgFileLookupDirs;\n","filename":"src\/jdk.jpackage\/share\/native\/applauncher\/AppLauncher.h","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"kludge_c++11.h\"\n+\n+#include <fstream>\n+#include \"PackageFile.h\"\n+#include \"Log.h\"\n+#include \"FileUtils.h\"\n+#include \"ErrorHandling.h\"\n+\n+\n+PackageFile::PackageFile(const tstring& v): packageName(v) {\n+}\n+\n+\n+PackageFile PackageFile::loadFromAppDir(const tstring& appDirPath) {\n+    tstring packageName;\n+    const tstring packageFilePath =\n+            FileUtils::mkpath() << appDirPath << _T(\".package\");\n+    if (FileUtils::isFileExists(packageFilePath)) {\n+        LOG_TRACE(tstrings::any() << \"Read \\\"\" << packageFilePath\n+                                  << \"\\\" package file\");\n+        std::ifstream input(packageFilePath);\n+        if (!input.good()) {\n+            JP_THROW(tstrings::any() << \"Error opening \\\"\" << packageFilePath\n+                    << \"\\\" file: \" << lastCRTError());\n+        }\n+\n+        std::string utf8line;\n+        if (std::getline(input, utf8line)) {\n+            LOG_TRACE(tstrings::any()\n+                    << \"Package name is [\" << utf8line << \"]\");\n+            packageName = tstrings::any(utf8line).tstr();\n+        }\n+    }\n+\n+    return PackageFile(packageName);\n+}\n","filename":"src\/jdk.jpackage\/share\/native\/applauncher\/PackageFile.cpp","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+#ifndef PackageFile_h\n+#define PackageFile_h\n+\n+#include \"tstrings.h\"\n+\n+\n+class PackageFile {\n+public:\n+    static PackageFile loadFromAppDir(const tstring& appDirPath);\n+\n+    tstring getPackageName() const {\n+        return packageName;\n+    }\n+\n+private:\n+    PackageFile(const tstring& packageName);\n+\n+private:\n+    tstring packageName;\n+};\n+\n+#endif \/\/ PackageFile_h\n","filename":"src\/jdk.jpackage\/share\/native\/applauncher\/PackageFile.h","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -385,3 +385,3 @@\n-            installerIcon = ApplicationLayout.windowsAppImage()\n-                    .resolveAt(appDir)\n-                    .launchersDirectory()\n+            var appLayout = ApplicationLayout.windowsAppImage().resolveAt(appDir);\n+\n+            installerIcon = appLayout.launchersDirectory()\n@@ -389,0 +389,2 @@\n+\n+            new PackageFile(appName).save(appLayout);\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WinMsiBundler.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"PackageFile.h\"\n@@ -136,0 +137,16 @@\n+void addCfgFileLookupDirForEnvVariable(\n+        const PackageFile& pkgFile, AppLauncher& appLauncher,\n+        const tstring& envVarName) {\n+\n+    tstring path;\n+    JP_TRY;\n+    path = SysInfo::getEnvVariable(envVarName);\n+    JP_CATCH_ALL;\n+\n+    if (!path.empty()) {\n+        appLauncher.addCfgFileLookupDir(FileUtils::mkpath() << path\n+                << pkgFile.getPackageName());\n+    }\n+}\n+\n+\n@@ -144,1 +161,3 @@\n-    const AppLauncher appLauncher = AppLauncher().setImageRoot(appImageRoot)\n+    const PackageFile pkgFile = PackageFile::loadFromAppDir(appDirPath);\n+\n+    AppLauncher appLauncher = AppLauncher().setImageRoot(appImageRoot)\n@@ -151,0 +170,5 @@\n+    if (!pkgFile.getPackageName().empty()) {\n+        addCfgFileLookupDirForEnvVariable(pkgFile, appLauncher, _T(\"LOCALAPPDATA\"));\n+        addCfgFileLookupDirForEnvVariable(pkgFile, appLauncher, _T(\"APPDATA\"));\n+    }\n+\n","filename":"src\/jdk.jpackage\/windows\/native\/applauncher\/WinLauncher.cpp","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import jdk.jpackage.internal.PackageFile;\n@@ -762,32 +763,2 @@\n-        if (isPackageUnpacked() || isImagePackageType()) {\n-            final Path rootDir = isPackageUnpacked() ? pathToUnpackedPackageFile(\n-                    appInstallationDirectory()) : outputBundle();\n-            final Path appImageFileName = AppImageFile.getPathInAppImage(\n-                    Path.of(\"\")).getFileName();\n-            try (Stream<Path> walk = ThrowingSupplier.toSupplier(\n-                    () -> Files.walk(rootDir)).get()) {\n-                List<String> appImageFiles = walk\n-                        .filter(path -> path.getFileName().equals(appImageFileName))\n-                        .map(Path::toString)\n-                        .collect(Collectors.toList());\n-                if (isImagePackageType() || (TKit.isOSX() && !isRuntime())) {\n-                    List<String> expected = List.of(\n-                            AppImageFile.getPathInAppImage(rootDir).toString());\n-                    TKit.assertStringListEquals(expected, appImageFiles,\n-                            String.format(\n-                                    \"Check there is only one file with [%s] name in the package\",\n-                                    appImageFileName));\n-                } else {\n-                    TKit.assertStringListEquals(List.of(), appImageFiles,\n-                            String.format(\n-                                    \"Check there are no files with [%s] name in the package\",\n-                                    appImageFileName));\n-                }\n-            }\n-        } else if (TKit.isOSX() && !isRuntime()) {\n-            TKit.assertFileExists(AppImageFile.getPathInAppImage(\n-                    appInstallationDirectory()));\n-        } else {\n-            TKit.assertPathExists(AppImageFile.getPathInAppImage(\n-                    appInstallationDirectory()), false);\n-        }\n+        assertAppImageFile();\n+        assertPackageFile();\n@@ -810,0 +781,48 @@\n+    private void assertAppImageFile() {\n+        final Path lookupPath = AppImageFile.getPathInAppImage(Path.of(\"\"));\n+\n+        if (isRuntime() || !isImagePackageType()) {\n+            assertFileInAppImage(lookupPath, null);\n+        } else {\n+            assertFileInAppImage(lookupPath, lookupPath);\n+        }\n+    }\n+\n+    private void assertPackageFile() {\n+        final Path lookupPath = PackageFile.getPathInAppImage(Path.of(\"\"));\n+\n+        if (isRuntime() || isImagePackageType() || TKit.isLinux()) {\n+            assertFileInAppImage(lookupPath, null);\n+        } else {\n+            assertFileInAppImage(lookupPath, lookupPath);\n+        }\n+    }\n+\n+    private void assertFileInAppImage(Path filename, Path expectedPath) {\n+        if (filename.getNameCount() > 1) {\n+            assertFileInAppImage(filename.getFileName(), expectedPath);\n+            return;\n+        }\n+\n+        final Path rootDir = isImagePackageType() ? outputBundle() : pathToUnpackedPackageFile(\n+                appInstallationDirectory());\n+\n+        try ( Stream<Path> walk = ThrowingSupplier.toSupplier(() -> Files.walk(\n+                rootDir)).get()) {\n+            List<String> files = walk.filter(path -> path.getFileName().equals(\n+                    filename)).map(Path::toString).toList();\n+\n+            if (expectedPath == null) {\n+                TKit.assertStringListEquals(List.of(), files, String.format(\n+                        \"Check there are no files with [%s] name in the package\",\n+                        filename));\n+            } else {\n+                List<String> expected = List.of(\n+                        rootDir.resolve(expectedPath).toString());\n+                TKit.assertStringListEquals(expected, files, String.format(\n+                        \"Check there is only one file with [%s] name in the package\",\n+                        filename));\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/JPackageCommand.java","additions":51,"deletions":32,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import java.io.Closeable;\n@@ -49,0 +50,1 @@\n+import java.util.Objects;\n@@ -772,0 +774,28 @@\n+    \/**\n+     * Creates a directory by creating all nonexistent parent directories first\n+     * just like java.nio.file.Files#createDirectories() and returns\n+     * java.io.Closeable that will delete all created nonexistent parent\n+     * directories.\n+     *\/\n+    public static Closeable createDirectories(Path dir) throws IOException {\n+        Objects.requireNonNull(dir);\n+\n+        Collection<Path> dirsToDelete = new ArrayList<>();\n+\n+        Path curDir = dir;\n+        while (!Files.exists(curDir)) {\n+            dirsToDelete.add(curDir);\n+            curDir = curDir.getParent();\n+        }\n+        Files.createDirectories(dir);\n+\n+        return new Closeable() {\n+            @Override\n+            public void close() throws IOException {\n+                for (var dirToDelete : dirsToDelete) {\n+                    Files.deleteIfExists(dirToDelete);\n+                }\n+            }\n+        };\n+    }\n+\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/TKit.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -257,0 +257,8 @@\n+if [ -n \"$APPDATA\" ]; then\n+  # Looks like this is Windows.\n+  # Explicitly add LOCALAPPDATA and APPDATA environment variables to the list\n+  # of environment variables jtreg will pass to tests as by default it will not.\n+  # This is needed for PerUserCfgTest test.\n+  jtreg_args+=(\"-e:LOCALAPPDATA,APPDATA\")\n+fi\n+\n","filename":"test\/jdk\/tools\/jpackage\/run_tests.sh","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,185 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.Optional;\n+import jdk.jpackage.test.AdditionalLauncher;\n+import jdk.jpackage.test.PackageTest;\n+import jdk.jpackage.test.Annotations.Test;\n+import jdk.jpackage.test.Functional.ThrowingConsumer;\n+import jdk.jpackage.test.HelloApp;\n+import jdk.jpackage.test.JPackageCommand;\n+import jdk.jpackage.test.LinuxHelper;\n+import jdk.jpackage.test.PackageType;\n+import jdk.jpackage.test.TKit;\n+\n+\/**\n+ * Test per-user configuration of app launchers created by jpackage.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary pre-user configuration of app launchers\n+ * @library ..\/helpers\n+ * @key jpackagePlatformPackage\n+ * @requires jpackage.test.SQETest == null\n+ * @build jdk.jpackage.test.*\n+ * @compile PerUserCfgTest.java\n+ * @modules jdk.jpackage\/jdk.jpackage.internal\n+ * @run main\/othervm\/timeout=360 -Xmx512m jdk.jpackage.test.Main\n+ *  --jpt-run=PerUserCfgTest\n+ *\/\n+public class PerUserCfgTest {\n+\n+    @Test\n+    public static void test() throws IOException {\n+        \/\/ Create a number of .cfg files with different startup args\n+        JPackageCommand cfgCmd = JPackageCommand.helloAppImage().setFakeRuntime()\n+                .setArgumentValue(\"--dest\", TKit.createTempDirectory(\"cfg-files\").toString());\n+\n+        addLauncher(cfgCmd, \"a\");\n+        addLauncher(cfgCmd, \"b\");\n+\n+        cfgCmd.execute();\n+\n+        new PackageTest().configureHelloApp().addInstallVerifier(cmd -> {\n+            if (cmd.isPackageUnpacked(\"Not running per-user configuration tests\")) {\n+                return;\n+            }\n+\n+            Path launcherPath = cmd.appLauncherPath();\n+            if (!cmd.canRunLauncher(String.format(\n+                    \"Not running %s launcher and per-user configuration tests\",\n+                    launcherPath))) {\n+                return;\n+            }\n+\n+            final PackageType type = cmd.packageType();\n+            if (PackageType.MAC.contains(type)) {\n+                withConfigFile(cmd, cfgCmd.appLauncherCfgPath(\"a\"),\n+                        getUserHomeDir().resolve(\"Library\/Application Support\").resolve(\n+                                cmd.name()), theCmd -> {\n+                    runMainLauncher(cmd, \"a\");\n+                });\n+            } else if (PackageType.LINUX.contains(type)) {\n+                final String pkgName = LinuxHelper.getPackageName(cmd);\n+                final Path homeDir = getUserHomeDir();\n+\n+                withConfigFile(cmd, cfgCmd.appLauncherCfgPath(\"a\"),\n+                        homeDir.resolve(\".local\").resolve(pkgName), theCmd -> {\n+                    runMainLauncher(cmd, \"a\");\n+                });\n+\n+                withConfigFile(cmd, cfgCmd.appLauncherCfgPath(\"b\"),\n+                        homeDir.resolve(\".\" + pkgName), theCmd -> {\n+                    runMainLauncher(cmd, \"b\");\n+                });\n+\n+                withConfigFile(cmd, cfgCmd.appLauncherCfgPath(\"b\"),\n+                        homeDir.resolve(\".\" + pkgName), theCmd -> {\n+                    runMainLauncher(cmd, \"b\");\n+\n+                    withConfigFile(cmd, cfgCmd.appLauncherCfgPath(\"a\"),\n+                            homeDir.resolve(\".local\").resolve(pkgName),\n+                            theCmd2 -> {\n+                                runMainLauncher(cmd, \"a\");\n+                            });\n+                });\n+            } else if (PackageType.WINDOWS.contains(type)) {\n+                final Path appData = getDirFromEnvVariable(\"APPDATA\");\n+                final Path localAppData = getDirFromEnvVariable(\"LOCALAPPDATA\");\n+\n+                if (appData == null || localAppData == null) {\n+                    TKit.trace(String.format(\n+                            \"Not running per-user configuration tests because some of the environment varibles are not set. \"\n+                                    + \"Run jtreg with -e:APPDATA,LOCALAPPDATA option to fix the problem\"));\n+                } else {\n+                    withConfigFile(cmd, cfgCmd.appLauncherCfgPath(\"a\"),\n+                            appData.resolve(cmd.name()), theCmd -> {\n+                        runMainLauncher(cmd, \"a\");\n+                    });\n+\n+                    withConfigFile(cmd, cfgCmd.appLauncherCfgPath(\"b\"),\n+                            localAppData.resolve(cmd.name()), theCmd -> {\n+                        runMainLauncher(cmd, \"b\");\n+                    });\n+\n+                    withConfigFile(cmd, cfgCmd.appLauncherCfgPath(\"b\"),\n+                            appData.resolve(cmd.name()), theCmd -> {\n+                        runMainLauncher(cmd, \"b\");\n+\n+                        withConfigFile(cmd, cfgCmd.appLauncherCfgPath(\"a\"),\n+                                localAppData.resolve(cmd.name()),\n+                                theCmd2 -> {\n+                                    runMainLauncher(cmd, \"a\");\n+                                });\n+                    });\n+                }\n+            }\n+            runMainLauncher(cmd);\n+        }).run();\n+    }\n+\n+    private static void addLauncher(JPackageCommand cmd, String name) {\n+        new AdditionalLauncher(name) {\n+            @Override\n+            protected void verify(JPackageCommand cmd) {}\n+        }.setDefaultArguments(name).applyTo(cmd);\n+    }\n+\n+    private static Path getUserHomeDir() {\n+        return getDirFromEnvVariable(\"HOME\");\n+    }\n+\n+    private static Path getDirFromEnvVariable(String envVariableName) {\n+        return Optional.ofNullable(System.getenv(envVariableName)).map(Path::of).orElse(\n+                null);\n+    }\n+\n+    private static void withConfigFile(JPackageCommand cmd, Path srcCfgFile,\n+            Path outputCfgFileDir, ThrowingConsumer<JPackageCommand> action) throws\n+            Throwable {\n+        Path targetCfgFile = outputCfgFileDir.resolve(cmd.appLauncherCfgPath(\n+                null).getFileName());\n+        TKit.assertPathExists(targetCfgFile, false);\n+        try (var dirCleaner = TKit.createDirectories(targetCfgFile.getParent())) {\n+            Files.copy(srcCfgFile, targetCfgFile);\n+            try {\n+                TKit.traceFileContents(targetCfgFile, \"cfg file\");\n+                action.accept(cmd);\n+            } finally {\n+                Files.deleteIfExists(targetCfgFile);\n+            }\n+        }\n+    }\n+\n+    private static void runMainLauncher(JPackageCommand cmd,\n+            String... expectedArgs) {\n+\n+        HelloApp.assertApp(cmd.appLauncherPath()).addDefaultArguments(List.of(\n+                expectedArgs)).executeAndVerifyOutput();\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/share\/PerUserCfgTest.java","additions":185,"deletions":0,"binary":false,"changes":185,"status":"added"}]}