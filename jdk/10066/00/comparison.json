{"files":[{"patch":"@@ -2094,0 +2094,4 @@\n+  OopMap* continuation_enter_setup(int& stack_slots);\n+  void fill_continuation_entry(Register reg_cont_obj, Register reg_flags);\n+  void continuation_enter_cleanup();\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,122 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"runtime\/continuation.hpp\"\n+#include \"runtime\/continuationEntry.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n+#include \"macroAssembler_x86.hpp\"\n+\n+\/\/---------------------------- continuation_enter_setup ---------------------------\n+\/\/\n+\/\/ Arguments:\n+\/\/   None.\n+\/\/\n+\/\/ Results:\n+\/\/   rsp: pointer to blank ContinuationEntry\n+\/\/\n+\/\/ Kills:\n+\/\/   rax\n+\/\/\n+OopMap* MacroAssembler::continuation_enter_setup(int& stack_slots) {\n+  assert(ContinuationEntry::size() % VMRegImpl::stack_slot_size == 0, \"\");\n+  assert(in_bytes(ContinuationEntry::cont_offset())  % VMRegImpl::stack_slot_size == 0, \"\");\n+  assert(in_bytes(ContinuationEntry::chunk_offset()) % VMRegImpl::stack_slot_size == 0, \"\");\n+\n+  stack_slots += checked_cast<int>(ContinuationEntry::size()) \/ wordSize;\n+  subptr(rsp, checked_cast<int32_t>(ContinuationEntry::size()));\n+\n+  int frame_size = (checked_cast<int>(ContinuationEntry::size()) + wordSize) \/ VMRegImpl::stack_slot_size;\n+  OopMap* map = new OopMap(frame_size, 0);\n+  ContinuationEntry::setup_oopmap(map);\n+\n+  movptr(rax, Address(r15_thread, JavaThread::cont_entry_offset()));\n+  movptr(Address(rsp, ContinuationEntry::parent_offset()), rax);\n+  movptr(Address(r15_thread, JavaThread::cont_entry_offset()), rsp);\n+\n+  return map;\n+}\n+\n+\/\/---------------------------- fill_continuation_entry ---------------------------\n+\/\/\n+\/\/ Arguments:\n+\/\/   rsp: pointer to blank Continuation entry\n+\/\/   reg_cont_obj: pointer to the continuation\n+\/\/   reg_flags: flags\n+\/\/\n+\/\/ Results:\n+\/\/   rsp: pointer to filled out ContinuationEntry\n+\/\/\n+\/\/ Kills:\n+\/\/   rax\n+\/\/\n+void MacroAssembler::fill_continuation_entry(Register reg_cont_obj, Register reg_flags) {\n+  assert_different_registers(rax, reg_cont_obj, reg_flags);\n+#ifdef ASSERT\n+  movl(Address(rsp, ContinuationEntry::cookie_offset()), ContinuationEntry::cookie_value());\n+#endif\n+  movptr(Address(rsp, ContinuationEntry::cont_offset()), reg_cont_obj);\n+  movl  (Address(rsp, ContinuationEntry::flags_offset()), reg_flags);\n+  movptr(Address(rsp, ContinuationEntry::chunk_offset()), 0);\n+  movl(Address(rsp, ContinuationEntry::argsize_offset()), 0);\n+  movl(Address(rsp, ContinuationEntry::pin_count_offset()), 0);\n+\n+  movptr(rax, Address(r15_thread, JavaThread::cont_fastpath_offset()));\n+  movptr(Address(rsp, ContinuationEntry::parent_cont_fastpath_offset()), rax);\n+  movq(rax, Address(r15_thread, JavaThread::held_monitor_count_offset()));\n+  movq(Address(rsp, ContinuationEntry::parent_held_monitor_count_offset()), rax);\n+\n+  movptr(Address(r15_thread, JavaThread::cont_fastpath_offset()), 0);\n+  movq(Address(r15_thread, JavaThread::held_monitor_count_offset()), 0);\n+}\n+\n+\/\/---------------------------- continuation_enter_cleanup ---------------------------\n+\/\/\n+\/\/ Arguments:\n+\/\/   rsp: pointer to the ContinuationEntry\n+\/\/\n+\/\/ Results:\n+\/\/   rsp: pointer to the spilled rbp in the entry frame\n+\/\/\n+\/\/ Kills:\n+\/\/   rbx\n+\/\/\n+void MacroAssembler::continuation_enter_cleanup() {\n+#ifdef ASSERT\n+  Label L_good_sp;\n+  cmpptr(rsp, Address(r15_thread, JavaThread::cont_entry_offset()));\n+  jcc(Assembler::equal, L_good_sp);\n+  stop(\"Incorrect rsp at continuation_enter_cleanup\");\n+  bind(L_good_sp);\n+#endif\n+\n+  movptr(rbx, Address(rsp, ContinuationEntry::parent_cont_fastpath_offset()));\n+  movptr(Address(r15_thread, JavaThread::cont_fastpath_offset()), rbx);\n+  movq(rbx, Address(rsp, ContinuationEntry::parent_held_monitor_count_offset()));\n+  movq(Address(r15_thread, JavaThread::held_monitor_count_offset()), rbx);\n+\n+  movptr(rbx, Address(rsp, ContinuationEntry::parent_offset()));\n+  movptr(Address(r15_thread, JavaThread::cont_entry_offset()), rbx);\n+  addptr(rsp, checked_cast<int32_t>(ContinuationEntry::size()));\n+}\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86_64.cpp","additions":122,"deletions":0,"binary":false,"changes":122,"status":"added"},{"patch":"@@ -1256,5 +1256,0 @@\n-\/\/ defined in stubGenerator_x86_64.cpp\n-OopMap* continuation_enter_setup(MacroAssembler* masm, int& stack_slots);\n-void fill_continuation_entry(MacroAssembler* masm, Register reg_cont_obj, Register reg_flags);\n-void continuation_enter_cleanup(MacroAssembler* masm);\n-\n@@ -1329,1 +1324,1 @@\n-    OopMap* map = continuation_enter_setup(masm, stack_slots);\n+    OopMap* map = __ continuation_enter_setup(stack_slots);\n@@ -1335,1 +1330,1 @@\n-    fill_continuation_entry(masm, reg_cont_obj, reg_is_virtual);\n+    __ fill_continuation_entry(reg_cont_obj, reg_is_virtual);\n@@ -1364,1 +1359,1 @@\n-  OopMap* map = continuation_enter_setup(masm, stack_slots);\n+  OopMap* map = __ continuation_enter_setup(stack_slots);\n@@ -1371,1 +1366,1 @@\n-  fill_continuation_entry(masm, reg_cont_obj, reg_is_virtual);\n+  __ fill_continuation_entry(reg_cont_obj, reg_is_virtual);\n@@ -1414,1 +1409,1 @@\n-  continuation_enter_cleanup(masm);\n+  __ continuation_enter_cleanup();\n@@ -1422,1 +1417,1 @@\n-  continuation_enter_cleanup(masm);\n+  __ continuation_enter_cleanup();\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":6,"deletions":11,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -82,4 +82,0 @@\n-OopMap* continuation_enter_setup(MacroAssembler* masm, int& stack_slots);\n-void fill_continuation_entry(MacroAssembler* masm);\n-void continuation_enter_cleanup(MacroAssembler* masm);\n-\n@@ -7453,1 +7449,1 @@\n-    continuation_enter_cleanup(_masm);\n+    __ continuation_enter_cleanup();\n@@ -8169,96 +8165,0 @@\n-#define __ masm->\n-\n-\/\/---------------------------- continuation_enter_setup ---------------------------\n-\/\/\n-\/\/ Arguments:\n-\/\/   None.\n-\/\/\n-\/\/ Results:\n-\/\/   rsp: pointer to blank ContinuationEntry\n-\/\/\n-\/\/ Kills:\n-\/\/   rax\n-\/\/\n-OopMap* continuation_enter_setup(MacroAssembler* masm, int& stack_slots) {\n-  assert(ContinuationEntry::size() % VMRegImpl::stack_slot_size == 0, \"\");\n-  assert(in_bytes(ContinuationEntry::cont_offset())  % VMRegImpl::stack_slot_size == 0, \"\");\n-  assert(in_bytes(ContinuationEntry::chunk_offset()) % VMRegImpl::stack_slot_size == 0, \"\");\n-\n-  stack_slots += checked_cast<int>(ContinuationEntry::size()) \/ wordSize;\n-  __ subptr(rsp, checked_cast<int32_t>(ContinuationEntry::size()));\n-\n-  int frame_size = (checked_cast<int>(ContinuationEntry::size()) + wordSize) \/ VMRegImpl::stack_slot_size;\n-  OopMap* map = new OopMap(frame_size, 0);\n-  ContinuationEntry::setup_oopmap(map);\n-\n-  __ movptr(rax, Address(r15_thread, JavaThread::cont_entry_offset()));\n-  __ movptr(Address(rsp, ContinuationEntry::parent_offset()), rax);\n-  __ movptr(Address(r15_thread, JavaThread::cont_entry_offset()), rsp);\n-\n-  return map;\n-}\n-\n-\/\/---------------------------- fill_continuation_entry ---------------------------\n-\/\/\n-\/\/ Arguments:\n-\/\/   rsp: pointer to blank Continuation entry\n-\/\/   reg_cont_obj: pointer to the continuation\n-\/\/   reg_flags: flags\n-\/\/\n-\/\/ Results:\n-\/\/   rsp: pointer to filled out ContinuationEntry\n-\/\/\n-\/\/ Kills:\n-\/\/   rax\n-\/\/\n-void fill_continuation_entry(MacroAssembler* masm, Register reg_cont_obj, Register reg_flags) {\n-  assert_different_registers(rax, reg_cont_obj, reg_flags);\n-\n-  DEBUG_ONLY(__ movl(Address(rsp, ContinuationEntry::cookie_offset()), ContinuationEntry::cookie_value());)\n-\n-  __ movptr(Address(rsp, ContinuationEntry::cont_offset()), reg_cont_obj);\n-  __ movl  (Address(rsp, ContinuationEntry::flags_offset()), reg_flags);\n-  __ movptr(Address(rsp, ContinuationEntry::chunk_offset()), 0);\n-  __ movl(Address(rsp, ContinuationEntry::argsize_offset()), 0);\n-  __ movl(Address(rsp, ContinuationEntry::pin_count_offset()), 0);\n-\n-  __ movptr(rax, Address(r15_thread, JavaThread::cont_fastpath_offset()));\n-  __ movptr(Address(rsp, ContinuationEntry::parent_cont_fastpath_offset()), rax);\n-  __ movq(rax, Address(r15_thread, JavaThread::held_monitor_count_offset()));\n-  __ movq(Address(rsp, ContinuationEntry::parent_held_monitor_count_offset()), rax);\n-\n-  __ movptr(Address(r15_thread, JavaThread::cont_fastpath_offset()), 0);\n-  __ movq(Address(r15_thread, JavaThread::held_monitor_count_offset()), 0);\n-}\n-\n-\/\/---------------------------- continuation_enter_cleanup ---------------------------\n-\/\/\n-\/\/ Arguments:\n-\/\/   rsp: pointer to the ContinuationEntry\n-\/\/\n-\/\/ Results:\n-\/\/   rsp: pointer to the spilled rbp in the entry frame\n-\/\/\n-\/\/ Kills:\n-\/\/   rbx\n-\/\/\n-void continuation_enter_cleanup(MacroAssembler* masm) {\n-#ifdef ASSERT\n-  Label L_good_sp;\n-  __ cmpptr(rsp, Address(r15_thread, JavaThread::cont_entry_offset()));\n-  __ jcc(Assembler::equal, L_good_sp);\n-  __ stop(\"Incorrect rsp at continuation_enter_cleanup\");\n-  __ bind(L_good_sp);\n-#endif\n-\n-  __ movptr(rbx, Address(rsp, ContinuationEntry::parent_cont_fastpath_offset()));\n-  __ movptr(Address(r15_thread, JavaThread::cont_fastpath_offset()), rbx);\n-  __ movq(rbx, Address(rsp, ContinuationEntry::parent_held_monitor_count_offset()));\n-  __ movq(Address(r15_thread, JavaThread::held_monitor_count_offset()), rbx);\n-\n-  __ movptr(rbx, Address(rsp, ContinuationEntry::parent_offset()));\n-  __ movptr(Address(r15_thread, JavaThread::cont_entry_offset()), rbx);\n-  __ addptr(rsp, checked_cast<int32_t>(ContinuationEntry::size()));\n-}\n-\n-#undef __\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":1,"deletions":101,"binary":false,"changes":102,"status":"modified"}]}