{"files":[{"patch":"@@ -82,5 +82,1 @@\n-    if (tos_state != Z_R0_scratch) {                                           \\\n-      __ z_slgr(br_tab_temp, tos_state); \/* to calculated branch target.     *\/\\\n-    }                                                                          \\\n-    __ z_brc(Assembler::bcondLogZero, 4);\/* skip trap if ok. *\/                \\\n-    __ z_illtrap(0x55);                                                        \\\n+    __ z_brc(Assembler::bcondLogZero, 3);\/* skip trap if ok. *\/                \\\n@@ -2453,1 +2449,3 @@\n-  __ load_sized_value(tos_state, Address(cache, in_bytes(ResolvedFieldEntry::type_offset())), sizeof(u1), false);\n+  if (tos_state != noreg) {\n+    __ load_sized_value(tos_state, Address(cache, in_bytes(ResolvedFieldEntry::type_offset())), sizeof(u1), false);\n+  }\n@@ -2661,1 +2659,1 @@\n-  \/\/  cache, index: short-lived. Their life ends after load_resolved_field_entry.\n+  \/\/  cache, index          : short-lived. Their life ends after load_resolved_field_entry.\n@@ -2664,5 +2662,4 @@\n-  \/\/  flags: unused in getfield.\n-  \/\/  br_tab: short-lived. Only used to address branch table, and for verification\n-  \/\/          in BTB_BEGIN macro.\n-  \/\/  tos_state: short-lived. Only used to index the branch table entry.\n-  \/\/  bc_reg: short-lived. Used as work register in patch_bytecode.\n+  \/\/  flags                 : unused in getfield.\n+  \/\/  br_tab                : short-lived. Only used to address branch table, and for verification in BTB_BEGIN macro.\n+  \/\/  tos_state             : short-lived. Only used to index the branch table entry.\n+  \/\/  bc_reg                : short-lived. Used as work register in patch_bytecode.\n@@ -2706,6 +2703,3 @@\n-    if (tos_state == Z_R0_scratch) {\n-      __ z_agr(br_tab, tos_state); \/\/ can't use tos_state with address calculation\n-      __ z_bcr(Assembler::bcondAlways, br_tab);\n-    } else {\n-      __ z_bc(Assembler::bcondAlways, 0, tos_state, br_tab);\n-    }\n+    assert(tos_state != Z_R0_scratch, \"shouldn't be\");\n+    __ z_agr(br_tab, tos_state);\n+    __ z_bcr(Assembler::bcondAlways, br_tab);\n@@ -3004,1 +2998,0 @@\n-  \/\/ Displacement is 0. No need to care about limited displacement range.\n@@ -3032,1 +3025,1 @@\n-  const unsigned int bsize = is_static ? BTB_MINSIZE*1 : BTB_MINSIZE*8; \/\/ TODO: why code size is increasing ?\n+  const unsigned int bsize = is_static ? BTB_MINSIZE*1 : BTB_MINSIZE*8;\n@@ -3042,6 +3035,3 @@\n-    if (tos_state == Z_R0_scratch) {\n-      __ z_agr(br_tab, tos_state); \/\/ can't use tos_state with address calculation\n-      __ z_bcr(Assembler::bcondAlways, br_tab);\n-    } else {\n-      __ z_bc(Assembler::bcondAlways, 0, tos_state, br_tab);\n-    }\n+    assert(tos_state != Z_R0_scratch, \"shouldn't be\");\n+    __ z_agr(br_tab, tos_state);\n+    __ z_bcr(Assembler::bcondAlways, br_tab);\n@@ -3287,1 +3277,0 @@\n-                                    \/\/ TODO: do we need to check twice (here and before call_VM?)\n@@ -3369,1 +3358,0 @@\n-  Register tos_state = Z_R1_scratch;\n@@ -3374,1 +3362,1 @@\n-  load_resolved_field_entry(obj, cache, tos_state, off, flags, false);\n+  load_resolved_field_entry(obj, cache, noreg, off, flags, false);\n","filename":"src\/hotspot\/cpu\/s390\/templateTable_s390.cpp","additions":17,"deletions":29,"binary":false,"changes":46,"status":"modified"}]}