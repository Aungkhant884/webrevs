{"files":[{"patch":"@@ -1530,1 +1530,2 @@\n-        return (a <= 0.0F) ? 0.0F - a : a;\n+        \/\/ Convert to bit field form, zero the sign bit, and convert back\n+        return Float.intBitsToFloat(Float.floatToRawIntBits(a) & FloatConsts.MAG_BIT_MASK);\n@@ -1555,1 +1556,3 @@\n-        return (a <= 0.0D) ? 0.0D - a : a;\n+        \/\/ Convert to bit field form, zero the sign bit, and convert back\n+        return Double.longBitsToDouble(Double.doubleToRawLongBits(a) & DoubleConsts.MAG_BIT_MASK);\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Math.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -76,0 +76,6 @@\n+    \/**\n+     * Bit mask to isolate the magnitude bits (combined exponent and\n+     * significand fields) of a {@code double}.\n+     *\/\n+    public static final long    MAG_BIT_MASK = ~SIGN_BIT_MASK;\n+\n@@ -82,1 +88,3 @@\n-                ((EXP_BIT_MASK & SIGNIF_BIT_MASK) == 0L)));\n+                ((EXP_BIT_MASK & SIGNIF_BIT_MASK) == 0L)) &&\n+                ((SIGN_BIT_MASK | MAG_BIT_MASK) == ~0));\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/math\/DoubleConsts.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,0 +76,6 @@\n+    \/**\n+     * Bit mask to isolate the magnitude bits (combined exponent and\n+     * significand fields) of a {@code float}.\n+     *\/\n+    public static final int     MAG_BIT_MASK = ~SIGN_BIT_MASK;\n+\n@@ -82,1 +88,2 @@\n-                ((EXP_BIT_MASK & SIGNIF_BIT_MASK) == 0)));\n+                ((EXP_BIT_MASK & SIGNIF_BIT_MASK) == 0)) &&\n+                ((SIGN_BIT_MASK | MAG_BIT_MASK) == ~0));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/math\/FloatConsts.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,1 @@\n+import java.util.concurrent.atomic.AtomicInteger;\n@@ -25,0 +26,5 @@\n+import java.util.function.DoubleConsumer;\n+import java.util.stream.DoubleStream;\n+import java.util.stream.Stream;\n+import jdk.internal.math.DoubleConsts;\n+import jdk.internal.math.FloatConsts;\n@@ -28,1 +34,1 @@\n- * @bug 8241374\n+ * @bug 6506405 8241374\n@@ -30,0 +36,1 @@\n+ * @modules java.base\/jdk.internal.math\n@@ -32,0 +39,22 @@\n+    private static final double GELFOND = Math.exp(Math.PI);\n+    private static final double TAU     = 2.0*Math.PI;\n+\n+    \/\/ Values for testing float and double abs\n+    private static final double[] FLOATING_POINT_VALUES = new double[] {\n+        0.0,\n+        -0.0,\n+        +0.0,\n+        Double.MIN_VALUE,\n+        Double.MIN_NORMAL,\n+        Double.NEGATIVE_INFINITY,\n+        Double.POSITIVE_INFINITY,\n+        Double.NaN,\n+        Double.longBitsToDouble((1 << DoubleConsts.SIGNIFICAND_WIDTH) |\n+           ((1 << DoubleConsts.SIGNIFICAND_WIDTH) - 1)),\n+        DoubleConsts.MAG_BIT_MASK >>> 1,\n+        Math.E,\n+        GELFOND,\n+        Math.PI,\n+        TAU\n+    };\n+\n@@ -39,0 +68,2 @@\n+        errors += testFloatAbs();\n+        errors += testDoubleAbs();\n@@ -45,0 +76,2 @@\n+    \/\/ --------------------------------------------------------------------\n+\n@@ -146,0 +179,51 @@\n+\n+    \/\/ --------------------------------------------------------------------\n+\n+    private static int testFloatAbs() {\n+        DoubleStream doubles = DoubleStream.of(FLOATING_POINT_VALUES);\n+\n+        final AtomicInteger errors = new AtomicInteger();\n+        doubles.mapToObj(d -> (float)d).\n+            forEach(f -> {errors.addAndGet(testFloatAbs(Math::abs, f));});\n+\n+        return errors.get();\n+    }\n+\n+    private static int testFloatAbs(UnaryOperator<Float> absFunc, float f) {\n+        float result = absFunc.apply(-f);\n+        if (Float.isNaN(f)) {\n+            return Float.floatToRawIntBits(result) !=\n+                Float.floatToRawIntBits(f) ? 1 : 0;\n+        } else if ((f >= 0 && result != f) || (f < 0 && result != -f)) {\n+            System.err.printf(\"Unexpected float abs result %f for argument %f%n\",\n+                              result, f);\n+            return 1;\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+    \/\/ --------------------------------------------------------------------\n+\n+    private static int testDoubleAbs() {\n+        DoubleStream doubles = DoubleStream.of(FLOATING_POINT_VALUES);\n+\n+        final AtomicInteger errors = new AtomicInteger();\n+        doubles.forEach(d -> {errors.addAndGet(testDoubleAbs(Math::abs, d));});\n+\n+        return errors.get();\n+    }\n+\n+    private static int testDoubleAbs(DoubleUnaryOperator absFunc, double d) {\n+        double result = absFunc.applyAsDouble(-d);\n+        if (Double.isNaN(d)) {\n+            return Double.doubleToRawLongBits(result) !=\n+                Double.doubleToRawLongBits(d) ? 1 : 0;\n+        } else if ((d >= 0 && result != d) || (d < 0 && result != -d)) {\n+            System.err.printf(\"Unexpected double abs result %f for argument %f%n\",\n+                              result, d);\n+            return 1;\n+        } else {\n+            return 0;\n+        }\n+    }\n","filename":"test\/jdk\/java\/lang\/Math\/AbsTests.java","additions":86,"deletions":2,"binary":false,"changes":88,"status":"modified"}]}