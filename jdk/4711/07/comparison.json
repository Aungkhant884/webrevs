{"files":[{"patch":"@@ -1530,1 +1530,2 @@\n-        return (a <= 0.0F) ? 0.0F - a : a;\n+        \/\/ Convert to bit field form, zero the sign bit, and convert back\n+        return Float.intBitsToFloat(Float.floatToRawIntBits(a) & FloatConsts.MAG_BIT_MASK);\n@@ -1555,1 +1556,3 @@\n-        return (a <= 0.0D) ? 0.0D - a : a;\n+        \/\/ Convert to bit field form, zero the sign bit, and convert back\n+        return Double.longBitsToDouble(Double.doubleToRawLongBits(a) & DoubleConsts.MAG_BIT_MASK);\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Math.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -76,0 +76,6 @@\n+    \/**\n+     * Bit mask to isolate the magnitude bits (combined exponent and\n+     * significand fields) of a {@code double}.\n+     *\/\n+    public static final long    MAG_BIT_MASK = ~SIGN_BIT_MASK;\n+\n@@ -82,1 +88,3 @@\n-                ((EXP_BIT_MASK & SIGNIF_BIT_MASK) == 0L)));\n+                ((EXP_BIT_MASK & SIGNIF_BIT_MASK) == 0L)) &&\n+                ((SIGN_BIT_MASK | MAG_BIT_MASK) == ~0));\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/math\/DoubleConsts.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,0 +76,6 @@\n+    \/**\n+     * Bit mask to isolate the magnitude bits (combined exponent and\n+     * significand fields) of a {@code float}.\n+     *\/\n+    public static final int     MAG_BIT_MASK = ~SIGN_BIT_MASK;\n+\n@@ -82,1 +88,2 @@\n-                ((EXP_BIT_MASK & SIGNIF_BIT_MASK) == 0)));\n+                ((EXP_BIT_MASK & SIGNIF_BIT_MASK) == 0)) &&\n+                ((SIGN_BIT_MASK | MAG_BIT_MASK) == ~0));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/math\/FloatConsts.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,8 @@\n-import java.util.function.*;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.DoubleUnaryOperator;\n+import java.util.function.IntUnaryOperator;\n+import java.util.function.LongUnaryOperator;\n+import java.util.function.UnaryOperator;\n+import java.util.stream.DoubleStream;\n+import jdk.internal.math.DoubleConsts;\n+import jdk.internal.math.FloatConsts;\n@@ -28,1 +35,1 @@\n- * @bug 8241374\n+ * @bug 6506405 8241374\n@@ -30,0 +37,1 @@\n+ * @modules java.base\/jdk.internal.math\n@@ -32,0 +40,30 @@\n+    private static final double GELFOND = Math.exp(Math.PI);\n+    private static final double TAU     = 2.0*Math.PI;\n+\n+    \/\/ Values for testing float and double abs\n+    private static final double[] FLOATING_POINT_VALUES = new double[] {\n+        0.0,\n+        -0.0,\n+        +0.0,\n+        Double.MIN_VALUE,\n+        Double.MIN_NORMAL,\n+        Double.NEGATIVE_INFINITY,\n+        Double.POSITIVE_INFINITY,\n+        Double.NaN,\n+        Float.MIN_VALUE,\n+        Float.MIN_NORMAL,\n+        Float.NEGATIVE_INFINITY,\n+        Float.POSITIVE_INFINITY,\n+        Float.NaN,\n+        Double.longBitsToDouble((1 << DoubleConsts.SIGNIFICAND_WIDTH) |\n+           ((1 << DoubleConsts.SIGNIFICAND_WIDTH) - 1)),\n+        DoubleConsts.MAG_BIT_MASK >>> 1,\n+        Float.intBitsToFloat((1 << FloatConsts.SIGNIFICAND_WIDTH) |\n+           ((1 << FloatConsts.SIGNIFICAND_WIDTH) - 1)),\n+        FloatConsts.MAG_BIT_MASK >>> 1,\n+        Math.E,\n+        GELFOND,\n+        Math.PI,\n+        TAU\n+    };\n+\n@@ -39,0 +77,2 @@\n+        errors += testFloatAbs();\n+        errors += testDoubleAbs();\n@@ -45,0 +85,2 @@\n+    \/\/ --------------------------------------------------------------------\n+\n@@ -146,0 +188,61 @@\n+\n+    \/\/ --------------------------------------------------------------------\n+\n+    private static int testFloatAbs() {\n+        DoubleStream doubles = DoubleStream.of(FLOATING_POINT_VALUES);\n+\n+        final AtomicInteger errors = new AtomicInteger();\n+        doubles.mapToObj(d -> (float)d).\n+            forEach(f -> {errors.addAndGet(testFloatAbs(f));});\n+\n+        return errors.get();\n+    }\n+\n+    private static int testFloatAbs(float f) {\n+        int errors  = testFloatAbs(\"Math.abs\", Math::abs, f);\n+        errors     += testFloatAbs(\"Math.abs\", Math::abs, -f);\n+        errors     += testFloatAbs(\"StrictMath.abs\", StrictMath::abs, f);\n+        errors     += testFloatAbs(\"StrictMath.abs\", StrictMath::abs, -f);\n+        return errors;\n+    }\n+\n+    private static int testFloatAbs(String testName,\n+                                    UnaryOperator<Float> absFunc, float f) {\n+        float result = absFunc.apply(-f);\n+        if (Float.isNaN(f) && Float.isNaN(result)) {\n+            return 0;\n+        }\n+\n+        float expected = f == -0.0F ? 0.0F : (f < 0.0F ? -f : f);\n+        return Tests.test(testName, f, result, expected);\n+    }\n+\n+    \/\/ --------------------------------------------------------------------\n+\n+    private static int testDoubleAbs() {\n+        DoubleStream doubles = DoubleStream.of(FLOATING_POINT_VALUES);\n+\n+        final AtomicInteger errors = new AtomicInteger();\n+        doubles.forEach(d -> {errors.addAndGet(testDoubleAbs(d));});\n+\n+        return errors.get();\n+    }\n+\n+    private static int testDoubleAbs(double d) {\n+        int errors  = testDoubleAbs(\"Math.abs\", Math::abs, d);\n+        errors     += testDoubleAbs(\"Math.abs\", Math::abs, -d);\n+        errors     += testDoubleAbs(\"StrictMath.abs\", StrictMath::abs, d);\n+        errors     += testDoubleAbs(\"StrictMath.abs\", StrictMath::abs, -d);\n+        return errors;\n+    }\n+\n+    private static int testDoubleAbs(String testName,\n+                                     DoubleUnaryOperator absFunc, double d) {\n+        double result = absFunc.applyAsDouble(-d);\n+        if (Double.isNaN(d) && Double.isNaN(result)) {\n+            return 0;\n+        }\n+\n+        double expected = d == -0.0F ? 0.0F : (d < 0.0F ? -d : d);\n+        return Tests.test(testName, d, result, expected);\n+    }\n","filename":"test\/jdk\/java\/lang\/Math\/AbsTests.java","additions":106,"deletions":3,"binary":false,"changes":109,"status":"modified"}]}