{"files":[{"patch":"@@ -1530,1 +1530,2 @@\n-        return (a <= 0.0F) ? 0.0F - a : a;\n+        \/\/ Convert to bit field form, zero the sign bit, and convert back\n+        return Float.intBitsToFloat(Float.floatToRawIntBits(a) & FloatConsts.MAG_BIT_MASK);\n@@ -1555,1 +1556,3 @@\n-        return (a <= 0.0D) ? 0.0D - a : a;\n+        \/\/ Convert to bit field form, zero the sign bit, and convert back\n+        return Double.longBitsToDouble(Double.doubleToRawLongBits(a) & DoubleConsts.MAG_BIT_MASK);\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Math.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -76,0 +76,6 @@\n+    \/**\n+     * Bit mask to isolate the magnitude bits (combined exponent and\n+     * significand fields) of a {@code double}.\n+     *\/\n+    public static final long    MAG_BIT_MASK = ~SIGN_BIT_MASK;\n+\n@@ -82,1 +88,3 @@\n-                ((EXP_BIT_MASK & SIGNIF_BIT_MASK) == 0L)));\n+                ((EXP_BIT_MASK & SIGNIF_BIT_MASK) == 0L)) &&\n+                ((SIGN_BIT_MASK | MAG_BIT_MASK) == ~0));\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/math\/DoubleConsts.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,0 +76,6 @@\n+    \/**\n+     * Bit mask to isolate the magnitude bits (combined exponent and\n+     * significand fields) of a {@code float}.\n+     *\/\n+    public static final int     MAG_BIT_MASK = ~SIGN_BIT_MASK;\n+\n@@ -82,1 +88,2 @@\n-                ((EXP_BIT_MASK & SIGNIF_BIT_MASK) == 0)));\n+                ((EXP_BIT_MASK & SIGNIF_BIT_MASK) == 0)) &&\n+                ((SIGN_BIT_MASK | MAG_BIT_MASK) == ~0));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/math\/FloatConsts.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,2 @@\n+import jdk.internal.math.DoubleConsts;\n+import jdk.internal.math.FloatConsts;\n@@ -28,1 +30,1 @@\n- * @bug 8241374\n+ * @bug 6506405 8241374\n@@ -30,0 +32,1 @@\n+ * @modules java.base\/jdk.internal.math\n@@ -32,0 +35,10 @@\n+    private static final float  EULER_F   = (float)Math.exp(1.0);\n+    private static final float  GELFOND_F = (float)Math.exp(Math.PI);\n+    private static final float  PI_F      = (float)Math.PI;\n+    private static final float  TAU_F     = 2.0F*PI_F;\n+\n+    private static final double EULER_D   = Math.exp(1.0);\n+    private static final double GELFOND_D = Math.exp(Math.PI);\n+    private static final double PI_D      = Math.PI;\n+    private static final double TAU_D     = 2.0*PI_D;\n+\n@@ -39,0 +52,2 @@\n+        errors += testInRangeFloatAbs();\n+        errors += testInRangeDoubleAbs();\n@@ -45,0 +60,2 @@\n+    \/\/ --------------------------------------------------------------------\n+\n@@ -146,0 +163,86 @@\n+\n+    \/\/ --------------------------------------------------------------------\n+\n+    private static float testInRangeFloatAbs() {\n+        int errors = 0;\n+        float[][] testCases  = {\n+            \/\/ Argument to abs, expected result\n+            {+0.0F, 0.0F},\n+            {-0.0F, 0.0F},\n+            {-Float.MIN_VALUE, Float.MIN_VALUE},\n+            {-Float.MIN_NORMAL, Float.MIN_NORMAL},\n+            {Float.NEGATIVE_INFINITY, Float.POSITIVE_INFINITY},\n+            {Float.POSITIVE_INFINITY, Float.POSITIVE_INFINITY},\n+            {Float.intBitsToFloat(FloatConsts.SIGN_BIT_MASK |\n+                (1 << FloatConsts.SIGNIFICAND_WIDTH) |\n+               ((1 << FloatConsts.SIGNIFICAND_WIDTH) - 1)),\n+             Float.intBitsToFloat((1 << FloatConsts.SIGNIFICAND_WIDTH) |\n+               ((1 << FloatConsts.SIGNIFICAND_WIDTH) - 1))},\n+            {FloatConsts.SIGN_BIT_MASK | (FloatConsts.MAG_BIT_MASK >>> 1),\n+                FloatConsts.MAG_BIT_MASK >>> 1},\n+            {-EULER_F, EULER_F},\n+            {-GELFOND_F, GELFOND_F},\n+            {-PI_F, PI_F},\n+            {-TAU_F, TAU_F}\n+        };\n+\n+        for(var testCase : testCases) {\n+            errors += testFloatAbs(Math::abs,      testCase[0], testCase[1]);\n+        }\n+        return errors;\n+    }\n+\n+    private static int testFloatAbs(UnaryOperator<Float> absFunc,\n+                           float argument, float expected) {\n+        float result = absFunc.apply(argument);\n+        if (result != expected) {\n+            System.err.printf(\"Unexpected float abs result %f for argument %f%n\",\n+                                result, argument);\n+            return 1;\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+    \/\/ --------------------------------------------------------------------\n+\n+    private static double testInRangeDoubleAbs() {\n+        int errors = 0;\n+        double[][] testCases  = {\n+            \/\/ Argument to abs, expected result\n+            {+0.0, 0.0},\n+            {-0.0, 0.0},\n+            {-Double.MIN_VALUE, Double.MIN_VALUE},\n+            {-Double.MIN_NORMAL, Double.MIN_NORMAL},\n+            {Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY},\n+            {Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY},\n+            {Double.longBitsToDouble(DoubleConsts.SIGN_BIT_MASK |\n+                (1 << DoubleConsts.SIGNIFICAND_WIDTH) |\n+               ((1 << DoubleConsts.SIGNIFICAND_WIDTH) - 1)),\n+             Double.longBitsToDouble((1 << DoubleConsts.SIGNIFICAND_WIDTH) |\n+               ((1 << DoubleConsts.SIGNIFICAND_WIDTH) - 1))},\n+            {DoubleConsts.SIGN_BIT_MASK | (DoubleConsts.MAG_BIT_MASK >>> 1),\n+                DoubleConsts.MAG_BIT_MASK >>> 1},\n+            {-EULER_D, EULER_D},\n+            {-GELFOND_D, GELFOND_D},\n+            {-PI_D, PI_D},\n+            {-TAU_D, TAU_D}\n+        };\n+\n+        for(var testCase : testCases) {\n+            errors += testDoubleAbs(Math::abs,      testCase[0], testCase[1]);\n+        }\n+        return errors;\n+    }\n+\n+    private static int testDoubleAbs(DoubleUnaryOperator absFunc,\n+                           double argument, double expected) {\n+        double result = absFunc.applyAsDouble(argument);\n+        if (result != expected) {\n+            System.err.printf(\"Unexpected double abs result %f for argument %f%n\",\n+                                result, argument);\n+            return 1;\n+        } else {\n+            return 0;\n+        }\n+    }\n","filename":"test\/jdk\/java\/lang\/Math\/AbsTests.java","additions":105,"deletions":2,"binary":false,"changes":107,"status":"modified"}]}