{"files":[{"patch":"@@ -24,0 +24,1 @@\n+import java.util.concurrent.atomic.AtomicInteger;\n@@ -25,0 +26,3 @@\n+import java.util.function.DoubleConsumer;\n+import java.util.stream.DoubleStream;\n+import java.util.stream.Stream;\n@@ -35,9 +39,21 @@\n-    private static final float  EULER_F   = (float)Math.exp(1.0);\n-    private static final float  GELFOND_F = (float)Math.exp(Math.PI);\n-    private static final float  PI_F      = (float)Math.PI;\n-    private static final float  TAU_F     = 2.0F*PI_F;\n-\n-    private static final double EULER_D   = Math.exp(1.0);\n-    private static final double GELFOND_D = Math.exp(Math.PI);\n-    private static final double PI_D      = Math.PI;\n-    private static final double TAU_D     = 2.0*PI_D;\n+    private static final double GELFOND = Math.exp(Math.PI);\n+    private static final double TAU     = 2.0*Math.PI;\n+\n+    \/\/ Values for testing float and double abs\n+    private static final double[] FLOATING_POINT_VALUES = new double[] {\n+        0.0,\n+        -0.0,\n+        +0.0,\n+        Double.MIN_VALUE,\n+        Double.MIN_NORMAL,\n+        Double.NEGATIVE_INFINITY,\n+        Double.POSITIVE_INFINITY,\n+        Double.NaN,\n+        Double.longBitsToDouble((1 << DoubleConsts.SIGNIFICAND_WIDTH) |\n+           ((1 << DoubleConsts.SIGNIFICAND_WIDTH) - 1)),\n+        DoubleConsts.MAG_BIT_MASK >>> 1,\n+        Math.E,\n+        GELFOND,\n+        Math.PI,\n+        TAU\n+    };\n@@ -52,2 +68,2 @@\n-        errors += testInRangeFloatAbs();\n-        errors += testInRangeDoubleAbs();\n+        errors += testFloatAbs();\n+        errors += testDoubleAbs();\n@@ -166,22 +182,2 @@\n-    private static float testInRangeFloatAbs() {\n-        int errors = 0;\n-        float[][] testCases  = {\n-            \/\/ Argument to abs, expected result\n-            {+0.0F, 0.0F},\n-            {-0.0F, 0.0F},\n-            {-Float.MIN_VALUE, Float.MIN_VALUE},\n-            {-Float.MIN_NORMAL, Float.MIN_NORMAL},\n-            {Float.NEGATIVE_INFINITY, Float.POSITIVE_INFINITY},\n-            {Float.POSITIVE_INFINITY, Float.POSITIVE_INFINITY},\n-            {Float.intBitsToFloat(FloatConsts.SIGN_BIT_MASK |\n-                (1 << FloatConsts.SIGNIFICAND_WIDTH) |\n-               ((1 << FloatConsts.SIGNIFICAND_WIDTH) - 1)),\n-             Float.intBitsToFloat((1 << FloatConsts.SIGNIFICAND_WIDTH) |\n-               ((1 << FloatConsts.SIGNIFICAND_WIDTH) - 1))},\n-            {FloatConsts.SIGN_BIT_MASK | (FloatConsts.MAG_BIT_MASK >>> 1),\n-                FloatConsts.MAG_BIT_MASK >>> 1},\n-            {-EULER_F, EULER_F},\n-            {-GELFOND_F, GELFOND_F},\n-            {-PI_F, PI_F},\n-            {-TAU_F, TAU_F}\n-        };\n+    private static int testFloatAbs() {\n+        DoubleStream doubles = DoubleStream.of(FLOATING_POINT_VALUES);\n@@ -189,4 +185,5 @@\n-        for(var testCase : testCases) {\n-            errors += testFloatAbs(Math::abs,      testCase[0], testCase[1]);\n-        }\n-        return errors;\n+        final AtomicInteger errors = new AtomicInteger();\n+        doubles.mapToObj(d -> (float)d).\n+            forEach(f -> {errors.addAndGet(testFloatAbs(Math::abs, f));});\n+\n+        return errors.get();\n@@ -195,4 +192,6 @@\n-    private static int testFloatAbs(UnaryOperator<Float> absFunc,\n-                           float argument, float expected) {\n-        float result = absFunc.apply(argument);\n-        if (result != expected) {\n+    private static int testFloatAbs(UnaryOperator<Float> absFunc, float f) {\n+        float result = absFunc.apply(-f);\n+        if (Float.isNaN(f)) {\n+            return Float.floatToRawIntBits(result) !=\n+                Float.floatToRawIntBits(f) ? 1 : 0;\n+        } else if ((f >= 0 && result != f) || (f < 0 && result != -f)) {\n@@ -200,1 +199,1 @@\n-                                result, argument);\n+                              result, f);\n@@ -209,22 +208,2 @@\n-    private static double testInRangeDoubleAbs() {\n-        int errors = 0;\n-        double[][] testCases  = {\n-            \/\/ Argument to abs, expected result\n-            {+0.0, 0.0},\n-            {-0.0, 0.0},\n-            {-Double.MIN_VALUE, Double.MIN_VALUE},\n-            {-Double.MIN_NORMAL, Double.MIN_NORMAL},\n-            {Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY},\n-            {Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY},\n-            {Double.longBitsToDouble(DoubleConsts.SIGN_BIT_MASK |\n-                (1 << DoubleConsts.SIGNIFICAND_WIDTH) |\n-               ((1 << DoubleConsts.SIGNIFICAND_WIDTH) - 1)),\n-             Double.longBitsToDouble((1 << DoubleConsts.SIGNIFICAND_WIDTH) |\n-               ((1 << DoubleConsts.SIGNIFICAND_WIDTH) - 1))},\n-            {DoubleConsts.SIGN_BIT_MASK | (DoubleConsts.MAG_BIT_MASK >>> 1),\n-                DoubleConsts.MAG_BIT_MASK >>> 1},\n-            {-EULER_D, EULER_D},\n-            {-GELFOND_D, GELFOND_D},\n-            {-PI_D, PI_D},\n-            {-TAU_D, TAU_D}\n-        };\n+    private static int testDoubleAbs() {\n+        DoubleStream doubles = DoubleStream.of(FLOATING_POINT_VALUES);\n@@ -232,4 +211,4 @@\n-        for(var testCase : testCases) {\n-            errors += testDoubleAbs(Math::abs,      testCase[0], testCase[1]);\n-        }\n-        return errors;\n+        final AtomicInteger errors = new AtomicInteger();\n+        doubles.forEach(d -> {errors.addAndGet(testDoubleAbs(Math::abs, d));});\n+\n+        return errors.get();\n@@ -238,4 +217,6 @@\n-    private static int testDoubleAbs(DoubleUnaryOperator absFunc,\n-                           double argument, double expected) {\n-        double result = absFunc.applyAsDouble(argument);\n-        if (result != expected) {\n+    private static int testDoubleAbs(DoubleUnaryOperator absFunc, double d) {\n+        double result = absFunc.applyAsDouble(-d);\n+        if (Double.isNaN(d)) {\n+            return Double.doubleToRawLongBits(result) !=\n+                Double.doubleToRawLongBits(d) ? 1 : 0;\n+        } else if ((d >= 0 && result != d) || (d < 0 && result != -d)) {\n@@ -243,1 +224,1 @@\n-                                result, argument);\n+                              result, d);\n","filename":"test\/jdk\/java\/lang\/Math\/AbsTests.java","additions":54,"deletions":73,"binary":false,"changes":127,"status":"modified"}]}