{"files":[{"patch":"@@ -122,0 +122,1 @@\n+      classLoaderDataShared.cpp \\\n","filename":"make\/hotspot\/lib\/JvmFeatures.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -201,0 +201,1 @@\n+JVM_DefineArchivedModules\n","filename":"make\/hotspot\/symbols\/symbols-unix","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1647,1 +1647,2 @@\n-    ModuleEntry* jb_module = null_cld_modules->locked_create_entry(Handle(),\n+    if (ModuleEntryTable::javabase_moduleEntry() == NULL) {  \/\/ may have been inited by CDS.\n+      ModuleEntry* jb_module = null_cld_modules->locked_create_entry(Handle(),\n@@ -1649,2 +1650,4 @@\n-    if (jb_module == NULL) {\n-      vm_exit_during_initialization(\"Unable to create ModuleEntry for \" JAVA_BASE_NAME);\n+      if (jb_module == NULL) {\n+        vm_exit_during_initialization(\"Unable to create ModuleEntry for \" JAVA_BASE_NAME);\n+      }\n+      ModuleEntryTable::set_javabase_moduleEntry(jb_module);\n@@ -1652,1 +1655,0 @@\n-    ModuleEntryTable::set_javabase_moduleEntry(jb_module);\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,202 @@\n+ \/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"classfile\/classLoaderData.inline.hpp\"\n+#include \"classfile\/classLoaderDataShared.hpp\"\n+#include \"classfile\/moduleEntry.hpp\"\n+#include \"classfile\/packageEntry.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"memory\/metaspaceShared.hpp\"\n+#include \"runtime\/handles.inline.hpp\"\n+\n+#if INCLUDE_CDS_JAVA_HEAP\n+\n+class ArchivedClassLoaderData {\n+  Array<PackageEntry*>* _packages;\n+  Array<ModuleEntry*>* _modules;\n+\n+  void assert_valid(ClassLoaderData* loader_data) {\n+    \/\/ loader_data may be NULL if the boot layer has loaded no modules for the platform or\n+    \/\/ system loaders (e.g., if you create a custom JDK image with only java.base).\n+    if (loader_data != NULL) {\n+      assert(!loader_data->has_class_mirror_holder(),\n+             \"loaders for non-strong hidden classes or unsafe anonymous classes not supported\");\n+    }\n+  }\n+public:\n+  ArchivedClassLoaderData() : _packages(NULL), _modules(NULL) {}\n+\n+  void iterate_symbols(ClassLoaderData* loader_data, MetaspaceClosure* closure);\n+  void allocate(ClassLoaderData* loader_data);\n+  void init_archived_entries(ClassLoaderData* loader_data);\n+  void init_archived_oops(ClassLoaderData* loader_data);\n+\n+  void serialize(SerializeClosure* f) {\n+    f->do_ptr((void**)&_packages);\n+    f->do_ptr((void**)&_modules);\n+  }\n+\n+  void restore(ClassLoaderData* loader_data, bool do_entries, bool do_oops);\n+};\n+\n+static ArchivedClassLoaderData _archived_boot_loader_data;\n+static ArchivedClassLoaderData _archived_platform_loader_data;\n+static ArchivedClassLoaderData _archived_system_loader_data;\n+static ModuleEntry* _archived_javabase_moduleEntry = NULL;\n+\n+void ArchivedClassLoaderData::iterate_symbols(ClassLoaderData* loader_data, MetaspaceClosure* closure) {\n+  assert(DumpSharedSpaces, \"must be\");\n+  assert_valid(loader_data);\n+  if (loader_data != NULL) {\n+    loader_data->packages()->iterate_symbols(closure);\n+    loader_data->modules() ->iterate_symbols(closure);\n+  }\n+}\n+\n+void ArchivedClassLoaderData::allocate(ClassLoaderData* loader_data) {\n+  assert(DumpSharedSpaces, \"must be\");\n+  assert_valid(loader_data);\n+  if (loader_data != NULL) {\n+    \/\/ We can't create hashtables at dump time because the hashcode depends on the\n+    \/\/ address of the Symbols, which may be relocated at runtime due to ASLR.\n+    \/\/ So we store the packages\/modules in Arrays. At runtime, we create\n+    \/\/ the hashtables using these arrays.\n+    _packages = loader_data->packages()->allocate_archived_entries();\n+    _modules  = loader_data->modules() ->allocate_archived_entries();\n+  }\n+}\n+\n+void ArchivedClassLoaderData::init_archived_entries(ClassLoaderData* loader_data) {\n+  assert(DumpSharedSpaces, \"must be\");\n+  assert_valid(loader_data);\n+  if (loader_data != NULL) {\n+    loader_data->packages()->init_archived_entries(_packages);\n+    loader_data->modules() ->init_archived_entries(_modules);\n+  }\n+}\n+\n+void ArchivedClassLoaderData::init_archived_oops(ClassLoaderData* loader_data) {\n+  assert(DumpSharedSpaces, \"must be\");\n+  assert_valid(loader_data);\n+  if (loader_data != NULL) {\n+    loader_data->modules()->init_archived_oops(_modules);\n+  }\n+}\n+\n+void ArchivedClassLoaderData::restore(ClassLoaderData* loader_data, bool do_entries, bool do_oops) {\n+  assert(UseSharedSpaces, \"must be\");\n+  assert_valid(loader_data);\n+  if (_modules != NULL) { \/\/ Could be NULL if we have archived no modules for platform\/system loaders\n+    ModuleEntryTable* modules = loader_data->modules();\n+    PackageEntryTable* packages = loader_data->packages();\n+\n+    MutexLocker m1(Module_lock);\n+    if (do_entries) {\n+      modules->load_archived_entries(loader_data, _modules);\n+      packages->load_archived_entries(_packages);\n+    }\n+    if (do_oops) {\n+      modules->restore_archived_oops(loader_data, _modules);\n+    }\n+  }\n+}\n+\n+\/\/ ------------------------------\n+\n+static ClassLoaderData* null_class_loader_data() {\n+  ClassLoaderData* loader_data = ClassLoaderData::the_null_class_loader_data();\n+  assert(loader_data != NULL, \"must be\");\n+  return loader_data;\n+}\n+\n+static ClassLoaderData* java_platform_loader_data_or_null() {\n+  return ClassLoaderData::class_loader_data_or_null(SystemDictionary::java_platform_loader());\n+}\n+\n+static ClassLoaderData* java_system_loader_data_or_null() {\n+  return ClassLoaderData::class_loader_data_or_null(SystemDictionary::java_system_loader());\n+}\n+\n+void ClassLoaderDataShared::iterate_symbols(MetaspaceClosure* closure) {\n+  assert(DumpSharedSpaces && MetaspaceShared::use_full_module_graph(), \"must be\");\n+  _archived_boot_loader_data.iterate_symbols    (null_class_loader_data(), closure);\n+  _archived_platform_loader_data.iterate_symbols(java_platform_loader_data_or_null(), closure);\n+  _archived_system_loader_data.iterate_symbols  (java_system_loader_data_or_null(), closure);\n+}\n+\n+void ClassLoaderDataShared::allocate_archived_tables() {\n+  assert(DumpSharedSpaces && MetaspaceShared::use_full_module_graph(), \"must be\");\n+  _archived_boot_loader_data.allocate    (null_class_loader_data());\n+  _archived_platform_loader_data.allocate(java_platform_loader_data_or_null());\n+  _archived_system_loader_data.allocate  (java_system_loader_data_or_null());\n+}\n+\n+void ClassLoaderDataShared::init_archived_tables() {\n+  assert(DumpSharedSpaces && MetaspaceShared::use_full_module_graph(), \"must be\");\n+  _archived_boot_loader_data.init_archived_entries    (null_class_loader_data());\n+  _archived_platform_loader_data.init_archived_entries(java_platform_loader_data_or_null());\n+  _archived_system_loader_data.init_archived_entries  (java_system_loader_data_or_null());\n+  _archived_javabase_moduleEntry = ModuleEntry::get_archived_entry(ModuleEntryTable::javabase_moduleEntry());\n+}\n+\n+void ClassLoaderDataShared::init_archived_oops() {\n+  assert(DumpSharedSpaces && MetaspaceShared::use_full_module_graph(), \"must be\");\n+  _archived_boot_loader_data.init_archived_oops    (null_class_loader_data());\n+  _archived_platform_loader_data.init_archived_oops(java_platform_loader_data_or_null());\n+  _archived_system_loader_data.init_archived_oops  (java_system_loader_data_or_null());\n+}\n+\n+void ClassLoaderDataShared::serialize(SerializeClosure* f) {\n+  _archived_boot_loader_data.serialize(f);\n+  _archived_platform_loader_data.serialize(f);\n+  _archived_system_loader_data.serialize(f);\n+  f->do_ptr((void**)&_archived_javabase_moduleEntry);\n+\n+  if (f->reading() && MetaspaceShared::use_full_module_graph()) {\n+    \/\/ Must be done before ClassLoader::create_javabase()\n+    _archived_boot_loader_data.restore(null_class_loader_data(), true, false);\n+    ModuleEntryTable::set_javabase_moduleEntry(_archived_javabase_moduleEntry);\n+    log_info(cds)(\"use_full_module_graph = true; java.base = \" INTPTR_FORMAT,\n+                  p2i(_archived_javabase_moduleEntry));\n+  }\n+}\n+\n+oop ClassLoaderDataShared::restore_archived_oops_for_null_class_loader_data() {\n+  assert(UseSharedSpaces && MetaspaceShared::use_full_module_graph(), \"must be\");\n+  _archived_boot_loader_data.restore(null_class_loader_data(), false, true);\n+  return _archived_javabase_moduleEntry->module();\n+}\n+\n+void ClassLoaderDataShared::restore_java_platform_loader_from_archive(ClassLoaderData* loader_data) {\n+  assert(UseSharedSpaces && MetaspaceShared::use_full_module_graph(), \"must be\");\n+  _archived_platform_loader_data.restore(loader_data, true, true);\n+}\n+\n+void ClassLoaderDataShared::restore_java_system_loader_from_archive(ClassLoaderData* loader_data) {\n+  assert(UseSharedSpaces && MetaspaceShared::use_full_module_graph(), \"must be\");\n+  _archived_system_loader_data.restore(loader_data, true, true);\n+}\n+\n+#endif \/\/ INCLUDE_CDS_JAVA_HEAP\n","filename":"src\/hotspot\/share\/classfile\/classLoaderDataShared.cpp","additions":202,"deletions":0,"binary":false,"changes":202,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+ \/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_CLASSFILE_CLASSLOADERDATASHARED_HPP\n+#define SHARE_CLASSFILE_CLASSLOADERDATASHARED_HPP\n+\n+#include \"memory\/allStatic.hpp\"\n+#include \"oops\/oopsHierarchy.hpp\"\n+\n+class ClassLoaderData;\n+class MetaspaceClosure;\n+class SerializeClosure;\n+\n+class ClassLoaderDataShared : AllStatic {\n+public:\n+  static void allocate_archived_tables();\n+  static void iterate_symbols(MetaspaceClosure* closure);\n+  static void init_archived_tables();\n+  static void init_archived_oops();\n+  static void serialize(SerializeClosure* f);\n+  static oop  restore_archived_oops_for_null_class_loader_data();\n+  static void restore_java_platform_loader_from_archive(ClassLoaderData* loader_data);\n+  static void restore_java_system_loader_from_archive(ClassLoaderData* loader_data);\n+};\n+\n+#endif \/\/ SHARE_CLASSFILE_CLASSLOADERDATASHARED_HPP\n","filename":"src\/hotspot\/share\/classfile\/classLoaderDataShared.hpp","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -3395,1 +3395,1 @@\n-ModuleEntry* java_lang_Module::module_entry(oop module) {\n+ModuleEntry* java_lang_Module::module_entry_raw(oop module) {\n@@ -3401,0 +3401,5 @@\n+  return module_entry;\n+}\n+\n+ModuleEntry* java_lang_Module::module_entry(oop module) {\n+  ModuleEntry* module_entry = module_entry_raw(module);\n@@ -4824,1 +4829,0 @@\n-      klass == SystemDictionary::Module_klass() ||       \/\/ Module::module_entry is malloc'ed\n@@ -4826,1 +4830,1 @@\n-      \/\/ regular Java code. The implementation of java.lang.invoke uses generated anonymoys classes\n+      \/\/ regular Java code. The implementation of java.lang.invoke uses generated anonymous classes\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -800,0 +800,1 @@\n+    static ModuleEntry* module_entry_raw(oop module);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,2 @@\n+#include \"memory\/archiveBuilder.hpp\"\n+#include \"memory\/archiveUtils.hpp\"\n@@ -33,0 +35,2 @@\n+#include \"memory\/heapShared.hpp\"\n+#include \"memory\/metaspaceShared.hpp\"\n@@ -43,0 +47,2 @@\n+#include \"utilities\/quickSort.hpp\"\n+#include \"utilities\/resourceHash.hpp\"\n@@ -111,1 +117,1 @@\n-  return _pd.resolve();\n+  return _shared_pd.resolve();\n@@ -118,2 +124,2 @@\n-  \/\/ init_handle_locked checks if someone beats us setting the _pd cache.\n-  loader_data->init_handle_locked(_pd, pd_h);\n+  \/\/ init_handle_locked checks if someone beats us setting the _shared_pd cache.\n+  loader_data->init_handle_locked(_shared_pd, pd_h);\n@@ -365,0 +371,197 @@\n+#if INCLUDE_CDS_JAVA_HEAP\n+typedef ResourceHashtable<\n+  const ModuleEntry*,\n+  ModuleEntry*,\n+  primitive_hash<const ModuleEntry*>,\n+  primitive_equals<const ModuleEntry*>,\n+  557, \/\/ prime number\n+  ResourceObj::C_HEAP> ArchivedModuleEntries;\n+static ArchivedModuleEntries* _archive_modules_entries = NULL;\n+\n+ModuleEntry* ModuleEntry::allocate_archived_entry() const {\n+  assert(is_named(), \"unnamed packages\/modules are not archived\");\n+  ModuleEntry* archived_entry = (ModuleEntry*)MetaspaceShared::read_write_space_alloc(sizeof(ModuleEntry));\n+  memcpy((void*)archived_entry, (void*)this, sizeof(ModuleEntry));\n+\n+  if (_archive_modules_entries == NULL) {\n+    _archive_modules_entries = new (ResourceObj::C_HEAP, mtClass)ArchivedModuleEntries();\n+  }\n+  assert(_archive_modules_entries->get(this) == NULL, \"Each ModuleEntry must not be shared across ModuleEntryTables\");\n+  _archive_modules_entries->put(this, archived_entry);\n+\n+  return archived_entry;\n+}\n+\n+ModuleEntry* ModuleEntry::get_archived_entry(ModuleEntry* orig_entry) {\n+  ModuleEntry** ptr = _archive_modules_entries->get(orig_entry);\n+  assert(ptr != NULL && *ptr != NULL, \"must have been allocated\");\n+  return *ptr;\n+}\n+\n+\/\/ This function is used to archive ModuleEntry::_reads and PackageEntry::_qualified_exports.\n+\/\/ GrowableArray cannot be directly archived, as it needs to be expandable at runtime.\n+\/\/ Write it out as an Array, and convert it back to GrowableArray at runtime.\n+Array<ModuleEntry*>* ModuleEntry::write_growable_array(GrowableArray<ModuleEntry*>* array) {\n+  Array<ModuleEntry*>* archived_array = NULL;\n+  int length = (array == NULL) ? 0 : array->length();\n+  if (length > 0) {\n+    archived_array = MetaspaceShared::new_ro_array<ModuleEntry*>(length);\n+    for (int i = 0; i < length; i++) {\n+      ModuleEntry* archived_entry = get_archived_entry(array->at(i));\n+      archived_array->at_put(i, archived_entry);\n+      ArchivePtrMarker::mark_pointer((address*)archived_array->adr_at(i));\n+    }\n+  }\n+\n+  return archived_array;\n+}\n+\n+GrowableArray<ModuleEntry*>* ModuleEntry::restore_growable_array(Array<ModuleEntry*>* archived_array) {\n+  GrowableArray<ModuleEntry*>* array = NULL;\n+  int length = (archived_array == NULL) ? 0 : archived_array->length();\n+  if (length > 0) {\n+    array = new (ResourceObj::C_HEAP, mtModule)GrowableArray<ModuleEntry*>(length, mtModule);\n+    for (int i = 0; i < length; i++) {\n+      ModuleEntry* archived_entry = archived_array->at(i);\n+      array->append(archived_entry);\n+    }\n+  }\n+\n+  return array;\n+}\n+\n+void ModuleEntry::iterate_symbols(MetaspaceClosure* closure) {\n+  closure->push(literal_addr()); \/\/ name\n+  closure->push(&_version);\n+  closure->push(&_location);\n+}\n+\n+void ModuleEntry::init_as_archived_entry() {\n+  Array<ModuleEntry*>* archived_reads = write_growable_array(_reads);\n+\n+  set_next(NULL);\n+  set_hash(0x0);        \/\/ re-init at runtime\n+  _loader_data = NULL;  \/\/ re-init at runtime\n+  _shared_path_index = FileMapInfo::get_module_shared_path_index(_location);\n+  if (literal() != NULL) {\n+    set_literal(ArchiveBuilder::get_relocated_symbol(literal()));\n+    ArchivePtrMarker::mark_pointer((address*)literal_addr());\n+  }\n+  _reads = (GrowableArray<ModuleEntry*>*)archived_reads;\n+  if (_version != NULL) {\n+    _version = ArchiveBuilder::get_relocated_symbol(_version);\n+  }\n+  if (_location != NULL) {\n+    _location = ArchiveBuilder::get_relocated_symbol(_location);\n+  }\n+\n+  ArchivePtrMarker::mark_pointer((address*)&_reads);\n+  ArchivePtrMarker::mark_pointer((address*)&_version);\n+  ArchivePtrMarker::mark_pointer((address*)&_location);\n+}\n+\n+void ModuleEntry::init_archived_oops() {\n+  assert(DumpSharedSpaces, \"static dump only\");\n+  oop module_obj = module();\n+  if (module_obj != NULL) {\n+    oop m = HeapShared::find_archived_heap_object(module_obj);\n+    assert(m != NULL, \"sanity\");\n+    _archived_module_narrow_oop = CompressedOops::encode(m);\n+  }\n+  assert(shared_protection_domain() == NULL, \"never set during -Xshare:dump\");\n+  \/\/ Clear handles and restore at run time. Handles cannot be archived.\n+  OopHandle null_handle;\n+  _module = null_handle;\n+}\n+\n+void ModuleEntry::load_from_archive(ClassLoaderData* loader_data) {\n+  set_loader_data(loader_data);\n+  _reads = restore_growable_array((Array<ModuleEntry*>*)_reads);\n+  JFR_ONLY(INIT_ID(this);)\n+}\n+\n+void ModuleEntry::restore_archive_oops(ClassLoaderData* loader_data) {\n+  Handle module_handle(Thread::current(), HeapShared::materialize_archived_object(_archived_module_narrow_oop));\n+  assert(module_handle.not_null(), \"huh\");\n+  set_module(loader_data->add_handle(module_handle));\n+\n+  \/\/ This was cleared to zero during dump time -- we didn't save the value\n+  \/\/ because it may be affected by archive relocation.\n+  java_lang_Module::set_module_entry(module_handle(), this);\n+\n+  if (loader_data->class_loader() != NULL) {\n+    java_lang_Module::set_loader(module_handle(), loader_data->class_loader());\n+  }\n+}\n+\n+static int compare_module_by_name(ModuleEntry* a, ModuleEntry* b) {\n+  assert(a == b || a->name() != b->name(), \"no duplicated names\");\n+  return a->name()->fast_compare(b->name());\n+}\n+\n+void ModuleEntryTable::iterate_symbols(MetaspaceClosure* closure) {\n+  for (int i = 0; i < table_size(); ++i) {\n+    for (ModuleEntry* m = bucket(i); m != NULL; m = m->next()) {\n+      m->iterate_symbols(closure);\n+    }\n+  }\n+}\n+\n+Array<ModuleEntry*>* ModuleEntryTable::allocate_archived_entries() {\n+  Array<ModuleEntry*>* archived_modules = MetaspaceShared::new_rw_array<ModuleEntry*>(number_of_entries());\n+  int n = 0;\n+  for (int i = 0; i < table_size(); ++i) {\n+    for (ModuleEntry* m = bucket(i); m != NULL; m = m->next()) {\n+      archived_modules->at_put(n++, m);\n+    }\n+  }\n+  if (n > 1) {\n+    \/\/ Always allocate in the same order to produce deterministic archive.\n+    QuickSort::sort(archived_modules->data(), n, (_sort_Fn)compare_module_by_name, true);\n+  }\n+  for (int i = 0; i < n; i++) {\n+    archived_modules->at_put(i, archived_modules->at(i)->allocate_archived_entry());\n+    ArchivePtrMarker::mark_pointer((address*)archived_modules->adr_at(i));\n+  }\n+  return archived_modules;\n+}\n+\n+void ModuleEntryTable::init_archived_entries(Array<ModuleEntry*>* archived_modules) {\n+  assert(DumpSharedSpaces, \"dump time only\");\n+  for (int i = 0; i < archived_modules->length(); i++) {\n+    ModuleEntry* archived_entry = archived_modules->at(i);\n+    archived_entry->init_as_archived_entry();\n+  }\n+}\n+\n+void ModuleEntryTable::init_archived_oops(Array<ModuleEntry*>* archived_modules) {\n+  assert(DumpSharedSpaces, \"dump time only\");\n+  for (int i = 0; i < archived_modules->length(); i++) {\n+    ModuleEntry* archived_entry = archived_modules->at(i);\n+    archived_entry->init_archived_oops();\n+  }\n+}\n+\n+void ModuleEntryTable::load_archived_entries(ClassLoaderData* loader_data,\n+                                             Array<ModuleEntry*>* archived_modules) {\n+  assert(UseSharedSpaces, \"runtime only\");\n+\n+  for (int i = 0; i < archived_modules->length(); i++) {\n+    ModuleEntry* archived_entry = archived_modules->at(i);\n+    archived_entry->load_from_archive(loader_data);\n+\n+    unsigned int hash = compute_hash(archived_entry->name());\n+    archived_entry->set_hash(hash);\n+    add_entry(hash_to_index(hash), archived_entry);\n+  }\n+}\n+\n+void ModuleEntryTable::restore_archived_oops(ClassLoaderData* loader_data, Array<ModuleEntry*>* archived_modules) {\n+  assert(UseSharedSpaces, \"runtime only\");\n+  for (int i = 0; i < archived_modules->length(); i++) {\n+    ModuleEntry* archived_entry = archived_modules->at(i);\n+    archived_entry->restore_archive_oops(loader_data);\n+  }\n+}\n+#endif \/\/ INCLUDE_CDS_JAVA_HEAP\n+\n","filename":"src\/hotspot\/share\/classfile\/moduleEntry.cpp","additions":206,"deletions":3,"binary":false,"changes":209,"status":"modified"},{"patch":"@@ -50,0 +50,2 @@\n+template <class T> class Array;\n+class MetaspaceClosure;\n@@ -66,1 +68,1 @@\n-  OopHandle _pd;                       \/\/ java.security.ProtectionDomain, cached\n+  OopHandle _shared_pd;                \/\/ java.security.ProtectionDomain, cached\n@@ -78,0 +80,2 @@\n+  CDS_JAVA_HEAP_ONLY(narrowOop _archived_module_narrow_oop;)\n+\n@@ -84,1 +88,1 @@\n-    _pd = OopHandle();\n+    _shared_pd = OopHandle();\n@@ -191,0 +195,12 @@\n+\n+#if INCLUDE_CDS_JAVA_HEAP\n+  void iterate_symbols(MetaspaceClosure* closure);\n+  ModuleEntry* allocate_archived_entry() const;\n+  void init_as_archived_entry();\n+  void init_archived_oops();\n+  static ModuleEntry* get_archived_entry(ModuleEntry* orig_entry);\n+  static Array<ModuleEntry*>* write_growable_array(GrowableArray<ModuleEntry*>* array);\n+  static GrowableArray<ModuleEntry*>* restore_growable_array(Array<ModuleEntry*>* archived_array);\n+  void load_from_archive(ClassLoaderData* loader_data);\n+  void restore_archive_oops(ClassLoaderData* loader_data);\n+#endif\n@@ -273,0 +289,11 @@\n+\n+#if INCLUDE_CDS_JAVA_HEAP\n+  void iterate_symbols(MetaspaceClosure* closure);\n+  Array<ModuleEntry*>* allocate_archived_entries();\n+  void init_archived_entries(Array<ModuleEntry*>* archived_modules);\n+  void init_archived_oops(Array<ModuleEntry*>* archived_modules);\n+  void load_archived_entries(ClassLoaderData* loader_data,\n+                             Array<ModuleEntry*>* archived_modules);\n+  void restore_archived_oops(ClassLoaderData* loader_data,\n+                             Array<ModuleEntry*>* archived_modules);\n+#endif\n","filename":"src\/hotspot\/share\/classfile\/moduleEntry.hpp","additions":29,"deletions":2,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"classfile\/classLoaderDataShared.hpp\"\n@@ -42,0 +43,1 @@\n+#include \"memory\/metaspaceShared.hpp\"\n@@ -43,0 +45,1 @@\n+#include \"prims\/jvmtiExport.hpp\"\n@@ -271,0 +274,1 @@\n+  check_cds_restrictions(CHECK);\n@@ -453,0 +457,40 @@\n+#if INCLUDE_CDS_JAVA_HEAP\n+void Modules::define_archived_modules(jobject platform_loader, jobject system_loader, TRAPS) {\n+  assert(UseSharedSpaces && MetaspaceShared::use_full_module_graph(), \"must be\");\n+\n+  \/\/ We don't want the classes used by the archived full module graph to be redefined by JVMTI.\n+  \/\/ Luckily, such classes are loaded in the JVMTI \"early\" phase, and CDS is disabled if a JVMTI\n+  \/\/ agent wants to redefine classes in this phase.\n+  JVMTI_ONLY(assert(JvmtiExport::is_early_phase(), \"must be\"));\n+  assert(!(JvmtiExport::should_post_class_file_load_hook() && JvmtiExport::has_early_class_hook_env()),\n+         \"CDS should be disabled if early class hooks are enabled\");\n+\n+  Handle java_base_module(THREAD, ClassLoaderDataShared::restore_archived_oops_for_null_class_loader_data());\n+  \/\/ Patch any previously loaded class's module field with java.base's java.lang.Module.\n+  ModuleEntryTable::patch_javabase_entries(java_base_module);\n+\n+  if (platform_loader == NULL) {\n+    THROW_MSG(vmSymbols::java_lang_NullPointerException(), \"Null platform loader object\");\n+  }\n+\n+  if (system_loader == NULL) {\n+    THROW_MSG(vmSymbols::java_lang_NullPointerException(), \"Null system loader object\");\n+  }\n+\n+  Handle h_platform_loader(THREAD, JNIHandles::resolve_non_null(platform_loader));\n+  ClassLoaderData* platform_loader_data = SystemDictionary::register_loader(h_platform_loader);\n+  ClassLoaderDataShared::restore_java_platform_loader_from_archive(platform_loader_data);\n+\n+  Handle h_system_loader(THREAD, JNIHandles::resolve_non_null(system_loader));\n+  ClassLoaderData* system_loader_data = SystemDictionary::register_loader(h_system_loader);\n+  ClassLoaderDataShared::restore_java_system_loader_from_archive(system_loader_data);\n+}\n+\n+void Modules::check_cds_restrictions(TRAPS) {\n+  if (DumpSharedSpaces && Universe::is_module_initialized() && MetaspaceShared::use_full_module_graph()) {\n+    THROW_MSG(vmSymbols::java_lang_UnsupportedOperationException(),\n+              \"During -Xshare:dump, module system cannot be modified after it's initialized\");\n+  }\n+}\n+#endif \/\/ INCLUDE_CDS_JAVA_HEAP\n+\n@@ -491,0 +535,1 @@\n+  check_cds_restrictions(CHECK);\n@@ -558,0 +603,1 @@\n+  check_cds_restrictions(CHECK);\n@@ -566,0 +612,1 @@\n+  check_cds_restrictions(CHECK);\n@@ -671,0 +718,1 @@\n+  check_cds_restrictions(CHECK);\n","filename":"src\/hotspot\/share\/classfile\/modules.cpp","additions":48,"deletions":0,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+* Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+  static void check_cds_restrictions(TRAPS) NOT_CDS_JAVA_HEAP_RETURN;\n@@ -55,0 +56,3 @@\n+  static void define_archived_modules(jobject platform_loader, jobject system_loader,\n+                                      TRAPS) NOT_CDS_JAVA_HEAP_RETURN;\n+\n","filename":"src\/hotspot\/share\/classfile\/modules.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,0 +29,3 @@\n+#include \"memory\/archiveBuilder.hpp\"\n+#include \"memory\/archiveUtils.hpp\"\n+#include \"memory\/metaspaceShared.hpp\"\n@@ -30,0 +33,1 @@\n+#include \"oops\/array.hpp\"\n@@ -37,0 +41,2 @@\n+#include \"utilities\/quickSort.hpp\"\n+#include \"utilities\/resourceHash.hpp\"\n@@ -192,0 +198,120 @@\n+#if INCLUDE_CDS_JAVA_HEAP\n+typedef ResourceHashtable<\n+  const PackageEntry*,\n+  PackageEntry*,\n+  primitive_hash<const PackageEntry*>,\n+  primitive_equals<const PackageEntry*>,\n+  557, \/\/ prime number\n+  ResourceObj::C_HEAP> ArchivedPackageEntries;\n+static ArchivedPackageEntries* _archived_packages_entries = NULL;\n+\n+PackageEntry* PackageEntry::allocate_archived_entry() const {\n+  assert(!in_unnamed_module(), \"unnamed packages\/modules are not archived\");\n+  PackageEntry* archived_entry = (PackageEntry*)MetaspaceShared::read_write_space_alloc(sizeof(PackageEntry));\n+  memcpy((void*)archived_entry, (void*)this, sizeof(PackageEntry));\n+\n+  if (_archived_packages_entries == NULL) {\n+    _archived_packages_entries = new (ResourceObj::C_HEAP, mtClass)ArchivedPackageEntries();\n+  }\n+  assert(_archived_packages_entries->get(this) == NULL, \"Each PackageEntry must not be shared across PackageEntryTables\");\n+  _archived_packages_entries->put(this, archived_entry);\n+\n+  return archived_entry;\n+}\n+\n+PackageEntry* PackageEntry::get_archived_entry(PackageEntry* orig_entry) {\n+  PackageEntry** ptr = _archived_packages_entries->get(orig_entry);\n+  assert(ptr != NULL && *ptr != NULL, \"must have been allocated\");\n+  return *ptr;\n+}\n+\n+void PackageEntry::iterate_symbols(MetaspaceClosure* closure) {\n+  closure->push(literal_addr()); \/\/ name\n+}\n+\n+void PackageEntry::init_as_archived_entry() {\n+  Array<ModuleEntry*>* archived_qualified_exports = ModuleEntry::write_growable_array(_qualified_exports);\n+\n+  set_next(NULL);\n+  set_literal(ArchiveBuilder::get_relocated_symbol(literal()));\n+  set_hash(0x0);  \/\/ re-init at runtime\n+  _module = ModuleEntry::get_archived_entry(_module);\n+  _qualified_exports = (GrowableArray<ModuleEntry*>*)archived_qualified_exports;\n+  _defined_by_cds_in_class_path = 0;\n+\n+  ArchivePtrMarker::mark_pointer((address*)literal_addr());\n+  ArchivePtrMarker::mark_pointer((address*)&_module);\n+  ArchivePtrMarker::mark_pointer((address*)&_qualified_exports);\n+}\n+\n+void PackageEntry::load_from_archive() {\n+  _qualified_exports = ModuleEntry::restore_growable_array((Array<ModuleEntry*>*)_qualified_exports);\n+  JFR_ONLY(INIT_ID(this);)\n+}\n+\n+static int compare_package_by_name(PackageEntry* a, PackageEntry* b) {\n+  assert(a == b || a->name() != b->name(), \"no duplicated names\");\n+  return a->name()->fast_compare(b->name());\n+}\n+\n+void PackageEntryTable::iterate_symbols(MetaspaceClosure* closure) {\n+  for (int i = 0; i < table_size(); ++i) {\n+    for (PackageEntry* p = bucket(i); p != NULL; p = p->next()) {\n+      p->iterate_symbols(closure);\n+    }\n+  }\n+}\n+\n+Array<PackageEntry*>* PackageEntryTable::allocate_archived_entries() {\n+  \/\/ First count the packages in named modules\n+  int n, i;\n+  for (n = 0, i = 0; i < table_size(); ++i) {\n+    for (PackageEntry* p = bucket(i); p != NULL; p = p->next()) {\n+      if (p->module()->name() != NULL) {\n+        n++;\n+      }\n+    }\n+  }\n+\n+  Array<PackageEntry*>* archived_packages = MetaspaceShared::new_rw_array<PackageEntry*>(n);\n+  for (n = 0, i = 0; i < table_size(); ++i) {\n+    for (PackageEntry* p = bucket(i); p != NULL; p = p->next()) {\n+      if (p->module()->name() != NULL) {\n+        \/\/ We don't archive unnamed modules, or packages in unnamed modules. They will be\n+        \/\/ created on-demand at runtime as classes in such packages are loaded.\n+        archived_packages->at_put(n++, p);\n+      }\n+    }\n+  }\n+  if (n > 1) {\n+    QuickSort::sort(archived_packages->data(), n, (_sort_Fn)compare_package_by_name, true);\n+  }\n+  for (i = 0; i < n; i++) {\n+    archived_packages->at_put(i, archived_packages->at(i)->allocate_archived_entry());\n+    ArchivePtrMarker::mark_pointer((address*)archived_packages->adr_at(i));\n+  }\n+  return archived_packages;\n+}\n+\n+void PackageEntryTable::init_archived_entries(Array<PackageEntry*>* archived_packages) {\n+  for (int i = 0; i < archived_packages->length(); i++) {\n+    PackageEntry* archived_entry = archived_packages->at(i);\n+    archived_entry->init_as_archived_entry();\n+  }\n+}\n+\n+void PackageEntryTable::load_archived_entries(Array<PackageEntry*>* archived_packages) {\n+  assert(UseSharedSpaces, \"runtime only\");\n+\n+  for (int i = 0; i < archived_packages->length(); i++) {\n+    PackageEntry* archived_entry = archived_packages->at(i);\n+    archived_entry->load_from_archive();\n+\n+    unsigned int hash = compute_hash(archived_entry->name());\n+    archived_entry->set_hash(hash);\n+    add_entry(hash_to_index(hash), archived_entry);\n+  }\n+}\n+\n+#endif \/\/ INCLUDE_CDS_JAVA_HEAP\n+\n@@ -277,1 +403,0 @@\n-\n","filename":"src\/hotspot\/share\/classfile\/packageEntry.cpp","additions":126,"deletions":1,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -39,0 +39,2 @@\n+template <class T> class Array;\n+class MetaspaceClosure;\n@@ -220,0 +222,8 @@\n+#if INCLUDE_CDS_JAVA_HEAP\n+  void iterate_symbols(MetaspaceClosure* closure);\n+  PackageEntry* allocate_archived_entry() const;\n+  void init_as_archived_entry();\n+  static PackageEntry* get_archived_entry(PackageEntry* orig_entry);\n+  void load_from_archive();\n+#endif\n+\n@@ -298,0 +308,7 @@\n+\n+#if INCLUDE_CDS_JAVA_HEAP\n+  void iterate_symbols(MetaspaceClosure* closure);\n+  Array<PackageEntry*>* allocate_archived_entries();\n+  void init_archived_entries(Array<PackageEntry*>* archived_packages);\n+  void load_archived_entries(Array<PackageEntry*>* archived_packages);\n+#endif\n","filename":"src\/hotspot\/share\/classfile\/packageEntry.hpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -190,0 +190,1 @@\n+  do_klass(jdk_internal_loader_BuiltinClassLoader_klass,jdk_internal_loader_BuiltinClassLoader                ) \\\n@@ -194,0 +195,2 @@\n+  do_klass(ConcurrentHashMap_klass,                     java_util_concurrent_ConcurrentHashMap                ) \\\n+  do_klass(ArrayList_klass,                             java_util_ArrayList                                   ) \\\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -133,0 +133,1 @@\n+  template(jdk_internal_loader_BuiltinClassLoader,    \"jdk\/internal\/loader\/BuiltinClassLoader\")   \\\n@@ -667,0 +668,2 @@\n+  template(java_util_concurrent_ConcurrentHashMap, \"java\/util\/concurrent\/ConcurrentHashMap\")                      \\\n+  template(java_util_ArrayList,                    \"java\/util\/ArrayList\")                                         \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -493,0 +493,8 @@\n+\/*\n+ * Define all modules that have been stored in the CDS archived heap.\n+ *  platform_loader: the built-in platform class loader\n+ *  system_loader:   the built-in system class loader\n+ *\/\n+JNIEXPORT void JNICALL\n+JVM_DefineArchivedModules(JNIEnv *env, jobject platform_loader, jobject system_loader);\n+\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"classfile\/classLoaderDataShared.hpp\"\n@@ -221,0 +222,5 @@\n+#if INCLUDE_CDS_JAVA_HEAP\n+  if (DumpSharedSpaces && MetaspaceShared::use_full_module_graph()) {\n+    ClassLoaderDataShared::iterate_symbols(&doit);\n+  }\n+#endif\n","filename":"src\/hotspot\/share\/memory\/archiveBuilder.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+  f(ModulesNatives) \\\n@@ -77,0 +78,5 @@\n+  void record_modules(int byte_size, bool read_only) {\n+    int which = (read_only) ? RO : RW;\n+    _bytes [which][ModulesNativesType] += byte_size;\n+  }\n+\n","filename":"src\/hotspot\/share\/memory\/dumpAllocStats.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -221,0 +221,1 @@\n+  _use_full_module_graph = MetaspaceShared::use_full_module_graph();\n@@ -2182,1 +2183,6 @@\n-    log_info(cds)(\"use_optimized_module_handling disabled: archive was created without optimized module handling\");\n+    log_info(cds)(\"optimized module handling: disabled because archive was created without optimized module handling\");\n+  }\n+\n+  if (!_use_full_module_graph) {\n+    MetaspaceShared::disable_full_module_graph();\n+    log_info(cds)(\"full module graph: disabled because archive was created without full module graph\");\n","filename":"src\/hotspot\/share\/memory\/filemap.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -236,0 +236,1 @@\n+  bool   _use_full_module_graph;        \/\/ Can we use the full archived module graph?\n","filename":"src\/hotspot\/share\/memory\/filemap.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+#include \"classfile\/classLoaderData.hpp\"\n+#include \"classfile\/classLoaderDataShared.hpp\"\n@@ -27,0 +29,1 @@\n+#include \"classfile\/moduleEntry.hpp\"\n@@ -29,0 +32,1 @@\n+#include \"classfile\/systemDictionary.hpp\"\n@@ -48,0 +52,1 @@\n+#include \"runtime\/javaCalls.hpp\"\n@@ -71,7 +76,7 @@\n-  {\"java\/lang\/Integer$IntegerCache\",           \"archivedCache\"},\n-  {\"java\/lang\/Long$LongCache\",                 \"archivedCache\"},\n-  {\"java\/lang\/Byte$ByteCache\",                 \"archivedCache\"},\n-  {\"java\/lang\/Short$ShortCache\",               \"archivedCache\"},\n-  {\"java\/lang\/Character$CharacterCache\",       \"archivedCache\"},\n-  {\"java\/util\/jar\/Attributes$Name\",            \"KNOWN_NAMES\"},\n-  {\"sun\/util\/locale\/BaseLocale\",               \"constantBaseLocales\"},\n+  {\"java\/lang\/Integer$IntegerCache\",              \"archivedCache\"},\n+  {\"java\/lang\/Long$LongCache\",                    \"archivedCache\"},\n+  {\"java\/lang\/Byte$ByteCache\",                    \"archivedCache\"},\n+  {\"java\/lang\/Short$ShortCache\",                  \"archivedCache\"},\n+  {\"java\/lang\/Character$CharacterCache\",          \"archivedCache\"},\n+  {\"java\/util\/jar\/Attributes$Name\",               \"KNOWN_NAMES\"},\n+  {\"sun\/util\/locale\/BaseLocale\",                  \"constantBaseLocales\"},\n@@ -81,4 +86,11 @@\n-  {\"jdk\/internal\/module\/ArchivedModuleGraph\",  \"archivedModuleGraph\"},\n-  {\"java\/util\/ImmutableCollections\",           \"archivedObjects\"},\n-  {\"java\/lang\/module\/Configuration\",           \"EMPTY_CONFIGURATION\"},\n-  {\"jdk\/internal\/math\/FDBigInteger\",           \"archivedCaches\"},\n+  {\"jdk\/internal\/module\/ArchivedModuleGraph\",     \"archivedModuleGraph\"},\n+  {\"java\/util\/ImmutableCollections\",              \"archivedObjects\"},\n+  {\"java\/lang\/module\/Configuration\",              \"EMPTY_CONFIGURATION\"},\n+  {\"jdk\/internal\/math\/FDBigInteger\",              \"archivedCaches\"},\n+};\n+\n+\/\/ Entry fields for subgraphs archived in the open archive heap region (full module graph).\n+static ArchivableStaticFieldInfo fmg_open_archive_subgraph_entry_fields[] = {\n+  {\"jdk\/internal\/loader\/ArchivedClassLoaders\",    \"archivedClassLoaders\"},\n+  {\"jdk\/internal\/module\/ArchivedBootLayer\",       \"archivedBootLayer\"},\n+  {\"java\/lang\/Module$ArchivedData\",               \"archivedData\"},\n@@ -91,0 +103,2 @@\n+const static int num_fmg_open_archive_subgraph_entry_fields =\n+  sizeof(fmg_open_archive_subgraph_entry_fields) \/ sizeof(ArchivableStaticFieldInfo);\n@@ -111,0 +125,30 @@\n+static void reset_states(oop obj, TRAPS) {\n+  Handle h_obj(THREAD, obj);\n+  InstanceKlass* klass = InstanceKlass::cast(obj->klass());\n+  TempNewSymbol method_name = SymbolTable::new_symbol(\"resetArchivedStates\");\n+  Symbol* method_sig = vmSymbols::void_method_signature();\n+\n+  while (klass != NULL) {\n+    Method* method = klass->find_method(method_name, method_sig);\n+    if (method != NULL) {\n+      assert(method->is_private(), \"must be\");\n+      if (log_is_enabled(Debug, cds)) {\n+        ResourceMark rm(THREAD);\n+        log_debug(cds)(\"  calling %s\", method->name_and_sig_as_C_string());\n+      }\n+      JavaValue result(T_VOID);\n+      JavaCalls::call_special(&result, h_obj, klass,\n+                              method_name, method_sig, CHECK);\n+    }\n+    klass = klass->java_super();\n+  }\n+}\n+\n+void HeapShared::reset_archived_object_states(TRAPS) {\n+  assert(DumpSharedSpaces, \"dump-time only\");\n+  log_debug(cds)(\"Resetting platform loader\");\n+  reset_states(SystemDictionary::java_platform_loader(), THREAD);\n+  log_debug(cds)(\"Resetting system loader\");\n+  reset_states(SystemDictionary::java_system_loader(), THREAD);\n+}\n+\n@@ -241,0 +285,4 @@\n+    if (MetaspaceShared::use_full_module_graph()) {\n+      ClassLoaderDataShared::init_archived_oops();\n+    }\n+\n@@ -280,0 +328,6 @@\n+  if (MetaspaceShared::use_full_module_graph()) {\n+    archive_object_subgraphs(fmg_open_archive_subgraph_entry_fields,\n+                             num_fmg_open_archive_subgraph_entry_fields,\n+                             false \/* is_closed_archive *\/,\n+                             THREAD);\n+  }\n@@ -299,0 +353,10 @@\n+KlassSubGraphInfo* HeapShared::init_subgraph_info(Klass* k, bool is_full_module_graph) {\n+  assert(DumpSharedSpaces, \"dump time only\");\n+  bool created;\n+  KlassSubGraphInfo* info =\n+    _dump_time_subgraph_info_table->put_if_absent(k, KlassSubGraphInfo(k, is_full_module_graph),\n+                                                  &created);\n+  assert(created, \"must not initialize twice\");\n+  return info;\n+}\n+\n@@ -301,7 +365,2 @@\n-  Klass* relocated_k = MetaspaceShared::get_relocated_klass(k);\n-  KlassSubGraphInfo* info = _dump_time_subgraph_info_table->get(relocated_k);\n-  if (info == NULL) {\n-    _dump_time_subgraph_info_table->put(relocated_k, KlassSubGraphInfo(relocated_k));\n-    info = _dump_time_subgraph_info_table->get(relocated_k);\n-    ++ _dump_time_subgraph_info_table->_count;\n-  }\n+  KlassSubGraphInfo* info = _dump_time_subgraph_info_table->get(k);\n+  assert(info != NULL, \"must have been initialized\");\n@@ -384,1 +443,1 @@\n-  _k = info->klass();\n+  _k = MetaspaceShared::get_relocated_klass(info->klass());\n@@ -387,0 +446,1 @@\n+  _is_full_module_graph = info->is_full_module_graph();\n@@ -434,1 +494,1 @@\n-      unsigned int hash = SystemDictionaryShared::hash_for_shared_dictionary(klass);\n+      unsigned int hash = SystemDictionaryShared::hash_for_shared_dictionary(MetaspaceShared::get_relocated_klass(klass));\n@@ -467,1 +527,1 @@\n-void HeapShared::initialize_from_archived_subgraph(Klass* k) {\n+void HeapShared::initialize_from_archived_subgraph(Klass* k, TRAPS) {\n@@ -479,1 +539,3 @@\n-    Thread* THREAD = Thread::current();\n+    if (record->is_full_module_graph() && !MetaspaceShared::use_full_module_graph()) {\n+      return;\n+    }\n@@ -631,0 +693,19 @@\n+void HeapShared::check_module_oop(oop orig_module_obj) {\n+  assert(DumpSharedSpaces, \"must be\");\n+  assert(java_lang_Module::is_instance(orig_module_obj), \"must be\");\n+  ModuleEntry* orig_module_ent = java_lang_Module::module_entry_raw(orig_module_obj);\n+  if (orig_module_ent == NULL) {\n+    \/\/ These special Module objects are created in Java code. They are not\n+    \/\/ defined via Modules::define_module(), so they don't have a ModuleEntry:\n+    \/\/     java.lang.Module::ALL_UNNAMED_MODULE\n+    \/\/     java.lang.Module::EVERYONE_MODULE\n+    \/\/     jdk.internal.loader.ClassLoaders$BootClassLoader::unnamedModule\n+    assert(java_lang_Module::name(orig_module_obj) == NULL, \"must be unnamed\");\n+    log_info(cds, heap)(\"Module oop with No ModuleEntry* @[\" PTR_FORMAT \"]\", p2i(orig_module_obj));\n+  } else {\n+    ClassLoaderData* loader_data = orig_module_ent->loader_data();\n+    assert(loader_data->is_builtin_class_loader_data(), \"must be\");\n+  }\n+}\n+\n+\n@@ -698,0 +779,12 @@\n+\n+    if (java_lang_Module::is_instance(orig_obj)) {\n+      check_module_oop(orig_obj);\n+      java_lang_Module::set_module_entry(archived_obj, NULL);\n+      java_lang_Module::set_loader(archived_obj, NULL);\n+    } else if (java_lang_ClassLoader::is_instance(orig_obj)) {\n+      \/\/ class_data will be restored explicitly at run time.\n+      guarantee(orig_obj == SystemDictionary::java_platform_loader() ||\n+                orig_obj == SystemDictionary::java_system_loader() ||\n+                java_lang_ClassLoader::loader_data_raw(orig_obj) == NULL, \"must be\");\n+      java_lang_ClassLoader::release_set_loader_data(archived_obj, NULL);\n+    }\n@@ -930,1 +1023,2 @@\n-                                            int num, Thread* THREAD) {\n+                                            int num, bool is_full_module_graph,\n+                                            Thread* THREAD) {\n@@ -950,0 +1044,1 @@\n+    init_subgraph_info(ik, is_full_module_graph);\n@@ -958,1 +1053,1 @@\n-                             THREAD);\n+                             false, THREAD);\n@@ -961,1 +1056,6 @@\n-                             THREAD);\n+                             false, THREAD);\n+  if (MetaspaceShared::use_full_module_graph()) {\n+    init_subgraph_entry_fields(fmg_open_archive_subgraph_entry_fields,\n+                               num_fmg_open_archive_subgraph_entry_fields,\n+                               true, THREAD);\n+  }\n@@ -999,0 +1099,1 @@\n+\n@@ -1001,1 +1102,2 @@\n-                                                  is_closed_archive, CHECK);\n+                                                  is_closed_archive,\n+                                                  CHECK);\n","filename":"src\/hotspot\/share\/memory\/heapShared.cpp","additions":128,"deletions":26,"binary":false,"changes":154,"status":"modified"},{"patch":"@@ -69,0 +69,1 @@\n+  bool _is_full_module_graph;\n@@ -70,1 +71,1 @@\n-  KlassSubGraphInfo(Klass* k) :\n+  KlassSubGraphInfo(Klass* k, bool is_full_module_graph) :\n@@ -72,1 +73,2 @@\n-    _subgraph_entry_fields(NULL) {}\n+    _subgraph_entry_fields(NULL),\n+    _is_full_module_graph(is_full_module_graph) {}\n@@ -96,0 +98,1 @@\n+  bool is_full_module_graph() const { return _is_full_module_graph; }\n@@ -104,0 +107,1 @@\n+  bool _is_full_module_graph;\n@@ -118,0 +122,1 @@\n+  bool is_full_module_graph() const { return _is_full_module_graph; }\n@@ -203,0 +208,1 @@\n+  static KlassSubGraphInfo* init_subgraph_info(Klass *k, bool is_full_module_graph);\n@@ -206,1 +212,1 @@\n-                                         int num, Thread* THREAD);\n+                                         int num, bool is_full_module_graph, Thread* THREAD);\n@@ -248,0 +254,2 @@\n+  static void check_module_oop(oop orig_module_obj);\n+\n@@ -249,0 +257,1 @@\n+  static void reset_archived_object_states(TRAPS);\n@@ -324,1 +333,1 @@\n-  static void initialize_from_archived_subgraph(Klass* k) NOT_CDS_JAVA_HEAP_RETURN;\n+  static void initialize_from_archived_subgraph(Klass* k, TRAPS) NOT_CDS_JAVA_HEAP_RETURN;\n","filename":"src\/hotspot\/share\/memory\/heapShared.hpp","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"classfile\/classLoaderDataShared.hpp\"\n@@ -43,0 +44,1 @@\n+#include \"memory\/dumpAllocStats.hpp\"\n@@ -90,0 +92,1 @@\n+bool MetaspaceShared::_use_full_module_graph = true;\n@@ -154,0 +157,4 @@\n+char* MetaspaceShared::read_write_space_alloc(size_t num_bytes) {\n+  return _rw_region.allocate(num_bytes);\n+}\n+\n@@ -503,0 +510,2 @@\n+  CDS_JAVA_HEAP_ONLY(ClassLoaderDataShared::serialize(soc));\n+\n@@ -1073,4 +1082,23 @@\n-  _mc_region.pack(&_rw_region);\n-  builder.dump_rw_region();\n-  _rw_region.pack(&_ro_region);\n-  builder.dump_ro_region();\n+  {\n+    _mc_region.pack(&_rw_region);\n+    builder.dump_rw_region();\n+#if INCLUDE_CDS_JAVA_HEAP\n+    if (MetaspaceShared::use_full_module_graph()) {\n+      \/\/ Archive the ModuleEntry's and PackageEntry's of the 3 built-in loaders\n+      char* start = _rw_region.top();\n+      ClassLoaderDataShared::allocate_archived_tables();\n+      ArchiveBuilder::alloc_stats()->record_modules(_rw_region.top() - start, \/*read_only*\/false);\n+    }\n+#endif\n+  }\n+  {\n+    _rw_region.pack(&_ro_region);\n+    builder.dump_ro_region();\n+#if INCLUDE_CDS_JAVA_HEAP\n+    if (MetaspaceShared::use_full_module_graph()) {\n+      char* start = _ro_region.top();\n+      ClassLoaderDataShared::init_archived_tables();\n+      ArchiveBuilder::alloc_stats()->record_modules(_ro_region.top() - start, \/*read_only*\/true);\n+    }\n+#endif\n+  }\n@@ -1369,0 +1397,6 @@\n+#if INCLUDE_CDS_JAVA_HEAP\n+    if (use_full_module_graph()) {\n+      HeapShared::reset_archived_object_states(THREAD);\n+    }\n+#endif\n+\n@@ -1752,1 +1786,2 @@\n-    log_info(cds)(\"Using optimized module handling %s\", MetaspaceShared::use_optimized_module_handling() ? \"enabled\" : \"disabled\");\n+    log_info(cds)(\"optimized module handling: %s\", MetaspaceShared::use_optimized_module_handling() ? \"enabled\" : \"disabled\");\n+    log_info(cds)(\"full module graph: %s\", MetaspaceShared::use_full_module_graph() ? \"enabled\" : \"disabled\");\n@@ -2077,0 +2112,11 @@\n+bool MetaspaceShared::use_full_module_graph() {\n+  bool result = _use_optimized_module_handling && _use_full_module_graph &&\n+    (UseSharedSpaces || DumpSharedSpaces) && HeapShared::is_heap_object_archiving_allowed();\n+  if (result && UseSharedSpaces) {\n+    \/\/ Classes used by the archived full module graph are loaded in JVMTI early phase.\n+    assert(!(JvmtiExport::should_post_class_file_load_hook() && JvmtiExport::has_early_class_hook_env()),\n+           \"CDS should be disabled if early class hooks are enabled\");\n+  }\n+  return result;\n+}\n+\n","filename":"src\/hotspot\/share\/memory\/metaspaceShared.cpp","additions":51,"deletions":5,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -81,0 +81,1 @@\n+  static bool _use_full_module_graph;\n@@ -218,0 +219,1 @@\n+  static char* read_write_space_alloc(size_t num_bytes);\n@@ -221,1 +223,0 @@\n-#if INCLUDE_CDS\n@@ -226,3 +227,8 @@\n-#else\n-    return NULL;\n-#endif\n+  }\n+\n+  template <typename T>\n+  static Array<T>* new_rw_array(int length) {\n+    size_t byte_size = Array<T>::byte_sizeof(length, sizeof(T));\n+    Array<T>* array = (Array<T>*)read_write_space_alloc(byte_size);\n+    array->initialize(length);\n+    return array;\n@@ -273,1 +279,1 @@\n-  static bool use_optimized_module_handling()     { return _use_optimized_module_handling;  }\n+  static bool use_optimized_module_handling() { return NOT_CDS(false) CDS_ONLY(_use_optimized_module_handling); }\n@@ -276,0 +282,4 @@\n+  \/\/ Can we use the full archived modue graph?\n+  static bool use_full_module_graph() NOT_CDS_RETURN_(false);\n+  static void disable_full_module_graph() { _use_full_module_graph = false; }\n+\n","filename":"src\/hotspot\/share\/memory\/metaspaceShared.hpp","additions":15,"deletions":5,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+#include \"memory\/archiveUtils.hpp\"\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1332,0 +1332,1 @@\n+  void init_shared_package_entry();\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1230,0 +1230,5 @@\n+JVM_ENTRY(void, JVM_DefineArchivedModules(JNIEnv *env, jobject platform_loader, jobject system_loader))\n+  JVMWrapper(\"JVM_DefineArchivedModules\");\n+  Modules::define_archived_modules(platform_loader, system_loader, CHECK);\n+JVM_END\n+\n@@ -3725,1 +3730,1 @@\n-  HeapShared::initialize_from_archived_subgraph(k);\n+  HeapShared::initialize_from_archived_subgraph(k, THREAD);\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1462,1 +1462,8 @@\n-    log_info(cds)(\"Using optimized module handling disabled due to incompatible property: %s=%s\", key, value);\n+    log_info(cds)(\"optimized module handling: disabled due to incompatible property: %s=%s\", key, value);\n+  }\n+  if (strcmp(key, \"jdk.module.showModuleResolution\") == 0 ||\n+      strcmp(key, \"jdk.module.illegalAccess\") == 0 ||\n+      strcmp(key, \"jdk.module.validation\") == 0 ||\n+      strcmp(key, \"java.system.class.loader\") == 0) {\n+    MetaspaceShared::disable_full_module_graph();\n+    log_info(cds)(\"full module graph: disabled due to incompatible property: %s=%s\", key, value);\n@@ -2511,1 +2518,1 @@\n-      log_info(cds)(\"Using optimized module handling disabled due to bootclasspath was appended\");\n+      log_info(cds)(\"optimized module handling: disabled because bootclasspath was appended\");\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2717,0 +2717,11 @@\n+\n+    \/**\n+     * Called by the VM, during -Xshare:dump\n+     *\/\n+    private void resetArchivedStates() {\n+        parallelLockMap.clear();\n+        packages.clear();\n+        package2certs.clear();\n+        classes.clear();\n+        classLoaderValueMap = null;\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ClassLoader.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+import jdk.internal.misc.VM;\n@@ -249,2 +250,2 @@\n-    private static final Module ALL_UNNAMED_MODULE = new Module(null);\n-    private static final Set<Module> ALL_UNNAMED_MODULE_SET = Set.of(ALL_UNNAMED_MODULE);\n+    private static final Module ALL_UNNAMED_MODULE;\n+    private static final Set<Module> ALL_UNNAMED_MODULE_SET;\n@@ -253,2 +254,45 @@\n-    private static final Module EVERYONE_MODULE = new Module(null);\n-    private static final Set<Module> EVERYONE_SET = Set.of(EVERYONE_MODULE);\n+    private static final Module EVERYONE_MODULE;\n+    private static final Set<Module> EVERYONE_SET;\n+\n+    private static class ArchivedData {\n+        private static ArchivedData archivedData;\n+        private final Module allUnnamedModule;\n+        private final Set<Module> allUnnamedModules;\n+        private final Module everyoneModule;\n+        private final Set<Module> everyoneSet;\n+\n+        private ArchivedData() {\n+            this.allUnnamedModule = ALL_UNNAMED_MODULE;\n+            this.allUnnamedModules = ALL_UNNAMED_MODULE_SET;\n+            this.everyoneModule = EVERYONE_MODULE;\n+            this.everyoneSet = EVERYONE_SET;\n+        }\n+\n+        static void archive() {\n+            archivedData = new ArchivedData();\n+        }\n+\n+        static ArchivedData get() {\n+            return archivedData;\n+        }\n+\n+        static {\n+            VM.initializeFromArchive(ArchivedData.class);\n+        }\n+    }\n+\n+    static {\n+        ArchivedData archivedData = ArchivedData.get();\n+        if (archivedData != null) {\n+            ALL_UNNAMED_MODULE = archivedData.allUnnamedModule;\n+            ALL_UNNAMED_MODULE_SET = archivedData.allUnnamedModules;\n+            EVERYONE_MODULE = archivedData.everyoneModule;\n+            EVERYONE_SET = archivedData.everyoneSet;\n+        } else {\n+            ALL_UNNAMED_MODULE = new Module(null);\n+            ALL_UNNAMED_MODULE_SET = Set.of(ALL_UNNAMED_MODULE);\n+            EVERYONE_MODULE = new Module(null);\n+            EVERYONE_SET = Set.of(EVERYONE_MODULE);\n+            ArchivedData.archive();\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Module.java","additions":48,"deletions":4,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -2251,0 +2251,3 @@\n+            public void bindToLoader(ModuleLayer layer, ClassLoader loader) {\n+                layer.bindToLoader(loader);\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -272,0 +272,7 @@\n+\n+    \/**\n+     * Called by the VM, during -Xshare:dump\n+     *\/\n+    private void resetArchivedStates() {\n+        pdcache.clear();\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/security\/SecureClassLoader.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -259,0 +259,6 @@\n+    \/**\n+     * Record that this layer has at least one module defined to the given\n+     * class loader.\n+     *\/\n+    void bindToLoader(ModuleLayer layer, ClassLoader loader);\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.loader;\n+\n+import java.util.Map;\n+import jdk.internal.misc.VM;\n+import jdk.internal.module.ServicesCatalog;\n+\n+\/**\n+ * Used to archive the built-in class loaders, their services catalogs, and the\n+ * package-to-module map used by the built-in class loaders.\n+ *\/\n+class ArchivedClassLoaders {\n+    private static ArchivedClassLoaders archivedClassLoaders;\n+\n+    private final ClassLoader bootLoader;\n+    private final ClassLoader platformLoader;\n+    private final ClassLoader appLoader;\n+    private final ServicesCatalog[] servicesCatalogs;\n+    private final Map<String, ?> packageToModule;\n+\n+    private ArchivedClassLoaders() {\n+        bootLoader = ClassLoaders.bootLoader();\n+        platformLoader = ClassLoaders.platformClassLoader();\n+        appLoader = ClassLoaders.appClassLoader();\n+\n+        servicesCatalogs = new ServicesCatalog[3];\n+        servicesCatalogs[0] = BootLoader.getServicesCatalog();\n+        servicesCatalogs[1] = ServicesCatalog.getServicesCatalog(platformLoader);\n+        servicesCatalogs[2] = ServicesCatalog.getServicesCatalog(appLoader);\n+\n+        packageToModule = BuiltinClassLoader.packageToModule();\n+    }\n+\n+    ClassLoader bootLoader() {\n+        return bootLoader;\n+    }\n+\n+    ClassLoader platformLoader() {\n+        return platformLoader;\n+    }\n+\n+    ClassLoader appLoader() {\n+        return appLoader;\n+    }\n+\n+    ServicesCatalog servicesCatalog(ClassLoader loader) {\n+        if (loader == null) {\n+            return servicesCatalogs[0];\n+        } else if (loader == platformLoader) {\n+            return servicesCatalogs[1];\n+        } else if (loader == appLoader) {\n+            return servicesCatalogs[2];\n+        } else {\n+            throw new InternalError();\n+        }\n+    }\n+\n+    Map<String, ?> packageToModule() {\n+        return packageToModule;\n+    }\n+\n+    static void archive() {\n+        archivedClassLoaders = new ArchivedClassLoaders();\n+    }\n+\n+    static ArchivedClassLoaders get() {\n+        return archivedClassLoaders;\n+    }\n+\n+    static {\n+        VM.initializeFromArchive(ArchivedClassLoaders.class);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/loader\/ArchivedClassLoaders.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -68,1 +68,9 @@\n-    private static final ServicesCatalog SERVICES_CATALOG = ServicesCatalog.create();\n+    private static final ServicesCatalog SERVICES_CATALOG;\n+    static {\n+        ArchivedClassLoaders archivedClassLoaders = ArchivedClassLoaders.get();\n+        if (archivedClassLoaders != null) {\n+            SERVICES_CATALOG = archivedClassLoaders.servicesCatalog(null);\n+        } else {\n+            SERVICES_CATALOG = ServicesCatalog.create();\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/loader\/BootLoader.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -107,2 +107,1 @@\n-    private final URLClassPath ucp;\n-\n+    private @Stable URLClassPath ucp;\n@@ -159,1 +158,0 @@\n-\n@@ -161,2 +159,19 @@\n-    private static final Map<String, LoadedModule> packageToModule\n-        = new ConcurrentHashMap<>(1024);\n+    private static final Map<String, LoadedModule> packageToModule;\n+    static {\n+        ArchivedClassLoaders archivedClassLoaders = ArchivedClassLoaders.get();\n+        if (archivedClassLoaders != null) {\n+            @SuppressWarnings(\"unchecked\")\n+            Map<String, LoadedModule> map\n+                = (Map<String, LoadedModule>) archivedClassLoaders.packageToModule();\n+            packageToModule = map;\n+        } else {\n+            packageToModule = new ConcurrentHashMap<>(1024);\n+        }\n+    }\n+\n+    \/**\n+     * Invoked by ArchivedClassLoaders to archive the package-to-module map.\n+     *\/\n+    static Map<String, ?> packageToModule() {\n+        return packageToModule;\n+    }\n@@ -188,0 +203,15 @@\n+    \/**\n+     * Appends to the given file path to the class path.\n+     *\/\n+    void appendClassPath(String path) {\n+        \/\/ assert ucp != null;\n+        ucp.addFile(path);\n+    }\n+\n+    \/**\n+     * Sets the class path, called to reset the class path during -Xshare:dump\n+     *\/\n+    void setClassPath(URLClassPath ucp) {\n+        this.ucp = ucp;\n+    }\n+\n@@ -1045,0 +1075,5 @@\n+\n+    \/\/ Called from VM only, during -Xshare:dump\n+    private void resetArchivedStates() {\n+        ucp = null;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/loader\/BuiltinClassLoader.java","additions":40,"deletions":5,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import jdk.internal.module.ServicesCatalog;\n@@ -59,8 +60,16 @@\n-        \/\/ -Xbootclasspath\/a or -javaagent with Boot-Class-Path attribute\n-        String append = VM.getSavedProperty(\"jdk.boot.class.path.append\");\n-        BOOT_LOADER =\n-            new BootClassLoader((append != null && !append.isEmpty())\n-                ? new URLClassPath(append, true)\n-                : null);\n-        PLATFORM_LOADER = new PlatformClassLoader(BOOT_LOADER);\n-\n+        ArchivedClassLoaders archivedClassLoaders = ArchivedClassLoaders.get();\n+        if (archivedClassLoaders != null) {\n+            \/\/ assert VM.getSavedProperty(\"jdk.boot.class.path.append\") == null\n+            BOOT_LOADER = (BootClassLoader) archivedClassLoaders.bootLoader();\n+            PLATFORM_LOADER = (PlatformClassLoader) archivedClassLoaders.platformLoader();\n+            ServicesCatalog catalog = archivedClassLoaders.servicesCatalog(PLATFORM_LOADER);\n+            ServicesCatalog.putServicesCatalog(PLATFORM_LOADER, catalog);\n+        } else {\n+            \/\/ -Xbootclasspath\/a or -javaagent with Boot-Class-Path attribute\n+            String append = VM.getSavedProperty(\"jdk.boot.class.path.append\");\n+            URLClassPath ucp = (append != null && !append.isEmpty())\n+                    ? new URLClassPath(append, true)\n+                    : null;\n+            BOOT_LOADER = new BootClassLoader(ucp);\n+            PLATFORM_LOADER = new PlatformClassLoader(BOOT_LOADER);\n+        }\n@@ -78,1 +87,9 @@\n-        APP_LOADER = new AppClassLoader(PLATFORM_LOADER, ucp);\n+        if (archivedClassLoaders != null) {\n+            APP_LOADER = (AppClassLoader) archivedClassLoaders.appLoader();\n+            ServicesCatalog catalog = archivedClassLoaders.servicesCatalog(APP_LOADER);\n+            ServicesCatalog.putServicesCatalog(APP_LOADER, catalog);\n+            APP_LOADER.setClassPath(ucp);\n+        } else {\n+            APP_LOADER = new AppClassLoader(PLATFORM_LOADER, ucp);\n+            ArchivedClassLoaders.archive();\n+        }\n@@ -147,3 +164,1 @@\n-        final URLClassPath ucp;\n-\n-        AppClassLoader(PlatformClassLoader parent, URLClassPath ucp) {\n+        AppClassLoader(BuiltinClassLoader parent, URLClassPath ucp) {\n@@ -151,1 +166,0 @@\n-            this.ucp = ucp;\n@@ -184,1 +198,1 @@\n-            ucp.addFile(path);\n+            appendClassPath(path);\n@@ -193,0 +207,7 @@\n+\n+        \/**\n+         * Called by the VM, during -Xshare:dump\n+         *\/\n+        private void resetArchivedStates() {\n+            setClassPath(null);\n+        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/loader\/ClassLoaders.java","additions":35,"deletions":14,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -471,0 +471,2 @@\n+    public static native void defineArchivedModules(ClassLoader platformLoader, ClassLoader systemLoader);\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/VM.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.module;\n+\n+import jdk.internal.misc.VM;\n+\n+\/**\n+ * Used by ModuleBootstrap for archiving the boot layer and the builder needed to\n+ * set the IllegalAccessLogger.\n+ *\/\n+class ArchivedBootLayer {\n+    private static ArchivedBootLayer archivedBootLayer;\n+\n+    private final ModuleLayer bootLayer;\n+    private final IllegalAccessLogger.Builder builder;\n+\n+    private ArchivedBootLayer(ModuleLayer bootLayer,\n+                              IllegalAccessLogger.Builder builder) {\n+        this.bootLayer = bootLayer;\n+        this.builder = builder;\n+    }\n+\n+    ModuleLayer bootLayer() {\n+        return bootLayer;\n+    }\n+\n+    IllegalAccessLogger.Builder illegalAccessLoggerBuilder() {\n+        return builder;\n+    }\n+\n+    static ArchivedBootLayer get() {\n+        return archivedBootLayer;\n+    }\n+\n+    static void archive(ModuleLayer layer, IllegalAccessLogger.Builder builder) {\n+        archivedBootLayer = new ArchivedBootLayer(layer, builder);\n+    }\n+\n+    static {\n+        VM.initializeFromArchive(ArchivedBootLayer.class);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/ArchivedBootLayer.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -25,1 +25,0 @@\n-\n@@ -28,2 +27,0 @@\n-import java.lang.module.Configuration;\n-import java.lang.module.ModuleFinder;\n@@ -33,1 +30,2 @@\n-\n+import java.lang.module.Configuration;\n+import java.lang.module.ModuleFinder;\n@@ -37,1 +35,2 @@\n- * Used by ModuleBootstrap to obtain the archived system modules and finder.\n+ * Used by ModuleBootstrap for archiving the configuration for the boot layer,\n+ * the system module finder, and the maps used to create the IllegalAccessLogger.\n@@ -39,1 +38,1 @@\n-final class ArchivedModuleGraph {\n+class ArchivedModuleGraph {\n@@ -50,7 +49,7 @@\n-    public ArchivedModuleGraph(boolean hasSplitPackages,\n-                               boolean hasIncubatorModules,\n-                               ModuleFinder finder,\n-                               Configuration configuration,\n-                               Function<String, ClassLoader> classLoaderFunction,\n-                               Map<String, Set<String>> concealedPackagesToOpen,\n-                               Map<String, Set<String>> exportedPackagesToOpen) {\n+    private ArchivedModuleGraph(boolean hasSplitPackages,\n+                                boolean hasIncubatorModules,\n+                                ModuleFinder finder,\n+                                Configuration configuration,\n+                                Function<String, ClassLoader> classLoaderFunction,\n+                                Map<String, Set<String>> concealedPackagesToOpen,\n+                                Map<String, Set<String>> exportedPackagesToOpen) {\n@@ -110,2 +109,14 @@\n-    static void archive(ArchivedModuleGraph graph) {\n-        archivedModuleGraph = graph;\n+    static void archive(boolean hasSplitPackages,\n+                        boolean hasIncubatorModules,\n+                        ModuleFinder finder,\n+                        Configuration configuration,\n+                        Function<String, ClassLoader> classLoaderFunction,\n+                        Map<String, Set<String>> concealedPackagesToOpen,\n+                        Map<String, Set<String>> exportedPackagesToOpen) {\n+        archivedModuleGraph = new ArchivedModuleGraph(hasSplitPackages,\n+                                                      hasIncubatorModules,\n+                                                      finder,\n+                                                      configuration,\n+                                                      classLoaderFunction,\n+                                                      concealedPackagesToOpen,\n+                                                      exportedPackagesToOpen);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/ArchivedModuleGraph.java","additions":26,"deletions":15,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,1 @@\n-    public static enum Mode {\n+    public enum Mode {\n@@ -121,1 +121,1 @@\n-         * Builds the IllegalAccessLogger and sets it as the system-wise logger.\n+         * Builds the IllegalAccessLogger and sets it as the system-wide logger.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/IllegalAccessLogger.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -45,1 +45,0 @@\n-import java.util.NoSuchElementException;\n@@ -52,2 +51,0 @@\n-import jdk.internal.loader.BootLoader;\n-import jdk.internal.loader.BuiltinClassLoader;\n@@ -57,0 +54,4 @@\n+import jdk.internal.loader.BootLoader;\n+import jdk.internal.loader.BuiltinClassLoader;\n+import jdk.internal.loader.ClassLoaders;\n+import jdk.internal.misc.VM;\n@@ -89,2 +90,2 @@\n-    private static final JavaLangModuleAccess JLMA\n-        = SharedSecrets.getJavaLangModuleAccess();\n+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n+    private static final JavaLangModuleAccess JLMA = SharedSecrets.getJavaLangModuleAccess();\n@@ -137,1 +138,20 @@\n-     * Initialize the module system, returning the boot layer.\n+     * Returns true if the archived boot layer can be used. The system properties\n+     * are checked in the order that they are used by boot2.\n+     *\/\n+    private static boolean canUseArchivedBootLayer() {\n+        return getProperty(\"jdk.module.upgrade.path\") == null &&\n+               getProperty(\"jdk.module.path\") == null &&\n+               getProperty(\"jdk.module.patch.0\") == null &&    \/\/ --patch-module\n+               getProperty(\"jdk.module.main\") == null &&\n+               getProperty(\"jdk.module.addmods.0\") == null  && \/\/ --add-modules\n+               getProperty(\"jdk.module.limitmods\") == null &&\n+               getProperty(\"jdk.module.addreads.0\") == null &&    \/\/ --add-reads\n+               getProperty(\"jdk.module.addexports.0\") == null &&  \/\/ --add-exports\n+               getProperty(\"jdk.module.addopens.0\") == null &&    \/\/ --add-opens\n+               getProperty(\"jdk.module.illegalAccess\") == null;\n+    }\n+\n+    \/**\n+     * Initialize the module system, returning the boot layer. The boot layer\n+     * is obtained from the CDS archive if possible, otherwise it is generated\n+     * from the module graph.\n@@ -141,2 +161,1 @@\n-    public static ModuleLayer boot() throws Exception {\n-\n+    public static ModuleLayer boot() {\n@@ -145,0 +164,26 @@\n+        ModuleLayer bootLayer;\n+        ArchivedBootLayer archivedBootLayer = ArchivedBootLayer.get();\n+        if (archivedBootLayer != null) {\n+            assert canUseArchivedBootLayer();\n+            bootLayer = archivedBootLayer.bootLayer();\n+            BootLoader.getUnnamedModule(); \/\/ trigger <clinit> of BootLoader.\n+            VM.defineArchivedModules(ClassLoaders.platformClassLoader(), ClassLoaders.appClassLoader());\n+\n+            \/\/ assume boot layer has at least one module providing a service\n+            \/\/ that is mapped to the application class loader.\n+            JLA.bindToLoader(bootLayer, ClassLoaders.appClassLoader());\n+\n+            \/\/ IllegalAccessLogger needs to be set\n+            var illegalAccessLoggerBuilder = archivedBootLayer.illegalAccessLoggerBuilder();\n+            if (illegalAccessLoggerBuilder != null) {\n+                illegalAccessLoggerBuilder.complete();\n+            }\n+        } else {\n+            bootLayer = boot2();\n+        }\n+\n+        Counters.publish(\"jdk.module.boot.totalTime\");\n+        return bootLayer;\n+    }\n+\n+    private static ModuleLayer boot2() {\n@@ -431,5 +476,6 @@\n-        addIllegalAccess(upgradeModulePath,\n-                         concealedPackagesToOpen,\n-                         exportedPackagesToOpen,\n-                         bootLayer,\n-                         extraExportsOrOpens);\n+        IllegalAccessLogger.Builder builder =\n+            addIllegalAccess(upgradeModulePath,\n+                             concealedPackagesToOpen,\n+                             exportedPackagesToOpen,\n+                             bootLayer,\n+                             extraExportsOrOpens);\n@@ -445,2 +491,2 @@\n-        \/\/ Module graph can be archived at CDS dump time. Only allow the\n-        \/\/ unnamed module case for now.\n+        \/\/ Archive module graph and boot layer can be archived at CDS dump time.\n+        \/\/ Only allow the unnamed module case for now.\n@@ -448,8 +494,11 @@\n-            ArchivedModuleGraph.archive(\n-                    new ArchivedModuleGraph(hasSplitPackages,\n-                                            hasIncubatorModules,\n-                                            systemModuleFinder,\n-                                            cf,\n-                                            clf,\n-                                            concealedPackagesToOpen,\n-                                            exportedPackagesToOpen));\n+            ArchivedModuleGraph.archive(hasSplitPackages,\n+                                        hasIncubatorModules,\n+                                        systemModuleFinder,\n+                                        cf,\n+                                        clf,\n+                                        concealedPackagesToOpen,\n+                                        exportedPackagesToOpen);\n+\n+            if (!hasSplitPackages && !hasIncubatorModules) {\n+                ArchivedBootLayer.archive(bootLayer, builder);\n+            }\n@@ -458,3 +507,0 @@\n-        \/\/ total time to initialize\n-        Counters.publish(\"jdk.module.boot.totalTime\");\n-\n@@ -754,5 +800,6 @@\n-    private static void addIllegalAccess(ModuleFinder upgradeModulePath,\n-                                         Map<String, Set<String>> concealedPackagesToOpen,\n-                                         Map<String, Set<String>> exportedPackagesToOpen,\n-                                         ModuleLayer bootLayer,\n-                                         boolean extraExportsOrOpens) {\n+    private static IllegalAccessLogger.Builder\n+        addIllegalAccess(ModuleFinder upgradeModulePath,\n+                         Map<String, Set<String>> concealedPackagesToOpen,\n+                         Map<String, Set<String>> exportedPackagesToOpen,\n+                         ModuleLayer bootLayer,\n+                         boolean extraExportsOrOpens) {\n@@ -764,1 +811,1 @@\n-                    return;\n+                    return null;\n@@ -776,1 +823,1 @@\n-                    return;\n+                    return null;\n@@ -839,2 +886,1 @@\n-            JavaLangAccess jla = SharedSecrets.getJavaLangAccess();\n-            jla.addOpensToAllUnnamed(m, concealedPackages, exportedPackages);\n+            JLA.addOpensToAllUnnamed(m, concealedPackages, exportedPackages);\n@@ -844,0 +890,1 @@\n+        return builder;\n@@ -908,0 +955,8 @@\n+\n+    \/**\n+     * Gets the named system property\n+     *\/\n+    private static String getProperty(String key) {\n+        return System.getProperty(key);\n+    }\n+\n@@ -912,1 +967,1 @@\n-        return (String)System.getProperties().remove(key);\n+        return (String) System.getProperties().remove(key);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/ModuleBootstrap.java","additions":91,"deletions":36,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -174,0 +174,10 @@\n+    \/**\n+     * Associates the given ServicesCatalog with the given class loader.\n+     *\/\n+    public static void putServicesCatalog(ClassLoader loader, ServicesCatalog catalog) {\n+        ServicesCatalog previous = CLV.putIfAbsent(loader, catalog);\n+        if (previous != null) {\n+            throw new InternalError();\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/ServicesCatalog.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -65,0 +65,7 @@\n+JNIEXPORT void JNICALL\n+Java_jdk_internal_misc_VM_defineArchivedModules(JNIEnv *env, jclass ignore,\n+                                                jobject platform_loader,\n+                                                jobject system_loader) {\n+    JVM_DefineArchivedModules(env, platform_loader, system_loader);\n+}\n+\n","filename":"src\/java.base\/share\/native\/libjava\/VM.c","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ * @compile ..\/modules\/CompilerUtils.java\n@@ -37,0 +38,2 @@\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n@@ -52,0 +55,5 @@\n+    private static final String TEST_SRC = System.getProperty(\"test.src\");\n+    private static final String TEST_CLASSES = System.getProperty(\"test.classes\");\n+\n+    private static final Path SRC_DIR = Paths.get(TEST_SRC, \"src\");\n+    private static final Path MODS_DIR = Paths.get(TEST_CLASSES, \"mods\");\n@@ -86,0 +94,12 @@\n+        boolean compiled;\n+        \/\/ Compile module jdk.test declaration\n+        compiled = CompilerUtils.compile(\n+            SRC_DIR.resolve(\"jdk.test\"),\n+            MODS_DIR.resolve(\"jdk.test\"));\n+        if (!compiled) {\n+            throw new RuntimeException(\"Test failed to compile module jdk.test\");\n+        }\n+\n+        \/\/ If modules in the system image have been archived in CDS, they will not be\n+        \/\/ created again at run time. Explicitly use an external module to make sure\n+        \/\/ we have a runtime-defined ModuleEntry\n@@ -90,1 +110,2 @@\n-            \"-version\");\n+            \"-p\", MODS_DIR.toString(),\n+            \"-m\", \"jdk.test\/test.Main\");\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/CheckForProperDetailStackTrace.java","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -0,0 +1,25 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+module jdk.test {\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/src\/jdk.test\/module-info.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test;\n+\n+public class Main {\n+    public static void main(String[] args) throws Exception {\n+        System.out.println(\"jdk.test\/test\/Main: hello\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/src\/jdk.test\/test\/Main.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8244778\n+ * @summary Make sure the archived mirrors of the primitive classes have the proper module (java.base)\n+ * @requires vm.cds\n+ * @library \/test\/lib\n+ * @run driver PrimitiveClassMirrors\n+ *\/\n+\n+import jdk.test.lib.cds.CDSTestUtils;\n+import jdk.test.lib.cds.CDSOptions;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class PrimitiveClassMirrors {\n+    public static void main(String[] args) throws Exception {\n+        CDSOptions opts = new CDSOptions();\n+\n+        CDSTestUtils.createArchiveAndCheck(opts);\n+        opts.setUseVersion(false);\n+        opts.addSuffix(\"-Xlog:cds=warning\", \"PrimitiveClassMirrors$TestApp\");\n+        OutputAnalyzer out = CDSTestUtils.runWithArchive(opts);\n+        out.shouldHaveExitValue(0);\n+\n+        \/\/ The test should have same results if CDS is turned off\n+        opts.setXShareMode(\"off\");\n+        OutputAnalyzer out2 = CDSTestUtils.runWithArchive(opts);\n+        out2.shouldHaveExitValue(0);\n+    }\n+\n+    static class TestApp {\n+        public static void main(String args[]) throws Exception {\n+            Class classes[] = {\n+                int.class,\n+                float.class,\n+                double.class,\n+                byte.class,\n+                boolean.class,\n+                char.class,\n+                long.class,\n+                short.class,\n+                void.class,\n+\n+                int[].class,\n+                float[].class,\n+                double[].class,\n+                byte[].class,\n+                boolean[].class,\n+                char[].class,\n+                long[].class,\n+                short[].class,\n+            };\n+\n+            for (Class c : classes) {\n+                test(c);\n+            }\n+        }\n+    }\n+\n+    static void test(Class c) throws Exception {\n+        Module m = c.getModule();\n+        boolean unexpected = (m == null || !(\"java.base\".equals(m.getName())));\n+        System.out.println(\"Module for \" + c + \" = \" + m + (unexpected ? \" *** Error\" : \"\"));\n+        if (unexpected) {\n+            throw new RuntimeException(\"Unexpected: \" + m);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/PrimitiveClassMirrors.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -0,0 +1,132 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8244778\n+ * @summary Make sure that the ServicesCatalogs for boot\/platform\/app loaders are properly archived.\n+ * @requires vm.cds\n+ * @modules java.naming\n+ * @library \/test\/lib\n+ * @run driver ServiceLoaderTest\n+ *\/\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.ServiceLoader;\n+import java.util.spi.ToolProvider;\n+import javax.naming.spi.InitialContextFactory;\n+import jdk.test.lib.cds.CDSTestUtils;\n+import jdk.test.lib.cds.CDSOptions;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class ServiceLoaderTest {\n+    public static void main(String[] args) throws Exception {\n+        CDSOptions opts = new CDSOptions();\n+\n+        CDSTestUtils.createArchiveAndCheck(opts);\n+\n+        \/\/ Some mach5 tiers run with -vmoptions:-Xlog:cds=debug. This would cause the outputs to mismatch.\n+        \/\/ Force -Xlog:cds=warning to supress the CDS logs.\n+        opts.setUseVersion(false);\n+        opts.addSuffix(\"-showversion\", \"-Xlog:cds=warning\", \"ServiceLoaderApp\");\n+        OutputAnalyzer out1 = CDSTestUtils.runWithArchive(opts);\n+\n+        opts.setXShareMode(\"off\");\n+        OutputAnalyzer out2 = CDSTestUtils.runWithArchive(opts);\n+\n+        compare(out1, out2);\n+    }\n+\n+    static void compare(OutputAnalyzer out1, OutputAnalyzer out2) {\n+        String[] arr1 = splitLines(out1);\n+        String[] arr2 = splitLines(out2);\n+\n+        int max = arr1.length > arr2.length ? arr1.length : arr2.length;\n+        for (int i = 0; i < max; i++) {\n+            if (i >= arr1.length) {\n+                mismatch(i, \"<EOF>\", arr2[i]);\n+            }\n+            if (i >= arr2.length) {\n+                mismatch(i, arr1[i], \"<EOF>\");\n+            }\n+            if (!arr1[i].equals(arr2[i])) {\n+                mismatch(i, arr1[i], arr2[i]);\n+            }\n+        }\n+    }\n+\n+    static String[] splitLines(OutputAnalyzer out) {\n+        return out.getStdout().split(\"\\n\");\n+    }\n+\n+    static void mismatch(int i, String s1, String s2) {\n+        System.out.println(\"Mismatched line: \" + i);\n+        System.out.println(\"cds on : \" + s1);\n+        System.out.println(\"cds off: \" + s2);\n+        throw new RuntimeException(\"Mismatched line \" + i + \": \\\"\" + s1 + \"\\\" vs \\\"\" + s2 + \"\\\"\");\n+    }\n+}\n+\n+class ServiceLoaderApp {\n+    public static void main(String args[]) throws Exception {\n+        doTest(ToolProvider.class);\n+        doTest(InitialContextFactory.class);\n+    }\n+\n+    static void doTest(Class c) throws Exception {\n+        System.out.println(\"============================================================\");\n+        System.out.println(\"Testing : \" + c.getName());\n+        System.out.println(\"============================================================\");\n+\n+        print_loader(\"default\",         ServiceLoader.load(c));\n+        print_loader(\"null loader\",     ServiceLoader.load(c, null));\n+        print_loader(\"platform loader\", ServiceLoader.load(c, ServiceLoaderApp.class.getClassLoader().getParent()));\n+        print_loader(\"system loader\",   ServiceLoader.load(c, ServiceLoaderApp.class.getClassLoader()));\n+    }\n+\n+    static void print_loader(String testCase, ServiceLoader loader) throws Exception {\n+        System.out.println(\"[TEST CASE] \" + testCase);\n+        System.out.println(\"[svcloader] \" + asString(loader));\n+        Iterator it = loader.iterator();\n+        ArrayList<String> list = new ArrayList<>();\n+        while (it.hasNext()) {\n+            list.add(asString(it.next().toString()));\n+        }\n+        Collections.sort(list);\n+        for (String s : list) {\n+            System.out.println(s);\n+        }\n+    }\n+\n+    static String asString(Object o) {\n+        String s = o.toString();\n+        int n = s.indexOf(\"@\");\n+        if (n >= 0) {\n+            s = s.substring(0, n);\n+        }\n+        return s;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/ServiceLoaderTest.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,0 +75,1 @@\n+        \"-Xlog:cds\",\n@@ -83,0 +84,1 @@\n+        output.shouldContain(\"full module graph: disabled due to incompatible property: java.system.class.loader=\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/SpecifySysLoaderProp.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8244778\n+ * @requires vm.cds\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n+ * @run driver NewModuleFinderTest\n+ * @summary Make sure the archived module graph can co-exist with modules that are\n+ *          dynamically defined at runtime using the ModuleFinder API.\n+ *\/\n+\n+import java.lang.module.Configuration;\n+import java.lang.module.ModuleFinder;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Set;\n+import jdk.test.lib.cds.CDSTestUtils;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class NewModuleFinderTest {\n+\n+    private static final Path USER_DIR = Paths.get(System.getProperty(\"user.dir\"));\n+    private static final String TEST_SRC = System.getProperty(\"test.src\");\n+    private static final Path SRC_DIR = Paths.get(TEST_SRC, \"modulepath\/src\");\n+    private static final Path MODS_DIR = Paths.get(\"mods\");\n+\n+    \/\/ the module name of the test module\n+    private static final String TEST_MODULE = \"com.simple\";\n+\n+    \/\/ the module main class\n+    private static final String MAIN_CLASS = \"com.simple.Main\";\n+\n+    private static final Set<String> modules = Set.of(TEST_MODULE);\n+\n+    public static void buildTestModule() throws Exception {\n+        \/\/ javac -d mods\/$TESTMODULE --module-path MOD_DIR modulepath\/src\/$TESTMODULE\/**\n+        JarBuilder.compileModule(SRC_DIR.resolve(TEST_MODULE),\n+                                 MODS_DIR.resolve(TEST_MODULE),\n+                                 MODS_DIR.toString());\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        \/\/ compile the modules and create the modular jar files\n+        buildTestModule();\n+\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n+            \"-Xlog:cds\",\n+            \"-Xlog:module=debug\",\n+            \"NewModuleFinderTest$Helper\");\n+        OutputAnalyzer out = CDSTestUtils.executeAndLog(pb, \"exec\");\n+        out.shouldHaveExitValue(0);\n+        out.shouldContain(\"define_module(): creation of module: com.simple,\");\n+    }\n+\n+    static class Helper {\n+        public static void main(String... args) {\n+            ModuleFinder finder = ModuleFinder.of(MODS_DIR);\n+            Configuration parent = ModuleLayer.boot().configuration();\n+            Configuration cf = parent.resolveAndBind(ModuleFinder.of(),\n+                                                     finder,\n+                                                     modules);\n+\n+            ClassLoader scl = ClassLoader.getSystemClassLoader();\n+            ModuleLayer layer = ModuleLayer.boot().defineModulesWithManyLoaders(cf, scl);\n+\n+            Module m1 = layer.findModule(TEST_MODULE).get();\n+            System.out.println(\"Module = \" + m1);\n+            if (m1 != null) {\n+                System.out.println(\"Success\");\n+            } else {\n+                throw new RuntimeException(\"Module should not be null\");\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/jigsaw\/NewModuleFinderTest.java","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8249276\n+ * @summary Make sure that archived module graph is not loaded if critical classes have been redefined.\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n+ * @requires vm.cds\n+ * @requires vm.flavor != \"minimal\"\n+ * @modules java.instrument\n+ * @run driver RedefineClassesInModuleGraph\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class RedefineClassesInModuleGraph {\n+    public static String appClasses[] = {\n+        RedefineClassesInModuleGraphApp.class.getName(),\n+    };\n+    public static String agentClasses[] = {\n+        RedefineClassesInModuleGraphAgent.class.getName(),\n+        RedefineClassesInModuleGraphTransformer.class.getName(),\n+    };\n+\n+    private static final String MANIFEST =\n+        \"Manifest-Version: 1.0\\n\" +\n+        \"Premain-Class: RedefineClassesInModuleGraphAgent\\n\" +\n+        \"Can-Retransform-Classes: true\\n\" +\n+        \"Can-Redefine-Classes: true\\n\";\n+\n+    public static void main(String[] args) throws Throwable {\n+        String agentJar =\n+            ClassFileInstaller.writeJar(\"RedefineClassesInModuleGraphAgent.jar\",\n+                                        ClassFileInstaller.Manifest.fromString(MANIFEST),\n+                                        agentClasses);\n+\n+        String appJar =\n+            ClassFileInstaller.writeJar(\"RedefineClassesInModuleGraphApp.jar\", appClasses);\n+\n+        TestCommon.testDump(appJar, agentClasses);\n+\n+        TestCommon.run(\n+            \"-cp\", appJar,\n+            \"-javaagent:\" + agentJar,\n+            RedefineClassesInModuleGraphApp.class.getName())\n+          .assertNormalExit();\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/jigsaw\/RedefineClassesInModuleGraph.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+import java.lang.instrument.Instrumentation;\n+\n+public class RedefineClassesInModuleGraphAgent {\n+    private static Instrumentation savedInstrumentation;\n+\n+    public static void premain(String agentArguments, Instrumentation instrumentation) {\n+        instrumentation.addTransformer(new RedefineClassesInModuleGraphTransformer(), \/*canRetransform=*\/true);\n+        savedInstrumentation = instrumentation;\n+    }\n+\n+    public static Instrumentation getInstrumentation() {\n+        return savedInstrumentation;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/jigsaw\/RedefineClassesInModuleGraphAgent.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+public class RedefineClassesInModuleGraphApp {\n+    public static void main(String args[]) {\n+        Module m = Object.class.getModule();\n+        ModuleLayer ml = m.getLayer();\n+        System.out.println(m);\n+        System.out.println(ml);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/jigsaw\/RedefineClassesInModuleGraphApp.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+import java.lang.instrument.ClassFileTransformer;\n+import java.lang.instrument.IllegalClassFormatException;\n+import java.security.ProtectionDomain;\n+\n+public class RedefineClassesInModuleGraphTransformer implements ClassFileTransformer {\n+    public byte[] transform(ClassLoader loader, String name, Class<?> classBeingRedefined,\n+                            ProtectionDomain pd, byte[] buffer) throws IllegalClassFormatException {\n+        System.out.println(\"transforming \" + name);\n+\n+        if (name.equals(\"java\/lang\/Module\")  ||\n+            name.equals(\"java\/lang\/ModuleLayer\")  ||\n+            name.equals(\"java\/lang\/module\/ResolvedModule\")) {\n+            throw new RuntimeException(\"Classes used by the module graph should never be transformed by Java agent\");\n+        }\n+        return null;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/jigsaw\/RedefineClassesInModuleGraphTransformer.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -27,1 +27,1 @@\n- * @requires vm.cds & !vm.jvmci\n+ * @requires vm.cds & !vm.graal.enabled\n@@ -66,2 +66,2 @@\n-    private static String OPTIMIZE_ENABLED = \"Using optimized module handling enabled\";\n-    private static String OPTIMIZE_DISABLED = \"Using optimized module handling disabled\";\n+    private static String OPTIMIZE_ENABLED = \"optimized module handling: enabled\";\n+    private static String OPTIMIZE_DISABLED = \"optimized module handling: disabled\";\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/jigsaw\/modulepath\/OptimizeModuleHandlingTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,1 +56,2 @@\n-                .addSuffix(\"-showversion\");\n+                .addSuffix(\"-showversion\")\n+                .addSuffix(\"-Xlog:cds\");\n@@ -83,0 +84,2 @@\n+            \"-early -notshared java\/lang\/Module\",\n+            \"-early -notshared java\/lang\/ModuleLayer\",\n@@ -90,7 +93,2 @@\n-\n-            \/* Try to replace classes that are used by the archived subgraph graphs.\n-               The following test cases are in ReplaceCriticalClassesForSubgraphs.java.\n-            \"-early -notshared -subgraph java\/lang\/module\/ResolvedModule jdk.internal.module.ArchivedModuleGraph\",\n-            \"-early -notshared -subgraph java\/lang\/Long java.lang.Long$LongCache\",\n-            \"-subgraph java\/lang\/Long java.lang.Long$LongCache\",\n-            *\/\n+            \"java\/lang\/Module\",\n+            \"java\/lang\/ModuleLayer\",\n@@ -119,1 +117,1 @@\n-            throw new RuntimeException(\"Invalid test case. Should be <-early> <-subgraph> <-notshared> klassName subgraphKlass\");\n+            throw new RuntimeException(\"Invalid test case. Should be <-early> <-subgraph> <-notshared> <-nowhitebox> klassName subgraphKlass\");\n@@ -125,0 +123,1 @@\n+        boolean whitebox = true;\n@@ -133,0 +132,2 @@\n+            } else if (opt.equals(\"-nowhitebox\")) {\n+                whitebox = false;\n@@ -169,4 +170,5 @@\n-                       agent,\n-                       \"-XX:+WhiteBoxAPI\",\n-                       \"-Xbootclasspath\/a:\" + ClassFileInstaller.getJarPath(\"whitebox.jar\"));\n-\n+                       agent);\n+        if (whitebox) {\n+            opts.addSuffix(\"-XX:+WhiteBoxAPI\",\n+                           \"-Xbootclasspath\/a:\" + ClassFileInstaller.getJarPath(\"whitebox.jar\"));\n+        }\n@@ -194,0 +196,2 @@\n+                            \/\/ If the subgraph is successfully initialized, the specified shared class must not be rewritten.\n+                            out.shouldNotContain(\"Rewriting done.\");\n@@ -203,1 +207,2 @@\n-        WhiteBox wb = WhiteBox.getWhiteBox();\n+        try {\n+            WhiteBox wb = WhiteBox.getWhiteBox();\n@@ -205,5 +210,9 @@\n-        if (shouldBeShared && !wb.isSharedClass(klass)) {\n-            throw new RuntimeException(klass + \" should be shared but but actually is not.\");\n-        }\n-        if (!shouldBeShared && wb.isSharedClass(klass)) {\n-            throw new RuntimeException(klass + \" should not be shared but actually is.\");\n+            if (shouldBeShared && !wb.isSharedClass(klass)) {\n+                throw new RuntimeException(klass + \" should be shared but but actually is not.\");\n+            }\n+            if (!shouldBeShared && wb.isSharedClass(klass)) {\n+                throw new RuntimeException(klass + \" should not be shared but actually is.\");\n+            }\n+            System.out.println(\"wb.isSharedClass(\" + klass + \"): \" + wb.isSharedClass(klass) + \" == \" + shouldBeShared);\n+        } catch (UnsatisfiedLinkError e) {\n+            System.out.println(\"WhiteBox is disabled -- because test has -nowhitebox\");\n@@ -211,1 +220,0 @@\n-        System.out.println(\"wb.isSharedClass(klass): \" + wb.isSharedClass(klass) + \" == \" + shouldBeShared);\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/serviceability\/ReplaceCriticalClasses.java","additions":29,"deletions":21,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-            \/\/ Try to replace classes that are used by the archived subgraph graphs.\n+            \/\/ Try to replace classes that are used by the archived subgraph graphs. (CDS should be disabled)\n@@ -46,0 +46,4 @@\n+\n+            \/\/ CDS should not be disabled -- these critical classes cannot be replaced because\n+            \/\/ JvmtiExport::early_class_hook_env() is false.\n+            \"-subgraph java\/lang\/module\/ResolvedModule jdk.internal.module.ArchivedModuleGraph\",\n@@ -47,0 +51,7 @@\n+\n+            \/\/ Tests for archived full module graph. We cannot use whitebox, which requires appending to bootclasspath.\n+            \/\/ VM will disable full module graph if bootclasspath is appended.\n+            \"-nowhitebox -early -notshared -subgraph java\/lang\/Module jdk.internal.module.ArchivedBootLayer\",\n+            \"-nowhitebox -early -notshared -subgraph java\/lang\/ModuleLayer jdk.internal.module.ArchivedBootLayer\",\n+            \"-nowhitebox -subgraph java\/lang\/Module jdk.internal.module.ArchivedBootLayer\",\n+            \"-nowhitebox -subgraph java\/lang\/ModuleLayer jdk.internal.module.ArchivedBootLayer\",\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/serviceability\/ReplaceCriticalClassesForSubgraphs.java","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -37,0 +37,5 @@\n+    \/\/ If modules in the system image have been archived in CDS, no Modules will\n+    \/\/ be dynamically created at runtime. Disable CDS so all of the expected messages\n+    \/\/ are printed.\n+    private static String XSHARE_OFF = \"-Xshare:off\";\n+\n@@ -38,3 +43,3 @@\n-        testModuleTrace(\"-Xlog:module=trace\", \"-version\");\n-        testModuleLoad(\"-Xlog:module+load\", \"-version\");\n-        testModuleUnload(\"-Xlog:module+unload\", \"-version\");\n+        testModuleTrace(\"-Xlog:module=trace\", XSHARE_OFF, \"-version\");\n+        testModuleLoad(\"-Xlog:module+load\", XSHARE_OFF, \"-version\");\n+        testModuleUnload(\"-Xlog:module+unload\", XSHARE_OFF, \"-version\");\n@@ -43,1 +48,1 @@\n-        testModuleLoad(\"-verbose:module\", \"-version\");\n+        testModuleLoad(\"-verbose:module\", XSHARE_OFF, \"-version\");\n","filename":"test\/hotspot\/jtreg\/runtime\/logging\/ModulesTest.java","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"}]}