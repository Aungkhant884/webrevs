{"files":[{"patch":"@@ -4204,1 +4204,1 @@\n-    greater_equal(0x3, \"nb\");\n+    greater_equal(0x3, \"ae\");\n@@ -4206,1 +4206,1 @@\n-    greater(0x7, \"nbe\");\n+    greater(0x7, \"a\");\n@@ -4219,1 +4219,2 @@\n-            n->as_Bool()->_test._test == BoolTest::gt);\n+            n->as_Bool()->_test._test == BoolTest::gt ||\n+            n->in(1)->in(1) == n->in(1)->in(2));\n@@ -4222,2 +4223,2 @@\n-    equal(0x4, \"e\");\n-    not_equal(0x5, \"ne\");\n+    equal(0xb, \"np\");\n+    not_equal(0xa, \"p\");\n@@ -4225,1 +4226,1 @@\n-    greater_equal(0x3, \"nb\");\n+    greater_equal(0x3, \"ae\");\n@@ -4227,1 +4228,1 @@\n-    greater(0x7, \"nbe\");\n+    greater(0x7, \"a\");\n@@ -4237,2 +4238,3 @@\n-  predicate(n->as_Bool()->_test._test == BoolTest::ne ||\n-            n->as_Bool()->_test._test == BoolTest::eq);\n+  predicate((n->as_Bool()->_test._test == BoolTest::ne ||\n+             n->as_Bool()->_test._test == BoolTest::eq) &&\n+            n->in(1)->in(1) != n->in(1)->in(2));\n@@ -4244,1 +4246,1 @@\n-    greater_equal(0x3, \"nb\");\n+    greater_equal(0x3, \"ae\");\n@@ -4246,1 +4248,1 @@\n-    greater(0x7, \"nbe\");\n+    greater(0x7, \"a\");\n@@ -6973,0 +6975,28 @@\n+instruct cmovI_regUCF2_ne(cmpOpUCF2 cop, rFlagsRegUCF cr, rRegI dst, rRegI src) %{\n+  predicate(n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::ne);\n+  match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));\n+\n+  ins_cost(200); \/\/ XXX\n+  format %{ \"cmovpl  $dst, $src\\n\\t\"\n+            \"cmovnel $dst, $src\" %}\n+  ins_encode %{\n+    __ cmovl(Assembler::parity, $dst$$Register, $src$$Register);\n+    __ cmovl(Assembler::notEqual, $dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n+instruct cmovI_regUCF2_eq(cmpOpUCF2 cop, rFlagsRegUCF cr, rRegI dst, rRegI src) %{\n+  predicate(n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::eq);\n+  match(Set dst (CMoveI (Binary cop cr) (Binary src dst)));\n+\n+  ins_cost(200); \/\/ XXX\n+  format %{ \"cmovpl  $dst, $src\\n\\t\"\n+            \"cmovnel $dst, $src\" %}\n+  ins_encode %{\n+    __ cmovl(Assembler::parity, $dst$$Register, $src$$Register);\n+    __ cmovl(Assembler::notEqual, $dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n@@ -7040,0 +7070,28 @@\n+instruct cmovN_regUCF2_ne(cmpOpUCF2 cop, rFlagsRegUCF cr, rRegN dst, rRegN src) %{\n+  predicate(n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::ne);\n+  match(Set dst (CMoveN (Binary cop cr) (Binary dst src)));\n+\n+  ins_cost(200); \/\/ XXX\n+  format %{ \"cmovpl  $dst, $src\\n\\t\"\n+            \"cmovnel $dst, $src\" %}\n+  ins_encode %{\n+    __ cmovl(Assembler::parity, $dst$$Register, $src$$Register);\n+    __ cmovl(Assembler::notEqual, $dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n+instruct cmovN_regUCF2_eq(cmpOpUCF2 cop, rFlagsRegUCF cr, rRegN dst, rRegN src) %{\n+  predicate(n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::eq);\n+  match(Set dst (CMoveN (Binary cop cr) (Binary src dst)));\n+\n+  ins_cost(200); \/\/ XXX\n+  format %{ \"cmovpl  $dst, $src\\n\\t\"\n+            \"cmovnel $dst, $src\" %}\n+  ins_encode %{\n+    __ cmovl(Assembler::parity, $dst$$Register, $src$$Register);\n+    __ cmovl(Assembler::notEqual, $dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n@@ -7074,0 +7132,28 @@\n+instruct cmovP_regUCF2_ne(cmpOpUCF2 cop, rFlagsRegUCF cr, rRegP dst, rRegP src) %{\n+  predicate(n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::ne);\n+  match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));\n+\n+  ins_cost(200); \/\/ XXX\n+  format %{ \"cmovpq  $dst, $src\\n\\t\"\n+            \"cmovneq $dst, $src\" %}\n+  ins_encode %{\n+    __ cmovq(Assembler::parity, $dst$$Register, $src$$Register);\n+    __ cmovq(Assembler::notEqual, $dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n+instruct cmovP_regUCF2_eq(cmpOpUCF2 cop, rFlagsRegUCF cr, rRegP dst, rRegP src) %{\n+  predicate(n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::eq);\n+  match(Set dst (CMoveP (Binary cop cr) (Binary src dst)));\n+\n+  ins_cost(200); \/\/ XXX\n+  format %{ \"cmovpq  $dst, $src\\n\\t\"\n+            \"cmovneq $dst, $src\" %}\n+  ins_encode %{\n+    __ cmovq(Assembler::parity, $dst$$Register, $src$$Register);\n+    __ cmovq(Assembler::notEqual, $dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n@@ -7145,0 +7231,28 @@\n+instruct cmovL_regUCF2_ne(cmpOpUCF2 cop, rFlagsRegUCF cr, rRegL dst, rRegL src) %{\n+  predicate(n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::ne);\n+  match(Set dst (CMoveL (Binary cop cr) (Binary dst src)));\n+\n+  ins_cost(200); \/\/ XXX\n+  format %{ \"cmovpq  $dst, $src\\n\\t\"\n+            \"cmovneq $dst, $src\" %}\n+  ins_encode %{\n+    __ cmovq(Assembler::parity, $dst$$Register, $src$$Register);\n+    __ cmovq(Assembler::notEqual, $dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n+instruct cmovL_regUCF2_eq(cmpOpUCF2 cop, rFlagsRegUCF cr, rRegL dst, rRegL src) %{\n+  predicate(n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::eq);\n+  match(Set dst (CMoveL (Binary cop cr) (Binary src dst)));\n+\n+  ins_cost(200); \/\/ XXX\n+  format %{ \"cmovpq  $dst, $src\\n\\t\"\n+            \"cmovneq $dst, $src\" %}\n+  ins_encode %{\n+    __ cmovq(Assembler::parity, $dst$$Register, $src$$Register);\n+    __ cmovq(Assembler::notEqual, $dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n@@ -10393,0 +10507,1 @@\n+\/\/ Really expensive, avoid\n@@ -10397,1 +10512,1 @@\n-  ins_cost(145);\n+  ins_cost(500);\n@@ -10422,18 +10537,0 @@\n-instruct cmpF_cc_mem(rFlagsRegU cr, regF src1, memory src2)\n-%{\n-  match(Set cr (CmpF src1 (LoadF src2)));\n-\n-  ins_cost(145);\n-  format %{ \"ucomiss $src1, $src2\\n\\t\"\n-            \"jnp,s   exit\\n\\t\"\n-            \"pushfq\\t# saw NaN, set CF\\n\\t\"\n-            \"andq    [rsp], #0xffffff2b\\n\\t\"\n-            \"popfq\\n\"\n-    \"exit:\" %}\n-  ins_encode %{\n-    __ ucomiss($src1$$XMMRegister, $src2$$Address);\n-    emit_cmpfp_fixup(_masm);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n@@ -10451,17 +10548,0 @@\n-instruct cmpF_cc_imm(rFlagsRegU cr, regF src, immF con) %{\n-  match(Set cr (CmpF src con));\n-\n-  ins_cost(145);\n-  format %{ \"ucomiss $src, [$constantaddress]\\t# load from constant table: float=$con\\n\\t\"\n-            \"jnp,s   exit\\n\\t\"\n-            \"pushfq\\t# saw NaN, set CF\\n\\t\"\n-            \"andq    [rsp], #0xffffff2b\\n\\t\"\n-            \"popfq\\n\"\n-    \"exit:\" %}\n-  ins_encode %{\n-    __ ucomiss($src$$XMMRegister, $constantaddress($con));\n-    emit_cmpfp_fixup(_masm);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n@@ -10478,0 +10558,1 @@\n+\/\/ Really expensive, avoid\n@@ -10482,1 +10563,1 @@\n-  ins_cost(145);\n+  ins_cost(500);\n@@ -10507,18 +10588,0 @@\n-instruct cmpD_cc_mem(rFlagsRegU cr, regD src1, memory src2)\n-%{\n-  match(Set cr (CmpD src1 (LoadD src2)));\n-\n-  ins_cost(145);\n-  format %{ \"ucomisd $src1, $src2\\n\\t\"\n-            \"jnp,s   exit\\n\\t\"\n-            \"pushfq\\t# saw NaN, set CF\\n\\t\"\n-            \"andq    [rsp], #0xffffff2b\\n\\t\"\n-            \"popfq\\n\"\n-    \"exit:\" %}\n-  ins_encode %{\n-    __ ucomisd($src1$$XMMRegister, $src2$$Address);\n-    emit_cmpfp_fixup(_masm);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n@@ -10536,17 +10599,0 @@\n-instruct cmpD_cc_imm(rFlagsRegU cr, regD src, immD con) %{\n-  match(Set cr (CmpD src con));\n-\n-  ins_cost(145);\n-  format %{ \"ucomisd $src, [$constantaddress]\\t# load from constant table: double=$con\\n\\t\"\n-            \"jnp,s   exit\\n\\t\"\n-            \"pushfq\\t# saw NaN, set CF\\n\\t\"\n-            \"andq    [rsp], #0xffffff2b\\n\\t\"\n-            \"popfq\\n\"\n-    \"exit:\" %}\n-  ins_encode %{\n-    __ ucomisd($src$$XMMRegister, $constantaddress($con));\n-    emit_cmpfp_fixup(_masm);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":129,"deletions":83,"binary":false,"changes":212,"status":"modified"},{"patch":"@@ -684,1 +684,1 @@\n-        return (v == POSITIVE_INFINITY) || (v == NEGATIVE_INFINITY);\n+        return Math.abs(v) > MAX_VALUE;\n@@ -698,1 +698,1 @@\n-        return Math.abs(d) <= Double.MAX_VALUE;\n+        return Math.abs(d) <= MAX_VALUE;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Double.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -509,1 +509,1 @@\n-        return (v == POSITIVE_INFINITY) || (v == NEGATIVE_INFINITY);\n+        return Math.abs(v) > MAX_VALUE;\n@@ -523,2 +523,2 @@\n-     public static boolean isFinite(float f) {\n-        return Math.abs(f) <= Float.MAX_VALUE;\n+    public static boolean isFinite(float f) {\n+        return Math.abs(f) <= MAX_VALUE;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Float.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,182 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+\n+\/*\n+ * @test\n+ * @bug 8285973\n+ * @summary Test that code generation for fp comparison works as intended\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.TestFPComparison\n+ *\/\n+public class TestFPComparison {\n+    static final double[] DOUBLES = new double[] {\n+            0,\n+            1,\n+            Double.MIN_VALUE,\n+            Double.MAX_VALUE,\n+            Double.POSITIVE_INFINITY,\n+            Double.NEGATIVE_INFINITY,\n+            Double.NaN,\n+    };\n+\n+    static final float[] FLOATS = new float[] {\n+            0,\n+            1,\n+            Float.MIN_VALUE,\n+            Float.MAX_VALUE,\n+            Float.POSITIVE_INFINITY,\n+            Float.NEGATIVE_INFINITY,\n+            Float.NaN,\n+    };\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @DontInline\n+    static int call() {\n+        return 1;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CMOVEI, \"1\"})\n+    public int cMoveEqualTwoDoubles(double x, double y) {\n+        return x == y ? 1 : 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CMOVEI, \"1\"})\n+    public int cMoveEqualTwoFloats(float x, float y) {\n+        return x == y ? 1 : 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CMOVEI, \"1\"})\n+    public int cMoveNotEqualTwoDoubles(double x, double y) {\n+        return x != y ? 1 : 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CMOVEI, \"1\"})\n+    public int cMoveNotEqualTwoFloats(float x, float y) {\n+        return x != y ? 1 : 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CMOVEI, \"1\"})\n+    public int cMoveEqualOneDouble(double x) {\n+        return x == x ? 1 : 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CMOVEI, \"1\"})\n+    public int cMoveEqualOneFloat(float x) {\n+        return x == x ? 1 : 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CMOVEI, \"1\"})\n+    public int cMoveNotEqualOneDouble(double x) {\n+        return x != x ? 1 : 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CMOVEI, \"1\"})\n+    public int cMoveNotEqualOneFloat(float x) {\n+        return x != x ? 1 : 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.IF, \"1\"})\n+    public int branchEqualOneDouble(double x) {\n+        return x == x ? call() : 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.IF, \"1\"})\n+    public int branchEqualOneFloat(float x) {\n+        return x == x ? call() : 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.IF, \"1\"})\n+    public int branchNotEqualOneDouble(double x) {\n+        return x != x ? call() : 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.IF, \"1\"})\n+    public int branchNotEqualOneFloat(float x) {\n+        return x != x ? call() : 0;\n+    }\n+\n+    @Run(test = {\"cMoveEqualTwoDoubles\", \"cMoveEqualTwoFloats\", \"cMoveNotEqualTwoDoubles\", \"cMoveNotEqualTwoFloats\",\n+            \"cMoveEqualOneDouble\", \"cMoveEqualOneFloat\", \"cMoveNotEqualOneDouble\", \"cMoveNotEqualOneFloat\",\n+            \"branchEqualOneDouble\", \"branchEqualOneFloat\", \"branchNotEqualOneDouble\", \"branchNotEqualOneFloat\"})\n+    public void runTests() {\n+        for (int i = 0; i < DOUBLES.length; i++) {\n+            for (int j = 0; j < DOUBLES.length; j++) {\n+                Asserts.assertEquals(cMoveEqualTwoDoubles(DOUBLES[i], DOUBLES[i]),\n+                        (i != DOUBLES.length - 1) ? 1 : 0);\n+                Asserts.assertEquals(cMoveNotEqualTwoDoubles(DOUBLES[i], DOUBLES[i]),\n+                        (i == DOUBLES.length - 1) ? 1 : 0);\n+                Asserts.assertEquals(cMoveEqualTwoDoubles(DOUBLES[i], DOUBLES[j]),\n+                        (i == j && i != DOUBLES.length - 1) ? 1 : 0);\n+                Asserts.assertEquals(cMoveNotEqualTwoDoubles(DOUBLES[i], DOUBLES[j]),\n+                        (i != j || i == DOUBLES.length - 1) ? 1 : 0);\n+            }\n+        }\n+        for (int i = 0; i < FLOATS.length; i++) {\n+            for (int j = 0; j < FLOATS.length; j++) {\n+                Asserts.assertEquals(cMoveEqualTwoFloats(FLOATS[i], FLOATS[i]),\n+                        (i != FLOATS.length - 1) ? 1 : 0);\n+                Asserts.assertEquals(cMoveNotEqualTwoFloats(FLOATS[i], FLOATS[i]),\n+                        (i == FLOATS.length - 1) ? 1 : 0);\n+                Asserts.assertEquals(cMoveEqualTwoFloats(FLOATS[i], FLOATS[j]),\n+                        (i == j && i != FLOATS.length - 1) ? 1 : 0);\n+                Asserts.assertEquals(cMoveNotEqualTwoFloats(FLOATS[i], FLOATS[j]),\n+                        (i != j || i == FLOATS.length - 1) ? 1 : 0);\n+            }\n+        }\n+        for (int i = 0; i < DOUBLES.length; i++) {\n+            Asserts.assertEquals(cMoveEqualOneDouble(DOUBLES[DOUBLES.length - 1]), 0);\n+            Asserts.assertEquals(cMoveNotEqualOneDouble(DOUBLES[DOUBLES.length - 1]), 1);\n+            Asserts.assertEquals(cMoveEqualOneDouble(DOUBLES[i]), (i != DOUBLES.length - 1) ? 1 : 0);\n+            Asserts.assertEquals(cMoveNotEqualOneDouble(DOUBLES[i]), (i == DOUBLES.length - 1) ? 1 : 0);\n+            Asserts.assertEquals(branchEqualOneDouble(DOUBLES[i]), (i != DOUBLES.length - 1) ? 1 : 0);\n+            Asserts.assertEquals(branchNotEqualOneDouble(DOUBLES[i]), (i == DOUBLES.length - 1) ? 1 : 0);\n+        }\n+        for (int i = 0; i < FLOATS.length; i++) {\n+            Asserts.assertEquals(cMoveEqualOneFloat(FLOATS[FLOATS.length - 1]), 0);\n+            Asserts.assertEquals(cMoveNotEqualOneFloat(FLOATS[FLOATS.length - 1]), 1);\n+            Asserts.assertEquals(cMoveEqualOneFloat(FLOATS[i]), (i != FLOATS.length - 1) ? 1 : 0);\n+            Asserts.assertEquals(cMoveNotEqualOneFloat(FLOATS[i]), (i == FLOATS.length - 1) ? 1 : 0);\n+            Asserts.assertEquals(branchEqualOneFloat(FLOATS[i]), (i != FLOATS.length - 1) ? 1 : 0);\n+            Asserts.assertEquals(branchNotEqualOneFloat(FLOATS[i]), (i == FLOATS.length - 1) ? 1 : 0);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestFPComparison.java","additions":182,"deletions":0,"binary":false,"changes":182,"status":"added"},{"patch":"@@ -143,0 +143,1 @@\n+    public static final String CMOVEI = START + \"CMoveI\" + MID + END;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+\n+\/**\n+ * @test\n+ * @summary Verify isNan, isInfinite, isFinite\n+ * @bug 8285973\n+ * @library \/test\/lib\n+ * @run main\/othervm Classification\n+ *\/\n+public class Classification {\n+    public static void main(String[] args) {\n+        testIsNaN();\n+        testIsInfinite();\n+        testIsFinite();\n+    }\n+\n+    static void testIsNaN() {\n+        Asserts.assertTrue(Double.isNaN(Double.NaN));\n+        Asserts.assertFalse(Double.isNaN(0));\n+        Asserts.assertFalse(Double.isNaN(1));\n+        Asserts.assertFalse(Double.isNaN(Double.MIN_VALUE));\n+        Asserts.assertFalse(Double.isNaN(Double.MAX_VALUE));\n+        Asserts.assertFalse(Double.isNaN(Double.POSITIVE_INFINITY));\n+        Asserts.assertFalse(Double.isNaN(Double.NEGATIVE_INFINITY));\n+    }\n+\n+    static void testIsInfinite() {\n+        Asserts.assertFalse(Double.isInfinite(Double.NaN));\n+        Asserts.assertFalse(Double.isInfinite(0));\n+        Asserts.assertFalse(Double.isInfinite(1));\n+        Asserts.assertFalse(Double.isInfinite(Double.MIN_VALUE));\n+        Asserts.assertFalse(Double.isInfinite(Double.MAX_VALUE));\n+        Asserts.assertTrue(Double.isInfinite(Double.POSITIVE_INFINITY));\n+        Asserts.assertTrue(Double.isInfinite(Double.NEGATIVE_INFINITY));\n+    }\n+\n+    static void testIsFinite() {\n+        Asserts.assertFalse(Double.isFinite(Double.NaN));\n+        Asserts.assertTrue(Double.isFinite(0));\n+        Asserts.assertTrue(Double.isFinite(1));\n+        Asserts.assertTrue(Double.isFinite(Double.MIN_VALUE));\n+        Asserts.assertTrue(Double.isFinite(Double.MAX_VALUE));\n+        Asserts.assertFalse(Double.isFinite(Double.POSITIVE_INFINITY));\n+        Asserts.assertFalse(Double.isFinite(Double.NEGATIVE_INFINITY));\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Double\/Classification.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+\n+\/**\n+ * @test\n+ * @summary Verify isNan, isInfinite, isFinite\n+ * @bug 8285973\n+ * @library \/test\/lib\n+ * @run main\/othervm Classification\n+ *\/\n+public class Classification {\n+    public static void main(String[] args) {\n+        testIsNaN();\n+        testIsInfinite();\n+        testIsFinite();\n+    }\n+\n+    static void testIsNaN() {\n+        Asserts.assertTrue(Float.isNaN(Float.NaN));\n+        Asserts.assertFalse(Float.isNaN(0));\n+        Asserts.assertFalse(Float.isNaN(1));\n+        Asserts.assertFalse(Float.isNaN(Float.MIN_VALUE));\n+        Asserts.assertFalse(Float.isNaN(Float.MAX_VALUE));\n+        Asserts.assertFalse(Float.isNaN(Float.POSITIVE_INFINITY));\n+        Asserts.assertFalse(Float.isNaN(Float.NEGATIVE_INFINITY));\n+    }\n+\n+    static void testIsInfinite() {\n+        Asserts.assertFalse(Float.isInfinite(Float.NaN));\n+        Asserts.assertFalse(Float.isInfinite(0));\n+        Asserts.assertFalse(Float.isInfinite(1));\n+        Asserts.assertFalse(Float.isInfinite(Float.MIN_VALUE));\n+        Asserts.assertFalse(Float.isInfinite(Float.MAX_VALUE));\n+        Asserts.assertTrue(Float.isInfinite(Float.POSITIVE_INFINITY));\n+        Asserts.assertTrue(Float.isInfinite(Float.NEGATIVE_INFINITY));\n+    }\n+\n+    static void testIsFinite() {\n+        Asserts.assertFalse(Float.isFinite(Float.NaN));\n+        Asserts.assertTrue(Float.isFinite(0));\n+        Asserts.assertTrue(Float.isFinite(1));\n+        Asserts.assertTrue(Float.isFinite(Float.MIN_VALUE));\n+        Asserts.assertTrue(Float.isFinite(Float.MAX_VALUE));\n+        Asserts.assertFalse(Float.isFinite(Float.POSITIVE_INFINITY));\n+        Asserts.assertFalse(Float.isFinite(Float.NEGATIVE_INFINITY));\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Float\/Classification.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -0,0 +1,132 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang;\n+\n+import org.openjdk.jmh.annotations.*;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.random.RandomGenerator;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Fork(1)\n+public class FPComparison {\n+    static final int INVOCATIONS = 1024;\n+\n+    float[] f1;\n+    double[] d1;\n+    float[] f2;\n+    double[] d2;\n+    int[] res;\n+\n+    @Setup\n+    public void setup() {\n+        var random = RandomGenerator.getDefault();\n+        f1 = new float[INVOCATIONS];\n+        d1 = new double[INVOCATIONS];\n+        f2 = new float[INVOCATIONS];\n+        d2 = new double[INVOCATIONS];\n+        res = new int[INVOCATIONS];\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            int type = random.nextInt(5);\n+            if (type == 1) {\n+                f1[i] = random.nextFloat();\n+                d1[i] = random.nextDouble();\n+                f2[i] = random.nextFloat();\n+                d2[i] = random.nextDouble();\n+            } else if (type == 2) {\n+                f1[i] = Float.POSITIVE_INFINITY;\n+                d1[i] = Double.POSITIVE_INFINITY;\n+                f2[i] = Float.POSITIVE_INFINITY;\n+                d2[i] = Double.POSITIVE_INFINITY;\n+            } else if (type == 3) {\n+                f1[i] = Float.NEGATIVE_INFINITY;\n+                d1[i] = Double.NEGATIVE_INFINITY;\n+                f2[i] = Float.NEGATIVE_INFINITY;\n+                d2[i] = Double.NEGATIVE_INFINITY;\n+            } else if (type >= 4) {\n+                f1[i] = Float.NaN;\n+                d1[i] = Double.NaN;\n+                f2[i] = Float.NaN;\n+                d2[i] = Double.NaN;\n+            }\n+        }\n+    }\n+\n+    @Benchmark\n+    public void isNanFloat() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            res[i] = Float.isNaN(f1[i]) ? 1 : 0;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void isNanDouble() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            res[i] = Double.isNaN(d1[i]) ? 1 : 0;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void isInfiniteFloat() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            res[i] = Float.isInfinite(f1[i]) ? 1 : 0;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void isInfiniteDouble() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            res[i] = Double.isInfinite(d1[i]) ? 1 : 0;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void isFiniteFloat() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            res[i] = Float.isFinite(f1[i]) ? 1 : 0;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void isFiniteDouble() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            res[i] = Double.isFinite(d1[i]) ? 1 : 0;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void equalFloat() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            res[i] = (f1[i] == f2[i]) ? 1 : 0;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void equalDouble() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            res[i] = (d1[i] == d2[i]) ? 1 : 0;\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/FPComparison.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"added"}]}