{"files":[{"patch":"@@ -4176,1 +4176,1 @@\n-    greater_equal(0x3, \"nb\");\n+    greater_equal(0x3, \"ae\");\n@@ -4178,1 +4178,1 @@\n-    greater(0x7, \"nbe\");\n+    greater(0x7, \"a\");\n@@ -4191,1 +4191,2 @@\n-            n->as_Bool()->_test._test == BoolTest::gt);\n+            n->as_Bool()->_test._test == BoolTest::gt ||\n+            n->in(1)->in(1) == n->in(1)->in(2));\n@@ -4194,2 +4195,2 @@\n-    equal(0x4, \"e\");\n-    not_equal(0x5, \"ne\");\n+    equal(0xb, \"np\");\n+    not_equal(0xa, \"p\");\n@@ -4197,1 +4198,1 @@\n-    greater_equal(0x3, \"nb\");\n+    greater_equal(0x3, \"ae\");\n@@ -4199,1 +4200,1 @@\n-    greater(0x7, \"nbe\");\n+    greater(0x7, \"a\");\n@@ -4209,2 +4210,3 @@\n-  predicate(n->as_Bool()->_test._test == BoolTest::ne ||\n-            n->as_Bool()->_test._test == BoolTest::eq);\n+  predicate((n->as_Bool()->_test._test == BoolTest::ne ||\n+             n->as_Bool()->_test._test == BoolTest::eq) &&\n+            n->in(1)->in(1) != n->in(1)->in(2));\n@@ -4216,1 +4218,1 @@\n-    greater_equal(0x3, \"nb\");\n+    greater_equal(0x3, \"ae\");\n@@ -4218,1 +4220,1 @@\n-    greater(0x7, \"nbe\");\n+    greater(0x7, \"a\");\n@@ -6945,0 +6947,28 @@\n+instruct cmovI_regUCF2_ne(cmpOpUCF2 cop, rFlagsRegUCF cr, rRegI dst, rRegI src) %{\n+  predicate(n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::ne);\n+  match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));\n+\n+  ins_cost(200); \/\/ XXX\n+  format %{ \"cmovpl  $dst, $src\\n\\t\"\n+            \"cmovnel $dst, $src\" %}\n+  ins_encode %{\n+    __ cmovl(Assembler::parity, $dst$$Register, $src$$Register);\n+    __ cmovl(Assembler::notEqual, $dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n+instruct cmovI_regUCF2_eq(cmpOpUCF2 cop, rFlagsRegUCF cr, rRegI dst, rRegI src) %{\n+  predicate(n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::eq);\n+  match(Set dst (CMoveI (Binary cop cr) (Binary src dst)));\n+\n+  ins_cost(200); \/\/ XXX\n+  format %{ \"cmovpl  $dst, $src\\n\\t\"\n+            \"cmovnel $dst, $src\" %}\n+  ins_encode %{\n+    __ cmovl(Assembler::parity, $dst$$Register, $src$$Register);\n+    __ cmovl(Assembler::notEqual, $dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n@@ -7012,0 +7042,28 @@\n+instruct cmovN_regUCF2_ne(cmpOpUCF2 cop, rFlagsRegUCF cr, rRegN dst, rRegN src) %{\n+  predicate(n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::ne);\n+  match(Set dst (CMoveN (Binary cop cr) (Binary dst src)));\n+\n+  ins_cost(200); \/\/ XXX\n+  format %{ \"cmovpl  $dst, $src\\n\\t\"\n+            \"cmovnel $dst, $src\" %}\n+  ins_encode %{\n+    __ cmovl(Assembler::parity, $dst$$Register, $src$$Register);\n+    __ cmovl(Assembler::notEqual, $dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n+instruct cmovN_regUCF2_eq(cmpOpUCF2 cop, rFlagsRegUCF cr, rRegN dst, rRegN src) %{\n+  predicate(n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::eq);\n+  match(Set dst (CMoveN (Binary cop cr) (Binary src dst)));\n+\n+  ins_cost(200); \/\/ XXX\n+  format %{ \"cmovpl  $dst, $src\\n\\t\"\n+            \"cmovnel $dst, $src\" %}\n+  ins_encode %{\n+    __ cmovl(Assembler::parity, $dst$$Register, $src$$Register);\n+    __ cmovl(Assembler::notEqual, $dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n@@ -7046,0 +7104,28 @@\n+instruct cmovP_regUCF2_ne(cmpOpUCF2 cop, rFlagsRegUCF cr, rRegP dst, rRegP src) %{\n+  predicate(n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::ne);\n+  match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));\n+\n+  ins_cost(200); \/\/ XXX\n+  format %{ \"cmovpq  $dst, $src\\n\\t\"\n+            \"cmovneq $dst, $src\" %}\n+  ins_encode %{\n+    __ cmovq(Assembler::parity, $dst$$Register, $src$$Register);\n+    __ cmovq(Assembler::notEqual, $dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n+instruct cmovP_regUCF2_eq(cmpOpUCF2 cop, rFlagsRegUCF cr, rRegP dst, rRegP src) %{\n+  predicate(n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::eq);\n+  match(Set dst (CMoveP (Binary cop cr) (Binary src dst)));\n+\n+  ins_cost(200); \/\/ XXX\n+  format %{ \"cmovpq  $dst, $src\\n\\t\"\n+            \"cmovneq $dst, $src\" %}\n+  ins_encode %{\n+    __ cmovq(Assembler::parity, $dst$$Register, $src$$Register);\n+    __ cmovq(Assembler::notEqual, $dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n@@ -7117,0 +7203,28 @@\n+instruct cmovL_regUCF2_ne(cmpOpUCF2 cop, rFlagsRegUCF cr, rRegL dst, rRegL src) %{\n+  predicate(n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::ne);\n+  match(Set dst (CMoveL (Binary cop cr) (Binary dst src)));\n+\n+  ins_cost(200); \/\/ XXX\n+  format %{ \"cmovpq  $dst, $src\\n\\t\"\n+            \"cmovneq $dst, $src\" %}\n+  ins_encode %{\n+    __ cmovq(Assembler::parity, $dst$$Register, $src$$Register);\n+    __ cmovq(Assembler::notEqual, $dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n+instruct cmovL_regUCF2_eq(cmpOpUCF2 cop, rFlagsRegUCF cr, rRegL dst, rRegL src) %{\n+  predicate(n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::eq);\n+  match(Set dst (CMoveL (Binary cop cr) (Binary src dst)));\n+\n+  ins_cost(200); \/\/ XXX\n+  format %{ \"cmovpq  $dst, $src\\n\\t\"\n+            \"cmovneq $dst, $src\" %}\n+  ins_encode %{\n+    __ cmovq(Assembler::parity, $dst$$Register, $src$$Register);\n+    __ cmovq(Assembler::notEqual, $dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n@@ -10365,0 +10479,1 @@\n+\/\/ Really expensive, avoid\n@@ -10369,1 +10484,1 @@\n-  ins_cost(145);\n+  ins_cost(500);\n@@ -10394,18 +10509,0 @@\n-instruct cmpF_cc_mem(rFlagsRegU cr, regF src1, memory src2)\n-%{\n-  match(Set cr (CmpF src1 (LoadF src2)));\n-\n-  ins_cost(145);\n-  format %{ \"ucomiss $src1, $src2\\n\\t\"\n-            \"jnp,s   exit\\n\\t\"\n-            \"pushfq\\t# saw NaN, set CF\\n\\t\"\n-            \"andq    [rsp], #0xffffff2b\\n\\t\"\n-            \"popfq\\n\"\n-    \"exit:\" %}\n-  ins_encode %{\n-    __ ucomiss($src1$$XMMRegister, $src2$$Address);\n-    emit_cmpfp_fixup(_masm);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n@@ -10423,17 +10520,0 @@\n-instruct cmpF_cc_imm(rFlagsRegU cr, regF src, immF con) %{\n-  match(Set cr (CmpF src con));\n-\n-  ins_cost(145);\n-  format %{ \"ucomiss $src, [$constantaddress]\\t# load from constant table: float=$con\\n\\t\"\n-            \"jnp,s   exit\\n\\t\"\n-            \"pushfq\\t# saw NaN, set CF\\n\\t\"\n-            \"andq    [rsp], #0xffffff2b\\n\\t\"\n-            \"popfq\\n\"\n-    \"exit:\" %}\n-  ins_encode %{\n-    __ ucomiss($src$$XMMRegister, $constantaddress($con));\n-    emit_cmpfp_fixup(_masm);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n@@ -10450,0 +10530,1 @@\n+\/\/ Really expensive, avoid\n@@ -10454,1 +10535,1 @@\n-  ins_cost(145);\n+  ins_cost(500);\n@@ -10479,18 +10560,0 @@\n-instruct cmpD_cc_mem(rFlagsRegU cr, regD src1, memory src2)\n-%{\n-  match(Set cr (CmpD src1 (LoadD src2)));\n-\n-  ins_cost(145);\n-  format %{ \"ucomisd $src1, $src2\\n\\t\"\n-            \"jnp,s   exit\\n\\t\"\n-            \"pushfq\\t# saw NaN, set CF\\n\\t\"\n-            \"andq    [rsp], #0xffffff2b\\n\\t\"\n-            \"popfq\\n\"\n-    \"exit:\" %}\n-  ins_encode %{\n-    __ ucomisd($src1$$XMMRegister, $src2$$Address);\n-    emit_cmpfp_fixup(_masm);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n@@ -10508,17 +10571,0 @@\n-instruct cmpD_cc_imm(rFlagsRegU cr, regD src, immD con) %{\n-  match(Set cr (CmpD src con));\n-\n-  ins_cost(145);\n-  format %{ \"ucomisd $src, [$constantaddress]\\t# load from constant table: double=$con\\n\\t\"\n-            \"jnp,s   exit\\n\\t\"\n-            \"pushfq\\t# saw NaN, set CF\\n\\t\"\n-            \"andq    [rsp], #0xffffff2b\\n\\t\"\n-            \"popfq\\n\"\n-    \"exit:\" %}\n-  ins_encode %{\n-    __ ucomisd($src$$XMMRegister, $constantaddress($con));\n-    emit_cmpfp_fixup(_masm);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":129,"deletions":83,"binary":false,"changes":212,"status":"modified"},{"patch":"@@ -0,0 +1,361 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+\n+\/*\n+ * @test\n+ * @bug 8285973\n+ * @summary Test that code generation for fp comparison works as intended\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.TestFPComparison\n+ *\/\n+public class TestFPComparison {\n+    static final double[] DOUBLES = new double[] {\n+            Double.NEGATIVE_INFINITY,\n+            -Double.MAX_VALUE,\n+            -1.0,\n+            -Double.MIN_VALUE,\n+            -0.0,\n+            0.0,\n+            Double.MIN_VALUE,\n+            1.0,\n+            Double.MAX_VALUE,\n+            Double.POSITIVE_INFINITY,\n+            Double.NaN,\n+    };\n+\n+    static final float[] FLOATS = new float[] {\n+            Float.NEGATIVE_INFINITY,\n+            -Float.MAX_VALUE,\n+            -1.0F,\n+            -Float.MIN_VALUE,\n+            -0.0F,\n+            0.0F,\n+            Float.MIN_VALUE,\n+            1.0F,\n+            Float.MAX_VALUE,\n+            Float.POSITIVE_INFINITY,\n+            Float.NaN,\n+    };\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @DontInline\n+    static int call() {\n+        return 1;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CMOVEI, \"1\"})\n+    public int cMoveEqualTwoDoubles(double x, double y) {\n+        return x == y ? 1 : 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CMOVEI, \"1\"})\n+    public int cMoveEqualTwoFloats(float x, float y) {\n+        return x == y ? 1 : 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CMOVEI, \"1\"})\n+    public int cMoveNotEqualTwoDoubles(double x, double y) {\n+        return x != y ? 1 : 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CMOVEI, \"1\"})\n+    public int cMoveNotEqualTwoFloats(float x, float y) {\n+        return x != y ? 1 : 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CMOVEI, \"1\"})\n+    public int cMoveLessThanTwoDoubles(double x, double y) {\n+        return x < y ? 1 : 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CMOVEI, \"1\"})\n+    public int cMoveLessThanTwoFloats(float x, float y) {\n+        return x < y ? 1 : 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CMOVEI, \"1\"})\n+    public int cMoveMoreThanTwoDoubles(double x, double y) {\n+        return x > y ? 1 : 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CMOVEI, \"1\"})\n+    public int cMoveMoreThanTwoFloats(float x, float y) {\n+        return x > y ? 1 : 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CMOVEI, \"1\"})\n+    public int cMoveLessEqualTwoDoubles(double x, double y) {\n+        return x <= y ? 1 : 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CMOVEI, \"1\"})\n+    public int cMoveLessEqualTwoFloats(float x, float y) {\n+        return x <= y ? 1 : 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CMOVEI, \"1\"})\n+    public int cMoveMoreEqualTwoDoubles(double x, double y) {\n+        return x >= y ? 1 : 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CMOVEI, \"1\"})\n+    public int cMoveMoreEqualTwoFloats(float x, float y) {\n+        return x >= y ? 1 : 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CMOVEI, \"1\"})\n+    public int cMoveEqualOneDouble(double x) {\n+        return x == x ? 1 : 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CMOVEI, \"1\"})\n+    public int cMoveEqualOneFloat(float x) {\n+        return x == x ? 1 : 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CMOVEI, \"1\"})\n+    public int cMoveNotEqualOneDouble(double x) {\n+        return x != x ? 1 : 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CMOVEI, \"1\"})\n+    public int cMoveNotEqualOneFloat(float x) {\n+        return x != x ? 1 : 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.IF, \"1\"})\n+    public int branchEqualTwoDoubles(double x, double y) {\n+        return x == y ? call() : 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.IF, \"1\"})\n+    public int branchEqualTwoFloats(float x, float y) {\n+        return x == y ? call() : 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.IF, \"1\"})\n+    public int branchNotEqualTwoDoubles(double x, double y) {\n+        return x != y ? call() : 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.IF, \"1\"})\n+    public int branchNotEqualTwoFloats(float x, float y) {\n+        return x != y ? call() : 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.IF, \"1\"})\n+    public int branchLessThanTwoDoubles(double x, double y) {\n+        return x < y ? call() : 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.IF, \"1\"})\n+    public int branchLessThanTwoFloats(float x, float y) {\n+        return x < y ? call() : 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.IF, \"1\"})\n+    public int branchMoreThanTwoDoubles(double x, double y) {\n+        return x > y ? call() : 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.IF, \"1\"})\n+    public int branchMoreThanTwoFloats(float x, float y) {\n+        return x > y ? call() : 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.IF, \"1\"})\n+    public int branchLessEqualTwoDoubles(double x, double y) {\n+        return x <= y ? call() : 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.IF, \"1\"})\n+    public int branchLessEqualTwoFloats(float x, float y) {\n+        return x <= y ? call() : 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.IF, \"1\"})\n+    public int branchMoreEqualTwoDoubles(double x, double y) {\n+        return x >= y ? call() : 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.IF, \"1\"})\n+    public int branchMoreEqualTwoFloats(float x, float y) {\n+        return x >= y ? call() : 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.IF, \"1\"})\n+    public int branchEqualOneDouble(double x) {\n+        return x == x ? call() : 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.IF, \"1\"})\n+    public int branchEqualOneFloat(float x) {\n+        return x == x ? call() : 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.IF, \"1\"})\n+    public int branchNotEqualOneDouble(double x) {\n+        return x != x ? call() : 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.IF, \"1\"})\n+    public int branchNotEqualOneFloat(float x) {\n+        return x != x ? call() : 0;\n+    }\n+\n+    @Run(test = {\"cMoveEqualTwoDoubles\", \"cMoveEqualTwoFloats\", \"cMoveNotEqualTwoDoubles\", \"cMoveNotEqualTwoFloats\",\n+            \"cMoveLessThanTwoDoubles\", \"cMoveLessThanTwoFloats\", \"cMoveMoreThanTwoDoubles\", \"cMoveMoreThanTwoFloats\",\n+            \"cMoveLessEqualTwoDoubles\", \"cMoveLessEqualTwoFloats\", \"cMoveMoreEqualTwoDoubles\", \"cMoveMoreEqualTwoFloats\",\n+            \"cMoveEqualOneDouble\", \"cMoveEqualOneFloat\", \"cMoveNotEqualOneDouble\", \"cMoveNotEqualOneFloat\",\n+            \"branchEqualTwoDoubles\", \"branchEqualTwoFloats\", \"branchNotEqualTwoDoubles\", \"branchNotEqualTwoFloats\",\n+            \"branchLessThanTwoDoubles\", \"branchLessThanTwoFloats\", \"branchMoreThanTwoDoubles\", \"branchMoreThanTwoFloats\",\n+            \"branchLessEqualTwoDoubles\", \"branchLessEqualTwoFloats\", \"branchMoreEqualTwoDoubles\", \"branchMoreEqualTwoFloats\",\n+            \"branchEqualOneDouble\", \"branchEqualOneFloat\", \"branchNotEqualOneDouble\", \"branchNotEqualOneFloat\"})\n+    public void runTests() {\n+        for (int i = 0; i < DOUBLES.length; i++) {\n+            for (int j = 0; j < DOUBLES.length; j++) {\n+                int len = DOUBLES.length;\n+                double x = DOUBLES[i];\n+                double y = DOUBLES[j];\n+                Asserts.assertEquals(cMoveEqualTwoDoubles(x, x),\n+                        (x == x) ? 1 : 0);\n+                Asserts.assertEquals(cMoveNotEqualTwoDoubles(x, x),\n+                        (x != x) ? 1 : 0);\n+                Asserts.assertEquals(cMoveEqualTwoDoubles(x, y),\n+                        (x == y) ? 1 : 0);\n+                Asserts.assertEquals(cMoveNotEqualTwoDoubles(x, y),\n+                        (x != y) ? 1 : 0);\n+                Asserts.assertEquals(cMoveLessThanTwoDoubles(x, y),\n+                        (x < y) ? 1 : 0);\n+                Asserts.assertEquals(cMoveLessEqualTwoDoubles(x, y),\n+                        (x <= y) ? 1 : 0);\n+                Asserts.assertEquals(cMoveMoreThanTwoDoubles(x, y),\n+                        (x > y) ? 1 : 0);\n+                Asserts.assertEquals(cMoveMoreEqualTwoDoubles(x, y),\n+                        (x >= y) ? 1 : 0);\n+                Asserts.assertEquals(branchEqualTwoDoubles(x, y),\n+                        (x == y) ? 1 : 0);\n+                Asserts.assertEquals(branchNotEqualTwoDoubles(x, y),\n+                        (x != y) ? 1 : 0);\n+                Asserts.assertEquals(branchLessThanTwoDoubles(x, y),\n+                        (x < y) ? 1 : 0);\n+                Asserts.assertEquals(branchLessEqualTwoDoubles(x, y),\n+                        (x <= y) ? 1 : 0);\n+                Asserts.assertEquals(branchMoreThanTwoDoubles(x, y),\n+                        (x > y) ? 1 : 0);\n+                Asserts.assertEquals(branchMoreEqualTwoDoubles(x, y),\n+                        (x >= y) ? 1 : 0);\n+            }\n+        }\n+        for (int i = 0; i < FLOATS.length; i++) {\n+            for (int j = 0; j < FLOATS.length; j++) {\n+                int len = FLOATS.length;\n+                float x = FLOATS[i];\n+                float y = FLOATS[j];\n+                Asserts.assertEquals(cMoveEqualTwoFloats(x, x),\n+                        (x == x) ? 1 : 0);\n+                Asserts.assertEquals(cMoveNotEqualTwoFloats(x, x),\n+                        (x != x) ? 1 : 0);\n+                Asserts.assertEquals(cMoveEqualTwoFloats(x, y),\n+                        (x == y) ? 1 : 0);\n+                Asserts.assertEquals(cMoveNotEqualTwoFloats(x, y),\n+                        (x != y) ? 1 : 0);\n+                Asserts.assertEquals(cMoveLessThanTwoFloats(x, y),\n+                        (x < y) ? 1 : 0);\n+                Asserts.assertEquals(cMoveLessEqualTwoFloats(x, y),\n+                        (x <= y) ? 1 : 0);\n+                Asserts.assertEquals(cMoveMoreThanTwoFloats(x, y),\n+                        (x > y) ? 1 : 0);\n+                Asserts.assertEquals(cMoveMoreEqualTwoFloats(x, y),\n+                        (x >= y) ? 1 : 0);\n+                Asserts.assertEquals(branchEqualTwoFloats(x, y),\n+                        (x == y) ? 1 : 0);\n+                Asserts.assertEquals(branchNotEqualTwoFloats(x, y),\n+                        (x != y) ? 1 : 0);\n+                Asserts.assertEquals(branchLessThanTwoFloats(x, y),\n+                        (x < y) ? 1 : 0);\n+                Asserts.assertEquals(branchLessEqualTwoFloats(x, y),\n+                        (x <= y) ? 1 : 0);\n+                Asserts.assertEquals(branchMoreThanTwoFloats(x, y),\n+                        (x > y) ? 1 : 0);\n+                Asserts.assertEquals(branchMoreEqualTwoFloats(x, y),\n+                        (x >= y) ? 1 : 0);\n+            }\n+        }\n+        for (int i = 0; i < DOUBLES.length; i++) {\n+            Asserts.assertEquals(cMoveEqualOneDouble(DOUBLES[DOUBLES.length - 1]), 0);\n+            Asserts.assertEquals(cMoveNotEqualOneDouble(DOUBLES[DOUBLES.length - 1]), 1);\n+            Asserts.assertEquals(cMoveEqualOneDouble(DOUBLES[i]), (i != DOUBLES.length - 1) ? 1 : 0);\n+            Asserts.assertEquals(cMoveNotEqualOneDouble(DOUBLES[i]), (i == DOUBLES.length - 1) ? 1 : 0);\n+            Asserts.assertEquals(branchEqualOneDouble(DOUBLES[i]), (i != DOUBLES.length - 1) ? 1 : 0);\n+            Asserts.assertEquals(branchNotEqualOneDouble(DOUBLES[i]), (i == DOUBLES.length - 1) ? 1 : 0);\n+        }\n+        for (int i = 0; i < FLOATS.length; i++) {\n+            Asserts.assertEquals(cMoveEqualOneFloat(FLOATS[FLOATS.length - 1]), 0);\n+            Asserts.assertEquals(cMoveNotEqualOneFloat(FLOATS[FLOATS.length - 1]), 1);\n+            Asserts.assertEquals(cMoveEqualOneFloat(FLOATS[i]), (i != FLOATS.length - 1) ? 1 : 0);\n+            Asserts.assertEquals(cMoveNotEqualOneFloat(FLOATS[i]), (i == FLOATS.length - 1) ? 1 : 0);\n+            Asserts.assertEquals(branchEqualOneFloat(FLOATS[i]), (i != FLOATS.length - 1) ? 1 : 0);\n+            Asserts.assertEquals(branchNotEqualOneFloat(FLOATS[i]), (i == FLOATS.length - 1) ? 1 : 0);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestFPComparison.java","additions":361,"deletions":0,"binary":false,"changes":361,"status":"added"},{"patch":"@@ -144,0 +144,1 @@\n+    public static final String CMOVEI = START + \"CMoveI\" + MID + END;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,132 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang;\n+\n+import org.openjdk.jmh.annotations.*;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.random.RandomGenerator;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Fork(1)\n+public class FPComparison {\n+    static final int INVOCATIONS = 1024;\n+\n+    float[] f1;\n+    double[] d1;\n+    float[] f2;\n+    double[] d2;\n+    int[] res;\n+\n+    @Setup\n+    public void setup() {\n+        var random = RandomGenerator.getDefault();\n+        f1 = new float[INVOCATIONS];\n+        d1 = new double[INVOCATIONS];\n+        f2 = new float[INVOCATIONS];\n+        d2 = new double[INVOCATIONS];\n+        res = new int[INVOCATIONS];\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            int type = random.nextInt(5);\n+            if (type == 1) {\n+                f1[i] = random.nextFloat();\n+                d1[i] = random.nextDouble();\n+                f2[i] = random.nextFloat();\n+                d2[i] = random.nextDouble();\n+            } else if (type == 2) {\n+                f1[i] = Float.POSITIVE_INFINITY;\n+                d1[i] = Double.POSITIVE_INFINITY;\n+                f2[i] = Float.POSITIVE_INFINITY;\n+                d2[i] = Double.POSITIVE_INFINITY;\n+            } else if (type == 3) {\n+                f1[i] = Float.NEGATIVE_INFINITY;\n+                d1[i] = Double.NEGATIVE_INFINITY;\n+                f2[i] = Float.NEGATIVE_INFINITY;\n+                d2[i] = Double.NEGATIVE_INFINITY;\n+            } else if (type >= 4) {\n+                f1[i] = Float.NaN;\n+                d1[i] = Double.NaN;\n+                f2[i] = Float.NaN;\n+                d2[i] = Double.NaN;\n+            }\n+        }\n+    }\n+\n+    @Benchmark\n+    public void isNanFloat() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            res[i] = Float.isNaN(f1[i]) ? 1 : 0;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void isNanDouble() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            res[i] = Double.isNaN(d1[i]) ? 1 : 0;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void isInfiniteFloat() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            res[i] = Float.isInfinite(f1[i]) ? 1 : 0;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void isInfiniteDouble() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            res[i] = Double.isInfinite(d1[i]) ? 1 : 0;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void isFiniteFloat() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            res[i] = Float.isFinite(f1[i]) ? 1 : 0;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void isFiniteDouble() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            res[i] = Double.isFinite(d1[i]) ? 1 : 0;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void equalFloat() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            res[i] = (f1[i] == f2[i]) ? 1 : 0;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void equalDouble() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            res[i] = (d1[i] == d2[i]) ? 1 : 0;\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/FPComparison.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"added"}]}