{"files":[{"patch":"@@ -1034,4 +1034,8 @@\n-      assert(strncmp(name, \"_multianewarray\", 15) == 0, \"TODO: add failed case check\");\n-      \/\/ Returns a newly allocated non-escaped object.\n-      add_java_object(call, PointsToNode::NoEscape);\n-      set_not_scalar_replaceable(ptnode_adr(call_idx) NOT_PRODUCT(COMMA \"is result of multinewarray\"));\n+      if (strncmp(name, \"_notify_allocation\", 18) == 0) { \/\/ Object escapes to JVMTI\n+        add_java_object(call, PointsToNode::GlobalEscape);\n+      } else {\n+        assert(strncmp(name, \"_multianewarray\", 15) == 0, \"TODO: add failed case check\");\n+        \/\/ Returns a newly allocated non-escaped object.\n+        add_java_object(call, PointsToNode::NoEscape);\n+        set_not_scalar_replaceable(ptnode_adr(call_idx) NOT_PRODUCT(COMMA \"is result of multinewarray\"));\n+      }\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+#include \"prims\/jvmtiExport.hpp\"\n@@ -2831,1 +2832,0 @@\n-\n@@ -2833,0 +2833,24 @@\n+#if INCLUDE_JVMTI\n+  \/\/ Check if JvmtiExport::_should_post_allocation_notifications is enabled and post notifications\n+  IdealKit ideal(this);\n+  IdealVariable result(ideal); ideal.declarations_done();\n+  Node* ONE = ideal.ConI(1);\n+  Node* addr = makecon(TypeRawPtr::make((address) &JvmtiExport::_should_post_allocation_notifications));\n+  Node* should_post_vm_object_alloc = ideal.load(ideal.ctrl(), addr, TypeInt::BOOL, T_BOOLEAN, Compile::AliasIdxRaw);\n+\n+  ideal.sync_kit(this);\n+  ideal.if_then(should_post_vm_object_alloc, BoolTest::eq, ONE); {\n+    const TypeFunc *tf = OptoRuntime::notify_allocation_Type();\n+    address funcAddr = OptoRuntime::notify_allocation();\n+    sync_kit(ideal);\n+    Node* call = make_runtime_call(RC_NO_LEAF, tf, funcAddr, \"_notify_allocation\", TypePtr::BOTTOM, obj);\n+    ideal.sync_kit(this);\n+    ideal.set(result,_gvn.transform(new ProjNode(call, TypeFunc::Parms+0)));\n+  } ideal.else_(); {\n+    ideal.set(result,obj);\n+  } ideal.end_if();\n+  final_sync(ideal);\n+\n+  set_result(ideal.value(result));\n+  return true;\n+#else\n@@ -2835,0 +2859,2 @@\n+#endif \/\/INCLUDE_JVMTI\n+\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":27,"deletions":1,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -113,0 +113,1 @@\n+address OptoRuntime::_notify_allocation                           = nullptr;\n@@ -156,0 +157,1 @@\n+  gen(env, _notify_allocation              , notify_allocation_Type       , SharedRuntime::notify_allocation,    0 , true, false);\n@@ -477,0 +479,16 @@\n+#if INCLUDE_JVMTI\n+const TypeFunc *OptoRuntime::notify_allocation_Type() {\n+  \/\/ create input type (domain)\n+  const Type **fields = TypeTuple::fields(1);\n+  fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL;\n+  const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+1, fields);\n+\n+   \/\/ create result type (range)\n+   fields = TypeTuple::fields(1);\n+   fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL; \/\/ Returned oop\n+\n+   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+1, fields);\n+\n+   return TypeFunc::make(domain, range);\n+}\n+#endif\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -139,0 +139,1 @@\n+  static address _notify_allocation;\n@@ -216,0 +217,1 @@\n+  static address notify_allocation()                     { return _notify_allocation; }\n@@ -306,0 +308,1 @@\n+  static const TypeFunc* notify_allocation_Type();\n","filename":"src\/hotspot\/share\/opto\/runtime.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -727,0 +727,1 @@\n+    JvmtiExport::_should_post_allocation_notifications = JvmtiExport::should_post_vm_object_alloc();\n","filename":"src\/hotspot\/share\/prims\/jvmtiEventController.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1049,0 +1049,4 @@\n+\/\/ This flag is read by C2 during VM internal objects allocation\n+bool JvmtiExport::_should_post_allocation_notifications = true;\n+\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -399,0 +399,3 @@\n+  \/\/ Used by C2 to post vm_object_alloc\n+  static bool _should_post_allocation_notifications;\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -631,0 +631,8 @@\n+JRT_ENTRY(void, SharedRuntime::notify_allocation(oopDesc* o, JavaThread* current))\n+  Handle h = Handle(current, o);\n+  if (JvmtiExport::should_post_vm_object_alloc()) {\n+    JvmtiExport::post_vm_object_alloc(current, o);\n+  }\n+  current->set_vm_result(h());\n+JRT_END\n+\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -268,0 +268,1 @@\n+  static void notify_allocation(oopDesc* o, JavaThread* current);\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-vmTestbase\/nsk\/jvmti\/AttachOnDemand\/attach022\/TestDescription.java 8277573 generic-all\n@@ -41,2 +40,0 @@\n-serviceability\/jvmti\/VMObjectAlloc\/VMObjectAllocTest.java 8288430 generic-all\n-\n","filename":"test\/hotspot\/jtreg\/ProblemList-Xcomp.txt","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -149,1 +149,0 @@\n-vmTestbase\/nsk\/jvmti\/AttachOnDemand\/attach002a\/TestDescription.java 8277573 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}