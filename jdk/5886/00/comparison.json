{"files":[{"patch":"@@ -30,0 +30,1 @@\n+#include \"logging\/log.hpp\"\n","filename":"src\/hotspot\/share\/gc\/epsilon\/epsilonArguments.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"logging\/log.hpp\"\n","filename":"src\/hotspot\/share\/gc\/epsilon\/epsilonHeap.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,109 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-\n-#include \"gc\/g1\/g1BatchedGangTask.hpp\"\n-#include \"gc\/g1\/g1CollectedHeap.inline.hpp\"\n-#include \"gc\/g1\/g1GCParPhaseTimesTracker.hpp\"\n-#include \"runtime\/atomic.hpp\"\n-#include \"utilities\/growableArray.hpp\"\n-\n-void G1AbstractSubTask::record_work_item(uint worker_id, uint index, size_t count) {\n-  G1CollectedHeap* g1h = G1CollectedHeap::heap();\n-  g1h->phase_times()->record_thread_work_item(_tag, worker_id, count, index);\n-}\n-\n-const char* G1AbstractSubTask::name() const {\n-  G1CollectedHeap* g1h = G1CollectedHeap::heap();\n-  return g1h->phase_times()->phase_name(_tag);\n-}\n-\n-bool G1BatchedGangTask::try_claim_serial_task(int& task) {\n-  task = Atomic::fetch_and_add(&_num_serial_tasks_done, 1);\n-  return task < _serial_tasks.length();\n-}\n-\n-void G1BatchedGangTask::add_serial_task(G1AbstractSubTask* task) {\n-  assert(task != nullptr, \"must be\");\n-  _serial_tasks.push(task);\n-}\n-\n-void G1BatchedGangTask::add_parallel_task(G1AbstractSubTask* task) {\n-  assert(task != nullptr, \"must be\");\n-  _parallel_tasks.push(task);\n-}\n-\n-G1BatchedGangTask::G1BatchedGangTask(const char* name, G1GCPhaseTimes* phase_times) :\n-  AbstractGangTask(name),\n-  _num_serial_tasks_done(0),\n-  _phase_times(phase_times),\n-  _serial_tasks(),\n-  _parallel_tasks() {\n-}\n-\n-uint G1BatchedGangTask::num_workers_estimate() const {\n-  double sum = 0.0;\n-  for (G1AbstractSubTask* task : _serial_tasks) {\n-    sum += task->worker_cost();\n-  }\n-  for (G1AbstractSubTask* task : _parallel_tasks) {\n-    sum += task->worker_cost();\n-  }\n-  return ceil(sum);\n-}\n-\n-void G1BatchedGangTask::set_max_workers(uint max_workers) {\n-  for (G1AbstractSubTask* task : _serial_tasks) {\n-    task->set_max_workers(max_workers);\n-  }\n-  for (G1AbstractSubTask* task : _parallel_tasks) {\n-    task->set_max_workers(max_workers);\n-  }\n-}\n-\n-void G1BatchedGangTask::work(uint worker_id) {\n-  int t = 0;\n-  while (try_claim_serial_task(t)) {\n-    G1AbstractSubTask* task = _serial_tasks.at(t);\n-    G1GCParPhaseTimesTracker x(_phase_times, task->tag(), worker_id);\n-    task->do_work(worker_id);\n-  }\n-  for (G1AbstractSubTask* task : _parallel_tasks) {\n-    G1GCParPhaseTimesTracker x(_phase_times, task->tag(), worker_id);\n-    task->do_work(worker_id);\n-  }\n-}\n-\n-G1BatchedGangTask::~G1BatchedGangTask() {\n-  assert(Atomic::load(&_num_serial_tasks_done) >= _serial_tasks.length(),\n-         \"Only %d tasks of %d claimed\", Atomic::load(&_num_serial_tasks_done), _serial_tasks.length());\n-\n-  for (G1AbstractSubTask* task : _parallel_tasks) {\n-    delete task;\n-  }\n-  for (G1AbstractSubTask* task : _serial_tasks) {\n-    delete task;\n-  }\n-}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BatchedGangTask.cpp","additions":0,"deletions":109,"binary":false,"changes":109,"status":"deleted"},{"patch":"@@ -1,152 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_G1_G1BATCHEDGANGTASK_HPP\n-#define SHARE_GC_G1_G1BATCHEDGANGTASK_HPP\n-\n-#include \"gc\/g1\/g1GCPhaseTimes.hpp\"\n-#include \"gc\/shared\/workgroup.hpp\"\n-#include \"memory\/allocation.hpp\"\n-\n-template <typename E, MEMFLAGS F>\n-class GrowableArrayCHeap;\n-\n-\/\/ G1AbstractSubTask represents a task to be performed either within a\n-\/\/ G1BatchedGangTask running on a single worker (\"serially\") or multiple workers\n-\/\/ (\"in parallel\"). A G1AbstractSubTask is always associated with a phase tag\n-\/\/ that is used to automatically store timing information.\n-\/\/\n-\/\/ A \"serial\" task is some piece of work that either can not be parallelized\n-\/\/ easily, or is typically so short that parallelization is not worth the effort.\n-\/\/ Current examples would be summarizing per worker thread information gathered\n-\/\/ during garbage collection (e.g. Merge PSS work).\n-\/\/\n-\/\/ A \"parallel\" task could be some large amount of work that typically naturally\n-\/\/ splits across the heap in some way. Current examples would be clearing the\n-\/\/ card table.\n-\/\/\n-\/\/ See G1BatchedGangTask for information on execution.\n-class G1AbstractSubTask : public CHeapObj<mtGC> {\n-  G1GCPhaseTimes::GCParPhases _tag;\n-\n-  NONCOPYABLE(G1AbstractSubTask);\n-\n-protected:\n-  \/\/ Record work item for this tag in G1GCPhaseTimes.\n-  void record_work_item(uint worker_id, uint index, size_t count);\n-\n-public:\n-  \/\/ Worker cost for \"almost no work\" to be done.\n-  static constexpr double AlmostNoWork = 0.01;\n-\n-  G1AbstractSubTask(G1GCPhaseTimes::GCParPhases tag) : _tag(tag) { }\n-  virtual ~G1AbstractSubTask() { }\n-\n-  \/\/ How many workers (threads) would this task be able to keep busy for at least\n-  \/\/ as long as to amortize worker startup costs.\n-  \/\/ Called by G1BatchedGangTask to determine total number of workers.\n-  virtual double worker_cost() const = 0;\n-\n-  \/\/ Called by G1BatchedGangTask to provide information about the the maximum\n-  \/\/ number of workers for all subtasks after it has been determined.\n-  virtual void set_max_workers(uint max_workers) { }\n-\n-  \/\/ Perform the actual work. Gets the worker id it is run on passed in.\n-  virtual void do_work(uint worker_id) = 0;\n-\n-  \/\/ Tag for this G1AbstractSubTask.\n-  G1GCPhaseTimes::GCParPhases tag() const { return _tag; }\n-  \/\/ Human readable name derived from the tag.\n-  const char* name() const;\n-};\n-\n-\/\/ G1BatchedGangTask runs a set of G1AbstractSubTask using a work gang.\n-\/\/\n-\/\/ Subclasses of this class add their G1AbstractSubTasks into either the list\n-\/\/ of \"serial\" or the list of \"parallel\" tasks. They are supposed to be the owners\n-\/\/ of the G1AbstractSubTasks.\n-\/\/\n-\/\/ Eg. the constructor contains code like the following:\n-\/\/\n-\/\/   add_serial_task(new SomeSubTask());\n-\/\/   [...]\n-\/\/   add_parallel_task(new SomeOtherSubTask());\n-\/\/   [...]\n-\/\/\n-\/\/ During execution in the work gang, this class will make sure that the \"serial\"\n-\/\/ tasks are executed by a single worker exactly once, but different \"serial\"\n-\/\/ tasks may be executed in parallel using different workers. \"Parallel\" tasks'\n-\/\/ do_work() method may be called by different workers passing a different\n-\/\/ worker_id at the same time, but at most once per given worker_id.\n-\/\/\n-\/\/ There is also no guarantee that G1AbstractSubTasks::do_work() of different tasks\n-\/\/ are actually run in parallel.\n-\/\/\n-\/\/ The current implementation assumes that constructors and destructors of the\n-\/\/ G1AbstractSubTasks can executed in the constructor\/destructor of an instance\n-\/\/ of this class.\n-\/\/\n-\/\/ The constructor, destructor and the do_work() methods from different\n-\/\/ G1AbstractSubTasks may run in any order so they must not have any\n-\/\/ dependencies at all.\n-\/\/\n-\/\/ For a given G1AbstractSubTask T call order of its methods are as follows:\n-\/\/\n-\/\/ 1) T()\n-\/\/ 2) T::thread_usage()\n-\/\/ 3) T::set_max_workers()\n-\/\/ 4) T::do_work()  \/\/ potentially in parallel with any other registered G1AbstractSubTask\n-\/\/ 5) ~T()\n-\/\/\n-class G1BatchedGangTask : public AbstractGangTask {\n-  volatile int _num_serial_tasks_done;\n-  G1GCPhaseTimes* _phase_times;\n-\n-  bool try_claim_serial_task(int& task);\n-\n-  NONCOPYABLE(G1BatchedGangTask);\n-\n-  GrowableArrayCHeap<G1AbstractSubTask*, mtGC> _serial_tasks;\n-  GrowableArrayCHeap<G1AbstractSubTask*, mtGC> _parallel_tasks;\n-\n-protected:\n-  void add_serial_task(G1AbstractSubTask* task);\n-  void add_parallel_task(G1AbstractSubTask* task);\n-\n-  G1BatchedGangTask(const char* name, G1GCPhaseTimes* phase_times);\n-\n-public:\n-  void work(uint worker_id) override;\n-\n-  \/\/ How many workers can this gang task keep busy and should be started for\n-  \/\/ \"optimal\" performance.\n-  uint num_workers_estimate() const;\n-  \/\/ Informs the G1AbstractSubTasks about that we will start execution with the\n-  \/\/ given number of workers.\n-  void set_max_workers(uint max_workers);\n-\n-  ~G1BatchedGangTask();\n-};\n-\n-#endif \/\/ SHARE_GC_G1_G1BATCHEDGANGTASK_HPP\n\\ No newline at end of file\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BatchedGangTask.hpp","additions":0,"deletions":152,"binary":false,"changes":152,"status":"deleted"},{"patch":"@@ -0,0 +1,109 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"gc\/g1\/g1BatchedTask.hpp\"\n+#include \"gc\/g1\/g1CollectedHeap.inline.hpp\"\n+#include \"gc\/g1\/g1GCParPhaseTimesTracker.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+\n+void G1AbstractSubTask::record_work_item(uint worker_id, uint index, size_t count) {\n+  G1CollectedHeap* g1h = G1CollectedHeap::heap();\n+  g1h->phase_times()->record_thread_work_item(_tag, worker_id, count, index);\n+}\n+\n+const char* G1AbstractSubTask::name() const {\n+  G1CollectedHeap* g1h = G1CollectedHeap::heap();\n+  return g1h->phase_times()->phase_name(_tag);\n+}\n+\n+bool G1BatchedTask::try_claim_serial_task(int& task) {\n+  task = Atomic::fetch_and_add(&_num_serial_tasks_done, 1);\n+  return task < _serial_tasks.length();\n+}\n+\n+void G1BatchedTask::add_serial_task(G1AbstractSubTask* task) {\n+  assert(task != nullptr, \"must be\");\n+  _serial_tasks.push(task);\n+}\n+\n+void G1BatchedTask::add_parallel_task(G1AbstractSubTask* task) {\n+  assert(task != nullptr, \"must be\");\n+  _parallel_tasks.push(task);\n+}\n+\n+G1BatchedTask::G1BatchedTask(const char* name, G1GCPhaseTimes* phase_times) :\n+  WorkerTask(name),\n+  _num_serial_tasks_done(0),\n+  _phase_times(phase_times),\n+  _serial_tasks(),\n+  _parallel_tasks() {\n+}\n+\n+uint G1BatchedTask::num_workers_estimate() const {\n+  double sum = 0.0;\n+  for (G1AbstractSubTask* task : _serial_tasks) {\n+    sum += task->worker_cost();\n+  }\n+  for (G1AbstractSubTask* task : _parallel_tasks) {\n+    sum += task->worker_cost();\n+  }\n+  return ceil(sum);\n+}\n+\n+void G1BatchedTask::set_max_workers(uint max_workers) {\n+  for (G1AbstractSubTask* task : _serial_tasks) {\n+    task->set_max_workers(max_workers);\n+  }\n+  for (G1AbstractSubTask* task : _parallel_tasks) {\n+    task->set_max_workers(max_workers);\n+  }\n+}\n+\n+void G1BatchedTask::work(uint worker_id) {\n+  int t = 0;\n+  while (try_claim_serial_task(t)) {\n+    G1AbstractSubTask* task = _serial_tasks.at(t);\n+    G1GCParPhaseTimesTracker x(_phase_times, task->tag(), worker_id);\n+    task->do_work(worker_id);\n+  }\n+  for (G1AbstractSubTask* task : _parallel_tasks) {\n+    G1GCParPhaseTimesTracker x(_phase_times, task->tag(), worker_id);\n+    task->do_work(worker_id);\n+  }\n+}\n+\n+G1BatchedTask::~G1BatchedTask() {\n+  assert(Atomic::load(&_num_serial_tasks_done) >= _serial_tasks.length(),\n+         \"Only %d tasks of %d claimed\", Atomic::load(&_num_serial_tasks_done), _serial_tasks.length());\n+\n+  for (G1AbstractSubTask* task : _parallel_tasks) {\n+    delete task;\n+  }\n+  for (G1AbstractSubTask* task : _serial_tasks) {\n+    delete task;\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BatchedTask.cpp","additions":109,"deletions":0,"binary":false,"changes":109,"status":"added"},{"patch":"@@ -0,0 +1,152 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1BATCHEDTASK_HPP\n+#define SHARE_GC_G1_G1BATCHEDTASK_HPP\n+\n+#include \"gc\/g1\/g1GCPhaseTimes.hpp\"\n+#include \"gc\/shared\/workerThread.hpp\"\n+#include \"memory\/allocation.hpp\"\n+\n+template <typename E, MEMFLAGS F>\n+class GrowableArrayCHeap;\n+\n+\/\/ G1AbstractSubTask represents a task to be performed either within a\n+\/\/ G1BatchedTask running on a single worker (\"serially\") or multiple workers\n+\/\/ (\"in parallel\"). A G1AbstractSubTask is always associated with a phase tag\n+\/\/ that is used to automatically store timing information.\n+\/\/\n+\/\/ A \"serial\" task is some piece of work that either can not be parallelized\n+\/\/ easily, or is typically so short that parallelization is not worth the effort.\n+\/\/ Current examples would be summarizing per worker thread information gathered\n+\/\/ during garbage collection (e.g. Merge PSS work).\n+\/\/\n+\/\/ A \"parallel\" task could be some large amount of work that typically naturally\n+\/\/ splits across the heap in some way. Current examples would be clearing the\n+\/\/ card table.\n+\/\/\n+\/\/ See G1BatchedTask for information on execution.\n+class G1AbstractSubTask : public CHeapObj<mtGC> {\n+  G1GCPhaseTimes::GCParPhases _tag;\n+\n+  NONCOPYABLE(G1AbstractSubTask);\n+\n+protected:\n+  \/\/ Record work item for this tag in G1GCPhaseTimes.\n+  void record_work_item(uint worker_id, uint index, size_t count);\n+\n+public:\n+  \/\/ Worker cost for \"almost no work\" to be done.\n+  static constexpr double AlmostNoWork = 0.01;\n+\n+  G1AbstractSubTask(G1GCPhaseTimes::GCParPhases tag) : _tag(tag) { }\n+  virtual ~G1AbstractSubTask() { }\n+\n+  \/\/ How many workers (threads) would this task be able to keep busy for at least\n+  \/\/ as long as to amortize worker startup costs.\n+  \/\/ Called by G1BatchedTask to determine total number of workers.\n+  virtual double worker_cost() const = 0;\n+\n+  \/\/ Called by G1BatchedTask to provide information about the the maximum\n+  \/\/ number of workers for all subtasks after it has been determined.\n+  virtual void set_max_workers(uint max_workers) { }\n+\n+  \/\/ Perform the actual work. Gets the worker id it is run on passed in.\n+  virtual void do_work(uint worker_id) = 0;\n+\n+  \/\/ Tag for this G1AbstractSubTask.\n+  G1GCPhaseTimes::GCParPhases tag() const { return _tag; }\n+  \/\/ Human readable name derived from the tag.\n+  const char* name() const;\n+};\n+\n+\/\/ G1BatchedTask runs a set of G1AbstractSubTask using workers.\n+\/\/\n+\/\/ Subclasses of this class add their G1AbstractSubTasks into either the list\n+\/\/ of \"serial\" or the list of \"parallel\" tasks. They are supposed to be the owners\n+\/\/ of the G1AbstractSubTasks.\n+\/\/\n+\/\/ Eg. the constructor contains code like the following:\n+\/\/\n+\/\/   add_serial_task(new SomeSubTask());\n+\/\/   [...]\n+\/\/   add_parallel_task(new SomeOtherSubTask());\n+\/\/   [...]\n+\/\/\n+\/\/ During execution in workers, this class will make sure that the \"serial\"\n+\/\/ tasks are executed by a single worker exactly once, but different \"serial\"\n+\/\/ tasks may be executed in parallel using different workers. \"Parallel\" tasks'\n+\/\/ do_work() method may be called by different workers passing a different\n+\/\/ worker_id at the same time, but at most once per given worker_id.\n+\/\/\n+\/\/ There is also no guarantee that G1AbstractSubTasks::do_work() of different tasks\n+\/\/ are actually run in parallel.\n+\/\/\n+\/\/ The current implementation assumes that constructors and destructors of the\n+\/\/ G1AbstractSubTasks can executed in the constructor\/destructor of an instance\n+\/\/ of this class.\n+\/\/\n+\/\/ The constructor, destructor and the do_work() methods from different\n+\/\/ G1AbstractSubTasks may run in any order so they must not have any\n+\/\/ dependencies at all.\n+\/\/\n+\/\/ For a given G1AbstractSubTask T call order of its methods are as follows:\n+\/\/\n+\/\/ 1) T()\n+\/\/ 2) T::thread_usage()\n+\/\/ 3) T::set_max_workers()\n+\/\/ 4) T::do_work()  \/\/ potentially in parallel with any other registered G1AbstractSubTask\n+\/\/ 5) ~T()\n+\/\/\n+class G1BatchedTask : public WorkerTask {\n+  volatile int _num_serial_tasks_done;\n+  G1GCPhaseTimes* _phase_times;\n+\n+  bool try_claim_serial_task(int& task);\n+\n+  NONCOPYABLE(G1BatchedTask);\n+\n+  GrowableArrayCHeap<G1AbstractSubTask*, mtGC> _serial_tasks;\n+  GrowableArrayCHeap<G1AbstractSubTask*, mtGC> _parallel_tasks;\n+\n+protected:\n+  void add_serial_task(G1AbstractSubTask* task);\n+  void add_parallel_task(G1AbstractSubTask* task);\n+\n+  G1BatchedTask(const char* name, G1GCPhaseTimes* phase_times);\n+\n+public:\n+  void work(uint worker_id) override;\n+\n+  \/\/ How many workers can this task keep busy and should be started for\n+  \/\/ \"optimal\" performance.\n+  uint num_workers_estimate() const;\n+  \/\/ Informs the G1AbstractSubTasks about that we will start execution with the\n+  \/\/ given number of workers.\n+  void set_max_workers(uint max_workers);\n+\n+  ~G1BatchedTask();\n+};\n+\n+#endif \/\/ SHARE_GC_G1_G1BATCHEDTASK_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BatchedTask.hpp","additions":152,"deletions":0,"binary":false,"changes":152,"status":"added"},{"patch":"@@ -35,1 +35,1 @@\n-#include \"gc\/g1\/g1BatchedGangTask.hpp\"\n+#include \"gc\/g1\/g1BatchedTask.hpp\"\n@@ -141,1 +141,1 @@\n-void G1CollectedHeap::run_batch_task(G1BatchedGangTask* cl) {\n+void G1CollectedHeap::run_batch_task(G1BatchedTask* cl) {\n@@ -1277,1 +1277,1 @@\n-bool G1CollectedHeap::expand(size_t expand_bytes, WorkGang* pretouch_workers, double* expand_time_ms) {\n+bool G1CollectedHeap::expand(size_t expand_bytes, WorkerThreads* pretouch_workers, double* expand_time_ms) {\n@@ -1686,1 +1686,1 @@\n-  _workers = new WorkGang(\"GC Thread\", ParallelGCThreads);\n+  _workers = new WorkerThreads(\"GC Thread\", ParallelGCThreads);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-class G1BatchedGangTask;\n+class G1BatchedTask;\n@@ -86,1 +86,1 @@\n-class WorkGang;\n+class WorkerThreads;\n@@ -148,1 +148,1 @@\n-  WorkGang* _workers;\n+  WorkerThreads* _workers;\n@@ -541,1 +541,1 @@\n-  WorkGang* workers() const { return _workers; }\n+  WorkerThreads* workers() const { return _workers; }\n@@ -543,2 +543,2 @@\n-  \/\/ Run the given batch task using the work gang.\n-  void run_batch_task(G1BatchedGangTask* cl);\n+  \/\/ Run the given batch task using the workers.\n+  void run_batch_task(G1BatchedTask* cl);\n@@ -575,1 +575,1 @@\n-  bool expand(size_t expand_bytes, WorkGang* pretouch_workers = NULL, double* expand_time_ms = NULL);\n+  bool expand(size_t expand_bytes, WorkerThreads* pretouch_workers = NULL, double* expand_time_ms = NULL);\n@@ -1319,1 +1319,1 @@\n-  virtual WorkGang* safepoint_workers() { return _workers; }\n+  virtual WorkerThreads* safepoint_workers() { return _workers; }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"gc\/shared\/workgroup.hpp\"\n+#include \"gc\/shared\/workerThread.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetCandidates.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-class G1BuildCandidateRegionsTask : public AbstractGangTask {\n+class G1BuildCandidateRegionsTask : public WorkerTask {\n@@ -226,1 +226,1 @@\n-    AbstractGangTask(\"G1 Build Candidate Regions\"),\n+    WorkerTask(\"G1 Build Candidate Regions\"),\n@@ -314,1 +314,1 @@\n-G1CollectionSetCandidates* G1CollectionSetChooser::build(WorkGang* workers, uint max_num_regions) {\n+G1CollectionSetCandidates* G1CollectionSetChooser::build(WorkerThreads* workers, uint max_num_regions) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetChooser.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-class WorkGang;\n+class WorkerThreads;\n@@ -62,1 +62,1 @@\n-  static G1CollectionSetCandidates* build(WorkGang* workers, uint max_num_regions);\n+  static G1CollectionSetCandidates* build(WorkerThreads* workers, uint max_num_regions);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetChooser.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"gc\/g1\/g1BatchedGangTask.hpp\"\n+#include \"gc\/g1\/g1BatchedTask.hpp\"\n@@ -435,1 +435,1 @@\n-  _concurrent_workers = new WorkGang(\"G1 Conc\", _max_concurrent_workers);\n+  _concurrent_workers = new WorkerThreads(\"G1 Conc\", _max_concurrent_workers);\n@@ -583,1 +583,1 @@\n-class G1ClearBitMapTask : public AbstractGangTask {\n+class G1ClearBitMapTask : public WorkerTask {\n@@ -677,1 +677,1 @@\n-    AbstractGangTask(\"G1 Clear Bitmap\"),\n+    WorkerTask(\"G1 Clear Bitmap\"),\n@@ -693,1 +693,1 @@\n-void G1ConcurrentMark::clear_next_bitmap(WorkGang* workers, bool may_yield) {\n+void G1ConcurrentMark::clear_next_bitmap(WorkerThreads* workers, bool may_yield) {\n@@ -726,1 +726,1 @@\n-void G1ConcurrentMark::clear_next_bitmap(WorkGang* workers) {\n+void G1ConcurrentMark::clear_next_bitmap(WorkerThreads* workers) {\n@@ -732,1 +732,1 @@\n-  WithUpdatedActiveWorkers update(workers, workers->created_workers());\n+  WithActiveWorkers update(workers, workers->created_workers());\n@@ -736,1 +736,1 @@\n-class G1PreConcurrentStartTask : public G1BatchedGangTask {\n+class G1PreConcurrentStartTask : public G1BatchedTask {\n@@ -808,1 +808,1 @@\n-  G1BatchedGangTask(\"Pre Concurrent Start\", G1CollectedHeap::heap()->phase_times()) {\n+  G1BatchedTask(\"Pre Concurrent Start\", G1CollectedHeap::heap()->phase_times()) {\n@@ -892,1 +892,1 @@\n-class G1CMConcurrentMarkingTask : public AbstractGangTask {\n+class G1CMConcurrentMarkingTask : public WorkerTask {\n@@ -926,1 +926,1 @@\n-      AbstractGangTask(\"Concurrent Mark\"), _cm(cm) { }\n+      WorkerTask(\"Concurrent Mark\"), _cm(cm) { }\n@@ -974,1 +974,1 @@\n-class G1CMRootRegionScanTask : public AbstractGangTask {\n+class G1CMRootRegionScanTask : public WorkerTask {\n@@ -978,1 +978,1 @@\n-    AbstractGangTask(\"G1 Root Region Scan\"), _cm(cm) { }\n+    WorkerTask(\"G1 Root Region Scan\"), _cm(cm) { }\n@@ -1049,2 +1049,2 @@\n-  active_workers = _concurrent_workers->update_active_workers(active_workers);\n-  log_info(gc, task)(\"Using %u workers of %u for marking\", active_workers, _concurrent_workers->total_workers());\n+  active_workers = _concurrent_workers->set_active_workers(active_workers);\n+  log_info(gc, task)(\"Using %u workers of %u for marking\", active_workers, _concurrent_workers->max_workers());\n@@ -1078,1 +1078,1 @@\n-class G1UpdateRemSetTrackingBeforeRebuildTask : public AbstractGangTask {\n+class G1UpdateRemSetTrackingBeforeRebuildTask : public WorkerTask {\n@@ -1179,1 +1179,1 @@\n-    AbstractGangTask(\"G1 Update RemSet Tracking Before Rebuild\"),\n+    WorkerTask(\"G1 Update RemSet Tracking Before Rebuild\"),\n@@ -1310,1 +1310,1 @@\n-class G1ReclaimEmptyRegionsTask : public AbstractGangTask {\n+class G1ReclaimEmptyRegionsTask : public WorkerTask {\n@@ -1365,1 +1365,1 @@\n-    AbstractGangTask(\"G1 Cleanup\"),\n+    WorkerTask(\"G1 Cleanup\"),\n@@ -1392,1 +1392,1 @@\n-  WorkGang* workers = _g1h->workers();\n+  WorkerThreads* workers = _g1h->workers();\n@@ -1616,1 +1616,1 @@\n-    \/\/ otherwise we use the work gang from the G1CollectedHeap and\n+    \/\/ otherwise we use the workers from the G1CollectedHeap and\n@@ -1805,1 +1805,1 @@\n-class G1CMRemarkTask : public AbstractGangTask {\n+class G1CMRemarkTask : public WorkerTask {\n@@ -1829,1 +1829,1 @@\n-    AbstractGangTask(\"Par Remark\"), _cm(cm) {\n+    WorkerTask(\"Par Remark\"), _cm(cm) {\n@@ -1845,1 +1845,1 @@\n-  \/\/ through the gang in the task.\n+  \/\/ through the task.\n@@ -2564,1 +2564,1 @@\n-    being called by any of the worker threads in a work gang.\n+    being called by any of the worker threads.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":25,"deletions":25,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -37,1 +37,2 @@\n-#include \"gc\/shared\/workgroup.hpp\"\n+#include \"gc\/shared\/workerThread.hpp\"\n+#include \"gc\/shared\/workerUtils.hpp\"\n@@ -328,2 +329,2 @@\n-  WorkGangBarrierSync     _first_overflow_barrier_sync;\n-  WorkGangBarrierSync     _second_overflow_barrier_sync;\n+  WorkerThreadsBarrierSync     _first_overflow_barrier_sync;\n+  WorkerThreadsBarrierSync     _second_overflow_barrier_sync;\n@@ -357,1 +358,1 @@\n-  WorkGang* _concurrent_workers;\n+  WorkerThreads* _concurrent_workers;\n@@ -443,1 +444,1 @@\n-  \/\/ Clear the next marking bitmap in parallel using the given WorkGang. If may_yield is\n+  \/\/ Clear the next marking bitmap in parallel using the given WorkerThreads. If may_yield is\n@@ -445,1 +446,1 @@\n-  void clear_next_bitmap(WorkGang* workers, bool may_yield);\n+  void clear_next_bitmap(WorkerThreads* workers, bool may_yield);\n@@ -537,1 +538,1 @@\n-  void clear_next_bitmap(WorkGang* workers);\n+  void clear_next_bitmap(WorkerThreads* workers);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.hpp","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -273,1 +273,1 @@\n-  AbstractGangTask(\"G1 Remove Self-forwarding Pointers\"),\n+  WorkerTask(\"G1 Remove Self-forwarding Pointers\"),\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailure.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"gc\/shared\/workgroup.hpp\"\n+#include \"gc\/shared\/workerThread.hpp\"\n@@ -39,1 +39,1 @@\n-class G1ParRemoveSelfForwardPtrsTask: public AbstractGangTask {\n+class G1ParRemoveSelfForwardPtrsTask: public WorkerTask {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailure.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -78,1 +78,1 @@\n-  uint max_worker_count = heap->workers()->total_workers();\n+  uint max_worker_count = heap->workers()->max_workers();\n@@ -105,1 +105,1 @@\n-  worker_count = heap->workers()->update_active_workers(worker_count);\n+  worker_count = heap->workers()->set_active_workers(worker_count);\n@@ -335,1 +335,1 @@\n-void G1FullCollector::run_task(AbstractGangTask* task) {\n+void G1FullCollector::run_task(WorkerTask* task) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-class AbstractGangTask;\n+class WorkerTask;\n@@ -137,1 +137,1 @@\n-  void run_task(AbstractGangTask* task);\n+  void run_task(WorkerTask* task);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"gc\/shared\/workgroup.hpp\"\n+#include \"gc\/shared\/workerThread.hpp\"\n@@ -33,1 +33,1 @@\n-class G1FullGCTask : public AbstractGangTask {\n+class G1FullGCTask : public WorkerTask {\n@@ -38,1 +38,1 @@\n-    AbstractGangTask(name),\n+    WorkerTask(name),\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCTask.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -429,1 +429,1 @@\n-class G1ParVerifyTask: public AbstractGangTask {\n+class G1ParVerifyTask: public WorkerTask {\n@@ -441,1 +441,1 @@\n-      AbstractGangTask(\"Parallel verify task\"),\n+      WorkerTask(\"Parallel verify task\"),\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapVerifier.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"gc\/shared\/workgroup.hpp\"\n+#include \"gc\/shared\/workerThread.hpp\"\n@@ -236,1 +236,1 @@\n-void G1PageBasedVirtualSpace::pretouch(size_t start_page, size_t size_in_pages, WorkGang* pretouch_gang) {\n+void G1PageBasedVirtualSpace::pretouch(size_t start_page, size_t size_in_pages, WorkerThreads* pretouch_workers) {\n@@ -239,1 +239,1 @@\n-                         _page_size, pretouch_gang);\n+                         _page_size, pretouch_workers);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1PageBasedVirtualSpace.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-class WorkGang;\n+class WorkerThreads;\n@@ -120,1 +120,1 @@\n-  void pretouch(size_t start_page, size_t size_in_pages, WorkGang* pretouch_gang = NULL);\n+  void pretouch(size_t start_page, size_t size_in_pages, WorkerThreads* pretouch_workers = NULL);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1PageBasedVirtualSpace.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-  AbstractGangTask(\"G1 Parallel Cleaning\"),\n+  WorkerTask(\"G1 Parallel Cleaning\"),\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParallelCleaning.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-class G1ParallelCleaningTask : public AbstractGangTask {\n+class G1ParallelCleaningTask : public WorkerTask {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParallelCleaning.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -92,1 +92,1 @@\n-  virtual void commit_regions(uint start_idx, size_t num_regions, WorkGang* pretouch_gang) {\n+  virtual void commit_regions(uint start_idx, size_t num_regions, WorkerThreads* pretouch_workers) {\n@@ -108,1 +108,1 @@\n-      _storage.pretouch(start_page, size_in_pages, pretouch_gang);\n+      _storage.pretouch(start_page, size_in_pages, pretouch_workers);\n@@ -175,1 +175,1 @@\n-  virtual void commit_regions(uint start_idx, size_t num_regions, WorkGang* pretouch_gang) {\n+  virtual void commit_regions(uint start_idx, size_t num_regions, WorkerThreads* pretouch_workers) {\n@@ -222,1 +222,1 @@\n-      _storage.pretouch(first_committed, num_committed, pretouch_gang);\n+      _storage.pretouch(first_committed, num_committed, pretouch_workers);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RegionToSpaceMapper.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-class WorkGang;\n+class WorkerThreads;\n@@ -73,1 +73,1 @@\n-  virtual void commit_regions(uint start_idx, size_t num_regions = 1, WorkGang* pretouch_workers = NULL) = 0;\n+  virtual void commit_regions(uint start_idx, size_t num_regions = 1, WorkerThreads* pretouch_workers = NULL) = 0;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RegionToSpaceMapper.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-#include \"gc\/g1\/g1BatchedGangTask.hpp\"\n+#include \"gc\/g1\/g1BatchedTask.hpp\"\n@@ -409,1 +409,1 @@\n-    WorkGang* workers = g1h->workers();\n+    WorkerThreads* workers = g1h->workers();\n@@ -1105,1 +1105,1 @@\n-class G1MergeHeapRootsTask : public AbstractGangTask {\n+class G1MergeHeapRootsTask : public WorkerTask {\n@@ -1374,1 +1374,1 @@\n-    AbstractGangTask(\"G1 Merge Heap Roots\"),\n+    WorkerTask(\"G1 Merge Heap Roots\"),\n@@ -1493,1 +1493,1 @@\n-  WorkGang* workers = g1h->workers();\n+  WorkerThreads* workers = g1h->workers();\n@@ -1741,1 +1741,1 @@\n-class G1RebuildRemSetTask: public AbstractGangTask {\n+class G1RebuildRemSetTask: public WorkerTask {\n@@ -1977,1 +1977,1 @@\n-      AbstractGangTask(\"G1 Rebuild Remembered Set\"),\n+      WorkerTask(\"G1 Rebuild Remembered Set\"),\n@@ -1994,1 +1994,1 @@\n-                               WorkGang* workers,\n+                               WorkerThreads* workers,\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -116,1 +116,1 @@\n-  \/\/ Creates a gang task for cleaining up temporary data structures and the\n+  \/\/ Creates a task for cleaining up temporary data structures and the\n@@ -152,2 +152,2 @@\n-  \/\/ using the given work gang.\n-  void rebuild_rem_set(G1ConcurrentMark* cm, WorkGang* workers, uint worker_id_offset);\n+  \/\/ using the given workers.\n+  void rebuild_rem_set(G1ConcurrentMark* cm, WorkerThreads* workers, uint worker_id_offset);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-#include \"gc\/shared\/workgroup.hpp\"\n+#include \"gc\/shared\/workerThread.hpp\"\n@@ -272,1 +272,1 @@\n-WorkGang* G1YoungCollector::workers() const {\n+WorkerThreads* G1YoungCollector::workers() const {\n@@ -325,1 +325,1 @@\n-class G1PrepareEvacuationTask : public AbstractGangTask {\n+class G1PrepareEvacuationTask : public WorkerTask {\n@@ -462,1 +462,1 @@\n-    AbstractGangTask(\"Prepare Evacuation\"),\n+    WorkerTask(\"Prepare Evacuation\"),\n@@ -497,1 +497,1 @@\n-Tickspan G1YoungCollector::run_task_timed(AbstractGangTask* task) {\n+Tickspan G1YoungCollector::run_task_timed(WorkerTask* task) {\n@@ -504,1 +504,1 @@\n-  uint active_workers = WorkerPolicy::calc_active_workers(workers()->total_workers(),\n+  uint active_workers = WorkerPolicy::calc_active_workers(workers()->max_workers(),\n@@ -507,2 +507,2 @@\n-  active_workers = workers()->update_active_workers(active_workers);\n-  log_info(gc,task)(\"Using %u workers of %u for evacuation\", active_workers, workers()->total_workers());\n+  active_workers = workers()->set_active_workers(active_workers);\n+  log_info(gc,task)(\"Using %u workers of %u for evacuation\", active_workers, workers()->max_workers());\n@@ -627,1 +627,1 @@\n-class G1EvacuateRegionsBaseTask : public AbstractGangTask {\n+class G1EvacuateRegionsBaseTask : public WorkerTask {\n@@ -675,1 +675,1 @@\n-    AbstractGangTask(name),\n+    WorkerTask(name),\n@@ -759,1 +759,1 @@\n-    \/\/ G1RootProcessor object. By subtracting the WorkGang task from the total\n+    \/\/ G1RootProcessor object. By subtracting the WorkerThreads task from the total\n@@ -1081,1 +1081,1 @@\n-  \/\/ Verification may use the gang workers, so they must be set up before.\n+  \/\/ Verification may use the workers, so they must be set up before.\n@@ -1086,1 +1086,1 @@\n-  \/\/ use of the STW work gang to maximize cpu use (i.e. all cores are available\n+  \/\/ use of the STW workers to maximize cpu use (i.e. all cores are available\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.cpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-class AbstractGangTask;\n+class WorkerTask;\n@@ -35,1 +35,1 @@\n-class G1BatchedGangTask;\n+class G1BatchedTask;\n@@ -55,1 +55,1 @@\n-class WorkGang;\n+class WorkerThreads;\n@@ -81,1 +81,1 @@\n-  WorkGang* workers() const;\n+  WorkerThreads* workers() const;\n@@ -92,1 +92,1 @@\n-  \/\/ Runs the given AbstractGangTask with the current active workers,\n+  \/\/ Runs the given WorkerTask with the current active workers,\n@@ -94,1 +94,1 @@\n-  Tickspan run_task_timed(AbstractGangTask* task);\n+  Tickspan run_task_timed(WorkerTask* task);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -128,1 +128,1 @@\n-  G1BatchedGangTask(\"Post Evacuate Cleanup 1\", G1CollectedHeap::heap()->phase_times())\n+  G1BatchedTask(\"Post Evacuate Cleanup 1\", G1CollectedHeap::heap()->phase_times())\n@@ -309,1 +309,1 @@\n-  AbstractGangTask* _task;\n+  WorkerTask* _task;\n@@ -675,1 +675,1 @@\n-  G1BatchedGangTask(\"Post Evacuate Cleanup 2\", G1CollectedHeap::heap()->phase_times())\n+  G1BatchedTask(\"Post Evacuate Cleanup 2\", G1CollectedHeap::heap()->phase_times())\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"gc\/g1\/g1BatchedGangTask.hpp\"\n+#include \"gc\/g1\/g1BatchedTask.hpp\"\n@@ -45,1 +45,1 @@\n-class G1PostEvacuateCollectionSetCleanupTask1 : public G1BatchedGangTask {\n+class G1PostEvacuateCollectionSetCleanupTask1 : public G1BatchedTask {\n@@ -64,1 +64,1 @@\n-class G1PostEvacuateCollectionSetCleanupTask2 : public G1BatchedGangTask {\n+class G1PostEvacuateCollectionSetCleanupTask2 : public G1BatchedTask {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -169,2 +169,2 @@\n-void HeapRegionManager::expand(uint start, uint num_regions, WorkGang* pretouch_gang) {\n-  commit_regions(start, num_regions, pretouch_gang);\n+void HeapRegionManager::expand(uint start, uint num_regions, WorkerThreads* pretouch_workers) {\n+  commit_regions(start, num_regions, pretouch_workers);\n@@ -184,1 +184,1 @@\n-void HeapRegionManager::commit_regions(uint index, size_t num_regions, WorkGang* pretouch_gang) {\n+void HeapRegionManager::commit_regions(uint index, size_t num_regions, WorkerThreads* pretouch_workers) {\n@@ -189,1 +189,1 @@\n-  _heap_mapper->commit_regions(index, num_regions, pretouch_gang);\n+  _heap_mapper->commit_regions(index, num_regions, pretouch_workers);\n@@ -192,2 +192,2 @@\n-  _prev_bitmap_mapper->commit_regions(index, num_regions, pretouch_gang);\n-  _next_bitmap_mapper->commit_regions(index, num_regions, pretouch_gang);\n+  _prev_bitmap_mapper->commit_regions(index, num_regions, pretouch_workers);\n+  _next_bitmap_mapper->commit_regions(index, num_regions, pretouch_workers);\n@@ -195,2 +195,2 @@\n-  _bot_mapper->commit_regions(index, num_regions, pretouch_gang);\n-  _cardtable_mapper->commit_regions(index, num_regions, pretouch_gang);\n+  _bot_mapper->commit_regions(index, num_regions, pretouch_workers);\n+  _cardtable_mapper->commit_regions(index, num_regions, pretouch_workers);\n@@ -198,1 +198,1 @@\n-  _card_counts_mapper->commit_regions(index, num_regions, pretouch_gang);\n+  _card_counts_mapper->commit_regions(index, num_regions, pretouch_workers);\n@@ -349,1 +349,1 @@\n-uint HeapRegionManager::expand_any(uint num_regions, WorkGang* pretouch_workers) {\n+uint HeapRegionManager::expand_any(uint num_regions, WorkerThreads* pretouch_workers) {\n@@ -371,1 +371,1 @@\n-uint HeapRegionManager::expand_by(uint num_regions, WorkGang* pretouch_workers) {\n+uint HeapRegionManager::expand_by(uint num_regions, WorkerThreads* pretouch_workers) {\n@@ -387,1 +387,1 @@\n-void HeapRegionManager::expand_exact(uint start, uint num_regions, WorkGang* pretouch_workers) {\n+void HeapRegionManager::expand_exact(uint start, uint num_regions, WorkerThreads* pretouch_workers) {\n@@ -558,1 +558,1 @@\n-bool HeapRegionManager::allocate_containing_regions(MemRegion range, size_t* commit_count, WorkGang* pretouch_workers) {\n+bool HeapRegionManager::allocate_containing_regions(MemRegion range, size_t* commit_count, WorkerThreads* pretouch_workers) {\n@@ -763,1 +763,1 @@\n-class G1RebuildFreeListTask : public AbstractGangTask {\n+class G1RebuildFreeListTask : public WorkerTask {\n@@ -771,1 +771,1 @@\n-      AbstractGangTask(\"G1 Rebuild Free List Task\"),\n+      WorkerTask(\"G1 Rebuild Free List Task\"),\n@@ -821,1 +821,1 @@\n-void HeapRegionManager::rebuild_free_list(WorkGang* workers) {\n+void HeapRegionManager::rebuild_free_list(WorkerThreads* workers) {\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionManager.cpp","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-class WorkGang;\n+class WorkerThreads;\n@@ -92,1 +92,1 @@\n-  void commit_regions(uint index, size_t num_regions = 1, WorkGang* pretouch_gang = NULL);\n+  void commit_regions(uint index, size_t num_regions = 1, WorkerThreads* pretouch_workers = NULL);\n@@ -130,1 +130,1 @@\n-  void expand(uint index, uint num_regions, WorkGang* pretouch_gang = NULL);\n+  void expand(uint index, uint num_regions, WorkerThreads* pretouch_workers = NULL);\n@@ -150,1 +150,1 @@\n-  void expand_exact(uint start, uint num_regions, WorkGang* pretouch_workers);\n+  void expand_exact(uint start, uint num_regions, WorkerThreads* pretouch_workers);\n@@ -154,1 +154,1 @@\n-  uint expand_any(uint num_regions, WorkGang* pretouch_workers);\n+  uint expand_any(uint num_regions, WorkerThreads* pretouch_workers);\n@@ -200,1 +200,1 @@\n-  void rebuild_free_list(WorkGang* workers);\n+  void rebuild_free_list(WorkerThreads* workers);\n@@ -256,1 +256,1 @@\n-  uint expand_by(uint num_regions, WorkGang* pretouch_workers);\n+  uint expand_by(uint num_regions, WorkerThreads* pretouch_workers);\n@@ -271,1 +271,1 @@\n-  bool allocate_containing_regions(MemRegion range, size_t* commit_count, WorkGang* pretouch_workers);\n+  bool allocate_containing_regions(MemRegion range, size_t* commit_count, WorkerThreads* pretouch_workers);\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionManager.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"gc\/shared\/workgroup.hpp\"\n+#include \"gc\/shared\/workerThread.hpp\"\n@@ -580,1 +580,1 @@\n-                                  WorkGang* pretouch_gang) {\n+                                  WorkerThreads* pretouch_workers) {\n","filename":"src\/hotspot\/share\/gc\/parallel\/mutableNUMASpace.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -204,1 +204,1 @@\n-                          WorkGang* pretouch_gang = NULL);\n+                          WorkerThreads* pretouch_workers = NULL);\n","filename":"src\/hotspot\/share\/gc\/parallel\/mutableNUMASpace.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-                              WorkGang* pretouch_gang) {\n+                              WorkerThreads* pretouch_workers) {\n@@ -125,1 +125,1 @@\n-                             page_size, pretouch_gang);\n+                             page_size, pretouch_workers);\n@@ -128,1 +128,1 @@\n-                             page_size, pretouch_gang);\n+                             page_size, pretouch_workers);\n","filename":"src\/hotspot\/share\/gc\/parallel\/mutableSpace.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-class WorkGang;\n+class WorkerThreads;\n@@ -105,1 +105,1 @@\n-                          WorkGang* pretouch_gang = NULL);\n+                          WorkerThreads* pretouch_workers = NULL);\n","filename":"src\/hotspot\/share\/gc\/parallel\/mutableSpace.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-  \/\/ Set up WorkGang\n+  \/\/ Set up WorkerThreads\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-#include \"gc\/shared\/workgroup.hpp\"\n+#include \"gc\/shared\/workerThread.hpp\"\n@@ -94,1 +94,1 @@\n-  WorkGang _workers;\n+  WorkerThreads _workers;\n@@ -246,1 +246,1 @@\n-  virtual WorkGang* safepoint_workers() { return &_workers; }\n+  virtual WorkerThreads* safepoint_workers() { return &_workers; }\n@@ -273,1 +273,1 @@\n-  WorkGang& workers() {\n+  WorkerThreads& workers() {\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-  uint parallel_gc_threads = ParallelScavengeHeap::heap()->workers().total_workers();\n+  uint parallel_gc_threads = ParallelScavengeHeap::heap()->workers().max_workers();\n@@ -90,1 +90,1 @@\n-  assert(ParallelScavengeHeap::heap()->workers().total_workers() != 0,\n+  assert(ParallelScavengeHeap::heap()->workers().max_workers() != 0,\n@@ -99,1 +99,1 @@\n-  uint parallel_gc_threads = ParallelScavengeHeap::heap()->workers().total_workers();\n+  uint parallel_gc_threads = ParallelScavengeHeap::heap()->workers().max_workers();\n@@ -106,1 +106,1 @@\n-  uint parallel_gc_threads = ParallelScavengeHeap::heap()->workers().total_workers();\n+  uint parallel_gc_threads = ParallelScavengeHeap::heap()->workers().max_workers();\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCompactionManager.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -362,1 +362,1 @@\n-  WorkGang* workers = Thread::current()->is_VM_thread() ?\n+  WorkerThreads* workers = Thread::current()->is_VM_thread() ?\n","filename":"src\/hotspot\/share\/gc\/parallel\/psOldGen.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -63,1 +63,2 @@\n-#include \"gc\/shared\/workgroup.hpp\"\n+#include \"gc\/shared\/workerThread.hpp\"\n+#include \"gc\/shared\/workerUtils.hpp\"\n@@ -1768,1 +1769,1 @@\n-      WorkerPolicy::calc_active_workers(ParallelScavengeHeap::heap()->workers().total_workers(),\n+      WorkerPolicy::calc_active_workers(ParallelScavengeHeap::heap()->workers().max_workers(),\n@@ -1771,1 +1772,1 @@\n-    ParallelScavengeHeap::heap()->workers().update_active_workers(active_workers);\n+    ParallelScavengeHeap::heap()->workers().set_active_workers(active_workers);\n@@ -2019,1 +2020,1 @@\n-class MarkFromRootsTask : public AbstractGangTask {\n+class MarkFromRootsTask : public WorkerTask {\n@@ -2028,1 +2029,1 @@\n-      AbstractGangTask(\"MarkFromRootsTask\"),\n+      WorkerTask(\"MarkFromRootsTask\"),\n@@ -2155,1 +2156,1 @@\n-class PSAdjustTask final : public AbstractGangTask {\n+class PSAdjustTask final : public WorkerTask {\n@@ -2171,1 +2172,1 @@\n-    AbstractGangTask(\"PSAdjust task\"),\n+    WorkerTask(\"PSAdjust task\"),\n@@ -2494,1 +2495,1 @@\n-class UpdateDensePrefixAndCompactionTask: public AbstractGangTask {\n+class UpdateDensePrefixAndCompactionTask: public WorkerTask {\n@@ -2501,1 +2502,1 @@\n-      AbstractGangTask(\"UpdateDensePrefixAndCompactionTask\"),\n+      WorkerTask(\"UpdateDensePrefixAndCompactionTask\"),\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -57,1 +57,2 @@\n-#include \"gc\/shared\/workgroup.hpp\"\n+#include \"gc\/shared\/workerThread.hpp\"\n+#include \"gc\/shared\/workerUtils.hpp\"\n@@ -280,1 +281,1 @@\n-class ScavengeRootsTask : public AbstractGangTask {\n+class ScavengeRootsTask : public WorkerTask {\n@@ -295,1 +296,1 @@\n-      AbstractGangTask(\"ScavengeRootsTask\"),\n+      WorkerTask(\"ScavengeRootsTask\"),\n@@ -466,1 +467,1 @@\n-      WorkerPolicy::calc_active_workers(ParallelScavengeHeap::heap()->workers().total_workers(),\n+      WorkerPolicy::calc_active_workers(ParallelScavengeHeap::heap()->workers().max_workers(),\n@@ -469,1 +470,1 @@\n-    ParallelScavengeHeap::heap()->workers().update_active_workers(active_workers);\n+    ParallelScavengeHeap::heap()->workers().set_active_workers(active_workers);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psScavenge.cpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -192,1 +192,1 @@\n-  WorkGang& pretouch_workers = ParallelScavengeHeap::heap()->workers();\n+  WorkerThreads& pretouch_workers = ParallelScavengeHeap::heap()->workers();\n@@ -641,1 +641,1 @@\n-  WorkGang* workers = &ParallelScavengeHeap::heap()->workers();\n+  WorkerThreads* workers = &ParallelScavengeHeap::heap()->workers();\n","filename":"src\/hotspot\/share\/gc\/parallel\/psYoungGen.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-class AbstractGangTask;\n+class WorkerTask;\n@@ -62,1 +62,1 @@\n-class WorkGang;\n+class WorkerThreads;\n@@ -472,1 +472,1 @@\n-  virtual WorkGang* safepoint_workers() { return NULL; }\n+  virtual WorkerThreads* safepoint_workers() { return NULL; }\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-#include \"gc\/shared\/workgroup.hpp\"\n+#include \"gc\/shared\/workerThread.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/genCollectedHeap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-class WorkGang;\n+class WorkerThreads;\n","filename":"src\/hotspot\/share\/gc\/shared\/genCollectedHeap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"gc\/shared\/workgroup.hpp\"\n+#include \"gc\/shared\/workerThread.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/parallelCleaning.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,2 @@\n-#include \"gc\/shared\/workgroup.hpp\"\n+#include \"gc\/shared\/workerThread.hpp\"\n+#include \"gc\/shared\/workerUtils.hpp\"\n@@ -95,1 +96,1 @@\n-class RestorePreservedMarksTask : public AbstractGangTask {\n+class RestorePreservedMarksTask : public WorkerTask {\n@@ -112,1 +113,1 @@\n-    : AbstractGangTask(\"Restore Preserved Marks\"),\n+    : WorkerTask(\"Restore Preserved Marks\"),\n@@ -132,1 +133,1 @@\n-void PreservedMarksSet::restore(WorkGang* workers) {\n+void PreservedMarksSet::restore(WorkerThreads* workers) {\n@@ -145,1 +146,1 @@\n-AbstractGangTask* PreservedMarksSet::create_task() {\n+WorkerTask* PreservedMarksSet::create_task() {\n","filename":"src\/hotspot\/share\/gc\/shared\/preservedMarks.cpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-class AbstractGangTask;\n+class WorkerTask;\n@@ -35,1 +35,1 @@\n-class WorkGang;\n+class WorkerThreads;\n@@ -113,1 +113,1 @@\n-  \/\/ the memory taken up by the stack segments using the given WorkGang. If the WorkGang\n+  \/\/ the memory taken up by the stack segments using the given WorkerThreads. If the WorkerThreads\n@@ -115,1 +115,1 @@\n-  void restore(WorkGang* workers);\n+  void restore(WorkerThreads* workers);\n@@ -117,1 +117,1 @@\n-  AbstractGangTask* create_task();\n+  WorkerTask* create_task();\n","filename":"src\/hotspot\/share\/gc\/shared\/preservedMarks.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"logging\/log.hpp\"\n@@ -37,1 +38,1 @@\n-    AbstractGangTask(task_name),\n+    WorkerTask(task_name),\n@@ -65,1 +66,1 @@\n-                            size_t page_size, WorkGang* pretouch_gang) {\n+                            size_t page_size, WorkerThreads* pretouch_workers) {\n@@ -82,1 +83,1 @@\n-  if (pretouch_gang != NULL) {\n+  if (pretouch_workers != NULL) {\n@@ -85,1 +86,1 @@\n-    uint num_workers = (uint)MIN2(num_chunks, (size_t)pretouch_gang->total_workers());\n+    uint num_workers = (uint)MIN2(num_chunks, (size_t)pretouch_workers->max_workers());\n@@ -89,1 +90,1 @@\n-    pretouch_gang->run_task(&task, num_workers);\n+    pretouch_workers->run_task(&task, num_workers);\n","filename":"src\/hotspot\/share\/gc\/shared\/pretouchTask.cpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"gc\/shared\/workgroup.hpp\"\n+#include \"gc\/shared\/workerThread.hpp\"\n@@ -30,1 +30,1 @@\n-class PretouchTask : public AbstractGangTask {\n+class PretouchTask : public WorkerTask {\n@@ -44,1 +44,1 @@\n-                       size_t page_size, WorkGang* pretouch_gang);\n+                       size_t page_size, WorkerThreads* pretouch_workers);\n","filename":"src\/hotspot\/share\/gc\/shared\/pretouchTask.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -704,3 +704,3 @@\n-    WorkGang* gang = Universe::heap()->safepoint_workers();\n-    assert(gang != NULL, \"can not dispatch multi threaded without a work gang\");\n-    assert(gang->active_workers() >= num_queues(),\n+    WorkerThreads* workers = Universe::heap()->safepoint_workers();\n+    assert(workers != NULL, \"can not dispatch multi threaded without workers\");\n+    assert(workers->active_workers() >= num_queues(),\n@@ -708,2 +708,2 @@\n-           num_queues(), gang->active_workers());\n-    gang->run_task(&proxy_task, num_queues());\n+           num_queues(), workers->active_workers());\n+    workers->run_task(&proxy_task, num_queues());\n","filename":"src\/hotspot\/share\/gc\/shared\/referenceProcessor.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"gc\/shared\/workgroup.hpp\"\n+#include \"gc\/shared\/workerThread.hpp\"\n@@ -591,1 +591,1 @@\n-class RefProcProxyTask : public AbstractGangTask {\n+class RefProcProxyTask : public WorkerTask {\n@@ -600,1 +600,1 @@\n-  RefProcProxyTask(const char* name, uint max_workers) : AbstractGangTask(name), _max_workers(max_workers), _rp_task(nullptr),_tm(RefProcThreadModel::Single), _queue_count(0), _marks_oops_alive(false) {}\n+  RefProcProxyTask(const char* name, uint max_workers) : WorkerTask(name), _max_workers(max_workers), _rp_task(nullptr),_tm(RefProcThreadModel::Single), _queue_count(0), _marks_oops_alive(false) {}\n","filename":"src\/hotspot\/share\/gc\/shared\/referenceProcessor.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"gc\/shared\/workgroup.hpp\"\n+#include \"gc\/shared\/workerThread.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/space.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -128,1 +128,1 @@\n-void WeakProcessor::GangTask::work(uint worker_id) {\n+void WeakProcessor::WeakOopsDoTask::work(uint worker_id) {\n","filename":"src\/hotspot\/share\/gc\/shared\/weakProcessor.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"gc\/shared\/workgroup.hpp\"\n+#include \"gc\/shared\/workerThread.hpp\"\n@@ -34,1 +34,1 @@\n-class WorkGang;\n+class WorkerThreads;\n@@ -56,1 +56,1 @@\n-  static void weak_oops_do(WorkGang* workers,\n+  static void weak_oops_do(WorkerThreads* workers,\n@@ -67,1 +67,1 @@\n-  static void weak_oops_do(WorkGang* workers,\n+  static void weak_oops_do(WorkerThreads* workers,\n@@ -82,1 +82,1 @@\n-  class GangTask;\n+  class WeakOopsDoTask;\n","filename":"src\/hotspot\/share\/gc\/shared\/weakProcessor.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-#include \"gc\/shared\/workgroup.hpp\"\n+#include \"gc\/shared\/workerThread.hpp\"\n@@ -99,1 +99,1 @@\n-class WeakProcessor::GangTask : public AbstractGangTask {\n+class WeakProcessor::WeakOopsDoTask : public WorkerTask {\n@@ -103,1 +103,1 @@\n-  void (*_erased_do_work)(GangTask* task, uint worker_id);\n+  void (*_erased_do_work)(WeakOopsDoTask* task, uint worker_id);\n@@ -106,1 +106,1 @@\n-  static void erased_do_work(GangTask* task, uint worker_id) {\n+  static void erased_do_work(WeakOopsDoTask* task, uint worker_id) {\n@@ -114,6 +114,6 @@\n-  GangTask(const char* name,\n-           IsAlive* is_alive,\n-           KeepAlive* keep_alive,\n-           WeakProcessorTimes* times,\n-           uint nworkers) :\n-    AbstractGangTask(name),\n+  WeakOopsDoTask(const char* name,\n+                 IsAlive* is_alive,\n+                 KeepAlive* keep_alive,\n+                 WeakProcessorTimes* times,\n+                 uint nworkers) :\n+    WorkerTask(name),\n@@ -131,1 +131,1 @@\n-void WeakProcessor::weak_oops_do(WorkGang* workers,\n+void WeakProcessor::weak_oops_do(WorkerThreads* workers,\n@@ -137,1 +137,1 @@\n-  uint nworkers = ergo_workers(MIN2(workers->total_workers(),\n+  uint nworkers = ergo_workers(MIN2(workers->max_workers(),\n@@ -140,1 +140,1 @@\n-  GangTask task(\"Weak Processor\", is_alive, keep_alive, times, nworkers);\n+  WeakOopsDoTask task(\"Weak Processor\", is_alive, keep_alive, times, nworkers);\n@@ -146,1 +146,1 @@\n-void WeakProcessor::weak_oops_do(WorkGang* workers,\n+void WeakProcessor::weak_oops_do(WorkerThreads* workers,\n@@ -150,1 +150,1 @@\n-  uint nworkers = ergo_workers(workers->total_workers());\n+  uint nworkers = ergo_workers(workers->max_workers());\n","filename":"src\/hotspot\/share\/gc\/shared\/weakProcessor.inline.hpp","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -1,113 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_SHARED_WORKERMANAGER_HPP\n-#define SHARE_GC_SHARED_WORKERMANAGER_HPP\n-\n-#include \"gc\/shared\/gc_globals.hpp\"\n-#include \"logging\/log.hpp\"\n-#include \"memory\/allocation.hpp\"\n-#include \"runtime\/os.hpp\"\n-#include \"runtime\/thread.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-\n-class WorkerManager : public AllStatic {\n- public:\n-  \/\/ Create additional workers as needed.\n-  \/\/   active_workers - number of workers being requested for an upcoming\n-  \/\/ parallel task.\n-  \/\/   total_workers - total number of workers.  This is the maximum\n-  \/\/ number possible.\n-  \/\/   created_workers - number of workers already created.  This maybe\n-  \/\/ less than, equal to, or greater than active workers.  If greater than\n-  \/\/ or equal to active_workers, nothing is done.\n-  \/\/   worker_type - type of thread.\n-  \/\/   initializing - true if this is called to get the initial number of\n-  \/\/ GC workers.\n-  \/\/ If initializing is true, do a vm exit if the workers cannot be created.\n-  \/\/ The initializing = true case is for JVM start up and failing to\n-  \/\/ create all the worker at start should considered a problem so exit.\n-  \/\/ If initializing = false, there are already some number of worker\n-  \/\/ threads and a failure would not be optimal but should not be fatal.\n-  static uint add_workers (WorkGang* workers,\n-                           uint active_workers,\n-                           uint total_workers,\n-                           uint created_workers,\n-                           os::ThreadType worker_type,\n-                           bool initializing);\n-\n-  \/\/ Log (at trace level) a change in the number of created workers.\n-  static void log_worker_creation(WorkGang* workers,\n-                                  uint previous_created_workers,\n-                                  uint active_workers,\n-                                  uint created_workers,\n-                                  bool initializing);\n-};\n-\n-uint WorkerManager::add_workers(WorkGang* workers,\n-                                uint active_workers,\n-                                uint total_workers,\n-                                uint created_workers,\n-                                os::ThreadType worker_type,\n-                                bool initializing) {\n-  uint start = created_workers;\n-  uint end = MIN2(active_workers, total_workers);\n-  for (uint worker_id = start; worker_id < end; worker_id += 1) {\n-    WorkerThread* new_worker = NULL;\n-    if (initializing || !InjectGCWorkerCreationFailure) {\n-      new_worker = workers->install_worker(worker_id);\n-    }\n-    if (new_worker == NULL || !os::create_thread(new_worker, worker_type)) {\n-      log_trace(gc, task)(\"WorkerManager::add_workers() : \"\n-                          \"creation failed due to failed allocation of native %s\",\n-                          new_worker == NULL ? \"memory\" : \"thread\");\n-      delete new_worker;\n-      if (initializing) {\n-        vm_exit_out_of_memory(0, OOM_MALLOC_ERROR, \"Cannot create worker GC thread. Out of system resources.\");\n-      }\n-      break;\n-    }\n-    created_workers++;\n-    os::start_thread(new_worker);\n-  }\n-\n-  log_trace(gc, task)(\"WorkerManager::add_workers() : \"\n-                      \"created_workers: %u\", created_workers);\n-\n-  return created_workers;\n-}\n-\n-void WorkerManager::log_worker_creation(WorkGang* workers,\n-                                        uint previous_created_workers,\n-                                        uint active_workers,\n-                                        uint created_workers,\n-                                        bool initializing) {\n-  if (previous_created_workers < created_workers) {\n-    const char* initializing_msg = initializing ? \"Adding initial\" : \"Creating additional\";\n-    log_trace(gc, task)(\"%s %s(s) previously created workers %u active workers %u total created workers %u\",\n-                        initializing_msg, workers->group_name(), previous_created_workers, active_workers, created_workers);\n-  }\n-}\n-\n-#endif \/\/ SHARE_GC_SHARED_WORKERMANAGER_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/workerManager.hpp","additions":0,"deletions":113,"binary":false,"changes":113,"status":"deleted"},{"patch":"@@ -0,0 +1,161 @@\n+\/*\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/shared\/gc_globals.hpp\"\n+#include \"gc\/shared\/workerThread.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/init.hpp\"\n+#include \"runtime\/java.hpp\"\n+#include \"runtime\/os.hpp\"\n+\n+WorkerTaskDispatcher::WorkerTaskDispatcher() :\n+    _task(NULL),\n+    _started(0),\n+    _not_finished(0),\n+    _start_semaphore(),\n+    _end_semaphore() {}\n+\n+void WorkerTaskDispatcher::coordinator_distribute_task(WorkerTask* task, uint num_workers) {\n+  \/\/ No workers are allowed to read the state variables until they have been signaled.\n+  _task = task;\n+  _not_finished = num_workers;\n+\n+  \/\/ Dispatch 'num_workers' number of tasks.\n+  _start_semaphore.signal(num_workers);\n+\n+  \/\/ Wait for the last worker to signal the coordinator.\n+  _end_semaphore.wait();\n+\n+  \/\/ No workers are allowed to read the state variables after the coordinator has been signaled.\n+  assert(_not_finished == 0, \"%d not finished workers?\", _not_finished);\n+  _task = NULL;\n+  _started = 0;\n+}\n+\n+void WorkerTaskDispatcher::worker_run_task() {\n+  \/\/ Wait for the coordinator to dispatch a task.\n+  _start_semaphore.wait();\n+\n+  \/\/ Get worker id.\n+  const uint worker_id = Atomic::fetch_and_add(&_started, 1u);\n+\n+  \/\/ Run task.\n+  GCIdMark gc_id_mark(_task->gc_id());\n+  _task->work(worker_id);\n+\n+  \/\/ Mark that the worker is done with the task.\n+  \/\/ The worker is not allowed to read the state variables after this line.\n+  const uint not_finished = Atomic::sub(&_not_finished, 1u);\n+\n+  \/\/ The last worker signals to the coordinator that all work is completed.\n+  if (not_finished == 0) {\n+    _end_semaphore.signal();\n+  }\n+}\n+\n+WorkerThreads::WorkerThreads(const char* name, uint max_workers) :\n+    _name(name),\n+    _workers(NEW_C_HEAP_ARRAY(WorkerThread*, max_workers, mtInternal)),\n+    _max_workers(max_workers),\n+    _created_workers(0),\n+    _active_workers(0),\n+    _dispatcher() {}\n+\n+void WorkerThreads::initialize_workers() {\n+  const uint initial_active_workers = UseDynamicNumberOfGCThreads ? 1 : _max_workers;\n+  if (set_active_workers(initial_active_workers) != initial_active_workers) {\n+    vm_exit_during_initialization();\n+  }\n+}\n+\n+WorkerThread* WorkerThreads::create_worker(uint id) {\n+  if (is_init_completed() && InjectGCWorkerCreationFailure) {\n+    return NULL;\n+  }\n+\n+  WorkerThread* const worker = new WorkerThread(_name, id, &_dispatcher);\n+\n+  if (!os::create_thread(worker, os::gc_thread)) {\n+    delete worker;\n+    return NULL;\n+  }\n+\n+  os::start_thread(worker);\n+\n+  return worker;\n+}\n+\n+uint WorkerThreads::set_active_workers(uint num_workers) {\n+  assert(num_workers > 0 && num_workers <= _max_workers,\n+         \"Invalid number of active workers %u (should be 1-%u)\",\n+         num_workers, _max_workers);\n+\n+  while (_created_workers < num_workers) {\n+    WorkerThread* const worker = create_worker(_created_workers);\n+    if (worker == NULL) {\n+      log_error(gc, task)(\"Failed to create worker thread\");\n+      break;\n+    }\n+\n+    _workers[_created_workers] = worker;\n+    _created_workers++;\n+  }\n+\n+  _active_workers = MIN2(_created_workers, num_workers);\n+\n+  log_trace(gc, task)(\"%s: using %d out of %d workers\", _name, _active_workers, _max_workers);\n+\n+  return _active_workers;\n+}\n+\n+void WorkerThreads::threads_do(ThreadClosure* tc) const {\n+  for (uint i = 0; i < _created_workers; i++) {\n+    tc->do_thread(_workers[i]);\n+  }\n+}\n+\n+void WorkerThreads::run_task(WorkerTask* task) {\n+  _dispatcher.coordinator_distribute_task(task, _active_workers);\n+}\n+\n+void WorkerThreads::run_task(WorkerTask* task, uint num_workers) {\n+  WithActiveWorkers with_active_workers(this, num_workers);\n+  run_task(task);\n+}\n+\n+WorkerThread::WorkerThread(const char* name_prefix, uint id, WorkerTaskDispatcher* dispatcher) :\n+    _dispatcher(dispatcher),\n+    _id(id) {\n+  set_name(\"%s#%d\", name_prefix, id);\n+}\n+\n+void WorkerThread::run() {\n+  os::set_priority(this, NearMaxPriority);\n+\n+  while (true) {\n+    _dispatcher->worker_run_task();\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/shared\/workerThread.cpp","additions":161,"deletions":0,"binary":false,"changes":161,"status":"added"},{"patch":"@@ -0,0 +1,164 @@\n+\/*\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHARED_WORKERTHREAD_HPP\n+#define SHARE_GC_SHARED_WORKERTHREAD_HPP\n+\n+#include \"gc\/shared\/gcId.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"runtime\/nonJavaThread.hpp\"\n+#include \"runtime\/semaphore.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+class ThreadClosure;\n+class WorkerTaskDispatcher;\n+class WorkerThread;\n+\n+\/\/ An task to be worked on by worker threads\n+class WorkerTask : public CHeapObj<mtInternal> {\n+private:\n+  const char* _name;\n+  const uint _gc_id;\n+\n+ public:\n+  explicit WorkerTask(const char* name) :\n+    _name(name),\n+    _gc_id(GCId::current_or_undefined()) {}\n+\n+  const char* name() const { return _name; }\n+  const uint gc_id() const { return _gc_id; }\n+\n+  virtual void work(uint worker_id) = 0;\n+};\n+\n+\/\/ WorkerThreads dispatcher implemented with semaphores\n+class WorkerTaskDispatcher {\n+  \/\/ The task currently being dispatched to the WorkerThreads.\n+  WorkerTask* _task;\n+\n+  volatile uint _started;\n+  volatile uint _not_finished;\n+\n+  \/\/ Semaphore used to start the WorkerThreads.\n+  Semaphore _start_semaphore;\n+  \/\/ Semaphore used to notify the coordinator that all workers are done.\n+  Semaphore _end_semaphore;\n+\n+public:\n+  WorkerTaskDispatcher();\n+\n+  \/\/ Coordinator API.\n+\n+  \/\/ Distributes the task out to num_workers workers.\n+  \/\/ Returns when the task has been completed by all workers.\n+  void coordinator_distribute_task(WorkerTask* task, uint num_workers);\n+\n+  \/\/ Worker API.\n+\n+  \/\/ Waits for a task to become available to the worker and runs it.\n+  void worker_run_task();\n+};\n+\n+\/\/ A set of worker threads to execute tasks\n+class WorkerThreads : public CHeapObj<mtInternal> {\n+private:\n+  const char* const    _name;\n+  WorkerThread**       _workers;\n+  const uint           _max_workers;\n+  uint                 _created_workers;\n+  uint                 _active_workers;\n+  WorkerTaskDispatcher _dispatcher;\n+\n+protected:\n+  virtual WorkerThread* create_worker(uint id);\n+\n+public:\n+  WorkerThreads(const char* name, uint max_workers);\n+\n+  void initialize_workers();\n+\n+  uint max_workers() const     { return _max_workers; }\n+  uint created_workers() const { return _created_workers; }\n+  uint active_workers() const  { return _active_workers; }\n+\n+  uint set_active_workers(uint num_workers);\n+\n+  void threads_do(ThreadClosure* tc) const;\n+\n+  const char* name() const { return _name; }\n+\n+  \/\/ Run a task using the current active number of workers, returns when the task is done.\n+  void run_task(WorkerTask* task);\n+\n+  \/\/ Run a task with the given number of workers, returns when the task is done.\n+  void run_task(WorkerTask* task, uint num_workers);\n+};\n+\n+class WorkerThread : public NamedThread {\n+private:\n+  WorkerTaskDispatcher* const _dispatcher;\n+  const uint                  _id;\n+\n+public:\n+  static WorkerThread* current() {\n+    return WorkerThread::cast(Thread::current());\n+  }\n+\n+  static WorkerThread* cast(Thread* t) {\n+    assert(t->is_Worker_thread(), \"incorrect cast to WorkerThread\");\n+    return static_cast<WorkerThread*>(t);\n+  }\n+\n+  WorkerThread(const char* name_prefix, uint id, WorkerTaskDispatcher* dispatcher);\n+\n+  uint id() const                        { return _id; }\n+\n+  bool is_Worker_thread() const override { return true; }\n+  const char* type_name() const override { return \"WorkerThread\"; }\n+\n+  void run() override;\n+};\n+\n+\/\/ Temporarily try to set the number of active workers.\n+\/\/ It's not guaranteed that it succeeds, and users need to\n+\/\/ query the number of active workers.\n+class WithActiveWorkers : public StackObj {\n+private:\n+  WorkerThreads* const _workers;\n+  const uint           _prev_active_workers;\n+\n+public:\n+  WithActiveWorkers(WorkerThreads* workers, uint num_workers) :\n+      _workers(workers),\n+      _prev_active_workers(workers->active_workers()) {\n+    _workers->set_active_workers(num_workers);\n+  }\n+\n+  ~WithActiveWorkers() {\n+    _workers->set_active_workers(_prev_active_workers);\n+  }\n+};\n+\n+#endif \/\/ SHARE_GC_SHARED_WORKERTHREAD_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/workerThread.hpp","additions":164,"deletions":0,"binary":false,"changes":164,"status":"added"},{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/shared\/workerUtils.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n+\n+\/\/ *** WorkerThreadsBarrierSync\n+\n+WorkerThreadsBarrierSync::WorkerThreadsBarrierSync()\n+  : _monitor(Mutex::nosafepoint, \"WorkerThreadsBarrierSync_lock\"),\n+    _n_workers(0), _n_completed(0), _should_reset(false), _aborted(false) {\n+}\n+\n+void WorkerThreadsBarrierSync::set_n_workers(uint n_workers) {\n+  _n_workers    = n_workers;\n+  _n_completed  = 0;\n+  _should_reset = false;\n+  _aborted      = false;\n+}\n+\n+bool WorkerThreadsBarrierSync::enter() {\n+  MonitorLocker ml(monitor(), Mutex::_no_safepoint_check_flag);\n+  if (should_reset()) {\n+    \/\/ The should_reset() was set and we are the first worker to enter\n+    \/\/ the sync barrier. We will zero the n_completed() count which\n+    \/\/ effectively resets the barrier.\n+    zero_completed();\n+    set_should_reset(false);\n+  }\n+  inc_completed();\n+  if (n_completed() == n_workers()) {\n+    \/\/ At this point we would like to reset the barrier to be ready in\n+    \/\/ case it is used again. However, we cannot set n_completed() to\n+    \/\/ 0, even after the notify_all(), given that some other workers\n+    \/\/ might still be waiting for n_completed() to become ==\n+    \/\/ n_workers(). So, if we set n_completed() to 0, those workers\n+    \/\/ will get stuck (as they will wake up, see that n_completed() !=\n+    \/\/ n_workers() and go back to sleep). Instead, we raise the\n+    \/\/ should_reset() flag and the barrier will be reset the first\n+    \/\/ time a worker enters it again.\n+    set_should_reset(true);\n+    ml.notify_all();\n+  } else {\n+    while (n_completed() != n_workers() && !aborted()) {\n+      ml.wait();\n+    }\n+  }\n+  return !aborted();\n+}\n+\n+void WorkerThreadsBarrierSync::abort() {\n+  MutexLocker x(monitor(), Mutex::_no_safepoint_check_flag);\n+  set_aborted();\n+  monitor()->notify_all();\n+}\n+\n+\/\/ SubTasksDone functions.\n+\n+SubTasksDone::SubTasksDone(uint n) :\n+  _tasks(NULL), _n_tasks(n) {\n+  _tasks = NEW_C_HEAP_ARRAY(bool, n, mtInternal);\n+  for (uint i = 0; i < _n_tasks; i++) {\n+    _tasks[i] = false;\n+  }\n+}\n+\n+#ifdef ASSERT\n+void SubTasksDone::all_tasks_claimed_impl(uint skipped[], size_t skipped_size) {\n+  if (Atomic::cmpxchg(&_verification_done, false, true)) {\n+    \/\/ another thread has done the verification\n+    return;\n+  }\n+  \/\/ all non-skipped tasks are claimed\n+  for (uint i = 0; i < _n_tasks; ++i) {\n+    if (!_tasks[i]) {\n+      auto is_skipped = false;\n+      for (size_t j = 0; j < skipped_size; ++j) {\n+        if (i == skipped[j]) {\n+          is_skipped = true;\n+          break;\n+        }\n+      }\n+      assert(is_skipped, \"%d not claimed.\", i);\n+    }\n+  }\n+  \/\/ all skipped tasks are *not* claimed\n+  for (size_t i = 0; i < skipped_size; ++i) {\n+    auto task_index = skipped[i];\n+    assert(task_index < _n_tasks, \"Array in range.\");\n+    assert(!_tasks[task_index], \"%d is both claimed and skipped.\", task_index);\n+  }\n+}\n+#endif\n+\n+bool SubTasksDone::try_claim_task(uint t) {\n+  assert(t < _n_tasks, \"bad task id.\");\n+  return !_tasks[t] && !Atomic::cmpxchg(&_tasks[t], false, true);\n+}\n+\n+SubTasksDone::~SubTasksDone() {\n+  assert(_verification_done, \"all_tasks_claimed must have been called.\");\n+  FREE_C_HEAP_ARRAY(bool, _tasks);\n+}\n+\n+\/\/ *** SequentialSubTasksDone\n+\n+bool SequentialSubTasksDone::try_claim_task(uint& t) {\n+  t = _num_claimed;\n+  if (t < _num_tasks) {\n+    t = Atomic::add(&_num_claimed, 1u) - 1;\n+  }\n+  return t < _num_tasks;\n+}\n","filename":"src\/hotspot\/share\/gc\/shared\/workerUtils.cpp","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"},{"patch":"@@ -0,0 +1,148 @@\n+\/*\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHARED_WORKERUTILS_HPP\n+#define SHARE_GC_SHARED_WORKERUTILS_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"metaprogramming\/enableIf.hpp\"\n+#include \"metaprogramming\/logical.hpp\"\n+#include \"runtime\/mutex.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+\/\/ A class that acts as a synchronisation barrier. Workers enter\n+\/\/ the barrier and must wait until all other workers have entered\n+\/\/ before any of them may leave.\n+\n+class WorkerThreadsBarrierSync : public StackObj {\n+protected:\n+  Monitor _monitor;\n+  uint    _n_workers;\n+  uint    _n_completed;\n+  bool    _should_reset;\n+  bool    _aborted;\n+\n+  Monitor* monitor()        { return &_monitor; }\n+  uint     n_workers()      { return _n_workers; }\n+  uint     n_completed()    { return _n_completed; }\n+  bool     should_reset()   { return _should_reset; }\n+  bool     aborted()        { return _aborted; }\n+\n+  void     zero_completed() { _n_completed = 0; }\n+  void     inc_completed()  { _n_completed++; }\n+  void     set_aborted()    { _aborted = true; }\n+  void     set_should_reset(bool v) { _should_reset = v; }\n+\n+public:\n+  WorkerThreadsBarrierSync();\n+\n+  \/\/ Set the number of workers that will use the barrier.\n+  \/\/ Must be called before any of the workers start running.\n+  void set_n_workers(uint n_workers);\n+\n+  \/\/ Enter the barrier. A worker that enters the barrier will\n+  \/\/ not be allowed to leave until all other threads have\n+  \/\/ also entered the barrier or the barrier is aborted.\n+  \/\/ Returns false if the barrier was aborted.\n+  bool enter();\n+\n+  \/\/ Aborts the barrier and wakes up any threads waiting for\n+  \/\/ the barrier to complete. The barrier will remain in the\n+  \/\/ aborted state until the next call to set_n_workers().\n+  void abort();\n+};\n+\n+\/\/ A class to manage claiming of subtasks within a group of tasks.  The\n+\/\/ subtasks will be identified by integer indices, usually elements of an\n+\/\/ enumeration type.\n+\n+class SubTasksDone: public CHeapObj<mtInternal> {\n+  volatile bool* _tasks;\n+  uint _n_tasks;\n+\n+  \/\/ make sure verification logic is run exactly once to avoid duplicate assertion failures\n+  DEBUG_ONLY(volatile bool _verification_done = false;)\n+  void all_tasks_claimed_impl(uint skipped[], size_t skipped_size) NOT_DEBUG_RETURN;\n+\n+  NONCOPYABLE(SubTasksDone);\n+\n+public:\n+  \/\/ Initializes \"this\" to a state in which there are \"n\" tasks to be\n+  \/\/ processed, none of the which are originally claimed.\n+  SubTasksDone(uint n);\n+\n+  \/\/ Attempt to claim the task \"t\", returning true if successful,\n+  \/\/ false if it has already been claimed.  The task \"t\" is required\n+  \/\/ to be within the range of \"this\".\n+  bool try_claim_task(uint t);\n+\n+  \/\/ The calling thread asserts that it has attempted to claim all the tasks\n+  \/\/ that it will try to claim.  Tasks that are meant to be skipped must be\n+  \/\/ explicitly passed as extra arguments. Every thread in the parallel task\n+  \/\/ must execute this.\n+  template<typename T0, typename... Ts,\n+          ENABLE_IF(Conjunction<std::is_same<T0, Ts>...>::value)>\n+  void all_tasks_claimed(T0 first_skipped, Ts... more_skipped) {\n+    static_assert(std::is_convertible<T0, uint>::value, \"not convertible\");\n+    uint skipped[] = { static_cast<uint>(first_skipped), static_cast<uint>(more_skipped)... };\n+    all_tasks_claimed_impl(skipped, ARRAY_SIZE(skipped));\n+  }\n+  \/\/ if there are no skipped tasks.\n+  void all_tasks_claimed() {\n+    all_tasks_claimed_impl(nullptr, 0);\n+  }\n+\n+  \/\/ Destructor.\n+  ~SubTasksDone();\n+};\n+\n+\/\/ As above, but for sequential tasks, i.e. instead of claiming\n+\/\/ sub-tasks from a set (possibly an enumeration), claim sub-tasks\n+\/\/ in sequential order. This is ideal for claiming dynamically\n+\/\/ partitioned tasks (like striding in the parallel remembered\n+\/\/ set scanning).\n+\n+class SequentialSubTasksDone : public CHeapObj<mtInternal> {\n+\n+  uint _num_tasks;     \/\/ Total number of tasks available.\n+  volatile uint _num_claimed;   \/\/ Number of tasks claimed.\n+\n+  NONCOPYABLE(SequentialSubTasksDone);\n+\n+public:\n+  SequentialSubTasksDone(uint num_tasks) : _num_tasks(num_tasks), _num_claimed(0) { }\n+  ~SequentialSubTasksDone() {\n+    \/\/ Claiming may try to claim more tasks than there are.\n+    assert(_num_claimed >= _num_tasks, \"Claimed %u tasks of %u\", _num_claimed, _num_tasks);\n+  }\n+\n+  \/\/ Attempt to claim the next unclaimed task in the sequence,\n+  \/\/ returning true if successful, with t set to the index of the\n+  \/\/ claimed task. Returns false if there are no more unclaimed tasks\n+  \/\/ in the sequence. In this case t is undefined.\n+  bool try_claim_task(uint& t);\n+};\n+\n+#endif \/\/ SHARE_GC_SHARED_WORKERUTILS_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/workerUtils.hpp","additions":148,"deletions":0,"binary":false,"changes":148,"status":"added"},{"patch":"@@ -1,351 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"gc\/shared\/gcId.hpp\"\n-#include \"gc\/shared\/workgroup.hpp\"\n-#include \"gc\/shared\/workerManager.hpp\"\n-#include \"memory\/allocation.hpp\"\n-#include \"memory\/allocation.inline.hpp\"\n-#include \"memory\/iterator.hpp\"\n-#include \"runtime\/atomic.hpp\"\n-#include \"runtime\/os.hpp\"\n-#include \"runtime\/semaphore.hpp\"\n-#include \"runtime\/thread.inline.hpp\"\n-\n-\/\/ WorkGang dispatcher implemented with semaphores.\n-\/\/\n-\/\/ Semaphores don't require the worker threads to re-claim the lock when they wake up.\n-\/\/ This helps lowering the latency when starting and stopping the worker threads.\n-class GangTaskDispatcher : public CHeapObj<mtGC> {\n-  \/\/ The task currently being dispatched to the GangWorkers.\n-  AbstractGangTask* _task;\n-\n-  volatile uint _started;\n-  volatile uint _not_finished;\n-\n-  \/\/ Semaphore used to start the GangWorkers.\n-  Semaphore* _start_semaphore;\n-  \/\/ Semaphore used to notify the coordinator that all workers are done.\n-  Semaphore* _end_semaphore;\n-\n-public:\n-  GangTaskDispatcher() :\n-      _task(NULL),\n-      _started(0),\n-      _not_finished(0),\n-      _start_semaphore(new Semaphore()),\n-      _end_semaphore(new Semaphore())\n-{ }\n-\n-  ~GangTaskDispatcher() {\n-    delete _start_semaphore;\n-    delete _end_semaphore;\n-  }\n-\n-  \/\/ Coordinator API.\n-\n-  \/\/ Distributes the task out to num_workers workers.\n-  \/\/ Returns when the task has been completed by all workers.\n-  void coordinator_execute_on_workers(AbstractGangTask* task, uint num_workers) {\n-    \/\/ No workers are allowed to read the state variables until they have been signaled.\n-    _task         = task;\n-    _not_finished = num_workers;\n-\n-    \/\/ Dispatch 'num_workers' number of tasks.\n-    _start_semaphore->signal(num_workers);\n-\n-    \/\/ Wait for the last worker to signal the coordinator.\n-    _end_semaphore->wait();\n-\n-    \/\/ No workers are allowed to read the state variables after the coordinator has been signaled.\n-    assert(_not_finished == 0, \"%d not finished workers?\", _not_finished);\n-    _task    = NULL;\n-    _started = 0;\n-\n-  }\n-\n-  \/\/ Worker API.\n-\n-  \/\/ Waits for a task to become available to the worker.\n-  \/\/ Returns when the worker has been assigned a task.\n-  WorkData worker_wait_for_task() {\n-    \/\/ Wait for the coordinator to dispatch a task.\n-    _start_semaphore->wait();\n-\n-    uint num_started = Atomic::add(&_started, 1u);\n-\n-    \/\/ Subtract one to get a zero-indexed worker id.\n-    uint worker_id = num_started - 1;\n-\n-    return WorkData(_task, worker_id);\n-  }\n-\n-  \/\/ Signal to the coordinator that the worker is done with the assigned task.\n-  void worker_done_with_task() {\n-    \/\/ Mark that the worker is done with the task.\n-    \/\/ The worker is not allowed to read the state variables after this line.\n-    uint not_finished = Atomic::sub(&_not_finished, 1u);\n-\n-    \/\/ The last worker signals to the coordinator that all work is completed.\n-    if (not_finished == 0) {\n-      _end_semaphore->signal();\n-    }\n-  }\n-};\n-\/\/ Definitions of WorkGang methods.\n-\n-WorkGang::WorkGang(const char* name, uint workers) :\n-    _workers(NULL),\n-    _total_workers(workers),\n-    _active_workers(UseDynamicNumberOfGCThreads ? 1U : workers),\n-    _created_workers(0),\n-    _name(name),\n-    _dispatcher(new GangTaskDispatcher())\n-  { }\n-\n-WorkGang::~WorkGang() {\n-  delete _dispatcher;\n-}\n-\n-\/\/ The current implementation will exit if the allocation\n-\/\/ of any worker fails.\n-void WorkGang::initialize_workers() {\n-  log_develop_trace(gc, workgang)(\"Constructing work gang %s with %u threads\", name(), total_workers());\n-  _workers = NEW_C_HEAP_ARRAY(GangWorker*, total_workers(), mtInternal);\n-  add_workers(true);\n-}\n-\n-\n-GangWorker* WorkGang::install_worker(uint worker_id) {\n-  GangWorker* new_worker = allocate_worker(worker_id);\n-  set_thread(worker_id, new_worker);\n-  return new_worker;\n-}\n-\n-void WorkGang::add_workers(bool initializing) {\n-  uint previous_created_workers = _created_workers;\n-\n-  _created_workers = WorkerManager::add_workers(this,\n-                                                _active_workers,\n-                                                _total_workers,\n-                                                _created_workers,\n-                                                os::gc_thread,\n-                                                initializing);\n-  _active_workers = MIN2(_created_workers, _active_workers);\n-\n-  WorkerManager::log_worker_creation(this, previous_created_workers, _active_workers, _created_workers, initializing);\n-}\n-\n-GangWorker* WorkGang::worker(uint i) const {\n-  \/\/ Array index bounds checking.\n-  GangWorker* result = NULL;\n-  assert(_workers != NULL, \"No workers for indexing\");\n-  assert(i < total_workers(), \"Worker index out of bounds\");\n-  result = _workers[i];\n-  assert(result != NULL, \"Indexing to null worker\");\n-  return result;\n-}\n-\n-void WorkGang::threads_do(ThreadClosure* tc) const {\n-  assert(tc != NULL, \"Null ThreadClosure\");\n-  uint workers = created_workers();\n-  for (uint i = 0; i < workers; i++) {\n-    tc->do_thread(worker(i));\n-  }\n-}\n-\n-GangWorker* WorkGang::allocate_worker(uint worker_id) {\n-  return new GangWorker(this, worker_id);\n-}\n-\n-void WorkGang::run_task(AbstractGangTask* task) {\n-  run_task(task, active_workers());\n-}\n-\n-void WorkGang::run_task(AbstractGangTask* task, uint num_workers) {\n-  guarantee(num_workers <= total_workers(),\n-            \"Trying to execute task %s with %u workers which is more than the amount of total workers %u.\",\n-            task->name(), num_workers, total_workers());\n-  guarantee(num_workers > 0, \"Trying to execute task %s with zero workers\", task->name());\n-  uint old_num_workers = _active_workers;\n-  update_active_workers(num_workers);\n-  _dispatcher->coordinator_execute_on_workers(task, num_workers);\n-  update_active_workers(old_num_workers);\n-}\n-\n-GangWorker::GangWorker(WorkGang* gang, uint id) {\n-  _gang = gang;\n-  set_id(id);\n-  set_name(\"%s#%d\", gang->name(), id);\n-}\n-\n-void GangWorker::run() {\n-  initialize();\n-  loop();\n-}\n-\n-void GangWorker::initialize() {\n-  assert(_gang != NULL, \"No gang to run in\");\n-  os::set_priority(this, NearMaxPriority);\n-  log_develop_trace(gc, workgang)(\"Running gang worker for gang %s id %u\", gang()->name(), id());\n-  assert(!Thread::current()->is_VM_thread(), \"VM thread should not be part\"\n-         \" of a work gang\");\n-}\n-\n-WorkData GangWorker::wait_for_task() {\n-  return gang()->dispatcher()->worker_wait_for_task();\n-}\n-\n-void GangWorker::signal_task_done() {\n-  gang()->dispatcher()->worker_done_with_task();\n-}\n-\n-void GangWorker::run_task(WorkData data) {\n-  GCIdMark gc_id_mark(data._task->gc_id());\n-  log_develop_trace(gc, workgang)(\"Running work gang: %s task: %s worker: %u\", name(), data._task->name(), data._worker_id);\n-\n-  data._task->work(data._worker_id);\n-\n-  log_develop_trace(gc, workgang)(\"Finished work gang: %s task: %s worker: %u thread: \" PTR_FORMAT,\n-                                  name(), data._task->name(), data._worker_id, p2i(Thread::current()));\n-}\n-\n-void GangWorker::loop() {\n-  while (true) {\n-    WorkData data = wait_for_task();\n-\n-    run_task(data);\n-\n-    signal_task_done();\n-  }\n-}\n-\n-\/\/ *** WorkGangBarrierSync\n-\n-WorkGangBarrierSync::WorkGangBarrierSync()\n-  : _monitor(Mutex::nosafepoint, \"WorkGangBarrierSync_lock\"),\n-    _n_workers(0), _n_completed(0), _should_reset(false), _aborted(false) {\n-}\n-\n-void WorkGangBarrierSync::set_n_workers(uint n_workers) {\n-  _n_workers    = n_workers;\n-  _n_completed  = 0;\n-  _should_reset = false;\n-  _aborted      = false;\n-}\n-\n-bool WorkGangBarrierSync::enter() {\n-  MonitorLocker ml(monitor(), Mutex::_no_safepoint_check_flag);\n-  if (should_reset()) {\n-    \/\/ The should_reset() was set and we are the first worker to enter\n-    \/\/ the sync barrier. We will zero the n_completed() count which\n-    \/\/ effectively resets the barrier.\n-    zero_completed();\n-    set_should_reset(false);\n-  }\n-  inc_completed();\n-  if (n_completed() == n_workers()) {\n-    \/\/ At this point we would like to reset the barrier to be ready in\n-    \/\/ case it is used again. However, we cannot set n_completed() to\n-    \/\/ 0, even after the notify_all(), given that some other workers\n-    \/\/ might still be waiting for n_completed() to become ==\n-    \/\/ n_workers(). So, if we set n_completed() to 0, those workers\n-    \/\/ will get stuck (as they will wake up, see that n_completed() !=\n-    \/\/ n_workers() and go back to sleep). Instead, we raise the\n-    \/\/ should_reset() flag and the barrier will be reset the first\n-    \/\/ time a worker enters it again.\n-    set_should_reset(true);\n-    ml.notify_all();\n-  } else {\n-    while (n_completed() != n_workers() && !aborted()) {\n-      ml.wait();\n-    }\n-  }\n-  return !aborted();\n-}\n-\n-void WorkGangBarrierSync::abort() {\n-  MutexLocker x(monitor(), Mutex::_no_safepoint_check_flag);\n-  set_aborted();\n-  monitor()->notify_all();\n-}\n-\n-\/\/ SubTasksDone functions.\n-\n-SubTasksDone::SubTasksDone(uint n) :\n-  _tasks(NULL), _n_tasks(n) {\n-  _tasks = NEW_C_HEAP_ARRAY(bool, n, mtInternal);\n-  for (uint i = 0; i < _n_tasks; i++) {\n-    _tasks[i] = false;\n-  }\n-}\n-\n-#ifdef ASSERT\n-void SubTasksDone::all_tasks_claimed_impl(uint skipped[], size_t skipped_size) {\n-  if (Atomic::cmpxchg(&_verification_done, false, true)) {\n-    \/\/ another thread has done the verification\n-    return;\n-  }\n-  \/\/ all non-skipped tasks are claimed\n-  for (uint i = 0; i < _n_tasks; ++i) {\n-    if (!_tasks[i]) {\n-      auto is_skipped = false;\n-      for (size_t j = 0; j < skipped_size; ++j) {\n-        if (i == skipped[j]) {\n-          is_skipped = true;\n-          break;\n-        }\n-      }\n-      assert(is_skipped, \"%d not claimed.\", i);\n-    }\n-  }\n-  \/\/ all skipped tasks are *not* claimed\n-  for (size_t i = 0; i < skipped_size; ++i) {\n-    auto task_index = skipped[i];\n-    assert(task_index < _n_tasks, \"Array in range.\");\n-    assert(!_tasks[task_index], \"%d is both claimed and skipped.\", task_index);\n-  }\n-}\n-#endif\n-\n-bool SubTasksDone::try_claim_task(uint t) {\n-  assert(t < _n_tasks, \"bad task id.\");\n-  return !_tasks[t] && !Atomic::cmpxchg(&_tasks[t], false, true);\n-}\n-\n-SubTasksDone::~SubTasksDone() {\n-  assert(_verification_done, \"all_tasks_claimed must have been called.\");\n-  FREE_C_HEAP_ARRAY(bool, _tasks);\n-}\n-\n-\/\/ *** SequentialSubTasksDone\n-\n-bool SequentialSubTasksDone::try_claim_task(uint& t) {\n-  t = _num_claimed;\n-  if (t < _num_tasks) {\n-    t = Atomic::add(&_num_claimed, 1u) - 1;\n-  }\n-  return t < _num_tasks;\n-}\n","filename":"src\/hotspot\/share\/gc\/shared\/workgroup.cpp","additions":0,"deletions":351,"binary":false,"changes":351,"status":"deleted"},{"patch":"@@ -1,328 +0,0 @@\n-\/*\n- * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_SHARED_WORKGROUP_HPP\n-#define SHARE_GC_SHARED_WORKGROUP_HPP\n-\n-#include \"memory\/allocation.hpp\"\n-#include \"metaprogramming\/enableIf.hpp\"\n-#include \"metaprogramming\/logical.hpp\"\n-#include \"runtime\/globals.hpp\"\n-#include \"runtime\/nonJavaThread.hpp\"\n-#include \"runtime\/thread.hpp\"\n-#include \"gc\/shared\/gcId.hpp\"\n-#include \"logging\/log.hpp\"\n-#include \"utilities\/debug.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-\n-\/\/ Task class hierarchy:\n-\/\/   AbstractGangTask\n-\/\/\n-\/\/ Gang\/Group class hierarchy:\n-\/\/   WorkGang\n-\/\/\n-\/\/ Worker class hierarchy:\n-\/\/   GangWorker (subclass of WorkerThread)\n-\n-\/\/ Forward declarations of classes defined here\n-\n-class GangWorker;\n-class Semaphore;\n-class ThreadClosure;\n-class GangTaskDispatcher;\n-\n-\/\/ An abstract task to be worked on by a gang.\n-\/\/ You subclass this to supply your own work() method\n-class AbstractGangTask : public CHeapObj<mtInternal> {\n-  const char* _name;\n-  const uint _gc_id;\n-\n- public:\n-  explicit AbstractGangTask(const char* name) :\n-    _name(name),\n-    _gc_id(GCId::current_or_undefined())\n-  {}\n-\n-  \/\/ The abstract work method.\n-  \/\/ The argument tells you which member of the gang you are.\n-  virtual void work(uint worker_id) = 0;\n-\n-  \/\/ Debugging accessor for the name.\n-  const char* name() const { return _name; }\n-  const uint gc_id() const { return _gc_id; }\n-};\n-\n-struct WorkData {\n-  AbstractGangTask* _task;\n-  uint              _worker_id;\n-  WorkData(AbstractGangTask* task, uint worker_id) : _task(task), _worker_id(worker_id) {}\n-};\n-\n-\/\/ The work gang is the collection of workers to execute tasks.\n-\/\/ The number of workers run for a task is \"_active_workers\"\n-\/\/ while \"_total_workers\" is the number of available workers.\n-class WorkGang : public CHeapObj<mtInternal> {\n-  \/\/ The array of worker threads for this gang.\n-  GangWorker** _workers;\n-  \/\/ The count of the number of workers in the gang.\n-  uint _total_workers;\n-  \/\/ The currently active workers in this gang.\n-  uint _active_workers;\n-  \/\/ The count of created workers in the gang.\n-  uint _created_workers;\n-  \/\/ Printing support.\n-  const char* _name;\n-\n-  \/\/ To get access to the GangTaskDispatcher instance.\n-  friend class GangWorker;\n-  GangTaskDispatcher* const _dispatcher;\n-\n-  GangTaskDispatcher* dispatcher() const { return _dispatcher; }\n-\n-  void set_thread(uint worker_id, GangWorker* worker) {\n-    _workers[worker_id] = worker;\n-  }\n-\n-  \/\/ Add GC workers when _created_workers < _active_workers; otherwise, no-op.\n-  \/\/ If there's no memory\/thread allocation failure, _created_worker is\n-  \/\/ adjusted to match _active_workers (_created_worker == _active_workers).\n-  void add_workers(bool initializing);\n-\n-  GangWorker* allocate_worker(uint which);\n-\n- public:\n-  WorkGang(const char* name, uint workers);\n-\n-  ~WorkGang();\n-\n-  \/\/ Initialize workers in the gang.  Return true if initialization succeeded.\n-  void initialize_workers();\n-\n-  uint total_workers() const { return _total_workers; }\n-\n-  uint created_workers() const {\n-    return _created_workers;\n-  }\n-\n-  uint active_workers() const {\n-    assert(_active_workers != 0, \"zero active workers\");\n-    assert(_active_workers <= _total_workers,\n-           \"_active_workers: %u > _total_workers: %u\", _active_workers, _total_workers);\n-    return _active_workers;\n-  }\n-\n-  uint update_active_workers(uint v) {\n-    assert(v <= _total_workers,\n-           \"Trying to set more workers active than there are\");\n-    assert(v != 0, \"Trying to set active workers to 0\");\n-    _active_workers = v;\n-    add_workers(false \/* initializing *\/);\n-    log_trace(gc, task)(\"%s: using %d out of %d workers\", name(), _active_workers, _total_workers);\n-    return _active_workers;\n-  }\n-\n-  \/\/ Return the Ith worker.\n-  GangWorker* worker(uint i) const;\n-\n-  \/\/ Base name (without worker id #) of threads.\n-  const char* group_name() { return name(); }\n-\n-  void threads_do(ThreadClosure* tc) const;\n-\n-  \/\/ Create a GC worker and install it into the work gang.\n-  virtual GangWorker* install_worker(uint which);\n-\n-  \/\/ Debugging.\n-  const char* name() const { return _name; }\n-\n-  \/\/ Run a task using the current active number of workers, returns when the task is done.\n-  void run_task(AbstractGangTask* task);\n-\n-  \/\/ Run a task with the given number of workers, returns\n-  \/\/ when the task is done. The number of workers must be at most the number of\n-  \/\/ active workers.  Additional workers may be created if an insufficient\n-  \/\/ number currently exists.\n-  void run_task(AbstractGangTask* task, uint num_workers);\n-};\n-\n-\/\/ Temporarily try to set the number of active workers.\n-\/\/ It's not guaranteed that it succeeds, and users need to\n-\/\/ query the number of active workers.\n-class WithUpdatedActiveWorkers : public StackObj {\n-private:\n-  WorkGang* const _gang;\n-  const uint              _old_active_workers;\n-\n-public:\n-  WithUpdatedActiveWorkers(WorkGang* gang, uint requested_num_workers) :\n-      _gang(gang),\n-      _old_active_workers(gang->active_workers()) {\n-    uint capped_num_workers = MIN2(requested_num_workers, gang->total_workers());\n-    gang->update_active_workers(capped_num_workers);\n-  }\n-\n-  ~WithUpdatedActiveWorkers() {\n-    _gang->update_active_workers(_old_active_workers);\n-  }\n-};\n-\n-\/\/ Several instances of this class run in parallel as workers for a gang.\n-class GangWorker: public WorkerThread {\n-private:\n-  WorkGang* _gang;\n-\n-  void initialize();\n-  void loop();\n-\n-  WorkGang* gang() const { return _gang; }\n-\n-  WorkData wait_for_task();\n-  void run_task(WorkData work);\n-  void signal_task_done();\n-\n-protected:\n-  \/\/ The only real method: run a task for the gang.\n-  void run() override;\n-\n-public:\n-  GangWorker(WorkGang* gang, uint id);\n-\n-  \/\/ Printing\n-  const char* type_name() const override { return \"GCTaskThread\"; }\n-};\n-\n-\/\/ A class that acts as a synchronisation barrier. Workers enter\n-\/\/ the barrier and must wait until all other workers have entered\n-\/\/ before any of them may leave.\n-\n-class WorkGangBarrierSync : public StackObj {\n-protected:\n-  Monitor _monitor;\n-  uint    _n_workers;\n-  uint    _n_completed;\n-  bool    _should_reset;\n-  bool    _aborted;\n-\n-  Monitor* monitor()        { return &_monitor; }\n-  uint     n_workers()      { return _n_workers; }\n-  uint     n_completed()    { return _n_completed; }\n-  bool     should_reset()   { return _should_reset; }\n-  bool     aborted()        { return _aborted; }\n-\n-  void     zero_completed() { _n_completed = 0; }\n-  void     inc_completed()  { _n_completed++; }\n-  void     set_aborted()    { _aborted = true; }\n-  void     set_should_reset(bool v) { _should_reset = v; }\n-\n-public:\n-  WorkGangBarrierSync();\n-\n-  \/\/ Set the number of workers that will use the barrier.\n-  \/\/ Must be called before any of the workers start running.\n-  void set_n_workers(uint n_workers);\n-\n-  \/\/ Enter the barrier. A worker that enters the barrier will\n-  \/\/ not be allowed to leave until all other threads have\n-  \/\/ also entered the barrier or the barrier is aborted.\n-  \/\/ Returns false if the barrier was aborted.\n-  bool enter();\n-\n-  \/\/ Aborts the barrier and wakes up any threads waiting for\n-  \/\/ the barrier to complete. The barrier will remain in the\n-  \/\/ aborted state until the next call to set_n_workers().\n-  void abort();\n-};\n-\n-\/\/ A class to manage claiming of subtasks within a group of tasks.  The\n-\/\/ subtasks will be identified by integer indices, usually elements of an\n-\/\/ enumeration type.\n-\n-class SubTasksDone: public CHeapObj<mtInternal> {\n-  volatile bool* _tasks;\n-  uint _n_tasks;\n-\n-  \/\/ make sure verification logic is run exactly once to avoid duplicate assertion failures\n-  DEBUG_ONLY(volatile bool _verification_done = false;)\n-  void all_tasks_claimed_impl(uint skipped[], size_t skipped_size) NOT_DEBUG_RETURN;\n-\n-  NONCOPYABLE(SubTasksDone);\n-\n-public:\n-  \/\/ Initializes \"this\" to a state in which there are \"n\" tasks to be\n-  \/\/ processed, none of the which are originally claimed.\n-  SubTasksDone(uint n);\n-\n-  \/\/ Attempt to claim the task \"t\", returning true if successful,\n-  \/\/ false if it has already been claimed.  The task \"t\" is required\n-  \/\/ to be within the range of \"this\".\n-  bool try_claim_task(uint t);\n-\n-  \/\/ The calling thread asserts that it has attempted to claim all the tasks\n-  \/\/ that it will try to claim.  Tasks that are meant to be skipped must be\n-  \/\/ explicitly passed as extra arguments. Every thread in the parallel task\n-  \/\/ must execute this.\n-  template<typename T0, typename... Ts,\n-          ENABLE_IF(Conjunction<std::is_same<T0, Ts>...>::value)>\n-  void all_tasks_claimed(T0 first_skipped, Ts... more_skipped) {\n-    static_assert(std::is_convertible<T0, uint>::value, \"not convertible\");\n-    uint skipped[] = { static_cast<uint>(first_skipped), static_cast<uint>(more_skipped)... };\n-    all_tasks_claimed_impl(skipped, ARRAY_SIZE(skipped));\n-  }\n-  \/\/ if there are no skipped tasks.\n-  void all_tasks_claimed() {\n-    all_tasks_claimed_impl(nullptr, 0);\n-  }\n-\n-  \/\/ Destructor.\n-  ~SubTasksDone();\n-};\n-\n-\/\/ As above, but for sequential tasks, i.e. instead of claiming\n-\/\/ sub-tasks from a set (possibly an enumeration), claim sub-tasks\n-\/\/ in sequential order. This is ideal for claiming dynamically\n-\/\/ partitioned tasks (like striding in the parallel remembered\n-\/\/ set scanning).\n-\n-class SequentialSubTasksDone : public CHeapObj<mtInternal> {\n-\n-  uint _num_tasks;     \/\/ Total number of tasks available.\n-  volatile uint _num_claimed;   \/\/ Number of tasks claimed.\n-\n-  NONCOPYABLE(SequentialSubTasksDone);\n-\n-public:\n-  SequentialSubTasksDone(uint num_tasks) : _num_tasks(num_tasks), _num_claimed(0) { }\n-  ~SequentialSubTasksDone() {\n-    \/\/ Claiming may try to claim more tasks than there are.\n-    assert(_num_claimed >= _num_tasks, \"Claimed %u tasks of %u\", _num_claimed, _num_tasks);\n-  }\n-\n-  \/\/ Attempt to claim the next unclaimed task in the sequence,\n-  \/\/ returning true if successful, with t set to the index of the\n-  \/\/ claimed task. Returns false if there are no more unclaimed tasks\n-  \/\/ in the sequence. In this case t is undefined.\n-  bool try_claim_task(uint& t);\n-};\n-\n-#endif \/\/ SHARE_GC_SHARED_WORKGROUP_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/workgroup.hpp","additions":0,"deletions":328,"binary":false,"changes":328,"status":"deleted"},{"patch":"@@ -156,1 +156,1 @@\n-class ShenandoahDisarmNMethodsTask : public AbstractGangTask {\n+class ShenandoahDisarmNMethodsTask : public WorkerTask {\n@@ -163,1 +163,1 @@\n-    AbstractGangTask(\"Shenandoah Disarm NMethods\"),\n+    WorkerTask(\"Shenandoah Disarm NMethods\"),\n@@ -261,1 +261,1 @@\n-class ShenandoahUnlinkTask : public AbstractGangTask {\n+class ShenandoahUnlinkTask : public WorkerTask {\n@@ -269,1 +269,1 @@\n-    AbstractGangTask(\"Shenandoah Unlink NMethods\"),\n+    WorkerTask(\"Shenandoah Unlink NMethods\"),\n@@ -292,1 +292,1 @@\n-void ShenandoahCodeRoots::unlink(WorkGang* workers, bool unloading_occurred) {\n+void ShenandoahCodeRoots::unlink(WorkerThreads* workers, bool unloading_occurred) {\n@@ -323,1 +323,1 @@\n-class ShenandoahNMethodPurgeTask : public AbstractGangTask {\n+class ShenandoahNMethodPurgeTask : public WorkerTask {\n@@ -330,1 +330,1 @@\n-    AbstractGangTask(\"Shenandoah Purge NMethods\"),\n+    WorkerTask(\"Shenandoah Purge NMethods\"),\n@@ -347,1 +347,1 @@\n-void ShenandoahCodeRoots::purge(WorkGang* workers) {\n+void ShenandoahCodeRoots::purge(WorkerThreads* workers) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCodeRoots.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-class WorkGang;\n+class WorkerThreads;\n@@ -98,2 +98,2 @@\n-  static void unlink(WorkGang* workers, bool unloading_occurred);\n-  static void purge(WorkGang* workers);\n+  static void unlink(WorkerThreads* workers, bool unloading_occurred);\n+  static void purge(WorkerThreads* workers);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCodeRoots.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -628,1 +628,1 @@\n-class ShenandoahConcurrentEvacUpdateThreadTask : public AbstractGangTask {\n+class ShenandoahConcurrentEvacUpdateThreadTask : public WorkerTask {\n@@ -634,1 +634,1 @@\n-    AbstractGangTask(\"Shenandoah Evacuate\/Update Concurrent Thread Roots\"),\n+    WorkerTask(\"Shenandoah Evacuate\/Update Concurrent Thread Roots\"),\n@@ -723,1 +723,1 @@\n-class ShenandoahConcurrentWeakRootsEvacUpdateTask : public AbstractGangTask {\n+class ShenandoahConcurrentWeakRootsEvacUpdateTask : public WorkerTask {\n@@ -735,1 +735,1 @@\n-    AbstractGangTask(\"Shenandoah Evacuate\/Update Concurrent Weak Roots\"),\n+    WorkerTask(\"Shenandoah Evacuate\/Update Concurrent Weak Roots\"),\n@@ -837,1 +837,1 @@\n-class ShenandoahConcurrentRootsEvacUpdateTask : public AbstractGangTask {\n+class ShenandoahConcurrentRootsEvacUpdateTask : public WorkerTask {\n@@ -847,1 +847,1 @@\n-    AbstractGangTask(\"Shenandoah Evacuate\/Update Concurrent Strong Roots\"),\n+    WorkerTask(\"Shenandoah Evacuate\/Update Concurrent Strong Roots\"),\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-class ShenandoahConcurrentMarkingTask : public AbstractGangTask {\n+class ShenandoahConcurrentMarkingTask : public WorkerTask {\n@@ -52,1 +52,1 @@\n-    AbstractGangTask(\"Shenandoah Concurrent Mark\"), _cm(cm), _terminator(terminator) {\n+    WorkerTask(\"Shenandoah Concurrent Mark\"), _cm(cm), _terminator(terminator) {\n@@ -96,1 +96,1 @@\n-class ShenandoahFinalMarkingTask : public AbstractGangTask {\n+class ShenandoahFinalMarkingTask : public WorkerTask {\n@@ -104,1 +104,1 @@\n-    AbstractGangTask(\"Shenandoah Final Mark\"), _cm(cm), _terminator(terminator), _dedup_string(dedup_string) {\n+    WorkerTask(\"Shenandoah Final Mark\"), _cm(cm), _terminator(terminator), _dedup_string(dedup_string) {\n@@ -140,1 +140,1 @@\n-class ShenandoahMarkConcurrentRootsTask : public AbstractGangTask {\n+class ShenandoahMarkConcurrentRootsTask : public WorkerTask {\n@@ -159,1 +159,1 @@\n-  AbstractGangTask(\"Shenandoah Concurrent Mark Roots\"),\n+  WorkerTask(\"Shenandoah Concurrent Mark Roots\"),\n@@ -179,1 +179,1 @@\n-  WorkGang* workers = heap->workers();\n+  WorkerThreads* workers = heap->workers();\n@@ -202,1 +202,1 @@\n-  WorkGang* workers = heap->workers();\n+  WorkerThreads* workers = heap->workers();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentMark.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"gc\/shared\/workerThread.hpp\"\n@@ -62,1 +63,0 @@\n-#include \"gc\/shared\/workgroup.hpp\"\n@@ -366,1 +366,1 @@\n-class ShenandoahPrepareForCompactionTask : public AbstractGangTask {\n+class ShenandoahPrepareForCompactionTask : public WorkerTask {\n@@ -374,1 +374,1 @@\n-    AbstractGangTask(\"Shenandoah Prepare For Compaction\"),\n+    WorkerTask(\"Shenandoah Prepare For Compaction\"),\n@@ -760,1 +760,1 @@\n-class ShenandoahAdjustPointersTask : public AbstractGangTask {\n+class ShenandoahAdjustPointersTask : public WorkerTask {\n@@ -767,1 +767,1 @@\n-    AbstractGangTask(\"Shenandoah Adjust Pointers\"),\n+    WorkerTask(\"Shenandoah Adjust Pointers\"),\n@@ -784,1 +784,1 @@\n-class ShenandoahAdjustRootPointersTask : public AbstractGangTask {\n+class ShenandoahAdjustRootPointersTask : public WorkerTask {\n@@ -790,1 +790,1 @@\n-    AbstractGangTask(\"Shenandoah Adjust Root Pointers\"),\n+    WorkerTask(\"Shenandoah Adjust Root Pointers\"),\n@@ -808,1 +808,1 @@\n-  WorkGang* workers = heap->workers();\n+  WorkerThreads* workers = heap->workers();\n@@ -848,1 +848,1 @@\n-class ShenandoahCompactObjectsTask : public AbstractGangTask {\n+class ShenandoahCompactObjectsTask : public WorkerTask {\n@@ -855,1 +855,1 @@\n-    AbstractGangTask(\"Shenandoah Compact Objects\"),\n+    WorkerTask(\"Shenandoah Compact Objects\"),\n@@ -998,1 +998,1 @@\n-class ShenandoahMCResetCompleteBitmapTask : public AbstractGangTask {\n+class ShenandoahMCResetCompleteBitmapTask : public WorkerTask {\n@@ -1004,1 +1004,1 @@\n-    AbstractGangTask(\"Shenandoah Reset Bitmap\") {\n+    WorkerTask(\"Shenandoah Reset Bitmap\") {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"gc\/shared\/workgroup.hpp\"\n+#include \"gc\/shared\/workerThread.hpp\"\n@@ -54,1 +54,1 @@\n-class ShenandoahUpdateRootsTask : public AbstractGangTask {\n+class ShenandoahUpdateRootsTask : public WorkerTask {\n@@ -60,1 +60,1 @@\n-    AbstractGangTask(\"Shenandoah Update Roots\"),\n+    WorkerTask(\"Shenandoah Update Roots\"),\n@@ -98,1 +98,1 @@\n-  WorkGang* workers = heap->workers();\n+  WorkerThreads* workers = heap->workers();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGC.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -91,1 +91,1 @@\n-class ShenandoahPretouchHeapTask : public AbstractGangTask {\n+class ShenandoahPretouchHeapTask : public WorkerTask {\n@@ -97,1 +97,1 @@\n-    AbstractGangTask(\"Shenandoah Pretouch Heap\"),\n+    WorkerTask(\"Shenandoah Pretouch Heap\"),\n@@ -111,1 +111,1 @@\n-class ShenandoahPretouchBitmapTask : public AbstractGangTask {\n+class ShenandoahPretouchBitmapTask : public WorkerTask {\n@@ -119,1 +119,1 @@\n-    AbstractGangTask(\"Shenandoah Pretouch Bitmap\"),\n+    WorkerTask(\"Shenandoah Pretouch Bitmap\"),\n@@ -498,1 +498,1 @@\n-  _workers = new ShenandoahWorkGang(\"Shenandoah GC Threads\", _max_workers);\n+  _workers = new ShenandoahWorkerThreads(\"Shenandoah GC Threads\", _max_workers);\n@@ -506,1 +506,1 @@\n-    _safepoint_workers = new ShenandoahWorkGang(\"Safepoint Cleanup Thread\",\n+    _safepoint_workers = new ShenandoahWorkerThreads(\"Safepoint Cleanup Thread\",\n@@ -516,1 +516,1 @@\n-class ShenandoahResetBitmapTask : public AbstractGangTask {\n+class ShenandoahResetBitmapTask : public WorkerTask {\n@@ -522,1 +522,1 @@\n-    AbstractGangTask(\"Shenandoah Reset Bitmap\") {}\n+    WorkerTask(\"Shenandoah Reset Bitmap\") {}\n@@ -615,1 +615,1 @@\n-  \/\/ Now, we will let WorkGang to initialize gclab when new worker is created.\n+  \/\/ Now, we will let WorkerThreads to initialize gclab when new worker is created.\n@@ -956,1 +956,1 @@\n-class ShenandoahEvacuationTask : public AbstractGangTask {\n+class ShenandoahEvacuationTask : public WorkerTask {\n@@ -965,1 +965,1 @@\n-    AbstractGangTask(\"Shenandoah Evacuation\"),\n+    WorkerTask(\"Shenandoah Evacuation\"),\n@@ -1486,1 +1486,1 @@\n-class ShenandoahParallelHeapRegionTask : public AbstractGangTask {\n+class ShenandoahParallelHeapRegionTask : public WorkerTask {\n@@ -1497,1 +1497,1 @@\n-          AbstractGangTask(\"Shenandoah Parallel Region Operation\"),\n+          WorkerTask(\"Shenandoah Parallel Region Operation\"),\n@@ -2013,1 +2013,1 @@\n-class ShenandoahUpdateHeapRefsTask : public AbstractGangTask {\n+class ShenandoahUpdateHeapRefsTask : public WorkerTask {\n@@ -2019,1 +2019,1 @@\n-    AbstractGangTask(\"Shenandoah Update References\"),\n+    WorkerTask(\"Shenandoah Update References\"),\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-class ShenandoahWorkGang;\n+class ShenandoahWorkerThreads;\n@@ -210,2 +210,2 @@\n-  ShenandoahWorkGang* _workers;\n-  ShenandoahWorkGang* _safepoint_workers;\n+  ShenandoahWorkerThreads* _workers;\n+  ShenandoahWorkerThreads* _safepoint_workers;\n@@ -217,2 +217,2 @@\n-  WorkGang* workers() const;\n-  WorkGang* safepoint_workers();\n+  WorkerThreads* workers() const;\n+  WorkerThreads* safepoint_workers();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-inline WorkGang* ShenandoahHeap::workers() const {\n+inline WorkerThreads* ShenandoahHeap::workers() const {\n@@ -71,1 +71,1 @@\n-inline WorkGang* ShenandoahHeap::safepoint_workers() {\n+inline WorkerThreads* ShenandoahHeap::safepoint_workers() {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-  AbstractGangTask(\"Shenandoah Class Unloading\"),\n+  WorkerTask(\"Shenandoah Class Unloading\"),\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahParallelCleaning.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"gc\/shared\/workgroup.hpp\"\n+#include \"gc\/shared\/workerThread.hpp\"\n@@ -36,1 +36,1 @@\n-class ShenandoahParallelWeakRootsCleaningTask : public AbstractGangTask {\n+class ShenandoahParallelWeakRootsCleaningTask : public WorkerTask {\n@@ -54,1 +54,1 @@\n-class ShenandoahClassUnloadingTask : public AbstractGangTask {\n+class ShenandoahClassUnloadingTask : public WorkerTask {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahParallelCleaning.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-  AbstractGangTask(\"Shenandoah Weak Root Cleaning\"),\n+  WorkerTask(\"Shenandoah Weak Root Cleaning\"),\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahParallelCleaning.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -467,1 +467,1 @@\n-class ShenandoahReferenceProcessorTask : public AbstractGangTask {\n+class ShenandoahReferenceProcessorTask : public WorkerTask {\n@@ -475,1 +475,1 @@\n-    AbstractGangTask(\"ShenandoahReferenceProcessorTask\"),\n+    WorkerTask(\"ShenandoahReferenceProcessorTask\"),\n@@ -494,1 +494,1 @@\n-void ShenandoahReferenceProcessor::process_references(ShenandoahPhaseTimings::Phase phase, WorkGang* workers, bool concurrent) {\n+void ShenandoahReferenceProcessor::process_references(ShenandoahPhaseTimings::Phase phase, WorkerThreads* workers, bool concurrent) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahReferenceProcessor.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-class WorkGang;\n+class WorkerThreads;\n@@ -182,1 +182,1 @@\n-  void process_references(ShenandoahPhaseTimings::Phase phase, WorkGang* workers, bool concurrent);\n+  void process_references(ShenandoahPhaseTimings::Phase phase, WorkerThreads* workers, bool concurrent);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahReferenceProcessor.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"gc\/shared\/workgroup.hpp\"\n+#include \"gc\/shared\/workerThread.hpp\"\n@@ -63,1 +63,1 @@\n-class ShenandoahSTWMarkTask : public AbstractGangTask {\n+class ShenandoahSTWMarkTask : public WorkerTask {\n@@ -73,1 +73,1 @@\n-  AbstractGangTask(\"Shenandoah STW mark\"),\n+  WorkerTask(\"Shenandoah STW mark\"),\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahSTWMark.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -424,1 +424,1 @@\n-class ShenandoahVerifierReachableTask : public AbstractGangTask {\n+class ShenandoahVerifierReachableTask : public WorkerTask {\n@@ -438,1 +438,1 @@\n-    AbstractGangTask(\"Shenandoah Verifier Reachable Objects\"),\n+    WorkerTask(\"Shenandoah Verifier Reachable Objects\"),\n@@ -487,1 +487,1 @@\n-class ShenandoahVerifierMarkedRegionTask : public AbstractGangTask {\n+class ShenandoahVerifierMarkedRegionTask : public WorkerTask {\n@@ -502,1 +502,1 @@\n-          AbstractGangTask(\"Shenandoah Verifier Marked Objects\"),\n+          WorkerTask(\"Shenandoah Verifier Marked Objects\"),\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVerifier.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-ShenandoahWorkerScope::ShenandoahWorkerScope(WorkGang* workers, uint nworkers, const char* msg, bool check) :\n+ShenandoahWorkerScope::ShenandoahWorkerScope(WorkerThreads* workers, uint nworkers, const char* msg, bool check) :\n@@ -38,1 +38,1 @@\n-  _n_workers = _workers->update_active_workers(nworkers);\n+  _n_workers = _workers->set_active_workers(nworkers);\n@@ -54,1 +54,1 @@\n-ShenandoahPushWorkerScope::ShenandoahPushWorkerScope(WorkGang* workers, uint nworkers, bool check) :\n+ShenandoahPushWorkerScope::ShenandoahPushWorkerScope(WorkerThreads* workers, uint nworkers, bool check) :\n@@ -57,1 +57,1 @@\n-  _n_workers = _workers->update_active_workers(nworkers);\n+  _n_workers = _workers->set_active_workers(nworkers);\n@@ -70,1 +70,1 @@\n-  uint nworkers = _workers->update_active_workers(_old_workers);\n+  uint nworkers = _workers->set_active_workers(_old_workers);\n@@ -74,2 +74,2 @@\n-GangWorker* ShenandoahWorkGang::install_worker(uint which) {\n-  GangWorker* worker = WorkGang::install_worker(which);\n+WorkerThread* ShenandoahWorkerThreads::create_worker(uint id) {\n+  WorkerThread* worker = WorkerThreads::create_worker(id);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahWorkGroup.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"gc\/shared\/workgroup.hpp\"\n+#include \"gc\/shared\/workerThread.hpp\"\n@@ -37,1 +37,1 @@\n-  WorkGang* _workers;\n+  WorkerThreads* _workers;\n@@ -39,1 +39,1 @@\n-  ShenandoahWorkerScope(WorkGang* workers, uint nworkers, const char* msg, bool do_check = true);\n+  ShenandoahWorkerScope(WorkerThreads* workers, uint nworkers, const char* msg, bool do_check = true);\n@@ -47,1 +47,1 @@\n-  WorkGang* _workers;\n+  WorkerThreads* _workers;\n@@ -50,1 +50,1 @@\n-  ShenandoahPushWorkerScope(WorkGang* workers, uint nworkers, bool do_check = true);\n+  ShenandoahPushWorkerScope(WorkerThreads* workers, uint nworkers, bool do_check = true);\n@@ -54,1 +54,1 @@\n-class ShenandoahWorkGang : public WorkGang {\n+class ShenandoahWorkerThreads : public WorkerThreads {\n@@ -58,1 +58,1 @@\n-  ShenandoahWorkGang(const char* name,\n+  ShenandoahWorkerThreads(const char* name,\n@@ -60,1 +60,1 @@\n-    WorkGang(name, workers), _initialize_gclab(false) {\n+    WorkerThreads(name, workers), _initialize_gclab(false) {\n@@ -63,1 +63,1 @@\n-  \/\/ Create a GC worker and install it into the work gang.\n+  \/\/ Create a GC worker.\n@@ -65,1 +65,1 @@\n-  GangWorker* install_worker(uint which);\n+  WorkerThread* create_worker(uint id);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahWorkGroup.hpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -269,1 +269,1 @@\n-WorkGang* ZCollectedHeap::safepoint_workers() {\n+WorkerThreads* ZCollectedHeap::safepoint_workers() {\n","filename":"src\/hotspot\/share\/gc\/z\/zCollectedHeap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -107,1 +107,1 @@\n-  virtual WorkGang* safepoint_workers();\n+  virtual WorkerThreads* safepoint_workers();\n","filename":"src\/hotspot\/share\/gc\/z\/zCollectedHeap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-class ZRuntimeWorkersInitializeTask : public AbstractGangTask {\n+class ZRuntimeWorkersInitializeTask : public WorkerTask {\n@@ -41,1 +41,1 @@\n-      AbstractGangTask(\"ZRuntimeWorkersInitializeTask\"),\n+      WorkerTask(\"ZRuntimeWorkersInitializeTask\"),\n@@ -64,1 +64,1 @@\n-  log_info_p(gc, init)(\"Runtime Workers: %u\", _workers.total_workers());\n+  log_info_p(gc, init)(\"Runtime Workers: %u\", _workers.max_workers());\n@@ -68,2 +68,2 @@\n-  _workers.update_active_workers(_workers.total_workers());\n-  if (_workers.active_workers() != _workers.total_workers()) {\n+  _workers.set_active_workers(_workers.max_workers());\n+  if (_workers.active_workers() != _workers.max_workers()) {\n@@ -75,1 +75,1 @@\n-  ZRuntimeWorkersInitializeTask task(_workers.total_workers());\n+  ZRuntimeWorkersInitializeTask task(_workers.max_workers());\n@@ -79,1 +79,1 @@\n-WorkGang* ZRuntimeWorkers::workers() {\n+WorkerThreads* ZRuntimeWorkers::workers() {\n","filename":"src\/hotspot\/share\/gc\/z\/zRuntimeWorkers.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-#include \"gc\/shared\/workgroup.hpp\"\n+#include \"gc\/shared\/workerThread.hpp\"\n@@ -33,1 +33,1 @@\n-  WorkGang _workers;\n+  WorkerThreads _workers;\n@@ -38,1 +38,1 @@\n-  WorkGang* workers();\n+  WorkerThreads* workers();\n","filename":"src\/hotspot\/share\/gc\/z\/zRuntimeWorkers.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,3 +28,3 @@\n-ZTask::GangTask::GangTask(ZTask* ztask, const char* name) :\n-    AbstractGangTask(name),\n-    _ztask(ztask) {}\n+ZTask::Task::Task(ZTask* task, const char* name) :\n+    WorkerTask(name),\n+    _task(task) {}\n@@ -32,1 +32,1 @@\n-void ZTask::GangTask::work(uint worker_id) {\n+void ZTask::Task::work(uint worker_id) {\n@@ -34,1 +34,1 @@\n-  _ztask->work();\n+  _task->work();\n@@ -39,1 +39,1 @@\n-    _gang_task(this, name) {}\n+    _worker_task(this, name) {}\n@@ -42,1 +42,1 @@\n-  return _gang_task.name();\n+  return _worker_task.name();\n@@ -45,2 +45,2 @@\n-AbstractGangTask* ZTask::gang_task() {\n-  return &_gang_task;\n+WorkerTask* ZTask::worker_task() {\n+  return &_worker_task;\n","filename":"src\/hotspot\/share\/gc\/z\/zTask.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-#include \"gc\/shared\/workgroup.hpp\"\n+#include \"gc\/shared\/workerThread.hpp\"\n@@ -32,1 +32,1 @@\n-  class GangTask : public AbstractGangTask {\n+  class Task : public WorkerTask {\n@@ -34,1 +34,1 @@\n-    ZTask* const _ztask;\n+    ZTask* const _task;\n@@ -37,1 +37,1 @@\n-    GangTask(ZTask* ztask, const char* name);\n+    Task(ZTask* task, const char* name);\n@@ -42,1 +42,1 @@\n-  GangTask _gang_task;\n+  Task _worker_task;\n@@ -48,1 +48,1 @@\n-  AbstractGangTask* gang_task();\n+  WorkerTask* worker_task();\n","filename":"src\/hotspot\/share\/gc\/z\/zTask.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-class ZWorkersInitializeTask : public AbstractGangTask {\n+class ZWorkersInitializeTask : public WorkerTask {\n@@ -42,1 +42,1 @@\n-      AbstractGangTask(\"ZWorkersInitializeTask\"),\n+      WorkerTask(\"ZWorkersInitializeTask\"),\n@@ -69,1 +69,1 @@\n-    log_info_p(gc, init)(\"GC Workers: %u (dynamic)\", _workers.total_workers());\n+    log_info_p(gc, init)(\"GC Workers: %u (dynamic)\", _workers.max_workers());\n@@ -71,1 +71,1 @@\n-    log_info_p(gc, init)(\"GC Workers: %u\/%u (static)\", ConcGCThreads, _workers.total_workers());\n+    log_info_p(gc, init)(\"GC Workers: %u\/%u (static)\", ConcGCThreads, _workers.max_workers());\n@@ -76,2 +76,2 @@\n-  _workers.update_active_workers(_workers.total_workers());\n-  if (_workers.active_workers() != _workers.total_workers()) {\n+  _workers.set_active_workers(_workers.max_workers());\n+  if (_workers.active_workers() != _workers.max_workers()) {\n@@ -82,1 +82,1 @@\n-  ZWorkersInitializeTask task(_workers.total_workers());\n+  ZWorkersInitializeTask task(_workers.max_workers());\n@@ -92,1 +92,1 @@\n-  _workers.update_active_workers(nworkers);\n+  _workers.set_active_workers(nworkers);\n@@ -98,1 +98,1 @@\n-  _workers.run_task(task->gang_task());\n+  _workers.run_task(task->worker_task());\n@@ -107,1 +107,1 @@\n-  _workers.update_active_workers(_workers.total_workers());\n+  _workers.set_active_workers(_workers.max_workers());\n@@ -109,1 +109,1 @@\n-  _workers.run_task(task->gang_task());\n+  _workers.run_task(task->worker_task());\n@@ -112,1 +112,1 @@\n-  _workers.update_active_workers(prev_active_workers);\n+  _workers.set_active_workers(prev_active_workers);\n","filename":"src\/hotspot\/share\/gc\/z\/zWorkers.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-#include \"gc\/shared\/workgroup.hpp\"\n+#include \"gc\/shared\/workerThread.hpp\"\n@@ -34,1 +34,1 @@\n-  WorkGang _workers;\n+  WorkerThreads _workers;\n","filename":"src\/hotspot\/share\/gc\/z\/zWorkers.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -97,2 +97,1 @@\n-  LOG_PREFIX(GCId::print_prefix, LOG_TAGS(gc, verify, start)) \\\n-  LOG_PREFIX(GCId::print_prefix, LOG_TAGS(gc, workgang))\n+  LOG_PREFIX(GCId::print_prefix, LOG_TAGS(gc, verify, start))\n","filename":"src\/hotspot\/share\/logging\/logPrefix.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -199,2 +199,1 @@\n-  LOG_TAG(vtablestubs) \\\n-  LOG_TAG(workgang)\n+  LOG_TAG(vtablestubs)\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -580,3 +580,3 @@\n-    WorkGang* gang = Universe::heap()->safepoint_workers();\n-    if (gang != NULL) {\n-      \/\/ The GC provided a WorkGang to be used during a safepoint.\n+    WorkerThreads* workers = Universe::heap()->safepoint_workers();\n+    if (workers != NULL) {\n+      \/\/ The GC provided a WorkerThreads to be used during a safepoint.\n@@ -584,2 +584,3 @@\n-      \/\/ Can't run with more threads than provided by the WorkGang.\n-      WithUpdatedActiveWorkers update_and_restore(gang, parallel_thread_num);\n+      \/\/ Can't run with more threads than provided by the WorkerThreads.\n+      const uint capped_parallel_thread_num = MIN2(parallel_thread_num, workers->max_workers());\n+      WithActiveWorkers with_active_workers(workers, capped_parallel_thread_num);\n@@ -587,1 +588,1 @@\n-      ParallelObjectIterator* poi = Universe::heap()->parallel_object_iterator(gang->active_workers());\n+      ParallelObjectIterator* poi = Universe::heap()->parallel_object_iterator(workers->active_workers());\n@@ -593,1 +594,1 @@\n-        gang->run_task(&task);\n+        workers->run_task(&task);\n","filename":"src\/hotspot\/share\/memory\/heapInspection.cpp","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/shared\/workerThread.hpp\"\n@@ -33,1 +34,0 @@\n-#include \"gc\/shared\/workgroup.hpp\"\n@@ -229,1 +229,1 @@\n-class ParHeapInspectTask : public AbstractGangTask {\n+class ParHeapInspectTask : public WorkerTask {\n@@ -242,1 +242,1 @@\n-      AbstractGangTask(\"Iterating heap\"),\n+      WorkerTask(\"Iterating heap\"),\n","filename":"src\/hotspot\/share\/memory\/heapInspection.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -104,25 +104,0 @@\n-\/\/ Worker threads are named and have an id of an assigned work.\n-class WorkerThread: public NamedThread {\n- private:\n-  uint _id;\n- public:\n-  static WorkerThread* current() {\n-    return WorkerThread::cast(Thread::current());\n-  }\n-\n-  static WorkerThread* cast(Thread* t) {\n-    assert(t->is_Worker_thread(), \"incorrect cast to WorkerThread\");\n-    return static_cast<WorkerThread*>(t);\n-  }\n-\n-  WorkerThread() : _id(0)               { }\n-  virtual bool is_Worker_thread() const { return true; }\n-\n-  void set_id(uint work_id)             { _id = work_id; }\n-  uint id() const                       { return _id; }\n-\n-  \/\/ Printing\n-  virtual const char* type_name() const { return \"WorkerThread\"; }\n-\n-};\n-\n","filename":"src\/hotspot\/share\/runtime\/nonJavaThread.hpp","additions":0,"deletions":25,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -40,1 +40,2 @@\n-#include \"gc\/shared\/workgroup.hpp\"\n+#include \"gc\/shared\/workerThread.hpp\"\n+#include \"gc\/shared\/workerUtils.hpp\"\n@@ -518,1 +519,1 @@\n-class ParallelSPCleanupTask : public AbstractGangTask {\n+class ParallelSPCleanupTask : public WorkerTask {\n@@ -542,1 +543,1 @@\n-    AbstractGangTask(\"Parallel Safepoint Cleanup\"),\n+    WorkerTask(\"Parallel Safepoint Cleanup\"),\n@@ -605,1 +606,1 @@\n-  WorkGang* cleanup_workers = heap->safepoint_workers();\n+  WorkerThreads* cleanup_workers = heap->safepoint_workers();\n","filename":"src\/hotspot\/share\/runtime\/safepoint.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-#include \"gc\/shared\/workgroup.hpp\"\n+#include \"gc\/shared\/workerThread.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/sweeper.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -102,1 +102,0 @@\n-\/\/         - GangWorker\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-#include \"gc\/shared\/workgroup.hpp\"\n+#include \"gc\/shared\/workerThread.hpp\"\n@@ -1856,1 +1856,1 @@\n-class VM_HeapDumper : public VM_GC_Operation, public AbstractGangTask {\n+class VM_HeapDumper : public VM_GC_Operation, public WorkerTask {\n@@ -1976,1 +1976,1 @@\n-    AbstractGangTask(\"dump heap\") {\n+    WorkerTask(\"dump heap\") {\n@@ -2251,1 +2251,1 @@\n-  WorkGang* gang = ch->safepoint_workers();\n+  WorkerThreads* workers = ch->safepoint_workers();\n@@ -2253,1 +2253,1 @@\n-  if (gang == NULL) {\n+  if (workers == NULL) {\n@@ -2259,2 +2259,2 @@\n-    prepare_parallel_dump(gang->active_workers());\n-    gang->run_task(this);\n+    prepare_parallel_dump(workers->active_workers());\n+    workers->run_task(this);\n","filename":"src\/hotspot\/share\/services\/heapDumper.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -27,2 +27,2 @@\n-#include \"gc\/g1\/g1BatchedGangTask.hpp\"\n-#include \"gc\/shared\/workgroup.hpp\"\n+#include \"gc\/g1\/g1BatchedTask.hpp\"\n+#include \"gc\/shared\/workerThread.hpp\"\n@@ -32,7 +32,7 @@\n-class G1BatchedGangTaskWorkers : AllStatic {\n-  static WorkGang* _work_gang;\n-  static WorkGang* work_gang() {\n-    if (_work_gang == nullptr) {\n-      _work_gang = new WorkGang(\"G1 Small Workers\", MaxWorkers);\n-      _work_gang->initialize_workers();\n-      _work_gang->update_active_workers(MaxWorkers);\n+class G1BatchedTaskWorkers : AllStatic {\n+  static WorkerThreads* _workers;\n+  static WorkerThreads* workers() {\n+    if (_workers == nullptr) {\n+      _workers = new WorkerThreads(\"G1 Small Workers\", MaxWorkers);\n+      _workers->initialize_workers();\n+      _workers->set_active_workers(MaxWorkers);\n@@ -40,1 +40,1 @@\n-    return _work_gang;\n+    return _workers;\n@@ -45,2 +45,2 @@\n-  static void run_task(AbstractGangTask* task) {\n-    work_gang()->run_task(task);\n+  static void run_task(WorkerTask* task) {\n+    workers()->run_task(task);\n@@ -50,1 +50,1 @@\n-WorkGang* G1BatchedGangTaskWorkers::_work_gang = nullptr;\n+WorkerThreads* G1BatchedTaskWorkers::_workers = nullptr;\n@@ -99,1 +99,1 @@\n-  \/\/ Called by G1BatchedGangTask to provide information about the the maximum\n+  \/\/ Called by G1BatchedTask to provide information about the the maximum\n@@ -143,1 +143,1 @@\n-class G1TestBatchedGangTask : public G1BatchedGangTask {\n+class G1TestBatchedTask : public G1BatchedTask {\n@@ -145,1 +145,1 @@\n-  G1TestBatchedGangTask() : G1BatchedGangTask(\"Batched Gang Test Task\", nullptr) {\n+  G1TestBatchedTask() : G1BatchedTask(\"Batched Test Task\", nullptr) {\n@@ -151,2 +151,2 @@\n-TEST_VM(G1BatchedGangTask, check) {\n-  G1TestBatchedGangTask task;\n+TEST_VM(G1BatchedTask, check) {\n+  G1TestBatchedTask task;\n@@ -155,2 +155,2 @@\n-  task.set_max_workers(G1BatchedGangTaskWorkers::MaxWorkers);\n-  G1BatchedGangTaskWorkers::run_task(&task);\n+  task.set_max_workers(G1BatchedTaskWorkers::MaxWorkers);\n+  G1BatchedTaskWorkers::run_task(&task);\n","filename":"test\/hotspot\/gtest\/gc\/g1\/test_g1BatchedGangTask.cpp","additions":20,"deletions":20,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"gc\/shared\/workgroup.hpp\"\n+#include \"gc\/shared\/workerThread.hpp\"\n@@ -47,1 +47,1 @@\n-  static WorkGang* _workers;\n+  static WorkerThreads* _workers;\n@@ -50,1 +50,1 @@\n-  static WorkGang* workers() {\n+  static WorkerThreads* workers() {\n@@ -53,1 +53,1 @@\n-      _workers = new WorkGang(\"G1CardSetTest Work Gang\", _max_workers);\n+      _workers = new WorkerThreads(\"G1CardSetTest Workers\", _max_workers);\n@@ -55,1 +55,1 @@\n-      _workers->update_active_workers(_max_workers);\n+      _workers->set_active_workers(_max_workers);\n@@ -88,1 +88,1 @@\n-WorkGang* G1CardSetTest::_workers = NULL;\n+WorkerThreads* G1CardSetTest::_workers = NULL;\n@@ -379,1 +379,1 @@\n-class G1CardSetMtTestTask : public AbstractGangTask {\n+class G1CardSetMtTestTask : public WorkerTask {\n@@ -387,1 +387,1 @@\n-    AbstractGangTask(\"\"),\n+    WorkerTask(\"\"),\n","filename":"test\/hotspot\/gtest\/gc\/g1\/test_g1CardSet.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"gc\/shared\/workgroup.hpp\"\n+#include \"gc\/shared\/workerThread.hpp\"\n@@ -35,6 +35,6 @@\n-  static WorkGang* _work_gang;\n-  static WorkGang* work_gang() {\n-    if (_work_gang == NULL) {\n-      _work_gang = new WorkGang(\"G1 Small Workers\", MaxWorkers);\n-      _work_gang->initialize_workers();\n-      _work_gang->update_active_workers(MaxWorkers);\n+  static WorkerThreads* _workers;\n+  static WorkerThreads* workers() {\n+    if (_workers == NULL) {\n+      _workers = new WorkerThreads(\"G1 Small Workers\", MaxWorkers);\n+      _workers->initialize_workers();\n+      _workers->set_active_workers(MaxWorkers);\n@@ -42,1 +42,1 @@\n-    return _work_gang;\n+    return _workers;\n@@ -47,2 +47,2 @@\n-  static void run_task(AbstractGangTask* task) {\n-    work_gang()->run_task(task);\n+  static void run_task(WorkerTask* task) {\n+    workers()->run_task(task);\n@@ -51,1 +51,1 @@\n-WorkGang* G1MapperWorkers::_work_gang = NULL;\n+WorkerThreads* G1MapperWorkers::_workers = NULL;\n@@ -53,1 +53,1 @@\n-class G1TestCommitUncommit : public AbstractGangTask {\n+class G1TestCommitUncommit : public WorkerTask {\n@@ -58,1 +58,1 @@\n-      AbstractGangTask(\"Stress mapper\"),\n+      WorkerTask(\"Stress mapper\"),\n","filename":"test\/hotspot\/gtest\/gc\/g1\/test_stressCommitUncommit.cpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-#include \"gc\/shared\/workgroup.hpp\"\n+#include \"gc\/shared\/workerThread.hpp\"\n@@ -866,1 +866,1 @@\n-  WorkGang* workers();\n+  WorkerThreads* workers();\n@@ -874,1 +874,1 @@\n-  static WorkGang* _workers;\n+  static WorkerThreads* _workers;\n@@ -877,1 +877,1 @@\n-WorkGang* OopStorageTestParIteration::_workers = NULL;\n+WorkerThreads* OopStorageTestParIteration::_workers = NULL;\n@@ -879,1 +879,1 @@\n-WorkGang* OopStorageTestParIteration::workers() {\n+WorkerThreads* OopStorageTestParIteration::workers() {\n@@ -881,1 +881,1 @@\n-    _workers = new WorkGang(\"OopStorageTestParIteration workers\", _max_workers);\n+    _workers = new WorkerThreads(\"OopStorageTestParIteration workers\", _max_workers);\n@@ -883,1 +883,1 @@\n-    _workers->update_active_workers(_max_workers);\n+    _workers->set_active_workers(_max_workers);\n@@ -889,1 +889,1 @@\n-class OopStorageTestParIteration::Task : public AbstractGangTask {\n+class OopStorageTestParIteration::Task : public WorkerTask {\n@@ -898,1 +898,1 @@\n-    AbstractGangTask(name),\n+    WorkerTask(name),\n@@ -914,1 +914,1 @@\n-class OopStorageTestParIteration::TaskUsingOopsDo : public AbstractGangTask {\n+class OopStorageTestParIteration::TaskUsingOopsDo : public WorkerTask {\n@@ -917,1 +917,1 @@\n-    AbstractGangTask(name),\n+    WorkerTask(name),\n@@ -934,1 +934,1 @@\n-  VM_ParStateVerify(WorkGang* workers, AbstractGangTask* task) :\n+  VM_ParStateVerify(WorkerThreads* workers, WorkerTask* task) :\n@@ -943,2 +943,2 @@\n-  WorkGang* _workers;\n-  AbstractGangTask* _task;\n+  WorkerThreads* _workers;\n+  WorkerTask* _task;\n","filename":"test\/hotspot\/gtest\/gc\/shared\/test_oopStorage.cpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-#include \"gc\/shared\/workgroup.hpp\"\n+#include \"gc\/shared\/workerThread.hpp\"\n@@ -59,1 +59,1 @@\n-  WorkGang* workers() const;\n+  WorkerThreads* workers() const;\n@@ -69,1 +69,1 @@\n-  static WorkGang* _workers;\n+  static WorkerThreads* _workers;\n@@ -75,1 +75,1 @@\n-WorkGang* OopStorageParIterPerf::_workers = NULL;\n+WorkerThreads* OopStorageParIterPerf::_workers = NULL;\n@@ -77,1 +77,1 @@\n-WorkGang* OopStorageParIterPerf::workers() const {\n+WorkerThreads* OopStorageParIterPerf::workers() const {\n@@ -79,1 +79,1 @@\n-    WorkGang* wg = new WorkGang(\"OopStorageParIterPerf workers\", _num_workers);\n+    WorkerThreads* wg = new WorkerThreads(\"OopStorageParIterPerf workers\", _num_workers);\n@@ -81,1 +81,1 @@\n-    wg->update_active_workers(_num_workers);\n+    wg->set_active_workers(_num_workers);\n@@ -102,1 +102,1 @@\n-  VM_ParStateTime(WorkGang* workers, AbstractGangTask* task, uint nthreads) :\n+  VM_ParStateTime(WorkerThreads* workers, WorkerTask* task, uint nthreads) :\n@@ -111,2 +111,2 @@\n-  WorkGang* _workers;\n-  AbstractGangTask* _task;\n+  WorkerThreads* _workers;\n+  WorkerTask* _task;\n@@ -116,1 +116,1 @@\n-class OopStorageParIterPerf::Task : public AbstractGangTask {\n+class OopStorageParIterPerf::Task : public WorkerTask {\n@@ -125,1 +125,1 @@\n-    AbstractGangTask(\"OopStorageParIterPerf::Task\"),\n+    WorkerTask(\"OopStorageParIterPerf::Task\"),\n","filename":"test\/hotspot\/gtest\/gc\/shared\/test_oopStorage_parperf.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"}]}