{"files":[{"patch":"@@ -332,4 +332,0 @@\n-        \/\/ @@@ Smarter alignment checking if accessing heap segment backing non-byte[] array\n-        if (msp.maxAlignMask() > 1) {\n-            throw new IllegalArgumentException();\n-        }\n@@ -377,4 +373,0 @@\n-        \/\/ @@@ Smarter alignment checking if accessing heap segment backing non-byte[] array\n-        if (msp.maxAlignMask() > 1) {\n-            throw new IllegalArgumentException();\n-        }\n@@ -423,4 +415,0 @@\n-        \/\/ @@@ Smarter alignment checking if accessing heap segment backing non-byte[] array\n-        if (msp.maxAlignMask() > 1) {\n-            throw new IllegalArgumentException();\n-        }\n@@ -469,4 +457,0 @@\n-        \/\/ @@@ Smarter alignment checking if accessing heap segment backing non-byte[] array\n-        if (msp.maxAlignMask() > 1) {\n-            throw new IllegalArgumentException();\n-        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/X-ScopedMemoryAccess.java.template","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -28,0 +28,3 @@\n+\n+import jdk.internal.foreign.AbstractMemorySegmentImpl;\n+import jdk.internal.foreign.Utils;\n@@ -31,0 +34,2 @@\n+import java.lang.foreign.ValueLayout;\n+import java.lang.reflect.Array;\n@@ -32,0 +37,1 @@\n+import java.util.Objects;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractVector.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2848,1 +2848,1 @@\n-     * @throws IllegalArgumentException if the index is is out of range\n+     * @throws IllegalArgumentException if the index is out of range\n@@ -2866,1 +2866,1 @@\n-     * @throws IllegalArgumentException if the index is is out of range\n+     * @throws IllegalArgumentException if the index is out of range\n@@ -3284,2 +3284,0 @@\n-     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n-     *         not backed by a {@code byte[]} array.\n@@ -3336,2 +3334,0 @@\n-     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n-     *         not backed by a {@code byte[]} array.\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2662,1 +2662,1 @@\n-     * @throws IllegalArgumentException if the index is is out of range\n+     * @throws IllegalArgumentException if the index is out of range\n@@ -2680,1 +2680,1 @@\n-     * @throws IllegalArgumentException if the index is is out of range\n+     * @throws IllegalArgumentException if the index is out of range\n@@ -2967,2 +2967,0 @@\n-     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n-     *         not backed by a {@code byte[]} array.\n@@ -3024,2 +3022,0 @@\n-     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n-     *         not backed by a {@code byte[]} array.\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2682,1 +2682,1 @@\n-     * @throws IllegalArgumentException if the index is is out of range\n+     * @throws IllegalArgumentException if the index is out of range\n@@ -2700,1 +2700,1 @@\n-     * @throws IllegalArgumentException if the index is is out of range\n+     * @throws IllegalArgumentException if the index is out of range\n@@ -2973,2 +2973,0 @@\n-     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n-     *         not backed by a {@code byte[]} array.\n@@ -3030,2 +3028,0 @@\n-     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n-     *         not backed by a {@code byte[]} array.\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2833,1 +2833,1 @@\n-     * @throws IllegalArgumentException if the index is is out of range\n+     * @throws IllegalArgumentException if the index is out of range\n@@ -2851,1 +2851,1 @@\n-     * @throws IllegalArgumentException if the index is is out of range\n+     * @throws IllegalArgumentException if the index is out of range\n@@ -3129,2 +3129,0 @@\n-     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n-     *         not backed by a {@code byte[]} array.\n@@ -3186,2 +3184,0 @@\n-     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n-     *         not backed by a {@code byte[]} array.\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2699,1 +2699,1 @@\n-     * @throws IllegalArgumentException if the index is is out of range\n+     * @throws IllegalArgumentException if the index is out of range\n@@ -2717,1 +2717,1 @@\n-     * @throws IllegalArgumentException if the index is is out of range\n+     * @throws IllegalArgumentException if the index is out of range\n@@ -3008,2 +3008,0 @@\n-     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n-     *         not backed by a {@code byte[]} array.\n@@ -3065,2 +3063,0 @@\n-     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n-     *         not backed by a {@code byte[]} array.\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2849,1 +2849,1 @@\n-     * @throws IllegalArgumentException if the index is is out of range\n+     * @throws IllegalArgumentException if the index is out of range\n@@ -2867,1 +2867,1 @@\n-     * @throws IllegalArgumentException if the index is is out of range\n+     * @throws IllegalArgumentException if the index is out of range\n@@ -3278,2 +3278,0 @@\n-     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n-     *         not backed by a {@code byte[]} array.\n@@ -3335,2 +3333,0 @@\n-     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n-     *         not backed by a {@code byte[]} array.\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3361,1 +3361,1 @@\n-     * @throws IllegalArgumentException if the index is is out of range\n+     * @throws IllegalArgumentException if the index is out of range\n@@ -3379,1 +3379,1 @@\n-     * @throws IllegalArgumentException if the index is is out of range\n+     * @throws IllegalArgumentException if the index is out of range\n@@ -4080,2 +4080,0 @@\n-     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n-     *         not backed by a {@code byte[]} array.\n@@ -4141,2 +4139,0 @@\n-     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n-     *         not backed by a {@code byte[]} array.\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import java.lang.foreign.ValueLayout;\n@@ -28,0 +29,1 @@\n+import java.nio.IntBuffer;\n@@ -30,0 +32,1 @@\n+import java.util.Objects;\n@@ -32,0 +35,1 @@\n+import java.util.stream.Stream;\n@@ -53,1 +57,1 @@\n-            withToString(\"HMS\", (int s) ->\n+            withToString(\"DMS\", (int s) ->\n@@ -56,1 +60,1 @@\n-            withToString(\"DMS\", (int s) -> {\n+            withToString(\"HMS:byte[]\", (int s) -> {\n@@ -59,0 +63,45 @@\n+            }),\n+            withToString(\"HMS:short[]\", (int s) -> {\n+                short[] b = new short[s \/ Short.BYTES];\n+                return MemorySegment.ofArray(b);\n+            }),\n+            withToString(\"HMS:int[]\", (int s) -> {\n+                int[] b = new int[s \/ Integer.BYTES];\n+                return MemorySegment.ofArray(b);\n+            }),\n+            withToString(\"HMS:float[]\", (int s) -> {\n+                float[] b = new float[s \/ Float.BYTES];\n+                return MemorySegment.ofArray(b);\n+            }),\n+            withToString(\"HMS:long[]\", (int s) -> {\n+                long[] b = new long[s \/ Long.BYTES];\n+                return MemorySegment.ofArray(b);\n+            }),\n+            withToString(\"HMS:double[]\", (int s) -> {\n+                double[] b = new double[s \/ Double.BYTES];\n+                return MemorySegment.ofArray(b);\n+            }),\n+            withToString(\"HMS:ByteBuffer.wrap\", (int s) -> {\n+                byte[] b = new byte[s];\n+                ByteBuffer buff = ByteBuffer.wrap(b);\n+                return MemorySegment.ofBuffer(buff);\n+            }),\n+            \/\/ Just test one of the specialized buffers\n+            withToString(\"HMS:IntBuffer.wrap\", (int s) -> {\n+                int[] b = new int[s \/ Integer.BYTES];\n+                IntBuffer buff = IntBuffer.wrap(b);\n+                return MemorySegment.ofBuffer(buff);\n+            }),\n+            withToString(\"HMS:ByteBuffer.allocate\", (int s) -> {\n+                ByteBuffer buff = ByteBuffer.allocate(s);\n+                return MemorySegment.ofBuffer(buff);\n+            }),\n+            \/\/ Just test one of the specialized buffers\n+            withToString(\"HMS:IntBuffer.allocate\", (int s) -> {\n+                IntBuffer buff = IntBuffer.allocate(s \/ Integer.BYTES);\n+                return MemorySegment.ofBuffer(buff);\n+            }),\n+            \/\/ Slice\n+            withToString(\"HMS:long[].asSlice\", (int s) -> {\n+                long[] b = new long[s \/ Long.BYTES + 1];\n+                return MemorySegment.ofArray(b).asSlice(Long.BYTES);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/AbstractVectorLoadStoreTest.java","additions":51,"deletions":2,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -0,0 +1,160 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.vector\n+ * @run testng\/othervm -XX:+UnlockDiagnosticVMOptions\n+ *                     -XX:+PrintIntrinsics\n+ *                     -Xbatch\n+ *                     -XX:CompileCommand=dontinline,UnalignedHeapTest::payload*\n+ *                     -XX:CompileCommand=PrintCompilation,UnalignedHeapTest::payload*\n+ *                      IntrinsicHeapTest\n+ *\/\n+\n+import jdk.incubator.vector.*;\n+import org.testng.annotations.Test;\n+\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+import java.nio.ByteOrder;\n+import java.util.Arrays;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.LockSupport;\n+import java.util.stream.IntStream;\n+\n+import static org.testng.Assert.*;\n+\n+public class IntrinsicHeapTest {\n+\n+    \/\/ Big enough to hold all species variants for all array types\n+    private static final int ARRAY_LEN = 1024;\n+\n+    @Test\n+    public void testByteArray() {\n+        test(IntrinsicHeapTest::payloadByteArray);\n+    }\n+\n+    @Test\n+    public void testShortArray() {\n+        test(IntrinsicHeapTest::payloadShortArray);\n+    }\n+\n+    @Test\n+    public void testIntArray() {\n+        test(IntrinsicHeapTest::payloadIntArray);\n+    }\n+\n+    @Test\n+    public void testFloatArray() {\n+        test(IntrinsicHeapTest::payloadFloatArray);\n+    }\n+\n+    @Test\n+    public void testLongArray() {\n+        test(IntrinsicHeapTest::payloadLongArray);\n+    }\n+\n+    @Test\n+    public void testDoubleArray() {\n+        test(IntrinsicHeapTest::payloadDoubleArray);\n+    }\n+\n+    static void test(Runnable test) {\n+        for (int i = 0; i < 30000 \/ 5; i++) {\n+            test.run();\n+        }\n+        LockSupport.parkNanos(TimeUnit.MILLISECONDS.toNanos(1));\n+    }\n+\n+    static void payloadByteArray() {\n+        for (VectorSpecies<Byte> species: Arrays.asList(ByteVector.SPECIES_64, ByteVector.SPECIES_128, ByteVector.SPECIES_256, ByteVector.SPECIES_512, ByteVector.SPECIES_MAX)) {\n+            byte[] arr = new byte[ARRAY_LEN];\n+            IntStream.range(0, ARRAY_LEN).forEach(i -> arr[i] = (byte) i); \/\/ May wrap around\n+            MemorySegment segment = MemorySegment.ofArray(arr);\n+            Vector<Byte> vector = species.fromMemorySegment(segment, 0, ByteOrder.nativeOrder());\n+            byte[] expected = segment.asSlice(0, species.vectorByteSize()).toArray(ValueLayout.JAVA_BYTE);\n+            byte[] actual = (byte[]) vector.toArray();\n+            assertEquals(actual, expected, species.toString());\n+        }\n+    }\n+\n+    static void payloadShortArray() {\n+        for (VectorSpecies<Short> species: Arrays.asList(ShortVector.SPECIES_64, ShortVector.SPECIES_128, ShortVector.SPECIES_256, ShortVector.SPECIES_512, ShortVector.SPECIES_MAX)) {\n+            short[] arr = new short[ARRAY_LEN];\n+            IntStream.range(0, ARRAY_LEN).forEach(i -> arr[i] = (short) i);\n+            MemorySegment segment = MemorySegment.ofArray(arr);\n+            Vector<Short> vector = species.fromMemorySegment(segment, 0, ByteOrder.nativeOrder());\n+            short[] expected = segment.asSlice(0, species.vectorByteSize()).toArray(ValueLayout.JAVA_SHORT_UNALIGNED);\n+            short[] actual = (short[]) vector.toArray();\n+            assertEquals(actual, expected, species.toString());\n+        }\n+    }\n+\n+    static void payloadIntArray() {\n+        for (VectorSpecies<Integer> species: Arrays.asList(IntVector.SPECIES_64, IntVector.SPECIES_128, IntVector.SPECIES_256, IntVector.SPECIES_512, IntVector.SPECIES_MAX)) {\n+            MemorySegment segment = MemorySegment.ofArray(IntStream.range(0, ARRAY_LEN).toArray());\n+            Vector<Integer> vector = species.fromMemorySegment(segment, 0, ByteOrder.nativeOrder());\n+            int[] expected = segment.asSlice(0, species.vectorByteSize()).toArray(ValueLayout.JAVA_INT_UNALIGNED);\n+            int[] actual = vector.toIntArray();\n+            assertEquals(actual, expected, species.toString());\n+        }\n+    }\n+\n+    static void payloadFloatArray() {\n+        for (VectorSpecies<Float> species: Arrays.asList(FloatVector.SPECIES_64, FloatVector.SPECIES_128, FloatVector.SPECIES_256, FloatVector.SPECIES_512, FloatVector.SPECIES_MAX)) {\n+            float[] arr = new float[ARRAY_LEN];\n+            IntStream.range(0, ARRAY_LEN).forEach(i -> arr[i] = (float) i);\n+            MemorySegment segment = MemorySegment.ofArray(arr);\n+            Vector<Float> vector = species.fromMemorySegment(segment, 0, ByteOrder.nativeOrder());\n+            float[] expected = segment.asSlice(0, species.vectorByteSize()).toArray(ValueLayout.JAVA_FLOAT_UNALIGNED);\n+            float[] actual = (float[]) vector.toArray();\n+            assertEquals(actual, expected, species.toString());\n+        }\n+    }\n+\n+    static void payloadLongArray() {\n+        for (VectorSpecies<Long> species: Arrays.asList(LongVector.SPECIES_64, LongVector.SPECIES_128, LongVector.SPECIES_256, LongVector.SPECIES_512, LongVector.SPECIES_MAX)) {\n+            long[] arr = new long[ARRAY_LEN];\n+            IntStream.range(0, ARRAY_LEN).forEach(i -> arr[i] = i);\n+            MemorySegment segment = MemorySegment.ofArray(arr);\n+            Vector<Long> vector = species.fromMemorySegment(segment, 0, ByteOrder.nativeOrder());\n+            long[] expected = segment.asSlice(0, species.vectorByteSize()).toArray(ValueLayout.JAVA_LONG_UNALIGNED);\n+            long[] actual = (long[]) vector.toArray();\n+            assertEquals(actual, expected, species.toString());\n+        }\n+    }\n+\n+    static void payloadDoubleArray() {\n+        for (VectorSpecies<Double> species: Arrays.asList(DoubleVector.SPECIES_64, DoubleVector.SPECIES_128, DoubleVector.SPECIES_256, DoubleVector.SPECIES_512, DoubleVector.SPECIES_MAX)) {\n+            double[] arr = new double[ARRAY_LEN];\n+            IntStream.range(0, ARRAY_LEN).forEach(i -> arr[i] = (double) i);\n+            MemorySegment segment = MemorySegment.ofArray(arr);\n+            Vector<Double> vector = species.fromMemorySegment(segment, 0, ByteOrder.nativeOrder());\n+            double[] expected = segment.asSlice(0, species.vectorByteSize()).toArray(ValueLayout.JAVA_DOUBLE_UNALIGNED);\n+            double[] actual = (double[]) vector.toArray();\n+            assertEquals(actual, expected, species.toString());\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntrinsicHeapTest.java","additions":160,"deletions":0,"binary":false,"changes":160,"status":"added"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.vector\n+ * @run testng UnalignedHeapTest\n+ *\/\n+\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.DoubleVector;\n+import jdk.incubator.vector.FloatVector;\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.LongVector;\n+import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorSpecies;\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.*;\n+\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+import java.nio.ByteOrder;\n+import java.util.Arrays;\n+import java.util.stream.IntStream;\n+\n+public class UnalignedHeapTest {\n+\n+    \/\/ Big enough to hold all species variants for all array types\n+    private static final int ARRAY_LEN = 1024;\n+\n+    @Test\n+    public void testByteArray() {\n+        for (VectorSpecies<Byte> species: Arrays.asList(ByteVector.SPECIES_64, ByteVector.SPECIES_128, ByteVector.SPECIES_256, ByteVector.SPECIES_512, ByteVector.SPECIES_MAX)) {\n+            byte[] arr = new byte[ARRAY_LEN];\n+            IntStream.range(0, ARRAY_LEN).forEach(i -> arr[i] = (byte) i); \/\/ May wrap around\n+            MemorySegment segment = MemorySegment.ofArray(arr).asSlice(1);\n+            Vector<Byte> vector = species.fromMemorySegment(segment, 0, ByteOrder.nativeOrder());\n+            byte[] expected = segment.asSlice(0, species.vectorByteSize()).toArray(ValueLayout.JAVA_BYTE);\n+            byte[] actual = (byte[]) vector.toArray();\n+            assertEquals(actual, expected, species.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testShortArray() {\n+        for (VectorSpecies<Short> species: Arrays.asList(ShortVector.SPECIES_64, ShortVector.SPECIES_128, ShortVector.SPECIES_256, ShortVector.SPECIES_512, ShortVector.SPECIES_MAX)) {\n+            short[] arr = new short[ARRAY_LEN];\n+            IntStream.range(0, ARRAY_LEN).forEach(i -> arr[i] = (short) i);\n+            MemorySegment segment = MemorySegment.ofArray(arr).asSlice(1);\n+            Vector<Short> vector = species.fromMemorySegment(segment, 0, ByteOrder.nativeOrder());\n+            short[] expected = segment.asSlice(0, species.vectorByteSize()).toArray(ValueLayout.JAVA_SHORT_UNALIGNED);\n+            short[] actual = (short[]) vector.toArray();\n+            assertEquals(actual, expected, species.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testIntArray() {\n+        for (VectorSpecies<Integer> species: Arrays.asList(IntVector.SPECIES_64, IntVector.SPECIES_128, IntVector.SPECIES_256, IntVector.SPECIES_512, IntVector.SPECIES_MAX)) {\n+            MemorySegment segment = MemorySegment.ofArray(IntStream.range(0, ARRAY_LEN).toArray()).asSlice(1);\n+            Vector<Integer> vector = species.fromMemorySegment(segment, 0, ByteOrder.nativeOrder());\n+            int[] expected = segment.asSlice(0, species.vectorByteSize()).toArray(ValueLayout.JAVA_INT_UNALIGNED);\n+            int[] actual = vector.toIntArray();\n+            assertEquals(actual, expected, species.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testFloatArray() {\n+        for (VectorSpecies<Float> species: Arrays.asList(FloatVector.SPECIES_64, FloatVector.SPECIES_128, FloatVector.SPECIES_256, FloatVector.SPECIES_512, FloatVector.SPECIES_MAX)) {\n+            float[] arr = new float[ARRAY_LEN];\n+            IntStream.range(0, ARRAY_LEN).forEach(i -> arr[i] = (float) i);\n+            MemorySegment segment = MemorySegment.ofArray(arr).asSlice(1);\n+            Vector<Float> vector = species.fromMemorySegment(segment, 0, ByteOrder.nativeOrder());\n+            float[] expected = segment.asSlice(0, species.vectorByteSize()).toArray(ValueLayout.JAVA_FLOAT_UNALIGNED);\n+            float[] actual = (float[]) vector.toArray();\n+            assertEquals(actual, expected, species.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testLongArray() {\n+        for (VectorSpecies<Long> species: Arrays.asList(LongVector.SPECIES_64, LongVector.SPECIES_128, LongVector.SPECIES_256, LongVector.SPECIES_512, LongVector.SPECIES_MAX)) {\n+            long[] arr = new long[ARRAY_LEN];\n+            IntStream.range(0, ARRAY_LEN).forEach(i -> arr[i] = i);\n+            MemorySegment segment = MemorySegment.ofArray(arr).asSlice(1);\n+            Vector<Long> vector = species.fromMemorySegment(segment, 0, ByteOrder.nativeOrder());\n+            long[] expected = segment.asSlice(0, species.vectorByteSize()).toArray(ValueLayout.JAVA_LONG_UNALIGNED);\n+            long[] actual = (long[]) vector.toArray();\n+            assertEquals(actual, expected, species.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testDoubleArray() {\n+        for (VectorSpecies<Double> species: Arrays.asList(DoubleVector.SPECIES_64, DoubleVector.SPECIES_128, DoubleVector.SPECIES_256, DoubleVector.SPECIES_512, DoubleVector.SPECIES_MAX)) {\n+            double[] arr = new double[ARRAY_LEN];\n+            IntStream.range(0, ARRAY_LEN).forEach(i -> arr[i] = (double) i);\n+            MemorySegment segment = MemorySegment.ofArray(arr).asSlice(1);\n+            Vector<Double> vector = species.fromMemorySegment(segment, 0, ByteOrder.nativeOrder());\n+            double[] expected = segment.asSlice(0, species.vectorByteSize()).toArray(ValueLayout.JAVA_DOUBLE_UNALIGNED);\n+            double[] actual = (double[]) vector.toArray();\n+            assertEquals(actual, expected, species.toString());\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/jdk\/incubator\/vector\/UnalignedHeapTest.java","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"},{"patch":"@@ -0,0 +1,259 @@\n+\/*\n+ *  Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package org.openjdk.bench.jdk.incubator.vector;\n+\n+import jdk.incubator.vector.*;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+import java.nio.ByteOrder;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 1, jvmArgsAppend = {\n+        \"--add-modules=jdk.incubator.vector\",\n+        \"--enable-native-access\", \"ALL-UNNAMED\"})\n+public class TestLoadSegmentVarious {\n+\n+    private static final VectorSpecies<Byte> BYTE_SPECIES = VectorSpecies.ofLargestShape(byte.class);\n+    private static final VectorSpecies<Integer> INTEGER_SPECIES = VectorSpecies.ofLargestShape(int.class);\n+    private static final VectorSpecies<Double> DOUBLE_SPECIES = VectorSpecies.ofLargestShape(double.class);\n+\n+    \/\/ Must be evenly dividable by Double.BYTES\n+    @Param(\"1024\")\n+    private int size;\n+\n+    private byte[] byteSrcArray;\n+    private MemorySegment byteSegment;\n+    private int[] intSrcArray;\n+    private MemorySegment intSegment;\n+    private double[] doubleSrcArray;\n+    private MemorySegment doubleSegment;\n+\n+    @Setup\n+    public void setup() {\n+        byteSrcArray = new byte[size];\n+        byteDstArray = byteSrcArray.clone();\n+        for (int i = 0; i < byteSrcArray.length; i++) {\n+            byteSrcArray[i] = (byte) i;\n+        }\n+        byteSegment = MemorySegment.ofArray(byteSrcArray);\n+\n+        intSrcArray = new int[size \/ Integer.BYTES];\n+        intDstArray = intSrcArray.clone();\n+        for (int i = 0; i < intSrcArray.length; i++) {\n+            intSrcArray[i] = i;\n+        }\n+        intSegment = MemorySegment.ofArray(intSrcArray);\n+\n+        doubleSrcArray = new double[size \/ Double.BYTES];\n+        doubleDstArray = doubleSrcArray.clone();\n+        for (int i = 0; i < doubleSrcArray.length; i++) {\n+            intSrcArray[i] = i;\n+        }\n+        doubleSegment = MemorySegment.ofArray(doubleSrcArray);\n+    }\n+\n+    \/\/ Scalar conversion\n+\n+    @Benchmark\n+    public void scalarByteVectorFromByteSegment(Blackhole bh) {\n+        for (int i = 0; i < size; i++) {\n+            byte[] arr = new byte[BYTE_SPECIES.length()];\n+            arr[i % BYTE_SPECIES.length()] = byteSegment.get(ValueLayout.JAVA_BYTE, i);\n+            var v = ByteVector.fromArray(BYTE_SPECIES, arr, 0);\n+            bh.consume(v);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void scalarByteVectorFromIntSegment(Blackhole bh) {\n+        for (int i = 0; i < size; i++) {\n+            byte[] arr = new byte[BYTE_SPECIES.length()];\n+            arr[i % BYTE_SPECIES.length()] = intSegment.get(ValueLayout.JAVA_BYTE, i);\n+            var v = ByteVector.fromArray(BYTE_SPECIES, arr, 0);\n+            bh.consume(v);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void scalarByteVectorFromDoubleSegment(Blackhole bh) {\n+        for (int i = 0; i < size; i++) {\n+            byte[] arr = new byte[BYTE_SPECIES.length()];\n+            arr[i % BYTE_SPECIES.length()] = doubleSegment.get(ValueLayout.JAVA_BYTE, i);\n+            var v = ByteVector.fromArray(BYTE_SPECIES, arr, 0);\n+            bh.consume(v);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void scalarIntVectorFromByteSegment(Blackhole bh) {\n+        for (int i = 0; i < size \/ Integer.BYTES; i++) {\n+            int[] arr = new int[INTEGER_SPECIES.length()];\n+            arr[i % INTEGER_SPECIES.length()] = byteSegment.get(ValueLayout.JAVA_INT_UNALIGNED, i * Integer.BYTES);\n+            var v = IntVector.fromArray(INTEGER_SPECIES, arr, 0);\n+            bh.consume(v);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void scalarIntVectorFromIntSegment(Blackhole bh) {\n+        for (int i = 0; i < size \/ Integer.BYTES; i++) {\n+            int[] arr = new int[INTEGER_SPECIES.length()];\n+            arr[i % INTEGER_SPECIES.length()] = intSegment.get(ValueLayout.JAVA_INT, i * Integer.BYTES);\n+            var v = IntVector.fromArray(INTEGER_SPECIES, arr, 0);\n+            bh.consume(v);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void scalarIntVectorFromDoubleSegment(Blackhole bh) {\n+        for (int i = 0; i < size \/ Integer.BYTES; i++) {\n+            int[] arr = new int[INTEGER_SPECIES.length()];\n+            arr[i % INTEGER_SPECIES.length()] = doubleSegment.get(ValueLayout.JAVA_INT, i * Integer.BYTES);\n+            var v = IntVector.fromArray(INTEGER_SPECIES, arr, 0);\n+            bh.consume(v);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void scalarDoubleVectorFromByteSegment(Blackhole bh) {\n+        for (int i = 0; i < size \/ Double.BYTES; i ++) {\n+            double[] arr = new double[DOUBLE_SPECIES.length()];\n+            arr[i % DOUBLE_SPECIES.length()] = byteSegment.get(ValueLayout.JAVA_DOUBLE_UNALIGNED, i * Double.BYTES);\n+            var v = DoubleVector.fromArray(DOUBLE_SPECIES, arr, 0);\n+            bh.consume(v);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void scalarDoubleVectorFromIntSegment(Blackhole bh) {\n+        for (int i = 0; i < size \/ Double.BYTES; i ++) {\n+            double[] arr = new double[DOUBLE_SPECIES.length()];\n+            arr[i % DOUBLE_SPECIES.length()] = intSegment.get(ValueLayout.JAVA_DOUBLE_UNALIGNED, i * Double.BYTES);\n+            var v = DoubleVector.fromArray(DOUBLE_SPECIES, arr, 0);\n+            bh.consume(v);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void scalarDoubleVectorFromDoubleSegment(Blackhole bh) {\n+        for (int i = 0; i < size \/ Double.BYTES; i ++) {\n+            double[] arr = new double[DOUBLE_SPECIES.length()];\n+            arr[i % DOUBLE_SPECIES.length()] = doubleSegment.get(ValueLayout.JAVA_DOUBLE, i * Double.BYTES);\n+            var v = DoubleVector.fromArray(DOUBLE_SPECIES, arr, 0);\n+            bh.consume(v);\n+        }\n+    }\n+\n+    \/\/ Vector conversion\n+\n+    @Benchmark\n+    public void byteVectorFromByteBackedSegment(Blackhole bh) {\n+        for (int i = 0; i < BYTE_SPECIES.loopBound(byteSrcArray.length); i += BYTE_SPECIES.vectorByteSize()) {\n+            var v = ByteVector.fromMemorySegment(BYTE_SPECIES, byteSegment, i, ByteOrder.nativeOrder());\n+            bh.consume(v);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byteVectorFromIntBackedSegment(Blackhole bh) {\n+        for (int i = 0; i < BYTE_SPECIES.loopBound(byteSrcArray.length); i += BYTE_SPECIES.vectorByteSize()) {\n+            var v = ByteVector.fromMemorySegment(BYTE_SPECIES, intSegment, i, ByteOrder.nativeOrder());\n+            bh.consume(v);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byteVectorFromDoubleBackedSegment(Blackhole bh) {\n+        for (int i = 0; i < BYTE_SPECIES.loopBound(byteSrcArray.length); i += BYTE_SPECIES.vectorByteSize()) {\n+            var v = ByteVector.fromMemorySegment(BYTE_SPECIES, doubleSegment, i, ByteOrder.nativeOrder());\n+            bh.consume(v);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void intVectorFromByteBackedSegment(Blackhole bh) {\n+        for (int i = 0; i < INTEGER_SPECIES.loopBound(intSrcArray.length); i += INTEGER_SPECIES.vectorByteSize()) {\n+            var v = IntVector.fromMemorySegment(INTEGER_SPECIES, byteSegment, i, ByteOrder.nativeOrder());\n+            bh.consume(v);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void intVectorFromIntBackedSegment(Blackhole bh) {\n+        for (int i = 0; i < INTEGER_SPECIES.loopBound(intSrcArray.length); i += INTEGER_SPECIES.vectorByteSize()) {\n+            var v = IntVector.fromMemorySegment(INTEGER_SPECIES, intSegment, i, ByteOrder.nativeOrder());\n+            bh.consume(v);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void intVectorFromDoubleBackedSegment(Blackhole bh) {\n+        for (int i = 0; i < INTEGER_SPECIES.loopBound(intSrcArray.length); i += INTEGER_SPECIES.vectorByteSize()) {\n+            var v = IntVector.fromMemorySegment(INTEGER_SPECIES, doubleSegment, i, ByteOrder.nativeOrder());\n+            bh.consume(v);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void doubleVectorFromByteBackedSegment(Blackhole bh) {\n+        for (int i = 0; i < DOUBLE_SPECIES.loopBound(doubleSrcArray.length); i += DOUBLE_SPECIES.vectorByteSize()) {\n+            var v = DoubleVector.fromMemorySegment(DOUBLE_SPECIES, byteSegment, i, ByteOrder.nativeOrder());\n+            bh.consume(v);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void doubleVectorFromIntBackedSegment(Blackhole bh) {\n+        for (int i = 0; i < DOUBLE_SPECIES.loopBound(doubleSrcArray.length); i += DOUBLE_SPECIES.vectorByteSize()) {\n+            var v = DoubleVector.fromMemorySegment(DOUBLE_SPECIES, intSegment, i, ByteOrder.nativeOrder());\n+            bh.consume(v);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void doubleVectorFromDoubleBackedSegment(Blackhole bh) {\n+        for (int i = 0; i < DOUBLE_SPECIES.loopBound(doubleSrcArray.length); i += DOUBLE_SPECIES.vectorByteSize()) {\n+            var v = DoubleVector.fromMemorySegment(DOUBLE_SPECIES, doubleSegment, i, ByteOrder.nativeOrder());\n+            bh.consume(v);\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/TestLoadSegmentVarious.java","additions":259,"deletions":0,"binary":false,"changes":259,"status":"added"}]}