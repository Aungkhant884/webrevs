{"files":[{"patch":"@@ -332,4 +332,0 @@\n-        \/\/ @@@ Smarter alignment checking if accessing heap segment backing non-byte[] array\n-        if (msp.maxAlignMask() > 1) {\n-            throw new IllegalArgumentException();\n-        }\n@@ -377,4 +373,0 @@\n-        \/\/ @@@ Smarter alignment checking if accessing heap segment backing non-byte[] array\n-        if (msp.maxAlignMask() > 1) {\n-            throw new IllegalArgumentException();\n-        }\n@@ -423,4 +415,0 @@\n-        \/\/ @@@ Smarter alignment checking if accessing heap segment backing non-byte[] array\n-        if (msp.maxAlignMask() > 1) {\n-            throw new IllegalArgumentException();\n-        }\n@@ -469,4 +457,0 @@\n-        \/\/ @@@ Smarter alignment checking if accessing heap segment backing non-byte[] array\n-        if (msp.maxAlignMask() > 1) {\n-            throw new IllegalArgumentException();\n-        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/X-ScopedMemoryAccess.java.template","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -28,0 +28,3 @@\n+\n+import jdk.internal.foreign.AbstractMemorySegmentImpl;\n+import jdk.internal.foreign.Utils;\n@@ -31,0 +34,2 @@\n+import java.lang.foreign.ValueLayout;\n+import java.lang.reflect.Array;\n@@ -32,0 +37,1 @@\n+import java.util.Objects;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractVector.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2848,1 +2848,1 @@\n-     * @throws IllegalArgumentException if the index is is out of range\n+     * @throws IllegalArgumentException if the index is out of range\n@@ -2866,1 +2866,1 @@\n-     * @throws IllegalArgumentException if the index is is out of range\n+     * @throws IllegalArgumentException if the index is out of range\n@@ -3284,2 +3284,0 @@\n-     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n-     *         not backed by a {@code byte[]} array.\n@@ -3336,2 +3334,0 @@\n-     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n-     *         not backed by a {@code byte[]} array.\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2662,1 +2662,1 @@\n-     * @throws IllegalArgumentException if the index is is out of range\n+     * @throws IllegalArgumentException if the index is out of range\n@@ -2680,1 +2680,1 @@\n-     * @throws IllegalArgumentException if the index is is out of range\n+     * @throws IllegalArgumentException if the index is out of range\n@@ -2967,2 +2967,0 @@\n-     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n-     *         not backed by a {@code byte[]} array.\n@@ -3024,2 +3022,0 @@\n-     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n-     *         not backed by a {@code byte[]} array.\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2682,1 +2682,1 @@\n-     * @throws IllegalArgumentException if the index is is out of range\n+     * @throws IllegalArgumentException if the index is out of range\n@@ -2700,1 +2700,1 @@\n-     * @throws IllegalArgumentException if the index is is out of range\n+     * @throws IllegalArgumentException if the index is out of range\n@@ -2973,2 +2973,0 @@\n-     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n-     *         not backed by a {@code byte[]} array.\n@@ -3030,2 +3028,0 @@\n-     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n-     *         not backed by a {@code byte[]} array.\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2833,1 +2833,1 @@\n-     * @throws IllegalArgumentException if the index is is out of range\n+     * @throws IllegalArgumentException if the index is out of range\n@@ -2851,1 +2851,1 @@\n-     * @throws IllegalArgumentException if the index is is out of range\n+     * @throws IllegalArgumentException if the index is out of range\n@@ -3129,2 +3129,0 @@\n-     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n-     *         not backed by a {@code byte[]} array.\n@@ -3186,2 +3184,0 @@\n-     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n-     *         not backed by a {@code byte[]} array.\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2699,1 +2699,1 @@\n-     * @throws IllegalArgumentException if the index is is out of range\n+     * @throws IllegalArgumentException if the index is out of range\n@@ -2717,1 +2717,1 @@\n-     * @throws IllegalArgumentException if the index is is out of range\n+     * @throws IllegalArgumentException if the index is out of range\n@@ -3008,2 +3008,0 @@\n-     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n-     *         not backed by a {@code byte[]} array.\n@@ -3065,2 +3063,0 @@\n-     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n-     *         not backed by a {@code byte[]} array.\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2849,1 +2849,1 @@\n-     * @throws IllegalArgumentException if the index is is out of range\n+     * @throws IllegalArgumentException if the index is out of range\n@@ -2867,1 +2867,1 @@\n-     * @throws IllegalArgumentException if the index is is out of range\n+     * @throws IllegalArgumentException if the index is out of range\n@@ -3278,2 +3278,0 @@\n-     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n-     *         not backed by a {@code byte[]} array.\n@@ -3335,2 +3333,0 @@\n-     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n-     *         not backed by a {@code byte[]} array.\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3361,1 +3361,1 @@\n-     * @throws IllegalArgumentException if the index is is out of range\n+     * @throws IllegalArgumentException if the index is out of range\n@@ -3379,1 +3379,1 @@\n-     * @throws IllegalArgumentException if the index is is out of range\n+     * @throws IllegalArgumentException if the index is out of range\n@@ -4080,2 +4080,0 @@\n-     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n-     *         not backed by a {@code byte[]} array.\n@@ -4141,2 +4139,0 @@\n-     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n-     *         not backed by a {@code byte[]} array.\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import java.lang.foreign.ValueLayout;\n@@ -28,0 +29,1 @@\n+import java.nio.IntBuffer;\n@@ -30,0 +32,1 @@\n+import java.util.Objects;\n@@ -32,0 +35,1 @@\n+import java.util.stream.Stream;\n@@ -53,1 +57,1 @@\n-            withToString(\"HMS\", (int s) ->\n+            withToString(\"DMS\", (int s) ->\n@@ -56,1 +60,1 @@\n-            withToString(\"DMS\", (int s) -> {\n+            withToString(\"HMS:byte[]\", (int s) -> {\n@@ -59,0 +63,45 @@\n+            }),\n+            withToString(\"HMS:short[]\", (int s) -> {\n+                short[] b = new short[s \/ Short.BYTES];\n+                return MemorySegment.ofArray(b);\n+            }),\n+            withToString(\"HMS:int[]\", (int s) -> {\n+                int[] b = new int[s \/ Integer.BYTES];\n+                return MemorySegment.ofArray(b);\n+            }),\n+            withToString(\"HMS:float[]\", (int s) -> {\n+                float[] b = new float[s \/ Float.BYTES];\n+                return MemorySegment.ofArray(b);\n+            }),\n+            withToString(\"HMS:long[]\", (int s) -> {\n+                long[] b = new long[s \/ Long.BYTES];\n+                return MemorySegment.ofArray(b);\n+            }),\n+            withToString(\"HMS:double[]\", (int s) -> {\n+                double[] b = new double[s \/ Double.BYTES];\n+                return MemorySegment.ofArray(b);\n+            }),\n+            withToString(\"HMS:ByteBuffer.wrap\", (int s) -> {\n+                byte[] b = new byte[s];\n+                ByteBuffer buff = ByteBuffer.wrap(b);\n+                return MemorySegment.ofBuffer(buff);\n+            }),\n+            \/\/ Just test one of the specialized buffers\n+            withToString(\"HMS:IntBuffer.wrap\", (int s) -> {\n+                int[] b = new int[s \/ Integer.BYTES];\n+                IntBuffer buff = IntBuffer.wrap(b);\n+                return MemorySegment.ofBuffer(buff);\n+            }),\n+            withToString(\"HMS:ByteBuffer.allocate\", (int s) -> {\n+                ByteBuffer buff = ByteBuffer.allocate(s);\n+                return MemorySegment.ofBuffer(buff);\n+            }),\n+            \/\/ Just test one of the specialized buffers\n+            withToString(\"HMS:IntBuffer.allocate\", (int s) -> {\n+                IntBuffer buff = IntBuffer.allocate(s \/ Integer.BYTES);\n+                return MemorySegment.ofBuffer(buff);\n+            }),\n+            \/\/ Slice\n+            withToString(\"HMS:long[].asSlice\", (int s) -> {\n+                long[] b = new long[s \/ Long.BYTES + 1];\n+                return MemorySegment.ofArray(b).asSlice(Long.BYTES);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/AbstractVectorLoadStoreTest.java","additions":51,"deletions":2,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -0,0 +1,130 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.vector\n+ * @run testng UnalignedHeapTest\n+ *\n+ *\/\n+\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.DoubleVector;\n+import jdk.incubator.vector.FloatVector;\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.LongVector;\n+import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorSpecies;\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.*;\n+\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+import java.nio.ByteOrder;\n+import java.util.Arrays;\n+import java.util.stream.IntStream;\n+\n+public class UnalignedHeapTest {\n+\n+    \/\/ Big enough to hold all species variants for all array types\n+    private static final int ARRAY_LEN = 1024;\n+\n+    @Test\n+    public void testByteArray() {\n+        for (VectorSpecies<Byte> species: Arrays.asList(ByteVector.SPECIES_64, ByteVector.SPECIES_128, ByteVector.SPECIES_256, ByteVector.SPECIES_512, ByteVector.SPECIES_MAX)) {\n+            byte[] arr = new byte[ARRAY_LEN];\n+            IntStream.range(0, ARRAY_LEN).forEach(i -> arr[i] = (byte) i); \/\/ May wrap around\n+            MemorySegment segment = MemorySegment.ofArray(arr).asSlice(1);\n+            Vector<Byte> vector = species.fromMemorySegment(segment, 0, ByteOrder.nativeOrder());\n+            byte[] expected = segment.asSlice(0, species.vectorByteSize()).toArray(ValueLayout.JAVA_BYTE);\n+            byte[] actual = (byte[]) vector.toArray();\n+            assertEquals(actual, expected, species.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testShortArray() {\n+        for (VectorSpecies<Short> species: Arrays.asList(ShortVector.SPECIES_64, ShortVector.SPECIES_128, ShortVector.SPECIES_256, ShortVector.SPECIES_512, ShortVector.SPECIES_MAX)) {\n+            short[] arr = new short[ARRAY_LEN];\n+            IntStream.range(0, ARRAY_LEN).forEach(i -> arr[i] = (short) i);\n+            MemorySegment segment = MemorySegment.ofArray(arr).asSlice(1);\n+            Vector<Short> vector = species.fromMemorySegment(segment, 0, ByteOrder.nativeOrder());\n+            short[] expected = segment.asSlice(0, species.vectorByteSize()).toArray(ValueLayout.JAVA_SHORT_UNALIGNED);\n+            short[] actual = (short[]) vector.toArray();\n+            assertEquals(actual, expected, species.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testIntArray() {\n+        for (VectorSpecies<Integer> species: Arrays.asList(IntVector.SPECIES_64, IntVector.SPECIES_128, IntVector.SPECIES_256, IntVector.SPECIES_512, IntVector.SPECIES_MAX)) {\n+            MemorySegment segment = MemorySegment.ofArray(IntStream.range(0, ARRAY_LEN).toArray()).asSlice(1);\n+            Vector<Integer> vector = species.fromMemorySegment(segment, 0, ByteOrder.nativeOrder());\n+            int[] expected = segment.asSlice(0, species.vectorByteSize()).toArray(ValueLayout.JAVA_INT_UNALIGNED);\n+            int[] actual = vector.toIntArray();\n+            assertEquals(actual, expected, species.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testFloatArray() {\n+        for (VectorSpecies<Float> species: Arrays.asList(FloatVector.SPECIES_64, FloatVector.SPECIES_128, FloatVector.SPECIES_256, FloatVector.SPECIES_512, FloatVector.SPECIES_MAX)) {\n+            float[] arr = new float[ARRAY_LEN];\n+            IntStream.range(0, ARRAY_LEN).forEach(i -> arr[i] = (float) i);\n+            MemorySegment segment = MemorySegment.ofArray(arr).asSlice(1);\n+            Vector<Float> vector = species.fromMemorySegment(segment, 0, ByteOrder.nativeOrder());\n+            float[] expected = segment.asSlice(0, species.vectorByteSize()).toArray(ValueLayout.JAVA_FLOAT_UNALIGNED);\n+            float[] actual = (float[]) vector.toArray();\n+            assertEquals(actual, expected, species.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testLongArray() {\n+        for (VectorSpecies<Long> species: Arrays.asList(LongVector.SPECIES_64, LongVector.SPECIES_128, LongVector.SPECIES_256, LongVector.SPECIES_512, LongVector.SPECIES_MAX)) {\n+            long[] arr = new long[ARRAY_LEN];\n+            IntStream.range(0, ARRAY_LEN).forEach(i -> arr[i] = i);\n+            MemorySegment segment = MemorySegment.ofArray(arr).asSlice(1);\n+            Vector<Long> vector = species.fromMemorySegment(segment, 0, ByteOrder.nativeOrder());\n+            long[] expected = segment.asSlice(0, species.vectorByteSize()).toArray(ValueLayout.JAVA_LONG_UNALIGNED);\n+            long[] actual = (long[]) vector.toArray();\n+            assertEquals(actual, expected, species.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testDoubleArray() {\n+        for (VectorSpecies<Double> species: Arrays.asList(DoubleVector.SPECIES_64, DoubleVector.SPECIES_128, DoubleVector.SPECIES_256, DoubleVector.SPECIES_512, DoubleVector.SPECIES_MAX)) {\n+            double[] arr = new double[ARRAY_LEN];\n+            IntStream.range(0, ARRAY_LEN).forEach(i -> arr[i] = (double) i);\n+            MemorySegment segment = MemorySegment.ofArray(arr).asSlice(1);\n+            Vector<Double> vector = species.fromMemorySegment(segment, 0, ByteOrder.nativeOrder());\n+            double[] expected = segment.asSlice(0, species.vectorByteSize()).toArray(ValueLayout.JAVA_DOUBLE_UNALIGNED);\n+            double[] actual = (double[]) vector.toArray();\n+            assertEquals(actual, expected, species.toString());\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/jdk\/incubator\/vector\/UnalignedHeapTest.java","additions":130,"deletions":0,"binary":false,"changes":130,"status":"added"}]}