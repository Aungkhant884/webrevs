{"files":[{"patch":"@@ -1,160 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @modules jdk.incubator.vector\n- * @run testng\/othervm -XX:+UnlockDiagnosticVMOptions\n- *                     -XX:+PrintIntrinsics\n- *                     -Xbatch\n- *                     -XX:CompileCommand=dontinline,UnalignedHeapTest::payload*\n- *                     -XX:CompileCommand=PrintCompilation,UnalignedHeapTest::payload*\n- *                      IntrinsicHeapTest\n- *\/\n-\n-import jdk.incubator.vector.*;\n-import org.testng.annotations.Test;\n-\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.ValueLayout;\n-import java.nio.ByteOrder;\n-import java.util.Arrays;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.locks.LockSupport;\n-import java.util.stream.IntStream;\n-\n-import static org.testng.Assert.*;\n-\n-public class IntrinsicHeapTest {\n-\n-    \/\/ Big enough to hold all species variants for all array types\n-    private static final int ARRAY_LEN = 1024;\n-\n-    @Test\n-    public void testByteArray() {\n-        test(IntrinsicHeapTest::payloadByteArray);\n-    }\n-\n-    @Test\n-    public void testShortArray() {\n-        test(IntrinsicHeapTest::payloadShortArray);\n-    }\n-\n-    @Test\n-    public void testIntArray() {\n-        test(IntrinsicHeapTest::payloadIntArray);\n-    }\n-\n-    @Test\n-    public void testFloatArray() {\n-        test(IntrinsicHeapTest::payloadFloatArray);\n-    }\n-\n-    @Test\n-    public void testLongArray() {\n-        test(IntrinsicHeapTest::payloadLongArray);\n-    }\n-\n-    @Test\n-    public void testDoubleArray() {\n-        test(IntrinsicHeapTest::payloadDoubleArray);\n-    }\n-\n-    static void test(Runnable test) {\n-        for (int i = 0; i < 30000 \/ 5; i++) {\n-            test.run();\n-        }\n-        LockSupport.parkNanos(TimeUnit.MILLISECONDS.toNanos(1));\n-    }\n-\n-    static void payloadByteArray() {\n-        for (VectorSpecies<Byte> species: Arrays.asList(ByteVector.SPECIES_64, ByteVector.SPECIES_128, ByteVector.SPECIES_256, ByteVector.SPECIES_512, ByteVector.SPECIES_MAX)) {\n-            byte[] arr = new byte[ARRAY_LEN];\n-            IntStream.range(0, ARRAY_LEN).forEach(i -> arr[i] = (byte) i); \/\/ May wrap around\n-            MemorySegment segment = MemorySegment.ofArray(arr);\n-            Vector<Byte> vector = species.fromMemorySegment(segment, 0, ByteOrder.nativeOrder());\n-            byte[] expected = segment.asSlice(0, species.vectorByteSize()).toArray(ValueLayout.JAVA_BYTE);\n-            byte[] actual = (byte[]) vector.toArray();\n-            assertEquals(actual, expected, species.toString());\n-        }\n-    }\n-\n-    static void payloadShortArray() {\n-        for (VectorSpecies<Short> species: Arrays.asList(ShortVector.SPECIES_64, ShortVector.SPECIES_128, ShortVector.SPECIES_256, ShortVector.SPECIES_512, ShortVector.SPECIES_MAX)) {\n-            short[] arr = new short[ARRAY_LEN];\n-            IntStream.range(0, ARRAY_LEN).forEach(i -> arr[i] = (short) i);\n-            MemorySegment segment = MemorySegment.ofArray(arr);\n-            Vector<Short> vector = species.fromMemorySegment(segment, 0, ByteOrder.nativeOrder());\n-            short[] expected = segment.asSlice(0, species.vectorByteSize()).toArray(ValueLayout.JAVA_SHORT_UNALIGNED);\n-            short[] actual = (short[]) vector.toArray();\n-            assertEquals(actual, expected, species.toString());\n-        }\n-    }\n-\n-    static void payloadIntArray() {\n-        for (VectorSpecies<Integer> species: Arrays.asList(IntVector.SPECIES_64, IntVector.SPECIES_128, IntVector.SPECIES_256, IntVector.SPECIES_512, IntVector.SPECIES_MAX)) {\n-            MemorySegment segment = MemorySegment.ofArray(IntStream.range(0, ARRAY_LEN).toArray());\n-            Vector<Integer> vector = species.fromMemorySegment(segment, 0, ByteOrder.nativeOrder());\n-            int[] expected = segment.asSlice(0, species.vectorByteSize()).toArray(ValueLayout.JAVA_INT_UNALIGNED);\n-            int[] actual = vector.toIntArray();\n-            assertEquals(actual, expected, species.toString());\n-        }\n-    }\n-\n-    static void payloadFloatArray() {\n-        for (VectorSpecies<Float> species: Arrays.asList(FloatVector.SPECIES_64, FloatVector.SPECIES_128, FloatVector.SPECIES_256, FloatVector.SPECIES_512, FloatVector.SPECIES_MAX)) {\n-            float[] arr = new float[ARRAY_LEN];\n-            IntStream.range(0, ARRAY_LEN).forEach(i -> arr[i] = (float) i);\n-            MemorySegment segment = MemorySegment.ofArray(arr);\n-            Vector<Float> vector = species.fromMemorySegment(segment, 0, ByteOrder.nativeOrder());\n-            float[] expected = segment.asSlice(0, species.vectorByteSize()).toArray(ValueLayout.JAVA_FLOAT_UNALIGNED);\n-            float[] actual = (float[]) vector.toArray();\n-            assertEquals(actual, expected, species.toString());\n-        }\n-    }\n-\n-    static void payloadLongArray() {\n-        for (VectorSpecies<Long> species: Arrays.asList(LongVector.SPECIES_64, LongVector.SPECIES_128, LongVector.SPECIES_256, LongVector.SPECIES_512, LongVector.SPECIES_MAX)) {\n-            long[] arr = new long[ARRAY_LEN];\n-            IntStream.range(0, ARRAY_LEN).forEach(i -> arr[i] = i);\n-            MemorySegment segment = MemorySegment.ofArray(arr);\n-            Vector<Long> vector = species.fromMemorySegment(segment, 0, ByteOrder.nativeOrder());\n-            long[] expected = segment.asSlice(0, species.vectorByteSize()).toArray(ValueLayout.JAVA_LONG_UNALIGNED);\n-            long[] actual = (long[]) vector.toArray();\n-            assertEquals(actual, expected, species.toString());\n-        }\n-    }\n-\n-    static void payloadDoubleArray() {\n-        for (VectorSpecies<Double> species: Arrays.asList(DoubleVector.SPECIES_64, DoubleVector.SPECIES_128, DoubleVector.SPECIES_256, DoubleVector.SPECIES_512, DoubleVector.SPECIES_MAX)) {\n-            double[] arr = new double[ARRAY_LEN];\n-            IntStream.range(0, ARRAY_LEN).forEach(i -> arr[i] = (double) i);\n-            MemorySegment segment = MemorySegment.ofArray(arr);\n-            Vector<Double> vector = species.fromMemorySegment(segment, 0, ByteOrder.nativeOrder());\n-            double[] expected = segment.asSlice(0, species.vectorByteSize()).toArray(ValueLayout.JAVA_DOUBLE_UNALIGNED);\n-            double[] actual = (double[]) vector.toArray();\n-            assertEquals(actual, expected, species.toString());\n-        }\n-    }\n-\n-}\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntrinsicHeapTest.java","additions":0,"deletions":160,"binary":false,"changes":160,"status":"deleted"}]}