{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -748,0 +748,77 @@\n+\n+    \/**\n+     * Return the base 10 logarithm of x\n+     *\n+     * Method :\n+     *      Let log10_2hi = leading 40 bits of log10(2) and\n+     *          log10_2lo = log10(2) - log10_2hi,\n+     *          ivln10   = 1\/log(10) rounded.\n+     *      Then\n+     *              n = ilogb(x),\n+     *              if(n<0)  n = n+1;\n+     *              x = scalbn(x,-n);\n+     *              log10(x) := n*log10_2hi + (n*log10_2lo + ivln10*log(x))\n+     *\n+     * Note 1:\n+     *      To guarantee log10(10**n)=n, where 10**n is normal, the rounding\n+     *      mode must set to Round-to-Nearest.\n+     * Note 2:\n+     *      [1\/log(10)] rounded to 53 bits has error  .198   ulps;\n+     *      log10 is monotonic at all binary break points.\n+     *\n+     * Special cases:\n+     *      log10(x) is NaN with signal if x < 0;\n+     *      log10(+INF) is +INF with no signal; log10(0) is -INF with signal;\n+     *      log10(NaN) is that NaN with no signal;\n+     *      log10(10**N) = N  for N=0,1,...,22.\n+     *\n+     * Constants:\n+     * The hexadecimal values are the intended ones for the following constants.\n+     * The decimal values may be used, provided that the compiler will convert\n+     * from decimal to binary accurately enough to produce the hexadecimal values\n+     * shown.\n+     *\/\n+    static class Log10 {\n+        private static double two54     = 0x1.0p54;              \/\/ 1.80143985094819840000e+16;\n+        private static double ivln10    = 0x1.bcb7b1526e50ep-2;  \/\/ 4.34294481903251816668e-01\n+\n+        private static double log10_2hi = 0x1.34413509f6p-2;     \/\/ 3.01029995663611771306e-01;\n+        private static double log10_2lo = 0x1.9fef311f12b36p-42; \/\/ 3.69423907715893078616e-13;\n+\n+        private Log10() {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public static double compute(double x) {\n+            double y, z;\n+            int i, k;\n+\n+            int hx = __HI(x); \/\/ high word of x\n+            int lx = __LO(x); \/\/ low word of x\n+\n+            k=0;\n+            if (hx < 0x0010_0000) {                  \/* x < 2**-1022  *\/\n+                if (((hx & 0x7fff_ffff) | lx) == 0) {\n+                    return -two54\/0.0;               \/* log(+-0)=-inf *\/\n+                }\n+                if (hx < 0) {\n+                    return (x - x)\/0.0;              \/* log(-#) = NaN *\/\n+                }\n+                k -= 54;\n+                x *= two54; \/* subnormal number, scale up x *\/\n+                hx = __HI(x);\n+            }\n+\n+            if (hx >= 0x7ff0_0000) {\n+                return x + x;\n+            }\n+\n+            k += (hx >> 20) - 1023;\n+            i  = (k  & 0x8000_0000) >>> 31; \/\/ unsigned shift\n+            hx = (hx & 0x000f_ffff) | ((0x3ff - i) << 20);\n+            y  = (double)(k + i);\n+            x = __HI(x, hx); \/\/ replace high word of x with hx\n+            z  = y * log10_2lo + ivln10 * StrictMath.log(x);\n+            return  z + y * log10_2hi;\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/FdLibm.java","additions":78,"deletions":1,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -284,1 +284,3 @@\n-    public static native double log10(double a);\n+    public static double log10(double a) {\n+        return FdLibm.Log10.compute(a);\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StrictMath.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,0 +77,8 @@\n+    public static double cbrt(double x) {\n+        return Cbrt.compute(x);\n+    }\n+\n+    public static double log10(double x) {\n+        return Log10.compute(x);\n+    }\n+\n@@ -92,1 +100,1 @@\n-        public static strictfp double compute(double x) {\n+        public static double compute(double x) {\n@@ -336,1 +344,1 @@\n-        public static strictfp double compute(double x) {\n+        public static double compute(double x) {\n@@ -387,0 +395,68 @@\n+\n+    \/**\n+     * Return the base 10 logarithm of x\n+     *\n+     * Method :\n+     *      Let log10_2hi = leading 40 bits of log10(2) and\n+     *          log10_2lo = log10(2) - log10_2hi,\n+     *          ivln10   = 1\/log(10) rounded.\n+     *      Then\n+     *              n = ilogb(x),\n+     *              if(n<0)  n = n+1;\n+     *              x = scalbn(x,-n);\n+     *              log10(x) := n*log10_2hi + (n*log10_2lo + ivln10*log(x))\n+     *\n+     * Note 1:\n+     *      To guarantee log10(10**n)=n, where 10**n is normal, the rounding\n+     *      mode must set to Round-to-Nearest.\n+     * Note 2:\n+     *      [1\/log(10)] rounded to 53 bits has error  .198   ulps;\n+     *      log10 is monotonic at all binary break points.\n+     *\n+     * Special cases:\n+     *      log10(x) is NaN with signal if x < 0;\n+     *      log10(+INF) is +INF with no signal; log10(0) is -INF with signal;\n+     *      log10(NaN) is that NaN with no signal;\n+     *      log10(10**N) = N  for N=0,1,...,22.\n+     *\n+     * Constants:\n+     * The hexadecimal values are the intended ones for the following constants.\n+     * The decimal values may be used, provided that the compiler will convert\n+     * from decimal to binary accurately enough to produce the hexadecimal values\n+     * shown.\n+     *\/\n+    static class Log10 {\n+        private static double two54      =  1.80143985094819840000e+16; \/* 0x43500000, 0x00000000 *\/\n+        private static double ivln10     =  4.34294481903251816668e-01; \/* 0x3FDBCB7B, 0x1526E50E *\/\n+\n+        private static double log10_2hi  =  3.01029995663611771306e-01; \/* 0x3FD34413, 0x509F6000 *\/\n+        private static double log10_2lo  =  3.69423907715893078616e-13; \/* 0x3D59FEF3, 0x11F12B36 *\/\n+\n+        private static double zero   =  0.0;\n+\n+        public static double compute(double x) {\n+            double y,z;\n+            int i,k,hx;\n+            \/*unsigned*\/ int lx;\n+\n+            hx = __HI(x);   \/* high word of x *\/\n+            lx = __LO(x);   \/* low word of x *\/\n+\n+            k=0;\n+            if (hx < 0x00100000) {                  \/* x < 2**-1022  *\/\n+                if (((hx&0x7fffffff)|lx)==0)\n+                    return -two54\/zero;             \/* log(+-0)=-inf *\/\n+                if (hx<0) return (x-x)\/zero;        \/* log(-#) = NaN *\/\n+                k -= 54; x *= two54; \/* subnormal number, scale up x *\/\n+                hx = __HI(x);                \/* high word of x *\/\n+            }\n+            if (hx >= 0x7ff00000) return x+x;\n+            k += (hx>>20)-1023;\n+            i  = (k&0x80000000)>>>31; \/\/ unsigned shift\n+            hx = (hx&0x000fffff)|((0x3ff-i)<<20);\n+            y  = (double)(k+i);\n+            x = __HI(x, hx); \/\/original: __HI(x) = hx;\n+            z  = y*log10_2lo + ivln10*StrictMath.log(x); \/\/ TOOD: switch to Translit.log when available\n+            return  z+y*log10_2hi;\n+        }\n+    }\n","filename":"test\/jdk\/java\/lang\/StrictMath\/FdlibmTranslit.java","additions":79,"deletions":3,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,8 @@\n- * @bug 4074599\n+ * @bug 4074599 8301205\n+ * @key randomness\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.RandomFactory\n+ * @build Tests\n+ * @build FdlibmTranslit\n+ * @build Log10Tests\n+ * @run main Log10Tests\n@@ -29,1 +36,1 @@\n-\n+import jdk.test.lib.RandomFactory;\n@@ -45,0 +52,13 @@\n+    public static void main(String... args) {\n+        int failures = 0;\n+\n+        failures += testLog10();\n+        failures += testAgainstTranslit();\n+\n+        if (failures > 0) {\n+            System.err.println(\"Testing log10 incurred \"\n+                               + failures + \" failures.\");\n+            throw new RuntimeException();\n+        }\n+    }\n+\n@@ -712,1 +732,7 @@\n-    public static void main(String [] argv) {\n+    \/\/ Initialize shared random number generator\n+    private static java.util.Random random = RandomFactory.getRandom();\n+\n+    \/**\n+     * Test StrictMath.log10 against transliteration port of log10.\n+     *\/\n+    private static int testAgainstTranslit() {\n@@ -714,0 +740,1 @@\n+        double x;\n@@ -715,1 +742,3 @@\n-        failures += testLog10();\n+        \/\/ Test just above subnormal threshold...\n+        x = Double.MIN_NORMAL;\n+        failures += testRange(x, Math.ulp(x), 1000);\n@@ -717,4 +746,26 @@\n-        if (failures > 0) {\n-            System.err.println(\"Testing log10 incurred \"\n-                               + failures + \" failures.\");\n-            throw new RuntimeException();\n+        \/\/ ... and just below subnormal threshold ...\n+         x =  Math.nextDown(Double.MIN_NORMAL);\n+         failures += testRange(x, -Math.ulp(x), 1000);\n+\n+        \/\/ ... and near 1.0 ...\n+         x = 1.0;\n+         failures += testRange(x, Math.ulp(x), 1000);\n+         x = Math.nextDown(1.0);\n+         failures += testRange(x, -Math.ulp(x), 1000);\n+\n+         x = Tests.createRandomDouble(random);\n+\n+         \/\/ Make the increment twice the ulp value in case the random\n+         \/\/ value is near an exponent threshold. Don't worry about test\n+         \/\/ elements overflowing to infinity if the starting value is\n+         \/\/ near Double.MAX_VALUE.\n+         failures += testRange(x, 2.0 * Math.ulp(x), 1000);\n+\n+         return failures;\n+    }\n+\n+    private static int testRange(double start, double increment, int count) {\n+        int failures = 0;\n+        double x = start;\n+        for (int i = 0; i < count; i++, x += increment) {\n+            failures += testLog10Case(x, FdlibmTranslit.log10(x));\n@@ -722,0 +773,1 @@\n+        return failures;\n","filename":"test\/jdk\/java\/lang\/StrictMath\/Log10Tests.java","additions":61,"deletions":9,"binary":false,"changes":70,"status":"modified"}]}