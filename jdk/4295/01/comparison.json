{"files":[{"patch":"@@ -595,2 +595,5 @@\n-     * changed using the {@code setValue} method.  This class\n-     * facilitates the process of building custom map\n+     * changed using the {@code setValue} method. Instances of\n+     * this class are not associated with any map's entry-set view.\n+     *\n+     * @apiNote\n+     * This class facilitates the process of building custom map\n@@ -728,4 +731,15 @@\n-     * An Entry maintaining an immutable key and value.  This class\n-     * does not support method {@code setValue}.  This class may be\n-     * convenient in methods that return thread-safe snapshots of\n-     * key-value mappings.\n+     * An unmodifiable Entry maintaining a key and a value.  This class\n+     * does not support the {@code setValue} method. Instances of\n+     * this class are not associated with any map's entry-set view.\n+     *\n+     * @apiNote\n+     * Instances of this class are not necessarily immutable, as the key\n+     * and value may be mutable. An instance of <i>this specific class<\/i>\n+     * is unmodifiable, because the key and value references cannot be\n+     * changed. A reference of this <i>type<\/i> may not be unmodifiable,\n+     * as a subclass may be modifiable or may provide the appearance of modifiability.\n+     * <p>\n+     * This class may be convenient in methods that return thread-safe snapshots of\n+     * key-value mappings. For alternatives, see the\n+     * {@link Map#entry Map::entry} and {@link Map.Entry#copyOf Map.Entry::copyOf}\n+     * methods.\n@@ -791,1 +805,4 @@\n-         * an <i>immutable<\/i> map entry.\n+         * an unmodifiable map entry.\n+         *\n+         * @implSpec\n+         * The implementation in this class always throws {@code UnsupportedOperationException}.\n","filename":"src\/java.base\/share\/classes\/java\/util\/AbstractMap.java","additions":24,"deletions":7,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -396,8 +396,27 @@\n-     * A map entry (key-value pair).  The {@code Map.entrySet} method returns\n-     * a collection-view of the map, whose elements are of this class.  The\n-     * <i>only<\/i> way to obtain a reference to a map entry is from the\n-     * iterator of this collection-view.  These {@code Map.Entry} objects are\n-     * valid <i>only<\/i> for the duration of the iteration; more formally,\n-     * the behavior of a map entry is undefined if the backing map has been\n-     * modified after the entry was returned by the iterator, except through\n-     * the {@code setValue} operation on the map entry.\n+     * A map entry (key-value pair). The Entry may be unmodifiable, or the\n+     * value may be modifiable if the optional {@code setValue} method is\n+     * implemented. The Entry may be independent of any map, or it may represent\n+     * an entry of the entry-set view of a map.\n+     * <p>\n+     * Instances of the {@code Map.Entry} interface may be obtained by iterating\n+     * the entry-set view of a map. These instances maintain a connection to the\n+     * original, backing map. This connection to the backing map is valid\n+     * <i>only<\/i> for the duration of iteration over the entry-set view.\n+     * During iteration of the entry-set view, if supported by the backing map,\n+     * a change to a {@code Map.Entry}'s value via the\n+     * {@link Map.Entry#setValue setValue} method will be visible in the backing map.\n+     * The behavior of such a {@code Map.Entry} instance is undefined outside of\n+     * iteration of the map's entry-set view. It is also undefined if the backing\n+     * map has been modified after the {@code Map.Entry} was returned by the\n+     * iterator, except through the {@code Map.Entry.setValue} method. In particular,\n+     * a change to the value of a mapping in the backing map might or might not be\n+     * visible in the corresponding {@code Map.Entry} element of the entry-set view.\n+     *\n+     * @apiNote\n+     * It is possible to create a {@code Map.Entry} instance that is disconnected\n+     * from a backing map by using the {@link Map.Entry#copyOf copyOf} method. For example,\n+     * the following creates a snapshot of a map's entries that is guaranteed not to\n+     * change even if the original map is modified:\n+     * <pre> {@code\n+     * var entries = map.entrySet().stream().map(Map.Entry::copyOf).toList()\n+     * }<\/pre>\n@@ -562,0 +581,31 @@\n+\n+        \/**\n+         * Returns a copy of the given {@code Map.Entry}. The returned instance is not\n+         * associated with any map. The returned instance has the same characteristics\n+         * as instances returned by the {@link Map#entry Map::entry} method.\n+         *\n+         * @apiNote\n+         * An instance obtained from a map's entry-set view has a connection to that map.\n+         * The {@code copyOf}  method may be used to create a {@code Map.Entry} instance,\n+         * containing the same key and value, that is independent of any map.\n+         *\n+         * @implNote\n+         * If the given entry was obtained from a call to {@code copyOf} or {@code Map::entry},\n+         * calling {@code copyOf} will generally not create another copy.\n+         *\n+         * @param <K> the type of the key\n+         * @param <V> the type of the value\n+         * @param e the entry to be copied\n+         * @return a map entry equal to the given entry\n+         * @throws NullPointerException if e is null or if either of its key or value is null\n+         * @since 17\n+         *\/\n+        @SuppressWarnings(\"unchecked\")\n+        public static <K, V> Map.Entry<K, V> copyOf(Map.Entry<? extends K, ? extends V> e) {\n+            Objects.requireNonNull(e);\n+            if (e instanceof KeyValueHolder) {\n+                return (Map.Entry<K, V>) e;\n+            } else {\n+                return Map.entry(e.getKey(), e.getValue());\n+            }\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/util\/Map.java","additions":58,"deletions":8,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,0 @@\n-import java.util.stream.Collectors;\n@@ -48,0 +47,1 @@\n+import static org.testng.Assert.assertThrows;\n@@ -49,1 +49,0 @@\n-import static org.testng.Assert.fail;\n@@ -473,1 +472,1 @@\n-    \/\/ Map.entry() tests\n+    \/\/ Map::entry tests\n@@ -485,0 +484,6 @@\n+    @Test\n+    public void entrySetValueDisallowed() {\n+        var e = Map.entry(\"a\", \"b\");\n+        assertThrows(UnsupportedOperationException.class, () -> e.setValue(\"x\"));\n+    }\n+\n@@ -495,2 +500,48 @@\n-        assertEquals(sie.hashCode(), kvh1.hashCode());\n-        assertEquals(sie.toString(), kvh1.toString());\n+        assertEquals(kvh1.hashCode(), sie.hashCode());\n+        assertEquals(kvh1.toString(), sie.toString());\n+    }\n+\n+    \/\/ Map.Entry::copyOf tests\n+\n+    @Test(expectedExceptions=NullPointerException.class)\n+    public void entryCopyNullDisallowed() {\n+        Map.Entry.copyOf(null);\n+    }\n+\n+    @Test\n+    public void entryCopyWithNullKeyDisallowed() {\n+        var e = new AbstractMap.SimpleEntry<>(null, \"b\");\n+        assertThrows(NullPointerException.class, () -> Map.Entry.copyOf(e));\n+    }\n+\n+    @Test\n+    public void entryCopyWithNullValueDisallowed() {\n+        var e = new AbstractMap.SimpleEntry<>(\"a\", null);\n+        assertThrows(NullPointerException.class, () -> Map.Entry.copyOf(e));\n+    }\n+\n+    @Test\n+    public void entryCopySetValueDisallowed() {\n+        var e = new AbstractMap.SimpleEntry<>(\"a\", \"b\");\n+        var c = Map.Entry.copyOf(e);\n+        assertThrows(UnsupportedOperationException.class, () -> c.setValue(\"x\"));\n+    }\n+\n+    @Test\n+    public void entryCopyBasicTests() {\n+        Map.Entry<String,String> orig = new AbstractMap.SimpleImmutableEntry<>(\"xyzzy\", \"plugh\");\n+        Map.Entry<String,String> copy1 = Map.Entry.copyOf(orig);\n+        Map.Entry<String,String> copy2 = Map.Entry.copyOf(copy1);\n+\n+        assertEquals(orig, copy1);\n+        assertEquals(copy1, orig);\n+        assertEquals(orig, copy2);\n+        assertEquals(copy2, orig);\n+        assertEquals(copy1, copy2);\n+        assertEquals(copy2, copy1);\n+\n+        assertNotSame(orig, copy1);\n+        assertSame(copy1, copy2);\n+\n+        assertEquals(copy1.hashCode(), orig.hashCode());\n+        assertEquals(copy1.toString(), orig.toString());\n","filename":"test\/jdk\/java\/util\/Map\/MapFactories.java","additions":57,"deletions":6,"binary":false,"changes":63,"status":"modified"}]}