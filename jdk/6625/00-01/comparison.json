{"files":[{"patch":"@@ -135,1 +135,1 @@\n-      \/\/ FP return values can be also in CPU registers on ARM and PPC32 (softfp ABI)\n+      \/\/ FP return values can be also in CPU registers on ARM (softfp ABI)\n@@ -137,2 +137,1 @@\n-             ARM_ONLY(|| kindfield == cpu_register)\n-             PPC32_ONLY(|| kindfield == cpu_register) ) &&\n+             ARM_ONLY(|| kindfield == cpu_register) &&\n@@ -142,1 +141,1 @@\n-      \/\/ FP return values can be also in CPU registers on ARM and PPC32 (softfp ABI)\n+      \/\/ FP return values can be also in CPU registers on ARM (softfp ABI)\n@@ -144,2 +143,1 @@\n-             ARM_ONLY(|| kindfield == cpu_register)\n-             PPC32_ONLY(|| kindfield == cpu_register) ) &&\n+             ARM_ONLY(|| kindfield == cpu_register) &&\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.cpp","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2144,3 +2144,0 @@\n-#else\n-#if defined(PPC32)\n-        return LIR_OprFact::double_cpu(assigned_regHi, assigned_reg);\n@@ -2149,1 +2146,0 @@\n-#endif \/\/ PPC32\n@@ -2792,3 +2788,0 @@\n-#ifdef PPC32\n-      assert(opr->fpu_regnrLo() == opr->fpu_regnrHi(), \"assumed in calculation (only fpu_regnrHi is used)\");\n-#endif\n","filename":"src\/hotspot\/share\/c1\/c1_LinearScan.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -246,3 +246,0 @@\n-#if defined(PPC32)\n-  case handle_exception_nofpu_id:\n-#endif\n@@ -1182,34 +1179,0 @@\n-#if defined(PPC32)\n-        if (load_klass_or_mirror_patch_id ||\n-            stub_id == Runtime1::load_appendix_patching_id) {\n-          \/\/ Update the location in the nmethod with the proper\n-          \/\/ metadata.  When the code was generated, a NULL was stuffed\n-          \/\/ in the metadata table and that table needs to be update to\n-          \/\/ have the right value.  On intel the value is kept\n-          \/\/ directly in the instruction instead of in the metadata\n-          \/\/ table, so set_data above effectively updated the value.\n-          nmethod* nm = CodeCache::find_nmethod(instr_pc);\n-          assert(nm != NULL, \"invalid nmethod_pc\");\n-          RelocIterator mds(nm, copy_buff, copy_buff + 1);\n-          bool found = false;\n-          while (mds.next() && !found) {\n-            if (mds.type() == relocInfo::oop_type) {\n-              assert(stub_id == Runtime1::load_mirror_patching_id ||\n-                     stub_id == Runtime1::load_appendix_patching_id, \"wrong stub id\");\n-              oop_Relocation* r = mds.oop_reloc();\n-              oop* oop_adr = r->oop_addr();\n-              *oop_adr = stub_id == Runtime1::load_mirror_patching_id ? mirror() : appendix();\n-              r->fix_oop_relocation();\n-              found = true;\n-            } else if (mds.type() == relocInfo::metadata_type) {\n-              assert(stub_id == Runtime1::load_klass_patching_id, \"wrong stub id\");\n-              metadata_Relocation* r = mds.metadata_reloc();\n-              Metadata** metadata_adr = r->metadata_addr();\n-              *metadata_adr = load_klass;\n-              r->fix_metadata_relocation();\n-              found = true;\n-            }\n-          }\n-          assert(found, \"the metadata must exist!\");\n-        }\n-#endif\n@@ -1273,7 +1236,0 @@\n-#ifdef PPC32\n-          { address instr_pc2 = instr_pc + NativeMovConstReg::lo_offset;\n-            RelocIterator iter2(nm, instr_pc2, instr_pc2 + 1);\n-            relocInfo::change_reloc_info_for_address(&iter2, (address) instr_pc2,\n-                                                     relocInfo::none, rtype);\n-          }\n-#endif\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":0,"deletions":44,"binary":false,"changes":44,"status":"modified"}]}