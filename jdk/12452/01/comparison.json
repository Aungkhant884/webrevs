{"files":[{"patch":"@@ -1,157 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"gc\/g1\/g1CardCounts.hpp\"\n-#include \"gc\/g1\/g1CollectedHeap.inline.hpp\"\n-#include \"gc\/shared\/cardTableBarrierSet.hpp\"\n-#include \"services\/memTracker.hpp\"\n-#include \"utilities\/copy.hpp\"\n-\n-void G1CardCountsMappingChangedListener::on_commit(uint start_idx, size_t num_regions, bool zero_filled) {\n-  if (zero_filled) {\n-    return;\n-  }\n-  MemRegion mr(G1CollectedHeap::heap()->bottom_addr_for_region(start_idx), num_regions * HeapRegion::GrainWords);\n-  _counts->clear_range(mr);\n-}\n-\n-size_t G1CardCounts::compute_size(size_t mem_region_size_in_words) {\n-  \/\/ We keep card counts for every card, so the size of the card counts table must\n-  \/\/ be the same as the card table.\n-  return G1CardTable::compute_size(mem_region_size_in_words);\n-}\n-\n-size_t G1CardCounts::heap_map_factor() {\n-  \/\/ See G1CardCounts::compute_size() why we reuse the card table value.\n-  return G1CardTable::heap_map_factor();\n-}\n-\n-void G1CardCounts::clear_range(size_t from_card_num, size_t to_card_num) {\n-  if (has_count_table()) {\n-    assert(from_card_num < to_card_num,\n-           \"Wrong order? from: \" SIZE_FORMAT \", to: \" SIZE_FORMAT,\n-           from_card_num, to_card_num);\n-    Copy::fill_to_bytes(&_card_counts[from_card_num], (to_card_num - from_card_num));\n-  }\n-}\n-\n-G1CardCounts::G1CardCounts(G1CollectedHeap *g1h):\n-  _listener(), _g1h(g1h), _ct(NULL), _card_counts(NULL), _reserved_max_card_num(0), _ct_bot(NULL) {\n-  _listener.set_cardcounts(this);\n-}\n-\n-void G1CardCounts::initialize(G1RegionToSpaceMapper* mapper) {\n-  assert(_g1h->reserved().byte_size() > 0, \"initialization order\");\n-  assert(_g1h->capacity() == 0, \"initialization order\");\n-\n-  if (G1ConcRSHotCardLimit > 0) {\n-    \/\/ The max value we can store in the counts table is\n-    \/\/ max_jubyte. Guarantee the value of the hot\n-    \/\/ threshold limit is no more than this.\n-    guarantee(G1ConcRSHotCardLimit <= max_jubyte, \"sanity\");\n-\n-    _ct = _g1h->card_table();\n-    _ct_bot = _ct->byte_for_const(_g1h->reserved().start());\n-\n-    _card_counts = (jubyte*) mapper->reserved().start();\n-    _reserved_max_card_num = mapper->reserved().byte_size();\n-    mapper->set_mapping_changed_listener(&_listener);\n-  }\n-}\n-\n-uint G1CardCounts::add_card_count(CardValue* card_ptr) {\n-  \/\/ Returns the number of times the card has been refined.\n-  \/\/ If we failed to reserve\/commit the counts table, return 0.\n-  \/\/ If card_ptr is beyond the committed end of the counts table,\n-  \/\/ return 0.\n-  \/\/ Otherwise return the actual count.\n-  \/\/ Unless G1ConcRSHotCardLimit has been set appropriately,\n-  \/\/ returning 0 will result in the card being considered\n-  \/\/ cold and will be refined immediately.\n-  uint count = 0;\n-  if (has_count_table()) {\n-    size_t card_num = ptr_2_card_num(card_ptr);\n-    assert(card_num < _reserved_max_card_num,\n-           \"Card \" SIZE_FORMAT \" outside of card counts table (max size \" SIZE_FORMAT \")\",\n-           card_num, _reserved_max_card_num);\n-    count = (uint) _card_counts[card_num];\n-    if (count < G1ConcRSHotCardLimit) {\n-      _card_counts[card_num] =\n-        (jubyte)(MIN2((uintx)(_card_counts[card_num] + 1), G1ConcRSHotCardLimit));\n-    }\n-  }\n-  return count;\n-}\n-\n-bool G1CardCounts::is_hot(uint count) {\n-  return (count >= G1ConcRSHotCardLimit);\n-}\n-\n-void G1CardCounts::clear_region(HeapRegion* hr) {\n-  MemRegion mr(hr->bottom(), hr->end());\n-  clear_range(mr);\n-}\n-\n-void G1CardCounts::clear_range(MemRegion mr) {\n-  if (has_count_table()) {\n-    const CardValue* from_card_ptr = _ct->byte_for_const(mr.start());\n-    \/\/ We use the last address in the range as the range could represent the\n-    \/\/ last region in the heap. In which case trying to find the card will be an\n-    \/\/ OOB access to the card table.\n-    const CardValue* last_card_ptr = _ct->byte_for_const(mr.last());\n-\n-#ifdef ASSERT\n-    HeapWord* start_addr = _ct->addr_for(from_card_ptr);\n-    assert(start_addr == mr.start(), \"MemRegion start must be aligned to a card.\");\n-    HeapWord* last_addr = _ct->addr_for(last_card_ptr);\n-    assert((last_addr + G1CardTable::card_size_in_words()) == mr.end(), \"MemRegion end must be aligned to a card.\");\n-#endif \/\/ ASSERT\n-\n-    \/\/ Clear the counts for the (exclusive) card range.\n-    size_t from_card_num = ptr_2_card_num(from_card_ptr);\n-    size_t to_card_num = ptr_2_card_num(last_card_ptr) + 1;\n-    clear_range(from_card_num, to_card_num);\n-  }\n-}\n-\n-class G1CardCountsClearClosure : public HeapRegionClosure {\n- private:\n-  G1CardCounts* _card_counts;\n- public:\n-  G1CardCountsClearClosure(G1CardCounts* card_counts) :\n-    HeapRegionClosure(), _card_counts(card_counts) { }\n-\n-\n-  virtual bool do_heap_region(HeapRegion* r) {\n-    _card_counts->clear_region(r);\n-    return false;\n-  }\n-};\n-\n-void G1CardCounts::clear_all() {\n-  assert(SafepointSynchronize::is_at_safepoint(), \"don't call this otherwise\");\n-  G1CardCountsClearClosure cl(this);\n-  _g1h->heap_region_iterate(&cl);\n-}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardCounts.cpp","additions":0,"deletions":157,"binary":false,"changes":157,"status":"deleted"},{"patch":"@@ -1,135 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_G1_G1CARDCOUNTS_HPP\n-#define SHARE_GC_G1_G1CARDCOUNTS_HPP\n-\n-#include \"gc\/g1\/g1CardTable.hpp\"\n-#include \"gc\/g1\/g1RegionToSpaceMapper.hpp\"\n-#include \"memory\/allocation.hpp\"\n-#include \"memory\/virtualspace.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-\n-class CardTableBarrierSet;\n-class G1CardCounts;\n-class G1CollectedHeap;\n-class G1RegionToSpaceMapper;\n-class HeapRegion;\n-\n-class G1CardCountsMappingChangedListener : public G1MappingChangedListener {\n- private:\n-  G1CardCounts* _counts;\n- public:\n-  void set_cardcounts(G1CardCounts* counts) { _counts = counts; }\n-\n-  virtual void on_commit(uint start_idx, size_t num_regions, bool zero_filled);\n-};\n-\n-\/\/ Table to track the number of times a card has been refined. Once\n-\/\/ a card has been refined a certain number of times, it is\n-\/\/ considered 'hot' and its refinement is delayed by inserting the\n-\/\/ card into the hot card cache. The card will then be refined when\n-\/\/ it is evicted from the hot card cache, or when the hot card cache\n-\/\/ is 'drained' during the next evacuation pause.\n-\n-class G1CardCounts: public CHeapObj<mtGC> {\n-public:\n-  typedef CardTable::CardValue CardValue;\n-\n-private:\n-  G1CardCountsMappingChangedListener _listener;\n-\n-  G1CollectedHeap* _g1h;\n-  G1CardTable*     _ct;\n-\n-  \/\/ The table of counts\n-  uint8_t* _card_counts;\n-\n-  \/\/ Max capacity of the reserved space for the counts table\n-  size_t _reserved_max_card_num;\n-\n-  \/\/ CardTable bottom.\n-  const CardValue* _ct_bot;\n-\n-  \/\/ Returns true if the card counts table has been reserved.\n-  bool has_reserved_count_table() { return _card_counts != NULL; }\n-\n-  \/\/ Returns true if the card counts table has been reserved and committed.\n-  bool has_count_table() {\n-    return has_reserved_count_table();\n-  }\n-\n-  size_t ptr_2_card_num(const CardValue* card_ptr) {\n-    assert(card_ptr >= _ct_bot,\n-           \"Invalid card pointer: \"\n-           \"card_ptr: \" PTR_FORMAT \", \"\n-           \"_ct_bot: \" PTR_FORMAT,\n-           p2i(card_ptr), p2i(_ct_bot));\n-    size_t card_num = pointer_delta(card_ptr, _ct_bot, sizeof(CardValue));\n-    assert(card_num < _reserved_max_card_num,\n-           \"card pointer out of range: \" PTR_FORMAT, p2i(card_ptr));\n-    return card_num;\n-  }\n-\n-  CardValue* card_num_2_ptr(size_t card_num) {\n-    assert(card_num < _reserved_max_card_num,\n-           \"card num out of range: \" SIZE_FORMAT, card_num);\n-    return (CardValue*) (_ct_bot + card_num);\n-  }\n-\n-  \/\/ Clear the counts table for the given (exclusive) index range.\n-  void clear_range(size_t from_card_num, size_t to_card_num);\n-\n- public:\n-  G1CardCounts(G1CollectedHeap* g1h);\n-\n-  \/\/ Return the number of slots needed for a card counts table\n-  \/\/ that covers mem_region_words words.\n-  static size_t compute_size(size_t mem_region_size_in_words);\n-\n-  \/\/ Returns how many bytes of the heap a single byte of the card counts table\n-  \/\/ corresponds to.\n-  static size_t heap_map_factor();\n-\n-  void initialize(G1RegionToSpaceMapper* mapper);\n-\n-  \/\/ Increments the refinement count for the given card.\n-  \/\/ Returns the pre-increment count value.\n-  uint add_card_count(CardValue* card_ptr);\n-\n-  \/\/ Returns true if the given count is high enough to be considered\n-  \/\/ 'hot'; false otherwise.\n-  bool is_hot(uint count);\n-\n-  \/\/ Clears the card counts for the cards spanned by the region\n-  void clear_region(HeapRegion* hr);\n-\n-  \/\/ Clears the card counts for the cards spanned by the MemRegion\n-  void clear_range(MemRegion mr);\n-\n-  \/\/ Clear the entire card counts table during GC.\n-  void clear_all();\n-};\n-\n-#endif \/\/ SHARE_GC_G1_G1CARDCOUNTS_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardCounts.hpp","additions":0,"deletions":135,"binary":false,"changes":135,"status":"deleted"},{"patch":"@@ -53,1 +53,0 @@\n-#include \"gc\/g1\/g1HotCardCache.hpp\"\n@@ -1037,4 +1036,0 @@\n-  if (G1HotCardCache::use_cache()) {\n-    _hot_card_cache->reset_hot_cache();\n-  }\n-\n@@ -1442,1 +1437,0 @@\n-  _hot_card_cache(NULL),\n@@ -1580,3 +1574,0 @@\n-  \/\/ Create the hot card cache.\n-  _hot_card_cache = new G1HotCardCache(this);\n-\n@@ -1605,1 +1596,1 @@\n-  \/\/ Create storage for the BOT, card table, card counts table (hot card cache) and the bitmap.\n+  \/\/ Create storage for the BOT, card table and the bitmap.\n@@ -1616,5 +1607,0 @@\n-  G1RegionToSpaceMapper* card_counts_storage =\n-    create_aux_memory_mapper(\"Card Counts Table\",\n-                             G1CardCounts::compute_size(heap_rs.size() \/ HeapWordSize),\n-                             G1CardCounts::heap_map_factor());\n-\n@@ -1625,1 +1611,1 @@\n-  _hrm.initialize(heap_storage, bitmap_storage, bot_storage, cardtable_storage, card_counts_storage);\n+  _hrm.initialize(heap_storage, bitmap_storage, bot_storage, cardtable_storage);\n@@ -1628,3 +1614,0 @@\n-  \/\/ Do later initialization work for concurrent refinement.\n-  _hot_card_cache->initialize(card_counts_storage);\n-\n@@ -1641,1 +1624,1 @@\n-  _rem_set = new G1RemSet(this, _card_table, _hot_card_cache);\n+  _rem_set = new G1RemSet(this, _card_table);\n@@ -1821,4 +1804,0 @@\n-void G1CollectedHeap::iterate_hcc_closure(G1CardTableEntryClosure* cl, uint worker_id) {\n-  _hot_card_cache->drain(cl, worker_id);\n-}\n-\n@@ -2877,7 +2856,0 @@\n-  \/\/ Clear the card counts for this region.\n-  \/\/ Note: we only need to do this if the region is not young\n-  \/\/ (since we don't refine cards in young regions).\n-  if (!hr->is_young()) {\n-    _hot_card_cache->reset_card_counts(hr);\n-  }\n-\n@@ -3312,4 +3284,0 @@\n-void G1CollectedHeap::reset_hot_card_cache() {\n-  _hot_card_cache->reset_hot_cache();\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":3,"deletions":35,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -79,1 +79,0 @@\n-class G1HotCardCache;\n@@ -810,3 +809,0 @@\n-  \/\/ The hot card cache for remembered set insertion optimization.\n-  G1HotCardCache* _hot_card_cache;\n-\n@@ -966,3 +962,0 @@\n-  \/\/ Apply the given closure on all cards in the Hot Card Cache, emptying it.\n-  void iterate_hcc_closure(G1CardTableEntryClosure* cl, uint worker_id);\n-\n@@ -1096,2 +1089,0 @@\n-  G1HotCardCache* hot_card_cache() const { return _hot_card_cache; }\n-\n@@ -1299,4 +1290,0 @@\n-  \/\/ Reset and re-enable the hot card cache.\n-  \/\/ Note the counts for the cards in the regions in the\n-  \/\/ collection set are reset when the collection set is freed.\n-  void reset_hot_card_cache();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"gc\/g1\/g1HotCardCache.hpp\"\n@@ -296,2 +295,1 @@\n-  size_t pending_cards = _policy->pending_cards_at_gc_start() +\n-                         _g1h->hot_card_cache()->num_entries();\n+  size_t pending_cards = _policy->pending_cards_at_gc_start();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSet.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-#include \"gc\/g1\/g1HotCardCache.hpp\"\n@@ -122,5 +121,0 @@\n-\n-  G1HotCardCache* hcc = _g1h->hot_card_cache();\n-  if (G1HotCardCache::use_cache()) {\n-    hcc->reset_card_counts(hr);\n-  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCPrepareTask.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"gc\/g1\/g1HotCardCache.hpp\"\n@@ -86,7 +85,0 @@\n-  if (G1HotCardCache::use_cache()) {\n-    _gc_par_phases[MergeHCC] = new WorkerDataArray<double>(\"MergeHCC\", \"Hot Card Cache (ms):\", max_gc_threads);\n-    _gc_par_phases[MergeHCC]->create_thread_work_items(\"Dirty Cards:\", MergeHCCDirtyCards);\n-    _gc_par_phases[MergeHCC]->create_thread_work_items(\"Skipped Cards:\", MergeHCCSkippedCards);\n-  } else {\n-    _gc_par_phases[MergeHCC] = NULL;\n-  }\n@@ -109,1 +101,0 @@\n-  _gc_par_phases[ResetHotCardCache] = new WorkerDataArray<double>(\"ResetHotCardCache\", \"Reset Hot Card Cache (ms):\", max_gc_threads);\n@@ -251,1 +242,0 @@\n-      ASSERT_PHASE_UNINITIALIZED(MergeHCC);\n@@ -463,3 +453,0 @@\n-  if (G1HotCardCache::use_cache()) {\n-    debug_phase(_gc_par_phases[MergeHCC]);\n-  }\n@@ -521,1 +508,0 @@\n-  debug_phase(_gc_par_phases[ResetHotCardCache], 1);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1GCPhaseTimes.cpp","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -61,1 +61,0 @@\n-    MergeHCC,\n@@ -85,1 +84,0 @@\n-    ResetHotCardCache,\n@@ -132,5 +130,0 @@\n-  enum GCMergeHCCWorkItems {\n-    MergeHCCDirtyCards,\n-    MergeHCCSkippedCards\n-  };\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1GCPhaseTimes.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1,119 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"gc\/g1\/g1CardTableEntryClosure.hpp\"\n-#include \"gc\/g1\/g1CollectedHeap.inline.hpp\"\n-#include \"gc\/g1\/g1DirtyCardQueue.hpp\"\n-#include \"gc\/g1\/g1HotCardCache.hpp\"\n-#include \"runtime\/atomic.hpp\"\n-\n-G1HotCardCache::G1HotCardCache(G1CollectedHeap *g1h):\n-  _g1h(g1h), _card_counts(g1h),\n-  _hot_cache(NULL), _hot_cache_size(0), _hot_cache_par_chunk_size(0),\n-  _hot_cache_idx(0), _hot_cache_par_claimed_idx(0), _cache_wrapped_around(false)\n-{}\n-\n-void G1HotCardCache::initialize(G1RegionToSpaceMapper* card_counts_storage) {\n-  if (use_cache()) {\n-    _hot_cache_size = (size_t)1 << G1ConcRSLogCacheSize;\n-    _hot_cache = ArrayAllocator<CardValue*>::allocate(_hot_cache_size, mtGC);\n-\n-    reset_hot_cache_internal();\n-\n-    \/\/ For refining the cards in the hot cache in parallel\n-    _hot_cache_par_chunk_size = ClaimChunkSize;\n-    _hot_cache_par_claimed_idx = 0;\n-\n-    _cache_wrapped_around = false;\n-\n-    _card_counts.initialize(card_counts_storage);\n-  }\n-}\n-\n-G1HotCardCache::~G1HotCardCache() {\n-  if (use_cache()) {\n-    assert(_hot_cache != NULL, \"Logic\");\n-    ArrayAllocator<CardValue*>::free(_hot_cache, _hot_cache_size);\n-    _hot_cache = NULL;\n-  }\n-}\n-\n-CardTable::CardValue* G1HotCardCache::insert(CardValue* card_ptr) {\n-  uint count = _card_counts.add_card_count(card_ptr);\n-  if (!_card_counts.is_hot(count)) {\n-    \/\/ The card is not hot so do not store it in the cache;\n-    \/\/ return it for immediate refining.\n-    return card_ptr;\n-  }\n-  \/\/ Otherwise, the card is hot.\n-  size_t index = Atomic::fetch_and_add(&_hot_cache_idx, 1u);\n-  if (index == _hot_cache_size) {\n-    \/\/ Can use relaxed store because all racing threads are writing the same\n-    \/\/ value and there aren't any concurrent readers.\n-    Atomic::store(&_cache_wrapped_around, true);\n-  }\n-  size_t masked_index = index & (_hot_cache_size - 1);\n-  CardValue* current_ptr = _hot_cache[masked_index];\n-\n-  \/\/ Try to store the new card pointer into the cache. Compare-and-swap to guard\n-  \/\/ against the unlikely event of a race resulting in another card pointer to\n-  \/\/ have already been written to the cache. In this case we will return\n-  \/\/ card_ptr in favor of the other option, which would be starting over. This\n-  \/\/ should be OK since card_ptr will likely be the older card already when\/if\n-  \/\/ this ever happens.\n-  CardValue* previous_ptr = Atomic::cmpxchg(&_hot_cache[masked_index],\n-                                            current_ptr,\n-                                            card_ptr);\n-  return (previous_ptr == current_ptr) ? previous_ptr : card_ptr;\n-}\n-\n-void G1HotCardCache::drain(G1CardTableEntryClosure* cl, uint worker_id) {\n-  assert(use_cache(), \"Drain only necessary if we use the hot card cache.\");\n-\n-  assert(_hot_cache != NULL, \"Logic\");\n-\n-  while (_hot_cache_par_claimed_idx < _hot_cache_size) {\n-    size_t end_idx = Atomic::add(&_hot_cache_par_claimed_idx,\n-                                 _hot_cache_par_chunk_size);\n-    size_t start_idx = end_idx - _hot_cache_par_chunk_size;\n-    \/\/ The current worker has successfully claimed the chunk [start_idx..end_idx)\n-    end_idx = MIN2(end_idx, _hot_cache_size);\n-    for (size_t i = start_idx; i < end_idx; i++) {\n-      CardValue* card_ptr = _hot_cache[i];\n-      if (card_ptr != NULL) {\n-        cl->do_card_ptr(card_ptr, worker_id);\n-      } else {\n-        break;\n-      }\n-    }\n-  }\n-\n-  \/\/ The existing entries in the hot card cache, which were just refined\n-  \/\/ above, are discarded prior to re-enabling the cache near the end of the GC.\n-}\n-\n-void G1HotCardCache::reset_card_counts(HeapRegion* hr) {\n-  _card_counts.clear_region(hr);\n-}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HotCardCache.cpp","additions":0,"deletions":119,"binary":false,"changes":119,"status":"deleted"},{"patch":"@@ -1,146 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_G1_G1HOTCARDCACHE_HPP\n-#define SHARE_GC_G1_G1HOTCARDCACHE_HPP\n-\n-#include \"gc\/g1\/g1CardCounts.hpp\"\n-#include \"memory\/allocation.hpp\"\n-#include \"runtime\/javaThread.hpp\"\n-#include \"runtime\/safepoint.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-\n-class G1CardTableEntryClosure;\n-class G1CollectedHeap;\n-class HeapRegion;\n-\n-\/\/ An evicting cache of cards that have been logged by the G1 post\n-\/\/ write barrier. Placing a card in the cache delays the refinement\n-\/\/ of the card until the card is evicted, or the cache is drained\n-\/\/ during the next evacuation pause.\n-\/\/\n-\/\/ The first thing the G1 post write barrier does is to check whether\n-\/\/ the card containing the updated pointer is already dirty and, if\n-\/\/ so, skips the remaining code in the barrier.\n-\/\/\n-\/\/ Delaying the refinement of a card will make the card fail the\n-\/\/ first is_dirty check in the write barrier, skipping the remainder\n-\/\/ of the write barrier.\n-\/\/\n-\/\/ This can significantly reduce the overhead of the write barrier\n-\/\/ code, increasing throughput.\n-\n-class G1HotCardCache: public CHeapObj<mtGC> {\n-public:\n-  typedef CardTable::CardValue CardValue;\n-\n-private:\n-  G1CollectedHeap*  _g1h;\n-\n-  G1CardCounts      _card_counts;\n-\n-\n-  \/\/ The card cache table\n-  CardValue** _hot_cache;\n-\n-  size_t            _hot_cache_size;\n-\n-  size_t            _hot_cache_par_chunk_size;\n-\n-  \/\/ Avoids false sharing when concurrently updating _hot_cache_idx or\n-  \/\/ _hot_cache_par_claimed_idx. These are never updated at the same time\n-  \/\/ thus it's not necessary to separate them as well\n-  char _pad_before[DEFAULT_CACHE_LINE_SIZE];\n-\n-  volatile size_t _hot_cache_idx;\n-\n-  volatile size_t _hot_cache_par_claimed_idx;\n-\n-  char _pad_after[DEFAULT_CACHE_LINE_SIZE];\n-\n-  \/\/ Records whether insertion overflowed the hot card cache at least once. This\n-  \/\/ avoids the need for a separate atomic counter of how many valid entries are\n-  \/\/ in the HCC.\n-  volatile bool _cache_wrapped_around;\n-\n-  \/\/ The number of cached cards a thread claims when flushing the cache\n-  static const int ClaimChunkSize = 32;\n-\n- public:\n-  static bool use_cache() {\n-    return (G1ConcRSLogCacheSize > 0);\n-  }\n-\n-  G1HotCardCache(G1CollectedHeap* g1h);\n-  ~G1HotCardCache();\n-\n-  void initialize(G1RegionToSpaceMapper* card_counts_storage);\n-\n-  \/\/ Returns the card to be refined or NULL.\n-  \/\/\n-  \/\/ Increments the count for given the card. if the card is not 'hot',\n-  \/\/ it is returned for immediate refining. Otherwise the card is\n-  \/\/ added to the hot card cache.\n-  \/\/ If there is enough room in the hot card cache for the card we're\n-  \/\/ adding, NULL is returned and no further action in needed.\n-  \/\/ If we evict a card from the cache to make room for the new card,\n-  \/\/ the evicted card is then returned for refinement.\n-  CardValue* insert(CardValue* card_ptr);\n-\n-  \/\/ Refine the cards that have delayed as a result of\n-  \/\/ being in the cache.\n-  void drain(G1CardTableEntryClosure* cl, uint worker_id);\n-\n-  \/\/ Set up for parallel processing of the cards in the hot cache\n-  void reset_hot_cache_claimed_index() {\n-    _hot_cache_par_claimed_idx = 0;\n-  }\n-\n-  \/\/ Resets the hot card cache and discards the entries.\n-  void reset_hot_cache() {\n-    assert(SafepointSynchronize::is_at_safepoint(), \"Should be at a safepoint\");\n-    if (use_cache()) {\n-      reset_hot_cache_internal();\n-    }\n-  }\n-\n-  \/\/ Zeros the values in the card counts table for the given region\n-  void reset_card_counts(HeapRegion* hr);\n-\n-  \/\/ Number of entries in the HCC.\n-  size_t num_entries() const {\n-    return _cache_wrapped_around ? _hot_cache_size : _hot_cache_idx + 1;\n-  }\n- private:\n-  void reset_hot_cache_internal() {\n-    assert(_hot_cache != NULL, \"Logic\");\n-    _hot_cache_idx = 0;\n-    for (size_t i = 0; i < _hot_cache_size; i++) {\n-      _hot_cache[i] = NULL;\n-    }\n-    _cache_wrapped_around = false;\n-  }\n-};\n-\n-#endif \/\/ SHARE_GC_G1_G1HOTCARDCACHE_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HotCardCache.hpp","additions":0,"deletions":146,"binary":false,"changes":146,"status":"deleted"},{"patch":"@@ -37,1 +37,0 @@\n-#include \"gc\/g1\/g1HotCardCache.hpp\"\n@@ -803,1 +802,0 @@\n-  double merge_hcc_time_ms = average_time_ms(G1GCPhaseTimes::MergeHCC);\n@@ -806,2 +804,1 @@\n-    size_t const merged_cards_from_log_buffers = p->sum_thread_work_items(G1GCPhaseTimes::MergeHCC, G1GCPhaseTimes::MergeHCCDirtyCards) +\n-                                                 p->sum_thread_work_items(G1GCPhaseTimes::MergeLB, G1GCPhaseTimes::MergeLBDirtyCards);\n+    size_t const merged_cards_from_log_buffers = p->sum_thread_work_items(G1GCPhaseTimes::MergeLB, G1GCPhaseTimes::MergeLBDirtyCards);\n@@ -817,1 +814,0 @@\n-                                    average_time_ms(G1GCPhaseTimes::MergeHCC) +\n@@ -900,10 +896,0 @@\n-  if (logged_cards_time_goal_ms < merge_hcc_time_ms) {\n-    log_debug(gc, ergo, refine)(\"Adjust concurrent refinement thresholds (scanning the HCC expected to take longer than Update RS time goal).\"\n-                                \"Logged Cards Scan time goal: %1.2fms Scan HCC time: %1.2fms\",\n-                                logged_cards_time_goal_ms, merge_hcc_time_ms);\n-\n-    logged_cards_time_goal_ms = 0;\n-  } else {\n-    logged_cards_time_goal_ms -= merge_hcc_time_ms;\n-  }\n-\n@@ -914,3 +900,0 @@\n-  size_t hcc_cards =\n-    phase_times()->sum_thread_work_items(G1GCPhaseTimes::MergeHCC,\n-                                         G1GCPhaseTimes::MergeHCCDirtyCards);\n@@ -922,1 +905,1 @@\n-           (\"GC refinement: goal: %zu + %zu \/ %1.2fms, actual: %zu \/ %1.2fms, HCC: %zu \/ %1.2fms%s\",\n+           (\"GC refinement: goal: %zu + %zu \/ %1.2fms, actual: %zu \/ %1.2fms, %s\",\n@@ -928,2 +911,0 @@\n-            hcc_cards,\n-            merge_hcc_time_ms,\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":2,"deletions":21,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-#include \"gc\/g1\/g1HotCardCache.hpp\"\n@@ -67,1 +66,1 @@\n-\/\/ scanned (log buffers, hcc, remembered sets) into a single data structure to remove\n+\/\/ scanned (log buffers, remembered sets) into a single data structure to remove\n@@ -470,2 +469,1 @@\n-                   G1CardTable* ct,\n-                   G1HotCardCache* hot_card_cache) :\n+                   G1CardTable* ct) :\n@@ -476,2 +474,1 @@\n-  _g1p(_g1h->policy()),\n-  _hot_card_cache(hot_card_cache) {\n+  _g1p(_g1h->policy()) {\n@@ -1373,11 +1370,0 @@\n-    \/\/ Apply closure to log entries in the HCC.\n-    if (_initial_evacuation && G1HotCardCache::use_cache()) {\n-      assert(merge_remset_phase == G1GCPhaseTimes::MergeRS, \"Wrong merge phase\");\n-      G1GCParPhaseTimesTracker x(p, G1GCPhaseTimes::MergeHCC, worker_id);\n-      G1MergeLogBufferCardsClosure cl(g1h, _scan_state);\n-      g1h->iterate_hcc_closure(&cl, worker_id);\n-\n-      p->record_thread_work_item(G1GCPhaseTimes::MergeHCC, worker_id, cl.cards_dirty(), G1GCPhaseTimes::MergeHCCDirtyCards);\n-      p->record_thread_work_item(G1GCPhaseTimes::MergeHCC, worker_id, cl.cards_skipped(), G1GCPhaseTimes::MergeHCCSkippedCards);\n-    }\n-\n@@ -1531,31 +1517,0 @@\n-  \/\/ The result from the hot card cache insert call is either:\n-  \/\/   * pointer to the current card\n-  \/\/     (implying that the current card is not 'hot'),\n-  \/\/   * null\n-  \/\/     (meaning we had inserted the card ptr into the \"hot\" card cache,\n-  \/\/     which had some headroom),\n-  \/\/   * a pointer to a \"hot\" card that was evicted from the \"hot\" cache.\n-  \/\/\n-\n-  if (G1HotCardCache::use_cache()) {\n-    const CardValue* orig_card_ptr = card_ptr;\n-    card_ptr = _hot_card_cache->insert(card_ptr);\n-    if (card_ptr == NULL) {\n-      \/\/ There was no eviction. Nothing to do.\n-      return false;\n-    } else if (card_ptr != orig_card_ptr) {\n-      \/\/ Original card was inserted and an old card was evicted.\n-      start = _ct->addr_for(card_ptr);\n-      r = _g1h->heap_region_containing_or_null(start);\n-\n-      \/\/ Check whether the region formerly in the cache should be\n-      \/\/ ignored, as discussed earlier for the original card.  The\n-      \/\/ region could have been freed (or even uncommitted) while\n-      \/\/ in the cache.\n-      if (r == nullptr || !r->is_old_or_humongous_or_archive()) {\n-        return false;\n-      }\n-      *card_ptr_addr = card_ptr;\n-    } \/\/ Else we still have the original card.\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.cpp","additions":3,"deletions":48,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -46,1 +46,0 @@\n-class G1HotCardCache;\n@@ -72,1 +71,0 @@\n-  G1HotCardCache*        _hot_card_cache;\n@@ -84,3 +82,1 @@\n-  G1RemSet(G1CollectedHeap* g1h,\n-           G1CardTable* ct,\n-           G1HotCardCache* hot_card_cache);\n+  G1RemSet(G1CollectedHeap* g1h, G1CardTable* ct);\n@@ -97,1 +93,1 @@\n-  \/\/ Merge cards from various sources (remembered sets, hot card cache, log buffers)\n+  \/\/ Merge cards from various sources (remembered sets, log buffers)\n@@ -129,2 +125,1 @@\n-  \/\/ card needs later refinement. Note that \"*card_ptr_addr\" could be updated to\n-  \/\/ a different card due to use of hot card cache.\n+  \/\/ card needs later refinement.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.hpp","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-#include \"gc\/g1\/g1HotCardCache.hpp\"\n@@ -205,4 +204,0 @@\n-G1HotCardCache* G1YoungCollector::hot_card_cache() const {\n-  return _g1h->hot_card_cache();\n-}\n-\n@@ -523,2 +518,0 @@\n-  hot_card_cache()->reset_hot_cache_claimed_index();\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n-class G1HotCardCache;\n@@ -72,1 +71,1 @@\n-  G1HotCardCache* hot_card_cache() const;\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -242,8 +242,0 @@\n-class G1PostEvacuateCollectionSetCleanupTask2::ResetHotCardCacheTask : public G1AbstractSubTask {\n-public:\n-  ResetHotCardCacheTask() : G1AbstractSubTask(G1GCPhaseTimes::ResetHotCardCache) { }\n-\n-  double worker_cost() const override { return 0.5; }\n-  void do_work(uint worker_id) override { G1CollectedHeap::heap()->reset_hot_card_cache(); }\n-};\n-\n@@ -736,1 +728,0 @@\n-  add_serial_task(new ResetHotCardCacheTask());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -57,1 +57,0 @@\n-\/\/ - Reset Hot Card Cache (s)\n@@ -66,1 +65,0 @@\n-  class ResetHotCardCacheTask;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -181,8 +181,0 @@\n-  product(size_t, G1ConcRSLogCacheSize, 10,                                 \\\n-          \"Log base 2 of the length of conc RS hot-card cache.\")            \\\n-          range(0, 27)                                                      \\\n-                                                                            \\\n-  product(uintx, G1ConcRSHotCardLimit, 4,                                   \\\n-          \"The threshold that defines (>=) a hot card.\")                    \\\n-          range(0, max_jubyte)                                              \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/gc\/g1\/g1_globals.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -67,1 +67,0 @@\n-  _card_counts_mapper(NULL),\n@@ -78,2 +77,1 @@\n-                                   G1RegionToSpaceMapper* cardtable,\n-                                   G1RegionToSpaceMapper* card_counts) {\n+                                   G1RegionToSpaceMapper* cardtable) {\n@@ -89,2 +87,0 @@\n-  _card_counts_mapper = card_counts;\n-\n@@ -194,2 +190,0 @@\n-\n-  _card_counts_mapper->commit_regions(index, num_regions, pretouch_workers);\n@@ -221,2 +215,0 @@\n-  _card_counts_mapper->uncommit_regions(start, num_regions);\n-\n@@ -274,2 +266,0 @@\n-  \/\/ Signal G1CardCounts to clear the given regions.\n-  _card_counts_mapper->signal_mapping_changed(start, num_regions);\n@@ -282,2 +272,1 @@\n-    _cardtable_mapper->committed_size() +\n-    _card_counts_mapper->committed_size();\n+    _cardtable_mapper->committed_size();\n@@ -288,2 +277,1 @@\n-    _cardtable_mapper->reserved_size() +\n-    _card_counts_mapper->reserved_size();\n+    _cardtable_mapper->reserved_size();\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionManager.cpp","additions":3,"deletions":15,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -79,1 +79,0 @@\n-  G1RegionToSpaceMapper* _card_counts_mapper;\n@@ -166,2 +165,1 @@\n-                  G1RegionToSpaceMapper* cardtable,\n-                  G1RegionToSpaceMapper* card_counts);\n+                  G1RegionToSpaceMapper* cardtable);\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionManager.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -558,0 +558,3 @@\n+  { \"G1ConcRSLogCacheSize\",    JDK_Version::undefined(), JDK_Version::jdk(21), JDK_Version::undefined() },\n+  { \"G1ConcRSHotCardLimit\",   JDK_Version::undefined(), JDK_Version::jdk(21), JDK_Version::undefined() },\n+\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -129,1 +129,0 @@\n-        new LogMessageWithLevel(\"Hot Card Cache\", Level.DEBUG),\n@@ -182,1 +181,0 @@\n-        new LogMessageWithLevel(\"Reset Hot Card Cache\", Level.DEBUG),\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestGCLogMessages.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -105,1 +105,0 @@\n-        checkSize(output, expectedPageSize, \"Card Counts Table: .*page_size=([^ ]+)\");\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestLargePageUseForAuxMemory.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,47 +0,0 @@\n-\/*\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package gc.g1;\n-\n-\/*\n- * @test TestNoUseHCC\n- * @summary Check that G1 survives a GC without HCC enabled\n- * @requires vm.gc.G1\n- * @modules java.base\/jdk.internal.misc\n- * @library \/test\/lib\n- * @build jdk.test.whitebox.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n- * @run main\/othervm -Xbootclasspath\/a:. -Xlog:gc+phases=debug -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseG1GC -Xmx64M -XX:G1ConcRSLogCacheSize=0 gc.g1.TestNoUseHCC\n- *\/\n-\n-import jdk.test.whitebox.WhiteBox;\n-\n-public class TestNoUseHCC {\n-\n-    private static final WhiteBox WB = WhiteBox.getWhiteBox();\n-\n-    public static void main(String [] args) {\n-        WB.youngGC();\n-    }\n-}\n-\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestNoUseHCC.java","additions":0,"deletions":47,"binary":false,"changes":47,"status":"deleted"},{"patch":"@@ -42,1 +42,0 @@\n-import jdk.internal.misc.Unsafe; \/\/ for ADDRESS_SIZE\n@@ -64,4 +63,1 @@\n-    private final int hotCardTableSize;\n-\n-    protected TestShrinkAuxiliaryData(int hotCardTableSize) {\n-        this.hotCardTableSize = hotCardTableSize;\n+    protected TestShrinkAuxiliaryData() {\n@@ -74,10 +70,1 @@\n-        int maxCacheSize = Math.max(0, Math.min(31, getMaxCacheSize()));\n-        if (maxCacheSize < hotCardTableSize) {\n-            throw new SkippedException(String.format(\n-                    \"Skiping test for %d cache size due max cache size %d\",\n-                    hotCardTableSize, maxCacheSize));\n-        }\n-\n-        printTestInfo(maxCacheSize);\n-\n-        vmOpts.add(\"-XX:G1ConcRSLogCacheSize=\" + hotCardTableSize);\n+        printTestInfo();\n@@ -112,2 +99,1 @@\n-    private void printTestInfo(int maxCacheSize) {\n-\n+    private void printTestInfo() {\n@@ -120,3 +106,1 @@\n-                \"Test will use %s bytes of memory of %s available%n\"\n-                + \"Available memory is %s with %d bytes pointer size - can save %s pointers%n\"\n-                + \"Max cache size: 2^%d = %s elements%n\",\n+                \"Test will use %s bytes of memory of %s available%n\",\n@@ -124,9 +108,1 @@\n-                grouped.format(Runtime.getRuntime().maxMemory()),\n-                grouped.format(Runtime.getRuntime().maxMemory()\n-                        - ShrinkAuxiliaryDataTest.getMemoryUsedByTest()),\n-                Unsafe.ADDRESS_SIZE,\n-                grouped.format((Runtime.getRuntime().freeMemory()\n-                        - ShrinkAuxiliaryDataTest.getMemoryUsedByTest())\n-                        \/ Unsafe.ADDRESS_SIZE),\n-                maxCacheSize,\n-                grouped.format((int) Math.pow(2, maxCacheSize))\n+                grouped.format(Runtime.getRuntime().maxMemory())\n@@ -136,17 +112,0 @@\n-    \/**\n-     * Detects maximum possible size of G1ConcRSLogCacheSize available for\n-     * current process based on maximum available process memory size\n-     *\n-     * @return power of two\n-     *\/\n-    private static int getMaxCacheSize() {\n-        long availableMemory = Runtime.getRuntime().freeMemory()\n-                - ShrinkAuxiliaryDataTest.getMemoryUsedByTest() - 1l;\n-        if (availableMemory <= 0) {\n-            return 0;\n-        }\n-\n-        long availablePointersCount = availableMemory \/ Unsafe.ADDRESS_SIZE;\n-        return (63 - (int) Long.numberOfLeadingZeros(availablePointersCount));\n-    }\n-\n@@ -169,1 +128,0 @@\n-         * - RSet cache size is not too big\n@@ -176,0 +134,2 @@\n+            \/\/ Auxiliary data size is about ~1.9% of heap size.\n+            int auxDataSize = REGION_SIZE * REGIONS_TO_ALLOCATE * 19 \/ 1000;\n@@ -178,1 +138,1 @@\n-                    + \" aux data ~= \" + (REGION_SIZE * 3 \/ 100));\n+                    + \" aux data ~= \" + auxDataSize);\n@@ -180,2 +140,1 @@\n-            \/\/ Auxiliary data size is about ~3.6% of heap size.\n-            if (pageSize >= REGION_SIZE * 3 \/ 100) {\n+            if (pageSize >= auxDataSize) {\n@@ -232,2 +191,0 @@\n-            long numUsedRegions = WhiteBox.getWhiteBox().g1NumMaxRegions()\n-                    - WhiteBox.getWhiteBox().g1NumFreeRegions();\n@@ -235,1 +192,0 @@\n-            auxFull = (float)muAuxDataFull.getUsed() \/ numUsedRegions;\n@@ -237,2 +193,2 @@\n-            System.out.format(\"Full aux data  ratio= %f, regions max= %d, used= %d\\n\",\n-                    auxFull, WhiteBox.getWhiteBox().g1NumMaxRegions(), numUsedRegions\n+            System.out.format(\"Full -- heap capacity: %d, Aux data: %d\\n\",\n+                    muFull.getCommitted(), muAuxDataFull.getUsed()\n@@ -255,6 +211,2 @@\n-            numUsedRegions = WhiteBox.getWhiteBox().g1NumMaxRegions()\n-                    - WhiteBox.getWhiteBox().g1NumFreeRegions();\n-            auxFree = (float)muAuxDataFree.getUsed() \/ numUsedRegions;\n-\n-            System.out.format(\"Free aux data ratio= %f, regions max= %d, used= %d\\n\",\n-                    auxFree, WhiteBox.getWhiteBox().g1NumMaxRegions(), numUsedRegions\n+            System.out.format(\"Free -- heap capacity: %d, Aux data: %d\\n\",\n+                    muFree.getCommitted(), muAuxDataFree.getUsed()\n@@ -263,4 +215,2 @@\n-            Asserts.assertLessThanOrEqual(muFree.getCommitted(), muFull.getCommitted(),\n-                    String.format(\"heap decommit failed - full > free: %d > %d\",\n-                            muFree.getCommitted(), muFull.getCommitted()\n-                    )\n+            Asserts.assertLessThan(muFree.getCommitted(), muFull.getCommitted(),\n+                                   \"heap decommit failed\"\n@@ -269,12 +219,3 @@\n-            System.out.format(\"State               used   committed\\n\");\n-            System.out.format(\"Full aux data: %10d %10d\\n\", muAuxDataFull.getUsed(), muAuxDataFull.getCommitted());\n-            System.out.format(\"Free aux data: %10d %10d\\n\", muAuxDataFree.getUsed(), muAuxDataFree.getCommitted());\n-\n-            \/\/ if decommited check that aux data has same ratio\n-            if (muFree.getCommitted() < muFull.getCommitted()) {\n-                Asserts.assertLessThanOrEqual(auxFree, auxFull,\n-                        String.format(\"auxiliary data decommit failed - full > free: %f > %f\",\n-                                auxFree, auxFull\n-                        )\n-                );\n-            }\n+            Asserts.assertLessThan(muAuxDataFree.getUsed(), muAuxDataFull.getUsed(),\n+                                   \"auxiliary data decommit failed\"\n+            );\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestShrinkAuxiliaryData.java","additions":18,"deletions":77,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -1,46 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package gc.g1;\n-\n-\/**\n- * @test TestShrinkAuxiliaryData00\n- * @key randomness\n- * @bug 8038423 8061715\n- * @summary Checks that decommitment occurs for JVM with different\n- * G1ConcRSLogCacheSize and ObjectAlignmentInBytes options values\n- * @requires vm.gc.G1\n- * @library \/test\/lib\n- * @library \/\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @build jdk.test.whitebox.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n- * @run main\/timeout=720 gc.g1.TestShrinkAuxiliaryData00\n- *\/\n-public class TestShrinkAuxiliaryData00 {\n-\n-    public static void main(String[] args) throws Exception {\n-        new TestShrinkAuxiliaryData(0).test();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestShrinkAuxiliaryData00.java","additions":0,"deletions":46,"binary":false,"changes":46,"status":"deleted"},{"patch":"@@ -1,46 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package gc.g1;\n-\n-\/**\n- * @test TestShrinkAuxiliaryData05\n- * @key randomness\n- * @bug 8038423 8061715 8078405\n- * @summary Checks that decommitment occurs for JVM with different\n- * G1ConcRSLogCacheSize and ObjectAlignmentInBytes options values\n- * @requires vm.gc.G1\n- * @library \/test\/lib\n- * @library \/\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @build jdk.test.whitebox.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n- * @run main\/timeout=720 gc.g1.TestShrinkAuxiliaryData05\n- *\/\n-public class TestShrinkAuxiliaryData05 {\n-\n-    public static void main(String[] args) throws Exception {\n-        new TestShrinkAuxiliaryData(5).test();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestShrinkAuxiliaryData05.java","additions":0,"deletions":46,"binary":false,"changes":46,"status":"deleted"},{"patch":"@@ -1,46 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package gc.g1;\n-\n-\/**\n- * @test TestShrinkAuxiliaryData10\n- * @key randomness\n- * @bug 8038423 8061715 8078405\n- * @summary Checks that decommitment occurs for JVM with different\n- * G1ConcRSLogCacheSize and ObjectAlignmentInBytes options values\n- * @requires vm.gc.G1\n- * @library \/test\/lib\n- * @library \/\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @build jdk.test.whitebox.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n- * @run main\/timeout=720 gc.g1.TestShrinkAuxiliaryData10\n- *\/\n-public class TestShrinkAuxiliaryData10 {\n-\n-    public static void main(String[] args) throws Exception {\n-        new TestShrinkAuxiliaryData(10).test();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestShrinkAuxiliaryData10.java","additions":0,"deletions":46,"binary":false,"changes":46,"status":"deleted"},{"patch":"@@ -1,46 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package gc.g1;\n-\n-\/**\n- * @test TestShrinkAuxiliaryData15\n- * @bug 8038423 8061715 8078405\n- * @key randomness\n- * @summary Checks that decommitment occurs for JVM with different\n- * G1ConcRSLogCacheSize and ObjectAlignmentInBytes options values\n- * @requires vm.gc.G1\n- * @library \/test\/lib\n- * @library \/\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @build jdk.test.whitebox.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n- * @run main\/timeout=720 gc.g1.TestShrinkAuxiliaryData15\n- *\/\n-public class TestShrinkAuxiliaryData15 {\n-\n-    public static void main(String[] args) throws Exception {\n-        new TestShrinkAuxiliaryData(15).test();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestShrinkAuxiliaryData15.java","additions":0,"deletions":46,"binary":false,"changes":46,"status":"deleted"},{"patch":"@@ -1,46 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package gc.g1;\n-\n-\/**\n- * @test TestShrinkAuxiliaryData20\n- * @key randomness\n- * @bug 8038423 8061715 8078405\n- * @summary Checks that decommitment occurs for JVM with different\n- * G1ConcRSLogCacheSize and ObjectAlignmentInBytes options values\n- * @requires vm.gc.G1\n- * @library \/test\/lib\n- * @library \/\n- * @modules java.base\/jdk.internal.misc\n-  *          java.management\n- * @build jdk.test.whitebox.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n- * @run main\/timeout=720 gc.g1.TestShrinkAuxiliaryData20\n- *\/\n-public class TestShrinkAuxiliaryData20 {\n-\n-    public static void main(String[] args) throws Exception {\n-        new TestShrinkAuxiliaryData(20).test();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestShrinkAuxiliaryData20.java","additions":0,"deletions":46,"binary":false,"changes":46,"status":"deleted"},{"patch":"@@ -1,46 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package gc.g1;\n-\n-\/**\n- * @test TestShrinkAuxiliaryData25\n- * @key randomness\n- * @bug 8038423 8061715 8078405\n- * @summary Checks that decommitment occurs for JVM with different\n- * G1ConcRSLogCacheSize and ObjectAlignmentInBytes options values\n- * @requires vm.gc.G1\n- * @library \/test\/lib\n- * @library \/\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @build jdk.test.whitebox.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n- * @run main\/timeout=720 gc.g1.TestShrinkAuxiliaryData25\n- *\/\n-public class TestShrinkAuxiliaryData25 {\n-\n-    public static void main(String[] args) throws Exception {\n-        new TestShrinkAuxiliaryData(25).test();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestShrinkAuxiliaryData25.java","additions":0,"deletions":46,"binary":false,"changes":46,"status":"deleted"},{"patch":"@@ -1,46 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package gc.g1;\n-\n-\/**\n- * @test TestShrinkAuxiliaryData27\n- * @key randomness\n- * @bug 8038423 8061715 8078405\n- * @summary Checks that decommitment occurs for JVM with different\n- * G1ConcRSLogCacheSize and ObjectAlignmentInBytes options values\n- * @requires vm.gc.G1\n- * @library \/test\/lib\n- * @library \/\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @build jdk.test.whitebox.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n- * @run main\/timeout=720 gc.g1.TestShrinkAuxiliaryData27\n- *\/\n-public class TestShrinkAuxiliaryData27 {\n-\n-    public static void main(String[] args) throws Exception {\n-        new TestShrinkAuxiliaryData(27).test();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestShrinkAuxiliaryData27.java","additions":0,"deletions":46,"binary":false,"changes":46,"status":"deleted"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package gc.g1;\n+\n+\/**\n+ * @test TestShrinkAuxiliaryDataRunner\n+ * @key randomness\n+ * @bug 8038423 8061715\n+ * @summary Checks that decommitment occurs for JVM with different ObjectAlignmentInBytes values\n+ * @requires vm.gc.G1\n+ * @library \/test\/lib\n+ * @library \/\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/timeout=720 gc.g1.TestShrinkAuxiliaryDataRunner\n+ *\/\n+public class TestShrinkAuxiliaryDataRunner {\n+\n+    public static void main(String[] args) throws Exception {\n+        new TestShrinkAuxiliaryData().test();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestShrinkAuxiliaryDataRunner.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -100,1 +100,0 @@\n-            \"MergeHCC\",\n@@ -109,1 +108,0 @@\n-            \"ResetHotCardCache\",\n","filename":"test\/jdk\/jdk\/jfr\/event\/gc\/collection\/TestG1ParallelPhases.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"}]}