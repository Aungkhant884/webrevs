{"files":[{"patch":"@@ -34,1 +34,2 @@\n-STATIC_ASSERT(sizeof(BitMap::bm_word_t) == BytesPerWord); \/\/ \"Implementation assumption.\"\n+using bm_word_t = BitMap::bm_word_t;\n+using idx_t = BitMap::idx_t;\n@@ -36,2 +37,1 @@\n-typedef BitMap::bm_word_t bm_word_t;\n-typedef BitMap::idx_t     idx_t;\n+STATIC_ASSERT(sizeof(bm_word_t) == BytesPerWord); \/\/ \"Implementation assumption.\"\n@@ -39,38 +39,2 @@\n-class ResourceBitMapAllocator : StackObj {\n- public:\n-  bm_word_t* allocate(idx_t size_in_words) const {\n-    return NEW_RESOURCE_ARRAY(bm_word_t, size_in_words);\n-  }\n-  void free(bm_word_t* map, idx_t size_in_words) const {\n-    \/\/ Don't free resource allocated arrays.\n-  }\n-};\n-\n-class CHeapBitMapAllocator : StackObj {\n-  MEMFLAGS _flags;\n-\n- public:\n-  CHeapBitMapAllocator(MEMFLAGS flags) : _flags(flags) {}\n-  bm_word_t* allocate(size_t size_in_words) const {\n-    return ArrayAllocator<bm_word_t>::allocate(size_in_words, _flags);\n-  }\n-  void free(bm_word_t* map, idx_t size_in_words) const {\n-    ArrayAllocator<bm_word_t>::free(map, size_in_words);\n-  }\n-};\n-\n-class ArenaBitMapAllocator : StackObj {\n-  Arena* _arena;\n-\n- public:\n-  ArenaBitMapAllocator(Arena* arena) : _arena(arena) {}\n-  bm_word_t* allocate(idx_t size_in_words) const {\n-    return (bm_word_t*)_arena->Amalloc(size_in_words * BytesPerWord);\n-  }\n-  void free(bm_word_t* map, idx_t size_in_words) const {\n-    \/\/ ArenaBitMaps currently don't free memory.\n-  }\n-};\n-\n-template <class Allocator>\n-BitMap::bm_word_t* BitMap::reallocate(const Allocator& allocator, bm_word_t* old_map, idx_t old_size_in_bits, idx_t new_size_in_bits, bool clear) {\n+template <class BitMapWithAllocator>\n+bm_word_t* GrowableBitMap<BitMapWithAllocator>::reallocate(bm_word_t* old_map, idx_t old_size_in_bits, idx_t new_size_in_bits, bool clear) {\n@@ -81,0 +45,1 @@\n+  BitMapWithAllocator* derived = static_cast<BitMapWithAllocator*>(this);\n@@ -83,1 +48,1 @@\n-    map = allocator.allocate(new_size_in_words);\n+    map = derived->allocate(new_size_in_words);\n@@ -102,1 +67,1 @@\n-    allocator.free(old_map, old_size_in_words);\n+    derived->free(old_map, old_size_in_words);\n@@ -108,4 +73,3 @@\n-template <class Allocator>\n-bm_word_t* BitMap::allocate(const Allocator& allocator, idx_t size_in_bits, bool clear) {\n-  \/\/ Reuse reallocate to ensure that the new memory is cleared.\n-  return reallocate(allocator, NULL, 0, size_in_bits, clear);\n+ArenaBitMap::ArenaBitMap(Arena* arena, idx_t size_in_bits, bool clear)\n+  : GrowableBitMap<ArenaBitMap>(), _arena(arena) {\n+  initialize(size_in_bits, clear);\n@@ -114,27 +78,2 @@\n-template <class Allocator>\n-void BitMap::free(const Allocator& allocator, bm_word_t* map, idx_t  size_in_bits) {\n-  bm_word_t* ret = reallocate(allocator, map, size_in_bits, 0);\n-  assert(ret == NULL, \"Reallocate shouldn't have allocated\");\n-}\n-\n-template <class Allocator>\n-void BitMap::resize(const Allocator& allocator, idx_t new_size_in_bits, bool clear) {\n-  bm_word_t* new_map = reallocate(allocator, map(), size(), new_size_in_bits, clear);\n-\n-  update(new_map, new_size_in_bits);\n-}\n-\n-template <class Allocator>\n-void BitMap::initialize(const Allocator& allocator, idx_t size_in_bits, bool clear) {\n-  assert(map() == NULL, \"precondition\");\n-  assert(size() == 0,   \"precondition\");\n-\n-  resize(allocator, size_in_bits, clear);\n-}\n-\n-template <class Allocator>\n-void BitMap::reinitialize(const Allocator& allocator, idx_t new_size_in_bits, bool clear) {\n-  \/\/ Remove previous bits - no need to clear\n-  resize(allocator, 0, false \/* clear *\/);\n-\n-  initialize(allocator, new_size_in_bits, clear);\n+bm_word_t* ArenaBitMap::allocate(idx_t size_in_words) const {\n+  return (bm_word_t*)_arena->Amalloc(size_in_words * BytesPerWord);\n@@ -144,5 +83,2 @@\n-    : BitMap(allocate(ResourceBitMapAllocator(), size_in_bits, clear), size_in_bits) {\n-}\n-\n-void ResourceBitMap::resize(idx_t new_size_in_bits) {\n-  BitMap::resize(ResourceBitMapAllocator(), new_size_in_bits, true \/* clear *\/);\n+  : GrowableBitMap<ResourceBitMap>() {\n+  initialize(size_in_bits, clear);\n@@ -151,10 +87,2 @@\n-void ResourceBitMap::initialize(idx_t size_in_bits) {\n-  BitMap::initialize(ResourceBitMapAllocator(), size_in_bits, true \/* clear *\/);\n-}\n-\n-void ResourceBitMap::reinitialize(idx_t size_in_bits) {\n-  BitMap::reinitialize(ResourceBitMapAllocator(), size_in_bits, true \/* clear *\/);\n-}\n-\n-ArenaBitMap::ArenaBitMap(Arena* arena, idx_t size_in_bits)\n-    : BitMap(allocate(ArenaBitMapAllocator(arena), size_in_bits), size_in_bits) {\n+bm_word_t* ResourceBitMap::allocate(idx_t size_in_words) const {\n+  return (bm_word_t*)NEW_RESOURCE_ARRAY(bm_word_t, size_in_words);\n@@ -164,1 +92,2 @@\n-    : BitMap(allocate(CHeapBitMapAllocator(flags), size_in_bits, clear), size_in_bits), _flags(flags) {\n+  : GrowableBitMap<CHeapBitMap>(), _flags(flags) {\n+  initialize(size_in_bits, clear);\n@@ -168,1 +97,1 @@\n-  free(CHeapBitMapAllocator(_flags), map(), size());\n+  free(map(), size());\n@@ -171,2 +100,2 @@\n-void CHeapBitMap::resize(idx_t new_size_in_bits, bool clear) {\n-  BitMap::resize(CHeapBitMapAllocator(_flags), new_size_in_bits, clear);\n+bm_word_t* CHeapBitMap::allocate(idx_t size_in_words) const {\n+  return ArrayAllocator<bm_word_t>::allocate(size_in_words, _flags);\n@@ -175,6 +104,2 @@\n-void CHeapBitMap::initialize(idx_t size_in_bits, bool clear) {\n-  BitMap::initialize(CHeapBitMapAllocator(_flags), size_in_bits, clear);\n-}\n-\n-void CHeapBitMap::reinitialize(idx_t size_in_bits, bool clear) {\n-  BitMap::reinitialize(CHeapBitMapAllocator(_flags), size_in_bits, clear);\n+void CHeapBitMap::free(bm_word_t* map, idx_t size_in_words) const {\n+  ArrayAllocator<bm_word_t>::free(map, size_in_words);\n@@ -709,0 +634,4 @@\n+\n+template class GrowableBitMap<ArenaBitMap>;\n+template class GrowableBitMap<ResourceBitMap>;\n+template class GrowableBitMap<CHeapBitMap>;\n","filename":"src\/hotspot\/share\/utilities\/bitMap.cpp","additions":28,"deletions":99,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -67,0 +67,1 @@\n+ protected:\n@@ -113,1 +114,0 @@\n- protected:\n@@ -164,36 +164,0 @@\n-  \/\/ Allocation Helpers.\n-\n-  \/\/ Allocates and clears the bitmap memory.\n-  template <class Allocator>\n-  static bm_word_t* allocate(const Allocator&, idx_t size_in_bits, bool clear = true);\n-\n-  \/\/ Reallocates and clears the new bitmap memory.\n-  template <class Allocator>\n-  static bm_word_t* reallocate(const Allocator&, bm_word_t* map, idx_t old_size_in_bits, idx_t new_size_in_bits, bool clear = true);\n-\n-  \/\/ Free the bitmap memory.\n-  template <class Allocator>\n-  static void free(const Allocator&, bm_word_t* map, idx_t size_in_bits);\n-\n-  \/\/ Protected functions, that are used by BitMap sub-classes that support them.\n-\n-  \/\/ Resize the backing bitmap memory.\n-  \/\/\n-  \/\/ Old bits are transferred to the new memory\n-  \/\/ and the extended memory is cleared.\n-  template <class Allocator>\n-  void resize(const Allocator& allocator, idx_t new_size_in_bits, bool clear);\n-\n-  \/\/ Set up and clear the bitmap memory.\n-  \/\/\n-  \/\/ Precondition: The bitmap was default constructed and has\n-  \/\/ not yet had memory allocated via resize or (re)initialize.\n-  template <class Allocator>\n-  void initialize(const Allocator& allocator, idx_t size_in_bits, bool clear);\n-\n-  \/\/ Set up and clear the bitmap memory.\n-  \/\/\n-  \/\/ Can be called on previously initialized bitmaps.\n-  template <class Allocator>\n-  void reinitialize(const Allocator& allocator, idx_t new_size_in_bits, bool clear);\n-\n@@ -357,1 +321,1 @@\n-\/\/ A concrete implementation of the \"abstract\" BitMap class.\n+\/\/ CRTP: BitmapWithAllocator exposes the following Allocator interfaces upward to GrowableBitMap.\n@@ -359,6 +323,7 @@\n-\/\/ The BitMapView is used when the backing storage is managed externally.\n-class BitMapView : public BitMap {\n- public:\n-  BitMapView() : BitMap(NULL, 0) {}\n-  BitMapView(bm_word_t* map, idx_t size_in_bits) : BitMap(map, size_in_bits) {}\n-};\n+\/\/  bm_word_t* allocate(idx_t size_in_words) const;\n+\/\/  void free(bm_word_t* map, idx_t size_in_words) const\n+\/\/\n+template <class BitMapWithAllocator>\n+class GrowableBitMap : public BitMap {\n+ protected:\n+  bm_word_t* reallocate(bm_word_t* map, idx_t old_size_in_bits, idx_t new_size_in_bits, bool clear);\n@@ -366,2 +331,2 @@\n-\/\/ A BitMap with storage in a ResourceArea.\n-class ResourceBitMap : public BitMap {\n+  GrowableBitMap() : GrowableBitMap(nullptr, 0) {}\n+  GrowableBitMap(bm_word_t* map, idx_t size_in_bits) : BitMap(map, size_in_bits) {}\n@@ -370,10 +335,0 @@\n-  ResourceBitMap() : BitMap(NULL, 0) {}\n-  \/\/ Conditionally clears the bitmap memory.\n-  ResourceBitMap(idx_t size_in_bits, bool clear = true);\n-\n-  \/\/ Resize the backing bitmap memory.\n-  \/\/\n-  \/\/ Old bits are transferred to the new memory\n-  \/\/ and the extended memory is cleared.\n-  void resize(idx_t new_size_in_bits);\n-\n@@ -383,2 +338,7 @@\n-  \/\/ not yet had memory allocated via resize or initialize.\n-  void initialize(idx_t size_in_bits);\n+  \/\/ not yet had memory allocated via resize or (re)initialize.\n+  void initialize(idx_t size_in_bits, bool clear = true) {\n+    assert(map() == NULL, \"precondition\");\n+    assert(size() == 0,   \"precondition\");\n+\n+    resize(size_in_bits, clear);\n+  }\n@@ -389,1 +349,26 @@\n-  void reinitialize(idx_t size_in_bits);\n+  void reinitialize(idx_t new_size_in_bits, bool clear = true) {\n+    \/\/ Remove previous bits - no need to clear\n+    resize(0, false \/* clear *\/);\n+\n+    initialize(new_size_in_bits, clear);\n+  }\n+\n+  \/\/ Protected functions, that are used by BitMap sub-classes that support them.\n+\n+  \/\/ Resize the backing bitmap memory.\n+  \/\/\n+  \/\/ Old bits are transferred to the new memory\n+  \/\/ and the extended memory is cleared.\n+  void resize(idx_t new_size_in_bits, bool clear = true) {\n+    bm_word_t* new_map = reallocate(map(), size(), new_size_in_bits, clear);\n+    update(new_map, new_size_in_bits);\n+  }\n+};\n+\n+\/\/ A concrete implementation of the \"abstract\" BitMap class.\n+\/\/\n+\/\/ The BitMapView is used when the backing storage is managed externally.\n+class BitMapView : public BitMap {\n+ public:\n+  BitMapView() : BitMapView(nullptr, 0) {}\n+  BitMapView(bm_word_t* map, idx_t size_in_bits) : BitMap(map, size_in_bits) {}\n@@ -393,1 +378,5 @@\n-class ArenaBitMap : public BitMap {\n+class ArenaBitMap : public GrowableBitMap<ArenaBitMap> {\n+  Arena* const _arena;\n+\n+  NONCOPYABLE(ArenaBitMap);\n+\n@@ -396,1 +385,1 @@\n-  ArenaBitMap(Arena* arena, idx_t size_in_bits);\n+  ArenaBitMap(Arena* arena, idx_t size_in_bits, bool clear = true);\n@@ -398,2 +387,16 @@\n- private:\n-  NONCOPYABLE(ArenaBitMap);\n+  bm_word_t* allocate(idx_t size_in_words) const;\n+  void free(bm_word_t* map, idx_t size_in_words) const {\n+    \/\/ ArenaBitMaps currently don't free memory.\n+  }\n+};\n+\n+\/\/ A BitMap with storage in the current threads resource area.\n+class ResourceBitMap : public GrowableBitMap<ResourceBitMap> {\n+ public:\n+  ResourceBitMap() : ResourceBitMap(0) {}\n+  ResourceBitMap(idx_t size_in_bits, bool clear = true);\n+\n+  bm_word_t* allocate(idx_t size_in_words) const;\n+  void free(bm_word_t* map, idx_t size_in_words) const {\n+    \/\/ ArenaBitMaps currently don't free memory.\n+  }\n@@ -403,1 +406,3 @@\n-class CHeapBitMap : public BitMap {\n+class CHeapBitMap : public GrowableBitMap<CHeapBitMap> {\n+  \/\/ NMT memory type\n+  const MEMFLAGS _flags;\n@@ -405,1 +410,0 @@\n- private:\n@@ -410,3 +414,0 @@\n-  \/\/ NMT memory type\n-  MEMFLAGS _flags;\n-\n@@ -414,1 +415,2 @@\n-  CHeapBitMap(MEMFLAGS flags = mtInternal) : BitMap(NULL, 0), _flags(flags) {}\n+  CHeapBitMap() : CHeapBitMap(mtInternal) {}\n+  explicit CHeapBitMap(MEMFLAGS flags) : GrowableBitMap(0, false), _flags(flags) {}\n@@ -419,16 +421,2 @@\n-  \/\/ Resize the backing bitmap memory.\n-  \/\/\n-  \/\/ Old bits are transferred to the new memory\n-  \/\/ and the extended memory is (optionally) cleared.\n-  void resize(idx_t new_size_in_bits, bool clear = true);\n-\n-  \/\/ Set up and (optionally) clear the bitmap memory.\n-  \/\/\n-  \/\/ Precondition: The bitmap was default constructed and has\n-  \/\/ not yet had memory allocated via resize or initialize.\n-  void initialize(idx_t size_in_bits, bool clear = true);\n-\n-  \/\/ Set up and (optionally) clear the bitmap memory.\n-  \/\/\n-  \/\/ Can be called on previously initialized bitmaps.\n-  void reinitialize(idx_t size_in_bits, bool clear = true);\n+  bm_word_t* allocate(idx_t size_in_words) const;\n+  void free(bm_word_t* map, idx_t size_in_words) const;\n","filename":"src\/hotspot\/share\/utilities\/bitMap.hpp","additions":73,"deletions":85,"binary":false,"changes":158,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"memory\/arena.hpp\"\n@@ -86,1 +87,1 @@\n-\n+  template <class ReinitializableBitMapClass>\n@@ -90,1 +91,1 @@\n-    ResourceBitMap map(init_size);\n+    ReinitializableBitMapClass  map(init_size);\n@@ -94,1 +95,1 @@\n-    ResourceBitMap map2(BITMAP_SIZE);\n+    ReinitializableBitMapClass map2(BITMAP_SIZE);\n@@ -100,1 +101,1 @@\n-\n+  template <class PrintableBitMapClass>\n@@ -104,1 +105,1 @@\n-    ResourceBitMap map(size);\n+    PrintableBitMapClass map(size);\n@@ -116,0 +117,9 @@\n+\/\/ TestArenaBitMap is the shorthand combination of Arena and ArenaBitMap.\n+\/\/ Multiple inheritance guarantees to construct Arena first.\n+class TestArenaBitMap : private Arena, public ArenaBitMap {\n+ public:\n+  TestArenaBitMap() : TestArenaBitMap(0) {}\n+  TestArenaBitMap(idx_t size_in_bits, bool clear = true) : Arena(mtTest),\n+                                                           ArenaBitMap(static_cast<Arena*>(this), size_in_bits, clear) {}\n+};\n+\n@@ -119,0 +129,1 @@\n+\n@@ -126,0 +137,2 @@\n+  BitMapTest::testResizeGrow<TestArenaBitMap>();\n+  EXPECT_FALSE(HasFailure()) << \"Failed on type ArenaBitMap\";\n@@ -133,0 +146,2 @@\n+  BitMapTest::testResizeShrink<TestArenaBitMap>();\n+  EXPECT_FALSE(HasFailure()) << \"Failed on type ArenaBitMap\";\n@@ -140,0 +155,2 @@\n+  BitMapTest::testResizeSame<TestArenaBitMap>();\n+  EXPECT_FALSE(HasFailure()) << \"Failed on type ArenaBitMap\";\n@@ -165,0 +182,2 @@\n+  BitMapTest::testInitialize<TestArenaBitMap>();\n+  EXPECT_FALSE(HasFailure()) << \"Failed on type ArenaBitMap\";\n@@ -168,3 +187,6 @@\n-  BitMapTest::testReinitialize(0);\n-  BitMapTest::testReinitialize(BitMapTest::BITMAP_SIZE >> 3);\n-  BitMapTest::testReinitialize(BitMapTest::BITMAP_SIZE);\n+  constexpr BitMap::idx_t sizes[] = {0, BitMapTest::BITMAP_SIZE >> 3, BitMapTest::BITMAP_SIZE};\n+\n+  for (auto size : sizes) {\n+    BitMapTest::testReinitialize<ResourceBitMap>(size);\n+    BitMapTest::testReinitialize<TestArenaBitMap>(size);\n+  }\n@@ -176,3 +198,6 @@\n-  BitMapTest::testPrintOn(0);\n-  BitMapTest::testPrintOn(BitMapTest::BITMAP_SIZE >> 3);\n-  BitMapTest::testPrintOn(BitMapTest::BITMAP_SIZE);\n+  constexpr BitMap::idx_t sizes[] = {0, BitMapTest::BITMAP_SIZE >> 3, BitMapTest::BITMAP_SIZE};\n+\n+  for (auto size : sizes) {\n+    BitMapTest::testPrintOn<ResourceBitMap>(size);\n+    BitMapTest::testPrintOn<TestArenaBitMap>(size);\n+  }\n","filename":"test\/hotspot\/gtest\/utilities\/test_bitMap.cpp","additions":36,"deletions":11,"binary":false,"changes":47,"status":"modified"}]}