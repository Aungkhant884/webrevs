{"files":[{"patch":"@@ -34,1 +34,2 @@\n-STATIC_ASSERT(sizeof(BitMap::bm_word_t) == BytesPerWord); \/\/ \"Implementation assumption.\"\n+using bm_word_t = BitMap::bm_word_t;\n+using idx_t = BitMap::idx_t;\n@@ -36,2 +37,1 @@\n-typedef BitMap::bm_word_t bm_word_t;\n-typedef BitMap::idx_t     idx_t;\n+STATIC_ASSERT(sizeof(bm_word_t) == BytesPerWord); \/\/ \"Implementation assumption.\"\n@@ -39,38 +39,2 @@\n-class ResourceBitMapAllocator : StackObj {\n- public:\n-  bm_word_t* allocate(idx_t size_in_words) const {\n-    return NEW_RESOURCE_ARRAY(bm_word_t, size_in_words);\n-  }\n-  void free(bm_word_t* map, idx_t size_in_words) const {\n-    \/\/ Don't free resource allocated arrays.\n-  }\n-};\n-\n-class CHeapBitMapAllocator : StackObj {\n-  MEMFLAGS _flags;\n-\n- public:\n-  CHeapBitMapAllocator(MEMFLAGS flags) : _flags(flags) {}\n-  bm_word_t* allocate(size_t size_in_words) const {\n-    return ArrayAllocator<bm_word_t>::allocate(size_in_words, _flags);\n-  }\n-  void free(bm_word_t* map, idx_t size_in_words) const {\n-    ArrayAllocator<bm_word_t>::free(map, size_in_words);\n-  }\n-};\n-\n-class ArenaBitMapAllocator : StackObj {\n-  Arena* _arena;\n-\n- public:\n-  ArenaBitMapAllocator(Arena* arena) : _arena(arena) {}\n-  bm_word_t* allocate(idx_t size_in_words) const {\n-    return (bm_word_t*)_arena->Amalloc(size_in_words * BytesPerWord);\n-  }\n-  void free(bm_word_t* map, idx_t size_in_words) const {\n-    \/\/ ArenaBitMaps currently don't free memory.\n-  }\n-};\n-\n-template <class Allocator>\n-BitMap::bm_word_t* BitMap::reallocate(const Allocator& allocator, bm_word_t* old_map, idx_t old_size_in_bits, idx_t new_size_in_bits, bool clear) {\n+template <class BitMapWithAllocator>\n+bm_word_t* GrowableBitMap<BitMapWithAllocator>::reallocate(bm_word_t* old_map, idx_t old_size_in_bits, idx_t new_size_in_bits, bool clear) {\n@@ -81,0 +45,1 @@\n+  BitMapWithAllocator* derived = static_cast<BitMapWithAllocator*>(this);\n@@ -83,1 +48,1 @@\n-    map = allocator.allocate(new_size_in_words);\n+    map = derived->allocate(new_size_in_words);\n@@ -102,1 +67,1 @@\n-    allocator.free(old_map, old_size_in_words);\n+    derived->free(old_map, old_size_in_words);\n@@ -108,2 +73,1 @@\n-template <class Allocator>\n-bm_word_t* BitMap::allocate(const Allocator& allocator, idx_t size_in_bits, bool clear) {\n+ArenaBitMap::ArenaBitMap(Arena* arena, idx_t size_in_bits, bool clear) : GrowableBitMap<ArenaBitMap>(), _arena(arena) {\n@@ -111,22 +75,2 @@\n-  return reallocate(allocator, NULL, 0, size_in_bits, clear);\n-}\n-\n-template <class Allocator>\n-void BitMap::free(const Allocator& allocator, bm_word_t* map, idx_t  size_in_bits) {\n-  bm_word_t* ret = reallocate(allocator, map, size_in_bits, 0);\n-  assert(ret == NULL, \"Reallocate shouldn't have allocated\");\n-}\n-\n-template <class Allocator>\n-void BitMap::resize(const Allocator& allocator, idx_t new_size_in_bits, bool clear) {\n-  bm_word_t* new_map = reallocate(allocator, map(), size(), new_size_in_bits, clear);\n-\n-  update(new_map, new_size_in_bits);\n-}\n-\n-template <class Allocator>\n-void BitMap::initialize(const Allocator& allocator, idx_t size_in_bits, bool clear) {\n-  assert(map() == NULL, \"precondition\");\n-  assert(size() == 0,   \"precondition\");\n-\n-  resize(allocator, size_in_bits, clear);\n+  bm_word_t* map = reallocate(nullptr, 0, size_in_bits, clear);\n+  update(map, size_in_bits);\n@@ -135,6 +79,2 @@\n-template <class Allocator>\n-void BitMap::reinitialize(const Allocator& allocator, idx_t new_size_in_bits, bool clear) {\n-  \/\/ Remove previous bits - no need to clear\n-  resize(allocator, 0, false \/* clear *\/);\n-\n-  initialize(allocator, new_size_in_bits, clear);\n+bm_word_t* ArenaBitMap::allocate(idx_t size_in_words) const {\n+  return (bm_word_t*)_arena->Amalloc(size_in_words * BytesPerWord);\n@@ -144,17 +84,1 @@\n-    : BitMap(allocate(ResourceBitMapAllocator(), size_in_bits, clear), size_in_bits) {\n-}\n-\n-void ResourceBitMap::resize(idx_t new_size_in_bits) {\n-  BitMap::resize(ResourceBitMapAllocator(), new_size_in_bits, true \/* clear *\/);\n-}\n-\n-void ResourceBitMap::initialize(idx_t size_in_bits) {\n-  BitMap::initialize(ResourceBitMapAllocator(), size_in_bits, true \/* clear *\/);\n-}\n-\n-void ResourceBitMap::reinitialize(idx_t size_in_bits) {\n-  BitMap::reinitialize(ResourceBitMapAllocator(), size_in_bits, true \/* clear *\/);\n-}\n-\n-ArenaBitMap::ArenaBitMap(Arena* arena, idx_t size_in_bits)\n-    : BitMap(allocate(ArenaBitMapAllocator(arena), size_in_bits), size_in_bits) {\n+  : GrowableBitMap<ResourceBitMap>(size_in_bits, clear) {\n@@ -164,1 +88,4 @@\n-    : BitMap(allocate(CHeapBitMapAllocator(flags), size_in_bits, clear), size_in_bits), _flags(flags) {\n+  : GrowableBitMap<CHeapBitMap>(), _flags(flags) {\n+  \/\/ Reuse reallocate to ensure that the new memory is cleared.\n+  bm_word_t* map = reallocate(nullptr, 0, size_in_bits, clear);\n+  update(map, size_in_bits);\n@@ -168,13 +95,1 @@\n-  free(CHeapBitMapAllocator(_flags), map(), size());\n-}\n-\n-void CHeapBitMap::resize(idx_t new_size_in_bits, bool clear) {\n-  BitMap::resize(CHeapBitMapAllocator(_flags), new_size_in_bits, clear);\n-}\n-\n-void CHeapBitMap::initialize(idx_t size_in_bits, bool clear) {\n-  BitMap::initialize(CHeapBitMapAllocator(_flags), size_in_bits, clear);\n-}\n-\n-void CHeapBitMap::reinitialize(idx_t size_in_bits, bool clear) {\n-  BitMap::reinitialize(CHeapBitMapAllocator(_flags), size_in_bits, clear);\n+  free(map(), size());\n@@ -709,0 +624,4 @@\n+\n+template class GrowableBitMap<ArenaBitMap>;\n+template class GrowableBitMap<ResourceBitMap>;\n+template class GrowableBitMap<CHeapBitMap>;\n","filename":"src\/hotspot\/share\/utilities\/bitMap.cpp","additions":23,"deletions":104,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n- private:\n+ protected:\n@@ -113,1 +113,0 @@\n- protected:\n@@ -164,36 +163,0 @@\n-  \/\/ Allocation Helpers.\n-\n-  \/\/ Allocates and clears the bitmap memory.\n-  template <class Allocator>\n-  static bm_word_t* allocate(const Allocator&, idx_t size_in_bits, bool clear = true);\n-\n-  \/\/ Reallocates and clears the new bitmap memory.\n-  template <class Allocator>\n-  static bm_word_t* reallocate(const Allocator&, bm_word_t* map, idx_t old_size_in_bits, idx_t new_size_in_bits, bool clear = true);\n-\n-  \/\/ Free the bitmap memory.\n-  template <class Allocator>\n-  static void free(const Allocator&, bm_word_t* map, idx_t size_in_bits);\n-\n-  \/\/ Protected functions, that are used by BitMap sub-classes that support them.\n-\n-  \/\/ Resize the backing bitmap memory.\n-  \/\/\n-  \/\/ Old bits are transferred to the new memory\n-  \/\/ and the extended memory is cleared.\n-  template <class Allocator>\n-  void resize(const Allocator& allocator, idx_t new_size_in_bits, bool clear);\n-\n-  \/\/ Set up and clear the bitmap memory.\n-  \/\/\n-  \/\/ Precondition: The bitmap was default constructed and has\n-  \/\/ not yet had memory allocated via resize or (re)initialize.\n-  template <class Allocator>\n-  void initialize(const Allocator& allocator, idx_t size_in_bits, bool clear);\n-\n-  \/\/ Set up and clear the bitmap memory.\n-  \/\/\n-  \/\/ Can be called on previously initialized bitmaps.\n-  template <class Allocator>\n-  void reinitialize(const Allocator& allocator, idx_t new_size_in_bits, bool clear);\n-\n@@ -207,3 +170,1 @@\n-  BitMap(bm_word_t* map, idx_t size_in_bits) : _map(map), _size(size_in_bits) {\n-    verify_size(size_in_bits);\n-  }\n+  BitMap(bm_word_t* map, idx_t size_in_bits) : _map(map), _size(size_in_bits) {}\n@@ -357,1 +318,1 @@\n-\/\/ A concrete implementation of the \"abstract\" BitMap class.\n+\/\/ CRTP: BitmapWithAllocator exposes to the following Allocator interfaces upward to GrowableBitMap.\n@@ -359,6 +320,7 @@\n-\/\/ The BitMapView is used when the backing storage is managed externally.\n-class BitMapView : public BitMap {\n- public:\n-  BitMapView() : BitMap(NULL, 0) {}\n-  BitMapView(bm_word_t* map, idx_t size_in_bits) : BitMap(map, size_in_bits) {}\n-};\n+\/\/  bm_word_t* allocate(idx_t size_in_words) const;\n+\/\/  void free(bm_word_t* map, idx_t size_in_words) const\n+\/\/\n+template <class BitMapWithAllocator>\n+class GrowableBitMap : public BitMap {\n+ protected:\n+  bm_word_t* reallocate(bm_word_t* map, idx_t old_size_in_bits, idx_t new_size_in_bits, bool clear = true);\n@@ -366,2 +328,3 @@\n-\/\/ A BitMap with storage in a ResourceArea.\n-class ResourceBitMap : public BitMap {\n+  GrowableBitMap(idx_t size_in_bits, bool clear) : BitMap(reallocate(nullptr, 0, size_in_bits, clear), size_in_bits) {\n+  }\n+  GrowableBitMap() : BitMap(nullptr, 0) {}\n@@ -370,10 +333,0 @@\n-  ResourceBitMap() : BitMap(NULL, 0) {}\n-  \/\/ Conditionally clears the bitmap memory.\n-  ResourceBitMap(idx_t size_in_bits, bool clear = true);\n-\n-  \/\/ Resize the backing bitmap memory.\n-  \/\/\n-  \/\/ Old bits are transferred to the new memory\n-  \/\/ and the extended memory is cleared.\n-  void resize(idx_t new_size_in_bits);\n-\n@@ -383,2 +336,7 @@\n-  \/\/ not yet had memory allocated via resize or initialize.\n-  void initialize(idx_t size_in_bits);\n+  \/\/ not yet had memory allocated via resize or (re)initialize.\n+  void initialize(idx_t size_in_bits, bool clear = true) {\n+    assert(map() == NULL, \"precondition\");\n+    assert(size() == 0,   \"precondition\");\n+\n+    resize(size_in_bits, clear);\n+  }\n@@ -389,1 +347,26 @@\n-  void reinitialize(idx_t size_in_bits);\n+  void reinitialize(idx_t new_size_in_bits, bool clear = true) {\n+    \/\/ Remove previous bits - no need to clear\n+    resize(0, false \/* clear *\/);\n+\n+    initialize(new_size_in_bits, clear);\n+  }\n+\n+  \/\/ Protected functions, that are used by BitMap sub-classes that support them.\n+\n+  \/\/ Resize the backing bitmap memory.\n+  \/\/\n+  \/\/ Old bits are transferred to the new memory\n+  \/\/ and the extended memory is cleared.\n+  void resize(idx_t new_size_in_bits, bool clear = true) {\n+    bm_word_t* new_map = reallocate(map(), size(), new_size_in_bits, clear);\n+    update(new_map, new_size_in_bits);\n+  }\n+};\n+\n+\/\/ A concrete implementation of the \"abstract\" BitMap class.\n+\/\/\n+\/\/ The BitMapView is used when the backing storage is managed externally.\n+class BitMapView : public BitMap {\n+ public:\n+  BitMapView() : BitMapView(nullptr, 0) {}\n+  BitMapView(bm_word_t* map, idx_t size_in_bits) : BitMap(map, size_in_bits) {}\n@@ -393,1 +376,4 @@\n-class ArenaBitMap : public BitMap {\n+class ArenaBitMap : public GrowableBitMap<ArenaBitMap> {\n+  Arena* const _arena;\n+  NONCOPYABLE(ArenaBitMap);\n+\n@@ -396,1 +382,1 @@\n-  ArenaBitMap(Arena* arena, idx_t size_in_bits);\n+  ArenaBitMap(Arena* arena, idx_t size_in_bits, bool clear = true);\n@@ -398,2 +384,5 @@\n- private:\n-  NONCOPYABLE(ArenaBitMap);\n+  bm_word_t* allocate(idx_t size_in_words) const;\n+\n+  void free(bm_word_t* map, idx_t size_in_words) const {\n+    \/\/ ArenaBitMaps currently don't free memory.\n+  }\n@@ -402,2 +391,1 @@\n-\/\/ A BitMap with storage in the CHeap.\n-class CHeapBitMap : public BitMap {\n+class ResourceBitMap : public GrowableBitMap<ResourceBitMap> {\n@@ -405,1 +393,16 @@\n- private:\n+ public:\n+  ResourceBitMap() : ResourceBitMap(0) {}\n+  ResourceBitMap(idx_t size_in_bits, bool clear = true);\n+\n+  bm_word_t* allocate(idx_t size_in_words) const {\n+    return (bm_word_t*)NEW_RESOURCE_ARRAY(bm_word_t, size_in_words);\n+  }\n+\n+  void free(bm_word_t* map, idx_t size_in_words) const {\n+    \/\/ ArenaBitMaps currently don't free memory.\n+  }\n+};\n+\n+\/\/ A BitMap with storage in the CHeap.\n+class CHeapBitMap : public GrowableBitMap<CHeapBitMap> {\n+  MEMFLAGS _flags;\n@@ -410,3 +413,0 @@\n-  \/\/ NMT memory type\n-  MEMFLAGS _flags;\n-\n@@ -414,1 +414,2 @@\n-  CHeapBitMap(MEMFLAGS flags = mtInternal) : BitMap(NULL, 0), _flags(flags) {}\n+  CHeapBitMap() : CHeapBitMap(mtInternal) {}\n+  explicit CHeapBitMap(MEMFLAGS flags) : GrowableBitMap(0, false), _flags(flags) {}\n@@ -419,11 +420,3 @@\n-  \/\/ Resize the backing bitmap memory.\n-  \/\/\n-  \/\/ Old bits are transferred to the new memory\n-  \/\/ and the extended memory is (optionally) cleared.\n-  void resize(idx_t new_size_in_bits, bool clear = true);\n-\n-  \/\/ Set up and (optionally) clear the bitmap memory.\n-  \/\/\n-  \/\/ Precondition: The bitmap was default constructed and has\n-  \/\/ not yet had memory allocated via resize or initialize.\n-  void initialize(idx_t size_in_bits, bool clear = true);\n+  bm_word_t* allocate(idx_t size_in_words) const {\n+    return ArrayAllocator<bm_word_t>::allocate(size_in_words, _flags);\n+  }\n@@ -431,4 +424,3 @@\n-  \/\/ Set up and (optionally) clear the bitmap memory.\n-  \/\/\n-  \/\/ Can be called on previously initialized bitmaps.\n-  void reinitialize(idx_t size_in_bits, bool clear = true);\n+  void free(bm_word_t* map, idx_t size_in_words) const {\n+    ArrayAllocator<bm_word_t>::free(map, size_in_words);\n+  }\n","filename":"src\/hotspot\/share\/utilities\/bitMap.hpp","additions":81,"deletions":89,"binary":false,"changes":170,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"memory\/arena.hpp\"\n@@ -86,1 +87,1 @@\n-\n+  template <class ReinitializableBitMapClass>\n@@ -90,1 +91,1 @@\n-    ResourceBitMap map(init_size);\n+    ReinitializableBitMapClass  map(init_size);\n@@ -94,1 +95,1 @@\n-    ResourceBitMap map2(BITMAP_SIZE);\n+    ReinitializableBitMapClass map2(BITMAP_SIZE);\n@@ -100,1 +101,1 @@\n-\n+  template <class PrintableBitMapClass>\n@@ -104,1 +105,1 @@\n-    ResourceBitMap map(size);\n+    PrintableBitMapClass map(size);\n@@ -116,0 +117,9 @@\n+\/\/ FixedArenaBitMap is the shorthand combination of Arena and ArenaBitMap.\n+\/\/ Multiple inheritance guarantees to construct Arena first.\n+class FixedArenaBitMap : private Arena, public ArenaBitMap {\n+ public:\n+  FixedArenaBitMap() : FixedArenaBitMap(0) {}\n+  FixedArenaBitMap(idx_t size_in_bits, bool clear = true) : Arena(mtTest),\n+                                                            ArenaBitMap(static_cast<Arena*>(this), size_in_bits, clear) {}\n+};\n+\n@@ -121,0 +131,2 @@\n+  BitMapTest::testResizeGrow<FixedArenaBitMap>();\n+  EXPECT_FALSE(HasFailure()) << \"Failed on type ArenaBitMap\";\n@@ -128,0 +140,2 @@\n+  BitMapTest::testResizeShrink<FixedArenaBitMap>();\n+  EXPECT_FALSE(HasFailure()) << \"Failed on type ArenaBitMap\";\n@@ -135,0 +149,2 @@\n+  BitMapTest::testResizeSame<FixedArenaBitMap>();\n+  EXPECT_FALSE(HasFailure()) << \"Failed on type ArenaBitMap\";\n@@ -160,0 +176,2 @@\n+  BitMapTest::testInitialize<FixedArenaBitMap>();\n+  EXPECT_FALSE(HasFailure()) << \"Failed on type ArenaBitMap\";\n@@ -163,3 +181,6 @@\n-  BitMapTest::testReinitialize(0);\n-  BitMapTest::testReinitialize(BitMapTest::BITMAP_SIZE >> 3);\n-  BitMapTest::testReinitialize(BitMapTest::BITMAP_SIZE);\n+  constexpr BitMap::idx_t sizes[] = {0, BitMapTest::BITMAP_SIZE >> 3, BitMapTest::BITMAP_SIZE};\n+\n+  for (auto size : sizes) {\n+    BitMapTest::testReinitialize<ResourceBitMap>(size);\n+    BitMapTest::testReinitialize<FixedArenaBitMap>(size);\n+  }\n@@ -171,3 +192,6 @@\n-  BitMapTest::testPrintOn(0);\n-  BitMapTest::testPrintOn(BitMapTest::BITMAP_SIZE >> 3);\n-  BitMapTest::testPrintOn(BitMapTest::BITMAP_SIZE);\n+  constexpr BitMap::idx_t sizes[] = {0, BitMapTest::BITMAP_SIZE >> 3, BitMapTest::BITMAP_SIZE};\n+\n+  for (auto size : sizes) {\n+    BitMapTest::testPrintOn<ResourceBitMap>(size);\n+    BitMapTest::testPrintOn<FixedArenaBitMap>(size);\n+  }\n","filename":"test\/hotspot\/gtest\/utilities\/test_bitMap.cpp","additions":35,"deletions":11,"binary":false,"changes":46,"status":"modified"}]}