{"files":[{"patch":"@@ -2149,92 +2149,0 @@\n-\n-\/\/ java_lang_VirtualThread\n-\n-int java_lang_VirtualThread::static_notify_jvmti_events_offset;\n-int java_lang_VirtualThread::static_vthread_scope_offset;\n-int java_lang_VirtualThread::_carrierThread_offset;\n-int java_lang_VirtualThread::_continuation_offset;\n-int java_lang_VirtualThread::_state_offset;\n-\n-#define VTHREAD_FIELDS_DO(macro) \\\n-  macro(static_notify_jvmti_events_offset, k, \"notifyJvmtiEvents\",  bool_signature,              true);  \\\n-  macro(static_vthread_scope_offset,       k, \"VTHREAD_SCOPE\",      continuationscope_signature, true);  \\\n-  macro(_carrierThread_offset,             k, \"carrierThread\",      thread_signature,            false); \\\n-  macro(_continuation_offset,              k, \"cont\",               continuation_signature,      false); \\\n-  macro(_state_offset,                     k, \"state\",              int_signature,               false)\n-\n-static bool vthread_notify_jvmti_events = JNI_FALSE;\n-\n-void java_lang_VirtualThread::compute_offsets() {\n-  InstanceKlass* k = vmClasses::VirtualThread_klass();\n-  VTHREAD_FIELDS_DO(FIELD_COMPUTE_OFFSET);\n-}\n-\n-void java_lang_VirtualThread::init_static_notify_jvmti_events() {\n-  if (vthread_notify_jvmti_events) {\n-    InstanceKlass* ik = vmClasses::VirtualThread_klass();\n-    oop base = ik->static_field_base_raw();\n-    base->release_bool_field_put(static_notify_jvmti_events_offset, vthread_notify_jvmti_events);\n-  }\n-}\n-\n-bool java_lang_VirtualThread::is_instance(oop obj) {\n-  return obj != NULL && is_subclass(obj->klass());\n-}\n-\n-oop java_lang_VirtualThread::carrier_thread(oop vthread) {\n-  oop thread = vthread->obj_field(_carrierThread_offset);\n-  return thread;\n-}\n-\n-oop java_lang_VirtualThread::continuation(oop vthread) {\n-  oop cont = vthread->obj_field(_continuation_offset);\n-  return cont;\n-}\n-\n-int java_lang_VirtualThread::state(oop vthread) {\n-  return vthread->int_field_acquire(_state_offset);\n-}\n-\n-JavaThreadStatus java_lang_VirtualThread::map_state_to_thread_status(int state) {\n-  JavaThreadStatus status = JavaThreadStatus::NEW;\n-  switch (state) {\n-    case NEW :\n-      status = JavaThreadStatus::NEW;\n-      break;\n-    case STARTED :\n-    case RUNNABLE :\n-    case RUNNABLE_SUSPENDED :\n-    case RUNNING :\n-    case PARKING :\n-    case YIELDING :\n-      status = JavaThreadStatus::RUNNABLE;\n-      break;\n-    case PARKED :\n-    case PARKED_SUSPENDED :\n-    case PINNED :\n-      status = JavaThreadStatus::PARKED;\n-      break;\n-    case TERMINATED :\n-      status = JavaThreadStatus::TERMINATED;\n-      break;\n-    default:\n-      ShouldNotReachHere();\n-  }\n-  return status;\n-}\n-\n-#if INCLUDE_CDS\n-void java_lang_VirtualThread::serialize_offsets(SerializeClosure* f) {\n-   VTHREAD_FIELDS_DO(FIELD_SERIALIZE_OFFSET);\n-}\n-#endif\n-\n-bool java_lang_VirtualThread::notify_jvmti_events() {\n-  return vthread_notify_jvmti_events == JNI_TRUE;\n-}\n-\n-void java_lang_VirtualThread::set_notify_jvmti_events(bool enable) {\n-  vthread_notify_jvmti_events = enable;\n-}\n-\n-\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":0,"deletions":92,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -523,49 +523,0 @@\n-\n-\/\/ Interface to java.lang.VirtualThread objects\n-\n-class java_lang_VirtualThread : AllStatic {\n- private:\n-  static int static_notify_jvmti_events_offset;\n-  static int static_vthread_scope_offset;\n-  static int _carrierThread_offset;\n-  static int _continuation_offset;\n-  static int _state_offset;\n-  JFR_ONLY(static int _jfr_epoch_offset;)\n- public:\n-  enum {\n-    NEW          = 0,\n-    STARTED      = 1,\n-    RUNNABLE     = 2,\n-    RUNNING      = 3,\n-    PARKING      = 4,\n-    PARKED       = 5,\n-    PINNED       = 6,\n-    YIELDING     = 7,\n-    TERMINATED   = 99,\n-\n-    \/\/ can be suspended from scheduling when unmounted\n-    SUSPENDED    = 1 << 8,\n-    RUNNABLE_SUSPENDED = (RUNNABLE | SUSPENDED),\n-    PARKED_SUSPENDED   = (PARKED | SUSPENDED)\n-  };\n-\n-  static void compute_offsets();\n-  static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;\n-\n-  \/\/ Testers\n-  static bool is_subclass(Klass* klass) {\n-    return klass->is_subclass_of(vmClasses::VirtualThread_klass());\n-  }\n-  static bool is_instance(oop obj);\n-\n-  static oop vthread_scope();\n-  static oop carrier_thread(oop vthread);\n-  static oop continuation(oop vthread);\n-  static int state(oop vthread);\n-  static JavaThreadStatus map_state_to_thread_status(int state);\n-  static bool notify_jvmti_events();\n-  static void set_notify_jvmti_events(bool enable);\n-  static void init_static_notify_jvmti_events();\n-};\n-\n-\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":0,"deletions":49,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -206,5 +206,0 @@\n-inline oop java_lang_VirtualThread::vthread_scope() {\n-  oop base = vmClasses::VirtualThread_klass()->static_field_base_raw();\n-  return base->obj_field(static_vthread_scope_offset);\n-}\n-\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.inline.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+#include \"runtime\/continuationJavaClasses.hpp\"\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+#include \"runtime\/continuationJavaClasses.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+#include \"runtime\/continuationJavaClasses.inline.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"runtime\/continuationJavaClasses.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jvmtiEventController.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+#include \"runtime\/continuationJavaClasses.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"runtime\/continuationJavaClasses.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jvmtiExtensions.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"classfile\/javaClasses.hpp\"\n@@ -45,0 +44,1 @@\n+#include \"runtime\/continuationJavaClasses.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jvmtiImpl.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"runtime\/continuationJavaClasses.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jvmtiThreadState.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"classfile\/javaThreadStatus.hpp\"\n@@ -30,1 +31,91 @@\n-#include \"runtime\/continuationJavaClasses.hpp\"\n+#include \"runtime\/continuationJavaClasses.inline.hpp\"\n+\n+\/\/ java_lang_VirtualThread\n+\n+int java_lang_VirtualThread::static_notify_jvmti_events_offset;\n+int java_lang_VirtualThread::static_vthread_scope_offset;\n+int java_lang_VirtualThread::_carrierThread_offset;\n+int java_lang_VirtualThread::_continuation_offset;\n+int java_lang_VirtualThread::_state_offset;\n+\n+#define VTHREAD_FIELDS_DO(macro) \\\n+  macro(static_notify_jvmti_events_offset, k, \"notifyJvmtiEvents\",  bool_signature,              true);  \\\n+  macro(static_vthread_scope_offset,       k, \"VTHREAD_SCOPE\",      continuationscope_signature, true);  \\\n+  macro(_carrierThread_offset,             k, \"carrierThread\",      thread_signature,            false); \\\n+  macro(_continuation_offset,              k, \"cont\",               continuation_signature,      false); \\\n+  macro(_state_offset,                     k, \"state\",              int_signature,               false)\n+\n+static bool vthread_notify_jvmti_events = JNI_FALSE;\n+\n+void java_lang_VirtualThread::compute_offsets() {\n+  InstanceKlass* k = vmClasses::VirtualThread_klass();\n+  VTHREAD_FIELDS_DO(FIELD_COMPUTE_OFFSET);\n+}\n+\n+void java_lang_VirtualThread::init_static_notify_jvmti_events() {\n+  if (vthread_notify_jvmti_events) {\n+    InstanceKlass* ik = vmClasses::VirtualThread_klass();\n+    oop base = ik->static_field_base_raw();\n+    base->release_bool_field_put(static_notify_jvmti_events_offset, vthread_notify_jvmti_events);\n+  }\n+}\n+\n+bool java_lang_VirtualThread::is_instance(oop obj) {\n+  return obj != NULL && is_subclass(obj->klass());\n+}\n+\n+oop java_lang_VirtualThread::carrier_thread(oop vthread) {\n+  oop thread = vthread->obj_field(_carrierThread_offset);\n+  return thread;\n+}\n+\n+oop java_lang_VirtualThread::continuation(oop vthread) {\n+  oop cont = vthread->obj_field(_continuation_offset);\n+  return cont;\n+}\n+\n+int java_lang_VirtualThread::state(oop vthread) {\n+  return vthread->int_field_acquire(_state_offset);\n+}\n+\n+JavaThreadStatus java_lang_VirtualThread::map_state_to_thread_status(int state) {\n+  JavaThreadStatus status = JavaThreadStatus::NEW;\n+  switch (state) {\n+    case NEW :\n+      status = JavaThreadStatus::NEW;\n+      break;\n+    case STARTED :\n+    case RUNNABLE :\n+    case RUNNABLE_SUSPENDED :\n+    case RUNNING :\n+    case PARKING :\n+    case YIELDING :\n+      status = JavaThreadStatus::RUNNABLE;\n+      break;\n+    case PARKED :\n+    case PARKED_SUSPENDED :\n+    case PINNED :\n+      status = JavaThreadStatus::PARKED;\n+      break;\n+    case TERMINATED :\n+      status = JavaThreadStatus::TERMINATED;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+  }\n+  return status;\n+}\n+\n+#if INCLUDE_CDS\n+void java_lang_VirtualThread::serialize_offsets(SerializeClosure* f) {\n+   VTHREAD_FIELDS_DO(FIELD_SERIALIZE_OFFSET);\n+}\n+#endif\n+\n+bool java_lang_VirtualThread::notify_jvmti_events() {\n+  return vthread_notify_jvmti_events == JNI_TRUE;\n+}\n+\n+void java_lang_VirtualThread::set_notify_jvmti_events(bool enable) {\n+  vthread_notify_jvmti_events = enable;\n+}\n","filename":"src\/hotspot\/share\/runtime\/continuationJavaClasses.cpp","additions":92,"deletions":1,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"classfile\/vmClasses.hpp\"\n@@ -35,0 +36,47 @@\n+\/\/ Interface to java.lang.VirtualThread objects\n+\n+class java_lang_VirtualThread : AllStatic {\n+ private:\n+  static int static_notify_jvmti_events_offset;\n+  static int static_vthread_scope_offset;\n+  static int _carrierThread_offset;\n+  static int _continuation_offset;\n+  static int _state_offset;\n+  JFR_ONLY(static int _jfr_epoch_offset;)\n+ public:\n+  enum {\n+    NEW          = 0,\n+    STARTED      = 1,\n+    RUNNABLE     = 2,\n+    RUNNING      = 3,\n+    PARKING      = 4,\n+    PARKED       = 5,\n+    PINNED       = 6,\n+    YIELDING     = 7,\n+    TERMINATED   = 99,\n+\n+    \/\/ can be suspended from scheduling when unmounted\n+    SUSPENDED    = 1 << 8,\n+    RUNNABLE_SUSPENDED = (RUNNABLE | SUSPENDED),\n+    PARKED_SUSPENDED   = (PARKED | SUSPENDED)\n+  };\n+\n+  static void compute_offsets();\n+  static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;\n+\n+  \/\/ Testers\n+  static bool is_subclass(Klass* klass) {\n+    return klass->is_subclass_of(vmClasses::VirtualThread_klass());\n+  }\n+  static bool is_instance(oop obj);\n+\n+  static oop vthread_scope();\n+  static oop carrier_thread(oop vthread);\n+  static oop continuation(oop vthread);\n+  static int state(oop vthread);\n+  static JavaThreadStatus map_state_to_thread_status(int state);\n+  static bool notify_jvmti_events();\n+  static void set_notify_jvmti_events(bool enable);\n+  static void init_static_notify_jvmti_events();\n+};\n+\n","filename":"src\/hotspot\/share\/runtime\/continuationJavaClasses.hpp","additions":48,"deletions":0,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"oops\/instanceKlass.inline.hpp\"\n@@ -36,0 +37,5 @@\n+inline oop java_lang_VirtualThread::vthread_scope() {\n+  oop base = vmClasses::VirtualThread_klass()->static_field_base_raw();\n+  return base->obj_field(static_vthread_scope_offset);\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/continuationJavaClasses.inline.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"runtime\/continuationJavaClasses.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/escapeBarrier.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}