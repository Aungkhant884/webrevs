{"files":[{"patch":"@@ -166,0 +166,3 @@\n+#ifdef O_CLOEXEC\n+    flags |= O_CLOEXEC;\n+#endif\n@@ -183,9 +186,0 @@\n-static int\n-ZFILE_read(ZFILE zfd, char *buf, jint nbytes) {\n-#ifdef WIN32\n-    return (int) IO_Read(zfd, buf, nbytes);\n-#else\n-    return read(zfd, buf, nbytes);\n-#endif\n-}\n-\n@@ -216,39 +210,53 @@\n-\/*\n- * Reads len bytes of data into buf.\n- * Returns 0 if all bytes could be read, otherwise returns -1.\n- *\/\n-static int\n-readFully(ZFILE zfd, void *buf, jlong len) {\n-  char *bp = (char *) buf;\n-\n-  while (len > 0) {\n-        jlong limit = ((((jlong) 1) << 31) - 1);\n-        jint count = (len < limit) ?\n-            (jint) len :\n-            (jint) limit;\n-        jint n = ZFILE_read(zfd, bp, count);\n-        if (n > 0) {\n-            bp += n;\n-            len -= n;\n-        } else if (n == -1 && errno == EINTR) {\n-          \/* Retry after EINTR (interrupted by signal). *\/\n-            continue;\n-        } else { \/* EOF or IO error *\/\n-            return -1;\n-        }\n-    }\n-    return 0;\n-}\n-\n-\/*\n- * Reads len bytes of data from the specified offset into buf.\n- * Returns 0 if all bytes could be read, otherwise returns -1.\n- *\/\n-static int\n-readFullyAt(ZFILE zfd, void *buf, jlong len, jlong offset)\n-{\n-    if (IO_Lseek(zfd, offset, SEEK_SET) == -1) {\n-        return -1; \/* lseek failure. *\/\n-    }\n-\n-    return readFully(zfd, buf, len);\n+static jlong readFullyAt(ZFILE zfd, void *buf, jlong nbytes, jlong offset) {\n+  assert(nbytes >= 0);\n+  assert(offset >= 0);\n+#ifdef WIN32\n+  jlong total = 0;\n+  OVERLAPPED overlapped;\n+  DWORD number_of_bytes_to_read;\n+  DWORD number_of_bytes_read;\n+  while (total < nbytes) {\n+    memset(&overlapped, '\\0', sizeof(overlapped));\n+    overlapped.Offset = (DWORD) offset;\n+    overlapped.OffsetHigh = (DWORD) (offset >> 32);\n+    if ((nbytes - total) > 0xffffffffu) {\n+      number_of_bytes_to_read = 0xffffffffu;\n+    } else {\n+      number_of_bytes_to_read = (DWORD) (nbytes - total);\n+    }\n+    number_of_bytes_read = 0;\n+    if (!ReadFile((HANDLE) zfd, buf, number_of_bytes_to_read, &number_of_bytes_read, &overlapped)) {\n+      return -1;\n+    }\n+    buf = ((char*) buf) + number_of_bytes_read;\n+    offset += (jlong) number_of_bytes_read;\n+    total += (jlong) number_of_bytes_read;\n+  }\n+  assert(total == nbytes);\n+  return total;\n+#else\n+  jlong total = 0;\n+  size_t to_read;\n+  ssize_t result;\n+  while (total < nbytes) {\n+    if ((nbytes - total) > SSIZE_MAX) {\n+      to_read = (size_t) SSIZE_MAX;\n+    } else {\n+      to_read = (size_t) (nbytes - total);\n+    }\n+    result = pread(zfd, buf, to_read, (off_t) offset);\n+    if (result == -1) {\n+      if (errno == EINTR) {\n+        continue;\n+      }\n+      return -1;\n+    } else if (result == 0) {\n+      return -1;\n+    }\n+    buf = ((char*) buf) + ((size_t) result);\n+    offset += (jlong) result;\n+    total += (jlong) result;\n+  }\n+  assert(total == nbytes);\n+  return total;\n+#endif\n@@ -873,1 +881,1 @@\n-    if (readFully(zfd, errbuf, 4) != -1) {  \/\/ errors will be handled later\n+    if (readFullyAt(zfd, errbuf, 4, 0) != -1) {  \/\/ errors will be handled later\n@@ -976,1 +984,1 @@\n-    if (readFully(zfd, cen+bufsize, censize-bufsize) == -1) goto Catch;\n+    if (readFullyAt(zfd, cen+bufsize, censize-bufsize, cenpos+bufsize) == -1) goto Catch;\n","filename":"src\/java.base\/share\/native\/libzip\/zip_util.c","additions":58,"deletions":50,"binary":false,"changes":108,"status":"modified"}]}