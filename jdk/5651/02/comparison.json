{"files":[{"patch":"@@ -1451,0 +1451,10 @@\n+\n+    if (n->in(0) != NULL) {\n+      IdealLoopTree* loop_ctrl = get_loop(n->in(0));\n+      if (n_loop != loop_ctrl && n_loop->is_member(loop_ctrl)) {\n+        \/\/ n has a control input inside a loop but get_ctrl() is member of an outer loop. This could happen, for example,\n+        \/\/ for Div nodes inside a loop (control input inside loop) without a use except for an UCT (outside the loop).\n+        \/\/ Rewire control of n to get_ctrl(n) to move it out of the loop, regardless if its input(s) are later sunk or not.\n+        _igvn.replace_input_of(n, 0, n_ctrl);\n+      }\n+    }\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key stress randomness\n+ * @bug 8274074\n+ * @requires vm.compiler2.enabled\n+ * @summary Sinking a data node used as divisor of a DivI node into a zero check UCT loses its pin outside the loop due to\n+ *          optimizing the CastII node away, resulting in a div by zero crash (SIGFPE) due to letting the DivI node floating\n+ *          back inside the loop.\n+ * @run main\/othervm -Xcomp -XX:CompileCommand=compileonly,compiler.loopopts.TestSinkingDivisorLostPin -XX:-TieredCompilation\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+StressGCM -XX:StressSeed=4177789702 compiler.loopopts.TestSinkingDivisorLostPin\n+ * @run main\/othervm -Xcomp -XX:CompileCommand=compileonly,compiler.loopopts.TestSinkingDivisorLostPin -XX:-TieredCompilation\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+StressGCM compiler.loopopts.TestSinkingDivisorLostPin\n+ *\/\n+\n+package compiler.loopopts;\n+\n+public class TestSinkingDivisorLostPin {\n+    static int iFld = 1;\n+    static int x = 1;\n+    static int q = 0;\n+    static int iArrFld[] = new int[100];\n+\n+    public static void main(String[] strArr) {\n+        test();\n+    }\n+\n+    static void test() {\n+        int y = 1;\n+        int i = 1;\n+        do {\n+            int j;\n+            for (j = 1; j < 88; j++) {\n+                iArrFld[1] = x;\n+            }\n+            try {\n+                y = iFld - q; \/\/ y = 1 - 0\n+                y = (iArrFld[2] \/ y); \/\/ y = iArrFld[2] \/ 1\n+                \/\/ Zero check Z1 with UCT\n+                \/\/ DivI node D on IfTrue path of zero check\n+                y = (5 \/ iFld); \/\/ y = 5 \/ 1\n+                \/\/ Zero check Z2 with UCT\n+                \/\/ DivI node D is only used on IfFalse path of zero check Z2 into UCT (on IfTrue path, the result is not used anywhere\n+                \/\/ because we directly overwrite it again with \"y = (5 \/ iFld)). The IfFalse path of the zero check, however, is never\n+                \/\/ taken because iFld = 1. But before applying the sinking algorithm, the DivI node D could be executed during the\n+                \/\/ loop, as the zero check Z1 succeeds. Only after sinking the SubI node for \"iFld - q\" into the IfFalse path of Z2\n+                \/\/ and optimizing it accordingly (iFld is found to be zero because the zero check Z2 failed, i.e. iFld is zero which is\n+                \/\/ propagated into the CastII node whose type is improved to [0,0] and the node is replaced by constant zero), the\n+                \/\/ DivI node must NOT be executed inside the loop anymore. But the DivI node is executed in the loop because of losing\n+                \/\/ the CastII pin. The fix is to update the control input of the DivI node to the get_ctrl() input outside the loop\n+                \/\/ (IfFalse of zero check Z2).\n+            } catch (ArithmeticException a_e) {\n+            }\n+\n+            iFld -= 8;\n+            if (y == 3) {\n+            }\n+            i++;\n+        } while (i < 10);\n+    }\n+\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestSinkingDivisorLostPin.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"}]}