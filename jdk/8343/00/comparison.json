{"files":[{"patch":"","filename":"src\/hotspot\/cpu\/ppc\/parse_ppc.cpp","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/hotspot\/cpu\/x86\/parse_x86.cpp","status":"copied"},{"patch":"@@ -2410,4 +2410,0 @@\n-bool Parse::do_one_bytecode_targeted() {\n-  return false;\n-}\n-\n@@ -8860,20 +8856,4 @@\n-\/\/ Integer Division with Immediate -1: Negate.\n-instruct divI_reg_immIvalueMinus1(iRegIdst dst, iRegIsrc src1, immI_minus1 src2) %{\n-  match(Set dst (DivI src1 src2));\n-  ins_cost(DEFAULT_COST);\n-\n-  format %{ \"NEG     $dst, $src1 \\t\/\/ \/-1\" %}\n-  size(4);\n-  ins_encode %{\n-    __ neg($dst$$Register, $src1$$Register);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-\/\/ Integer Division with constant, but not -1.\n-\/\/ We should be able to improve this by checking the type of src2.\n-\/\/ It might well be that src2 is known to be positive.\n-instruct divI_reg_regnotMinus1(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{\n-  match(Set dst (DivI src1 src2));\n-  predicate(n->in(2)->find_int_con(-1) != -1); \/\/ src2 is a constant, but not -1\n-  ins_cost(2*DEFAULT_COST);\n+\/\/ Integer Division, but not min_jint \/ -1\n+instruct noOvfDivI_reg_reg(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{\n+  match(Set dst (NoOvfDivI src1 src2));\n+  ins_cost(3*DEFAULT_COST);\n@@ -8889,50 +8869,4 @@\n-instruct cmovI_bne_negI_reg(iRegIdst dst, flagsRegSrc crx, iRegIsrc src1) %{\n-  effect(USE_DEF dst, USE src1, USE crx);\n-  predicate(false);\n-\n-  ins_variable_size_depending_on_alignment(true);\n-\n-  format %{ \"CMOVE   $dst, neg($src1), $crx\" %}\n-  \/\/ Worst case is branch + move + stop, no stop without scheduler.\n-  size(8);\n-  ins_encode %{\n-    Label done;\n-    __ bne($crx$$CondRegister, done);\n-    __ neg($dst$$Register, $src1$$Register);\n-    __ bind(done);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-\/\/ Integer Division with Registers not containing constants.\n-instruct divI_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{\n-  match(Set dst (DivI src1 src2));\n-  ins_cost(10*DEFAULT_COST);\n-\n-  expand %{\n-    immI16 imm %{ (int)-1 %}\n-    flagsReg tmp1;\n-    cmpI_reg_imm16(tmp1, src2, imm);          \/\/ check src2 == -1\n-    divI_reg_regnotMinus1(dst, src1, src2);   \/\/ dst = src1 \/ src2\n-    cmovI_bne_negI_reg(dst, tmp1, src1);      \/\/ cmove dst = neg(src1) if src2 == -1\n-  %}\n-%}\n-\n-\/\/ Long Division with Immediate -1: Negate.\n-instruct divL_reg_immLvalueMinus1(iRegLdst dst, iRegLsrc src1, immL_minus1 src2) %{\n-  match(Set dst (DivL src1 src2));\n-  ins_cost(DEFAULT_COST);\n-\n-  format %{ \"NEG     $dst, $src1 \\t\/\/ \/-1, long\" %}\n-  size(4);\n-  ins_encode %{\n-    __ neg($dst$$Register, $src1$$Register);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-\/\/ Long Division with constant, but not -1.\n-instruct divL_reg_regnotMinus1(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{\n-  match(Set dst (DivL src1 src2));\n-  predicate(n->in(2)->find_long_con(-1L) != -1L); \/\/ Src2 is a constant, but not -1.\n-  ins_cost(2*DEFAULT_COST);\n+\/\/ Long Division, but not min_jlong \/ -1\n+instruct noOvfDivL_reg_reg(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{\n+  match(Set dst (NoOvfDivL src1 src2));\n+  ins_cost(3*DEFAULT_COST);\n@@ -8948,32 +8882,0 @@\n-instruct cmovL_bne_negL_reg(iRegLdst dst, flagsRegSrc crx, iRegLsrc src1) %{\n-  effect(USE_DEF dst, USE src1, USE crx);\n-  predicate(false);\n-\n-  ins_variable_size_depending_on_alignment(true);\n-\n-  format %{ \"CMOVE   $dst, neg($src1), $crx\" %}\n-  \/\/ Worst case is branch + move + stop, no stop without scheduler.\n-  size(8);\n-  ins_encode %{\n-    Label done;\n-    __ bne($crx$$CondRegister, done);\n-    __ neg($dst$$Register, $src1$$Register);\n-    __ bind(done);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-\/\/ Long Division with Registers not containing constants.\n-instruct divL_reg_reg_Ex(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{\n-  match(Set dst (DivL src1 src2));\n-  ins_cost(10*DEFAULT_COST);\n-\n-  expand %{\n-    immL16 imm %{ (int)-1 %}\n-    flagsReg tmp1;\n-    cmpL_reg_imm16(tmp1, src2, imm);          \/\/ check src2 == -1\n-    divL_reg_regnotMinus1(dst, src1, src2);   \/\/ dst = src1 \/ src2\n-    cmovL_bne_negL_reg(dst, tmp1, src1);      \/\/ cmove dst = neg(src1) if src2 == -1\n-  %}\n-%}\n-\n@@ -8982,2 +8884,2 @@\n-  match(Set dst (ModI src1 src2));\n-  ins_cost(10*DEFAULT_COST);\n+  match(Set dst (NoOvfModI src1 src2));\n+  ins_cost(5*DEFAULT_COST);\n@@ -8986,2 +8888,1 @@\n-    immI16 imm %{ (int)-1 %}\n-    flagsReg tmp1;\n+    iRegIdst tmp1;\n@@ -8989,6 +8890,3 @@\n-    iRegIdst tmp3;\n-    cmpI_reg_imm16(tmp1, src2, imm);           \/\/ check src2 == -1\n-    divI_reg_regnotMinus1(tmp2, src1, src2);   \/\/ tmp2 = src1 \/ src2\n-    cmovI_bne_negI_reg(tmp2, tmp1, src1);      \/\/ cmove tmp2 = neg(src1) if src2 == -1\n-    mulI_reg_reg(tmp3, src2, tmp2);            \/\/ tmp3 = src2 * tmp2\n-    subI_reg_reg(dst, src1, tmp3);             \/\/ dst = src1 - tmp3\n+    noOvfDivI_reg_reg(tmp1, src1, src2);\n+    mulI_reg_reg(tmp2, src2, tmp1);\n+    subI_reg_reg(dst, src1, tmp2);\n@@ -9000,2 +8898,2 @@\n-  match(Set dst (ModL src1 src2));\n-  ins_cost(10*DEFAULT_COST);\n+  match(Set dst (NoOvfModL src1 src2));\n+  ins_cost(5*DEFAULT_COST);\n@@ -9004,2 +8902,1 @@\n-    immL16 imm %{ (int)-1 %}\n-    flagsReg tmp1;\n+    iRegLdst tmp1;\n@@ -9007,6 +8904,3 @@\n-    iRegLdst tmp3;\n-    cmpL_reg_imm16(tmp1, src2, imm);             \/\/ check src2 == -1\n-    divL_reg_regnotMinus1(tmp2, src1, src2);     \/\/ tmp2 = src1 \/ src2\n-    cmovL_bne_negL_reg(tmp2, tmp1, src1);        \/\/ cmove tmp2 = neg(src1) if src2 == -1\n-    mulL_reg_reg(tmp3, src2, tmp2);              \/\/ tmp3 = src2 * tmp2\n-    subL_reg_reg(dst, src1, tmp3);               \/\/ dst = src1 - tmp3\n+    noOvfDivL_reg_reg(tmp1, src1, src2);\n+    mulL_reg_reg(tmp2, src2, tmp1);\n+    subL_reg_reg(dst, src1, tmp2);\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":20,"deletions":126,"binary":false,"changes":146,"status":"modified"}]}