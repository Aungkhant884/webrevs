{"files":[{"patch":"@@ -0,0 +1,227 @@\n+\/*\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"hugepages.hpp\"\n+\n+#include \"logging\/log.hpp\"\n+#include \"logging\/logStream.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+\n+#include <dirent.h>\n+\n+StaticHugePageSupport::StaticHugePageSupport() :\n+  _initialized(false), _pagesizes(), _default_hugepage_size(SIZE_MAX) {}\n+\n+os::PageSizes StaticHugePageSupport::pagesizes() const {\n+  assert(_initialized, \"Not initialized\");\n+  return _pagesizes;\n+}\n+\n+size_t StaticHugePageSupport::default_hugepage_size() const {\n+  assert(_initialized, \"Not initialized\");\n+  return _default_hugepage_size;\n+}\n+\n+\/\/ Scan \/proc\/meminfo and return value of Hugepagesize\n+static size_t scan_default_hugepagesize() {\n+  size_t pagesize = 0;\n+\n+  \/\/ large_page_size on Linux is used to round up heap size. x86 uses either\n+  \/\/ 2M or 4M page, depending on whether PAE (Physical Address Extensions)\n+  \/\/ mode is enabled. AMD64\/EM64T uses 2M page in 64bit mode. IA64 can use\n+  \/\/ page as large as 1G.\n+  \/\/\n+  \/\/ Here we try to figure out page size by parsing \/proc\/meminfo and looking\n+  \/\/ for a line with the following format:\n+  \/\/    Hugepagesize:     2048 kB\n+  \/\/\n+  \/\/ If we can't determine the value (e.g. \/proc is not mounted, or the text\n+  \/\/ format has been changed), we'll set largest page size to 0\n+\n+  FILE *fp = os::fopen(\"\/proc\/meminfo\", \"r\");\n+  if (fp) {\n+    while (!feof(fp)) {\n+      int x = 0;\n+      char buf[16];\n+      if (fscanf(fp, \"Hugepagesize: %d\", &x) == 1) {\n+        if (x && fgets(buf, sizeof(buf), fp) && strcmp(buf, \" kB\\n\") == 0) {\n+          pagesize = x * K;\n+          break;\n+        }\n+      } else {\n+        \/\/ skip to next line\n+        for (;;) {\n+          int ch = fgetc(fp);\n+          if (ch == EOF || ch == (int)'\\n') break;\n+        }\n+      }\n+    }\n+    fclose(fp);\n+  }\n+\n+  return pagesize;\n+}\n+\n+\/\/ Given a file that contains a single (integral) number, return that number, 0 and false if failed.\n+static bool read_number_file(const char* file, size_t* out) {\n+  (*out) = 0;\n+  FILE* f = ::fopen(file, \"r\");\n+  bool rc = false;\n+  if (f != nullptr) {\n+    uint64_t i = 0;\n+    if (::fscanf(f, SIZE_FORMAT, out) == 1) {\n+      rc = true;\n+    }\n+    ::fclose(f);\n+  }\n+  return rc;\n+}\n+\n+static const char* const sys_hugepages = \"\/sys\/kernel\/mm\/hugepages\";\n+\n+\/\/ Scan all directories in \/sys\/kernel\/mm\/hugepages\/hugepages-xxxx\n+\/\/ to discover the available page sizes\n+static os::PageSizes scan_hugepages() {\n+\n+  os::PageSizes pagesizes;\n+\n+  DIR *dir = opendir(sys_hugepages);\n+\n+  struct dirent *entry;\n+  size_t pagesize;\n+  while ((entry = readdir(dir)) != nullptr) {\n+    if (entry->d_type == DT_DIR &&\n+        sscanf(entry->d_name, \"hugepages-%zukB\", &pagesize) == 1) {\n+      \/\/ The kernel is using kB, hotspot uses bytes\n+      \/\/ Add each found Large Page Size to page_sizes\n+      pagesize *= K;\n+      pagesizes.add(pagesize);\n+    }\n+  }\n+  closedir(dir);\n+\n+  return pagesizes;\n+}\n+\n+void StaticHugePageSupport::print_on(outputStream* os) {\n+  if (_initialized) {\n+    os->print_cr(\"Static hugepage support:\");\n+    for (size_t s = _pagesizes.smallest(); s != 0; s = _pagesizes.next_larger(s)) {\n+      os->print_cr(\"  hugepage size: \" EXACTFMT, EXACTFMTARGS(s));\n+    }\n+    os->print_cr(\"  default hugepage size: \" EXACTFMT, EXACTFMTARGS(_default_hugepage_size));\n+  } else {\n+    os->print_cr(\"  unknown.\");\n+  }\n+}\n+\n+void StaticHugePageSupport::scan_os() {\n+  _pagesizes = scan_hugepages();\n+  _default_hugepage_size = scan_default_hugepagesize();\n+  assert(_pagesizes.contains(_default_hugepage_size),\n+         \"Unexpected configuration: default pagesize (\" SIZE_FORMAT \") \"\n+         \"has no associated directory in \/sys\/kernel\/mm\/hugepages..\", _default_hugepage_size);\n+  _initialized = true;\n+  LogTarget(Info, pagesize) lt;\n+  if (lt.is_enabled()) {\n+    LogStream ls(lt);\n+    print_on(&ls);\n+  }\n+}\n+\n+THPSupport::THPSupport() :\n+    _initialized(false), _mode(THPMode::never), _pagesize(SIZE_MAX) {}\n+\n+\n+THPMode THPSupport::mode() const {\n+  assert(_initialized, \"Not initialized\");\n+  return _mode;\n+}\n+\n+size_t THPSupport::pagesize() const {\n+  assert(_initialized, \"Not initialized\");\n+  return _pagesize;\n+}\n+\n+void THPSupport::scan_os() {\n+  \/\/ Scan \/sys\/kernel\/mm\/transparent_hugepage\/enabled\n+  \/\/ see mm\/huge_memory.c\n+  _mode = THPMode::never;\n+  const char* filename = \"\/sys\/kernel\/mm\/transparent_hugepage\/enabled\";\n+  FILE* f = ::fopen(filename, \"r\");\n+  if (f != nullptr) {\n+    char buf[64];\n+    char* s = fgets(buf, sizeof(buf), f);\n+    assert(s == buf, \"Should have worked\");\n+    if (::strstr(buf, \"[madvise]\") != nullptr) {\n+      _mode = THPMode::madvise;\n+    } else if (::strstr(buf, \"[always]\") != nullptr) {\n+      _mode = THPMode::always;\n+    } else {\n+      assert(::strstr(buf, \"[never]\") != nullptr, \"Weird content of %s: %s\", filename, buf);\n+    }\n+    fclose(f);\n+  }\n+\n+  \/\/ Scan large page size for THP from hpage_pmd_size\n+  _pagesize = 0;\n+  read_number_file(\"\/sys\/kernel\/mm\/transparent_hugepage\/hpage_pmd_size\", &_pagesize);\n+  assert(_pagesize > 0, \"Expected\");\n+  _initialized = true;\n+\n+  LogTarget(Info, pagesize) lt;\n+  if (lt.is_enabled()) {\n+    LogStream ls(lt);\n+    print_on(&ls);\n+  }\n+}\n+\n+void THPSupport::print_on(outputStream* os) {\n+  if (_initialized) {\n+    os->print_cr(\"Transparent hugepage (THP) support:\");\n+    os->print_cr(\"  THP mode: %s\",\n+        (_mode == THPMode::always ? \"always\" : (_mode == THPMode::never ? \"never\" : \"madvise\")));\n+    os->print_cr(\"  THP pagesize: \" EXACTFMT, EXACTFMTARGS(_pagesize));\n+  } else {\n+    os->print_cr(\"  unknown.\");\n+  }\n+}\n+\n+StaticHugePageSupport HugePages::_static_hugepage_support;\n+THPSupport HugePages::_thp_support;\n+\n+void HugePages::initialize() {\n+  _static_hugepage_support.scan_os();\n+  _thp_support.scan_os();\n+}\n+\n+void HugePages::print_on(outputStream* os) {\n+  _static_hugepage_support.print_on(os);\n+  _thp_support.print_on(os);\n+}\n","filename":"src\/hotspot\/os\/linux\/hugepages.cpp","additions":227,"deletions":0,"binary":false,"changes":227,"status":"added"},{"patch":"@@ -0,0 +1,110 @@\n+\/*\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_LINUX_HUGEPAGES_HPP\n+#define OS_LINUX_HUGEPAGES_HPP\n+\n+#include \"memory\/allStatic.hpp\"\n+#include \"runtime\/os.hpp\" \/\/ for os::PageSizes\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+class outputStream;\n+\n+\/\/ Header contains the interface that reads OS information about\n+\/\/ available hugepage support:\n+\/\/ - class StaticHugePageSupport - about static (non-THP) hugepages\n+\/\/ - class THPSupport - about transparent huge pages\n+\/\/ and:\n+\/\/ - class HugePages - a static umbrella wrapper\n+\n+\/\/ Information about static (non-thp) hugepages\n+class StaticHugePageSupport {\n+  bool _initialized;\n+\n+  \/\/ All supported hugepage sizes (sizes for which entries exist\n+  \/\/ in \/sys\/kernel\/mm\/hugepages\/hugepage-xxx)\n+  os::PageSizes _pagesizes;\n+\n+  \/\/ Contains the default hugepage. The \"default hugepage size\" is the one that\n+  \/\/ - is marked in \/proc\/meminfo as \"Hugepagesize\"\n+  \/\/ - is the size one gets when using mmap(MAP_HUGETLB) when omitting size specifiers like MAP_HUGE_SHIFT)\n+  size_t _default_hugepage_size;\n+\n+public:\n+  StaticHugePageSupport();\n+\n+  void scan_os();\n+\n+  os::PageSizes pagesizes() const;\n+  size_t default_hugepage_size() const;\n+  void print_on(outputStream* os);\n+};\n+\n+enum class THPMode { always, never, madvise };\n+\n+\/\/ 2) for transparent hugepages\n+class THPSupport {\n+  bool _initialized;\n+\n+  \/\/ See \/sys\/kernel\/mm\/transparent_hugepages\/enabled\n+  THPMode _mode;\n+\n+  \/\/ Contains the THP page size\n+  size_t _pagesize;\n+\n+public:\n+\n+  THPSupport();\n+\n+  \/\/ Queries the OS, fills in object\n+  void scan_os();\n+\n+  THPMode mode() const;\n+  size_t pagesize() const;\n+  void print_on(outputStream* os);\n+};\n+\n+\/\/ Umbrella static interface\n+class HugePages : public AllStatic {\n+\n+  static StaticHugePageSupport _static_hugepage_support;\n+  static THPSupport _thp_support;\n+\n+public:\n+\n+  static const StaticHugePageSupport& static_info() { return _static_hugepage_support; }\n+  static const THPSupport& thp_info() { return _thp_support; }\n+\n+  static size_t default_static_hugepage_size()  { return _static_hugepage_support.default_hugepage_size(); }\n+  static bool supports_static_hugepages()       { return default_static_hugepage_size() > 0; }\n+  static THPMode thp_mode()                     { return _thp_support.mode(); }\n+  static bool supports_thp()                    { return thp_mode() == THPMode::madvise || thp_mode() == THPMode::always; }\n+  static size_t thp_pagesize()                  { return _thp_support.pagesize(); }\n+\n+  static void initialize();\n+  static void print_on(outputStream* os);\n+};\n+\n+#endif \/\/ OS_LINUX_HUGEPAGES_HPP\n","filename":"src\/hotspot\/os\/linux\/hugepages.hpp","additions":110,"deletions":0,"binary":false,"changes":110,"status":"added"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"hugepages.hpp\"\n@@ -172,1 +173,0 @@\n-size_t os::Linux::_default_large_page_size = 0;\n@@ -935,1 +935,1 @@\n-  size_t default_large_page_size = os::Linux::default_large_page_size();\n+  size_t default_large_page_size = HugePages::default_static_hugepage_size();\n@@ -3548,1 +3548,1 @@\n-  if (page_size != default_large_page_size()) {\n+  if (page_size != HugePages::default_static_hugepage_size()) {\n@@ -3656,73 +3656,0 @@\n-static size_t scan_default_large_page_size() {\n-  size_t default_large_page_size = 0;\n-\n-  \/\/ large_page_size on Linux is used to round up heap size. x86 uses either\n-  \/\/ 2M or 4M page, depending on whether PAE (Physical Address Extensions)\n-  \/\/ mode is enabled. AMD64\/EM64T uses 2M page in 64bit mode. IA64 can use\n-  \/\/ page as large as 1G.\n-  \/\/\n-  \/\/ Here we try to figure out page size by parsing \/proc\/meminfo and looking\n-  \/\/ for a line with the following format:\n-  \/\/    Hugepagesize:     2048 kB\n-  \/\/\n-  \/\/ If we can't determine the value (e.g. \/proc is not mounted, or the text\n-  \/\/ format has been changed), we'll set largest page size to 0\n-\n-  FILE *fp = os::fopen(\"\/proc\/meminfo\", \"r\");\n-  if (fp) {\n-    while (!feof(fp)) {\n-      int x = 0;\n-      char buf[16];\n-      if (fscanf(fp, \"Hugepagesize: %d\", &x) == 1) {\n-        if (x && fgets(buf, sizeof(buf), fp) && strcmp(buf, \" kB\\n\") == 0) {\n-          default_large_page_size = x * K;\n-          break;\n-        }\n-      } else {\n-        \/\/ skip to next line\n-        for (;;) {\n-          int ch = fgetc(fp);\n-          if (ch == EOF || ch == (int)'\\n') break;\n-        }\n-      }\n-    }\n-    fclose(fp);\n-  }\n-\n-  return default_large_page_size;\n-}\n-\n-static os::PageSizes scan_multiple_page_support() {\n-  \/\/ Scan \/sys\/kernel\/mm\/hugepages\n-  \/\/ to discover the available page sizes\n-  const char* sys_hugepages = \"\/sys\/kernel\/mm\/hugepages\";\n-  os::PageSizes page_sizes;\n-\n-  DIR *dir = opendir(sys_hugepages);\n-\n-  struct dirent *entry;\n-  size_t page_size;\n-  while ((entry = readdir(dir)) != nullptr) {\n-    if (entry->d_type == DT_DIR &&\n-        sscanf(entry->d_name, \"hugepages-%zukB\", &page_size) == 1) {\n-      \/\/ The kernel is using kB, hotspot uses bytes\n-      \/\/ Add each found Large Page Size to page_sizes\n-      page_sizes.add(page_size * K);\n-    }\n-  }\n-  closedir(dir);\n-\n-  LogTarget(Debug, pagesize) lt;\n-  if (lt.is_enabled()) {\n-    LogStream ls(lt);\n-    ls.print(\"Large Page sizes: \");\n-    page_sizes.print_on(&ls);\n-  }\n-\n-  return page_sizes;\n-}\n-\n-size_t os::Linux::default_large_page_size() {\n-  return _default_large_page_size;\n-}\n-\n@@ -3781,0 +3708,18 @@\n+struct LargePageInitializationLoggerMark {\n+  ~LargePageInitializationLoggerMark() {\n+    LogTarget(Info, pagesize) lt;\n+    if (lt.is_enabled()) {\n+      LogStream ls(lt);\n+      if (UseLargePages) {\n+        ls.print_cr(\"UseLargePages=1, UseTransparentHugePages=%d, UseHugeTLBFS=%d, UseSHM=%d\",\n+                    UseTransparentHugePages, UseHugeTLBFS, UseSHM);\n+        ls.print(\"Large page support enabled. Usable page sizes: \");\n+        os::page_sizes().print_on(&ls);\n+        ls.print_cr(\". Default large page size: \" EXACTFMT \".\", EXACTFMTARGS(os::large_page_size()));\n+      } else {\n+        ls.print(\"Large page support disabled.\");\n+      }\n+    }\n+  }\n+};\n+\n@@ -3782,3 +3727,4 @@\n-  \/\/ Always initialize the default large page size even if large pages are not being used.\n-  size_t default_large_page_size = scan_default_large_page_size();\n-  os::Linux::_default_large_page_size = default_large_page_size;\n+  LargePageInitializationLoggerMark logger;\n+\n+  \/\/ Query OS information first.\n+  HugePages::initialize();\n@@ -3805,1 +3751,2 @@\n-  if (default_large_page_size == 0) {\n+  if ( ( UseTransparentHugePages && HugePages::supports_thp() == false) ||\n+       (!UseTransparentHugePages && HugePages::supports_static_hugepages() == false) ) {\n@@ -3814,19 +3761,10 @@\n-  os::PageSizes all_large_pages = scan_multiple_page_support();\n-\n-  \/\/ 3) Consistency check and post-processing\n-\n-  \/\/ It is unclear if \/sys\/kernel\/mm\/hugepages\/ and \/proc\/meminfo could disagree. Manually\n-  \/\/ re-add the default page size to the list of page sizes to be sure.\n-  all_large_pages.add(default_large_page_size);\n-\n-  \/\/ Check LargePageSizeInBytes matches an available page size and if so set _large_page_size\n-  \/\/ using LargePageSizeInBytes as the maximum allowed large page size. If LargePageSizeInBytes\n-  \/\/ doesn't match an available page size set _large_page_size to default_large_page_size\n-  \/\/ and use it as the maximum.\n- if (FLAG_IS_DEFAULT(LargePageSizeInBytes) ||\n-      LargePageSizeInBytes == 0 ||\n-      LargePageSizeInBytes == default_large_page_size) {\n-    _large_page_size = default_large_page_size;\n-    log_info(pagesize)(\"Using the default large page size: \" SIZE_FORMAT \"%s\",\n-                       byte_size_in_exact_unit(_large_page_size),\n-                       exact_unit_for_byte_size(_large_page_size));\n+\n+  if (UseTransparentHugePages) {\n+    \/\/ In THP mode:\n+    \/\/ - os::large_page_size() is the *THP page size*\n+    \/\/ - os::pagesizes() has two members, the THP page size and the system page size\n+    assert(HugePages::supports_thp() && HugePages::thp_pagesize() > 0, \"Missing OS info\");\n+    _large_page_size = HugePages::thp_pagesize();\n+    _page_sizes.add(_large_page_size);\n+    _page_sizes.add(os::vm_page_size());\n+\n@@ -3834,9 +3772,17 @@\n-    if (all_large_pages.contains(LargePageSizeInBytes)) {\n-      _large_page_size = LargePageSizeInBytes;\n-      log_info(pagesize)(\"Overriding default large page size (\" SIZE_FORMAT \"%s) \"\n-                         \"using LargePageSizeInBytes: \" SIZE_FORMAT \"%s\",\n-                         byte_size_in_exact_unit(default_large_page_size),\n-                         exact_unit_for_byte_size(default_large_page_size),\n-                         byte_size_in_exact_unit(_large_page_size),\n-                         exact_unit_for_byte_size(_large_page_size));\n-    } else {\n+\n+    \/\/ In static hugepage mode:\n+    \/\/ - os::large_page_size() is the default static hugepage size (\/proc\/meminfo \"Hugepagesize\")\n+    \/\/ - os::pagesizes() contains all hugepage sizes the kernel supports, regardless whether there\n+    \/\/   are pages configured in the pool or not (from \/sys\/kernel\/hugepages\/hugepage-xxxx ...)\n+    os::PageSizes all_large_pages = HugePages::static_info().pagesizes();\n+    const size_t default_large_page_size = HugePages::default_static_hugepage_size();\n+\n+    \/\/ 3) Consistency check and post-processing\n+\n+    \/\/ Check LargePageSizeInBytes matches an available page size and if so set _large_page_size\n+    \/\/ using LargePageSizeInBytes as the maximum allowed large page size. If LargePageSizeInBytes\n+    \/\/ doesn't match an available page size set _large_page_size to default_large_page_size\n+    \/\/ and use it as the maximum.\n+   if (FLAG_IS_DEFAULT(LargePageSizeInBytes) ||\n+        LargePageSizeInBytes == 0 ||\n+        LargePageSizeInBytes == default_large_page_size) {\n@@ -3844,4 +3790,1 @@\n-      log_info(pagesize)(\"LargePageSizeInBytes is not a valid large page size (\" SIZE_FORMAT \"%s) \"\n-                         \"using the default large page size: \" SIZE_FORMAT \"%s\",\n-                         byte_size_in_exact_unit(LargePageSizeInBytes),\n-                         exact_unit_for_byte_size(LargePageSizeInBytes),\n+      log_info(pagesize)(\"Using the default large page size: \" SIZE_FORMAT \"%s\",\n@@ -3850,0 +3793,18 @@\n+    } else {\n+      if (all_large_pages.contains(LargePageSizeInBytes)) {\n+        _large_page_size = LargePageSizeInBytes;\n+        log_info(pagesize)(\"Overriding default large page size (\" SIZE_FORMAT \"%s) \"\n+                           \"using LargePageSizeInBytes: \" SIZE_FORMAT \"%s\",\n+                           byte_size_in_exact_unit(default_large_page_size),\n+                           exact_unit_for_byte_size(default_large_page_size),\n+                           byte_size_in_exact_unit(_large_page_size),\n+                           exact_unit_for_byte_size(_large_page_size));\n+      } else {\n+        _large_page_size = default_large_page_size;\n+        log_info(pagesize)(\"LargePageSizeInBytes is not a valid large page size (\" SIZE_FORMAT \"%s) \"\n+                           \"using the default large page size: \" SIZE_FORMAT \"%s\",\n+                           byte_size_in_exact_unit(LargePageSizeInBytes),\n+                           exact_unit_for_byte_size(LargePageSizeInBytes),\n+                           byte_size_in_exact_unit(_large_page_size),\n+                           exact_unit_for_byte_size(_large_page_size));\n+      }\n@@ -3851,1 +3812,0 @@\n-  }\n@@ -3853,12 +3813,6 @@\n-  \/\/ Populate _page_sizes with large page sizes less than or equal to\n-  \/\/ _large_page_size.\n-  for (size_t page_size = _large_page_size; page_size != 0;\n-         page_size = all_large_pages.next_smaller(page_size)) {\n-    _page_sizes.add(page_size);\n-  }\n-\n-  LogTarget(Info, pagesize) lt;\n-  if (lt.is_enabled()) {\n-    LogStream ls(lt);\n-    ls.print(\"Usable page sizes: \");\n-    _page_sizes.print_on(&ls);\n+    \/\/ Populate _page_sizes with large page sizes less than or equal to\n+    \/\/ _large_page_size.\n+    for (size_t page_size = _large_page_size; page_size != 0;\n+           page_size = all_large_pages.next_smaller(page_size)) {\n+      _page_sizes.add(page_size);\n+    }\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":79,"deletions":125,"binary":false,"changes":204,"status":"modified"},{"patch":"@@ -52,2 +52,0 @@\n-  static size_t _default_large_page_size;\n-\n@@ -80,4 +78,0 @@\n-  static size_t default_large_page_size();\n-  static size_t scan_default_large_page_size();\n-  static os::PageSizes scan_multiple_page_support();\n-\n","filename":"src\/hotspot\/os\/linux\/os_linux.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -412,0 +412,3 @@\n+#define EXACTFMT            SIZE_FORMAT \"%s\"\n+#define EXACTFMTARGS(s)     byte_size_in_exact_unit(s), exact_unit_for_byte_size(s)\n+\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,221 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+import java.io.*;\n+import java.util.Set;\n+import java.util.*;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+class HugePageConfiguration {\n+\n+    Set<Long> _staticHugePageSizes;\n+    long _staticDefaultHugePageSize;\n+\n+    enum THPMode {always, never, madvise, unknown}\n+    THPMode _thpMode;\n+    long _thpPageSize;\n+\n+    public Set<Long> getStaticHugePageSizes() {\n+        return _staticHugePageSizes;\n+    }\n+\n+    public long getStaticDefaultHugePageSize() {\n+        return _staticDefaultHugePageSize;\n+    }\n+\n+    public THPMode getThpMode() {\n+        return _thpMode;\n+    }\n+\n+    public long getThpPageSize() {\n+        return _thpPageSize;\n+    }\n+\n+    public HugePageConfiguration(Set<Long> _staticHugePageSizes, long _staticDefaultHugePageSize, THPMode _thpMode, long _thpPageSize) {\n+        this._staticHugePageSizes = _staticHugePageSizes;\n+        this._staticDefaultHugePageSize = _staticDefaultHugePageSize;\n+        this._thpMode = _thpMode;\n+        this._thpPageSize = _thpPageSize;\n+    }\n+\n+    @java.lang.Override\n+    public String toString() {\n+        return \"Configuration{\" +\n+                \"_staticHugePageSizes=\" + _staticHugePageSizes +\n+                \", _staticDefaultHugePageSize=\" + _staticDefaultHugePageSize +\n+                \", _thpMode=\" + _thpMode +\n+                \", _thpPageSize=\" + _thpPageSize +\n+                '}';\n+    }\n+\n+    @java.lang.Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (o == null || getClass() != o.getClass()) return false;\n+        HugePageConfiguration that = (HugePageConfiguration) o;\n+        return _staticDefaultHugePageSize == that._staticDefaultHugePageSize && _thpPageSize == that._thpPageSize && Objects.equals(_staticHugePageSizes, that._staticHugePageSizes) && _thpMode == that._thpMode;\n+    }\n+\n+    @java.lang.Override\n+    public int hashCode() {\n+        return Objects.hash(_staticHugePageSizes, _staticDefaultHugePageSize, _thpMode, _thpPageSize);\n+    }\n+\n+    private static long readDefaultHugePageSizeFromOS() {\n+        Pattern pat = Pattern.compile(\"Hugepagesize: *(\\\\d+) +kB\");\n+        long result = 0;\n+        try (Scanner scanner = new Scanner(new File(\"\/proc\/meminfo\"))) {\n+            while (scanner.hasNextLine()) {\n+                Matcher mat = pat.matcher(scanner.nextLine());\n+                if (mat.matches()) {\n+                    scanner.close();\n+                    return Long.parseLong(mat.group(1)) * 1024;\n+                }\n+            }\n+        } catch (FileNotFoundException e) {\n+            System.out.println(\"Could not open \/proc\/meminfo\");\n+        }\n+        return 0;\n+    }\n+\n+    private static Set<Long> readSupportedHugePagesFromOS() {\n+        TreeSet<Long> pagesizes = new TreeSet<>();\n+        Pattern pat = Pattern.compile(\"hugepages-(\\\\d+)kB\");\n+        File[] subdirs = new File(\"\/sys\/kernel\/mm\/hugepages\").listFiles();\n+        if (subdirs != null) {\n+            for (File f : subdirs) {\n+                String name = f.getName();\n+                Matcher mat = pat.matcher(name);\n+                if (mat.matches()) {\n+                    long pagesize = Long.parseLong(mat.group(1)) * 1024;\n+                    pagesizes.add(pagesize);\n+                }\n+            }\n+        }\n+        return pagesizes;\n+    }\n+\n+    private static THPMode readTHPModeFromOS() {\n+        THPMode mode = THPMode.unknown;\n+        String file = \"\/sys\/kernel\/mm\/transparent_hugepage\/enabled\";\n+        try (FileReader fr = new FileReader(file);\n+             BufferedReader reader = new BufferedReader(fr)) {\n+            String s = reader.readLine();\n+            if (s.contains(\"[never]\")) {\n+                mode = THPMode.never;\n+            } else if (s.contains(\"[always]\")) {\n+                mode = THPMode.always;\n+            } else if (s.contains(\"[madvise]\")) {\n+                mode = THPMode.madvise;\n+            } else {\n+                throw new RuntimeException(\"Unexpected content of \" + file + \": \" + s);\n+            }\n+        } catch (IOException e) {\n+            System.out.println(\"Failed to read \" + file);\n+            mode = THPMode.unknown;\n+        }\n+        return mode;\n+    }\n+\n+    private static long readTHPPageSizeFromOS() {\n+        long pagesize = 0;\n+        String file = \"\/sys\/kernel\/mm\/transparent_hugepage\/hpage_pmd_size\";\n+        try (FileReader fr = new FileReader(file);\n+             BufferedReader reader = new BufferedReader(fr)) {\n+            String s = reader.readLine();\n+            pagesize = Long.parseLong(s);\n+        } catch (IOException | NumberFormatException e) { \/* ignored *\/ }\n+        return pagesize;\n+    }\n+\n+    \/\/ Fill object with info read from proc file system\n+    public static HugePageConfiguration readFromOS() {\n+        return new HugePageConfiguration(readSupportedHugePagesFromOS(),\n+                readDefaultHugePageSizeFromOS(),\n+                readTHPModeFromOS(),\n+                readTHPPageSizeFromOS());\n+    }\n+\n+    private static long parseSIUnit(String num, String unit) {\n+        long n = Long.parseLong(num);\n+        return switch (unit) {\n+            case \"K\" -> n * 1024;\n+            case \"M\" -> n * 1024 * 1024;\n+            case \"G\" -> n * 1024 * 1024 * 1024;\n+            default -> throw new RuntimeException(\"Invalid unit \" + unit);\n+        };\n+    }\n+\n+    public static HugePageConfiguration readFromJVMLog(OutputAnalyzer output) {\n+        \/\/ Expects output from -Xlog:pagesize\n+        \/\/ Example:\n+        \/\/ [0.001s][info][pagesize] Static hugepage support:\n+        \/\/ [0.001s][info][pagesize]   hugepage size: 2M\n+        \/\/ [0.001s][info][pagesize]   hugepage size: 1G\n+        \/\/ [0.001s][info][pagesize]   default hugepage size: 2M\n+        \/\/ [0.001s][info][pagesize] Transparent hugepage (THP) support:\n+        \/\/ [0.001s][info][pagesize]   THP mode: madvise\n+        \/\/ [0.001s][info][pagesize]   THP pagesize: 2M\n+        TreeSet<Long> hugepages = new TreeSet<>();\n+        long defaultHugepageSize = 0;\n+        THPMode thpMode = THPMode.never;\n+        long thpPageSize = 0;\n+        Pattern patternHugepageSize = Pattern.compile(\".*\\\\[pagesize] *hugepage size: (\\\\d+)([KMG])\");\n+        Pattern patternDefaultHugepageSize = Pattern.compile(\".*\\\\[pagesize] *default hugepage size: (\\\\d+)([KMG]) *\");\n+        Pattern patternTHPPageSize = Pattern.compile(\".*\\\\[pagesize] *THP pagesize: (\\\\d+)([KMG])\");\n+        Pattern patternTHPMode = Pattern.compile(\".*\\\\[pagesize] *THP mode: (\\\\S+)\");\n+        List<String> lines = output.asLines();\n+        for (String s : lines) {\n+            Matcher mat = patternHugepageSize.matcher(s);\n+            if (mat.matches()) {\n+                hugepages.add(parseSIUnit(mat.group(1), mat.group(2)));\n+                continue;\n+            }\n+            if (defaultHugepageSize == 0) {\n+                mat = patternDefaultHugepageSize.matcher(s);\n+                if (mat.matches()) {\n+                    defaultHugepageSize = parseSIUnit(mat.group(1), mat.group(2));\n+                    continue;\n+                }\n+            }\n+            if (thpPageSize == 0) {\n+                mat = patternTHPPageSize.matcher(s);\n+                if (mat.matches()) {\n+                    thpPageSize = parseSIUnit(mat.group(1), mat.group(2));\n+                    continue;\n+                }\n+            }\n+            mat = patternTHPMode.matcher(s);\n+            if (mat.matches()) {\n+                thpMode = THPMode.valueOf(mat.group(1));\n+            }\n+        }\n+\n+        return new HugePageConfiguration(hugepages, defaultHugepageSize, thpMode, thpPageSize);\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/os\/HugePageConfiguration.java","additions":221,"deletions":0,"binary":false,"changes":221,"status":"added"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test that the JVM detects the OS hugepage\/THP settings correctly.\n+ * @library \/test\/lib\n+ * @requires os.family == \"linux\"\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @run driver HugePageDetection\n+ *\/\n+\n+import java.util.*;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class HugePageDetection {\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        ArrayList<String> finalargs = new ArrayList<String>();\n+        String[] defaultArgs = {\n+            \"-Xlog:pagesize\", \"-Xmx64M\", \"-XX:-CreateCoredumpOnCrash\"\n+        };\n+        finalargs.addAll(Arrays.asList(defaultArgs));\n+        finalargs.add(\"-version\");\n+\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n+                new String[] {\"-Xlog:pagesize\", \"-Xmx64M\", \"-version\"});\n+\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.reportDiagnosticSummary();\n+        output.shouldHaveExitValue(0);\n+\n+        \/\/ The configuration detected by the JVM should match the OS settings\n+\n+        HugePageConfiguration configurationFromOS = HugePageConfiguration.readFromOS();\n+        System.out.println(\"Configuration read from OS: \" + configurationFromOS);\n+\n+        HugePageConfiguration configurationFromLog = HugePageConfiguration.readFromJVMLog(output);\n+        System.out.println(\"Configuration read from JVM log: \" + configurationFromLog);\n+\n+        if (configurationFromOS.equals(configurationFromLog)) {\n+            System.out.println(\"Okay\");\n+        } else {\n+            throw new RuntimeException(\"Configurations differ\");\n+        }\n+\n+        \/\/ If we want to run\n+\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/os\/HugePageDetection.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"}]}