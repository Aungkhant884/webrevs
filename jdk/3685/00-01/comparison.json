{"files":[{"patch":"@@ -1,432 +0,0 @@\n-diff --git a\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/EventStream.java b\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/EventStream.java\n-index 079813bfb77..ff84196c972 100644\n---- a\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/EventStream.java\n-+++ b\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/EventStream.java\n-@@ -138,7 +138,14 @@ public interface EventStream extends AutoCloseable {\n-      *\/\n-     public static EventStream openRepository() throws IOException {\n-         Utils.checkAccessFlightRecorder();\n--        return new EventDirectoryStream(AccessController.getContext(), null, SecuritySupport.PRIVILEGED, null, Collections.emptyList());\n-+        return new EventDirectoryStream(\n-+            AccessController.getContext(),\n-+            null,\n-+            SecuritySupport.PRIVILEGED,\n-+            null,\n-+            Collections.emptyList(),\n-+            false\n-+        );\n-     }\n- \n-     \/**\n-@@ -161,7 +168,14 @@ public interface EventStream extends AutoCloseable {\n-     public static EventStream openRepository(Path directory) throws IOException {\n-         Objects.requireNonNull(directory);\n-         AccessControlContext acc = AccessController.getContext();\n--        return new EventDirectoryStream(acc, directory, FileAccess.UNPRIVILEGED, null, Collections.emptyList());\n-+        return new EventDirectoryStream(\n-+            acc,\n-+            directory,\n-+            FileAccess.UNPRIVILEGED,\n-+            null,\n-+            Collections.emptyList(),\n-+            true\n-+        );\n-     }\n- \n-     \/**\n-diff --git a\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/RecordingStream.java b\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/RecordingStream.java\n-index 7d3a313a209..694be0667a9 100644\n---- a\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/RecordingStream.java\n-+++ b\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/RecordingStream.java\n-@@ -108,7 +108,14 @@ public final class RecordingStream implements AutoCloseable, EventStream {\n-         this.recording.setName(\"Recording Stream: \" + creationTime);\n-         try {\n-             PlatformRecording pr = PrivateAccess.getInstance().getPlatformRecording(recording);\n--            this.directoryStream = new EventDirectoryStream(acc, null, SecuritySupport.PRIVILEGED, pr, configurations());\n-+            this.directoryStream = new EventDirectoryStream(\n-+                acc,\n-+                null,\n-+                SecuritySupport.PRIVILEGED,\n-+                pr,\n-+                configurations(),\n-+                false\n-+            );\n-         } catch (IOException ioe) {\n-             this.recording.close();\n-             throw new IllegalStateException(ioe.getMessage());\n-diff --git a\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/PlatformRecorder.java b\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/PlatformRecorder.java\n-index 46f40bf1f59..ddfca0e4cad 100644\n---- a\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/PlatformRecorder.java\n-+++ b\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/PlatformRecorder.java\n-@@ -621,7 +621,7 @@ public final class PlatformRecorder {\n-     public synchronized void migrate(SafePath repo) throws IOException {\n-         \/\/ Must set repository while holding recorder lock so\n-         \/\/ the final chunk in repository gets marked correctly\n--        Repository.getRepository().setBasePath(repo);\n-+        Repository.getRepository().setBasePath(false, repo);\n-         boolean disk = false;\n-         for (PlatformRecording s : getRecordings()) {\n-             if (RecordingState.RUNNING == s.getState() && s.isToDisk()) {\n-diff --git a\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/Repository.java b\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/Repository.java\n-index 06a17489400..4c4e673b620 100644\n---- a\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/Repository.java\n-+++ b\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/Repository.java\n-@@ -55,14 +55,14 @@ public final class Repository {\n-         return instance;\n-     }\n- \n--    public synchronized void setBasePath(SafePath baseLocation) throws IOException {\n-+    public synchronized void setBasePath(boolean probe, SafePath baseLocation) throws IOException {\n-         if(baseLocation.equals(this.baseLocation)) {\n-             Logger.log(LogTag.JFR, LogLevel.INFO, \"Same base repository path \" + baseLocation.toString() + \" is set\");\n-             return;\n-         }\n-         \/\/ Probe to see if repository can be created, needed for fail fast\n-         \/\/ during JVM startup or JFR.configure\n--        this.repository = createRepository(baseLocation);\n-+        this.repository = createRepository(probe, baseLocation);\n-         this.chunkFilename = null;\n-         try {\n-             \/\/ Remove so we don't \"leak\" repositories, if JFR is never started\n-@@ -76,14 +76,14 @@ public final class Repository {\n- \n-     public synchronized void ensureRepository() throws IOException {\n-         if (baseLocation == null) {\n--            setBasePath(SecuritySupport.JAVA_IO_TMPDIR);\n-+            setBasePath(true, SecuritySupport.JAVA_IO_TMPDIR);\n-         }\n-     }\n- \n-     synchronized RepositoryChunk newChunk(ZonedDateTime timestamp) {\n-         try {\n-             if (!SecuritySupport.existDirectory(repository)) {\n--                this.repository = createRepository(baseLocation);\n-+                this.repository = createRepository(false, baseLocation);\n-                 jvm.setRepositoryLocation(repository.toString());\n-                 SecuritySupport.setProperty(JFR_REPOSITORY_LOCATION_PROPERTY, repository.toString());\n-                 cleanupDirectories.add(repository);\n-@@ -102,11 +102,12 @@ public final class Repository {\n-         }\n-     }\n- \n--    private static SafePath createRepository(SafePath basePath) throws IOException {\n-+    private static SafePath createRepository(boolean probe, SafePath basePath) throws IOException {\n-         SafePath canonicalBaseRepositoryPath = createRealBasePath(basePath);\n-         SafePath f = null;\n- \n--        String basename = Utils.formatDateTime(LocalDateTime.now()) + \"_\" + JVM.getJVM().getPid();\n-+        String basename = probe ? \"probe_\" : \"\";\n-+        basename+= Utils.formatDateTime(LocalDateTime.now()) + \"_\" + JVM.getJVM().getPid();\n-         String name = basename;\n- \n-         int i = 0;\n-diff --git a\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/SecuritySupport.java b\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/SecuritySupport.java\n-index 60246811484..3dd2f9bf41c 100644\n---- a\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/SecuritySupport.java\n-+++ b\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/SecuritySupport.java\n-@@ -46,6 +46,7 @@ import java.nio.file.Paths;\n- import java.nio.file.SimpleFileVisitor;\n- import java.nio.file.StandardOpenOption;\n- import java.nio.file.attribute.BasicFileAttributes;\n-+import java.nio.file.attribute.FileTime;\n- import java.security.AccessControlContext;\n- import java.security.AccessController;\n- import java.security.Permission;\n-@@ -506,6 +507,18 @@ public final class SecuritySupport {\n-         public boolean exists(Path p) throws IOException {\n-             return doPrivilegedIOWithReturn( () -> Files.exists(p));\n-         }\n-+\n-+        @Override\n-+        public boolean isDirectory(Path p) {\n-+            return doPrivilegedWithReturn( () -> Files.isDirectory(p));\n-+        }\n-+\n-+        @Override\n-+        public FileTime getLastModified(Path p) throws IOException {\n-+            \/\/ Timestamp only needed when examining repository for other JVMs,\n-+            \/\/ in which case an unprivileged mode should be used.\n-+            throw new InternalError(\"Should not reach here\");\n-+        }\n-     }\n- \n- \n-diff --git a\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/EventDirectoryStream.java b\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/EventDirectoryStream.java\n-index 543a1c93297..3c921ddd9af 100644\n---- a\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/EventDirectoryStream.java\n-+++ b\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/EventDirectoryStream.java\n-@@ -40,6 +40,7 @@ import jdk.jfr.Configuration;\n- import jdk.jfr.consumer.RecordedEvent;\n- import jdk.jfr.internal.JVM;\n- import jdk.jfr.internal.PlatformRecording;\n-+import jdk.jfr.internal.SecuritySupport;\n- import jdk.jfr.internal.Utils;\n- import jdk.jfr.internal.consumer.ChunkParser.ParserConfiguration;\n- \n-@@ -64,10 +65,21 @@ public class EventDirectoryStream extends AbstractEventStream {\n- \n-     private volatile Consumer<Long> onCompleteHandler;\n- \n--    public EventDirectoryStream(AccessControlContext acc, Path p, FileAccess fileAccess, PlatformRecording recording, List<Configuration> configurations) throws IOException {\n-+    public EventDirectoryStream(\n-+            AccessControlContext acc,\n-+            Path p,\n-+            FileAccess fileAccess,\n-+            PlatformRecording recording,\n-+            List<Configuration> configurations,\n-+            boolean allowSubDirectories\n-+            ) throws IOException {\n-+\n-         super(acc, recording, configurations);\n-+        if (p != null && SecuritySupport.PRIVILEGED == fileAccess) {\n-+            throw new SecurityException(\"Priviliged file access not allowed with potentially malicious Path implementation\");\n-+        }\n-         this.fileAccess = Objects.requireNonNull(fileAccess);\n--        this.repositoryFiles = new RepositoryFiles(fileAccess, p);\n-+        this.repositoryFiles = new RepositoryFiles(fileAccess, p, allowSubDirectories);\n-     }\n- \n-     @Override\n-@@ -136,6 +148,7 @@ public class EventDirectoryStream extends AbstractEventStream {\n-             return;\n-         }\n-         currentChunkStartNanos = repositoryFiles.getTimestamp(path);\n-+        System.out.println(\"Chunk parsing: \" + path);\n-         try (RecordingInput input = new RecordingInput(path.toFile(), fileAccess)) {\n-             currentParser = new ChunkParser(input, disp.parserConfiguration);\n-             long segmentStart = currentParser.getStartNanos() + currentParser.getChunkDuration();\n-diff --git a\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/FileAccess.java b\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/FileAccess.java\n-index 66f72a8dd55..66cfe3d5101 100644\n---- a\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/FileAccess.java\n-+++ b\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/FileAccess.java\n-@@ -31,6 +31,7 @@ import java.io.RandomAccessFile;\n- import java.nio.file.DirectoryStream;\n- import java.nio.file.Files;\n- import java.nio.file.Path;\n-+import java.nio.file.attribute.FileTime;\n- \n- \/\/ Protected by modular boundaries.\n- public abstract class FileAccess {\n-@@ -48,6 +49,10 @@ public abstract class FileAccess {\n- \n-     public abstract boolean exists(Path s) throws IOException;\n- \n-+    public abstract boolean isDirectory(Path p);\n-+\n-+    public abstract FileTime getLastModified(Path p) throws IOException;\n-+\n-     private static class UnPrivileged extends FileAccess {\n-         @Override\n-         public RandomAccessFile openRAF(File f, String mode) throws IOException {\n-@@ -78,5 +83,17 @@ public abstract class FileAccess {\n-         public boolean exists(Path p) {\n-             return Files.exists(p);\n-         }\n-+\n-+        @Override\n-+        public boolean isDirectory(Path p) {\n-+            return Files.isDirectory(p);\n-+        }\n-+\n-+        @Override\n-+        public FileTime getLastModified(Path p) throws IOException {\n-+            return Files.getLastModifiedTime(p);\n-+        }\n-     }\n-+\n-+\n- }\n-diff --git a\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/OngoingStream.java b\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/OngoingStream.java\n-index ac61378141e..91d725c1e48 100644\n---- a\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/OngoingStream.java\n-+++ b\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/OngoingStream.java\n-@@ -61,7 +61,7 @@ public final class OngoingStream extends EventByteStream {\n-         this.blockSize = blockSize;\n-         this.startTimeNanos = startTimeNanos;\n-         this.endTimeNanos = endTimeNanos;\n--        this.repositoryFiles = new RepositoryFiles(SecuritySupport.PRIVILEGED, null);\n-+        this.repositoryFiles = new RepositoryFiles(SecuritySupport.PRIVILEGED, null, false);\n-     }\n- \n-     @Override\n-diff --git a\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/RepositoryFiles.java b\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/RepositoryFiles.java\n-index 754e5fd6d3d..cdae473bc89 100644\n---- a\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/RepositoryFiles.java\n-+++ b\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/RepositoryFiles.java\n-@@ -27,7 +27,10 @@ package jdk.jfr.internal.consumer;\n- \n- import java.io.IOException;\n- import java.nio.file.DirectoryStream;\n-+import java.nio.file.Files;\n- import java.nio.file.Path;\n-+import java.nio.file.attribute.FileTime;\n-+import java.time.LocalDateTime;\n- import java.util.ArrayList;\n- import java.util.Collections;\n- import java.util.HashMap;\n-@@ -35,6 +38,7 @@ import java.util.HashSet;\n- import java.util.List;\n- import java.util.Map;\n- import java.util.NavigableMap;\n-+import java.util.Optional;\n- import java.util.Set;\n- import java.util.SortedMap;\n- import java.util.TreeMap;\n-@@ -47,6 +51,7 @@ import jdk.jfr.internal.SecuritySupport.SafePath;\n- \n- public final class RepositoryFiles {\n-     private static final Object WAIT_OBJECT = new Object();\n-+    private static final String DIRECTORY_PATTERN = \"DDDD_DD_DD_DD_DD_DD_\";\n-     public static void notifyNewFile() {\n-         synchronized (WAIT_OBJECT) {\n-             WAIT_OBJECT.notifyAll();\n-@@ -56,15 +61,16 @@ public final class RepositoryFiles {\n-     private final FileAccess fileAccess;\n-     private final NavigableMap<Long, Path> pathSet = new TreeMap<>();\n-     private final Map<Path, Long> pathLookup = new HashMap<>();\n--    private final Path repository;\n-     private final Object waitObject;\n--\n-+    private boolean allowSubDirectory;\n-     private volatile boolean closed;\n-+    private Path repository;\n- \n--    public RepositoryFiles(FileAccess fileAccess, Path repository) {\n-+    public RepositoryFiles(FileAccess fileAccess, Path repository, boolean allowSubDirectory) {\n-         this.repository = repository;\n-         this.fileAccess = fileAccess;\n-         this.waitObject = repository == null ? WAIT_OBJECT : new Object();\n-+        this.allowSubDirectory = allowSubDirectory;\n-     }\n- \n-     long getTimestamp(Path p) {\n-@@ -167,6 +173,14 @@ public final class RepositoryFiles {\n-     private boolean updatePaths() throws IOException {\n-         boolean foundNew = false;\n-         Path repoPath = repository;\n-+\n-+        if (allowSubDirectory) {\n-+            Path subDirectory = findSubDirectory(repoPath);\n-+            if (subDirectory != null) {\n-+                repoPath = subDirectory;\n-+            }\n-+        }\n-+\n-         if (repoPath == null) {\n-             \/\/ Always get the latest repository if 'jcmd JFR.configure\n-             \/\/ repositorypath=...' has been executed\n-@@ -209,20 +223,78 @@ public final class RepositoryFiles {\n-                 long size = fileAccess.fileSize(p);\n-                 if (size >= ChunkHeader.headerSize()) {\n-                     long startNanos = readStartTime(p);\n--                    pathSet.put(startNanos, p);\n--                    pathLookup.put(p, startNanos);\n--                    foundNew = true;\n-+                    if (startNanos != -1) {\n-+                        pathSet.put(startNanos, p);\n-+                        pathLookup.put(p, startNanos);\n-+                        foundNew = true;\n-+                    }\n-                 }\n-             }\n-+            if (allowSubDirectory && foundNew) {\n-+                \/\/ Found a valid file, possibly in a subdirectory.\n-+                \/\/ Use the same (sub)directory from now on.\n-+                repository = repoPath;\n-+                allowSubDirectory = false;\n-+            }\n-+\n-             return foundNew;\n-         }\n-     }\n- \n--    private long readStartTime(Path p) throws IOException {\n-+    private Path findSubDirectory(Path repoPath) {\n-+        FileTime latestTimestamp = null;\n-+        Path latestPath = null;\n-+        try (DirectoryStream<Path> dirStream = fileAccess.newDirectoryStream(repoPath)) {\n-+            for (Path p : dirStream) {\n-+                String filename = p.getFileName().toString();\n-+                if (isRepository(filename) && fileAccess.isDirectory(p)) {\n-+                    FileTime timestamp = getLastModified(p);\n-+                    if (timestamp != null) {\n-+                        if (latestPath == null || latestTimestamp.compareTo(timestamp) <= 0) {\n-+                            latestPath = p;\n-+                            latestTimestamp = timestamp;\n-+                        }\n-+                    }\n-+                }\n-+            }\n-+        } catch (IOException e) {\n-+            \/\/ Ignore\n-+        }\n-+        return latestPath;\n-+    }\n-+\n-+    private FileTime getLastModified(Path p) {\n-+        try {\n-+            return fileAccess.getLastModified(p);\n-+        } catch (IOException e) {\n-+            return null;\n-+        }\n-+    }\n-+\n-+    private static boolean isRepository(String filename) {\n-+        if (filename.length() < DIRECTORY_PATTERN.length()) {\n-+            return false;\n-+        }\n-+        for (int i = 0; i < DIRECTORY_PATTERN.length(); i++) {\n-+            char expected = DIRECTORY_PATTERN.charAt(i);\n-+            char c = filename.charAt(i);\n-+            if (expected == 'D' && !Character.isDigit(c)) {\n-+                return false;\n-+            }\n-+            if (expected == '_' && c != '_') {\n-+                return false;\n-+            }\n-+        }\n-+        return true;\n-+    }\n-+\n-+    private long readStartTime(Path p) {\n-         try (RecordingInput in = new RecordingInput(p.toFile(), fileAccess, 100)) {\n-             Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, \"Parsing header for chunk start time\");\n-             ChunkHeader c = new ChunkHeader(in);\n-             return c.getStartNanos();\n-+        } catch (IOException ioe) {\n-+            return -1;\n-         }\n-     }\n- \n-diff --git a\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/DCmdConfigure.java b\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/DCmdConfigure.java\n-index 78127138b8f..5c878b03be7 100644\n---- a\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/DCmdConfigure.java\n-+++ b\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/DCmdConfigure.java\n-@@ -93,7 +93,7 @@ final class DCmdConfigure extends AbstractDCmd {\n-                 if (FlightRecorder.isInitialized()) {\n-                     PrivateAccess.getInstance().getPlatformRecorder().migrate(s);\n-                 } else {\n--                    Repository.getRepository().setBasePath(s);\n-+                    Repository.getRepository().setBasePath(false, s);\n-                 }\n-                 Logger.log(LogTag.JFR, LogLevel.INFO, \"Base repository path set to \" + repositoryPath);\n-             } catch (Exception e) {\n-diff --git a\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/management\/ManagementSupport.java b\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/management\/ManagementSupport.java\n-index 39343ffb644..14cd860a98c 100644\n---- a\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/management\/ManagementSupport.java\n-+++ b\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/management\/ManagementSupport.java\n-@@ -174,6 +174,13 @@ public final class ManagementSupport {\n-             AccessControlContext acc,\n-             Path directory,\n-             List<Configuration> confs) throws IOException {\n--        return new EventDirectoryStream(acc, directory, FileAccess.UNPRIVILEGED, null, confs);\n-+        return new EventDirectoryStream(\n-+            acc,\n-+            directory,\n-+            FileAccess.UNPRIVILEGED,\n-+            null,\n-+            confs,\n-+            false\n-+        );\n-     }\n- }\n","filename":"patch.txt","additions":0,"deletions":432,"binary":false,"changes":432,"status":"deleted"}]}