{"files":[{"patch":"@@ -0,0 +1,432 @@\n+diff --git a\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/EventStream.java b\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/EventStream.java\n+index 079813bfb77..ff84196c972 100644\n+--- a\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/EventStream.java\n++++ b\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/EventStream.java\n+@@ -138,7 +138,14 @@ public interface EventStream extends AutoCloseable {\n+      *\/\n+     public static EventStream openRepository() throws IOException {\n+         Utils.checkAccessFlightRecorder();\n+-        return new EventDirectoryStream(AccessController.getContext(), null, SecuritySupport.PRIVILEGED, null, Collections.emptyList());\n++        return new EventDirectoryStream(\n++            AccessController.getContext(),\n++            null,\n++            SecuritySupport.PRIVILEGED,\n++            null,\n++            Collections.emptyList(),\n++            false\n++        );\n+     }\n+ \n+     \/**\n+@@ -161,7 +168,14 @@ public interface EventStream extends AutoCloseable {\n+     public static EventStream openRepository(Path directory) throws IOException {\n+         Objects.requireNonNull(directory);\n+         AccessControlContext acc = AccessController.getContext();\n+-        return new EventDirectoryStream(acc, directory, FileAccess.UNPRIVILEGED, null, Collections.emptyList());\n++        return new EventDirectoryStream(\n++            acc,\n++            directory,\n++            FileAccess.UNPRIVILEGED,\n++            null,\n++            Collections.emptyList(),\n++            true\n++        );\n+     }\n+ \n+     \/**\n+diff --git a\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/RecordingStream.java b\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/RecordingStream.java\n+index 7d3a313a209..694be0667a9 100644\n+--- a\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/RecordingStream.java\n++++ b\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/RecordingStream.java\n+@@ -108,7 +108,14 @@ public final class RecordingStream implements AutoCloseable, EventStream {\n+         this.recording.setName(\"Recording Stream: \" + creationTime);\n+         try {\n+             PlatformRecording pr = PrivateAccess.getInstance().getPlatformRecording(recording);\n+-            this.directoryStream = new EventDirectoryStream(acc, null, SecuritySupport.PRIVILEGED, pr, configurations());\n++            this.directoryStream = new EventDirectoryStream(\n++                acc,\n++                null,\n++                SecuritySupport.PRIVILEGED,\n++                pr,\n++                configurations(),\n++                false\n++            );\n+         } catch (IOException ioe) {\n+             this.recording.close();\n+             throw new IllegalStateException(ioe.getMessage());\n+diff --git a\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/PlatformRecorder.java b\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/PlatformRecorder.java\n+index 46f40bf1f59..ddfca0e4cad 100644\n+--- a\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/PlatformRecorder.java\n++++ b\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/PlatformRecorder.java\n+@@ -621,7 +621,7 @@ public final class PlatformRecorder {\n+     public synchronized void migrate(SafePath repo) throws IOException {\n+         \/\/ Must set repository while holding recorder lock so\n+         \/\/ the final chunk in repository gets marked correctly\n+-        Repository.getRepository().setBasePath(repo);\n++        Repository.getRepository().setBasePath(false, repo);\n+         boolean disk = false;\n+         for (PlatformRecording s : getRecordings()) {\n+             if (RecordingState.RUNNING == s.getState() && s.isToDisk()) {\n+diff --git a\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/Repository.java b\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/Repository.java\n+index 06a17489400..4c4e673b620 100644\n+--- a\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/Repository.java\n++++ b\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/Repository.java\n+@@ -55,14 +55,14 @@ public final class Repository {\n+         return instance;\n+     }\n+ \n+-    public synchronized void setBasePath(SafePath baseLocation) throws IOException {\n++    public synchronized void setBasePath(boolean probe, SafePath baseLocation) throws IOException {\n+         if(baseLocation.equals(this.baseLocation)) {\n+             Logger.log(LogTag.JFR, LogLevel.INFO, \"Same base repository path \" + baseLocation.toString() + \" is set\");\n+             return;\n+         }\n+         \/\/ Probe to see if repository can be created, needed for fail fast\n+         \/\/ during JVM startup or JFR.configure\n+-        this.repository = createRepository(baseLocation);\n++        this.repository = createRepository(probe, baseLocation);\n+         this.chunkFilename = null;\n+         try {\n+             \/\/ Remove so we don't \"leak\" repositories, if JFR is never started\n+@@ -76,14 +76,14 @@ public final class Repository {\n+ \n+     public synchronized void ensureRepository() throws IOException {\n+         if (baseLocation == null) {\n+-            setBasePath(SecuritySupport.JAVA_IO_TMPDIR);\n++            setBasePath(true, SecuritySupport.JAVA_IO_TMPDIR);\n+         }\n+     }\n+ \n+     synchronized RepositoryChunk newChunk(ZonedDateTime timestamp) {\n+         try {\n+             if (!SecuritySupport.existDirectory(repository)) {\n+-                this.repository = createRepository(baseLocation);\n++                this.repository = createRepository(false, baseLocation);\n+                 jvm.setRepositoryLocation(repository.toString());\n+                 SecuritySupport.setProperty(JFR_REPOSITORY_LOCATION_PROPERTY, repository.toString());\n+                 cleanupDirectories.add(repository);\n+@@ -102,11 +102,12 @@ public final class Repository {\n+         }\n+     }\n+ \n+-    private static SafePath createRepository(SafePath basePath) throws IOException {\n++    private static SafePath createRepository(boolean probe, SafePath basePath) throws IOException {\n+         SafePath canonicalBaseRepositoryPath = createRealBasePath(basePath);\n+         SafePath f = null;\n+ \n+-        String basename = Utils.formatDateTime(LocalDateTime.now()) + \"_\" + JVM.getJVM().getPid();\n++        String basename = probe ? \"probe_\" : \"\";\n++        basename+= Utils.formatDateTime(LocalDateTime.now()) + \"_\" + JVM.getJVM().getPid();\n+         String name = basename;\n+ \n+         int i = 0;\n+diff --git a\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/SecuritySupport.java b\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/SecuritySupport.java\n+index 60246811484..3dd2f9bf41c 100644\n+--- a\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/SecuritySupport.java\n++++ b\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/SecuritySupport.java\n+@@ -46,6 +46,7 @@ import java.nio.file.Paths;\n+ import java.nio.file.SimpleFileVisitor;\n+ import java.nio.file.StandardOpenOption;\n+ import java.nio.file.attribute.BasicFileAttributes;\n++import java.nio.file.attribute.FileTime;\n+ import java.security.AccessControlContext;\n+ import java.security.AccessController;\n+ import java.security.Permission;\n+@@ -506,6 +507,18 @@ public final class SecuritySupport {\n+         public boolean exists(Path p) throws IOException {\n+             return doPrivilegedIOWithReturn( () -> Files.exists(p));\n+         }\n++\n++        @Override\n++        public boolean isDirectory(Path p) {\n++            return doPrivilegedWithReturn( () -> Files.isDirectory(p));\n++        }\n++\n++        @Override\n++        public FileTime getLastModified(Path p) throws IOException {\n++            \/\/ Timestamp only needed when examining repository for other JVMs,\n++            \/\/ in which case an unprivileged mode should be used.\n++            throw new InternalError(\"Should not reach here\");\n++        }\n+     }\n+ \n+ \n+diff --git a\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/EventDirectoryStream.java b\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/EventDirectoryStream.java\n+index 543a1c93297..3c921ddd9af 100644\n+--- a\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/EventDirectoryStream.java\n++++ b\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/EventDirectoryStream.java\n+@@ -40,6 +40,7 @@ import jdk.jfr.Configuration;\n+ import jdk.jfr.consumer.RecordedEvent;\n+ import jdk.jfr.internal.JVM;\n+ import jdk.jfr.internal.PlatformRecording;\n++import jdk.jfr.internal.SecuritySupport;\n+ import jdk.jfr.internal.Utils;\n+ import jdk.jfr.internal.consumer.ChunkParser.ParserConfiguration;\n+ \n+@@ -64,10 +65,21 @@ public class EventDirectoryStream extends AbstractEventStream {\n+ \n+     private volatile Consumer<Long> onCompleteHandler;\n+ \n+-    public EventDirectoryStream(AccessControlContext acc, Path p, FileAccess fileAccess, PlatformRecording recording, List<Configuration> configurations) throws IOException {\n++    public EventDirectoryStream(\n++            AccessControlContext acc,\n++            Path p,\n++            FileAccess fileAccess,\n++            PlatformRecording recording,\n++            List<Configuration> configurations,\n++            boolean allowSubDirectories\n++            ) throws IOException {\n++\n+         super(acc, recording, configurations);\n++        if (p != null && SecuritySupport.PRIVILEGED == fileAccess) {\n++            throw new SecurityException(\"Priviliged file access not allowed with potentially malicious Path implementation\");\n++        }\n+         this.fileAccess = Objects.requireNonNull(fileAccess);\n+-        this.repositoryFiles = new RepositoryFiles(fileAccess, p);\n++        this.repositoryFiles = new RepositoryFiles(fileAccess, p, allowSubDirectories);\n+     }\n+ \n+     @Override\n+@@ -136,6 +148,7 @@ public class EventDirectoryStream extends AbstractEventStream {\n+             return;\n+         }\n+         currentChunkStartNanos = repositoryFiles.getTimestamp(path);\n++        System.out.println(\"Chunk parsing: \" + path);\n+         try (RecordingInput input = new RecordingInput(path.toFile(), fileAccess)) {\n+             currentParser = new ChunkParser(input, disp.parserConfiguration);\n+             long segmentStart = currentParser.getStartNanos() + currentParser.getChunkDuration();\n+diff --git a\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/FileAccess.java b\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/FileAccess.java\n+index 66f72a8dd55..66cfe3d5101 100644\n+--- a\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/FileAccess.java\n++++ b\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/FileAccess.java\n+@@ -31,6 +31,7 @@ import java.io.RandomAccessFile;\n+ import java.nio.file.DirectoryStream;\n+ import java.nio.file.Files;\n+ import java.nio.file.Path;\n++import java.nio.file.attribute.FileTime;\n+ \n+ \/\/ Protected by modular boundaries.\n+ public abstract class FileAccess {\n+@@ -48,6 +49,10 @@ public abstract class FileAccess {\n+ \n+     public abstract boolean exists(Path s) throws IOException;\n+ \n++    public abstract boolean isDirectory(Path p);\n++\n++    public abstract FileTime getLastModified(Path p) throws IOException;\n++\n+     private static class UnPrivileged extends FileAccess {\n+         @Override\n+         public RandomAccessFile openRAF(File f, String mode) throws IOException {\n+@@ -78,5 +83,17 @@ public abstract class FileAccess {\n+         public boolean exists(Path p) {\n+             return Files.exists(p);\n+         }\n++\n++        @Override\n++        public boolean isDirectory(Path p) {\n++            return Files.isDirectory(p);\n++        }\n++\n++        @Override\n++        public FileTime getLastModified(Path p) throws IOException {\n++            return Files.getLastModifiedTime(p);\n++        }\n+     }\n++\n++\n+ }\n+diff --git a\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/OngoingStream.java b\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/OngoingStream.java\n+index ac61378141e..91d725c1e48 100644\n+--- a\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/OngoingStream.java\n++++ b\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/OngoingStream.java\n+@@ -61,7 +61,7 @@ public final class OngoingStream extends EventByteStream {\n+         this.blockSize = blockSize;\n+         this.startTimeNanos = startTimeNanos;\n+         this.endTimeNanos = endTimeNanos;\n+-        this.repositoryFiles = new RepositoryFiles(SecuritySupport.PRIVILEGED, null);\n++        this.repositoryFiles = new RepositoryFiles(SecuritySupport.PRIVILEGED, null, false);\n+     }\n+ \n+     @Override\n+diff --git a\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/RepositoryFiles.java b\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/RepositoryFiles.java\n+index 754e5fd6d3d..cdae473bc89 100644\n+--- a\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/RepositoryFiles.java\n++++ b\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/RepositoryFiles.java\n+@@ -27,7 +27,10 @@ package jdk.jfr.internal.consumer;\n+ \n+ import java.io.IOException;\n+ import java.nio.file.DirectoryStream;\n++import java.nio.file.Files;\n+ import java.nio.file.Path;\n++import java.nio.file.attribute.FileTime;\n++import java.time.LocalDateTime;\n+ import java.util.ArrayList;\n+ import java.util.Collections;\n+ import java.util.HashMap;\n+@@ -35,6 +38,7 @@ import java.util.HashSet;\n+ import java.util.List;\n+ import java.util.Map;\n+ import java.util.NavigableMap;\n++import java.util.Optional;\n+ import java.util.Set;\n+ import java.util.SortedMap;\n+ import java.util.TreeMap;\n+@@ -47,6 +51,7 @@ import jdk.jfr.internal.SecuritySupport.SafePath;\n+ \n+ public final class RepositoryFiles {\n+     private static final Object WAIT_OBJECT = new Object();\n++    private static final String DIRECTORY_PATTERN = \"DDDD_DD_DD_DD_DD_DD_\";\n+     public static void notifyNewFile() {\n+         synchronized (WAIT_OBJECT) {\n+             WAIT_OBJECT.notifyAll();\n+@@ -56,15 +61,16 @@ public final class RepositoryFiles {\n+     private final FileAccess fileAccess;\n+     private final NavigableMap<Long, Path> pathSet = new TreeMap<>();\n+     private final Map<Path, Long> pathLookup = new HashMap<>();\n+-    private final Path repository;\n+     private final Object waitObject;\n+-\n++    private boolean allowSubDirectory;\n+     private volatile boolean closed;\n++    private Path repository;\n+ \n+-    public RepositoryFiles(FileAccess fileAccess, Path repository) {\n++    public RepositoryFiles(FileAccess fileAccess, Path repository, boolean allowSubDirectory) {\n+         this.repository = repository;\n+         this.fileAccess = fileAccess;\n+         this.waitObject = repository == null ? WAIT_OBJECT : new Object();\n++        this.allowSubDirectory = allowSubDirectory;\n+     }\n+ \n+     long getTimestamp(Path p) {\n+@@ -167,6 +173,14 @@ public final class RepositoryFiles {\n+     private boolean updatePaths() throws IOException {\n+         boolean foundNew = false;\n+         Path repoPath = repository;\n++\n++        if (allowSubDirectory) {\n++            Path subDirectory = findSubDirectory(repoPath);\n++            if (subDirectory != null) {\n++                repoPath = subDirectory;\n++            }\n++        }\n++\n+         if (repoPath == null) {\n+             \/\/ Always get the latest repository if 'jcmd JFR.configure\n+             \/\/ repositorypath=...' has been executed\n+@@ -209,20 +223,78 @@ public final class RepositoryFiles {\n+                 long size = fileAccess.fileSize(p);\n+                 if (size >= ChunkHeader.headerSize()) {\n+                     long startNanos = readStartTime(p);\n+-                    pathSet.put(startNanos, p);\n+-                    pathLookup.put(p, startNanos);\n+-                    foundNew = true;\n++                    if (startNanos != -1) {\n++                        pathSet.put(startNanos, p);\n++                        pathLookup.put(p, startNanos);\n++                        foundNew = true;\n++                    }\n+                 }\n+             }\n++            if (allowSubDirectory && foundNew) {\n++                \/\/ Found a valid file, possibly in a subdirectory.\n++                \/\/ Use the same (sub)directory from now on.\n++                repository = repoPath;\n++                allowSubDirectory = false;\n++            }\n++\n+             return foundNew;\n+         }\n+     }\n+ \n+-    private long readStartTime(Path p) throws IOException {\n++    private Path findSubDirectory(Path repoPath) {\n++        FileTime latestTimestamp = null;\n++        Path latestPath = null;\n++        try (DirectoryStream<Path> dirStream = fileAccess.newDirectoryStream(repoPath)) {\n++            for (Path p : dirStream) {\n++                String filename = p.getFileName().toString();\n++                if (isRepository(filename) && fileAccess.isDirectory(p)) {\n++                    FileTime timestamp = getLastModified(p);\n++                    if (timestamp != null) {\n++                        if (latestPath == null || latestTimestamp.compareTo(timestamp) <= 0) {\n++                            latestPath = p;\n++                            latestTimestamp = timestamp;\n++                        }\n++                    }\n++                }\n++            }\n++        } catch (IOException e) {\n++            \/\/ Ignore\n++        }\n++        return latestPath;\n++    }\n++\n++    private FileTime getLastModified(Path p) {\n++        try {\n++            return fileAccess.getLastModified(p);\n++        } catch (IOException e) {\n++            return null;\n++        }\n++    }\n++\n++    private static boolean isRepository(String filename) {\n++        if (filename.length() < DIRECTORY_PATTERN.length()) {\n++            return false;\n++        }\n++        for (int i = 0; i < DIRECTORY_PATTERN.length(); i++) {\n++            char expected = DIRECTORY_PATTERN.charAt(i);\n++            char c = filename.charAt(i);\n++            if (expected == 'D' && !Character.isDigit(c)) {\n++                return false;\n++            }\n++            if (expected == '_' && c != '_') {\n++                return false;\n++            }\n++        }\n++        return true;\n++    }\n++\n++    private long readStartTime(Path p) {\n+         try (RecordingInput in = new RecordingInput(p.toFile(), fileAccess, 100)) {\n+             Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, \"Parsing header for chunk start time\");\n+             ChunkHeader c = new ChunkHeader(in);\n+             return c.getStartNanos();\n++        } catch (IOException ioe) {\n++            return -1;\n+         }\n+     }\n+ \n+diff --git a\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/DCmdConfigure.java b\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/DCmdConfigure.java\n+index 78127138b8f..5c878b03be7 100644\n+--- a\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/DCmdConfigure.java\n++++ b\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/DCmdConfigure.java\n+@@ -93,7 +93,7 @@ final class DCmdConfigure extends AbstractDCmd {\n+                 if (FlightRecorder.isInitialized()) {\n+                     PrivateAccess.getInstance().getPlatformRecorder().migrate(s);\n+                 } else {\n+-                    Repository.getRepository().setBasePath(s);\n++                    Repository.getRepository().setBasePath(false, s);\n+                 }\n+                 Logger.log(LogTag.JFR, LogLevel.INFO, \"Base repository path set to \" + repositoryPath);\n+             } catch (Exception e) {\n+diff --git a\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/management\/ManagementSupport.java b\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/management\/ManagementSupport.java\n+index 39343ffb644..14cd860a98c 100644\n+--- a\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/management\/ManagementSupport.java\n++++ b\/src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/management\/ManagementSupport.java\n+@@ -174,6 +174,13 @@ public final class ManagementSupport {\n+             AccessControlContext acc,\n+             Path directory,\n+             List<Configuration> confs) throws IOException {\n+-        return new EventDirectoryStream(acc, directory, FileAccess.UNPRIVILEGED, null, confs);\n++        return new EventDirectoryStream(\n++            acc,\n++            directory,\n++            FileAccess.UNPRIVILEGED,\n++            null,\n++            confs,\n++            false\n++        );\n+     }\n+ }\n","filename":"patch.txt","additions":432,"deletions":0,"binary":false,"changes":432,"status":"added"},{"patch":"@@ -141,1 +141,8 @@\n-        return new EventDirectoryStream(AccessController.getContext(), null, SecuritySupport.PRIVILEGED, null, Collections.emptyList());\n+        return new EventDirectoryStream(\n+            AccessController.getContext(),\n+            null,\n+            SecuritySupport.PRIVILEGED,\n+            null,\n+            Collections.emptyList(),\n+            false\n+        );\n@@ -164,1 +171,8 @@\n-        return new EventDirectoryStream(acc, directory, FileAccess.UNPRIVILEGED, null, Collections.emptyList());\n+        return new EventDirectoryStream(\n+            acc,\n+            directory,\n+            FileAccess.UNPRIVILEGED,\n+            null,\n+            Collections.emptyList(),\n+            true\n+        );\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/EventStream.java","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -111,1 +111,8 @@\n-            this.directoryStream = new EventDirectoryStream(acc, null, SecuritySupport.PRIVILEGED, pr, configurations());\n+            this.directoryStream = new EventDirectoryStream(\n+                acc,\n+                null,\n+                SecuritySupport.PRIVILEGED,\n+                pr,\n+                configurations(),\n+                false\n+            );\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/RecordingStream.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+import java.nio.file.attribute.FileTime;\n@@ -509,0 +510,12 @@\n+\n+        @Override\n+        public boolean isDirectory(Path p) {\n+            return doPrivilegedWithReturn( () -> Files.isDirectory(p));\n+        }\n+\n+        @Override\n+        public FileTime getLastModified(Path p) throws IOException {\n+            \/\/ Timestamp only needed when examining repository for other JVMs,\n+            \/\/ in which case an unprivileged mode should be used.\n+            throw new InternalError(\"Should not reach here\");\n+        }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/SecuritySupport.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,1 @@\n+import jdk.jfr.internal.SecuritySupport;\n@@ -67,1 +68,7 @@\n-    public EventDirectoryStream(AccessControlContext acc, Path p, FileAccess fileAccess, PlatformRecording recording, List<Configuration> configurations) throws IOException {\n+    public EventDirectoryStream(\n+            AccessControlContext acc,\n+            Path p,\n+            FileAccess fileAccess,\n+            PlatformRecording recording,\n+            List<Configuration> configurations,\n+            boolean allowSubDirectories) throws IOException {\n@@ -69,0 +76,3 @@\n+        if (p != null && SecuritySupport.PRIVILEGED == fileAccess) {\n+            throw new SecurityException(\"Priviliged file access not allowed with potentially malicious Path implementation\");\n+        }\n@@ -70,1 +80,1 @@\n-        this.repositoryFiles = new RepositoryFiles(fileAccess, p);\n+        this.repositoryFiles = new RepositoryFiles(fileAccess, p, allowSubDirectories);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/EventDirectoryStream.java","additions":13,"deletions":3,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.nio.file.attribute.FileTime;\n@@ -51,0 +52,4 @@\n+    public abstract boolean isDirectory(Path p);\n+\n+    public abstract FileTime getLastModified(Path p) throws IOException;\n+\n@@ -81,0 +86,10 @@\n+\n+        @Override\n+        public boolean isDirectory(Path p) {\n+            return Files.isDirectory(p);\n+        }\n+\n+        @Override\n+        public FileTime getLastModified(Path p) throws IOException {\n+            return Files.getLastModifiedTime(p);\n+        }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/FileAccess.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-        this.repositoryFiles = new RepositoryFiles(SecuritySupport.PRIVILEGED, null);\n+        this.repositoryFiles = new RepositoryFiles(SecuritySupport.PRIVILEGED, null, false);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/OngoingStream.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import java.nio.file.attribute.FileTime;\n@@ -50,0 +51,1 @@\n+    private static final String DIRECTORY_PATTERN = \"DDDD_DD_DD_DD_DD_DD_\";\n@@ -59,1 +61,0 @@\n-    private final Path repository;\n@@ -61,1 +62,1 @@\n-\n+    private boolean allowSubDirectory;\n@@ -63,0 +64,1 @@\n+    private Path repository;\n@@ -64,1 +66,1 @@\n-    public RepositoryFiles(FileAccess fileAccess, Path repository) {\n+    public RepositoryFiles(FileAccess fileAccess, Path repository, boolean allowSubDirectory) {\n@@ -68,0 +70,1 @@\n+        this.allowSubDirectory = allowSubDirectory;\n@@ -170,0 +173,8 @@\n+\n+        if (allowSubDirectory) {\n+            Path subDirectory = findSubDirectory(repoPath);\n+            if (subDirectory != null) {\n+                repoPath = subDirectory;\n+            }\n+        }\n+\n@@ -212,3 +223,5 @@\n-                    pathSet.put(startNanos, p);\n-                    pathLookup.put(p, startNanos);\n-                    foundNew = true;\n+                    if (startNanos != -1) {\n+                        pathSet.put(startNanos, p);\n+                        pathLookup.put(p, startNanos);\n+                        foundNew = true;\n+                    }\n@@ -217,0 +230,7 @@\n+            if (allowSubDirectory && foundNew) {\n+                \/\/ Found a valid file, possibly in a subdirectory.\n+                \/\/ Use the same (sub)directory from now on.\n+                repository = repoPath;\n+                allowSubDirectory = false;\n+            }\n+\n@@ -221,1 +241,48 @@\n-    private long readStartTime(Path p) throws IOException {\n+    private Path findSubDirectory(Path repoPath) {\n+        FileTime latestTimestamp = null;\n+        Path latestPath = null;\n+        try (DirectoryStream<Path> dirStream = fileAccess.newDirectoryStream(repoPath)) {\n+            for (Path p : dirStream) {\n+                String filename = p.getFileName().toString();\n+                if (isRepository(filename) && fileAccess.isDirectory(p)) {\n+                    FileTime timestamp = getLastModified(p);\n+                    if (timestamp != null) {\n+                        if (latestPath == null || latestTimestamp.compareTo(timestamp) <= 0) {\n+                            latestPath = p;\n+                            latestTimestamp = timestamp;\n+                        }\n+                    }\n+                }\n+            }\n+        } catch (IOException e) {\n+            \/\/ Ignore\n+        }\n+        return latestPath;\n+    }\n+\n+    private FileTime getLastModified(Path p) {\n+        try {\n+            return fileAccess.getLastModified(p);\n+        } catch (IOException e) {\n+            return null;\n+        }\n+    }\n+\n+    private static boolean isRepository(String filename) {\n+        if (filename.length() < DIRECTORY_PATTERN.length()) {\n+            return false;\n+        }\n+        for (int i = 0; i < DIRECTORY_PATTERN.length(); i++) {\n+            char expected = DIRECTORY_PATTERN.charAt(i);\n+            char c = filename.charAt(i);\n+            if (expected == 'D' && !Character.isDigit(c)) {\n+                return false;\n+            }\n+            if (expected == '_' && c != '_') {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private long readStartTime(Path p) {\n@@ -226,0 +293,2 @@\n+        } catch (IOException ioe) {\n+            return -1;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/RepositoryFiles.java","additions":77,"deletions":8,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -177,1 +177,8 @@\n-        return new EventDirectoryStream(acc, directory, FileAccess.UNPRIVILEGED, null, confs);\n+        return new EventDirectoryStream(\n+            acc,\n+            directory,\n+            FileAccess.UNPRIVILEGED,\n+            null,\n+            confs,\n+            false\n+        );\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/management\/ManagementSupport.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,219 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.api.consumer.streaming;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import com.sun.tools.attach.VirtualMachine;\n+import com.sun.tools.attach.VirtualMachineDescriptor;\n+\n+import jdk.jfr.Event;\n+import jdk.jfr.Name;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class Application {\n+    @Name(\"Message\")\n+    static class Message extends Event {\n+        String content;\n+    }\n+    private static int counter;\n+    private final Path lockFile;\n+    private final Path repository;\n+    private final String message;\n+    private final ScheduledExecutorService monitor;\n+    private final int id;\n+    private final Thread thread;\n+    private Process process;\n+    private OutputAnalyzer analyzer;\n+    private int statusCheck;\n+\n+    public Application(Path repository) {\n+        this(repository, \"Whatever\");\n+    }\n+\n+    public Application(Path repository, String message) {\n+        counter++;\n+        this.id = counter;\n+        String lockFilename = counter + \"_\";\n+        lockFilename += ProcessHandle.current() + \"_\";\n+        lockFilename += System.currentTimeMillis() + \".lock\";\n+        this.lockFile  = Path.of(\".\").resolve(lockFilename);\n+        this.repository = repository;\n+        this.message = message;\n+        \/\/ For debugging\n+        this.thread = Thread.currentThread();\n+        this.monitor = Executors.newScheduledThreadPool(1);\n+    }\n+\n+    public static void main(String... args) throws InterruptedException {\n+        Path p = Path.of(args[0]);\n+        String content = args[1];\n+        while (true) {\n+            Message event = new Message();\n+            event.content = content;\n+            event.commit();\n+            if (!Files.exists(p)) {\n+                return;\n+            }\n+            takeNap();\n+        }\n+    }\n+\n+    private static void takeNap() {\n+        try {\n+            Thread.sleep(10);\n+        } catch (InterruptedException e) {\n+            \/\/ ignore\n+        }\n+    }\n+\n+    public void start() throws IOException {\n+        String[] args = new String[5];\n+        args[0] = \"-XX:StartFlightRecording\";\n+        args[1] = \"-XX:FlightRecorderOptions:repository=\" + repository;\n+        args[2] = Application.class.getName();\n+        args[3] = lockFile.toString();\n+        args[4] = message;\n+        ProcessBuilder pb = ProcessTools.createTestJvm(args);\n+        touch(lockFile);\n+        process = pb.start();\n+        \/\/ For debugging\n+        analyzer = new OutputAnalyzer(process);\n+        monitor.scheduleWithFixedDelay(() -> checkStatus(), 0, 1, TimeUnit.SECONDS);\n+        if (!process.isAlive()) {\n+            throw new IOException(\"Test application not alive after start\");\n+        }\n+        System.out.println(\"App started\");\n+    }\n+\n+    public void stop() throws IOException {\n+        Files.delete(lockFile);\n+        monitor.shutdown();\n+    }\n+\n+    private static void touch(Path p) throws IOException, FileNotFoundException {\n+        try (RandomAccessFile raf = new RandomAccessFile(p.toFile(), \"rw\")) {\n+            raf.write(4711);\n+        }\n+    }\n+\n+    public void awaitRecording() throws IOException {\n+        String pid = Long.toString(process.pid());\n+        long t = System.currentTimeMillis();\n+        while (true) {\n+            if (!process.isAlive()) {\n+                String std = new String(process.getInputStream().readAllBytes());\n+                System.out.println(\"========= Application: \" + id + \" Process std out ==========\");\n+                System.out.println(std);\n+                System.out.println(\"====================================================\");\n+                String err = new String(process.getInputStream().readAllBytes());\n+                System.out.println(\"========= Application: \" + id + \" Process std err ==========\");\n+                System.out.println(err);\n+                System.out.println(\"====================================================\");\n+                throw new IOException(\"Application process not alive!\");\n+            }\n+            try {\n+                for (VirtualMachineDescriptor vmd: VirtualMachine.list()) {\n+                    if (vmd.id().equals(pid)) {\n+                        VirtualMachine vm = VirtualMachine.attach(vmd);\n+                        Object repo = vm.getSystemProperties().get(\"jdk.jfr.repository\");\n+                        vm.detach();\n+                        if (repo != null) {\n+                            return;\n+                        }\n+                    }\n+                }\n+            } catch (Exception e) {\n+                System.out.println(\"Await: \" + e.getMessage());\n+                System.out.println(\"Process alive: \"  + process.isAlive());\n+                System.out.println(\"PID: \" + pid);\n+            }\n+            takeNap();\n+            if (System.currentTimeMillis() -t > 10_000) {\n+                checkStatus();\n+                t = System.currentTimeMillis();\n+            }\n+            System.out.println(\"Awaiting recording\");\n+        }\n+     }\n+\n+    \/\/ For debugging purposes\n+    public void checkStatus() {\n+        System.out.println(\"Application \" + id + \" status: \");\n+        try {\n+            boolean hasRepository = Files.exists(repository);\n+            boolean hasLockFile = Files.exists(lockFile);\n+            boolean isAlive = process == null ? false : process.isAlive();\n+            System.out.println(\"Has repository: \" + hasRepository);\n+            System.out.println(\"Has lock file: \" + hasLockFile);\n+            System.out.println(\"Is alive: \" + isAlive);\n+            if (hasRepository) {\n+                System.out.println(directoryToText(new StringBuilder(), \"\", repository));\n+            }\n+            System.out.println();\n+            statusCheck++;\n+            if (statusCheck % 10 == 9) {\n+                System.out.println(\"Stack trace for thread that created the application:\");\n+                for (StackTraceElement se : thread.getStackTrace()) {\n+                    System.out.println(se);\n+                }\n+                if (process != null && !process.isAlive()) {\n+                    System.out.println(analyzer.getStdout());\n+                    System.out.println(analyzer.getStderr());\n+                }\n+            }\n+        } catch (Exception e) {\n+            System.out.println(e.getMessage());\n+        }\n+    }\n+\n+    private static StringBuilder directoryToText(StringBuilder output, String indent, Path directory) throws IOException {\n+        output.append(indent)\n+          .append(\"*- \")\n+          .append(directory.getFileName().toString())\n+          .append(System.lineSeparator());\n+        for (Path path : Files.list(directory).toList()) {\n+            if (Files.isDirectory(path)) {\n+                directoryToText(output, indent + \" \", path);\n+            } else {\n+                fileToText(output, indent + \" \", path);\n+            }\n+        }\n+        return output;\n+    }\n+\n+    private static void fileToText(StringBuilder output, String indent, Path file) throws IOException {\n+        output.append(indent)\n+          .append(\"|- \")\n+          .append(file.getFileName().toString())\n+          .append(System.lineSeparator());\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/jdk\/jfr\/api\/consumer\/streaming\/Application.java","additions":219,"deletions":0,"binary":false,"changes":219,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.api.consumer.streaming;\n+\n+import java.nio.file.Path;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import jdk.jfr.consumer.EventStream;\n+import jdk.test.lib.Asserts;\n+\n+\/**\n+ * @test\n+ * @summary Test that it is possible to start a stream against a directory,\n+ *          specified on command, line before the application starts\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @build jdk.jfr.api.consumer.streaming.Application\n+ * @run main\/othervm jdk.jfr.api.consumer.streaming.TestBaseRepositoryAfterStart\n+ *\/\n+public class TestBaseRepositoryAfterStart {\n+    public static void main(String... args) throws Exception {\n+        AtomicBoolean success = new AtomicBoolean();\n+        Path repository = Path.of(\"single-after\");\n+        Application app = new Application(repository);\n+        app.start();\n+        app.awaitRecording();\n+        try (EventStream es = EventStream.openRepository(repository)) {\n+            es.onEvent(e -> {\n+                success.set(true);\n+                es.close();\n+            });\n+            es.start();\n+        }\n+        app.stop();\n+        Asserts.assertTrue(success.get(), \"Unable to start stream after application started\");\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/api\/consumer\/streaming\/TestBaseRepositoryAfterStart.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.api.consumer.streaming;\n+\n+import java.nio.file.Path;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import jdk.jfr.consumer.EventStream;\n+import jdk.test.lib.Asserts;\n+\n+\/**\n+ * @test\n+ * @summary Test that it is possible to start a stream against a directory,\n+ *          specified on command line, after the application starts\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @build jdk.jfr.api.consumer.streaming.Application\n+ * @run main\/othervm jdk.jfr.api.consumer.streaming.TestBaseRepositoryBeforeStart\n+ *\/\n+public class TestBaseRepositoryBeforeStart {\n+    public static void main(String... args) throws Exception {\n+        AtomicBoolean success = new AtomicBoolean();\n+        Path repository = Path.of(\"single-before\");\n+        try (EventStream es = EventStream.openRepository(repository)) {\n+            es.onEvent(e -> {\n+                success.set(true);\n+                es.close();\n+            });\n+            es.startAsync(); \/\/ not guaranteed to have started, but likely\n+            Application app = new Application(repository);\n+            app.start();\n+            es.awaitTermination();\n+            app.stop();\n+        }\n+        Asserts.assertTrue(success.get(), \"Unable to start stream before application starts\");\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/api\/consumer\/streaming\/TestBaseRepositoryBeforeStart.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.api.consumer.streaming;\n+\n+import java.nio.file.Path;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import jdk.jfr.consumer.EventStream;\n+import jdk.test.lib.Asserts;\n+\n+\/**\n+ * @test\n+ * @summary Test that a stream starts against the latest created repository\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @build jdk.jfr.api.consumer.streaming.Application\n+ * @run main\/othervm jdk.jfr.api.consumer.streaming.TestBaseRepositoryLastModified\n+ *\/\n+public class TestBaseRepositoryLastModified {\n+    public static void main(String... args) throws Exception {\n+        AtomicBoolean success = new AtomicBoolean();\n+        Path repository = Path.of(\"last-modified\");\n+\n+        Application app1 = new Application(repository, \"One\");\n+        app1.start();\n+        app1.awaitRecording();\n+\n+        Application app2 = new Application(repository, \"Two\");\n+        app2.start();\n+        app2.awaitRecording();\n+\n+        try (EventStream es = EventStream.openRepository(repository)) {\n+            es.onEvent(\"Message\", e -> {\n+                String message = e.getString(\"content\");\n+                success.set(\"Two\".equals(message));\n+                es.close();\n+            });\n+            es.start();\n+        }\n+        app1.stop();\n+        app2.stop();\n+        Asserts.assertTrue(success.get(), \"Stream not opened against most recent directory\");\n+\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/api\/consumer\/streaming\/TestBaseRepositoryLastModified.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.api.consumer.streaming;\n+\n+import java.nio.file.Path;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import jdk.jfr.consumer.EventStream;\n+import jdk.test.lib.Asserts;\n+\n+\/**\n+ * @test\n+ * @summary Test that it is possible to start a stream against a directory,\n+ *          specified on command line, where multiple processes starts\n+ *          simultaneously\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @build jdk.jfr.api.consumer.streaming.Application\n+ * @run main\/othervm jdk.jfr.api.consumer.streaming.TestBaseRepositoryMultipleProcesses\n+ *\/\n+public class TestBaseRepositoryMultipleProcesses {\n+    public static void main(String... args) throws Exception {\n+        AtomicBoolean success = new AtomicBoolean();\n+        Path repository = Path.of(\"multiple\");\n+        Application app1 = new Application(repository);\n+        Application app2 = new Application(repository);\n+        Application app3 = new Application(repository);\n+        app1.start();\n+        app2.start();\n+        app3.start();\n+        try (EventStream es = EventStream.openRepository(repository)) {\n+            es.onEvent(e -> {\n+                success.set(true);\n+                es.close();\n+            });\n+            es.start();\n+        }\n+        app1.stop();\n+        app2.stop();\n+        app3.stop();\n+        Asserts.assertTrue(success.get(), \"Unable to stream when there are multiple processes\");\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/api\/consumer\/streaming\/TestBaseRepositoryMultipleProcesses.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"}]}