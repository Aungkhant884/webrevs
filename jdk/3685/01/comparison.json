{"files":[{"patch":"@@ -141,1 +141,8 @@\n-        return new EventDirectoryStream(AccessController.getContext(), null, SecuritySupport.PRIVILEGED, null, Collections.emptyList());\n+        return new EventDirectoryStream(\n+            AccessController.getContext(),\n+            null,\n+            SecuritySupport.PRIVILEGED,\n+            null,\n+            Collections.emptyList(),\n+            false\n+        );\n@@ -164,1 +171,8 @@\n-        return new EventDirectoryStream(acc, directory, FileAccess.UNPRIVILEGED, null, Collections.emptyList());\n+        return new EventDirectoryStream(\n+            acc,\n+            directory,\n+            FileAccess.UNPRIVILEGED,\n+            null,\n+            Collections.emptyList(),\n+            true\n+        );\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/EventStream.java","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -111,1 +111,8 @@\n-            this.directoryStream = new EventDirectoryStream(acc, null, SecuritySupport.PRIVILEGED, pr, configurations());\n+            this.directoryStream = new EventDirectoryStream(\n+                acc,\n+                null,\n+                SecuritySupport.PRIVILEGED,\n+                pr,\n+                configurations(),\n+                false\n+            );\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/RecordingStream.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+import java.nio.file.attribute.FileTime;\n@@ -509,0 +510,12 @@\n+\n+        @Override\n+        public boolean isDirectory(Path p) {\n+            return doPrivilegedWithReturn( () -> Files.isDirectory(p));\n+        }\n+\n+        @Override\n+        public FileTime getLastModified(Path p) throws IOException {\n+            \/\/ Timestamp only needed when examining repository for other JVMs,\n+            \/\/ in which case an unprivileged mode should be used.\n+            throw new InternalError(\"Should not reach here\");\n+        }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/SecuritySupport.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,1 @@\n+import jdk.jfr.internal.SecuritySupport;\n@@ -67,1 +68,7 @@\n-    public EventDirectoryStream(AccessControlContext acc, Path p, FileAccess fileAccess, PlatformRecording recording, List<Configuration> configurations) throws IOException {\n+    public EventDirectoryStream(\n+            AccessControlContext acc,\n+            Path p,\n+            FileAccess fileAccess,\n+            PlatformRecording recording,\n+            List<Configuration> configurations,\n+            boolean allowSubDirectories) throws IOException {\n@@ -69,0 +76,3 @@\n+        if (p != null && SecuritySupport.PRIVILEGED == fileAccess) {\n+            throw new SecurityException(\"Priviliged file access not allowed with potentially malicious Path implementation\");\n+        }\n@@ -70,1 +80,1 @@\n-        this.repositoryFiles = new RepositoryFiles(fileAccess, p);\n+        this.repositoryFiles = new RepositoryFiles(fileAccess, p, allowSubDirectories);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/EventDirectoryStream.java","additions":13,"deletions":3,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.nio.file.attribute.FileTime;\n@@ -51,0 +52,4 @@\n+    public abstract boolean isDirectory(Path p);\n+\n+    public abstract FileTime getLastModified(Path p) throws IOException;\n+\n@@ -81,0 +86,10 @@\n+\n+        @Override\n+        public boolean isDirectory(Path p) {\n+            return Files.isDirectory(p);\n+        }\n+\n+        @Override\n+        public FileTime getLastModified(Path p) throws IOException {\n+            return Files.getLastModifiedTime(p);\n+        }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/FileAccess.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-        this.repositoryFiles = new RepositoryFiles(SecuritySupport.PRIVILEGED, null);\n+        this.repositoryFiles = new RepositoryFiles(SecuritySupport.PRIVILEGED, null, false);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/OngoingStream.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import java.nio.file.attribute.FileTime;\n@@ -50,0 +51,1 @@\n+    private static final String DIRECTORY_PATTERN = \"DDDD_DD_DD_DD_DD_DD_\";\n@@ -59,1 +61,0 @@\n-    private final Path repository;\n@@ -61,1 +62,1 @@\n-\n+    private boolean allowSubDirectory;\n@@ -63,0 +64,1 @@\n+    private Path repository;\n@@ -64,1 +66,1 @@\n-    public RepositoryFiles(FileAccess fileAccess, Path repository) {\n+    public RepositoryFiles(FileAccess fileAccess, Path repository, boolean allowSubDirectory) {\n@@ -68,0 +70,1 @@\n+        this.allowSubDirectory = allowSubDirectory;\n@@ -170,0 +173,8 @@\n+\n+        if (allowSubDirectory) {\n+            Path subDirectory = findSubDirectory(repoPath);\n+            if (subDirectory != null) {\n+                repoPath = subDirectory;\n+            }\n+        }\n+\n@@ -212,3 +223,5 @@\n-                    pathSet.put(startNanos, p);\n-                    pathLookup.put(p, startNanos);\n-                    foundNew = true;\n+                    if (startNanos != -1) {\n+                        pathSet.put(startNanos, p);\n+                        pathLookup.put(p, startNanos);\n+                        foundNew = true;\n+                    }\n@@ -217,0 +230,7 @@\n+            if (allowSubDirectory && foundNew) {\n+                \/\/ Found a valid file, possibly in a subdirectory.\n+                \/\/ Use the same (sub)directory from now on.\n+                repository = repoPath;\n+                allowSubDirectory = false;\n+            }\n+\n@@ -221,1 +241,48 @@\n-    private long readStartTime(Path p) throws IOException {\n+    private Path findSubDirectory(Path repoPath) {\n+        FileTime latestTimestamp = null;\n+        Path latestPath = null;\n+        try (DirectoryStream<Path> dirStream = fileAccess.newDirectoryStream(repoPath)) {\n+            for (Path p : dirStream) {\n+                String filename = p.getFileName().toString();\n+                if (isRepository(filename) && fileAccess.isDirectory(p)) {\n+                    FileTime timestamp = getLastModified(p);\n+                    if (timestamp != null) {\n+                        if (latestPath == null || latestTimestamp.compareTo(timestamp) <= 0) {\n+                            latestPath = p;\n+                            latestTimestamp = timestamp;\n+                        }\n+                    }\n+                }\n+            }\n+        } catch (IOException e) {\n+            \/\/ Ignore\n+        }\n+        return latestPath;\n+    }\n+\n+    private FileTime getLastModified(Path p) {\n+        try {\n+            return fileAccess.getLastModified(p);\n+        } catch (IOException e) {\n+            return null;\n+        }\n+    }\n+\n+    private static boolean isRepository(String filename) {\n+        if (filename.length() < DIRECTORY_PATTERN.length()) {\n+            return false;\n+        }\n+        for (int i = 0; i < DIRECTORY_PATTERN.length(); i++) {\n+            char expected = DIRECTORY_PATTERN.charAt(i);\n+            char c = filename.charAt(i);\n+            if (expected == 'D' && !Character.isDigit(c)) {\n+                return false;\n+            }\n+            if (expected == '_' && c != '_') {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private long readStartTime(Path p) {\n@@ -226,0 +293,2 @@\n+        } catch (IOException ioe) {\n+            return -1;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/RepositoryFiles.java","additions":77,"deletions":8,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -177,1 +177,8 @@\n-        return new EventDirectoryStream(acc, directory, FileAccess.UNPRIVILEGED, null, confs);\n+        return new EventDirectoryStream(\n+            acc,\n+            directory,\n+            FileAccess.UNPRIVILEGED,\n+            null,\n+            confs,\n+            false\n+        );\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/management\/ManagementSupport.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,219 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.api.consumer.streaming;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import com.sun.tools.attach.VirtualMachine;\n+import com.sun.tools.attach.VirtualMachineDescriptor;\n+\n+import jdk.jfr.Event;\n+import jdk.jfr.Name;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class Application {\n+    @Name(\"Message\")\n+    static class Message extends Event {\n+        String content;\n+    }\n+    private static int counter;\n+    private final Path lockFile;\n+    private final Path repository;\n+    private final String message;\n+    private final ScheduledExecutorService monitor;\n+    private final int id;\n+    private final Thread thread;\n+    private Process process;\n+    private OutputAnalyzer analyzer;\n+    private int statusCheck;\n+\n+    public Application(Path repository) {\n+        this(repository, \"Whatever\");\n+    }\n+\n+    public Application(Path repository, String message) {\n+        counter++;\n+        this.id = counter;\n+        String lockFilename = counter + \"_\";\n+        lockFilename += ProcessHandle.current() + \"_\";\n+        lockFilename += System.currentTimeMillis() + \".lock\";\n+        this.lockFile  = Path.of(\".\").resolve(lockFilename);\n+        this.repository = repository;\n+        this.message = message;\n+        \/\/ For debugging\n+        this.thread = Thread.currentThread();\n+        this.monitor = Executors.newScheduledThreadPool(1);\n+    }\n+\n+    public static void main(String... args) throws InterruptedException {\n+        Path p = Path.of(args[0]);\n+        String content = args[1];\n+        while (true) {\n+            Message event = new Message();\n+            event.content = content;\n+            event.commit();\n+            if (!Files.exists(p)) {\n+                return;\n+            }\n+            takeNap();\n+        }\n+    }\n+\n+    private static void takeNap() {\n+        try {\n+            Thread.sleep(10);\n+        } catch (InterruptedException e) {\n+            \/\/ ignore\n+        }\n+    }\n+\n+    public void start() throws IOException {\n+        String[] args = new String[5];\n+        args[0] = \"-XX:StartFlightRecording\";\n+        args[1] = \"-XX:FlightRecorderOptions:repository=\" + repository;\n+        args[2] = Application.class.getName();\n+        args[3] = lockFile.toString();\n+        args[4] = message;\n+        ProcessBuilder pb = ProcessTools.createTestJvm(args);\n+        touch(lockFile);\n+        process = pb.start();\n+        \/\/ For debugging\n+        analyzer = new OutputAnalyzer(process);\n+        monitor.scheduleWithFixedDelay(() -> checkStatus(), 0, 1, TimeUnit.SECONDS);\n+        if (!process.isAlive()) {\n+            throw new IOException(\"Test application not alive after start\");\n+        }\n+        System.out.println(\"App started\");\n+    }\n+\n+    public void stop() throws IOException {\n+        Files.delete(lockFile);\n+        monitor.shutdown();\n+    }\n+\n+    private static void touch(Path p) throws IOException, FileNotFoundException {\n+        try (RandomAccessFile raf = new RandomAccessFile(p.toFile(), \"rw\")) {\n+            raf.write(4711);\n+        }\n+    }\n+\n+    public void awaitRecording() throws IOException {\n+        String pid = Long.toString(process.pid());\n+        long t = System.currentTimeMillis();\n+        while (true) {\n+            if (!process.isAlive()) {\n+                String std = new String(process.getInputStream().readAllBytes());\n+                System.out.println(\"========= Application: \" + id + \" Process std out ==========\");\n+                System.out.println(std);\n+                System.out.println(\"====================================================\");\n+                String err = new String(process.getInputStream().readAllBytes());\n+                System.out.println(\"========= Application: \" + id + \" Process std err ==========\");\n+                System.out.println(err);\n+                System.out.println(\"====================================================\");\n+                throw new IOException(\"Application process not alive!\");\n+            }\n+            try {\n+                for (VirtualMachineDescriptor vmd: VirtualMachine.list()) {\n+                    if (vmd.id().equals(pid)) {\n+                        VirtualMachine vm = VirtualMachine.attach(vmd);\n+                        Object repo = vm.getSystemProperties().get(\"jdk.jfr.repository\");\n+                        vm.detach();\n+                        if (repo != null) {\n+                            return;\n+                        }\n+                    }\n+                }\n+            } catch (Exception e) {\n+                System.out.println(\"Await: \" + e.getMessage());\n+                System.out.println(\"Process alive: \"  + process.isAlive());\n+                System.out.println(\"PID: \" + pid);\n+            }\n+            takeNap();\n+            if (System.currentTimeMillis() -t > 10_000) {\n+                checkStatus();\n+                t = System.currentTimeMillis();\n+            }\n+            System.out.println(\"Awaiting recording\");\n+        }\n+     }\n+\n+    \/\/ For debugging purposes\n+    public void checkStatus() {\n+        System.out.println(\"Application \" + id + \" status: \");\n+        try {\n+            boolean hasRepository = Files.exists(repository);\n+            boolean hasLockFile = Files.exists(lockFile);\n+            boolean isAlive = process == null ? false : process.isAlive();\n+            System.out.println(\"Has repository: \" + hasRepository);\n+            System.out.println(\"Has lock file: \" + hasLockFile);\n+            System.out.println(\"Is alive: \" + isAlive);\n+            if (hasRepository) {\n+                System.out.println(directoryToText(new StringBuilder(), \"\", repository));\n+            }\n+            System.out.println();\n+            statusCheck++;\n+            if (statusCheck % 10 == 9) {\n+                System.out.println(\"Stack trace for thread that created the application:\");\n+                for (StackTraceElement se : thread.getStackTrace()) {\n+                    System.out.println(se);\n+                }\n+                if (process != null && !process.isAlive()) {\n+                    System.out.println(analyzer.getStdout());\n+                    System.out.println(analyzer.getStderr());\n+                }\n+            }\n+        } catch (Exception e) {\n+            System.out.println(e.getMessage());\n+        }\n+    }\n+\n+    private static StringBuilder directoryToText(StringBuilder output, String indent, Path directory) throws IOException {\n+        output.append(indent)\n+          .append(\"*- \")\n+          .append(directory.getFileName().toString())\n+          .append(System.lineSeparator());\n+        for (Path path : Files.list(directory).toList()) {\n+            if (Files.isDirectory(path)) {\n+                directoryToText(output, indent + \" \", path);\n+            } else {\n+                fileToText(output, indent + \" \", path);\n+            }\n+        }\n+        return output;\n+    }\n+\n+    private static void fileToText(StringBuilder output, String indent, Path file) throws IOException {\n+        output.append(indent)\n+          .append(\"|- \")\n+          .append(file.getFileName().toString())\n+          .append(System.lineSeparator());\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/jdk\/jfr\/api\/consumer\/streaming\/Application.java","additions":219,"deletions":0,"binary":false,"changes":219,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.api.consumer.streaming;\n+\n+import java.nio.file.Path;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import jdk.jfr.consumer.EventStream;\n+import jdk.test.lib.Asserts;\n+\n+\/**\n+ * @test\n+ * @summary Test that it is possible to start a stream against a directory,\n+ *          specified on command, line before the application starts\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @build jdk.jfr.api.consumer.streaming.Application\n+ * @run main\/othervm jdk.jfr.api.consumer.streaming.TestBaseRepositoryAfterStart\n+ *\/\n+public class TestBaseRepositoryAfterStart {\n+    public static void main(String... args) throws Exception {\n+        AtomicBoolean success = new AtomicBoolean();\n+        Path repository = Path.of(\"single-after\");\n+        Application app = new Application(repository);\n+        app.start();\n+        app.awaitRecording();\n+        try (EventStream es = EventStream.openRepository(repository)) {\n+            es.onEvent(e -> {\n+                success.set(true);\n+                es.close();\n+            });\n+            es.start();\n+        }\n+        app.stop();\n+        Asserts.assertTrue(success.get(), \"Unable to start stream after application started\");\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/api\/consumer\/streaming\/TestBaseRepositoryAfterStart.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.api.consumer.streaming;\n+\n+import java.nio.file.Path;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import jdk.jfr.consumer.EventStream;\n+import jdk.test.lib.Asserts;\n+\n+\/**\n+ * @test\n+ * @summary Test that it is possible to start a stream against a directory,\n+ *          specified on command line, after the application starts\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @build jdk.jfr.api.consumer.streaming.Application\n+ * @run main\/othervm jdk.jfr.api.consumer.streaming.TestBaseRepositoryBeforeStart\n+ *\/\n+public class TestBaseRepositoryBeforeStart {\n+    public static void main(String... args) throws Exception {\n+        AtomicBoolean success = new AtomicBoolean();\n+        Path repository = Path.of(\"single-before\");\n+        try (EventStream es = EventStream.openRepository(repository)) {\n+            es.onEvent(e -> {\n+                success.set(true);\n+                es.close();\n+            });\n+            es.startAsync(); \/\/ not guaranteed to have started, but likely\n+            Application app = new Application(repository);\n+            app.start();\n+            es.awaitTermination();\n+            app.stop();\n+        }\n+        Asserts.assertTrue(success.get(), \"Unable to start stream before application starts\");\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/api\/consumer\/streaming\/TestBaseRepositoryBeforeStart.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.api.consumer.streaming;\n+\n+import java.nio.file.Path;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import jdk.jfr.consumer.EventStream;\n+import jdk.test.lib.Asserts;\n+\n+\/**\n+ * @test\n+ * @summary Test that a stream starts against the latest created repository\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @build jdk.jfr.api.consumer.streaming.Application\n+ * @run main\/othervm jdk.jfr.api.consumer.streaming.TestBaseRepositoryLastModified\n+ *\/\n+public class TestBaseRepositoryLastModified {\n+    public static void main(String... args) throws Exception {\n+        AtomicBoolean success = new AtomicBoolean();\n+        Path repository = Path.of(\"last-modified\");\n+\n+        Application app1 = new Application(repository, \"One\");\n+        app1.start();\n+        app1.awaitRecording();\n+\n+        Application app2 = new Application(repository, \"Two\");\n+        app2.start();\n+        app2.awaitRecording();\n+\n+        try (EventStream es = EventStream.openRepository(repository)) {\n+            es.onEvent(\"Message\", e -> {\n+                String message = e.getString(\"content\");\n+                success.set(\"Two\".equals(message));\n+                es.close();\n+            });\n+            es.start();\n+        }\n+        app1.stop();\n+        app2.stop();\n+        Asserts.assertTrue(success.get(), \"Stream not opened against most recent directory\");\n+\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/api\/consumer\/streaming\/TestBaseRepositoryLastModified.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.api.consumer.streaming;\n+\n+import java.nio.file.Path;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import jdk.jfr.consumer.EventStream;\n+import jdk.test.lib.Asserts;\n+\n+\/**\n+ * @test\n+ * @summary Test that it is possible to start a stream against a directory,\n+ *          specified on command line, where multiple processes starts\n+ *          simultaneously\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @build jdk.jfr.api.consumer.streaming.Application\n+ * @run main\/othervm jdk.jfr.api.consumer.streaming.TestBaseRepositoryMultipleProcesses\n+ *\/\n+public class TestBaseRepositoryMultipleProcesses {\n+    public static void main(String... args) throws Exception {\n+        AtomicBoolean success = new AtomicBoolean();\n+        Path repository = Path.of(\"multiple\");\n+        Application app1 = new Application(repository);\n+        Application app2 = new Application(repository);\n+        Application app3 = new Application(repository);\n+        app1.start();\n+        app2.start();\n+        app3.start();\n+        try (EventStream es = EventStream.openRepository(repository)) {\n+            es.onEvent(e -> {\n+                success.set(true);\n+                es.close();\n+            });\n+            es.start();\n+        }\n+        app1.stop();\n+        app2.stop();\n+        app3.stop();\n+        Asserts.assertTrue(success.get(), \"Unable to stream when there are multiple processes\");\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/api\/consumer\/streaming\/TestBaseRepositoryMultipleProcesses.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"}]}