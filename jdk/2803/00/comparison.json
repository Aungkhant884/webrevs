{"files":[{"patch":"@@ -584,3 +584,0 @@\n-\n-        \/\/ now get the current position to calculate length\n-        long dumpEnd = fos.getChannel().position();\n@@ -588,0 +585,1 @@\n+        long currentRecordLength = 0;\n@@ -589,10 +587,14 @@\n-        \/\/ calculate the length of heap data\n-        \/\/ only process when segmented heap dump is not used, since SegmentedOutputStream\n-        \/\/ could create segment automatically.\n-        long currentRecordLength = (dumpEnd - currentSegmentStart - 4L);\n-        if ((!useSegmentedHeapDump) && currentRecordLength > 0 &&\n-            (currentRecordLength + headerSize + originalLengthInBytes) > MAX_U4_VALUE) {\n-            fillInHeapRecordLength();\n-            currentSegmentStart = 0;\n-            writeHeapRecordPrologue();\n-            currentRecordLength = 0;\n+        \/\/ There is an U4 slot contains the data size written in the dump file.\n+        \/\/ Need to trunicate the array length if the size exceed the MAX_U4_VALUE.\n+        if (!useSegmentedHeapDump) {\n+            \/\/ now get the current position to calculate length\n+            long dumpEnd = fos.getChannel().position();\n+            \/\/ calculate the length of heap data\n+            currentRecordLength = (dumpEnd - currentSegmentStart - 4L);\n+            if (currentRecordLength > 0 &&\n+                (currentRecordLength + headerSize + originalLengthInBytes) > MAX_U4_VALUE) {\n+                fillInHeapRecordLength();\n+                currentSegmentStart = 0;\n+                writeHeapRecordPrologue();\n+                currentRecordLength = 0;\n+            }\n@@ -600,1 +602,0 @@\n-\n@@ -610,0 +611,9 @@\n+\n+        \/\/ Now the total size of data to dump is known and can be filled to segment header.\n+        \/\/ Enable write-through mode to avoid internal buffer copies.\n+        if (useSegmentedHeapDump) {\n+            long longBytes = length * typeSize + headerSize;\n+            int bytesToWrite = (int) (longBytes);\n+            hprofBufferedOut.fillSegmentSizeAndEnableWriteThrough(bytesToWrite);\n+        }\n+\n@@ -1335,0 +1345,1 @@\n+            writeThrough = false;\n@@ -1357,1 +1368,1 @@\n-           if (segmentMode) {\n+           if (segmentMode && !writeThrough) {\n@@ -1385,1 +1396,1 @@\n-            if (segmentMode) {\n+            if (segmentMode && !writeThrough) {\n@@ -1412,1 +1423,1 @@\n-            if (segmentMode) {\n+            if (segmentMode && !writeThrough) {\n@@ -1453,0 +1464,1 @@\n+                writeThrough = false;\n@@ -1461,0 +1473,5 @@\n+            if (writeThrough) {\n+                \/\/ no data in internal buffer.\n+                assert segmentWritten == 0;\n+                writeThrough = false;\n+            }\n@@ -1468,0 +1485,17 @@\n+        \/**\n+         * Fill segment size and enable write through mode\n+         * @param    size    size of data to be written\n+         *\/\n+        public void fillSegmentSizeAndEnableWriteThrough(int size) throws IOException {\n+            assert segmentMode == true;\n+            assert writeThrough == false;\n+            if (segmentWritten != 0) {\n+                \/\/ flush previous written data and clear the internal buffer.\n+                flush();\n+            }\n+            \/\/ buffer must be empty now.\n+            assert (segmentMode && (segmentWritten == 0) && (writeThrough == false)) : \"Wrong Status\";\n+            \/\/ enable write through so the internal buffer is clean to reuse.\n+            writeThrough = true;\n+            writeSegmentHeader(size);\n+        }\n@@ -1477,0 +1511,2 @@\n+            \/\/ write through mode always flush data.\n+            if (writeThrough) return true;\n@@ -1482,1 +1518,1 @@\n-         * Writes the write segment header into internal buffer.\n+         * Writes the segment header with given data size.\n@@ -1484,5 +1520,8 @@\n-        private void writeSegmentHeader() {\n-            assert segmentWritten == 0;\n-            segmentBuffer[segmentWritten++] = (byte)HPROF_HEAP_DUMP_SEGMENT;\n-            writeInteger(0);\n-            \/\/ segment size, write dummy length of 0 and we'll fix it later.\n+        private void writeSegmentHeader(int size) throws IOException {\n+            assert segmentWritten == 0 : \"initializing non empty segment\";\n+            byte flag = (byte)HPROF_HEAP_DUMP_SEGMENT;\n+            if (writeThrough) {\n+                super.write(flag);\n+            } else {\n+                segmentBuffer[segmentWritten++] = flag;\n+            }\n@@ -1490,0 +1529,8 @@\n+            writeInteger(size);\n+        }\n+\n+        \/**\n+         * Writes the write segment header with dummy length of 0.\n+         *\/\n+        private void writeSegmentHeader() throws IOException {\n+            writeSegmentHeader(0);\n@@ -1496,0 +1543,2 @@\n+            \/\/ write through mode has assumption that data size is already filled in header.\n+            assert !writeThrough;\n@@ -1504,1 +1553,1 @@\n-        private final void writeInteger(int value) {\n+        private final void writeInteger(int value) throws IOException {\n@@ -1506,2 +1555,6 @@\n-            System.arraycopy(intBytes, 0, segmentBuffer, segmentWritten, 4);\n-            segmentWritten += 4;\n+            if (!writeThrough) {\n+                System.arraycopy(intBytes, 0, segmentBuffer, segmentWritten, 4);\n+                segmentWritten += 4;\n+            } else {\n+                super.write(intBytes, 0, 4);\n+            }\n@@ -1525,0 +1578,2 @@\n+        \/\/ Write data directly to underlying stream, don't use internal buffer.\n+        private boolean writeThrough;\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/utilities\/HeapHprofBinWriter.java","additions":81,"deletions":26,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -96,1 +96,0 @@\n-resourcehogs\/serviceability\/sa\/TestHeapDumpForLargeArray.java 8262386 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}