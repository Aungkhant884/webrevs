{"files":[{"patch":"@@ -1347,2 +1347,4 @@\n-            segmentBuffer = new byte[SEGMENT_BUFFER_SIZE];\n-            segmentWritten = 0;\n+            currentBuffer = new byte[SEGMENT_BUFFER_SIZE];\n+            bufferList = new ArrayList<byte[]>();\n+            bufferWritten = 0;\n+            listWritten = 0;\n@@ -1369,1 +1371,1 @@\n-               if (segmentWritten == 0) {\n+               if (isEmpty()) {\n@@ -1372,6 +1374,7 @@\n-               } else if (segmentWritten == segmentBuffer.length) {\n-                   \/\/ Internal buffer is full, extend a larger one.\n-                   int newSize = segmentBuffer.length + SEGMENT_BUFFER_INC_SIZE;\n-                   byte newBuf[] = new byte[newSize];\n-                   System.arraycopy(segmentBuffer, 0, newBuf, 0, segmentWritten);\n-                   segmentBuffer = newBuf;\n+               } else if (bufferWritten == currentBuffer.length) {\n+                   \/\/ Internal buffer is full, generate a new one.\n+                   bufferList.add(currentBuffer);\n+                   listWritten += currentBuffer.length;\n+                   byte newBuf[] = new byte[SEGMENT_BUFFER_SIZE];\n+                   currentBuffer = newBuf;\n+                   bufferWritten = 0;\n@@ -1379,1 +1382,1 @@\n-               segmentBuffer[segmentWritten++] = (byte)b;\n+               currentBuffer[bufferWritten++] = (byte)b;\n@@ -1397,1 +1400,1 @@\n-                if (segmentWritten == 0) {\n+                if (isEmpty()) {\n@@ -1401,2 +1404,11 @@\n-                if (segmentWritten + len > segmentBuffer.length) {\n-                    int newSize = segmentBuffer.length + Math.max(SEGMENT_BUFFER_INC_SIZE, len);\n+                int remain = len;\n+                if (remain > currentBuffer.length - bufferWritten) {\n+                    \/\/ fill current buffer.\n+                    int toWrite = currentBuffer.length - bufferWritten;\n+                    System.arraycopy(b, 0, currentBuffer, bufferWritten, toWrite);\n+                    \/\/ current buffer is full, fill into list.\n+                    bufferList.add(currentBuffer);\n+                    listWritten += currentBuffer.length;\n+                    \/\/ generate new current buffer and fill with remain data.\n+                    remain -= toWrite;\n+                    int newSize = Math.max(SEGMENT_BUFFER_SIZE, remain);\n@@ -1404,2 +1416,2 @@\n-                    System.arraycopy(segmentBuffer, 0, newBuf, 0, segmentWritten);\n-                    segmentBuffer = newBuf;\n+                    currentBuffer = newBuf;\n+                    bufferWritten = 0;\n@@ -1407,2 +1419,2 @@\n-                System.arraycopy(b, off, segmentBuffer, segmentWritten, len);\n-                segmentWritten += len;\n+                System.arraycopy(b, off, currentBuffer, bufferWritten, remain);\n+                bufferWritten += remain;\n@@ -1424,0 +1436,1 @@\n+                long totalWritten = listWritten + bufferWritten;\n@@ -1425,1 +1438,1 @@\n-                if (segmentWritten == 0) return;\n+                if (totalWritten == 0) return;\n@@ -1427,1 +1440,1 @@\n-                assert segmentWritten > SEGMENT_HEADER_SIZE\n+                assert totalWritten > SEGMENT_HEADER_SIZE\n@@ -1430,1 +1443,1 @@\n-                if (segmentWritten > (segmentBuffer.length)) {\n+                if (totalWritten - SEGMENT_HEADER_SIZE >= (4L * 0x40000000)) {\n@@ -1434,3 +1447,14 @@\n-                if (segmentWritten > SEGMENT_HEADER_SIZE) {\n-                    fillSegmentSize(segmentWritten - SEGMENT_HEADER_SIZE);\n-                    super.write(segmentBuffer, 0, segmentWritten);\n+                if (totalWritten > SEGMENT_HEADER_SIZE) {\n+                    fillSegmentSize((int)(totalWritten - SEGMENT_HEADER_SIZE));\n+                    \/\/ Write buffer list.\n+                    if (bufferList.size() > 0) {\n+                        assert bufferWritten > 0;\n+                        for (byte[] bufferToWrite : bufferList) {\n+                            int lengthToWrite = bufferToWrite.length;\n+                            super.write(bufferToWrite, 0, lengthToWrite);\n+                        }\n+                        bufferList.clear();\n+                    }\n+                    assert bufferList.isEmpty();\n+                    \/\/ Write current buffer.\n+                    super.write(currentBuffer, 0, bufferWritten);\n@@ -1438,1 +1462,2 @@\n-                    segmentWritten = 0;\n+                    bufferWritten = 0;\n+                    listWritten = 0;\n@@ -1449,1 +1474,1 @@\n-            if (allowSegmented && !segmentMode && segmentWritten == 0) {\n+            if (allowSegmented && !segmentMode && isEmpty()) {\n@@ -1452,1 +1477,1 @@\n-                segmentWritten = 0;\n+                bufferWritten = 0;\n@@ -1462,1 +1487,1 @@\n-                assert segmentWritten == 0;\n+                assert isEmpty();\n@@ -1475,1 +1500,1 @@\n-                assert segmentWritten == 0;\n+                assert isEmpty();\n@@ -1480,1 +1505,1 @@\n-                assert segmentWritten == 0;\n+                assert isEmpty();\n@@ -1492,2 +1517,2 @@\n-            if (segmentWritten != 0) {\n-                \/\/ flush previous written data and clear the internal buffer.\n+            long totalWritten = bufferWritten + listWritten;\n+            if (totalWritten != 0) {\n@@ -1496,3 +1521,3 @@\n-            \/\/ buffer must be empty now.\n-            assert (segmentMode && (segmentWritten == 0) && (writeThrough == false)) : \"Wrong Status\";\n-            \/\/ enable write through so the internal buffer is clean to reuse.\n+            \/\/ buffer must be empty\n+            assert (segmentMode && (bufferWritten + listWritten == 0) && (writeThrough == false)) : \"Wrong Status\";\n+            \/\/ enable write through so the internal buffer is clean to reuse\n@@ -1504,2 +1529,1 @@\n-         * Check whether the data should be flush based on data saved in\n-         * segmentBuffer.\n+         * Check whether the data should be flush based on total bytes saved\n@@ -1514,1 +1538,1 @@\n-            return segmentWritten > SEGMENT_BUFFER_SIZE;\n+            return bufferWritten + listWritten > SEGMENT_BUFFER_SIZE;\n@@ -1521,1 +1545,1 @@\n-            assert segmentWritten == 0 : \"initializing non empty segment\";\n+            assert (isEmpty()) : \"initializing non empty segment\";\n@@ -1526,1 +1550,1 @@\n-                segmentBuffer[segmentWritten++] = flag;\n+                currentBuffer[bufferWritten++] = flag;\n@@ -1546,1 +1570,9 @@\n-            System.arraycopy(lenBytes, 0, segmentBuffer, 5, 4);\n+            \/\/ find the first Buffer - buffer that contains header\n+            \/\/ if bufferList is empty, it is currentBuffer,\n+            \/\/ otherwise it is bufferList[0];\n+            byte[] firstBuffer = currentBuffer;\n+            if (bufferList.size() > 0) {\n+                firstBuffer = bufferList.get(0);\n+            }\n+            assert (firstBuffer.length > SEGMENT_HEADER_SIZE) && (firstBuffer[0] == (byte)HPROF_HEAP_DUMP_SEGMENT): \"the buffer does not contains segment header\";\n+            System.arraycopy(lenBytes, 0, firstBuffer, 5, 4);\n@@ -1550,1 +1582,1 @@\n-         * Writes an {@code int} to the internal segment buffer\n+         * Writes an {@code int} to the internal buffer.\n@@ -1556,2 +1588,2 @@\n-                System.arraycopy(intBytes, 0, segmentBuffer, segmentWritten, 4);\n-                segmentWritten += 4;\n+                System.arraycopy(intBytes, 0, currentBuffer, bufferWritten, 4);\n+                bufferWritten += 4;\n@@ -1563,1 +1595,11 @@\n-        \/\/ The buffer size for segmentBuffer.\n+        \/*\n+         * Whether the internal buffer and list are empty\n+         *\/\n+        private final boolean isEmpty() {\n+            if (listWritten == 0) {\n+                assert bufferList.isEmpty() : \"buffer list is not empty\" + bufferList.size();\n+            }\n+            return (listWritten == 0 && bufferWritten == 0);\n+        }\n+\n+        \/\/ The buffer size for currentBuffer.\n@@ -1568,2 +1610,0 @@\n-        \/\/ Buffer size used to extend the segment buffer.\n-        private static final int SEGMENT_BUFFER_INC_SIZE = 1 << 10;\n@@ -1580,2 +1620,9 @@\n-        private byte segmentBuffer[];\n-        private int segmentWritten;\n+        private byte currentBuffer[];\n+        \/\/ Size of data written in current buffer.\n+        private int bufferWritten;\n+        \/\/ Total size of written data in buffer list, exclude the current buffer.\n+        \/\/ This value could be larger than MAX_U4_VALUE hence there is segment header.\n+        \/\/ Note that it can not exceed MAX_U4_VALUE + SEGMENT_HEADER_SIZE.\n+        private long listWritten;\n+        \/\/ List holding all currentBuffer that not flush.\n+        private ArrayList<byte[]> bufferList;\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/utilities\/HeapHprofBinWriter.java","additions":95,"deletions":48,"binary":false,"changes":143,"status":"modified"}]}