{"files":[{"patch":"@@ -584,3 +584,0 @@\n-\n-        \/\/ now get the current position to calculate length\n-        long dumpEnd = fos.getChannel().position();\n@@ -588,0 +585,1 @@\n+        long currentRecordLength = 0;\n@@ -589,10 +587,14 @@\n-        \/\/ calculate the length of heap data\n-        \/\/ only process when segmented heap dump is not used, since SegmentedOutputStream\n-        \/\/ could create segment automatically.\n-        long currentRecordLength = (dumpEnd - currentSegmentStart - 4L);\n-        if ((!useSegmentedHeapDump) && currentRecordLength > 0 &&\n-            (currentRecordLength + headerSize + originalLengthInBytes) > MAX_U4_VALUE) {\n-            fillInHeapRecordLength();\n-            currentSegmentStart = 0;\n-            writeHeapRecordPrologue();\n-            currentRecordLength = 0;\n+        \/\/ There is an U4 slot contains the data size written in the dump file.\n+        \/\/ Need to trunicate the array length if the size exceed the MAX_U4_VALUE.\n+        if (!useSegmentedHeapDump) {\n+            \/\/ now get the current position to calculate length\n+            long dumpEnd = fos.getChannel().position();\n+            \/\/ calculate the length of heap data\n+            currentRecordLength = (dumpEnd - currentSegmentStart - 4L);\n+            if (currentRecordLength > 0 &&\n+                (currentRecordLength + headerSize + originalLengthInBytes) > MAX_U4_VALUE) {\n+                fillInHeapRecordLength();\n+                currentSegmentStart = 0;\n+                writeHeapRecordPrologue();\n+                currentRecordLength = 0;\n+            }\n@@ -600,1 +602,0 @@\n-\n@@ -610,0 +611,9 @@\n+\n+        \/\/ Now the total size of data to dump is known and can be filled to segment header.\n+        \/\/ Enable write-through mode to avoid internal buffer copies.\n+        if (useSegmentedHeapDump) {\n+            long longBytes = length * typeSize + headerSize;\n+            int bytesToWrite = (int) (longBytes);\n+            hprofBufferedOut.fillSegmentSizeAndEnableWriteThrough(bytesToWrite);\n+        }\n+\n@@ -1335,0 +1345,1 @@\n+            writeThrough = false;\n@@ -1336,2 +1347,4 @@\n-            segmentBuffer = new byte[SEGMENT_BUFFER_SIZE];\n-            segmentWritten = 0;\n+            currentBuffer = new byte[SEGMENT_BUFFER_SIZE];\n+            bufferList = new ArrayList<byte[]>();\n+            bufferWritten = 0;\n+            listWritten = 0;\n@@ -1357,2 +1370,2 @@\n-           if (segmentMode) {\n-               if (segmentWritten == 0) {\n+           if (segmentMode && !writeThrough) {\n+               if (isEmpty()) {\n@@ -1361,6 +1374,7 @@\n-               } else if (segmentWritten == segmentBuffer.length) {\n-                   \/\/ Internal buffer is full, extend a larger one.\n-                   int newSize = segmentBuffer.length + SEGMENT_BUFFER_INC_SIZE;\n-                   byte newBuf[] = new byte[newSize];\n-                   System.arraycopy(segmentBuffer, 0, newBuf, 0, segmentWritten);\n-                   segmentBuffer = newBuf;\n+               } else if (bufferWritten == currentBuffer.length) {\n+                   \/\/ Internal buffer is full, generate a new one.\n+                   bufferList.add(currentBuffer);\n+                   listWritten += currentBuffer.length;\n+                   byte newBuf[] = new byte[SEGMENT_BUFFER_SIZE];\n+                   currentBuffer = newBuf;\n+                   bufferWritten = 0;\n@@ -1368,1 +1382,1 @@\n-               segmentBuffer[segmentWritten++] = (byte)b;\n+               currentBuffer[bufferWritten++] = (byte)b;\n@@ -1385,2 +1399,2 @@\n-            if (segmentMode) {\n-                if (segmentWritten == 0) {\n+            if (segmentMode && !writeThrough) {\n+                if (isEmpty()) {\n@@ -1390,2 +1404,11 @@\n-                if (segmentWritten + len > segmentBuffer.length) {\n-                    int newSize = segmentBuffer.length + Math.max(SEGMENT_BUFFER_INC_SIZE, len);\n+                int remain = len;\n+                if (remain > currentBuffer.length - bufferWritten) {\n+                    \/\/ fill current buffer.\n+                    int toWrite = currentBuffer.length - bufferWritten;\n+                    System.arraycopy(b, 0, currentBuffer, bufferWritten, toWrite);\n+                    \/\/ current buffer is full, fill into list.\n+                    bufferList.add(currentBuffer);\n+                    listWritten += currentBuffer.length;\n+                    \/\/ generate new current buffer and fill with remain data.\n+                    remain -= toWrite;\n+                    int newSize = Math.max(SEGMENT_BUFFER_SIZE, remain);\n@@ -1393,2 +1416,2 @@\n-                    System.arraycopy(segmentBuffer, 0, newBuf, 0, segmentWritten);\n-                    segmentBuffer = newBuf;\n+                    currentBuffer = newBuf;\n+                    bufferWritten = 0;\n@@ -1396,2 +1419,2 @@\n-                System.arraycopy(b, off, segmentBuffer, segmentWritten, len);\n-                segmentWritten += len;\n+                System.arraycopy(b, off, currentBuffer, bufferWritten, remain);\n+                bufferWritten += remain;\n@@ -1412,1 +1435,2 @@\n-            if (segmentMode) {\n+            if (segmentMode && !writeThrough) {\n+                long totalWritten = listWritten + bufferWritten;\n@@ -1414,1 +1438,1 @@\n-                if (segmentWritten == 0) return;\n+                if (totalWritten == 0) return;\n@@ -1416,1 +1440,1 @@\n-                assert segmentWritten > SEGMENT_HEADER_SIZE\n+                assert totalWritten > SEGMENT_HEADER_SIZE\n@@ -1419,1 +1443,1 @@\n-                if (segmentWritten > (segmentBuffer.length)) {\n+                if (totalWritten - SEGMENT_HEADER_SIZE >= (4L * 0x40000000)) {\n@@ -1423,3 +1447,14 @@\n-                if (segmentWritten > SEGMENT_HEADER_SIZE) {\n-                    fillSegmentSize(segmentWritten - SEGMENT_HEADER_SIZE);\n-                    super.write(segmentBuffer, 0, segmentWritten);\n+                if (totalWritten > SEGMENT_HEADER_SIZE) {\n+                    fillSegmentSize((int)(totalWritten - SEGMENT_HEADER_SIZE));\n+                    \/\/ Write buffer list.\n+                    if (bufferList.size() > 0) {\n+                        assert bufferWritten > 0;\n+                        for (byte[] bufferToWrite : bufferList) {\n+                            int lengthToWrite = bufferToWrite.length;\n+                            super.write(bufferToWrite, 0, lengthToWrite);\n+                        }\n+                        bufferList.clear();\n+                    }\n+                    assert bufferList.isEmpty();\n+                    \/\/ Write current buffer.\n+                    super.write(currentBuffer, 0, bufferWritten);\n@@ -1427,1 +1462,2 @@\n-                    segmentWritten = 0;\n+                    bufferWritten = 0;\n+                    listWritten = 0;\n@@ -1438,1 +1474,1 @@\n-            if (allowSegmented && !segmentMode && segmentWritten == 0) {\n+            if (allowSegmented && !segmentMode && isEmpty()) {\n@@ -1441,1 +1477,1 @@\n-                segmentWritten = 0;\n+                bufferWritten = 0;\n@@ -1451,1 +1487,1 @@\n-                assert segmentWritten == 0;\n+                assert isEmpty();\n@@ -1453,0 +1489,1 @@\n+                writeThrough = false;\n@@ -1461,0 +1498,5 @@\n+            if (writeThrough) {\n+                \/\/ no data in internal buffer.\n+                assert isEmpty();\n+                writeThrough = false;\n+            }\n@@ -1463,1 +1505,1 @@\n-                assert segmentWritten == 0;\n+                assert isEmpty();\n@@ -1468,0 +1510,17 @@\n+        \/**\n+         * Fill segment size and enable write through mode\n+         * @param    size    size of data to be written\n+         *\/\n+        public void fillSegmentSizeAndEnableWriteThrough(int size) throws IOException {\n+            assert segmentMode == true;\n+            assert writeThrough == false;\n+            long totalWritten = bufferWritten + listWritten;\n+            if (totalWritten != 0) {\n+                flush();\n+            }\n+            \/\/ buffer must be empty\n+            assert (segmentMode && (bufferWritten + listWritten == 0) && (writeThrough == false)) : \"Wrong Status\";\n+            \/\/ enable write through so the internal buffer is clean to reuse\n+            writeThrough = true;\n+            writeSegmentHeader(size);\n+        }\n@@ -1470,2 +1529,1 @@\n-         * Check whether the data should be flush based on data saved in\n-         * segmentBuffer.\n+         * Check whether the data should be flush based on total bytes saved\n@@ -1477,0 +1535,2 @@\n+            \/\/ write through mode always flush data.\n+            if (writeThrough) return true;\n@@ -1478,1 +1538,1 @@\n-            return segmentWritten > SEGMENT_BUFFER_SIZE;\n+            return bufferWritten + listWritten > SEGMENT_BUFFER_SIZE;\n@@ -1482,1 +1542,1 @@\n-         * Writes the write segment header into internal buffer.\n+         * Writes the segment header with given data size.\n@@ -1484,5 +1544,8 @@\n-        private void writeSegmentHeader() {\n-            assert segmentWritten == 0;\n-            segmentBuffer[segmentWritten++] = (byte)HPROF_HEAP_DUMP_SEGMENT;\n-            writeInteger(0);\n-            \/\/ segment size, write dummy length of 0 and we'll fix it later.\n+        private void writeSegmentHeader(int size) throws IOException {\n+            assert (isEmpty()) : \"initializing non empty segment\";\n+            byte flag = (byte)HPROF_HEAP_DUMP_SEGMENT;\n+            if (writeThrough) {\n+                super.write(flag);\n+            } else {\n+                currentBuffer[bufferWritten++] = flag;\n+            }\n@@ -1490,0 +1553,8 @@\n+            writeInteger(size);\n+        }\n+\n+        \/**\n+         * Writes the write segment header with dummy length of 0.\n+         *\/\n+        private void writeSegmentHeader() throws IOException {\n+            writeSegmentHeader(0);\n@@ -1496,0 +1567,2 @@\n+            \/\/ write through mode has assumption that data size is already filled in header.\n+            assert !writeThrough;\n@@ -1497,1 +1570,9 @@\n-            System.arraycopy(lenBytes, 0, segmentBuffer, 5, 4);\n+            \/\/ find the first Buffer - buffer that contains header\n+            \/\/ if bufferList is empty, it is currentBuffer,\n+            \/\/ otherwise it is bufferList[0];\n+            byte[] firstBuffer = currentBuffer;\n+            if (bufferList.size() > 0) {\n+                firstBuffer = bufferList.get(0);\n+            }\n+            assert (firstBuffer.length > SEGMENT_HEADER_SIZE) && (firstBuffer[0] == (byte)HPROF_HEAP_DUMP_SEGMENT): \"the buffer does not contains segment header\";\n+            System.arraycopy(lenBytes, 0, firstBuffer, 5, 4);\n@@ -1501,1 +1582,1 @@\n-         * Writes an {@code int} to the internal segment buffer\n+         * Writes an {@code int} to the internal buffer.\n@@ -1504,1 +1585,1 @@\n-        private final void writeInteger(int value) {\n+        private final void writeInteger(int value) throws IOException {\n@@ -1506,2 +1587,16 @@\n-            System.arraycopy(intBytes, 0, segmentBuffer, segmentWritten, 4);\n-            segmentWritten += 4;\n+            if (!writeThrough) {\n+                System.arraycopy(intBytes, 0, currentBuffer, bufferWritten, 4);\n+                bufferWritten += 4;\n+            } else {\n+                super.write(intBytes, 0, 4);\n+            }\n+        }\n+\n+        \/*\n+         * Whether the internal buffer and list are empty\n+         *\/\n+        private final boolean isEmpty() {\n+            if (listWritten == 0) {\n+                assert bufferList.isEmpty() : \"buffer list is not empty\" + bufferList.size();\n+            }\n+            return (listWritten == 0 && bufferWritten == 0);\n@@ -1510,1 +1605,1 @@\n-        \/\/ The buffer size for segmentBuffer.\n+        \/\/ The buffer size for currentBuffer.\n@@ -1515,2 +1610,0 @@\n-        \/\/ Buffer size used to extend the segment buffer.\n-        private static final int SEGMENT_BUFFER_INC_SIZE = 1 << 10;\n@@ -1525,2 +1618,11 @@\n-        private byte segmentBuffer[];\n-        private int segmentWritten;\n+        \/\/ Write data directly to underlying stream, don't use internal buffer.\n+        private boolean writeThrough;\n+        private byte currentBuffer[];\n+        \/\/ Size of data written in current buffer.\n+        private int bufferWritten;\n+        \/\/ Total size of written data in buffer list, exclude the current buffer.\n+        \/\/ This value could be larger than MAX_U4_VALUE hence there is segment header.\n+        \/\/ Note that it can not exceed MAX_U4_VALUE + SEGMENT_HEADER_SIZE.\n+        private long listWritten;\n+        \/\/ List holding all currentBuffer that not flush.\n+        private ArrayList<byte[]> bufferList;\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/utilities\/HeapHprofBinWriter.java","additions":166,"deletions":64,"binary":false,"changes":230,"status":"modified"},{"patch":"@@ -96,1 +96,0 @@\n-resourcehogs\/serviceability\/sa\/TestHeapDumpForLargeArray.java 8262386 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}