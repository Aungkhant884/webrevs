{"files":[{"patch":"@@ -584,3 +584,0 @@\n-\n-        \/\/ now get the current position to calculate length\n-        long dumpEnd = fos.getChannel().position();\n@@ -588,0 +585,1 @@\n+        long currentRecordLength = 0;\n@@ -589,10 +587,14 @@\n-        \/\/ calculate the length of heap data\n-        \/\/ only process when segmented heap dump is not used, since SegmentedOutputStream\n-        \/\/ could create segment automatically.\n-        long currentRecordLength = (dumpEnd - currentSegmentStart - 4L);\n-        if ((!useSegmentedHeapDump) && currentRecordLength > 0 &&\n-            (currentRecordLength + headerSize + originalLengthInBytes) > MAX_U4_VALUE) {\n-            fillInHeapRecordLength();\n-            currentSegmentStart = 0;\n-            writeHeapRecordPrologue();\n-            currentRecordLength = 0;\n+        \/\/ There is an U4 slot that contains the data size written in the dump file.\n+        \/\/ Need to truncate the array length if the size exceeds the MAX_U4_VALUE.\n+        if (!useSegmentedHeapDump) {\n+            \/\/ now get the current position to calculate length\n+            long dumpEnd = fos.getChannel().position();\n+            \/\/ calculate the length of heap data\n+            currentRecordLength = (dumpEnd - currentSegmentStart - 4L);\n+            if (currentRecordLength > 0 &&\n+                (currentRecordLength + headerSize + originalLengthInBytes) > MAX_U4_VALUE) {\n+                fillInHeapRecordLength();\n+                currentSegmentStart = 0;\n+                writeHeapRecordPrologue();\n+                currentRecordLength = 0;\n+            }\n@@ -600,1 +602,0 @@\n-\n@@ -610,0 +611,8 @@\n+\n+        \/\/ Now the total size of data to dump is known and can be filled to segment header.\n+        \/\/ Enable unbuffered mode to avoid memory consumption and internal buffer copies.\n+        if (useSegmentedHeapDump) {\n+            int size = (int) (length * typeSize + headerSize);\n+            hprofBufferedOut.fillSegmentSizeAndEnableUnbufferedMode(size);\n+        }\n+\n@@ -1335,0 +1344,1 @@\n+            unbufferedMode = false;\n@@ -1357,1 +1367,1 @@\n-           if (segmentMode) {\n+           if (segmentMode && !unbufferedMode) {\n@@ -1385,1 +1395,1 @@\n-            if (segmentMode) {\n+            if (segmentMode && !unbufferedMode) {\n@@ -1412,1 +1422,1 @@\n-            if (segmentMode) {\n+            if (segmentMode && !unbufferedMode) {\n@@ -1453,0 +1463,1 @@\n+                unbufferedMode = false;\n@@ -1461,0 +1472,5 @@\n+            if (unbufferedMode) {\n+                \/\/ no data in internal buffer.\n+                assert segmentWritten == 0;\n+                unbufferedMode = false;\n+            }\n@@ -1468,0 +1484,17 @@\n+        \/**\n+         * Fill segment size and enable unbuffered mode\n+         * @param    size    size of data to be written\n+         *\/\n+        public void fillSegmentSizeAndEnableUnbufferedMode(int size) throws IOException {\n+            assert segmentMode == true;\n+            assert unbufferedMode == false;\n+            if (segmentWritten != 0) {\n+                \/\/ flush previous written data and clear the internal buffer.\n+                flush();\n+            }\n+            \/\/ buffer must be empty now.\n+            assert (segmentMode && (segmentWritten == 0) && (unbufferedMode == false)) : \"Wrong Status\";\n+            \/\/ enable unbuffered mode.\n+            unbufferedMode = true;\n+            writeSegmentHeader(size);\n+        }\n@@ -1477,0 +1510,2 @@\n+            \/\/ unbuffered mode always flush data.\n+            if (unbufferedMode) return true;\n@@ -1482,1 +1517,1 @@\n-         * Writes the write segment header into internal buffer.\n+         * Writes the segment header with given data size.\n@@ -1484,5 +1519,8 @@\n-        private void writeSegmentHeader() {\n-            assert segmentWritten == 0;\n-            segmentBuffer[segmentWritten++] = (byte)HPROF_HEAP_DUMP_SEGMENT;\n-            writeInteger(0);\n-            \/\/ segment size, write dummy length of 0 and we'll fix it later.\n+        private void writeSegmentHeader(int size) throws IOException {\n+            assert segmentWritten == 0 : \"initializing non empty segment\";\n+            byte flag = (byte)HPROF_HEAP_DUMP_SEGMENT;\n+            if (unbufferedMode) {\n+                super.write(flag);\n+            } else {\n+                segmentBuffer[segmentWritten++] = flag;\n+            }\n@@ -1490,0 +1528,8 @@\n+            writeInteger(size);\n+        }\n+\n+        \/**\n+         * Writes the write segment header with dummy length of 0.\n+         *\/\n+        private void writeSegmentHeader() throws IOException {\n+            writeSegmentHeader(0);\n@@ -1496,0 +1542,2 @@\n+            \/\/ unbuffered mode has assumption that data size is already filled in header.\n+            assert !unbufferedMode;\n@@ -1504,1 +1552,1 @@\n-        private final void writeInteger(int value) {\n+        private final void writeInteger(int value) throws IOException {\n@@ -1506,2 +1554,6 @@\n-            System.arraycopy(intBytes, 0, segmentBuffer, segmentWritten, 4);\n-            segmentWritten += 4;\n+            if (!unbufferedMode) {\n+                System.arraycopy(intBytes, 0, segmentBuffer, segmentWritten, 4);\n+                segmentWritten += 4;\n+            } else {\n+                super.write(intBytes, 0, 4);\n+            }\n@@ -1525,0 +1577,2 @@\n+        \/\/ Write data directly to underlying stream, don't use internal buffer.\n+        private boolean unbufferedMode;\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/utilities\/HeapHprofBinWriter.java","additions":80,"deletions":26,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -96,1 +96,0 @@\n-resourcehogs\/serviceability\/sa\/TestHeapDumpForLargeArray.java 8262386 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}