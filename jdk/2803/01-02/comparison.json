{"files":[{"patch":"@@ -1347,4 +1347,2 @@\n-            currentBuffer = new byte[SEGMENT_BUFFER_SIZE];\n-            bufferList = new ArrayList<byte[]>();\n-            bufferWritten = 0;\n-            listWritten = 0;\n+            segmentBuffer = new byte[SEGMENT_BUFFER_SIZE];\n+            segmentWritten = 0;\n@@ -1371,1 +1369,1 @@\n-               if (isEmpty()) {\n+               if (segmentWritten == 0) {\n@@ -1374,7 +1372,6 @@\n-               } else if (bufferWritten == currentBuffer.length) {\n-                   \/\/ Internal buffer is full, generate a new one.\n-                   bufferList.add(currentBuffer);\n-                   listWritten += currentBuffer.length;\n-                   byte newBuf[] = new byte[SEGMENT_BUFFER_SIZE];\n-                   currentBuffer = newBuf;\n-                   bufferWritten = 0;\n+               } else if (segmentWritten == segmentBuffer.length) {\n+                   \/\/ Internal buffer is full, extend a larger one.\n+                   int newSize = segmentBuffer.length + SEGMENT_BUFFER_INC_SIZE;\n+                   byte newBuf[] = new byte[newSize];\n+                   System.arraycopy(segmentBuffer, 0, newBuf, 0, segmentWritten);\n+                   segmentBuffer = newBuf;\n@@ -1382,1 +1379,1 @@\n-               currentBuffer[bufferWritten++] = (byte)b;\n+               segmentBuffer[segmentWritten++] = (byte)b;\n@@ -1400,1 +1397,1 @@\n-                if (isEmpty()) {\n+                if (segmentWritten == 0) {\n@@ -1404,11 +1401,2 @@\n-                int remain = len;\n-                if (remain > currentBuffer.length - bufferWritten) {\n-                    \/\/ fill current buffer.\n-                    int toWrite = currentBuffer.length - bufferWritten;\n-                    System.arraycopy(b, 0, currentBuffer, bufferWritten, toWrite);\n-                    \/\/ current buffer is full, fill into list.\n-                    bufferList.add(currentBuffer);\n-                    listWritten += currentBuffer.length;\n-                    \/\/ generate new current buffer and fill with remain data.\n-                    remain -= toWrite;\n-                    int newSize = Math.max(SEGMENT_BUFFER_SIZE, remain);\n+                if (segmentWritten + len > segmentBuffer.length) {\n+                    int newSize = segmentBuffer.length + Math.max(SEGMENT_BUFFER_INC_SIZE, len);\n@@ -1416,2 +1404,2 @@\n-                    currentBuffer = newBuf;\n-                    bufferWritten = 0;\n+                    System.arraycopy(segmentBuffer, 0, newBuf, 0, segmentWritten);\n+                    segmentBuffer = newBuf;\n@@ -1419,2 +1407,2 @@\n-                System.arraycopy(b, off, currentBuffer, bufferWritten, remain);\n-                bufferWritten += remain;\n+                System.arraycopy(b, off, segmentBuffer, segmentWritten, len);\n+                segmentWritten += len;\n@@ -1436,1 +1424,0 @@\n-                long totalWritten = listWritten + bufferWritten;\n@@ -1438,1 +1425,1 @@\n-                if (totalWritten == 0) return;\n+                if (segmentWritten == 0) return;\n@@ -1440,1 +1427,1 @@\n-                assert totalWritten > SEGMENT_HEADER_SIZE\n+                assert segmentWritten > SEGMENT_HEADER_SIZE\n@@ -1443,1 +1430,1 @@\n-                if (totalWritten - SEGMENT_HEADER_SIZE >= (4L * 0x40000000)) {\n+                if (segmentWritten > (segmentBuffer.length)) {\n@@ -1447,14 +1434,3 @@\n-                if (totalWritten > SEGMENT_HEADER_SIZE) {\n-                    fillSegmentSize((int)(totalWritten - SEGMENT_HEADER_SIZE));\n-                    \/\/ Write buffer list.\n-                    if (bufferList.size() > 0) {\n-                        assert bufferWritten > 0;\n-                        for (byte[] bufferToWrite : bufferList) {\n-                            int lengthToWrite = bufferToWrite.length;\n-                            super.write(bufferToWrite, 0, lengthToWrite);\n-                        }\n-                        bufferList.clear();\n-                    }\n-                    assert bufferList.isEmpty();\n-                    \/\/ Write current buffer.\n-                    super.write(currentBuffer, 0, bufferWritten);\n+                if (segmentWritten > SEGMENT_HEADER_SIZE) {\n+                    fillSegmentSize(segmentWritten - SEGMENT_HEADER_SIZE);\n+                    super.write(segmentBuffer, 0, segmentWritten);\n@@ -1462,2 +1438,1 @@\n-                    bufferWritten = 0;\n-                    listWritten = 0;\n+                    segmentWritten = 0;\n@@ -1474,1 +1449,1 @@\n-            if (allowSegmented && !segmentMode && isEmpty()) {\n+            if (allowSegmented && !segmentMode && segmentWritten == 0) {\n@@ -1477,1 +1452,1 @@\n-                bufferWritten = 0;\n+                segmentWritten = 0;\n@@ -1487,1 +1462,1 @@\n-                assert isEmpty();\n+                assert segmentWritten == 0;\n@@ -1500,1 +1475,1 @@\n-                assert isEmpty();\n+                assert segmentWritten == 0;\n@@ -1505,1 +1480,1 @@\n-                assert isEmpty();\n+                assert segmentWritten == 0;\n@@ -1517,2 +1492,2 @@\n-            long totalWritten = bufferWritten + listWritten;\n-            if (totalWritten != 0) {\n+            if (segmentWritten != 0) {\n+                \/\/ flush previous written data and clear the internal buffer.\n@@ -1521,3 +1496,3 @@\n-            \/\/ buffer must be empty\n-            assert (segmentMode && (bufferWritten + listWritten == 0) && (writeThrough == false)) : \"Wrong Status\";\n-            \/\/ enable write through so the internal buffer is clean to reuse\n+            \/\/ buffer must be empty now.\n+            assert (segmentMode && (segmentWritten == 0) && (writeThrough == false)) : \"Wrong Status\";\n+            \/\/ enable write through so the internal buffer is clean to reuse.\n@@ -1529,1 +1504,2 @@\n-         * Check whether the data should be flush based on total bytes saved\n+         * Check whether the data should be flush based on data saved in\n+         * segmentBuffer.\n@@ -1538,1 +1514,1 @@\n-            return bufferWritten + listWritten > SEGMENT_BUFFER_SIZE;\n+            return segmentWritten > SEGMENT_BUFFER_SIZE;\n@@ -1545,1 +1521,1 @@\n-            assert (isEmpty()) : \"initializing non empty segment\";\n+            assert segmentWritten == 0 : \"initializing non empty segment\";\n@@ -1550,1 +1526,1 @@\n-                currentBuffer[bufferWritten++] = flag;\n+                segmentBuffer[segmentWritten++] = flag;\n@@ -1570,9 +1546,1 @@\n-            \/\/ find the first Buffer - buffer that contains header\n-            \/\/ if bufferList is empty, it is currentBuffer,\n-            \/\/ otherwise it is bufferList[0];\n-            byte[] firstBuffer = currentBuffer;\n-            if (bufferList.size() > 0) {\n-                firstBuffer = bufferList.get(0);\n-            }\n-            assert (firstBuffer.length > SEGMENT_HEADER_SIZE) && (firstBuffer[0] == (byte)HPROF_HEAP_DUMP_SEGMENT): \"the buffer does not contains segment header\";\n-            System.arraycopy(lenBytes, 0, firstBuffer, 5, 4);\n+            System.arraycopy(lenBytes, 0, segmentBuffer, 5, 4);\n@@ -1582,1 +1550,1 @@\n-         * Writes an {@code int} to the internal buffer.\n+         * Writes an {@code int} to the internal segment buffer\n@@ -1588,2 +1556,2 @@\n-                System.arraycopy(intBytes, 0, currentBuffer, bufferWritten, 4);\n-                bufferWritten += 4;\n+                System.arraycopy(intBytes, 0, segmentBuffer, segmentWritten, 4);\n+                segmentWritten += 4;\n@@ -1595,11 +1563,1 @@\n-        \/*\n-         * Whether the internal buffer and list are empty\n-         *\/\n-        private final boolean isEmpty() {\n-            if (listWritten == 0) {\n-                assert bufferList.isEmpty() : \"buffer list is not empty\" + bufferList.size();\n-            }\n-            return (listWritten == 0 && bufferWritten == 0);\n-        }\n-\n-        \/\/ The buffer size for currentBuffer.\n+        \/\/ The buffer size for segmentBuffer.\n@@ -1610,0 +1568,2 @@\n+        \/\/ Buffer size used to extend the segment buffer.\n+        private static final int SEGMENT_BUFFER_INC_SIZE = 1 << 10;\n@@ -1620,9 +1580,2 @@\n-        private byte currentBuffer[];\n-        \/\/ Size of data written in current buffer.\n-        private int bufferWritten;\n-        \/\/ Total size of written data in buffer list, exclude the current buffer.\n-        \/\/ This value could be larger than MAX_U4_VALUE hence there is segment header.\n-        \/\/ Note that it can not exceed MAX_U4_VALUE + SEGMENT_HEADER_SIZE.\n-        private long listWritten;\n-        \/\/ List holding all currentBuffer that not flush.\n-        private ArrayList<byte[]> bufferList;\n+        private byte segmentBuffer[];\n+        private int segmentWritten;\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/utilities\/HeapHprofBinWriter.java","additions":48,"deletions":95,"binary":false,"changes":143,"status":"modified"}]}