{"files":[{"patch":"@@ -813,3 +813,4 @@\n-void CompilerOracle::parse_from_line(char* line) {\n-  if (line[0] == '\\0') return;\n-  if (line[0] == '#')  return;\n+bool CompilerOracle::parse_from_line(char* line) {\n+  if ((line[0] == '\\0') || (line[0] == '#')) {\n+    return true;\n+  }\n@@ -827,1 +828,1 @@\n-    return;\n+    return false;\n@@ -832,1 +833,1 @@\n-    return;\n+    return true;\n@@ -837,1 +838,1 @@\n-    return;\n+    return true;\n@@ -859,1 +860,1 @@\n-      return;\n+      return false;\n@@ -876,1 +877,1 @@\n-          return;\n+          return false;\n@@ -885,1 +886,1 @@\n-          return;\n+          return false;\n@@ -893,1 +894,1 @@\n-          return;\n+          return false;\n@@ -912,1 +913,1 @@\n-      return;\n+      return false;\n@@ -919,1 +920,1 @@\n-        return;\n+        return true;\n@@ -923,1 +924,1 @@\n-        return;\n+        return false;\n@@ -929,1 +930,1 @@\n-      return;\n+      return false;\n@@ -933,0 +934,1 @@\n+  return true;\n@@ -951,1 +953,1 @@\n-void CompilerOracle::parse_from_file() {\n+bool CompilerOracle::parse_from_file() {\n@@ -954,1 +956,3 @@\n-  if (stream == nullptr) return;\n+  if (stream == nullptr) {\n+    return true;\n+  }\n@@ -959,0 +963,1 @@\n+  bool success = true;\n@@ -962,1 +967,3 @@\n-      parse_from_line(token);\n+      if (!parse_from_line(token)) {\n+        success = false;\n+      }\n@@ -970,2 +977,3 @@\n-  parse_from_line(token);\n-\n+  if (!parse_from_line(token)) {\n+    success = false;\n+  }\n@@ -973,0 +981,1 @@\n+  return success;\n@@ -975,1 +984,1 @@\n-void CompilerOracle::parse_from_string(const char* str, void (*parse_line)(char*)) {\n+bool CompilerOracle::parse_from_string(const char* str, bool (*parse_line)(char*)) {\n@@ -980,0 +989,1 @@\n+  bool success = true;\n@@ -983,1 +993,3 @@\n-      parse_line(token);\n+      if (!parse_line(token)) {\n+        success = false;\n+      }\n@@ -991,1 +1003,4 @@\n-  parse_line(token);\n+  if (!parse_line(token)) {\n+    success = false;\n+  }\n+  return success;\n@@ -994,3 +1009,8 @@\n-void compilerOracle_init() {\n-  CompilerOracle::parse_from_string(CompileCommand, CompilerOracle::parse_from_line);\n-  CompilerOracle::parse_from_string(CompileOnly, CompilerOracle::parse_compile_only);\n+bool compilerOracle_init() {\n+  bool success = true;\n+  if (!CompilerOracle::parse_from_string(CompileCommand, CompilerOracle::parse_from_line)) {\n+    success = false;\n+  }\n+  if (!CompilerOracle::parse_from_string(CompileOnly, CompilerOracle::parse_compile_only)) {\n+    success = false;\n+  }\n@@ -998,1 +1018,3 @@\n-    CompilerOracle::parse_from_file();\n+    if (!CompilerOracle::parse_from_file()) {\n+      success = false;\n+    }\n@@ -1012,0 +1034,1 @@\n+  return success;\n@@ -1014,1 +1037,1 @@\n-void CompilerOracle::parse_compile_only(char* line) {\n+bool CompilerOracle::parse_compile_only(char* line) {\n@@ -1041,2 +1064,3 @@\n-      if (newName == nullptr)\n-        return;\n+      if (newName == nullptr) {\n+        return false;\n+      }\n@@ -1098,0 +1122,1 @@\n+  return true;\n","filename":"src\/hotspot\/share\/compiler\/compilerOracle.cpp","additions":54,"deletions":29,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -127,1 +127,1 @@\n-  static void parse_from_file();\n+  static bool parse_from_file();\n@@ -170,3 +170,3 @@\n-  static void parse_from_string(const char* option_string, void (*parser)(char*));\n-  static void parse_from_line(char* line);\n-  static void parse_compile_only(char* line);\n+  static bool parse_from_string(const char* option_string, bool (*parser)(char*));\n+  static bool parse_from_line(char* line);\n+  static bool parse_compile_only(char* line);\n","filename":"src\/hotspot\/share\/compiler\/compilerOracle.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-void compilerOracle_init();\n+bool compilerOracle_init();\n@@ -157,1 +157,3 @@\n-  compilerOracle_init();\n+  if (!compilerOracle_init()) {\n+    return JNI_EINVAL;\n+  }\n","filename":"src\/hotspot\/share\/runtime\/init.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +50,1 @@\n-        new IntrinsicCommand(Scenario.Type.OPTION, ids).test();\n+        new IntrinsicCommand(Scenario.Type.OPTION, ids, true).test();\n@@ -51,1 +52,1 @@\n-        \/\/ even though intrinsic ids are invalid, hotspot returns 0\n+        \/\/ invalid compileCommands, hotspot exits with non-zero retval\n@@ -54,1 +55,1 @@\n-        new IntrinsicCommand(Scenario.Type.OPTION, ids).test();\n+        new IntrinsicCommand(Scenario.Type.OPTION, ids, false).test();\n","filename":"test\/hotspot\/jtreg\/compiler\/compilercontrol\/commands\/ControlIntrinsicTest.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +28,1 @@\n- * @summary Tests CompileCommand=option,package\/class,ccstrlist,ControlIntrinsic,+_id\n+ * @summary Tests CompileCommand=option,package\/class,ccstrlist,ControlIntrinsic,+_getClass\n@@ -39,2 +40,2 @@\n-        ProcessTools.executeTestJvm(\"-XX:CompileCommand=option,package\/class,ccstrlist,ControlIntrinsic,+_id\", \"-version\")\n-                    .shouldHaveExitValue(0)\n+        ProcessTools.executeTestJvm(\"-XX:CompileCommand=option,package\/class,ccstrlist,ControlIntrinsic,+_getClass\", \"-version\")\n+                    .shouldHaveExitValue(1)\n@@ -45,2 +46,2 @@\n-        ProcessTools.executeTestJvm(\"-XX:CompileCommand=option,*,ccstrlist,ControlIntrinsic,+_id\", \"-version\")\n-                    .shouldHaveExitValue(0)\n+        ProcessTools.executeTestJvm(\"-XX:CompileCommand=option,*,ccstrlist,ControlIntrinsic,+_getClass\", \"-version\")\n+                    .shouldHaveExitValue(1)\n@@ -53,1 +54,1 @@\n-        ProcessTools.executeTestJvm(\"-XX:CompileCommand=option,*.ccstrlist,ccstrlist,ControlIntrinsic,+_id\", \"-version\")\n+        ProcessTools.executeTestJvm(\"-XX:CompileCommand=option,*.ccstrlist,ccstrlist,ControlIntrinsic,+_getClass\", \"-version\")\n@@ -58,1 +59,2 @@\n-        ProcessTools.executeTestJvm(\"-XX:CompileCommand=option,*.*,ccstrlist,ControlIntrinsic,+_id\", \"-version\")\n+\n+        ProcessTools.executeTestJvm(\"-XX:CompileCommand=option,*.*,ccstrlist,ControlIntrinsic,+_getClass\", \"-version\")\n","filename":"test\/hotspot\/jtreg\/compiler\/compilercontrol\/commands\/OptionTest.java","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +50,1 @@\n-        new IntrinsicCommand(Scenario.Type.DIRECTIVE, ids).test();\n+        new IntrinsicCommand(Scenario.Type.DIRECTIVE, ids, true).test();\n@@ -54,1 +55,1 @@\n-        new IntrinsicCommand(Scenario.Type.DIRECTIVE, ids).test();\n+        new IntrinsicCommand(Scenario.Type.DIRECTIVE, ids, false).test();\n","filename":"test\/hotspot\/jtreg\/compiler\/compilercontrol\/directives\/ControlIntrinsicTest.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,1 +64,1 @@\n-            CompileCommand compileCommand = new JcmdCommand(Command.COMPILEONLY,\n+            CompileCommand compileCommand = new JcmdCommand(Command.COMPILEONLY, true,\n@@ -72,1 +72,1 @@\n-            builder.add(new JcmdCommand(Command.NONEXISTENT, null, null,\n+            builder.add(new JcmdCommand(Command.NONEXISTENT, true, null, null,\n","filename":"test\/hotspot\/jtreg\/compiler\/compilercontrol\/jcmd\/AddAndRemoveTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,1 +66,1 @@\n-                    cmdGen.generateCommand(), methodDescriptor,\n+                    cmdGen.generateCommand(), true, methodDescriptor,\n@@ -72,1 +72,1 @@\n-        builder.add(new JcmdCommand(Command.NONEXISTENT, null, null,\n+        builder.add(new JcmdCommand(Command.NONEXISTENT, true, null, null,\n@@ -75,1 +75,1 @@\n-        builder.add(new JcmdCommand(Command.NONEXISTENT, null, null,\n+        builder.add(new JcmdCommand(Command.NONEXISTENT, true, null, null,\n","filename":"test\/hotspot\/jtreg\/compiler\/compilercontrol\/jcmd\/ClearDirectivesStackTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +50,1 @@\n-        new IntrinsicCommand(Scenario.Type.JCMD, ids).test();\n+        new IntrinsicCommand(Scenario.Type.JCMD, ids, true).test();\n@@ -51,1 +52,1 @@\n-        \/\/ will get error message but jcmd process still return 0\n+        \/\/ invalid compileCommands, hotspot exits with non-zero retval\n@@ -54,1 +55,1 @@\n-        new IntrinsicCommand(Scenario.Type.JCMD, ids).test();\n+        new IntrinsicCommand(Scenario.Type.JCMD, ids, false).test();\n","filename":"test\/hotspot\/jtreg\/compiler\/compilercontrol\/jcmd\/ControlIntrinsicTest.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -80,1 +80,1 @@\n-            CompileCommand compileCommand = new CompileCommand(command,\n+            CompileCommand compileCommand = new CompileCommand(command, true,\n@@ -86,1 +86,1 @@\n-        builder.add(new JcmdCommand(Command.NONEXISTENT, null, null,\n+        builder.add(new JcmdCommand(Command.NONEXISTENT, true, null, null,\n","filename":"test\/hotspot\/jtreg\/compiler\/compilercontrol\/jcmd\/PrintDirectivesTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,0 +58,1 @@\n+    private final boolean isValid;\n@@ -60,1 +61,1 @@\n-    public IntrinsicCommand(Scenario.Type type, IntrinsicId[] intrinsic_ids) {\n+    public IntrinsicCommand(Scenario.Type type, IntrinsicId[] intrinsic_ids, boolean isValid) {\n@@ -65,0 +66,1 @@\n+        this.isValid = isValid;\n@@ -74,1 +76,1 @@\n-        CompileCommand compileCommand = cmdGen.generateCompileCommand(command,\n+        CompileCommand compileCommand = cmdGen.generateCompileCommand(command, isValid,\n@@ -76,0 +78,1 @@\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/compilercontrol\/share\/IntrinsicCommand.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -84,1 +84,1 @@\n-                cc = cmdGen.generateCompileCommand(cmd, md, null, argument);\n+                cc = cmdGen.generateCompileCommand(cmd, true, md, null, argument);\n@@ -86,1 +86,1 @@\n-                cc = cmdGen.generateCompileCommand(cmd, md, null);\n+                cc = cmdGen.generateCompileCommand(cmd, true, md, null);\n","filename":"test\/hotspot\/jtreg\/compiler\/compilercontrol\/share\/MultiCommand.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-        CompileCommand compileCommand = cmdGen.generateCompileCommand(command,\n+        CompileCommand compileCommand = cmdGen.generateCompileCommand(command, true,\n","filename":"test\/hotspot\/jtreg\/compiler\/compilercontrol\/share\/SingleCommand.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -125,0 +125,1 @@\n+                            compileCommand.isValid,\n","filename":"test\/hotspot\/jtreg\/compiler\/compilercontrol\/share\/scenario\/AbstractCommandBuilder.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -84,1 +84,1 @@\n-    public CompileCommand generateCompileCommand(Command command,\n+    public CompileCommand generateCompileCommand(Command command, boolean isValid,\n@@ -89,1 +89,1 @@\n-        return type.createCompileCommand(command, md, generateCompiler());\n+        return type.createCompileCommand(command, isValid, md, generateCompiler());\n@@ -92,1 +92,1 @@\n-    public CompileCommand generateCompileCommand(Command command,\n+    public CompileCommand generateCompileCommand(Command command, boolean isValid,\n@@ -97,1 +97,1 @@\n-        return type.createCompileCommand(command, md, generateCompiler(), argument);\n+        return type.createCompileCommand(command, isValid, md, generateCompiler(), argument);\n","filename":"test\/hotspot\/jtreg\/compiler\/compilercontrol\/share\/scenario\/CommandGenerator.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,2 @@\n+    public final boolean isValid;\n+\n@@ -39,0 +41,1 @@\n+                          boolean isValid,\n@@ -43,0 +46,1 @@\n+        this.isValid = isValid;\n@@ -50,0 +54,1 @@\n+                          boolean isValid,\n@@ -55,0 +60,1 @@\n+        this.isValid = isValid;\n@@ -68,0 +74,3 @@\n+        if (!isValid) {\n+            return false;\n+        }\n","filename":"test\/hotspot\/jtreg\/compiler\/compilercontrol\/share\/scenario\/CompileCommand.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,1 +72,1 @@\n-                .map(md -> new CompileCommand(null, md, null, null))\n+                .map(md -> new CompileCommand(null, true, md, null, null))\n@@ -127,1 +127,1 @@\n-                CompileCommand cc = new CompileCommand(Command.QUIET, md,\n+                CompileCommand cc = new CompileCommand(Command.QUIET, true, md,\n","filename":"test\/hotspot\/jtreg\/compiler\/compilercontrol\/share\/scenario\/DirectiveBuilder.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+                       boolean isValid,\n@@ -36,1 +37,1 @@\n-        super(command, methodDescriptor, compiler, type);\n+        super(command, isValid, methodDescriptor, compiler, type);\n@@ -41,0 +42,1 @@\n+                       boolean isValid,\n@@ -46,1 +48,1 @@\n-        super(command, methodDescriptor, compiler, type, argument);\n+        super(command, isValid, methodDescriptor, compiler, type, argument);\n","filename":"test\/hotspot\/jtreg\/compiler\/compilercontrol\/share\/scenario\/JcmdCommand.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -130,1 +130,1 @@\n-            CompileCommand cc = new CompileCommand(Command.QUIET, md,\n+            CompileCommand cc = new CompileCommand(Command.QUIET, true, md,\n@@ -202,1 +202,1 @@\n-                    .map(md -> new JcmdCommand(null, md, null, null,\n+                    .map(md -> new JcmdCommand(null, false, md, null, null,\n","filename":"test\/hotspot\/jtreg\/compiler\/compilercontrol\/share\/scenario\/JcmdStateBuilder.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -125,13 +125,7 @@\n-            \/\/ two cases for invalid inputs.\n-            if (mainOutput.getExitValue() == 0) {\n-                if (!isJcmdValid) {\n-                    boolean parse_error_found = false;\n-                    for(OutputAnalyzer out : outputList) {\n-                        if (out.getOutput().contains(\"Parsing of compiler directives failed\")) {\n-                            parse_error_found = true;\n-                            break;\n-                        }\n-                    }\n-                    Asserts.assertTrue(parse_error_found, \"'Parsing of compiler directives failed' missing from output\");\n-                } else {\n-                    mainOutput.shouldContain(\"CompileCommand: An error occurred during parsing\");\n+            Asserts.assertNE(mainOutput.getExitValue(), 0, \"VM should exit with \"\n+                    + \"error for incorrect directives\");\n+            boolean parse_error_found = false;\n+            for (OutputAnalyzer out : outputList) {\n+                if (out.getOutput().contains(\"Parsing of compiler directives failed\")) {\n+                    parse_error_found = true;\n+                    break;\n@@ -139,4 +133,3 @@\n-            } else {\n-                Asserts.assertNE(mainOutput.getExitValue(), 0, \"VM should exit with \"\n-                        + \"error for incorrect directives\");\n-                mainOutput.shouldContain(\"Parsing of compiler directives failed\");\n+            }\n+            if (!parse_error_found) {\n+                mainOutput.shouldContain(\"CompileCommand: An error occurred during parsing\");\n@@ -191,1 +184,1 @@\n-            public CompileCommand createCompileCommand(Command command,\n+            public CompileCommand createCompileCommand(Command command, boolean isValid,\n@@ -193,1 +186,1 @@\n-                return new JcmdCommand(command, md, compiler, this,\n+                return new JcmdCommand(command, isValid, md, compiler, this,\n@@ -198,1 +191,1 @@\n-            public CompileCommand createCompileCommand(Command command,\n+            public CompileCommand createCompileCommand(Command command, boolean isValid,\n@@ -200,1 +193,1 @@\n-                return new JcmdCommand(command, md, compiler, this,\n+                return new JcmdCommand(command, isValid, md, compiler, this,\n@@ -207,1 +200,1 @@\n-        public CompileCommand createCompileCommand(Command command,\n+        public CompileCommand createCompileCommand(Command command, boolean isValid,\n@@ -209,1 +202,1 @@\n-            return new CompileCommand(command, md, compiler, this);\n+            return new CompileCommand(command, isValid, md, compiler, this);\n@@ -212,1 +205,1 @@\n-        public CompileCommand createCompileCommand(Command command,\n+        public CompileCommand createCompileCommand(Command command, boolean isValid,\n@@ -214,1 +207,1 @@\n-            return new CompileCommand(command, md, compiler, this, argument);\n+            return new CompileCommand(command, isValid, md, compiler, this, argument);\n","filename":"test\/hotspot\/jtreg\/compiler\/compilercontrol\/share\/scenario\/Scenario.java","additions":19,"deletions":26,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -273,1 +273,1 @@\n-        out.shouldHaveExitValue(0);\n+        out.shouldHaveExitValue(1);\n@@ -288,1 +288,1 @@\n-        out.shouldHaveExitValue(0);\n+        out.shouldHaveExitValue(1);\n","filename":"test\/hotspot\/jtreg\/compiler\/oracle\/CheckCompileCommandOption.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -107,1 +107,1 @@\n-            oa.shouldHaveExitValue(0)\n+            oa.shouldHaveExitValue(1)\n","filename":"test\/hotspot\/jtreg\/compiler\/oracle\/PrintIdealPhaseTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -93,1 +94,1 @@\n-        out.shouldHaveExitValue(0);\n+        out.shouldHaveExitValue(1);\n","filename":"test\/hotspot\/jtreg\/compiler\/oracle\/TestInvalidCompileCommand.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,2 +51,1 @@\n-        \/\/ problems in CompileCommandFile are treated as warnings\n-        output.shouldHaveExitValue(0);\n+        output.shouldHaveExitValue(1);\n","filename":"test\/hotspot\/jtreg\/runtime\/CommandLine\/CompilerConfigFileWarning.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"}]}