{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,2 @@\n- * MD2, MD5, SHA-1, SHA-224, SHA-256, SHA-384, and SHA-512.\n+ * MD2, MD5, SHA-1, SHA-2 family (SHA-224, SHA-256, SHA-384, and SHA-512)\n+ * and SHA-3 family (SHA3-224, SHA3-256, SHA3-384, and SHA3-512) of digests.\n@@ -107,0 +108,1 @@\n+        case (int)CKM_SHA3_224:\n@@ -111,0 +113,1 @@\n+        case (int)CKM_SHA3_256:\n@@ -114,0 +117,1 @@\n+        case (int)CKM_SHA3_384:\n@@ -117,0 +121,1 @@\n+        case (int)CKM_SHA3_512:\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Digest.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,3 @@\n- * DES, DESede, AES, ARCFOUR, and Blowfish.\n+ * DES, DESede, AES, ARCFOUR, Blowfish, Hmac using MD5, SHA, SHA-2 family\n+ * (SHA-224, SHA-256, SHA-384, SHA-512, SHA-512\/224, SHA-512\/256), and SHA-3\n+ * family (SHA3-224, SHA3-256, SHA3-384, SHA3-512) of digests.\n@@ -68,0 +70,42 @@\n+    \/\/ for determining if the specified key size is valid\n+    private final CK_MECHANISM_INFO range;\n+\n+    \/\/ utility method for query the native key sizes and enforcing the\n+    \/\/ java-specific lower limit; returned values are in bits\n+    private static CK_MECHANISM_INFO getSupportedRange(Token token,\n+        long mech) throws ProviderException {\n+        \/\/ No need to query for fix-length algorithms\n+        if (mech == CKM_DES_KEY_GEN || mech == CKM_DES2_KEY_GEN ||\n+            mech == CKM_DES3_KEY_GEN) {\n+            return null;\n+        }\n+\n+        \/\/ Explicitly disallow keys shorter than 40-bits for security\n+        int lower = 40;\n+        int upper = Integer.MAX_VALUE;\n+        try {\n+            CK_MECHANISM_INFO info = token.getMechanismInfo(mech);\n+            if (info != null) {\n+                boolean isBytes = ((mech != CKM_GENERIC_SECRET_KEY_GEN\n+                        && mech != CKM_RC4_KEY_GEN) || info.iMinKeySize < 8);\n+                lower = Math.max(lower, (isBytes?\n+                        Math.multiplyExact(info.iMinKeySize, 8) :\n+                        info.iMinKeySize));\n+                \/\/ NSS CKM_GENERIC_SECRET_KEY_GEN mech info is not precise;\n+                \/\/ its upper limit is too low and does not match its impl\n+                if (mech == CKM_GENERIC_SECRET_KEY_GEN &&\n+                    info.iMaxKeySize <= 32) {\n+                    \/\/ ignore and leave upper limit at MAX_VALUE;\n+                } else if (info.iMaxKeySize != Integer.MAX_VALUE) {\n+                    upper = (isBytes?\n+                            Math.multiplyExact(info.iMaxKeySize, 8) :\n+                            info.iMaxKeySize);\n+                }\n+            }\n+        } catch (PKCS11Exception p11e) {\n+            \/\/ Should never happen\n+            throw new ProviderException(\"Cannot retrieve mechanism info\", p11e);\n+        }\n+        return new CK_MECHANISM_INFO(lower, upper, 0 \/* flags not used *\/);\n+    }\n+\n@@ -81,0 +125,1 @@\n+    \/\/ called by P11SecretKeyFactory to check key size\n@@ -83,0 +128,6 @@\n+        CK_MECHANISM_INFO range = getSupportedRange(token, keyGenMech);\n+        return checkKeySize(keyGenMech, keySize, range);\n+    }\n+\n+    private static int checkKeySize(long keyGenMech, int keySize,\n+        CK_MECHANISM_INFO range) throws InvalidAlgorithmParameterException {\n@@ -105,28 +156,2 @@\n-                CK_MECHANISM_INFO info = null;\n-                try {\n-                    info = token.getMechanismInfo(keyGenMech);\n-                } catch (PKCS11Exception p11e) {\n-                    \/\/ Should never happen\n-                    throw new ProviderException\n-                            (\"Cannot retrieve mechanism info\", p11e);\n-                }\n-                if (info == null) {\n-                    \/\/ XXX Unable to retrieve the supported key length from\n-                    \/\/ the underlying native impl. Skip the checking for now.\n-                    return keySize;\n-                }\n-                \/\/ PKCS#11 defines these to be in number of bytes except for\n-                \/\/ RC4 which is in bits. However, some PKCS#11 impls still use\n-                \/\/ bytes for all mechs, e.g. NSS. We try to detect this\n-                \/\/ inconsistency if the minKeySize seems unreasonably small.\n-                int minKeySize = info.iMinKeySize;\n-                int maxKeySize = info.iMaxKeySize;\n-                if (keyGenMech != CKM_RC4_KEY_GEN || minKeySize < 8) {\n-                    minKeySize = Math.multiplyExact(minKeySize, 8);\n-                    if (maxKeySize != Integer.MAX_VALUE) {\n-                        maxKeySize = Math.multiplyExact(maxKeySize, 8);\n-                    }\n-                }\n-                \/\/ Explicitly disallow keys shorter than 40-bits for security\n-                if (minKeySize < 40) minKeySize = 40;\n-                if (keySize < minKeySize || keySize > maxKeySize) {\n+                if (range != null && keySize < range.iMinKeySize\n+                    || keySize > range.iMaxKeySize) {\n@@ -134,2 +159,2 @@\n-                            (\"Key length must be between \" + minKeySize +\n-                            \" and \" + maxKeySize + \" bits\");\n+                        (\"Key length must be between \" + range.iMinKeySize +\n+                        \" and \" + range.iMaxKeySize + \" bits\");\n@@ -141,3 +166,1 @@\n-                                (\"AES key length must be \" + minKeySize +\n-                                (maxKeySize >= 192? \", 192\":\"\") +\n-                                (maxKeySize >= 256? \", or 256\":\"\") + \" bits\");\n+                            (\"AES key length must be 128, 192, or 256 bits\");\n@@ -151,0 +174,14 @@\n+    \/\/ check the supplied keysize (in bits) and adjust it based on the given\n+    \/\/ range\n+    private static int adjustKeySize(int ks, CK_MECHANISM_INFO mi) {\n+        \/\/ adjust to fit within the supported range\n+        if (mi != null) {\n+            if (ks < mi.iMinKeySize) {\n+                ks = mi.iMinKeySize;\n+            } else if (ks > mi.iMaxKeySize) {\n+                ks = mi.iMaxKeySize;\n+            }\n+        }\n+        return ks;\n+    }\n+\n@@ -167,1 +204,2 @@\n-        setDefaultKeySize();\n+        this.range = getSupportedRange(token, mechanism);\n+        setDefault();\n@@ -170,2 +208,3 @@\n-    \/\/ set default keysize and also initialize keyType\n-    private void setDefaultKeySize() {\n+    \/\/ set default keysize and keyType\n+    private void setDefault() {\n+        significantKeySize = -1;\n@@ -176,0 +215,1 @@\n+            significantKeySize = 56;\n@@ -180,0 +220,1 @@\n+            significantKeySize = 112;\n@@ -184,0 +225,1 @@\n+            significantKeySize = 168;\n@@ -186,1 +228,1 @@\n-            keySize = 128;\n+            keySize = adjustKeySize(128, range);\n@@ -190,1 +232,1 @@\n-            keySize = 128;\n+            keySize = adjustKeySize(128, range);\n@@ -194,1 +236,1 @@\n-            keySize = 128;\n+            keySize = adjustKeySize(128, range);\n@@ -197,0 +239,65 @@\n+        case (int)CKM_SHA_1_KEY_GEN:\n+            keySize = adjustKeySize(160, range);\n+            keyType = CKK_SHA_1_HMAC;\n+            break;\n+        case (int)CKM_SHA224_KEY_GEN:\n+            keySize = adjustKeySize(224, range);\n+            keyType = CKK_SHA224_HMAC;\n+            break;\n+        case (int)CKM_SHA256_KEY_GEN:\n+            keySize = adjustKeySize(256, range);\n+            keyType = CKK_SHA256_HMAC;\n+            break;\n+        case (int)CKM_SHA384_KEY_GEN:\n+            keySize = adjustKeySize(384, range);\n+            keyType = CKK_SHA384_HMAC;\n+            break;\n+        case (int)CKM_SHA512_KEY_GEN:\n+            keySize = adjustKeySize(512, range);\n+            keyType = CKK_SHA512_HMAC;\n+            break;\n+        case (int)CKM_SHA512_224_KEY_GEN:\n+            keySize = adjustKeySize(224, range);\n+            keyType = CKK_SHA512_224_HMAC;\n+            break;\n+        case (int)CKM_SHA512_256_KEY_GEN:\n+            keySize = adjustKeySize(256, range);\n+            keyType = CKK_SHA512_256_HMAC;\n+            break;\n+        case (int)CKM_SHA3_224_KEY_GEN:\n+            keySize = adjustKeySize(224, range);\n+            keyType = CKK_SHA3_224_HMAC;\n+            break;\n+        case (int)CKM_SHA3_256_KEY_GEN:\n+            keySize = adjustKeySize(256, range);\n+            keyType = CKK_SHA3_256_HMAC;\n+            break;\n+        case (int)CKM_SHA3_384_KEY_GEN:\n+            keySize = adjustKeySize(384, range);\n+            keyType = CKK_SHA3_384_HMAC;\n+            break;\n+        case (int)CKM_SHA3_512_KEY_GEN:\n+            keySize = adjustKeySize(512, range);\n+            keyType = CKK_SHA3_512_HMAC;\n+            break;\n+        case (int)CKM_GENERIC_SECRET_KEY_GEN:\n+            if (algorithm.startsWith(\"Hmac\")) {\n+                String digest = algorithm.substring(4);\n+                keySize = adjustKeySize(switch (digest) {\n+                    case \"MD5\" -> 512;\n+                    case \"SHA1\" -> 160;\n+                    case \"SHA224\", \"SHA512\/224\", \"SHA3-224\" -> 224;\n+                    case \"SHA256\", \"SHA512\/256\", \"SHA3-256\" -> 256;\n+                    case \"SHA384\", \"SHA3-384\" -> 384;\n+                    case \"SHA512\", \"SHA3-512\" -> 512;\n+                    default -> {\n+                        throw new ProviderException(\"Unsupported algorithm \" +\n+                            algorithm);\n+                    }\n+                }, range);\n+            } else {\n+                throw new ProviderException(\"Unsupported algorithm \" +\n+                        algorithm);\n+            }\n+            keyType = CKK_GENERIC_SECRET;\n+            break;\n@@ -200,4 +307,2 @@\n-        try {\n-            significantKeySize = checkKeySize(mechanism, keySize, token);\n-        } catch (InvalidAlgorithmParameterException iape) {\n-            throw new ProviderException(\"Unsupported default key size\", iape);\n+        if (significantKeySize == -1) {\n+            significantKeySize = keySize;\n@@ -210,1 +315,1 @@\n-        setDefaultKeySize();\n+        setDefault();\n@@ -225,1 +330,1 @@\n-            newSignificantKeySize = checkKeySize(mechanism, keySize, token);\n+            newSignificantKeySize = checkKeySize(mechanism, keySize, range);\n@@ -257,4 +362,5 @@\n-            switch ((int)keyType) {\n-            case (int)CKK_DES:\n-            case (int)CKK_DES2:\n-            case (int)CKK_DES3:\n+\n+            switch ((int)mechanism) {\n+            case (int)CKM_DES_KEY_GEN:\n+            case (int)CKM_DES2_KEY_GEN:\n+            case (int)CKM_DES3_KEY_GEN:\n@@ -285,1 +391,0 @@\n-\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11KeyGenerator.java","additions":157,"deletions":52,"binary":false,"changes":209,"status":"modified"},{"patch":"@@ -42,2 +42,3 @@\n- * MD5, SHA-1, SHA-224, SHA-256, SHA-384, and SHA-512 and the SSL3 MAC\n- * using MD5 and SHA-1.\n+ * MD5, SHA-1, SHA-2 family (SHA-224, SHA-256, SHA-384, and SHA-512),\n+ * SHA-3 family (SHA3-224, SHA3-256, SHA3-384, and SHA3-512), and the\n+ * SSL3 MAC using MD5 and SHA-1.\n@@ -95,0 +96,1 @@\n+        case (int)CKM_SHA3_224_HMAC:\n@@ -99,0 +101,1 @@\n+        case (int)CKM_SHA3_256_HMAC:\n@@ -102,0 +105,1 @@\n+        case (int)CKM_SHA3_384_HMAC:\n@@ -105,0 +109,1 @@\n+        case (int)CKM_SHA3_512_HMAC:\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Mac.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import sun.security.util.KnownOIDs;\n@@ -55,0 +56,4 @@\n+ *   . SHA3-224withRSASSA-PSS\n+ *   . SHA3-256withRSASSA-PSS\n+ *   . SHA3-384withRSASSA-PSS\n+ *   . SHA3-512withRSASSA-PSS\n@@ -74,2 +79,0 @@\n-        DIGEST_LENGTHS.put(\"SHA\", 20);\n-        DIGEST_LENGTHS.put(\"SHA1\", 20);\n@@ -77,1 +80,0 @@\n-        DIGEST_LENGTHS.put(\"SHA224\", 28);\n@@ -79,1 +81,0 @@\n-        DIGEST_LENGTHS.put(\"SHA256\", 32);\n@@ -81,1 +82,0 @@\n-        DIGEST_LENGTHS.put(\"SHA384\", 48);\n@@ -83,1 +83,0 @@\n-        DIGEST_LENGTHS.put(\"SHA512\", 64);\n@@ -85,1 +84,0 @@\n-        DIGEST_LENGTHS.put(\"SHA512\/224\", 28);\n@@ -87,1 +85,16 @@\n-        DIGEST_LENGTHS.put(\"SHA512\/256\", 32);\n+        DIGEST_LENGTHS.put(\"SHA3-224\", 28);\n+        DIGEST_LENGTHS.put(\"SHA3-256\", 32);\n+        DIGEST_LENGTHS.put(\"SHA3-384\", 48);\n+        DIGEST_LENGTHS.put(\"SHA3-512\", 64);\n+    }\n+\n+    \/\/ utility method for looking up the std digest algorithms\n+    private static String toStdName(String givenDigestAlg) {\n+        if (givenDigestAlg == null) return null;\n+\n+        KnownOIDs given2 = KnownOIDs.findMatch(givenDigestAlg);\n+        if (given2 == null) {\n+            return givenDigestAlg;\n+        } else {\n+            return given2.stdName();\n+        }\n@@ -95,18 +108,2 @@\n-        if (givenAlg.indexOf(\"-\") != -1) {\n-            return stdAlg.equalsIgnoreCase(givenAlg);\n-        } else {\n-            if (stdAlg.equals(\"SHA-1\")) {\n-                return (givenAlg.equalsIgnoreCase(\"SHA\")\n-                        || givenAlg.equalsIgnoreCase(\"SHA1\"));\n-            } else {\n-                StringBuilder sb = new StringBuilder(givenAlg);\n-                \/\/ case-insensitive check\n-                if (givenAlg.regionMatches(true, 0, \"SHA\", 0, 3)) {\n-                    givenAlg = sb.insert(3, \"-\").toString();\n-                    return stdAlg.equalsIgnoreCase(givenAlg);\n-                } else {\n-                    throw new ProviderException(\"Unsupported digest algorithm \"\n-                            + givenAlg);\n-                }\n-            }\n-        }\n+        givenAlg = toStdName(givenAlg);\n+        return stdAlg.equalsIgnoreCase(givenAlg);\n@@ -175,1 +172,4 @@\n-        this.mdAlg = (idx == -1? null : algorithm.substring(0, idx));\n+        \/\/ convert to stdName\n+        this.mdAlg = (idx == -1?\n+                null : toStdName(algorithm.substring(0, idx)));\n+\n@@ -182,0 +182,4 @@\n+        case (int)CKM_SHA3_224_RSA_PKCS_PSS:\n+        case (int)CKM_SHA3_256_RSA_PKCS_PSS:\n+        case (int)CKM_SHA3_384_RSA_PKCS_PSS:\n+        case (int)CKM_SHA3_512_RSA_PKCS_PSS:\n@@ -183,0 +187,1 @@\n+            this.md = null;\n@@ -185,0 +190,8 @@\n+            \/\/ check if the digest algo is supported by underlying PKCS11 lib\n+            if (this.mdAlg != null && token.getMechanismInfo\n+                    (Functions.getHashMechId(this.mdAlg)) == null) {\n+                throw new NoSuchAlgorithmException(\"Unsupported algorithm: \" +\n+                        algorithm);\n+            }\n+            this.md = (this.mdAlg == null? null :\n+                    MessageDigest.getInstance(this.mdAlg));\n@@ -190,1 +203,15 @@\n-        this.md = null;\n+    }\n+\n+    private static PSSParameterSpec genDefaultParams(String digestAlg,\n+            P11Key key) throws SignatureException {\n+        int mdLen;\n+        try {\n+            mdLen = DIGEST_LENGTHS.get(digestAlg);\n+        } catch (NullPointerException npe) {\n+            throw new SignatureException(\"Unsupported digest: \" +\n+                    digestAlg);\n+        }\n+        int saltLen = Integer.min(mdLen, (key.length() >> 3) - mdLen -2);\n+        return new PSSParameterSpec(digestAlg,\n+                \"MGF1\", new MGF1ParameterSpec(digestAlg),\n+                saltLen, PSSParameterSpec.TRAILER_FIELD_BC);\n@@ -195,0 +222,1 @@\n+\n@@ -203,9 +231,0 @@\n-            } else {\n-                int saltLen = DIGEST_LENGTHS.get(this.mdAlg).intValue();\n-                \/\/ generate default params for both sign and verify?\n-                this.sigParams = new PSSParameterSpec(this.mdAlg,\n-                        \"MGF1\", new MGF1ParameterSpec(this.mdAlg),\n-                        saltLen, PSSParameterSpec.TRAILER_FIELD_BC);\n-                this.mechanism.setParameter(new CK_RSA_PKCS_PSS_PARAMS(\n-                        this.mdAlg, \"MGF1\", this.mdAlg,\n-                        DIGEST_LENGTHS.get(this.mdAlg).intValue()));\n@@ -213,0 +232,4 @@\n+            \/\/ generate default params for both sign and verify?\n+            this.sigParams = genDefaultParams(this.mdAlg, this.p11Key);\n+            this.mechanism.setParameter(new CK_RSA_PKCS_PSS_PARAMS(\n+                    this.mdAlg, \"MGF1\", this.mdAlg, sigParams.getSaltLength()));\n@@ -216,1 +239,5 @@\n-            initialize();\n+            try {\n+                initialize();\n+            } catch (ProviderException pe) {\n+                throw new SignatureException(pe);\n+            }\n@@ -282,1 +309,1 @@\n-    private void initialize() {\n+    private void initialize() throws ProviderException {\n@@ -359,1 +386,2 @@\n-            int hLen = DIGEST_LENGTHS.get(digestAlg).intValue();\n+\n+            int hLen = DIGEST_LENGTHS.get(toStdName(digestAlg)).intValue();\n@@ -383,1 +411,1 @@\n-        if (this.mdAlg != null && !isDigestEqual(digestAlgorithm, this.mdAlg)) {\n+        if (this.mdAlg != null && !isDigestEqual(this.mdAlg, digestAlgorithm)) {\n@@ -388,1 +416,13 @@\n-        Integer digestLen = DIGEST_LENGTHS.get(digestAlgorithm);\n+\n+        try {\n+            if (token.getMechanismInfo(Functions.getHashMechId\n+                    (digestAlgorithm)) == null) {\n+                throw new InvalidAlgorithmParameterException\n+                        (\"Unsupported digest algorithm: \" + digestAlgorithm);\n+            }\n+        } catch (PKCS11Exception pe) {\n+            \/\/ should not happen\n+            throw new InvalidAlgorithmParameterException(pe);\n+        }\n+\n+        Integer digestLen = DIGEST_LENGTHS.get(toStdName(digestAlgorithm));\n@@ -461,2 +501,8 @@\n-        \/\/ For PSS, defer PKCS11 initialization calls to update\/doFinal as it\n-        \/\/ needs both key and params\n+        \/\/ attempt initialization when key and params are both available\n+        if (this.p11Key != null && this.sigParams != null) {\n+            try {\n+                initialize();\n+            } catch (ProviderException pe) {\n+                throw new InvalidKeyException(pe);\n+            }\n+        }\n@@ -483,2 +529,8 @@\n-        \/\/ For PSS, defer PKCS11 initialization calls to update\/doFinal as it\n-        \/\/ needs both key and params\n+        \/\/ attempt initialization when key and params are both available\n+        if (this.p11Key != null && this.sigParams != null) {\n+            try {\n+                initialize();\n+            } catch (ProviderException pe) {\n+                throw new InvalidKeyException(pe);\n+            }\n+        }\n@@ -689,0 +741,9 @@\n+\n+        \/\/ attempt initialization when key and params are both available\n+        if (this.p11Key != null && this.sigParams != null) {\n+            try {\n+                initialize();\n+            } catch (ProviderException pe) {\n+                throw new InvalidAlgorithmParameterException(pe);\n+            }\n+        }\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11PSSSignature.java","additions":107,"deletions":46,"binary":false,"changes":153,"status":"modified"},{"patch":"@@ -54,2 +54,9 @@\n- *   . NONEwithDSAinP1363Format (RawDSAinP1363Format)\n- *   . SHA1withDSAinP1363Format\n+ *   . SHA224withDSA\n+ *   . SHA256withDSA\n+ *   . SHA384withDSA\n+ *   . SHA512withDSA\n+ *   . SHA3-224withDSA\n+ *   . SHA3-256withDSA\n+ *   . SHA3-384withDSA\n+ *   . SHA3-512withDSA\n+ *   . <any of above>inP1363Format\n@@ -64,0 +71,4 @@\n+ *   . SHA3-224withRSA\n+ *   . SHA3-256withRSA\n+ *   . SHA3-384withRSA\n+ *   . SHA3-512withRSA\n@@ -71,6 +82,5 @@\n- *   . NONEwithECDSAinP1363Format\n- *   . SHA1withECDSAinP1363Format\n- *   . SHA224withECDSAinP1363Format\n- *   . SHA256withECDSAinP1363Format\n- *   . SHA384withECDSAinP1363Format\n- *   . SHA512withECDSAinP1363Format\n+ *   . SHA3_224withECDSA\n+ *   . SHA3_256withECDSA\n+ *   . SHA3_384withECDSA\n+ *   . SHA3_512withECDSA\n+ *   . <any of above>inP1363Format\n@@ -147,2 +157,2 @@\n-    \/\/ XXX PKCS#11 v2.20 says \"should not be longer than 1024 bits\",\n-    \/\/ but this is a little arbitrary\n+    \/\/ PKCS#11 spec for CKM_ECDSA states that the length should not be longer\n+    \/\/ than 1024 bits\", but this is a little arbitrary\n@@ -151,0 +161,1 @@\n+\n@@ -168,0 +179,4 @@\n+        case (int)CKM_SHA3_224_RSA_PKCS:\n+        case (int)CKM_SHA3_256_RSA_PKCS:\n+        case (int)CKM_SHA3_384_RSA_PKCS:\n+        case (int)CKM_SHA3_512_RSA_PKCS:\n@@ -173,0 +188,8 @@\n+        case (int)CKM_DSA_SHA224:\n+        case (int)CKM_DSA_SHA256:\n+        case (int)CKM_DSA_SHA384:\n+        case (int)CKM_DSA_SHA512:\n+        case (int)CKM_DSA_SHA3_224:\n+        case (int)CKM_DSA_SHA3_256:\n+        case (int)CKM_DSA_SHA3_384:\n+        case (int)CKM_DSA_SHA3_512:\n@@ -178,0 +201,8 @@\n+        case (int)CKM_ECDSA_SHA224:\n+        case (int)CKM_ECDSA_SHA256:\n+        case (int)CKM_ECDSA_SHA384:\n+        case (int)CKM_ECDSA_SHA512:\n+        case (int)CKM_ECDSA_SHA3_224:\n+        case (int)CKM_ECDSA_SHA3_256:\n+        case (int)CKM_ECDSA_SHA3_384:\n+        case (int)CKM_ECDSA_SHA3_512:\n@@ -203,19 +234,0 @@\n-                String digestAlg;\n-                if (algorithm.equals(\"SHA1withECDSA\") ||\n-                    algorithm.equals(\"SHA1withECDSAinP1363Format\")) {\n-                    digestAlg = \"SHA-1\";\n-                } else if (algorithm.equals(\"SHA224withECDSA\") ||\n-                           algorithm.equals(\"SHA224withECDSAinP1363Format\")) {\n-                    digestAlg = \"SHA-224\";\n-                } else if (algorithm.equals(\"SHA256withECDSA\") ||\n-                           algorithm.equals(\"SHA256withECDSAinP1363Format\")) {\n-                    digestAlg = \"SHA-256\";\n-                } else if (algorithm.equals(\"SHA384withECDSA\") ||\n-                           algorithm.equals(\"SHA384withECDSAinP1363Format\")) {\n-                    digestAlg = \"SHA-384\";\n-                } else if (algorithm.equals(\"SHA512withECDSA\") ||\n-                           algorithm.equals(\"SHA512withECDSAinP1363Format\")) {\n-                    digestAlg = \"SHA-512\";\n-                } else {\n-                    throw new ProviderException(algorithm);\n-                }\n@@ -223,1 +235,2 @@\n-                md = MessageDigest.getInstance(digestAlg);\n+                md = MessageDigest.getInstance\n+                        (getDigestEnum(algorithm).stdName());\n@@ -230,24 +243,3 @@\n-            if (algorithm.equals(\"MD5withRSA\")) {\n-                md = MessageDigest.getInstance(\"MD5\");\n-                digestOID = AlgorithmId.MD5_oid;\n-            } else if (algorithm.equals(\"SHA1withRSA\")) {\n-                md = MessageDigest.getInstance(\"SHA-1\");\n-                digestOID = AlgorithmId.SHA_oid;\n-            } else if (algorithm.equals(\"MD2withRSA\")) {\n-                md = MessageDigest.getInstance(\"MD2\");\n-                digestOID = AlgorithmId.MD2_oid;\n-            } else if (algorithm.equals(\"SHA224withRSA\")) {\n-                md = MessageDigest.getInstance(\"SHA-224\");\n-                digestOID = AlgorithmId.SHA224_oid;\n-            } else if (algorithm.equals(\"SHA256withRSA\")) {\n-                md = MessageDigest.getInstance(\"SHA-256\");\n-                digestOID = AlgorithmId.SHA256_oid;\n-            } else if (algorithm.equals(\"SHA384withRSA\")) {\n-                md = MessageDigest.getInstance(\"SHA-384\");\n-                digestOID = AlgorithmId.SHA384_oid;\n-            } else if (algorithm.equals(\"SHA512withRSA\")) {\n-                md = MessageDigest.getInstance(\"SHA-512\");\n-                digestOID = AlgorithmId.SHA512_oid;\n-            } else {\n-                throw new ProviderException(\"Unknown signature: \" + algorithm);\n-            }\n+            KnownOIDs digestAlg = getDigestEnum(algorithm);\n+            md = MessageDigest.getInstance(digestAlg.stdName());\n+            digestOID = ObjectIdentifier.of(digestAlg);\n@@ -307,2 +299,2 @@\n-                if (keyAlgorithm.equals(\"DSA\")) {\n-                    signature = new byte[40];\n+                if (mechanism == CKM_DSA) {\n+                    signature = new byte[64]; \/\/ assume N = 256\n@@ -439,17 +431,11 @@\n-        int encodedLength;\n-        if (algorithm.equals(\"MD5withRSA\") ||\n-            algorithm.equals(\"MD2withRSA\")) {\n-            encodedLength = 34;\n-        } else if (algorithm.equals(\"SHA1withRSA\")) {\n-            encodedLength = 35;\n-        } else if (algorithm.equals(\"SHA224withRSA\")) {\n-            encodedLength = 47;\n-        } else if (algorithm.equals(\"SHA256withRSA\")) {\n-            encodedLength = 51;\n-        } else if (algorithm.equals(\"SHA384withRSA\")) {\n-            encodedLength = 67;\n-        } else if (algorithm.equals(\"SHA512withRSA\")) {\n-            encodedLength = 83;\n-        } else {\n-            throw new ProviderException(\"Unknown signature algo: \" + algorithm);\n-        }\n+        int encodedLength = switch (algorithm) {\n+            case \"MD5withRSA\", \"MD2withRSA\" -> 34;\n+            case \"SHA1withRSA\" -> 35;\n+            case \"SHA224withRSA\", \"SHA3-224withRSA\" -> 47;\n+            case \"SHA256withRSA\", \"SHA3-256withRSA\" -> 51;\n+            case \"SHA384withRSA\", \"SHA3-384withRSA\" -> 67;\n+            case \"SHA512withRSA\", \"SHA3-512withRSA\" -> 83;\n+            default ->\n+                throw new ProviderException(\"Unknown signature algo: \" +\n+                        algorithm);\n+        };\n@@ -627,2 +613,1 @@\n-                int len = keyAlgorithm.equals(\"DSA\") ? 40 : 0;\n-                signature = token.p11.C_SignFinal(session.id(), len);\n+                signature = token.p11.C_SignFinal(session.id(), 0);\n@@ -772,0 +757,17 @@\n+    private static KnownOIDs getDigestEnum(String algorithm)\n+            throws NoSuchAlgorithmException {\n+        try {\n+            String digAlg = SignatureUtil.extractDigestAlgFromDwithE(algorithm);\n+            KnownOIDs k = KnownOIDs.findMatch(digAlg);\n+            if (k == null) {\n+                throw new NoSuchAlgorithmException\n+                        (\"Unsupported digest algorithm: \" + digAlg);\n+            }\n+            return k;\n+        } catch (IllegalArgumentException iae) {\n+            \/\/ should never happen\n+            throw new NoSuchAlgorithmException(\"Unknown signature: \" +\n+                    algorithm, iae);\n+        }\n+    }\n+\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Signature.java","additions":77,"deletions":75,"binary":false,"changes":152,"status":"modified"},{"patch":"@@ -546,0 +546,8 @@\n+        dA(MD, \"SHA3-224\",        P11Digest,\n+                m(CKM_SHA3_224));\n+        dA(MD, \"SHA3-256\",        P11Digest,\n+                m(CKM_SHA3_256));\n+        dA(MD, \"SHA3-384\",        P11Digest,\n+                m(CKM_SHA3_384));\n+        dA(MD, \"SHA3-512\",        P11Digest,\n+                m(CKM_SHA3_512));\n@@ -563,1 +571,8 @@\n-\n+        dA(MAC, \"HmacSHA3-224\",    P11MAC,\n+                m(CKM_SHA3_224_HMAC));\n+        dA(MAC, \"HmacSHA3-256\",    P11MAC,\n+                m(CKM_SHA3_256_HMAC));\n+        dA(MAC, \"HmacSHA3-384\",    P11MAC,\n+                m(CKM_SHA3_384_HMAC));\n+        dA(MAC, \"HmacSHA3-512\",    P11MAC,\n+                m(CKM_SHA3_512_HMAC));\n@@ -593,0 +608,24 @@\n+        d(KG,  \"HmacMD5\",      P11KeyGenerator, \/\/ 1.3.6.1.5.5.8.1.1\n+                m(CKM_GENERIC_SECRET_KEY_GEN));\n+        dA(KG,  \"HmacSHA1\",      P11KeyGenerator,\n+                m(CKM_SHA_1_KEY_GEN, CKM_GENERIC_SECRET_KEY_GEN));\n+        dA(KG,  \"HmacSHA224\",    P11KeyGenerator,\n+                m(CKM_SHA224_KEY_GEN, CKM_GENERIC_SECRET_KEY_GEN));\n+        dA(KG,  \"HmacSHA256\",    P11KeyGenerator,\n+                m(CKM_SHA256_KEY_GEN, CKM_GENERIC_SECRET_KEY_GEN));\n+        dA(KG,  \"HmacSHA384\",    P11KeyGenerator,\n+                m(CKM_SHA384_KEY_GEN, CKM_GENERIC_SECRET_KEY_GEN));\n+        dA(KG,  \"HmacSHA512\",    P11KeyGenerator,\n+                m(CKM_SHA512_KEY_GEN, CKM_GENERIC_SECRET_KEY_GEN));\n+        dA(KG,  \"HmacSHA512\/224\",    P11KeyGenerator,\n+                m(CKM_SHA512_224_KEY_GEN, CKM_GENERIC_SECRET_KEY_GEN));\n+        dA(KG,  \"HmacSHA512\/256\",    P11KeyGenerator,\n+                m(CKM_SHA512_256_KEY_GEN, CKM_GENERIC_SECRET_KEY_GEN));\n+        dA(KG,  \"HmacSHA3-224\",    P11KeyGenerator,\n+                m(CKM_SHA3_224_KEY_GEN, CKM_GENERIC_SECRET_KEY_GEN));\n+        dA(KG,  \"HmacSHA3-256\",    P11KeyGenerator,\n+                m(CKM_SHA3_256_KEY_GEN, CKM_GENERIC_SECRET_KEY_GEN));\n+        dA(KG,  \"HmacSHA3-384\",    P11KeyGenerator,\n+                m(CKM_SHA3_384_KEY_GEN, CKM_GENERIC_SECRET_KEY_GEN));\n+        dA(KG,  \"HmacSHA3-512\",    P11KeyGenerator,\n+                m(CKM_SHA3_512_KEY_GEN, CKM_GENERIC_SECRET_KEY_GEN));\n@@ -714,0 +753,8 @@\n+        dA(SIG, \"SHA3-224withDSA\", P11Signature,\n+                m(CKM_DSA_SHA3_224));\n+        dA(SIG, \"SHA3-256withDSA\", P11Signature,\n+                m(CKM_DSA_SHA3_256));\n+        dA(SIG, \"SHA3-384withDSA\", P11Signature,\n+                m(CKM_DSA_SHA3_384));\n+        dA(SIG, \"SHA3-512withDSA\", P11Signature,\n+                m(CKM_DSA_SHA3_512));\n@@ -720,1 +767,16 @@\n-\n+        d(SIG, \"SHA224withDSAinP1363Format\",      P11Signature,\n+                m(CKM_DSA_SHA224));\n+        d(SIG, \"SHA256withDSAinP1363Format\",      P11Signature,\n+                m(CKM_DSA_SHA256));\n+        d(SIG, \"SHA384withDSAinP1363Format\",      P11Signature,\n+                m(CKM_DSA_SHA384));\n+        d(SIG, \"SHA512withDSAinP1363Format\",      P11Signature,\n+                m(CKM_DSA_SHA512));\n+        d(SIG, \"SHA3-224withDSAinP1363Format\",      P11Signature,\n+                m(CKM_DSA_SHA3_224));\n+        d(SIG, \"SHA3-256withDSAinP1363Format\",      P11Signature,\n+                m(CKM_DSA_SHA3_256));\n+        d(SIG, \"SHA3-384withDSAinP1363Format\",      P11Signature,\n+                m(CKM_DSA_SHA3_384));\n+        d(SIG, \"SHA3-512withDSAinP1363Format\",      P11Signature,\n+                m(CKM_DSA_SHA3_512));\n@@ -726,1 +788,1 @@\n-                m(CKM_ECDSA));\n+                m(CKM_ECDSA_SHA224, CKM_ECDSA));\n@@ -728,1 +790,1 @@\n-                m(CKM_ECDSA));\n+                m(CKM_ECDSA_SHA256, CKM_ECDSA));\n@@ -730,1 +792,1 @@\n-                m(CKM_ECDSA));\n+                m(CKM_ECDSA_SHA384, CKM_ECDSA));\n@@ -732,1 +794,9 @@\n-                m(CKM_ECDSA));\n+                m(CKM_ECDSA_SHA512, CKM_ECDSA));\n+        dA(SIG, \"SHA3-224withECDSA\",       P11Signature,\n+                m(CKM_ECDSA_SHA3_224, CKM_ECDSA));\n+        dA(SIG, \"SHA3-256withECDSA\",       P11Signature,\n+                m(CKM_ECDSA_SHA3_256, CKM_ECDSA));\n+        dA(SIG, \"SHA3-384withECDSA\",       P11Signature,\n+                m(CKM_ECDSA_SHA3_384, CKM_ECDSA));\n+        dA(SIG, \"SHA3-512withECDSA\",       P11Signature,\n+                m(CKM_ECDSA_SHA3_512, CKM_ECDSA));\n@@ -738,1 +808,1 @@\n-                m(CKM_ECDSA));\n+                m(CKM_ECDSA_SHA224, CKM_ECDSA));\n@@ -740,1 +810,1 @@\n-                m(CKM_ECDSA));\n+                m(CKM_ECDSA_SHA256, CKM_ECDSA));\n@@ -742,1 +812,1 @@\n-                m(CKM_ECDSA));\n+                m(CKM_ECDSA_SHA384, CKM_ECDSA));\n@@ -744,1 +814,10 @@\n-                m(CKM_ECDSA));\n+                m(CKM_ECDSA_SHA512, CKM_ECDSA));\n+        d(SIG, \"SHA3-224withECDSAinP1363Format\", P11Signature,\n+                m(CKM_ECDSA_SHA3_224, CKM_ECDSA));\n+        d(SIG, \"SHA3-256withECDSAinP1363Format\", P11Signature,\n+                m(CKM_ECDSA_SHA3_256, CKM_ECDSA));\n+        d(SIG, \"SHA3-384withECDSAinP1363Format\", P11Signature,\n+                m(CKM_ECDSA_SHA3_384, CKM_ECDSA));\n+        d(SIG, \"SHA3-512withECDSAinP1363Format\", P11Signature,\n+                m(CKM_ECDSA_SHA3_512, CKM_ECDSA));\n+\n@@ -759,0 +838,8 @@\n+        dA(SIG, \"SHA3-224withRSA\", P11Signature,\n+                m(CKM_SHA3_224_RSA_PKCS, CKM_RSA_PKCS, CKM_RSA_X_509));\n+        dA(SIG, \"SHA3-256withRSA\", P11Signature,\n+                m(CKM_SHA3_256_RSA_PKCS, CKM_RSA_PKCS, CKM_RSA_X_509));\n+        dA(SIG, \"SHA3-384withRSA\", P11Signature,\n+                m(CKM_SHA3_384_RSA_PKCS, CKM_RSA_PKCS, CKM_RSA_X_509));\n+        dA(SIG, \"SHA3-512withRSA\", P11Signature,\n+                m(CKM_SHA3_512_RSA_PKCS, CKM_RSA_PKCS, CKM_RSA_X_509));\n@@ -771,0 +858,8 @@\n+        d(SIG, \"SHA3-224withRSASSA-PSS\", P11PSSSignature,\n+                m(CKM_SHA3_224_RSA_PKCS_PSS));\n+        d(SIG, \"SHA3-256withRSASSA-PSS\", P11PSSSignature,\n+                m(CKM_SHA3_256_RSA_PKCS_PSS));\n+        d(SIG, \"SHA3-384withRSASSA-PSS\", P11PSSSignature,\n+                m(CKM_SHA3_384_RSA_PKCS_PSS));\n+        d(SIG, \"SHA3-512withRSASSA-PSS\", P11PSSSignature,\n+                m(CKM_SHA3_512_RSA_PKCS_PSS));\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/SunPKCS11.java","additions":105,"deletions":10,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,6 @@\n-        this.mgf = Functions.getMGFId(\"CKG_MGF1_\" + mgfHash.replaceFirst(\"-\", \"\"));\n+        if (mgfHash.startsWith(\"SHA3-\")) {\n+            mgfHash = mgfHash.replaceFirst(\"-\", \"_\");\n+        } else {\n+            mgfHash = mgfHash.replaceFirst(\"-\", \"\");\n+        }\n+        this.mgf = Functions.getMGFId(\"CKG_MGF1_\" + mgfHash);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/wrapper\/CK_RSA_PKCS_PSS_PARAMS.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8242332\n+ * @summary Check that PKCS11 Hamc KeyGenerator picks appropriate default size\n+ * @library \/test\/lib ..\n+ * @modules jdk.crypto.cryptoki\n+ * @run main\/othervm HmacDefKeySizeTest\n+ * @run main\/othervm HmacDefKeySizeTest sm\n+ *\/\n+\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.NoSuchProviderException;\n+import java.security.Provider;\n+import java.util.List;\n+import javax.crypto.KeyGenerator;\n+import javax.crypto.SecretKey;\n+\n+public class HmacDefKeySizeTest extends PKCS11Test {\n+\n+    \/**\n+     * Request a KeyGenerator object from PKCS11 provider for Hmac algorithm,\n+     * and generate the SecretKey.\n+     *\n+     * @param args the command line arguments\n+     *\/\n+    public static void main(String[] args) throws Exception {\n+        main(new HmacDefKeySizeTest(), args);\n+    }\n+\n+    @Override\n+    public void main(Provider p) {\n+        List<String> algorithms = getSupportedAlgorithms(\"KeyGenerator\",\n+                \"Hmac\", p);\n+        boolean success = true;\n+\n+        for (String alg : algorithms) {\n+            System.out.println(\"Testing \" + alg);\n+            try {\n+                KeyGenerator kg = KeyGenerator.getInstance(alg, p);\n+                SecretKey k1 = kg.generateKey();\n+                int keysize = k1.getEncoded().length << 3;\n+                System.out.println(\"=> default key size = \" + keysize);\n+                kg.init(keysize);\n+                SecretKey k2 = kg.generateKey();\n+                if ((k2.getEncoded().length << 3) != keysize) {\n+                    success = false;\n+                    System.out.println(\"keysize check failed\");\n+                }\n+            } catch (Exception e) {\n+                System.out.println(\"Unexpected exception: \" + e);\n+                e.printStackTrace();\n+                success = false;\n+            }\n+        }\n+\n+        if (!success) {\n+            throw new RuntimeException(\"One or more tests failed\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/pkcs11\/KeyGenerator\/HmacDefKeySizeTest.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 4917233 6461727 6490213 6720456\n+ * @bug 4917233 6461727 6490213 6720456 8242332\n@@ -130,0 +130,12 @@\n+        String[] HMAC_ALGS = {\n+            \"HmacSHA1\", \"HmacSHA224\", \"HmacSHA256\", \"HmacSHA384\", \"HmacSHA512\",\n+            \"HmacSHA512\/224\", \"HmacSHA512\/256\", \"HmacSHA3-224\", \"HmacSHA3-256\",\n+            \"HmacSHA3-384\", \"HmacSHA3-512\",\n+        };\n+\n+        for (String hmacAlg : HMAC_ALGS) {\n+            test(hmacAlg, 0, p, TestResult.FAIL);\n+            test(hmacAlg, 128, p, TestResult.PASS);\n+            test(hmacAlg, 224, p, TestResult.PASS);\n+        }\n+\n","filename":"test\/jdk\/sun\/security\/pkcs11\/KeyGenerator\/TestKeyGenerator.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8048603\n+ * @bug 8048603 8242332\n@@ -43,0 +43,2 @@\n+import javax.crypto.KeyGenerator;\n+import javax.crypto.SecretKey;\n@@ -49,1 +51,1 @@\n-    private static final int KEY_SIZE = 70;\n+    private static final int KEY_SIZE = 128;\n@@ -70,0 +72,2 @@\n+        SecureRandom srdm = new SecureRandom();\n+\n@@ -71,0 +75,13 @@\n+            \/\/ first try w\/ java secret key object\n+            byte[] keyVal = new byte[KEY_SIZE];\n+            srdm.nextBytes(keyVal);\n+            SecretKey skey = new SecretKeySpec(keyVal, alg);\n+\n+            try {\n+                doTest(alg, skey, p);\n+            } catch (Exception e) {\n+                System.out.println(\"Unexpected exception: \" + e);\n+                e.printStackTrace();\n+                success = false;\n+            }\n+\n@@ -72,1 +89,7 @@\n-                doTest(alg, p);\n+                KeyGenerator kg = KeyGenerator.getInstance(alg, p);\n+                kg.init(KEY_SIZE);\n+                skey = kg.generateKey();\n+                doTest(alg, skey, p);\n+            } catch (NoSuchAlgorithmException nsae) {\n+                System.out.println(\"Skip test using native key for \" + alg);\n+                continue;\n@@ -85,1 +108,1 @@\n-    private void doTest(String algo, Provider provider)\n+    private void doTest(String algo, SecretKey key, Provider provider)\n@@ -99,6 +122,1 @@\n-        SecureRandom srdm = new SecureRandom();\n-        byte[] keyVal = new byte[KEY_SIZE];\n-        srdm.nextBytes(keyVal);\n-        SecretKeySpec keySpec = new SecretKeySpec(keyVal, \"HMAC\");\n-\n-        mac.init(keySpec);\n+        mac.init(key);\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Mac\/MacSameTest.java","additions":28,"deletions":10,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 4856966\n+ * @bug 4856966 8242332\n@@ -38,0 +38,1 @@\n+import java.util.List;\n@@ -49,4 +50,1 @@\n-        if (p.getService(\"Mac\", \"HmacMD5\") == null) {\n-            System.out.println(p + \" does not support HmacMD5, skipping\");\n-            return;\n-        }\n+        List<String> algorithms = getSupportedAlgorithms(\"Mac\", \"Hmac\", p);\n@@ -54,6 +52,28 @@\n-        byte[] data1 = new byte[10 * 1024];\n-        random.nextBytes(data1);\n-        byte[] keyData = new byte[16];\n-        random.nextBytes(keyData);\n-        SecretKeySpec key = new SecretKeySpec(keyData, \"Hmac\");\n-        Mac mac = Mac.getInstance(\"HmacMD5\", p);\n+        byte[] data = new byte[10 * 1024];\n+        random.nextBytes(data);\n+        byte[] keyVal = new byte[16];\n+        random.nextBytes(keyVal);\n+\n+        boolean success = true;\n+        for (String alg : algorithms) {\n+            try {\n+                doTest(alg, p, keyVal, data);\n+            } catch (Exception e) {\n+                System.out.println(\"Unexpected exception: \" + e);\n+                e.printStackTrace();\n+                success = false;\n+            }\n+        }\n+\n+        if (!success) {\n+            throw new RuntimeException(\"Test failed\");\n+        } else {\n+            System.out.println(\"All tests passed\");\n+        }\n+    }\n+\n+    private void doTest(String alg, Provider p, byte[] keyVal, byte[] data)\n+            throws Exception {\n+        System.out.println(\"Testing \" + alg);\n+        SecretKeySpec key = new SecretKeySpec(keyVal, alg);\n+        Mac mac = Mac.getInstance(alg, p);\n@@ -62,1 +82,1 @@\n-        mac.update(data1);\n+        mac.update(data);\n@@ -66,1 +86,1 @@\n-        mac.update(data1);\n+        mac.update(data);\n@@ -72,1 +92,1 @@\n-        mac.update(data1);\n+        mac.update(data);\n@@ -74,2 +94,0 @@\n-\n-        System.out.println(\"All tests passed\");\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Mac\/ReinitMac.java","additions":35,"deletions":17,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 4856966 8080462\n+ * @bug 4856966 8080462 8242332\n@@ -39,0 +39,1 @@\n+import java.util.List;\n@@ -42,4 +43,0 @@\n-    static final String[] ALGS = {\n-        \"SHA-224\", \"SHA-256\", \"SHA-384\", \"SHA-512\", \"SHA-512\/224\", \"SHA-512\/256\"\n-    };\n-\n@@ -54,0 +51,3 @@\n+        List<String> ALGS = getSupportedAlgorithms(\"MessageDigest\",\n+                \"SHA\", p);\n+\n@@ -65,7 +65,1 @@\n-        MessageDigest md;\n-        try {\n-            md = MessageDigest.getInstance(alg, p);\n-        } catch (NoSuchAlgorithmException e) {\n-            System.out.println(\"Skip \" + alg + \" due to no support\");\n-            return;\n-        }\n+        MessageDigest md = MessageDigest.getInstance(alg, p);\n","filename":"test\/jdk\/sun\/security\/pkcs11\/MessageDigest\/ByteBuffers.java","additions":7,"deletions":13,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 4856966\n+ * @bug 4856966 8242332\n@@ -40,0 +40,1 @@\n+import java.util.List;\n@@ -49,4 +50,2 @@\n-        if (p.getService(\"MessageDigest\", \"MD5\") == null) {\n-            System.out.println(\"Provider does not support MD5, skipping\");\n-            return;\n-        }\n+        List<String> ALGS = getSupportedAlgorithms(\"MessageDigest\",\n+                \"SHA\", p);\n@@ -58,2 +57,22 @@\n-        MessageDigest md;\n-        md = MessageDigest.getInstance(\"MD5\", \"SUN\");\n+\n+        boolean success = true;\n+        for (String alg : ALGS) {\n+            try {\n+                doTest(alg, p, data1, data2);\n+            } catch (Exception e) {\n+                System.out.println(\"Unexpected exception: \" + e);\n+                e.printStackTrace();\n+                success = false;\n+            }\n+        }\n+\n+        if (!success) {\n+            throw new RuntimeException(\"Test failed\");\n+        }\n+        System.out.println(\"All tests passed\");\n+    }\n+\n+    private void doTest(String alg, Provider p, byte[] data1, byte[] data2)\n+            throws Exception {\n+        System.out.println(\"Testing \" + alg);\n+        MessageDigest md = MessageDigest.getInstance(alg, \"SUN\");\n@@ -61,1 +80,1 @@\n-        md = MessageDigest.getInstance(\"MD5\", p);\n+        md = MessageDigest.getInstance(alg, p);\n@@ -71,1 +90,0 @@\n-        System.out.println(\"All tests passed\");\n","filename":"test\/jdk\/sun\/security\/pkcs11\/MessageDigest\/ReinitDigest.java","additions":28,"deletions":10,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 6414899\n+ * @bug 6414899 8242332\n@@ -40,0 +40,1 @@\n+import java.util.List;\n@@ -43,4 +44,0 @@\n-    private static final String[] ALGOS = {\n-        \"MD2\", \"MD5\", \"SHA1\", \"SHA-224\", \"SHA-256\", \"SHA-384\", \"SHA-512\"\n-    };\n-\n@@ -54,1 +51,0 @@\n-\n@@ -57,0 +53,1 @@\n+        List<String> ALGS = getSupportedAlgorithms(\"MessageDigest\", \"SHA\", p);\n@@ -63,22 +60,7 @@\n-        for (int i = 0; i < ALGOS.length; i++) {\n-            if (p.getService(\"MessageDigest\", ALGOS[i]) == null) {\n-                System.out.println(ALGOS[i] + \" is not supported, skipping\");\n-                continue;\n-            } else {\n-                System.out.println(\"Testing \" + ALGOS[i] + \" of \" + p.getName());\n-                MessageDigest md = MessageDigest.getInstance(ALGOS[i], p);\n-                try {\n-                    md = testCloning(md, p);\n-                    \/\/ repeat the test again after generating digest once\n-                    for (int j = 0; j < 10; j++) {\n-                        md = testCloning(md, p);\n-                    }\n-                } catch (Exception ex) {\n-                    if (ALGOS[i] == \"MD2\" &&\n-                        p.getName().equalsIgnoreCase(\"SunPKCS11-NSS\")) {\n-                        \/\/ known bug in NSS; ignore for now\n-                        System.out.println(\"Ignore Known bug in MD2 of NSS\");\n-                        continue;\n-                    }\n-                    throw ex;\n-                }\n+        for (String alg : ALGS) {\n+            System.out.println(\"Testing \" + alg);\n+            MessageDigest md = MessageDigest.getInstance(alg, p);\n+            md = testCloning(md, p);\n+            \/\/ repeat the test again after generating digest once\n+            for (int j = 0; j < 10; j++) {\n+                md = testCloning(md, p);\n@@ -90,2 +72,1 @@\n-        throws Exception {\n-\n+            throws Exception {\n","filename":"test\/jdk\/sun\/security\/pkcs11\/MessageDigest\/TestCloning.java","additions":12,"deletions":31,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 4856966\n+ * @bug 4856966 8242332\n@@ -58,1 +58,1 @@\n-        kpg.initialize(512);\n+        kpg.initialize(2048);\n@@ -61,1 +61,1 @@\n-        Signature sig = Signature.getInstance(\"MD5withRSA\", p);\n+        Signature sig = Signature.getInstance(\"SHA256withRSA\", p);\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Signature\/ByteBuffers.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @bug 8080462\n+ * @bug 8080462 8242332\n@@ -41,0 +41,4 @@\n+        test(\"RSASSA-PSS\", p);\n+    }\n+\n+    private void test(String sigAlg, Provider p) throws Exception {\n@@ -43,1 +47,1 @@\n-            s1 = Signature.getInstance(\"RSASSA-PSS\", p);\n+            s1 = Signature.getInstance(sigAlg, p);\n@@ -45,1 +49,1 @@\n-            System.out.println(\"Skip testing RSASSA-PSS\" +\n+            System.out.println(\"Skip testing \" + sigAlg +\n@@ -52,1 +56,1 @@\n-        Signature s2 = Signature.getInstance(\"RSASSA-PSS\", p);\n+        Signature s2 = Signature.getInstance(sigAlg, p);\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Signature\/InitAgainPSS.java","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @bug 8080462 8226651\n+ * @bug 8080462 8226651 8242332\n@@ -58,0 +58,1 @@\n+\n@@ -69,0 +70,9 @@\n+        runTest(p, 1024, \"SHA3-256\", \"SHA3-256\");\n+        runTest(p, 1024, \"SHA3-256\", \"SHA3-384\");\n+        runTest(p, 1024, \"SHA3-256\", \"SHA3-512\");\n+        runTest(p, 1024, \"SHA3-384\", \"SHA3-256\");\n+        runTest(p, 1024, \"SHA3-384\", \"SHA3-384\");\n+        runTest(p, 1024, \"SHA3-384\", \"SHA3-512\");\n+        runTest(p, 1040, \"SHA3-512\", \"SHA3-256\");\n+        runTest(p, 1040, \"SHA3-512\", \"SHA3-384\");\n+        runTest(p, 1040, \"SHA3-512\", \"SHA3-512\");\n@@ -73,0 +83,11 @@\n+\n+        \/\/ skip further test if this provider does not support hashAlg or\n+        \/\/ mgfHashAlg\n+        try {\n+            MessageDigest.getInstance(hashAlg, p);\n+            MessageDigest.getInstance(mgfHashAlg, p);\n+        } catch (NoSuchAlgorithmException nsae) {\n+            System.out.println(\"No support for \" + hashAlg + \", skip\");\n+            return;\n+        }\n+\n@@ -98,0 +119,1 @@\n+\n@@ -111,0 +133,1 @@\n+\n@@ -113,0 +136,1 @@\n+\n@@ -124,0 +148,1 @@\n+\n@@ -136,0 +161,1 @@\n+\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Signature\/KeyAndParamCheckForPSS.java","additions":28,"deletions":2,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 4856966\n+ * @bug 4856966 8242332\n@@ -33,299 +33,0 @@\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n- * @run main ReinitSignature\n@@ -351,1 +52,1 @@\n-        kpg.initialize(512);\n+        kpg.initialize(2048);\n@@ -355,1 +56,1 @@\n-        Signature sig = Signature.getInstance(\"MD5withRSA\", p);\n+        Signature sig = Signature.getInstance(\"SHA256withRSA\", p);\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Signature\/ReinitSignature.java","additions":3,"deletions":302,"binary":false,"changes":305,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @bug 8080462 8226651\n+ * @bug 8080462 8226651 8242332\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Signature\/SigInteropPSS.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.security.*;\n+import java.security.spec.*;\n+import java.security.interfaces.*;\n+\n+\/*\n+ * @test\n+ * @bug 8080462 8226651 8242332\n+ * @summary testing interoperability of PSS signatures of PKCS11 provider\n+ *         against SunRsaSign provider\n+ * @library \/test\/lib ..\n+ * @modules jdk.crypto.cryptoki\n+ * @run main\/othervm SigInteropPSS2\n+ *\/\n+public class SigInteropPSS2 extends PKCS11Test {\n+\n+    private static final byte[] MSG =\n+        \"Interoperability test between SunRsaSign and SunPKCS11\".getBytes();\n+\n+    private static final String[] DIGESTS = {\n+        \"SHA224\", \"SHA256\", \"SHA384\", \"SHA512\",\n+        \"SHA3-224\", \"SHA3-256\", \"SHA3-384\", \"SHA3-512\"\n+    };\n+\n+    public static void main(String[] args) throws Exception {\n+        main(new SigInteropPSS2(), args);\n+    }\n+\n+    @Override\n+    public void main(Provider p) throws Exception {\n+\n+        Signature sigPkcs11;\n+        Signature sigSunRsaSign =\n+                Signature.getInstance(\"RSASSA-PSS\", \"SunRsaSign\");\n+\n+        KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"RSA\", p);\n+            kpg.initialize(3072);\n+        KeyPair kp = kpg.generateKeyPair();\n+\n+        for (String digest : DIGESTS) {\n+            try {\n+                sigPkcs11 = Signature.getInstance(digest + \"withRSASSA-PSS\", p);\n+            } catch (NoSuchAlgorithmException e) {\n+                System.out.println(\"Skip testing \" + digest + \"withRSASSA-PSS\" +\n+                    \" due to no support\");\n+                continue;\n+            }\n+\n+            runTest(sigPkcs11, sigSunRsaSign, kp);\n+        }\n+        System.out.println(\"Test passed\");\n+    }\n+\n+    static void runTest(Signature signer, Signature verifier, KeyPair kp)\n+            throws Exception {\n+        System.out.println(\"\\tSign: \" + signer.getProvider().getName());\n+        System.out.println(\"\\tVerify: \" + verifier.getProvider().getName());\n+\n+        signer.initSign(kp.getPrivate());\n+        signer.update(MSG);\n+        byte[] sigBytes = signer.sign();\n+\n+        AlgorithmParameters signParams = signer.getParameters();\n+        verifier.setParameter(signParams.getParameterSpec\n+                (PSSParameterSpec.class));\n+        verifier.initVerify(kp.getPublic());\n+\n+        verifier.update(MSG);\n+        boolean isValid = verifier.verify(sigBytes);\n+        if (isValid) {\n+            System.out.println(\"\\tPSS Signature verified\");\n+        } else {\n+            throw new RuntimeException(\"ERROR verifying PSS Signature\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Signature\/SigInteropPSS2.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @bug 8080462 8226651\n+ * @bug 8080462 8226651 8242332\n@@ -43,2 +43,4 @@\n-    private static final String[] DIGESTS = { \"SHA-224\", \"SHA-256\",\n-            \"SHA-384\" , \"SHA-512\" };\n+    private static final String[] DIGESTS = {\n+            \"SHA-224\", \"SHA-256\", \"SHA-384\" , \"SHA-512\",\n+            \"SHA3-224\", \"SHA3-256\", \"SHA3-384\" , \"SHA3-512\",\n+    };\n@@ -118,1 +120,16 @@\n-        System.out.println(\"Testing against \" + hash + \" and MGF1_\" + mgfHash);\n+\n+        String testName = hash + \" and MGF1_\" + mgfHash;\n+        \/\/ only test RSASSA-PSS signature against the supplied hash\/mgfHash\n+        \/\/ if they are supported; otherwise PKCS11 library will throw\n+        \/\/ CKR_MECHANISM_PARAM_INVALID at Signature.initXXX calls\n+        try {\n+            MessageDigest md = MessageDigest.getInstance(hash, prov);\n+            if (!hash.equalsIgnoreCase(mgfHash)) {\n+                md = MessageDigest.getInstance(mgfHash, prov);\n+            }\n+        } catch (NoSuchAlgorithmException nsae) {\n+            System.out.println(\"Skip testing \" + hash + \"\/\" + mgfHash);\n+            return;\n+        }\n+\n+        System.out.println(\"Testing against \" + testName);\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Signature\/SignatureTestPSS.java","additions":22,"deletions":5,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -0,0 +1,140 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+import java.security.*;\n+import java.security.interfaces.*;\n+import java.security.spec.*;\n+import java.util.stream.IntStream;\n+\n+\/**\n+ * @test\n+ * @bug 8244154 8242332\n+ * @summary Generate a <digest>withRSASSA-PSS signature and verify it using\n+ *         PKCS11 provider\n+ * @library \/test\/lib ..\n+ * @modules jdk.crypto.cryptoki\n+ * @run main SignatureTestPSS2\n+ *\/\n+public class SignatureTestPSS2 extends PKCS11Test {\n+\n+    \/\/ PKCS11 does not support RSASSA-PSS keys yet\n+    private static final String KEYALG = \"RSA\";\n+    private static final String[] SIGALGS = {\n+            \"SHA224withRSASSA-PSS\", \"SHA256withRSASSA-PSS\",\n+            \"SHA384withRSASSA-PSS\", \"SHA512withRSASSA-PSS\",\n+            \"SHA3-224withRSASSA-PSS\", \"SHA3-256withRSASSA-PSS\",\n+            \"SHA3-384withRSASSA-PSS\", \"SHA3-512withRSASSA-PSS\"\n+    };\n+\n+    private static final int[] KEYSIZES = { 2048, 3072 };\n+\n+    \/**\n+     * How much times signature updated.\n+     *\/\n+    private static final int UPDATE_TIMES = 2;\n+\n+    public static void main(String[] args) throws Exception {\n+        main(new SignatureTestPSS2(), args);\n+    }\n+\n+    @Override\n+    public void main(Provider p) throws Exception {\n+        for (String sa : SIGALGS) {\n+            Signature sig;\n+            try {\n+                sig = Signature.getInstance(sa, p);\n+            } catch (NoSuchAlgorithmException e) {\n+                System.out.println(\"Skip testing \" + sa +\n+                    \" due to no support\");\n+                return;\n+            }\n+            for (int i : KEYSIZES) {\n+                runTest(sig, i);\n+            }\n+        }\n+    }\n+\n+    private static void runTest(Signature s, int keySize) throws Exception {\n+        byte[] data = new byte[100];\n+        IntStream.range(0, data.length).forEach(j -> {\n+            data[j] = (byte) j;\n+        });\n+        System.out.println(\"[KEYSIZE = \" + keySize + \"]\");\n+\n+        \/\/ create a key pair\n+        KeyPair kpair = generateKeys(KEYALG, keySize, s.getProvider());\n+        test(s, kpair.getPrivate(), kpair.getPublic(), data);\n+    }\n+\n+    private static void test(Signature sig, PrivateKey privKey,\n+            PublicKey pubKey, byte[] data) throws RuntimeException {\n+        \/\/ For signature algorithm, create and verify a signature\n+        try {\n+            checkSignature(sig, privKey, pubKey, data);\n+        } catch (NoSuchAlgorithmException | InvalidKeyException |\n+                 SignatureException | NoSuchProviderException ex) {\n+            throw new RuntimeException(ex);\n+        } catch (InvalidAlgorithmParameterException ex2) {\n+            System.out.println(\"Skip test due to \" + ex2);\n+        }\n+    }\n+\n+    private static KeyPair generateKeys(String keyalg, int size, Provider p)\n+            throws NoSuchAlgorithmException {\n+        KeyPairGenerator kpg = KeyPairGenerator.getInstance(keyalg, p);\n+        kpg.initialize(size);\n+        return kpg.generateKeyPair();\n+    }\n+\n+    private static void checkSignature(Signature sig, PrivateKey priv,\n+            PublicKey pub, byte[] data) throws NoSuchAlgorithmException,\n+            InvalidKeyException, SignatureException, NoSuchProviderException,\n+            InvalidAlgorithmParameterException {\n+        System.out.println(\"Testing against \" + sig.getAlgorithm());\n+        sig.initSign(priv);\n+        for (int i = 0; i < UPDATE_TIMES; i++) {\n+            sig.update(data);\n+        }\n+        byte[] signedData = sig.sign();\n+\n+        \/\/ Make sure signature verifies with original data\n+        \/\/ do we need to call sig.setParameter(params) again?\n+        sig.initVerify(pub);\n+        for (int i = 0; i < UPDATE_TIMES; i++) {\n+            sig.update(data);\n+        }\n+        if (!sig.verify(signedData)) {\n+            throw new RuntimeException(\"Failed to verify signature\");\n+        }\n+\n+        \/\/ Make sure signature does NOT verify when the original data\n+        \/\/ has changed\n+        sig.initVerify(pub);\n+        for (int i = 0; i < UPDATE_TIMES + 1; i++) {\n+            sig.update(data);\n+        }\n+\n+        if (sig.verify(signedData)) {\n+            throw new RuntimeException(\"Failed to detect bad signature\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Signature\/SignatureTestPSS2.java","additions":140,"deletions":0,"binary":false,"changes":140,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n- * @bug 8080462\n+ * @bug 8080462 8242332\n@@ -43,2 +43,6 @@\n-        \/\/\"SHA384withDSA\",\n-        \/\/\"SHA512withDSA\",\n+        \"SHA3-224withDSA\",\n+        \"SHA3-256withDSA\",\n+        \"SHA384withDSA\",\n+        \"SHA512withDSA\",\n+        \"SHA3-384withDSA\",\n+        \"SHA3-512withDSA\",\n@@ -62,1 +66,0 @@\n-            ex.printStackTrace();\n@@ -66,0 +69,1 @@\n+        boolean allPass = true;\n@@ -67,1 +71,17 @@\n-            test(sigAlg, kp, p);\n+            System.out.println(\"Testing \" + sigAlg);\n+            try {\n+                Signature sig = Signature.getInstance(sigAlg, p);\n+                test(sig, kp, p);\n+            } catch (NoSuchAlgorithmException nsae) {\n+                System.out.println(\"=>Skip due to no support\");\n+            } catch (Exception ex) {\n+                System.out.println(\"Unexpected exception when testing \" +\n+                    sigAlg);\n+                ex.printStackTrace();\n+                allPass = false;\n+            }\n+        }\n+        if (allPass) {\n+            System.out.println(\"Tests Passed\");\n+        } else {\n+            throw new RuntimeException(\"One or more tests failed\");\n@@ -71,1 +91,1 @@\n-    private static void test(String sigAlg, KeyPair kp, Provider p)\n+    private static void test(Signature sig, KeyPair kp, Provider p)\n@@ -73,8 +93,0 @@\n-        Signature sig;\n-        try {\n-            sig = Signature.getInstance(sigAlg, p);\n-        } catch (Exception ex) {\n-            System.out.println(\"Skip due to no support: \" + sigAlg);\n-            ex.printStackTrace();\n-            return;\n-        }\n@@ -88,4 +100,5 @@\n-        sig.initVerify(kp.getPublic());\n-        sig.update(data);\n-        boolean verifies = sig.verify(signature);\n-        System.out.println(sigAlg + \": Passed\");\n+        Signature sigV = Signature.getInstance(sig.getAlgorithm() , p);\n+        sigV.initVerify(kp.getPublic());\n+        sigV.update(data);\n+        boolean verifies = sigV.verify(signature);\n+        System.out.println(\"=> Passed\");\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Signature\/TestDSA2.java","additions":32,"deletions":19,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -25,2 +25,2 @@\n- * @test %W% %E%\n- * @bug 6695485\n+ * @test\n+ * @bug 6695485 8242332\n@@ -53,3 +53,8 @@\n-        boolean isValidKeyLength[] = { true, true, true, false, false };\n-        String algos[] = { \"SHA1withRSA\", \"SHA224withRSA\", \"SHA256withRSA\",\n-                           \"SHA384withRSA\", \"SHA512withRSA\" };\n+        boolean isValidKeyLength[] = {\n+                true, true, true, false, false, true, true, false, false\n+        };\n+        String algos[] = {\n+                \"SHA1withRSA\", \"SHA224withRSA\", \"SHA256withRSA\",\n+                \"SHA384withRSA\", \"SHA512withRSA\", \"SHA3-224withRSA\",\n+                \"SHA3-256withRSA\", \"SHA3-384withRSA\", \"SHA3-512withRSA\"\n+        };\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Signature\/TestRSAKeyLength.java","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -14,2 +14,0 @@\n-# HMAC_SHA256\/384\/512 broken until NSS 3.10.2\n-# see https:\/\/bugzilla.mozilla.org\/show_bug.cgi?id=291858\n@@ -17,3 +15,16 @@\n-  CKM_SHA256_HMAC\n-  CKM_SHA384_HMAC\n-  CKM_SHA512_HMAC\n+  CKM_DSA_SHA224\n+  CKM_DSA_SHA256\n+  CKM_DSA_SHA384\n+  CKM_DSA_SHA512\n+  CKM_DSA_SHA3_224\n+  CKM_DSA_SHA3_256\n+  CKM_DSA_SHA3_384\n+  CKM_DSA_SHA3_512\n+  CKM_ECDSA_SHA224\n+  CKM_ECDSA_SHA256\n+  CKM_ECDSA_SHA384\n+  CKM_ECDSA_SHA512\n+  CKM_ECDSA_SHA3_224\n+  CKM_ECDSA_SHA3_256\n+  CKM_ECDSA_SHA3_384\n+  CKM_ECDSA_SHA3_512\n","filename":"test\/jdk\/sun\/security\/pkcs11\/nss\/p11-nss.txt","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"}]}