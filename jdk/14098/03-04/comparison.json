{"files":[{"patch":"@@ -116,1 +116,1 @@\n-     * but with no target layout\n+     * but with no target layout.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/AddressLayout.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -268,1 +268,1 @@\n-     * @throws WrongThreadException if this arena is confined, and this method is called from a thread {@code T}\n+     * @throws WrongThreadException if this arena is confined, and this method is called from a thread\n@@ -299,2 +299,2 @@\n-     * @throws WrongThreadException if this arena is confined, and this method is called from a thread {@code T}\n-     * other than the arena owner thread.\n+     * @throws WrongThreadException if this arena is confined, and this method is called from a thread\n+     * other than the arena's owner thread.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Arena.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n- * argument layouts and zero or one return layout. A function descriptor is used to create\n+ * argument layouts, and zero or one return layout. A function descriptor is used to create\n@@ -57,1 +57,1 @@\n-     * {@return the argument layouts of this function descriptor (as an immutable list)}.\n+     * {@return the argument layouts of this function descriptor (as an unmodifiable list)}.\n@@ -90,2 +90,1 @@\n-     * Returns a function descriptor with no return layout.\n-     * @return a new function descriptor, with no return layout.\n+     * {@return a new function descriptor, with no return layout}\n@@ -127,1 +126,1 @@\n-     * which return no values.\n+     * that return no values.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/FunctionDescriptor.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -201,1 +201,1 @@\n- * is supported by a native linker {@code NL} iff:\n+ * is supported by a native linker {@code NL} if:\n@@ -203,1 +203,2 @@\n- * <li>{@code L} is a value layout {@code V} and {@code V.withoutName()} is equal to one of the following layout constants:\n+ * <li>{@code L} is a value layout {@code V} and {@code V.withoutName()} is {@linkplain MemoryLayout#equals(Object) equal}\n+ * to one of the following layout constants:\n@@ -214,1 +215,2 @@\n- * <li>{@code L} is an address layout {@code A} and {@code A.withoutTargetLayout().withoutName()} is equal to {@link ValueLayout#ADDRESS}<\/li>\n+ * <li>{@code L} is an address layout {@code A} and {@code A.withoutTargetLayout().withoutName()} is\n+ * {@linkplain MemoryLayout#equals(Object) equal} to {@link ValueLayout#ADDRESS}<\/li>\n@@ -356,1 +358,1 @@\n- * Both these operations are accomplished using the restricted method {@link MemorySegment#reinterpret(long, Arena, Consumer)},\n+ * Both of these operations are accomplished using the restricted method {@link MemorySegment#reinterpret(long, Arena, Consumer)},\n@@ -444,1 +446,2 @@\n- * associated with the upcall stub to a type that is incompatible with the type of the upcall stub. Moreover, if the method\n+ * associated with the upcall stub to a type that is incompatible with the type of the upcall stub, and then attempts to\n+ * invoke the function through the resulting function pointer. Moreover, if the method\n@@ -473,1 +476,1 @@\n-     * Creates a method handle which is used to call a foreign function with the given signature and symbol.\n+     * Creates a method handle which is used to call a foreign function with the given signature and address.\n@@ -485,1 +488,2 @@\n-     * @param symbol   the symbol of the target foreign function.\n+     * @param address  the native memory segment whose {@linkplain MemorySegment#address() base address} is the\n+     *                 address of the target foreign function.\n@@ -490,1 +494,1 @@\n-     *                                  or if the symbol is {@link MemorySegment#NULL}\n+     * @throws IllegalArgumentException if {@code !address.isNative()}, or if {@code address.equals(MemorySegment.NULL)}.\n@@ -493,0 +497,2 @@\n+     *\n+     * @see SymbolLookup\n@@ -495,1 +501,1 @@\n-    MethodHandle downcallHandle(MemorySegment symbol, FunctionDescriptor function, Option... options);\n+    MethodHandle downcallHandle(MemorySegment address, FunctionDescriptor function, Option... options);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":15,"deletions":9,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n- * segment whose contents should be ignored, and which are primarily present for alignment reasons (see {@link MemoryLayout#paddingLayout(long)}).\n+ * segment whose contents should be ignored, and which are primarily present for alignment reasons.\n@@ -149,1 +149,1 @@\n- * an unspecified element in a sequence layout. A var handles derived from a layout path containing one or more\n+ * an unspecified element in a sequence layout. A var handle derived from a layout path containing one or more\n@@ -186,1 +186,1 @@\n-*                   )\n+*                  )\n@@ -216,1 +216,1 @@\n- * {@code C_i = f_i(C_i-1)}, where {@code f_i} is the selection function expressed the path element under consideration,\n+ * {@code C_i = f_i(C_i-1)}, where {@code f_i} is the selection function associated with the path element under consideration,\n@@ -219,1 +219,1 @@\n- * A layout path P is considered well-formed for an initial layout {@code C_0} if all its path elements\n+ * A layout path {@code P} is considered well-formed for an initial layout {@code C_0} if all its path elements\n@@ -256,2 +256,1 @@\n-     * Returns a memory layout of the same type with the same size and alignment constraint as this layout,\n-     * but with the specified name.\n+     * {@return a memory layout with the same characteristics as this layout, but with the given name}\n@@ -260,1 +259,0 @@\n-     * @return a memory layout with the same characteristics as this layout, but with the given name.\n@@ -266,2 +264,1 @@\n-     * Returns a memory layout of the same type with the same size and alignment constraint as this layout,\n-     * but without a name.\n+     * {@return a memory layout with the same characteristics as this layout, but with no name}\n@@ -270,2 +267,0 @@\n-     *\n-     * @return a memory layout with the same characteristics as this layout, but with no name.\n@@ -293,2 +288,2 @@\n-     * Returns a memory layout of the same type with the same size and name as this layout,\n-     * but with the specified alignment constraint (in bytes).\n+     * {@return a memory layout with the same characteristics as this layout, but with the given\n+     * alignment constraint (in bytes)}\n@@ -297,1 +292,0 @@\n-     * @return a memory layout with the same characteristics of this layout, but with the given alignment constraint.\n@@ -324,3 +318,1 @@\n-     *     <li>it has a leading parameter of type {@code MemorySegment}, corresponding to the memory segment\n-     *     to be accessed;<\/li>\n-     *     <li>it has as many parameters of type {@code long}, one for each <a href=#open-path-elements>open path elements<\/a>\n+     *     <li>it has as zero or more parameters of type {@code long}, one for each <a href=#open-path-elements>open path element<\/a>\n@@ -363,2 +355,2 @@\n-     *     <li>it has as many access coordinates of type {@code long}, one for each\n-     *     <a href=#open-path-elements>open path elements<\/a> in the provided layout path. The order of these access\n+     *     <li>it has as zero or more access coordinates of type {@code long}, one for each\n+     *     <a href=#open-path-elements>open path element<\/a> in the provided layout path. The order of these access\n@@ -392,3 +384,3 @@\n-     * Multiple paths can be chained, by using <a href=#deref-path-elements>dereference path elements<\/a>.\n-     * A dereference path element allows to obtain a native memory segment whose base address is the address value\n-     * obtained by accessing a memory segment at the offset determined by the layout path elements immediately preceding\n+     * Multiple paths can be chained, with <a href=#deref-path-elements>dereference path elements<\/a>.\n+     * A dereference path element constructs a fresh native memory segment whose base address is the address value\n+     * read obtained by accessing a memory segment at the offset determined by the layout path elements immediately preceding\n@@ -436,2 +428,2 @@\n-     *     to be accessed;<\/li>\n-     *     <li>it has as many parameters of type {@code long}, one for each <a href=#open-path-elements>open path elements<\/a>\n+     *     to be sliced;<\/li>\n+     *     <li>it has as zero or more parameters of type {@code long}, one for each <a href=#open-path-elements>open path element<\/a>\n@@ -499,1 +491,1 @@\n-     * Sequence path elements selecting more than a sequence element layout are called\n+     * Sequence path elements selecting more than one sequence element layout are called\n@@ -644,1 +636,1 @@\n-     * alignment constraint, a padding layout does not affect the alignment constraint of the group or sequence layout\n+     * alignment constraint, a padding layout does not affect the natural alignment of the group or sequence layout\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryLayout.java","additions":19,"deletions":27,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -936,8 +936,10 @@\n-     * the properties of this segment. For instance, if this segment is a {@linkplain #isReadOnly() read-only segment},\n-     * then the resulting buffer is also {@linkplain ByteBuffer#isReadOnly() read-only}. Additionally, if this is a native\n-     * segment, the resulting buffer is a {@linkplain ByteBuffer#isDirect() direct buffer}.\n-     * <p>\n-     * The returned buffer's {@linkplain ByteBuffer#position() position} is set to zero, while\n-     * the returned buffer's {@linkplain ByteBuffer#capacity() capacity} and {@linkplain ByteBuffer#limit() limit}\n-     * are both set to this segment' {@linkplain MemorySegment#byteSize() size}. For this reason, a byte buffer cannot be\n-     * returned if this segment' size is greater than {@link Integer#MAX_VALUE}.\n+     * the properties of this segment. More specifically, the resulting buffer has the following characteristics:\n+     * <ul>\n+     * <li>It is {@linkplain ByteBuffer#isReadOnly() read-only}, if this segment is a\n+     * {@linkplain #isReadOnly() read-only segment};<\/li>\n+     * <li>Its {@linkplain ByteBuffer#position() position} is set to zero;\n+     * <li>Its {@linkplain ByteBuffer#capacity() capacity} and {@linkplain ByteBuffer#limit() limit}\n+     * are both set to this segment' {@linkplain MemorySegment#byteSize() size}. For this reason, a byte buffer\n+     * cannot be returned if this segment's size is greater than {@link Integer#MAX_VALUE};<\/li>\n+     * <li>It is a {@linkplain ByteBuffer#isDirect() direct buffer}, if this is a native segment.<\/li>\n+     * <\/ul>\n@@ -951,1 +953,1 @@\n-     * operations on the resulting buffer might result in an unspecified exceptions being thrown. Examples of such problematic operations are\n+     * operations on the resulting buffer might result in unspecified exceptions being thrown. Examples of such problematic operations are\n@@ -2196,1 +2198,0 @@\n-     * @throws UnsupportedOperationException if {@code srcSegment} is {@linkplain #isReadOnly() read-only}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -65,4 +65,7 @@\n- * @apiNote A segment allocator does not impose any constraint on the lifetime of the segments returned by its\n- * {@link #allocate(long, long)} method. Clients requiring allocation of multiple segments featuring the same\n- * lifetime should use an {@linkplain Arena arena} instead, which, in addition to allocation, also provides\n- * <em>timely deallocation<\/em>.\n+ * @apiNote Unless otherwise specified, the {@link #allocate(long, long)} method is not thread-safe.\n+ * Furthermore, memory segments allocated by a segment allocator can be associated with different\n+ * lifetimes, and can even be backed by overlapping regions of memory. For these reasons, clients should generally\n+ * only interact with a segment allocator they own.\n+ * <p>\n+ * Clients should consider using an {@linkplain Arena arena} instead, which, provides strong thread-safety,\n+ * lifetime and non-overlapping guarantees.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SegmentAllocator.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -70,2 +70,1 @@\n-     * Returns a sequence layout with the same element layout, alignment constraint and name as this sequence layout,\n-     * but with the specified element count.\n+     * {@return a sequence layout with the same characteristics of this layout, but with the given element count}\n@@ -73,1 +72,0 @@\n-     * @return a sequence layout with the same characteristics of this layout, but with the given element count.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SequenceLayout.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n- *     {@link MemorySegment#reinterpret(long) resizing} the segment first).<\/li>\n+ *     {@linkplain MemorySegment#reinterpret(long) resizing} the segment first).<\/li>\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SymbolLookup.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -67,2 +67,1 @@\n-     * Returns a value layout with the same carrier, alignment constraint and name as this value layout,\n-     * but with the specified byte order.\n+     * {@return a value layout with the same characteristics as this layout, but with the given byte order}\n@@ -71,1 +70,0 @@\n-     * @return a value layout with the same characteristics as this layout, but with the given byte order.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/ValueLayout.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -125,0 +125,1 @@\n+    @Test\n","filename":"test\/jdk\/java\/foreign\/TestLayoutPaths.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -92,1 +92,0 @@\n-            \/\/ check failure with read-only dest\n","filename":"test\/jdk\/java\/foreign\/TestSegmentCopy.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}