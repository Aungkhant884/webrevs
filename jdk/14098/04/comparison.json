{"files":[{"patch":"@@ -40,1 +40,1 @@\n- * {@code MemorySegment.class}. The size and alignment of an address layout are platform dependent\n+ * {@code MemorySegment.class}. The size and alignment of an address layout are platform-dependent\n@@ -116,3 +116,3 @@\n-     * but without any specified target layout.\n-     * <p>\n-     * This can be useful to compare two address layouts that have different target layouts, but are otherwise equal.\n+     * but with no target layout.\n+     *\n+     * @apiNote This can be useful to compare two address layouts that have different target layouts, but are otherwise equal.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/AddressLayout.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n- * <em>after<\/em> the automatic arena (and all the segments allocated by it) become\n+ * <em>after<\/em> the automatic arena (and all the segments allocated by it) becomes\n@@ -205,1 +205,1 @@\n-     * Segments obtained with the returned arena can be\n+     * Segments allocated with the returned arena can be\n@@ -216,1 +216,1 @@\n-     * Obtains the global arena. Segments obtained with the global arena can be\n+     * Obtains the global arena. Segments allocated with the global arena can be\n@@ -230,1 +230,3 @@\n-     * {@return a new confined arena, owned by the current thread}\n+     * {@return a new confined arena} Segments allocated with the confined arena can be\n+     * {@linkplain MemorySegment#isAccessibleBy(Thread) accessed} by the thread that created the arena,\n+     * the arena's <em>owner thread<\/em>.\n@@ -237,1 +239,2 @@\n-     * {@return a new shared arena}\n+     * {@return a new shared arena} Segments allocated with the global arena can be\n+     * {@linkplain MemorySegment#isAccessibleBy(Thread) accessed} by any thread.\n@@ -247,1 +250,1 @@\n-     * allocated off-heap memory region backing the segment, and the address is\n+     * allocated off-heap region of memory backing the segment, and the address is\n@@ -259,1 +262,1 @@\n-     * @param byteSize the size (in bytes) of the off-heap memory block backing the native memory segment.\n+     * @param byteSize the size (in bytes) of the off-heap region of memory backing the native memory segment.\n@@ -262,1 +265,1 @@\n-     * @throws IllegalArgumentException if {@code bytesSize < 0}, {@code alignmentBytes <= 0}, or if {@code alignmentBytes}\n+     * @throws IllegalArgumentException if {@code bytesSize < 0}, {@code byteAlignment <= 0}, or if {@code byteAlignment}\n@@ -265,2 +268,2 @@\n-     * @throws WrongThreadException if this arena is confined, and this method is called from a thread {@code T}\n-     * other than the arena owner thread.\n+     * @throws WrongThreadException if this arena is confined, and this method is called from a thread\n+     * other than the arena's owner thread.\n@@ -296,3 +299,3 @@\n-     * @throws WrongThreadException if this arena is confined, and this method is called from a thread {@code T}\n-     * other than the arena owner thread.\n-     * @throws UnsupportedOperationException if this arena does not support explicit closure.\n+     * @throws WrongThreadException if this arena is confined, and this method is called from a thread\n+     * other than the arena's owner thread.\n+     * @throws UnsupportedOperationException if this arena cannot be closed explicitly.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Arena.java","additions":16,"deletions":13,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -37,3 +37,3 @@\n- * A function descriptor models the signature of foreign functions. A function descriptor is made up of zero or more\n- * argument layouts and zero or one return layout. A function descriptor is typically used when creating\n- * {@linkplain Linker#downcallHandle(MemorySegment, FunctionDescriptor, Linker.Option...) downcall method handles} or\n+ * A function descriptor models the signature of a foreign function. A function descriptor is made up of zero or more\n+ * argument layouts, and zero or one return layout. A function descriptor is used to create\n+ * {@linkplain Linker#downcallHandle(MemorySegment, FunctionDescriptor, Linker.Option...) downcall method handles} and\n@@ -52,1 +52,1 @@\n-     * {@return the return layout (if any) associated with this function descriptor}\n+     * {@return the return layout (if any) of this function descriptor}\n@@ -57,1 +57,1 @@\n-     * {@return the argument layouts associated with this function descriptor (as an immutable list)}.\n+     * {@return the argument layouts of this function descriptor (as an unmodifiable list)}.\n@@ -62,1 +62,1 @@\n-     * Returns a function descriptor with the given argument layouts appended to the argument layout array\n+     * Returns a function descriptor with the given argument layouts appended to the argument layouts\n@@ -66,1 +66,1 @@\n-     * @return the new function descriptor.\n+     * @return a new function descriptor, with the provided additional argument layouts.\n@@ -75,1 +75,1 @@\n-     * @return the new function descriptor.\n+     * @return a new function descriptor, with the provided additional argument layouts.\n@@ -82,1 +82,1 @@\n-     * Returns a function descriptor with the given memory layout as the new return layout.\n+     * Returns a function descriptor with the provided return layout.\n@@ -85,1 +85,1 @@\n-     * @return the new function descriptor.\n+     * @return a new function descriptor, with the provided return layout.\n@@ -90,3 +90,1 @@\n-     * Returns a function descriptor with the return layout dropped. This is useful to model functions\n-     * which return no values.\n-     * @return the new function descriptor.\n+     * {@return a new function descriptor, with no return layout}\n@@ -99,1 +97,1 @@\n-     * The carrier type of a layout is determined as follows:\n+     * The carrier type of a layout {@code L} is determined as follows:\n@@ -101,2 +99,2 @@\n-     * <li>If the layout is a {@link ValueLayout} the carrier type is determined through {@link ValueLayout#carrier()}.<\/li>\n-     * <li>If the layout is a {@link GroupLayout} or a {@link SequenceLayout}, the carrier type is {@link MemorySegment}.<\/li>\n+     * <li>If {@code L} is a {@link ValueLayout} the carrier type is determined through {@link ValueLayout#carrier()}.<\/li>\n+     * <li>If {@code L} is a {@link GroupLayout} or a {@link SequenceLayout}, the carrier type is {@link MemorySegment}.<\/li>\n@@ -108,3 +106,1 @@\n-     * @return the method type consisting of the carrier types of the layouts in this function descriptor\n-     * @throws IllegalArgumentException if one or more layouts in the function descriptor can not be mapped to carrier\n-     *                                  types (e.g. if they are sequence layouts or padding layouts).\n+     * @return the method type consisting of the carrier types of the layouts in this function descriptor.\n@@ -120,1 +116,1 @@\n-     * @return the new function descriptor.\n+     * @return a new function descriptor with the provided return and argument layouts.\n@@ -129,1 +125,2 @@\n-     * Creates a function descriptor with the given argument layouts and no return layout.\n+     * Creates a function descriptor with the given argument layouts and no return layout.  This is useful to model functions\n+     * that return no values.\n@@ -132,1 +129,1 @@\n-     * @return the new function descriptor.\n+     * @return a new function descriptor with the provided argument layouts.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/FunctionDescriptor.java","additions":19,"deletions":22,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -32,4 +32,4 @@\n- * A compound layout that aggregates multiple <em>member layouts<\/em>. There are two ways in which member layouts\n- * can be combined: if member layouts are laid out one after the other, the resulting group layout is said to be a <em>struct layout<\/em>\n- * (see {@link MemoryLayout#structLayout(MemoryLayout...)}); conversely, if all member layouts are laid out at the same starting offset,\n- * the resulting group layout is said to be a <em>union layout<\/em> (see {@link MemoryLayout#unionLayout(MemoryLayout...)}).\n+ * A compound layout that is an aggregation of multiple, heterogeneous <em>member layouts<\/em>. There are two ways in which member layouts\n+ * can be combined: if member layouts are laid out one after the other, the resulting group layout is a\n+ * {@linkplain StructLayout struct layout}; conversely, if all member layouts are laid out at the same starting offset,\n+ * the resulting group layout is a {@linkplain UnionLayout union layout}.\n@@ -46,1 +46,1 @@\n-     * Returns the member layouts associated with this group.\n+     * {@return the member layouts of this group layout}\n@@ -51,2 +51,0 @@\n-     *\n-     * @return the member layouts associated with this group.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/GroupLayout.java","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -200,2 +200,24 @@\n- * All the native linker implementations limit the function descriptors that they support to those that contain\n- * only so-called <em>canonical<\/em> layouts. A canonical layout has the following characteristics:\n+ * All native linker implementations operate on a subset of memory layouts. More formally, a layout {@code L}\n+ * is supported by a native linker {@code NL} if:\n+ * <ul>\n+ * <li>{@code L} is a value layout {@code V} and {@code V.withoutName()} is {@linkplain MemoryLayout#equals(Object) equal}\n+ * to one of the following layout constants:\n+ * <ul>\n+ * <li>{@link ValueLayout#JAVA_BOOLEAN}<\/li>\n+ * <li>{@link ValueLayout#JAVA_BYTE}<\/li>\n+ * <li>{@link ValueLayout#JAVA_CHAR}<\/li>\n+ * <li>{@link ValueLayout#JAVA_SHORT}<\/li>\n+ * <li>{@link ValueLayout#JAVA_INT}<\/li>\n+ * <li>{@link ValueLayout#JAVA_LONG}<\/li>\n+ * <li>{@link ValueLayout#JAVA_FLOAT}<\/li>\n+ * <li>{@link ValueLayout#JAVA_DOUBLE}<\/li>\n+ * <\/ul><\/li>\n+ * <li>{@code L} is an address layout {@code A} and {@code A.withoutTargetLayout().withoutName()} is\n+ * {@linkplain MemoryLayout#equals(Object) equal} to {@link ValueLayout#ADDRESS}<\/li>\n+ * <li>{@code L} is a sequence layout {@code S} and all the following conditions hold:\n+ * <ol>\n+ * <li>the alignment constraint of {@code S} is set to its <a href=\"MemoryLayout.html#layout-align\">natural alignment<\/a>, and<\/li>\n+ * <li>{@code S.elementLayout()} is a layout supported by {@code NL}.<\/li>\n+ * <\/ol>\n+ * <\/li>\n+ * <li>{@code L} is a group layout {@code G} and all the following conditions hold:\n@@ -203,6 +225,4 @@\n- * <li>Its alignment constraint is set to its <a href=\"MemoryLayout.html#layout-align\">natural alignment<\/a><\/li>\n- * <li>If it is a {@linkplain ValueLayout value layout}, its {@linkplain ValueLayout#order() byte order} is\n- * the {@linkplain ByteOrder#nativeOrder() native byte order}.\n- * <li>If it is a {@linkplain GroupLayout group layout}, its size is a multiple of its alignment constraint, and<\/li>\n- * <li>It does not contain padding other than what is strictly required to align its non-padding layout elements,\n- * or to satisfy constraint 3<\/li>\n+ * <li>the alignment constraint of {@code G} is set to its <a href=\"MemoryLayout.html#layout-align\">natural alignment<\/a>;<\/li>\n+ * <li>the size of {@code G} is a multiple of its alignment constraint;<\/li>\n+ * <li>each member layout in {@code G.memberLayouts()} is either a padding layout or a layout supported by {@code NL}, and<\/li>\n+ * <li>{@code G} does not contain padding other than what is strictly required to align its non-padding layout elements, or to satisfy (2).<\/li>\n@@ -210,0 +230,5 @@\n+ * <\/li>\n+ * <\/ul>\n+ *\n+ * A native linker only supports function descriptors whose argument\/return layouts are layouts supported by that linker\n+ * and are not sequence layouts.\n@@ -320,2 +345,2 @@\n- * When interacting with a native functions returning a pointer (such as {@code malloc}), the Java runtime has no insight\n- * into the size or the lifetime of the returned pointer. Consider the following code:\n+ * When a native function returning a pointer (such as {@code malloc}) is invoked using a downcall method handle,\n+ * the Java runtime has no insight into the size or the lifetime of the returned pointer. Consider the following code:\n@@ -333,2 +358,2 @@\n- * Both these operations are accomplished using the restricted {@link MemorySegment#reinterpret(long, Arena, Consumer)}\n- * method, as follows:\n+ * Both of these operations are accomplished using the restricted method {@link MemorySegment#reinterpret(long, Arena, Consumer)},\n+ * as follows:\n@@ -388,6 +413,6 @@\n- * describes the specialized signature of the C function we want to call. This descriptor must include layouts for any\n- * additional variadic argument we intend to provide. In this case, the specialized signature of the C\n- * function is {@code (char*, int, int, int)} as the format string accepts three integer parameters. Then, we need to use\n- * a linker option to specify the position of the first variadic layout in the provided function descriptor (starting from 0).\n- * In this case, since the first parameter is the format string (a non-variadic argument), the first variadic index\n- * needs to be set to 1, as follows:\n+ * describes the specialized signature of the C function we want to call. This descriptor must include an additional layout\n+ * for each variadic argument we intend to provide. In this case, the specialized signature of the C\n+ * function is {@code (char*, int, int, int)} as the format string accepts three integer parameters. We then need to use\n+ * a {@linkplain Linker.Option#firstVariadicArg(int) linker option} to specify the position of the first variadic layout\n+ * in the provided function descriptor (starting from 0). In this case, since the first parameter is the format string\n+ * (a non-variadic argument), the first variadic index needs to be set to 1, as follows:\n@@ -420,4 +445,3 @@\n- * When creating upcall stubs the linker runtime validates the type of the target method handle against the provided\n- * function descriptor and report an error if any mismatch is detected. As for downcalls, JVM crashes might occur,\n- * if the foreign code casts the function pointer associated with an upcall stub to a type\n- * that is incompatible with the provided function descriptor. Moreover, if the target method\n+ * When an upcall stub is passed to a foreign function, a JVM crash might occur, if the foreign code casts the function pointer\n+ * associated with the upcall stub to a type that is incompatible with the type of the upcall stub, and then attempts to\n+ * invoke the function through the resulting function pointer. Moreover, if the method\n@@ -437,1 +461,1 @@\n-     * Returns a linker for the ABI associated with the underlying native platform. The underlying native platform\n+     * {@return a linker for the ABI associated with the underlying native platform} The underlying native platform\n@@ -445,1 +469,0 @@\n-     * @return a linker for the ABI associated with the underlying native platform.\n@@ -465,4 +488,5 @@\n-     * @param symbol   the address of the target function.\n-     * @param function the function descriptor of the target function.\n-     * @param options  any linker options.\n-     * @return a downcall method handle. The method handle type is <a href=\"Linker.html#downcall-method-handles\"><em>inferred<\/em><\/a>\n+     * @param address  the native memory segment whose {@linkplain MemorySegment#address() base address} is the\n+     *                 address of the target foreign function.\n+     * @param function the function descriptor of the target foreign function.\n+     * @param options  the linker options associated with this linkage request.\n+     * @return a downcall method handle.\n@@ -470,1 +494,1 @@\n-     *                                  or if the symbol is {@link MemorySegment#NULL}\n+     * @throws IllegalArgumentException if {@code !address.isNative()}, or if {@code address.equals(MemorySegment.NULL)}.\n@@ -473,0 +497,2 @@\n+     *\n+     * @see SymbolLookup\n@@ -475,1 +501,1 @@\n-    MethodHandle downcallHandle(MemorySegment symbol, FunctionDescriptor function, Option... options);\n+    MethodHandle downcallHandle(MemorySegment address, FunctionDescriptor function, Option... options);\n@@ -487,1 +513,1 @@\n-     * Upon invoking a downcall method handle, the linker runtime will guarantee the following for any argument\n+     * Upon invoking a downcall method handle, the linker provides the following guarantees for any argument\n@@ -494,2 +520,2 @@\n-     *     {@linkplain Arena#ofShared()} shared arena}, any attempt to {@linkplain Arena#close() close}\n-     *     the shared arena while the downcall method handle is executing will result in an {@link IllegalStateException}.<\/li>\n+     *     {@linkplain Arena#ofShared() shared arena}, any attempt to {@linkplain Arena#close() close}\n+     *     the arena while the downcall method handle is still executing will result in an {@link IllegalStateException}.<\/li>\n@@ -501,2 +527,2 @@\n-     * However, if the function descriptor's return layout has a {@linkplain AddressLayout#targetLayout()} {@code T},\n-     * then the size of the returned segment is set to {@code T.byteSize()}.\n+     * However, if the function descriptor's return layout has a {@linkplain AddressLayout#targetLayout() target layout}\n+     * {@code T}, then the size of the returned segment is set to {@code T.byteSize()}.\n@@ -513,4 +539,3 @@\n-     * @param function the function descriptor of the target function.\n-     * @param options  any linker options.\n-     * @return a downcall method handle. The method handle type is <a href=\"Linker.html#downcall-method-handles\"><em>inferred<\/em><\/a>\n-     * from the provided function descriptor.\n+     * @param function the function descriptor of the target foreign function.\n+     * @param options  the linker options associated with this linkage request.\n+     * @return a downcall method handle.\n@@ -525,1 +550,1 @@\n-     * Creates a stub which can be passed to other foreign functions as a function pointer, associated with the given\n+     * Creates an upcall stub which can be passed to other foreign functions as a function pointer, associated with the given\n@@ -537,1 +562,1 @@\n-     * However, if the address layout has a {@linkplain AddressLayout#targetLayout()} {@code T}, then the size of the\n+     * However, if the address layout has a {@linkplain AddressLayout#targetLayout() target layout} {@code T}, then the size of the\n@@ -541,4 +566,4 @@\n-     * the VM will exit with a non-zero exit code. To avoid the VM aborting due to an uncaught exception, clients\n-     * could wrap all code in the target method handle in a try\/catch block that catches any {@link Throwable}, for\n-     * instance by using the {@link java.lang.invoke.MethodHandles#catchException(MethodHandle, Class, MethodHandle)}\n-     * method handle combinator, and handle exceptions as desired in the corresponding catch block.\n+     * the JVM will terminate abruptly. To avoid this, clients should wrap the code in the target method handle in a\n+     * try\/catch block to catch any unexpected exceptions. This can be done using the\n+     * {@link java.lang.invoke.MethodHandles#catchException(MethodHandle, Class, MethodHandle)} method handle combinator,\n+     * and handle exceptions as desired in the corresponding catch block.\n@@ -554,1 +579,1 @@\n-     * @param options  any linker options.\n+     * @param options  the linker options associated with this linkage request.\n@@ -557,2 +582,3 @@\n-     * @throws IllegalArgumentException if it is determined that the target method handle can throw an exception, or if the target method handle\n-     * has a type that does not match the upcall stub <a href=\"Linker.html#upcall-stubs\"><em>inferred type<\/em><\/a>.\n+     * @throws IllegalArgumentException if the type of {@code target} is incompatible with the\n+     * type {@linkplain FunctionDescriptor#toMethodType() derived} from {@code function}.\n+     * @throws IllegalArgumentException if it is determined that the target method handle can throw an exception.\n@@ -583,2 +609,1 @@\n-     * A linker option is used to indicate additional linking requirements to the linker,\n-     * besides what is described by a function descriptor.\n+     * A linker option is used to provide additional parameters to a linkage request.\n@@ -592,3 +617,4 @@\n-         * {@return a linker option used to denote the index of the first variadic argument layout in a\n-         *          foreign function call}\n-         * @param index the index of the first variadic argument in a downcall handle linkage request.\n+         * {@return a linker option used to denote the index of the first variadic argument layout in the\n+         *          function descriptor associated with a downcall linkage request}\n+         * @param index the index of the first variadic argument layout in the function descriptor associated\n+         *              with a downcall linkage request.\n@@ -610,1 +636,1 @@\n-         * This parameter, called the 'capture state segment', represents the native segment into which\n+         * This parameter, the <em>capture state segment<\/em>, represents the native segment into which\n@@ -613,2 +639,3 @@\n-         * The capture state segment should have the layout returned by {@linkplain #captureStateLayout}.\n-         * This layout is a struct layout which has a named field for each captured value.\n+         * The capture state segment must have size and alignment compatible with the layout returned by\n+         * {@linkplain #captureStateLayout}. This layout is a struct layout which has a named field for\n+         * each captured value.\n@@ -650,1 +677,1 @@\n-         *          to a downcall handle linked with {@link #captureCallState(String...)}}.\n+         *          to a downcall handle linked with {@link #captureCallState(String...)}}\n@@ -652,1 +679,1 @@\n-         * The capture state layout is <em>platform dependent<\/em> but is guaranteed to be\n+         * The capture state layout is <em>platform-dependent<\/em> but is guaranteed to be\n@@ -661,1 +688,2 @@\n-         * The following snipet shows how to obtain the names of the supported captured value layouts:\n+         * <p>\n+         * Clients can obtain the names of the supported captured value layouts as follows:\n@@ -663,1 +691,1 @@\n-         *    String capturedNames = Linker.Option.captureStateLayout().memberLayouts().stream()\n+         *    List<String> capturedNames = Linker.Option.captureStateLayout().memberLayouts().stream()\n@@ -666,2 +694,1 @@\n-         *        .map(Objects::toString)\n-         *        .collect(Collectors.joining(\", \"));\n+         *        .toList();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":89,"deletions":62,"binary":false,"changes":151,"status":"modified"},{"patch":"@@ -51,4 +51,0 @@\n- * There are two leaves in the layout hierarchy, <em>value layouts<\/em>, which are used to represent values of given size and kind (see\n- * {@link ValueLayout}) and <em>padding layouts<\/em> which are used, as the name suggests, to represent a portion of a memory\n- * segment whose contents should be ignored, and which are primarily present for alignment reasons (see {@link MemoryLayout#paddingLayout(long)}).\n- * Some common value layout constants are defined in the {@link ValueLayout} class.\n@@ -56,3 +52,12 @@\n- * More complex layouts can be derived from simpler ones: a <em>sequence layout<\/em> denotes a repetition of one or more\n- * element layout (see {@link SequenceLayout}); a <em>group layout<\/em> denotes an aggregation of (typically) heterogeneous\n- * member layouts (see {@link GroupLayout}).\n+ * There are two leaves in the layout hierarchy, {@linkplain ValueLayout value layouts}, which are used to represent values of given size and kind (see\n+ * and {@linkplain PaddingLayout padding layouts} which are used, as the name suggests, to represent a portion of a memory\n+ * segment whose contents should be ignored, and which are primarily present for alignment reasons.\n+ * Some common value layout constants, such as {@link ValueLayout#JAVA_INT} and {@link ValueLayout#JAVA_FLOAT_UNALIGNED}\n+ * are defined in the {@link ValueLayout} class. A special kind of value layout, namely an {@linkplain AddressLayout address layout},\n+ * is used to model values that denote the address of a region of memory.\n+ * <p>\n+ * More complex layouts can be derived from simpler ones: a {@linkplain SequenceLayout sequence layout} denotes a\n+ * homogeneous repetition of zero or more occurrences of an element layout; a {@linkplain GroupLayout group layout}\n+ * denotes a heterogeneous aggregation of zero or more member layouts. Group layouts come in two\n+ * flavors: {@linkplain StructLayout struct layouts}, where member layouts are laid out one after the other, and\n+ * {@linkplain UnionLayout union layouts} where member layouts are laid out at the same starting offset.\n@@ -84,1 +89,1 @@\n- * <h2 id=\"layout-align\">Size, alignment and byte order<\/h2>\n+ * <h2 id=\"layout-align\">Characteristics of memory layouts<\/h2>\n@@ -86,3 +91,1 @@\n- * All layouts have a size; layout size for value and padding layouts is always explicitly denoted; this means that a layout description\n- * always has the same size in bytes, regardless of the platform in which it is used. For derived layouts, the size is computed\n- * as follows:\n+ * All layouts have a <em>size<\/em> (expressed in bytes), which is defined as follows:\n@@ -90,5 +93,12 @@\n- *     <li>for a sequence layout <em>S<\/em> whose element layout is <em>E<\/em> and size is <em>L<\/em>,\n- *     the size of <em>S<\/em> is that of <em>E<\/em>, multiplied by <em>L<\/em><\/li>\n- *     <li>for a group layout <em>G<\/em> with member layouts <em>M1<\/em>, <em>M2<\/em>, ... <em>Mn<\/em> whose sizes are\n- *     <em>S1<\/em>, <em>S2<\/em>, ... <em>Sn<\/em>, respectively, the size of <em>G<\/em> is either <em>S1 + S2 + ... + Sn<\/em> or\n- *     <em>max(S1, S2, ... Sn)<\/em> depending on whether the group is a <em>struct<\/em> or an <em>union<\/em>, respectively<\/li>\n+ *     <li>The size of a value layout is determined by the {@linkplain ValueLayout#carrier()}\n+ *     associated with the value layout. That is, the constant {@link ValueLayout#JAVA_INT} has carrier {@code int}, and\n+ *     size of 4 bytes;<\/li>\n+ *     <li>The size of an address layout is platform-dependent. That is, the constant {@link ValueLayout#ADDRESS}\n+ *     has size of 8 bytes on a 64-bit platform;<\/li>\n+ *     <li>The size of a padding layout is always provided explicitly, on {@linkplain MemoryLayout#paddingLayout(long) construction};<\/li>\n+ *     <li>The size of a sequence layout whose element layout is <em>E<\/em> and element count is <em>L<\/em>,\n+ *     is the size of <em>E<\/em>, multiplied by <em>L<\/em>;<\/li>\n+ *     <li>The size of a struct layout with member layouts <em>M1<\/em>, <em>M2<\/em>, ... <em>Mn<\/em> whose sizes are\n+ *     <em>S1<\/em>, <em>S2<\/em>, ... <em>Sn<\/em>, respectively, is <em>S1 + S2 + ... + Sn<\/em>;<\/li>\n+ *     <li>The size of a union layout <em>U<\/em> with member layouts <em>M1<\/em>, <em>M2<\/em>, ... <em>Mn<\/em> whose sizes are\n+ *     <em>S1<\/em>, <em>S2<\/em>, ... <em>Sn<\/em>, respectively, is <em>max(S1, S2, ... Sn).<\/em><\/li>\n@@ -97,1 +107,1 @@\n- * Furthermore, all layouts feature a <em>natural alignment<\/em> which can be inferred as follows:\n+ * Furthermore, all layouts have a <em>natural alignment<\/em> (expressed in bytes) which is defined as follows:\n@@ -99,7 +109,5 @@\n- *     <li>for a padding layout <em>L<\/em>, the natural alignment is 1, regardless of its size; that is, in the absence\n- *     of an explicit alignment constraint, a padding layout should not affect the alignment constraint of the group\n- *     layout it is nested into<\/li>\n- *     <li>for a value layout <em>L<\/em> whose size is <em>N<\/em>, the natural alignment of <em>L<\/em> is <em>N<\/em><\/li>\n- *     <li>for a sequence layout <em>S<\/em> whose element layout is <em>E<\/em>, the natural alignment of <em>S<\/em> is that of <em>E<\/em><\/li>\n- *     <li>for a group layout <em>G<\/em> with member layouts <em>M1<\/em>, <em>M2<\/em>, ... <em>Mn<\/em> whose alignments are\n- *     <em>A1<\/em>, <em>A2<\/em>, ... <em>An<\/em>, respectively, the natural alignment of <em>G<\/em> is <em>max(A1, A2 ... An)<\/em><\/li>\n+ *     <li>The natural alignment of a padding layout is 1;<\/li>\n+ *     <li>The natural alignment of a value layout whose size is <em>N<\/em> is <em>N<\/em>;<\/li>\n+ *     <li>The natural alignment of a sequence layout whose element layout is <em>E<\/em> is the alignment of <em>E<\/em>;<\/li>\n+ *     <li>The natural alignment of a group layout with member layouts <em>M1<\/em>, <em>M2<\/em>, ... <em>Mn<\/em> whose\n+ *     alignments are <em>A1<\/em>, <em>A2<\/em>, ... <em>An<\/em>, respectively, is <em>max(A1, A2 ... An)<\/em>.<\/li>\n@@ -107,4 +115,2 @@\n- * A layout's natural alignment can be overridden if needed (see {@link MemoryLayout#withByteAlignment(long)}), which can be useful to describe\n- * hyper-aligned layouts.\n- * <p>\n- * All value layouts have an <em>explicit<\/em> byte order (see {@link java.nio.ByteOrder}) which is set when the layout is created.\n+ * A layout's alignment can be overridden if needed (see {@link MemoryLayout#withByteAlignment(long)}), which can be useful to describe\n+ * layouts with weaker or stronger alignment constraints.\n@@ -114,3 +120,3 @@\n- * A <em>layout path<\/em> originates from a <em>root<\/em> layout (typically a group or a sequence layout) and terminates\n- * at a layout nested within the root layout - this is the layout <em>selected<\/em> by the layout path.\n- * Layout paths are typically expressed as a sequence of one or more {@link PathElement} instances.\n+ * A <em>layout path<\/em> is used to unambiguously select a layout that is nested in some other layout.\n+ * Layout paths are typically expressed as a sequence of one or more {@linkplain PathElement path elements}.\n+ * (A more formal definition of layout paths is provided <a href=\"#well-formedness\">below<\/a>).\n@@ -118,4 +124,7 @@\n- * Layout paths are for example useful in order to obtain {@linkplain MemoryLayout#byteOffset(PathElement...) offsets} of\n- * arbitrarily nested layouts inside another layout, to quickly obtain a {@linkplain #varHandle(PathElement...) memory access handle}\n- * corresponding to the selected layout, or to {@linkplain #select(PathElement...) select} an arbitrarily nested layout inside\n- * another layout.\n+ * Layout paths can be used to:\n+ * <ul>\n+ *     <li>obtain {@linkplain MemoryLayout#byteOffset(PathElement...) offsets} of arbitrarily nested layouts;<\/li>\n+ *     <li>obtain a {@linkplain #varHandle(PathElement...) var handle} that can be used to access the value corresponding\n+ *     to the selected layout;<\/li>\n+ *     <li>{@linkplain #select(PathElement...) select} an arbitrarily nested layout.<\/li>\n+ * <\/ul>\n@@ -123,2 +132,1 @@\n- * Such <em>layout paths<\/em> can be constructed programmatically using the methods in this class.\n- * For instance, given the {@code taggedValues} layout instance constructed as above, we can obtain the offset,\n+ * For instance, given the {@code taggedValues} sequence layout constructed above, we can obtain the offset,\n@@ -137,5 +145,7 @@\n- * Layout paths can feature one or more <em>free dimensions<\/em>. For instance, a layout path traversing\n- * an unspecified sequence element (that is, where one of the path component was obtained with the\n- * {@link PathElement#sequenceElement()} method) features an additional free dimension, which will have to be bound at runtime.\n- * This is important when obtaining a {@linkplain MethodHandles#memorySegmentViewVarHandle(ValueLayout) memory segment view var handle}\n- * from layouts, as in the following code:\n+ * <h3 id=\"open-path-elements\">Open path elements<\/h3>\n+ *\n+ * Some layout path elements, said <em>open path elements<\/em>, can select multiple layouts at once. For instance,\n+ * the open path elements {@link PathElement#sequenceElement()}, {@link PathElement#sequenceElement(long, long)} select\n+ * an unspecified element in a sequence layout. A var handle derived from a layout path containing one or more\n+ * open path element features additional coordinates of type {@code long}, which can be used by clients to <em>bind<\/em>\n+ * the open elements in the path:\n@@ -146,0 +156,2 @@\n+ * MemorySegment valuesSegment = ...\n+ * int val = (int) valueHandle.get(valuesSegment, 2); \/\/ reads the \"value\" field of the third struct in the array\n@@ -148,10 +160,5 @@\n- * Since the layout path constructed in the above example features exactly one free dimension (as it doesn't specify\n- * <em>which<\/em> member layout named {@code value} should be selected from the enclosing sequence layout),\n- * it follows that the var handle {@code valueHandle} will feature an <em>additional<\/em> {@code long}\n- * access coordinate.\n- *\n- * <p>A layout path with free dimensions can also be used to create an offset-computing method handle, using the\n- * {@link #byteOffset(PathElement...)} or {@link #byteOffsetHandle(PathElement...)} method. Again, free dimensions are\n- * translated into {@code long} parameters of the created method handle. The method handle can be used to compute the\n- * offsets of elements of a sequence at different indices, by supplying these indices when invoking the method handle.\n- * For instance:\n+ * <p>\n+ * Open path elements also affects the creation of\n+ * {@linkplain #byteOffsetHandle(PathElement...) offset-computing method handles}. Each open path element becomes\n+ * an additional {@code long} parameter in the obtained method handle. This parameter can be used to specify the index\n+ * of the sequence element whose offset is to be computed:\n@@ -166,0 +173,62 @@\n+ * <h3 id=\"deref-path-elements\">Dereference path elements<\/h3>\n+ *\n+ * A special kind of path element, called <em>dereference path element<\/em>, allows var handles obtained from\n+ * memory layouts to follow pointers. Consider the following layout:\n+ *\n+ * {@snippet lang=java :\n+ * StructLayout RECTANGLE = MemoryLayout.structLayout(\n+ *         ValueLayout.ADDRESS.withTargetLayout(\n+ *                 MemoryLayout.sequenceLayout(4,\n+ *                         MemoryLayout.structLayout(\n+ *                                 ValueLayout.JAVA_INT.withName(\"x\"),\n+ *                                 ValueLayout.JAVA_INT.withName(\"y\")\n+ *                         ).withName(\"point\")\n+*                  )\n+*          ).withName(\"points\")\n+ * );\n+ * }\n+ *\n+ * This layout is a struct layout which describe a rectangle. It contains a single field, namely {@code points},\n+ * an address layout whose {@linkplain AddressLayout#targetLayout() target layout} is a sequence layout of four\n+ * struct layouts. Each struct layout describes a two-dimensional point, and is defined as a pair or\n+ * {@link ValueLayout#JAVA_INT} coordinates, with names {@code x} and {@code y}, respectively.\n+ * <p>\n+ * With dereference path elements, we can obtain a var handle which accesses the {@code y} coordinate of one of the\n+ * point in the rectangle, as follows:\n+ *\n+ * {@snippet lang=java :\n+ * VarHandle rectPointYs = RECTANGLE.varHandle(\n+ *         PathElement.groupElement(\"points\"),\n+ *         PathElement.dereferenceElement(),\n+ *         PathElement.sequenceElement(),\n+ *         PathElement.groupElement(\"y\")\n+ * );\n+ *\n+ * MemorySegment rect = ...\n+ * int rect_y_4 = (int) rectPointYs.get(rect, 2); \/\/ rect.points[2]->y\n+ * }\n+ *\n+ * <h3 id=\"well-formedness\">Layout path well-formedness<\/h3>\n+ *\n+ * A layout path is applied to a layout {@code C_0}, also called the <em>initial layout<\/em>. Each path element in a\n+ * layout path can be thought of as a function which updates the current layout {@code C_i-1} to some other layout\n+ * {@code C_i}. That is, for each path element {@code E1, E2, ... En}, in a layout path {@code P}, we compute\n+ * {@code C_i = f_i(C_i-1)}, where {@code f_i} is the selection function associated with the path element under consideration,\n+ * denoted as {@code E_i}. The final layout {@code C_i} is also called the <em>selected layout<\/em>.\n+ * <p>\n+ * A layout path {@code P} is considered well-formed for an initial layout {@code C_0} if all its path elements\n+ * {@code E1, E2, ... En} are well-formed for their corresponding input layouts {@code C_0, C_1, ... C_n-1}.\n+ * A path element {@code E} is considered well-formed for a layout {@code L} if any of the following is true:\n+ * <ul>\n+ * <li>{@code L} is a sequence layout and {@code E} is a sequence path element (one of {@link PathElement#sequenceElement(long)},\n+ * {@link PathElement#sequenceElement(long, long)} or {@link PathElement#sequenceElement()}). Moreover, if {@code E}\n+ * contains one or more sequence indices, such indices have to be compatible with the sequence layout's element count;<\/li>\n+ * <li>{@code L} is a group layout and {@code E} is a group path element (one of {@link PathElement#groupElement(String)}\n+ * or {@link PathElement#groupElement(long)}). Moreover, the group path element must refer to a valid member layout in\n+ * {@code L}, either by name, or index;<\/li>\n+ * <li>{@code L} is an address layout and {@code E} is a {@linkplain PathElement#dereferenceElement() dereference path element}.\n+ * Moreover, {@code L} must define some {@linkplain AddressLayout#targetLayout() target layout}.<\/li>\n+ * <\/ul>\n+ * Any attempt to provide a layout path {@code P} that is not well-formed for an initial layout {@code C_0} will result\n+ * in an {@link IllegalArgumentException}.\n+ *\n@@ -187,2 +256,1 @@\n-     * Returns a memory layout of the same type with the same size and alignment constraint as this layout,\n-     * but with the specified name.\n+     * {@return a memory layout with the same characteristics as this layout, but with the given name}\n@@ -191,1 +259,0 @@\n-     * @return a memory layout with the given name.\n@@ -197,4 +264,1 @@\n-     * Returns a memory layout of the same type with the same size and alignment constraint as this layout,\n-     * but without a name.\n-     * <p>\n-     * This can be useful to compare two layouts that have different names, but are otherwise equal.\n+     * {@return a memory layout with the same characteristics as this layout, but with no name}\n@@ -202,1 +266,1 @@\n-     * @return a memory layout without a name.\n+     * @apiNote This can be useful to compare two layouts that have different names, but are otherwise equal.\n@@ -208,1 +272,1 @@\n-     * Returns the alignment constraint associated with this layout, expressed in bytes. Layout alignment defines a power\n+     * {@return the alignment constraint associated with this layout, expressed in bytes} Layout alignment defines a power\n@@ -220,2 +284,0 @@\n-     *\n-     * @return the layout alignment constraint, in bytes.\n@@ -225,1 +287,0 @@\n-\n@@ -227,2 +288,2 @@\n-     * Returns a memory layout of the same type with the same size and name as this layout,\n-     * but with the specified alignment constraint (in bytes).\n+     * {@return a memory layout with the same characteristics as this layout, but with the given\n+     * alignment constraint (in bytes)}\n@@ -231,2 +292,1 @@\n-     * @return a memory layout with the given alignment constraint.\n-     * @throws IllegalArgumentException if {@code byteAlignment} is not a power of two, or if it's less than 1.\n+     * @throws IllegalArgumentException if {@code byteAlignment} is not a power of two.\n@@ -236,1 +296,0 @@\n-\n@@ -238,2 +297,2 @@\n-     * Computes the offset, in bytes, of the layout selected by the given layout path, where the path is considered rooted in this\n-     * layout.\n+     * Computes the offset, in bytes, of the layout selected by the given layout path, where the initial layout in the\n+     * path is this layout.\n@@ -243,7 +302,3 @@\n-     * @throws IllegalArgumentException if the layout path does not select any layout nested in this layout, or if the\n-     * layout path contains one or more path elements that select multiple sequence element indices\n-     * (see {@link PathElement#sequenceElement()} and {@link PathElement#sequenceElement(long, long)}).\n-     * @throws IllegalArgumentException if the layout path contains one or more dereference path elements\n-     * (see {@link PathElement#dereferenceElement()}).\n-     * @throws NullPointerException if either {@code elements == null}, or if any of the elements\n-     * in {@code elements} is {@code null}.\n+     * @throws IllegalArgumentException if the layout path is not <a href=\"#well-formedness\">well-formed<\/a> for this layout.\n+     * @throws IllegalArgumentException if the layout path contains one or more <a href=#open-path-elements>open path elements<\/a>.\n+     * @throws IllegalArgumentException if the layout path contains one or more <a href=#deref-path-elements>dereference path elements<\/a>.\n@@ -257,10 +312,12 @@\n-     * Creates a method handle that can be used to compute the offset, in bytes, of the layout selected\n-     * by the given layout path, where the path is considered rooted in this layout.\n-     *\n-     * <p>The returned method handle has a return type of {@code long}, and features as many {@code long}\n-     * parameter types as there are free dimensions in the provided layout path (see {@link PathElement#sequenceElement()}),\n-     * where the order of the parameters corresponds to the order of the path elements.\n-     * The returned method handle can be used to compute a layout offset similar to {@link #byteOffset(PathElement...)},\n-     * but where some sequence indices are specified only when invoking the method handle.\n-     *\n-     * <p>The final offset returned by the method handle is computed as follows:\n+     * Creates a method handle that computes the offset, in bytes, of the layout selected\n+     * by the given layout path, where the initial layout in the path is this layout.\n+     * <p>\n+     * The returned method handle has the following characteristics:\n+     * <ul>\n+     *     <li>its return type is {@code long};<\/li>\n+     *     <li>it has as zero or more parameters of type {@code long}, one for each <a href=#open-path-elements>open path element<\/a>\n+     *     in the provided layout path. The order of these parameters corresponds to the order in which the open path\n+     *     elements occur in the provided layout path.\n+     * <\/ul>\n+     * <p>\n+     * The final offset returned by the method handle is computed as follows:\n@@ -269,1 +326,1 @@\n-     * byteOffset = c_1 + c_2 + ... + c_m + (x_1 * s_1) + (x_2 * s_2) + ... + (x_n * s_n)\n+     * offset = c_1 + c_2 + ... + c_m + (x_1 * s_1) + (x_2 * s_2) + ... + (x_n * s_n)\n@@ -277,0 +334,3 @@\n+     * @apiNote The returned method handle can be used to compute a layout offset, similarly to {@link #byteOffset(PathElement...)},\n+     * but more flexibly, as some indices can be specified when invoking the method handle.\n+     *\n@@ -278,6 +338,3 @@\n-     * @return a method handle that can be used to compute the byte offset of the layout element\n-     * specified by the given layout path elements, when supplied with the missing sequence element indices.\n-     * @throws IllegalArgumentException if the layout path contains one or more path elements that select\n-     * multiple sequence element indices (see {@link PathElement#sequenceElement(long, long)}).\n-     * @throws IllegalArgumentException if the layout path contains one or more dereference path elements\n-     * (see {@link PathElement#dereferenceElement()}).\n+     * @return a method handle that computes the offset, in bytes, of the layout selected by the given layout path.\n+     * @throws IllegalArgumentException if the layout path is not <a href=\"#well-formedness\">well-formed<\/a> for this layout.\n+     * @throws IllegalArgumentException if the layout path contains one or more <a href=#deref-path-elements>dereference path elements<\/a>.\n@@ -291,2 +348,12 @@\n-     * Creates a var handle that can be used to access a memory segment at the layout selected by the given layout path,\n-     * where the path is considered rooted in this layout.\n+     * Creates a var handle that accesses a memory segment at the offset selected by the given layout path,\n+     * where the initial layout in the path is this layout.\n+     * <p>\n+     * The returned var handle has the following characteristics:\n+     * <ul>\n+     *     <li>its type is derived from the {@linkplain ValueLayout#carrier() carrier} of the\n+     *     selected value layout;<\/li>\n+     *     <li>it has as zero or more access coordinates of type {@code long}, one for each\n+     *     <a href=#open-path-elements>open path element<\/a> in the provided layout path. The order of these access\n+     *     coordinates corresponds to the order in which the open path elements occur in the provided\n+     *     layout path.\n+     * <\/ul>\n@@ -303,1 +370,1 @@\n-     * of heap segments is virtualized. The {@code offset} coordinate can be expressed in the following form:\n+     * of heap segments is virtualized. The {@code offset} value can be expressed in the following form:\n@@ -314,1 +381,1 @@\n-     * Additionally, the provided dynamic values must conform to some bound which is derived from the layout path, that is,\n+     * Additionally, the provided dynamic values must conform to bounds which are derived from the layout path, that is,\n@@ -317,5 +384,5 @@\n-     * Multiple paths can be chained, by using {@linkplain PathElement#dereferenceElement() dereference path elements}.\n-     * A dereference path element allows to obtain a native memory segment whose base address is the address obtained\n-     * by following the layout path elements immediately preceding the dereference path element. In other words,\n-     * if a layout path contains one or more dereference path elements, the final address accessed by the returned\n-     * var handle can be computed as follows:\n+     * Multiple paths can be chained, with <a href=#deref-path-elements>dereference path elements<\/a>.\n+     * A dereference path element constructs a fresh native memory segment whose base address is the address value\n+     * read obtained by accessing a memory segment at the offset determined by the layout path elements immediately preceding\n+     * the dereference path element. In other words, if a layout path contains one or more dereference path elements,\n+     * the final address accessed by the returned var handle can be computed as follows:\n@@ -339,3 +406,2 @@\n-     * @apiNote the resulting var handle will feature an additional {@code long} access coordinate for every\n-     * unspecified sequence access component contained in this layout path. Moreover, the resulting var handle\n-     * features certain <em>access mode restrictions<\/em>, which are common to all memory segment view handles.\n+     * @apiNote The resulting var handle features certain <em>access mode restrictions<\/em>, which are common to all\n+     * {@linkplain MethodHandles#memorySegmentViewVarHandle(ValueLayout) memory segment view handles}.\n@@ -344,5 +410,3 @@\n-     * @return a var handle which can be used to access a memory segment at the (possibly nested) layout selected by the layout path in {@code elements}.\n-     * @throws UnsupportedOperationException if the layout path has one or more elements with incompatible alignment constraint.\n-     * @throws IllegalArgumentException if the layout path in {@code elements} does not select a value layout (see {@link ValueLayout}).\n-     * @throws IllegalArgumentException if the layout path in {@code elements} contains a {@linkplain PathElement#dereferenceElement()\n-     * dereference path element} for an address layout that has no {@linkplain AddressLayout#targetLayout() target layout}.\n+     * @return a var handle that accesses a memory segment at the offset selected by the given layout path.\n+     * @throws IllegalArgumentException if the layout path is not <a href=\"#well-formedness\">well-formed<\/a> for this layout.\n+     * @throws IllegalArgumentException if the layout selected by the provided path is not a {@linkplain ValueLayout value layout}.\n@@ -358,21 +422,13 @@\n-     * corresponding to the layout selected by the given layout path, where the path is considered rooted in this layout.\n-     *\n-     * <p>The returned method handle has a return type of {@code MemorySegment}, features a {@code MemorySegment}\n-     * parameter as leading parameter representing the segment to be sliced, and features as many trailing {@code long}\n-     * parameter types as there are free dimensions in the provided layout path (see {@link PathElement#sequenceElement()}),\n-     * where the order of the parameters corresponds to the order of the path elements.\n-     * The returned method handle can be used to create a slice similar to using {@link MemorySegment#asSlice(long, long)},\n-     * but where the offset argument is dynamically compute based on indices specified when invoking the method handle.\n-     *\n-     * <p>The offset of the returned segment is computed as follows:\n-     *\n-     * <blockquote><pre>{@code\n-     * byteOffset = c_1 + c_2 + ... + c_m + (x_1 * s_1) + (x_2 * s_2) + ... + (x_n * s_n)\n-     * }<\/pre><\/blockquote>\n-     *\n-     * where {@code x_1}, {@code x_2}, ... {@code x_n} are <em>dynamic<\/em> values provided as {@code long}\n-     * arguments, whereas {@code c_1}, {@code c_2}, ... {@code c_m} are <em>static<\/em> offset constants\n-     * and {@code s_1}, {@code s_2}, ... {@code s_n} are <em>static<\/em> stride constants which are derived from\n-     * the layout path.\n-     *\n-     * <p>After the offset is computed, the returned segment is created as if by calling:\n+     * corresponding to the layout selected by the given layout path, where the initial layout in the path is this layout.\n+     * <p>\n+     * The returned method handle has the following characteristics:\n+     * <ul>\n+     *     <li>its return type is {@code MemorySegment};<\/li>\n+     *     <li>it has a leading parameter of type {@code MemorySegment}, corresponding to the memory segment\n+     *     to be sliced;<\/li>\n+     *     <li>it has as zero or more parameters of type {@code long}, one for each <a href=#open-path-elements>open path element<\/a>\n+     *     in the provided layout path. The order of these parameters corresponds to the order in which the open path\n+     *     elements occur in the provided layout path.\n+     * <\/ul>\n+     * <p>\n+     * The offset of the returned segment is computed as follows:\n@@ -380,1 +436,3 @@\n-     * segment.asSlice(offset, layout.byteSize());\n+     * long offset = byteOffset(elements);\n+     * long size = select(elements).byteSize();\n+     * MemorySegment slice = segment.asSlice(offset, size);\n@@ -383,2 +441,2 @@\n-     * where {@code segment} is the segment to be sliced, and where {@code layout} is the layout selected by the given\n-     * layout path, as per {@link MemoryLayout#select(PathElement...)}.\n+     * @apiNote The returned method handle can be used to obtain a memory segment slice, similarly to {@link MemorySegment#asSlice(long, long)},\n+     * but more flexibly, as some indices can be specified when invoking the method handle.\n@@ -387,3 +445,3 @@\n-     * @return a method handle which can be used to create a slice of the selected layout element, given a segment.\n-     * @throws IllegalArgumentException if the layout path contains one or more dereference path elements\n-     * (see {@link PathElement#dereferenceElement()}).\n+     * @return a method handle which is used to slice a memory segment at the offset selected by the given layout path.\n+     * @throws IllegalArgumentException if the layout path is not <a href=\"#well-formedness\">well-formed<\/a> for this layout.\n+     * @throws IllegalArgumentException if the layout path contains one or more <a href=#deref-path-elements>dereference path elements<\/a>.\n@@ -393,1 +451,1 @@\n-                Set.of(), elements);\n+                Set.of(PathKind.DEREF_ELEMENT), elements);\n@@ -397,1 +455,1 @@\n-     * Selects the layout from a path rooted in this layout.\n+     * Returns the layout selected from the provided path, where the initial layout in the path is this layout.\n@@ -401,5 +459,4 @@\n-     * @throws IllegalArgumentException if the layout path does not select any layout nested in this layout,\n-     * or if the layout path contains one or more path elements that select one or more sequence element indices\n-     * (see {@link PathElement#sequenceElement(long)} and {@link PathElement#sequenceElement(long, long)}).\n-     * @throws IllegalArgumentException if the layout path contains one or more dereference path elements\n-     * (see {@link PathElement#dereferenceElement()}).\n+     * @throws IllegalArgumentException if the layout path is not <a href=\"#well-formedness\">well-formed<\/a> for this layout.\n+     * @throws IllegalArgumentException if the layout path contains one or more <a href=#deref-path-elements>dereference path elements<\/a>.\n+     * @throws IllegalArgumentException if the layout path contains one or more path elements that select one or more\n+     * sequence element indices, such as {@link PathElement#sequenceElement(long)} and {@link PathElement#sequenceElement(long, long)}).\n@@ -427,6 +484,9 @@\n-     * are two kinds of path elements: <em>group path elements<\/em> and <em>sequence path elements<\/em>. Group\n-     * path elements are used to select a named member layout within a {@link GroupLayout}. Sequence\n-     * path elements are used to select a sequence element layout within a {@link SequenceLayout}; selection\n-     * of sequence element layout can be <em>explicit<\/em> (see {@link PathElement#sequenceElement(long)}) or\n-     * <em>implicit<\/em> (see {@link PathElement#sequenceElement()}). When a path uses one or more implicit\n-     * sequence path elements, it acquires additional <em>free dimensions<\/em>.\n+     * are three kinds of path elements:\n+     * <ul>\n+     *     <li><em>group path elements<\/em>, used to select a member layout within a {@link GroupLayout}, either by name or by index;<\/li>\n+     *     <li><em>sequence path elements<\/em>, used to select one or more sequence element layouts within a {@link SequenceLayout}; and<\/li>\n+     *     <li><em>dereference path elements<\/em>, used to <a href=\"MemoryLayout.html#deref-path-elements\">dereference<\/a>\n+     *     an address layout as its target layout.<\/li>\n+     * <\/ul>\n+     * Sequence path elements selecting more than one sequence element layout are called\n+     * <a href=\"MemoryLayout.html#open-path-elements\">open path elements<\/a>.\n@@ -444,2 +504,0 @@\n-         * The path element returned by this method does not alter the number of free dimensions of any path\n-         * that is combined with such element.\n@@ -451,2 +509,2 @@\n-         * @param name the name of the group element to be selected.\n-         * @return a path element which selects the group element with the given name.\n+         * @param name the name of the member layout to be selected.\n+         * @return a path element which selects the group member layout with the given name.\n@@ -462,2 +520,0 @@\n-         * The path element returned by this method does not alter the number of free dimensions of any path\n-         * that is combined with such element.\n@@ -465,2 +521,2 @@\n-         * @param index the index of the group element to be selected.\n-         * @return a path element which selects the group element with the given index.\n+         * @param index the index of the member layout element to be selected.\n+         * @return a path element which selects the group member layout with the given index.\n@@ -479,2 +535,0 @@\n-         * The path element returned by this method does not alter the number of free dimensions of any path\n-         * that is combined with such element.\n@@ -495,3 +549,3 @@\n-         * Returns a path element which selects the element layout in a <em>range<\/em> of positions in a sequence layout.\n-         * The range is expressed as a pair of starting index (inclusive) {@code S} and step factor (which can also be negative)\n-         * {@code F}.\n+         * Returns an <a href=\"MemoryLayout.html#open-path-elements\">open path element<\/a> which selects the element\n+         * layout in a <em>range<\/em> of positions in a sequence layout. The range is expressed as a pair of starting\n+         * index (inclusive) {@code S} and step factor (which can also be negative) {@code F}.\n@@ -499,14 +553,2 @@\n-         * If a path with free dimensions {@code n} is combined with the path element returned by this method,\n-         * the number of free dimensions of the resulting path will be {@code 1 + n}. If the free dimension associated\n-         * with this path is bound by an index {@code I}, the resulting accessed offset can be obtained with the following\n-         * formula:\n-         *\n-         * <blockquote><pre>{@code\n-         * E * (S + I * F)\n-         * }<\/pre><\/blockquote>\n-         *\n-         * where {@code E} is the size (in bytes) of the sequence element layout.\n-         * <p>\n-         * Additionally, if {@code C} is the sequence element count, it follows that {@code 0 <= I < B},\n-         * where {@code B} is computed as follows:\n-         *\n+         * The exact sequence element selected by this layout is expressed as an index {@code I}. If {@code C} is the\n+         * sequence element count, it follows that {@code 0 <= I < B}, where {@code B} is computed as follows:\n@@ -535,12 +577,2 @@\n-         * Returns a path element which selects an unspecified element layout in a sequence layout.\n-         * <p>\n-         * If a path with free dimensions {@code n} is combined with the path element returned by this method,\n-         * the number of free dimensions of the resulting path will be {@code 1 + n}. If the free dimension associated\n-         * with this path is bound by an index {@code I}, the resulting accessed offset can be obtained with the following\n-         * formula:\n-         *\n-         * <blockquote><pre>{@code\n-         * E * I\n-         * }<\/pre><\/blockquote>\n-         *\n-         * where {@code E} is the size (in bytes) of the sequence element layout.\n+         * Returns an <a href=\"MemoryLayout.html#open-path-elements\">open path element<\/a> which selects an unspecified\n+         * element layout in a sequence layout.\n@@ -548,1 +580,2 @@\n-         * Additionally, if {@code C} is the sequence element count, it follows that {@code 0 <= I < C}.\n+         * The exact sequence element selected by this layout is expressed as an index {@code I}. If {@code C} is the\n+         * sequence element count, it follows that {@code 0 <= I < C}.\n@@ -560,4 +593,0 @@\n-         * The path element returned by this method does not alter the number of free dimensions of any path\n-         * that is combined with such element. Using this path layout to dereference an address layout\n-         * that has no target layout results in an {@link IllegalArgumentException} (e.g. when\n-         * a var handle is {@linkplain #varHandle(PathElement...) obtained}).\n@@ -580,1 +609,2 @@\n-     *     and {@linkplain ValueLayout#carrier() carrier}<\/li>\n+     *     and {@linkplain ValueLayout#carrier() carrier}. Additionally, two address layouts are considered equal if they\n+     *     also have the same {@linkplain AddressLayout#targetLayout() target layout};<\/li>\n@@ -582,1 +612,1 @@\n-     *     if their element layouts (see {@link SequenceLayout#elementLayout()}) are also equal<\/li>\n+     *     if their element layouts (see {@link SequenceLayout#elementLayout()}) are also equal;<\/li>\n@@ -584,1 +614,1 @@\n-     *     {@link UnionLayout}) and if their member layouts (see {@link GroupLayout#memberLayouts()}) are also equal<\/li>\n+     *     {@link UnionLayout}) and if their member layouts (see {@link GroupLayout#memberLayouts()}) are also equal.<\/li>\n@@ -604,1 +634,4 @@\n-     * Creates a padding layout with the given byte size and a byte-alignment of one.\n+     * Creates a padding layout with the given byte size. The alignment constraint of the returned layout\n+     * is 1. As such, regardless of its size, in the absence of an {@linkplain #withByteAlignment(long) explicit}\n+     * alignment constraint, a padding layout does not affect the natural alignment of the group or sequence layout\n+     * it is nested into.\n@@ -620,1 +653,2 @@\n-     * @throws IllegalArgumentException if {@code elementCount } is negative.\n+     * @throws IllegalArgumentException if {@code elementCount} is negative.\n+     * @throws IllegalArgumentException if {@code elementLayout.byteSize() * elementCount} overflows.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryLayout.java","additions":235,"deletions":201,"binary":false,"changes":436,"status":"modified"},{"patch":"@@ -111,1 +111,1 @@\n- * <a href=\"ScopedArena.html#thread-confinement\">confinement characteristics<\/a> of the arena used to obtain them.\n+ * <a href=\"Arena.html#thread-confinement\">confinement characteristics<\/a> of the arena used to obtain them.\n@@ -144,1 +144,1 @@\n- *                                             MethodHandles.insertArguments(multiplyExact, 0, 4L));\n+ *                                             MethodHandles.insertArguments(multiplyExact, 0, ValueLayout.JAVA_INT.byteSize()));\n@@ -263,3 +263,4 @@\n- * aligned physical address. The runtime preserves this invariant even if the array is relocated during garbage\n- * collection. Access operations rely on this invariant to determine if the specified offset in a heap segment refers\n- * to an aligned address in physical memory. For example:\n+ * aligned physical address (except for {@code long[]} and {@code double[]}, where alignment is platform-dependent, as explained\n+ * below). The runtime preserves this invariant even if the array is relocated during garbage collection.\n+ * Access operations rely on this invariant to determine if the specified offset in a heap segment refers to an aligned\n+ * address in physical memory. For example:\n@@ -281,1 +282,1 @@\n- * <li>The starting physical address of a {@code long[]} array will be 4-byte aligned (e.g. 1000) on 32-bit platforms,\n+ * <li>The starting physical address of a {@code long[]} array will be 4-byte aligned (e.g. 1004) on 32-bit platforms,\n@@ -284,1 +285,1 @@\n- * alignment constraint, because the target addresses (1000, 1004, 1008, 1012) are 4-byte aligned. And, the segment\n+ * alignment constraint, because the target addresses (1004, 1008, 1012, 1016) are 4-byte aligned. And, the segment\n@@ -447,1 +448,1 @@\n-     * Returns the Java object stored in the on-heap memory region backing this memory segment, if any. For instance, if this\n+     * Returns the Java object stored in the on-heap region of memory backing this memory segment, if any. For instance, if this\n@@ -518,1 +519,1 @@\n-     * asSlice(offset, layout.byteSize(), 1);\n+     * asSlice(offset, newSize, 1);\n@@ -526,1 +527,2 @@\n-     * @throws IndexOutOfBoundsException if {@code offset < 0}, {@code offset > byteSize()}, {@code newSize < 0}, or {@code newSize > byteSize() - offset}\n+     * @throws IndexOutOfBoundsException if {@code offset < 0}, {@code offset > byteSize()}, {@code newSize < 0},\n+     * or {@code newSize > byteSize() - offset}\n@@ -538,1 +540,2 @@\n-     * @throws IndexOutOfBoundsException if {@code offset < 0}, {@code offset > byteSize()}, {@code newSize < 0}, or {@code newSize > byteSize() - offset}\n+     * @throws IndexOutOfBoundsException if {@code offset < 0}, {@code offset > byteSize()}, {@code newSize < 0},\n+     * or {@code newSize > byteSize() - offset}\n@@ -541,0 +544,1 @@\n+     * @throws IllegalArgumentException if {@code byteAlignment <= 0}, or if {@code byteAlignment} is not a power of 2.\n@@ -557,2 +561,2 @@\n-     * @throws IndexOutOfBoundsException if {@code offset < 0}, {@code offset > layout.byteSize()},\n-     * {@code newSize < 0}, or {@code newSize > layout.byteSize() - offset}\n+     * @throws IndexOutOfBoundsException if {@code offset < 0}, {@code offset > byteSize()},\n+     * or {@code layout.byteSize() > byteSize() - offset}\n@@ -615,1 +619,2 @@\n-     * MemorySegment cleanupSegment = MemorySegment.ofAddress(this.address());\n+     * MemorySegment cleanupSegment = MemorySegment.ofAddress(this.address())\n+     *                                             .reinterpret(byteSize());\n@@ -634,2 +639,1 @@\n-     * @throws IllegalArgumentException if {@code newSize < 0}.\n-     * @throws IllegalStateException if {@code scope.isAlive() == false}.\n+     * @throws IllegalStateException if {@code arena.scope().isAlive() == false}.\n@@ -654,1 +658,2 @@\n-     * MemorySegment cleanupSegment = MemorySegment.ofAddress(this.address());\n+     * MemorySegment cleanupSegment = MemorySegment.ofAddress(this.address())\n+     *                                             .reinterpret(newSize);\n@@ -677,1 +682,1 @@\n-     * @throws IllegalStateException if {@code scope.isAlive() == false}.\n+     * @throws IllegalStateException if {@code arena.scope().isAlive() == false}.\n@@ -721,1 +726,1 @@\n-     * this case, or when no overlap occurs, {@code null} is returned.\n+     * this case, or when no overlap occurs, an empty {@code Optional} is returned.\n@@ -738,1 +743,1 @@\n-     * other.address() - segment.address()\n+     * other.address() - address()\n@@ -747,1 +752,1 @@\n-     * a different kind, or because they are backed by different Java arrays.\n+     * different kinds, or because they are backed by different Java arrays.\n@@ -753,1 +758,1 @@\n-     * Fills a value into this memory segment.\n+     * Fills the contents of this memory segment with the given value.\n@@ -755,1 +760,1 @@\n-     * More specifically, the given value is filled into each address of this\n+     * More specifically, the given value is written into each address of this\n@@ -759,4 +764,2 @@\n-     * var byteHandle = MemoryLayout.sequenceLayout(ValueLayout.JAVA_BYTE)\n-     *         .varHandle(MemoryLayout.PathElement.sequenceElement());\n-     * for (long l = 0; l < segment.byteSize(); l++) {\n-     *     byteHandle.set(segment.address(), l, value);\n+     * for (long offset = 0; offset < segment.byteSize(); offset++) {\n+     *     byteHandle.set(ValueLayout.JAVA_BYTE, offset, value);\n@@ -766,1 +769,1 @@\n-     * without any regard or guarantees on the ordering of particular memory\n+     * But without any regard or guarantees on the ordering of particular memory\n@@ -769,1 +772,1 @@\n-     * Fill can be useful to initialize or reset the memory of a segment.\n+     * This method can be useful to initialize or reset the contents of a memory segment.\n@@ -771,2 +774,2 @@\n-     * @param value the value to fill into this segment\n-     * @return this memory segment\n+     * @param value the value to write into this segment.\n+     * @return this memory segment.\n@@ -777,1 +780,1 @@\n-     * @throws UnsupportedOperationException if this segment is read-only (see {@link #isReadOnly()}).\n+     * @throws UnsupportedOperationException if this segment is {@linkplain #isReadOnly() read-only}.\n@@ -800,1 +803,1 @@\n-     * @throws UnsupportedOperationException if this segment is read-only (see {@link #isReadOnly()}).\n+     * @throws UnsupportedOperationException if this segment is {@linkplain #isReadOnly() read-only}.\n@@ -823,1 +826,1 @@\n-     * @param other the segment to be tested for a mismatch with this segment\n+     * @param other the segment to be tested for a mismatch with this segment.\n@@ -825,1 +828,1 @@\n-     * and the given other segment, otherwise -1 if no mismatch\n+     * and the given other segment, otherwise -1 if no mismatch.\n@@ -933,9 +936,10 @@\n-     * the properties of this segment. For instance, if this segment is <em>immutable<\/em>\n-     * (e.g. the segment is a read-only segment, see {@link #isReadOnly()}), then the resulting buffer is <em>read-only<\/em>\n-     * (see {@link ByteBuffer#isReadOnly()}). Additionally, if this is a native segment, the resulting buffer is\n-     * <em>direct<\/em> (see {@link ByteBuffer#isDirect()}).\n-     * <p>\n-     * The returned buffer's position (see {@link ByteBuffer#position()}) is initially set to zero, while\n-     * the returned buffer's capacity and limit (see {@link ByteBuffer#capacity()} and {@link ByteBuffer#limit()}, respectively)\n-     * are set to this segment' size (see {@link MemorySegment#byteSize()}). For this reason, a byte buffer cannot be\n-     * returned if this segment' size is greater than {@link Integer#MAX_VALUE}.\n+     * the properties of this segment. More specifically, the resulting buffer has the following characteristics:\n+     * <ul>\n+     * <li>It is {@linkplain ByteBuffer#isReadOnly() read-only}, if this segment is a\n+     * {@linkplain #isReadOnly() read-only segment};<\/li>\n+     * <li>Its {@linkplain ByteBuffer#position() position} is set to zero;\n+     * <li>Its {@linkplain ByteBuffer#capacity() capacity} and {@linkplain ByteBuffer#limit() limit}\n+     * are both set to this segment' {@linkplain MemorySegment#byteSize() size}. For this reason, a byte buffer\n+     * cannot be returned if this segment's size is greater than {@link Integer#MAX_VALUE};<\/li>\n+     * <li>It is a {@linkplain ByteBuffer#isDirect() direct buffer}, if this is a native segment.<\/li>\n+     * <\/ul>\n@@ -943,1 +947,1 @@\n-     * The life-cycle of the returned buffer will be tied to that of this segment. That is, accessing the returned buffer\n+     * The life-cycle of the returned buffer is tied to that of this segment. That is, accessing the returned buffer\n@@ -948,2 +952,2 @@\n-     * If this segment is accessible from a single thread, calling read\/write I\/O\n-     * operations on the resulting buffer might result in an unspecified exception being thrown. Examples of such problematic operations are\n+     * If this segment is {@linkplain #isAccessibleBy(Thread) accessible} from a single thread, calling read\/write I\/O\n+     * operations on the resulting buffer might result in unspecified exceptions being thrown. Examples of such problematic operations are\n@@ -958,1 +962,1 @@\n-     * e.g. because it models a heap-based segment that is not based on a {@code byte[]}), or if its size is greater\n+     * e.g. if it is a heap segment backed by an array other than {@code byte[]}), or if its size is greater\n@@ -987,1 +991,1 @@\n-     * e.g. because {@code byteSize() % 2 != 0}, or {@code byteSize() \/ 2 > Integer#MAX_VALUE}\n+     * e.g. because {@code byteSize() % 2 != 0}, or {@code byteSize() \/ 2 > Integer.MAX_VALUE}\n@@ -1001,1 +1005,1 @@\n-     * e.g. because {@code byteSize() % 2 != 0}, or {@code byteSize() \/ 2 > Integer#MAX_VALUE}.\n+     * e.g. because {@code byteSize() % 2 != 0}, or {@code byteSize() \/ 2 > Integer.MAX_VALUE}.\n@@ -1015,1 +1019,1 @@\n-     * e.g. because {@code byteSize() % 4 != 0}, or {@code byteSize() \/ 4 > Integer#MAX_VALUE}.\n+     * e.g. because {@code byteSize() % 4 != 0}, or {@code byteSize() \/ 4 > Integer.MAX_VALUE}.\n@@ -1029,1 +1033,1 @@\n-     * e.g. because {@code byteSize() % 4 != 0}, or {@code byteSize() \/ 4 > Integer#MAX_VALUE}.\n+     * e.g. because {@code byteSize() % 4 != 0}, or {@code byteSize() \/ 4 > Integer.MAX_VALUE}.\n@@ -1043,1 +1047,1 @@\n-     * e.g. because {@code byteSize() % 8 != 0}, or {@code byteSize() \/ 8 > Integer#MAX_VALUE}.\n+     * e.g. because {@code byteSize() % 8 != 0}, or {@code byteSize() \/ 8 > Integer.MAX_VALUE}.\n@@ -1057,1 +1061,1 @@\n-     * e.g. because {@code byteSize() % 8 != 0}, or {@code byteSize() \/ 8 > Integer#MAX_VALUE}.\n+     * e.g. because {@code byteSize() % 8 != 0}, or {@code byteSize() \/ 8 > Integer.MAX_VALUE}.\n@@ -1072,1 +1076,1 @@\n-     * @throws IndexOutOfBoundsException if {@code offset < 0} or {@code S + offset > byteSize()}, where {@code S} is the size of the UTF-8\n+     * @throws IndexOutOfBoundsException if {@code offset < 0} or {@code offset > byteSize() - S}, where {@code S} is the size of the UTF-8\n@@ -1098,1 +1102,1 @@\n-     * @throws IndexOutOfBoundsException if {@code offset < 0} or {@code str.getBytes().length() + offset >= byteSize()}.\n+     * @throws IndexOutOfBoundsException if {@code offset < 0} or {@code offset > byteSize() - str.getBytes().length() + 1}.\n@@ -1113,1 +1117,1 @@\n-     * If the buffer is {@linkplain Buffer#isReadOnly() read-only}, the resulting segment will also be\n+     * If the buffer is {@linkplain Buffer#isReadOnly() read-only}, the resulting segment is also\n@@ -1138,1 +1142,1 @@\n-     * The scope of the returned segment is a fresh scope that is always alive, and keeps the given byte array reachable.\n+     * The scope of the returned segment is a fresh scope that is always alive, and keeps the given array reachable.\n@@ -1150,1 +1154,1 @@\n-     * The scope of the returned segment is a fresh scope that is always alive, and keeps the given byte array reachable.\n+     * The scope of the returned segment is a fresh scope that is always alive, and keeps the given array reachable.\n@@ -1162,1 +1166,1 @@\n-     * The scope of the returned segment is a fresh scope that is always alive, and keeps the given byte array reachable.\n+     * The scope of the returned segment is a fresh scope that is always alive, and keeps the given array reachable.\n@@ -1174,1 +1178,1 @@\n-     * The scope of the returned segment is a fresh scope that is always alive, and keeps the given byte array reachable.\n+     * The scope of the returned segment is a fresh scope that is always alive, and keeps the given array reachable.\n@@ -1186,1 +1190,1 @@\n-     * The scope of the returned segment is a fresh scope that is always alive, and keeps the given byte array reachable.\n+     * The scope of the returned segment is a fresh scope that is always alive, and keeps the given array reachable.\n@@ -1198,1 +1202,1 @@\n-     * The scope of the returned segment is a fresh scope that is always alive, and keeps the given byte array reachable.\n+     * The scope of the returned segment is a fresh scope that is always alive, and keeps the given array reachable.\n@@ -1210,1 +1214,1 @@\n-     * The scope of the returned segment is a fresh scope that is always alive, and keeps the given byte array reachable.\n+     * The scope of the returned segment is a fresh scope that is always alive, and keeps the given array reachable.\n@@ -1227,1 +1231,1 @@\n-     * The returned segment is always accessible, from any thread.\n+     * The returned segment is associated with a scope that is always alive, and is accessible from any thread.\n@@ -1271,2 +1275,2 @@\n-     * @throws IndexOutOfBoundsException if {@code srcOffset + bytes > srcSegment.byteSize()} or if\n-     * {@code dstOffset + bytes > dstSegment.byteSize()}, or if either {@code srcOffset}, {@code dstOffset}\n+     * @throws IndexOutOfBoundsException if {@code srcOffset > srcSegment.byteSize() - bytes} or if\n+     * {@code dstOffset > dstSegment.byteSize() - bytes}, or if either {@code srcOffset}, {@code dstOffset}\n@@ -1274,1 +1278,1 @@\n-     * @throws UnsupportedOperationException if the destination segment is read-only (see {@link #isReadOnly()}).\n+     * @throws UnsupportedOperationException if {@code dstSegment} is {@linkplain #isReadOnly() read-only}.\n@@ -1319,4 +1323,4 @@\n-     * @throws IndexOutOfBoundsException if {@code srcOffset + (elementCount * S) > srcSegment.byteSize()} or if\n-     * {@code dstOffset + (elementCount * S) > dstSegment.byteSize()}, where {@code S} is the byte size\n-     * of the element layouts, or if either {@code srcOffset}, {@code dstOffset} or {@code elementCount} are {@code < 0}.\n-     * @throws UnsupportedOperationException if the destination segment is read-only (see {@link #isReadOnly()}).\n+     * @throws UnsupportedOperationException if {@code dstSegment} is {@linkplain #isReadOnly() read-only}.\n+     * @throws IndexOutOfBoundsException if {@code elementCount * srcLayout.byteSize()} or {@code elementCount * dtsLayout.byteSize()} overflows.\n+     * @throws IndexOutOfBoundsException if {@code dstOffset > dstSegment.byteSize() - (elementCount * dstLayout.byteSize())}.\n+     * @throws IndexOutOfBoundsException if either {@code srcOffset}, {@code dstOffset} or {@code elementCount} are {@code < 0}.\n@@ -1347,2 +1351,1 @@\n-     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n-     * memory segment.\n+     * @throws IndexOutOfBoundsException if {@code offset > byteSize() - layout.byteSize()}.\n@@ -1367,2 +1370,1 @@\n-     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n-     * memory segment.\n+     * @throws IndexOutOfBoundsException if {@code offset > byteSize() - layout.byteSize()}.\n@@ -1388,2 +1390,1 @@\n-     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n-     * memory segment.\n+     * @throws IndexOutOfBoundsException if {@code offset > byteSize() - layout.byteSize()}.\n@@ -1408,2 +1409,1 @@\n-     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n-     * memory segment.\n+     * @throws IndexOutOfBoundsException if {@code offset > byteSize() - layout.byteSize()}.\n@@ -1429,2 +1429,1 @@\n-     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n-     * memory segment.\n+     * @throws IndexOutOfBoundsException if {@code offset > byteSize() - layout.byteSize()}.\n@@ -1449,2 +1448,1 @@\n-     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n-     * memory segment.\n+     * @throws IndexOutOfBoundsException if {@code offset > byteSize() - layout.byteSize()}.\n@@ -1470,2 +1468,1 @@\n-     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n-     * memory segment.\n+     * @throws IndexOutOfBoundsException if {@code offset > byteSize() - layout.byteSize()}.\n@@ -1490,2 +1487,1 @@\n-     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n-     * memory segment.\n+     * @throws IndexOutOfBoundsException if {@code offset > byteSize() - layout.byteSize()}.\n@@ -1511,2 +1507,1 @@\n-     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n-     * memory segment.\n+     * @throws IndexOutOfBoundsException if {@code offset > byteSize() - layout.byteSize()}.\n@@ -1531,2 +1526,1 @@\n-     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n-     * memory segment.\n+     * @throws IndexOutOfBoundsException if {@code offset > byteSize() - layout.byteSize()}.\n@@ -1552,2 +1546,1 @@\n-     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n-     * memory segment.\n+     * @throws IndexOutOfBoundsException if {@code offset > byteSize() - layout.byteSize()}.\n@@ -1572,2 +1565,1 @@\n-     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n-     * memory segment.\n+     * @throws IndexOutOfBoundsException if {@code offset > byteSize() - layout.byteSize()}.\n@@ -1593,2 +1585,1 @@\n-     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n-     * memory segment.\n+     * @throws IndexOutOfBoundsException if {@code offset > byteSize() - layout.byteSize()}.\n@@ -1613,2 +1604,1 @@\n-     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n-     * memory segment.\n+     * @throws IndexOutOfBoundsException if {@code offset > byteSize() - layout.byteSize()}.\n@@ -1634,2 +1624,1 @@\n-     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n-     * memory segment.\n+     * @throws IndexOutOfBoundsException if {@code offset > byteSize() - layout.byteSize()}.\n@@ -1654,2 +1643,1 @@\n-     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n-     * memory segment.\n+     * @throws IndexOutOfBoundsException if {@code offset > byteSize() - layout.byteSize()}.\n@@ -1667,1 +1655,1 @@\n-     * {@linkplain AddressLayout#targetLayout()} {@code T}, then the size of the returned segment\n+     * {@linkplain AddressLayout#targetLayout() target layout} {@code T}, then the size of the returned segment\n@@ -1681,2 +1669,1 @@\n-     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n-     * memory segment.\n+     * @throws IndexOutOfBoundsException if {@code offset > byteSize() - layout.byteSize()}.\n@@ -1701,2 +1688,1 @@\n-     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n-     * memory segment.\n+     * @throws IndexOutOfBoundsException if {@code offset > byteSize() - layout.byteSize()}.\n@@ -1725,2 +1711,2 @@\n-     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n-     * memory segment.\n+     * @throws IndexOutOfBoundsException if {@code index * byteSize()} overflows.\n+     * @throws IndexOutOfBoundsException if {@code index * byteSize() > byteSize() - layout.byteSize()}.\n@@ -1749,2 +1735,2 @@\n-     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n-     * memory segment.\n+     * @throws IndexOutOfBoundsException if {@code index * byteSize()} overflows.\n+     * @throws IndexOutOfBoundsException if {@code index * byteSize() > byteSize() - layout.byteSize()}.\n@@ -1773,2 +1759,2 @@\n-     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n-     * memory segment.\n+     * @throws IndexOutOfBoundsException if {@code index * byteSize()} overflows.\n+     * @throws IndexOutOfBoundsException if {@code index * byteSize() > byteSize() - layout.byteSize()}.\n@@ -1797,2 +1783,2 @@\n-     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n-     * memory segment.\n+     * @throws IndexOutOfBoundsException if {@code index * byteSize()} overflows.\n+     * @throws IndexOutOfBoundsException if {@code index * byteSize() > byteSize() - layout.byteSize()}.\n@@ -1822,2 +1808,2 @@\n-     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n-     * memory segment.\n+     * @throws IndexOutOfBoundsException if {@code index * byteSize()} overflows.\n+     * @throws IndexOutOfBoundsException if {@code index * byteSize() > byteSize() - layout.byteSize()}.\n@@ -1846,2 +1832,2 @@\n-     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n-     * memory segment.\n+     * @throws IndexOutOfBoundsException if {@code index * byteSize()} overflows.\n+     * @throws IndexOutOfBoundsException if {@code index * byteSize() > byteSize() - layout.byteSize()}.\n@@ -1872,2 +1858,2 @@\n-     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n-     * memory segment.\n+     * @throws IndexOutOfBoundsException if {@code index * byteSize()} overflows.\n+     * @throws IndexOutOfBoundsException if {@code index * byteSize() > byteSize() - layout.byteSize()}.\n@@ -1897,2 +1883,2 @@\n-     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n-     * memory segment.\n+     * @throws IndexOutOfBoundsException if {@code index * byteSize()} overflows.\n+     * @throws IndexOutOfBoundsException if {@code index * byteSize() > byteSize() - layout.byteSize()}.\n@@ -1922,2 +1908,2 @@\n-     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n-     * memory segment.\n+     * @throws IndexOutOfBoundsException if {@code index * byteSize()} overflows.\n+     * @throws IndexOutOfBoundsException if {@code index * byteSize() > byteSize() - layout.byteSize()}.\n@@ -1946,2 +1932,2 @@\n-     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n-     * memory segment.\n+     * @throws IndexOutOfBoundsException if {@code index * byteSize()} overflows.\n+     * @throws IndexOutOfBoundsException if {@code index * byteSize() > byteSize() - layout.byteSize()}.\n@@ -1971,2 +1957,2 @@\n-     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n-     * memory segment.\n+     * @throws IndexOutOfBoundsException if {@code index * byteSize()} overflows.\n+     * @throws IndexOutOfBoundsException if {@code index * byteSize() > byteSize() - layout.byteSize()}.\n@@ -1995,2 +1981,2 @@\n-     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n-     * memory segment.\n+     * @throws IndexOutOfBoundsException if {@code index * byteSize()} overflows.\n+     * @throws IndexOutOfBoundsException if {@code index * byteSize() > byteSize() - layout.byteSize()}.\n@@ -2020,2 +2006,2 @@\n-     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n-     * memory segment.\n+     * @throws IndexOutOfBoundsException if {@code index * byteSize()} overflows.\n+     * @throws IndexOutOfBoundsException if {@code index * byteSize() > byteSize() - layout.byteSize()}.\n@@ -2044,2 +2030,2 @@\n-     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n-     * memory segment.\n+     * @throws IndexOutOfBoundsException if {@code index * byteSize()} overflows.\n+     * @throws IndexOutOfBoundsException if {@code index * byteSize() > byteSize() - layout.byteSize()}.\n@@ -2069,2 +2055,2 @@\n-     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n-     * memory segment.\n+     * @throws IndexOutOfBoundsException if {@code index * byteSize()} overflows.\n+     * @throws IndexOutOfBoundsException if {@code index * byteSize() > byteSize() - layout.byteSize()}.\n@@ -2093,2 +2079,2 @@\n-     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n-     * memory segment.\n+     * @throws IndexOutOfBoundsException if {@code index * byteSize()} overflows.\n+     * @throws IndexOutOfBoundsException if {@code index * byteSize() > byteSize() - layout.byteSize()}.\n@@ -2108,1 +2094,1 @@\n-     * {@linkplain AddressLayout#targetLayout()} {@code T}, then the size of the returned segment\n+     * {@linkplain AddressLayout#targetLayout() target layout} {@code T}, then the size of the returned segment\n@@ -2124,2 +2110,2 @@\n-     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n-     * memory segment.\n+     * @throws IndexOutOfBoundsException if {@code index * byteSize()} overflows.\n+     * @throws IndexOutOfBoundsException if {@code index * byteSize() > byteSize() - layout.byteSize()}.\n@@ -2148,2 +2134,2 @@\n-     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n-     * memory segment.\n+     * @throws IndexOutOfBoundsException if {@code index * byteSize()} overflows.\n+     * @throws IndexOutOfBoundsException if {@code index * byteSize() > byteSize() - layout.byteSize()}.\n@@ -2165,1 +2151,1 @@\n-     *     <li>{@code s1.array().equals(s2.array())}, that is, the two segments must be of the same kind;\n+     *     <li>{@code s1.heapBase().equals(s2.heapBase())}, that is, the two segments must be of the same kind;\n@@ -2167,1 +2153,1 @@\n-     *     the same on-heap Java array;\n+     *     the same on-heap {@linkplain #heapBase() Java object};\n@@ -2170,1 +2156,1 @@\n-     *     to the same position inside their associated Java array instance.<\/li>\n+     *     to the same offset inside their associated {@linkplain #heapBase() Java object}.<\/li>\n@@ -2175,1 +2161,1 @@\n-     * to perform address checks, such as checking if a native segment has the {@code NULL} address.\n+     * to check whether two segments have the same address.\n@@ -2207,4 +2193,9 @@\n-     * @throws  IllegalArgumentException if {@code dstArray} is not an array, or if it is an array but whose type is not supported,\n-     * if the destination array component type does not match the carrier of the source element layout, if the source\n-     * segment\/offset are <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the source element layout,\n-     * or if the destination element layout alignment is greater than its size.\n+     * @throws  IllegalArgumentException if {@code dstArray} is not an array, or if it is an array but whose type is not supported.\n+     * @throws IllegalArgumentException if the destination array component type does not match {@code srcLayout.carrier()}.\n+     * @throws IllegalArgumentException if {@code offset} is <a href=\"MemorySegment.html#segment-alignment\">incompatible\n+     * with the alignment constraint<\/a> in the source element layout.\n+     * @throws IllegalArgumentException if {@code srcLayout.byteAlignment() > srcLayout.byteSize()}.\n+     * @throws IndexOutOfBoundsException if {@code elementCount * srcLayout.byteSize()} overflows.\n+     * @throws IndexOutOfBoundsException if {@code srcOffset > srcSegment.byteSize() - (elementCount * srcLayout.byteSize())}.\n+     * @throws IndexOutOfBoundsException if {@code dstIndex > dstArray.length - elementCount}.\n+     * @throws IndexOutOfBoundsException if either {@code srcOffset}, {@code dstIndex} or {@code elementCount} are {@code < 0}.\n@@ -2241,4 +2232,10 @@\n-     * @throws  IllegalArgumentException if {@code srcArray} is not an array, or if it is an array but whose type is not supported,\n-     * if the source array component type does not match the carrier of the destination element layout, if the destination\n-     * segment\/offset are <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the destination element layout,\n-     * or if the destination element layout alignment is greater than its size.\n+     * @throws  IllegalArgumentException if {@code srcArray} is not an array, or if it is an array but whose type is not supported.\n+     * @throws IllegalArgumentException if the source array component type does not match {@code srcLayout.carrier()}.\n+     * @throws IllegalArgumentException if {@code offset} is <a href=\"MemorySegment.html#segment-alignment\">incompatible\n+     * with the alignment constraint<\/a> in the source element layout.\n+     * @throws IllegalArgumentException if {@code dstLayout.byteAlignment() > dstLayout.byteSize()}.\n+     * @throws UnsupportedOperationException if {@code dstSegment} is {@linkplain #isReadOnly() read-only}.\n+     * @throws IndexOutOfBoundsException if {@code elementCount * dstLayout.byteSize()} overflows.\n+     * @throws IndexOutOfBoundsException if {@code dstOffset > dstSegment.byteSize() - (elementCount * dstLayout.byteSize())}.\n+     * @throws IndexOutOfBoundsException if {@code srcIndex > srcArray.length - elementCount}.\n+     * @throws IndexOutOfBoundsException if either {@code srcIndex}, {@code dstOffset} or {@code elementCount} are {@code < 0}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":155,"deletions":158,"binary":false,"changes":313,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n- * must implement the {@link #allocate(long, long)} method. This interface defines several default methods\n+ * must implement the {@link #allocate(long, long)} method. A segment allocator defines several methods\n@@ -43,2 +43,0 @@\n- * This interface is a {@linkplain FunctionalInterface functional interface}: clients can easily obtain a new segment allocator\n- * by using either a lambda expression or a method reference.\n@@ -46,1 +44,8 @@\n- * This interface also defines factories for commonly used allocators:\n+ * {@code SegmentAllocator} is a {@linkplain FunctionalInterface functional interface}. Clients can easily obtain a new\n+ * segment allocator by using either a lambda expression or a method reference:\n+ *\n+ * {@snippet lang=java :\n+ * SegmentAllocator autoAllocator = (byteSize, byteAlignment) -> Arena.ofAuto().allocate(byteSize, byteAlignment);\n+ * }\n+ * <p>\n+ * This interface defines factories for commonly used allocators:\n@@ -50,1 +55,1 @@\n- *     <li>{@link #prefixAllocator(MemorySegment)} obtains an allocator which wraps a segment (either on-heap or off-heap)\n+ *     <li>{@link #prefixAllocator(MemorySegment)} obtains an allocator which wraps a segment\n@@ -58,1 +63,9 @@\n- * the allocator parameter tells the linker runtime where to store the return value of the foreign function.\n+ * the allocator parameter tells the linker where to store the return value of the foreign function.\n+ *\n+ * @apiNote Unless otherwise specified, the {@link #allocate(long, long)} method is not thread-safe.\n+ * Furthermore, memory segments allocated by a segment allocator can be associated with different\n+ * lifetimes, and can even be backed by overlapping regions of memory. For these reasons, clients should generally\n+ * only interact with a segment allocator they own.\n+ * <p>\n+ * Clients should consider using an {@linkplain Arena arena} instead, which, provides strong thread-safety,\n+ * lifetime and non-overlapping guarantees.\n@@ -314,0 +327,1 @@\n+     * @throws IllegalArgumentException if {@code elementLayout.byteSize() * count} overflows.\n@@ -341,1 +355,1 @@\n-     * or if {@code alignmentBytes} is not a power of 2.\n+     * or if {@code byteAlignment} is not a power of 2.\n@@ -350,2 +364,3 @@\n-     * When the returned allocator cannot satisfy an allocation request, e.g. because a slice of the provided\n-     * segment with the requested size cannot be found, an {@link IndexOutOfBoundsException} is thrown.\n+     * The returned allocator throws {@link IndexOutOfBoundsException} when a slice of the provided\n+     * segment with the requested size and alignment cannot be found.\n+     * @implNote A slicing allocator is not <em>thread-safe<\/em>.\n@@ -368,1 +383,1 @@\n-     * SegmentAllocator prefixAllocator = (size, align) -> segment.asSlice(0, size);\n+     * SegmentAllocator prefixAllocator = (size, align) -> segment.asSlice(0, size, align);\n@@ -370,2 +385,4 @@\n-     * <p>\n-     * This allocator can be useful to limit allocation requests in case a client\n+     * The returned allocator throws {@link IndexOutOfBoundsException} when a slice of the provided\n+     * segment with the requested size and alignment cannot be found.\n+     *\n+     * @apiNote A prefix allocator can be useful to limit allocation requests in case a client\n@@ -374,2 +391,1 @@\n-     * <p>\n-     * While the allocator returned by this method is <em>thread-safe<\/em>, concurrent access on the same recycling\n+     * @implNote While a prefix allocator is <em>thread-safe<\/em>, concurrent access on the same recycling\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SegmentAllocator.java","additions":30,"deletions":14,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -32,3 +32,3 @@\n- * A compound layout that denotes a repetition of a given <em>element layout<\/em>.\n- * The repetition count is said to be the sequence layout's <em>element count<\/em>. A finite sequence can be thought of as a\n- * group layout where the sequence layout's element layout is repeated a number of times that is equal to the sequence\n+ * A compound layout that denotes a homogeneous repetition of a given <em>element layout<\/em>.\n+ * The repetition count is said to be the sequence layout's <em>element count<\/em>. A sequence layout can be thought of as a\n+ * struct layout where the sequence layout's element layout is repeated a number of times that is equal to the sequence\n@@ -60,1 +60,1 @@\n-     * {@return the element layout associated with this sequence layout}\n+     * {@return the element layout of this sequence layout}\n@@ -70,2 +70,1 @@\n-     * Returns a sequence layout with the same element layout, alignment constraint and name as this sequence layout,\n-     * but with the specified element count.\n+     * {@return a sequence layout with the same characteristics of this layout, but with the given element count}\n@@ -73,2 +72,2 @@\n-     * @return a sequence layout with the given element count.\n-     * @throws IllegalArgumentException if {@code elementCount < 0}.\n+     * @throws IllegalArgumentException if {@code elementCount} is negative.\n+     * @throws IllegalArgumentException if {@code elementLayout.bitSize() * elementCount} overflows.\n@@ -79,3 +78,3 @@\n-     * Re-arrange the elements in this sequence layout into a multi-dimensional sequence layout.\n-     * The resulting layout is a sequence layout where element layouts in the flattened projection of this\n-     * sequence layout (see {@link #flatten()}) are re-arranged into one or more nested sequence layouts\n+     * Rearranges the elements in this sequence layout into a multi-dimensional sequence layout.\n+     * The resulting layout is a sequence layout where element layouts in the {@linkplain #flatten() flattened projection}\n+     * of this sequence layout are rearranged into one or more nested sequence layouts\n@@ -104,1 +103,1 @@\n-     * @return a sequence layout where element layouts in the flattened projection of this\n+     * @return a sequence layout where element layouts in the {@linkplain #flatten() flattened projection} of this\n@@ -115,1 +114,10 @@\n-     * is the first non-sequence element layout found by recursively traversing the element layouts of this sequence layout.\n+     * is the first non-sequence layout found by inspecting (recursively, if needed) the element layout of this sequence layout:\n+     * {@snippet lang=java :\n+     * MemoryLayout flatElementLayout(SequenceLayout sequenceLayout) {\n+     *    return switch (sequenceLayout.elementLayout()) {\n+     *        case SequenceLayout nestedSequenceLayout -> flatElementLayout(nestedSequenceLayout);\n+     *        case MemoryLayout layout -> layout;\n+     *    };\n+     * }\n+     * }\n+     * <p>\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SequenceLayout.java","additions":21,"deletions":13,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n- *     {@link MemorySegment#reinterpret(long)} () resizing} the segment first).<\/li>\n+ *     {@linkplain MemorySegment#reinterpret(long) resizing} the segment first).<\/li>\n@@ -67,1 +67,1 @@\n- * is {@linkplain Arena#close()}:\n+ * is {@linkplain Arena#close() closed}:\n@@ -211,3 +211,0 @@\n-     * @implNote The process of resolving a library name is OS-specific. For instance, in a POSIX-compliant OS,\n-     * the library name is resolved according to the specification of the {@code dlopen} function for that OS.\n-     * In Windows, the library name is resolved according to the specification of the {@code LoadLibrary} function.\n@@ -220,0 +217,4 @@\n+     * @implNote The process of resolving a library name is OS-specific. For instance, in a POSIX-compliant OS,\n+     * the library name is resolved according to the specification of the {@code dlopen} function for that OS.\n+     * In Windows, the library name is resolved according to the specification of the {@code LoadLibrary} function.\n+     *\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SymbolLookup.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -45,3 +45,5 @@\n- * The layout constants in this class make implicit alignment and byte-ordering assumption: all layout\n- * constants in this class are byte-aligned, and their byte order is set to the {@linkplain ByteOrder#nativeOrder() platform default},\n- * thus making it easy to work with other APIs, such as arrays and {@link java.nio.ByteBuffer}.\n+ * @apiNote Some characteristics of the Java layout constants are platform-dependent. For instance, the byte order of\n+ * these constants is set to the {@linkplain ByteOrder#nativeOrder() native byte order}, thus making it easy to work\n+ * with other APIs, such as arrays and {@link java.nio.ByteBuffer}. Moreover, the alignment constraint of\n+ * {@link ValueLayout#JAVA_LONG} and {@link ValueLayout#JAVA_DOUBLE} is set to 8 bytes on 64-bit platforms, but only to\n+ * 4 bytes on 32-bit platforms.\n@@ -65,2 +67,1 @@\n-     * Returns a value layout with the same carrier, alignment constraint and name as this value layout,\n-     * but with the specified byte order.\n+     * {@return a value layout with the same characteristics as this layout, but with the given byte order}\n@@ -69,1 +70,0 @@\n-     * @return a value layout with the given byte order.\n@@ -81,6 +81,4 @@\n-     * array. The layout of this array is a sequence layout with {@code shape.length} nested sequence layouts. The element\n-     * layout of the sequence layout at depth {@code shape.length} is this value layout.\n-     * As a result, if {@code shape.length == 0}, the array layout will feature only one dimension.\n-     * <p>\n-     * The resulting var handle will feature {@code sizes.length + 1} coordinates of type {@code long}, which are\n-     * used as indices into a multi-dimensional array.\n+     * array. This array has a notional sequence layout featuring {@code shape.length} nested sequence layouts. The element\n+     * layout of the innermost sequence layout in the notional sequence layout is this value layout. The resulting var handle\n+     * is obtained as if calling the {@link #varHandle(PathElement...)} method on the notional layout, with a layout\n+     * path containing exactly {@code shape.length + 1} {@linkplain PathElement#sequenceElement() open sequence layout path elements}.\n@@ -94,1 +92,1 @@\n-     * Can be used to access a multi-dimensional array whose layout is as follows:\n+     * Is equivalent to the following code:\n@@ -97,3 +95,5 @@\n-     * SequenceLayout arrayLayout = MemoryLayout.sequenceLayout(\n-     *                                      MemoryLayout.sequenceLayout(10,\n-     *                                                  MemoryLayout.sequenceLayout(20, ValueLayout.JAVA_INT)));\n+     * SequenceLayout notionalLayout = MemoryLayout.sequenceLayout(\n+ *                                         MemoryLayout.sequenceLayout(10, MemoryLayout.sequenceLayout(20, ValueLayout.JAVA_INT)));\n+     * VarHandle arrayHandle = notionalLayout.varHandle(PathElement.sequenceElement(),\n+     *                                                  PathElement.sequenceElement(),\n+     *                                                  PathElement.sequenceElement());\n@@ -113,1 +113,1 @@\n-     *     <li>{@code 0 <= x < arrayLayout.elementCount() }<\/li>\n+     *     <li>{@code 0 <= x < notionalLayout.elementCount() }<\/li>\n@@ -451,1 +451,1 @@\n-     * A value layout constant whose size is the same as that of a machine address ({@code size_t}),\n+     * An address layout constant whose size is the same as that of a machine address ({@code size_t}),\n@@ -507,1 +507,1 @@\n-     * An unaligned value layout constant whose size is the same as that of a machine address ({@code size_t}),\n+     * An unaligned address layout constant whose size is the same as that of a machine address ({@code size_t}),\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/ValueLayout.java","additions":19,"deletions":19,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -80,2 +80,2 @@\n- * inside libraries; the second is used to model the signature of foreign functions, while the third provides\n- * linking capabilities which allows modelling foreign functions as {@link java.lang.invoke.MethodHandle} instances,\n+ * inside libraries; the second is used to model the signature of foreign functions, while the third is used\n+ * to link foreign functions as {@link java.lang.invoke.MethodHandle} instances,\n@@ -119,1 +119,1 @@\n- * the restricted method {@link java.lang.foreign.MemorySegment#reinterpret(long)} ()}\n+ * the restricted method {@link java.lang.foreign.MemorySegment#reinterpret(long)}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/package-info.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -189,1 +189,1 @@\n-            FunctionDescriptor compareDesc = FunctionDescriptor.of(JAVA_INT,\n+            FunctionDescriptor comparDesc = FunctionDescriptor.of(JAVA_INT,\n@@ -192,1 +192,1 @@\n-            MethodHandle compareHandle = MethodHandles.lookup()\n+            MethodHandle comparHandle = MethodHandles.lookup()\n@@ -194,1 +194,1 @@\n-                            compareDesc.toMethodType());\n+                            comparDesc.toMethodType());\n@@ -198,1 +198,1 @@\n-                MemorySegment compareFunc = linker.upcallStub(compareHandle, compareDesc, arena);\n+                MemorySegment compareFunc = linker.upcallStub(comparHandle, comparDesc, arena);\n@@ -403,1 +403,1 @@\n-                        MethodHandles.insertArguments(multiplyExact, 0, 4L));\n+                        MethodHandles.insertArguments(multiplyExact, 0, ValueLayout.JAVA_INT.byteSize()));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/snippet-files\/Snippets.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -7951,1 +7951,1 @@\n-     * by viewing its contents as a sequence of the provided value layout.\n+     * at a given byte offset, using the provided value layout.\n@@ -7958,5 +7958,5 @@\n-     * <p>The returned var handle's type is {@code carrier} and the list of coordinate types is\n-     * {@code (MemorySegment, long)}, where the {@code long} coordinate type corresponds to byte offset into\n-     * a given memory segment. The returned var handle accesses bytes at an offset in a given\n-     * memory segment, composing bytes to or from a value of the type {@code carrier} according to the given endianness;\n-     * the alignment constraint (in bytes) for the resulting var handle is given by {@code alignmentBytes}.\n+     * <p>The list of coordinate types associated with the returned var handle is {@code (MemorySegment, long)},\n+     * where the {@code long} coordinate type corresponds to byte offset into the given memory segment coordinate.\n+     * Thus, the returned var handle accesses bytes at an offset in a given memory segment, composing bytes to or from\n+     * a value of the var handle type. Moreover, the access operation will honor the endianness and the\n+     * alignment constraints expressed in the provided layout.\n@@ -8018,1 +8018,0 @@\n-     * @throws IllegalArgumentException if an illegal carrier type is used, or if {@code alignmentBytes} is not a power of two.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -117,0 +117,2 @@\n+        Utils.checkAlign(byteAlignment);\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -203,0 +203,4 @@\n+        checkAlign(byteAlignment);\n+    }\n+\n+    public static void checkAlign(long byteAlignment) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/Utils.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+import java.util.Set;\n@@ -151,1 +152,0 @@\n-        checkHasNaturalAlignment(layout);\n@@ -153,1 +153,1 @@\n-            checkByteOrder(vl);\n+            checkSupported(vl);\n@@ -155,0 +155,1 @@\n+            checkHasNaturalAlignment(layout);\n@@ -170,0 +171,1 @@\n+            checkHasNaturalAlignment(layout);\n@@ -179,0 +181,1 @@\n+            checkHasNaturalAlignment(layout);\n@@ -203,0 +206,10 @@\n+    private static void checkSupported(ValueLayout valueLayout) {\n+        valueLayout = valueLayout.withoutName();\n+        if (valueLayout instanceof AddressLayout addressLayout) {\n+            valueLayout = addressLayout.withoutTargetLayout();\n+        }\n+        if (!SUPPORTED_LAYOUTS.contains(valueLayout.withoutName())) {\n+            throw new IllegalArgumentException(\"Unsupported layout: \" + valueLayout);\n+        }\n+    }\n+\n@@ -235,5 +248,11 @@\n-    private void checkByteOrder(ValueLayout vl) {\n-        if (vl.order() != linkerByteOrder()) {\n-            throw new IllegalArgumentException(\"Layout does not have the right byte order: \" + vl);\n-        }\n-    }\n+    private static final Set<MemoryLayout> SUPPORTED_LAYOUTS = Set.of(\n+            ValueLayout.JAVA_BOOLEAN,\n+            ValueLayout.JAVA_BYTE,\n+            ValueLayout.JAVA_CHAR,\n+            ValueLayout.JAVA_SHORT,\n+            ValueLayout.JAVA_INT,\n+            ValueLayout.JAVA_FLOAT,\n+            ValueLayout.JAVA_LONG,\n+            ValueLayout.JAVA_DOUBLE,\n+            ValueLayout.ADDRESS\n+    );\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/AbstractLinker.java","additions":26,"deletions":7,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -226,0 +226,15 @@\n+            \/\/ok\n+        }\n+    }\n+\n+    @Test(dataProvider = \"copyModesAndHelpers\")\n+    public void testCopyReadOnlyDest(CopyMode mode, CopyHelper<Object, ValueLayout> helper, String helperDebugString) {\n+        int bytesPerElement = (int)helper.elementLayout.byteSize();\n+        MemorySegment base = srcSegment(SEG_LENGTH_BYTES);\n+        \/\/CopyFrom\n+        Object srcArr = helper.toArray(base);\n+        MemorySegment dstSeg = helper.fromArray(srcArr).asReadOnly();\n+        try {\n+            helper.copyFromArray(srcArr, 0, SEG_LENGTH_BYTES \/ bytesPerElement, dstSeg, 0, ByteOrder.nativeOrder());\n+            fail();\n+        } catch (UnsupportedOperationException ex) {\n","filename":"test\/jdk\/java\/foreign\/TestArrayCopy.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -133,0 +133,5 @@\n+    @Test(expectedExceptions = IllegalArgumentException.class)\n+    void testBadDerefInSlice() {\n+        A.sliceHandle(PathElement.groupElement(\"b\"), PathElement.dereferenceElement());\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestDereferencePath.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -122,1 +122,1 @@\n-                    \"Layout alignment must be natural alignment\"\n+                    \"Unsupported layout: 2%i4\"\n@@ -126,1 +126,1 @@\n-                    \"Layout alignment must be natural alignment\"\n+                    \"Unsupported layout: 2%a8\"\n@@ -130,1 +130,1 @@\n-                    \"Layout alignment must be natural alignment\"\n+                    \"Unsupported layout: 4%c2\"\n@@ -138,1 +138,1 @@\n-                    \"Layout alignment must be natural alignment\"\n+                    \"Unsupported layout: 1%s2\"\n@@ -147,1 +147,1 @@\n-                    \"Layout alignment must be natural alignment\"\n+                    \"Unsupported layout: 1%s2\"\n@@ -154,1 +154,1 @@\n-                    \"Layout alignment must be natural alignment\"\n+                    \"Unsupported layout: 1%i4\"\n@@ -165,1 +165,1 @@\n-                    \"Layout does not have the right byte order\"\n+                    \"Unsupported layout: I4\"\n@@ -169,1 +169,1 @@\n-                    \"Layout does not have the right byte order\"\n+                    \"Unsupported layout: I4\"\n@@ -173,1 +173,1 @@\n-                    \"Layout does not have the right byte order\"\n+                    \"Unsupported layout: I4\"\n","filename":"test\/jdk\/java\/foreign\/TestIllegalLink.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -125,0 +125,6 @@\n+    @Test\n+    public void testByteOffsetHandleRange() {\n+        SequenceLayout seq = MemoryLayout.sequenceLayout(5, MemoryLayout.structLayout(JAVA_INT));\n+        seq.byteOffsetHandle(sequenceElement(0, 1));\n+    }\n+\n@@ -128,1 +134,1 @@\n-        seq.byteOffsetHandle(sequenceElement(0, 1)); \/\/ ranges not accepted\n+        seq.byteOffsetHandle(sequenceElement(5, 1)); \/\/ invalid range (starting position is outside the sequence)\n","filename":"test\/jdk\/java\/foreign\/TestLayoutPaths.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.lang.foreign.MemoryLayout;\n@@ -35,1 +36,0 @@\n-import java.util.function.Function;\n@@ -43,1 +43,1 @@\n-    static class Accessor<T, X, L extends ValueLayout> {\n+    static class Accessor<X, L extends ValueLayout> {\n@@ -45,2 +45,2 @@\n-        interface SegmentGetter<T, X, L> {\n-            X get(T buffer, L layout, long offset);\n+        interface SegmentGetter<X, L> {\n+            X get(MemorySegment segment, L layout, long offset);\n@@ -49,2 +49,2 @@\n-        interface SegmentSetter<T, X, L> {\n-            void set(T buffer, L layout, long offset, X o);\n+        interface SegmentSetter<X, L> {\n+            void set(MemorySegment segment, L layout, long offset, X o);\n@@ -63,3 +63,2 @@\n-        final Function<MemorySegment, T> transform;\n-        final SegmentGetter<T, X, L> segmentGetter;\n-        final SegmentSetter<T, X, L> segmentSetter;\n+        final SegmentGetter<X, L> segmentGetter;\n+        final SegmentSetter<X, L> segmentSetter;\n@@ -69,2 +68,2 @@\n-        Accessor(Function<MemorySegment, T> transform, L layout, X value,\n-                 SegmentGetter<T, X, L> segmentGetter, SegmentSetter<T, X, L> segmentSetter,\n+        Accessor(L layout, X value,\n+                 SegmentGetter<X, L> segmentGetter, SegmentSetter<X, L> segmentSetter,\n@@ -72,1 +71,0 @@\n-            this.transform = transform;\n@@ -85,2 +83,1 @@\n-                T t = transform.apply(segment);\n-                segmentSetter.set(t, layout, 8, value);\n+                segmentSetter.set(segment, layout, 8, value);\n@@ -89,1 +86,1 @@\n-                assertEquals(value, segmentGetter.get(t, layout, 8));\n+                assertEquals(value, segmentGetter.get(segment, layout, 8));\n@@ -97,1 +94,0 @@\n-                T t = transform.apply(segment);\n@@ -100,1 +96,1 @@\n-                    segmentSetter.set(t, alignedLayout, 0, value);\n+                    segmentSetter.set(segment, alignedLayout, 0, value);\n@@ -106,1 +102,1 @@\n-                    segmentGetter.get(t, alignedLayout, 0);\n+                    segmentGetter.get(segment, alignedLayout, 0);\n@@ -114,4 +110,12 @@\n-        static <L extends ValueLayout, X> Accessor<MemorySegment, X, L> ofSegment(L layout, X value,\n-                         SegmentGetter<MemorySegment, X, L> segmentGetter, SegmentSetter<MemorySegment, X, L> segmentSetter,\n-                         BufferGetter<X> bufferGetter, BufferSetter<X> bufferSetter) {\n-            return new Accessor<>(Function.identity(), layout, value, segmentGetter, segmentSetter, bufferGetter, bufferSetter);\n+        X get(MemorySegment segment, long offset) {\n+            return segmentGetter.get(segment, layout, offset);\n+        }\n+\n+        void set(MemorySegment segment, long offset, X value) {\n+            segmentSetter.set(segment, layout, offset, value);\n+        }\n+\n+        static <L extends ValueLayout, X> Accessor<X, L> of(L layout, X value,\n+                                                            SegmentGetter<X, L> segmentGetter, SegmentSetter<X, L> segmentSetter,\n+                                                            BufferGetter<X> bufferGetter, BufferSetter<X> bufferSetter) {\n+            return new Accessor<>(layout, value, segmentGetter, segmentSetter, bufferGetter, bufferSetter);\n@@ -122,1 +126,1 @@\n-    public void testSegmentAccess(String testName, Accessor<?, ?, ?> accessor) {\n+    public void testSegmentAccess(String testName, Accessor<?, ?> accessor) {\n@@ -127,1 +131,1 @@\n-    public void testSegmentAccessHyper(String testName, Accessor<?, ?, ?> accessor) {\n+    public void testSegmentAccessHyper(String testName, Accessor<?, ?> accessor) {\n@@ -155,0 +159,9 @@\n+    @Test(dataProvider = \"segmentAccessors\")\n+    public <X, L extends ValueLayout> void badAccessOverflowInIndexedAccess(String testName, Accessor<X, L> accessor) {\n+        MemorySegment segment = MemorySegment.ofArray(new byte[100]);\n+        if (testName.contains(\"\/index\") && accessor.layout.byteSize() > 1) {\n+            assertThrows(IndexOutOfBoundsException.class, () -> accessor.get(segment, Long.MAX_VALUE));\n+            assertThrows(IndexOutOfBoundsException.class, () -> accessor.set(segment, Long.MAX_VALUE, accessor.value));\n+        }\n+    }\n+\n@@ -161,1 +174,1 @@\n-                {\"byte\", Accessor.ofSegment(ValueLayout.JAVA_BYTE, (byte) 42,\n+                {\"byte\", Accessor.of(ValueLayout.JAVA_BYTE, (byte) 42,\n@@ -165,1 +178,1 @@\n-                {\"boolean\", Accessor.ofSegment(ValueLayout.JAVA_BOOLEAN, false,\n+                {\"boolean\", Accessor.of(ValueLayout.JAVA_BOOLEAN, false,\n@@ -169,1 +182,1 @@\n-                {\"char\", Accessor.ofSegment(ValueLayout.JAVA_CHAR, (char) 42,\n+                {\"char\", Accessor.of(ValueLayout.JAVA_CHAR, (char) 42,\n@@ -173,1 +186,1 @@\n-                {\"short\", Accessor.ofSegment(ValueLayout.JAVA_SHORT, (short) 42,\n+                {\"short\", Accessor.of(ValueLayout.JAVA_SHORT, (short) 42,\n@@ -177,1 +190,1 @@\n-                {\"int\", Accessor.ofSegment(ValueLayout.JAVA_INT, 42,\n+                {\"int\", Accessor.of(ValueLayout.JAVA_INT, 42,\n@@ -181,1 +194,1 @@\n-                {\"float\", Accessor.ofSegment(ValueLayout.JAVA_FLOAT, 42f,\n+                {\"float\", Accessor.of(ValueLayout.JAVA_FLOAT, 42f,\n@@ -185,1 +198,1 @@\n-                {\"long\", Accessor.ofSegment(ValueLayout.JAVA_LONG, 42L,\n+                {\"long\", Accessor.of(ValueLayout.JAVA_LONG, 42L,\n@@ -189,1 +202,1 @@\n-                {\"double\", Accessor.ofSegment(ValueLayout.JAVA_DOUBLE, 42d,\n+                {\"double\", Accessor.of(ValueLayout.JAVA_DOUBLE, 42d,\n@@ -193,1 +206,1 @@\n-                { \"address\", Accessor.ofSegment(ValueLayout.ADDRESS, MemorySegment.ofAddress(42),\n+                { \"address\", Accessor.of(ValueLayout.ADDRESS, MemorySegment.ofAddress(42),\n@@ -211,1 +224,1 @@\n-                {\"byte\/index\", Accessor.ofSegment(ValueLayout.JAVA_BYTE, (byte) 42,\n+                {\"byte\/index\", Accessor.of(ValueLayout.JAVA_BYTE, (byte) 42,\n@@ -215,1 +228,1 @@\n-                {\"boolean\/index\", Accessor.ofSegment(ValueLayout.JAVA_BOOLEAN, true,\n+                {\"boolean\/index\", Accessor.of(ValueLayout.JAVA_BOOLEAN, true,\n@@ -219,1 +232,1 @@\n-                {\"char\/index\", Accessor.ofSegment(ValueLayout.JAVA_CHAR, (char) 42,\n+                {\"char\/index\", Accessor.of(ValueLayout.JAVA_CHAR, (char) 42,\n@@ -223,1 +236,1 @@\n-                {\"short\/index\", Accessor.ofSegment(ValueLayout.JAVA_SHORT, (short) 42,\n+                {\"short\/index\", Accessor.of(ValueLayout.JAVA_SHORT, (short) 42,\n@@ -227,1 +240,1 @@\n-                {\"int\/index\", Accessor.ofSegment(ValueLayout.JAVA_INT, 42,\n+                {\"int\/index\", Accessor.of(ValueLayout.JAVA_INT, 42,\n@@ -231,1 +244,1 @@\n-                {\"float\/index\", Accessor.ofSegment(ValueLayout.JAVA_FLOAT, 42f,\n+                {\"float\/index\", Accessor.of(ValueLayout.JAVA_FLOAT, 42f,\n@@ -235,1 +248,1 @@\n-                {\"long\/index\", Accessor.ofSegment(ValueLayout.JAVA_LONG, 42L,\n+                {\"long\/index\", Accessor.of(ValueLayout.JAVA_LONG, 42L,\n@@ -239,1 +252,1 @@\n-                {\"double\/index\", Accessor.ofSegment(ValueLayout.JAVA_DOUBLE, 42d,\n+                {\"double\/index\", Accessor.of(ValueLayout.JAVA_DOUBLE, 42d,\n@@ -243,1 +256,1 @@\n-                { \"address\/index\", Accessor.ofSegment(ValueLayout.ADDRESS, MemorySegment.ofAddress(42),\n+                { \"address\/index\", Accessor.of(ValueLayout.ADDRESS, MemorySegment.ofAddress(42),\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAccessInstance.java","additions":55,"deletions":42,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -154,0 +154,5 @@\n+    @Test(dataProvider = \"allocators\", expectedExceptions = IllegalArgumentException.class)\n+    public void testBadAllocationArrayOverflow(SegmentAllocator allocator) {\n+        allocator.allocateArray(ValueLayout.JAVA_LONG,  Long.MAX_VALUE);\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestSegmentAllocators.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import java.util.Arrays;\n@@ -41,0 +42,1 @@\n+import org.testng.SkipException;\n@@ -78,0 +80,18 @@\n+    @Test(expectedExceptions = UnsupportedOperationException.class, dataProvider = \"segmentKinds\")\n+    public void testReadOnlyCopy(SegmentKind kind1, SegmentKind kind2) {\n+        MemorySegment s1 = kind1.makeSegment(TEST_BYTE_SIZE);\n+        MemorySegment s2 = kind2.makeSegment(TEST_BYTE_SIZE);\n+        \/\/ check failure with read-only dest\n+        MemorySegment.copy(s1, Type.BYTE.layout, 0, s2.asReadOnly(), Type.BYTE.layout, 0, 0);\n+    }\n+\n+    @Test(expectedExceptions = IndexOutOfBoundsException.class, dataProvider = \"types\")\n+    public void testBadOverflow(Type type) {\n+        if (type.layout.byteSize() > 1) {\n+            MemorySegment segment = MemorySegment.ofArray(new byte[100]);\n+            MemorySegment.copy(segment, type.layout, 0, segment, type.layout, 0, Long.MAX_VALUE);\n+        } else {\n+            throw new SkipException(\"Byte layouts do not overflow\");\n+        }\n+    }\n+\n@@ -192,0 +212,7 @@\n+    @DataProvider\n+    static Object[][] types() {\n+        return Arrays.stream(Type.values())\n+                .map(t -> new Object[] { t })\n+                .toArray(Object[][]::new);\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestSegmentCopy.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -137,0 +137,16 @@\n+    @Test\n+    public void testSliceAlignmentPowerOfTwo() {\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment segment = arena.allocate(100, 4096);\n+            for (int i = 8 ; i < 4096 ; i++) {\n+                boolean badAlign = Long.bitCount(i) != 1; \/\/ not a power of two\n+                try {\n+                    segment.asSlice(0, 100, i);\n+                    assertFalse(badAlign);\n+                } catch (IllegalArgumentException iae) {\n+                    assertTrue(badAlign);\n+                }\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestSlices.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"}]}