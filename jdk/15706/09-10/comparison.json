{"files":[{"patch":"@@ -67,1 +67,2 @@\n-     * {@return the {@code count} value of an {@code invokeinterface} instruction, as defined in {@jvms 6.5}}\n+     * {@return the {@code count} value of an {@code invokeinterface} instruction, as defined in {@jvms 6.5}\n+     * or {@code 0} for {@code invokespecial}, {@code invokestatic} and {@code invokevirtual} instructions}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/InvokeInstruction.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -259,4 +259,15 @@\n- * Basic syntax control can be achieved using symbolic descriptors. For example\n- * using {@link java.lang.constant.ClassDesc} assures the right serial form is\n- * used in the particular place inside classfile and also assures the class name\n- * has been already syntactically validated.\n+ * Syntax validation is applied during symbolic descriptors construction.\n+ * For example {@link java.lang.constant.ClassDesc#of} validates the class binary\n+ * name or {@link java.lang.constant.ClassDesc#ofDescriptor} validates the class\n+ * descriptor syntax.\n+ * <p>\n+ * Using symbolic descriptors assures the right serial form selection by\n+ * the ClassFile API library. For example a class name is stored in its internal\n+ * form as constant pool class entry or in a class descriptor form when represents\n+ * an array or as constant pool Utf8 entry in a class descriptor form when referenced\n+ * from an annotation. The library always converts symbols to the right serial\n+ * forms based on the actual context. Following example accepts syntactically\n+ * validated class binary name and performs conversion to internal class name.\n+ * {@snippet lang=java :\n+ * var validClassEntry = constantPoolBuilder.classEntry(ClassDesc.of(\"mypackage.MyClass\"));\n+ * }\n@@ -265,2 +276,5 @@\n- * constant pool entries to avoid any form of syntax control. Constant pool entries\n- * can be constructed from raw values, with no additional syntactic checks.\n+ * constant pool entries to avoid any form of syntax validation or conversion.\n+ * Constant pool entries can be constructed from raw values, with no additional\n+ * syntactic checks, conversions or validations. In the following example is\n+ * wrongly used binary class name and it is serialized without any validation or\n+ * conversion.\n@@ -268,2 +282,2 @@\n- * var invalidInternalClassName = constantPoolBuilder.classEntry(\n- *                                    constantPoolBuilder.utf8Entry(\"mypackage.MyClass\"));\n+ * var invalidClassEntry = constantPoolBuilder.classEntry(\n+ *                             constantPoolBuilder.utf8Entry(\"mypackage.MyClass\"));\n@@ -386,6 +400,11 @@\n- * <h3>Transformation handling of unknown classfile elements from a future<\/h3>\n- * To achieve stability of transformations in future JDK releases it is desired\n- * to set appropriate response to potential new classfile elements appearing.\n- * Transformation designed to handle all situation should be implemented strict way,\n- * so it fails when a new classfile element appears. As for example in the following\n- * strict compatibility-checking code transformation snippet:\n+ * <h3>Transformation handling of unknown classfile elements<\/h3>\n+ * Future JDK releases may introduce new classfile elements, not known at the\n+ * development time of a custom transformation code.\n+ * To achieve deterministic stability of transformations running on future JDK\n+ * releases it is desired to set appropriate response to classfile elements\n+ * unknown at the development time.\n+ * <p>\n+ * Classfile transforms interested in consuming all classfile elements should be\n+ * implemented strictly to throw exceptions if a new and unknown classfile\n+ * element appears. As for example in the following strict compatibility-checking\n+ * code transformation snippet:\n@@ -394,3 +413,4 @@\n- * However transformation selectively interested in just some of the classfile\n- * elements can pass all other elements by (including new unknown elements from\n- * future JDK releases). Following example shows such future-proof code transformation:\n+ * Conversely, classfile transforms that are only interested in consuming a portion\n+ * of classfile elements do not need to concern with new and unknown classfile\n+ * elements and may pass them through. Following example shows such future-proof\n+ * code transformation:\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/package-info.java","additions":37,"deletions":17,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -427,1 +427,1 @@\n-            return Util.parameterSlots(Util.methodTypeSymbol(method().nameAndType()));\n+            return 0;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractInstruction.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -133,1 +133,1 @@\n-                    if (instr.isInterface() && instr.opcode() != Opcode.INVOKESTATIC)\n+                    if (instr.opcode() == Opcode.INVOKEINTERFACE)\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/CodeWriter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-                \"ClassFile should have no SourceFile attribute when compiled without debug information.\");\n+                \"Classfile should have no SourceFile attribute when compiled without debug information.\");\n","filename":"test\/langtools\/tools\/javac\/classfiles\/attributes\/SourceFile\/NoSourceFileAttribute.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}