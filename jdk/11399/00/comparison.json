{"files":[{"patch":"@@ -41,0 +41,1 @@\n+import java.lang.reflect.ClassFileFormatVersion;\n@@ -1335,0 +1336,3 @@\n+     * The {@code AccessFlags} are the access flags of the class\n+     * that are specified for the class file format version;\n+     * any unspecified flags are omitted.\n@@ -1343,0 +1347,1 @@\n+     * <li> its class file format version is that of the component class\n@@ -1364,0 +1369,1 @@\n+        var cffv = ClassFileFormatVersion.fromMajor(getClassFileVersion() & 0xffff);\n@@ -1367,1 +1373,2 @@\n-                                            location);\n+                                            location,\n+                                            cffv);\n@@ -4691,1 +4698,2 @@\n-    private int getClassFileVersion() {\n+    \/* package-private *\/\n+    int getClassFileVersion() {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2640,0 +2640,4 @@\n+\n+            public int classFileFormatVersion(Class<?> clazz) {\n+                return clazz.getClassFileVersion();\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -489,1 +489,1 @@\n-     * positions not support for the location in question\n+     * positions not supported for the location in question\n@@ -495,1 +495,1 @@\n-            if ((mask &  accessMask) != 0) {\n+            if ((mask & accessMask) != 0) {\n@@ -498,0 +498,3 @@\n+                if (mask == 0) {\n+                    break;      \/\/ no more mask bits\n+                }\n@@ -508,0 +511,29 @@\n+    \/**\n+     * {@return an unmodifiable set of access flags for the given mask value\n+     * appropriate for the class file format version and location}\n+     * Mask bits not supported for the location are ignored.\n+     *\n+     * @param mask bit mask of access flags\n+     * @param location context to interpret mask value\n+     * @param cffv the class file format version\n+     *\/\n+    public static Set<AccessFlag> maskToAccessFlags(int mask, Location location,\n+                                                    ClassFileFormatVersion cffv) {\n+        Set<AccessFlag> result = java.util.EnumSet.noneOf(AccessFlag.class);\n+        for (var accessFlag : AccessFlag.values()) {\n+            int accessMask = accessFlag.mask();\n+            if ((mask & accessMask) != 0) {\n+                var locations = accessFlag.locations(cffv);\n+                if (locations.contains(location)) {\n+                    result.add(accessFlag);\n+                    mask = mask & ~accessMask;\n+                    if (mask == 0) {\n+                        break;      \/\/ no more mask bits\n+                    }\n+                }\n+            }\n+        }\n+        return Collections.unmodifiableSet(result);\n+    }\n+\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/AccessFlag.java","additions":34,"deletions":2,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -216,0 +216,3 @@\n+     * The {@code AccessFlags} are the access flags of the executable\n+     * that are specified for the class file format version;\n+     * any unspecified flags are omitted.\n@@ -223,0 +226,2 @@\n+        int major = SharedSecrets.getJavaLangAccess().classFileFormatVersion(getDeclaringClass()) & 0xffff;\n+        var cffv = ClassFileFormatVersion.fromMajor(major);\n@@ -224,1 +229,2 @@\n-                                            AccessFlag.Location.METHOD);\n+                                            AccessFlag.Location.METHOD,\n+                                            cffv);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Executable.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -217,0 +217,4 @@\n+     * The {@code AccessFlags} are the access flags of the field\n+     * that are specified for the class file format version of the class;\n+     * any unspecified flags are omitted.\n+     *\n@@ -223,1 +227,5 @@\n-        return AccessFlag.maskToAccessFlags(getModifiers(), AccessFlag.Location.FIELD);\n+        int major = SharedSecrets.getJavaLangAccess().classFileFormatVersion(getDeclaringClass()) & 0xffff;\n+        var cffv = ClassFileFormatVersion.fromMajor(major);\n+        return AccessFlag.maskToAccessFlags(getModifiers(),\n+                AccessFlag.Location.FIELD,\n+                cffv);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Field.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -540,0 +540,6 @@\n+\n+    \/**\n+     * Returns the class file format version of the class.\n+     *\/\n+    int classFileFormatVersion(Class<?> klass);\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+ \/\/ The synthetic modifier (0x1000) is not defined for class file format version 50 (Release 6)\n+\n+super synthetic public class VersionedLocationsClass_50\n+\tversion 50:0\n+{\n+\n+public synthetic Field synField:\"I\";\n+\n+public synthetic Method \"synMethod\":\"()V\"\n+        stack 1 locals 1\n+{\n+        return;\n+}\n+\n+public Method \"<init>\":\"()V\"\n+        stack 1 locals 1\n+{\n+        aload_0;\n+        invokespecial   Method java\/lang\/Object.\"<init>\":\"()V\";\n+        return;\n+}\n+\n+} \/\/ end Class VersionedLocationClass_50\n","filename":"test\/jdk\/java\/lang\/reflect\/AccessFlag\/VersionedLocationsClass_50.jasm","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+ \/\/ The synthetic modifier (0x1000)  is defined starting with class file format version 51 (Release 7)\n+\n+\n+\n+super synthetic public class VersionedLocationsClass_51\n+\tversion 51:0\n+{\n+\n+public synthetic Field synField:\"I\";\n+\n+public synthetic Method \"synMethod\":\"()V\"\n+        stack 1 locals 1\n+{\n+        return;\n+}\n+\n+public Method \"<init>\":\"()V\"\n+        stack 1 locals 1\n+{\n+        aload_0;\n+        invokespecial   Method java\/lang\/Object.\"<init>\":\"()V\";\n+        return;\n+}\n+\n+} \/\/ end Class VersionedLocationClass_51\n","filename":"test\/jdk\/java\/lang\/reflect\/AccessFlag\/VersionedLocationsClass_51.jasm","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -27,0 +27,1 @@\n+ * @compile VersionedLocationsClass_50.jasm VersionedLocationsClass_51.jasm\n@@ -28,0 +29,1 @@\n+ * @run main VersionedLocationsTest\n@@ -80,0 +82,1 @@\n+        testVersionedSyntheticClass();\n@@ -259,1 +262,38 @@\n-        compareLocations(expected, SYNTHETIC, cffv);\n+            compareLocations(expected, SYNTHETIC, cffv);\n+        }\n+    }\n+\n+    private record VersionedSyntheticTC(String label, boolean expectSynthetic,\n+                                        Set<AccessFlag> accessFlags) {};\n+\n+    private static void testVersionedSyntheticClass() throws Exception{\n+        final Class<?> syn51 = Class.forName(\"VersionedLocationsClass_51\");\n+        final Class<?> syn50 = Class.forName(\"VersionedLocationsClass_50\");\n+\n+        VersionedSyntheticTC[] testCases = {\n+                new VersionedSyntheticTC(\"clazz.accessFlags() - v51\", true,\n+                        syn51.accessFlags()),\n+\n+                new VersionedSyntheticTC(\"synMethod.accessFlags() - v51\", true,\n+                        syn51.getDeclaredMethod(\"synMethod\").accessFlags()),\n+\n+                new VersionedSyntheticTC(\"synField.accessFlags() - v51\", true,\n+                        syn51.getDeclaredField(\"synField\").accessFlags()),\n+\n+                new VersionedSyntheticTC(\"clazz.accessFlags() - v50\", false,\n+                        syn50.accessFlags()),\n+\n+                new VersionedSyntheticTC(\"synMethod.accessFlags() - v50\", false,\n+                        syn50.getDeclaredMethod(\"synMethod\").accessFlags()),\n+\n+                new VersionedSyntheticTC(\"synField.accessFlags() - v50\", false,\n+                        syn50.getDeclaredField(\"synField\").accessFlags()),\n+        };\n+\n+        for (VersionedSyntheticTC testcase : testCases) {\n+            final boolean hasSynthetic = testcase.accessFlags.contains(SYNTHETIC);\n+            if (testcase.expectSynthetic != hasSynthetic) {\n+                String err = testcase.expectSynthetic ? \"missing\" : \"unexpected\";\n+                throw new RuntimeException(testcase.label + \": \" + err +\n+                        \" SYNTHETIC in accessFlags: \" + testcase.accessFlags);\n+            }\n","filename":"test\/jdk\/java\/lang\/reflect\/AccessFlag\/VersionedLocationsTest.java","additions":41,"deletions":1,"binary":false,"changes":42,"status":"modified"}]}