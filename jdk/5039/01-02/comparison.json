{"files":[{"patch":"@@ -37,1 +37,3 @@\n-  if (plab_word_size < (threshold << BOTConstants::LogN_words)) {\n+  if (plab_word_size >= (threshold << BOTConstants::LogN_words)) {\n+    _dynamic_container_type = Array;\n+  } else {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BOTFixingCardSet.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2775,3 +2775,1 @@\n-    \/\/ if (_concurrent_bot_fixing->in_progress()) { \/\/ TODO\n-      _concurrent_bot_fixing->abort_and_wait();\n-    \/\/ }\n+    _concurrent_bot_fixing->abort_and_wait();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+  _stopped_count(0),\n@@ -190,1 +191,1 @@\n-  _current = NULL; \/\/ TODO why\n+  _current = NULL;\n@@ -217,0 +218,1 @@\n+  if (_stopped_count == _n_workers) return; \/\/ No workers\n@@ -236,0 +238,12 @@\n+\/\/ Called by one of the workers.\n+void G1ConcurrentBOTFixing::deactivate() {\n+  assert(ConcurrentBOTFixing_lock->owned_by_self(), \"Must be locked by self\");\n+  if (_in_progress && _inactive_count + _stopped_count == _n_workers) {\n+    _in_progress = false;\n+    _should_abort = false;\n+    ConcurrentBOTFixing_lock->notify_all(); \/\/ Notify that all workers are now inactive\/stopped\n+    log_trace(gc, bot)(\"Concurrent BOT fixing: took %8.2lf ms\",\n+                       (Ticks::now() - _stats.concurrent_phase_start_time).seconds() * MILLIUNITS);\n+  }\n+}\n+\n@@ -244,7 +258,7 @@\n-  if (_in_progress && _inactive_count == _n_workers) {\n-    _in_progress = false;\n-    _should_abort = false;\n-    ConcurrentBOTFixing_lock->notify_all(); \/\/ Notify that all workers are now inactive\n-    log_trace(gc, bot)(\"Concurrent BOT fixing: took %8.2lf ms\",\n-                       (Ticks::now() - _stats.concurrent_phase_start_time).seconds() * MILLIUNITS);\n-  }\n+  deactivate();\n+}\n+\n+void G1ConcurrentBOTFixing::note_stopped() {\n+  assert(ConcurrentBOTFixing_lock->owned_by_self(), \"Must be locked by self\");\n+  _stopped_count++;\n+  deactivate();\n@@ -285,1 +299,1 @@\n-    more_work = _fixer->fix_bot_step(); \/\/ TODO doesn't terminate\n+    more_work = _fixer->fix_bot_step();\n@@ -295,1 +309,1 @@\n-  _fixer->note_inactive();\n+  _fixer->note_stopped();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentBOTFixing.cpp","additions":24,"deletions":10,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -24,2 +24,3 @@\n-  \/\/ A counter to know when all workers have finished.\n-  uint _inactive_count;\n+  \/\/ Two counters to know when all workers have finished.\n+  uint _inactive_count; \/\/ Number of workers waiting for jobs\n+  uint _stopped_count; \/\/ Number of workers terminated\n@@ -31,1 +32,1 @@\n-  \/\/ A flag to know turn recording on\/off. Mainly to disable recording for full gcs.\n+  \/\/ A flag to turn recording on\/off. Mainly to disable recording for full gcs.\n@@ -53,1 +54,1 @@\n-  \/\/ Abort the jobs and wait for workers to stop.\n+  \/\/ Abort the jobs and wait for workers to finish.\n@@ -55,2 +56,4 @@\n-  \/\/ Workers use these to maintain _inactive_count and notify possible waiters\n-  \/\/ waiting for them to finish.\n+  \/\/ Signal that the workers have all finished.\n+  void deactivate();\n+  \/\/ Workers use these to maintain _inactive_count\/_stopped_count and notify possible waiters\n+  \/\/ waiting for the workers to finish.\n@@ -59,0 +62,1 @@\n+  void note_stopped();\n@@ -79,1 +83,1 @@\n-  \/\/ These threads always have a specific card in mind, that is, the dirty card it wants to refine.\n+  \/\/ These threads always have a specific card in mind, that is, the dirty card to refine.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentBOTFixing.hpp","additions":11,"deletions":7,"binary":false,"changes":18,"status":"modified"}]}