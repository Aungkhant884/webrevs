{"files":[{"patch":"@@ -1,289 +0,0 @@\n-#include \"gc\/g1\/g1BlockOffsetTable.hpp\"\n-#include \"gc\/g1\/g1BOTFixingCardSet.inline.hpp\"\n-#include \"gc\/g1\/heapRegion.hpp\"\n-\n-#include \"logging\/log.hpp\"\n-#include \"runtime\/atomic.hpp\"\n-#include \"utilities\/bitMap.hpp\"\n-\n-using CardIndex = G1BOTFixingCardSet::CardIndex;\n-\n-CardIndex G1BOTFixingCardSet::_last_card_index = 0;\n-size_t G1BOTFixingCardSet::_plab_word_size = 0;\n-G1BOTFixingCardSet::ContainerType G1BOTFixingCardSet::_dynamic_container_type = Array;\n-\n-G1BOTFixingCardSet::G1BOTFixingCardSet(HeapRegion* hr) :\n-  _type(Static),\n-  _start_card_index(_first_card_index),\n-  _num_plabs(0),\n-  _dynamic_container(NULL),\n-  _next(NULL),\n-  _hr(hr) {\n-  assert((size_t)HeapRegion::LogOfHRGrainBytes - BOTConstants::LogN <=\n-         sizeof(CardIndex) * BitsPerByte,\n-         \"Unable to encode card with \" SIZE_FORMAT \" bits\", sizeof(CardIndex) * BitsPerByte);\n-  for (uint i = 0; i < static_container_size; i++) {\n-    _static_container[i] = 0;\n-  }\n-}\n-\n-\/\/ Prepare globals for adding cards.\n-void G1BOTFixingCardSet::prepare(size_t plab_word_size) {\n-  \/\/ The last word's card.\n-  _last_card_index = (CardIndex)((HeapRegion::GrainWords - 1) >> BOTConstants::LogN_words);\n-  _plab_word_size = plab_word_size;\n-  size_t threshold = sizeof(CardIndex) * BitsPerByte;\n-  \/\/ If plab is smaller than (number of bits x card size).\n-  if (plab_word_size >= (threshold << BOTConstants::LogN_words)) {\n-    _dynamic_container_type = Array;\n-  } else {\n-    _dynamic_container_type = BitMap;\n-  }\n-}\n-\n-\/\/ New plabs are allocated above the current top. So BOT fixing starts at the current top.\n-\/\/ Anything below is considered fixed.\n-void G1BOTFixingCardSet::set_bot_fixing_start() {\n-  assert(_hr->is_old(), \"Only set for old regions\");\n-  if (_hr->top() == _hr->end()) {\n-    \/\/ Nothing to do.\n-    return;\n-  }\n-  CardIndex card_index_for_top = card_index_for(_hr->top());\n-  \/\/ The card of top() does not need to be fixed. Move to the next one.\n-  if (card_index_for_top == _last_card_index) {\n-    return;\n-  }\n-  _start_card_index = card_index_for_top + 1;\n-}\n-\n-void G1BOTFixingCardSet::transition_to_dynamic() {\n-  void* container_mem = NULL;\n-  \/\/ Size of the area in the region that needs fixing. We don't need to reserve space for\n-  \/\/ cards that don't need fixing in the container.\n-  size_t fix_size = HeapRegion::GrainWords -\n-                    (((size_t)_start_card_index) << BOTConstants::LogN_words);\n-  if (_dynamic_container_type == Array) {\n-    \/\/ +1 is because when the region is nearly full, there could be some space\n-    \/\/ smaller than _plab_word_size. A plab can still be allocated\n-    \/\/ into that space. We have to take that into account.\n-    size_t array_size = fix_size \/ _plab_word_size + (fix_size % _plab_word_size != 0) + 1;\n-    size_t container_size = G1BOTFixingCardSetArray::size_in_bytes(array_size);\n-    container_mem = NEW_C_HEAP_ARRAY(jbyte, container_size, mtGC);\n-    memset(container_mem, 0, container_size);\n-    new (container_mem) G1BOTFixingCardSetArray(array_size);\n-  } else {\n-    assert(_dynamic_container_type == BitMap, \"Sanity\");\n-    size_t max_num_cards = (fix_size >> BOTConstants::LogN_words);\n-    size_t container_size = G1BOTFixingCardSetBitMap::size_in_bytes(max_num_cards);\n-    container_mem = NEW_C_HEAP_ARRAY(jbyte, container_size, mtGC);\n-    memset(container_mem, 0, container_size);\n-    new (container_mem) G1BOTFixingCardSetBitMap(max_num_cards);\n-  }\n-\n-  \/\/ Guarantees that whoever fails must see the correct dynamic container.\n-  if (!Atomic::replace_if_null(&_dynamic_container, container_mem, memory_order_acq_rel)) {\n-    \/\/ Someone else replaced before us.\n-    FREE_C_HEAP_ARRAY(jbyte, container_mem);\n-    return;\n-  }\n-\n-  \/\/ Guarantees that whoever reads _type != Static can see the dynamic container.\n-  ContainerType t = Atomic::cmpxchg(&_type, Static, _dynamic_container_type, memory_order_acq_rel);\n-  assert(t == Static, \"We should be the only one setting the type\");\n-\n-  \/\/ Copy content from the static array to the new container.\n-  assert(_num_plabs >= static_container_size, \"Static container must be full\");\n-  for (uint i = 0; i < static_container_size; i++) {\n-    CardIndex c = (CardIndex)_static_container[i];\n-    if (_dynamic_container_type == Array) {\n-      ((G1BOTFixingCardSetArray*)container_mem)->add_card(array_index_for(c), c);\n-    } else {\n-      assert(_dynamic_container_type == BitMap, \"Sanity\");\n-      ((G1BOTFixingCardSetBitMap*)container_mem)->add_card(bitmap_effect_card_index_for(c));\n-    }\n-    _static_container[i] = 0;\n-  }\n-}\n-\n-void G1BOTFixingCardSet::add_card_to_dynamic(CardIndex card_index) {\n-  if (_dynamic_container_type == Array) {\n-    as_array()->add_card(array_index_for(card_index), card_index);\n-  } else {\n-    assert(_dynamic_container_type == BitMap, \"Sanity\");\n-    as_bitmap()->add_card(bitmap_effect_card_index_for(card_index));\n-  }\n-}\n-\n-bool G1BOTFixingCardSet::add_card(HeapWord* addr) {\n-  CardIndex card_index = card_index_for(addr);\n-  assert(card_index >= _start_card_index, \"No need to fix\");\n-  \/\/ Try to add to the static array first.\n-  if (Atomic::load_acquire(&_type) == Static) {\n-    uint i = Atomic::fetch_and_add(&_num_plabs, (uint)1, memory_order_relaxed);\n-    if (i < static_container_size) {\n-      _static_container[i] = card_index;\n-      return i == 0; \/\/ Is this the first card?\n-    } else {\n-      transition_to_dynamic();\n-    }\n-  }\n-  assert(_dynamic_container != NULL, \"Must be visible\");\n-\n-  add_card_to_dynamic(card_index);\n-  return false;\n-}\n-\n-bool G1BOTFixingCardSet::claim_card_from_dynamic(CardIndex card_index) {\n-  if (_dynamic_container_type == Array) {\n-    return as_array()->claim_card(array_index_for(card_index)) == card_index;\n-  } else {\n-    assert(_dynamic_container_type == BitMap, \"Sanity\");\n-    CardIndex effect_card_index = bitmap_effect_card_index_for(card_index);\n-    return as_bitmap()->claim_card(effect_card_index);\n-  }\n-}\n-\n-bool G1BOTFixingCardSet::claim_card(CardIndex card_index) {\n-  assert(card_index >= _start_card_index, \"No need to fix this card\");\n-  if (_type == Static) {\n-    for (uint i = 0; i < static_container_size; i++) {\n-      if ((CardIndex)_static_container[i] == card_index) {\n-        CardIndex c = (CardIndex)Atomic::cmpxchg(&_static_container[i], (WordType)card_index,\n-                                                 (WordType)0, memory_order_relaxed);\n-        return c == card_index;\n-      }\n-    }\n-    return false;\n-  }\n-\n-  return claim_card_from_dynamic(card_index);\n-}\n-\n-CardIndex G1BOTFixingCardSet::find_first_card_in(CardIndex min_card_index,\n-                                                 CardIndex max_card_index) {\n-  if (_dynamic_container_type == Array) {\n-    return as_array()->find_first_card_in(array_index_for(min_card_index),\n-                                          array_index_for(max_card_index));\n-  } else {\n-    assert(_dynamic_container_type == BitMap, \"Sanity\");\n-    CardIndex min_effect_card_index = bitmap_effect_card_index_for(min_card_index);\n-    CardIndex max_effect_card_index = bitmap_effect_card_index_for(max_card_index);\n-    CardIndex c = as_bitmap()->find_first_card_in(min_effect_card_index, max_effect_card_index);\n-    if (c == max_effect_card_index + 1) {\n-      \/\/ Not found.\n-      return 0;\n-    }\n-    return bitmap_card_index_for(c);\n-  }\n-}\n-\n-\/\/ Given a card boundary, return the card that represents the plab that crosses this boundary.\n-\/\/ This should be used by concurrent refinement to get the covering plab of a card table card.\n-\/\/ A possible plab start will help us narrow down the search range for this plab, where we\n-\/\/ assume the plab starts no later than latest_plab_start.\n-CardIndex G1BOTFixingCardSet::find_plab_covering(HeapWord* card_boundary,\n-                                                 HeapWord* latest_plab_start) {\n-  assert(card_boundary < _hr->top(), \"Sanity\");\n-  assert(is_aligned(card_boundary, BOTConstants::N_bytes), \"Must be aligned\");\n-  assert(latest_plab_start <= card_boundary, \"Not a helpful start addr\");\n-  assert(card_boundary < latest_plab_start + _plab_word_size, \"PLAB cannot possibly cover addr\");\n-  \/\/ If a plab covers the card boundary, we should be able to find\n-  \/\/ the last card of the plab at [card_boundary, latest_plab_start + _plab_word_size).\n-  CardIndex min_card_index = card_index_for(card_boundary);\n-  HeapWord* end_of_search = MIN2(latest_plab_start + _plab_word_size, _hr->top()) - 1;\n-  CardIndex max_card_index = card_index_for(end_of_search);\n-  assert(_start_card_index <= min_card_index && min_card_index <= max_card_index, \"Sanity\");\n-\n-  if (_type == Static) {\n-    CardIndex found = 0;\n-    for (uint i = 0; i < static_container_size; i++) {\n-      CardIndex c = (CardIndex)_static_container[i];\n-      if (min_card_index <= c && c <= max_card_index) {\n-        if (found == 0) {\n-          found = c;\n-        } else {\n-          \/\/ Sometimes multiple cards fall in this range (depending the given latest_plab_start),\n-          \/\/ we should use the smaller one. The other one must be a false match.\n-          found = MIN2(c, found);\n-        }\n-      }\n-    }\n-    return found;\n-  }\n-\n-  return find_first_card_in(min_card_index, max_card_index);\n-}\n-\n-void G1BOTFixingCardSet::iterate_cards_in_dynamic(CardIterator& iter) {\n-  if (_dynamic_container_type == Array) {\n-    return as_array()->iterate_cards(iter);\n-  } else {\n-    assert(_dynamic_container_type == BitMap, \"Sanity\");\n-\n-    class BOTFixingBitMapClosure: public BitMapClosure {\n-      G1BOTFixingCardSet* _card_set;\n-      CardIterator* _iter;\n-    public:\n-      BOTFixingBitMapClosure(G1BOTFixingCardSet* card_set, CardIterator* iter) :\n-        _card_set(card_set), _iter(iter) {}\n-      bool do_bit(BitMap::idx_t index) {\n-        return _iter->do_card(\n-          _card_set->bitmap_card_index_for((G1BOTFixingCardSetBitMap::card_index_for(index))));\n-      }\n-    } cl(this, &iter);\n-\n-    return as_bitmap()->iterate_cards(&cl);\n-  }\n-}\n-\n-void G1BOTFixingCardSet::iterate_cards(CardIterator& iter) {\n-  if (_type == Static) {\n-    for (uint i = 0; i < static_container_size; i++) {\n-      CardIndex card_index = (CardIndex)_static_container[i];\n-      if (card_index != 0) {\n-        if (card_index == Atomic::cmpxchg(&_static_container[i], (WordType)card_index, (WordType)0,\n-                                          memory_order_relaxed)) {\n-          if (!iter.do_card(card_index)) {\n-            return;\n-          }\n-        }\n-      }\n-    }\n-  } else {\n-    iterate_cards_in_dynamic(iter);\n-  }\n-}\n-\n-void G1BOTFixingCardSet::clear() {\n-  if (_type != Static) {\n-    \/\/ First transition back to static.\n-    _type = Static;\n-    FREE_C_HEAP_ARRAY(jbyte, _dynamic_container);\n-    _dynamic_container = NULL;\n-  }\n-\n-  _start_card_index = _first_card_index;\n-  _num_plabs = 0;\n-  for (uint i = 0; i < static_container_size; i++) {\n-    _static_container[i] = 0;\n-  }\n-}\n-\n-void G1BOTFixingCardSet::print_stats() {\n-  log_info(gc, bot)(\"BOT Fixing Card Set: region=%s, type=%d, start\/last=%d\/%d, n=%d\",\n-                    _hr->get_type_str(), _type, _start_card_index, _last_card_index, _num_plabs);\n-}\n-\n-void G1BOTFixingCardSet::verify() {\n-  assert(_type == Static, \"Type incorrect\");\n-  \/\/ An old region might not have its card set cleared since last gc, because it's never enlisted.\n-  assert(_start_card_index == _first_card_index || _hr->is_old(),\n-         \"Start card incorrect\");\n-  assert(_num_plabs == 0, \"Size not zero\");\n-  for (uint i = 0; i < static_container_size; i++) {\n-    assert(_static_container[i] == 0, \"Static container not zero\");\n-  }\n-  assert(_dynamic_container == NULL, \"Dynamic container not cleared\");\n-  \/\/ _next can be whatever (managed externally).\n-}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BOTFixingCardSet.cpp","additions":0,"deletions":289,"binary":false,"changes":289,"status":"deleted"},{"patch":"@@ -1,232 +0,0 @@\n-#ifndef SHARE_GC_G1_G1BOTFIXINGCARDSET_HPP\n-#define SHARE_GC_G1_G1BOTFIXINGCARDSET_HPP\n-\n-#include \"utilities\/bitMap.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-\n-class HeapRegion;\n-class G1BOTFixingCardSetArray;\n-class G1BOTFixingCardSetBitMap;\n-\n-\/\/ This card set contains the BOT entries (cards) that need to be fixed in a region.\n-\/\/ Each member uniquely identifies a plab by being the last card covered by the plab.\n-\/\/ Every card covered by a plab (except for the first one) need to be fixed.\n-\/\/ Knowing the last card of a plab is the same as knowing the cards it covers,\n-\/\/ because BOT can return the start of the plab given its last card, then we know\n-\/\/ what's in between. If BOT cannot precisely return the start of the plab (this happens when\n-\/\/ it gets fixed, probably by concurrent refinement), it will still return up to which point\n-\/\/ it has been fixed. Then we can fixed from there.\n-\/\/\n-\/\/ We chose to use the last card of a plab instead of the first card, because otherwise we cannot\n-\/\/ take advantage of this partially fixed case. However, if there is no partial fixing, i.e.,\n-\/\/ every plab gets fixed before we visit BOT for the area it covers, then there is not much\n-\/\/ difference.\n-\/\/\n-\/\/ This card set uses three types of containers. There could be either an array or a bitmap,\n-\/\/ depending on the plab size:\n-\/\/ Suppose the card size is 512 bytes and the largest region is 32m. A card can be represented\n-\/\/ using an offset with under 16 bits. The number of entries we need in an array is around\n-\/\/ region_size\/plab_size, which gives us array_size=region_size\/plab_size*16 bits.\n-\/\/ The size of a bitmap, using 1 bit for 1 card, for the same region would be region_size\/512 bits.\n-\/\/ So, using a bitmap is more worthwhile (in terms of space)\n-\/\/ than an array only when the plab size is smaller than 16x512 bytes, or 16 cards.\n-\/\/ This card set chooses the data structure accordingly given a plab_size.\n-\/\/\n-\/\/ Sometimes we know that the plabs are allocated above an address (e.g., region top before gc).\n-\/\/ We will use this information to reduce the required size.\n-\/\/\n-\/\/ The above two containers are dynamically allocated. To prevent too many dynamic allocations,\n-\/\/ there is also a fixed-sized array, which is supposed to handle most of the cases.\n-class G1BOTFixingCardSet {\n-public:\n-  typedef uint16_t CardIndex;\n-  typedef uint32_t WordType; \/\/ Atomic operations work with this granularity\n-  static_assert(sizeof(WordType) >= sizeof(CardIndex), \"Must be able to hold a card index\");\n-\n-  class CardIterator: public StackObj {\n-  public:\n-    \/\/ Return false to abort iteration.\n-    virtual bool do_card(CardIndex card_index) = 0;\n-  };\n-\n-private:\n-  enum ContainerType {\n-    Static,\n-    Array,\n-    BitMap\n-  };\n-  ContainerType _type;\n-\n-  \/\/ CardIndex 0 is considered an invalid card, because we never need to fix the first BOT entry.\n-  static const CardIndex _first_card_index = 1;\n-  \/\/ Fixing starts from this card. This should be set to the first card\n-  \/\/ after region top (not including region top) before gc.\n-  \/\/ This card is in [_first_card_index, _last_card_index].\n-  CardIndex _start_card_index;\n-  \/\/ The last card in a region. It's relative to the max size of the region.\n-  \/\/ This card might need special handling if we use an array container.\n-  static CardIndex _last_card_index;\n-\n-  \/\/ PLAB size recorded before each gc.\n-  static size_t _plab_word_size;\n-\n-  \/\/ Number of plabs recorded. Also a pointer into _static_container.\n-  \/\/ When we transition to using the dynamic array or bitmap, this stops updating.\n-  \/\/ So it's only good for is_empty() after that.\n-  uint _num_plabs;\n-\n-  \/\/ The statically allocated container.\n-  static constexpr uint static_container_size = 4; \/\/ Preferably at least the number of gc threads\n-  WordType _static_container[static_container_size];\n-\n-  \/\/ A type decided before each gc according to the plab size.\n-  static ContainerType _dynamic_container_type;\n-  \/\/ The dynamically allocated container.\n-  void* _dynamic_container;\n-\n-  \/\/ To form a list of card sets. Used in job dispatching and cleaning up.\n-  G1BOTFixingCardSet* _next;\n-\n-  \/\/ The owner heap region.\n-  HeapRegion* _hr;\n-\n-  size_t array_index_for(CardIndex card_index) const;\n-  CardIndex bitmap_effect_card_index_for(CardIndex card_index) const;\n-  CardIndex bitmap_card_index_for(CardIndex effect_card_index) const;\n-\n-  \/\/ Transition from static to dynamic container.\n-  void transition_to_dynamic();\n-\n-  G1BOTFixingCardSetArray* as_array();\n-  G1BOTFixingCardSetBitMap* as_bitmap();\n-\n-  void add_card_to_dynamic(CardIndex card_index);\n-\n-  bool claim_card_from_dynamic(CardIndex card_index);\n-\n-  \/\/ Find the first card in the range [min_card_index, max_card_index] in the dynamic container.\n-  CardIndex find_first_card_in(CardIndex min_card_index, CardIndex max_card_index);\n-\n-  void iterate_cards_in_dynamic(CardIterator& iter);\n-\n-public:\n-  G1BOTFixingCardSet(HeapRegion* hr);\n-\n-  static void prepare(size_t plab_word_size);\n-\n-  G1BOTFixingCardSet* next() const { return _next; }\n-  void set_next(G1BOTFixingCardSet* next) {\n-    _next = next;\n-  }\n-\n-  HeapRegion* hr() const { return _hr; }\n-\n-  bool is_empty() const { return _num_plabs == 0; }\n-  void mark_as_done() { _num_plabs = 0; }\n-\n-  CardIndex card_index_for(HeapWord* addr) const;\n-\n-  HeapWord* card_boundary_for(CardIndex card_index) const;\n-\n-  void set_bot_fixing_start();\n-  bool is_below_start(HeapWord* addr) const;\n-\n-  \/\/ Add the card of this address to the set. Return whether the container was empty.\n-  bool add_card(HeapWord* addr);\n-\n-  \/\/ Claim the card of this index and return whether it's successful.\n-  bool claim_card(CardIndex card_index);\n-\n-  \/\/ Find the last card of the plab that covers the given card boundary.\n-  \/\/ latest_plab_start specifies the latest point where the plab starts (say, given by\n-  \/\/ _hr->need_fixing(card_boundary)).\n-  \/\/ Return the card index. Note that this is not always accurate. The caller\n-  \/\/ might need to check whether this plab really covers the card boundary.\n-  CardIndex find_plab_covering(HeapWord* card_boundary, HeapWord* latest_plab_start);\n-\n-  \/\/ Iterate the cards.\n-  void iterate_cards(CardIterator& iter);\n-\n-  void clear();\n-\n-  void print_stats();\n-  void verify();\n-};\n-\n-class G1BOTFixingCardSetArray {\n-private:\n-  typedef G1BOTFixingCardSet::CardIndex CardIndex;\n-  typedef G1BOTFixingCardSet::WordType WordType;\n-  typedef G1BOTFixingCardSet::CardIterator CardIterator;\n-  static constexpr size_t EntriesPerWord = sizeof(WordType) \/ sizeof(CardIndex);\n-\n-  const size_t _size;\n-  CardIndex _data[1];\n-\n-  template<typename Derived>\n-  static size_t header_size_in_bytes_internal() {\n-    return offset_of(Derived, _data);\n-  }\n-\n-  inline void set_entry(size_t i, CardIndex v);\n-  inline CardIndex try_clear_entry(size_t i);\n-\n-public:\n-  G1BOTFixingCardSetArray(size_t num_elems) : _size(num_elems) {\n-    assert(_size > 0, \"Sanity\");\n-  }\n-\n-  static size_t size_in_bytes(size_t num_elems) {\n-    return header_size_in_bytes_internal<G1BOTFixingCardSetArray>() +\n-           align_up(num_elems, EntriesPerWord) * sizeof(CardIndex);\n-  }\n-\n-  void add_card(size_t position, CardIndex card_index);\n-\n-  CardIndex claim_card(size_t position);\n-  CardIndex find_first_card_in(size_t min_pos, size_t max_pos);\n-\n-  void iterate_cards(CardIterator& iter);\n-};\n-\n-class G1BOTFixingCardSetBitMap {\n-private:\n-  typedef G1BOTFixingCardSet::CardIndex CardIndex;\n-  typedef G1BOTFixingCardSet::CardIterator CardIterator;\n-\n-  const size_t _size_in_bits;\n-  BitMap::bm_word_t _bits[1];\n-\n-  template<typename Derived>\n-  static size_t header_size_in_bytes_internal() {\n-    return offset_of(Derived, _bits);\n-  }\n-\n-public:\n-  G1BOTFixingCardSetBitMap(size_t size_in_bits) : _size_in_bits(size_in_bits) {\n-    assert(_size_in_bits > 0, \"Sanity\");\n-  }\n-\n-  static size_t size_in_bytes(size_t size_in_bits) {\n-    return header_size_in_bytes_internal<G1BOTFixingCardSetBitMap>() +\n-           BitMap::calc_size_in_words(size_in_bits) * BytesPerWord;\n-  }\n-\n-  static BitMap::idx_t bit_position_for(CardIndex card_index) {\n-    assert(sizeof(CardIndex) <= sizeof(BitMap::idx_t), \"Sanity\");\n-    return card_index;\n-  }\n-  static CardIndex card_index_for(BitMap::idx_t bit_position) {\n-    assert(bit_position <= (BitMap::idx_t)(CardIndex)-1, \"Overflow\");\n-    return (CardIndex)bit_position;\n-  }\n-\n-  void add_card(CardIndex effect_card_index);\n-\n-  bool claim_card(CardIndex effect_card_index);\n-  CardIndex find_first_card_in(CardIndex min_card_index, CardIndex max_card_index);\n-\n-  void iterate_cards(BitMapClosure* cl);\n-};\n-\n-#endif \/\/ SHARE_GC_G1_G1BOTFIXINGCARDSET_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BOTFixingCardSet.hpp","additions":0,"deletions":232,"binary":false,"changes":232,"status":"deleted"},{"patch":"@@ -1,174 +0,0 @@\n-#ifndef SHARE_GC_G1_G1BOTFIXINGCARDSET_INLINE_HPP\n-#define SHARE_GC_G1_G1BOTFIXINGCARDSET_INLINE_HPP\n-\n-#include \"gc\/g1\/g1BlockOffsetTable.hpp\"\n-#include \"gc\/g1\/g1BOTFixingCardSet.hpp\"\n-#include \"gc\/g1\/heapRegion.hpp\"\n-\n-#include \"runtime\/atomic.hpp\"\n-#include \"utilities\/bitMap.inline.hpp\"\n-\n-\/\/ Set the element at i to v. This must success, assuming no other threads will try to set it.\n-inline void G1BOTFixingCardSetArray::set_entry(size_t i, CardIndex v) {\n-  assert(i < _size, \"Sanity\");\n-  CardIndex* entry = align_down(_data + i, sizeof(WordType));\n-  WordType* word_entry = (WordType*)entry;\n-  size_t offset = i % EntriesPerWord;\n-\n-  WordType old_val = *word_entry;\n-  WordType expect = 0;\n-  do {\n-    assert(((CardIndex*)(&old_val))[offset] == 0, \"Entry have been set\");\n-    expect = old_val;\n-    WordType new_val = expect;\n-    ((CardIndex*)(&new_val))[offset] = v;\n-    old_val = Atomic::cmpxchg(word_entry, expect, new_val, memory_order_relaxed);\n-  } while (old_val != expect);\n-}\n-\n-\/\/ Clear the entry at i. Success in clearing will return the original value at this position.\n-inline G1BOTFixingCardSet::CardIndex G1BOTFixingCardSetArray::try_clear_entry(size_t i) {\n-  assert(i < _size, \"Sanity\");\n-  CardIndex* entry = align_down(_data + i, sizeof(WordType));\n-  WordType* word_entry = (WordType*)entry;\n-  size_t offset = i % EntriesPerWord;\n-\n-  WordType old_val = *word_entry;\n-  WordType expect = 0;\n-  do {\n-    if (((CardIndex*)(&old_val))[offset] == 0) {\n-      return 0;\n-    }\n-    expect = old_val;\n-    WordType new_val = expect;\n-    ((CardIndex*)(&new_val))[offset] = 0;\n-    old_val = Atomic::cmpxchg(word_entry, expect, new_val, memory_order_relaxed);\n-  } while (old_val != expect);\n-  return old_val;\n-}\n-\n-inline void G1BOTFixingCardSetArray::add_card(size_t position, CardIndex card_index) {\n-  set_entry(position, card_index);\n-}\n-\n-inline G1BOTFixingCardSet::CardIndex G1BOTFixingCardSetArray::claim_card(size_t position) {\n-  return try_clear_entry(position);\n-}\n-\n-inline G1BOTFixingCardSet::CardIndex G1BOTFixingCardSetArray::find_first_card_in(size_t min_pos,\n-                                                                                 size_t max_pos) {\n-  assert(min_pos <= max_pos, \"Invalid range\");\n-  assert(max_pos < _size, \"Range out of bounds\");\n-  for (size_t i = min_pos; i <= max_pos; i++) {\n-    if (_data[i] != 0) {\n-      return _data[i];\n-    }\n-  }\n-  return 0;\n-}\n-\n-inline void G1BOTFixingCardSetArray::iterate_cards(CardIterator& iter) {\n-  for (size_t i = 0; i < _size; i++) {\n-    if (_data[i] != 0) {\n-      if (claim_card(i)) {\n-        if (iter.do_card(_data[i]) == false) {\n-          \/\/ Iteration aborts.\n-          return;\n-        }\n-      }\n-    }\n-  }\n-}\n-\n-inline void G1BOTFixingCardSetBitMap::add_card(CardIndex effect_card_index) {\n-  BitMapView bm(_bits, _size_in_bits);\n-  BitMap::idx_t bit_pos = bit_position_for(effect_card_index);\n-  assert(bit_pos < _size_in_bits, \"Out of bounds\");\n-  bool success = bm.par_set_bit(bit_pos, memory_order_relaxed);\n-  assert(success, \"Must success for add card\");\n-}\n-\n-inline bool G1BOTFixingCardSetBitMap::claim_card(CardIndex effect_card_index) {\n-  BitMapView bm(_bits, _size_in_bits);\n-  BitMap::idx_t bit_pos = bit_position_for(effect_card_index);\n-  if (bm.par_clear_bit(bit_pos, memory_order_relaxed)) {\n-    return true;\n-  }\n-  return false;\n-}\n-\n-inline G1BOTFixingCardSet::CardIndex G1BOTFixingCardSetBitMap::find_first_card_in(\n-    CardIndex min_effect_card_index, CardIndex max_effect_card_index) {\n-  BitMap::idx_t min_pos = bit_position_for(min_effect_card_index);\n-  BitMap::idx_t max_pos = bit_position_for(max_effect_card_index);\n-  assert(min_pos <= max_pos, \"Invalid range\");\n-  assert(max_pos < _size_in_bits, \"Range out of bounds\");\n-  BitMapView bm(_bits, _size_in_bits);\n-  BitMapView::idx_t one_position = bm.get_next_one_offset(min_pos, max_pos + 1);\n-  if (one_position == max_pos + 1) {\n-    \/\/ If this overflows, it will be zero, which is still an invalid value that we can check.\n-    return max_effect_card_index + 1;\n-  }\n-  return card_index_for(one_position);\n-}\n-\n-inline void G1BOTFixingCardSetBitMap::iterate_cards(BitMapClosure* cl) {\n-  BitMapView bm(_bits, _size_in_bits);\n-  bm.iterate(cl);\n-}\n-\n-inline G1BOTFixingCardSet::CardIndex G1BOTFixingCardSet::card_index_for(HeapWord* addr) const {\n-  assert(_hr->bottom() <= addr && addr < _hr->end(), \"Card index would overflow\");\n-  size_t card_index = pointer_delta(addr, _hr->bottom()) >> BOTConstants::LogN_words;\n-  assert(card_index <= _last_card_index, \"Sanity\");\n-  return (CardIndex)card_index;\n-}\n-\n-inline HeapWord* G1BOTFixingCardSet::card_boundary_for(CardIndex card_index) const {\n-  return _hr->bottom() + (((size_t)card_index) << BOTConstants::LogN_words);\n-}\n-\n-inline bool G1BOTFixingCardSet::is_below_start(HeapWord* addr) const {\n-  return card_index_for(addr) < _start_card_index;\n-}\n-\n-\/\/ Compute the array index for a card index. We will first offset the card index by\n-\/\/ -_start_card_index. Then we will check whether we need to handle the special case of\n-\/\/ _last_card_index.\n-inline size_t G1BOTFixingCardSet::array_index_for(CardIndex card_index) const {\n-  assert(card_index >= _start_card_index, \"No need to fix\");\n-  card_index -= _start_card_index;\n-  size_t index_in_array = (((size_t)card_index) << BOTConstants::LogN_words) \/ _plab_word_size;\n-  assert(_last_card_index >= _start_card_index, \"One of these is not correctly set\");\n-  if (card_index == _last_card_index - _start_card_index) {\n-    \/\/ There is a special case that a small plab can be allocated at the end of the region,\n-    \/\/ possibly making the last two plabs sharing the same array index, if using the above\n-    \/\/ calculation. Because this small plab's last card must also be the last card of the region,\n-    \/\/ we can identify it and store this one in the special slot.\n-    index_in_array++; \/\/ The special slot\n-  }\n-  return index_in_array;\n-}\n-\n-\/\/ Effective card index is card index minus _start_card_index.\n-\/\/ Effective card index is used for bitmap storage.\n-inline G1BOTFixingCardSet::CardIndex\n-G1BOTFixingCardSet::bitmap_effect_card_index_for(CardIndex card_index) const {\n-  assert(card_index >= _start_card_index, \"No need to fix\");\n-  return card_index - _start_card_index;\n-}\n-inline G1BOTFixingCardSet::CardIndex\n-G1BOTFixingCardSet::bitmap_card_index_for(CardIndex effect_card_index) const {\n-  assert(effect_card_index + _start_card_index <= _last_card_index, \"Sanity\");\n-  return effect_card_index + _start_card_index;\n-}\n-\n-inline G1BOTFixingCardSetArray* G1BOTFixingCardSet::as_array() {\n-  return (G1BOTFixingCardSetArray*)_dynamic_container;\n-}\n-\n-inline G1BOTFixingCardSetBitMap* G1BOTFixingCardSet::as_bitmap() {\n-  return (G1BOTFixingCardSetBitMap*)_dynamic_container;\n-}\n-\n-#endif \/\/ SHARE_GC_G1_G1BOTFIXINGCARDSET_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BOTFixingCardSet.inline.hpp","additions":0,"deletions":174,"binary":false,"changes":174,"status":"deleted"},{"patch":"@@ -0,0 +1,289 @@\n+#include \"gc\/g1\/g1BlockOffsetTable.hpp\"\n+#include \"gc\/g1\/g1BOTUpdateCardSet.inline.hpp\"\n+#include \"gc\/g1\/heapRegion.hpp\"\n+\n+#include \"logging\/log.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+#include \"utilities\/bitMap.hpp\"\n+\n+using CardIndex = G1BOTUpdateCardSet::CardIndex;\n+\n+CardIndex G1BOTUpdateCardSet::_last_card_index = 0;\n+size_t G1BOTUpdateCardSet::_plab_word_size = 0;\n+G1BOTUpdateCardSet::ContainerType G1BOTUpdateCardSet::_dynamic_container_type = Array;\n+\n+G1BOTUpdateCardSet::G1BOTUpdateCardSet(HeapRegion* hr) :\n+  _type(Static),\n+  _start_card_index(_first_card_index),\n+  _num_plabs(0),\n+  _dynamic_container(NULL),\n+  _next(NULL),\n+  _hr(hr) {\n+  assert((size_t)HeapRegion::LogOfHRGrainBytes - BOTConstants::LogN <=\n+         sizeof(CardIndex) * BitsPerByte,\n+         \"Unable to encode card with \" SIZE_FORMAT \" bits\", sizeof(CardIndex) * BitsPerByte);\n+  for (uint i = 0; i < static_container_size; i++) {\n+    _static_container[i] = 0;\n+  }\n+}\n+\n+\/\/ Prepare globals for adding cards.\n+void G1BOTUpdateCardSet::prepare(size_t plab_word_size) {\n+  \/\/ The last word's card.\n+  _last_card_index = (CardIndex)((HeapRegion::GrainWords - 1) >> BOTConstants::LogN_words);\n+  _plab_word_size = plab_word_size;\n+  size_t threshold = sizeof(CardIndex) * BitsPerByte;\n+  \/\/ If plab is smaller than (number of bits x card size).\n+  if (plab_word_size >= (threshold << BOTConstants::LogN_words)) {\n+    _dynamic_container_type = Array;\n+  } else {\n+    _dynamic_container_type = BitMap;\n+  }\n+}\n+\n+\/\/ New plabs are allocated above the current top. So BOT update starts at the current top.\n+\/\/ Anything below is considered updated.\n+void G1BOTUpdateCardSet::set_bot_update_start() {\n+  assert(_hr->is_old(), \"Only set for old regions\");\n+  if (_hr->top() == _hr->end()) {\n+    \/\/ Nothing to do.\n+    return;\n+  }\n+  CardIndex card_index_for_top = card_index_for(_hr->top());\n+  \/\/ The card of top() does not need to be updated. Move to the next one.\n+  if (card_index_for_top == _last_card_index) {\n+    return;\n+  }\n+  _start_card_index = card_index_for_top + 1;\n+}\n+\n+void G1BOTUpdateCardSet::transition_to_dynamic() {\n+  void* container_mem = NULL;\n+  \/\/ Size of the area in the region that needs update. We don't need to reserve space for\n+  \/\/ cards that don't need update in the container.\n+  size_t update_size = HeapRegion::GrainWords -\n+                       (((size_t)_start_card_index) << BOTConstants::LogN_words);\n+  if (_dynamic_container_type == Array) {\n+    \/\/ +1 is because when the region is nearly full, there could be some space\n+    \/\/ smaller than _plab_word_size. A plab can still be allocated\n+    \/\/ into that space. We have to take that into account.\n+    size_t array_size = update_size \/ _plab_word_size + (update_size % _plab_word_size != 0) + 1;\n+    size_t container_size = G1BOTUpdateCardSetArray::size_in_bytes(array_size);\n+    container_mem = NEW_C_HEAP_ARRAY(jbyte, container_size, mtGC);\n+    memset(container_mem, 0, container_size);\n+    new (container_mem) G1BOTUpdateCardSetArray(array_size);\n+  } else {\n+    assert(_dynamic_container_type == BitMap, \"Sanity\");\n+    size_t max_num_cards = (update_size >> BOTConstants::LogN_words);\n+    size_t container_size = G1BOTUpdateCardSetBitMap::size_in_bytes(max_num_cards);\n+    container_mem = NEW_C_HEAP_ARRAY(jbyte, container_size, mtGC);\n+    memset(container_mem, 0, container_size);\n+    new (container_mem) G1BOTUpdateCardSetBitMap(max_num_cards);\n+  }\n+\n+  \/\/ Guarantees that whoever fails must see the correct dynamic container.\n+  if (!Atomic::replace_if_null(&_dynamic_container, container_mem, memory_order_acq_rel)) {\n+    \/\/ Someone else replaced before us.\n+    FREE_C_HEAP_ARRAY(jbyte, container_mem);\n+    return;\n+  }\n+\n+  \/\/ Guarantees that whoever reads _type != Static can see the dynamic container.\n+  ContainerType t = Atomic::cmpxchg(&_type, Static, _dynamic_container_type, memory_order_acq_rel);\n+  assert(t == Static, \"We should be the only one setting the type\");\n+\n+  \/\/ Copy content from the static array to the new container.\n+  assert(_num_plabs >= static_container_size, \"Static container must be full\");\n+  for (uint i = 0; i < static_container_size; i++) {\n+    CardIndex c = (CardIndex)_static_container[i];\n+    if (_dynamic_container_type == Array) {\n+      ((G1BOTUpdateCardSetArray*)container_mem)->add_card(array_index_for(c), c);\n+    } else {\n+      assert(_dynamic_container_type == BitMap, \"Sanity\");\n+      ((G1BOTUpdateCardSetBitMap*)container_mem)->add_card(bitmap_effect_card_index_for(c));\n+    }\n+    _static_container[i] = 0;\n+  }\n+}\n+\n+void G1BOTUpdateCardSet::add_card_to_dynamic(CardIndex card_index) {\n+  if (_dynamic_container_type == Array) {\n+    as_array()->add_card(array_index_for(card_index), card_index);\n+  } else {\n+    assert(_dynamic_container_type == BitMap, \"Sanity\");\n+    as_bitmap()->add_card(bitmap_effect_card_index_for(card_index));\n+  }\n+}\n+\n+bool G1BOTUpdateCardSet::add_card(HeapWord* addr) {\n+  CardIndex card_index = card_index_for(addr);\n+  assert(card_index >= _start_card_index, \"No need to update\");\n+  \/\/ Try to add to the static array first.\n+  if (Atomic::load_acquire(&_type) == Static) {\n+    uint i = Atomic::fetch_and_add(&_num_plabs, (uint)1, memory_order_relaxed);\n+    if (i < static_container_size) {\n+      _static_container[i] = card_index;\n+      return i == 0; \/\/ Is this the first card?\n+    } else {\n+      transition_to_dynamic();\n+    }\n+  }\n+  assert(_dynamic_container != NULL, \"Must be visible\");\n+\n+  add_card_to_dynamic(card_index);\n+  return false;\n+}\n+\n+bool G1BOTUpdateCardSet::claim_card_from_dynamic(CardIndex card_index) {\n+  if (_dynamic_container_type == Array) {\n+    return as_array()->claim_card(array_index_for(card_index)) == card_index;\n+  } else {\n+    assert(_dynamic_container_type == BitMap, \"Sanity\");\n+    CardIndex effect_card_index = bitmap_effect_card_index_for(card_index);\n+    return as_bitmap()->claim_card(effect_card_index);\n+  }\n+}\n+\n+bool G1BOTUpdateCardSet::claim_card(CardIndex card_index) {\n+  assert(card_index >= _start_card_index, \"No need to update this card\");\n+  if (_type == Static) {\n+    for (uint i = 0; i < static_container_size; i++) {\n+      if ((CardIndex)_static_container[i] == card_index) {\n+        CardIndex c = (CardIndex)Atomic::cmpxchg(&_static_container[i], (WordType)card_index,\n+                                                 (WordType)0, memory_order_relaxed);\n+        return c == card_index;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  return claim_card_from_dynamic(card_index);\n+}\n+\n+CardIndex G1BOTUpdateCardSet::find_first_card_in(CardIndex min_card_index,\n+                                                 CardIndex max_card_index) {\n+  if (_dynamic_container_type == Array) {\n+    return as_array()->find_first_card_in(array_index_for(min_card_index),\n+                                          array_index_for(max_card_index));\n+  } else {\n+    assert(_dynamic_container_type == BitMap, \"Sanity\");\n+    CardIndex min_effect_card_index = bitmap_effect_card_index_for(min_card_index);\n+    CardIndex max_effect_card_index = bitmap_effect_card_index_for(max_card_index);\n+    CardIndex c = as_bitmap()->find_first_card_in(min_effect_card_index, max_effect_card_index);\n+    if (c == max_effect_card_index + 1) {\n+      \/\/ Not found.\n+      return 0;\n+    }\n+    return bitmap_card_index_for(c);\n+  }\n+}\n+\n+\/\/ Given a card boundary, return the card that represents the plab that crosses this boundary.\n+\/\/ This should be used by concurrent refinement to get the covering plab of a card table card.\n+\/\/ A possible plab start will help us narrow down the search range for this plab, where we\n+\/\/ assume the plab starts no later than latest_plab_start.\n+CardIndex G1BOTUpdateCardSet::find_plab_covering(HeapWord* card_boundary,\n+                                                 HeapWord* latest_plab_start) {\n+  assert(card_boundary < _hr->top(), \"Sanity\");\n+  assert(is_aligned(card_boundary, BOTConstants::N_bytes), \"Must be aligned\");\n+  assert(latest_plab_start <= card_boundary, \"Not a helpful start addr\");\n+  assert(card_boundary < latest_plab_start + _plab_word_size, \"PLAB cannot possibly cover addr\");\n+  \/\/ If a plab covers the card boundary, we should be able to find\n+  \/\/ the last card of the plab at [card_boundary, latest_plab_start + _plab_word_size).\n+  CardIndex min_card_index = card_index_for(card_boundary);\n+  HeapWord* end_of_search = MIN2(latest_plab_start + _plab_word_size, _hr->top()) - 1;\n+  CardIndex max_card_index = card_index_for(end_of_search);\n+  assert(_start_card_index <= min_card_index && min_card_index <= max_card_index, \"Sanity\");\n+\n+  if (_type == Static) {\n+    CardIndex found = 0;\n+    for (uint i = 0; i < static_container_size; i++) {\n+      CardIndex c = (CardIndex)_static_container[i];\n+      if (min_card_index <= c && c <= max_card_index) {\n+        if (found == 0) {\n+          found = c;\n+        } else {\n+          \/\/ Sometimes multiple cards fall in this range (depending the given latest_plab_start),\n+          \/\/ we should use the smaller one. The other one must be a false match.\n+          found = MIN2(c, found);\n+        }\n+      }\n+    }\n+    return found;\n+  }\n+\n+  return find_first_card_in(min_card_index, max_card_index);\n+}\n+\n+void G1BOTUpdateCardSet::iterate_cards_in_dynamic(CardIterator& iter) {\n+  if (_dynamic_container_type == Array) {\n+    return as_array()->iterate_cards(iter);\n+  } else {\n+    assert(_dynamic_container_type == BitMap, \"Sanity\");\n+\n+    class BOTUpdateBitMapClosure: public BitMapClosure {\n+      G1BOTUpdateCardSet* _card_set;\n+      CardIterator* _iter;\n+    public:\n+      BOTUpdateBitMapClosure(G1BOTUpdateCardSet* card_set, CardIterator* iter) :\n+        _card_set(card_set), _iter(iter) {}\n+      bool do_bit(BitMap::idx_t index) {\n+        return _iter->do_card(\n+          _card_set->bitmap_card_index_for((G1BOTUpdateCardSetBitMap::card_index_for(index))));\n+      }\n+    } cl(this, &iter);\n+\n+    return as_bitmap()->iterate_cards(&cl);\n+  }\n+}\n+\n+void G1BOTUpdateCardSet::iterate_cards(CardIterator& iter) {\n+  if (_type == Static) {\n+    for (uint i = 0; i < static_container_size; i++) {\n+      CardIndex card_index = (CardIndex)_static_container[i];\n+      if (card_index != 0) {\n+        if (card_index == Atomic::cmpxchg(&_static_container[i], (WordType)card_index, (WordType)0,\n+                                          memory_order_relaxed)) {\n+          if (!iter.do_card(card_index)) {\n+            return;\n+          }\n+        }\n+      }\n+    }\n+  } else {\n+    iterate_cards_in_dynamic(iter);\n+  }\n+}\n+\n+void G1BOTUpdateCardSet::clear() {\n+  if (_type != Static) {\n+    \/\/ First transition back to static.\n+    _type = Static;\n+    FREE_C_HEAP_ARRAY(jbyte, _dynamic_container);\n+    _dynamic_container = NULL;\n+  }\n+\n+  _start_card_index = _first_card_index;\n+  _num_plabs = 0;\n+  for (uint i = 0; i < static_container_size; i++) {\n+    _static_container[i] = 0;\n+  }\n+}\n+\n+void G1BOTUpdateCardSet::print_stats() {\n+  log_info(gc, bot)(\"BOT Update Card Set: region=%s, type=%d, start\/last=%d\/%d, n=%d\",\n+                    _hr->get_type_str(), _type, _start_card_index, _last_card_index, _num_plabs);\n+}\n+\n+void G1BOTUpdateCardSet::verify() {\n+  assert(_type == Static, \"Type incorrect\");\n+  \/\/ An old region might not have its card set cleared since last gc, because it's never enlisted.\n+  assert(_start_card_index == _first_card_index || _hr->is_old(),\n+         \"Start card incorrect\");\n+  assert(_num_plabs == 0, \"Size not zero\");\n+  for (uint i = 0; i < static_container_size; i++) {\n+    assert(_static_container[i] == 0, \"Static container not zero\");\n+  }\n+  assert(_dynamic_container == NULL, \"Dynamic container not cleared\");\n+  \/\/ _next can be whatever (managed externally).\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BOTUpdateCardSet.cpp","additions":289,"deletions":0,"binary":false,"changes":289,"status":"added"},{"patch":"@@ -0,0 +1,232 @@\n+#ifndef SHARE_GC_G1_G1BOTFIXINGCARDSET_HPP\n+#define SHARE_GC_G1_G1BOTFIXINGCARDSET_HPP\n+\n+#include \"utilities\/bitMap.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+class HeapRegion;\n+class G1BOTUpdateCardSetArray;\n+class G1BOTUpdateCardSetBitMap;\n+\n+\/\/ This card set contains the BOT entries (cards) that need to be updated in a region.\n+\/\/ Each member uniquely identifies a plab by being the last card covered by the plab.\n+\/\/ Every card covered by a plab (except for the first one) need to be updated.\n+\/\/ Knowing the last card of a plab is the same as knowing the cards it covers,\n+\/\/ because BOT can return the start of the plab given its last card, then we know\n+\/\/ what's in between. If BOT cannot precisely return the start of the plab (this happens when\n+\/\/ it gets updated, probably by concurrent refinement), it will still return up to which point\n+\/\/ it has been updated. Then we can update from there.\n+\/\/\n+\/\/ We chose to use the last card of a plab instead of the first card, because otherwise we cannot\n+\/\/ take advantage of this partially updated case. However, if there is no partial update, i.e.,\n+\/\/ every plab gets updated before we visit BOT for the area it covers, then there is not much\n+\/\/ difference.\n+\/\/\n+\/\/ This card set uses three types of containers. There could be either an array or a bitmap,\n+\/\/ depending on the plab size:\n+\/\/ Suppose the card size is 512 bytes and the largest region is 32m. A card can be represented\n+\/\/ using an offset with under 16 bits. The number of entries we need in an array is around\n+\/\/ region_size\/plab_size, which gives us array_size=region_size\/plab_size*16 bits.\n+\/\/ The size of a bitmap, using 1 bit for 1 card, for the same region would be region_size\/512 bits.\n+\/\/ So, using a bitmap is more worthwhile (in terms of space)\n+\/\/ than an array only when the plab size is smaller than 16x512 bytes, or 16 cards.\n+\/\/ This card set chooses the data structure accordingly given a plab_size.\n+\/\/\n+\/\/ Sometimes we know that the plabs are allocated above an address (e.g., region top before gc).\n+\/\/ We will use this information to reduce the required size.\n+\/\/\n+\/\/ The above two containers are dynamically allocated. To prevent too many dynamic allocations,\n+\/\/ there is also a fixed-sized array, which is supposed to handle most of the cases.\n+class G1BOTUpdateCardSet {\n+public:\n+  typedef uint16_t CardIndex;\n+  typedef uint32_t WordType; \/\/ Atomic operations work with this granularity\n+  static_assert(sizeof(WordType) >= sizeof(CardIndex), \"Must be able to hold a card index\");\n+\n+  class CardIterator: public StackObj {\n+  public:\n+    \/\/ Return false to abort iteration.\n+    virtual bool do_card(CardIndex card_index) = 0;\n+  };\n+\n+private:\n+  enum ContainerType {\n+    Static,\n+    Array,\n+    BitMap\n+  };\n+  ContainerType _type;\n+\n+  \/\/ CardIndex 0 is considered an invalid card, because we never need to update the first BOT entry.\n+  static const CardIndex _first_card_index = 1;\n+  \/\/ Update starts from this card. This should be set to the first card\n+  \/\/ after region top (not including region top) before gc.\n+  \/\/ This card is in [_first_card_index, _last_card_index].\n+  CardIndex _start_card_index;\n+  \/\/ The last card in a region. It's relative to the max size of the region.\n+  \/\/ This card might need special handling if we use an array container.\n+  static CardIndex _last_card_index;\n+\n+  \/\/ PLAB size recorded before each gc.\n+  static size_t _plab_word_size;\n+\n+  \/\/ Number of plabs recorded. Also a pointer into _static_container.\n+  \/\/ When we transition to using the dynamic array or bitmap, this stops updating.\n+  \/\/ So it's only good for is_empty() after that.\n+  uint _num_plabs;\n+\n+  \/\/ The statically allocated container.\n+  static constexpr uint static_container_size = 4; \/\/ Preferably at least the number of gc threads\n+  WordType _static_container[static_container_size];\n+\n+  \/\/ A type decided before each gc according to the plab size.\n+  static ContainerType _dynamic_container_type;\n+  \/\/ The dynamically allocated container.\n+  void* _dynamic_container;\n+\n+  \/\/ To form a list of card sets. Used in job dispatching and cleaning up.\n+  G1BOTUpdateCardSet* _next;\n+\n+  \/\/ The owner heap region.\n+  HeapRegion* _hr;\n+\n+  size_t array_index_for(CardIndex card_index) const;\n+  CardIndex bitmap_effect_card_index_for(CardIndex card_index) const;\n+  CardIndex bitmap_card_index_for(CardIndex effect_card_index) const;\n+\n+  \/\/ Transition from static to dynamic container.\n+  void transition_to_dynamic();\n+\n+  G1BOTUpdateCardSetArray* as_array();\n+  G1BOTUpdateCardSetBitMap* as_bitmap();\n+\n+  void add_card_to_dynamic(CardIndex card_index);\n+\n+  bool claim_card_from_dynamic(CardIndex card_index);\n+\n+  \/\/ Find the first card in the range [min_card_index, max_card_index] in the dynamic container.\n+  CardIndex find_first_card_in(CardIndex min_card_index, CardIndex max_card_index);\n+\n+  void iterate_cards_in_dynamic(CardIterator& iter);\n+\n+public:\n+  G1BOTUpdateCardSet(HeapRegion* hr);\n+\n+  static void prepare(size_t plab_word_size);\n+\n+  G1BOTUpdateCardSet* next() const { return _next; }\n+  void set_next(G1BOTUpdateCardSet* next) {\n+    _next = next;\n+  }\n+\n+  HeapRegion* hr() const { return _hr; }\n+\n+  bool is_empty() const { return _num_plabs == 0; }\n+  void mark_as_done() { _num_plabs = 0; }\n+\n+  CardIndex card_index_for(HeapWord* addr) const;\n+\n+  HeapWord* card_boundary_for(CardIndex card_index) const;\n+\n+  void set_bot_update_start();\n+  bool is_below_start(HeapWord* addr) const;\n+\n+  \/\/ Add the card of this address to the set. Return whether the container was empty.\n+  bool add_card(HeapWord* addr);\n+\n+  \/\/ Claim the card of this index and return whether it's successful.\n+  bool claim_card(CardIndex card_index);\n+\n+  \/\/ Find the last card of the plab that covers the given card boundary.\n+  \/\/ latest_plab_start specifies the latest point where the plab starts (say, given by\n+  \/\/ _hr->need_update(card_boundary)).\n+  \/\/ Return the card index. Note that this is not always accurate. The caller\n+  \/\/ might need to check whether this plab really covers the card boundary.\n+  CardIndex find_plab_covering(HeapWord* card_boundary, HeapWord* latest_plab_start);\n+\n+  \/\/ Iterate the cards.\n+  void iterate_cards(CardIterator& iter);\n+\n+  void clear();\n+\n+  void print_stats();\n+  void verify();\n+};\n+\n+class G1BOTUpdateCardSetArray {\n+private:\n+  typedef G1BOTUpdateCardSet::CardIndex CardIndex;\n+  typedef G1BOTUpdateCardSet::WordType WordType;\n+  typedef G1BOTUpdateCardSet::CardIterator CardIterator;\n+  static constexpr size_t EntriesPerWord = sizeof(WordType) \/ sizeof(CardIndex);\n+\n+  const size_t _size;\n+  CardIndex _data[1];\n+\n+  template<typename Derived>\n+  static size_t header_size_in_bytes_internal() {\n+    return offset_of(Derived, _data);\n+  }\n+\n+  inline void set_entry(size_t i, CardIndex v);\n+  inline CardIndex try_clear_entry(size_t i);\n+\n+public:\n+  G1BOTUpdateCardSetArray(size_t num_elems) : _size(num_elems) {\n+    assert(_size > 0, \"Sanity\");\n+  }\n+\n+  static size_t size_in_bytes(size_t num_elems) {\n+    return header_size_in_bytes_internal<G1BOTUpdateCardSetArray>() +\n+           align_up(num_elems, EntriesPerWord) * sizeof(CardIndex);\n+  }\n+\n+  void add_card(size_t position, CardIndex card_index);\n+\n+  CardIndex claim_card(size_t position);\n+  CardIndex find_first_card_in(size_t min_pos, size_t max_pos);\n+\n+  void iterate_cards(CardIterator& iter);\n+};\n+\n+class G1BOTUpdateCardSetBitMap {\n+private:\n+  typedef G1BOTUpdateCardSet::CardIndex CardIndex;\n+  typedef G1BOTUpdateCardSet::CardIterator CardIterator;\n+\n+  const size_t _size_in_bits;\n+  BitMap::bm_word_t _bits[1];\n+\n+  template<typename Derived>\n+  static size_t header_size_in_bytes_internal() {\n+    return offset_of(Derived, _bits);\n+  }\n+\n+public:\n+  G1BOTUpdateCardSetBitMap(size_t size_in_bits) : _size_in_bits(size_in_bits) {\n+    assert(_size_in_bits > 0, \"Sanity\");\n+  }\n+\n+  static size_t size_in_bytes(size_t size_in_bits) {\n+    return header_size_in_bytes_internal<G1BOTUpdateCardSetBitMap>() +\n+           BitMap::calc_size_in_words(size_in_bits) * BytesPerWord;\n+  }\n+\n+  static BitMap::idx_t bit_position_for(CardIndex card_index) {\n+    assert(sizeof(CardIndex) <= sizeof(BitMap::idx_t), \"Sanity\");\n+    return card_index;\n+  }\n+  static CardIndex card_index_for(BitMap::idx_t bit_position) {\n+    assert(bit_position <= (BitMap::idx_t)(CardIndex)-1, \"Overflow\");\n+    return (CardIndex)bit_position;\n+  }\n+\n+  void add_card(CardIndex effect_card_index);\n+\n+  bool claim_card(CardIndex effect_card_index);\n+  CardIndex find_first_card_in(CardIndex min_card_index, CardIndex max_card_index);\n+\n+  void iterate_cards(BitMapClosure* cl);\n+};\n+\n+#endif \/\/ SHARE_GC_G1_G1BOTFIXINGCARDSET_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BOTUpdateCardSet.hpp","additions":232,"deletions":0,"binary":false,"changes":232,"status":"added"},{"patch":"@@ -0,0 +1,174 @@\n+#ifndef SHARE_GC_G1_G1BOTFIXINGCARDSET_INLINE_HPP\n+#define SHARE_GC_G1_G1BOTFIXINGCARDSET_INLINE_HPP\n+\n+#include \"gc\/g1\/g1BlockOffsetTable.hpp\"\n+#include \"gc\/g1\/g1BOTUpdateCardSet.hpp\"\n+#include \"gc\/g1\/heapRegion.hpp\"\n+\n+#include \"runtime\/atomic.hpp\"\n+#include \"utilities\/bitMap.inline.hpp\"\n+\n+\/\/ Set the element at i to v. This must success, assuming no other threads will try to set it.\n+inline void G1BOTUpdateCardSetArray::set_entry(size_t i, CardIndex v) {\n+  assert(i < _size, \"Sanity\");\n+  CardIndex* entry = align_down(_data + i, sizeof(WordType));\n+  WordType* word_entry = (WordType*)entry;\n+  size_t offset = i % EntriesPerWord;\n+\n+  WordType old_val = *word_entry;\n+  WordType expect = 0;\n+  do {\n+    assert(((CardIndex*)(&old_val))[offset] == 0, \"Entry have been set\");\n+    expect = old_val;\n+    WordType new_val = expect;\n+    ((CardIndex*)(&new_val))[offset] = v;\n+    old_val = Atomic::cmpxchg(word_entry, expect, new_val, memory_order_relaxed);\n+  } while (old_val != expect);\n+}\n+\n+\/\/ Clear the entry at i. Success in clearing will return the original value at this position.\n+inline G1BOTUpdateCardSet::CardIndex G1BOTUpdateCardSetArray::try_clear_entry(size_t i) {\n+  assert(i < _size, \"Sanity\");\n+  CardIndex* entry = align_down(_data + i, sizeof(WordType));\n+  WordType* word_entry = (WordType*)entry;\n+  size_t offset = i % EntriesPerWord;\n+\n+  WordType old_val = *word_entry;\n+  WordType expect = 0;\n+  do {\n+    if (((CardIndex*)(&old_val))[offset] == 0) {\n+      return 0;\n+    }\n+    expect = old_val;\n+    WordType new_val = expect;\n+    ((CardIndex*)(&new_val))[offset] = 0;\n+    old_val = Atomic::cmpxchg(word_entry, expect, new_val, memory_order_relaxed);\n+  } while (old_val != expect);\n+  return ((CardIndex*)(&expect))[offset];\n+}\n+\n+inline void G1BOTUpdateCardSetArray::add_card(size_t position, CardIndex card_index) {\n+  set_entry(position, card_index);\n+}\n+\n+inline G1BOTUpdateCardSet::CardIndex G1BOTUpdateCardSetArray::claim_card(size_t position) {\n+  return try_clear_entry(position);\n+}\n+\n+inline G1BOTUpdateCardSet::CardIndex G1BOTUpdateCardSetArray::find_first_card_in(size_t min_pos,\n+                                                                                 size_t max_pos) {\n+  assert(min_pos <= max_pos, \"Invalid range\");\n+  assert(max_pos < _size, \"Range out of bounds\");\n+  for (size_t i = min_pos; i <= max_pos; i++) {\n+    if (_data[i] != 0) {\n+      return _data[i];\n+    }\n+  }\n+  return 0;\n+}\n+\n+inline void G1BOTUpdateCardSetArray::iterate_cards(CardIterator& iter) {\n+  for (size_t i = 0; i < _size; i++) {\n+    if (_data[i] != 0) {\n+      if (claim_card(i)) {\n+        if (iter.do_card(_data[i]) == false) {\n+          \/\/ Iteration aborts.\n+          return;\n+        }\n+      }\n+    }\n+  }\n+}\n+\n+inline void G1BOTUpdateCardSetBitMap::add_card(CardIndex effect_card_index) {\n+  BitMapView bm(_bits, _size_in_bits);\n+  BitMap::idx_t bit_pos = bit_position_for(effect_card_index);\n+  assert(bit_pos < _size_in_bits, \"Out of bounds\");\n+  bool success = bm.par_set_bit(bit_pos, memory_order_relaxed);\n+  assert(success, \"Must success for add card\");\n+}\n+\n+inline bool G1BOTUpdateCardSetBitMap::claim_card(CardIndex effect_card_index) {\n+  BitMapView bm(_bits, _size_in_bits);\n+  BitMap::idx_t bit_pos = bit_position_for(effect_card_index);\n+  if (bm.par_clear_bit(bit_pos, memory_order_relaxed)) {\n+    return true;\n+  }\n+  return false;\n+}\n+\n+inline G1BOTUpdateCardSet::CardIndex G1BOTUpdateCardSetBitMap::find_first_card_in(\n+    CardIndex min_effect_card_index, CardIndex max_effect_card_index) {\n+  BitMap::idx_t min_pos = bit_position_for(min_effect_card_index);\n+  BitMap::idx_t max_pos = bit_position_for(max_effect_card_index);\n+  assert(min_pos <= max_pos, \"Invalid range\");\n+  assert(max_pos < _size_in_bits, \"Range out of bounds\");\n+  BitMapView bm(_bits, _size_in_bits);\n+  BitMapView::idx_t one_position = bm.get_next_one_offset(min_pos, max_pos + 1);\n+  if (one_position == max_pos + 1) {\n+    \/\/ If this overflows, it will be zero, which is still an invalid value that we can check.\n+    return max_effect_card_index + 1;\n+  }\n+  return card_index_for(one_position);\n+}\n+\n+inline void G1BOTUpdateCardSetBitMap::iterate_cards(BitMapClosure* cl) {\n+  BitMapView bm(_bits, _size_in_bits);\n+  bm.iterate(cl);\n+}\n+\n+inline G1BOTUpdateCardSet::CardIndex G1BOTUpdateCardSet::card_index_for(HeapWord* addr) const {\n+  assert(_hr->bottom() <= addr && addr < _hr->end(), \"Card index would overflow\");\n+  size_t card_index = pointer_delta(addr, _hr->bottom()) >> BOTConstants::LogN_words;\n+  assert(card_index <= _last_card_index, \"Sanity\");\n+  return (CardIndex)card_index;\n+}\n+\n+inline HeapWord* G1BOTUpdateCardSet::card_boundary_for(CardIndex card_index) const {\n+  return _hr->bottom() + (((size_t)card_index) << BOTConstants::LogN_words);\n+}\n+\n+inline bool G1BOTUpdateCardSet::is_below_start(HeapWord* addr) const {\n+  return card_index_for(addr) < _start_card_index;\n+}\n+\n+\/\/ Compute the array index for a card index. We will first offset the card index by\n+\/\/ -_start_card_index. Then we will check whether we need to handle the special case of\n+\/\/ _last_card_index.\n+inline size_t G1BOTUpdateCardSet::array_index_for(CardIndex card_index) const {\n+  assert(card_index >= _start_card_index, \"No need to update\");\n+  card_index -= _start_card_index;\n+  size_t index_in_array = (((size_t)card_index) << BOTConstants::LogN_words) \/ _plab_word_size;\n+  assert(_last_card_index >= _start_card_index, \"One of these is not correctly set\");\n+  if (card_index == _last_card_index - _start_card_index) {\n+    \/\/ There is a special case that a small plab can be allocated at the end of the region,\n+    \/\/ possibly making the last two plabs sharing the same array index, if using the above\n+    \/\/ calculation. Because this small plab's last card must also be the last card of the region,\n+    \/\/ we can identify it and store this one in the special slot.\n+    index_in_array++; \/\/ The special slot\n+  }\n+  return index_in_array;\n+}\n+\n+\/\/ Effective card index is card index minus _start_card_index.\n+\/\/ Effective card index is used for bitmap storage.\n+inline G1BOTUpdateCardSet::CardIndex\n+G1BOTUpdateCardSet::bitmap_effect_card_index_for(CardIndex card_index) const {\n+  assert(card_index >= _start_card_index, \"No need to update\");\n+  return card_index - _start_card_index;\n+}\n+inline G1BOTUpdateCardSet::CardIndex\n+G1BOTUpdateCardSet::bitmap_card_index_for(CardIndex effect_card_index) const {\n+  assert(effect_card_index + _start_card_index <= _last_card_index, \"Sanity\");\n+  return effect_card_index + _start_card_index;\n+}\n+\n+inline G1BOTUpdateCardSetArray* G1BOTUpdateCardSet::as_array() {\n+  return (G1BOTUpdateCardSetArray*)_dynamic_container;\n+}\n+\n+inline G1BOTUpdateCardSetBitMap* G1BOTUpdateCardSet::as_bitmap() {\n+  return (G1BOTUpdateCardSetBitMap*)_dynamic_container;\n+}\n+\n+#endif \/\/ SHARE_GC_G1_G1BOTFIXINGCARDSET_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BOTUpdateCardSet.inline.hpp","additions":174,"deletions":0,"binary":false,"changes":174,"status":"added"},{"patch":"@@ -188,1 +188,1 @@\n-  HeapWord* need_fixing(HeapWord* addr) const;\n+  HeapWord* need_update(HeapWord* addr) const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BlockOffsetTable.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-inline HeapWord* G1BlockOffsetTablePart::need_fixing(HeapWord* addr) const {\n+inline HeapWord* G1BlockOffsetTablePart::need_update(HeapWord* addr) const {\n@@ -45,1 +45,1 @@\n-  \/\/ We use the function's side effect (to fix BOT), but not the function's result.\n+  \/\/ We use the function's side effect (to update BOT), but not the function's result.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BlockOffsetTable.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-#include \"gc\/g1\/g1ConcurrentBOTFixing.hpp\"\n+#include \"gc\/g1\/g1ConcurrentBOTUpdate.hpp\"\n@@ -1450,1 +1450,1 @@\n-  _concurrent_bot_fixing(NULL),\n+  _concurrent_bot_update(NULL),\n@@ -1700,2 +1700,2 @@\n-  if (G1UseConcurrentBOTFixing) {\n-    _concurrent_bot_fixing = new G1ConcurrentBOTFixing(this);\n+  if (G1UseConcurrentBOTUpdate) {\n+    _concurrent_bot_update = new G1ConcurrentBOTUpdate(this);\n@@ -1800,2 +1800,2 @@\n-  if (G1UseConcurrentBOTFixing) {\n-    _concurrent_bot_fixing->stop();\n+  if (G1UseConcurrentBOTUpdate) {\n+    _concurrent_bot_update->stop();\n@@ -2492,2 +2492,2 @@\n-  if (G1UseConcurrentBOTFixing) {\n-    _concurrent_bot_fixing->threads_do(tc);\n+  if (G1UseConcurrentBOTUpdate) {\n+    _concurrent_bot_update->threads_do(tc);\n@@ -2500,2 +2500,2 @@\n-  if (G1UseConcurrentBOTFixing) {\n-    _concurrent_bot_fixing->print_summary_info();\n+  if (G1UseConcurrentBOTUpdate) {\n+    _concurrent_bot_update->print_summary_info();\n@@ -2772,2 +2772,2 @@\n-void G1CollectedHeap::finalize_concurrent_bot_fixing() {\n-  if (G1UseConcurrentBOTFixing) {\n+void G1CollectedHeap::finalize_concurrent_bot_update() {\n+  if (G1UseConcurrentBOTUpdate) {\n@@ -2775,2 +2775,2 @@\n-    _concurrent_bot_fixing->abort_and_wait();\n-    _concurrent_bot_fixing->clear_card_sets();\n+    _concurrent_bot_update->abort_and_wait();\n+    _concurrent_bot_update->clear_card_sets();\n@@ -2779,1 +2779,1 @@\n-    phase_times()->record_concurrent_bot_fixing_finalize_time(time_ms);\n+    phase_times()->record_concurrent_bot_update_finalize_time(time_ms);\n@@ -3099,1 +3099,1 @@\n-    finalize_concurrent_bot_fixing();\n+    finalize_concurrent_bot_update();\n@@ -3159,2 +3159,2 @@\n-  if (G1UseConcurrentBOTFixing) {\n-    _concurrent_bot_fixing->activate();\n+  if (G1UseConcurrentBOTUpdate) {\n+    _concurrent_bot_update->activate();\n@@ -3389,3 +3389,3 @@\n-    void prepare_bot_fixing_card_set(HeapRegion* hr) {\n-      if (G1UseConcurrentBOTFixing) {\n-        DEBUG_ONLY(hr->bot_fixing_card_set()->verify();)\n+    void prepare_bot_update_card_set(HeapRegion* hr) {\n+      if (G1UseConcurrentBOTUpdate) {\n+        DEBUG_ONLY(hr->bot_update_card_set()->verify();)\n@@ -3393,1 +3393,1 @@\n-          hr->set_bot_fixing_start();\n+          hr->set_bot_update_start();\n@@ -3472,1 +3472,1 @@\n-      prepare_bot_fixing_card_set(hr);\n+      prepare_bot_update_card_set(hr);\n@@ -3598,2 +3598,2 @@\n-    if (G1UseConcurrentBOTFixing) {\n-      _concurrent_bot_fixing->pre_record_plab_allocation();\n+    if (G1UseConcurrentBOTUpdate) {\n+      _concurrent_bot_update->pre_record_plab_allocation();\n@@ -3865,2 +3865,2 @@\n-  if (G1UseConcurrentBOTFixing) {\n-    _concurrent_bot_fixing->post_record_plab_allocation();\n+  if (G1UseConcurrentBOTUpdate) {\n+    _concurrent_bot_update->post_record_plab_allocation();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":27,"deletions":27,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-class G1ConcurrentBOTFixing;\n+class G1ConcurrentBOTUpdate;\n@@ -197,1 +197,1 @@\n-  G1ConcurrentBOTFixing* _concurrent_bot_fixing;\n+  G1ConcurrentBOTUpdate* _concurrent_bot_update;\n@@ -798,1 +798,1 @@\n-  void finalize_concurrent_bot_fixing();\n+  void finalize_concurrent_bot_update();\n@@ -1066,1 +1066,1 @@\n-  G1ConcurrentBOTFixing* concurrent_bot_fixing() const { return _concurrent_bot_fixing; }\n+  G1ConcurrentBOTUpdate* concurrent_bot_update() const { return _concurrent_bot_update; }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1,317 +0,0 @@\n-#include \"gc\/g1\/g1BlockOffsetTable.inline.hpp\"\n-#include \"gc\/g1\/g1BOTFixingCardSet.inline.hpp\"\n-#include \"gc\/g1\/g1CardTable.hpp\"\n-#include \"gc\/g1\/g1CollectedHeap.hpp\"\n-#include \"gc\/g1\/g1ConcurrentBOTFixing.hpp\"\n-#include \"gc\/g1\/heapRegion.inline.hpp\"\n-\n-#include \"logging\/log.hpp\"\n-#include \"runtime\/atomic.hpp\"\n-#include \"runtime\/os.hpp\"\n-\n-using CardIndex = G1BOTFixingCardSet::CardIndex;\n-\n-class G1ConcurrentBOTFixingThread: public ConcurrentGCThread {\n-  friend class G1ConcurrentBOTFixing;\n-\n-  double _vtime_accum;\n-  G1ConcurrentBOTFixing* _fixer;\n-\n-  G1ConcurrentBOTFixingThread(G1ConcurrentBOTFixing* fixer, uint i);\n-\n-  void wait_for_work(bool more_work);\n-\n-  void run_service();\n-  void stop_service();\n-\n-  double vtime_accum() const { return _vtime_accum; }\n-};\n-\n-G1ConcurrentBOTFixing::G1ConcurrentBOTFixing(G1CollectedHeap* g1h) :\n-  _g1h(g1h),\n-  _in_progress(false),\n-  _should_abort(false),\n-  _n_workers(ConcGCThreads),\n-  _inactive_count(0),\n-  _stopped_count(0),\n-  _fixer_threads(NULL),\n-  _plab_word_size(0),\n-  _plab_recording_in_progress(false),\n-  _card_sets(NULL),\n-  _current(NULL),\n-  _stats() {\n-  _fixer_threads = NEW_C_HEAP_ARRAY(G1ConcurrentBOTFixingThread*, _n_workers, mtGC);\n-  for (uint i = 0; i < _n_workers; i++) {\n-    G1ConcurrentBOTFixingThread* t = NULL;\n-    if (!InjectGCWorkerCreationFailure) {\n-      t = new G1ConcurrentBOTFixingThread(this, i);\n-    }\n-    if (t == NULL || t->osthread() == NULL) {\n-      log_warning(gc, bot)(\"Unable to create G1ConcurrentBOTFixingThread #%d\", i);\n-      if (i == 0) {\n-        G1UseConcurrentBOTFixing = false;\n-      }\n-      _n_workers = i; \/\/ Actual number of threads created\n-      break;\n-    }\n-    _fixer_threads[i] = t;\n-  }\n-}\n-\n-void G1ConcurrentBOTFixing::fix_bot_for_card_set(G1BOTFixingCardSet* card_set) {\n-  assert(!card_set->is_empty(), \"We should be the only one emptying it\");\n-  card_set->print_stats();\n-  class BOTFixingCardSetClosure: public G1BOTFixingCardSet::CardIterator {\n-    G1ConcurrentBOTFixing* _fixer;\n-    HeapRegion* _hr;\n-\n-  public:\n-    uint _num_plabs;\n-\n-    BOTFixingCardSetClosure(G1ConcurrentBOTFixing* fixer, HeapRegion* hr) :\n-      _fixer(fixer), _hr(hr), _num_plabs(0) {}\n-    bool do_card(CardIndex card_index) {\n-      HeapWord* card_boundary = _hr->bot_fixing_card_set()->card_boundary_for(card_index);\n-      \/\/ We have the last card boundary cover by a plab.\n-      \/\/ We will fix the block (normally the block will be the plab) that covers this card boundary.\n-      _hr->update_bot(card_boundary);\n-      _num_plabs++;\n-      return (_fixer->should_abort() == false); \/\/ Stop iteration if it aborts\n-    }\n-  } cl(this, card_set->hr());\n-\n-  Ticks start = Ticks::now();\n-  card_set->iterate_cards(cl);\n-  card_set->mark_as_done();\n-  log_info(gc, bot)(\"Concurrent BOT Fixing: fixed %d plabs, took %8.2lf ms\",\n-                    cl._num_plabs, (Ticks::now() - start).seconds() * MILLIUNITS);\n-}\n-\n-bool G1ConcurrentBOTFixing::fix_bot_step() {\n-  G1BOTFixingCardSet* old_val = _current;\n-  G1BOTFixingCardSet* expect = NULL;\n-  G1BOTFixingCardSet* new_val = NULL;\n-  do {\n-    if (old_val == NULL) return false;\n-\n-    expect = old_val;\n-    new_val = expect->next();\n-    old_val = Atomic::cmpxchg(&_current, expect, new_val, memory_order_relaxed);\n-  } while (old_val != expect);\n-\n-  fix_bot_for_card_set(old_val);\n-\n-  return (new_val != NULL) && !_should_abort;\n-}\n-\n-void G1ConcurrentBOTFixing::fix_bot_before_refine(HeapRegion* r, HeapWord* card_boundary) {\n-  assert(r->is_old(), \"Only do this for heap regions with BOT\");\n-  assert(_g1h->card_table()->is_card_aligned(card_boundary), \"Only do this for cards to refine\");\n-\n-  Ticks start = Ticks::now();\n-  \/\/ If the region doesn't have plabs or if the card is below where plabs are allocated.\n-  G1BOTFixingCardSet* card_set = r->bot_fixing_card_set();\n-  if (card_set->is_empty() || card_set->is_below_start(card_boundary)) return;\n-\n-  \/\/ If the card points into an object instead of a plab.\n-  HeapWord* latest_plab_start = r->need_fixing(card_boundary);\n-  if (latest_plab_start == NULL) return;\n-\n-  \/\/ If the plab has been claimed.\n-  CardIndex c = card_set->find_plab_covering(card_boundary, latest_plab_start);\n-  if (c == 0) return;\n-  \/\/ In some rare cases, the plab have been claimed and we get the plab after that plab.\n-  \/\/ Since it's rare, we do not check this case and let this thread fix the wrong plab.\n-  \/\/ This will (nicely) leave more time for the fix result of first plab to be visible to us.\n-  if (!card_set->claim_card(c)) return;\n-\n-  r->update_bot(card_set->card_boundary_for(c));\n-}\n-\n-void G1ConcurrentBOTFixing::pre_record_plab_allocation() {\n-  assert_at_safepoint_on_vm_thread();\n-  assert(_card_sets == NULL, \"Sanity\");\n-  _plab_word_size = _g1h->desired_plab_sz(G1HeapRegionAttr::Old);\n-  G1BOTFixingCardSet::prepare(_plab_word_size);\n-  _plab_recording_in_progress = true;\n-}\n-\n-void G1ConcurrentBOTFixing::enlist_card_set(G1BOTFixingCardSet* card_set) {\n-  assert(!card_set->is_empty(), \"Invalid card set\");\n-  G1BOTFixingCardSet* old_val = _card_sets;\n-  G1BOTFixingCardSet* expect = NULL;\n-  do {\n-    expect = old_val;\n-    old_val = Atomic::cmpxchg(&_card_sets, expect, card_set, memory_order_relaxed);\n-  } while (old_val != expect);\n-  card_set->set_next(old_val);\n-}\n-\n-void G1ConcurrentBOTFixing::record_plab_allocation(HeapWord* plab_allocation, size_t word_size) {\n-  if (!_plab_recording_in_progress) return;\n-\n-  HeapRegion* r = _g1h->heap_region_containing(plab_allocation);\n-  assert(r->is_old(), \"Only old regions need this\");\n-  assert(word_size > 0, \"Sanity\");\n-  \/\/ Only when a region is full can a plab be smaller than its desired size.\n-  assert(word_size == _plab_word_size ||\n-         (word_size < _plab_word_size && plab_allocation + word_size == r->end()),\n-         \"Invalid plab size\");\n-\n-  HeapWord* first_card_boundary = align_down(plab_allocation, BOTConstants::N_bytes);\n-  HeapWord* last_card_boundary = align_down(plab_allocation + word_size - 1, BOTConstants::N_bytes);\n-  if (first_card_boundary == last_card_boundary) {\n-    \/\/ PLABs not crossing boundary could not have changed BOT. No need to fix them.\n-    return;\n-  }\n-\n-  G1BOTFixingCardSet* card_set = r->bot_fixing_card_set();\n-  bool should_enlist = card_set->add_card(last_card_boundary);\n-\n-  if (should_enlist) {\n-    enlist_card_set(card_set);\n-  }\n-}\n-\n-void G1ConcurrentBOTFixing::post_record_plab_allocation() {\n-  assert_at_safepoint_on_vm_thread();\n-  _plab_recording_in_progress = false;\n-  _current = _card_sets;\n-}\n-\n-void G1ConcurrentBOTFixing::clear_card_sets() {\n-  assert_at_safepoint_on_vm_thread();\n-  uint count[2] = { 0, 0 };\n-  while (_card_sets != NULL) {\n-    G1BOTFixingCardSet* card_set = _card_sets;\n-    _card_sets = _card_sets->next();\n-    count[card_set->is_empty()]++;\n-    card_set->clear();\n-  }\n-  _current = NULL;\n-  log_info(gc, bot)(\"Concurrent BOT Fixing: processed\/aborted = %d\/%d\", count[1], count[0]);\n-}\n-\n-void G1ConcurrentBOTFixing::threads_do(ThreadClosure* tc) {\n-  for (uint i = 0; i < _n_workers; i++) {\n-    tc->do_thread(_fixer_threads[i]);\n-  }\n-}\n-\n-void G1ConcurrentBOTFixing::print_summary_info() {\n-  Log(gc, bot) log;\n-  if (log.is_trace()) {\n-    log.trace(\" Concurrent BOT fixing:\");\n-    for (uint i = 0; i < _n_workers; i++) {\n-      log.trace(\"  Worker #%d concurrent time = %8.2f s.\", i, _fixer_threads[i]->vtime_accum());\n-    }\n-  }\n-}\n-\n-\/\/ Synchronization between the BOT fixing threads and the activating\/aborting VM thread.\n-\n-\/\/ Called by VM thread.\n-void G1ConcurrentBOTFixing::activate() {\n-  MutexLocker ml(ConcurrentBOTFixing_lock, Mutex::_no_safepoint_check_flag);\n-  assert(_in_progress == false, \"Activated twice\");\n-  assert(_should_abort == false, \"Sanity\");\n-  if (_stopped_count == _n_workers) return; \/\/ No workers\n-  _in_progress = true;\n-  ConcurrentBOTFixing_lock->notify_all();\n-  _stats.concurrent_phase_start_time = Ticks::now();\n-}\n-\n-\/\/ Called by VM thread.\n-void G1ConcurrentBOTFixing::abort_and_wait() {\n-  MonitorLocker ml(ConcurrentBOTFixing_lock, Mutex::_no_safepoint_check_flag);\n-  if (_in_progress) {\n-    _should_abort = true;\n-  } else {\n-    assert(_should_abort == false, \"Must have cleared this\");\n-  }\n-  while (_in_progress) {\n-    assert(_should_abort, \"Who changed this?\");\n-    ml.wait();\n-  }\n-}\n-\n-\/\/ Called by one of the workers.\n-void G1ConcurrentBOTFixing::deactivate() {\n-  assert(ConcurrentBOTFixing_lock->owned_by_self(), \"Must be locked by self\");\n-  if (_in_progress && _inactive_count + _stopped_count == _n_workers) {\n-    _in_progress = false;\n-    _should_abort = false;\n-    ConcurrentBOTFixing_lock->notify_all(); \/\/ Notify that all workers are now inactive\/stopped\n-    log_trace(gc, bot)(\"Concurrent BOT fixing: took %8.2lf ms\",\n-                       (Ticks::now() - _stats.concurrent_phase_start_time).seconds() * MILLIUNITS);\n-  }\n-}\n-\n-void G1ConcurrentBOTFixing::note_active() {\n-  assert(ConcurrentBOTFixing_lock->owned_by_self(), \"Must be locked by self\");\n-  _inactive_count--;\n-}\n-\n-void G1ConcurrentBOTFixing::note_inactive() {\n-  assert(ConcurrentBOTFixing_lock->owned_by_self(), \"Must be locked by self\");\n-  _inactive_count++;\n-  deactivate();\n-}\n-\n-void G1ConcurrentBOTFixing::note_stopped() {\n-  assert(ConcurrentBOTFixing_lock->owned_by_self(), \"Must be locked by self\");\n-  _stopped_count++;\n-  deactivate();\n-}\n-\n-void G1ConcurrentBOTFixing::stop() {\n-  for (uint i = 0; i < _n_workers; i++) {\n-    _fixer_threads[i]->stop();\n-  }\n-}\n-\n-G1ConcurrentBOTFixingThread::G1ConcurrentBOTFixingThread(G1ConcurrentBOTFixing* fixer, uint i) :\n-  ConcurrentGCThread(), _vtime_accum(0.0), _fixer(fixer) {\n-  set_name(\"G1 BOT Fixing #%d\", i);\n-  create_and_start();\n-}\n-\n-void G1ConcurrentBOTFixingThread::wait_for_work(bool more_work) {\n-  MonitorLocker ml(ConcurrentBOTFixing_lock, Mutex::_no_safepoint_check_flag);\n-  _fixer->note_inactive();\n-  while ((!more_work || _fixer->should_abort()) && !should_terminate()) {\n-    ml.wait();\n-    more_work = _fixer->in_progress();\n-  }\n-  _fixer->note_active();\n-}\n-\n-void G1ConcurrentBOTFixingThread::run_service() {\n-  double vtime_start = os::elapsedVTime();\n-\n-  bool more_work = false;\n-  while (!should_terminate()) {\n-    wait_for_work(more_work);\n-    if (should_terminate()) {\n-      break;\n-    }\n-\n-    more_work = _fixer->fix_bot_step();\n-\n-    if (os::supports_vtime()) {\n-      _vtime_accum = (os::elapsedVTime() - vtime_start);\n-    } else {\n-      _vtime_accum = 0.0;\n-    }\n-  }\n-\n-  MutexLocker ml(ConcurrentBOTFixing_lock, Mutex::_no_safepoint_check_flag);\n-  _fixer->note_stopped();\n-}\n-\n-void G1ConcurrentBOTFixingThread::stop_service() {\n-  MutexLocker ml(ConcurrentBOTFixing_lock, Mutex::_no_safepoint_check_flag);\n-  ConcurrentBOTFixing_lock->notify_all();\n-}\n-\n-\/\/ End of synchronization between the BOT fixing threads and the activating\/aborting VM thread.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentBOTFixing.cpp","additions":0,"deletions":317,"binary":false,"changes":317,"status":"deleted"},{"patch":"@@ -1,90 +0,0 @@\n-#ifndef SHARE_GC_G1_G1CONCURRENTBOTFIXING_HPP\n-#define SHARE_GC_G1_G1CONCURRENTBOTFIXING_HPP\n-\n-#include \"gc\/g1\/g1BOTFixingCardSet.hpp\"\n-\n-#include \"memory\/iterator.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-#include \"utilities\/ticks.hpp\"\n-\n-struct G1BOTFixingStats {\n-  Ticks concurrent_phase_start_time;\n-};\n-\n-class G1CollectedHeap;\n-class G1ConcurrentBOTFixingThread;\n-\n-class G1ConcurrentBOTFixing: public CHeapObj<mtGC> {\n-  G1CollectedHeap* _g1h;\n-\n-  volatile bool _in_progress;\n-  volatile bool _should_abort;\n-  \/\/ Workers.\n-  uint _n_workers;\n-  \/\/ Two counters to know when all workers have finished.\n-  uint _inactive_count; \/\/ Number of workers waiting for jobs\n-  uint _stopped_count; \/\/ Number of workers terminated\n-  G1ConcurrentBOTFixingThread** _fixer_threads;\n-\n-  \/\/ The plab size recorded before evacuation.\n-  size_t _plab_word_size;\n-\n-  \/\/ A flag to turn recording on\/off. Mainly to disable recording for full gcs.\n-  bool _plab_recording_in_progress;\n-\n-  \/\/ A list of card sets, each recording the cards (of plabs) that need to be fixed.\n-  G1BOTFixingCardSet* _card_sets;\n-  \/\/ A pointer into the list for job dispatching.\n-  G1BOTFixingCardSet* _current;\n-\n-  G1BOTFixingStats _stats;\n-\n-  void enlist_card_set(G1BOTFixingCardSet* card_set);\n-\n-  void fix_bot_for_card_set(G1BOTFixingCardSet* card_set);\n-\n-public:\n-  G1ConcurrentBOTFixing(G1CollectedHeap* g1h);\n-\n-  bool in_progress() const { return _in_progress; }\n-  bool should_abort() const { return _should_abort; }\n-\n-  \/\/ Signal the workers to concurrently process the card sets.\n-  void activate();\n-  \/\/ Abort the jobs and wait for workers to finish.\n-  void abort_and_wait();\n-  \/\/ Signal that the workers have all finished.\n-  void deactivate();\n-  \/\/ Workers use these to maintain _inactive_count\/_stopped_count and notify possible waiters\n-  \/\/ waiting for the workers to finish.\n-  void note_active();\n-  void note_inactive();\n-  void note_stopped();\n-  \/\/ Terminate the threads.\n-  void stop();\n-\n-  \/\/ Clear the card sets from previous gcs.\n-  void clear_card_sets();\n-\n-  \/\/ Prepare BOT fixing with necessary information, e.g., plab size. Called before recording plabs.\n-  void pre_record_plab_allocation();\n-\n-  \/\/ Record each plab allocation.\n-  void record_plab_allocation(HeapWord* plab_allocation, size_t word_size);\n-\n-  \/\/ Setup for the concurrent phase after plab recording.\n-  void post_record_plab_allocation();\n-\n-  \/\/ Entry point for the fixer threads. Claim and process one of the card sets from the list.\n-  \/\/ Return whether there are possibly more. Return false if someone asked us to abort.\n-  bool fix_bot_step();\n-\n-  \/\/ Entry point for concurrent refinement threads or mutators that tries to do conc refinement.\n-  \/\/ These threads always have a specific card in mind, that is, the dirty card to refine.\n-  void fix_bot_before_refine(HeapRegion* r, HeapWord* card_boundary);\n-\n-  void threads_do(ThreadClosure* tc);\n-  void print_summary_info();\n-};\n-\n-#endif \/\/ SHARE_GC_G1_G1CONCURRENTBOTFIXING_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentBOTFixing.hpp","additions":0,"deletions":90,"binary":false,"changes":90,"status":"deleted"},{"patch":"@@ -0,0 +1,320 @@\n+#include \"gc\/g1\/g1BlockOffsetTable.inline.hpp\"\n+#include \"gc\/g1\/g1BOTUpdateCardSet.inline.hpp\"\n+#include \"gc\/g1\/g1CardTable.hpp\"\n+#include \"gc\/g1\/g1CollectedHeap.hpp\"\n+#include \"gc\/g1\/g1ConcurrentBOTUpdate.hpp\"\n+#include \"gc\/g1\/heapRegion.inline.hpp\"\n+\n+#include \"logging\/log.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/os.hpp\"\n+\n+using CardIndex = G1BOTUpdateCardSet::CardIndex;\n+\n+class G1ConcurrentBOTUpdateThread: public ConcurrentGCThread {\n+  friend class G1ConcurrentBOTUpdate;\n+\n+  double _vtime_accum;\n+  G1ConcurrentBOTUpdate* _updater;\n+\n+  G1ConcurrentBOTUpdateThread(G1ConcurrentBOTUpdate* updater, uint i);\n+\n+  void wait_for_work();\n+\n+  void run_service();\n+  void stop_service();\n+\n+  double vtime_accum() const { return _vtime_accum; }\n+};\n+\n+G1ConcurrentBOTUpdate::G1ConcurrentBOTUpdate(G1CollectedHeap* g1h) :\n+  _g1h(g1h),\n+  _in_progress(false),\n+  _should_abort(false),\n+  _n_workers(ConcGCThreads),\n+  _inactive_count(0),\n+  _stopped_count(0),\n+  _updater_threads(NULL),\n+  _plab_word_size(0),\n+  _plab_recording_in_progress(false),\n+  _card_sets(NULL),\n+  _current(NULL),\n+  _stats() {\n+  _updater_threads = NEW_C_HEAP_ARRAY(G1ConcurrentBOTUpdateThread*, _n_workers, mtGC);\n+  for (uint i = 0; i < _n_workers; i++) {\n+    G1ConcurrentBOTUpdateThread* t = NULL;\n+    if (!InjectGCWorkerCreationFailure) {\n+      t = new G1ConcurrentBOTUpdateThread(this, i);\n+    }\n+    if (t == NULL || t->osthread() == NULL) {\n+      log_warning(gc, bot)(\"Unable to create G1ConcurrentBOTUpdateThread #%d\", i);\n+      if (i == 0) {\n+        G1UseConcurrentBOTUpdate = false;\n+      }\n+      _n_workers = i; \/\/ Actual number of threads created\n+      break;\n+    }\n+    _updater_threads[i] = t;\n+  }\n+}\n+\n+void G1ConcurrentBOTUpdate::update_bot_for_card_set(G1BOTUpdateCardSet* card_set) {\n+  assert(!card_set->is_empty(), \"We should be the only one emptying it\");\n+  card_set->print_stats();\n+  class BOTUpdateCardSetClosure: public G1BOTUpdateCardSet::CardIterator {\n+    G1ConcurrentBOTUpdate* _updater;\n+    HeapRegion* _hr;\n+\n+  public:\n+    uint _num_plabs;\n+\n+    BOTUpdateCardSetClosure(G1ConcurrentBOTUpdate* updater, HeapRegion* hr) :\n+      _updater(updater), _hr(hr), _num_plabs(0) {}\n+    bool do_card(CardIndex card_index) {\n+      HeapWord* card_boundary = _hr->bot_update_card_set()->card_boundary_for(card_index);\n+      \/\/ We have the last card boundary cover by a plab. We will update\n+      \/\/ the block (normally the block will be the plab) that covers this card boundary.\n+      _hr->update_bot(card_boundary);\n+      _num_plabs++;\n+      return (_updater->should_abort() == false); \/\/ Stop iteration if it aborts\n+    }\n+  } cl(this, card_set->hr());\n+\n+  Ticks start = Ticks::now();\n+  card_set->iterate_cards(cl);\n+  card_set->mark_as_done();\n+  log_info(gc, bot)(\"Concurrent BOT Update: updated %d plabs, took %8.2lf ms\",\n+                    cl._num_plabs, (Ticks::now() - start).seconds() * MILLIUNITS);\n+}\n+\n+bool G1ConcurrentBOTUpdate::update_bot_step() {\n+  G1BOTUpdateCardSet* old_val = _current;\n+  G1BOTUpdateCardSet* expect = NULL;\n+  G1BOTUpdateCardSet* new_val = NULL;\n+  do {\n+    if (old_val == NULL) return false;\n+\n+    expect = old_val;\n+    new_val = expect->next();\n+    old_val = Atomic::cmpxchg(&_current, expect, new_val, memory_order_relaxed);\n+  } while (old_val != expect);\n+\n+  update_bot_for_card_set(old_val);\n+\n+  return (new_val != NULL) && !_should_abort;\n+}\n+\n+void G1ConcurrentBOTUpdate::update_bot_before_refine(HeapRegion* r, HeapWord* card_boundary) {\n+  assert(r->is_old(), \"Only do this for heap regions with BOT\");\n+  assert(_g1h->card_table()->is_card_aligned(card_boundary), \"Only do this for cards to refine\");\n+\n+  Ticks start = Ticks::now();\n+  \/\/ If the region doesn't have plabs or if the card is below where plabs are allocated.\n+  G1BOTUpdateCardSet* card_set = r->bot_update_card_set();\n+  if (card_set->is_empty() || card_set->is_below_start(card_boundary)) return;\n+\n+  \/\/ If the card points into an object instead of a plab.\n+  HeapWord* latest_plab_start = r->need_update(card_boundary);\n+  if (latest_plab_start == NULL) return;\n+\n+  \/\/ If the plab has been claimed.\n+  CardIndex c = card_set->find_plab_covering(card_boundary, latest_plab_start);\n+  if (c == 0) return;\n+  \/\/ In some rare cases, the plab have been claimed and we get the plab after that plab.\n+  \/\/ Since it's rare, we do not check this case and let this thread update the wrong plab.\n+  \/\/ This will (nicely) leave more time for the update result of first plab to be visible to us.\n+  if (!card_set->claim_card(c)) return;\n+\n+  r->update_bot(card_set->card_boundary_for(c));\n+  log_info(gc, bot)(\"Concurrent BOT Update: updated 1 plab before refine, took %8.2lf ms\",\n+                    (Ticks::now() - start).seconds() * MILLIUNITS);\n+}\n+\n+void G1ConcurrentBOTUpdate::pre_record_plab_allocation() {\n+  assert_at_safepoint_on_vm_thread();\n+  assert(_card_sets == NULL, \"Sanity\");\n+  _plab_word_size = _g1h->desired_plab_sz(G1HeapRegionAttr::Old);\n+  G1BOTUpdateCardSet::prepare(_plab_word_size);\n+  _plab_recording_in_progress = true;\n+}\n+\n+void G1ConcurrentBOTUpdate::enlist_card_set(G1BOTUpdateCardSet* card_set) {\n+  assert(!card_set->is_empty(), \"Invalid card set\");\n+  G1BOTUpdateCardSet* old_val = _card_sets;\n+  G1BOTUpdateCardSet* expect = NULL;\n+  do {\n+    expect = old_val;\n+    old_val = Atomic::cmpxchg(&_card_sets, expect, card_set, memory_order_relaxed);\n+  } while (old_val != expect);\n+  card_set->set_next(old_val);\n+}\n+\n+void G1ConcurrentBOTUpdate::record_plab_allocation(HeapWord* plab_allocation, size_t word_size) {\n+  if (!_plab_recording_in_progress) return;\n+\n+  HeapRegion* r = _g1h->heap_region_containing(plab_allocation);\n+  assert(r->is_old(), \"Only old regions need this\");\n+  assert(word_size > 0, \"Sanity\");\n+  \/\/ Only when a region is full can a plab be smaller than its desired size.\n+  assert(word_size == _plab_word_size ||\n+         (word_size < _plab_word_size && plab_allocation + word_size == r->end()),\n+         \"Invalid plab size\");\n+\n+  HeapWord* first_card_boundary = align_down(plab_allocation, BOTConstants::N_bytes);\n+  HeapWord* last_card_boundary = align_down(plab_allocation + word_size - 1, BOTConstants::N_bytes);\n+  if (first_card_boundary == last_card_boundary) {\n+    \/\/ PLABs not crossing boundary could not have changed BOT. No need to update them.\n+    return;\n+  }\n+\n+  G1BOTUpdateCardSet* card_set = r->bot_update_card_set();\n+  bool should_enlist = card_set->add_card(last_card_boundary);\n+\n+  if (should_enlist) {\n+    enlist_card_set(card_set);\n+  }\n+}\n+\n+void G1ConcurrentBOTUpdate::post_record_plab_allocation() {\n+  assert_at_safepoint_on_vm_thread();\n+  _plab_recording_in_progress = false;\n+  _current = _card_sets;\n+}\n+\n+void G1ConcurrentBOTUpdate::clear_card_sets() {\n+  assert_at_safepoint_on_vm_thread();\n+  uint count[2] = { 0, 0 };\n+  while (_card_sets != NULL) {\n+    G1BOTUpdateCardSet* card_set = _card_sets;\n+    _card_sets = _card_sets->next();\n+    count[card_set->is_empty()]++;\n+    card_set->clear();\n+  }\n+  _current = NULL;\n+  log_info(gc, bot)(\"Concurrent BOT Update: processed\/aborted = %d\/%d\", count[1], count[0]);\n+}\n+\n+void G1ConcurrentBOTUpdate::threads_do(ThreadClosure* tc) {\n+  for (uint i = 0; i < _n_workers; i++) {\n+    tc->do_thread(_updater_threads[i]);\n+  }\n+}\n+\n+void G1ConcurrentBOTUpdate::print_summary_info() {\n+  Log(gc, bot) log;\n+  if (log.is_trace()) {\n+    log.trace(\" Concurrent BOT Update:\");\n+    for (uint i = 0; i < _n_workers; i++) {\n+      log.trace(\"  Worker #%d concurrent time = %8.2f s.\", i, _updater_threads[i]->vtime_accum());\n+    }\n+  }\n+}\n+\n+\/\/ Synchronization between the BOT update threads and the activating\/aborting VM thread.\n+\n+\/\/ Called by VM thread.\n+void G1ConcurrentBOTUpdate::activate() {\n+  MutexLocker ml(ConcurrentBOTUpdate_lock, Mutex::_no_safepoint_check_flag);\n+  assert(_in_progress == false, \"Activated twice\");\n+  assert(_should_abort == false, \"Sanity\");\n+  if (_stopped_count == _n_workers) return; \/\/ No workers\n+  _in_progress = true;\n+  ConcurrentBOTUpdate_lock->notify_all();\n+  _stats.concurrent_phase_start_time = Ticks::now();\n+}\n+\n+\/\/ Called by VM thread.\n+void G1ConcurrentBOTUpdate::abort_and_wait() {\n+  MonitorLocker ml(ConcurrentBOTUpdate_lock, Mutex::_no_safepoint_check_flag);\n+  if (_in_progress) {\n+    _should_abort = true;\n+  } else {\n+    assert(_should_abort == false, \"Must have cleared this\");\n+  }\n+  while (_in_progress) {\n+    assert(_should_abort, \"Who changed this?\");\n+    ml.wait();\n+  }\n+}\n+\n+\/\/ Called by one of the workers.\n+void G1ConcurrentBOTUpdate::deactivate() {\n+  assert(ConcurrentBOTUpdate_lock->owned_by_self(), \"Must be locked by self\");\n+  if (_in_progress && _inactive_count + _stopped_count == _n_workers) {\n+    _in_progress = false;\n+    _should_abort = false;\n+    ConcurrentBOTUpdate_lock->notify_all(); \/\/ Notify that all workers are now inactive\/stopped\n+    log_info(gc, bot)(\"Concurrent BOT Update: took %8.2lf ms\",\n+                      (Ticks::now() - _stats.concurrent_phase_start_time).seconds() * MILLIUNITS);\n+  }\n+}\n+\n+void G1ConcurrentBOTUpdate::note_active() {\n+  assert(ConcurrentBOTUpdate_lock->owned_by_self(), \"Must be locked by self\");\n+  _inactive_count--;\n+}\n+\n+void G1ConcurrentBOTUpdate::note_inactive() {\n+  assert(ConcurrentBOTUpdate_lock->owned_by_self(), \"Must be locked by self\");\n+  _inactive_count++;\n+  deactivate();\n+}\n+\n+void G1ConcurrentBOTUpdate::note_stopped() {\n+  assert(ConcurrentBOTUpdate_lock->owned_by_self(), \"Must be locked by self\");\n+  _stopped_count++;\n+  deactivate();\n+}\n+\n+void G1ConcurrentBOTUpdate::stop() {\n+  for (uint i = 0; i < _n_workers; i++) {\n+    _updater_threads[i]->stop();\n+  }\n+}\n+\n+G1ConcurrentBOTUpdateThread::G1ConcurrentBOTUpdateThread(G1ConcurrentBOTUpdate* updater, uint i) :\n+  ConcurrentGCThread(), _vtime_accum(0.0), _updater(updater) {\n+  set_name(\"G1 BOT Update #%d\", i);\n+  create_and_start();\n+}\n+\n+void G1ConcurrentBOTUpdateThread::wait_for_work() {\n+  MonitorLocker ml(ConcurrentBOTUpdate_lock, Mutex::_no_safepoint_check_flag);\n+  _updater->note_inactive();\n+  while ((!_updater->in_progress() || _updater->should_abort()) && !should_terminate()) {\n+    ml.wait();\n+  }\n+  _updater->note_active();\n+}\n+\n+void G1ConcurrentBOTUpdateThread::run_service() {\n+  double vtime_start = os::elapsedVTime();\n+\n+  bool more_work = false;\n+  while (!should_terminate()) {\n+    if (more_work == false) {\n+      wait_for_work();\n+      if (should_terminate()) {\n+        break;\n+      }\n+    }\n+\n+    more_work = _updater->update_bot_step();\n+\n+    if (os::supports_vtime()) {\n+      _vtime_accum = (os::elapsedVTime() - vtime_start);\n+    } else {\n+      _vtime_accum = 0.0;\n+    }\n+  }\n+\n+  MutexLocker ml(ConcurrentBOTUpdate_lock, Mutex::_no_safepoint_check_flag);\n+  _updater->note_stopped();\n+}\n+\n+void G1ConcurrentBOTUpdateThread::stop_service() {\n+  MutexLocker ml(ConcurrentBOTUpdate_lock, Mutex::_no_safepoint_check_flag);\n+  ConcurrentBOTUpdate_lock->notify_all();\n+}\n+\n+\/\/ End of synchronization between the BOT update threads and the activating\/aborting VM thread.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentBOTUpdate.cpp","additions":320,"deletions":0,"binary":false,"changes":320,"status":"added"},{"patch":"@@ -0,0 +1,90 @@\n+#ifndef SHARE_GC_G1_G1CONCURRENTBOTFIXING_HPP\n+#define SHARE_GC_G1_G1CONCURRENTBOTFIXING_HPP\n+\n+#include \"gc\/g1\/g1BOTUpdateCardSet.hpp\"\n+\n+#include \"memory\/iterator.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/ticks.hpp\"\n+\n+struct G1BOTUpdateStats {\n+  Ticks concurrent_phase_start_time;\n+};\n+\n+class G1CollectedHeap;\n+class G1ConcurrentBOTUpdateThread;\n+\n+class G1ConcurrentBOTUpdate: public CHeapObj<mtGC> {\n+  G1CollectedHeap* _g1h;\n+\n+  volatile bool _in_progress;\n+  volatile bool _should_abort;\n+  \/\/ Workers.\n+  uint _n_workers;\n+  \/\/ Two counters to know when all workers have finished.\n+  uint _inactive_count; \/\/ Number of workers waiting for jobs\n+  uint _stopped_count; \/\/ Number of workers terminated\n+  G1ConcurrentBOTUpdateThread** _updater_threads;\n+\n+  \/\/ The plab size recorded before evacuation.\n+  size_t _plab_word_size;\n+\n+  \/\/ A flag to turn recording on\/off. Mainly to disable recording for full gcs.\n+  bool _plab_recording_in_progress;\n+\n+  \/\/ A list of card sets, each recording the cards (of plabs) that need to be updated.\n+  G1BOTUpdateCardSet* _card_sets;\n+  \/\/ A pointer into the list for job dispatching.\n+  G1BOTUpdateCardSet* _current;\n+\n+  G1BOTUpdateStats _stats;\n+\n+  void enlist_card_set(G1BOTUpdateCardSet* card_set);\n+\n+  void update_bot_for_card_set(G1BOTUpdateCardSet* card_set);\n+\n+public:\n+  G1ConcurrentBOTUpdate(G1CollectedHeap* g1h);\n+\n+  bool in_progress() const { return _in_progress; }\n+  bool should_abort() const { return _should_abort; }\n+\n+  \/\/ Signal the workers to concurrently process the card sets.\n+  void activate();\n+  \/\/ Abort the jobs and wait for workers to finish.\n+  void abort_and_wait();\n+  \/\/ Signal that the workers have all finished.\n+  void deactivate();\n+  \/\/ Workers use these to maintain _inactive_count\/_stopped_count and notify possible waiters\n+  \/\/ waiting for the workers to finish.\n+  void note_active();\n+  void note_inactive();\n+  void note_stopped();\n+  \/\/ Terminate the threads.\n+  void stop();\n+\n+  \/\/ Clear the card sets from previous gcs.\n+  void clear_card_sets();\n+\n+  \/\/ Prepare BOT update with necessary information, e.g., plab size. Called before recording plabs.\n+  void pre_record_plab_allocation();\n+\n+  \/\/ Record each plab allocation.\n+  void record_plab_allocation(HeapWord* plab_allocation, size_t word_size);\n+\n+  \/\/ Setup for the concurrent phase after plab recording.\n+  void post_record_plab_allocation();\n+\n+  \/\/ Entry point for the updater threads. Claim and process one of the card sets from the list.\n+  \/\/ Return whether there are possibly more. Return false if someone asked us to abort.\n+  bool update_bot_step();\n+\n+  \/\/ Entry point for concurrent refinement threads or mutators that tries to do conc refinement.\n+  \/\/ These threads always have a specific card in mind, that is, the dirty card to refine.\n+  void update_bot_before_refine(HeapRegion* r, HeapWord* card_boundary);\n+\n+  void threads_do(ThreadClosure* tc);\n+  void print_summary_info();\n+};\n+\n+#endif \/\/ SHARE_GC_G1_G1CONCURRENTBOTFIXING_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentBOTUpdate.hpp","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -173,1 +173,1 @@\n-  _heap->finalize_concurrent_bot_fixing();\n+  _heap->finalize_concurrent_bot_update();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -169,1 +169,1 @@\n-  _concurrent_bot_fixing_finalize_time_ms = 0.0;\n+  _concurrent_bot_update_finalize_time_ms = 0.0;\n@@ -379,1 +379,1 @@\n-  const double sum_ms = _concurrent_bot_fixing_finalize_time_ms +\n+  const double sum_ms = _concurrent_bot_update_finalize_time_ms +\n@@ -391,2 +391,2 @@\n-  if (_concurrent_bot_fixing_finalize_time_ms > 0.0) {\n-    debug_time(\"Concurrent BOT Fixing Finalization\", _concurrent_bot_fixing_finalize_time_ms);\n+  if (_concurrent_bot_update_finalize_time_ms > 0.0) {\n+    debug_time(\"Concurrent BOT Update Finalization\", _concurrent_bot_update_finalize_time_ms);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1GCPhaseTimes.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -177,1 +177,1 @@\n-  double _concurrent_bot_fixing_finalize_time_ms;\n+  double _concurrent_bot_update_finalize_time_ms;\n@@ -311,2 +311,2 @@\n-  void record_concurrent_bot_fixing_finalize_time(double time_ms) {\n-    _concurrent_bot_fixing_finalize_time_ms = time_ms;\n+  void record_concurrent_bot_update_finalize_time(double time_ms) {\n+    _concurrent_bot_update_finalize_time_ms = time_ms;\n@@ -399,2 +399,2 @@\n-  double concurrent_bot_fixing_finalize_time_ms() {\n-    return _concurrent_bot_fixing_finalize_time_ms;\n+  double concurrent_bot_update_finalize_time_ms() {\n+    return _concurrent_bot_update_finalize_time_ms;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1GCPhaseTimes.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"gc\/g1\/g1ConcurrentBOTFixing.hpp\"\n+#include \"gc\/g1\/g1ConcurrentBOTUpdate.hpp\"\n@@ -413,2 +413,2 @@\n-      if (G1UseConcurrentBOTFixing && dest_attr->is_old()) {\n-        _g1h->concurrent_bot_fixing()->record_plab_allocation(obj_ptr, actual_plab_size);\n+      if (G1UseConcurrentBOTUpdate && dest_attr->is_old()) {\n+        _g1h->concurrent_bot_update()->record_plab_allocation(obj_ptr, actual_plab_size);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-#include \"gc\/g1\/g1ConcurrentBOTFixing.hpp\"\n+#include \"gc\/g1\/g1ConcurrentBOTUpdate.hpp\"\n@@ -46,1 +46,0 @@\n-#include \"gc\/g1\/g1ThreadLocalData.hpp\"\n@@ -1660,5 +1659,5 @@\n-  if (G1UseConcurrentBOTFixing) {\n-    G1ConcurrentBOTFixing* concurrent_bot_fixing = _g1h->concurrent_bot_fixing();\n-    if (concurrent_bot_fixing->in_progress() && r->is_old()) {\n-      \/\/ Fix BOT if this card points into a plab, which causes the BOT to be inaccurate.\n-      concurrent_bot_fixing->fix_bot_before_refine(r, start);\n+  if (G1UseConcurrentBOTUpdate) {\n+    G1ConcurrentBOTUpdate* concurrent_bot_update = _g1h->concurrent_bot_update();\n+    if (concurrent_bot_update->in_progress() && r->is_old()) {\n+      \/\/ Update BOT if this card points into a plab, which causes the BOT to be inaccurate.\n+      concurrent_bot_update->update_bot_before_refine(r, start);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.cpp","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -348,1 +348,1 @@\n-  product(bool, G1UseConcurrentBOTFixing, true,                             \\\n+  product(bool, G1UseConcurrentBOTUpdate, true,                             \\\n","filename":"src\/hotspot\/share\/gc\/g1\/g1_globals.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -236,1 +236,1 @@\n-  _bot_fixing_card_set(this),\n+  _bot_update_card_set(this),\n@@ -795,1 +795,1 @@\n-  _bot_fixing_card_set.clear();\n+  _bot_update_card_set.clear();\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"gc\/g1\/g1ConcurrentBOTFixing.hpp\"\n+#include \"gc\/g1\/g1ConcurrentBOTUpdate.hpp\"\n@@ -81,1 +81,1 @@\n-  G1BOTFixingCardSet _bot_fixing_card_set;\n+  G1BOTUpdateCardSet _bot_update_card_set;\n@@ -205,1 +205,1 @@\n-  HeapWord* need_fixing(HeapWord* addr) const;\n+  HeapWord* need_update(HeapWord* addr) const;\n@@ -208,3 +208,3 @@\n-  \/\/ BOT fixing starts from here onwards.\n-  void set_bot_fixing_start() {\n-    _bot_fixing_card_set.set_bot_fixing_start();\n+  \/\/ BOT update starts from here onwards.\n+  void set_bot_update_start() {\n+    _bot_update_card_set.set_bot_update_start();\n@@ -213,2 +213,2 @@\n-  G1BOTFixingCardSet* bot_fixing_card_set() {\n-    return &_bot_fixing_card_set;\n+  G1BOTUpdateCardSet* bot_update_card_set() {\n+    return &_bot_update_card_set;\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -111,2 +111,2 @@\n-inline HeapWord* HeapRegion::need_fixing(HeapWord* addr) const {\n-  return _bot_part.need_fixing(addr);\n+inline HeapWord* HeapRegion::need_update(HeapWord* addr) const {\n+  return _bot_part.need_update(addr);\n@@ -235,1 +235,1 @@\n-    _bot_fixing_card_set.clear();\n+    _bot_update_card_set.clear();\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -117,1 +117,1 @@\n-Monitor* ConcurrentBOTFixing_lock     = NULL;\n+Monitor* ConcurrentBOTUpdate_lock     = NULL;\n@@ -228,1 +228,1 @@\n-    def(ConcurrentBOTFixing_lock   , PaddedMonitor, leaf     ,   true,  _safepoint_check_never);\n+    def(ConcurrentBOTUpdate_lock   , PaddedMonitor, leaf     ,   true,  _safepoint_check_never);\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -111,1 +111,1 @@\n-extern Monitor* ConcurrentBOTFixing_lock;        \/\/ synchronization between VM thread and the concurrent BOT fixing threads\n+extern Monitor* ConcurrentBOTUpdate_lock;        \/\/ synchronization between VM thread and the concurrent BOT update threads\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}