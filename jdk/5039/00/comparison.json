{"files":[{"patch":"@@ -193,0 +193,1 @@\n+  inline HeapWord* block_start(const void* addr, HeapWord*& iterated_hint);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BlockOffsetTable.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -40,0 +40,15 @@\n+inline HeapWord* G1BlockOffsetTablePart::block_start(const void* addr, HeapWord*& iterated_hint) {\n+  assert(addr >= _hr->bottom() && addr < _hr->top(), \"invalid address\");\n+  HeapWord* q = block_at_or_preceding(addr);\n+  \/\/ If there is a hint, which indicates that BOT has previously fixed up to this\n+  \/\/ position in the same region, and the hint position must be a block start, we avoid\n+  \/\/ having to go back to the position of q. If addr is lower than the hint, do regular forward.\n+  if (iterated_hint != NULL && iterated_hint > q && iterated_hint <= addr) {\n+    q = iterated_hint;\n+  }\n+  q = forward_to_block_containing_addr(q, addr);\n+  \/\/ Record the BOT-fixed range.\n+  iterated_hint = MAX2(q + block_size(q), iterated_hint);\n+  return q;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BlockOffsetTable.inline.hpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -779,0 +779,5 @@\n+  \/\/ The address to which this thread already iterated, not necessarily scanned.\n+  \/\/ For precisely marked objects, it can be scanned in the middle, but this variable\n+  \/\/ records the end of that object.\n+  HeapWord* _iterated_to;\n+\n@@ -788,1 +793,2 @@\n-    HeapWord* const scanned_to = card_region->oops_on_memregion_seq_iterate_careful<true>(mr, &card_cl);\n+    HeapWord* const scanned_to =\n+      card_region->oops_on_memregion_seq_iterate_careful<true>(mr, &card_cl, _iterated_to);\n@@ -832,0 +838,2 @@\n+    _iterated_to = NULL;\n+\n@@ -883,0 +891,1 @@\n+    _iterated_to(NULL),\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.cpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -152,0 +152,1 @@\n+  HeapWord* block_start(const void* p, HeapWord*& iterated_hint);\n@@ -568,0 +569,6 @@\n+  template <bool is_gc_active, class Closure>\n+  \/\/ The hinted version asks for a hint which we have previously iterated up to.\n+  \/\/ If we have iterated to this position, that means BOT is fixed up to the hint.\n+  \/\/ This information can help BOT return a block start faster.\n+  inline HeapWord* oops_on_memregion_seq_iterate_careful(MemRegion mr, Closure* cl,\n+                                                         HeapWord*& iterated_hint);\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -115,0 +115,4 @@\n+inline HeapWord* HeapRegion::block_start(const void* p, HeapWord*& iterated_hint) {\n+  return _bot_part.block_start(p, iterated_hint);\n+}\n+\n@@ -343,0 +347,8 @@\n+  HeapWord* no_hint = NULL;\n+  return oops_on_memregion_seq_iterate_careful<is_gc_active>(mr, cl, no_hint);\n+}\n+\n+template <bool is_gc_active, class Closure>\n+HeapWord* HeapRegion::oops_on_memregion_seq_iterate_careful(MemRegion mr,\n+                                                            Closure* cl,\n+                                                            HeapWord*& iterated_hint) {\n@@ -364,1 +376,1 @@\n-  HeapWord* cur = block_start(start);\n+  HeapWord* cur = block_start(start, iterated_hint);\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.inline.hpp","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"}]}