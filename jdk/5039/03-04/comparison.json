{"files":[{"patch":"@@ -1,289 +0,0 @@\n-#include \"gc\/g1\/g1BlockOffsetTable.hpp\"\n-#include \"gc\/g1\/g1BOTUpdateCardSet.inline.hpp\"\n-#include \"gc\/g1\/heapRegion.hpp\"\n-\n-#include \"logging\/log.hpp\"\n-#include \"runtime\/atomic.hpp\"\n-#include \"utilities\/bitMap.hpp\"\n-\n-using CardIndex = G1BOTUpdateCardSet::CardIndex;\n-\n-CardIndex G1BOTUpdateCardSet::_last_card_index = 0;\n-size_t G1BOTUpdateCardSet::_plab_word_size = 0;\n-G1BOTUpdateCardSet::ContainerType G1BOTUpdateCardSet::_dynamic_container_type = Array;\n-\n-G1BOTUpdateCardSet::G1BOTUpdateCardSet(HeapRegion* hr) :\n-  _type(Static),\n-  _start_card_index(_first_card_index),\n-  _num_plabs(0),\n-  _dynamic_container(NULL),\n-  _next(NULL),\n-  _hr(hr) {\n-  assert((size_t)HeapRegion::LogOfHRGrainBytes - BOTConstants::LogN <=\n-         sizeof(CardIndex) * BitsPerByte,\n-         \"Unable to encode card with \" SIZE_FORMAT \" bits\", sizeof(CardIndex) * BitsPerByte);\n-  for (uint i = 0; i < static_container_size; i++) {\n-    _static_container[i] = 0;\n-  }\n-}\n-\n-\/\/ Prepare globals for adding cards.\n-void G1BOTUpdateCardSet::prepare(size_t plab_word_size) {\n-  \/\/ The last word's card.\n-  _last_card_index = (CardIndex)((HeapRegion::GrainWords - 1) >> BOTConstants::LogN_words);\n-  _plab_word_size = plab_word_size;\n-  size_t threshold = sizeof(CardIndex) * BitsPerByte;\n-  \/\/ If plab is smaller than (number of bits x card size).\n-  if (plab_word_size >= (threshold << BOTConstants::LogN_words)) {\n-    _dynamic_container_type = Array;\n-  } else {\n-    _dynamic_container_type = BitMap;\n-  }\n-}\n-\n-\/\/ New plabs are allocated above the current top. So BOT update starts at the current top.\n-\/\/ Anything below is considered updated.\n-void G1BOTUpdateCardSet::set_bot_update_start() {\n-  assert(_hr->is_old(), \"Only set for old regions\");\n-  if (_hr->top() == _hr->end()) {\n-    \/\/ Nothing to do.\n-    return;\n-  }\n-  CardIndex card_index_for_top = card_index_for(_hr->top());\n-  \/\/ The card of top() does not need to be updated. Move to the next one.\n-  if (card_index_for_top == _last_card_index) {\n-    return;\n-  }\n-  _start_card_index = card_index_for_top + 1;\n-}\n-\n-void G1BOTUpdateCardSet::transition_to_dynamic() {\n-  void* container_mem = NULL;\n-  \/\/ Size of the area in the region that needs update. We don't need to reserve space for\n-  \/\/ cards that don't need update in the container.\n-  size_t update_size = HeapRegion::GrainWords -\n-                       (((size_t)_start_card_index) << BOTConstants::LogN_words);\n-  if (_dynamic_container_type == Array) {\n-    \/\/ +1 is because when the region is nearly full, there could be some space\n-    \/\/ smaller than _plab_word_size. A plab can still be allocated\n-    \/\/ into that space. We have to take that into account.\n-    size_t array_size = update_size \/ _plab_word_size + (update_size % _plab_word_size != 0) + 1;\n-    size_t container_size = G1BOTUpdateCardSetArray::size_in_bytes(array_size);\n-    container_mem = NEW_C_HEAP_ARRAY(jbyte, container_size, mtGC);\n-    memset(container_mem, 0, container_size);\n-    new (container_mem) G1BOTUpdateCardSetArray(array_size);\n-  } else {\n-    assert(_dynamic_container_type == BitMap, \"Sanity\");\n-    size_t max_num_cards = (update_size >> BOTConstants::LogN_words);\n-    size_t container_size = G1BOTUpdateCardSetBitMap::size_in_bytes(max_num_cards);\n-    container_mem = NEW_C_HEAP_ARRAY(jbyte, container_size, mtGC);\n-    memset(container_mem, 0, container_size);\n-    new (container_mem) G1BOTUpdateCardSetBitMap(max_num_cards);\n-  }\n-\n-  \/\/ Guarantees that whoever fails must see the correct dynamic container.\n-  if (!Atomic::replace_if_null(&_dynamic_container, container_mem, memory_order_acq_rel)) {\n-    \/\/ Someone else replaced before us.\n-    FREE_C_HEAP_ARRAY(jbyte, container_mem);\n-    return;\n-  }\n-\n-  \/\/ Guarantees that whoever reads _type != Static can see the dynamic container.\n-  ContainerType t = Atomic::cmpxchg(&_type, Static, _dynamic_container_type, memory_order_acq_rel);\n-  assert(t == Static, \"We should be the only one setting the type\");\n-\n-  \/\/ Copy content from the static array to the new container.\n-  assert(_num_plabs >= static_container_size, \"Static container must be full\");\n-  for (uint i = 0; i < static_container_size; i++) {\n-    CardIndex c = (CardIndex)_static_container[i];\n-    if (_dynamic_container_type == Array) {\n-      ((G1BOTUpdateCardSetArray*)container_mem)->add_card(array_index_for(c), c);\n-    } else {\n-      assert(_dynamic_container_type == BitMap, \"Sanity\");\n-      ((G1BOTUpdateCardSetBitMap*)container_mem)->add_card(bitmap_effect_card_index_for(c));\n-    }\n-    _static_container[i] = 0;\n-  }\n-}\n-\n-void G1BOTUpdateCardSet::add_card_to_dynamic(CardIndex card_index) {\n-  if (_dynamic_container_type == Array) {\n-    as_array()->add_card(array_index_for(card_index), card_index);\n-  } else {\n-    assert(_dynamic_container_type == BitMap, \"Sanity\");\n-    as_bitmap()->add_card(bitmap_effect_card_index_for(card_index));\n-  }\n-}\n-\n-bool G1BOTUpdateCardSet::add_card(HeapWord* addr) {\n-  CardIndex card_index = card_index_for(addr);\n-  assert(card_index >= _start_card_index, \"No need to update\");\n-  \/\/ Try to add to the static array first.\n-  if (Atomic::load_acquire(&_type) == Static) {\n-    uint i = Atomic::fetch_and_add(&_num_plabs, (uint)1, memory_order_relaxed);\n-    if (i < static_container_size) {\n-      _static_container[i] = card_index;\n-      return i == 0; \/\/ Is this the first card?\n-    } else {\n-      transition_to_dynamic();\n-    }\n-  }\n-  assert(_dynamic_container != NULL, \"Must be visible\");\n-\n-  add_card_to_dynamic(card_index);\n-  return false;\n-}\n-\n-bool G1BOTUpdateCardSet::claim_card_from_dynamic(CardIndex card_index) {\n-  if (_dynamic_container_type == Array) {\n-    return as_array()->claim_card(array_index_for(card_index)) == card_index;\n-  } else {\n-    assert(_dynamic_container_type == BitMap, \"Sanity\");\n-    CardIndex effect_card_index = bitmap_effect_card_index_for(card_index);\n-    return as_bitmap()->claim_card(effect_card_index);\n-  }\n-}\n-\n-bool G1BOTUpdateCardSet::claim_card(CardIndex card_index) {\n-  assert(card_index >= _start_card_index, \"No need to update this card\");\n-  if (_type == Static) {\n-    for (uint i = 0; i < static_container_size; i++) {\n-      if ((CardIndex)_static_container[i] == card_index) {\n-        CardIndex c = (CardIndex)Atomic::cmpxchg(&_static_container[i], (WordType)card_index,\n-                                                 (WordType)0, memory_order_relaxed);\n-        return c == card_index;\n-      }\n-    }\n-    return false;\n-  }\n-\n-  return claim_card_from_dynamic(card_index);\n-}\n-\n-CardIndex G1BOTUpdateCardSet::find_first_card_in(CardIndex min_card_index,\n-                                                 CardIndex max_card_index) {\n-  if (_dynamic_container_type == Array) {\n-    return as_array()->find_first_card_in(array_index_for(min_card_index),\n-                                          array_index_for(max_card_index));\n-  } else {\n-    assert(_dynamic_container_type == BitMap, \"Sanity\");\n-    CardIndex min_effect_card_index = bitmap_effect_card_index_for(min_card_index);\n-    CardIndex max_effect_card_index = bitmap_effect_card_index_for(max_card_index);\n-    CardIndex c = as_bitmap()->find_first_card_in(min_effect_card_index, max_effect_card_index);\n-    if (c == max_effect_card_index + 1) {\n-      \/\/ Not found.\n-      return 0;\n-    }\n-    return bitmap_card_index_for(c);\n-  }\n-}\n-\n-\/\/ Given a card boundary, return the card that represents the plab that crosses this boundary.\n-\/\/ This should be used by concurrent refinement to get the covering plab of a card table card.\n-\/\/ A possible plab start will help us narrow down the search range for this plab, where we\n-\/\/ assume the plab starts no later than latest_plab_start.\n-CardIndex G1BOTUpdateCardSet::find_plab_covering(HeapWord* card_boundary,\n-                                                 HeapWord* latest_plab_start) {\n-  assert(card_boundary < _hr->top(), \"Sanity\");\n-  assert(is_aligned(card_boundary, BOTConstants::N_bytes), \"Must be aligned\");\n-  assert(latest_plab_start <= card_boundary, \"Not a helpful start addr\");\n-  assert(card_boundary < latest_plab_start + _plab_word_size, \"PLAB cannot possibly cover addr\");\n-  \/\/ If a plab covers the card boundary, we should be able to find\n-  \/\/ the last card of the plab at [card_boundary, latest_plab_start + _plab_word_size).\n-  CardIndex min_card_index = card_index_for(card_boundary);\n-  HeapWord* end_of_search = MIN2(latest_plab_start + _plab_word_size, _hr->top()) - 1;\n-  CardIndex max_card_index = card_index_for(end_of_search);\n-  assert(_start_card_index <= min_card_index && min_card_index <= max_card_index, \"Sanity\");\n-\n-  if (_type == Static) {\n-    CardIndex found = 0;\n-    for (uint i = 0; i < static_container_size; i++) {\n-      CardIndex c = (CardIndex)_static_container[i];\n-      if (min_card_index <= c && c <= max_card_index) {\n-        if (found == 0) {\n-          found = c;\n-        } else {\n-          \/\/ Sometimes multiple cards fall in this range (depending the given latest_plab_start),\n-          \/\/ we should use the smaller one. The other one must be a false match.\n-          found = MIN2(c, found);\n-        }\n-      }\n-    }\n-    return found;\n-  }\n-\n-  return find_first_card_in(min_card_index, max_card_index);\n-}\n-\n-void G1BOTUpdateCardSet::iterate_cards_in_dynamic(CardIterator& iter) {\n-  if (_dynamic_container_type == Array) {\n-    return as_array()->iterate_cards(iter);\n-  } else {\n-    assert(_dynamic_container_type == BitMap, \"Sanity\");\n-\n-    class BOTUpdateBitMapClosure: public BitMapClosure {\n-      G1BOTUpdateCardSet* _card_set;\n-      CardIterator* _iter;\n-    public:\n-      BOTUpdateBitMapClosure(G1BOTUpdateCardSet* card_set, CardIterator* iter) :\n-        _card_set(card_set), _iter(iter) {}\n-      bool do_bit(BitMap::idx_t index) {\n-        return _iter->do_card(\n-          _card_set->bitmap_card_index_for((G1BOTUpdateCardSetBitMap::card_index_for(index))));\n-      }\n-    } cl(this, &iter);\n-\n-    return as_bitmap()->iterate_cards(&cl);\n-  }\n-}\n-\n-void G1BOTUpdateCardSet::iterate_cards(CardIterator& iter) {\n-  if (_type == Static) {\n-    for (uint i = 0; i < static_container_size; i++) {\n-      CardIndex card_index = (CardIndex)_static_container[i];\n-      if (card_index != 0) {\n-        if (card_index == Atomic::cmpxchg(&_static_container[i], (WordType)card_index, (WordType)0,\n-                                          memory_order_relaxed)) {\n-          if (!iter.do_card(card_index)) {\n-            return;\n-          }\n-        }\n-      }\n-    }\n-  } else {\n-    iterate_cards_in_dynamic(iter);\n-  }\n-}\n-\n-void G1BOTUpdateCardSet::clear() {\n-  if (_type != Static) {\n-    \/\/ First transition back to static.\n-    _type = Static;\n-    FREE_C_HEAP_ARRAY(jbyte, _dynamic_container);\n-    _dynamic_container = NULL;\n-  }\n-\n-  _start_card_index = _first_card_index;\n-  _num_plabs = 0;\n-  for (uint i = 0; i < static_container_size; i++) {\n-    _static_container[i] = 0;\n-  }\n-}\n-\n-void G1BOTUpdateCardSet::print_stats() {\n-  log_info(gc, bot)(\"BOT Update Card Set: region=%s, type=%d, start\/last=%d\/%d, n=%d\",\n-                    _hr->get_type_str(), _type, _start_card_index, _last_card_index, _num_plabs);\n-}\n-\n-void G1BOTUpdateCardSet::verify() {\n-  assert(_type == Static, \"Type incorrect\");\n-  \/\/ An old region might not have its card set cleared since last gc, because it's never enlisted.\n-  assert(_start_card_index == _first_card_index || _hr->is_old(),\n-         \"Start card incorrect\");\n-  assert(_num_plabs == 0, \"Size not zero\");\n-  for (uint i = 0; i < static_container_size; i++) {\n-    assert(_static_container[i] == 0, \"Static container not zero\");\n-  }\n-  assert(_dynamic_container == NULL, \"Dynamic container not cleared\");\n-  \/\/ _next can be whatever (managed externally).\n-}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BOTUpdateCardSet.cpp","additions":0,"deletions":289,"binary":false,"changes":289,"status":"deleted"},{"patch":"@@ -1,232 +0,0 @@\n-#ifndef SHARE_GC_G1_G1BOTFIXINGCARDSET_HPP\n-#define SHARE_GC_G1_G1BOTFIXINGCARDSET_HPP\n-\n-#include \"utilities\/bitMap.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-\n-class HeapRegion;\n-class G1BOTUpdateCardSetArray;\n-class G1BOTUpdateCardSetBitMap;\n-\n-\/\/ This card set contains the BOT entries (cards) that need to be updated in a region.\n-\/\/ Each member uniquely identifies a plab by being the last card covered by the plab.\n-\/\/ Every card covered by a plab (except for the first one) need to be updated.\n-\/\/ Knowing the last card of a plab is the same as knowing the cards it covers,\n-\/\/ because BOT can return the start of the plab given its last card, then we know\n-\/\/ what's in between. If BOT cannot precisely return the start of the plab (this happens when\n-\/\/ it gets updated, probably by concurrent refinement), it will still return up to which point\n-\/\/ it has been updated. Then we can update from there.\n-\/\/\n-\/\/ We chose to use the last card of a plab instead of the first card, because otherwise we cannot\n-\/\/ take advantage of this partially updated case. However, if there is no partial update, i.e.,\n-\/\/ every plab gets updated before we visit BOT for the area it covers, then there is not much\n-\/\/ difference.\n-\/\/\n-\/\/ This card set uses three types of containers. There could be either an array or a bitmap,\n-\/\/ depending on the plab size:\n-\/\/ Suppose the card size is 512 bytes and the largest region is 32m. A card can be represented\n-\/\/ using an offset with under 16 bits. The number of entries we need in an array is around\n-\/\/ region_size\/plab_size, which gives us array_size=region_size\/plab_size*16 bits.\n-\/\/ The size of a bitmap, using 1 bit for 1 card, for the same region would be region_size\/512 bits.\n-\/\/ So, using a bitmap is more worthwhile (in terms of space)\n-\/\/ than an array only when the plab size is smaller than 16x512 bytes, or 16 cards.\n-\/\/ This card set chooses the data structure accordingly given a plab_size.\n-\/\/\n-\/\/ Sometimes we know that the plabs are allocated above an address (e.g., region top before gc).\n-\/\/ We will use this information to reduce the required size.\n-\/\/\n-\/\/ The above two containers are dynamically allocated. To prevent too many dynamic allocations,\n-\/\/ there is also a fixed-sized array, which is supposed to handle most of the cases.\n-class G1BOTUpdateCardSet {\n-public:\n-  typedef uint16_t CardIndex;\n-  typedef uint32_t WordType; \/\/ Atomic operations work with this granularity\n-  static_assert(sizeof(WordType) >= sizeof(CardIndex), \"Must be able to hold a card index\");\n-\n-  class CardIterator: public StackObj {\n-  public:\n-    \/\/ Return false to abort iteration.\n-    virtual bool do_card(CardIndex card_index) = 0;\n-  };\n-\n-private:\n-  enum ContainerType {\n-    Static,\n-    Array,\n-    BitMap\n-  };\n-  ContainerType _type;\n-\n-  \/\/ CardIndex 0 is considered an invalid card, because we never need to update the first BOT entry.\n-  static const CardIndex _first_card_index = 1;\n-  \/\/ Update starts from this card. This should be set to the first card\n-  \/\/ after region top (not including region top) before gc.\n-  \/\/ This card is in [_first_card_index, _last_card_index].\n-  CardIndex _start_card_index;\n-  \/\/ The last card in a region. It's relative to the max size of the region.\n-  \/\/ This card might need special handling if we use an array container.\n-  static CardIndex _last_card_index;\n-\n-  \/\/ PLAB size recorded before each gc.\n-  static size_t _plab_word_size;\n-\n-  \/\/ Number of plabs recorded. Also a pointer into _static_container.\n-  \/\/ When we transition to using the dynamic array or bitmap, this stops updating.\n-  \/\/ So it's only good for is_empty() after that.\n-  uint _num_plabs;\n-\n-  \/\/ The statically allocated container.\n-  static constexpr uint static_container_size = 4; \/\/ Preferably at least the number of gc threads\n-  WordType _static_container[static_container_size];\n-\n-  \/\/ A type decided before each gc according to the plab size.\n-  static ContainerType _dynamic_container_type;\n-  \/\/ The dynamically allocated container.\n-  void* _dynamic_container;\n-\n-  \/\/ To form a list of card sets. Used in job dispatching and cleaning up.\n-  G1BOTUpdateCardSet* _next;\n-\n-  \/\/ The owner heap region.\n-  HeapRegion* _hr;\n-\n-  size_t array_index_for(CardIndex card_index) const;\n-  CardIndex bitmap_effect_card_index_for(CardIndex card_index) const;\n-  CardIndex bitmap_card_index_for(CardIndex effect_card_index) const;\n-\n-  \/\/ Transition from static to dynamic container.\n-  void transition_to_dynamic();\n-\n-  G1BOTUpdateCardSetArray* as_array();\n-  G1BOTUpdateCardSetBitMap* as_bitmap();\n-\n-  void add_card_to_dynamic(CardIndex card_index);\n-\n-  bool claim_card_from_dynamic(CardIndex card_index);\n-\n-  \/\/ Find the first card in the range [min_card_index, max_card_index] in the dynamic container.\n-  CardIndex find_first_card_in(CardIndex min_card_index, CardIndex max_card_index);\n-\n-  void iterate_cards_in_dynamic(CardIterator& iter);\n-\n-public:\n-  G1BOTUpdateCardSet(HeapRegion* hr);\n-\n-  static void prepare(size_t plab_word_size);\n-\n-  G1BOTUpdateCardSet* next() const { return _next; }\n-  void set_next(G1BOTUpdateCardSet* next) {\n-    _next = next;\n-  }\n-\n-  HeapRegion* hr() const { return _hr; }\n-\n-  bool is_empty() const { return _num_plabs == 0; }\n-  void mark_as_done() { _num_plabs = 0; }\n-\n-  CardIndex card_index_for(HeapWord* addr) const;\n-\n-  HeapWord* card_boundary_for(CardIndex card_index) const;\n-\n-  void set_bot_update_start();\n-  bool is_below_start(HeapWord* addr) const;\n-\n-  \/\/ Add the card of this address to the set. Return whether the container was empty.\n-  bool add_card(HeapWord* addr);\n-\n-  \/\/ Claim the card of this index and return whether it's successful.\n-  bool claim_card(CardIndex card_index);\n-\n-  \/\/ Find the last card of the plab that covers the given card boundary.\n-  \/\/ latest_plab_start specifies the latest point where the plab starts (say, given by\n-  \/\/ _hr->need_update(card_boundary)).\n-  \/\/ Return the card index. Note that this is not always accurate. The caller\n-  \/\/ might need to check whether this plab really covers the card boundary.\n-  CardIndex find_plab_covering(HeapWord* card_boundary, HeapWord* latest_plab_start);\n-\n-  \/\/ Iterate the cards.\n-  void iterate_cards(CardIterator& iter);\n-\n-  void clear();\n-\n-  void print_stats();\n-  void verify();\n-};\n-\n-class G1BOTUpdateCardSetArray {\n-private:\n-  typedef G1BOTUpdateCardSet::CardIndex CardIndex;\n-  typedef G1BOTUpdateCardSet::WordType WordType;\n-  typedef G1BOTUpdateCardSet::CardIterator CardIterator;\n-  static constexpr size_t EntriesPerWord = sizeof(WordType) \/ sizeof(CardIndex);\n-\n-  const size_t _size;\n-  CardIndex _data[1];\n-\n-  template<typename Derived>\n-  static size_t header_size_in_bytes_internal() {\n-    return offset_of(Derived, _data);\n-  }\n-\n-  inline void set_entry(size_t i, CardIndex v);\n-  inline CardIndex try_clear_entry(size_t i);\n-\n-public:\n-  G1BOTUpdateCardSetArray(size_t num_elems) : _size(num_elems) {\n-    assert(_size > 0, \"Sanity\");\n-  }\n-\n-  static size_t size_in_bytes(size_t num_elems) {\n-    return header_size_in_bytes_internal<G1BOTUpdateCardSetArray>() +\n-           align_up(num_elems, EntriesPerWord) * sizeof(CardIndex);\n-  }\n-\n-  void add_card(size_t position, CardIndex card_index);\n-\n-  CardIndex claim_card(size_t position);\n-  CardIndex find_first_card_in(size_t min_pos, size_t max_pos);\n-\n-  void iterate_cards(CardIterator& iter);\n-};\n-\n-class G1BOTUpdateCardSetBitMap {\n-private:\n-  typedef G1BOTUpdateCardSet::CardIndex CardIndex;\n-  typedef G1BOTUpdateCardSet::CardIterator CardIterator;\n-\n-  const size_t _size_in_bits;\n-  BitMap::bm_word_t _bits[1];\n-\n-  template<typename Derived>\n-  static size_t header_size_in_bytes_internal() {\n-    return offset_of(Derived, _bits);\n-  }\n-\n-public:\n-  G1BOTUpdateCardSetBitMap(size_t size_in_bits) : _size_in_bits(size_in_bits) {\n-    assert(_size_in_bits > 0, \"Sanity\");\n-  }\n-\n-  static size_t size_in_bytes(size_t size_in_bits) {\n-    return header_size_in_bytes_internal<G1BOTUpdateCardSetBitMap>() +\n-           BitMap::calc_size_in_words(size_in_bits) * BytesPerWord;\n-  }\n-\n-  static BitMap::idx_t bit_position_for(CardIndex card_index) {\n-    assert(sizeof(CardIndex) <= sizeof(BitMap::idx_t), \"Sanity\");\n-    return card_index;\n-  }\n-  static CardIndex card_index_for(BitMap::idx_t bit_position) {\n-    assert(bit_position <= (BitMap::idx_t)(CardIndex)-1, \"Overflow\");\n-    return (CardIndex)bit_position;\n-  }\n-\n-  void add_card(CardIndex effect_card_index);\n-\n-  bool claim_card(CardIndex effect_card_index);\n-  CardIndex find_first_card_in(CardIndex min_card_index, CardIndex max_card_index);\n-\n-  void iterate_cards(BitMapClosure* cl);\n-};\n-\n-#endif \/\/ SHARE_GC_G1_G1BOTFIXINGCARDSET_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BOTUpdateCardSet.hpp","additions":0,"deletions":232,"binary":false,"changes":232,"status":"deleted"},{"patch":"@@ -1,174 +0,0 @@\n-#ifndef SHARE_GC_G1_G1BOTFIXINGCARDSET_INLINE_HPP\n-#define SHARE_GC_G1_G1BOTFIXINGCARDSET_INLINE_HPP\n-\n-#include \"gc\/g1\/g1BlockOffsetTable.hpp\"\n-#include \"gc\/g1\/g1BOTUpdateCardSet.hpp\"\n-#include \"gc\/g1\/heapRegion.hpp\"\n-\n-#include \"runtime\/atomic.hpp\"\n-#include \"utilities\/bitMap.inline.hpp\"\n-\n-\/\/ Set the element at i to v. This must success, assuming no other threads will try to set it.\n-inline void G1BOTUpdateCardSetArray::set_entry(size_t i, CardIndex v) {\n-  assert(i < _size, \"Sanity\");\n-  CardIndex* entry = align_down(_data + i, sizeof(WordType));\n-  WordType* word_entry = (WordType*)entry;\n-  size_t offset = i % EntriesPerWord;\n-\n-  WordType old_val = *word_entry;\n-  WordType expect = 0;\n-  do {\n-    assert(((CardIndex*)(&old_val))[offset] == 0, \"Entry have been set\");\n-    expect = old_val;\n-    WordType new_val = expect;\n-    ((CardIndex*)(&new_val))[offset] = v;\n-    old_val = Atomic::cmpxchg(word_entry, expect, new_val, memory_order_relaxed);\n-  } while (old_val != expect);\n-}\n-\n-\/\/ Clear the entry at i. Success in clearing will return the original value at this position.\n-inline G1BOTUpdateCardSet::CardIndex G1BOTUpdateCardSetArray::try_clear_entry(size_t i) {\n-  assert(i < _size, \"Sanity\");\n-  CardIndex* entry = align_down(_data + i, sizeof(WordType));\n-  WordType* word_entry = (WordType*)entry;\n-  size_t offset = i % EntriesPerWord;\n-\n-  WordType old_val = *word_entry;\n-  WordType expect = 0;\n-  do {\n-    if (((CardIndex*)(&old_val))[offset] == 0) {\n-      return 0;\n-    }\n-    expect = old_val;\n-    WordType new_val = expect;\n-    ((CardIndex*)(&new_val))[offset] = 0;\n-    old_val = Atomic::cmpxchg(word_entry, expect, new_val, memory_order_relaxed);\n-  } while (old_val != expect);\n-  return ((CardIndex*)(&expect))[offset];\n-}\n-\n-inline void G1BOTUpdateCardSetArray::add_card(size_t position, CardIndex card_index) {\n-  set_entry(position, card_index);\n-}\n-\n-inline G1BOTUpdateCardSet::CardIndex G1BOTUpdateCardSetArray::claim_card(size_t position) {\n-  return try_clear_entry(position);\n-}\n-\n-inline G1BOTUpdateCardSet::CardIndex G1BOTUpdateCardSetArray::find_first_card_in(size_t min_pos,\n-                                                                                 size_t max_pos) {\n-  assert(min_pos <= max_pos, \"Invalid range\");\n-  assert(max_pos < _size, \"Range out of bounds\");\n-  for (size_t i = min_pos; i <= max_pos; i++) {\n-    if (_data[i] != 0) {\n-      return _data[i];\n-    }\n-  }\n-  return 0;\n-}\n-\n-inline void G1BOTUpdateCardSetArray::iterate_cards(CardIterator& iter) {\n-  for (size_t i = 0; i < _size; i++) {\n-    if (_data[i] != 0) {\n-      if (claim_card(i)) {\n-        if (iter.do_card(_data[i]) == false) {\n-          \/\/ Iteration aborts.\n-          return;\n-        }\n-      }\n-    }\n-  }\n-}\n-\n-inline void G1BOTUpdateCardSetBitMap::add_card(CardIndex effect_card_index) {\n-  BitMapView bm(_bits, _size_in_bits);\n-  BitMap::idx_t bit_pos = bit_position_for(effect_card_index);\n-  assert(bit_pos < _size_in_bits, \"Out of bounds\");\n-  bool success = bm.par_set_bit(bit_pos, memory_order_relaxed);\n-  assert(success, \"Must success for add card\");\n-}\n-\n-inline bool G1BOTUpdateCardSetBitMap::claim_card(CardIndex effect_card_index) {\n-  BitMapView bm(_bits, _size_in_bits);\n-  BitMap::idx_t bit_pos = bit_position_for(effect_card_index);\n-  if (bm.par_clear_bit(bit_pos, memory_order_relaxed)) {\n-    return true;\n-  }\n-  return false;\n-}\n-\n-inline G1BOTUpdateCardSet::CardIndex G1BOTUpdateCardSetBitMap::find_first_card_in(\n-    CardIndex min_effect_card_index, CardIndex max_effect_card_index) {\n-  BitMap::idx_t min_pos = bit_position_for(min_effect_card_index);\n-  BitMap::idx_t max_pos = bit_position_for(max_effect_card_index);\n-  assert(min_pos <= max_pos, \"Invalid range\");\n-  assert(max_pos < _size_in_bits, \"Range out of bounds\");\n-  BitMapView bm(_bits, _size_in_bits);\n-  BitMapView::idx_t one_position = bm.get_next_one_offset(min_pos, max_pos + 1);\n-  if (one_position == max_pos + 1) {\n-    \/\/ If this overflows, it will be zero, which is still an invalid value that we can check.\n-    return max_effect_card_index + 1;\n-  }\n-  return card_index_for(one_position);\n-}\n-\n-inline void G1BOTUpdateCardSetBitMap::iterate_cards(BitMapClosure* cl) {\n-  BitMapView bm(_bits, _size_in_bits);\n-  bm.iterate(cl);\n-}\n-\n-inline G1BOTUpdateCardSet::CardIndex G1BOTUpdateCardSet::card_index_for(HeapWord* addr) const {\n-  assert(_hr->bottom() <= addr && addr < _hr->end(), \"Card index would overflow\");\n-  size_t card_index = pointer_delta(addr, _hr->bottom()) >> BOTConstants::LogN_words;\n-  assert(card_index <= _last_card_index, \"Sanity\");\n-  return (CardIndex)card_index;\n-}\n-\n-inline HeapWord* G1BOTUpdateCardSet::card_boundary_for(CardIndex card_index) const {\n-  return _hr->bottom() + (((size_t)card_index) << BOTConstants::LogN_words);\n-}\n-\n-inline bool G1BOTUpdateCardSet::is_below_start(HeapWord* addr) const {\n-  return card_index_for(addr) < _start_card_index;\n-}\n-\n-\/\/ Compute the array index for a card index. We will first offset the card index by\n-\/\/ -_start_card_index. Then we will check whether we need to handle the special case of\n-\/\/ _last_card_index.\n-inline size_t G1BOTUpdateCardSet::array_index_for(CardIndex card_index) const {\n-  assert(card_index >= _start_card_index, \"No need to update\");\n-  card_index -= _start_card_index;\n-  size_t index_in_array = (((size_t)card_index) << BOTConstants::LogN_words) \/ _plab_word_size;\n-  assert(_last_card_index >= _start_card_index, \"One of these is not correctly set\");\n-  if (card_index == _last_card_index - _start_card_index) {\n-    \/\/ There is a special case that a small plab can be allocated at the end of the region,\n-    \/\/ possibly making the last two plabs sharing the same array index, if using the above\n-    \/\/ calculation. Because this small plab's last card must also be the last card of the region,\n-    \/\/ we can identify it and store this one in the special slot.\n-    index_in_array++; \/\/ The special slot\n-  }\n-  return index_in_array;\n-}\n-\n-\/\/ Effective card index is card index minus _start_card_index.\n-\/\/ Effective card index is used for bitmap storage.\n-inline G1BOTUpdateCardSet::CardIndex\n-G1BOTUpdateCardSet::bitmap_effect_card_index_for(CardIndex card_index) const {\n-  assert(card_index >= _start_card_index, \"No need to update\");\n-  return card_index - _start_card_index;\n-}\n-inline G1BOTUpdateCardSet::CardIndex\n-G1BOTUpdateCardSet::bitmap_card_index_for(CardIndex effect_card_index) const {\n-  assert(effect_card_index + _start_card_index <= _last_card_index, \"Sanity\");\n-  return effect_card_index + _start_card_index;\n-}\n-\n-inline G1BOTUpdateCardSetArray* G1BOTUpdateCardSet::as_array() {\n-  return (G1BOTUpdateCardSetArray*)_dynamic_container;\n-}\n-\n-inline G1BOTUpdateCardSetBitMap* G1BOTUpdateCardSet::as_bitmap() {\n-  return (G1BOTUpdateCardSetBitMap*)_dynamic_container;\n-}\n-\n-#endif \/\/ SHARE_GC_G1_G1BOTFIXINGCARDSET_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BOTUpdateCardSet.inline.hpp","additions":0,"deletions":174,"binary":false,"changes":174,"status":"deleted"},{"patch":"@@ -185,4 +185,0 @@\n-  \/\/ Check whether the entry for addr points to a block that cannot covers addr.\n-  \/\/ (If addr is at a card boundary, this indicates the entry needs to be udpated.)\n-  \/\/ Return such block (or NULL otherwise).\n-  HeapWord* need_update(HeapWord* addr) const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BlockOffsetTable.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,9 +34,0 @@\n-inline HeapWord* G1BlockOffsetTablePart::need_update(HeapWord* addr) const {\n-  assert(addr >= _hr->bottom() && addr < _hr->top(), \"invalid address\");\n-  HeapWord* q = block_at_or_preceding(addr);\n-  if (q + block_size(q) <= addr) {\n-    return q;\n-  }\n-  return NULL;\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BlockOffsetTable.inline.hpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1800,3 +1800,0 @@\n-  if (G1UseConcurrentBOTUpdate) {\n-    _concurrent_bot_update->stop();\n-  }\n@@ -2492,3 +2489,0 @@\n-  if (G1UseConcurrentBOTUpdate) {\n-    _concurrent_bot_update->threads_do(tc);\n-  }\n@@ -2500,3 +2494,0 @@\n-  if (G1UseConcurrentBOTUpdate) {\n-    _concurrent_bot_update->print_summary_info();\n-  }\n@@ -2772,11 +2763,0 @@\n-void G1CollectedHeap::finalize_concurrent_bot_update() {\n-  if (G1UseConcurrentBOTUpdate) {\n-    double start_t = os::elapsedTime();\n-    _concurrent_bot_update->abort_and_wait();\n-    _concurrent_bot_update->clear_card_sets();\n-    double end_t = os::elapsedTime();\n-    double time_ms = (end_t - start_t) * 1000.0;\n-    phase_times()->record_concurrent_bot_update_finalize_time(time_ms);\n-  }\n-}\n-\n@@ -3099,2 +3079,0 @@\n-    finalize_concurrent_bot_update();\n-\n@@ -3159,3 +3137,0 @@\n-  if (G1UseConcurrentBOTUpdate) {\n-    _concurrent_bot_update->activate();\n-  }\n@@ -3389,9 +3364,0 @@\n-    void prepare_bot_update_card_set(HeapRegion* hr) {\n-      if (G1UseConcurrentBOTUpdate) {\n-        DEBUG_ONLY(hr->bot_update_card_set()->verify();)\n-        if (hr->is_old()) {\n-          hr->set_bot_update_start();\n-        }\n-      }\n-    }\n-\n@@ -3472,2 +3438,0 @@\n-      prepare_bot_update_card_set(hr);\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":0,"deletions":36,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -798,2 +798,0 @@\n-  void finalize_concurrent_bot_update();\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,2 +1,2 @@\n-#include \"gc\/g1\/g1BlockOffsetTable.inline.hpp\"\n-#include \"gc\/g1\/g1BOTUpdateCardSet.inline.hpp\"\n+#include \"gc\/g1\/g1BarrierSet.hpp\"\n+#include \"gc\/g1\/g1BlockOffsetTable.hpp\"\n@@ -9,20 +9,0 @@\n-#include \"runtime\/atomic.hpp\"\n-#include \"runtime\/os.hpp\"\n-\n-using CardIndex = G1BOTUpdateCardSet::CardIndex;\n-\n-class G1ConcurrentBOTUpdateThread: public ConcurrentGCThread {\n-  friend class G1ConcurrentBOTUpdate;\n-\n-  double _vtime_accum;\n-  G1ConcurrentBOTUpdate* _updater;\n-\n-  G1ConcurrentBOTUpdateThread(G1ConcurrentBOTUpdate* updater, uint i);\n-\n-  void wait_for_work();\n-\n-  void run_service();\n-  void stop_service();\n-\n-  double vtime_accum() const { return _vtime_accum; }\n-};\n@@ -32,6 +12,0 @@\n-  _in_progress(false),\n-  _should_abort(false),\n-  _n_workers(ConcGCThreads),\n-  _inactive_count(0),\n-  _stopped_count(0),\n-  _updater_threads(NULL),\n@@ -39,28 +13,1 @@\n-  _plab_recording_in_progress(false),\n-  _card_sets(NULL),\n-  _current(NULL),\n-  _stats() {\n-  _updater_threads = NEW_C_HEAP_ARRAY(G1ConcurrentBOTUpdateThread*, _n_workers, mtGC);\n-  for (uint i = 0; i < _n_workers; i++) {\n-    G1ConcurrentBOTUpdateThread* t = NULL;\n-    if (!InjectGCWorkerCreationFailure) {\n-      t = new G1ConcurrentBOTUpdateThread(this, i);\n-    }\n-    if (t == NULL || t->osthread() == NULL) {\n-      log_warning(gc, bot)(\"Unable to create G1ConcurrentBOTUpdateThread #%d\", i);\n-      if (i == 0) {\n-        G1UseConcurrentBOTUpdate = false;\n-      }\n-      _n_workers = i; \/\/ Actual number of threads created\n-      break;\n-    }\n-    _updater_threads[i] = t;\n-  }\n-}\n-\n-void G1ConcurrentBOTUpdate::update_bot_for_card_set(G1BOTUpdateCardSet* card_set) {\n-  assert(!card_set->is_empty(), \"We should be the only one emptying it\");\n-  card_set->print_stats();\n-  class BOTUpdateCardSetClosure: public G1BOTUpdateCardSet::CardIterator {\n-    G1ConcurrentBOTUpdate* _updater;\n-    HeapRegion* _hr;\n+  _plab_recording_in_progress(false) {}\n@@ -68,38 +15,2 @@\n-  public:\n-    uint _num_plabs;\n-\n-    BOTUpdateCardSetClosure(G1ConcurrentBOTUpdate* updater, HeapRegion* hr) :\n-      _updater(updater), _hr(hr), _num_plabs(0) {}\n-    bool do_card(CardIndex card_index) {\n-      HeapWord* card_boundary = _hr->bot_update_card_set()->card_boundary_for(card_index);\n-      \/\/ We have the last card boundary cover by a plab. We will update\n-      \/\/ the block (normally the block will be the plab) that covers this card boundary.\n-      _hr->update_bot(card_boundary);\n-      _num_plabs++;\n-      return (_updater->should_abort() == false); \/\/ Stop iteration if it aborts\n-    }\n-  } cl(this, card_set->hr());\n-\n-  Ticks start = Ticks::now();\n-  card_set->iterate_cards(cl);\n-  card_set->mark_as_done();\n-  log_info(gc, bot)(\"Concurrent BOT Update: updated %d plabs, took %8.2lf ms\",\n-                    cl._num_plabs, (Ticks::now() - start).seconds() * MILLIUNITS);\n-}\n-\n-bool G1ConcurrentBOTUpdate::update_bot_step() {\n-  G1BOTUpdateCardSet* old_val = _current;\n-  G1BOTUpdateCardSet* expect = NULL;\n-  G1BOTUpdateCardSet* new_val = NULL;\n-  do {\n-    if (old_val == NULL) return false;\n-\n-    expect = old_val;\n-    new_val = expect->next();\n-    old_val = Atomic::cmpxchg(&_current, expect, new_val, memory_order_relaxed);\n-  } while (old_val != expect);\n-\n-  update_bot_for_card_set(old_val);\n-\n-  return (new_val != NULL) && !_should_abort;\n-}\n+void G1ConcurrentBOTUpdate::update_bot_for_plab(HeapWord* card_boundary) {\n+  HeapRegion* r = _g1h->heap_region_containing(card_boundary);\n@@ -107,1 +18,0 @@\n-void G1ConcurrentBOTUpdate::update_bot_before_refine(HeapRegion* r, HeapWord* card_boundary) {\n@@ -109,1 +19,1 @@\n-  assert(_g1h->card_table()->is_card_aligned(card_boundary), \"Only do this for cards to refine\");\n+  assert(_g1h->card_table()->is_card_aligned(card_boundary), \"Need plab card boundary\");\n@@ -112,18 +22,2 @@\n-  \/\/ If the region doesn't have plabs or if the card is below where plabs are allocated.\n-  G1BOTUpdateCardSet* card_set = r->bot_update_card_set();\n-  if (card_set->is_empty() || card_set->is_below_start(card_boundary)) return;\n-\n-  \/\/ If the card points into an object instead of a plab.\n-  HeapWord* latest_plab_start = r->need_update(card_boundary);\n-  if (latest_plab_start == NULL) return;\n-\n-  \/\/ If the plab has been claimed.\n-  CardIndex c = card_set->find_plab_covering(card_boundary, latest_plab_start);\n-  if (c == 0) return;\n-  \/\/ In some rare cases, the plab have been claimed and we get the plab after that plab.\n-  \/\/ Since it's rare, we do not check this case and let this thread update the wrong plab.\n-  \/\/ This will (nicely) leave more time for the update result of first plab to be visible to us.\n-  if (!card_set->claim_card(c)) return;\n-\n-  r->update_bot(card_set->card_boundary_for(c));\n-  log_info(gc, bot)(\"Concurrent BOT Update: updated 1 plab before refine, took %8.2lf ms\",\n+  r->update_bot(card_boundary);\n+  log_info(gc, bot)(\"Concurrent BOT Update: cr updated 1 plab, took %8.2lf ms\",\n@@ -133,0 +27,5 @@\n+bool G1ConcurrentBOTUpdate::update_bot_for_plab_part(HeapWord* card_boundary) {\n+  \/\/ TODO\n+  return false;\n+}\n+\n@@ -135,1 +34,0 @@\n-  assert(_card_sets == NULL, \"Sanity\");\n@@ -137,13 +35,10 @@\n-  G1BOTUpdateCardSet::prepare(_plab_word_size);\n-  _plab_recording_in_progress = true;\n-}\n-\n-void G1ConcurrentBOTUpdate::enlist_card_set(G1BOTUpdateCardSet* card_set) {\n-  assert(!card_set->is_empty(), \"Invalid card set\");\n-  G1BOTUpdateCardSet* old_val = _card_sets;\n-  G1BOTUpdateCardSet* expect = NULL;\n-  do {\n-    expect = old_val;\n-    old_val = Atomic::cmpxchg(&_card_sets, expect, card_set, memory_order_relaxed);\n-  } while (old_val != expect);\n-  card_set->set_next(old_val);\n+  \/\/ A threshold to control the cost of managing the plabs. If plab size is too small,\n+  \/\/ it costs a lot to store them, yet the benefit of updating them becomes unnoticeable.\n+  \/\/ The threshold is chosen based on the BOT mechanics: when a plab is smaller than this value,\n+  \/\/ BOT entries only make skipping one card at a time. So partial updates to the BOT are not\n+  \/\/ likely to incur duplicated work. On the other hand, if a plab is larger than this value,\n+  \/\/ BOT makes large skips (e.g., 16 cards at a time), which might induce duplicated work for\n+  \/\/ partial BOT updates. This is when concurrent (non-partial) BOT update becomes very beneficial.\n+  if (_plab_word_size > (BOTConstants::Base * BOTConstants::N_words)) {\n+    _plab_recording_in_progress = true;\n+  }\n@@ -152,3 +47,3 @@\n-void G1ConcurrentBOTUpdate::record_plab_allocation(HeapWord* plab_allocation, size_t word_size) {\n-  if (!_plab_recording_in_progress) return;\n-\n+void G1ConcurrentBOTUpdate::record_plab_allocation_work(G1PLABCardQueue* plab_card_queue,\n+                                                        HeapWord* plab_allocation,\n+                                                        size_t word_size) {\n@@ -170,6 +65,4 @@\n-  G1BOTUpdateCardSet* card_set = r->bot_update_card_set();\n-  bool should_enlist = card_set->add_card(last_card_boundary);\n-\n-  if (should_enlist) {\n-    enlist_card_set(card_set);\n-  }\n+  size_t batch_size = HeapRegion::GrainWords \/ _plab_word_size; \/\/ TODO\n+  assert(batch_size > 1, \"At least 2 plabs per region\");\n+  G1BarrierSet::dirty_card_queue_set().enqueue_plab_card(*plab_card_queue,\n+                                                         last_card_boundary, batch_size);\n@@ -181,20 +74,0 @@\n-  _current = _card_sets;\n-}\n-\n-void G1ConcurrentBOTUpdate::clear_card_sets() {\n-  assert_at_safepoint_on_vm_thread();\n-  uint count[2] = { 0, 0 };\n-  while (_card_sets != NULL) {\n-    G1BOTUpdateCardSet* card_set = _card_sets;\n-    _card_sets = _card_sets->next();\n-    count[card_set->is_empty()]++;\n-    card_set->clear();\n-  }\n-  _current = NULL;\n-  log_info(gc, bot)(\"Concurrent BOT Update: processed\/aborted = %d\/%d\", count[1], count[0]);\n-}\n-\n-void G1ConcurrentBOTUpdate::threads_do(ThreadClosure* tc) {\n-  for (uint i = 0; i < _n_workers; i++) {\n-    tc->do_thread(_updater_threads[i]);\n-  }\n@@ -202,119 +75,0 @@\n-\n-void G1ConcurrentBOTUpdate::print_summary_info() {\n-  Log(gc, bot) log;\n-  if (log.is_trace()) {\n-    log.trace(\" Concurrent BOT Update:\");\n-    for (uint i = 0; i < _n_workers; i++) {\n-      log.trace(\"  Worker #%d concurrent time = %8.2f s.\", i, _updater_threads[i]->vtime_accum());\n-    }\n-  }\n-}\n-\n-\/\/ Synchronization between the BOT update threads and the activating\/aborting VM thread.\n-\n-\/\/ Called by VM thread.\n-void G1ConcurrentBOTUpdate::activate() {\n-  MutexLocker ml(ConcurrentBOTUpdate_lock, Mutex::_no_safepoint_check_flag);\n-  assert(_in_progress == false, \"Activated twice\");\n-  assert(_should_abort == false, \"Sanity\");\n-  if (_stopped_count == _n_workers) return; \/\/ No workers\n-  _in_progress = true;\n-  ConcurrentBOTUpdate_lock->notify_all();\n-  _stats.concurrent_phase_start_time = Ticks::now();\n-}\n-\n-\/\/ Called by VM thread.\n-void G1ConcurrentBOTUpdate::abort_and_wait() {\n-  MonitorLocker ml(ConcurrentBOTUpdate_lock, Mutex::_no_safepoint_check_flag);\n-  if (_in_progress) {\n-    _should_abort = true;\n-  } else {\n-    assert(_should_abort == false, \"Must have cleared this\");\n-  }\n-  while (_in_progress) {\n-    assert(_should_abort, \"Who changed this?\");\n-    ml.wait();\n-  }\n-}\n-\n-\/\/ Called by one of the workers.\n-void G1ConcurrentBOTUpdate::deactivate() {\n-  assert(ConcurrentBOTUpdate_lock->owned_by_self(), \"Must be locked by self\");\n-  if (_in_progress && _inactive_count + _stopped_count == _n_workers) {\n-    _in_progress = false;\n-    _should_abort = false;\n-    ConcurrentBOTUpdate_lock->notify_all(); \/\/ Notify that all workers are now inactive\/stopped\n-    log_info(gc, bot)(\"Concurrent BOT Update: took %8.2lf ms\",\n-                      (Ticks::now() - _stats.concurrent_phase_start_time).seconds() * MILLIUNITS);\n-  }\n-}\n-\n-void G1ConcurrentBOTUpdate::note_active() {\n-  assert(ConcurrentBOTUpdate_lock->owned_by_self(), \"Must be locked by self\");\n-  _inactive_count--;\n-}\n-\n-void G1ConcurrentBOTUpdate::note_inactive() {\n-  assert(ConcurrentBOTUpdate_lock->owned_by_self(), \"Must be locked by self\");\n-  _inactive_count++;\n-  deactivate();\n-}\n-\n-void G1ConcurrentBOTUpdate::note_stopped() {\n-  assert(ConcurrentBOTUpdate_lock->owned_by_self(), \"Must be locked by self\");\n-  _stopped_count++;\n-  deactivate();\n-}\n-\n-void G1ConcurrentBOTUpdate::stop() {\n-  for (uint i = 0; i < _n_workers; i++) {\n-    _updater_threads[i]->stop();\n-  }\n-}\n-\n-G1ConcurrentBOTUpdateThread::G1ConcurrentBOTUpdateThread(G1ConcurrentBOTUpdate* updater, uint i) :\n-  ConcurrentGCThread(), _vtime_accum(0.0), _updater(updater) {\n-  set_name(\"G1 BOT Update #%d\", i);\n-  create_and_start();\n-}\n-\n-void G1ConcurrentBOTUpdateThread::wait_for_work() {\n-  MonitorLocker ml(ConcurrentBOTUpdate_lock, Mutex::_no_safepoint_check_flag);\n-  _updater->note_inactive();\n-  while ((!_updater->in_progress() || _updater->should_abort()) && !should_terminate()) {\n-    ml.wait();\n-  }\n-  _updater->note_active();\n-}\n-\n-void G1ConcurrentBOTUpdateThread::run_service() {\n-  double vtime_start = os::elapsedVTime();\n-\n-  bool more_work = false;\n-  while (!should_terminate()) {\n-    if (more_work == false) {\n-      wait_for_work();\n-      if (should_terminate()) {\n-        break;\n-      }\n-    }\n-\n-    more_work = _updater->update_bot_step();\n-\n-    if (os::supports_vtime()) {\n-      _vtime_accum = (os::elapsedVTime() - vtime_start);\n-    } else {\n-      _vtime_accum = 0.0;\n-    }\n-  }\n-\n-  MutexLocker ml(ConcurrentBOTUpdate_lock, Mutex::_no_safepoint_check_flag);\n-  _updater->note_stopped();\n-}\n-\n-void G1ConcurrentBOTUpdateThread::stop_service() {\n-  MutexLocker ml(ConcurrentBOTUpdate_lock, Mutex::_no_safepoint_check_flag);\n-  ConcurrentBOTUpdate_lock->notify_all();\n-}\n-\n-\/\/ End of synchronization between the BOT update threads and the activating\/aborting VM thread.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentBOTUpdate.cpp","additions":30,"deletions":276,"binary":false,"changes":306,"status":"modified"},{"patch":"@@ -1,2 +1,2 @@\n-#ifndef SHARE_GC_G1_G1CONCURRENTBOTFIXING_HPP\n-#define SHARE_GC_G1_G1CONCURRENTBOTFIXING_HPP\n+#ifndef SHARE_GC_G1_G1CONCURRENTBOTUPDATE_HPP\n+#define SHARE_GC_G1_G1CONCURRENTBOTUPDATE_HPP\n@@ -4,3 +4,0 @@\n-#include \"gc\/g1\/g1BOTUpdateCardSet.hpp\"\n-\n-#include \"memory\/iterator.hpp\"\n@@ -8,5 +5,0 @@\n-#include \"utilities\/ticks.hpp\"\n-\n-struct G1BOTUpdateStats {\n-  Ticks concurrent_phase_start_time;\n-};\n@@ -15,1 +7,1 @@\n-class G1ConcurrentBOTUpdateThread;\n+class G1PLABCardQueue;\n@@ -20,9 +12,0 @@\n-  volatile bool _in_progress;\n-  volatile bool _should_abort;\n-  \/\/ Workers.\n-  uint _n_workers;\n-  \/\/ Two counters to know when all workers have finished.\n-  uint _inactive_count; \/\/ Number of workers waiting for jobs\n-  uint _stopped_count; \/\/ Number of workers terminated\n-  G1ConcurrentBOTUpdateThread** _updater_threads;\n-\n@@ -35,10 +18,1 @@\n-  \/\/ A list of card sets, each recording the cards (of plabs) that need to be updated.\n-  G1BOTUpdateCardSet* _card_sets;\n-  \/\/ A pointer into the list for job dispatching.\n-  G1BOTUpdateCardSet* _current;\n-\n-  G1BOTUpdateStats _stats;\n-\n-  void enlist_card_set(G1BOTUpdateCardSet* card_set);\n-\n-  void update_bot_for_card_set(G1BOTUpdateCardSet* card_set);\n+  void record_plab_allocation_work(G1PLABCardQueue* q, HeapWord* plab_allocation, size_t word_size);\n@@ -49,20 +23,0 @@\n-  bool in_progress() const { return _in_progress; }\n-  bool should_abort() const { return _should_abort; }\n-\n-  \/\/ Signal the workers to concurrently process the card sets.\n-  void activate();\n-  \/\/ Abort the jobs and wait for workers to finish.\n-  void abort_and_wait();\n-  \/\/ Signal that the workers have all finished.\n-  void deactivate();\n-  \/\/ Workers use these to maintain _inactive_count\/_stopped_count and notify possible waiters\n-  \/\/ waiting for the workers to finish.\n-  void note_active();\n-  void note_inactive();\n-  void note_stopped();\n-  \/\/ Terminate the threads.\n-  void stop();\n-\n-  \/\/ Clear the card sets from previous gcs.\n-  void clear_card_sets();\n-\n@@ -73,1 +27,5 @@\n-  void record_plab_allocation(HeapWord* plab_allocation, size_t word_size);\n+  void record_plab_allocation(G1PLABCardQueue* q, HeapWord* plab_allocation, size_t word_size) {\n+    if (_plab_recording_in_progress) {\n+      record_plab_allocation_work(q, plab_allocation, word_size);\n+    }\n+  }\n@@ -75,1 +33,1 @@\n-  \/\/ Setup for the concurrent phase after plab recording.\n+  \/\/ Called after recording plabs.\n@@ -78,10 +36,4 @@\n-  \/\/ Entry point for the updater threads. Claim and process one of the card sets from the list.\n-  \/\/ Return whether there are possibly more. Return false if someone asked us to abort.\n-  bool update_bot_step();\n-\n-  \/\/ Entry point for concurrent refinement threads or mutators that tries to do conc refinement.\n-  \/\/ These threads always have a specific card in mind, that is, the dirty card to refine.\n-  void update_bot_before_refine(HeapRegion* r, HeapWord* card_boundary);\n-\n-  void threads_do(ThreadClosure* tc);\n-  void print_summary_info();\n+  void update_bot_for_plab(HeapWord* card_boundary);\n+  \/\/ This version will update BOT for part of the plab, allowing for more prompt pause (for gc).\n+  \/\/ Return true if the plab has more parts to update; otherwise return false.\n+  bool update_bot_for_plab_part(HeapWord* card_boundary);\n@@ -90,1 +42,1 @@\n-#endif \/\/ SHARE_GC_G1_G1CONCURRENTBOTFIXING_HPP\n+#endif \/\/ SHARE_GC_G1_G1CONCURRENTBOTUPDATE_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentBOTUpdate.hpp","additions":15,"deletions":63,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"gc\/g1\/g1ConcurrentBOTUpdate.hpp\"\n@@ -64,0 +65,8 @@\n+G1PLABCardQueue::G1PLABCardQueue(G1DirtyCardQueueSet* qset) :\n+  PtrQueue(qset)\n+{ }\n+\n+G1PLABCardQueue::~G1PLABCardQueue() {\n+  G1BarrierSet::dirty_card_queue_set().flush_queue(*this);\n+}\n+\n@@ -97,0 +106,16 @@\n+void G1DirtyCardQueueSet::flush_queue(G1PLABCardQueue& queue) {\n+  void** buffer = queue.buffer();\n+  if (buffer != nullptr) {\n+    size_t index = queue.index();\n+    queue.set_buffer(nullptr);\n+    queue.set_index(0);\n+    BufferNode* node = BufferNode::make_node_from_buffer(buffer, index);\n+    if (index == buffer_size()) {\n+      deallocate_buffer(node);\n+    } else {\n+      Atomic::add(&_num_cards, buffer_size() - node->index());\n+      _completed.push(*node);\n+    }\n+  }\n+}\n+\n@@ -106,0 +131,17 @@\n+void G1DirtyCardQueueSet::enqueue_plab_card(G1PLABCardQueue& queue, HeapWord* card_boundary,\n+                                            size_t batch_size) {\n+  CardValue* value = (CardValue*)card_boundary; \/\/ Pretend to be a card pointer\n+  if (buffer_size() - queue.index() < batch_size + 1 && try_enqueue(queue, value)) {\n+    return;\n+  }\n+  \/\/ Either we have a full batch or the buffer is full.\n+  BufferNode* old_node = exchange_buffer_with_new(queue);\n+  if (old_node != nullptr) {\n+    Atomic::add(&_num_cards, buffer_size() - old_node->index());\n+    _completed.push(*old_node);\n+  }\n+  \/\/ We enqueue a special card to indicate this is a plab card buffer.\n+  retry_enqueue(queue, nullptr);\n+  retry_enqueue(queue, value);\n+}\n+\n@@ -356,0 +398,1 @@\n+  G1ConcurrentBOTUpdate* const _concurrent_bot_update;\n@@ -431,0 +474,19 @@\n+  bool process_plab_card_buffer() {\n+    \/\/ Check if the first enqueued is a nullptr.\n+    if (_node->index() == _node_buffer_size || _node_buffer[_node_buffer_size - 1] != nullptr) {\n+      \/\/ Not a plab card buffer.\n+      return false;\n+    }\n+    assert(G1UseConcurrentBOTUpdate, \"Otherwise there shouldn't be plab card buffers\");\n+\n+    for (size_t i = _node->index(); i < _node_buffer_size - 1; ++i) {\n+      if (SuspendibleThreadSet::should_yield()) {\n+        \/\/ Abandon the unprocessed cards.\n+        break;\n+      }\n+      _concurrent_bot_update->update_bot_for_plab((HeapWord*)_node_buffer[i]); \/\/ TODO part\n+    }\n+    \/\/ Return \"fully processed\" no matter what. This buffer will always be abandon.\n+    return true;\n+  }\n+\n@@ -441,1 +503,2 @@\n-    _g1rs(G1CollectedHeap::heap()->rem_set()) {}\n+    _g1rs(G1CollectedHeap::heap()->rem_set()),\n+    _concurrent_bot_update(G1CollectedHeap::heap()->concurrent_bot_update()) {}\n@@ -444,0 +507,2 @@\n+    if (process_plab_card_buffer()) return true;\n+\n@@ -479,1 +544,2 @@\n-    assert(node->index() == buffer_size(),\n+    assert(node->index() == buffer_size() ||\n+           BufferNode::make_buffer_from_node(node)[buffer_size() - 1] == nullptr,\n","filename":"src\/hotspot\/share\/gc\/g1\/g1DirtyCardQueue.cpp","additions":68,"deletions":2,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -70,0 +70,6 @@\n+class G1PLABCardQueue: public PtrQueue, public CHeapObj<mtGC> {\n+public:\n+  G1PLABCardQueue(G1DirtyCardQueueSet* qset);\n+  ~G1PLABCardQueue();\n+};\n+\n@@ -282,0 +288,2 @@\n+  void flush_queue(G1PLABCardQueue& queue);\n+\n@@ -285,0 +293,2 @@\n+  void enqueue_plab_card(G1PLABCardQueue& queue, HeapWord* card_boundary, size_t batch_size);\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1DirtyCardQueue.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -173,1 +173,0 @@\n-  _heap->finalize_concurrent_bot_update();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -169,1 +169,0 @@\n-  _concurrent_bot_update_finalize_time_ms = 0.0;\n@@ -379,2 +378,1 @@\n-  const double sum_ms = _concurrent_bot_update_finalize_time_ms +\n-                        _root_region_scan_wait_time_ms +\n+  const double sum_ms = _root_region_scan_wait_time_ms +\n@@ -391,3 +389,0 @@\n-  if (_concurrent_bot_update_finalize_time_ms > 0.0) {\n-    debug_time(\"Concurrent BOT Update Finalization\", _concurrent_bot_update_finalize_time_ms);\n-  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1GCPhaseTimes.cpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -177,1 +177,0 @@\n-  double _concurrent_bot_update_finalize_time_ms;\n@@ -311,4 +310,0 @@\n-  void record_concurrent_bot_update_finalize_time(double time_ms) {\n-    _concurrent_bot_update_finalize_time_ms = time_ms;\n-  }\n-\n@@ -399,4 +394,0 @@\n-  double concurrent_bot_update_finalize_time_ms() {\n-    return _concurrent_bot_update_finalize_time_ms;\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1GCPhaseTimes.hpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -66,0 +66,1 @@\n+    _plab_card_queue(NULL),\n@@ -97,0 +98,3 @@\n+  if (G1UseConcurrentBOTUpdate) {\n+    _plab_card_queue = new G1PLABCardQueue(&G1BarrierSet::dirty_card_queue_set());\n+  }\n@@ -115,0 +119,2 @@\n+  if (_plab_card_queue != NULL)\n+    G1BarrierSet::dirty_card_queue_set().flush_queue(*_plab_card_queue);\n@@ -127,0 +133,1 @@\n+  delete _plab_card_queue;\n@@ -414,1 +421,2 @@\n-        _g1h->concurrent_bot_update()->record_plab_allocation(obj_ptr, actual_plab_size);\n+        _g1h->concurrent_bot_update()->record_plab_allocation(_plab_card_queue,\n+                                                              obj_ptr, actual_plab_size);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+  G1PLABCardQueue* _plab_card_queue;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1369,1 +1369,7 @@\n-      cl->apply_to_buffer(node, buffer_size, worker_id);\n+      if (node->index() < buffer_size &&\n+          BufferNode::make_buffer_from_node(node)[buffer_size - 1] != nullptr) {\n+        cl->apply_to_buffer(node, buffer_size, worker_id);\n+      } else {\n+        \/\/ The first card is a nullptr. This buffer must be a plab card buffer.\n+        assert(G1UseConcurrentBOTUpdate, \"Must be\");\n+      }\n@@ -1659,7 +1665,0 @@\n-  if (G1UseConcurrentBOTUpdate) {\n-    G1ConcurrentBOTUpdate* concurrent_bot_update = _g1h->concurrent_bot_update();\n-    if (concurrent_bot_update->in_progress() && r->is_old()) {\n-      \/\/ Update BOT if this card points into a plab, which causes the BOT to be inaccurate.\n-      concurrent_bot_update->update_bot_before_refine(r, start);\n-    }\n-  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.cpp","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -236,1 +236,0 @@\n-  _bot_update_card_set(this),\n@@ -794,2 +793,0 @@\n-\n-  _bot_update_card_set.clear();\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"gc\/g1\/g1ConcurrentBOTUpdate.hpp\"\n@@ -81,1 +80,0 @@\n-  G1BOTUpdateCardSet _bot_update_card_set;\n@@ -205,1 +203,0 @@\n-  HeapWord* need_update(HeapWord* addr) const;\n@@ -208,9 +205,0 @@\n-  \/\/ BOT update starts from here onwards.\n-  void set_bot_update_start() {\n-    _bot_update_card_set.set_bot_update_start();\n-  }\n-\n-  G1BOTUpdateCardSet* bot_update_card_set() {\n-    return &_bot_update_card_set;\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.hpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -111,4 +111,0 @@\n-inline HeapWord* HeapRegion::need_update(HeapWord* addr) const {\n-  return _bot_part.need_update(addr);\n-}\n-\n@@ -235,1 +231,0 @@\n-    _bot_update_card_set.clear();\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.inline.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -117,1 +117,0 @@\n-Monitor* ConcurrentBOTUpdate_lock     = NULL;\n@@ -228,1 +227,0 @@\n-    def(ConcurrentBOTUpdate_lock   , PaddedMonitor, leaf     ,   true,  _safepoint_check_never);\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -111,1 +111,0 @@\n-extern Monitor* ConcurrentBOTUpdate_lock;        \/\/ synchronization between VM thread and the concurrent BOT update threads\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}