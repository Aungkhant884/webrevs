{"files":[{"patch":"@@ -1989,1 +1989,1 @@\n-  switch (state) {\n+  switch (state & ~SUSPENDED) {\n@@ -1995,1 +1995,0 @@\n-    case RUNNABLE_SUSPENDED :\n@@ -1998,0 +1997,1 @@\n+    case TIMED_PARKING:\n@@ -2002,1 +2002,0 @@\n-    case PARKED_SUSPENDED :\n@@ -2006,0 +2005,4 @@\n+    case TIMED_PARKED:\n+    case TIMED_PINNED:\n+      status = JavaThreadStatus::PARKED_TIMED;\n+      break;\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -524,14 +524,15 @@\n-    NEW          = 0,\n-    STARTED      = 1,\n-    RUNNABLE     = 2,\n-    RUNNING      = 3,\n-    PARKING      = 4,\n-    PARKED       = 5,\n-    PINNED       = 6,\n-    YIELDING     = 7,\n-    TERMINATED   = 99,\n-\n-    \/\/ can be suspended from scheduling when unmounted\n-    SUSPENDED    = 1 << 8,\n-    RUNNABLE_SUSPENDED = (RUNNABLE | SUSPENDED),\n-    PARKED_SUSPENDED   = (PARKED | SUSPENDED)\n+    NEW           = 0,\n+    STARTED       = 1,\n+    RUNNABLE      = 2,\n+    RUNNING       = 3,\n+    PARKING       = 4,\n+    PARKED        = 5,\n+    PINNED        = 6,\n+    TIMED_PARKING = 7,\n+    TIMED_PARKED  = 8,\n+    TIMED_PINNED  = 9,\n+    YIELDING      = 10,\n+    TERMINATED    = 99,\n+\n+    \/\/ additional state bits\n+    SUSPENDED    = 1 << 8,   \/\/ suspended when unmounted\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":15,"deletions":14,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -89,1 +89,1 @@\n-     * Virtual thread state and transitions:\n+     * Virtual thread state transitions:\n@@ -91,1 +91,1 @@\n-     *      NEW -> STARTED         \/\/ Thread.start\n+     *      NEW -> STARTED         \/\/ Thread.start, schedule to run\n@@ -94,0 +94,1 @@\n+     *  RUNNING -> TERMINATED      \/\/ done\n@@ -95,3 +96,5 @@\n-     *  RUNNING -> PARKING         \/\/ Thread attempts to park\n-     *  PARKING -> PARKED          \/\/ cont.yield successful, thread is parked\n-     *  PARKING -> PINNED          \/\/ cont.yield failed, thread is pinned\n+     *  RUNNING -> PARKING         \/\/ Thread parking with LockSupport.park\n+     *  PARKING -> PARKED          \/\/ cont.yield successful, parked indefinitely\n+     *  PARKING -> PINNED          \/\/ cont.yield failed, parked indefinitely on carrier\n+     *   PARKED -> RUNNABLE        \/\/ unparked, schedule to continue\n+     *   PINNED -> RUNNING         \/\/ unparked, continue execution on same carrier\n@@ -99,2 +102,5 @@\n-     *   PARKED -> RUNNABLE        \/\/ unpark or interrupted\n-     *   PINNED -> RUNNABLE        \/\/ unpark or interrupted\n+     *       RUNNING -> TIMED_PARKING   \/\/ Thread parking with LockSupport.parkNanos\n+     * TIMED_PARKING -> TIMED_PARKED    \/\/ cont.yield successful, timed-parked\n+     * TIMED_PARKING -> TIMED_PINNED    \/\/ cont.yield failed, timed-parked on carrier\n+     *  TIMED_PARKED -> RUNNABLE        \/\/ unparked, schedule to continue\n+     *  TIMED_PINNED -> RUNNING         \/\/ unparked, continue execution on same carrier\n@@ -103,1 +109,1 @@\n-     *\n+\n@@ -107,2 +113,0 @@\n-     *\n-     *  RUNNING -> TERMINATED      \/\/ done\n@@ -114,0 +118,2 @@\n+\n+    \/\/ untimed parking\n@@ -117,1 +123,8 @@\n-    private static final int YIELDING = 7;     \/\/ Thread.yield\n+\n+    \/\/ timed parking\n+    private static final int TIMED_PARKING = 7;\n+    private static final int TIMED_PARKED  = 8;\n+    private static final int TIMED_PINNED  = 9;\n+\n+    private static final int YIELDING   = 10;  \/\/ Thread.yield\n+\n@@ -122,2 +135,0 @@\n-    private static final int RUNNABLE_SUSPENDED = (RUNNABLE | SUSPENDED);\n-    private static final int PARKED_SUSPENDED   = (PARKED | SUSPENDED);\n@@ -437,2 +448,1 @@\n-        int s = state();\n-        assert (s == PARKING || s == YIELDING) && (carrierThread == null);\n+        assert carrierThread == null;\n@@ -440,2 +450,4 @@\n-        if (s == PARKING) {\n-            setState(PARKED);\n+        int s = state();\n+        if (s == PARKING || s == TIMED_PARKING) {\n+            int newState = (s == PARKING) ? PARKED : TIMED_PARKED;\n+            setState(newState);\n@@ -447,1 +459,1 @@\n-            if (parkPermit && compareAndSetState(PARKED, RUNNABLE)) {\n+            if (parkPermit && compareAndSetState(newState, RUNNABLE)) {\n@@ -468,0 +480,2 @@\n+        } else {\n+            assert false;\n@@ -610,1 +624,1 @@\n-            setState(PARKING);\n+            setState(TIMED_PARKING);\n@@ -616,1 +630,1 @@\n-                    assert state() == PARKING;\n+                    assert state() == TIMED_PARKING;\n@@ -648,1 +662,1 @@\n-        setState(PINNED);\n+        setState(timed ? TIMED_PINNED : PINNED);\n@@ -716,1 +730,2 @@\n-            if (s == PARKED && compareAndSetState(PARKED, RUNNABLE)) {\n+            boolean parked = (s == PARKED) || (s == TIMED_PARKED);\n+            if (parked && compareAndSetState(s, RUNNABLE)) {\n@@ -727,1 +742,1 @@\n-            } else if (s == PINNED) {\n+            } else if ((s == PINNED) || (s == TIMED_PINNED)) {\n@@ -731,1 +746,1 @@\n-                    if (carrier != null && state() == PINNED) {\n+                    if (carrier != null && ((s = state()) == PINNED || s == TIMED_PINNED)) {\n@@ -868,1 +883,2 @@\n-        switch (state()) {\n+        int s = state();\n+        switch (s & ~SUSPENDED) {\n@@ -879,1 +895,0 @@\n-            case RUNNABLE_SUSPENDED:\n@@ -893,0 +908,1 @@\n+            case TIMED_PARKING:\n@@ -897,1 +913,0 @@\n-            case PARKED_SUSPENDED:\n@@ -899,1 +914,4 @@\n-                return Thread.State.WAITING;\n+                return State.WAITING;\n+            case TIMED_PARKED:\n+            case TIMED_PINNED:\n+                return State.TIMED_WAITING;\n@@ -939,1 +957,1 @@\n-            case RUNNABLE, PARKED -> {\n+            case RUNNABLE, PARKED, TIMED_PARKED -> {\n@@ -951,1 +969,1 @@\n-                            || (parkPermit && compareAndSetState(PARKED, RUNNABLE))) {\n+                            || (parkPermit && compareAndSetState(initialState, RUNNABLE))) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/VirtualThread.java","additions":48,"deletions":30,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -0,0 +1,416 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=default\n+ * @bug 8312498\n+ * @summary Basic test for JVMTI GetThreadState with virtual threads\n+ * @run junit\/othervm\/native GetThreadStateTest\n+ *\/\n+\n+\/*\n+ * @test id=no-vmcontinuations\n+ * @requires vm.continuations\n+ * @run junit\/othervm\/native -XX:+UnlockExperimentalVMOptions -XX:-VMContinuations GetThreadStateTest\n+ *\/\n+\n+import java.util.StringJoiner;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.locks.LockSupport;\n+\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class GetThreadStateTest {\n+\n+    @BeforeAll\n+    static void setup() {\n+        System.loadLibrary(\"GetThreadStateTest\");\n+        init();\n+    }\n+\n+    \/**\n+     * Test state of new\/unstarted thread.\n+     *\/\n+    @Test\n+    void testUnstarted() {\n+        var thread = Thread.ofVirtual().unstarted(() -> { });\n+        check(thread, \/*new*\/ 0);\n+    }\n+\n+    \/**\n+     * Test state of terminated thread.\n+     *\/\n+    @Test\n+    void testTerminated() throws Exception {\n+        var thread = Thread.ofVirtual().start(() -> { });\n+        thread.join();\n+        check(thread, JVMTI_THREAD_STATE_TERMINATED);\n+    }\n+\n+    \/**\n+     * Test state of runnable thread.\n+     *\/\n+    @Test\n+    void testRunnable() throws Exception {\n+        var latch = new CountDownLatch(1);\n+        var done = new AtomicBoolean();\n+        var thread = Thread.ofVirtual().start(() -> {\n+            latch.countDown();\n+\n+            \/\/ spin until done\n+            while (!done.get()) {\n+                Thread.onSpinWait();\n+            }\n+        });\n+        try {\n+            \/\/ wait for thread to start execution\n+            latch.await();\n+\n+            \/\/ thread should be runnable\n+            int expected = JVMTI_THREAD_STATE_ALIVE | JVMTI_THREAD_STATE_RUNNABLE;\n+            check(thread, expected);\n+\n+            \/\/ re-test with interrupt status set\n+            thread.interrupt();\n+            check(thread, expected | JVMTI_THREAD_STATE_INTERRUPTED);\n+        } finally {\n+            done.set(true);\n+            thread.join();\n+        }\n+    }\n+\n+    \/**\n+     * Test state of thread waiting to enter a monitor.\n+     *\/\n+    @Test\n+    void testMonitorEnter() throws Exception {\n+        var latch = new CountDownLatch(1);\n+        Object lock = new Object();\n+        var thread = Thread.ofVirtual().unstarted(() -> {\n+            latch.countDown();\n+            synchronized (lock) { }\n+        });\n+        try {\n+            synchronized (lock) {\n+                \/\/ start thread and wait for it to start execution\n+                thread.start();\n+                latch.await();\n+\n+                \/\/ thread should block on monitor enter\n+                int expected = JVMTI_THREAD_STATE_ALIVE | JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER;\n+                await(thread, expected);\n+\n+                \/\/ re-test with interrupt status set\n+                thread.interrupt();\n+                check(thread, expected | JVMTI_THREAD_STATE_INTERRUPTED);\n+            }\n+        } finally {\n+            thread.join();\n+        }\n+    }\n+\n+    \/**\n+     * Test state of thread waiting in Object.wait().\n+     *\/\n+    @Test\n+    void testObjectWait() throws Exception {\n+        var latch = new CountDownLatch(1);\n+        Object lock = new Object();\n+        var thread = Thread.ofVirtual().start(() -> {\n+            synchronized (lock) {\n+                latch.countDown();\n+                try {\n+                    lock.wait();\n+                } catch (InterruptedException e) { }\n+            }\n+        });\n+        try {\n+            \/\/ wait for thread to own monitor\n+            latch.await();\n+\n+            \/\/ thread should wait\n+            int expected = JVMTI_THREAD_STATE_ALIVE |\n+                    JVMTI_THREAD_STATE_WAITING |\n+                    JVMTI_THREAD_STATE_WAITING_INDEFINITELY |\n+                    JVMTI_THREAD_STATE_IN_OBJECT_WAIT;\n+            await(thread, expected);\n+\n+            \/\/ notify so thread waits to re-enter monitor\n+            synchronized (lock) {\n+                lock.notifyAll();\n+                expected = JVMTI_THREAD_STATE_ALIVE | JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER;\n+                check(thread, expected);\n+\n+                \/\/ re-test with interrupt status set\n+                thread.interrupt();\n+                check(thread, expected | JVMTI_THREAD_STATE_INTERRUPTED);\n+            }\n+        } finally {\n+            thread.interrupt();\n+            thread.join();\n+        }\n+    }\n+\n+    \/**\n+     * Test state of thread waiting in Object.wait(millis).\n+     *\/\n+    @Test\n+    void testObjectWaitMillis() throws Exception {\n+        var latch = new CountDownLatch(1);\n+        Object lock = new Object();\n+        var thread = Thread.ofVirtual().start(() -> {\n+            synchronized (lock) {\n+                latch.countDown();\n+                try {\n+                    lock.wait(Long.MAX_VALUE);\n+                } catch (InterruptedException e) { }\n+            }\n+        });\n+        try {\n+            \/\/ wait for thread to own monitor\n+            latch.await();\n+\n+            \/\/ thread should wait\n+            int expected = JVMTI_THREAD_STATE_ALIVE |\n+                    JVMTI_THREAD_STATE_WAITING |\n+                    JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT |\n+                    JVMTI_THREAD_STATE_IN_OBJECT_WAIT;\n+            await(thread, expected);\n+\n+            \/\/ notify so thread waits to re-enter monitor\n+            synchronized (lock) {\n+                lock.notifyAll();\n+                expected = JVMTI_THREAD_STATE_ALIVE | JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER;\n+                check(thread, expected);\n+\n+                \/\/ re-test with interrupt status set\n+                thread.interrupt();\n+                check(thread, expected | JVMTI_THREAD_STATE_INTERRUPTED);\n+            }\n+        } finally {\n+            thread.interrupt();\n+            thread.join();\n+        }\n+    }\n+\n+    \/**\n+     * Test state of thread parked with LockSupport.park.\n+     *\/\n+    @Test\n+    void testPark() throws Exception {\n+        var latch = new CountDownLatch(1);\n+        var done = new AtomicBoolean();\n+        var thread = Thread.ofVirtual().start(() -> {\n+            latch.countDown();\n+            while (!done.get()) {\n+                LockSupport.park();\n+            }\n+        });\n+        try {\n+            \/\/ wait for thread to start execution\n+            latch.await();\n+\n+            \/\/ thread should park\n+            int expected = JVMTI_THREAD_STATE_ALIVE |\n+                    JVMTI_THREAD_STATE_WAITING |\n+                    JVMTI_THREAD_STATE_WAITING_INDEFINITELY |\n+                    JVMTI_THREAD_STATE_PARKED;\n+            await(thread, expected);\n+        } finally {\n+            done.set(true);\n+            LockSupport.unpark(thread);\n+            thread.join();\n+        }\n+    }\n+\n+    \/**\n+     * Test state of thread parked with LockSupport.parkNanos.\n+     *\/\n+    @Test\n+    void testParkNanos() throws Exception {\n+        var latch = new CountDownLatch(1);\n+        var done = new AtomicBoolean();\n+        var thread = Thread.ofVirtual().start(() -> {\n+            latch.countDown();\n+            while (!done.get()) {\n+                LockSupport.parkNanos(Long.MAX_VALUE);\n+            }\n+        });\n+        try {\n+            \/\/ wait for thread to start execution\n+            latch.await();\n+\n+            \/\/ thread should park\n+            int expected = JVMTI_THREAD_STATE_ALIVE |\n+                    JVMTI_THREAD_STATE_WAITING |\n+                    JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT |\n+                    JVMTI_THREAD_STATE_PARKED;\n+            await(thread, expected);\n+        } finally {\n+            done.set(true);\n+            LockSupport.unpark(thread);\n+            thread.join();\n+        }\n+    }\n+\n+    \/**\n+     * Test state of thread parked with LockSupport.park while holding a monitor.\n+     *\/\n+    @Test\n+    void testParkWhenPinned() throws Exception {\n+        var latch = new CountDownLatch(1);\n+        Object lock = new Object();\n+        var done = new AtomicBoolean();\n+        var thread = Thread.ofVirtual().start(() -> {\n+            synchronized (lock) {\n+                latch.countDown();\n+                while (!done.get()) {\n+                    LockSupport.park();\n+                }\n+            }\n+        });\n+        try {\n+            \/\/ wait for thread to own monitor\n+            latch.await();\n+\n+            \/\/ thread should park\n+            int expected = JVMTI_THREAD_STATE_ALIVE |\n+                    JVMTI_THREAD_STATE_WAITING |\n+                    JVMTI_THREAD_STATE_WAITING_INDEFINITELY |\n+                    JVMTI_THREAD_STATE_PARKED;\n+            await(thread, expected);\n+        } finally {\n+            done.set(true);\n+            LockSupport.unpark(thread);\n+            thread.join();\n+        }\n+    }\n+\n+    \/**\n+     * Test state of thread parked with LockSupport.parkNanos while holding a monitor.\n+     *\/\n+    @Test\n+    void testParkNanosWhenPinned() throws Exception {\n+        var latch = new CountDownLatch(1);\n+        Object lock = new Object();\n+        var done = new AtomicBoolean();\n+        var thread = Thread.ofVirtual().start(() -> {\n+            synchronized (lock) {\n+                latch.countDown();\n+                while (!done.get()) {\n+                    LockSupport.parkNanos(Long.MAX_VALUE);\n+                }\n+            }\n+        });\n+        try {\n+            \/\/ wait for thread to own monitor\n+            latch.await();\n+\n+            \/\/ thread should park\n+            int expected = JVMTI_THREAD_STATE_ALIVE |\n+                    JVMTI_THREAD_STATE_WAITING |\n+                    JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT |\n+                    JVMTI_THREAD_STATE_PARKED;\n+            await(thread, expected);\n+        } finally {\n+            done.set(true);\n+            LockSupport.unpark(thread);\n+            thread.join();\n+        }\n+    }\n+\n+    \/**\n+     * Asserts that the given thread has the expected JVMTI state.\n+     *\/\n+    private static void check(Thread thread, int expected) {\n+        System.err.format(\"  expect state=0x%x (%s) ...%n\", expected, jvmtiStateToString(expected));\n+        int state = jvmtiState(thread);\n+        System.err.format(\"  thread state=0x%x (%s)%n\", state, jvmtiStateToString(state));\n+        assertEquals(expected, state);\n+    }\n+\n+    \/**\n+     * Waits indefinitely for the given thread to get to the target JVMTI state.\n+     *\/\n+    private static void await(Thread thread, int targetState) throws Exception {\n+        System.err.format(\"  await state=0x%x (%s) ...%n\", targetState, jvmtiStateToString(targetState));\n+        int state = jvmtiState(thread);\n+        System.err.format(\"  thread state=0x%x (%s)%n\", state, jvmtiStateToString(state));\n+        while (state != targetState) {\n+            assertTrue(thread.isAlive(), \"Thread has terminated\");\n+            Thread.sleep(20);\n+            state = jvmtiState(thread);\n+            System.err.format(\"  thread state=0x%x (%s)%n\", state, jvmtiStateToString(state));\n+        }\n+    }\n+\n+    private static final int JVMTI_THREAD_STATE_ALIVE = 0x0001;\n+    private static final int JVMTI_THREAD_STATE_TERMINATED = 0x0002;\n+    private static final int JVMTI_THREAD_STATE_RUNNABLE = 0x0004;\n+    private static final int JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER = 0x0400;\n+    private static final int JVMTI_THREAD_STATE_WAITING = 0x0080;\n+    private static final int JVMTI_THREAD_STATE_WAITING_INDEFINITELY = 0x0010;\n+    private static final int JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT = 0x0020;\n+    private static final int JVMTI_THREAD_STATE_SLEEPING = 0x0040;\n+    private static final int JVMTI_THREAD_STATE_IN_OBJECT_WAIT = 0x0100;\n+    private static final int JVMTI_THREAD_STATE_PARKED = 0x0200;\n+    private static final int JVMTI_THREAD_STATE_SUSPENDED = 0x100000;\n+    private static final int JVMTI_THREAD_STATE_INTERRUPTED = 0x200000;\n+    private static final int JVMTI_THREAD_STATE_IN_NATIVE = 0x400000;\n+\n+    private static native void init();\n+    private static native int jvmtiState(Thread thread);\n+\n+    private static String jvmtiStateToString(int state) {\n+        StringJoiner sj = new StringJoiner(\" | \");\n+        if ((state & JVMTI_THREAD_STATE_ALIVE) != 0)\n+            sj.add(\"JVMTI_THREAD_STATE_ALIVE\");\n+        if ((state & JVMTI_THREAD_STATE_TERMINATED) != 0)\n+            sj.add(\"JVMTI_THREAD_STATE_TERMINATED\");\n+        if ((state & JVMTI_THREAD_STATE_RUNNABLE) != 0)\n+            sj.add(\"JVMTI_THREAD_STATE_RUNNABLE\");\n+        if ((state & JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER) != 0)\n+            sj.add(\"JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER\");\n+        if ((state & JVMTI_THREAD_STATE_WAITING) != 0)\n+            sj.add(\"JVMTI_THREAD_STATE_WAITING\");\n+        if ((state & JVMTI_THREAD_STATE_WAITING_INDEFINITELY) != 0)\n+            sj.add(\"JVMTI_THREAD_STATE_WAITING_INDEFINITELY\");\n+        if ((state & JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT) != 0)\n+            sj.add(\"JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT\");\n+        if ((state & JVMTI_THREAD_STATE_IN_OBJECT_WAIT) != 0)\n+            sj.add(\"JVMTI_THREAD_STATE_IN_OBJECT_WAIT\");\n+        if ((state & JVMTI_THREAD_STATE_PARKED) != 0)\n+            sj.add(\"JVMTI_THREAD_STATE_PARKED\");\n+        if ((state & JVMTI_THREAD_STATE_SUSPENDED) != 0)\n+            sj.add(\"JVMTI_THREAD_STATE_SUSPENDED\");\n+        if ((state & JVMTI_THREAD_STATE_INTERRUPTED) != 0)\n+            sj.add(\"JVMTI_THREAD_STATE_INTERRUPTED\");\n+        if ((state & JVMTI_THREAD_STATE_IN_NATIVE) != 0)\n+            sj.add(\"JVMTI_THREAD_STATE_IN_NATIVE\");\n+        String s = sj.toString();\n+        return s.isEmpty() ? \"<empty>\" : s;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/GetThreadState\/GetThreadStateTest.java","additions":416,"deletions":0,"binary":false,"changes":416,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jni.h\"\n+#include \"jvmti.h\"\n+\n+static jvmtiEnv *jvmti;\n+\n+JNIEXPORT void JNICALL Java_GetThreadStateTest_init(JNIEnv *env, jclass clazz) {\n+    JavaVM* vm;\n+    jint res;\n+    res = (*env)->GetJavaVM(env, &vm);\n+    if (res != 0) {\n+        (*env)->FatalError(env, \"GetJavaVM failed\");\n+    } else {\n+        res = (*vm)->GetEnv(vm, (void**)&jvmti, JVMTI_VERSION);\n+        if (res != JNI_OK) {\n+            (*env)->FatalError(env, \"GetEnv failed\");\n+        }\n+    }\n+}\n+\n+JNIEXPORT jint JNICALL Java_GetThreadStateTest_jvmtiState(JNIEnv *env, jclass clazz, jobject thread) {\n+    jvmtiError err;\n+    jint state = 0;\n+    err = (*jvmti)->GetThreadState(jvmti, thread, &state);\n+    if (err != JVMTI_ERROR_NONE) {\n+        (*env)->FatalError(env, \"GetThreadState failed\");\n+    }\n+    return state;\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/GetThreadState\/libGetThreadStateTest.c","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -152,2 +152,2 @@\n-            await(ready1); \/\/ to guaranty state is not State.WAITING after await(mready) in test1()\n-            \/\/ wait for test1 threads to reach WAITING state in sleep()\n+            await(ready1); \/\/ to guarantee state is not State.TIMED_WAITING after await(mready) in test1()\n+            \/\/ wait for test1 threads to reach TIMED_WAITING state in sleep()\n@@ -157,1 +157,1 @@\n-                while (state != Thread.State.WAITING) {\n+                while (state != Thread.State.TIMED_WAITING) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/VThreadEventTest\/VThreadEventTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n-    private static final Executor DEFAULT_SCHEDULER = defaultScheduler();\n@@ -219,14 +218,0 @@\n-    \/**\n-     * Returns the default scheduler.\n-     *\/\n-    private static Executor defaultScheduler() {\n-        try {\n-            Field defaultScheduler = Class.forName(\"java.lang.VirtualThread\")\n-                    .getDeclaredField(\"DEFAULT_SCHEDULER\");\n-            defaultScheduler.setAccessible(true);\n-            return (Executor) defaultScheduler.get(null);\n-        } catch (Exception e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/CustomScheduler.java","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1714,2 +1714,6 @@\n-        while (thread.getState() != Thread.State.WAITING) {\n-            Thread.sleep(20);\n+        try {\n+            Thread.State state = awaitParked(thread);\n+            assertEquals(Thread.State.WAITING, state);\n+        } finally {\n+            LockSupport.unpark(thread);\n+            thread.join();\n@@ -1717,2 +1721,0 @@\n-        LockSupport.unpark(thread);\n-        thread.join();\n@@ -1722,1 +1724,1 @@\n-     * Test Thread::getState when thread is parked while holding a monitor.\n+     * Test Thread::getState when thread is timed parked.\n@@ -1726,0 +1728,16 @@\n+        var thread = Thread.ofVirtual().start(() -> LockSupport.parkNanos(Long.MAX_VALUE));\n+        try {\n+            Thread.State state = awaitParked(thread);\n+            assertEquals(Thread.State.TIMED_WAITING, state);\n+        } finally {\n+            LockSupport.unpark(thread);\n+            thread.join();\n+        }\n+    }\n+\n+    \/**\n+     * Test Thread::getState when thread is parked while holding a monitor.\n+     *\/\n+    @Test\n+    void testGetState6() throws Exception {\n+        var done = new AtomicBoolean();\n@@ -1728,1 +1746,3 @@\n-                LockSupport.park();\n+                while (!done.get()) {\n+                    LockSupport.park();\n+                }\n@@ -1731,2 +1751,7 @@\n-        while (thread.getState() != Thread.State.WAITING) {\n-            Thread.sleep(20);\n+        try {\n+            Thread.State state = awaitParked(thread);\n+            assertEquals(Thread.State.WAITING, state);\n+        } finally {\n+            done.set(true);\n+            LockSupport.unpark(thread);\n+            thread.join();\n@@ -1734,2 +1759,0 @@\n-        LockSupport.unpark(thread);\n-        thread.join();\n@@ -1739,1 +1762,1 @@\n-     * Test Thread::getState when thread is waiting for a monitor.\n+     * Test Thread::getState when thread is timed parked while holding a monitor.\n@@ -1742,1 +1765,24 @@\n-    void testGetState6() throws Exception {\n+    void testGetState7() throws Exception {\n+        var done = new AtomicBoolean();\n+        var thread = Thread.ofVirtual().start(() -> {\n+            synchronized (lock) {\n+                while (!done.get()) {\n+                    LockSupport.parkNanos(Long.MAX_VALUE);\n+                }\n+            }\n+        });\n+        try {\n+            Thread.State state = awaitParked(thread);\n+            assertEquals(Thread.State.TIMED_WAITING, state);\n+        } finally {\n+            done.set(true);\n+            LockSupport.unpark(thread);\n+            thread.join();\n+        }\n+    }\n+\n+    \/**\n+     * Test Thread::getState when thread is waiting to enter a monitor.\n+     *\/\n+    @Test\n+    void testGetState8() throws Exception {\n@@ -1748,3 +1794,1 @@\n-            while (thread.getState() != Thread.State.BLOCKED) {\n-                Thread.sleep(20);\n-            }\n+            awaitBlocked(thread);  \/\/ await BLOCKED state\n@@ -1759,1 +1803,1 @@\n-    void testGetState7() throws Exception {\n+    void testGetState9() throws Exception {\n@@ -1765,2 +1809,27 @@\n-        while (thread.getState() != Thread.State.WAITING) {\n-            Thread.sleep(20);\n+        try {\n+            Thread.State state = awaitParked(thread);\n+            assertEquals(Thread.State.WAITING, state);\n+        } finally {\n+            thread.interrupt();\n+            thread.join();\n+        }\n+    }\n+\n+    \/**\n+     * Test Thread::getState when thread is waiting in Object.wait(millis).\n+     *\/\n+    @Test\n+    void testGetState10() throws Exception {\n+        var thread = Thread.ofVirtual().start(() -> {\n+            synchronized (lock) {\n+                try {\n+                    lock.wait(Long.MAX_VALUE);\n+                } catch (InterruptedException e) { }\n+            }\n+        });\n+        try {\n+            Thread.State state = awaitParked(thread);\n+            assertEquals(Thread.State.TIMED_WAITING, state);\n+        } finally {\n+            thread.interrupt();\n+            thread.join();\n@@ -1768,2 +1837,0 @@\n-        thread.interrupt();\n-        thread.join();\n@@ -1776,1 +1843,1 @@\n-    void testGetState8() throws Exception {\n+    void testGetState11() throws Exception {\n@@ -1902,3 +1969,1 @@\n-            while (vthread.getState() != Thread.State.WAITING) {\n-                Thread.sleep(20);\n-            }\n+            awaitParked(vthread);\n@@ -1931,6 +1996,1 @@\n-\n-        \/\/ wait for thread to park\n-        while (thread.getState() != Thread.State.WAITING) {\n-            Thread.sleep(20);\n-        }\n-\n+        awaitParked(thread);\n@@ -1999,3 +2059,1 @@\n-            while (vthread.getState() != Thread.State.WAITING) {\n-                Thread.sleep(20);\n-            }\n+            awaitParked(vthread);\n@@ -2211,3 +2269,1 @@\n-        while (thread.getState() != Thread.State.WAITING) {\n-            Thread.sleep(10);\n-        }\n+        awaitParked(thread);\n@@ -2238,1 +2294,1 @@\n-    static void awaitParked(Thread thread) throws InterruptedException {\n+    static Thread.State awaitParked(Thread thread) throws InterruptedException {\n@@ -2245,0 +2301,1 @@\n+        return state;\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/ThreadAPI.java","additions":94,"deletions":37,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -54,1 +54,0 @@\n-        Thread.Builder.OfVirtual builder = Thread.ofVirtual();\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/ThreadBuilders.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Stress test parking and unparking\n+ * @requires vm.debug != true\n+ * @run main\/othervm ParkALot 500000\n+ *\/\n+\n+\/*\n+ * @test\n+ * @requires vm.debug == true\n+ * @run main\/othervm ParkALot 200000\n+ *\/\n+\n+import java.time.Instant;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.locks.LockSupport;\n+\n+public class ParkALot {\n+    private static final int ITERATIONS = 1_000_000;\n+\n+    public static void main(String[] args) {\n+        int iterations;\n+        if (args.length > 0) {\n+            iterations = Integer.parseInt(args[0]);\n+        } else {\n+            iterations = ITERATIONS;\n+        }\n+\n+        int maxThreads = Math.max(Runtime.getRuntime().availableProcessors() \/ 2, 1);\n+        for (int nthreads = 1; nthreads <= maxThreads; nthreads++) {\n+            System.out.format(\"%s %d threads ...%n\", Instant.now(), nthreads);\n+            ThreadFactory factory = Thread.ofPlatform().factory();\n+            try (var executor = Executors.newThreadPerTaskExecutor(factory)) {\n+                for (int i = 0; i < nthreads; i++) {\n+                    executor.submit(() -> parkALot(iterations));\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Creates a virtual thread that alternates between untimed and timed parking.\n+     * A platform thread spins unparking the virtual thread.\n+     *\/\n+    private static void parkALot(int iterations) {\n+        Thread vthread = Thread.ofVirtual().start(() -> {\n+            int i = 0;\n+            boolean timed = false;\n+            while (i < iterations) {\n+                if (timed) {\n+                    LockSupport.parkNanos(Long.MAX_VALUE);\n+                    timed = false;\n+                } else {\n+                    LockSupport.park();\n+                    timed = true;\n+                }\n+                i++;\n+            }\n+        });\n+\n+        Thread.State state;\n+        while ((state = vthread.getState()) != Thread.State.TERMINATED) {\n+            if (state == Thread.State.WAITING || state == Thread.State.TIMED_WAITING) {\n+                LockSupport.unpark(vthread);\n+            } else {\n+                Thread.onSpinWait();\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/ParkALot.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"}]}