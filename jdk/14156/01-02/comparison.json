{"files":[{"patch":"@@ -844,8 +844,5 @@\n-  if (bol->_test._test != BoolTest::lt) {\n-    return false;\n-  }\n-  if (if_success_proj->is_IfFalse()) {\n-    assert(!iff->is_RangeCheck(),\n-           \"can only be IfNode because RangeCheckNodes always have trap on false projection\");\n-    \/\/ We have a trap on the true projection (let's assume offset = 0 and scale = 1, but it would also apply if not):\n-    \/\/ if (iv <u limit) {\n+  if (bol->_test._test != BoolTest::lt || if_success_proj->is_IfFalse()) {\n+    \/\/ We don't have the required range check pattern:\n+    \/\/ if (scale*iv + offset <u limit) {\n+    \/\/\n+    \/\/ } else {\n@@ -855,4 +852,2 @@\n-    \/\/ This needs to be flipped in order to have the trap on the false projection:\n-    \/\/ if (iv >=u limit) {\n-    \/\/\n-    \/\/ } else {\n+    \/\/ Having the trap on the true projection:\n+    \/\/ if (scale*iv + offset <u limit) {\n@@ -862,2 +857,2 @@\n-    \/\/ However, this does not match the range check pattern of a RangeCheckNode:\n-    \/\/ if (iv <u limit) {\n+    \/\/ is not correct. We would need to flip the test to get the expected \"trap on false path\" pattern:\n+    \/\/ if (scale*iv + offset >=u limit) {\n@@ -869,3 +864,3 @@\n-    \/\/ We therefore cannot treat this IfNode as range check anymore because the Hoisted Range Check Predicate could\n-    \/\/ succeed at runtime (i.e. true for the value of iv in the first loop iteration and true for the value of iv in the\n-    \/\/ last loop iteration) while the check to be hoisted could fail in other loop iterations.\n+    \/\/ If we create a Hoisted Range Check Predicate for this wrong pattern, it could succeed at runtime (i.e. true\n+    \/\/ for the value of \"scale*iv + offset\" in the first loop iteration and true for the value of \"scale*iv + offset\"\n+    \/\/ in the last loop iteration) while the check to be hoisted could fail in other loop iterations.\n@@ -875,2 +870,2 @@\n-    \/\/ iv_1 = iv in first loop iteration = -1\n-    \/\/ iv_last = iv in the last loop iteration = 999\n+    \/\/ init = \"scale*iv + offset\" in first loop iteration = 1*-1 + 0 = -1\n+    \/\/ last = \"scale*iv + offset\" in the last loop iteration = 1*999 + 0 = 999\n@@ -880,1 +875,1 @@\n-    \/\/ iv_1 >=u limit && iv_last >=u limit  <=>\n+    \/\/ init >=u limit && last >=u limit  <=>\n@@ -899,2 +894,4 @@\n-      \/\/ Allow predication on positive values that aren't LoadRanges. This allows optimization of loops where the\n-      \/\/ length of the array is a known value and doesn't need to be loaded back from the array.\n+      \/\/ Allow predication on positive values that aren't LoadRanges.\n+      \/\/ This allows optimization of loops where the length of the\n+      \/\/ array is a known value and doesn't need to be loaded back\n+      \/\/ from the array.\n@@ -974,4 +971,2 @@\n-BoolNode* PhaseIdealLoop::rc_predicate(IdealLoopTree *loop, Node* ctrl,\n-                                       int scale, Node* offset,\n-                                       Node* init, Node* limit, jint stride,\n-                                       Node* range, bool upper, bool &overflow, bool negate) {\n+BoolNode* PhaseIdealLoop::rc_predicate(IdealLoopTree* loop, Node* ctrl, int scale, Node* offset, Node* init,\n+                                       Node* limit, jint stride, Node* range, bool upper, bool& overflow) {\n@@ -1103,1 +1098,1 @@\n-  BoolNode* bol = new BoolNode(cmp, negate ? BoolTest::ge : BoolTest::lt);\n+  BoolNode* bol = new BoolNode(cmp, BoolTest::lt);\n@@ -1406,0 +1401,1 @@\n+    assert(if_success_proj->is_IfTrue(), \"trap must be on false projection for a range check\");\n@@ -1440,3 +1436,0 @@\n-    \/\/ Negate test if necessary (Parse Predicates always have IfTrue as success projection and IfFalse as uncommon trap)\n-    const bool negate = (if_success_proj->is_IfFalse());\n-\n@@ -1444,1 +1437,1 @@\n-    BoolNode* lower_bound_bol = rc_predicate(loop, ctrl, scale, offset, init, limit, stride, rng, false, overflow, negate);\n+    BoolNode* lower_bound_bol = rc_predicate(loop, ctrl, scale, offset, init, limit, stride, rng, false, overflow);\n@@ -1451,1 +1444,1 @@\n-    if (TraceLoopPredicate) tty->print_cr(\"lower bound check if: %s %d \", negate ? \" negated\" : \"\", lower_bound_iff->_idx);\n+    if (TraceLoopPredicate) tty->print_cr(\"lower bound check if: %d\", lower_bound_iff->_idx);\n@@ -1454,1 +1447,2 @@\n-    BoolNode* upper_bound_bol = rc_predicate(loop, lower_bound_proj, scale, offset, init, limit, stride, rng, true, overflow, negate);\n+    BoolNode* upper_bound_bol = rc_predicate(loop, lower_bound_proj, scale, offset, init, limit, stride, rng, true,\n+                                             overflow);\n@@ -1461,1 +1455,1 @@\n-    if (TraceLoopPredicate) tty->print_cr(\"upper bound check if: %s %d \", negate ? \" negated\" : \"\", lower_bound_iff->_idx);\n+    if (TraceLoopPredicate) tty->print_cr(\"upper bound check if: %d\", lower_bound_iff->_idx);\n@@ -1485,1 +1479,1 @@\n-  dominated_by(new_predicate_proj, iff, if_success_proj->_con != new_predicate_proj->_con );\n+  dominated_by(new_predicate_proj, iff, if_success_proj->_con != new_predicate_proj->_con);\n@@ -1502,1 +1496,2 @@\n-  BoolNode* bol = rc_predicate(loop, upper_bound_proj, scale, offset, opaque_init, limit, stride, rng, (stride > 0) != (scale > 0), overflow, negate);\n+  BoolNode* bol = rc_predicate(loop, upper_bound_proj, scale, offset, opaque_init, limit, stride, rng,\n+                               (stride > 0) != (scale > 0), overflow);\n@@ -1524,1 +1519,2 @@\n-  bol = rc_predicate(loop, new_proj, scale, offset, max_value, limit, stride, rng, (stride > 0) != (scale > 0), overflow, negate);\n+  bol = rc_predicate(loop, new_proj, scale, offset, max_value, limit, stride, rng, (stride > 0) != (scale > 0),\n+                     overflow);\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":33,"deletions":37,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -2861,1 +2861,1 @@\n-                               limit, (stride_con > 0) != (scale_con > 0), overflow, false);\n+                               limit, (stride_con > 0) != (scale_con > 0), overflow);\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1365,5 +1365,2 @@\n-  BoolNode* rc_predicate(IdealLoopTree *loop, Node* ctrl,\n-                         int scale, Node* offset,\n-                         Node* init, Node* limit, jint stride,\n-                         Node* range, bool upper, bool &overflow,\n-                         bool negate);\n+  BoolNode* rc_predicate(IdealLoopTree* loop, Node* ctrl, int scale, Node* offset, Node* init, Node* limit,\n+                         jint stride, Node* range, bool upper, bool& overflow);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- * @run main\/othervm -Xcomp -XX:CompileCommand=compileonly,compiler.predicates.TestHoistedPredicateForNonRangeCheck::test\n+ * @run main\/othervm -Xcomp -XX:CompileCommand=compileonly,compiler.predicates.TestHoistedPredicateForNonRangeCheck::test*\n@@ -33,1 +33,1 @@\n- * @run main\/othervm -Xcomp -XX:CompileCommand=compileonly,compiler.predicates.TestHoistedPredicateForNonRangeCheck::test\n+ * @run main\/othervm -Xcomp -XX:CompileCommand=compileonly,compiler.predicates.TestHoistedPredicateForNonRangeCheck::test*\n@@ -68,0 +68,9 @@\n+\n+            for (int i = 0; i < 2000; i++) {\n+                iFld = -100;\n+                testRangeCheckNode();\n+            }\n+            iFld = -1;\n+            iFld2 = 0;\n+            testRangeCheckNode();\n+            Asserts.assertEQ(iFld2, 36, \"wrong value\");\n@@ -118,0 +127,22 @@\n+    static void testRangeCheckNode() {\n+        int array[] = new int[34];\n+        \/\/ Hoisted Range Check Predicate with flipped bool because trap is on success proj and no trap on false proj due\n+        \/\/ to catching exception:\n+        \/\/ iFld >=u 34 && iFld+36 >=u 34\n+        \/\/ This is always false for first 2000 iterations where, initially, iFld = -100\n+        \/\/ It is still true in the last iteration where, initially, iFld = -1. But suddenly, in the second iteration,\n+        \/\/ where iFld = 0, we would take the true projection for the first time - but we removed that branch when\n+        \/\/ creating the Hoisted Range Check Predicate. We therefore run into the same problem as with test(): We either\n+        \/\/ halt due to Assertion Predicates catching this case or we have a wrong execution (iFld2 never updated).\n+        for (int i = 0; i < 37; i++) {\n+            try {\n+                array[iFld] = 34; \/\/ Normal RangeCheckNode\n+                iFld2++;\n+                Math.ceil(34); \/\/ Never taken and unloaded -> trap\n+            } catch (Exception e) {\n+                \/\/ False Proj of RangeCheckNod\n+                iFld++;\n+            }\n+        }\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/predicates\/TestHoistedPredicateForNonRangeCheck.java","additions":33,"deletions":2,"binary":false,"changes":35,"status":"modified"}]}