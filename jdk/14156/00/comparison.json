{"files":[{"patch":"@@ -856,5 +856,7 @@\n-    if (tinteger == nullptr || tinteger->empty() || tinteger->lo_as_long() < 0) {\n-      \/\/ Allow predication on positive values that aren't LoadRanges.\n-      \/\/ This allows optimization of loops where the length of the\n-      \/\/ array is a known value and doesn't need to be loaded back\n-      \/\/ from the array.\n+    if (!iff->is_RangeCheck() || tinteger == nullptr || tinteger->empty() || tinteger->lo_as_long() < 0) {\n+      \/\/ Allow predication on positive values that aren't LoadRanges. This allows optimization of loops where the\n+      \/\/ length of the array is a known value and doesn't need to be loaded back from the array.\n+      \/\/ This only works for actual RangeCheckNodes where we have a guarantee that if the range check of the first loop\n+      \/\/ iteration (initial value of induction variable) and the last loop iteration (last value of induction variable)\n+      \/\/ succeed, then, by implication, the range checks for the other loop iterations will also succeed. This is not\n+      \/\/ a guarantee for a normal IfNode here.\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,125 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8307683\n+ * @library \/test\/lib \/\n+ * @requires vm.compiler2.enabled\n+ * @summary Tests that IfNode is not wrongly chosen as range check by Loop Predication leading to crashes and wrong executions.\n+ * @run main\/othervm -Xcomp -XX:CompileCommand=compileonly,compiler.predicates.TestHoistedPredicateForNonRangeCheck::test\n+ *                   compiler.predicates.TestHoistedPredicateForNonRangeCheck\n+ * @run main\/othervm -Xcomp -XX:CompileCommand=compileonly,compiler.predicates.TestHoistedPredicateForNonRangeCheck::test\n+ *                   -XX:LoopMaxUnroll=0 compiler.predicates.TestHoistedPredicateForNonRangeCheck\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8307683\n+ * @library \/test\/lib \/\n+ * @summary Tests that IfNode is not wrongly chosen as range check by Loop Predication leading to crashes and wrong executions.\n+ * @run main\/othervm -Xbatch compiler.predicates.TestHoistedPredicateForNonRangeCheck calendar\n+ *\/\n+\n+package compiler.predicates;\n+\n+import jdk.test.lib.Asserts;\n+\n+import java.util.Calendar;\n+import java.util.Date;\n+\n+\n+public class TestHoistedPredicateForNonRangeCheck {\n+    static int iFld, iFld2;\n+\n+    public static void main(String[] args) {\n+        if (args.length == 0) {\n+            Integer.compareUnsigned(34, 34); \/\/ Ensure Integer class is loaded and we do not emit a trap inside test() for it.\n+\n+            for (int i = 0; i < 2; i++) {\n+                iFld = 0;\n+                iFld2 = 0;\n+                test();\n+                Asserts.assertEQ(iFld, 901, \"wrong value\");\n+                Asserts.assertEQ(iFld2, 100, \"wrong value\");\n+            }\n+        } else {\n+            boolean flag = false;\n+            for (int i = 0; i < 10000; i++) {\n+                testCalendar1();\n+                testCalendar2(flag);\n+            }\n+        }\n+    }\n+\n+    public static void test() {\n+        \/\/ (Inverted) Hoisted Predicate checks lower and upper bound: -1 < 0 && 1000 >= 100 -> always true and the predicate is removed\n+        \/\/ while template assertion predicates are kept. When splitting this loop further, we insert an assertion predicate which\n+        \/\/ fails for i = 0 and we halt. When not splitting this loop (with LoopMaxUnroll=0), we have a wrong execution due\n+        \/\/ to never executing iFld2++ (we removed the check and the branch with the trap).\n+        for (int i = -1; i < 1000; i++) {\n+            if (Integer.compareUnsigned(i, 100) < 0) { \/\/ Loop Predication creates a Hoisted Range Check Predicate due to trap with Float.isNan().\n+                iFld2++;\n+                Float.isNaN(34); \/\/ Float class is unloaded with -Xcomp -> inserts trap\n+            } else {\n+                iFld++;\n+            }\n+        }\n+    }\n+\n+    \/\/ Reported in JDK-8307683\n+    static void testCalendar1() {\n+        Calendar c = Calendar.getInstance();\n+        c.setLenient(false);\n+        c.set(Calendar.HOUR_OF_DAY, 0);\n+        c.set(Calendar.MINUTE, 0);\n+        c.getTime();\n+    }\n+\n+    \/\/ Reported in JDK-8307978\n+    static void testCalendar2(boolean flag) {\n+\n+        flag = !flag;\n+        Calendar timespan = removeTime(new Date(), flag);\n+        timespan.getTime();\n+    }\n+\n+    static Calendar removeTime(Date date, boolean flag) {\n+        Calendar calendar = Calendar.getInstance();\n+        if (flag) {\n+            calendar.setLenient(false);\n+        }\n+        calendar.setTime(date);\n+        calendar = removeTime(calendar);\n+        return calendar;\n+    }\n+\n+    static Calendar removeTime(Calendar calendar) {\n+        calendar.set(Calendar.HOUR_OF_DAY, 0);\n+        calendar.set(Calendar.MINUTE, 0);\n+        calendar.set(Calendar.SECOND, 0);\n+        calendar.set(Calendar.MILLISECOND, 0);\n+        return calendar;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/predicates\/TestHoistedPredicateForNonRangeCheck.java","additions":125,"deletions":0,"binary":false,"changes":125,"status":"added"}]}