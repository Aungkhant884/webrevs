{"files":[{"patch":"@@ -834,1 +834,1 @@\n-bool IdealLoopTree::is_range_check_if(IfNode *iff, PhaseIdealLoop *phase, BasicType bt, Node *iv, Node *&range,\n+bool IdealLoopTree::is_range_check_if(IfProjNode* if_success_proj, PhaseIdealLoop *phase, BasicType bt, Node *iv, Node *&range,\n@@ -836,0 +836,1 @@\n+  IfNode* iff = if_success_proj->in(0)->as_If();\n@@ -846,0 +847,41 @@\n+  if (if_success_proj->is_IfFalse()) {\n+    assert(!iff->is_RangeCheck(),\n+           \"can only be IfNode because RangeCheckNodes always have trap on false projection\");\n+    \/\/ We have a trap on the true projection (let's assume offset = 0 and scale = 1, but it would also apply if not):\n+    \/\/ if (iv <u limit) {\n+    \/\/   trap();\n+    \/\/ }\n+    \/\/\n+    \/\/ This needs to be flipped in order to have the trap on the false projection:\n+    \/\/ if (iv >=u limit) {\n+    \/\/\n+    \/\/ } else {\n+    \/\/   trap();\n+    \/\/ }\n+    \/\/\n+    \/\/ However, this does not match the range check pattern of a RangeCheckNode:\n+    \/\/ if (iv <u limit) {\n+    \/\/\n+    \/\/ } else {\n+    \/\/   trap();\n+    \/\/ }\n+    \/\/\n+    \/\/ We therefore cannot treat this IfNode as range check anymore because the Hoisted Range Check Predicate could\n+    \/\/ succeed at runtime (i.e. true for the value of iv in the first loop iteration and true for the value of iv in the\n+    \/\/ last loop iteration) while the check to be hoisted could fail in other loop iterations.\n+    \/\/\n+    \/\/ Example:\n+    \/\/ Loop: \"for (int i = -1; i < 1000; i++)\"\n+    \/\/ iv_1 = iv in first loop iteration = -1\n+    \/\/ iv_last = iv in the last loop iteration = 999\n+    \/\/ limit = 100\n+    \/\/\n+    \/\/ Hoisted Range Check Predicate is always true:\n+    \/\/ iv_1 >=u limit && iv_last >=u limit  <=>\n+    \/\/ -1 >=u 100 && 999 >= u 100\n+    \/\/\n+    \/\/ But for 0 <= x < 100: x >=u 100 is false.\n+    \/\/ We would wrongly skip the branch with the trap() and possibly miss to execute some other statements inside that\n+    \/\/ trap() branch.\n+    return false;\n+  }\n@@ -856,1 +898,1 @@\n-    if (!iff->is_RangeCheck() || tinteger == nullptr || tinteger->empty() || tinteger->lo_as_long() < 0) {\n+    if (tinteger == nullptr || tinteger->empty() || tinteger->lo_as_long() < 0) {\n@@ -859,4 +901,0 @@\n-      \/\/ This only works for actual RangeCheckNodes where we have a guarantee that if the range check of the first loop\n-      \/\/ iteration (initial value of induction variable) and the last loop iteration (last value of induction variable)\n-      \/\/ succeed, then, by implication, the range checks for the other loop iterations will also succeed. This is not\n-      \/\/ a guarantee for a normal IfNode here.\n@@ -876,1 +914,1 @@\n-bool IdealLoopTree::is_range_check_if(IfNode *iff, PhaseIdealLoop *phase, Invariance& invar DEBUG_ONLY(COMMA ProjNode *predicate_proj)) const {\n+bool IdealLoopTree::is_range_check_if(IfProjNode* if_success_proj, PhaseIdealLoop *phase, Invariance& invar DEBUG_ONLY(COMMA ProjNode *predicate_proj)) const {\n@@ -883,1 +921,1 @@\n-  if (!is_range_check_if(iff, phase, T_INT, iv, range, offset, scale)) {\n+  if (!is_range_check_if(if_success_proj, phase, T_INT, iv, range, offset, scale)) {\n@@ -1328,1 +1366,1 @@\n-bool PhaseIdealLoop::loop_predication_impl_helper(IdealLoopTree* loop, IfProjNode* if_proj,\n+bool PhaseIdealLoop::loop_predication_impl_helper(IdealLoopTree* loop, IfProjNode* if_success_proj,\n@@ -1333,1 +1371,1 @@\n-  IfNode*   iff  = if_proj->in(0)->as_If();\n+  IfNode*   iff  = if_success_proj->in(0)->as_If();\n@@ -1349,1 +1387,1 @@\n-    if (if_proj->is_IfFalse()) {\n+    if (if_success_proj->is_IfFalse()) {\n@@ -1366,1 +1404,1 @@\n-  } else if (cl != nullptr && loop->is_range_check_if(iff, this, invar DEBUG_ONLY(COMMA parse_predicate_proj))) {\n+  } else if (cl != nullptr && loop->is_range_check_if(if_success_proj, this, invar DEBUG_ONLY(COMMA parse_predicate_proj))) {\n@@ -1403,1 +1441,1 @@\n-    const bool negate = (if_proj->is_IfFalse());\n+    const bool negate = (if_success_proj->is_IfFalse());\n@@ -1428,1 +1466,1 @@\n-    new_predicate_proj = add_template_assertion_predicate(iff, loop, if_proj, parse_predicate_proj, upper_bound_proj, scale,\n+    new_predicate_proj = add_template_assertion_predicate(iff, loop, if_success_proj, parse_predicate_proj, upper_bound_proj, scale,\n@@ -1444,1 +1482,1 @@\n-  invar.map_ctrl(if_proj, new_predicate_proj); \/\/ so that invariance test can be appropriate\n+  invar.map_ctrl(if_success_proj, new_predicate_proj); \/\/ so that invariance test can be appropriate\n@@ -1447,1 +1485,1 @@\n-  dominated_by(new_predicate_proj, iff, if_proj->_con != new_predicate_proj->_con );\n+  dominated_by(new_predicate_proj, iff, if_success_proj->_con != new_predicate_proj->_con );\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":54,"deletions":16,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -1092,1 +1092,2 @@\n-      CallStaticJavaNode* call = c->as_IfProj()->is_uncommon_trap_if_pattern(Deoptimization::Reason_none);\n+      IfProjNode* if_proj = c->as_IfProj();\n+      CallStaticJavaNode* call = if_proj->is_uncommon_trap_if_pattern(Deoptimization::Reason_none);\n@@ -1097,2 +1098,1 @@\n-        RangeCheckNode* rc = c->in(0)->as_RangeCheck();\n-        if (loop->is_range_check_if(rc, this, T_LONG, phi, range, offset, scale) &&\n+        if (loop->is_range_check_if(if_proj, this, T_LONG, phi, range, offset, scale) &&\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -736,2 +736,2 @@\n-  bool is_range_check_if(IfNode *iff, PhaseIdealLoop *phase, Invariance& invar DEBUG_ONLY(COMMA ProjNode *predicate_proj)) const;\n-  bool is_range_check_if(IfNode* iff, PhaseIdealLoop* phase, BasicType bt, Node* iv, Node*& range, Node*& offset,\n+  bool is_range_check_if(IfProjNode* if_success_proj, PhaseIdealLoop* phase, Invariance& invar DEBUG_ONLY(COMMA ProjNode* predicate_proj)) const;\n+  bool is_range_check_if(IfProjNode* if_success_proj, PhaseIdealLoop* phase, BasicType bt, Node* iv, Node*& range, Node*& offset,\n@@ -1373,1 +1373,1 @@\n-  bool loop_predication_impl_helper(IdealLoopTree* loop, IfProjNode* if_proj,\n+  bool loop_predication_impl_helper(IdealLoopTree* loop, IfProjNode* if_success_proj,\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+    static int[] iArr = new int[100];\n@@ -64,2 +65,2 @@\n-                Asserts.assertEQ(iFld, 901, \"wrong value\");\n-                Asserts.assertEQ(iFld2, 100, \"wrong value\");\n+                Asserts.assertEQ(iFld, 3604, \"wrong value\");\n+                Asserts.assertEQ(iFld2, 400, \"wrong value\");\n@@ -77,4 +78,0 @@\n-        \/\/ (Inverted) Hoisted Predicate checks lower and upper bound: -1 < 0 && 1000 >= 100 -> always true and the predicate is removed\n-        \/\/ while template assertion predicates are kept. When splitting this loop further, we insert an assertion predicate which\n-        \/\/ fails for i = 0 and we halt. When not splitting this loop (with LoopMaxUnroll=0), we have a wrong execution due\n-        \/\/ to never executing iFld2++ (we removed the check and the branch with the trap).\n@@ -82,1 +79,7 @@\n-            if (Integer.compareUnsigned(i, 100) < 0) { \/\/ Loop Predication creates a Hoisted Range Check Predicate due to trap with Float.isNan().\n+            \/\/ We hoist this check and insert a Hoisted Predicate for the lower and upper bound:\n+            \/\/ -1 >=u 100 && 1000 >= u 100 -> always true and the predicates are removed.\n+            \/\/ Template Assertion Predicates, however, are kept. When splitting this loop further, we insert an Assertion\n+            \/\/ Predicate which fails for i = 0 and we halt.\n+            \/\/ When not splitting this loop (with LoopMaxUnroll=0), we have a wrong execution due to never executing\n+            \/\/ iFld2++ (we remove the check and the branch with the trap when creating the Hoisted Predicates).\n+            if (Integer.compareUnsigned(i, 100) < 0) {\n@@ -88,0 +91,24 @@\n+\n+            \/\/ Same but flipped condition and moved trap to other branch - result is the same.\n+            if (Integer.compareUnsigned(i, 100) >= 0) { \/\/ Loop Predication creates a Hoisted Range Check Predicate due to trap with Float.isNan().\n+                iFld++;\n+            } else {\n+                iFld2++;\n+                Float.isNaN(34); \/\/ Float class is unloaded with -Xcomp -> inserts trap\n+            }\n+\n+            \/\/ Same but with LoadRangeNode.\n+            if (Integer.compareUnsigned(i, iArr.length) >= 0) { \/\/ Loop Predication creates a Hoisted Range Check Predicate due to trap with Float.isNan().\n+                iFld++;\n+            } else {\n+                iFld2++;\n+                Float.isNaN(34); \/\/ Float class is unloaded with -Xcomp -> inserts trap\n+            }\n+\n+            \/\/ Same but with LoadRangeNode and flipped condition and moved trap to other branch - result is the same.\n+            if (Integer.compareUnsigned(i, iArr.length) >= 0) { \/\/ Loop Predication creates a Hoisted Range Check Predicate due to trap with Float.isNan().\n+                iFld++;\n+            } else {\n+                iFld2++;\n+                Float.isNaN(34); \/\/ Float class is unloaded with -Xcomp -> inserts trap\n+            }\n@@ -102,1 +129,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/predicates\/TestHoistedPredicateForNonRangeCheck.java","additions":34,"deletions":8,"binary":false,"changes":42,"status":"modified"}]}