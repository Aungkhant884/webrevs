{"files":[{"patch":"@@ -834,1 +834,1 @@\n-bool IdealLoopTree::is_range_check_if(IfNode *iff, PhaseIdealLoop *phase, BasicType bt, Node *iv, Node *&range,\n+bool IdealLoopTree::is_range_check_if(IfProjNode* if_success_proj, PhaseIdealLoop *phase, BasicType bt, Node *iv, Node *&range,\n@@ -836,0 +836,1 @@\n+  IfNode* iff = if_success_proj->in(0)->as_If();\n@@ -846,0 +847,41 @@\n+  if (if_success_proj->is_IfFalse()) {\n+    assert(!iff->is_RangeCheck(),\n+           \"can only be IfNode because RangeCheckNodes always have trap on false projection\");\n+    \/\/ We have a trap on the true projection (let's assume offset = 0 and scale = 1, but it would also apply if not):\n+    \/\/ if (iv <u limit) {\n+    \/\/   trap();\n+    \/\/ }\n+    \/\/\n+    \/\/ This needs to be flipped in order to have the trap on the false projection:\n+    \/\/ if (iv >=u limit) {\n+    \/\/\n+    \/\/ } else {\n+    \/\/   trap();\n+    \/\/ }\n+    \/\/\n+    \/\/ However, this does not match the range check pattern of a RangeCheckNode:\n+    \/\/ if (iv <u limit) {\n+    \/\/\n+    \/\/ } else {\n+    \/\/   trap();\n+    \/\/ }\n+    \/\/\n+    \/\/ We therefore cannot treat this IfNode as range check anymore because the Hoisted Range Check Predicate could\n+    \/\/ succeed at runtime (i.e. true for the value of iv in the first loop iteration and true for the value of iv in the\n+    \/\/ last loop iteration) while the check to be hoisted could fail in other loop iterations.\n+    \/\/\n+    \/\/ Example:\n+    \/\/ Loop: \"for (int i = -1; i < 1000; i++)\"\n+    \/\/ iv_1 = iv in first loop iteration = -1\n+    \/\/ iv_last = iv in the last loop iteration = 999\n+    \/\/ limit = 100\n+    \/\/\n+    \/\/ Hoisted Range Check Predicate is always true:\n+    \/\/ iv_1 >=u limit && iv_last >=u limit  <=>\n+    \/\/ -1 >=u 100 && 999 >= u 100\n+    \/\/\n+    \/\/ But for 0 <= x < 100: x >=u 100 is false.\n+    \/\/ We would wrongly skip the branch with the trap() and possibly miss to execute some other statements inside that\n+    \/\/ trap() branch.\n+    return false;\n+  }\n@@ -857,4 +899,2 @@\n-      \/\/ Allow predication on positive values that aren't LoadRanges.\n-      \/\/ This allows optimization of loops where the length of the\n-      \/\/ array is a known value and doesn't need to be loaded back\n-      \/\/ from the array.\n+      \/\/ Allow predication on positive values that aren't LoadRanges. This allows optimization of loops where the\n+      \/\/ length of the array is a known value and doesn't need to be loaded back from the array.\n@@ -874,1 +914,1 @@\n-bool IdealLoopTree::is_range_check_if(IfNode *iff, PhaseIdealLoop *phase, Invariance& invar DEBUG_ONLY(COMMA ProjNode *predicate_proj)) const {\n+bool IdealLoopTree::is_range_check_if(IfProjNode* if_success_proj, PhaseIdealLoop *phase, Invariance& invar DEBUG_ONLY(COMMA ProjNode *predicate_proj)) const {\n@@ -881,1 +921,1 @@\n-  if (!is_range_check_if(iff, phase, T_INT, iv, range, offset, scale)) {\n+  if (!is_range_check_if(if_success_proj, phase, T_INT, iv, range, offset, scale)) {\n@@ -1326,1 +1366,1 @@\n-bool PhaseIdealLoop::loop_predication_impl_helper(IdealLoopTree* loop, IfProjNode* if_proj,\n+bool PhaseIdealLoop::loop_predication_impl_helper(IdealLoopTree* loop, IfProjNode* if_success_proj,\n@@ -1331,1 +1371,1 @@\n-  IfNode*   iff  = if_proj->in(0)->as_If();\n+  IfNode*   iff  = if_success_proj->in(0)->as_If();\n@@ -1347,1 +1387,1 @@\n-    if (if_proj->is_IfFalse()) {\n+    if (if_success_proj->is_IfFalse()) {\n@@ -1364,1 +1404,1 @@\n-  } else if (cl != nullptr && loop->is_range_check_if(iff, this, invar DEBUG_ONLY(COMMA parse_predicate_proj))) {\n+  } else if (cl != nullptr && loop->is_range_check_if(if_success_proj, this, invar DEBUG_ONLY(COMMA parse_predicate_proj))) {\n@@ -1401,1 +1441,1 @@\n-    const bool negate = (if_proj->is_IfFalse());\n+    const bool negate = (if_success_proj->is_IfFalse());\n@@ -1426,1 +1466,1 @@\n-    new_predicate_proj = add_template_assertion_predicate(iff, loop, if_proj, parse_predicate_proj, upper_bound_proj, scale,\n+    new_predicate_proj = add_template_assertion_predicate(iff, loop, if_success_proj, parse_predicate_proj, upper_bound_proj, scale,\n@@ -1442,1 +1482,1 @@\n-  invar.map_ctrl(if_proj, new_predicate_proj); \/\/ so that invariance test can be appropriate\n+  invar.map_ctrl(if_success_proj, new_predicate_proj); \/\/ so that invariance test can be appropriate\n@@ -1445,1 +1485,1 @@\n-  dominated_by(new_predicate_proj, iff, if_proj->_con != new_predicate_proj->_con );\n+  dominated_by(new_predicate_proj, iff, if_success_proj->_con != new_predicate_proj->_con );\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":55,"deletions":15,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -1092,1 +1092,2 @@\n-      CallStaticJavaNode* call = c->as_IfProj()->is_uncommon_trap_if_pattern(Deoptimization::Reason_none);\n+      IfProjNode* if_proj = c->as_IfProj();\n+      CallStaticJavaNode* call = if_proj->is_uncommon_trap_if_pattern(Deoptimization::Reason_none);\n@@ -1097,2 +1098,1 @@\n-        RangeCheckNode* rc = c->in(0)->as_RangeCheck();\n-        if (loop->is_range_check_if(rc, this, T_LONG, phi, range, offset, scale) &&\n+        if (loop->is_range_check_if(if_proj, this, T_LONG, phi, range, offset, scale) &&\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -736,2 +736,2 @@\n-  bool is_range_check_if(IfNode *iff, PhaseIdealLoop *phase, Invariance& invar DEBUG_ONLY(COMMA ProjNode *predicate_proj)) const;\n-  bool is_range_check_if(IfNode* iff, PhaseIdealLoop* phase, BasicType bt, Node* iv, Node*& range, Node*& offset,\n+  bool is_range_check_if(IfProjNode* if_success_proj, PhaseIdealLoop* phase, Invariance& invar DEBUG_ONLY(COMMA ProjNode* predicate_proj)) const;\n+  bool is_range_check_if(IfProjNode* if_success_proj, PhaseIdealLoop* phase, BasicType bt, Node* iv, Node*& range, Node*& offset,\n@@ -1373,1 +1373,1 @@\n-  bool loop_predication_impl_helper(IdealLoopTree* loop, IfProjNode* if_proj,\n+  bool loop_predication_impl_helper(IdealLoopTree* loop, IfProjNode* if_success_proj,\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,151 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8307683\n+ * @library \/test\/lib \/\n+ * @requires vm.compiler2.enabled\n+ * @summary Tests that IfNode is not wrongly chosen as range check by Loop Predication leading to crashes and wrong executions.\n+ * @run main\/othervm -Xcomp -XX:CompileCommand=compileonly,compiler.predicates.TestHoistedPredicateForNonRangeCheck::test\n+ *                   compiler.predicates.TestHoistedPredicateForNonRangeCheck\n+ * @run main\/othervm -Xcomp -XX:CompileCommand=compileonly,compiler.predicates.TestHoistedPredicateForNonRangeCheck::test\n+ *                   -XX:LoopMaxUnroll=0 compiler.predicates.TestHoistedPredicateForNonRangeCheck\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8307683\n+ * @library \/test\/lib \/\n+ * @summary Tests that IfNode is not wrongly chosen as range check by Loop Predication leading to crashes and wrong executions.\n+ * @run main\/othervm -Xbatch compiler.predicates.TestHoistedPredicateForNonRangeCheck calendar\n+ *\/\n+\n+package compiler.predicates;\n+\n+import jdk.test.lib.Asserts;\n+\n+import java.util.Calendar;\n+import java.util.Date;\n+\n+\n+public class TestHoistedPredicateForNonRangeCheck {\n+    static int iFld, iFld2;\n+    static int[] iArr = new int[100];\n+\n+    public static void main(String[] args) {\n+        if (args.length == 0) {\n+            Integer.compareUnsigned(34, 34); \/\/ Ensure Integer class is loaded and we do not emit a trap inside test() for it.\n+\n+            for (int i = 0; i < 2; i++) {\n+                iFld = 0;\n+                iFld2 = 0;\n+                test();\n+                Asserts.assertEQ(iFld, 3604, \"wrong value\");\n+                Asserts.assertEQ(iFld2, 400, \"wrong value\");\n+            }\n+        } else {\n+            boolean flag = false;\n+            for (int i = 0; i < 10000; i++) {\n+                testCalendar1();\n+                testCalendar2(flag);\n+            }\n+        }\n+    }\n+\n+    public static void test() {\n+        for (int i = -1; i < 1000; i++) {\n+            \/\/ We hoist this check and insert a Hoisted Predicate for the lower and upper bound:\n+            \/\/ -1 >=u 100 && 1000 >= u 100 -> always true and the predicates are removed.\n+            \/\/ Template Assertion Predicates, however, are kept. When splitting this loop further, we insert an Assertion\n+            \/\/ Predicate which fails for i = 0 and we halt.\n+            \/\/ When not splitting this loop (with LoopMaxUnroll=0), we have a wrong execution due to never executing\n+            \/\/ iFld2++ (we remove the check and the branch with the trap when creating the Hoisted Predicates).\n+            if (Integer.compareUnsigned(i, 100) < 0) {\n+                iFld2++;\n+                Float.isNaN(34); \/\/ Float class is unloaded with -Xcomp -> inserts trap\n+            } else {\n+                iFld++;\n+            }\n+\n+            \/\/ Same but flipped condition and moved trap to other branch - result is the same.\n+            if (Integer.compareUnsigned(i, 100) >= 0) { \/\/ Loop Predication creates a Hoisted Range Check Predicate due to trap with Float.isNan().\n+                iFld++;\n+            } else {\n+                iFld2++;\n+                Float.isNaN(34); \/\/ Float class is unloaded with -Xcomp -> inserts trap\n+            }\n+\n+            \/\/ Same but with LoadRangeNode.\n+            if (Integer.compareUnsigned(i, iArr.length) >= 0) { \/\/ Loop Predication creates a Hoisted Range Check Predicate due to trap with Float.isNan().\n+                iFld++;\n+            } else {\n+                iFld2++;\n+                Float.isNaN(34); \/\/ Float class is unloaded with -Xcomp -> inserts trap\n+            }\n+\n+            \/\/ Same but with LoadRangeNode and flipped condition and moved trap to other branch - result is the same.\n+            if (Integer.compareUnsigned(i, iArr.length) >= 0) { \/\/ Loop Predication creates a Hoisted Range Check Predicate due to trap with Float.isNan().\n+                iFld++;\n+            } else {\n+                iFld2++;\n+                Float.isNaN(34); \/\/ Float class is unloaded with -Xcomp -> inserts trap\n+            }\n+        }\n+    }\n+\n+    \/\/ Reported in JDK-8307683\n+    static void testCalendar1() {\n+        Calendar c = Calendar.getInstance();\n+        c.setLenient(false);\n+        c.set(Calendar.HOUR_OF_DAY, 0);\n+        c.set(Calendar.MINUTE, 0);\n+        c.getTime();\n+    }\n+\n+    \/\/ Reported in JDK-8307978\n+    static void testCalendar2(boolean flag) {\n+        flag = !flag;\n+        Calendar timespan = removeTime(new Date(), flag);\n+        timespan.getTime();\n+    }\n+\n+    static Calendar removeTime(Date date, boolean flag) {\n+        Calendar calendar = Calendar.getInstance();\n+        if (flag) {\n+            calendar.setLenient(false);\n+        }\n+        calendar.setTime(date);\n+        calendar = removeTime(calendar);\n+        return calendar;\n+    }\n+\n+    static Calendar removeTime(Calendar calendar) {\n+        calendar.set(Calendar.HOUR_OF_DAY, 0);\n+        calendar.set(Calendar.MINUTE, 0);\n+        calendar.set(Calendar.SECOND, 0);\n+        calendar.set(Calendar.MILLISECOND, 0);\n+        return calendar;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/predicates\/TestHoistedPredicateForNonRangeCheck.java","additions":151,"deletions":0,"binary":false,"changes":151,"status":"added"}]}