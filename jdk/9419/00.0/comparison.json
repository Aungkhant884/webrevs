{"files":[{"patch":"@@ -726,1 +726,1 @@\n-  \/\/ Jump to the entry point of the i2c stub.\n+  \/\/ Jump to the entry point of the c2i stub.\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1016,1 +1016,3 @@\n-                                 int& stack_slots) {\n+                                 int& stack_slots,\n+                                 int& interpreted_entry_offset,\n+                                 int& compiled_entry_offset) {\n@@ -1018,2 +1020,1 @@\n-  Address resolve(SharedRuntime::get_resolve_static_call_stub(),\n-                  relocInfo::static_call_type);\n+  Address resolve(SharedRuntime::get_resolve_static_call_stub(), relocInfo::static_call_type);\n@@ -1021,1 +1022,0 @@\n-  stack_slots = 2; \/\/ will be overwritten\n@@ -1026,1 +1026,3 @@\n-  __ enter();\n+  \/\/ i2i entry used at interp_only_mode only\n+  interpreted_entry_offset = __ pc() - start;\n+  {\n@@ -1028,1 +1030,24 @@\n-  OopMap* map = continuation_enter_setup(masm, stack_slots);\n+#ifdef ASSERT\n+    Label is_interp_only;\n+    __ ldrw(rscratch1, Address(rthread, JavaThread::interp_only_mode_offset()));\n+    __ cbnzw(rscratch1, is_interp_only);\n+    __ stop(\"enterSpecial interpreter entry called when not in interp_only_mode\");\n+    __ bind(is_interp_only);\n+#endif\n+\n+    \/\/ Read interpreter arguments into registers (this is an ad-hoc i2c adapter)\n+    __ ldr(c_rarg1, Address(esp, Interpreter::stackElementSize*2));\n+    __ ldr(c_rarg2, Address(esp, Interpreter::stackElementSize*1));\n+    __ ldr(c_rarg3, Address(esp, Interpreter::stackElementSize*0));\n+    __ push_cont_fastpath(rthread);\n+\n+    __ enter();\n+    stack_slots = 2; \/\/ will be adjusted in setup\n+    OopMap* map = continuation_enter_setup(masm, stack_slots);\n+    \/\/ The frame is complete here, but we only record it for the compiled entry, so the frame would appear unsafe,\n+    \/\/ but that's okay because at the very worst we'll miss an async sample, but we're in interp_only_mode anyway.\n+\n+    fill_continuation_entry(masm);\n+\n+    __ cmp(c_rarg2, (u1)0);\n+    __ br(Assembler::NE, call_thaw);\n@@ -1030,2 +1055,20 @@\n-  \/\/ Frame is now completed as far as size and linkage.\n-  frame_complete =__ pc() - start;\n+    address mark = __ pc();\n+    __ trampoline_call1(resolve, NULL, false);\n+\n+    oop_maps->add_gc_map(__ pc() - start, map);\n+    __ post_call_nop();\n+\n+    __ b(exit);\n+\n+    CodeBuffer* cbuf = masm->code_section()->outer();\n+    CompiledStaticCall::emit_to_interp_stub(*cbuf, mark);\n+  }\n+\n+  \/\/ compiled entry\n+  __ align(CodeEntryAlignment);\n+  compiled_entry_offset = __ pc() - start;\n+\n+  __ enter();\n+  stack_slots = 2; \/\/ will be adjusted in setup\n+  OopMap* map = continuation_enter_setup(masm, stack_slots);\n+  frame_complete = __ pc() - start;\n@@ -1039,1 +1082,0 @@\n-\n@@ -1082,1 +1124,1 @@\n-  address stub = CompiledStaticCall::emit_to_interp_stub(*cbuf, mark);\n+  CompiledStaticCall::emit_to_interp_stub(*cbuf, mark);\n@@ -1172,1 +1214,1 @@\n-    int vep_offset = ((intptr_t)__ pc()) - start;\n+    int vep_offset = 0;\n@@ -1177,0 +1219,1 @@\n+    int interpreted_entry_offset = -1;\n@@ -1184,1 +1227,3 @@\n-                         stack_slots);\n+                         stack_slots,\n+                         interpreted_entry_offset,\n+                         vep_offset);\n@@ -1196,1 +1241,1 @@\n-    ContinuationEntry::set_enter_code(nm);\n+    ContinuationEntry::set_enter_code(nm, interpreted_entry_offset);\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":58,"deletions":13,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -1279,1 +1279,3 @@\n-                                 int& stack_slots) {\n+                                 int& stack_slots,\n+                                 int& interpreted_entry_offset,\n+                                 int& compiled_entry_offset) {\n@@ -1301,0 +1303,3 @@\n+  AddressLiteral resolve(SharedRuntime::get_resolve_static_call_stub(),\n+                         relocInfo::static_call_type);\n+\n@@ -1303,0 +1308,57 @@\n+  Label L_thaw, L_exit;\n+\n+  \/\/ i2i entry used at interp_only_mode only\n+  interpreted_entry_offset = __ pc() - start;\n+  {\n+#ifdef ASSERT\n+    Label is_interp_only;\n+    __ cmpb(Address(r15_thread, JavaThread::interp_only_mode_offset()), 0);\n+    __ jcc(Assembler::notEqual, is_interp_only);\n+    __ stop(\"enterSpecial interpreter entry called when not in interp_only_mode\");\n+    __ bind(is_interp_only);\n+#endif\n+\n+    __ pop(rax); \/\/ return address\n+    \/\/ Read interpreter arguments into registers (this is an ad-hoc i2c adapter)\n+    __ movptr(c_rarg1, Address(rsp, Interpreter::stackElementSize*2));\n+    __ movl(c_rarg2,   Address(rsp, Interpreter::stackElementSize*1));\n+    __ movl(c_rarg3,   Address(rsp, Interpreter::stackElementSize*0));\n+    __ andptr(rsp, -16); \/\/ Ensure compiled code always sees stack at proper alignment\n+    __ push(rax); \/\/ return address\n+    __ push_cont_fastpath();\n+\n+    __ enter();\n+\n+    stack_slots = 2; \/\/ will be adjusted in setup\n+    OopMap* map = continuation_enter_setup(masm, stack_slots);\n+    \/\/ The frame is complete here, but we only record it for the compiled entry, so the frame would appear unsafe,\n+    \/\/ but that's okay because at the very worst we'll miss an async sample, but we're in interp_only_mode anyway.\n+\n+    __ verify_oop(reg_cont_obj);\n+\n+    fill_continuation_entry(masm, reg_cont_obj, reg_is_virtual);\n+\n+    \/\/ If continuation, call to thaw. Otherwise, resolve the call and exit.\n+    __ testptr(reg_is_cont, reg_is_cont);\n+    __ jcc(Assembler::notZero, L_thaw);\n+\n+    \/\/ --- Resolve path\n+\n+    \/\/ Make sure the call is patchable\n+    __ align(BytesPerWord, __ offset() + NativeCall::displacement_offset);\n+    \/\/ Emit stub for static call\n+    CodeBuffer* cbuf = masm->code_section()->outer();\n+    address stub = CompiledStaticCall::emit_to_interp_stub(*cbuf, __ pc());\n+    if (stub == nullptr) {\n+      fatal(\"CodeCache is full at gen_continuation_enter\");\n+    }\n+    __ call(resolve);\n+    oop_maps->add_gc_map(__ pc() - start, map);\n+    __ post_call_nop();\n+\n+    __ jmp(L_exit);\n+  }\n+\n+  \/\/ compiled entry\n+  __ align(CodeEntryAlignment);\n+  compiled_entry_offset = __ pc() - start;\n@@ -1315,2 +1377,0 @@\n-  Label L_thaw, L_exit;\n-\n@@ -1337,2 +1397,0 @@\n-  AddressLiteral resolve(SharedRuntime::get_resolve_static_call_stub(),\n-                         relocInfo::static_call_type);\n@@ -1477,1 +1535,1 @@\n-    int vep_offset = ((intptr_t)__ pc()) - start;\n+    int vep_offset = 0;\n@@ -1482,0 +1540,1 @@\n+    int interpreted_entry_offset = -1;\n@@ -1487,1 +1546,3 @@\n-                         stack_slots);\n+                         stack_slots,\n+                         interpreted_entry_offset,\n+                         vep_offset);\n@@ -1499,1 +1560,1 @@\n-    ContinuationEntry::set_enter_code(nm);\n+    ContinuationEntry::set_enter_code(nm, interpreted_entry_offset);\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":69,"deletions":8,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"code\/compiledIC.hpp\"\n@@ -37,0 +38,2 @@\n+CompiledMethod* ContinuationEntry::_enter_special = nullptr;\n+int ContinuationEntry::_interpreted_entry_offset = 0;\n@@ -38,1 +41,1 @@\n-void ContinuationEntry::set_enter_code(CompiledMethod* cm) {\n+void ContinuationEntry::set_enter_code(CompiledMethod* cm, int interpreted_entry_offset) {\n@@ -41,0 +44,20 @@\n+\n+  _enter_special = cm;\n+  _interpreted_entry_offset = interpreted_entry_offset;\n+  assert(_enter_special->code_contains(compiled_entry()),    \"entry not in enterSpecial\");\n+  assert(_enter_special->code_contains(interpreted_entry()), \"entry not in enterSpecial\");\n+  assert(interpreted_entry() < compiled_entry(), \"unexpected code layout\");\n+}\n+\n+address ContinuationEntry::compiled_entry() {\n+  return _enter_special->verified_entry_point();\n+}\n+\n+address ContinuationEntry::interpreted_entry() {\n+  return _enter_special->code_begin() + _interpreted_entry_offset;\n+}\n+\n+bool ContinuationEntry::is_interpreted_call(address call_address) {\n+  assert(_enter_special->code_contains(call_address), \"call not in enterSpecial\");\n+  assert(call_address >= interpreted_entry(), \"unexpected location\");\n+  return call_address < compiled_entry();\n","filename":"src\/hotspot\/share\/runtime\/continuationEntry.cpp","additions":24,"deletions":1,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -56,1 +56,2 @@\n-  static void set_enter_code(CompiledMethod* nm); \/\/ friend SharedRuntime::generate_native_wrapper\n+  static void set_enter_code(CompiledMethod* cm, int interpreted_entry_offset);\n+  static bool is_interpreted_call(address call_address);\n@@ -60,0 +61,2 @@\n+  static CompiledMethod* _enter_special;\n+  static int _interpreted_entry_offset;\n@@ -93,0 +96,5 @@\n+  static address compiled_entry();\n+  static address interpreted_entry();\n+\n+  static CompiledMethod* enter_special() { return _enter_special; }\n+\n","filename":"src\/hotspot\/share\/runtime\/continuationEntry.hpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1346,0 +1346,3 @@\n+        if (is_nmethod && caller_nm->method()->is_continuation_enter_intrinsic()) {\n+          ssc->compute_entry_for_continuation_entry(callee_method, static_call_info);\n+        }\n@@ -1560,0 +1563,1 @@\n+  bool enter_special = false;\n@@ -1563,0 +1567,9 @@\n+\n+    if (current->is_interp_only_mode()) {\n+      RegisterMap reg_map(current, false);\n+      frame stub_frame = current->last_frame();\n+      assert(stub_frame.is_runtime_frame(), \"must be a runtimeStub\");\n+      frame caller = stub_frame.sender(&reg_map);\n+      enter_special = caller.cb() != NULL && caller.cb()->is_compiled()\n+        && caller.cb()->as_compiled_method()->method()->is_continuation_enter_intrinsic();\n+    }\n@@ -1564,0 +1577,12 @@\n+\n+  if (current->is_interp_only_mode() && enter_special) {\n+    \/\/ enterSpecial is compiled and calls this method to resolve the call to Continuation::enter\n+    \/\/ but in interp_only_mode we need to go to the interpreted entry\n+    \/\/ The c2i won't patch in this mode -- see fixup_callers_callsite\n+    \/\/\n+    \/\/ This should probably be done in all cases, not just enterSpecial (see JDK-8218403),\n+    \/\/ but that's part of a larger fix, and the situation is worse for enterSpecial, as it has no\n+    \/\/ interpreted version.\n+    return callee_method->get_c2i_entry();\n+  }\n+\n@@ -1994,0 +2019,3 @@\n+  assert(!JavaThread::current()->is_interp_only_mode() || !nm->method()->is_continuation_enter_intrinsic()\n+    || ContinuationEntry::is_interpreted_call(return_pc), \"interp_only_mode but not in enterSpecial interpreted entry\");\n+\n@@ -2030,0 +2058,7 @@\n+      if (nm->method()->is_continuation_enter_intrinsic()) {\n+        assert(ContinuationEntry::is_interpreted_call(call->instruction_address()) == JavaThread::current()->is_interp_only_mode(),\n+          \"mode: %d\", JavaThread::current()->is_interp_only_mode());\n+        if (ContinuationEntry::is_interpreted_call(call->instruction_address())) {\n+          return;\n+        }\n+      }\n@@ -3059,1 +3094,1 @@\n-        buffer.initialize_stubs_size(64);\n+        buffer.initialize_stubs_size(128);\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":36,"deletions":1,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -4379,0 +4379,87 @@\n+    void checkSwitchCaseLabelDominated(List<JCCase> cases) {\n+        List<JCCaseLabel> caseLabels = List.nil();\n+        for (List<JCCase> l = cases; l.nonEmpty(); l = l.tail) {\n+            JCCase c = l.head;\n+            for (JCCaseLabel label : c.labels) {\n+                if (label.hasTag(DEFAULTCASELABEL) || TreeInfo.isNullCaseLabel(label)) {\n+                    continue;\n+                }\n+                Type currentType = labelType(label);\n+                for (JCCaseLabel testCaseLabel : caseLabels) {\n+                    Type testType = labelType(testCaseLabel);\n+                    if (types.isSubtype(currentType, testType) &&\n+                        !currentType.hasTag(ERROR) && !testType.hasTag(ERROR)) {\n+                        \/\/the current label is potentially dominated by the existing (test) label, check:\n+                        boolean dominated = false;\n+                        if (label instanceof JCConstantCaseLabel) {\n+                            dominated |= !(testCaseLabel instanceof JCConstantCaseLabel);\n+                        } else if (label instanceof JCPatternCaseLabel patternCL &&\n+                                   testCaseLabel instanceof JCPatternCaseLabel testPatternCaseLabel &&\n+                                   TreeInfo.unguardedCaseLabel(testCaseLabel)) {\n+                            dominated = patternDominated(testPatternCaseLabel.pat,\n+                                                         patternCL.pat);\n+                        }\n+                        if (dominated) {\n+                            log.error(label.pos(), Errors.PatternDominated);\n+                        }\n+                    }\n+                }\n+                caseLabels = caseLabels.prepend(label);\n+            }\n+        }\n+    }\n+        \/\/where:\n+        private Type labelType(JCCaseLabel label) {\n+            return types.erasure(switch (label.getTag()) {\n+                case PATTERNCASELABEL -> ((JCPatternCaseLabel) label).pat.type;\n+                case CONSTANTCASELABEL -> types.boxedTypeOrType(((JCConstantCaseLabel) label).expr.type);\n+                default -> throw Assert.error(\"Unexpected tree kind: \" + label.getTag());\n+            });\n+        }\n+        private boolean patternDominated(JCPattern existingPattern, JCPattern currentPattern) {\n+            Type existingPatternType = types.erasure(existingPattern.type);\n+            Type currentPatternType = types.erasure(currentPattern.type);\n+            if (existingPatternType.isPrimitive() ^ currentPatternType.isPrimitive()) {\n+                return false;\n+            }\n+            if (existingPatternType.isPrimitive()) {\n+                return types.isSameType(existingPatternType, currentPatternType);\n+            } else {\n+                if (!types.isSubtype(currentPatternType, existingPatternType)) {\n+                    return false;\n+                }\n+            }\n+            while (existingPattern instanceof JCParenthesizedPattern parenthesized) {\n+                existingPattern = parenthesized.pattern;\n+            }\n+            while (currentPattern instanceof JCParenthesizedPattern parenthesized) {\n+                currentPattern = parenthesized.pattern;\n+            }\n+            if (currentPattern instanceof JCBindingPattern) {\n+                return existingPattern instanceof JCBindingPattern;\n+            } else if (currentPattern instanceof JCRecordPattern currentRecordPattern) {\n+                if (existingPattern instanceof JCBindingPattern) {\n+                    return true;\n+                } else if (existingPattern instanceof JCRecordPattern existingRecordPattern) {\n+                    List<JCPattern> existingNested = existingRecordPattern.nested;\n+                    List<JCPattern> currentNested = currentRecordPattern.nested;\n+                    if (existingNested.size() != currentNested.size()) {\n+                        return false;\n+                    }\n+                    while (existingNested.nonEmpty()) {\n+                        if (!patternDominated(existingNested.head, currentNested.head)) {\n+                            return false;\n+                        }\n+                        existingNested = existingNested.tail;\n+                        currentNested = currentNested.tail;\n+                    }\n+                    return true;\n+                } else {\n+                    Assert.error(\"Unknown pattern: \" + existingPattern.getTag());\n+                }\n+            } else {\n+                Assert.error(\"Unknown pattern: \" + currentPattern.getTag());\n+            }\n+            return false;\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -41,2 +41,0 @@\n-\n-serviceability\/jvmti\/vthread\/ContStackDepthTest\/ContStackDepthTest.java 8288949 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList-Xcomp.txt","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -756,0 +756,1 @@\n+jdk\/jfr\/event\/runtime\/TestActiveSettingEvent.java               8287832 generic-all\n","filename":"test\/jdk\/ProblemList.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}