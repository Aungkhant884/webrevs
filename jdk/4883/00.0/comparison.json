{"files":[{"patch":"@@ -299,0 +299,12 @@\n+    if (bt == T_OBJECT) {\n+      \/\/ BarrierSetC2::clone sets the offsets via BarrierSetC2::arraycopy_payload_base_offset\n+      \/\/ which 8-byte aligns them to allow for word size copies. Make sure the offsets point\n+      \/\/ to the first element in the array when cloning object arrays. Otherwise, load\n+      \/\/ barriers are applied to parts of the header.\n+      assert(src_offset == dest_offset, \"should be equal\");\n+      assert((src_offset->get_long() == arrayOopDesc::base_offset_in_bytes(T_OBJECT) && UseCompressedClassPointers) ||\n+             (src_offset->get_long() == arrayOopDesc::length_offset_in_bytes() && !UseCompressedClassPointers),\n+             \"unexpected offset for object array clone\");\n+      src_offset = phase->longcon(arrayOopDesc::base_offset_in_bytes(T_OBJECT));\n+      dest_offset = src_offset;\n+    }\n","filename":"src\/hotspot\/share\/gc\/z\/c2\/zBarrierSetC2.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2125,1 +2125,26 @@\n-\/\/Some convenience methods to deal with objects from java\n+static volatile int _emulated_lock = 0;\n+\n+WB_ENTRY(void, WB_LockAndBlock(JNIEnv* env, jobject wb, jboolean suspender))\n+  JavaThread* self = JavaThread::current();\n+\n+  {\n+    \/\/ Before trying to acquire the lock transition into a safepoint safe state.\n+    \/\/ Otherwise if either suspender or suspendee blocks for a safepoint\n+    \/\/ in ~ThreadBlockInVM the other one could loop forever trying to acquire\n+    \/\/ the lock without allowing the safepoint to progress.\n+    ThreadBlockInVM tbivm(self);\n+\n+    \/\/ We will deadlock here if we are 'suspender' and 'suspendee'\n+    \/\/ suspended in ~ThreadBlockInVM. This verifies we only suspend\n+    \/\/ at the right place.\n+    while (Atomic::cmpxchg(&_emulated_lock, 0, 1) != 0) {}\n+    assert(_emulated_lock == 1, \"Must be locked\");\n+\n+    \/\/ Sleep much longer in suspendee to force situation where\n+    \/\/ 'suspender' is waiting above to acquire lock.\n+    os::naked_short_sleep(suspender ? 1 : 10);\n+  }\n+  Atomic::store(&_emulated_lock, 0);\n+WB_END\n+\n+\/\/ Some convenience methods to deal with objects from java\n@@ -2616,0 +2641,1 @@\n+  {CC\"lockAndBlock\", CC\"(Z)V\",                        (void*)&WB_LockAndBlock},\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":27,"deletions":1,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -80,0 +80,1 @@\n+  bool is_suspend()                { return _handshake_cl->is_suspend(); }\n@@ -379,0 +380,1 @@\n+      \/\/ Will not suspend here.\n@@ -428,1 +430,5 @@\n-HandshakeOperation* HandshakeState::get_op_for_self() {\n+static bool no_suspend_filter(HandshakeOperation* op) {\n+  return !op->is_suspend();\n+}\n+\n+HandshakeOperation* HandshakeState::get_op_for_self(bool allow_suspend) {\n@@ -431,2 +437,6 @@\n-  return _queue.peek();\n-};\n+  if (allow_suspend) {\n+    return _queue.peek();\n+  } else {\n+    return _queue.peek(no_suspend_filter);\n+  }\n+}\n@@ -444,0 +454,5 @@\n+bool HandshakeState::has_a_non_suspend_operation() {\n+  MutexLocker ml(&_lock, Mutex::_no_safepoint_check_flag);\n+  return _queue.contains(no_suspend_filter);\n+}\n+\n@@ -457,1 +472,1 @@\n-bool HandshakeState::process_by_self() {\n+bool HandshakeState::process_by_self(bool allow_suspend) {\n@@ -462,0 +477,1 @@\n+\n@@ -463,8 +479,4 @@\n-  {\n-    \/\/ Handshakes cannot safely safepoint.\n-    \/\/ The exception to this rule is the asynchronous suspension handshake.\n-    \/\/ It by-passes the NSV by manually doing the transition.\n-    NoSafepointVerifier nsv;\n-    return process_self_inner();\n-  }\n-}\n+  \/\/ Handshakes cannot safely safepoint.\n+  \/\/ The exception to this rule is the asynchronous suspension handshake.\n+  \/\/ It by-passes the NSV by manually doing the transition.\n+  NoSafepointVerifier nsv;\n@@ -472,1 +484,0 @@\n-bool HandshakeState::process_self_inner() {\n@@ -475,1 +486,2 @@\n-    HandshakeOperation* op = get_op_for_self();\n+\n+    HandshakeOperation* op = get_op_for_self(allow_suspend);\n@@ -624,0 +636,1 @@\n+  virtual bool is_suspend() { return true; }\n@@ -670,0 +683,1 @@\n+  JavaThread* self = JavaThread::current();\n@@ -672,0 +686,6 @@\n+  if (_handshakee == self) {\n+    \/\/ If target is the current thread we need to call this to do the\n+    \/\/ actual suspend since Handshake::execute() above only installed\n+    \/\/ the asynchronous handshake.\n+    SafepointMechanism::process_if_requested(self);\n+  }\n","filename":"src\/hotspot\/share\/runtime\/handshake.cpp","additions":34,"deletions":14,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -246,0 +246,1 @@\n+  bool _allow_suspend;\n@@ -247,1 +248,2 @@\n-  ThreadBlockInVMPreprocess(JavaThread* thread, PRE_PROC& pr) : ThreadStateTransition(thread), _pr(pr) {\n+  ThreadBlockInVMPreprocess(JavaThread* thread, PRE_PROC& pr, bool allow_suspend = true)\n+    : ThreadStateTransition(thread), _pr(pr), _allow_suspend(allow_suspend) {\n@@ -260,1 +262,1 @@\n-    if (SafepointMechanism::should_process(_thread)) {\n+    if (SafepointMechanism::should_process(_thread, _allow_suspend)) {\n@@ -262,1 +264,1 @@\n-      SafepointMechanism::process_if_requested(_thread);\n+      SafepointMechanism::process_if_requested(_thread, _allow_suspend);\n@@ -292,1 +294,1 @@\n-    : _ifmr(in_flight_mutex_addr), _tbivmpp(thread, _ifmr) {}\n+    : _ifmr(in_flight_mutex_addr), _tbivmpp(thread, _ifmr, \/* allow_suspend= *\/ false) {}\n","filename":"src\/hotspot\/share\/runtime\/interfaceSupport.inline.hpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -611,0 +611,2 @@\n+  public native void lockAndBlock(boolean suspender);\n+\n","filename":"test\/lib\/sun\/hotspot\/WhiteBox.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}