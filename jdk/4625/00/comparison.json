{"files":[{"patch":"@@ -65,0 +65,1 @@\n+#include \"runtime\/vframe.inline.hpp\"\n@@ -1150,1 +1151,4 @@\n-bool matches(jobjectArray methods, Method* method, JVMCIEnv* JVMCIENV) {\n+\/*\n+ * Used by matches() to convert a ResolvedJavaMethod[] to an array of Method*.\n+ *\/\n+GrowableArray<Method*>* init_resolved_methods(jobjectArray methods, JVMCIEnv* JVMCIENV) {\n@@ -1152,1 +1156,1 @@\n-\n+  GrowableArray<Method*>* resolved_methods = new GrowableArray<Method*>(methods_oop->length());\n@@ -1155,1 +1159,26 @@\n-    if ((resolved->klass() == HotSpotJVMCI::HotSpotResolvedJavaMethodImpl::klass()) && HotSpotJVMCI::asMethod(JVMCIENV, resolved) == method) {\n+    Method* resolved_method = NULL;\n+    if (resolved->klass() == HotSpotJVMCI::HotSpotResolvedJavaMethodImpl::klass()) {\n+      resolved_method = HotSpotJVMCI::asMethod(JVMCIENV, resolved);\n+    }\n+    resolved_methods->append(resolved_method);\n+  }\n+  return resolved_methods;\n+}\n+\n+\/*\n+ * Used by c2v_iterateFrames to check if `method` matches one of the ResolvedJavaMethods in the `methods` array.\n+ * The ResolvedJavaMethod[] array is converted to a Method* array that is then cached in the resolved_methods_ref in\/out parameter.\n+ * In case of a match, the matching ResolvedJavaMethod is returned in matched_jvmci_method_ref.\n+ *\/\n+bool matches(jobjectArray methods, Method* method, GrowableArray<Method*>** resolved_methods_ref, Handle* matched_jvmci_method_ref, Thread* THREAD, JVMCIEnv* JVMCIENV) {\n+  GrowableArray<Method*>* resolved_methods = *resolved_methods_ref;\n+  if (resolved_methods == NULL) {\n+    resolved_methods = init_resolved_methods(methods, JVMCIENV);\n+    *resolved_methods_ref = resolved_methods;\n+  }\n+  assert(method != NULL, \"method should not be NULL\");\n+  assert(resolved_methods->length() == ((objArrayOop) JNIHandles::resolve(methods))->length(), \"arrays must have the same length\");\n+  for (int i = 0; i < resolved_methods->length(); i++) {\n+    Method* m = resolved_methods->at(i);\n+    if (m == method) {\n+      *matched_jvmci_method_ref = Handle(THREAD, ((objArrayOop) JNIHandles::resolve(methods))->obj_at(i));\n@@ -1162,1 +1191,4 @@\n-void call_interface(JavaValue* result, Klass* spec_klass, Symbol* name, Symbol* signature, JavaCallArguments* args, TRAPS) {\n+\/*\n+ * Resolves an interface call to a concrete method handle.\n+ *\/\n+methodHandle resolve_interface_call(Klass* spec_klass, Symbol* name, Symbol* signature, JavaCallArguments* args, TRAPS) {\n@@ -1168,1 +1200,1 @@\n-          callinfo, receiver, recvrKlass, link_info, true, CHECK);\n+          callinfo, receiver, recvrKlass, link_info, true, CHECK_(methodHandle()));\n@@ -1171,0 +1203,25 @@\n+  return method;\n+}\n+\n+\/*\n+ * Used by c2v_iterateFrames to make a new vframeStream at the given compiled frame id (stack pointer) and vframe id.\n+ *\/\n+void resync_vframestream_to_compiled_frame(vframeStream& vfst, intptr_t* stack_pointer, int vframe_id, JavaThread* thread, TRAPS) {\n+  vfst = vframeStream(thread);\n+  while (vfst.frame_id() != stack_pointer && !vfst.at_end()) {\n+    vfst.next();\n+  }\n+  if (vfst.frame_id() != stack_pointer) {\n+    THROW_MSG(vmSymbols::java_lang_IllegalStateException(), \"stack frame not found after deopt\")\n+  }\n+  if (vfst.is_interpreted_frame()) {\n+    THROW_MSG(vmSymbols::java_lang_IllegalStateException(), \"compiled stack frame expected\")\n+  }\n+  while (vfst.vframe_id() != vframe_id) {\n+    if (vfst.at_end()) {\n+      THROW_MSG(vmSymbols::java_lang_IllegalStateException(), \"vframe not found after deopt\")\n+    }\n+    vfst.next();\n+    assert(!vfst.is_interpreted_frame(), \"Wrong frame type\");\n+  }\n+}\n@@ -1172,2 +1229,15 @@\n-  \/\/ Invoke the method\n-  JavaCalls::call(result, method, args, CHECK);\n+\/*\n+ * Used by c2v_iterateFrames. Returns an array of any unallocated scope objects or NULL if none.\n+ *\/\n+GrowableArray<ScopeValue*>* get_unallocated_objects_or_null(GrowableArray<ScopeValue*>* scope_objects) {\n+  GrowableArray<ScopeValue*>* unallocated = NULL;\n+  for (int i = 0; i < scope_objects->length(); i++) {\n+    ObjectValue* sv = (ObjectValue*) scope_objects->at(i);\n+    if (sv->value().is_null()) {\n+      if (unallocated == NULL) {\n+        unallocated = new GrowableArray<ScopeValue*>(scope_objects->length());\n+      }\n+      unallocated->append(sv);\n+    }\n+  }\n+  return unallocated;\n@@ -1186,1 +1256,0 @@\n-  Handle frame_reference = HotSpotJVMCI::HotSpotStackFrameReference::klass()->allocate_instance_handle(CHECK_NULL);\n@@ -1188,1 +1257,1 @@\n-  StackFrameStream fst(thread, true \/* update *\/, true \/* process_frames *\/);\n+  vframeStream vfst(thread);\n@@ -1190,0 +1259,2 @@\n+  methodHandle visitor_method;\n+  GrowableArray<Method*>* resolved_methods = NULL;\n@@ -1191,5 +1262,1 @@\n-  int frame_number = 0;\n-  vframe* vf = vframe::new_vframe(fst, thread);\n-\n-  while (true) {\n-    \/\/ look for the given method\n+  while (!vfst.at_end()) { \/\/ frame loop\n@@ -1197,27 +1264,47 @@\n-    while (true) {\n-      StackValueCollection* locals = NULL;\n-      if (vf->is_compiled_frame()) {\n-        \/\/ compiled method frame\n-        compiledVFrame* cvf = compiledVFrame::cast(vf);\n-        if (methods == NULL || matches(methods, cvf->method(), JVMCIENV)) {\n-          if (initialSkip > 0) {\n-            initialSkip--;\n-          } else {\n-            ScopeDesc* scope = cvf->scope();\n-            \/\/ native wrappers do not have a scope\n-            if (scope != NULL && scope->objects() != NULL) {\n-              GrowableArray<ScopeValue*>* objects;\n-              if (!realloc_called) {\n-                objects = scope->objects();\n-              } else {\n-                \/\/ some object might already have been re-allocated, only reallocate the non-allocated ones\n-                objects = new GrowableArray<ScopeValue*>(scope->objects()->length());\n-                for (int i = 0; i < scope->objects()->length(); i++) {\n-                  ObjectValue* sv = (ObjectValue*) scope->objects()->at(i);\n-                  if (sv->value().is_null()) {\n-                    objects->append(sv);\n-                  }\n-                }\n-              }\n-              bool realloc_failures = Deoptimization::realloc_objects(thread, fst.current(), fst.register_map(), objects, CHECK_NULL);\n-              Deoptimization::reassign_fields(fst.current(), fst.register_map(), objects, realloc_failures, false);\n+    intptr_t* frame_id = vfst.frame_id();\n+\n+    \/\/ Previous compiledVFrame of this frame; use with at_scope() to reuse scope object pool.\n+    compiledVFrame* prev_cvf = NULL;\n+\n+    for (; !vfst.at_end() && vfst.frame_id() == frame_id; vfst.next()) { \/\/ vframe loop\n+      int frame_number = 0;\n+      Method *method = vfst.method();\n+      int bci = vfst.bci();\n+\n+      Handle matched_jvmci_method;\n+      if (methods == NULL || matches(methods, method, &resolved_methods, &matched_jvmci_method, THREAD, JVMCIENV)) {\n+        if (initialSkip > 0) {\n+          initialSkip--;\n+          continue;\n+        }\n+        javaVFrame* vf;\n+        if (prev_cvf != NULL && prev_cvf->frame_pointer()->id() == frame_id) {\n+          assert(prev_cvf->is_compiled_frame(), \"expected compiled Java frame\");\n+          vf = prev_cvf->at_scope(vfst.decode_offset(), vfst.vframe_id());\n+        } else {\n+          vf = vfst.asJavaVFrame();\n+        }\n+\n+        StackValueCollection* locals = NULL;\n+        typeArrayHandle localIsVirtual_h;\n+        if (vf->is_compiled_frame()) {\n+          \/\/ compiled method frame\n+          compiledVFrame* cvf = compiledVFrame::cast(vf);\n+\n+          ScopeDesc* scope = cvf->scope();\n+          \/\/ native wrappers do not have a scope\n+          if (scope != NULL && scope->objects() != NULL) {\n+            prev_cvf = cvf;\n+\n+            GrowableArray<ScopeValue*>* objects = NULL;\n+            if (!realloc_called) {\n+              objects = scope->objects();\n+            } else {\n+              \/\/ some object might already have been re-allocated, only reallocate the non-allocated ones\n+              objects = get_unallocated_objects_or_null(scope->objects());\n+            }\n+\n+            if (objects != NULL) {\n+              RegisterMap reg_map(vf->register_map());\n+              bool realloc_failures = Deoptimization::realloc_objects(thread, vf->frame_pointer(), &reg_map, objects, CHECK_NULL);\n+              Deoptimization::reassign_fields(vf->frame_pointer(), &reg_map, objects, realloc_failures, false);\n@@ -1225,0 +1312,1 @@\n+            }\n@@ -1226,8 +1314,7 @@\n-              GrowableArray<ScopeValue*>* local_values = scope->locals();\n-              assert(local_values != NULL, \"NULL locals\");\n-              typeArrayOop array_oop = oopFactory::new_boolArray(local_values->length(), CHECK_NULL);\n-              typeArrayHandle array(THREAD, array_oop);\n-              for (int i = 0; i < local_values->length(); i++) {\n-                ScopeValue* value = local_values->at(i);\n-                if (value->is_object()) {\n-                  array->bool_at_put(i, true);\n+            GrowableArray<ScopeValue*>* local_values = scope->locals();\n+            for (int i = 0; i < local_values->length(); i++) {\n+              ScopeValue* value = local_values->at(i);\n+              if (value->is_object()) {\n+                if (localIsVirtual_h.is_null()) {\n+                  typeArrayOop array_oop = oopFactory::new_boolArray(local_values->length(), CHECK_NULL);\n+                  localIsVirtual_h = typeArrayHandle(THREAD, array_oop);\n@@ -1235,0 +1322,1 @@\n+                localIsVirtual_h->bool_at_put(i, true);\n@@ -1236,3 +1324,0 @@\n-              HotSpotJVMCI::HotSpotStackFrameReference::set_localIsVirtual(JVMCIENV, frame_reference(), array());\n-            } else {\n-              HotSpotJVMCI::HotSpotStackFrameReference::set_localIsVirtual(JVMCIENV, frame_reference(), NULL);\n@@ -1240,6 +1325,0 @@\n-\n-            locals = cvf->locals();\n-            HotSpotJVMCI::HotSpotStackFrameReference::set_bci(JVMCIENV, frame_reference(), cvf->bci());\n-            methodHandle mh(THREAD, cvf->method());\n-            JVMCIObject method = JVMCIENV->get_jvmci_method(mh, JVMCI_CHECK_NULL);\n-            HotSpotJVMCI::HotSpotStackFrameReference::set_method(JVMCIENV, frame_reference(), JNIHandles::resolve(method.as_jobject()));\n@@ -1247,0 +1326,8 @@\n+\n+          locals = cvf->locals();\n+          frame_number = cvf->vframe_id();\n+        } else {\n+          \/\/ interpreted method frame\n+          interpretedVFrame* ivf = interpretedVFrame::cast(vf);\n+\n+          locals = ivf->locals();\n@@ -1248,14 +1335,9 @@\n-      } else if (vf->is_interpreted_frame()) {\n-        \/\/ interpreted method frame\n-        interpretedVFrame* ivf = interpretedVFrame::cast(vf);\n-        if (methods == NULL || matches(methods, ivf->method(), JVMCIENV)) {\n-          if (initialSkip > 0) {\n-            initialSkip--;\n-          } else {\n-            locals = ivf->locals();\n-            HotSpotJVMCI::HotSpotStackFrameReference::set_bci(JVMCIENV, frame_reference(), ivf->bci());\n-            methodHandle mh(THREAD, ivf->method());\n-            JVMCIObject method = JVMCIENV->get_jvmci_method(mh, JVMCI_CHECK_NULL);\n-            HotSpotJVMCI::HotSpotStackFrameReference::set_method(JVMCIENV, frame_reference(), JNIHandles::resolve(method.as_jobject()));\n-            HotSpotJVMCI::HotSpotStackFrameReference::set_localIsVirtual(JVMCIENV, frame_reference(), NULL);\n-          }\n+        assert(bci == vf->bci(), \"wrong bci\");\n+        assert(method == vf->method(), \"wrong method\");\n+\n+        Handle frame_reference = HotSpotJVMCI::HotSpotStackFrameReference::klass()->allocate_instance_handle(CHECK_NULL);\n+        HotSpotJVMCI::HotSpotStackFrameReference::set_bci(JVMCIENV, frame_reference(), bci);\n+        if (matched_jvmci_method.is_null()) {\n+          methodHandle mh(THREAD, method);\n+          JVMCIObject jvmci_method = JVMCIENV->get_jvmci_method(mh, JVMCI_CHECK_NULL);\n+          matched_jvmci_method = Handle(THREAD, JNIHandles::resolve(jvmci_method.as_jobject()));\n@@ -1263,1 +1345,2 @@\n-      }\n+        HotSpotJVMCI::HotSpotStackFrameReference::set_method(JVMCIENV, frame_reference(), matched_jvmci_method());\n+        HotSpotJVMCI::HotSpotStackFrameReference::set_localIsVirtual(JVMCIENV, frame_reference(), localIsVirtual_h());\n@@ -1265,3 +1348,0 @@\n-      \/\/ locals != NULL means that we found a matching frame and result is already partially initialized\n-      if (locals != NULL) {\n-        methods = match_methods;\n@@ -1269,1 +1349,1 @@\n-        HotSpotJVMCI::HotSpotStackFrameReference::set_stackPointer(JVMCIENV, frame_reference(), (jlong) fst.current()->sp());\n+        HotSpotJVMCI::HotSpotStackFrameReference::set_stackPointer(JVMCIENV, frame_reference(), (jlong) frame_id);\n@@ -1286,0 +1366,4 @@\n+        if (visitor_method.is_null()) {\n+          visitor_method = resolve_interface_call(HotSpotJVMCI::InspectedFrameVisitor::klass(), vmSymbols::visitFrame_name(), vmSymbols::visitFrame_signature(), &args, CHECK_NULL);\n+        }\n+\n@@ -1287,1 +1371,1 @@\n-        call_interface(&result, HotSpotJVMCI::InspectedFrameVisitor::klass(), vmSymbols::visitFrame_name(), vmSymbols::visitFrame_signature(), &args, CHECK_NULL);\n+        JavaCalls::call(&result, visitor_method, &args, CHECK_NULL);\n@@ -1291,0 +1375,6 @@\n+        if (methods == initial_methods) {\n+          methods = match_methods;\n+          if (resolved_methods != NULL && JNIHandles::resolve(match_methods) != JNIHandles::resolve(initial_methods)) {\n+            resolved_methods = NULL;\n+          }\n+        }\n@@ -1295,18 +1385,1 @@\n-          fst = StackFrameStream(thread, true \/* update *\/, true \/* process_frames *\/);\n-          while (fst.current()->sp() != stack_pointer && !fst.is_done()) {\n-            fst.next();\n-          }\n-          if (fst.current()->sp() != stack_pointer) {\n-            THROW_MSG_NULL(vmSymbols::java_lang_IllegalStateException(), \"stack frame not found after deopt\")\n-          }\n-          vf = vframe::new_vframe(fst, thread);\n-          if (!vf->is_compiled_frame()) {\n-            THROW_MSG_NULL(vmSymbols::java_lang_IllegalStateException(), \"compiled stack frame expected\")\n-          }\n-          for (int i = 0; i < frame_number; i++) {\n-            if (vf->is_top()) {\n-              THROW_MSG_NULL(vmSymbols::java_lang_IllegalStateException(), \"vframe not found after deopt\")\n-            }\n-            vf = vf->sender();\n-            assert(vf->is_compiled_frame(), \"Wrong frame type\");\n-          }\n+          resync_vframestream_to_compiled_frame(vfst, stack_pointer, frame_number, thread, CHECK_NULL);\n@@ -1314,6 +1387,0 @@\n-        frame_reference = HotSpotJVMCI::HotSpotStackFrameReference::klass()->allocate_instance_handle(CHECK_NULL);\n-        HotSpotJVMCI::HotSpotStackFrameReference::klass()->initialize(CHECK_NULL);\n-      }\n-\n-      if (vf->is_top()) {\n-        break;\n@@ -1321,2 +1388,0 @@\n-      frame_number++;\n-      vf = vf->sender();\n@@ -1324,7 +1389,0 @@\n-\n-    if (fst.is_done()) {\n-      break;\n-    }\n-    fst.next();\n-    vf = vframe::new_vframe(fst, thread);\n-    frame_number = 0;\n@@ -1429,1 +1487,1 @@\n-  while (fst.current()->sp() != stack_pointer && !fst.is_done()) {\n+  while (fst.current()->id() != stack_pointer && !fst.is_done()) {\n@@ -1432,1 +1490,1 @@\n-  if (fst.current()->sp() != stack_pointer) {\n+  if (fst.current()->id() != stack_pointer) {\n@@ -1446,1 +1504,1 @@\n-  while (fstAfterDeopt.current()->sp() != stack_pointer && !fstAfterDeopt.is_done()) {\n+  while (fstAfterDeopt.current()->id() != stack_pointer && !fstAfterDeopt.is_done()) {\n@@ -1449,1 +1507,1 @@\n-  if (fstAfterDeopt.current()->sp() != stack_pointer) {\n+  if (fstAfterDeopt.current()->id() != stack_pointer) {\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":173,"deletions":115,"binary":false,"changes":288,"status":"modified"},{"patch":"@@ -577,1 +577,1 @@\n-    guarantee(_frame.is_compiled_frame(), \"expected compiled Java frame\");\n+    guarantee(_frame.is_compiled_frame() || _frame.is_native_frame(), \"expected compiled Java frame\");\n@@ -584,1 +584,1 @@\n-    guarantee(f.is_compiled_frame(), \"expected compiled Java frame\");\n+    guarantee(f.is_compiled_frame() || f.is_native_frame(), \"expected compiled Java frame\");\n@@ -590,2 +590,5 @@\n-    \/\/ get the same scope as this stream\n-    cvf = cvf->at_scope(_decode_offset, _vframe_id);\n+    if (cvf->scope() == NULL) {\n+      guarantee(f.is_native_frame(), \"expected native frame\");\n+    } else {\n+      \/\/ get the same scope as this stream\n+      cvf = cvf->at_scope(_decode_offset, _vframe_id);\n@@ -593,2 +596,3 @@\n-    guarantee(cvf->scope()->decode_offset() == _decode_offset, \"wrong scope\");\n-    guarantee(cvf->scope()->sender_decode_offset() == _sender_decode_offset, \"wrong scope\");\n+      guarantee(cvf->scope()->decode_offset() == _decode_offset, \"wrong scope\");\n+      guarantee(cvf->scope()->sender_decode_offset() == _sender_decode_offset, \"wrong scope\");\n+    }\n","filename":"src\/hotspot\/share\/runtime\/vframe.cpp","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -313,0 +313,2 @@\n+  inline int vframe_id() const;\n+  inline int decode_offset() const;\n","filename":"src\/hotspot\/share\/runtime\/vframe.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,0 +39,10 @@\n+inline int vframeStreamCommon::vframe_id() const {\n+  assert(_mode == compiled_mode, \"usage\");\n+  return _vframe_id;\n+}\n+\n+inline int vframeStreamCommon::decode_offset() const {\n+  assert(_mode == compiled_mode, \"usage\");\n+  return _decode_offset;\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/vframe.inline.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,162 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8269592\n+ *\n+ * @requires vm.jvmci & vm.compMode == \"Xmixed\"\n+ * @requires vm.opt.final.EliminateAllocations == true\n+ *\n+ * @comment no \"-Xcomp -XX:-TieredCompilation\" combination allowed until JDK-8140018 is resolved\n+ * @requires vm.opt.TieredCompilation == null | vm.opt.TieredCompilation == true\n+ *\n+ * @library \/ \/test\/lib\n+ * @library ..\/common\/patches\n+ * @modules java.base\/jdk.internal.misc\n+ * @modules java.base\/jdk.internal.org.objectweb.asm\n+ *          java.base\/jdk.internal.org.objectweb.asm.tree\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.hotspot\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.code\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.code.stack\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.meta\n+ *\n+ * @build jdk.internal.vm.ci\/jdk.vm.ci.hotspot.CompilerToVMHelper sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -Xbatch -Xbootclasspath\/a:.\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI\n+ *                   -XX:+DoEscapeAnalysis -XX:-UseCounterDecay\n+ *                   compiler.jvmci.compilerToVM.IterateFramesNative\n+ *\/\n+\n+package compiler.jvmci.compilerToVM;\n+\n+import compiler.jvmci.common.CTVMUtilities;\n+import compiler.testlibrary.CompilerUtils;\n+import compiler.whitebox.CompilerWhiteBoxTest;\n+import jdk.test.lib.Asserts;\n+import jdk.vm.ci.code.stack.InspectedFrame;\n+import jdk.vm.ci.hotspot.CompilerToVMHelper;\n+import jdk.vm.ci.hotspot.HotSpotStackFrameReference;\n+import jdk.vm.ci.meta.ResolvedJavaMethod;\n+import jtreg.SkippedException;\n+import sun.hotspot.WhiteBox;\n+\n+import java.lang.reflect.Method;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+public class IterateFramesNative {\n+    private static final WhiteBox WB;\n+    private static final int COMPILE_THRESHOLD;\n+    private static final ResolvedJavaMethod NATIVE_METHOD_RESOLVED;\n+    private static final ResolvedJavaMethod NATIVE_CALLBACK_METHOD_RESOLVED;\n+\n+    static {\n+        Method nativeMethod;\n+        Method nativeCallbackMethod;\n+        WB = WhiteBox.getWhiteBox();\n+        try {\n+            nativeMethod = IterateFramesNative.class.getDeclaredMethod(\"callerNative\",\n+                    Runnable.class);\n+            nativeCallbackMethod = IterateFramesNative.class.getDeclaredMethod(\"testNativeFrameCallback\",\n+                    Helper.class, int.class);\n+        } catch (NoSuchMethodException e) {\n+            throw new Error(\"Can't get executable for test method\", e);\n+        }\n+        NATIVE_METHOD_RESOLVED = CTVMUtilities.getResolvedMethod(nativeMethod);\n+        NATIVE_CALLBACK_METHOD_RESOLVED = CTVMUtilities.getResolvedMethod(nativeCallbackMethod);\n+        COMPILE_THRESHOLD = WB.getBooleanVMFlag(\"TieredCompilation\")\n+                ? CompilerWhiteBoxTest.THRESHOLD\n+                : CompilerWhiteBoxTest.THRESHOLD * 2;\n+\n+        loadNativeLibrary();\n+    }\n+\n+    public static void main(String[] args) {\n+        int levels[] = CompilerUtils.getAvailableCompilationLevels();\n+        \/\/ we need compilation level 4 to use EscapeAnalysis\n+        if (levels.length < 1 || levels[levels.length - 1] != 4) {\n+            throw new SkippedException(\"Test needs compilation level 4\");\n+        }\n+\n+        new IterateFramesNative().test();\n+    }\n+\n+    private void test() {\n+        for (int i = 0; i < CompilerWhiteBoxTest.THRESHOLD + 1; i++) {\n+            testNativeFrame(\"someString\", i);\n+        }\n+    }\n+\n+    \/**\n+    * Loads native library(libIterateFramesNative.so)\n+    *\/\n+    protected static void loadNativeLibrary() {\n+        System.loadLibrary(\"IterateFramesNative\");\n+    }\n+\n+    private void testNativeFrame(String str, int iteration) {\n+        Helper innerHelper = new Helper(\"foo\");\n+        callerNative(() -> testNativeFrameCallback(innerHelper, iteration));\n+\n+        Asserts.assertEQ(innerHelper.string, NATIVE_METHOD_RESOLVED.getName(),\n+            \"Native frame not found?: \" + NATIVE_METHOD_RESOLVED.getName());\n+    }\n+\n+    public static native void callerNative(Runnable runnable);\n+\n+    private void testNativeFrameCallback(Helper helper, int iteration) {\n+        AtomicInteger frameCounter = new AtomicInteger();\n+        ResolvedJavaMethod[] methods = new ResolvedJavaMethod[] {NATIVE_METHOD_RESOLVED, NATIVE_CALLBACK_METHOD_RESOLVED};\n+        CompilerToVMHelper.iterateFrames(\n+            methods,\n+            methods,\n+            0,\n+            f -> {\n+                HotSpotStackFrameReference frame = (HotSpotStackFrameReference) f;\n+                Asserts.assertNotNull(frame, \"got null frame for native method\");\n+                int index = frameCounter.getAndIncrement();\n+                if (index == 0) {\n+                    Asserts.assertTrue(frame.isMethod(NATIVE_CALLBACK_METHOD_RESOLVED),\n+                        \"unexpected method: \" + frame.getMethod().getName());\n+                } else if (index == 1) {\n+                    Asserts.assertTrue(frame.isMethod(NATIVE_METHOD_RESOLVED),\n+                        \"unexpected method: \" + frame.getMethod().getName());\n+                    helper.string = frame.getMethod().getName();\n+                    Asserts.assertFalse(frame.hasVirtualObjects(),\n+                        \"native frames do not have virtual objects\");\n+                    return frame; \/\/ stop\n+                }\n+                return null;\n+            });\n+    }\n+\n+    private class Helper {\n+        public String string;\n+\n+        public Helper(String s) {\n+            this.string = s;\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/compilerToVM\/IterateFramesNative.java","additions":162,"deletions":0,"binary":false,"changes":162,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+\n+#include \"jni.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#define CHECK_EXCEPTIONS if ((*env)->ExceptionCheck(env)) return\n+\n+JNIEXPORT void JNICALL Java_compiler_jvmci_compilerToVM_IterateFramesNative_callerNative(JNIEnv *env, jobject obj, jobject runnable) {\n+  jclass cls = (*env)->GetObjectClass(env, runnable);\n+  jmethodID runMethodID = (*env)->GetMethodID(env, cls, \"run\", \"()V\");\n+  CHECK_EXCEPTIONS;\n+  (*env)->CallVoidMethod(env, runnable, runMethodID);\n+  CHECK_EXCEPTIONS;\n+}\n+\n+#ifdef __cplusplus\n+}\n+#endif\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/compilerToVM\/libIterateFramesNative.c","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"}]}