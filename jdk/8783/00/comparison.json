{"files":[{"patch":"@@ -494,15 +494,16 @@\n-  Node* predicate = NULL;\n-  predicate = find_predicate_insertion_point(entry, Deoptimization::Reason_loop_limit_check);\n-  if (predicate != NULL) {\n-    entry = skip_loop_predicates(entry);\n-  }\n-  if (UseProfiledLoopPredicate) {\n-    predicate = find_predicate_insertion_point(entry, Deoptimization::Reason_profile_predicate);\n-    if (predicate != NULL) { \/\/ right pattern that can be used by loop predication\n-      entry = skip_loop_predicates(entry);\n-    }\n-  }\n-  if (UseLoopPredicate) {\n-    predicate = find_predicate_insertion_point(entry, Deoptimization::Reason_predicate);\n-    if (predicate != NULL) { \/\/ right pattern that can be used by loop predication\n-      entry = skip_loop_predicates(entry);\n+  Predicates predicates(entry);\n+  return predicates.skip_all();\n+}\n+\n+\/\/--------------------------next_predicate---------------------------------\n+\/\/ Find next related predicate, useful for iterating over all related predicates\n+ProjNode* PhaseIdealLoop::next_predicate(ProjNode* predicate) {\n+  IfNode* iff = predicate->in(0)->as_If();\n+  ProjNode* uncommon_proj = iff->proj_out(1 - predicate->_con);\n+  Node* rgn = uncommon_proj->unique_ctrl_out();\n+  assert(rgn->is_Region() || rgn->is_Call(), \"must be a region or call uct\");\n+  Node* next = iff->in(0);\n+  if (next != nullptr && next->is_Proj() && next->in(0)->is_If()) {\n+    uncommon_proj = next->in(0)->as_If()->proj_out(1 - next->as_Proj()->_con);\n+    if (uncommon_proj->unique_ctrl_out() == rgn) { \/\/ lead into same region\n+      return next->as_Proj();\n@@ -511,1 +512,1 @@\n-  return entry;\n+  return nullptr;\n@@ -525,0 +526,22 @@\n+\/\/--------------------------Predicates::Predicates--------------------------\n+\/\/ given loop entry, find all predicates above loop\n+PhaseIdealLoop::Predicates::Predicates(Node* entry) {\n+  _loop_limit_check = find_predicate_insertion_point(entry, Deoptimization::Reason_loop_limit_check);\n+  if (_loop_limit_check != nullptr) {\n+    entry = skip_loop_predicates(entry);\n+  }\n+  if (UseProfiledLoopPredicate) {\n+    _profile_predicate = find_predicate_insertion_point(entry, Deoptimization::Reason_profile_predicate);\n+    if (_profile_predicate != nullptr) {\n+      entry = skip_loop_predicates(entry);\n+    }\n+  }\n+  if (UseLoopPredicate) {\n+    _predicate = find_predicate_insertion_point(entry, Deoptimization::Reason_predicate);\n+    if (_predicate != nullptr) {\n+      entry = skip_loop_predicates(entry);\n+    }\n+  }\n+  _entry_to_all_predicates = entry;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":39,"deletions":16,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -617,0 +617,3 @@\n+\/\/                     |\n+\/\/                     v\n+\/\/               loop predicate\n@@ -623,1 +626,1 @@\n-\/\/              \/          loop predicate   |\n+\/\/              \/                |          |\n@@ -650,1 +653,4 @@\n-\/\/                  stmt1\n+\/\/                 stmt1\n+\/\/                    |\n+\/\/                    v\n+\/\/              loop predicate\n@@ -663,1 +669,1 @@\n-\/\/             | loop predicate\n+\/\/             | initialized skeleton predicates\n@@ -717,1 +723,3 @@\n-  clone_loop(loop, old_new, dom_depth(head->skip_strip_mined()), ControlAroundStripMined);\n+  const uint idx_before_clone = Compile::current()->unique();\n+  LoopNode* outer_loop_head = head->skip_strip_mined();\n+  clone_loop(loop, old_new, dom_depth(outer_loop_head), ControlAroundStripMined);\n@@ -726,2 +734,2 @@\n-  _igvn.hash_delete(head->skip_strip_mined());\n-  head->skip_strip_mined()->set_req(LoopNode::EntryControl, new_entry);\n+  _igvn.hash_delete(outer_loop_head);\n+  outer_loop_head->set_req(LoopNode::EntryControl, new_entry);\n@@ -756,2 +764,2 @@\n-  int dd = dom_depth(head->skip_strip_mined());\n-  set_idom(head->skip_strip_mined(), head->skip_strip_mined()->in(LoopNode::EntryControl), dd);\n+  int dd_outer_loop_head = dom_depth(outer_loop_head);\n+  set_idom(outer_loop_head, outer_loop_head->in(LoopNode::EntryControl), dd_outer_loop_head);\n@@ -762,1 +770,1 @@\n-      set_idom(nnn, idom(nnn), dd-1);\n+      set_idom(nnn, idom(nnn), dd_outer_loop_head-1);\n@@ -766,0 +774,17 @@\n+  \/\/ Step 5: skeleton_predicates instantiation\n+  if (counted_loop && UseLoopPredicate) {\n+    CountedLoopNode *cl_head = head->as_CountedLoop();\n+    Node* init = cl_head->init_trip();\n+    Node* stride = cl_head->stride();\n+    IdealLoopTree* outer_loop = get_loop(outer_loop_head);\n+    Predicates predicates(new_head->in(LoopNode::EntryControl));\n+    initialize_skeleton_predicates_for_peeled_loop(predicates.predicate(),\n+                                                   outer_loop_head, dd_outer_loop_head,\n+                                                   init, stride, outer_loop,\n+                                                   idx_before_clone, old_new);\n+    initialize_skeleton_predicates_for_peeled_loop(predicates.profile_predicate(),\n+                                                   outer_loop_head, dd_outer_loop_head,\n+                                                   init, stride, outer_loop,\n+                                                   idx_before_clone, old_new);\n+ }\n+\n@@ -1318,2 +1343,2 @@\n-        prev_proj = clone_skeleton_predicate_for_main_or_post_loop(iff, opaque_init, NULL, predicate, uncommon_proj,\n-                                                                   current_proj, outer_loop, prev_proj);\n+        prev_proj = clone_skeleton_predicate_and_initialize(iff, opaque_init, NULL, predicate, uncommon_proj,\n+                                                            current_proj, outer_loop, prev_proj);\n@@ -1322,2 +1347,2 @@\n-        prev_proj = clone_skeleton_predicate_for_main_or_post_loop(iff, init, stride, predicate, uncommon_proj,\n-                                                                   current_proj, outer_loop, prev_proj);\n+        prev_proj = clone_skeleton_predicate_and_initialize(iff, init, stride, predicate, uncommon_proj,\n+                                                            current_proj, outer_loop, prev_proj);\n@@ -1476,2 +1501,2 @@\n-Node* PhaseIdealLoop::clone_skeleton_predicate_for_main_or_post_loop(Node* iff, Node* new_init, Node* new_stride, Node* predicate, Node* uncommon_proj,\n-                                                                     Node* control, IdealLoopTree* outer_loop, Node* input_proj) {\n+Node* PhaseIdealLoop::clone_skeleton_predicate_and_initialize(Node* iff, Node* new_init, Node* new_stride, Node* predicate, Node* uncommon_proj,\n+                                                              Node* control, IdealLoopTree* outer_loop, Node* input_proj) {\n@@ -2007,2 +2032,2 @@\n-        prev_proj = clone_skeleton_predicate_for_main_or_post_loop(iff, init, max_value, entry, proj, ctrl, outer_loop,\n-                                                                   prev_proj);\n+        prev_proj = clone_skeleton_predicate_and_initialize(iff, init, max_value, entry, proj, ctrl, outer_loop,\n+                                                            prev_proj);\n@@ -2036,2 +2061,2 @@\n-      prev_proj = clone_skeleton_predicate_for_main_or_post_loop(iff, init, stride, ctrl, proj, post_loop_entry,\n-                                                                 post_loop, prev_proj);\n+      prev_proj = clone_skeleton_predicate_and_initialize(iff, init, stride, ctrl, proj, post_loop_entry,\n+                                                          post_loop, prev_proj);\n@@ -2048,0 +2073,46 @@\n+void PhaseIdealLoop::initialize_skeleton_predicates_for_peeled_loop(ProjNode* predicate,\n+                                                                    LoopNode* outer_loop_head,\n+                                                                    int dd_outer_loop_head,\n+                                                                    Node* init,\n+                                                                    Node* stride,\n+                                                                    IdealLoopTree* outer_loop,\n+                                                                    const uint idx_before_clone,\n+                                                                    const Node_List &old_new) {\n+  if (predicate == nullptr) {\n+    return;\n+  }\n+  Node* control = outer_loop_head->in(LoopNode::EntryControl);\n+  Node* input_proj = control;\n+\n+  predicate = next_predicate(predicate);\n+  while (predicate != nullptr) {\n+    IfNode* iff = predicate->in(0)->as_If();\n+    if (iff->in(1)->Opcode() == Op_Opaque4) {\n+      assert(skeleton_predicate_has_opaque(iff), \"unexpected\");\n+      ProjNode* uncommon_proj = iff->proj_out(1 - predicate->as_Proj()->_con);\n+      input_proj = clone_skeleton_predicate_and_initialize(iff, init, stride, predicate, uncommon_proj, control, outer_loop, input_proj);\n+\n+      \/\/ Rewire any control inputs from the old skeleton predicates above the peeled iteration down to the initialized\n+      \/\/ skeleton predicates above the peeled loop.\n+      for (DUIterator i = predicate->outs(); predicate->has_out(i); i++) {\n+        Node* dependent = predicate->out(i);\n+        Node* new_node = old_new[dependent->_idx];\n+\n+        if (!dependent->is_CFG() &&\n+            dependent->_idx < idx_before_clone &&  \/\/ old node\n+            new_node != nullptr &&                 \/\/ cloned\n+            new_node->_idx >= idx_before_clone) {  \/\/ for peeling\n+          \/\/ The old nodes from the peeled loop still point to the predicate above the peeled loop.\n+          \/\/ We need to rewire the dependencies to the newly initialized skeleton predicates.\n+          _igvn.replace_input_of(dependent, 0, input_proj);\n+          --i; \/\/ correct for just deleted predicate->out(i)\n+        }\n+      }\n+    }\n+    predicate = next_predicate(predicate);\n+  }\n+\n+  _igvn.replace_input_of(outer_loop_head, LoopNode::EntryControl, input_proj);\n+  set_idom(outer_loop_head, input_proj, dd_outer_loop_head);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":90,"deletions":19,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -930,2 +930,2 @@\n-  Node* clone_skeleton_predicate_for_main_or_post_loop(Node* iff, Node* new_init, Node* new_stride, Node* predicate, Node* uncommon_proj, Node* control,\n-                                                       IdealLoopTree* outer_loop, Node* input_proj);\n+  Node* clone_skeleton_predicate_and_initialize(Node* iff, Node* new_init, Node* new_stride, Node* predicate, Node* uncommon_proj, Node* control,\n+                                                IdealLoopTree* outer_loop, Node* input_proj);\n@@ -937,0 +937,3 @@\n+  void initialize_skeleton_predicates_for_peeled_loop(ProjNode* predicate, LoopNode* outer_loop_head, int dd_outer_loop_head,\n+                                                      Node* init, Node* stride, IdealLoopTree* outer_loop,\n+                                                      const uint idx_before_clone, const Node_List& old_new);\n@@ -1331,0 +1334,1 @@\n+  static ProjNode* next_predicate(ProjNode* predicate);\n@@ -1334,0 +1338,33 @@\n+\n+  class Predicates {\n+  public:\n+    \/\/ given loop entry, find all predicates above loop\n+    Predicates(Node* entry);\n+\n+    \/\/ Proj of empty loop limit check predicate\n+    ProjNode* loop_limit_check() {\n+      return _loop_limit_check;\n+    }\n+\n+    \/\/ Proj of empty profile predicate\n+    ProjNode* profile_predicate() {\n+      return _profile_predicate;\n+    }\n+\n+    \/\/ Proj of empty predicate\n+    ProjNode* predicate() {\n+      return _predicate;\n+    }\n+\n+    \/\/ First control node above all predicates\n+    Node* skip_all() {\n+      return _entry_to_all_predicates;\n+    }\n+\n+  private:\n+    ProjNode*_loop_limit_check = nullptr;\n+    ProjNode* _profile_predicate = nullptr;\n+    ProjNode* _predicate = nullptr;\n+    Node* _entry_to_all_predicates = nullptr;\n+  };\n+\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":39,"deletions":2,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8283466\n+ * @summary When skeleton predicates are not copied into peeled loop and initialized, this can happen:\n+ *          1. The rangecheck from a load is hoisted outside of the counted loop.\n+ *          2. The counted loop is peeled (we disable unswitching and unrolling with arguments)\n+ *          3. The type inside the peeled loop may now be narrower.\n+ *          4. The dataflow can die when a type becomes impossible.\n+ *          5. The rangecheck is still before the peeling, and is not copied to the peeled loop. Hence\n+ *             we do not statically realize that the peeled loop can never be entered.\n+ *\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+StressLCM -XX:+StressGCM -XX:+StressCCP -XX:+StressIGVN\n+ *                   -Xcomp -XX:-TieredCompilation\n+ *                   -XX:LoopMaxUnroll=0 -XX:LoopUnrollLimit=0 -XX:-LoopUnswitching\n+ *                   -XX:CompileCommand=compileonly,compiler.loopopts.TestPeelingSkeletonPredicateInitialization::*\n+ *                   compiler.loopopts.TestPeelingSkeletonPredicateInitialization\n+*\/\n+\n+package compiler.loopopts;\n+\n+public class TestPeelingSkeletonPredicateInitialization {\n+  int N = 400;\n+  int array[] = new int[N];\n+  int array2[] = new int[N];\n+  void run(int X, int inv, boolean b) {\n+    \/\/ have the arguments so the values are unknown to C2, cannot optimize things away\n+    try {\n+      \/\/ not sure why needed. maybe has sth to do with div_by_zero below?\n+      int tmp = 1 \/ 0;\n+    } catch (ArithmeticException e) {\n+    }\n+    for(int i = 2; i > X; i-=3) {\n+      \/\/ potential div_by_zero: somehow the exit is not loop exit but rethrow\n+      \/\/ also: i-1 only works in peeled iteration\n+      \/\/ in peeled loop: ConvI2L dies because it knows dataflow is impossible\n+      \/\/ If skeleton_predicate is missing for peeled loop, then controlflow does not die\n+      array[i - 1] \/= inv;\n+      \/\/ loop invariant check that is not hoisted: this becomes reason for peeling\n+      array[inv] += 1;\n+      if (b) {\n+        \/\/ seems to be required for the memory phi so that it can be mangled when data flow dies\n+        array[inv] += 1;\n+        array2[inv] += 1;\n+      }\n+    }\n+  }\n+  public static void main(String[] strArr) {\n+    try {\n+      TestPeelingSkeletonPredicateInitialization _instance = new TestPeelingSkeletonPredicateInitialization();\n+      for (int i = 0; i < 10000; i++) {\n+        _instance.run(100, 3, false);\n+      }\n+    } catch (Exception ex) {\n+    }\n+  }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestPeelingSkeletonPredicateInitialization.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"}]}