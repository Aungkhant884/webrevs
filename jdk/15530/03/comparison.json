{"files":[{"patch":"@@ -35,0 +35,1 @@\n+import java.util.function.IntPredicate;\n@@ -36,0 +37,1 @@\n+import jdk.internal.util.ImmutableBitSetPredicate;\n@@ -81,1 +83,1 @@\n-    private static final BitSet DONT_NEED_ENCODING;\n+    private static final IntPredicate DONT_NEED_ENCODING;\n@@ -123,6 +125,5 @@\n-        DONT_NEED_ENCODING = new BitSet(128);\n-\n-        DONT_NEED_ENCODING.set('a', 'z' + 1);\n-        DONT_NEED_ENCODING.set('A', 'Z' + 1);\n-        DONT_NEED_ENCODING.set('0', '9' + 1);\n-        DONT_NEED_ENCODING.set(' '); \/* encoding a space to a + is done\n+        var bitSet = new BitSet(128);\n+        bitSet.set('a', 'z' + 1);\n+        bitSet.set('A', 'Z' + 1);\n+        bitSet.set('0', '9' + 1);\n+        bitSet.set(' '); \/* encoding a space to a + is done\n@@ -130,4 +131,6 @@\n-        DONT_NEED_ENCODING.set('-');\n-        DONT_NEED_ENCODING.set('_');\n-        DONT_NEED_ENCODING.set('.');\n-        DONT_NEED_ENCODING.set('*');\n+        bitSet.set('-');\n+        bitSet.set('_');\n+        bitSet.set('.');\n+        bitSet.set('*');\n+\n+        DONT_NEED_ENCODING = ImmutableBitSetPredicate.of(bitSet);\n@@ -229,1 +232,1 @@\n-            if (DONT_NEED_ENCODING.get(c)) {\n+            if (DONT_NEED_ENCODING.test(c)) {\n@@ -272,1 +275,1 @@\n-                } while (i < s.length() && !DONT_NEED_ENCODING.get((c = s.charAt(i))));\n+                } while (i < s.length() && !DONT_NEED_ENCODING.test((c = s.charAt(i))));\n","filename":"src\/java.base\/share\/classes\/java\/net\/URLEncoder.java","additions":16,"deletions":13,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -0,0 +1,66 @@\n+package jdk.internal.util;\n+\n+import jdk.internal.ValueBased;\n+import jdk.internal.vm.annotation.Stable;\n+\n+import java.util.BitSet;\n+import java.util.function.IntPredicate;\n+\n+\/**\n+ * Class for working with immutable BitSets.\n+ *\/\n+@ValueBased\n+public class ImmutableBitSetPredicate implements IntPredicate {\n+\n+    @Stable\n+    private final long[] words;\n+\n+    private ImmutableBitSetPredicate(BitSet original) {\n+        \/\/ If this class is made public, we need to do\n+        \/\/ a defensive array copy as certain BitSet implementations\n+        \/\/ may return a shared array. The spec says the array should be _new_ though but\n+        \/\/ the consequences might be unspecified for a malicious BitSet.\n+        this.words = original.toLongArray();\n+    }\n+\n+    @Override\n+    public boolean test(int bitIndex) {\n+        if (bitIndex < 0)\n+            throw new IndexOutOfBoundsException(\"bitIndex < 0: \" + bitIndex);\n+\n+        int wordIndex = wordIndex(bitIndex);\n+        return (wordIndex < words.length)\n+                && ((words[wordIndex] & (1L << bitIndex)) != 0);\n+    }\n+\n+    \/**\n+     * Given a bit index, return word index containing it.\n+     *\/\n+    private static int wordIndex(int bitIndex) {\n+        return bitIndex >> 6;\n+    }\n+\n+    \/**\n+     * {@return a new {@link IntPredicate } representing the {@link BitSet#get(int)} method applied\n+     * on an immutable snapshot of the current state of this BitSet}.\n+     * <p>\n+     * If the returned predicate is invoked with a {@code bitIndex} that is negative, the predicate\n+     * will throw an IndexOutOfBoundsException just as the {@link BitSet#get(int)} method would.\n+     * <p>\n+     * The method only supports BitSets where the highest bit that is set has an index less than {@link Integer#MAX_VALUE}.\n+     * <p>\n+     * Returned predicates are threadsafe and can be used without external synchronisation.\n+     *\n+     * @implNote The method is free to return a {@link ValueBased} implementation.\n+     *\n+     * @since 22\n+     *\/\n+    public static IntPredicate of(BitSet original) {\n+        \/\/ Do not propagate the Integer.MAX_VALUE issue\n+        if (Integer.toUnsignedLong(original.length()) > Integer.MAX_VALUE) {\n+            throw new IllegalArgumentException();\n+        }\n+        return new ImmutableBitSetPredicate(original);\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/ImmutableBitSetPredicate.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary Basic tests of immutable BitSets\n+ * @modules java.base\/jdk.internal.util\n+ * @run junit ImmutableBitSet\n+ *\/\n+\n+import jdk.internal.util.ImmutableBitSetPredicate;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.BitSet;\n+import java.util.Random;\n+import java.util.function.IntPredicate;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class ImmutableBitSet {\n+\n+    @Test\n+    void empty() {\n+        BitSet bs = new BitSet();\n+        IntPredicate ibs = ImmutableBitSetPredicate.of(bs);\n+        test(bs, ibs);\n+    }\n+\n+    @Test\n+    void negativeIndex() {\n+        BitSet bs = new BitSet();\n+        IntPredicate ibs = ImmutableBitSetPredicate.of(bs);\n+        assertThrows(IndexOutOfBoundsException.class, () -> {\n+            ibs.test(-1);\n+        });\n+    }\n+\n+    @Test\n+    void basic() {\n+        BitSet bs = createReference(147);\n+        IntPredicate ibs = ImmutableBitSetPredicate.of(bs);\n+        test(bs, ibs);\n+    }\n+\n+    @Test\n+    void clearedAtTheTail() {\n+        for (int i = Long.BYTES - 1; i < Long.BYTES + 2; i++) {\n+            BitSet bs = createReference(i);\n+            for (int j = bs.length() - 1; j > Long.BYTES - 1; j++) {\n+                bs.clear(j);\n+            }\n+            IntPredicate ibs = ImmutableBitSetPredicate.of(bs);\n+            test(bs, ibs);\n+        }\n+    }\n+\n+    static void test(BitSet expected, IntPredicate actual) {\n+        for (int i = 0; i < expected.length() + 17; i++) {\n+            assertEquals(expected.get(i), actual.test(i), \"at index \" + i);\n+        }\n+    }\n+\n+    private static BitSet createReference(int length) {\n+        BitSet result = new BitSet();\n+        Random random = new Random(length);\n+        for (int i = 0; i < length; i++) {\n+            result.set(i, random.nextBoolean());\n+        }\n+        return result;\n+    }\n+\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/util\/BitSet\/ImmutableBitSet.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"}]}