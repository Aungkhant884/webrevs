{"files":[{"patch":"@@ -37,0 +37,1 @@\n+import jdk.internal.util.ImmutableBitSetPredicate;\n@@ -135,1 +136,1 @@\n-        DONT_NEED_ENCODING = bitSet.toPredicate();\n+        DONT_NEED_ENCODING = ImmutableBitSetPredicate.of(bitSet);\n","filename":"src\/java.base\/share\/classes\/java\/net\/URLEncoder.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import java.util.function.IntPredicate;\n@@ -37,1 +36,0 @@\n-import jdk.internal.ValueBased;\n@@ -39,1 +37,0 @@\n-import jdk.internal.vm.annotation.Stable;\n@@ -1404,44 +1401,0 @@\n-    \/**\n-     * {@return a new {@link IntPredicate} representing the {@link BitSet#get(int)} method applied\n-     * on an immutable snapshot of the current state of this BitSet}.\n-     * <p>\n-     * If the returned predicate is invoked with a {@code bitIndex} that is negative, the predicate\n-     * will throw an IndexOutOfBoundsException just as the {@link BitSet#get(int)} method would.\n-     * <p>\n-     * Returned predicates are threadsafe and can be used without external synchronisation.  Furthermore,\n-     * they are eligible for constant-folding optimization by the VM.\n-     *\n-     * @implNote The method is free to return a {@link ValueBased} implementation.\n-     *\n-     * @since 22\n-     *\/\n-    public IntPredicate toPredicate() {\n-        return OfImmutable.of(this);\n-    }\n-\n-    @ValueBased\n-    private static final class OfImmutable implements IntPredicate {\n-\n-        @Stable\n-        private final long[] words;\n-\n-        private OfImmutable(BitSet original) {\n-            this.words = original.toLongArray();\n-        }\n-\n-        @Override\n-        public boolean test(int bitIndex) {\n-            if (bitIndex < 0)\n-                throw new IndexOutOfBoundsException(\"bitIndex < 0: \" + bitIndex);\n-\n-            int wordIndex = wordIndex(bitIndex);\n-            return (wordIndex < words.length)\n-                    && ((words[wordIndex] & (1L << bitIndex)) != 0);\n-        }\n-\n-        private static IntPredicate of(BitSet original) {\n-            return new OfImmutable(original);\n-        }\n-\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/util\/BitSet.java","additions":0,"deletions":47,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -0,0 +1,56 @@\n+package jdk.internal.util;\n+\n+import jdk.internal.ValueBased;\n+import jdk.internal.vm.annotation.Stable;\n+\n+import java.util.BitSet;\n+import java.util.function.IntPredicate;\n+\n+\/**\n+ * Class for working with immutable BitSets.\n+ *\/\n+@ValueBased\n+public class ImmutableBitSetPredicate implements IntPredicate {\n+\n+    @Stable\n+    private final long[] words;\n+\n+    private ImmutableBitSetPredicate(BitSet original) {\n+        this.words = original.toLongArray();\n+    }\n+\n+    @Override\n+    public boolean test(int bitIndex) {\n+        if (bitIndex < 0)\n+            throw new IndexOutOfBoundsException(\"bitIndex < 0: \" + bitIndex);\n+\n+        int wordIndex = wordIndex(bitIndex);\n+        return (wordIndex < words.length)\n+                && ((words[wordIndex] & (1L << bitIndex)) != 0);\n+    }\n+\n+    \/**\n+     * Given a bit index, return word index containing it.\n+     *\/\n+    private static int wordIndex(int bitIndex) {\n+        return bitIndex >> 6;\n+    }\n+\n+    \/**\n+     * {@return a new {@link IntPredicate } representing the {@link BitSet#get(int)} method applied\n+     * on an immutable snapshot of the current state of this BitSet}.\n+     * <p>\n+     * If the returned predicate is invoked with a {@code bitIndex} that is negative, the predicate\n+     * will throw an IndexOutOfBoundsException just as the {@link BitSet#get(int)} method would.\n+     * <p>\n+     * Returned predicates are threadsafe and can be used without external synchronisation.\n+     *\n+     * @implNote The method is free to return a {@link ValueBased} implementation.\n+     *\n+     * @since 22\n+     *\/\n+    public static IntPredicate of(BitSet original) {\n+        return new ImmutableBitSetPredicate(original);\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/ImmutableBitSetPredicate.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -27,0 +27,1 @@\n+ * @modules java.base\/jdk.internal.util\n@@ -30,0 +31,1 @@\n+import jdk.internal.util.ImmutableBitSetPredicate;\n@@ -43,1 +45,1 @@\n-        IntPredicate ibs = bs.toPredicate();\n+        IntPredicate ibs = ImmutableBitSetPredicate.of(bs);\n@@ -50,1 +52,1 @@\n-        IntPredicate ibs = bs.toPredicate();\n+        IntPredicate ibs = ImmutableBitSetPredicate.of(bs);\n@@ -59,1 +61,1 @@\n-        IntPredicate ibs = bs.toPredicate();\n+        IntPredicate ibs = ImmutableBitSetPredicate.of(bs);\n@@ -70,1 +72,1 @@\n-            IntPredicate ibs = bs.toPredicate();\n+            IntPredicate ibs = ImmutableBitSetPredicate.of(bs);\n","filename":"test\/jdk\/java\/util\/BitSet\/ImmutableBitSet.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"}]}