{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1536,3 +1536,2 @@\n- os::PlatformParker::PlatformParker() {\n-  int status;\n-  status = pthread_cond_init(&_cond[REL_INDEX], _condAttr);\n+ os::PlatformParker::PlatformParker() : _counter(0), _cur_index(-1) {\n+  int status = pthread_cond_init(&_cond[REL_INDEX], _condAttr);\n@@ -1544,1 +1543,9 @@\n-  _cur_index = -1; \/\/ mark as unused\n+}\n+\n+os::PlatformParker::~PlatformParker() {\n+  int status = pthread_cond_destroy(&_cond[REL_INDEX]);\n+  assert_status(status == 0, status, \"cond_destroy rel\");\n+  status = pthread_cond_destroy(&_cond[ABS_INDEX]);\n+  assert_status(status == 0, status, \"cond_destroy abs\");\n+  status = pthread_mutex_destroy(_mutex);\n+  assert_status(status == 0, status, \"mutex_destroy\");\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":12,"deletions":5,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -187,1 +187,2 @@\n-class PlatformParker : public CHeapObj<mtSynchronizer> {\n+class PlatformParker {\n+  NONCOPYABLE(PlatformParker);\n@@ -193,0 +194,1 @@\n+  volatile int _counter;\n@@ -197,3 +199,0 @@\n- public:       \/\/ TODO-FIXME: make dtor private\n-  ~PlatformParker() { guarantee(false, \"invariant\"); }\n-\n@@ -202,0 +201,1 @@\n+  ~PlatformParker();\n","filename":"src\/hotspot\/os\/posix\/os_posix.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -5434,2 +5434,1 @@\n-\/\/ use them directly. We opportunistically resuse the event inherited\n-\/\/ from Monitor.\n+\/\/ use them directly.\n@@ -5438,1 +5437,1 @@\n-  guarantee(_ParkEvent != NULL, \"invariant\");\n+  guarantee(_ParkerEvent != NULL, \"invariant\");\n@@ -5460,2 +5459,2 @@\n-      WaitForSingleObject(_ParkEvent, 0) == WAIT_OBJECT_0) {\n-    ResetEvent(_ParkEvent);\n+      WaitForSingleObject(_ParkerEvent, 0) == WAIT_OBJECT_0) {\n+    ResetEvent(_ParkerEvent);\n@@ -5468,2 +5467,2 @@\n-    WaitForSingleObject(_ParkEvent, time);\n-    ResetEvent(_ParkEvent);\n+    WaitForSingleObject(_ParkerEvent, time);\n+    ResetEvent(_ParkerEvent);\n@@ -5479,2 +5478,2 @@\n-  guarantee(_ParkEvent != NULL, \"invariant\");\n-  SetEvent(_ParkEvent);\n+  guarantee(_ParkerEvent != NULL, \"invariant\");\n+  SetEvent(_ParkerEvent);\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -191,3 +191,2 @@\n-class PlatformParker : public CHeapObj<mtSynchronizer> {\n-  protected:\n-    HANDLE _ParkEvent ;\n+class PlatformParker {\n+  NONCOPYABLE(PlatformParker);\n@@ -195,6 +194,2 @@\n-  public:\n-    ~PlatformParker () { guarantee (0, \"invariant\") ; }\n-    PlatformParker  () {\n-      _ParkEvent = CreateEvent (NULL, true, false, NULL) ;\n-      guarantee (_ParkEvent != NULL, \"invariant\") ;\n-    }\n+ protected:\n+  HANDLE _ParkerEvent;\n@@ -202,1 +197,9 @@\n-} ;\n+ public:\n+  PlatformParker() {\n+    _ParkerEvent = CreateEvent (NULL, true, false, NULL) ;\n+    guarantee(_ParkerEvent != NULL, \"invariant\") ;\n+  }\n+  ~PlatformParker() {\n+    CloseHandle(_ParkerEvent);\n+  }\n+};\n","filename":"src\/hotspot\/os\/windows\/os_windows.hpp","additions":14,"deletions":11,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -1004,2 +1004,0 @@\n-  Parker* p = NULL;\n-\n@@ -1015,1 +1013,3 @@\n-        p = thr->parker();\n+        Parker* p = thr->parker();\n+        HOTSPOT_THREAD_UNPARK((uintptr_t) p);\n+        p->unpark();\n@@ -1020,7 +1020,0 @@\n-  \/\/ 'p' points to type-stable-memory if non-NULL. If the target\n-  \/\/ thread terminates before we get here the new user of this\n-  \/\/ Parker will get a 'spurious' unpark - which is perfectly valid.\n-  if (p != NULL) {\n-    HOTSPOT_THREAD_UNPARK((uintptr_t) p);\n-    p->unpark();\n-  }\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":3,"deletions":10,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -115,52 +115,0 @@\n-\n-\n-\/\/ 6399321 As a temporary measure we copied & modified the ParkEvent::\n-\/\/ allocate() and release() code for use by Parkers.  The Parker:: forms\n-\/\/ will eventually be removed as we consolidate and shift over to ParkEvents\n-\/\/ for both builtin synchronization and JSR166 operations.\n-\n-volatile int Parker::ListLock = 0 ;\n-Parker * volatile Parker::FreeList = NULL ;\n-\n-Parker * Parker::Allocate (JavaThread * t) {\n-  guarantee (t != NULL, \"invariant\") ;\n-  Parker * p ;\n-\n-  \/\/ Start by trying to recycle an existing but unassociated\n-  \/\/ Parker from the global free list.\n-  \/\/ 8028280: using concurrent free list without memory management can leak\n-  \/\/ pretty badly it turns out.\n-  Thread::SpinAcquire(&ListLock, \"ParkerFreeListAllocate\");\n-  {\n-    p = FreeList;\n-    if (p != NULL) {\n-      FreeList = p->FreeNext;\n-    }\n-  }\n-  Thread::SpinRelease(&ListLock);\n-\n-  if (p != NULL) {\n-    guarantee (p->AssociatedWith == NULL, \"invariant\") ;\n-  } else {\n-    \/\/ Do this the hard way -- materialize a new Parker..\n-    p = new Parker() ;\n-  }\n-  p->AssociatedWith = t ;          \/\/ Associate p with t\n-  p->FreeNext       = NULL ;\n-  return p ;\n-}\n-\n-\n-void Parker::Release (Parker * p) {\n-  if (p == NULL) return ;\n-  guarantee (p->AssociatedWith != NULL, \"invariant\") ;\n-  guarantee (p->FreeNext == NULL      , \"invariant\") ;\n-  p->AssociatedWith = NULL ;\n-\n-  Thread::SpinAcquire(&ListLock, \"ParkerFreeListRelease\");\n-  {\n-    p->FreeNext = FreeList;\n-    FreeList = p;\n-  }\n-  Thread::SpinRelease(&ListLock);\n-}\n","filename":"src\/hotspot\/share\/runtime\/park.cpp","additions":1,"deletions":53,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+\n@@ -32,1 +33,1 @@\n- * Documentation for rationale. Basically, park acts like wait, unpark\n+ * documentation for rationale. Basically, park acts like wait, unpark\n@@ -35,6 +36,9 @@\n- * 6271289 --\n- * To avoid errors where an os thread expires but the JavaThread still\n- * exists, Parkers are immortal (type-stable) and are recycled across\n- * new threads.  This parallels the ParkEvent implementation.\n- * Because park-unpark allow spurious wakeups it is harmless if an\n- * unpark call unparks a new thread using the old Parker reference.\n+ * Parkers are inherently part of their associated JavaThread and are only\n+ * accessed when the JavaThread is guaranteed to be alive (e.g. by operating\n+ * on the current thread, or by having the thread protected by a\n+ * ThreadsListHandle.\n+ *\n+ * Class Parker is declared in shared code and extends the platform-specific\n+ * os::PlatformParker class, which contains the actual implementation\n+ * mechanics (condvars\/events etc). The implementation for park() and unpark()\n+ * are also in the platform-specific os_<os>.cpp files.\n@@ -49,4 +53,4 @@\n-private:\n-  volatile int _counter ;\n-  Parker * FreeNext ;\n-  JavaThread * AssociatedWith ; \/\/ Current association\n+ private:\n+  NONCOPYABLE(Parker);\n+ public:\n+  Parker() : PlatformParker() {}\n@@ -54,9 +58,0 @@\n-public:\n-  Parker() : PlatformParker() {\n-    _counter       = 0 ;\n-    FreeNext       = NULL ;\n-    AssociatedWith = NULL ;\n-  }\n-protected:\n-  ~Parker() { ShouldNotReachHere(); }\n-public:\n@@ -67,8 +62,0 @@\n-\n-  \/\/ Lifecycle operators\n-  static Parker * Allocate (JavaThread * t) ;\n-  static void Release (Parker * e) ;\n-private:\n-  static Parker * volatile FreeList ;\n-  static volatile int ListLock ;\n-\n","filename":"src\/hotspot\/share\/runtime\/park.hpp","additions":16,"deletions":29,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -1568,1 +1568,1 @@\n-  _parker(Parker::Allocate(this)),\n+  _parker(),\n@@ -1606,0 +1606,3 @@\n+  \/\/ All callers should have 'this' thread protected by a\n+  \/\/ ThreadsListHandle so that it cannot terminate and deallocate\n+  \/\/ itself.\n@@ -1703,4 +1706,0 @@\n-  \/\/ JSR166 -- return the parker to the free list\n-  Parker::Release(_parker);\n-  _parker = NULL;\n-\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -69,2 +69,0 @@\n-class ParkEvent;\n-class Parker;\n@@ -1857,1 +1855,1 @@\n-  Parker*    _parker;\n+  Parker _parker;\n@@ -1859,1 +1857,1 @@\n-  Parker*     parker() { return _parker; }\n+  Parker* parker() { return &_parker; }\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"}]}