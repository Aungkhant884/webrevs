{"files":[{"patch":"@@ -45,0 +45,1 @@\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n@@ -1315,0 +1316,32 @@\n+\/\/ Attempt to set the state to Native in VMError.\n+\/\/ By setting it to Native, it allows os::fork_and_exec to execute cmd such as jcmd %p.\n+\/\/ Otherwise, it may end up with a deadlock when cmd tries to synchronize all Java threads\n+\/\/ at safepoints.\n+class VMErrorThreadToNativeFromVM : public StackObj {\n+ private:\n+   JavaThread* _thread;\n+\n+ public:\n+  VMErrorThreadToNativeFromVM(Thread* t) : _thread(nullptr) {\n+    if (t != nullptr && t->is_Java_thread() &&\n+        !Threads_lock->owned_by_self()) { \/\/ VMError::controlled_crash() grabs Threads_lock.\n+      _thread = JavaThread::cast(t);\n+      assert(_thread == Thread::current(), \"must be current thread\");\n+      assert(_thread->thread_state() == _thread_in_vm, \"must be in VM\");\n+    }\n+\n+    if (_thread != nullptr) {\n+      assert(!_thread->owns_locks(), \"must release all locks when leaving VM\");\n+      ThreadStateTransition::transition_from_vm(_thread, _thread_in_native);\n+    }\n+  }\n+\n+  ~VMErrorThreadToNativeFromVM() {\n+    if (_thread != nullptr) {\n+      ThreadStateTransition::transition_from_native(_thread, _thread_in_vm);\n+      assert(!_thread->is_pending_jni_exception_check(), \"Pending JNI Exception Check\");\n+      \/\/ We don't need to clear_walkable because it will happen automagically when we return to java\n+    }\n+  }\n+};\n+\n@@ -1630,0 +1663,1 @@\n+      VMErrorThreadToNativeFromVM ttnfv(JavaThread::current_or_null());\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":34,"deletions":0,"binary":false,"changes":34,"status":"modified"}]}