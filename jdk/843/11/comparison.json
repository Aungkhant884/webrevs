{"files":[{"patch":"@@ -56,1 +56,6 @@\n-        super(new VarForm(value, coordinates));\n+        this(target, value, coordinates, handleFactory, new VarForm(value, coordinates), false);\n+    }\n+\n+    private IndirectVarHandle(VarHandle target, Class<?> value, Class<?>[] coordinates,\n+                      BiFunction<AccessMode, MethodHandle, MethodHandle> handleFactory, VarForm form, boolean exact) {\n+        super(form, exact);\n@@ -75,2 +80,2 @@\n-    MethodType accessModeTypeUncached(AccessMode accessMode) {\n-        return accessMode.at.accessModeType(directTarget.getClass(), value, coordinates);\n+    MethodType accessModeTypeUncached(AccessType at) {\n+        return at.accessModeType(null, value, coordinates);\n@@ -93,0 +98,14 @@\n+    @Override\n+    public VarHandle withInvokeExactBehavior() {\n+        return hasInvokeExactBehavior()\n+            ? this\n+            : new IndirectVarHandle(target, value, coordinates, handleFactory, vform, true);\n+    }\n+\n+    @Override\n+    public VarHandle withInvokeBehavior() {\n+        return !hasInvokeExactBehavior()\n+            ? this\n+            : new IndirectVarHandle(target, value, coordinates, handleFactory, vform, false);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/IndirectVarHandle.java","additions":22,"deletions":3,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.vm.annotation.Hidden;\n@@ -466,0 +467,1 @@\n+    @Hidden\n@@ -467,0 +469,4 @@\n+        if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/Invokers.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -45,2 +45,2 @@\n-    MemoryAccessVarHandleBase(VarForm form, boolean be, long length, long offset, long alignmentMask) {\n-        super(form);\n+    MemoryAccessVarHandleBase(VarForm form, boolean be, long length, long offset, long alignmentMask, boolean exact) {\n+        super(form, exact);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MemoryAccessVarHandleBase.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -74,0 +74,1 @@\n+import static jdk.internal.org.objectweb.asm.Opcodes.NEW;\n@@ -98,0 +99,6 @@\n+    private final static MethodType CONSTR_TYPE = MethodType.methodType(void.class, VarForm.class,\n+            boolean.class, long.class, long.class, long.class, boolean.class, long[].class);\n+    \/\/ MemoryAccessVarHandleBase\n+    private final static MethodType SUPER_CONTR_TYPE = MethodType.methodType(void.class, VarForm.class,\n+            boolean.class, long.class, long.class, long.class, boolean.class);\n+\n@@ -143,1 +150,1 @@\n-        this.implClassName = helperClass.getName().replace('.', '\/') + dimensions;\n+        this.implClassName = internalName(helperClass) + dimensions;\n@@ -167,2 +174,1 @@\n-            MethodType constrType = MethodType.methodType(void.class, VarForm.class, boolean.class, long.class, long.class, long.class, long[].class);\n-            MethodHandle constr = lookup.findConstructor(implCls, constrType);\n+            MethodHandle constr = lookup.findConstructor(implCls, CONSTR_TYPE);\n@@ -205,0 +211,3 @@\n+        addAsExact(cw);\n+        addAsGeneric(cw);\n+\n@@ -256,2 +265,1 @@\n-        MethodType constrType = MethodType.methodType(void.class, VarForm.class, boolean.class, long.class, long.class, long.class, long[].class);\n-        MethodVisitor mv = cw.visitMethod(0, \"<init>\", constrType.toMethodDescriptorString(), null, null);\n+        MethodVisitor mv = cw.visitMethod(0, \"<init>\", CONSTR_TYPE.toMethodDescriptorString(), null, null);\n@@ -261,1 +269,1 @@\n-        mv.visitVarInsn(ALOAD, 1);\n+        mv.visitVarInsn(ALOAD, 1); \/\/ vform\n@@ -263,4 +271,5 @@\n-        mv.visitVarInsn(ILOAD, 2);\n-        mv.visitVarInsn(LLOAD, 3);\n-        mv.visitVarInsn(LLOAD, 5);\n-        mv.visitVarInsn(LLOAD, 7);\n+        mv.visitVarInsn(ILOAD, 2); \/\/ be\n+        mv.visitVarInsn(LLOAD, 3); \/\/ length\n+        mv.visitVarInsn(LLOAD, 5); \/\/ offset\n+        mv.visitVarInsn(LLOAD, 7); \/\/ alignmentMask\n+        mv.visitVarInsn(ILOAD, 9); \/\/ exact\n@@ -268,1 +277,1 @@\n-                MethodType.methodType(void.class, VarForm.class, boolean.class, long.class, long.class, long.class).toMethodDescriptorString(), false);\n+                SUPER_CONTR_TYPE.toMethodDescriptorString(), false);\n@@ -272,1 +281,1 @@\n-            mv.visitVarInsn(ALOAD, 9);\n+            mv.visitVarInsn(ALOAD, 10);\n@@ -283,1 +292,1 @@\n-        MethodType modeMethType = MethodType.methodType(MethodType.class, VarHandle.AccessMode.class);\n+        MethodType modeMethType = MethodType.methodType(MethodType.class, VarHandle.AccessType.class);\n@@ -287,1 +296,0 @@\n-        mv.visitFieldInsn(GETFIELD, Type.getInternalName(VarHandle.AccessMode.class), \"at\", VarHandle.AccessType.class.descriptorString());\n@@ -412,0 +420,32 @@\n+    private void addAsExact(ClassWriter cw) {\n+        addAsExactOrAsGeneric(cw, \"asExact\", true);\n+    }\n+\n+    private void addAsGeneric(ClassWriter cw) {\n+        addAsExactOrAsGeneric(cw, \"asGeneric\", false);\n+    }\n+\n+    private void addAsExactOrAsGeneric(ClassWriter cw, String name, boolean exact) {\n+        MethodVisitor mv = cw.visitMethod(ACC_FINAL, name, \"()Ljava\/lang\/invoke\/VarHandle;\", null, null);\n+        mv.visitCode();\n+        mv.visitTypeInsn(NEW, implClassName);\n+        mv.visitInsn(DUP);\n+        mv.visitVarInsn(ALOAD, 0);\n+        mv.visitFieldInsn(GETFIELD, internalName(VarHandle.class), \"vform\", VarForm.class.descriptorString());\n+        mv.visitVarInsn(ALOAD, 0);\n+        mv.visitFieldInsn(GETFIELD, internalName(MemoryAccessVarHandleBase.class), \"be\", boolean.class.descriptorString());\n+        mv.visitVarInsn(ALOAD, 0);\n+        mv.visitFieldInsn(GETFIELD, internalName(MemoryAccessVarHandleBase.class), \"length\", long.class.descriptorString());\n+        mv.visitVarInsn(ALOAD, 0);\n+        mv.visitFieldInsn(GETFIELD, internalName(MemoryAccessVarHandleBase.class), \"offset\", long.class.descriptorString());\n+        mv.visitVarInsn(ALOAD, 0);\n+        mv.visitFieldInsn(GETFIELD, internalName(MemoryAccessVarHandleBase.class), \"alignmentMask\", long.class.descriptorString());\n+        mv.visitIntInsn(BIPUSH, exact ? 1 : 0);\n+        mv.visitVarInsn(ALOAD, 0);\n+        mv.visitMethodInsn(INVOKEVIRTUAL, implClassName, \"strides\", \"()[J\", false);\n+        mv.visitMethodInsn(INVOKESPECIAL, implClassName, \"<init>\", CONSTR_TYPE.descriptorString(), false);\n+        mv.visitInsn(ARETURN);\n+        mv.visitMaxs(0, 0);\n+        mv.visitEnd();\n+    }\n+\n@@ -421,0 +461,4 @@\n+    private static String internalName(Class<?> cls) {\n+        return cls.getName().replace('.', '\/');\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MemoryAccessVarHandleGenerator.java","additions":58,"deletions":14,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -285,2 +285,2 @@\n- * <p>\n- * Invocation of an access mode method behaves as if an invocation of\n+ * <p id=\"invoke-behavior\">\n+ * Invocation of an access mode method behaves, by default, as if an invocation of\n@@ -321,1 +321,1 @@\n- * More concisely, such behaviour is equivalent to:\n+ * More concisely, such behavior is equivalent to:\n@@ -331,0 +331,31 @@\n+ * <p id=\"invoke-exact-behavior\">\n+ * A VarHandle's invocation behavior can be adjusted (see {@link #withInvokeExactBehavior}) such that invocation of\n+ * an access mode method behaves as if invocation of {@link MethodHandle#invokeExact},\n+ * where the receiving method handle accepts the VarHandle instance as the leading argument.\n+ * More specifically, the following, where {@code {access-mode}} corresponds to the access mode method\n+ * name:\n+ * <pre> {@code\n+ * VarHandle vh = ..\n+ * R r = (R) vh.{access-mode}(p1, p2, ..., pN);\n+ * }<\/pre>\n+ * behaves as if:\n+ * <pre> {@code\n+ * VarHandle vh = ..\n+ * VarHandle.AccessMode am = VarHandle.AccessMode.valueFromMethodName(\"{access-mode}\");\n+ * MethodHandle mh = MethodHandles.varHandleExactInvoker(\n+ *                       am,\n+ *                       vh.accessModeType(am));\n+ *\n+ * R r = (R) mh.invokeExact(vh, p1, p2, ..., pN)\n+ * }<\/pre>\n+ * (modulo access mode methods do not declare throwing of {@code Throwable}).\n+ *\n+ * More concisely, such behavior is equivalent to:\n+ * <pre> {@code\n+ * VarHandle vh = ..\n+ * VarHandle.AccessMode am = VarHandle.AccessMode.valueFromMethodName(\"{access-mode}\");\n+ * MethodHandle mh = vh.toMethodHandle(am);\n+ *\n+ * R r = (R) mh.invokeExact(p1, p2, ..., pN)\n+ * }<\/pre>\n+ * Where, in this case, the method handle is bound to the VarHandle instance.\n@@ -428,1 +459,1 @@\n- * any specified access mode type and is equivalent in behaviour to\n+ * any specified access mode type and is equivalent in behavior to\n@@ -449,0 +480,1 @@\n+    final boolean exact;\n@@ -451,0 +483,4 @@\n+        this(vform, false);\n+    }\n+\n+    VarHandle(VarForm vform, boolean exact) {\n@@ -452,0 +488,1 @@\n+        this.exact = exact;\n@@ -468,0 +505,12 @@\n+    \/**\n+     * Returns {@code true} if this VarHandle has <a href=\"#invoke-exact-behavior\"><em>invoke-exact behavior<\/em><\/a>.\n+     *\n+     * @see #withInvokeExactBehavior()\n+     * @see #withInvokeBehavior()\n+     * @return {@code true} if this VarHandle has <a href=\"#invoke-exact-behavior\"><em>invoke-exact behavior<\/em><\/a>.\n+     * @since 16\n+     *\/\n+    public boolean hasInvokeExactBehavior() {\n+        return exact;\n+    }\n+\n@@ -1544,0 +1593,31 @@\n+    \/**\n+     * Returns a VarHandle, with access to the same variable(s) as this VarHandle, but whose\n+     * invocation behavior of access mode methods is adjusted to\n+     * <a href=\"#invoke-exact-behavior\"><em>invoke-exact behavior<\/em><\/a>.\n+     * <p>\n+     * If this VarHandle already has invoke-exact behavior this VarHandle is returned.\n+     * @apiNote\n+     * Invoke-exact behavior guarantees that that upon invocation of an access mode method\n+     * the types and arity of the arguments must match the {@link #accessModeType(AccessMode) access mode type},\n+     * otherwise a {@link WrongMethodTypeException} is thrown.\n+     *\n+     * @see #withInvokeBehavior()\n+     * @see #hasInvokeExactBehavior()\n+     * @return a VarHandle with invoke-exact behavior\n+     * @since 16\n+     *\/\n+    public abstract VarHandle withInvokeExactBehavior();\n+\n+    \/**\n+     * Returns a VarHandle, with access to the same variable(s) as this VarHandle, but whose\n+     * invocation behavior of access mode methods is adjusted to\n+     * <a href=\"#invoke-behavior\"><em>invoke behavior<\/em><\/a>.\n+     * <p>\n+     * If this VarHandle already has invoke behavior this VarHandle is returned.\n+     *\n+     * @see #withInvokeExactBehavior()\n+     * @see #hasInvokeExactBehavior()\n+     * @return a VarHandle with invoke behavior\n+     * @since 16\n+     *\/\n+    public abstract VarHandle withInvokeBehavior();\n@@ -1862,0 +1942,1 @@\n+        final MethodType symbolicMethodTypeExact;\n@@ -1869,0 +1950,1 @@\n+            this.symbolicMethodTypeExact = symbolicMethodType;\n@@ -1925,0 +2007,5 @@\n+        return accessModeType(accessMode.at.ordinal());\n+    }\n+\n+    @ForceInline\n+    final MethodType accessModeType(int accessTypeOrdinal) {\n@@ -1926,1 +2013,1 @@\n-        MethodType mt = tis.methodType_table[accessMode.at.ordinal()];\n+        MethodType mt = tis.methodType_table[accessTypeOrdinal];\n@@ -1928,2 +2015,2 @@\n-            mt = tis.methodType_table[accessMode.at.ordinal()] =\n-                    accessModeTypeUncached(accessMode);\n+            mt = tis.methodType_table[accessTypeOrdinal] =\n+                    accessModeTypeUncached(accessTypeOrdinal);\n@@ -1933,1 +2020,6 @@\n-    abstract MethodType accessModeTypeUncached(AccessMode accessMode);\n+\n+    final MethodType accessModeTypeUncached(int accessTypeOrdinal) {\n+        return accessModeTypeUncached(AccessType.values()[accessTypeOrdinal]);\n+    }\n+\n+    abstract MethodType accessModeTypeUncached(AccessType accessMode);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandle.java","additions":100,"deletions":8,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import jdk.internal.vm.annotation.Hidden;\n@@ -34,0 +35,1 @@\n+    @Hidden\n@@ -35,0 +37,4 @@\n+        if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n+        }\n@@ -38,2 +44,1 @@\n-        }\n-        else {\n+        } else {\n@@ -47,0 +52,1 @@\n+    @Hidden\n@@ -48,0 +54,4 @@\n+        if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n+        }\n@@ -50,2 +60,1 @@\n-        }\n-        else if (handle.isDirect() && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n+        } else if (handle.isDirect() && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n@@ -53,2 +62,1 @@\n-        }\n-        else {\n+        } else {\n@@ -62,4 +70,5 @@\n-    final static Object guard_LL_L(VarHandle handle, Object arg0, Object arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n-        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            Object r = MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n-            return ad.returnType.cast(r);\n+    @Hidden\n+    final static boolean guard_LLL_Z(VarHandle handle, Object arg0, Object arg1, Object arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n@@ -67,1 +76,3 @@\n-        else {\n+        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+        } else {\n@@ -69,1 +80,1 @@\n-            return mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n+            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n@@ -75,3 +86,5 @@\n-    final static boolean guard_LLL_Z(VarHandle handle, Object arg0, Object arg1, Object arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+    @Hidden\n+    final static Object guard_LLL_L(VarHandle handle, Object arg0, Object arg1, Object arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n@@ -79,1 +92,4 @@\n-        else {\n+        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            Object r = MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+            return ad.returnType.cast(r);\n+        } else {\n@@ -81,1 +97,1 @@\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+            return mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n@@ -87,1 +103,6 @@\n-    final static Object guard_LLL_L(VarHandle handle, Object arg0, Object arg1, Object arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+    @Hidden\n+    final static Object guard_LL_L(VarHandle handle, Object arg0, Object arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n+        }\n@@ -89,1 +110,1 @@\n-            Object r = MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+            Object r = MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n@@ -91,2 +112,1 @@\n-        }\n-        else {\n+        } else {\n@@ -94,1 +114,1 @@\n-            return mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+            return mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n@@ -100,0 +120,1 @@\n+    @Hidden\n@@ -101,0 +122,4 @@\n+        if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n+        }\n@@ -103,2 +128,1 @@\n-        }\n-        else {\n+        } else {\n@@ -112,0 +136,1 @@\n+    @Hidden\n@@ -113,0 +138,4 @@\n+        if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n+        }\n@@ -115,2 +144,1 @@\n-        }\n-        else if (handle.isDirect() && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n+        } else if (handle.isDirect() && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n@@ -118,2 +146,1 @@\n-        }\n-        else {\n+        } else {\n@@ -127,3 +154,5 @@\n-    final static int guard_LI_I(VarHandle handle, Object arg0, int arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n-        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (int) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n+    @Hidden\n+    final static boolean guard_LII_Z(VarHandle handle, Object arg0, int arg1, int arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n@@ -131,1 +160,3 @@\n-        else {\n+        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+        } else {\n@@ -133,1 +164,1 @@\n-            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n+            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n@@ -139,3 +170,5 @@\n-    final static boolean guard_LII_Z(VarHandle handle, Object arg0, int arg1, int arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+    @Hidden\n+    final static int guard_LII_I(VarHandle handle, Object arg0, int arg1, int arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n@@ -143,1 +176,3 @@\n-        else {\n+        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (int) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+        } else {\n@@ -145,1 +180,1 @@\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n@@ -151,3 +186,5 @@\n-    final static int guard_LII_I(VarHandle handle, Object arg0, int arg1, int arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (int) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+    @Hidden\n+    final static int guard_LI_I(VarHandle handle, Object arg0, int arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n@@ -155,1 +192,3 @@\n-        else {\n+        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (int) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n+        } else {\n@@ -157,1 +196,1 @@\n-            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n@@ -163,0 +202,1 @@\n+    @Hidden\n@@ -164,0 +204,4 @@\n+        if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n+        }\n@@ -166,2 +210,1 @@\n-        }\n-        else {\n+        } else {\n@@ -175,0 +218,1 @@\n+    @Hidden\n@@ -176,0 +220,4 @@\n+        if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n+        }\n@@ -178,2 +226,1 @@\n-        }\n-        else if (handle.isDirect() && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n+        } else if (handle.isDirect() && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n@@ -181,2 +228,1 @@\n-        }\n-        else {\n+        } else {\n@@ -190,3 +236,5 @@\n-    final static long guard_LJ_J(VarHandle handle, Object arg0, long arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n-        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (long) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n+    @Hidden\n+    final static boolean guard_LJJ_Z(VarHandle handle, Object arg0, long arg1, long arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n@@ -194,1 +242,3 @@\n-        else {\n+        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+        } else {\n@@ -196,1 +246,1 @@\n-            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n+            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n@@ -202,3 +252,5 @@\n-    final static boolean guard_LJJ_Z(VarHandle handle, Object arg0, long arg1, long arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+    @Hidden\n+    final static long guard_LJJ_J(VarHandle handle, Object arg0, long arg1, long arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n@@ -206,1 +258,3 @@\n-        else {\n+        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (long) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+        } else {\n@@ -208,1 +262,1 @@\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n@@ -214,3 +268,5 @@\n-    final static long guard_LJJ_J(VarHandle handle, Object arg0, long arg1, long arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (long) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+    @Hidden\n+    final static long guard_LJ_J(VarHandle handle, Object arg0, long arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n@@ -218,1 +274,3 @@\n-        else {\n+        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (long) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n+        } else {\n@@ -220,1 +278,1 @@\n-            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n@@ -226,0 +284,1 @@\n+    @Hidden\n@@ -227,0 +286,4 @@\n+        if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n+        }\n@@ -229,2 +292,1 @@\n-        }\n-        else {\n+        } else {\n@@ -238,0 +300,1 @@\n+    @Hidden\n@@ -239,0 +302,4 @@\n+        if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n+        }\n@@ -241,2 +308,1 @@\n-        }\n-        else if (handle.isDirect() && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n+        } else if (handle.isDirect() && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n@@ -244,2 +310,1 @@\n-        }\n-        else {\n+        } else {\n@@ -253,3 +318,5 @@\n-    final static float guard_LF_F(VarHandle handle, Object arg0, float arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n-        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (float) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n+    @Hidden\n+    final static boolean guard_LFF_Z(VarHandle handle, Object arg0, float arg1, float arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n@@ -257,1 +324,3 @@\n-        else {\n+        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+        } else {\n@@ -259,1 +328,1 @@\n-            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n+            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n@@ -265,3 +334,5 @@\n-    final static boolean guard_LFF_Z(VarHandle handle, Object arg0, float arg1, float arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+    @Hidden\n+    final static float guard_LFF_F(VarHandle handle, Object arg0, float arg1, float arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n@@ -269,1 +340,3 @@\n-        else {\n+        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (float) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+        } else {\n@@ -271,1 +344,1 @@\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n@@ -277,3 +350,5 @@\n-    final static float guard_LFF_F(VarHandle handle, Object arg0, float arg1, float arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (float) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+    @Hidden\n+    final static float guard_LF_F(VarHandle handle, Object arg0, float arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n@@ -281,1 +356,3 @@\n-        else {\n+        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (float) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n+        } else {\n@@ -283,1 +360,1 @@\n-            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n@@ -289,0 +366,1 @@\n+    @Hidden\n@@ -290,0 +368,4 @@\n+        if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n+        }\n@@ -292,2 +374,1 @@\n-        }\n-        else {\n+        } else {\n@@ -301,0 +382,1 @@\n+    @Hidden\n@@ -302,0 +384,4 @@\n+        if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n+        }\n@@ -304,2 +390,1 @@\n-        }\n-        else if (handle.isDirect() && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n+        } else if (handle.isDirect() && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n@@ -307,2 +392,1 @@\n-        }\n-        else {\n+        } else {\n@@ -316,3 +400,5 @@\n-    final static double guard_LD_D(VarHandle handle, Object arg0, double arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n-        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (double) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n+    @Hidden\n+    final static boolean guard_LDD_Z(VarHandle handle, Object arg0, double arg1, double arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n@@ -320,1 +406,3 @@\n-        else {\n+        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+        } else {\n@@ -322,1 +410,1 @@\n-            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n+            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n@@ -328,3 +416,5 @@\n-    final static boolean guard_LDD_Z(VarHandle handle, Object arg0, double arg1, double arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+    @Hidden\n+    final static double guard_LDD_D(VarHandle handle, Object arg0, double arg1, double arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n@@ -332,1 +422,3 @@\n-        else {\n+        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (double) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+        } else {\n@@ -334,1 +426,1 @@\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n@@ -340,3 +432,5 @@\n-    final static double guard_LDD_D(VarHandle handle, Object arg0, double arg1, double arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (double) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+    @Hidden\n+    final static double guard_LD_D(VarHandle handle, Object arg0, double arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n@@ -344,1 +438,3 @@\n-        else {\n+        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (double) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n+        } else {\n@@ -346,1 +442,1 @@\n-            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n@@ -352,0 +448,1 @@\n+    @Hidden\n@@ -353,0 +450,4 @@\n+        if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n+        }\n@@ -356,2 +457,1 @@\n-        }\n-        else {\n+        } else {\n@@ -365,0 +465,1 @@\n+    @Hidden\n@@ -366,0 +467,4 @@\n+        if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n+        }\n@@ -368,2 +473,1 @@\n-        }\n-        else if (handle.isDirect() && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n+        } else if (handle.isDirect() && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n@@ -371,2 +475,1 @@\n-        }\n-        else {\n+        } else {\n@@ -380,0 +483,1 @@\n+    @Hidden\n@@ -381,0 +485,4 @@\n+        if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n+        }\n@@ -383,2 +491,1 @@\n-        }\n-        else {\n+        } else {\n@@ -392,0 +499,1 @@\n+    @Hidden\n@@ -393,0 +501,4 @@\n+        if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n+        }\n@@ -395,2 +507,1 @@\n-        }\n-        else {\n+        } else {\n@@ -404,0 +515,1 @@\n+    @Hidden\n@@ -405,0 +517,4 @@\n+        if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n+        }\n@@ -407,2 +523,1 @@\n-        }\n-        else if (handle.isDirect() && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n+        } else if (handle.isDirect() && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n@@ -410,2 +525,1 @@\n-        }\n-        else {\n+        } else {\n@@ -419,3 +533,5 @@\n-    final static int guard_I_I(VarHandle handle, int arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n-        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (int) MethodHandle.linkToStatic(handle, arg0, handle.vform.getMemberName(ad.mode));\n+    @Hidden\n+    final static boolean guard_II_Z(VarHandle handle, int arg0, int arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n@@ -423,1 +539,3 @@\n-        else {\n+        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n+        } else {\n@@ -425,1 +543,1 @@\n-            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0);\n+            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n@@ -431,3 +549,5 @@\n-    final static boolean guard_II_Z(VarHandle handle, int arg0, int arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n-        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n+    @Hidden\n+    final static int guard_II_I(VarHandle handle, int arg0, int arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n@@ -435,1 +555,3 @@\n-        else {\n+        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (int) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n+        } else {\n@@ -437,1 +559,1 @@\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n+            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n@@ -443,3 +565,5 @@\n-    final static int guard_II_I(VarHandle handle, int arg0, int arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n-        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (int) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n+    @Hidden\n+    final static int guard_I_I(VarHandle handle, int arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n@@ -447,1 +571,3 @@\n-        else {\n+        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (int) MethodHandle.linkToStatic(handle, arg0, handle.vform.getMemberName(ad.mode));\n+        } else {\n@@ -449,1 +575,1 @@\n-            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n+            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0);\n@@ -455,0 +581,1 @@\n+    @Hidden\n@@ -456,0 +583,4 @@\n+        if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n+        }\n@@ -458,2 +589,1 @@\n-        }\n-        else {\n+        } else {\n@@ -467,0 +597,1 @@\n+    @Hidden\n@@ -468,0 +599,4 @@\n+        if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n+        }\n@@ -470,2 +605,1 @@\n-        }\n-        else if (handle.isDirect() && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n+        } else if (handle.isDirect() && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n@@ -473,2 +607,1 @@\n-        }\n-        else {\n+        } else {\n@@ -482,3 +615,5 @@\n-    final static long guard_J_J(VarHandle handle, long arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n-        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (long) MethodHandle.linkToStatic(handle, arg0, handle.vform.getMemberName(ad.mode));\n+    @Hidden\n+    final static boolean guard_JJ_Z(VarHandle handle, long arg0, long arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n@@ -486,1 +621,3 @@\n-        else {\n+        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n+        } else {\n@@ -488,1 +625,1 @@\n-            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0);\n+            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n@@ -494,3 +631,5 @@\n-    final static boolean guard_JJ_Z(VarHandle handle, long arg0, long arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n-        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n+    @Hidden\n+    final static long guard_JJ_J(VarHandle handle, long arg0, long arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n@@ -498,1 +637,3 @@\n-        else {\n+        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (long) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n+        } else {\n@@ -500,1 +641,1 @@\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n+            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n@@ -506,3 +647,5 @@\n-    final static long guard_JJ_J(VarHandle handle, long arg0, long arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n-        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (long) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n+    @Hidden\n+    final static long guard_J_J(VarHandle handle, long arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n@@ -510,1 +653,3 @@\n-        else {\n+        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (long) MethodHandle.linkToStatic(handle, arg0, handle.vform.getMemberName(ad.mode));\n+        } else {\n@@ -512,1 +657,1 @@\n-            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n+            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0);\n@@ -518,0 +663,1 @@\n+    @Hidden\n@@ -519,0 +665,4 @@\n+        if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n+        }\n@@ -521,2 +671,1 @@\n-        }\n-        else {\n+        } else {\n@@ -530,0 +679,1 @@\n+    @Hidden\n@@ -531,0 +681,4 @@\n+        if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n+        }\n@@ -533,2 +687,1 @@\n-        }\n-        else if (handle.isDirect() && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n+        } else if (handle.isDirect() && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n@@ -536,2 +689,1 @@\n-        }\n-        else {\n+        } else {\n@@ -545,3 +697,5 @@\n-    final static float guard_F_F(VarHandle handle, float arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n-        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (float) MethodHandle.linkToStatic(handle, arg0, handle.vform.getMemberName(ad.mode));\n+    @Hidden\n+    final static boolean guard_FF_Z(VarHandle handle, float arg0, float arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n@@ -549,1 +703,3 @@\n-        else {\n+        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n+        } else {\n@@ -551,1 +707,1 @@\n-            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0);\n+            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n@@ -557,3 +713,5 @@\n-    final static boolean guard_FF_Z(VarHandle handle, float arg0, float arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n-        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n+    @Hidden\n+    final static float guard_FF_F(VarHandle handle, float arg0, float arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n@@ -561,1 +719,3 @@\n-        else {\n+        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (float) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n+        } else {\n@@ -563,1 +723,1 @@\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n+            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n@@ -569,3 +729,5 @@\n-    final static float guard_FF_F(VarHandle handle, float arg0, float arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n-        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (float) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n+    @Hidden\n+    final static float guard_F_F(VarHandle handle, float arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n@@ -573,1 +735,3 @@\n-        else {\n+        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (float) MethodHandle.linkToStatic(handle, arg0, handle.vform.getMemberName(ad.mode));\n+        } else {\n@@ -575,1 +739,1 @@\n-            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n+            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0);\n@@ -581,0 +745,1 @@\n+    @Hidden\n@@ -582,0 +747,4 @@\n+        if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n+        }\n@@ -584,2 +753,1 @@\n-        }\n-        else {\n+        } else {\n@@ -593,0 +761,1 @@\n+    @Hidden\n@@ -594,0 +763,4 @@\n+        if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n+        }\n@@ -596,2 +769,1 @@\n-        }\n-        else if (handle.isDirect() && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n+        } else if (handle.isDirect() && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n@@ -599,2 +771,1 @@\n-        }\n-        else {\n+        } else {\n@@ -608,3 +779,5 @@\n-    final static double guard_D_D(VarHandle handle, double arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n-        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (double) MethodHandle.linkToStatic(handle, arg0, handle.vform.getMemberName(ad.mode));\n+    @Hidden\n+    final static boolean guard_DD_Z(VarHandle handle, double arg0, double arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n@@ -612,1 +785,3 @@\n-        else {\n+        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n+        } else {\n@@ -614,1 +789,1 @@\n-            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0);\n+            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n@@ -620,3 +795,5 @@\n-    final static boolean guard_DD_Z(VarHandle handle, double arg0, double arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n-        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n+    @Hidden\n+    final static double guard_DD_D(VarHandle handle, double arg0, double arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n@@ -624,1 +801,3 @@\n-        else {\n+        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (double) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n+        } else {\n@@ -626,1 +805,1 @@\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n+            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n@@ -632,3 +811,5 @@\n-    final static double guard_DD_D(VarHandle handle, double arg0, double arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n-        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (double) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n+    @Hidden\n+    final static double guard_D_D(VarHandle handle, double arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n@@ -636,1 +817,3 @@\n-        else {\n+        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (double) MethodHandle.linkToStatic(handle, arg0, handle.vform.getMemberName(ad.mode));\n+        } else {\n@@ -638,1 +821,1 @@\n-            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n+            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0);\n@@ -644,0 +827,1 @@\n+    @Hidden\n@@ -645,0 +829,4 @@\n+        if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n+        }\n@@ -648,2 +836,1 @@\n-        }\n-        else {\n+        } else {\n@@ -657,0 +844,1 @@\n+    @Hidden\n@@ -658,0 +846,4 @@\n+        if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n+        }\n@@ -660,2 +852,1 @@\n-        }\n-        else if (handle.isDirect() && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n+        } else if (handle.isDirect() && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n@@ -663,2 +854,1 @@\n-        }\n-        else {\n+        } else {\n@@ -672,4 +862,5 @@\n-    final static Object guard_LIL_L(VarHandle handle, Object arg0, int arg1, Object arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            Object r = MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-            return ad.returnType.cast(r);\n+    @Hidden\n+    final static boolean guard_LILL_Z(VarHandle handle, Object arg0, int arg1, Object arg2, Object arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n@@ -677,1 +868,3 @@\n-        else {\n+        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n+        } else {\n@@ -679,1 +872,1 @@\n-            return mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n@@ -685,3 +878,5 @@\n-    final static boolean guard_LILL_Z(VarHandle handle, Object arg0, int arg1, Object arg2, Object arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n-        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n+    @Hidden\n+    final static Object guard_LILL_L(VarHandle handle, Object arg0, int arg1, Object arg2, Object arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n@@ -689,1 +884,4 @@\n-        else {\n+        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            Object r = MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n+            return ad.returnType.cast(r);\n+        } else {\n@@ -691,1 +889,1 @@\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n+            return mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n@@ -697,1 +895,6 @@\n-    final static Object guard_LILL_L(VarHandle handle, Object arg0, int arg1, Object arg2, Object arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n+    @Hidden\n+    final static Object guard_LIL_L(VarHandle handle, Object arg0, int arg1, Object arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n+        }\n@@ -699,1 +902,1 @@\n-            Object r = MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n+            Object r = MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n@@ -701,2 +904,1 @@\n-        }\n-        else {\n+        } else {\n@@ -704,1 +906,1 @@\n-            return mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n+            return mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n@@ -710,0 +912,1 @@\n+    @Hidden\n@@ -711,0 +914,4 @@\n+        if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n+        }\n@@ -713,2 +920,1 @@\n-        }\n-        else if (handle.isDirect() && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n+        } else if (handle.isDirect() && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n@@ -716,2 +922,1 @@\n-        }\n-        else {\n+        } else {\n@@ -725,0 +930,1 @@\n+    @Hidden\n@@ -726,0 +932,4 @@\n+        if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n+        }\n@@ -728,2 +938,1 @@\n-        }\n-        else {\n+        } else {\n@@ -737,0 +946,1 @@\n+    @Hidden\n@@ -738,0 +948,4 @@\n+        if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n+        }\n@@ -740,2 +954,1 @@\n-        }\n-        else {\n+        } else {\n@@ -749,0 +962,1 @@\n+    @Hidden\n@@ -750,0 +964,4 @@\n+        if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n+        }\n@@ -752,2 +970,1 @@\n-        }\n-        else {\n+        } else {\n@@ -761,0 +978,1 @@\n+    @Hidden\n@@ -762,0 +980,4 @@\n+        if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n+        }\n@@ -764,2 +986,1 @@\n-        }\n-        else if (handle.isDirect() && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n+        } else if (handle.isDirect() && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n@@ -767,2 +988,1 @@\n-        }\n-        else {\n+        } else {\n@@ -776,3 +996,5 @@\n-    final static long guard_LIJ_J(VarHandle handle, Object arg0, int arg1, long arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (long) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+    @Hidden\n+    final static boolean guard_LIJJ_Z(VarHandle handle, Object arg0, int arg1, long arg2, long arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n@@ -780,1 +1002,3 @@\n-        else {\n+        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n+        } else {\n@@ -782,1 +1006,1 @@\n-            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n@@ -788,3 +1012,5 @@\n-    final static boolean guard_LIJJ_Z(VarHandle handle, Object arg0, int arg1, long arg2, long arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n-        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n+    @Hidden\n+    final static long guard_LIJJ_J(VarHandle handle, Object arg0, int arg1, long arg2, long arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n@@ -792,1 +1018,3 @@\n-        else {\n+        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (long) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n+        } else {\n@@ -794,1 +1022,1 @@\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n+            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n@@ -800,3 +1028,5 @@\n-    final static long guard_LIJJ_J(VarHandle handle, Object arg0, int arg1, long arg2, long arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n-        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (long) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n+    @Hidden\n+    final static long guard_LIJ_J(VarHandle handle, Object arg0, int arg1, long arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n@@ -804,1 +1034,3 @@\n-        else {\n+        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (long) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+        } else {\n@@ -806,1 +1038,1 @@\n-            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n+            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n@@ -812,0 +1044,1 @@\n+    @Hidden\n@@ -813,0 +1046,4 @@\n+        if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n+        }\n@@ -815,2 +1052,1 @@\n-        }\n-        else {\n+        } else {\n@@ -824,0 +1060,1 @@\n+    @Hidden\n@@ -825,0 +1062,4 @@\n+        if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n+        }\n@@ -827,2 +1068,1 @@\n-        }\n-        else if (handle.isDirect() && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n+        } else if (handle.isDirect() && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n@@ -830,2 +1070,1 @@\n-        }\n-        else {\n+        } else {\n@@ -839,3 +1078,5 @@\n-    final static float guard_LIF_F(VarHandle handle, Object arg0, int arg1, float arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (float) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+    @Hidden\n+    final static boolean guard_LIFF_Z(VarHandle handle, Object arg0, int arg1, float arg2, float arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n@@ -843,1 +1084,3 @@\n-        else {\n+        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n+        } else {\n@@ -845,1 +1088,1 @@\n-            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n@@ -851,3 +1094,5 @@\n-    final static boolean guard_LIFF_Z(VarHandle handle, Object arg0, int arg1, float arg2, float arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n-        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n+    @Hidden\n+    final static float guard_LIFF_F(VarHandle handle, Object arg0, int arg1, float arg2, float arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n@@ -855,1 +1100,3 @@\n-        else {\n+        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (float) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n+        } else {\n@@ -857,1 +1104,1 @@\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n+            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n@@ -863,3 +1110,5 @@\n-    final static float guard_LIFF_F(VarHandle handle, Object arg0, int arg1, float arg2, float arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n-        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (float) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n+    @Hidden\n+    final static float guard_LIF_F(VarHandle handle, Object arg0, int arg1, float arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n@@ -867,1 +1116,3 @@\n-        else {\n+        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (float) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+        } else {\n@@ -869,1 +1120,1 @@\n-            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n+            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n@@ -875,0 +1126,1 @@\n+    @Hidden\n@@ -876,0 +1128,4 @@\n+        if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n+        }\n@@ -878,2 +1134,1 @@\n-        }\n-        else {\n+        } else {\n@@ -887,0 +1142,1 @@\n+    @Hidden\n@@ -888,0 +1144,4 @@\n+        if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n+        }\n@@ -890,2 +1150,1 @@\n-        }\n-        else if (handle.isDirect() && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n+        } else if (handle.isDirect() && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n@@ -893,2 +1152,1 @@\n-        }\n-        else {\n+        } else {\n@@ -902,3 +1160,5 @@\n-    final static double guard_LID_D(VarHandle handle, Object arg0, int arg1, double arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (double) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+    @Hidden\n+    final static boolean guard_LIDD_Z(VarHandle handle, Object arg0, int arg1, double arg2, double arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n@@ -906,1 +1166,3 @@\n-        else {\n+        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n+        } else {\n@@ -908,1 +1170,1 @@\n-            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n@@ -914,3 +1176,5 @@\n-    final static boolean guard_LIDD_Z(VarHandle handle, Object arg0, int arg1, double arg2, double arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n-        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n+    @Hidden\n+    final static double guard_LIDD_D(VarHandle handle, Object arg0, int arg1, double arg2, double arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n@@ -918,1 +1182,3 @@\n-        else {\n+        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (double) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n+        } else {\n@@ -920,1 +1186,1 @@\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n+            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n@@ -926,3 +1192,5 @@\n-    final static double guard_LIDD_D(VarHandle handle, Object arg0, int arg1, double arg2, double arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n-        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (double) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n+    @Hidden\n+    final static double guard_LID_D(VarHandle handle, Object arg0, int arg1, double arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n@@ -930,1 +1198,3 @@\n-        else {\n+        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (double) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+        } else {\n@@ -932,1 +1202,1 @@\n-            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n+            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n@@ -938,0 +1208,1 @@\n+    @Hidden\n@@ -939,0 +1210,4 @@\n+        if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n+        }\n@@ -941,2 +1216,1 @@\n-        }\n-        else {\n+        } else {\n@@ -950,0 +1224,1 @@\n+    @Hidden\n@@ -951,0 +1226,4 @@\n+        if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n+        }\n@@ -953,2 +1232,1 @@\n-        }\n-        else if (handle.isDirect() && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n+        } else if (handle.isDirect() && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n@@ -956,2 +1234,1 @@\n-        }\n-        else {\n+        } else {\n@@ -965,3 +1242,5 @@\n-    final static int guard_LJI_I(VarHandle handle, Object arg0, long arg1, int arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (int) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+    @Hidden\n+    final static boolean guard_LJII_Z(VarHandle handle, Object arg0, long arg1, int arg2, int arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n@@ -969,1 +1248,3 @@\n-        else {\n+        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n+        } else {\n@@ -971,1 +1252,1 @@\n-            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n@@ -977,3 +1258,5 @@\n-    final static boolean guard_LJII_Z(VarHandle handle, Object arg0, long arg1, int arg2, int arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n-        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n+    @Hidden\n+    final static int guard_LJII_I(VarHandle handle, Object arg0, long arg1, int arg2, int arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n@@ -981,1 +1264,3 @@\n-        else {\n+        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (int) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n+        } else {\n@@ -983,1 +1268,1 @@\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n+            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n@@ -989,3 +1274,5 @@\n-    final static int guard_LJII_I(VarHandle handle, Object arg0, long arg1, int arg2, int arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n-        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (int) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n+    @Hidden\n+    final static int guard_LJI_I(VarHandle handle, Object arg0, long arg1, int arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n@@ -993,1 +1280,3 @@\n-        else {\n+        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (int) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+        } else {\n@@ -995,1 +1284,1 @@\n-            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n+            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n@@ -1001,0 +1290,1 @@\n+    @Hidden\n@@ -1002,0 +1292,4 @@\n+        if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n+        }\n@@ -1004,2 +1298,1 @@\n-        }\n-        else if (handle.isDirect() && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n+        } else if (handle.isDirect() && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n@@ -1007,2 +1300,1 @@\n-        }\n-        else {\n+        } else {\n@@ -1016,0 +1308,1 @@\n+    @Hidden\n@@ -1017,0 +1310,4 @@\n+        if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n+        }\n@@ -1019,2 +1316,1 @@\n-        }\n-        else {\n+        } else {\n@@ -1028,0 +1324,1 @@\n+    @Hidden\n@@ -1029,0 +1326,4 @@\n+        if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n+        }\n@@ -1031,2 +1332,1 @@\n-        }\n-        else {\n+        } else {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandleGuards.java","additions":621,"deletions":321,"binary":false,"changes":942,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.lang.reflect.Parameter;\n@@ -36,0 +37,1 @@\n+import java.util.LinkedHashMap;\n@@ -46,0 +48,2 @@\n+import static java.util.stream.Collectors.joining;\n+import static java.util.stream.Collectors.toList;\n@@ -334,1 +338,2 @@\n-            return maybeAdapt((VarHandle)fac.invoke(be, size, offset, alignmentMask, strides));\n+            boolean exact = false;\n+            return maybeAdapt((VarHandle)fac.invoke(be, size, offset, alignmentMask, exact, strides));\n@@ -344,1 +349,1 @@\n-        MethodType mtype = target.accessModeType(VarHandle.AccessMode.GET).dropParameterTypes(0, 1);\n+        MethodType mtype = target.accessModeType(VarHandle.AccessMode.GET);\n@@ -674,11 +679,16 @@\n-\/\/                \"@ForceInline\\n\" +\n-\/\/                \"@LambdaForm.Compiled\\n\" +\n-\/\/                \"final static <METHOD> throws Throwable {\\n\" +\n-\/\/                \"    if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodType) {\\n\" +\n-\/\/                \"        <RESULT_ERASED>MethodHandle.linkToStatic(<LINK_TO_STATIC_ARGS>);<RETURN_ERASED>\\n\" +\n-\/\/                \"    }\\n\" +\n-\/\/                \"    else {\\n\" +\n-\/\/                \"        MethodHandle mh = handle.getMethodHandle(ad.mode);\\n\" +\n-\/\/                \"        <RETURN>mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(<LINK_TO_INVOKER_ARGS>);\\n\" +\n-\/\/                \"    }\\n\" +\n-\/\/                \"}\";\n+\/\/                \"\"\"\n+\/\/                @ForceInline\n+\/\/                @LambdaForm.Compiled\n+\/\/                @Hidden\n+\/\/                final static <METHOD> throws Throwable {\n+\/\/                    if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n+\/\/                        throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n+\/\/                                + ad.symbolicMethodTypeExact);\n+\/\/                    }\n+\/\/                    if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+\/\/                        <RESULT_ERASED>MethodHandle.linkToStatic(<LINK_TO_STATIC_ARGS>);<RETURN_ERASED>\n+\/\/                    } else {\n+\/\/                        MethodHandle mh = handle.getMethodHandle(ad.mode);\n+\/\/                        <RETURN>mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(<LINK_TO_INVOKER_ARGS>);\n+\/\/                    }\n+\/\/                }\"\"\";\n@@ -687,14 +697,18 @@\n-\/\/                \"@ForceInline\\n\" +\n-\/\/                \"@LambdaForm.Compiled\\n\" +\n-\/\/                \"final static <METHOD> throws Throwable {\\n\" +\n-\/\/                \"    if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodType) {\\n\" +\n-\/\/                \"        MethodHandle.linkToStatic(<LINK_TO_STATIC_ARGS>);\\n\" +\n-\/\/                \"    }\\n\" +\n-\/\/                \"    else if (handle.isDirect() && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodType) {\\n\" +\n-\/\/                \"        MethodHandle.linkToStatic(<LINK_TO_STATIC_ARGS>);\\n\" +\n-\/\/                \"    }\\n\" +\n-\/\/                \"    else {\\n\" +\n-\/\/                \"        MethodHandle mh = handle.getMethodHandle(ad.mode);\\n\" +\n-\/\/                \"        mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(<LINK_TO_INVOKER_ARGS>);\\n\" +\n-\/\/                \"    }\\n\" +\n-\/\/                \"}\";\n+\/\/                \"\"\"\n+\/\/                @ForceInline\n+\/\/                @LambdaForm.Compiled\n+\/\/                @Hidden\n+\/\/                final static <METHOD> throws Throwable {\n+\/\/                    if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n+\/\/                        throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n+\/\/                                + ad.symbolicMethodTypeExact);\n+\/\/                    }\n+\/\/                    if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+\/\/                        MethodHandle.linkToStatic(<LINK_TO_STATIC_ARGS>);\n+\/\/                    } else if (handle.isDirect() && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n+\/\/                        MethodHandle.linkToStatic(<LINK_TO_STATIC_ARGS>);\n+\/\/                    } else {\n+\/\/                        MethodHandle mh = handle.getMethodHandle(ad.mode);\n+\/\/                        mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(<LINK_TO_INVOKER_ARGS>);\n+\/\/                    }\n+\/\/                }\"\"\";\n@@ -736,0 +750,1 @@\n+\/\/            System.out.println(\"import jdk.internal.vm.annotation.Hidden;\");\n@@ -788,5 +803,2 @@\n-\/\/                    map(mt -> generateMethod(mt)).\n-\/\/                    forEach(s -> {\n-\/\/                        System.out.println(s);\n-\/\/                        System.out.println();\n-\/\/                    });\n+\/\/                    map(GuardMethodGenerator::generateMethod).\n+\/\/                    forEach(System.out::println);\n@@ -848,0 +860,1 @@\n+\/\/            LINK_TO_INVOKER_ARGS.set(0, LINK_TO_INVOKER_ARGS.get(0) + \".asDirect()\");\n@@ -863,1 +876,1 @@\n-\/\/                                   : \" return ad.returnType.cast(r);\";\n+\/\/                                   : \"\\n        return ad.returnType.cast(r);\";\n@@ -880,1 +893,1 @@\n-\/\/                    ;\n+\/\/                    .indent(4);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandles.java","additions":47,"deletions":34,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-            this(receiverType, fieldOffset{#if[Object]?, fieldType}, FieldInstanceReadOnly.FORM);\n+            this(receiverType, fieldOffset{#if[Object]?, fieldType}, FieldInstanceReadOnly.FORM, false);\n@@ -52,2 +52,2 @@\n-                                        VarForm form) {\n-            super(form);\n+                                        VarForm form, boolean exact) {\n+            super(form, exact);\n@@ -62,2 +62,16 @@\n-        final MethodType accessModeTypeUncached(AccessMode accessMode) {\n-            return accessMode.at.accessModeType(receiverType, {#if[Object]?fieldType:$type$.class});\n+        public FieldInstanceReadOnly withInvokeExactBehavior() {\n+            return hasInvokeExactBehavior()\n+                ? this\n+                : new FieldInstanceReadOnly(receiverType, fieldOffset{#if[Object]?, fieldType}, vform, true);\n+        }\n+\n+        @Override\n+        public FieldInstanceReadOnly withInvokeBehavior() {\n+            return !hasInvokeExactBehavior()\n+                ? this\n+                : new FieldInstanceReadOnly(receiverType, fieldOffset{#if[Object]?, fieldType}, vform, false);\n+        }\n+\n+        @Override\n+        final MethodType accessModeTypeUncached(AccessType at) {\n+            return at.accessModeType(receiverType, {#if[Object]?fieldType:$type$.class});\n@@ -113,1 +127,20 @@\n-            super(receiverType, fieldOffset{#if[Object]?, fieldType}, FieldInstanceReadWrite.FORM);\n+            this(receiverType, fieldOffset{#if[Object]?, fieldType}, false);\n+        }\n+\n+        private FieldInstanceReadWrite(Class<?> receiverType, long fieldOffset{#if[Object]?, Class<?> fieldType},\n+                                       boolean exact) {\n+            super(receiverType, fieldOffset{#if[Object]?, fieldType}, FieldInstanceReadWrite.FORM, exact);\n+        }\n+\n+        @Override\n+        public FieldInstanceReadWrite withInvokeExactBehavior() {\n+            return hasInvokeExactBehavior()\n+                ? this\n+                : new FieldInstanceReadWrite(receiverType, fieldOffset{#if[Object]?, fieldType}, true);\n+        }\n+\n+        @Override\n+        public FieldInstanceReadWrite withInvokeBehavior() {\n+            return !hasInvokeExactBehavior()\n+                ? this\n+                : new FieldInstanceReadWrite(receiverType, fieldOffset{#if[Object]?, fieldType}, false);\n@@ -359,1 +392,1 @@\n-            this(base, fieldOffset{#if[Object]?, fieldType}, FieldStaticReadOnly.FORM);\n+            this(base, fieldOffset{#if[Object]?, fieldType}, FieldStaticReadOnly.FORM, false);\n@@ -363,2 +396,2 @@\n-                                      VarForm form) {\n-            super(form);\n+                                      VarForm form, boolean exact) {\n+            super(form, exact);\n@@ -372,0 +405,14 @@\n+        @Override\n+        public FieldStaticReadOnly withInvokeExactBehavior() {\n+            return hasInvokeExactBehavior()\n+                ? this\n+                : new FieldStaticReadOnly(base, fieldOffset{#if[Object]?, fieldType}, vform, true);\n+        }\n+\n+        @Override\n+        public FieldStaticReadOnly withInvokeBehavior() {\n+            return !hasInvokeExactBehavior()\n+                ? this\n+                : new FieldStaticReadOnly(base, fieldOffset{#if[Object]?, fieldType}, vform, false);\n+        }\n+\n@@ -388,2 +435,2 @@\n-        final MethodType accessModeTypeUncached(AccessMode accessMode) {\n-            return accessMode.at.accessModeType(null, {#if[Object]?fieldType:$type$.class});\n+        final MethodType accessModeTypeUncached(AccessType at) {\n+            return at.accessModeType(null, {#if[Object]?fieldType:$type$.class});\n@@ -426,1 +473,20 @@\n-            super(base, fieldOffset{#if[Object]?, fieldType}, FieldStaticReadWrite.FORM);\n+            this(base, fieldOffset{#if[Object]?, fieldType}, false);\n+        }\n+\n+        private FieldStaticReadWrite(Object base, long fieldOffset{#if[Object]?, Class<?> fieldType},\n+                                     boolean exact) {\n+            super(base, fieldOffset{#if[Object]?, fieldType}, FieldStaticReadWrite.FORM, exact);\n+        }\n+\n+        @Override\n+        public FieldStaticReadWrite withInvokeExactBehavior() {\n+            return hasInvokeExactBehavior()\n+                ? this\n+                : new FieldStaticReadWrite(base, fieldOffset{#if[Object]?, fieldType}, true);\n+        }\n+\n+        @Override\n+        public FieldStaticReadWrite withInvokeBehavior() {\n+            return !hasInvokeExactBehavior()\n+                ? this\n+                : new FieldStaticReadWrite(base, fieldOffset{#if[Object]?, fieldType}, false);\n@@ -673,1 +739,5 @@\n-            super(Array.FORM);\n+            this(abase, ashift{#if[Object]?, arrayType}, false);\n+        }\n+\n+        private Array(int abase, int ashift{#if[Object]?, Class<?> arrayType}, boolean exact) {\n+            super(Array.FORM, exact);\n@@ -682,0 +752,14 @@\n+        @Override\n+        public Array withInvokeExactBehavior() {\n+            return hasInvokeExactBehavior()\n+                ? this\n+                : new Array(abase, ashift{#if[Object]?, arrayType}, true);\n+        }\n+\n+        @Override\n+        public Array withInvokeBehavior() {\n+            return !hasInvokeExactBehavior()\n+                ? this\n+                : new Array(abase, ashift{#if[Object]?, arrayType}, false);\n+        }\n+\n@@ -692,2 +776,2 @@\n-        final MethodType accessModeTypeUncached(AccessMode accessMode) {\n-            return accessMode.at.accessModeType({#if[Object]?arrayType:$type$[].class}, {#if[Object]?arrayType.getComponentType():$type$.class}, int.class);\n+        final MethodType accessModeTypeUncached(AccessType at) {\n+            return at.accessModeType({#if[Object]?arrayType:$type$[].class}, {#if[Object]?arrayType.getComponentType():$type$.class}, int.class);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/X-VarHandle.java.template","additions":99,"deletions":15,"binary":false,"changes":114,"status":"modified"},{"patch":"@@ -71,2 +71,2 @@\n-        ByteArrayViewVarHandle(VarForm form, boolean be) {\n-            super(form);\n+        ByteArrayViewVarHandle(VarForm form, boolean be, boolean exact) {\n+            super(form, exact);\n@@ -80,1 +80,19 @@\n-            super(ArrayHandle.FORM, be);\n+            this(be, false);\n+        }\n+\n+        private ArrayHandle(boolean be, boolean exact) {\n+            super(ArrayHandle.FORM, be, exact);\n+        }\n+\n+        @Override\n+        public ArrayHandle withInvokeExactBehavior() {\n+            return hasInvokeExactBehavior()\n+                ? this\n+                : new ArrayHandle(be, true);\n+        }\n+\n+        @Override\n+        public ArrayHandle withInvokeBehavior() {\n+            return !hasInvokeExactBehavior()\n+                ? this\n+                : new ArrayHandle(be, false);\n@@ -84,2 +102,2 @@\n-        final MethodType accessModeTypeUncached(AccessMode accessMode) {\n-            return accessMode.at.accessModeType(byte[].class, $type$.class, int.class);\n+        final MethodType accessModeTypeUncached(AccessType at) {\n+            return at.accessModeType(byte[].class, $type$.class, int.class);\n@@ -558,1 +576,19 @@\n-            super(ByteBufferHandle.FORM, be);\n+            this(be, false);\n+        }\n+\n+        private ByteBufferHandle(boolean be, boolean exact) {\n+            super(ByteBufferHandle.FORM, be, exact);\n+        }\n+\n+        @Override\n+        public ByteBufferHandle withInvokeExactBehavior() {\n+            return hasInvokeExactBehavior()\n+                ? this\n+                : new ByteBufferHandle(be, true);\n+        }\n+\n+        @Override\n+        public ByteBufferHandle withInvokeBehavior() {\n+            return !hasInvokeExactBehavior()\n+                ? this\n+                : new ByteBufferHandle(be, false);\n@@ -562,2 +598,2 @@\n-        final MethodType accessModeTypeUncached(AccessMode accessMode) {\n-            return accessMode.at.accessModeType(ByteBuffer.class, $type$.class, int.class);\n+        final MethodType accessModeTypeUncached(AccessType at) {\n+            return at.accessModeType(ByteBuffer.class, $type$.class, int.class);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/X-VarHandleByteArrayView.java.template","additions":44,"deletions":8,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -0,0 +1,416 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.foreign\n+ *\n+ * @run testng\/othervm -Xverify:all VarHandleTestExact\n+ * @run testng\/othervm -Xverify:all -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=true -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=true VarHandleTestExact\n+ * @run testng\/othervm -Xverify:all -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=false -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=false VarHandleTestExact\n+ * @run testng\/othervm -Xverify:all -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=false -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=true VarHandleTestExact\n+ *\/\n+\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemoryHandles;\n+import jdk.incubator.foreign.MemorySegment;\n+import org.testng.SkipException;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.lang.invoke.WrongMethodTypeException;\n+import java.lang.reflect.Array;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.testng.Assert.fail;\n+\n+public class VarHandleTestExact {\n+\n+    private static class Widget {\n+        static Object objectField_SRW;\n+        static long longField_SRW;\n+        static double doubleField_SRW;\n+        static Long aLongField_SRW;\n+\n+        Object objectField_RW;\n+        long longField_RW;\n+        double doubleField_RW;\n+        Long aLongField_RW;\n+\n+        final static Object objectField_SRO = new Object();\n+        final static long longField_SRO = 1234L;\n+        final static double doubleField_SRO = 1234D;\n+        final static Long aLongField_SRO = 1234L;\n+\n+        final Object objectField_RO = new Object();\n+        final long longField_RO = 1234L;\n+        final double doubleField_RO = 1234D;\n+        final Long aLongField_RO = 1234L;\n+    }\n+\n+    @Test(dataProvider = \"dataObjectAccess\")\n+    public void testExactSet(String fieldBaseName, Class<?> fieldType, boolean ro, Object testValue,\n+                             SetX setter, GetX getter,\n+                             SetStaticX staticSetter, GetStaticX staticGetter)\n+            throws NoSuchFieldException, IllegalAccessException {\n+        if (ro) throw new SkipException(\"Can not test setter with read only field\");\n+        VarHandle vh = MethodHandles.lookup().findVarHandle(Widget.class, fieldBaseName + \"_RW\", fieldType);\n+        Widget w = new Widget();\n+\n+        try {\n+            vh.set(w, testValue);\n+            vh.withInvokeBehavior().set(w, testValue);\n+        } catch (WrongMethodTypeException wmte) {\n+            fail(\"Unexpected exception\", wmte);\n+        }\n+\n+        vh = vh.withInvokeExactBehavior();\n+        try {\n+            setter.set(vh, w, testValue); \/\/ should throw\n+            fail(\"Exception expected\");\n+        } catch (WrongMethodTypeException wmte) {\n+            assertMatches(wmte.getMessage(),\".*\\\\Qexpected (Widget,\" + fieldType.getSimpleName() + \")void \\\\E.*\");\n+        }\n+    }\n+\n+    @Test(dataProvider = \"dataObjectAccess\")\n+    public void testExactGet(String fieldBaseName, Class<?> fieldType, boolean ro, Object testValue,\n+                             SetX setter, GetX getter,\n+                             SetStaticX staticSetter, GetStaticX staticGetter)\n+            throws NoSuchFieldException, IllegalAccessException {\n+        VarHandle vh = MethodHandles.lookup().findVarHandle(Widget.class, fieldBaseName + (ro ? \"_RO\" : \"_RW\"), fieldType);\n+        Widget w = new Widget();\n+\n+        try {\n+            Object o = vh.get(w);\n+            Object o2 = vh.withInvokeBehavior().get(w);\n+        } catch (WrongMethodTypeException wmte) {\n+            fail(\"Unexpected exception\", wmte);\n+        }\n+\n+        vh = vh.withInvokeExactBehavior();\n+        try {\n+            getter.get(vh, w); \/\/ should throw\n+            fail(\"Exception expected\");\n+        } catch (WrongMethodTypeException wmte) {\n+            assertMatches(wmte.getMessage(),\".*\\\\Qexpected (Widget)\" + fieldType.getSimpleName() + \" \\\\E.*\");\n+        }\n+    }\n+\n+    @Test(dataProvider = \"dataObjectAccess\")\n+    public void testExactSetStatic(String fieldBaseName, Class<?> fieldType, boolean ro, Object testValue,\n+                                   SetX setter, GetX getter,\n+                                   SetStaticX staticSetter, GetStaticX staticGetter)\n+            throws NoSuchFieldException, IllegalAccessException {\n+        if (ro) throw new SkipException(\"Can not test setter with read only field\");\n+        VarHandle vh = MethodHandles.lookup().findStaticVarHandle(Widget.class, fieldBaseName + \"_SRW\", fieldType);\n+\n+        try {\n+            vh.set(testValue);\n+            vh.withInvokeBehavior().set(testValue);\n+        } catch (WrongMethodTypeException wmte) {\n+            fail(\"Unexpected exception\", wmte);\n+        }\n+\n+        vh = vh.withInvokeExactBehavior();\n+        try {\n+            staticSetter.set(vh, testValue); \/\/ should throw\n+            fail(\"Exception expected\");\n+        } catch (WrongMethodTypeException wmte) {\n+            assertMatches(wmte.getMessage(),\".*\\\\Qexpected (\" + fieldType.getSimpleName() + \")void \\\\E.*\");\n+        }\n+    }\n+\n+    @Test(dataProvider = \"dataObjectAccess\")\n+    public void testExactGetStatic(String fieldBaseName, Class<?> fieldType, boolean ro, Object testValue,\n+                                   SetX setter, GetX getter,\n+                                   SetStaticX staticSetter, GetStaticX staticGetter)\n+            throws NoSuchFieldException, IllegalAccessException {\n+        VarHandle vh = MethodHandles.lookup().findStaticVarHandle(Widget.class, fieldBaseName + (ro ? \"_SRO\" : \"_SRW\"), fieldType);\n+\n+        try {\n+            Object o = vh.get();\n+            Object o2 = vh.withInvokeBehavior().get();\n+        } catch (WrongMethodTypeException wmte) {\n+            fail(\"Unexpected exception\", wmte);\n+        }\n+\n+        vh = vh.withInvokeExactBehavior();\n+        try {\n+            staticGetter.get(vh); \/\/ should throw\n+            fail(\"Exception expected\");\n+        } catch (WrongMethodTypeException wmte) {\n+            assertMatches(wmte.getMessage(),\".*\\\\Qexpected ()\" + fieldType.getSimpleName() + \" \\\\E.*\");\n+        }\n+    }\n+\n+    @Test(dataProvider = \"dataSetArray\")\n+    public void testExactArraySet(Class<?> arrayClass, Object testValue, SetArrayX setter) {\n+        VarHandle vh = MethodHandles.arrayElementVarHandle(arrayClass);\n+        Object arr = Array.newInstance(arrayClass.componentType(), 1);\n+\n+        try {\n+            vh.set(arr, 0, testValue);\n+            vh.withInvokeBehavior().set(arr, 0, testValue);\n+        } catch (WrongMethodTypeException wmte) {\n+            fail(\"Unexpected exception\", wmte);\n+        }\n+\n+        vh = vh.withInvokeExactBehavior();\n+        try {\n+            setter.set(vh, arr, testValue); \/\/ should throw\n+            fail(\"Exception expected\");\n+        } catch (WrongMethodTypeException wmte) {\n+            assertMatches(wmte.getMessage(),\n+                \".*\\\\Qexpected (\" + arrayClass.getSimpleName() + \",int,\" + arrayClass.componentType().getSimpleName() + \")void \\\\E.*\");\n+        }\n+    }\n+\n+    @Test(dataProvider = \"dataSetBuffer\")\n+    public void testExactBufferSet(Class<?> arrayClass, Object testValue, SetBufferX setter) {\n+        VarHandle vh = MethodHandles.byteBufferViewVarHandle(arrayClass, ByteOrder.nativeOrder());\n+        ByteBuffer buff = ByteBuffer.allocateDirect(8);\n+\n+        try {\n+            vh.set(buff, 0, testValue);\n+            vh.withInvokeBehavior().set(buff, 0, testValue);\n+        } catch (WrongMethodTypeException wmte) {\n+            fail(\"Unexpected exception\", wmte);\n+        }\n+\n+        vh = vh.withInvokeExactBehavior();\n+        try {\n+            setter.set(vh, buff, testValue); \/\/ should throw\n+            fail(\"Exception expected\");\n+        } catch (WrongMethodTypeException wmte) {\n+            assertMatches(wmte.getMessage(),\n+                \".*\\\\Qexpected (ByteBuffer,int,\" + arrayClass.componentType().getSimpleName() + \")void \\\\E.*\");\n+        }\n+    }\n+\n+    @Test(dataProvider = \"dataSetMemorySegment\")\n+    public void testExactSegmentSet(Class<?> carrier, Object testValue, SetSegmentX setter) {\n+        VarHandle vh = MemoryHandles.varHandle(carrier, ByteOrder.nativeOrder());\n+        try (MemorySegment seg = MemorySegment.allocateNative(8)) {\n+            MemoryAddress base = seg.baseAddress();\n+            try {\n+                vh.set(base, testValue);\n+                vh.withInvokeBehavior().set(base, testValue);\n+            } catch (WrongMethodTypeException wmte) {\n+                fail(\"Unexpected exception\", wmte);\n+            }\n+\n+            vh = vh.withInvokeExactBehavior();\n+            try {\n+                setter.set(vh, base, testValue); \/\/ should throw\n+                fail(\"Exception expected\");\n+            } catch (WrongMethodTypeException wmte) {\n+                assertMatches(wmte.getMessage(),\n+                    \".*\\\\Qexpected (MemoryAddress,\" + carrier.getSimpleName() + \")void \\\\E.*\");\n+            }\n+        }\n+    }\n+\n+    private static void assertMatches(String str, String pattern) {\n+        if (!str.matches(pattern)) {\n+            throw new AssertionError(\"'\" + str + \"' did not match the pattern '\" + pattern + \"'.\");\n+        }\n+    }\n+\n+    private interface SetX {\n+        void set(VarHandle vh, Widget w, Object testValue);\n+    }\n+\n+    private interface SetStaticX {\n+        void set(VarHandle vh, Object testValue);\n+    }\n+\n+    private interface GetX {\n+        void get(VarHandle vh, Widget w);\n+    }\n+\n+    private interface GetStaticX {\n+        void get(VarHandle vh);\n+    }\n+\n+    private interface SetArrayX {\n+        void set(VarHandle vh, Object array, Object testValue);\n+    }\n+\n+    private interface SetBufferX {\n+        void set(VarHandle vh, ByteBuffer buff, Object testValue);\n+    }\n+\n+    private interface SetSegmentX {\n+        void set(VarHandle vh, MemoryAddress addr, Object testValue);\n+    }\n+\n+    private static void consume(Object o) {}\n+\n+    private static void testCaseObjectAccess(List<Object[]> cases, String fieldBaseName, Class<?> fieldType, Object testValue,\n+                                    SetX setter, GetX getter,\n+                                    SetStaticX staticSetter, GetStaticX staticGetter) {\n+        cases.add(new Object[] { fieldBaseName, fieldType, false, testValue, setter, getter, staticSetter, staticGetter });\n+        cases.add(new Object[] { fieldBaseName, fieldType, true, testValue, setter, getter, staticSetter, staticGetter });\n+    }\n+\n+    private static void testCaseArraySet(List<Object[]> cases, Class<?> arrayType, Object testValue, SetArrayX setter) {\n+        cases.add(new Object[] { arrayType, testValue, setter });\n+    }\n+\n+    private static void testCaseBufferSet(List<Object[]> cases, Class<?> arrayType, Object testValue, SetBufferX setter) {\n+        cases.add(new Object[] { arrayType, testValue, setter });\n+    }\n+\n+    private static void testCaseSegmentSet(List<Object[]> cases, Class<?> carrier, Object testValue, SetSegmentX setter) {\n+        cases.add(new Object[] { carrier, testValue, setter });\n+    }\n+\n+    @DataProvider\n+    public static Object[][] dataObjectAccess() {\n+        List<Object[]> cases = new ArrayList<>();\n+\n+        \/\/ create a bunch of different sig-poly call sites\n+        testCaseObjectAccess(cases, \"objectField\", Object.class, \"abcd\",\n+                (vh, w, tv) -> vh.set(w, (String) tv),\n+                (vh, w) -> consume((String) vh.get(w)),\n+                (vh, tv) -> vh.set((String) tv),\n+                (vh) -> consume((String) vh.get()));\n+        testCaseObjectAccess(cases, \"objectField\", Object.class, Integer.valueOf(1234),\n+                (vh, w, tv) -> vh.set(w, (Integer) tv),\n+                (vh, w) -> consume((Integer) vh.get(w)),\n+                (vh, tv) -> vh.set((Integer) tv),\n+                (vh) -> consume((Integer) vh.get()));\n+        testCaseObjectAccess(cases, \"longField\", long.class, 1234,\n+                (vh, w, tv) -> vh.set(w, (int) tv),\n+                (vh, w) -> consume((int) vh.get(w)),\n+                (vh, tv) -> vh.set((int) tv),\n+                (vh) -> consume((int) vh.get()));\n+        testCaseObjectAccess(cases, \"longField\", long.class, (short) 1234,\n+                (vh, w, tv) -> vh.set(w, (short) tv),\n+                (vh, w) -> consume((short) vh.get(w)),\n+                (vh, tv) -> vh.set((short) tv),\n+                (vh) -> consume((short) vh.get()));\n+        testCaseObjectAccess(cases, \"longField\", long.class, (char) 1234,\n+                (vh, w, tv) -> vh.set(w, (char) tv),\n+                (vh, w) -> consume((char) vh.get(w)),\n+                (vh, tv) -> vh.set((char) tv),\n+                (vh) -> consume((char) vh.get()));\n+        testCaseObjectAccess(cases, \"longField\", long.class, (byte) 1234,\n+                (vh, w, tv) -> vh.set(w, (byte) tv),\n+                (vh, w) -> consume((byte) vh.get(w)),\n+                (vh, tv) -> vh.set((byte) tv),\n+                (vh) -> consume((byte) vh.get()));\n+        testCaseObjectAccess(cases, \"longField\", long.class, Long.valueOf(1234L),\n+                (vh, w, tv) -> vh.set(w, (Long) tv),\n+                (vh, w) -> consume((Long) vh.get(w)),\n+                (vh, tv) -> vh.set((Long) tv),\n+                (vh) -> consume((Long) vh.get()));\n+        testCaseObjectAccess(cases, \"doubleField\", double.class, 1234F,\n+                (vh, w, tv) -> vh.set(w, (float) tv),\n+                (vh, w) -> consume((float) vh.get(w)),\n+                (vh, tv) -> vh.set((float) tv),\n+                (vh) -> consume((float) vh.get()));\n+        testCaseObjectAccess(cases, \"doubleField\", double.class, 1234,\n+                (vh, w, tv) -> vh.set(w, (int) tv),\n+                (vh, w) -> consume((int) vh.get(w)),\n+                (vh, tv) -> vh.set((int) tv),\n+                (vh) -> consume((int) vh.get()));\n+        testCaseObjectAccess(cases, \"doubleField\", double.class, 1234L,\n+                (vh, w, tv) -> vh.set(w, (long) tv),\n+                (vh, w) -> consume((long) vh.get(w)),\n+                (vh, tv) -> vh.set((long) tv),\n+                (vh) -> consume((long) vh.get()));\n+        testCaseObjectAccess(cases, \"doubleField\", double.class, Double.valueOf(1234D),\n+                (vh, w, tv) -> vh.set(w, (Double) tv),\n+                (vh, w) -> consume((Double) vh.get(w)),\n+                (vh, tv) -> vh.set((Double) tv),\n+                (vh) -> consume((Double) vh.get()));\n+        testCaseObjectAccess(cases, \"aLongField\", Long.class, 1234L,\n+                (vh, w, tv) -> vh.set(w, (long) tv),\n+                (vh, w) -> consume((long) vh.get(w)),\n+                (vh, tv) -> vh.set((long) tv),\n+                (vh) -> consume((long) vh.get()));\n+\n+        return cases.toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public static Object[][] dataSetArray() {\n+        List<Object[]> cases = new ArrayList<>();\n+\n+        \/\/ create a bunch of different sig-poly call sites\n+        testCaseArraySet(cases, Object[].class, \"abcd\",                (vh, arr, tv) -> vh.set((Object[]) arr, 0, (String) tv));\n+        testCaseArraySet(cases, Object[].class, Integer.valueOf(1234), (vh, arr, tv) -> vh.set((Object[]) arr, (Integer) tv));\n+        testCaseArraySet(cases, long[].class, 1234,                    (vh, arr, tv) -> vh.set((long[]) arr, 0, (int) tv));\n+        testCaseArraySet(cases, long[].class, (short) 1234,            (vh, arr, tv) -> vh.set((long[]) arr, 0, (short) tv));\n+        testCaseArraySet(cases, long[].class, (char)  1234,            (vh, arr, tv) -> vh.set((long[]) arr, 0, (char) tv));\n+        testCaseArraySet(cases, long[].class, (byte)  1234,            (vh, arr, tv) -> vh.set((long[]) arr, 0, (byte) tv));\n+        testCaseArraySet(cases, long[].class, Long.valueOf(1234L),     (vh, arr, tv) -> vh.set((long[]) arr, 0, (Long) tv));\n+        testCaseArraySet(cases, double[].class, 1234F,                 (vh, arr, tv) -> vh.set((double[]) arr, 0, (float) tv));\n+        testCaseArraySet(cases, double[].class, 1234,                  (vh, arr, tv) -> vh.set((double[]) arr, 0, (int) tv));\n+        testCaseArraySet(cases, double[].class, 1234L,                 (vh, arr, tv) -> vh.set((double[]) arr, 0, (long) tv));\n+        testCaseArraySet(cases, double[].class, Double.valueOf(1234D), (vh, arr, tv) -> vh.set((double[]) arr, 0, (Double) tv));\n+        testCaseArraySet(cases, Long[].class, 1234L,                   (vh, arr, tv) -> vh.set((Long[]) arr, 0, (long) tv));\n+\n+        return cases.toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public static Object[][] dataSetBuffer() {\n+        List<Object[]> cases = new ArrayList<>();\n+\n+        \/\/ create a bunch of different sig-poly call sites\n+        testCaseBufferSet(cases, long[].class, 1234,                    (vh, buff, tv) -> vh.set(buff, 0, (int) tv));\n+        testCaseBufferSet(cases, long[].class, (short) 1234,            (vh, buff, tv) -> vh.set(buff, 0, (short) tv));\n+        testCaseBufferSet(cases, long[].class, (char)  1234,            (vh, buff, tv) -> vh.set(buff, 0, (char) tv));\n+        testCaseBufferSet(cases, long[].class, (byte)  1234,            (vh, buff, tv) -> vh.set(buff, 0, (byte) tv));\n+        testCaseBufferSet(cases, long[].class, Long.valueOf(1234L),     (vh, buff, tv) -> vh.set(buff, 0, (Long) tv));\n+        testCaseBufferSet(cases, double[].class, 1234F,                 (vh, buff, tv) -> vh.set(buff, 0, (float) tv));\n+        testCaseBufferSet(cases, double[].class, 1234,                  (vh, buff, tv) -> vh.set(buff, 0, (int) tv));\n+        testCaseBufferSet(cases, double[].class, 1234L,                 (vh, buff, tv) -> vh.set(buff, 0, (long) tv));\n+        testCaseBufferSet(cases, double[].class, Double.valueOf(1234D), (vh, buff, tv) -> vh.set(buff, 0, (Double) tv));\n+\n+        return cases.toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public static Object[][] dataSetMemorySegment() {\n+        List<Object[]> cases = new ArrayList<>();\n+\n+        \/\/ create a bunch of different sig-poly call sites\n+        testCaseSegmentSet(cases, long.class, 1234,         (vh, addr, tv) -> vh.set(addr, (int) tv));\n+        testCaseSegmentSet(cases, long.class, (char) 1234,  (vh, addr, tv) -> vh.set(addr, (char) tv));\n+        testCaseSegmentSet(cases, long.class, (short) 1234, (vh, addr, tv) -> vh.set(addr, (short) tv));\n+        testCaseSegmentSet(cases, long.class, (byte) 1234,  (vh, addr, tv) -> vh.set(addr, (byte) tv));\n+        testCaseSegmentSet(cases, double.class, 1234F,      (vh, addr, tv) -> vh.set(addr, (float) tv));\n+\n+        return cases.toArray(Object[][]::new);\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestExact.java","additions":416,"deletions":0,"binary":false,"changes":416,"status":"added"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.invoke;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(3)\n+public class VarHandleExact {\n+\n+    static final VarHandle exact;\n+    static final VarHandle generic;\n+\n+    static {\n+        try {\n+            generic = MethodHandles.lookup().findVarHandle(Data.class, \"longField\", long.class);\n+        } catch (ReflectiveOperationException e) {\n+            throw new RuntimeException(e);\n+        }\n+        exact = generic.withInvokeExactBehavior();\n+    }\n+\n+    Data data;\n+\n+    static class Data {\n+        long longField;\n+    }\n+\n+    @Setup\n+    public void setup() {\n+        data = new Data();\n+    }\n+\n+    @Benchmark\n+    public void exact_exactInvocation() {\n+        exact.set(data, (long) 42);\n+    }\n+\n+    @Benchmark\n+    public void generic_genericInvocation() {\n+        generic.set(data, 42);\n+    }\n+\n+    @Benchmark\n+    public void generic_exactInvocation() {\n+        generic.set(data, (long) 42);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/invoke\/VarHandleExact.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.jdk.incubator.foreign;\n+\n+import jdk.incubator.foreign.MemoryHandles;\n+import jdk.incubator.foreign.MemorySegment;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import java.util.concurrent.TimeUnit;\n+\n+import static jdk.incubator.foreign.MemoryLayouts.JAVA_INT;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgsAppend = { \"--add-modules\", \"jdk.incubator.foreign\" })\n+public class VarHandleExact {\n+\n+    static final VarHandle exact;\n+    static final VarHandle generic;\n+\n+    static {\n+        generic = MemoryHandles.withStride(MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder()), 4);\n+        exact = generic.withInvokeExactBehavior();\n+    }\n+\n+    MemorySegment data;\n+\n+    @Setup\n+    public void setup() {\n+        data = MemorySegment.allocateNative(JAVA_INT);\n+    }\n+\n+    @TearDown\n+    public void tearDown() {\n+        data.close();\n+    }\n+\n+    @Benchmark\n+    public void exact_exactInvocation() {\n+        exact.set(data.baseAddress(), (long) 0, 42);\n+    }\n+\n+    @Benchmark\n+    public void generic_genericInvocation() {\n+        generic.set(data.baseAddress(), 0, 42);\n+    }\n+\n+    @Benchmark\n+    public void generic_exactInvocation() {\n+        generic.set(data.baseAddress(), (long) 0, 42);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/VarHandleExact.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"}]}