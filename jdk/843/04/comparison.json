{"files":[{"patch":"@@ -56,1 +56,6 @@\n-        super(new VarForm(value, coordinates));\n+        this(target, value, coordinates, handleFactory, new VarForm(value, coordinates), false);\n+    }\n+\n+    private IndirectVarHandle(VarHandle target, Class<?> value, Class<?>[] coordinates,\n+                      BiFunction<AccessMode, MethodHandle, MethodHandle> handleFactory, VarForm form, boolean exact) {\n+        super(form, exact);\n@@ -76,1 +81,1 @@\n-        return accessMode.at.accessModeType(directTarget.getClass(), value, coordinates);\n+        return accessMode.at.accessModeType(null, value, coordinates);\n@@ -93,0 +98,10 @@\n+    @Override\n+    public VarHandle asExact() {\n+        return new IndirectVarHandle(target, value, coordinates, handleFactory, vform, true);\n+    }\n+\n+    @Override\n+    public VarHandle asGeneric() {\n+        return new IndirectVarHandle(target, value, coordinates, handleFactory, vform, false);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/IndirectVarHandle.java","additions":17,"deletions":2,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.vm.annotation.Hidden;\n@@ -466,0 +467,1 @@\n+    @Hidden\n@@ -467,0 +469,4 @@\n+        if (handle.isExact() && handle.accessModeType(ad.mode) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.mode) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/Invokers.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -45,2 +45,2 @@\n-    MemoryAccessVarHandleBase(VarForm form, boolean be, long length, long offset, long alignmentMask) {\n-        super(form);\n+    MemoryAccessVarHandleBase(VarForm form, boolean be, long length, long offset, long alignmentMask, boolean exact) {\n+        super(form, exact);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MemoryAccessVarHandleBase.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -74,0 +74,1 @@\n+import static jdk.internal.org.objectweb.asm.Opcodes.NEW;\n@@ -98,0 +99,6 @@\n+    private final static MethodType CONSTR_TYPE = MethodType.methodType(void.class, VarForm.class,\n+            boolean.class, long.class, long.class, long.class, boolean.class, long[].class);\n+    \/\/ MemoryAccessVarHandleBase\n+    private final static MethodType SUPER_CONTR_TYPE = MethodType.methodType(void.class, VarForm.class,\n+            boolean.class, long.class, long.class, long.class, boolean.class);\n+\n@@ -143,1 +150,1 @@\n-        this.implClassName = helperClass.getName().replace('.', '\/') + dimensions;\n+        this.implClassName = internalName(helperClass) + dimensions;\n@@ -167,2 +174,1 @@\n-            MethodType constrType = MethodType.methodType(void.class, VarForm.class, boolean.class, long.class, long.class, long.class, long[].class);\n-            MethodHandle constr = lookup.findConstructor(implCls, constrType);\n+            MethodHandle constr = lookup.findConstructor(implCls, CONSTR_TYPE);\n@@ -205,0 +211,3 @@\n+        addAsExact(cw);\n+        addAsGeneric(cw);\n+\n@@ -256,2 +265,1 @@\n-        MethodType constrType = MethodType.methodType(void.class, VarForm.class, boolean.class, long.class, long.class, long.class, long[].class);\n-        MethodVisitor mv = cw.visitMethod(0, \"<init>\", constrType.toMethodDescriptorString(), null, null);\n+        MethodVisitor mv = cw.visitMethod(0, \"<init>\", CONSTR_TYPE.toMethodDescriptorString(), null, null);\n@@ -261,1 +269,1 @@\n-        mv.visitVarInsn(ALOAD, 1);\n+        mv.visitVarInsn(ALOAD, 1); \/\/ vform\n@@ -263,4 +271,5 @@\n-        mv.visitVarInsn(ILOAD, 2);\n-        mv.visitVarInsn(LLOAD, 3);\n-        mv.visitVarInsn(LLOAD, 5);\n-        mv.visitVarInsn(LLOAD, 7);\n+        mv.visitVarInsn(ILOAD, 2); \/\/ be\n+        mv.visitVarInsn(LLOAD, 3); \/\/ length\n+        mv.visitVarInsn(LLOAD, 5); \/\/ offset\n+        mv.visitVarInsn(LLOAD, 7); \/\/ alignmentMask\n+        mv.visitVarInsn(ILOAD, 9); \/\/ exact\n@@ -268,1 +277,1 @@\n-                MethodType.methodType(void.class, VarForm.class, boolean.class, long.class, long.class, long.class).toMethodDescriptorString(), false);\n+                SUPER_CONTR_TYPE.toMethodDescriptorString(), false);\n@@ -272,1 +281,1 @@\n-            mv.visitVarInsn(ALOAD, 9);\n+            mv.visitVarInsn(ALOAD, 10);\n@@ -412,0 +421,32 @@\n+    private void addAsExact(ClassWriter cw) {\n+        addAsExactOrAsGeneric(cw, \"asExact\", true);\n+    }\n+\n+    private void addAsGeneric(ClassWriter cw) {\n+        addAsExactOrAsGeneric(cw, \"asGeneric\", false);\n+    }\n+\n+    private void addAsExactOrAsGeneric(ClassWriter cw, String name, boolean exact) {\n+        MethodVisitor mv = cw.visitMethod(ACC_FINAL, name, \"()Ljava\/lang\/invoke\/VarHandle;\", null, null);\n+        mv.visitCode();\n+        mv.visitTypeInsn(NEW, implClassName);\n+        mv.visitInsn(DUP);\n+        mv.visitVarInsn(ALOAD, 0);\n+        mv.visitFieldInsn(GETFIELD, internalName(VarHandle.class), \"vform\", VarForm.class.descriptorString());\n+        mv.visitVarInsn(ALOAD, 0);\n+        mv.visitFieldInsn(GETFIELD, internalName(MemoryAccessVarHandleBase.class), \"be\", boolean.class.descriptorString());\n+        mv.visitVarInsn(ALOAD, 0);\n+        mv.visitFieldInsn(GETFIELD, internalName(MemoryAccessVarHandleBase.class), \"length\", long.class.descriptorString());\n+        mv.visitVarInsn(ALOAD, 0);\n+        mv.visitFieldInsn(GETFIELD, internalName(MemoryAccessVarHandleBase.class), \"offset\", long.class.descriptorString());\n+        mv.visitVarInsn(ALOAD, 0);\n+        mv.visitFieldInsn(GETFIELD, internalName(MemoryAccessVarHandleBase.class), \"alignmentMask\", long.class.descriptorString());\n+        mv.visitIntInsn(BIPUSH, exact ? 1 : 0);\n+        mv.visitVarInsn(ALOAD, 0);\n+        mv.visitMethodInsn(INVOKEVIRTUAL, implClassName, \"strides\", \"()[J\", false);\n+        mv.visitMethodInsn(INVOKESPECIAL, implClassName, \"<init>\", CONSTR_TYPE.descriptorString(), false);\n+        mv.visitInsn(ARETURN);\n+        mv.visitMaxs(0, 0);\n+        mv.visitEnd();\n+    }\n+\n@@ -421,0 +462,4 @@\n+    private static String internalName(Class<?> cls) {\n+        return cls.getName().replace('.', '\/');\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MemoryAccessVarHandleGenerator.java","additions":57,"deletions":12,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -449,0 +449,1 @@\n+    final boolean exact;\n@@ -451,0 +452,4 @@\n+        this(vform, false);\n+    }\n+\n+    VarHandle(VarForm vform, boolean exact) {\n@@ -452,0 +457,1 @@\n+        this.exact = exact;\n@@ -468,0 +474,14 @@\n+    \/**\n+     * Returns {@code true} if this var handle is <em>exact<\/em>. An exact var handle\n+     * will check whether the type at the call site of one of it's signature-polymorphic\n+     * methods, matches the expected type exactly, and throw a\n+     * {@link WrongMethodTypeException} in case of a mismatch.\n+     *\n+     * @see #asExact()\n+     *\n+     * @return {@code true} if this var handle is exact.\n+     *\/\n+    public boolean isExact() {\n+        return exact;\n+    }\n+\n@@ -1544,0 +1564,22 @@\n+    \/**\n+     * Returns a var handle that, upon invocation of one of its signature-polymorphic methods,\n+     * checks whether the invocation type matches the expected type of the invoked method exactly\n+     * without performing <em>any<\/em> type adaptations. A {@link WrongMethodTypeException} is\n+     * thrown in case of a mismatch.\n+     *\n+     * @see #asGeneric()\n+     *\n+     * @return an exact version of this var handle\n+     *\/\n+    public abstract VarHandle asExact();\n+\n+    \/**\n+     * Returns a var handle that, upon invocation of one of its signature-polymorphic methods,\n+     * will try to adapt the types of the argument(s) to the expected type of the invocation if\n+     * possible, rather than throwing an exception in case of a mismatch.\n+     *\n+     * @see #asExact()\n+     *\n+     * @return an exact version of this var handle\n+     *\/\n+    public abstract VarHandle asGeneric();\n@@ -1806,0 +1848,2 @@\n+        @Stable\n+        static final AccessMode[] stableValues = values();\n@@ -1862,0 +1906,1 @@\n+        final MethodType symbolicMethodTypeExact;\n@@ -1869,0 +1914,1 @@\n+            this.symbolicMethodTypeExact = symbolicMethodType;\n@@ -1933,0 +1979,3 @@\n+    final MethodType accessModeType(int accessMode) {\n+        return accessModeType(AccessMode.stableValues[accessMode]);\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandle.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import jdk.internal.vm.annotation.Hidden;\n@@ -34,0 +35,1 @@\n+    @Hidden\n@@ -35,0 +37,4 @@\n+        if (handle.isExact() && handle.accessModeType(ad.mode) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.mode) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n+        }\n@@ -38,2 +44,1 @@\n-        }\n-        else {\n+        } else {\n@@ -47,0 +52,1 @@\n+    @Hidden\n@@ -48,0 +54,4 @@\n+        if (handle.isExact() && handle.accessModeType(ad.mode) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.mode) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n+        }\n@@ -50,2 +60,1 @@\n-        }\n-        else if (handle.isDirect() && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n+        } else if (handle.isDirect() && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n@@ -53,2 +62,1 @@\n-        }\n-        else {\n+        } else {\n@@ -62,4 +70,5 @@\n-    final static Object guard_LL_L(VarHandle handle, Object arg0, Object arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n-        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            Object r = MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n-            return ad.returnType.cast(r);\n+    @Hidden\n+    final static boolean guard_LLL_Z(VarHandle handle, Object arg0, Object arg1, Object arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.isExact() && handle.accessModeType(ad.mode) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.mode) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n@@ -67,1 +76,3 @@\n-        else {\n+        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+        } else {\n@@ -69,1 +80,1 @@\n-            return mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n+            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n@@ -75,3 +86,5 @@\n-    final static boolean guard_LLL_Z(VarHandle handle, Object arg0, Object arg1, Object arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+    @Hidden\n+    final static Object guard_LLL_L(VarHandle handle, Object arg0, Object arg1, Object arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.isExact() && handle.accessModeType(ad.mode) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.mode) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n@@ -79,1 +92,4 @@\n-        else {\n+        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            Object r = MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+            return ad.returnType.cast(r);\n+        } else {\n@@ -81,1 +97,1 @@\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+            return mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n@@ -87,1 +103,6 @@\n-    final static Object guard_LLL_L(VarHandle handle, Object arg0, Object arg1, Object arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+    @Hidden\n+    final static Object guard_LL_L(VarHandle handle, Object arg0, Object arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.isExact() && handle.accessModeType(ad.mode) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.mode) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n+        }\n@@ -89,1 +110,1 @@\n-            Object r = MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+            Object r = MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n@@ -91,2 +112,1 @@\n-        }\n-        else {\n+        } else {\n@@ -94,1 +114,1 @@\n-            return mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+            return mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n@@ -100,0 +120,1 @@\n+    @Hidden\n@@ -101,0 +122,4 @@\n+        if (handle.isExact() && handle.accessModeType(ad.mode) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.mode) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n+        }\n@@ -103,2 +128,1 @@\n-        }\n-        else {\n+        } else {\n@@ -112,0 +136,1 @@\n+    @Hidden\n@@ -113,0 +138,4 @@\n+        if (handle.isExact() && handle.accessModeType(ad.mode) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.mode) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n+        }\n@@ -115,2 +144,1 @@\n-        }\n-        else if (handle.isDirect() && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n+        } else if (handle.isDirect() && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n@@ -118,2 +146,1 @@\n-        }\n-        else {\n+        } else {\n@@ -127,3 +154,5 @@\n-    final static int guard_LI_I(VarHandle handle, Object arg0, int arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n-        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (int) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n+    @Hidden\n+    final static boolean guard_LII_Z(VarHandle handle, Object arg0, int arg1, int arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.isExact() && handle.accessModeType(ad.mode) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.mode) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n@@ -131,1 +160,3 @@\n-        else {\n+        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+        } else {\n@@ -133,1 +164,1 @@\n-            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n+            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n@@ -139,3 +170,5 @@\n-    final static boolean guard_LII_Z(VarHandle handle, Object arg0, int arg1, int arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+    @Hidden\n+    final static int guard_LII_I(VarHandle handle, Object arg0, int arg1, int arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.isExact() && handle.accessModeType(ad.mode) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.mode) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n@@ -143,1 +176,3 @@\n-        else {\n+        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (int) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+        } else {\n@@ -145,1 +180,1 @@\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n@@ -151,3 +186,5 @@\n-    final static int guard_LII_I(VarHandle handle, Object arg0, int arg1, int arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (int) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+    @Hidden\n+    final static int guard_LI_I(VarHandle handle, Object arg0, int arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.isExact() && handle.accessModeType(ad.mode) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.mode) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n@@ -155,1 +192,3 @@\n-        else {\n+        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (int) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n+        } else {\n@@ -157,1 +196,1 @@\n-            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n@@ -163,0 +202,1 @@\n+    @Hidden\n@@ -164,0 +204,4 @@\n+        if (handle.isExact() && handle.accessModeType(ad.mode) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.mode) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n+        }\n@@ -166,2 +210,1 @@\n-        }\n-        else {\n+        } else {\n@@ -175,0 +218,1 @@\n+    @Hidden\n@@ -176,0 +220,4 @@\n+        if (handle.isExact() && handle.accessModeType(ad.mode) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.mode) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n+        }\n@@ -178,2 +226,1 @@\n-        }\n-        else if (handle.isDirect() && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n+        } else if (handle.isDirect() && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n@@ -181,2 +228,1 @@\n-        }\n-        else {\n+        } else {\n@@ -190,3 +236,5 @@\n-    final static long guard_LJ_J(VarHandle handle, Object arg0, long arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n-        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (long) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n+    @Hidden\n+    final static boolean guard_LJJ_Z(VarHandle handle, Object arg0, long arg1, long arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.isExact() && handle.accessModeType(ad.mode) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.mode) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n@@ -194,1 +242,3 @@\n-        else {\n+        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+        } else {\n@@ -196,1 +246,1 @@\n-            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n+            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n@@ -202,3 +252,5 @@\n-    final static boolean guard_LJJ_Z(VarHandle handle, Object arg0, long arg1, long arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+    @Hidden\n+    final static long guard_LJJ_J(VarHandle handle, Object arg0, long arg1, long arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.isExact() && handle.accessModeType(ad.mode) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.mode) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n@@ -206,1 +258,3 @@\n-        else {\n+        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (long) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+        } else {\n@@ -208,1 +262,1 @@\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n@@ -214,3 +268,5 @@\n-    final static long guard_LJJ_J(VarHandle handle, Object arg0, long arg1, long arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (long) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+    @Hidden\n+    final static long guard_LJ_J(VarHandle handle, Object arg0, long arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.isExact() && handle.accessModeType(ad.mode) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.mode) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n@@ -218,1 +274,3 @@\n-        else {\n+        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (long) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n+        } else {\n@@ -220,1 +278,1 @@\n-            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n@@ -226,0 +284,1 @@\n+    @Hidden\n@@ -227,0 +286,4 @@\n+        if (handle.isExact() && handle.accessModeType(ad.mode) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.mode) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n+        }\n@@ -229,2 +292,1 @@\n-        }\n-        else {\n+        } else {\n@@ -238,0 +300,1 @@\n+    @Hidden\n@@ -239,0 +302,4 @@\n+        if (handle.isExact() && handle.accessModeType(ad.mode) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.mode) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n+        }\n@@ -241,2 +308,1 @@\n-        }\n-        else if (handle.isDirect() && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n+        } else if (handle.isDirect() && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n@@ -244,2 +310,1 @@\n-        }\n-        else {\n+        } else {\n@@ -253,3 +318,5 @@\n-    final static float guard_LF_F(VarHandle handle, Object arg0, float arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n-        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (float) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n+    @Hidden\n+    final static boolean guard_LFF_Z(VarHandle handle, Object arg0, float arg1, float arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.isExact() && handle.accessModeType(ad.mode) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.mode) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n@@ -257,1 +324,3 @@\n-        else {\n+        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+        } else {\n@@ -259,1 +328,1 @@\n-            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n+            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n@@ -265,3 +334,5 @@\n-    final static boolean guard_LFF_Z(VarHandle handle, Object arg0, float arg1, float arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+    @Hidden\n+    final static float guard_LFF_F(VarHandle handle, Object arg0, float arg1, float arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.isExact() && handle.accessModeType(ad.mode) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.mode) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n@@ -269,1 +340,3 @@\n-        else {\n+        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (float) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+        } else {\n@@ -271,1 +344,1 @@\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n@@ -277,3 +350,5 @@\n-    final static float guard_LFF_F(VarHandle handle, Object arg0, float arg1, float arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (float) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+    @Hidden\n+    final static float guard_LF_F(VarHandle handle, Object arg0, float arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.isExact() && handle.accessModeType(ad.mode) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.mode) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n@@ -281,1 +356,3 @@\n-        else {\n+        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (float) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n+        } else {\n@@ -283,1 +360,1 @@\n-            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n@@ -289,0 +366,1 @@\n+    @Hidden\n@@ -290,0 +368,4 @@\n+        if (handle.isExact() && handle.accessModeType(ad.mode) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.mode) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n+        }\n@@ -292,2 +374,1 @@\n-        }\n-        else {\n+        } else {\n@@ -301,0 +382,1 @@\n+    @Hidden\n@@ -302,0 +384,4 @@\n+        if (handle.isExact() && handle.accessModeType(ad.mode) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.mode) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n+        }\n@@ -304,2 +390,1 @@\n-        }\n-        else if (handle.isDirect() && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n+        } else if (handle.isDirect() && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n@@ -307,2 +392,1 @@\n-        }\n-        else {\n+        } else {\n@@ -316,3 +400,5 @@\n-    final static double guard_LD_D(VarHandle handle, Object arg0, double arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n-        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (double) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n+    @Hidden\n+    final static boolean guard_LDD_Z(VarHandle handle, Object arg0, double arg1, double arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.isExact() && handle.accessModeType(ad.mode) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.mode) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n@@ -320,1 +406,3 @@\n-        else {\n+        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+        } else {\n@@ -322,1 +410,1 @@\n-            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n+            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n@@ -328,3 +416,5 @@\n-    final static boolean guard_LDD_Z(VarHandle handle, Object arg0, double arg1, double arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+    @Hidden\n+    final static double guard_LDD_D(VarHandle handle, Object arg0, double arg1, double arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.isExact() && handle.accessModeType(ad.mode) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.mode) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n@@ -332,1 +422,3 @@\n-        else {\n+        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (double) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+        } else {\n@@ -334,1 +426,1 @@\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n@@ -340,3 +432,5 @@\n-    final static double guard_LDD_D(VarHandle handle, Object arg0, double arg1, double arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (double) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+    @Hidden\n+    final static double guard_LD_D(VarHandle handle, Object arg0, double arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.isExact() && handle.accessModeType(ad.mode) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.mode) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n@@ -344,1 +438,3 @@\n-        else {\n+        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (double) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n+        } else {\n@@ -346,1 +442,1 @@\n-            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n@@ -352,0 +448,1 @@\n+    @Hidden\n@@ -353,0 +450,4 @@\n+        if (handle.isExact() && handle.accessModeType(ad.mode) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.mode) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n+        }\n@@ -356,2 +457,1 @@\n-        }\n-        else {\n+        } else {\n@@ -365,0 +465,1 @@\n+    @Hidden\n@@ -366,0 +467,4 @@\n+        if (handle.isExact() && handle.accessModeType(ad.mode) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.mode) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n+        }\n@@ -368,2 +473,1 @@\n-        }\n-        else if (handle.isDirect() && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n+        } else if (handle.isDirect() && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n@@ -371,2 +475,1 @@\n-        }\n-        else {\n+        } else {\n@@ -380,0 +483,1 @@\n+    @Hidden\n@@ -381,0 +485,4 @@\n+        if (handle.isExact() && handle.accessModeType(ad.mode) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.mode) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n+        }\n@@ -383,2 +491,1 @@\n-        }\n-        else {\n+        } else {\n@@ -392,0 +499,1 @@\n+    @Hidden\n@@ -393,0 +501,4 @@\n+        if (handle.isExact() && handle.accessModeType(ad.mode) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.mode) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n+        }\n@@ -395,2 +507,1 @@\n-        }\n-        else {\n+        } else {\n@@ -404,0 +515,1 @@\n+    @Hidden\n@@ -405,0 +517,4 @@\n+        if (handle.isExact() && handle.accessModeType(ad.mode) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.mode) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n+        }\n@@ -407,2 +523,1 @@\n-        }\n-        else if (handle.isDirect() && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n+        } else if (handle.isDirect() && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n@@ -410,2 +525,1 @@\n-        }\n-        else {\n+        } else {\n@@ -419,3 +533,5 @@\n-    final static int guard_I_I(VarHandle handle, int arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n-        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (int) MethodHandle.linkToStatic(handle, arg0, handle.vform.getMemberName(ad.mode));\n+    @Hidden\n+    final static boolean guard_II_Z(VarHandle handle, int arg0, int arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.isExact() && handle.accessModeType(ad.mode) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.mode) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n@@ -423,1 +539,3 @@\n-        else {\n+        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n+        } else {\n@@ -425,1 +543,1 @@\n-            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0);\n+            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n@@ -431,3 +549,5 @@\n-    final static boolean guard_II_Z(VarHandle handle, int arg0, int arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n-        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n+    @Hidden\n+    final static int guard_II_I(VarHandle handle, int arg0, int arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.isExact() && handle.accessModeType(ad.mode) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.mode) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n@@ -435,1 +555,3 @@\n-        else {\n+        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (int) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n+        } else {\n@@ -437,1 +559,1 @@\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n+            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n@@ -443,3 +565,5 @@\n-    final static int guard_II_I(VarHandle handle, int arg0, int arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n-        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (int) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n+    @Hidden\n+    final static int guard_I_I(VarHandle handle, int arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.isExact() && handle.accessModeType(ad.mode) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.mode) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n@@ -447,1 +571,3 @@\n-        else {\n+        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (int) MethodHandle.linkToStatic(handle, arg0, handle.vform.getMemberName(ad.mode));\n+        } else {\n@@ -449,1 +575,1 @@\n-            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n+            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0);\n@@ -455,0 +581,1 @@\n+    @Hidden\n@@ -456,0 +583,4 @@\n+        if (handle.isExact() && handle.accessModeType(ad.mode) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.mode) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n+        }\n@@ -458,2 +589,1 @@\n-        }\n-        else {\n+        } else {\n@@ -467,0 +597,1 @@\n+    @Hidden\n@@ -468,0 +599,4 @@\n+        if (handle.isExact() && handle.accessModeType(ad.mode) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.mode) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n+        }\n@@ -470,2 +605,1 @@\n-        }\n-        else if (handle.isDirect() && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n+        } else if (handle.isDirect() && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n@@ -473,2 +607,1 @@\n-        }\n-        else {\n+        } else {\n@@ -482,3 +615,5 @@\n-    final static long guard_J_J(VarHandle handle, long arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n-        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (long) MethodHandle.linkToStatic(handle, arg0, handle.vform.getMemberName(ad.mode));\n+    @Hidden\n+    final static boolean guard_JJ_Z(VarHandle handle, long arg0, long arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.isExact() && handle.accessModeType(ad.mode) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.mode) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n@@ -486,1 +621,3 @@\n-        else {\n+        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n+        } else {\n@@ -488,1 +625,1 @@\n-            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0);\n+            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n@@ -494,3 +631,5 @@\n-    final static boolean guard_JJ_Z(VarHandle handle, long arg0, long arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n-        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n+    @Hidden\n+    final static long guard_JJ_J(VarHandle handle, long arg0, long arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.isExact() && handle.accessModeType(ad.mode) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.mode) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n@@ -498,1 +637,3 @@\n-        else {\n+        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (long) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n+        } else {\n@@ -500,1 +641,1 @@\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n+            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n@@ -506,3 +647,5 @@\n-    final static long guard_JJ_J(VarHandle handle, long arg0, long arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n-        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (long) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n+    @Hidden\n+    final static long guard_J_J(VarHandle handle, long arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.isExact() && handle.accessModeType(ad.mode) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.mode) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n@@ -510,1 +653,3 @@\n-        else {\n+        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (long) MethodHandle.linkToStatic(handle, arg0, handle.vform.getMemberName(ad.mode));\n+        } else {\n@@ -512,1 +657,1 @@\n-            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n+            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0);\n@@ -518,0 +663,1 @@\n+    @Hidden\n@@ -519,0 +665,4 @@\n+        if (handle.isExact() && handle.accessModeType(ad.mode) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.mode) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n+        }\n@@ -521,2 +671,1 @@\n-        }\n-        else {\n+        } else {\n@@ -530,0 +679,1 @@\n+    @Hidden\n@@ -531,0 +681,4 @@\n+        if (handle.isExact() && handle.accessModeType(ad.mode) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.mode) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n+        }\n@@ -533,2 +687,1 @@\n-        }\n-        else if (handle.isDirect() && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n+        } else if (handle.isDirect() && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n@@ -536,2 +689,1 @@\n-        }\n-        else {\n+        } else {\n@@ -545,3 +697,5 @@\n-    final static float guard_F_F(VarHandle handle, float arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n-        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (float) MethodHandle.linkToStatic(handle, arg0, handle.vform.getMemberName(ad.mode));\n+    @Hidden\n+    final static boolean guard_FF_Z(VarHandle handle, float arg0, float arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.isExact() && handle.accessModeType(ad.mode) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.mode) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n@@ -549,1 +703,3 @@\n-        else {\n+        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n+        } else {\n@@ -551,1 +707,1 @@\n-            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0);\n+            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n@@ -557,3 +713,5 @@\n-    final static boolean guard_FF_Z(VarHandle handle, float arg0, float arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n-        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n+    @Hidden\n+    final static float guard_FF_F(VarHandle handle, float arg0, float arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.isExact() && handle.accessModeType(ad.mode) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.mode) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n@@ -561,1 +719,3 @@\n-        else {\n+        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (float) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n+        } else {\n@@ -563,1 +723,1 @@\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n+            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n@@ -569,3 +729,5 @@\n-    final static float guard_FF_F(VarHandle handle, float arg0, float arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n-        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (float) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n+    @Hidden\n+    final static float guard_F_F(VarHandle handle, float arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.isExact() && handle.accessModeType(ad.mode) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.mode) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n@@ -573,1 +735,3 @@\n-        else {\n+        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (float) MethodHandle.linkToStatic(handle, arg0, handle.vform.getMemberName(ad.mode));\n+        } else {\n@@ -575,1 +739,1 @@\n-            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n+            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0);\n@@ -581,0 +745,1 @@\n+    @Hidden\n@@ -582,0 +747,4 @@\n+        if (handle.isExact() && handle.accessModeType(ad.mode) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.mode) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n+        }\n@@ -584,2 +753,1 @@\n-        }\n-        else {\n+        } else {\n@@ -593,0 +761,1 @@\n+    @Hidden\n@@ -594,0 +763,4 @@\n+        if (handle.isExact() && handle.accessModeType(ad.mode) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.mode) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n+        }\n@@ -596,2 +769,1 @@\n-        }\n-        else if (handle.isDirect() && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n+        } else if (handle.isDirect() && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n@@ -599,2 +771,1 @@\n-        }\n-        else {\n+        } else {\n@@ -608,3 +779,5 @@\n-    final static double guard_D_D(VarHandle handle, double arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n-        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (double) MethodHandle.linkToStatic(handle, arg0, handle.vform.getMemberName(ad.mode));\n+    @Hidden\n+    final static boolean guard_DD_Z(VarHandle handle, double arg0, double arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.isExact() && handle.accessModeType(ad.mode) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.mode) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n@@ -612,1 +785,3 @@\n-        else {\n+        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n+        } else {\n@@ -614,1 +789,1 @@\n-            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0);\n+            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n@@ -620,3 +795,5 @@\n-    final static boolean guard_DD_Z(VarHandle handle, double arg0, double arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n-        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n+    @Hidden\n+    final static double guard_DD_D(VarHandle handle, double arg0, double arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.isExact() && handle.accessModeType(ad.mode) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.mode) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n@@ -624,1 +801,3 @@\n-        else {\n+        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (double) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n+        } else {\n@@ -626,1 +805,1 @@\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n+            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n@@ -632,3 +811,5 @@\n-    final static double guard_DD_D(VarHandle handle, double arg0, double arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n-        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (double) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n+    @Hidden\n+    final static double guard_D_D(VarHandle handle, double arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.isExact() && handle.accessModeType(ad.mode) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.mode) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n@@ -636,1 +817,3 @@\n-        else {\n+        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (double) MethodHandle.linkToStatic(handle, arg0, handle.vform.getMemberName(ad.mode));\n+        } else {\n@@ -638,1 +821,1 @@\n-            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n+            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0);\n@@ -644,0 +827,1 @@\n+    @Hidden\n@@ -645,0 +829,4 @@\n+        if (handle.isExact() && handle.accessModeType(ad.mode) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.mode) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n+        }\n@@ -648,2 +836,1 @@\n-        }\n-        else {\n+        } else {\n@@ -657,0 +844,1 @@\n+    @Hidden\n@@ -658,0 +846,4 @@\n+        if (handle.isExact() && handle.accessModeType(ad.mode) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.mode) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n+        }\n@@ -660,2 +852,1 @@\n-        }\n-        else if (handle.isDirect() && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n+        } else if (handle.isDirect() && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n@@ -663,2 +854,1 @@\n-        }\n-        else {\n+        } else {\n@@ -672,4 +862,5 @@\n-    final static Object guard_LIL_L(VarHandle handle, Object arg0, int arg1, Object arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            Object r = MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-            return ad.returnType.cast(r);\n+    @Hidden\n+    final static boolean guard_LILL_Z(VarHandle handle, Object arg0, int arg1, Object arg2, Object arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.isExact() && handle.accessModeType(ad.mode) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.mode) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n@@ -677,1 +868,3 @@\n-        else {\n+        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n+        } else {\n@@ -679,1 +872,1 @@\n-            return mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n@@ -685,3 +878,5 @@\n-    final static boolean guard_LILL_Z(VarHandle handle, Object arg0, int arg1, Object arg2, Object arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n-        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n+    @Hidden\n+    final static Object guard_LILL_L(VarHandle handle, Object arg0, int arg1, Object arg2, Object arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.isExact() && handle.accessModeType(ad.mode) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.mode) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n@@ -689,1 +884,4 @@\n-        else {\n+        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            Object r = MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n+            return ad.returnType.cast(r);\n+        } else {\n@@ -691,1 +889,1 @@\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n+            return mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n@@ -697,1 +895,6 @@\n-    final static Object guard_LILL_L(VarHandle handle, Object arg0, int arg1, Object arg2, Object arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n+    @Hidden\n+    final static Object guard_LIL_L(VarHandle handle, Object arg0, int arg1, Object arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.isExact() && handle.accessModeType(ad.mode) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.mode) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n+        }\n@@ -699,1 +902,1 @@\n-            Object r = MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n+            Object r = MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n@@ -701,2 +904,1 @@\n-        }\n-        else {\n+        } else {\n@@ -704,1 +906,1 @@\n-            return mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n+            return mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n@@ -710,0 +912,1 @@\n+    @Hidden\n@@ -711,0 +914,4 @@\n+        if (handle.isExact() && handle.accessModeType(ad.mode) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.mode) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n+        }\n@@ -713,2 +920,1 @@\n-        }\n-        else if (handle.isDirect() && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n+        } else if (handle.isDirect() && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n@@ -716,2 +922,1 @@\n-        }\n-        else {\n+        } else {\n@@ -725,0 +930,1 @@\n+    @Hidden\n@@ -726,0 +932,4 @@\n+        if (handle.isExact() && handle.accessModeType(ad.mode) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.mode) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n+        }\n@@ -728,2 +938,1 @@\n-        }\n-        else {\n+        } else {\n@@ -737,0 +946,1 @@\n+    @Hidden\n@@ -738,0 +948,4 @@\n+        if (handle.isExact() && handle.accessModeType(ad.mode) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.mode) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n+        }\n@@ -740,2 +954,1 @@\n-        }\n-        else {\n+        } else {\n@@ -749,0 +962,1 @@\n+    @Hidden\n@@ -750,0 +964,4 @@\n+        if (handle.isExact() && handle.accessModeType(ad.mode) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.mode) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n+        }\n@@ -752,2 +970,1 @@\n-        }\n-        else {\n+        } else {\n@@ -761,0 +978,1 @@\n+    @Hidden\n@@ -762,0 +980,4 @@\n+        if (handle.isExact() && handle.accessModeType(ad.mode) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.mode) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n+        }\n@@ -764,2 +986,1 @@\n-        }\n-        else if (handle.isDirect() && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n+        } else if (handle.isDirect() && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n@@ -767,2 +988,1 @@\n-        }\n-        else {\n+        } else {\n@@ -776,3 +996,5 @@\n-    final static long guard_LIJ_J(VarHandle handle, Object arg0, int arg1, long arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (long) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+    @Hidden\n+    final static boolean guard_LIJJ_Z(VarHandle handle, Object arg0, int arg1, long arg2, long arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.isExact() && handle.accessModeType(ad.mode) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.mode) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n@@ -780,1 +1002,3 @@\n-        else {\n+        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n+        } else {\n@@ -782,1 +1006,1 @@\n-            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n@@ -788,3 +1012,5 @@\n-    final static boolean guard_LIJJ_Z(VarHandle handle, Object arg0, int arg1, long arg2, long arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n-        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n+    @Hidden\n+    final static long guard_LIJJ_J(VarHandle handle, Object arg0, int arg1, long arg2, long arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.isExact() && handle.accessModeType(ad.mode) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.mode) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n@@ -792,1 +1018,3 @@\n-        else {\n+        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (long) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n+        } else {\n@@ -794,1 +1022,1 @@\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n+            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n@@ -800,3 +1028,5 @@\n-    final static long guard_LIJJ_J(VarHandle handle, Object arg0, int arg1, long arg2, long arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n-        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (long) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n+    @Hidden\n+    final static long guard_LIJ_J(VarHandle handle, Object arg0, int arg1, long arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.isExact() && handle.accessModeType(ad.mode) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.mode) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n@@ -804,1 +1034,3 @@\n-        else {\n+        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (long) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+        } else {\n@@ -806,1 +1038,1 @@\n-            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n+            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n@@ -812,0 +1044,1 @@\n+    @Hidden\n@@ -813,0 +1046,4 @@\n+        if (handle.isExact() && handle.accessModeType(ad.mode) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.mode) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n+        }\n@@ -815,2 +1052,1 @@\n-        }\n-        else {\n+        } else {\n@@ -824,0 +1060,1 @@\n+    @Hidden\n@@ -825,0 +1062,4 @@\n+        if (handle.isExact() && handle.accessModeType(ad.mode) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.mode) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n+        }\n@@ -827,2 +1068,1 @@\n-        }\n-        else if (handle.isDirect() && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n+        } else if (handle.isDirect() && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n@@ -830,2 +1070,1 @@\n-        }\n-        else {\n+        } else {\n@@ -839,3 +1078,5 @@\n-    final static float guard_LIF_F(VarHandle handle, Object arg0, int arg1, float arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (float) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+    @Hidden\n+    final static boolean guard_LIFF_Z(VarHandle handle, Object arg0, int arg1, float arg2, float arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.isExact() && handle.accessModeType(ad.mode) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.mode) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n@@ -843,1 +1084,3 @@\n-        else {\n+        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n+        } else {\n@@ -845,1 +1088,1 @@\n-            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n@@ -851,3 +1094,5 @@\n-    final static boolean guard_LIFF_Z(VarHandle handle, Object arg0, int arg1, float arg2, float arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n-        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n+    @Hidden\n+    final static float guard_LIFF_F(VarHandle handle, Object arg0, int arg1, float arg2, float arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.isExact() && handle.accessModeType(ad.mode) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.mode) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n@@ -855,1 +1100,3 @@\n-        else {\n+        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (float) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n+        } else {\n@@ -857,1 +1104,1 @@\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n+            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n@@ -863,3 +1110,5 @@\n-    final static float guard_LIFF_F(VarHandle handle, Object arg0, int arg1, float arg2, float arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n-        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (float) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n+    @Hidden\n+    final static float guard_LIF_F(VarHandle handle, Object arg0, int arg1, float arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.isExact() && handle.accessModeType(ad.mode) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.mode) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n@@ -867,1 +1116,3 @@\n-        else {\n+        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (float) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+        } else {\n@@ -869,1 +1120,1 @@\n-            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n+            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n@@ -875,0 +1126,1 @@\n+    @Hidden\n@@ -876,0 +1128,4 @@\n+        if (handle.isExact() && handle.accessModeType(ad.mode) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.mode) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n+        }\n@@ -878,2 +1134,1 @@\n-        }\n-        else {\n+        } else {\n@@ -887,0 +1142,1 @@\n+    @Hidden\n@@ -888,0 +1144,4 @@\n+        if (handle.isExact() && handle.accessModeType(ad.mode) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.mode) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n+        }\n@@ -890,2 +1150,1 @@\n-        }\n-        else if (handle.isDirect() && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n+        } else if (handle.isDirect() && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n@@ -893,2 +1152,1 @@\n-        }\n-        else {\n+        } else {\n@@ -902,3 +1160,5 @@\n-    final static double guard_LID_D(VarHandle handle, Object arg0, int arg1, double arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (double) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+    @Hidden\n+    final static boolean guard_LIDD_Z(VarHandle handle, Object arg0, int arg1, double arg2, double arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.isExact() && handle.accessModeType(ad.mode) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.mode) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n@@ -906,1 +1166,3 @@\n-        else {\n+        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n+        } else {\n@@ -908,1 +1170,1 @@\n-            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n@@ -914,3 +1176,5 @@\n-    final static boolean guard_LIDD_Z(VarHandle handle, Object arg0, int arg1, double arg2, double arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n-        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n+    @Hidden\n+    final static double guard_LIDD_D(VarHandle handle, Object arg0, int arg1, double arg2, double arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.isExact() && handle.accessModeType(ad.mode) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.mode) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n@@ -918,1 +1182,3 @@\n-        else {\n+        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (double) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n+        } else {\n@@ -920,1 +1186,1 @@\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n+            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n@@ -926,3 +1192,5 @@\n-    final static double guard_LIDD_D(VarHandle handle, Object arg0, int arg1, double arg2, double arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n-        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (double) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n+    @Hidden\n+    final static double guard_LID_D(VarHandle handle, Object arg0, int arg1, double arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.isExact() && handle.accessModeType(ad.mode) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.mode) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n@@ -930,1 +1198,3 @@\n-        else {\n+        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (double) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+        } else {\n@@ -932,1 +1202,1 @@\n-            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n+            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n@@ -938,0 +1208,1 @@\n+    @Hidden\n@@ -939,0 +1210,4 @@\n+        if (handle.isExact() && handle.accessModeType(ad.mode) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.mode) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n+        }\n@@ -941,2 +1216,1 @@\n-        }\n-        else {\n+        } else {\n@@ -950,0 +1224,1 @@\n+    @Hidden\n@@ -951,0 +1226,4 @@\n+        if (handle.isExact() && handle.accessModeType(ad.mode) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.mode) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n+        }\n@@ -953,2 +1232,1 @@\n-        }\n-        else if (handle.isDirect() && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n+        } else if (handle.isDirect() && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n@@ -956,2 +1234,1 @@\n-        }\n-        else {\n+        } else {\n@@ -965,3 +1242,5 @@\n-    final static int guard_LJI_I(VarHandle handle, Object arg0, long arg1, int arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (int) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+    @Hidden\n+    final static boolean guard_LJII_Z(VarHandle handle, Object arg0, long arg1, int arg2, int arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.isExact() && handle.accessModeType(ad.mode) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.mode) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n@@ -969,1 +1248,3 @@\n-        else {\n+        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n+        } else {\n@@ -971,1 +1252,1 @@\n-            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n@@ -977,3 +1258,5 @@\n-    final static boolean guard_LJII_Z(VarHandle handle, Object arg0, long arg1, int arg2, int arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n-        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n+    @Hidden\n+    final static int guard_LJII_I(VarHandle handle, Object arg0, long arg1, int arg2, int arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.isExact() && handle.accessModeType(ad.mode) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.mode) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n@@ -981,1 +1264,3 @@\n-        else {\n+        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (int) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n+        } else {\n@@ -983,1 +1268,1 @@\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n+            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n@@ -989,3 +1274,5 @@\n-    final static int guard_LJII_I(VarHandle handle, Object arg0, long arg1, int arg2, int arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n-        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (int) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n+    @Hidden\n+    final static int guard_LJI_I(VarHandle handle, Object arg0, long arg1, int arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+        if (handle.isExact() && handle.accessModeType(ad.mode) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.mode) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n@@ -993,1 +1280,3 @@\n-        else {\n+        if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (int) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+        } else {\n@@ -995,1 +1284,1 @@\n-            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n+            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n@@ -1001,0 +1290,1 @@\n+    @Hidden\n@@ -1002,0 +1292,4 @@\n+        if (handle.isExact() && handle.accessModeType(ad.mode) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.mode) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n+        }\n@@ -1004,2 +1298,1 @@\n-        }\n-        else if (handle.isDirect() && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n+        } else if (handle.isDirect() && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n@@ -1007,2 +1300,1 @@\n-        }\n-        else {\n+        } else {\n@@ -1016,0 +1308,1 @@\n+    @Hidden\n@@ -1017,0 +1310,4 @@\n+        if (handle.isExact() && handle.accessModeType(ad.mode) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.mode) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n+        }\n@@ -1019,2 +1316,1 @@\n-        }\n-        else {\n+        } else {\n@@ -1028,0 +1324,1 @@\n+    @Hidden\n@@ -1029,0 +1326,4 @@\n+        if (handle.isExact() && handle.accessModeType(ad.mode) != ad.symbolicMethodTypeExact) {\n+            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.mode) + \" but found \"\n+                    + ad.symbolicMethodTypeExact);\n+        }\n@@ -1031,2 +1332,1 @@\n-        }\n-        else {\n+        } else {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandleGuards.java","additions":621,"deletions":321,"binary":false,"changes":942,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.lang.reflect.Parameter;\n@@ -36,0 +37,1 @@\n+import java.util.LinkedHashMap;\n@@ -46,0 +48,2 @@\n+import static java.util.stream.Collectors.joining;\n+import static java.util.stream.Collectors.toList;\n@@ -334,1 +338,2 @@\n-            return maybeAdapt((VarHandle)fac.invoke(be, size, offset, alignmentMask, strides));\n+            boolean exact = false;\n+            return maybeAdapt((VarHandle)fac.invoke(be, size, offset, alignmentMask, exact, strides));\n@@ -344,1 +349,1 @@\n-        MethodType mtype = target.accessModeType(VarHandle.AccessMode.GET).dropParameterTypes(0, 1);\n+        MethodType mtype = target.accessModeType(VarHandle.AccessMode.GET);\n@@ -674,11 +679,16 @@\n-\/\/                \"@ForceInline\\n\" +\n-\/\/                \"@LambdaForm.Compiled\\n\" +\n-\/\/                \"final static <METHOD> throws Throwable {\\n\" +\n-\/\/                \"    if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodType) {\\n\" +\n-\/\/                \"        <RESULT_ERASED>MethodHandle.linkToStatic(<LINK_TO_STATIC_ARGS>);<RETURN_ERASED>\\n\" +\n-\/\/                \"    }\\n\" +\n-\/\/                \"    else {\\n\" +\n-\/\/                \"        MethodHandle mh = handle.getMethodHandle(ad.mode);\\n\" +\n-\/\/                \"        <RETURN>mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(<LINK_TO_INVOKER_ARGS>);\\n\" +\n-\/\/                \"    }\\n\" +\n-\/\/                \"}\";\n+\/\/                \"\"\"\n+\/\/                @ForceInline\n+\/\/                @LambdaForm.Compiled\n+\/\/                @Hidden\n+\/\/                final static <METHOD> throws Throwable {\n+\/\/                    if (handle.isExact() && handle.accessModeType(ad.mode) != ad.symbolicMethodTypeExact) {\n+\/\/                        throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.mode) + \" but found \"\n+\/\/                                + ad.symbolicMethodTypeExact);\n+\/\/                    }\n+\/\/                    if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+\/\/                        <RESULT_ERASED>MethodHandle.linkToStatic(<LINK_TO_STATIC_ARGS>);<RETURN_ERASED>\n+\/\/                    } else {\n+\/\/                        MethodHandle mh = handle.getMethodHandle(ad.mode);\n+\/\/                        <RETURN>mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(<LINK_TO_INVOKER_ARGS>);\n+\/\/                    }\n+\/\/                }\"\"\";\n@@ -687,14 +697,18 @@\n-\/\/                \"@ForceInline\\n\" +\n-\/\/                \"@LambdaForm.Compiled\\n\" +\n-\/\/                \"final static <METHOD> throws Throwable {\\n\" +\n-\/\/                \"    if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodType) {\\n\" +\n-\/\/                \"        MethodHandle.linkToStatic(<LINK_TO_STATIC_ARGS>);\\n\" +\n-\/\/                \"    }\\n\" +\n-\/\/                \"    else if (handle.isDirect() && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodType) {\\n\" +\n-\/\/                \"        MethodHandle.linkToStatic(<LINK_TO_STATIC_ARGS>);\\n\" +\n-\/\/                \"    }\\n\" +\n-\/\/                \"    else {\\n\" +\n-\/\/                \"        MethodHandle mh = handle.getMethodHandle(ad.mode);\\n\" +\n-\/\/                \"        mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(<LINK_TO_INVOKER_ARGS>);\\n\" +\n-\/\/                \"    }\\n\" +\n-\/\/                \"}\";\n+\/\/                \"\"\"\n+\/\/                @ForceInline\n+\/\/                @LambdaForm.Compiled\n+\/\/                @Hidden\n+\/\/                final static <METHOD> throws Throwable {\n+\/\/                    if (handle.isExact() && handle.accessModeType(ad.mode) != ad.symbolicMethodTypeExact) {\n+\/\/                        throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.mode) + \" but found \"\n+\/\/                                + ad.symbolicMethodTypeExact);\n+\/\/                    }\n+\/\/                    if (handle.isDirect() && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+\/\/                        MethodHandle.linkToStatic(<LINK_TO_STATIC_ARGS>);\n+\/\/                    } else if (handle.isDirect() && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n+\/\/                        MethodHandle.linkToStatic(<LINK_TO_STATIC_ARGS>);\n+\/\/                    } else {\n+\/\/                        MethodHandle mh = handle.getMethodHandle(ad.mode);\n+\/\/                        mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(<LINK_TO_INVOKER_ARGS>);\n+\/\/                    }\n+\/\/                }\"\"\";\n@@ -736,0 +750,1 @@\n+\/\/            System.out.println(\"import jdk.internal.vm.annotation.Hidden;\");\n@@ -788,5 +803,2 @@\n-\/\/                    map(mt -> generateMethod(mt)).\n-\/\/                    forEach(s -> {\n-\/\/                        System.out.println(s);\n-\/\/                        System.out.println();\n-\/\/                    });\n+\/\/                    map(GuardMethodGenerator::generateMethod).\n+\/\/                    forEach(System.out::println);\n@@ -848,0 +860,1 @@\n+\/\/            LINK_TO_INVOKER_ARGS.set(0, LINK_TO_INVOKER_ARGS.get(0) + \".asDirect()\");\n@@ -863,1 +876,1 @@\n-\/\/                                   : \" return ad.returnType.cast(r);\";\n+\/\/                                   : \"\\n        return ad.returnType.cast(r);\";\n@@ -880,1 +893,1 @@\n-\/\/                    ;\n+\/\/                    .indent(4);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandles.java","additions":47,"deletions":34,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-            this(receiverType, fieldOffset{#if[Object]?, fieldType}, FieldInstanceReadOnly.FORM);\n+            this(receiverType, fieldOffset{#if[Object]?, fieldType}, FieldInstanceReadOnly.FORM, false);\n@@ -52,2 +52,2 @@\n-                                        VarForm form) {\n-            super(form);\n+                                        VarForm form, boolean exact) {\n+            super(form, exact);\n@@ -61,0 +61,10 @@\n+        @Override\n+        public FieldInstanceReadOnly asExact() {\n+            return new FieldInstanceReadOnly(receiverType, fieldOffset{#if[Object]?, fieldType}, vform, true);\n+        }\n+\n+        @Override\n+        public FieldInstanceReadOnly asGeneric() {\n+            return new FieldInstanceReadOnly(receiverType, fieldOffset{#if[Object]?, fieldType}, vform, false);\n+        }\n+\n@@ -113,1 +123,16 @@\n-            super(receiverType, fieldOffset{#if[Object]?, fieldType}, FieldInstanceReadWrite.FORM);\n+            this(receiverType, fieldOffset{#if[Object]?, fieldType}, false);\n+        }\n+\n+        private FieldInstanceReadWrite(Class<?> receiverType, long fieldOffset{#if[Object]?, Class<?> fieldType},\n+                                       boolean exact) {\n+            super(receiverType, fieldOffset{#if[Object]?, fieldType}, FieldInstanceReadWrite.FORM, exact);\n+        }\n+\n+        @Override\n+        public FieldInstanceReadWrite asExact() {\n+            return new FieldInstanceReadWrite(receiverType, fieldOffset{#if[Object]?, fieldType}, true);\n+        }\n+\n+        @Override\n+        public FieldInstanceReadWrite asGeneric() {\n+            return new FieldInstanceReadWrite(receiverType, fieldOffset{#if[Object]?, fieldType}, false);\n@@ -359,1 +384,1 @@\n-            this(base, fieldOffset{#if[Object]?, fieldType}, FieldStaticReadOnly.FORM);\n+            this(base, fieldOffset{#if[Object]?, fieldType}, FieldStaticReadOnly.FORM, false);\n@@ -363,2 +388,2 @@\n-                                      VarForm form) {\n-            super(form);\n+                                      VarForm form, boolean exact) {\n+            super(form, exact);\n@@ -372,0 +397,10 @@\n+        @Override\n+        public FieldStaticReadOnly asExact() {\n+            return new FieldStaticReadOnly(base, fieldOffset{#if[Object]?, fieldType}, vform, true);\n+        }\n+\n+        @Override\n+        public FieldStaticReadOnly asGeneric() {\n+            return new FieldStaticReadOnly(base, fieldOffset{#if[Object]?, fieldType}, vform, false);\n+        }\n+\n@@ -426,1 +461,16 @@\n-            super(base, fieldOffset{#if[Object]?, fieldType}, FieldStaticReadWrite.FORM);\n+            this(base, fieldOffset{#if[Object]?, fieldType}, false);\n+        }\n+\n+        private FieldStaticReadWrite(Object base, long fieldOffset{#if[Object]?, Class<?> fieldType},\n+                                     boolean exact) {\n+            super(base, fieldOffset{#if[Object]?, fieldType}, FieldStaticReadWrite.FORM, exact);\n+        }\n+\n+        @Override\n+        public FieldStaticReadWrite asExact() {\n+            return new FieldStaticReadWrite(base, fieldOffset{#if[Object]?, fieldType}, true);\n+        }\n+\n+        @Override\n+        public FieldStaticReadWrite asGeneric() {\n+            return new FieldStaticReadWrite(base, fieldOffset{#if[Object]?, fieldType}, false);\n@@ -673,1 +723,5 @@\n-            super(Array.FORM);\n+            this(abase, ashift{#if[Object]?, arrayType}, false);\n+        }\n+\n+        private Array(int abase, int ashift{#if[Object]?, Class<?> arrayType}, boolean exact) {\n+            super(Array.FORM, exact);\n@@ -682,0 +736,10 @@\n+        @Override\n+        public Array asExact() {\n+            return new Array(abase, ashift{#if[Object]?, arrayType}, true);\n+        }\n+\n+        @Override\n+        public Array asGeneric() {\n+            return new Array(abase, ashift{#if[Object]?, arrayType}, false);\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/X-VarHandle.java.template","additions":73,"deletions":9,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -71,2 +71,2 @@\n-        ByteArrayViewVarHandle(VarForm form, boolean be) {\n-            super(form);\n+        ByteArrayViewVarHandle(VarForm form, boolean be, boolean exact) {\n+            super(form, exact);\n@@ -80,1 +80,15 @@\n-            super(ArrayHandle.FORM, be);\n+            this(be, false);\n+        }\n+\n+        private ArrayHandle(boolean be, boolean exact) {\n+            super(ArrayHandle.FORM, be, exact);\n+        }\n+\n+        @Override\n+        public ArrayHandle asExact() {\n+            return new ArrayHandle(be, true);\n+        }\n+\n+        @Override\n+        public ArrayHandle asGeneric() {\n+            return new ArrayHandle(be, false);\n@@ -558,1 +572,15 @@\n-            super(ByteBufferHandle.FORM, be);\n+            this(be, false);\n+        }\n+\n+        private ByteBufferHandle(boolean be, boolean exact) {\n+            super(ByteBufferHandle.FORM, be, exact);\n+        }\n+\n+        @Override\n+        public ByteBufferHandle asExact() {\n+            return new ByteBufferHandle(be, true);\n+        }\n+\n+        @Override\n+        public ByteBufferHandle asGeneric() {\n+            return new ByteBufferHandle(be, false);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/X-VarHandleByteArrayView.java.template","additions":32,"deletions":4,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -0,0 +1,416 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.foreign\n+ *\n+ * @run testng\/othervm -Xverify:all VarHandleTestExact\n+ * @run testng\/othervm -Xverify:all -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=true -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=true VarHandleTestExact\n+ * @run testng\/othervm -Xverify:all -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=false -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=false VarHandleTestExact\n+ * @run testng\/othervm -Xverify:all -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=false -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=true VarHandleTestExact\n+ *\/\n+\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemoryHandles;\n+import jdk.incubator.foreign.MemorySegment;\n+import org.testng.SkipException;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.lang.invoke.WrongMethodTypeException;\n+import java.lang.reflect.Array;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.testng.Assert.fail;\n+\n+public class VarHandleTestExact {\n+\n+    private static class Widget {\n+        static Object objectField_SRW;\n+        static long longField_SRW;\n+        static double doubleField_SRW;\n+        static Long aLongField_SRW;\n+\n+        Object objectField_RW;\n+        long longField_RW;\n+        double doubleField_RW;\n+        Long aLongField_RW;\n+\n+        final static Object objectField_SRO = new Object();\n+        final static long longField_SRO = 1234L;\n+        final static double doubleField_SRO = 1234D;\n+        final static Long aLongField_SRO = 1234L;\n+\n+        final Object objectField_RO = new Object();\n+        final long longField_RO = 1234L;\n+        final double doubleField_RO = 1234D;\n+        final Long aLongField_RO = 1234L;\n+    }\n+\n+    @Test(dataProvider = \"dataObjectAccess\")\n+    public void testExactSet(String fieldBaseName, Class<?> fieldType, boolean ro, Object testValue,\n+                             SetX setter, GetX getter,\n+                             SetStaticX staticSetter, GetStaticX staticGetter)\n+            throws NoSuchFieldException, IllegalAccessException {\n+        if (ro) throw new SkipException(\"Can not test setter with read only field\");\n+        VarHandle vh = MethodHandles.lookup().findVarHandle(Widget.class, fieldBaseName + \"_RW\", fieldType);\n+        Widget w = new Widget();\n+\n+        try {\n+            vh.set(w, testValue);\n+            vh.asGeneric().set(w, testValue);\n+        } catch (WrongMethodTypeException wmte) {\n+            fail(\"Unexpected exception\", wmte);\n+        }\n+\n+        vh = vh.asExact();\n+        try {\n+            setter.set(vh, w, testValue); \/\/ should throw\n+            fail(\"Exception expected\");\n+        } catch (WrongMethodTypeException wmte) {\n+            assertMatches(wmte.getMessage(),\".*\\\\Qexpected (Widget,\" + fieldType.getSimpleName() + \")void \\\\E.*\");\n+        }\n+    }\n+\n+    @Test(dataProvider = \"dataObjectAccess\")\n+    public void testExactGet(String fieldBaseName, Class<?> fieldType, boolean ro, Object testValue,\n+                             SetX setter, GetX getter,\n+                             SetStaticX staticSetter, GetStaticX staticGetter)\n+            throws NoSuchFieldException, IllegalAccessException {\n+        VarHandle vh = MethodHandles.lookup().findVarHandle(Widget.class, fieldBaseName + (ro ? \"_RO\" : \"_RW\"), fieldType);\n+        Widget w = new Widget();\n+\n+        try {\n+            Object o = vh.get(w);\n+            Object o2 = vh.asGeneric().get(w);\n+        } catch (WrongMethodTypeException wmte) {\n+            fail(\"Unexpected exception\", wmte);\n+        }\n+\n+        vh = vh.asExact();\n+        try {\n+            getter.get(vh, w); \/\/ should throw\n+            fail(\"Exception expected\");\n+        } catch (WrongMethodTypeException wmte) {\n+            assertMatches(wmte.getMessage(),\".*\\\\Qexpected (Widget)\" + fieldType.getSimpleName() + \" \\\\E.*\");\n+        }\n+    }\n+\n+    @Test(dataProvider = \"dataObjectAccess\")\n+    public void testExactSetStatic(String fieldBaseName, Class<?> fieldType, boolean ro, Object testValue,\n+                                   SetX setter, GetX getter,\n+                                   SetStaticX staticSetter, GetStaticX staticGetter)\n+            throws NoSuchFieldException, IllegalAccessException {\n+        if (ro) throw new SkipException(\"Can not test setter with read only field\");\n+        VarHandle vh = MethodHandles.lookup().findStaticVarHandle(Widget.class, fieldBaseName + \"_SRW\", fieldType);\n+\n+        try {\n+            vh.set(testValue);\n+            vh.asGeneric().set(testValue);\n+        } catch (WrongMethodTypeException wmte) {\n+            fail(\"Unexpected exception\", wmte);\n+        }\n+\n+        vh = vh.asExact();\n+        try {\n+            staticSetter.set(vh, testValue); \/\/ should throw\n+            fail(\"Exception expected\");\n+        } catch (WrongMethodTypeException wmte) {\n+            assertMatches(wmte.getMessage(),\".*\\\\Qexpected (\" + fieldType.getSimpleName() + \")void \\\\E.*\");\n+        }\n+    }\n+\n+    @Test(dataProvider = \"dataObjectAccess\")\n+    public void testExactGetStatic(String fieldBaseName, Class<?> fieldType, boolean ro, Object testValue,\n+                                   SetX setter, GetX getter,\n+                                   SetStaticX staticSetter, GetStaticX staticGetter)\n+            throws NoSuchFieldException, IllegalAccessException {\n+        VarHandle vh = MethodHandles.lookup().findStaticVarHandle(Widget.class, fieldBaseName + (ro ? \"_SRO\" : \"_SRW\"), fieldType);\n+\n+        try {\n+            Object o = vh.get();\n+            Object o2 = vh.asGeneric().get();\n+        } catch (WrongMethodTypeException wmte) {\n+            fail(\"Unexpected exception\", wmte);\n+        }\n+\n+        vh = vh.asExact();\n+        try {\n+            staticGetter.get(vh); \/\/ should throw\n+            fail(\"Exception expected\");\n+        } catch (WrongMethodTypeException wmte) {\n+            assertMatches(wmte.getMessage(),\".*\\\\Qexpected ()\" + fieldType.getSimpleName() + \" \\\\E.*\");\n+        }\n+    }\n+\n+    @Test(dataProvider = \"dataSetArray\")\n+    public void testExactArraySet(Class<?> arrayClass, Object testValue, SetArrayX setter) {\n+        VarHandle vh = MethodHandles.arrayElementVarHandle(arrayClass);\n+        Object arr = Array.newInstance(arrayClass.componentType(), 1);\n+\n+        try {\n+            vh.set(arr, 0, testValue);\n+            vh.asGeneric().set(arr, 0, testValue);\n+        } catch (WrongMethodTypeException wmte) {\n+            fail(\"Unexpected exception\", wmte);\n+        }\n+\n+        vh = vh.asExact();\n+        try {\n+            setter.set(vh, arr, testValue); \/\/ should throw\n+            fail(\"Exception expected\");\n+        } catch (WrongMethodTypeException wmte) {\n+            assertMatches(wmte.getMessage(),\n+                \".*\\\\Qexpected (\" + arrayClass.getSimpleName() + \",int,\" + arrayClass.componentType().getSimpleName() + \")void \\\\E.*\");\n+        }\n+    }\n+\n+    @Test(dataProvider = \"dataSetBuffer\")\n+    public void testExactBufferSet(Class<?> arrayClass, Object testValue, SetBufferX setter) {\n+        VarHandle vh = MethodHandles.byteBufferViewVarHandle(arrayClass, ByteOrder.nativeOrder());\n+        ByteBuffer buff = ByteBuffer.allocateDirect(8);\n+\n+        try {\n+            vh.set(buff, 0, testValue);\n+            vh.asGeneric().set(buff, 0, testValue);\n+        } catch (WrongMethodTypeException wmte) {\n+            fail(\"Unexpected exception\", wmte);\n+        }\n+\n+        vh = vh.asExact();\n+        try {\n+            setter.set(vh, buff, testValue); \/\/ should throw\n+            fail(\"Exception expected\");\n+        } catch (WrongMethodTypeException wmte) {\n+            assertMatches(wmte.getMessage(),\n+                \".*\\\\Qexpected (ByteBuffer,int,\" + arrayClass.componentType().getSimpleName() + \")void \\\\E.*\");\n+        }\n+    }\n+\n+    @Test(dataProvider = \"dataSetMemorySegment\")\n+    public void testExactSegmentSet(Class<?> carrier, Object testValue, SetSegmentX setter) {\n+        VarHandle vh = MemoryHandles.varHandle(carrier, ByteOrder.nativeOrder());\n+        try (MemorySegment seg = MemorySegment.allocateNative(8)) {\n+            MemoryAddress base = seg.baseAddress();\n+            try {\n+                vh.set(base, testValue);\n+                vh.asGeneric().set(base, testValue);\n+            } catch (WrongMethodTypeException wmte) {\n+                fail(\"Unexpected exception\", wmte);\n+            }\n+\n+            vh = vh.asExact();\n+            try {\n+                setter.set(vh, base, testValue); \/\/ should throw\n+                fail(\"Exception expected\");\n+            } catch (WrongMethodTypeException wmte) {\n+                assertMatches(wmte.getMessage(),\n+                    \".*\\\\Qexpected (MemoryAddress,\" + carrier.getSimpleName() + \")void \\\\E.*\");\n+            }\n+        }\n+    }\n+\n+    private static void assertMatches(String str, String pattern) {\n+        if (!str.matches(pattern)) {\n+            throw new AssertionError(\"'\" + str + \"' did not match the pattern '\" + pattern + \"'.\");\n+        }\n+    }\n+\n+    private interface SetX {\n+        void set(VarHandle vh, Widget w, Object testValue);\n+    }\n+\n+    private interface SetStaticX {\n+        void set(VarHandle vh, Object testValue);\n+    }\n+\n+    private interface GetX {\n+        void get(VarHandle vh, Widget w);\n+    }\n+\n+    private interface GetStaticX {\n+        void get(VarHandle vh);\n+    }\n+\n+    private interface SetArrayX {\n+        void set(VarHandle vh, Object array, Object testValue);\n+    }\n+\n+    private interface SetBufferX {\n+        void set(VarHandle vh, ByteBuffer buff, Object testValue);\n+    }\n+\n+    private interface SetSegmentX {\n+        void set(VarHandle vh, MemoryAddress addr, Object testValue);\n+    }\n+\n+    private static void consume(Object o) {}\n+\n+    private static void testCaseObjectAccess(List<Object[]> cases, String fieldBaseName, Class<?> fieldType, Object testValue,\n+                                    SetX setter, GetX getter,\n+                                    SetStaticX staticSetter, GetStaticX staticGetter) {\n+        cases.add(new Object[] { fieldBaseName, fieldType, false, testValue, setter, getter, staticSetter, staticGetter });\n+        cases.add(new Object[] { fieldBaseName, fieldType, true, testValue, setter, getter, staticSetter, staticGetter });\n+    }\n+\n+    private static void testCaseArraySet(List<Object[]> cases, Class<?> arrayType, Object testValue, SetArrayX setter) {\n+        cases.add(new Object[] { arrayType, testValue, setter });\n+    }\n+\n+    private static void testCaseBufferSet(List<Object[]> cases, Class<?> arrayType, Object testValue, SetBufferX setter) {\n+        cases.add(new Object[] { arrayType, testValue, setter });\n+    }\n+\n+    private static void testCaseSegmentSet(List<Object[]> cases, Class<?> carrier, Object testValue, SetSegmentX setter) {\n+        cases.add(new Object[] { carrier, testValue, setter });\n+    }\n+\n+    @DataProvider\n+    public static Object[][] dataObjectAccess() {\n+        List<Object[]> cases = new ArrayList<>();\n+\n+        \/\/ create a bunch of different sig-poly call sites\n+        testCaseObjectAccess(cases, \"objectField\", Object.class, \"abcd\",\n+                (vh, w, tv) -> vh.set(w, (String) tv),\n+                (vh, w) -> consume((String) vh.get(w)),\n+                (vh, tv) -> vh.set((String) tv),\n+                (vh) -> consume((String) vh.get()));\n+        testCaseObjectAccess(cases, \"objectField\", Object.class, Integer.valueOf(1234),\n+                (vh, w, tv) -> vh.set(w, (Integer) tv),\n+                (vh, w) -> consume((Integer) vh.get(w)),\n+                (vh, tv) -> vh.set((Integer) tv),\n+                (vh) -> consume((Integer) vh.get()));\n+        testCaseObjectAccess(cases, \"longField\", long.class, 1234,\n+                (vh, w, tv) -> vh.set(w, (int) tv),\n+                (vh, w) -> consume((int) vh.get(w)),\n+                (vh, tv) -> vh.set((int) tv),\n+                (vh) -> consume((int) vh.get()));\n+        testCaseObjectAccess(cases, \"longField\", long.class, (short) 1234,\n+                (vh, w, tv) -> vh.set(w, (short) tv),\n+                (vh, w) -> consume((short) vh.get(w)),\n+                (vh, tv) -> vh.set((short) tv),\n+                (vh) -> consume((short) vh.get()));\n+        testCaseObjectAccess(cases, \"longField\", long.class, (char) 1234,\n+                (vh, w, tv) -> vh.set(w, (char) tv),\n+                (vh, w) -> consume((char) vh.get(w)),\n+                (vh, tv) -> vh.set((char) tv),\n+                (vh) -> consume((char) vh.get()));\n+        testCaseObjectAccess(cases, \"longField\", long.class, (byte) 1234,\n+                (vh, w, tv) -> vh.set(w, (byte) tv),\n+                (vh, w) -> consume((byte) vh.get(w)),\n+                (vh, tv) -> vh.set((byte) tv),\n+                (vh) -> consume((byte) vh.get()));\n+        testCaseObjectAccess(cases, \"longField\", long.class, Long.valueOf(1234L),\n+                (vh, w, tv) -> vh.set(w, (Long) tv),\n+                (vh, w) -> consume((Long) vh.get(w)),\n+                (vh, tv) -> vh.set((Long) tv),\n+                (vh) -> consume((Long) vh.get()));\n+        testCaseObjectAccess(cases, \"doubleField\", double.class, 1234F,\n+                (vh, w, tv) -> vh.set(w, (float) tv),\n+                (vh, w) -> consume((float) vh.get(w)),\n+                (vh, tv) -> vh.set((float) tv),\n+                (vh) -> consume((float) vh.get()));\n+        testCaseObjectAccess(cases, \"doubleField\", double.class, 1234,\n+                (vh, w, tv) -> vh.set(w, (int) tv),\n+                (vh, w) -> consume((int) vh.get(w)),\n+                (vh, tv) -> vh.set((int) tv),\n+                (vh) -> consume((int) vh.get()));\n+        testCaseObjectAccess(cases, \"doubleField\", double.class, 1234L,\n+                (vh, w, tv) -> vh.set(w, (long) tv),\n+                (vh, w) -> consume((long) vh.get(w)),\n+                (vh, tv) -> vh.set((long) tv),\n+                (vh) -> consume((long) vh.get()));\n+        testCaseObjectAccess(cases, \"doubleField\", double.class, Double.valueOf(1234D),\n+                (vh, w, tv) -> vh.set(w, (Double) tv),\n+                (vh, w) -> consume((Double) vh.get(w)),\n+                (vh, tv) -> vh.set((Double) tv),\n+                (vh) -> consume((Double) vh.get()));\n+        testCaseObjectAccess(cases, \"aLongField\", Long.class, 1234L,\n+                (vh, w, tv) -> vh.set(w, (long) tv),\n+                (vh, w) -> consume((long) vh.get(w)),\n+                (vh, tv) -> vh.set((long) tv),\n+                (vh) -> consume((long) vh.get()));\n+\n+        return cases.toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public static Object[][] dataSetArray() {\n+        List<Object[]> cases = new ArrayList<>();\n+\n+        \/\/ create a bunch of different sig-poly call sites\n+        testCaseArraySet(cases, Object[].class, \"abcd\",                (vh, arr, tv) -> vh.set((Object[]) arr, 0, (String) tv));\n+        testCaseArraySet(cases, Object[].class, Integer.valueOf(1234), (vh, arr, tv) -> vh.set((Object[]) arr, (Integer) tv));\n+        testCaseArraySet(cases, long[].class, 1234,                    (vh, arr, tv) -> vh.set((long[]) arr, 0, (int) tv));\n+        testCaseArraySet(cases, long[].class, (short) 1234,            (vh, arr, tv) -> vh.set((long[]) arr, 0, (short) tv));\n+        testCaseArraySet(cases, long[].class, (char)  1234,            (vh, arr, tv) -> vh.set((long[]) arr, 0, (char) tv));\n+        testCaseArraySet(cases, long[].class, (byte)  1234,            (vh, arr, tv) -> vh.set((long[]) arr, 0, (byte) tv));\n+        testCaseArraySet(cases, long[].class, Long.valueOf(1234L),     (vh, arr, tv) -> vh.set((long[]) arr, 0, (Long) tv));\n+        testCaseArraySet(cases, double[].class, 1234F,                 (vh, arr, tv) -> vh.set((double[]) arr, 0, (float) tv));\n+        testCaseArraySet(cases, double[].class, 1234,                  (vh, arr, tv) -> vh.set((double[]) arr, 0, (int) tv));\n+        testCaseArraySet(cases, double[].class, 1234L,                 (vh, arr, tv) -> vh.set((double[]) arr, 0, (long) tv));\n+        testCaseArraySet(cases, double[].class, Double.valueOf(1234D), (vh, arr, tv) -> vh.set((double[]) arr, 0, (Double) tv));\n+        testCaseArraySet(cases, Long[].class, 1234L,                   (vh, arr, tv) -> vh.set((Long[]) arr, 0, (long) tv));\n+\n+        return cases.toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public static Object[][] dataSetBuffer() {\n+        List<Object[]> cases = new ArrayList<>();\n+\n+        \/\/ create a bunch of different sig-poly call sites\n+        testCaseBufferSet(cases, long[].class, 1234,                    (vh, buff, tv) -> vh.set(buff, 0, (int) tv));\n+        testCaseBufferSet(cases, long[].class, (short) 1234,            (vh, buff, tv) -> vh.set(buff, 0, (short) tv));\n+        testCaseBufferSet(cases, long[].class, (char)  1234,            (vh, buff, tv) -> vh.set(buff, 0, (char) tv));\n+        testCaseBufferSet(cases, long[].class, (byte)  1234,            (vh, buff, tv) -> vh.set(buff, 0, (byte) tv));\n+        testCaseBufferSet(cases, long[].class, Long.valueOf(1234L),     (vh, buff, tv) -> vh.set(buff, 0, (Long) tv));\n+        testCaseBufferSet(cases, double[].class, 1234F,                 (vh, buff, tv) -> vh.set(buff, 0, (float) tv));\n+        testCaseBufferSet(cases, double[].class, 1234,                  (vh, buff, tv) -> vh.set(buff, 0, (int) tv));\n+        testCaseBufferSet(cases, double[].class, 1234L,                 (vh, buff, tv) -> vh.set(buff, 0, (long) tv));\n+        testCaseBufferSet(cases, double[].class, Double.valueOf(1234D), (vh, buff, tv) -> vh.set(buff, 0, (Double) tv));\n+\n+        return cases.toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public static Object[][] dataSetMemorySegment() {\n+        List<Object[]> cases = new ArrayList<>();\n+\n+        \/\/ create a bunch of different sig-poly call sites\n+        testCaseSegmentSet(cases, long.class, 1234,         (vh, addr, tv) -> vh.set(addr, (int) tv));\n+        testCaseSegmentSet(cases, long.class, (char) 1234,  (vh, addr, tv) -> vh.set(addr, (char) tv));\n+        testCaseSegmentSet(cases, long.class, (short) 1234, (vh, addr, tv) -> vh.set(addr, (short) tv));\n+        testCaseSegmentSet(cases, long.class, (byte) 1234,  (vh, addr, tv) -> vh.set(addr, (byte) tv));\n+        testCaseSegmentSet(cases, double.class, 1234F,      (vh, addr, tv) -> vh.set(addr, (float) tv));\n+\n+        return cases.toArray(Object[][]::new);\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestExact.java","additions":416,"deletions":0,"binary":false,"changes":416,"status":"added"}]}