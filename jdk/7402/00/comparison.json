{"files":[{"patch":"@@ -667,4 +667,1 @@\n-            boolean exhaustiveSwitch = tree.patternSwitch ||\n-                                       tree.cases.stream()\n-                                                 .flatMap(c -> c.labels.stream())\n-                                                 .anyMatch(l -> TreeInfo.isNull(l));\n+            boolean exhaustiveSwitch = TreeInfo.expectedExhaustive(tree);\n@@ -692,4 +689,7 @@\n-            if (!tree.hasTotalPattern && exhaustiveSwitch &&\n-                !TreeInfo.isErrorEnumSwitch(tree.selector, tree.cases) &&\n-                (constants == null || !isExhaustive(tree.selector.pos(), tree.selector.type, constants))) {\n-                log.error(tree, Errors.NotExhaustiveStatement);\n+            tree.isExhaustive = tree.hasTotalPattern ||\n+                                TreeInfo.isErrorEnumSwitch(tree.selector, tree.cases);\n+            if (exhaustiveSwitch) {\n+                tree.isExhaustive |= isExhaustive(tree.selector.pos(), tree.selector.type, constants);\n+                if (!tree.isExhaustive) {\n+                    log.error(tree, Errors.NotExhaustiveStatement);\n+                }\n@@ -728,2 +728,4 @@\n-            if (!tree.hasTotalPattern && !TreeInfo.isErrorEnumSwitch(tree.selector, tree.cases) &&\n-                !isExhaustive(tree.selector.pos(), tree.selector.type, constants)) {\n+            tree.isExhaustive = tree.hasTotalPattern ||\n+                                TreeInfo.isErrorEnumSwitch(tree.selector, tree.cases) ||\n+                                isExhaustive(tree.selector.pos(), tree.selector.type, constants);\n+            if (!tree.isExhaustive) {\n@@ -2435,1 +2437,1 @@\n-            handleSwitch(tree, tree.selector, tree.cases, tree.hasTotalPattern);\n+            handleSwitch(tree, tree.selector, tree.cases, tree.isExhaustive);\n@@ -2439,1 +2441,1 @@\n-            handleSwitch(tree, tree.selector, tree.cases, tree.hasTotalPattern);\n+            handleSwitch(tree, tree.selector, tree.cases, tree.isExhaustive);\n@@ -2443,1 +2445,1 @@\n-                                  List<JCCase> cases, boolean hasTotalPattern) {\n+                                  List<JCCase> cases, boolean isExhaustive) {\n@@ -2481,1 +2483,1 @@\n-            if (!hasTotalPattern) {\n+            if (!isExhaustive) {\n@@ -2484,1 +2486,1 @@\n-                } else {\n+                } else if (tree.hasTag(SWITCH) && !TreeInfo.expectedExhaustive((JCSwitch) tree)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":17,"deletions":15,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -1288,0 +1288,1 @@\n+        public boolean isExhaustive;\n@@ -1374,0 +1375,1 @@\n+        public boolean isExhaustive;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1387,0 +1387,6 @@\n+    public static boolean expectedExhaustive(JCSwitch tree) {\n+        return tree.patternSwitch ||\n+               tree.cases.stream()\n+                         .flatMap(c -> c.labels.stream())\n+                         .anyMatch(l -> TreeInfo.isNull(l));\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8262891 8268871 8274363\n+ * @bug 8262891 8268871 8274363 8281100\n@@ -794,0 +794,76 @@\n+    @Test\n+    public void testDefiniteAssignment(Path base) throws Exception {\n+        doTest(base,\n+               new String[]{\"\"\"\n+                            package lib;\n+                            public sealed interface S permits A, B {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class A implements S {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class B implements S {}\n+                            \"\"\"},\n+               \"\"\"\n+               package test;\n+               import lib.*;\n+               public class Test {\n+                   private void testStatement(S obj) {\n+                       int data;\n+                       switch (obj) {\n+                           case A a -> data = 0;\n+                           case B b -> data = 0;\n+                       };\n+                       System.err.println(data);\n+                   }\n+                   private void testExpression(S obj) {\n+                       int data;\n+                       int v = switch (obj) {\n+                           case A a -> data = 0;\n+                           case B b -> data = 0;\n+                       };\n+                       System.err.println(data);\n+                   }\n+                   private void testStatementNotExhaustive(S obj) {\n+                       int data;\n+                       switch (obj) {\n+                           case A a -> data = 0;\n+                       };\n+                       System.err.println(data);\n+                   }\n+                   private void testExpressionNotExhaustive(S obj) {\n+                       int data;\n+                       int v = switch (obj) {\n+                           case A a -> data = 0;\n+                       };\n+                       System.err.println(data);\n+                   }\n+                   private void testStatementErrorEnum(E e) { \/\/\"E\" is intentionally unresolvable\n+                       int data;\n+                       switch (e) {\n+                           case A -> data = 0;\n+                           case B -> data = 0;\n+                       };\n+                       System.err.println(data);\n+                   }\n+                   private void testExpressionErrorEnum(E e) { \/\/\"E\" is intentionally unresolvable\n+                       int data;\n+                       int v = switch (e) {\n+                           case A -> data = 0;\n+                           case B -> data = 0;\n+                       };\n+                       System.err.println(data);\n+                   }\n+               }\n+               \"\"\",\n+               \"Test.java:34:41: compiler.err.cant.resolve.location: kindname.class, E, , , (compiler.misc.location: kindname.class, test.Test, null)\",\n+               \"Test.java:42:42: compiler.err.cant.resolve.location: kindname.class, E, , , (compiler.misc.location: kindname.class, test.Test, null)\",\n+               \"Test.java:22:9: compiler.err.not.exhaustive.statement\",\n+               \"Test.java:29:17: compiler.err.not.exhaustive\",\n+               \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n+               \"- compiler.note.preview.recompile\",\n+               \"4 errors\");\n+    }\n+\n@@ -828,1 +904,2 @@\n-                             \"--class-path\", libClasses.toString())\n+                             \"--class-path\", libClasses.toString(),\n+                             \"-XDshould-stop.at=FLOW\")\n","filename":"test\/langtools\/tools\/javac\/patterns\/Exhaustiveness.java","additions":79,"deletions":2,"binary":false,"changes":81,"status":"modified"}]}