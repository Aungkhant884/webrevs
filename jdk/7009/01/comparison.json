{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -102,0 +102,3 @@\n+JRT_ENTRY(void, at_safepoint(JavaThread* current)) {}\n+JRT_END\n+\n@@ -110,6 +113,4 @@\n-#define RETURN_SAFEPOINT                                                                                  \\\n-    if (SafepointMechanism::should_process(THREAD)) {                                                     \\\n-      HandleMarkCleaner __hmc(THREAD);                                                                    \\\n-      CALL_VM(SafepointMechanism::process_if_requested_with_exit_check(THREAD, true \/* check asyncs *\/),  \\\n-              handle_exception);                                                                          \\\n-    }                                                                                                     \\\n+#define RETURN_SAFEPOINT                                    \\\n+    if (SafepointMechanism::should_process(THREAD)) {       \\\n+      CALL_VM(at_safepoint(THREAD), handle_exception);      \\\n+    }\n","filename":"src\/hotspot\/share\/interpreter\/zero\/bytecodeInterpreter.cpp","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -491,2 +491,0 @@\n-  assert(_handshakee->thread_state() != _thread_blocked, \"should not be in a blocked state\");\n-  assert(_handshakee->thread_state() != _thread_in_native, \"should not be in native\");\n@@ -494,1 +492,4 @@\n-  ThreadInVMForHandshake tivm(_handshakee);\n+  _handshakee->frame_anchor()->make_walkable(_handshakee);\n+  \/\/ Threads shouldn't block if they are in the middle of printing, but...\n+  ttyLocker::break_tty_lock_for_safepoint(os::current_thread_id());\n+\n","filename":"src\/hotspot\/share\/runtime\/handshake.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -123,23 +123,0 @@\n-class ThreadInVMForHandshake : public ThreadStateTransition {\n-  const JavaThreadState _original_state;\n- public:\n-  ThreadInVMForHandshake(JavaThread* thread) : ThreadStateTransition(thread),\n-      _original_state(thread->thread_state()) {\n-\n-    if (thread->has_last_Java_frame()) {\n-      thread->frame_anchor()->make_walkable(thread);\n-    }\n-\n-    thread->set_thread_state(_thread_in_vm);\n-\n-    \/\/ Threads shouldn't block if they are in the middle of printing, but...\n-    ttyLocker::break_tty_lock_for_safepoint(os::current_thread_id());\n-  }\n-\n-  ~ThreadInVMForHandshake() {\n-    assert(_thread->thread_state() == _thread_in_vm, \"should only call when leaving VM after handshake\");\n-    _thread->set_thread_state(_original_state);\n-  }\n-\n-};\n-\n@@ -225,1 +202,1 @@\n-  ThreadBlockInVMPreprocess(JavaThread* thread, PRE_PROC& pr = emptyOp, bool allow_suspend = false)\n+  ThreadBlockInVMPreprocess(JavaThread* thread, PRE_PROC& pr, bool allow_suspend = false)\n@@ -239,0 +216,1 @@\n+};\n@@ -240,0 +218,5 @@\n+class ThreadBlockInVM  : public ThreadBlockInVMPreprocess<> {\n+ public:\n+  ThreadBlockInVM(JavaThread* thread, bool allow_suspend = false)\n+    : ThreadBlockInVMPreprocess(thread, emptyOp, allow_suspend) {}\n+ private:\n@@ -243,2 +226,0 @@\n-typedef ThreadBlockInVMPreprocess<> ThreadBlockInVM;\n-\n","filename":"src\/hotspot\/share\/runtime\/interfaceSupport.inline.hpp","additions":8,"deletions":27,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -757,0 +757,1 @@\n+  thread->set_thread_state(_thread_in_vm);\n@@ -768,0 +769,2 @@\n+\n+  thread->set_thread_state(_thread_in_Java);\n@@ -973,1 +976,0 @@\n-      ThreadInVMfromJava __tiv(self, false \/* check asyncs *\/);\n","filename":"src\/hotspot\/share\/runtime\/safepoint.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -129,4 +129,0 @@\n-  static bool is_a_block_safe_state(JavaThreadState state) {\n-    \/\/ Check that we have a valid thread_state before blocking for safepoints\n-    return state == _thread_in_vm || state == _thread_in_Java;\n-  }\n","filename":"src\/hotspot\/share\/runtime\/safepoint.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -122,1 +122,1 @@\n-    guarantee(SafepointSynchronize::is_a_block_safe_state(state), \"Illegal threadstate encountered: %d\", state);\n+    guarantee(state == _thread_in_vm, \"Illegal threadstate encountered: %d\", state);\n","filename":"src\/hotspot\/share\/runtime\/safepointMechanism.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1649,18 +1649,4 @@\n-    switch (thread_state()) {\n-    case _thread_in_vm: {\n-      JavaThread* THREAD = this;\n-      Exceptions::throw_unsafe_access_internal_error(THREAD, __FILE__, __LINE__, \"a fault occurred in an unsafe memory access operation\");\n-      \/\/ We might have blocked in a ThreadBlockInVM wrapper in the call above so make sure we process pending\n-      \/\/ suspend requests and object reallocation operations if any since we might be going to Java after this.\n-      SafepointMechanism::process_if_requested_with_exit_check(this, true \/* check asyncs *\/);\n-      return;\n-    }\n-    case _thread_in_Java: {\n-      ThreadInVMfromJava tiv(this);\n-      JavaThread* THREAD = this;\n-      Exceptions::throw_unsafe_access_internal_error(THREAD, __FILE__, __LINE__, \"a fault occurred in an unsafe memory access operation in compiled Java code\");\n-      return;\n-    }\n-    default:\n-      ShouldNotReachHere();\n-    }\n+    Exceptions::throw_unsafe_access_internal_error(this, __FILE__, __LINE__, \"a fault occurred in an unsafe memory access operation\");\n+    \/\/ We might have blocked in a ThreadBlockInVM wrapper in the call above so make sure we process pending\n+    \/\/ suspend requests and object reallocation operations if any since we might be going to Java after this.\n+    SafepointMechanism::process_if_requested_with_exit_check(this, true \/* check asyncs *\/);\n@@ -1773,12 +1759,5 @@\n-\/\/ this thread.\n-\/\/ Raw thread state transition to _thread_blocked and back again to the original\n-\/\/ state before returning are performed. The current thread is required to\n-\/\/ change to _thread_blocked in order to be seen to be safepoint\/handshake safe\n-\/\/ whilst suspended and only after becoming handshake safe, the other thread can\n-\/\/ complete the handshake used to synchronize with this thread and then perform\n-\/\/ the reallocation and relocking. We cannot use the thread state transition\n-\/\/ helpers because we arrive here in various states and also because the helpers\n-\/\/ indirectly call this method.  After leaving _thread_blocked we have to check\n-\/\/ for safepoint\/handshake, except if _thread_in_native. The thread is safe\n-\/\/ without blocking then. Allowed states are enumerated in\n-\/\/ SafepointSynchronize::block(). See also EscapeBarrier::sync_and_suspend_*()\n+\/\/ this thread. The current thread is required to change to _thread_blocked in order\n+\/\/ to be seen to be safepoint\/handshake safe whilst suspended and only after becoming\n+\/\/ handshake safe, the other thread can complete the handshake used to synchronize\n+\/\/ with this thread and then perform the reallocation and relocking.\n+\/\/ See EscapeBarrier::sync_and_suspend_*()\n@@ -1789,1 +1768,0 @@\n-  JavaThreadState state = thread_state();\n@@ -1793,1 +1771,1 @@\n-    set_thread_state(_thread_blocked);\n+    ThreadBlockInVM tbivm(this, true \/* allow_suspend *\/);\n@@ -1811,8 +1789,0 @@\n-    \/\/ The current thread could have been suspended again. We have to check for\n-    \/\/ suspend after restoring the saved state. Without this the current thread\n-    \/\/ might return to _thread_in_Java and execute bytecode.\n-    set_thread_state_fence(state);\n-\n-    if (state != _thread_in_native) {\n-      SafepointMechanism::process_if_requested(this);\n-    }\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":11,"deletions":41,"binary":false,"changes":52,"status":"modified"}]}