{"files":[{"patch":"@@ -42,1 +42,1 @@\n-  void apply_to_buffer(BufferNode* node, size_t buffer_capacity, uint worker_id) {\n+  void apply_to_buffer(BufferNode* node, uint worker_id) {\n@@ -44,1 +44,2 @@\n-    for (size_t i = node->index(); i < buffer_capacity; ++i) {\n+    size_t capacity = node->capacity();\n+    for (size_t i = node->index(); i < capacity; ++i) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardTableEntryClosure.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -89,1 +89,1 @@\n-    stats->inc_dirtied_cards(buffer_capacity() - queue.index());\n+    stats->inc_dirtied_cards(queue.size());\n@@ -107,0 +107,1 @@\n+    assert(old_node->index() == 0, \"invariant\");\n@@ -108,1 +109,1 @@\n-    stats->inc_dirtied_cards(buffer_capacity());\n+    stats->inc_dirtied_cards(old_node->capacity());\n@@ -126,1 +127,1 @@\n-  Atomic::add(&_num_cards, buffer_capacity() - cbn->index());\n+  Atomic::add(&_num_cards, cbn->size());\n@@ -162,1 +163,1 @@\n-  Atomic::sub(&_num_cards, buffer_capacity() - result->index());\n+  Atomic::sub(&_num_cards, result->size());\n@@ -172,1 +173,1 @@\n-    actual += buffer_capacity() - cur->index();\n+    actual += cur->size();\n@@ -288,1 +289,1 @@\n-  Atomic::add(&_num_cards, buffer_capacity() - node->index());\n+  Atomic::add(&_num_cards, node->size());\n@@ -425,1 +426,0 @@\n-                        size_t node_buffer_capacity,\n@@ -430,1 +430,1 @@\n-    _node_buffer_capacity(node_buffer_capacity),\n+    _node_buffer_capacity(node->capacity()),\n@@ -459,4 +459,1 @@\n-  G1RefineBufferedCards buffered_cards(node,\n-                                       buffer_capacity(),\n-                                       worker_id,\n-                                       stats);\n+  G1RefineBufferedCards buffered_cards(node, worker_id, stats);\n@@ -471,3 +468,2 @@\n-    assert(node->index() == buffer_capacity(),\n-           \"Buffer not fully consumed: index: \" SIZE_FORMAT \", size: \" SIZE_FORMAT,\n-           node->index(), buffer_capacity());\n+    assert(node->is_empty(), \"Buffer not fully consumed: index: %zu, size: %zu\",\n+           node->index(), node->capacity());\n@@ -476,1 +472,1 @@\n-    assert(node->index() < buffer_capacity(), \"Buffer fully consumed.\");\n+    assert(!node->is_empty(), \"Buffer fully consumed.\");\n@@ -578,2 +574,1 @@\n-  if ((queue.buffer() != nullptr) &&\n-      (queue.index() != buffer_capacity())) {\n+  if (!queue.is_empty()) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1DirtyCardQueue.cpp","additions":13,"deletions":18,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-  _buffers._entry_count += buffer_capacity() - node->index();\n+  _buffers._entry_count += node->size();\n@@ -133,1 +133,1 @@\n-  Atomic::add(&_entry_count, buffer_capacity() - node->index());\n+  Atomic::add(&_entry_count, node->size());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RedirtyCardsQueue.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1267,1 +1267,0 @@\n-    size_t buffer_capacity = dcqs.buffer_capacity();\n@@ -1269,1 +1268,1 @@\n-      cl->apply_to_buffer(node, buffer_capacity, worker_id);\n+      cl->apply_to_buffer(node, worker_id);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -417,1 +417,0 @@\n-    const size_t buffer_capacity = _rdcqs->buffer_capacity();\n@@ -423,1 +422,1 @@\n-        cl.apply_to_buffer(node, buffer_capacity, worker_id);\n+        cl.apply_to_buffer(node, worker_id);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -170,2 +170,1 @@\n-    size_t _buffer_capacity;\n-    Verifier() : _buffer_capacity(G1BarrierSet::dirty_card_queue_set().buffer_capacity()) {}\n+    Verifier() {}\n@@ -174,2 +173,1 @@\n-      assert((queue.buffer() == nullptr) || (queue.index() == _buffer_capacity),\n-             \"non-empty dirty card queue for thread %s\", t->name());\n+      assert(queue.is_empty(), \"non-empty dirty card queue for thread %s\", t->name());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPreEvacuateTasks.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -149,1 +149,1 @@\n-          range(1, max_uintx)                                               \\\n+          constraint(G1SATBBufferSizeConstraintFunc, AtParse)               \\\n@@ -169,1 +169,1 @@\n-          range(1, NOT_LP64(32*M) LP64_ONLY(1*G))                           \\\n+          constraint(G1UpdateBufferSizeConstraintFunc, AtParse)             \\\n","filename":"src\/hotspot\/share\/gc\/g1\/g1_globals.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/shared\/ptrQueue.hpp\"\n@@ -183,0 +184,29 @@\n+\n+static JVMFlag::Error buffer_size_constraint_helper(JVMFlagsEnum flagid,\n+                                                    size_t value,\n+                                                    bool verbose) {\n+  if (UseG1GC) {\n+    const size_t min_size = 1;\n+    const size_t max_size = BufferNode::max_size();\n+    JVMFlag* flag = JVMFlag::flag_from_enum(flagid);\n+    if ((value < min_size) || (value > max_size)) {\n+      JVMFlag::printError(verbose,\n+                          \"%s (%zu) must be in range [%zu, %zu]\\n\",\n+                          flag->name(), value, min_size, max_size);\n+      return JVMFlag::OUT_OF_BOUNDS;\n+    }\n+  }\n+  return JVMFlag::SUCCESS;\n+}\n+\n+JVMFlag::Error G1SATBBufferSizeConstraintFunc(size_t value, bool verbose) {\n+  return buffer_size_constraint_helper(FLAG_MEMBER_ENUM(G1SATBBufferSize),\n+                                       value,\n+                                       verbose);\n+}\n+\n+JVMFlag::Error G1UpdateBufferSizeConstraintFunc(size_t value, bool verbose) {\n+  return buffer_size_constraint_helper(FLAG_MEMBER_ENUM(G1UpdateBufferSize),\n+                                       value,\n+                                       verbose);\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/jvmFlagConstraintsG1.cpp","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -46,1 +46,6 @@\n-  f(size_t, NewSizeConstraintFuncG1)\n+  f(size_t, NewSizeConstraintFuncG1)                  \\\n+                                                      \\\n+  \/* G1 PtrQueue buffer size constraints *\/           \\\n+  f(size_t, G1SATBBufferSizeConstraintFunc)           \\\n+  f(size_t, G1UpdateBufferSizeConstraintFunc)         \\\n+  \/* *\/\n","filename":"src\/hotspot\/share\/gc\/g1\/jvmFlagConstraintsG1.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-  _capacity_in_bytes(index_to_byte_index(qset->buffer_capacity())),\n@@ -41,1 +40,14 @@\n-BufferNode::AllocatorConfig::AllocatorConfig(size_t size) : _buffer_capacity(size) {}\n+size_t PtrQueue::current_capacity() const {\n+  if (_buf == nullptr) {\n+    return 0;\n+  } else {\n+    return BufferNode::make_node_from_buffer(_buf)->capacity();\n+  }\n+}\n+\n+BufferNode::AllocatorConfig::AllocatorConfig(size_t size)\n+  : _buffer_capacity(size)\n+{\n+  assert(size >= 1, \"Invalid buffer capacity %zu\", size);\n+  assert(size <= max_size(), \"Invalid buffer capacity %zu\", size);\n+}\n@@ -44,1 +56,1 @@\n-  size_t byte_size = _buffer_capacity * sizeof(void*);\n+  size_t byte_size = buffer_capacity() * sizeof(void*);\n@@ -56,3 +68,1 @@\n-{\n-\n-}\n+{}\n@@ -65,1 +75,2 @@\n-  return ::new (_free_list.allocate()) BufferNode();\n+  auto internal_capacity = static_cast<InternalSizeType>(buffer_capacity());\n+  return ::new (_free_list.allocate()) BufferNode(internal_capacity);\n@@ -71,0 +82,2 @@\n+  assert(node->capacity() == buffer_capacity(),\n+         \"Wrong size %zu, expected %zu\", node->capacity(), buffer_capacity());\n@@ -82,3 +95,1 @@\n-  if (queue.buffer() != nullptr) {\n-    queue.set_index(buffer_capacity());\n-  }\n+  queue.set_index(queue.current_capacity());\n@@ -94,1 +105,1 @@\n-    if (index == buffer_capacity()) {\n+    if (index == node->capacity()) {\n@@ -131,2 +142,3 @@\n-  queue.set_buffer(allocate_buffer());\n-  queue.set_index(buffer_capacity());\n+  BufferNode* node = _allocator->allocate();\n+  queue.set_buffer(BufferNode::make_buffer_from_node(node));\n+  queue.set_index(node->capacity());\n","filename":"src\/hotspot\/share\/gc\/shared\/ptrQueue.cpp","additions":25,"deletions":13,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include <limits>\n@@ -53,4 +54,0 @@\n-  \/\/ Size of the current buffer, in bytes.\n-  \/\/ Value is always pointer-size aligned.\n-  size_t _capacity_in_bytes;\n-\n@@ -59,6 +56,0 @@\n-  \/\/ Get the capacity, in bytes.  The capacity must have been set.\n-  size_t capacity_in_bytes() const {\n-    assert(_capacity_in_bytes > 0, \"capacity not set\");\n-    return _capacity_in_bytes;\n-  }\n-\n@@ -95,1 +86,1 @@\n-    assert(new_index <= capacity(), \"precondition\");\n+    assert(new_index <= current_capacity(), \"precondition\");\n@@ -99,3 +90,3 @@\n-  size_t capacity() const {\n-    return byte_index_to_index(capacity_in_bytes());\n-  }\n+  \/\/ Returns the capacity of the buffer, or 0 if the queue doesn't currently\n+  \/\/ have a buffer.\n+  size_t current_capacity() const;\n@@ -103,1 +94,2 @@\n-  \/\/ To support compiler.\n+  bool is_empty() const { return index() == current_capacity(); }\n+  size_t size() const { return current_capacity() - index(); }\n@@ -106,0 +98,1 @@\n+  \/\/ To support compiler.\n@@ -122,1 +115,5 @@\n-  size_t _index;\n+  using InternalSizeType = LP64_ONLY(uint32_t) NOT_LP64(uint16_t);\n+  static_assert(sizeof(InternalSizeType) <= sizeof(size_t), \"assumption\");\n+\n+  InternalSizeType _index;\n+  InternalSizeType _capacity;\n@@ -126,2 +123,5 @@\n-  BufferNode() : _index(0), _next(nullptr) { }\n-  ~BufferNode() { }\n+  BufferNode(InternalSizeType capacity)\n+    : _index(capacity), _capacity(capacity), _next(nullptr)\n+  {}\n+\n+  ~BufferNode() = default;\n@@ -136,0 +136,4 @@\n+  static constexpr size_t max_size() {\n+    return std::numeric_limits<InternalSizeType>::max();\n+  }\n+\n@@ -142,1 +146,16 @@\n-  void set_index(size_t i)     { _index = i; }\n+\n+  void set_index(size_t i)     {\n+    assert(i <= capacity(), \"precondition\");\n+    _index = static_cast<InternalSizeType>(i);\n+  }\n+\n+  size_t capacity() const      { return _capacity; }\n+\n+  bool is_empty() const { return index() == capacity(); }\n+  size_t size() const { return capacity() - index(); }\n+\n+  \/\/ Return the BufferNode containing the buffer, WITHOUT setting its index.\n+  static BufferNode* make_node_from_buffer(void** buffer) {\n+    char* base = reinterpret_cast<char*>(buffer) - buffer_offset();\n+    return reinterpret_cast<BufferNode*>(base);\n+  }\n@@ -146,3 +165,1 @@\n-    BufferNode* node =\n-      reinterpret_cast<BufferNode*>(\n-        reinterpret_cast<char*>(buffer) - buffer_offset());\n+    BufferNode* node = make_node_from_buffer(buffer);\n@@ -169,0 +186,1 @@\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/ptrQueue.hpp","additions":40,"deletions":22,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-  print_satb_buffer(name, _buf, index(), capacity());\n+  print_satb_buffer(name, _buf, index(), current_capacity());\n@@ -196,4 +196,4 @@\n-      if (queue.buffer() != nullptr) {\n-        assert(!_active || queue.index() == _qset->buffer_capacity(),\n-               \"queues should be empty when activated\");\n-        queue.set_index(_qset->buffer_capacity());\n+      if (_active) {\n+        assert(queue.is_empty(), \"queues should be empty when activated\");\n+      } else {\n+        queue.set_index(queue.current_capacity());\n@@ -211,4 +211,1 @@\n-    size_t index = nd->index();\n-    size_t size = buffer_capacity();\n-    assert(index <= size, \"invariant\");\n-    cl->do_buffer(buf + index, size - index);\n+    cl->do_buffer(buf + nd->index(), nd->size());\n@@ -253,0 +250,1 @@\n+  assert(queue.buffer() != nullptr, \"precondition\");\n@@ -258,1 +256,1 @@\n-  assert(threshold <= buffer_capacity(),\n+  assert(threshold <= queue.current_capacity(),\n@@ -260,1 +258,1 @@\n-         threshold, buffer_capacity());\n+         threshold, queue.current_capacity());\n@@ -313,1 +311,1 @@\n-    print_satb_buffer(buffer, buf, nd->index(), buffer_capacity());\n+    print_satb_buffer(buffer, buf, nd->index(), nd->capacity());\n","filename":"src\/hotspot\/share\/gc\/shared\/satbMarkQueue.cpp","additions":10,"deletions":12,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -178,1 +178,1 @@\n-    \/\/ nothing to do\n+    \/\/ Nothing to do, and avoid pointer arithmetic on nullptr below.\n@@ -183,2 +183,2 @@\n-  void** src = &buf[queue.index()];\n-  void** dst = &buf[buffer_capacity()];\n+  void** src = buf + queue.index();\n+  void** dst = buf + queue.current_capacity();\n","filename":"src\/hotspot\/share\/gc\/shared\/satbMarkQueue.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}