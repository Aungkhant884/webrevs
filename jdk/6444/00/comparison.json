{"files":[{"patch":"@@ -2481,1 +2481,1 @@\n-const TypeVect* Matcher::predicate_reg_type(const Type* elemTy, int length) {\n+const TypeVectMask* Matcher::predicate_reg_type(const Type* elemTy, int length) {\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5648,1 +5648,16 @@\n-%}\n\\ No newline at end of file\n+%}\n+\n+\/\/ ---------------------------- Vector mask generation ---------------------------\n+instruct vmask_gen(pRegGov pg, iRegL len, rFlagsReg cr) %{\n+  predicate(UseSVE > 0);\n+  match(Set pg (VectorMaskGen len));\n+  effect(KILL cr);\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_whilelo $pg, zr, $len\\t # sve\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_whilelo(as_PRegister($pg$$reg), size, zr, as_Register($len$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve.ad","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -3141,1 +3141,16 @@\n-%}dnl\n+%}\n+\n+\/\/ ---------------------------- Vector mask generation ---------------------------\n+instruct vmask_gen(pRegGov pg, iRegL len, rFlagsReg cr) %{\n+  predicate(UseSVE > 0);\n+  match(Set pg (VectorMaskGen len));\n+  effect(KILL cr);\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_whilelo $pg, zr, $len\\t # sve\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_whilelo(as_PRegister($pg$$reg), size, zr, as_Register($len$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve_ad.m4","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -465,0 +465,8 @@\n+  int inline_size = (UseSVE > 0 && MaxVectorSize >= 16) ? MaxVectorSize : 0;\n+  if (FLAG_IS_DEFAULT(ArrayOperationPartialInlineSize)) {\n+    FLAG_SET_DEFAULT(ArrayOperationPartialInlineSize, inline_size);\n+  } else if (ArrayOperationPartialInlineSize != 0 && ArrayOperationPartialInlineSize != inline_size) {\n+    warning(\"Setting ArrayOperationPartialInlineSize to %d\", inline_size);\n+    ArrayOperationPartialInlineSize = inline_size;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -994,1 +994,1 @@\n-const TypeVect* Matcher::predicate_reg_type(const Type* elemTy, int length) {\n+const TypeVectMask* Matcher::predicate_reg_type(const Type* elemTy, int length) {\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2188,1 +2188,1 @@\n-const TypeVect* Matcher::predicate_reg_type(const Type* elemTy, int length) {\n+const TypeVectMask* Matcher::predicate_reg_type(const Type* elemTy, int length) {\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1547,1 +1547,1 @@\n-const TypeVect* Matcher::predicate_reg_type(const Type* elemTy, int length) {\n+const TypeVectMask* Matcher::predicate_reg_type(const Type* elemTy, int length) {\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2046,1 +2046,1 @@\n-const TypeVect* Matcher::predicate_reg_type(const Type* elemTy, int length) {\n+const TypeVectMask* Matcher::predicate_reg_type(const Type* elemTy, int length) {\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-          range(0, 64)                                                      \\\n+          range(0, 256)                                                     \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5430,1 +5430,1 @@\n-        Node* vmask      = _gvn.transform(new VectorMaskGenNode(ConvI2X(casted_length), TypeVect::VECTMASK, elem_bt));\n+        Node* vmask      = _gvn.transform(VectorMaskGenNode::make(ConvI2X(casted_length), elem_bt));\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -240,1 +240,1 @@\n-  Node* mask_gen =  new VectorMaskGenNode(casted_length, TypeVect::VECTMASK, type);\n+  Node* mask_gen = VectorMaskGenNode::make(casted_length, type);\n","filename":"src\/hotspot\/share\/opto\/macroArrayCopy.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -335,1 +335,1 @@\n-  static const TypeVect* predicate_reg_type(const Type* elemTy, int length);\n+  static const TypeVectMask* predicate_reg_type(const Type* elemTy, int length);\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2393,2 +2393,1 @@\n-    const TypeVect* mtype = Matcher::predicate_reg_type(elem, length);\n-    return (TypeVect*)(const_cast<TypeVect*>(mtype))->hashcons();\n+    return TypeVectMask::make(elem, length);\n@@ -2508,0 +2507,9 @@\n+const TypeVectMask *TypeVectMask::make(const BasicType elem_bt, uint length) {\n+  return make(get_const_basic_type(elem_bt), length);\n+}\n+\n+const TypeVectMask *TypeVectMask::make(const Type* elem, uint length) {\n+  const TypeVectMask* mtype = Matcher::predicate_reg_type(elem, length);\n+  return (TypeVectMask*) const_cast<TypeVectMask*>(mtype)->hashcons();\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -873,0 +873,2 @@\n+  static const TypeVectMask* make(const BasicType elem_bt, uint length);\n+  static const TypeVectMask* make(const Type* elem, uint length);\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -804,4 +804,4 @@\n-      BasicType mask_bt = ((VectorMaskGenNode*)in(3))->get_elem_type();\n-      uint load_sz      = type2aelembytes(mask_bt) * ty->get_con();\n-      if ( load_sz == 32 || load_sz == 64) {\n-        assert(load_sz == 32 || MaxVectorSize > 32, \"Unexpected load size\");\n+      BasicType mask_bt = Matcher::vector_element_basic_type(in(3));\n+      int load_sz = type2aelembytes(mask_bt) * ty->get_con();\n+      assert(load_sz <= MaxVectorSize, \"Unexpected load size\");\n+      if (load_sz == MaxVectorSize) {\n@@ -823,4 +823,4 @@\n-      BasicType mask_bt = ((VectorMaskGenNode*)in(4))->get_elem_type();\n-      uint load_sz      = type2aelembytes(mask_bt) * ty->get_con();\n-      if ( load_sz == 32 || load_sz == 64) {\n-        assert(load_sz == 32 || MaxVectorSize > 32, \"Unexpected store size\");\n+      BasicType mask_bt = Matcher::vector_element_basic_type(in(4));\n+      int load_sz = type2aelembytes(mask_bt) * ty->get_con();\n+      assert(load_sz <= MaxVectorSize, \"Unexpected store size\");\n+      if (load_sz == MaxVectorSize) {\n@@ -1428,0 +1428,6 @@\n+Node* VectorMaskGenNode::make(Node* length, BasicType mask_bt) {\n+  int max_vector = Matcher::max_vector_size(mask_bt);\n+  const TypeVectMask* t_vmask = TypeVectMask::make(mask_bt, max_vector);\n+  return new VectorMaskGenNode(length, t_vmask);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":14,"deletions":8,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -904,0 +904,1 @@\n+\/\/------------------------------VectorMaskGenNode----------------------------------\n@@ -906,1 +907,1 @@\n-  VectorMaskGenNode(Node* length, const Type* ty, BasicType ety): TypeNode(ty, 2), _elemType(ety) {\n+  VectorMaskGenNode(Node* length, const Type* ty): TypeNode(ty, 2) {\n@@ -911,8 +912,2 @@\n-  BasicType get_elem_type()  { return _elemType;}\n-  virtual  uint  size_of() const { return sizeof(VectorMaskGenNode); }\n-  virtual uint  ideal_reg() const {\n-    return Op_RegVectMask;\n-  }\n-\n-  private:\n-   BasicType _elemType;\n+  virtual uint ideal_reg() const { return Op_RegVectMask; }\n+  static Node* make(Node* length, BasicType vmask_bt);\n@@ -921,0 +916,1 @@\n+\/\/------------------------------VectorMaskOpNode-----------------------------------\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"}]}