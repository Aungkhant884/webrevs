{"files":[{"patch":"@@ -399,13 +399,15 @@\n-                    \/\/ We first need to find out if the current frame is native.\n-                    StackFrameImpl sf;\n-                    try {\n-                        sf = (StackFrameImpl)thread.frame(0);\n-                    } catch (IndexOutOfBoundsException e) {\n-                        throw new InvalidStackFrameException(\"No more frames on the stack\");\n-                    }\n-                    sf.validateStackFrame();\n-                    MethodImpl meth = (MethodImpl)sf.location().method();\n-                    if (meth.isNative()) {\n-                        throw new NativeMethodException();\n-                    } else {\n-                        throw new OpaqueFrameException();\n+                    \/\/ We first need to find out if the current frame is native, or if the\n+                    \/\/ previous frame is native, in which case we throw NativeMethodException\n+                    for (int i = 0; i < 2; i++) {\n+                        StackFrameImpl sf;\n+                        try {\n+                            sf = (StackFrameImpl)thread.frame(i);\n+                        } catch (IndexOutOfBoundsException e) {\n+                            \/\/ This should never happen, but we need to check for it.\n+                            break;\n+                        }\n+                        sf.validateStackFrame();\n+                        MethodImpl meth = (MethodImpl)sf.location().method();\n+                        if (meth.isNative()) {\n+                            throw new NativeMethodException();\n+                        }\n@@ -413,0 +415,3 @@\n+                    \/\/ No native frames involved. Must have been due to thread\n+                    \/\/ not being mounted.\n+                    throw new OpaqueFrameException();\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/jdi\/StackFrameImpl.java","additions":18,"deletions":13,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -0,0 +1,338 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary Call popFrames() on an unmounted virtual thread\n+ *\n+ * @run build TestScaffold VMConnection TargetListener TargetAdapter\n+ * @run compile -g PopFramesTest.java\n+ * @run driver PopFramesTest SLEEP_NATIVE\n+ * @run driver PopFramesTest LOOP_NATIVE\n+ * @run driver PopFramesTest SLEEP_PRENATIVE\n+ * @run driver PopFramesTest LOOP_PRENATIVE\n+ * @run driver PopFramesTest SLEEP_NONATIVE\n+ * @run driver PopFramesTest LOOP_NONATIVE\n+ *\/\n+import com.sun.jdi.*;\n+import com.sun.jdi.event.*;\n+import java.util.*;\n+\n+class PopFramesTestTarg {\n+    static TestMode mode;\n+\n+    static {\n+        System.loadLibrary(\"PopFramesTestTarg\");\n+    }\n+\n+    \/*\n+     * Call stack for each test mode:\n+     *  - Note in all cases the popMethod() frame is the frame passed to popFrames()..\n+     *  - Note that Thread.sleep() usually results in the native Thread.sleep0() frame\n+     *    being at the top of the stack. However, for a mounted virtual thread\n+     *    it does not result in any native frames due to how the VM parks virtual threads.\n+     * \n+     * SLEEP_NATIVE:\n+     *   Thread.sleep() + methods called by Thread.sleep()\n+     *   loopOrSleep()\n+     *   upcallMethod()\n+     *   doUpcall()  <-- native method\n+     *   popMethod()\n+     *   main()\n+     * \n+     * LOOP_NATIVE:\n+     *   loopOrSleep()  <-- tight loop\n+     *   upcallMethod()\n+     *   doUpcall()  <-- native method\n+     *   popMethod()\n+     *   main()\n+     *\n+     * SLEEP_PRENATIVE:\n+     *   Thread.sleep() + methods called by Thread.sleep()\n+     *   loopOrSleep()\n+     *   popMethod()\n+     *   upcallMethod()\n+     *   doUpcall()  <-- native method\n+     *   main()\n+     *\n+     * LOOP_PRENATIVE:\n+     *   loopOrSleep()  <-- tight loop\n+     *   popMethod()\n+     *   upcallMethod()\n+     *   doUpcall()  <-- native method\n+     *   main()\n+     *\n+     * SLEEP_NONATIVE:\n+     *   Thread.sleep() + methods called by Thread.sleep()\n+     *   loopOrSleep()\n+     *   popMethod()\n+     *   main()\n+     *\n+     * LOOP_NONATIVE:\n+     *   loopOrSleep()  <-- tight loop\n+     *   popMethod()\n+     *   main()\n+     *\/\n+\n+    \/*\n+     * This is the method whose frame will be popped.\n+     *\/\n+    public static void popMethod() {\n+        System.out.println(\"    debuggee: in popMethod\");\n+        if (mode.isCallNative()) {\n+            doUpcall();\n+        } else {\n+            loopOrSleep();\n+        }\n+    }\n+\n+    public static void loopOrSleep() {\n+        if (mode.isDoLoop()) {\n+            while (true);\n+        } else {\n+            try {\n+                Thread.sleep(10000);\n+            }  catch (InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+        } \n+    }\n+\n+    public static native void doUpcall(); \/\/ native method that will call upcallMethod()\n+\n+    public static void upcallMethod() {\n+        if (mode.isCallPrenative()) {\n+            popMethod();\n+        } else {\n+            loopOrSleep();\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        System.out.println(\"    debuggee: Howdy!\");\n+\n+        \/\/ We expect just one argument, which is the test mode, such as SLEEP_NONATIVE.\n+        if (args.length != 1) {\n+            throw new RuntimeException(\"Must pass 1 arguments to PopFramesTestTarg\");\n+        }\n+        System.out.println(\"    debuggee: args[0]: \" + args[0]);\n+        mode = Enum.valueOf(TestMode.class, args[0]); \/\/ convert test mode string to an enum\n+        System.out.println(\"    debuggee: test mode: \" + mode);\n+\n+        if (mode.isCallNative()) {\n+            popMethod(); \/\/ call popMethod() directly, and it will call out to native\n+        } else if (mode.isCallPrenative()) {\n+            doUpcall();  \/\/ call native method that will call back into java to call popMethod()\n+        } else {\n+            popMethod(); \/\/ call popMethod() directly\n+        }\n+\n+        System.out.println(\"    debuggee: Goodbye from PopAndInvokeTarg!\");\n+    }\n+}\n+\n+\/*\n+ * The different modes the test can be run in. Each mode will produce a different stack:\n+ *  - SLEEP means the debuggee blocks in Thread.sleep()\n+ *  - LOOP means the debuggee sits in a tight loop\n+ *  - NATIVE means there is a native frame within the set of frames to pop.\n+ *  - PRENATIVE means there is a native frame before the set of frame to pop.\n+ *  - NONATIVE means there is no native frame (purposefully) present in the stack.\n+ *\/\n+enum TestMode {\n+    SLEEP_NATIVE,\n+    LOOP_NATIVE,\n+    SLEEP_PRENATIVE,\n+    LOOP_PRENATIVE,\n+    SLEEP_NONATIVE,\n+    LOOP_NONATIVE;\n+\n+    boolean isDoLoop() {\n+        return this == LOOP_NATIVE || this == LOOP_PRENATIVE || this == LOOP_NONATIVE;\n+    }\n+\n+    boolean isCallNative() {\n+        return this == LOOP_NATIVE || this == SLEEP_NATIVE;\n+    }\n+\n+    boolean isCallPrenative() {\n+        return this == LOOP_PRENATIVE || this == SLEEP_PRENATIVE;\n+    }\n+}\n+\n+\/********** test program **********\/\n+\n+public class PopFramesTest extends TestScaffold {\n+    private static TestMode mode;\n+\n+    PopFramesTest(String args[]) {\n+        super(args);\n+    }\n+\n+    public static void main(String[] args)      throws Exception {\n+        \/\/ We should get one argument that indicates the test mode, such as SLEEP_NONATIVE.\n+        if (args.length != 1) {\n+            throw new RuntimeException(\"Must pass one argument to PopFramesTestTarg\");\n+        }\n+        mode = Enum.valueOf(TestMode.class, args[0]); \/\/ convert test mode string to an enum\n+\n+        \/*\n+         * The @run command looks something like:\n+         *   @run driver PopFramesTest SLEEP_NONATIVE\n+         * We need to pass SLEEP_NONATIVE to the debuggee. We also need to insert\n+         * -Djava.library.path so the native method can be accessed if called.\n+         *\/\n+        String nativePath = \"-Djava.library.path=\" + System.getProperty(\"java.library.path\");\n+        String[] newArgs = new String[2];\n+        newArgs[0] = nativePath;\n+        newArgs[1] = args[0]; \/\/ pass test mode, such as SLEEP_NONATIVE\n+\n+        new PopFramesTest(newArgs).startTests();\n+    }\n+\n+    StackFrame frameFor(ThreadReference thread, String methodName) throws Exception {\n+        Iterator it = thread.frames().iterator();\n+\n+        while (it.hasNext()) {\n+            StackFrame frame = (StackFrame)it.next();\n+            if (frame.location().method().name().equals(methodName)) {\n+                return frame;\n+            }\n+        }\n+        failure(\"FAIL: \" + methodName + \" not on stack\");\n+        return null;\n+    }\n+\n+    public void printStack(ThreadReference thread, String msg) throws Exception {\n+        System.out.println(msg);\n+        List<StackFrame> stack_frames = thread.frames();\n+        int i = 0;\n+        String sourceName;\n+        for (StackFrame f : stack_frames) {\n+            try {\n+                sourceName = f.location().sourceName();\n+            } catch (AbsentInformationException aie) {\n+                sourceName = \"Unknown source\";\n+            }\n+            System.out.println(\"frame[\" + i++ +\"]: \" + f.location().method() +\n+                               \" (bci:\"+ f.location().codeIndex() + \")\" +\n+                               \" (\" + sourceName + \":\"+ f.location().lineNumber() + \")\");\n+        }\n+    }\n+\n+    \/********** test core **********\/\n+\n+    protected void runTests() throws Exception {\n+        BreakpointEvent bpe = startTo(\"PopFramesTestTarg\", \"popMethod\", \"()V\");\n+        ClassType targetClass = (ClassType)bpe.location().declaringType();\n+        ThreadReference mainThread  = bpe.thread();\n+\n+        \/\/ Resume main thread until it is in Thread.sleep() or the infinite loop.\n+        mainThread.resume();\n+        try {\n+            Thread.sleep(1000); \/\/ give thread chance to get into Thread.sleep() or loop\n+        }  catch (InterruptedException e) {\n+            throw new RuntimeException(e);\n+        }\n+        mainThread.suspend(); \/\/ Suspend thread while in Thread.sleep() or loop\n+        printStack(mainThread, \"Debuggee stack before popFrames():\");\n+\n+        \/*\n+         * Figure out which exception popFrames() should throw.\n+         *\/\n+        Class expected_exception;\n+        switch(mode) {\n+        case SLEEP_NATIVE:\n+        case LOOP_NATIVE:\n+        case SLEEP_PRENATIVE:\n+            \/*\n+             * For the two NATIVE cases, there is a native frame within the set of frames\n+             * to pop. For the SLEEP_PRENATIVE case, there also ends up being a native\n+             * frame due to Thread.sleep0() being native. However, see the the SLEEP_NATIVE\n+             * comment below. The only reason we end up in Thread.sleep0() for a virtual\n+             * thread in the SLEEP_PRENATIVE case is because it is pinned due to the earlier\n+             * native method. It is not pinned in the SLEEP_NATIVE case as described below,\n+             * which is why it does not end up in Thread.sleep0().\n+             *\/\n+            expected_exception = NativeMethodException.class;\n+            break;\n+        case LOOP_PRENATIVE:\n+        case LOOP_NONATIVE:\n+            \/*\n+             * For these two test cases, there are no native frames within the set of\n+             * frames to pop, nor in the frame previous to the frame to pop, so no\n+             * exception is expected.\n+             *\/\n+            expected_exception = null;\n+            break;\n+        case SLEEP_NONATIVE:\n+            \/*\n+             * Normally a Thread.sleep() results in the Thread.sleep0() native frame\n+             * on the stack, so the end result is NativeMethodException. However, for\n+             * a virtual thread that is not pinned, you end up with no native methods\n+             * on the stack due to how the VM parks virtual threads. So we have an \n+             * unmounted virtual thread with no native frames, which means \n+             * OpaqueFrameException will be thrown.\n+             *\/\n+            String mainWrapper = System.getProperty(\"main.wrapper\");\n+            if (\"Virtual\".equals(mainWrapper)) {\n+                expected_exception = OpaqueFrameException.class;\n+            } else {\n+                expected_exception = NativeMethodException.class;\n+            }\n+            break;\n+        default:\n+            throw new RuntimeException(\"Bad test mode: \" + mode);\n+        }\n+\n+        \/*\n+         * Pop all the frames up to and including the popMethod() frame.\n+         *\/\n+        try {\n+            mainThread.popFrames(frameFor(mainThread, \"popMethod\"));\n+            if (expected_exception != null) {\n+                failure(\"failure: popFrames() did not get expected exception: \" + expected_exception);\n+            }\n+        } catch (Exception ex) {\n+            if (expected_exception == ex.getClass()) {\n+                System.out.println(\"success: popFrames() got expected exception: \" + ex);\n+            } else {\n+                failure(\"failure: popFrames() got unexpected exception: \" + ex);\n+            }\n+        }\n+\n+        printStack(mainThread, \"Debuggee stack after popFrames():\");\n+\n+        \/*\n+         * Most tests do a listenUntilVMDisconnect() here, but there is no real need for it\n+         * with this test, and doing so would require finding a way to get the debuggee\n+         * to exit the endless loop it might be in. When we return, TestScaffold will\n+         * call TestScaffold.shutdown(), causing the debuggee process to be terminated quickly.\n+         *\/\n+\n+        if (testFailed) {\n+            throw new Exception(\"PopFramesTest failed\");\n+        }\n+        System.out.println(\"Passed:\");\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/jdi\/PopFramesTest.java","additions":338,"deletions":0,"binary":false,"changes":338,"status":"added"},{"patch":"@@ -364,2 +364,38 @@\n-        List<String> argList = new ArrayList(Arrays.asList(args));\n-        argList.add(targetName);\n+        \/*\n+         * args[] contains all VM arguments followed by the app arguments.\n+         * We need to insert targetName between the two types of arguments.\n+         *\/\n+        boolean expectSecondArg = false;\n+        boolean foundFirstAppArg = false;\n+        List<String> argList = new ArrayList();\n+        for (int i = 0; i < args.length; i++) {\n+            String arg = args[i].trim();\n+            if (foundFirstAppArg) {\n+                argList.add(arg);\n+                continue;\n+            }\n+            if (expectSecondArg) {\n+                expectSecondArg = false;\n+                argList.add(arg);\n+                continue;\n+            }\n+            if (doubleWordArgs.contains(arg)) {\n+                expectSecondArg = true;\n+                argList.add(arg);\n+                continue;\n+            }\n+            if (arg.startsWith(\"-\")) {\n+                argList.add(arg);\n+                continue;\n+            }\n+            \/\/ We reached the first app argument.\n+            argList.add(targetName);\n+            argList.add(arg);\n+            foundFirstAppArg = true;\n+        }\n+\n+        if (!foundFirstAppArg) {\n+            \/\/ Add the target since we didn't do that in the above loop.\n+            argList.add(targetName);\n+        }\n+\n@@ -464,2 +500,5 @@\n-    final List<String> doubleWordArgs = List.of(\"-cp\", \"-classpath\", \"--add-opens\", \"--class-path\",\n-            \"--upgrade-module-path\", \"--add-modules\", \"-d\", \"--add-exports\", \"--patch-module\", \"--module-path\");\n+    final List<String> doubleWordArgs = List.of(\n+            \"-connect\", \"-trace\",   \/\/ special TestScaffold args\n+            \"-cp\", \"-classpath\", \"--add-opens\", \"--class-path\",\n+            \"--upgrade-module-path\", \"--add-modules\", \"-d\", \"--add-exports\",\n+            \"--patch-module\", \"--module-path\");\n","filename":"test\/jdk\/com\/sun\/jdi\/TestScaffold.java","additions":43,"deletions":4,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+\n+#include \"jni.h\"\n+\n+static jclass test_class;\n+static jmethodID mid;\n+static jint current_jni_version = JNI_VERSION_19;\n+\n+\n+JNIEXPORT jint JNICALL\n+JNI_OnLoad(JavaVM *vm, void *reserved) {\n+    JNIEnv *env;\n+    jclass cl;\n+\n+    (*vm)->GetEnv(vm, (void **) &env, current_jni_version);\n+\n+    cl = (*env)->FindClass(env, \"PopFramesTestTarg\");\n+    test_class = (*env)->NewGlobalRef(env, cl);\n+    mid = (*env)->GetStaticMethodID(env, test_class, \"upcallMethod\", \"()V\");\n+\n+    return current_jni_version;\n+}\n+\n+\/*\n+ * Class:     NativeMethod\n+ * Method:    doUpcall\n+ * Signature: ()V\n+ *\/\n+JNIEXPORT void JNICALL Java_PopFramesTestTarg_doUpcall(JNIEnv *env, jobject obj) {\n+    (*env)->CallStaticVoidMethod(env, obj, mid);\n+\n+    if ((*env)->ExceptionCheck(env)) {\n+        (*env)->ExceptionDescribe(env);\n+        (*env)->FatalError(env, \"Exception thrown\");\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/jdi\/libPopFramesTestTarg.c","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"}]}