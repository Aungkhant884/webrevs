{"files":[{"patch":"@@ -26,1 +26,5 @@\n- * @summary Call popFrames() on an unmounted virtual thread\n+ * @summary Call popFrames() on threads in various states not covered\n+ *          well by other tests. Most notably, this test includes\n+ *          test cases for a suspended but unmounted virtual thread.\n+ *          It is mostly for testing for OpaqueFrameException and\n+ *          NativeMethodException.\n@@ -41,0 +45,68 @@\n+\/*\n+ * There are six test modes covered by this test:\n+ *   SLEEP_NATIVE\n+ *   LOOP_NATIVE\n+ *   SLEEP_PRENATIVE\n+ *   LOOP_PRENATIVE\n+ *   SLEEP_NONATIVE\n+ *   LOOP_NONATIVE\n+ *\n+ * SLEEP:     the debuggee blocks in Thread.sleep()\n+ * LOOP:      the debuggee sits in a tight loop\n+ * NATIVE:    there is a native frame within the set of frames to pop.\n+ * PRENATIVE: there is a native frame before the set of frames to pop.\n+ * NONATIVE:  there is no native frame (purposefully) present in the stack.\n+ *\n+ * In all cases the thread is suspended and errors such as IllegalArgumentException\n+ * and InvalidStackFrameException should not happen. The popFrames() calls  should\n+ * either pass, or produce OpaqueFrameException or NativeMethodException.\n+ *\n+ * Call stacks for each test mode (and expected result):\n+ *  - Note in all cases the popMethod() frame is the frame passed to popFrames()..\n+ *  - Note that Thread.sleep() usually results in the native Thread.sleep0() frame\n+ *    being at the top of the stack. However, for a mounted virtual thread\n+ *    it does not result in any native frames due to how the VM parks virtual threads.\n+ *\n+ * SLEEP_NATIVE (NativeMethodException):\n+ *   Thread.sleep() + methods called by Thread.sleep()\n+ *   loopOrSleep()\n+ *   upcallMethod()\n+ *   doUpcall()  <-- native method\n+ *   popMethod()\n+ *   main()\n+ *\n+ * LOOP_NATIVE (NativeMethodException):\n+ *   loopOrSleep()  <-- tight loop\n+ *   upcallMethod()\n+ *   doUpcall()  <-- native method\n+ *   popMethod()\n+ *   main()\n+ *\n+ * SLEEP_PRENATIVE (NativeMethodException due to Thread.sleep() blocking in a native method):\n+ *   Thread.sleep() + methods called by Thread.sleep()\n+ *   loopOrSleep()\n+ *   popMethod()\n+ *   upcallMethod()\n+ *   doUpcall()  <-- native method\n+ *   main()\n+ *\n+ * LOOP_PRENATIVE (no exception):\n+ *   loopOrSleep()  <-- tight loop\n+ *   popMethod()\n+ *   upcallMethod()\n+ *   doUpcall()  <-- native method\n+ *   main()\n+ *\n+ * SLEEP_NONATIVE (NativeMethodException for platform thread or OpaqueFrameException\n+ * for virtual thread. See explanation in runTests().):\n+ *   Thread.sleep() + methods called by Thread.sleep()\n+ *   loopOrSleep()\n+ *   popMethod()\n+ *   main()\n+ *\n+ * LOOP_NONATIVE (no exception):\n+ *   loopOrSleep()  <-- tight loop\n+ *   popMethod()\n+ *   main()\n+ *\/\n+\n@@ -49,50 +121,1 @@\n-     * Call stack for each test mode:\n-     *  - Note in all cases the popMethod() frame is the frame passed to popFrames()..\n-     *  - Note that Thread.sleep() usually results in the native Thread.sleep0() frame\n-     *    being at the top of the stack. However, for a mounted virtual thread\n-     *    it does not result in any native frames due to how the VM parks virtual threads.\n-     *\n-     * SLEEP_NATIVE:\n-     *   Thread.sleep() + methods called by Thread.sleep()\n-     *   loopOrSleep()\n-     *   upcallMethod()\n-     *   doUpcall()  <-- native method\n-     *   popMethod()\n-     *   main()\n-     *\n-     * LOOP_NATIVE:\n-     *   loopOrSleep()  <-- tight loop\n-     *   upcallMethod()\n-     *   doUpcall()  <-- native method\n-     *   popMethod()\n-     *   main()\n-     *\n-     * SLEEP_PRENATIVE:\n-     *   Thread.sleep() + methods called by Thread.sleep()\n-     *   loopOrSleep()\n-     *   popMethod()\n-     *   upcallMethod()\n-     *   doUpcall()  <-- native method\n-     *   main()\n-     *\n-     * LOOP_PRENATIVE:\n-     *   loopOrSleep()  <-- tight loop\n-     *   popMethod()\n-     *   upcallMethod()\n-     *   doUpcall()  <-- native method\n-     *   main()\n-     *\n-     * SLEEP_NONATIVE:\n-     *   Thread.sleep() + methods called by Thread.sleep()\n-     *   loopOrSleep()\n-     *   popMethod()\n-     *   main()\n-     *\n-     * LOOP_NONATIVE:\n-     *   loopOrSleep()  <-- tight loop\n-     *   popMethod()\n-     *   main()\n-     *\/\n-\n-    \/*\n-     * This is the method whose frame will be popped.\n+     * This is the method whose frame (and all those after it) will be popped.\n@@ -155,6 +178,1 @@\n- * The different modes the test can be run in. Each mode will produce a different stack:\n- *  - SLEEP means the debuggee blocks in Thread.sleep()\n- *  - LOOP means the debuggee sits in a tight loop\n- *  - NATIVE means there is a native frame within the set of frames to pop.\n- *  - PRENATIVE means there is a native frame before the set of frame to pop.\n- *  - NONATIVE means there is no native frame (purposefully) present in the stack.\n+ * The different modes the test can be run in. See test description comment above.\n@@ -170,0 +188,1 @@\n+    \/\/ Returns true if debuggee should block in an infinite loop. Otherwise it calls Thread.sleep()\n@@ -174,0 +193,1 @@\n+    \/\/ Returns true if debuggee should introduce a native frame within the set of frames to pop\n@@ -178,0 +198,2 @@\n+    \/\/ Returns true if debuggee should introduce a native frame before the set of frames to pop.\n+    \/\/ The purpose is to cause the virtual thread to be pinned.\n@@ -271,5 +293,3 @@\n-             * frame due to Thread.sleep0() being native. However, see the the SLEEP_NATIVE\n-             * comment below. The only reason we end up in Thread.sleep0() for a virtual\n-             * thread in the SLEEP_PRENATIVE case is because it is pinned due to the earlier\n-             * native method. It is not pinned in the SLEEP_NATIVE case as described below,\n-             * which is why it does not end up in Thread.sleep0().\n+             * frame. It will either be Thread.sleep0() for platform threads or\n+             * Unsafe.park() for virtual threads. See the SLEEP_NATIVE comment below\n+             * for more details.\n@@ -290,6 +310,10 @@\n-             * Normally a Thread.sleep() results in the Thread.sleep0() native frame\n-             * on the stack, so the end result is NativeMethodException. However, for\n-             * a virtual thread that is not pinned, you end up with no native methods\n-             * on the stack due to how the VM parks virtual threads. So we have an\n-             * unmounted virtual thread with no native frames, which means\n-             * OpaqueFrameException will be thrown.\n+             * For platform threads, Thread.sleep() results in the Thread.sleep0() native\n+             * frame on the stack, so the end result is NativeMethodException. For virtual\n+             * threads it is not quite so simple. If the thead is pinned (such as when\n+             * there is already a native method on the stack), you end up in \n+             * VirtualThread.parkOnCarrierThread(), which calls Unsafe.park(), which is a\n+             * native method, so again this results in NativeMethodException. However, for\n+             * a virtual thread that is not pinned (which is true for this test case), you\n+             * end up with no native methods on the stack due to how Continuation.yield()\n+             * works. So you have an unmounted virtual thread with no native frames, which\n+             * results in OpaqueFrameException being thrown.\n","filename":"test\/jdk\/com\/sun\/jdi\/PopFramesTest.java","additions":92,"deletions":68,"binary":false,"changes":160,"status":"modified"}]}