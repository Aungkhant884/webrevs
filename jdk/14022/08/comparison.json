{"files":[{"patch":"@@ -2695,4 +2695,3 @@\n-        \"The target VM may not support, or may only provide limited support, for this \"\n-        \"command when the thread is a virtual thread. It may, for example, only support \"\n-        \"this command when the virtual thread is suspended at a breakpoint or singlestep \"\n-        \"event.\"\n+        \"This command may be used to pop frames of a virtual thread when \"\n+        \"it is suspended at an event. An implementation may support popping \"\n+        \"the frames of a suspended virtual thread in other cases.\"\n@@ -2716,2 +2715,2 @@\n-                                     \"thread is a virtual thread and the implementation \"\n-                                     \"is unable to pop the frames.\")\n+                                     \"thread is a suspended virtual thread and the implementation \"\n+                                     \"was unable to pop the frames.\")\n","filename":"src\/java.se\/share\/data\/jdwp\/jdwp.spec","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -373,1 +373,1 @@\n-     * The specified thread must be suspended.\n+     * This thread must be suspended.\n@@ -378,4 +378,3 @@\n-     * The target VM may not support, or may only provide limited support,\n-     * for popping stack frames when the thread is a virtual thread.\n-     * It may, for example, only support this operation when the virtual\n-     * thread is suspended at a breakpoint or singlestep event.\n+     * This method may be used to pop frames of a virtual thread when\n+     * it is suspended at an event. An implementation may support popping\n+     * the frames of a suspended virtual thread in other cases.\n@@ -406,2 +405,2 @@\n-     * @throws OpaqueFrameException if this thread is a virtual thread and the\n-     * target VM is unable to pop the frames.\n+     * @throws OpaqueFrameException if this thread is a suspended virtual thread and the\n+     * target VM was unable to pop the frames.\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/jdi\/ThreadReference.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -399,1 +399,19 @@\n-                    throw new OpaqueFrameException();  \/\/ can only happen with virtual threads\n+                    \/\/ We first need to find out if the current frame is native, or if the\n+                    \/\/ previous frame is native, in which case we throw NativeMethodException\n+                    for (int i = 0; i < 2; i++) {\n+                        StackFrameImpl sf;\n+                        try {\n+                            sf = (StackFrameImpl)thread.frame(i);\n+                        } catch (IndexOutOfBoundsException e) {\n+                            \/\/ This should never happen, but we need to check for it.\n+                            break;\n+                        }\n+                        sf.validateStackFrame();\n+                        MethodImpl meth = (MethodImpl)sf.location().method();\n+                        if (meth.isNative()) {\n+                            throw new NativeMethodException();\n+                        }\n+                    }\n+                    \/\/ No native frames involved. Must have been due to thread\n+                    \/\/ not being mounted.\n+                    throw new OpaqueFrameException();\n@@ -401,1 +419,1 @@\n-                    throw new NativeMethodException(); \/\/ can only happen with platform threads\n+                    throw new NativeMethodException();\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/jdi\/StackFrameImpl.java","additions":21,"deletions":3,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -97,26 +97,0 @@\n-####\n-## JVMTI PopFrame() is returning OPAQUE_FRAME because vthreads are not supported.\n-## Note: vmTestbase\/nsk\/jdi\/ThreadReference\/popFrames\/popframes001 was converted\n-## to support vthreads and expect the OPAQUE_FRAME error. The others were\n-## not because they don't add any additional value.\n-\n-vmTestbase\/nsk\/jdb\/pop_exception\/pop_exception001\/pop_exception001.java 8285414 generic-all\n-\n-vmTestbase\/nsk\/jdi\/VirtualMachine\/redefineClasses\/redefineclasses002\/TestDescription.java 8285414 generic-all\n-\n-vmTestbase\/nsk\/jdi\/Scenarios\/invokeMethod\/popframes001\/TestDescription.java 8285414 generic-all\n-vmTestbase\/nsk\/jdi\/BScenarios\/hotswap\/tc01x002\/TestDescription.java 8285414 generic-all\n-vmTestbase\/nsk\/jdi\/BScenarios\/hotswap\/tc02x001\/TestDescription.java 8285414 generic-all\n-vmTestbase\/nsk\/jdi\/BScenarios\/hotswap\/tc02x002\/TestDescription.java 8285414 generic-all\n-vmTestbase\/nsk\/jdi\/BScenarios\/hotswap\/tc04x001\/TestDescription.java 8285414 generic-all\n-vmTestbase\/nsk\/jdi\/BScenarios\/hotswap\/tc04x002\/TestDescription.java 8285414 generic-all\n-vmTestbase\/nsk\/jdi\/BScenarios\/hotswap\/tc06x001\/TestDescription.java 8285414 generic-all\n-vmTestbase\/nsk\/jdi\/BScenarios\/hotswap\/tc08x001\/TestDescription.java 8285414 generic-all\n-vmTestbase\/nsk\/jdi\/BScenarios\/hotswap\/tc10x002\/TestDescription.java 8285414 generic-all\n-\n-vmTestbase\/nsk\/jdi\/ThreadReference\/popFrames\/popframes002\/TestDescription.java 8285414 generic-all\n-vmTestbase\/nsk\/jdi\/ThreadReference\/popFrames\/popframes003\/TestDescription.java 8285414 generic-all\n-vmTestbase\/nsk\/jdi\/ThreadReference\/popFrames\/popframes004\/TestDescription.java 8285414 generic-all\n-\n-vmTestbase\/nsk\/jdi\/ThreadReference\/popFrames\/popframes001\/TestDescription.java 8308237 generic-all\n-\n","filename":"test\/hotspot\/jtreg\/ProblemList-Virtual.txt","additions":0,"deletions":26,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -96,2 +96,0 @@\n-    static boolean vthreadMode = \"Virtual\".equals(System.getProperty(\"main.wrapper\"));\n-\n@@ -224,4 +222,0 @@\n-            if (vthreadMode) {\n-                return 0; \/\/ just exit. we already got the expected OpaqueFrameException\n-            }\n-\n@@ -359,18 +353,4 @@\n-                if (vthreadMode) {\n-                    log3(\"ERROR: Expected OpaqueFrameException\");\n-                    testExitCode = FAILED;\n-                }\n-            } catch ( Exception e ) {\n-                if (vthreadMode && (e instanceof OpaqueFrameException)) {\n-                    \/\/ pass. resume thread and exit\n-                    log2(\"......got expected OpaqueFrameException\");\n-                    log2(\"......thread2Ref.resume();\");\n-                    thread2Ref.resume();\n-                    breakpointForCommunication();\n-                    vm.resume();\n-                    break;\n-                } else {\n-                    log3(\"ERROR: \" + e.getClass().getSimpleName());\n-                    testExitCode = FAILED;\n-                    throw e;\n-                }\n+            } catch ( IncompatibleThreadStateException e ) {\n+                log3(\"ERROR: IncompatibleThreadStateException\");\n+                testExitCode = FAILED;\n+                break;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ThreadReference\/popFrames\/popframes001.java","additions":4,"deletions":24,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -39,3 +39,0 @@\n-com\/sun\/jdi\/PopAndStepTest.java 8285422 generic-all\n-com\/sun\/jdi\/PopAsynchronousTest.java 8285422 generic-all\n-com\/sun\/jdi\/PopSynchronousTest.java 8285422 generic-all\n@@ -49,1 +46,0 @@\n-com\/sun\/jdi\/PopAndInvokeTest.java 8305632 generic-all\n","filename":"test\/jdk\/ProblemList-Virtual.txt","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,362 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary Call popFrames() on threads in various states not covered\n+ *          well by other tests. Most notably, this test includes\n+ *          test cases for a suspended but unmounted virtual thread.\n+ *          It is mostly for testing for OpaqueFrameException and\n+ *          NativeMethodException.\n+ *\n+ * @run build TestScaffold VMConnection TargetListener TargetAdapter\n+ * @run compile -g PopFramesTest.java\n+ * @run driver PopFramesTest SLEEP_NATIVE\n+ * @run driver PopFramesTest LOOP_NATIVE\n+ * @run driver PopFramesTest SLEEP_PRENATIVE\n+ * @run driver PopFramesTest LOOP_PRENATIVE\n+ * @run driver PopFramesTest SLEEP_NONATIVE\n+ * @run driver PopFramesTest LOOP_NONATIVE\n+ *\/\n+import com.sun.jdi.*;\n+import com.sun.jdi.event.*;\n+import java.util.*;\n+\n+\/*\n+ * There are six test modes covered by this test:\n+ *   SLEEP_NATIVE\n+ *   LOOP_NATIVE\n+ *   SLEEP_PRENATIVE\n+ *   LOOP_PRENATIVE\n+ *   SLEEP_NONATIVE\n+ *   LOOP_NONATIVE\n+ *\n+ * SLEEP:     the debuggee blocks in Thread.sleep().\n+ * LOOP:      the debuggee sits in a tight loop.\n+ * NATIVE:    there is a native frame within the set of frames to pop.\n+ * PRENATIVE: there is a native frame before the set of frames to pop.\n+ * NONATIVE:  there is no native frame (purposefully) present in the stack.\n+ *\n+ * In all cases the thread is suspended and errors such as IllegalArgumentException\n+ * and InvalidStackFrameException should not happen. The popFrames() calls  should\n+ * either pass, or produce OpaqueFrameException or NativeMethodException.\n+ *\n+ * Call stacks for each test mode (and expected result):\n+ *  - Note in all cases the popMethod() frame is the frame passed to popFrames().\n+ *  - Note that Thread.sleep() usually results in the native Thread.sleep0() frame\n+ *    being at the top of the stack. However, for a mounted virtual thread\n+ *    it does not result in any native frames due to how the VM parks virtual threads.\n+ *\n+ * SLEEP_NATIVE (NativeMethodException):\n+ *   Thread.sleep() + methods called by Thread.sleep()\n+ *   loopOrSleep()\n+ *   upcallMethod()\n+ *   doUpcall()  <-- native method\n+ *   popMethod()\n+ *   main()\n+ *\n+ * LOOP_NATIVE (NativeMethodException):\n+ *   loopOrSleep()  <-- tight loop\n+ *   upcallMethod()\n+ *   doUpcall()  <-- native method\n+ *   popMethod()\n+ *   main()\n+ *\n+ * SLEEP_PRENATIVE (NativeMethodException due to Thread.sleep() blocking in a native method):\n+ *   Thread.sleep() + methods called by Thread.sleep()\n+ *   loopOrSleep()\n+ *   popMethod()\n+ *   upcallMethod()\n+ *   doUpcall()  <-- native method\n+ *   main()\n+ *\n+ * LOOP_PRENATIVE (no exception):\n+ *   loopOrSleep()  <-- tight loop\n+ *   popMethod()\n+ *   upcallMethod()\n+ *   doUpcall()  <-- native method\n+ *   main()\n+ *\n+ * SLEEP_NONATIVE (NativeMethodException for platform thread or OpaqueFrameException\n+ * for virtual thread. See explanation in runTests().):\n+ *   Thread.sleep() + methods called by Thread.sleep()\n+ *   loopOrSleep()\n+ *   popMethod()\n+ *   main()\n+ *\n+ * LOOP_NONATIVE (no exception):\n+ *   loopOrSleep()  <-- tight loop\n+ *   popMethod()\n+ *   main()\n+ *\/\n+\n+class PopFramesTestTarg {\n+    static TestMode mode;\n+\n+    static {\n+        System.loadLibrary(\"PopFramesTestTarg\");\n+    }\n+\n+    \/*\n+     * This is the method whose frame (and all those after it) will be popped.\n+     *\/\n+    public static void popMethod() {\n+        System.out.println(\"    debuggee: in popMethod\");\n+        if (mode.isCallNative()) {\n+            doUpcall();\n+        } else {\n+            loopOrSleep();\n+        }\n+    }\n+\n+    public static void loopOrSleep() {\n+        if (mode.isDoLoop()) {\n+            while (true);\n+        } else {\n+            try {\n+                Thread.sleep(10000);\n+            } catch (InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+    }\n+\n+    public static native void doUpcall(); \/\/ native method that will call upcallMethod()\n+\n+    public static void upcallMethod() {\n+        if (mode.isCallPrenative()) {\n+            popMethod();\n+        } else {\n+            loopOrSleep();\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        System.out.println(\"    debuggee: Howdy!\");\n+\n+        \/\/ We expect just one argument, which is the test mode, such as SLEEP_NONATIVE.\n+        if (args.length != 1) {\n+            throw new RuntimeException(\"Must pass 1 arguments to PopFramesTestTarg\");\n+        }\n+        System.out.println(\"    debuggee: args[0]: \" + args[0]);\n+        mode = Enum.valueOf(TestMode.class, args[0]); \/\/ convert test mode string to an enum\n+        System.out.println(\"    debuggee: test mode: \" + mode);\n+\n+        if (mode.isCallNative()) {\n+            popMethod(); \/\/ call popMethod() directly, and it will call out to native\n+        } else if (mode.isCallPrenative()) {\n+            doUpcall();  \/\/ call native method that will call back into java to call popMethod()\n+        } else {\n+            popMethod(); \/\/ call popMethod() directly\n+        }\n+\n+        System.out.println(\"    debuggee: Goodbye from PopFramesTest!\");\n+    }\n+}\n+\n+\/*\n+ * The different modes the test can be run in. See test description comment above.\n+ *\/\n+enum TestMode {\n+    SLEEP_NATIVE,\n+    LOOP_NATIVE,\n+    SLEEP_PRENATIVE,\n+    LOOP_PRENATIVE,\n+    SLEEP_NONATIVE,\n+    LOOP_NONATIVE;\n+\n+    \/\/ Returns true if debuggee should block in an infinite loop. Otherwise it calls Thread.sleep().\n+    boolean isDoLoop() {\n+        return this == LOOP_NATIVE || this == LOOP_PRENATIVE || this == LOOP_NONATIVE;\n+    }\n+\n+    \/\/ Returns true if debuggee should introduce a native frame within the set of frames to pop.\n+    boolean isCallNative() {\n+        return this == LOOP_NATIVE || this == SLEEP_NATIVE;\n+    }\n+\n+    \/\/ Returns true if debuggee should introduce a native frame before the set of frames to pop.\n+    \/\/ The purpose is to cause the virtual thread to be pinned.\n+    boolean isCallPrenative() {\n+        return this == LOOP_PRENATIVE || this == SLEEP_PRENATIVE;\n+    }\n+}\n+\n+\/********** test program **********\/\n+\n+public class PopFramesTest extends TestScaffold {\n+    private static TestMode mode;\n+\n+    PopFramesTest(String args[]) {\n+        super(args);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        \/\/ We should get one argument that indicates the test mode, such as SLEEP_NONATIVE.\n+        if (args.length != 1) {\n+            throw new RuntimeException(\"Must pass one argument to PopFramesTestTarg\");\n+        }\n+        mode = Enum.valueOf(TestMode.class, args[0]); \/\/ convert test mode string to an enum\n+\n+        \/*\n+         * The @run command looks something like:\n+         *   @run driver PopFramesTest SLEEP_NONATIVE\n+         * We need to pass SLEEP_NONATIVE to the debuggee. We also need to insert\n+         * -Djava.library.path so the native method can be accessed if called.\n+         *\/\n+        String nativePath = \"-Djava.library.path=\" + System.getProperty(\"java.library.path\");\n+        String[] newArgs = new String[2];\n+        newArgs[0] = nativePath;\n+        newArgs[1] = args[0]; \/\/ pass test mode, such as SLEEP_NONATIVE\n+\n+        new PopFramesTest(newArgs).startTests();\n+    }\n+\n+    StackFrame frameFor(ThreadReference thread, String methodName) throws Exception {\n+        Iterator it = thread.frames().iterator();\n+\n+        while (it.hasNext()) {\n+            StackFrame frame = (StackFrame)it.next();\n+            if (frame.location().method().name().equals(methodName)) {\n+                return frame;\n+            }\n+        }\n+        failure(\"FAIL: \" + methodName + \" not on stack\");\n+        return null;\n+    }\n+\n+    public void printStack(ThreadReference thread, String msg) throws Exception {\n+        System.out.println(msg);\n+        List<StackFrame> stack_frames = thread.frames();\n+        int i = 0;\n+        String sourceName;\n+        for (StackFrame f : stack_frames) {\n+            try {\n+                sourceName = f.location().sourceName();\n+            } catch (AbsentInformationException aie) {\n+                sourceName = \"Unknown source\";\n+            }\n+            System.out.println(\"frame[\" + i++ +\"]: \" + f.location().method() +\n+                               \" (bci:\"+ f.location().codeIndex() + \")\" +\n+                               \" (\" + sourceName + \":\"+ f.location().lineNumber() + \")\");\n+        }\n+    }\n+\n+    \/********** test core **********\/\n+\n+    protected void runTests() throws Exception {\n+        BreakpointEvent bpe = startTo(\"PopFramesTestTarg\", \"loopOrSleep\", \"()V\");\n+        ClassType targetClass = (ClassType)bpe.location().declaringType();\n+        ThreadReference mainThread = bpe.thread();\n+\n+        \/\/ Resume main thread until it is in Thread.sleep() or the infinite loop.\n+        mainThread.resume();\n+        try {\n+            Thread.sleep(1000); \/\/ give thread chance to get into Thread.sleep() or loop\n+        } catch (InterruptedException e) {\n+            throw new RuntimeException(e);\n+        }\n+        mainThread.suspend(); \/\/ Suspend thread while in Thread.sleep() or loop\n+        printStack(mainThread, \"Debuggee stack before popFrames():\");\n+\n+        \/*\n+         * Figure out which exception popFrames() should throw.\n+         *\/\n+        Class expected_exception;\n+        switch(mode) {\n+        case SLEEP_NATIVE:\n+        case LOOP_NATIVE:\n+        case SLEEP_PRENATIVE:\n+            \/*\n+             * For the two NATIVE cases, there is a native frame within the set of frames\n+             * to pop. For the SLEEP_PRENATIVE case, there also ends up being a native\n+             * frame. It will either be Thread.sleep0() for platform threads or\n+             * Unsafe.park() for virtual threads. See the SLEEP_NATIVE comment below\n+             * for more details.\n+             *\/\n+            expected_exception = NativeMethodException.class;\n+            break;\n+        case LOOP_PRENATIVE:\n+        case LOOP_NONATIVE:\n+            \/*\n+             * For these two test cases, there are no native frames within the set of\n+             * frames to pop, nor in the frame previous to the frame to pop, so no\n+             * exception is expected.\n+             *\/\n+            expected_exception = null;\n+            break;\n+        case SLEEP_NONATIVE:\n+            \/*\n+             * For platform threads, Thread.sleep() results in the Thread.sleep0() native\n+             * frame on the stack, so the end result is NativeMethodException. For virtual\n+             * threads it is not quite so simple. If the thead is pinned (such as when\n+             * there is already a native method on the stack), you end up in\n+             * VirtualThread.parkOnCarrierThread(), which calls Unsafe.park(), which is a\n+             * native method, so again this results in NativeMethodException. However, for\n+             * a virtual thread that is not pinned (which is true for this test case), you\n+             * end up with no native methods on the stack due to how Continuation.yield()\n+             * works. So you have an unmounted virtual thread with no native frames, which\n+             * results in OpaqueFrameException being thrown.\n+             *\/\n+            String mainWrapper = System.getProperty(\"main.wrapper\");\n+            if (\"Virtual\".equals(mainWrapper)) {\n+                expected_exception = OpaqueFrameException.class;\n+            } else {\n+                expected_exception = NativeMethodException.class;\n+            }\n+            break;\n+        default:\n+            throw new RuntimeException(\"Bad test mode: \" + mode);\n+        }\n+\n+        \/*\n+         * Pop all the frames up to and including the popMethod() frame.\n+         *\/\n+        try {\n+            mainThread.popFrames(frameFor(mainThread, \"popMethod\"));\n+            if (expected_exception != null) {\n+                failure(\"failure: popFrames() did not get expected exception: \" + expected_exception);\n+            }\n+        } catch (Exception ex) {\n+            if (expected_exception == ex.getClass()) {\n+                System.out.println(\"success: popFrames() got expected exception: \" + ex);\n+            } else {\n+                failure(\"failure: popFrames() got unexpected exception: \" + ex);\n+            }\n+        }\n+\n+        printStack(mainThread, \"Debuggee stack after popFrames():\");\n+\n+        \/*\n+         * Most tests do a listenUntilVMDisconnect() here, but there is no real need for it\n+         * with this test, and doing so would require finding a way to get the debuggee\n+         * to exit the endless loop it might be in. When we return, TestScaffold will\n+         * call TestScaffold.shutdown(), causing the debuggee process to be terminated quickly.\n+         *\/\n+\n+        if (testFailed) {\n+            throw new Exception(\"PopFramesTest failed\");\n+        }\n+        System.out.println(\"Passed:\");\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/jdi\/PopFramesTest.java","additions":362,"deletions":0,"binary":false,"changes":362,"status":"added"},{"patch":"@@ -364,2 +364,38 @@\n-        List<String> argList = new ArrayList(Arrays.asList(args));\n-        argList.add(targetName);\n+        \/*\n+         * args[] contains all VM arguments followed by the app arguments.\n+         * We need to insert targetName between the two types of arguments.\n+         *\/\n+        boolean expectSecondArg = false;\n+        boolean foundFirstAppArg = false;\n+        List<String> argList = new ArrayList();\n+        for (int i = 0; i < args.length; i++) {\n+            String arg = args[i].trim();\n+            if (foundFirstAppArg) {\n+                argList.add(arg);\n+                continue;\n+            }\n+            if (expectSecondArg) {\n+                expectSecondArg = false;\n+                argList.add(arg);\n+                continue;\n+            }\n+            if (doubleWordArgs.contains(arg)) {\n+                expectSecondArg = true;\n+                argList.add(arg);\n+                continue;\n+            }\n+            if (arg.startsWith(\"-\")) {\n+                argList.add(arg);\n+                continue;\n+            }\n+            \/\/ We reached the first app argument.\n+            argList.add(targetName);\n+            argList.add(arg);\n+            foundFirstAppArg = true;\n+        }\n+\n+        if (!foundFirstAppArg) {\n+            \/\/ Add the target since we didn't do that in the above loop.\n+            argList.add(targetName);\n+        }\n+\n@@ -464,2 +500,5 @@\n-    final List<String> doubleWordArgs = List.of(\"-cp\", \"-classpath\", \"--add-opens\", \"--class-path\",\n-            \"--upgrade-module-path\", \"--add-modules\", \"-d\", \"--add-exports\", \"--patch-module\", \"--module-path\");\n+    final List<String> doubleWordArgs = List.of(\n+            \"-connect\", \"-trace\",   \/\/ special TestScaffold args\n+            \"-cp\", \"-classpath\", \"--add-opens\", \"--class-path\",\n+            \"--upgrade-module-path\", \"--add-modules\", \"-d\", \"--add-exports\",\n+            \"--patch-module\", \"--module-path\");\n","filename":"test\/jdk\/com\/sun\/jdi\/TestScaffold.java","additions":43,"deletions":4,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+\n+#include \"jni.h\"\n+\n+static jclass test_class;\n+static jmethodID mid;\n+static jint current_jni_version = JNI_VERSION_19;\n+\n+\n+JNIEXPORT jint JNICALL\n+JNI_OnLoad(JavaVM *vm, void *reserved) {\n+    JNIEnv *env;\n+    jclass cl;\n+\n+    (*vm)->GetEnv(vm, (void **) &env, current_jni_version);\n+\n+    cl = (*env)->FindClass(env, \"PopFramesTestTarg\");\n+    test_class = (*env)->NewGlobalRef(env, cl);\n+    mid = (*env)->GetStaticMethodID(env, test_class, \"upcallMethod\", \"()V\");\n+\n+    return current_jni_version;\n+}\n+\n+\/*\n+ * Class:     NativeMethod\n+ * Method:    doUpcall\n+ * Signature: ()V\n+ *\/\n+JNIEXPORT void JNICALL Java_PopFramesTestTarg_doUpcall(JNIEnv *env, jobject obj) {\n+    (*env)->CallStaticVoidMethod(env, obj, mid);\n+\n+    if ((*env)->ExceptionCheck(env)) {\n+        (*env)->ExceptionDescribe(env);\n+        (*env)->FatalError(env, \"Exception thrown\");\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/jdi\/libPopFramesTestTarg.c","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"}]}