{"files":[{"patch":"@@ -1309,6 +1309,0 @@\n-  assert(SafepointSynchronize::is_at_safepoint(), \"safe iteration is only available during safepoints\");\n-  if (!_aux_bitmap_region_special && !os::commit_memory((char*)_aux_bitmap_region.start(), _aux_bitmap_region.byte_size(), false)) {\n-    log_warning(gc)(\"Could not commit native memory for auxiliary marking bitmap for heap iteration\");\n-    return;\n-  }\n-\n@@ -1316,1 +1310,2 @@\n-  _aux_bit_map.clear();\n+  if (!prepare_aux_bitmap_for_iteration())\n+    return;\n@@ -1319,1 +1314,1 @@\n-\n+  \/\/ root marking\n@@ -1322,8 +1317,1 @@\n-  {\n-    \/\/ First, we process GC roots according to current GC cycle.\n-    \/\/ This populates the work stack with initial objects.\n-    \/\/ It is important to relinquish the associated locks before diving\n-    \/\/ into heap dumper.\n-    ShenandoahHeapIterationRootScanner rp;\n-    rp.roots_do(&oops);\n-  }\n+  scan_roots_for_iteration(&oop_stack, &oops);\n@@ -1340,0 +1328,3 @@\n+  \/\/ Reclaim bitmap\n+  reclaim_aux_bitmap_for_iteration();\n+}\n@@ -1341,3 +1332,26 @@\n-  if (!_aux_bitmap_region_special && !os::uncommit_memory((char*)_aux_bitmap_region.start(), _aux_bitmap_region.byte_size())) {\n-    log_warning(gc)(\"Could not uncommit native memory for auxiliary marking bitmap for heap iteration\");\n-  }\n+bool ShenandoahHeap::prepare_aux_bitmap_for_iteration() {\n+    assert(SafepointSynchronize::is_at_safepoint(), \"safe iteration is only available during safepoints\");\n+\n+    if (!_aux_bitmap_region_special && !os::commit_memory((char*)_aux_bitmap_region.start(), _aux_bitmap_region.byte_size(), false)) {\n+      log_warning(gc)(\"Could not commit native memory for auxiliary marking bitmap for heap iteration\");\n+      return false;\n+    }\n+\n+    \/\/ Reset bitmap\n+    _aux_bit_map.clear();\n+    return true;\n+}\n+\n+void ShenandoahHeap::scan_roots_for_iteration(Stack<oop, mtGC>* oop_stack, ObjectIterateScanRootClosure* oops) {\n+    \/\/ Process GC roots according to current GC cycle.\n+    \/\/ This populates the work stack with initial objects.\n+    \/\/ It is important to relinquish the associated locks before diving\n+    \/\/ into heap dumper.\n+    ShenandoahHeapIterationRootScanner rp;\n+    rp.roots_do(oops);\n+}\n+\n+void ShenandoahHeap::reclaim_aux_bitmap_for_iteration() {\n+    if (!_aux_bitmap_region_special && !os::uncommit_memory((char*)_aux_bitmap_region.start(), _aux_bitmap_region.byte_size())) {\n+      log_warning(gc)(\"Could not uncommit native memory for auxiliary marking bitmap for heap iteration\");\n+    }\n@@ -1380,31 +1394,0 @@\n-void ShenandoahHeap::scan_roots_for_iteration(Stack<oop, mtGC>* oop_stack) {\n-    assert(oop_stack != NULL, \"root stack must not be NULL\");\n-    \/\/ root marking\n-    ObjectIterateScanRootClosure oops(&_aux_bit_map, oop_stack);\n-    \/\/ Process GC roots according to current GC cycle.\n-    \/\/ This populates the work stack with initial objects.\n-    \/\/ It is important to relinquish the associated locks before diving\n-    \/\/ into heap dumper.\n-    ShenandoahHeapIterationRootScanner rp;\n-    rp.roots_do(&oops);\n-}\n-\n-bool ShenandoahHeap::prepare_aux_bitmap_for_iteration() {\n-    assert(SafepointSynchronize::is_at_safepoint(), \"safe iteration is only available during safepoints\");\n-\n-    if (!_aux_bitmap_region_special && !os::commit_memory((char*)_aux_bitmap_region.start(), _aux_bitmap_region.byte_size(), false)) {\n-      log_warning(gc)(\"Could not commit native memory for auxiliary marking bitmap for heap iteration\");\n-      return false;\n-    }\n-\n-    \/\/ Reset bitmap\n-    _aux_bit_map.clear();\n-    return true;\n-}\n-\n-void ShenandoahHeap::reclaim_aux_bitmap_for_iteration() {\n-    if (!_aux_bitmap_region_special && !os::uncommit_memory((char*)_aux_bitmap_region.start(), _aux_bitmap_region.byte_size())) {\n-      log_warning(gc)(\"Could not uncommit native memory for auxiliary marking bitmap for heap iteration\");\n-    }\n-}\n-\n@@ -1420,0 +1403,1 @@\n+  MarkBitMap*                  _aux_bit_map;\n@@ -1424,1 +1408,1 @@\n-  ShenandoahParallelObjectIterator(uint num_workers) :\n+  ShenandoahParallelObjectIterator(uint num_workers, MarkBitMap* bitmap) :\n@@ -1427,0 +1411,1 @@\n+        _aux_bit_map(bitmap),\n@@ -1430,0 +1415,2 @@\n+    \/\/ root marking\n+    ObjectIterateScanRootClosure oops(_aux_bit_map, &_roots_stack);\n@@ -1431,1 +1418,1 @@\n-    _heap->scan_roots_for_iteration(&_roots_stack);\n+    _heap->scan_roots_for_iteration(&_roots_stack, &oops);\n@@ -1455,1 +1442,1 @@\n-      _heap->object_iterate_parallel(cl, worker_id, _task_queues);\n+      object_iterate_parallel(cl, worker_id, _task_queues);\n@@ -1485,0 +1472,23 @@\n+\n+  void object_iterate_parallel(ObjectClosure* cl,\n+                               uint worker_id,\n+                               ShenandoahObjToScanQueueSet* queue_set) {\n+    assert(SafepointSynchronize::is_at_safepoint(), \"safe iteration is only available during safepoints\");\n+    assert(queue_set != NULL, \"task queue must not be NULL\");\n+\n+    ShenandoahObjToScanQueue* q = queue_set->queue(worker_id);\n+    assert(q != NULL, \"object iterate queue must not be NULL\");\n+    \/\/ Task in queue\n+    ShenandoahMarkTask t;\n+    ObjectIterateParScanClosure oops(_aux_bit_map, q);\n+\n+    \/\/ Work through the queue to traverse heap.\n+    \/\/ steal when there is no task in queue.\n+    while (q->pop(t) || queue_set->steal(worker_id, t)) {\n+      oop obj = t.obj();\n+      assert(oopDesc::is_oop(obj), \"must be a valid oop\");\n+      cl->do_object(obj);\n+      obj->oop_iterate(&oops);\n+    }\n+    assert(q.is_empty(), \"should be empty\");\n+  }\n@@ -1488,24 +1498,1 @@\n-  return new ShenandoahParallelObjectIterator(num_workers);\n-}\n-\n-void ShenandoahHeap::object_iterate_parallel(ObjectClosure* cl,\n-                                             uint worker_id,\n-                                             ShenandoahObjToScanQueueSet* queue_set) {\n-  assert(SafepointSynchronize::is_at_safepoint(), \"safe iteration is only available during safepoints\");\n-  assert(queue_set != NULL, \"task queue must not be NULL\");\n-\n-  ShenandoahObjToScanQueue* q = queue_set->queue(worker_id);\n-  assert(q != NULL, \"object iterate queue must not be NULL\");\n-  \/\/ Task in queue\n-  ShenandoahMarkTask t;\n-  ObjectIterateParScanClosure oops(&_aux_bit_map, q);\n-\n-  \/\/ Work through the queue to traverse heap.\n-  \/\/ steal when there is no task in queue.\n-  while (q->pop(t) || queue_set->steal(worker_id, t)) {\n-    oop obj = t.obj();\n-    assert(oopDesc::is_oop(obj), \"must be a valid oop\");\n-    cl->do_object(obj);\n-    obj->oop_iterate(&oops);\n-  }\n-  assert(q.is_empty(), \"should be empty\");\n+  return new ShenandoahParallelObjectIterator(num_workers, &_aux_bit_map);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":64,"deletions":77,"binary":false,"changes":141,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+class ObjectIterateScanRootClosure;\n@@ -555,2 +556,1 @@\n-  \/\/ parallel heap iteration support\n-  void scan_roots_for_iteration(Stack<oop, mtGC>* oop_stack);\n+  void scan_roots_for_iteration(Stack<oop, mtGC>* oop_stack, ObjectIterateScanRootClosure* oops);\n@@ -559,0 +559,1 @@\n+  \/\/ parallel heap iteration support\n@@ -560,3 +561,0 @@\n-  void object_iterate_parallel(ObjectClosure* cl,\n-                               uint worker_id,\n-                               ShenandoahObjToScanQueueSet* queue_set);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"}]}