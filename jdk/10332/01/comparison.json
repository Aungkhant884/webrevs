{"files":[{"patch":"@@ -460,2 +460,1 @@\n-instruct vloadconB(vReg dst, immI0 src) %{\n-  predicate(Matcher::vector_element_basic_type(n) == T_BYTE);\n+instruct vloadcon(vReg dst, immI0 src) %{\n@@ -463,1 +462,1 @@\n-  format %{ \"vloadconB $dst, $src\\t# load\/generate iota indices\" %}\n+  format %{ \"vloadcon $dst, $src\\t# load\/generate iota indices\" %}\n@@ -465,0 +464,1 @@\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n@@ -468,1 +468,6 @@\n-      __ lea(rscratch1, ExternalAddress(StubRoutines::aarch64::vector_iota_indices()));\n+      \/\/ The iota indices are ordered by type B\/S\/I\/L\/F\/D, and the offset between two types is 16.\n+      int offset = exact_log2(type2aelembytes(bt)) << 4;\n+      if (is_floating_point_type(bt)) {\n+        offset += 32;\n+      }\n+      __ lea(rscratch1, ExternalAddress(StubRoutines::aarch64::vector_iota_indices() + offset));\n@@ -475,1 +480,5 @@\n-      __ sve_index($dst$$FloatRegister, __ B, 0, 1);\n+      Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+      __ sve_index($dst$$FloatRegister, size, 0, 1);\n+      if (is_floating_point_type(bt)) {\n+        __ sve_scvtf($dst$$FloatRegister, size, ptrue, $dst$$FloatRegister, size);\n+      }\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad","additions":14,"deletions":5,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -399,2 +399,1 @@\n-instruct vloadconB(vReg dst, immI0 src) %{\n-  predicate(Matcher::vector_element_basic_type(n) == T_BYTE);\n+instruct vloadcon(vReg dst, immI0 src) %{\n@@ -402,1 +401,1 @@\n-  format %{ \"vloadconB $dst, $src\\t# load\/generate iota indices\" %}\n+  format %{ \"vloadcon $dst, $src\\t# load\/generate iota indices\" %}\n@@ -404,0 +403,1 @@\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n@@ -407,1 +407,6 @@\n-      __ lea(rscratch1, ExternalAddress(StubRoutines::aarch64::vector_iota_indices()));\n+      \/\/ The iota indices are ordered by type B\/S\/I\/L\/F\/D, and the offset between two types is 16.\n+      int offset = exact_log2(type2aelembytes(bt)) << 4;\n+      if (is_floating_point_type(bt)) {\n+        offset += 32;\n+      }\n+      __ lea(rscratch1, ExternalAddress(StubRoutines::aarch64::vector_iota_indices() + offset));\n@@ -414,1 +419,5 @@\n-      __ sve_index($dst$$FloatRegister, __ B, 0, 1);\n+      Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+      __ sve_index($dst$$FloatRegister, size, 0, 1);\n+      if (is_floating_point_type(bt)) {\n+        __ sve_scvtf($dst$$FloatRegister, size, ptrue, $dst$$FloatRegister, size);\n+      }\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4","additions":14,"deletions":5,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -633,0 +633,1 @@\n+    \/\/ B\n@@ -635,0 +636,15 @@\n+    \/\/ H\n+    __ emit_data64(0x0003000200010000, relocInfo::none);\n+    __ emit_data64(0x0007000600050004, relocInfo::none);\n+    \/\/ S\n+    __ emit_data64(0x0000000100000000, relocInfo::none);\n+    __ emit_data64(0x0000000300000002, relocInfo::none);\n+    \/\/ D\n+    __ emit_data64(0x0000000000000000, relocInfo::none);\n+    __ emit_data64(0x0000000000000001, relocInfo::none);\n+    \/\/ S - FP\n+    __ emit_data64(0x3F80000000000000, relocInfo::none); \/\/ 0.0f, 1.0f\n+    __ emit_data64(0x4040000040000000, relocInfo::none); \/\/ 2.0f, 3.0f\n+    \/\/ D - FP\n+    __ emit_data64(0x0000000000000000, relocInfo::none); \/\/ 0.0d\n+    __ emit_data64(0x3FF0000000000000, relocInfo::none); \/\/ 1.0d\n@@ -7849,1 +7865,3 @@\n-    StubRoutines::aarch64::_vector_iota_indices    = generate_iota_indices(\"iota_indices\");\n+    if (UseSVE == 0) {\n+      StubRoutines::aarch64::_vector_iota_indices = generate_iota_indices(\"iota_indices\");\n+    }\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1694,2 +1694,7 @@\n-void C2_MacroAssembler::load_iota_indices(XMMRegister dst, int vlen_in_bytes) {\n-  ExternalAddress addr(StubRoutines::x86::vector_iota_indices());\n+void C2_MacroAssembler::load_iota_indices(XMMRegister dst, int vlen_in_bytes, BasicType bt) {\n+  \/\/ The iota indices are ordered by type B\/S\/I\/L\/F\/D, and the offset between two types is 64.\n+  int offset = exact_log2(type2aelembytes(bt)) << 6;\n+  if (is_floating_point_type(bt)) {\n+    offset += 128;\n+  }\n+  ExternalAddress addr(StubRoutines::x86::vector_iota_indices() + offset);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -162,1 +162,1 @@\n-  void load_iota_indices(XMMRegister dst, int vlen_in_bytes);\n+  void load_iota_indices(XMMRegister dst, int vlen_in_bytes, BasicType bt);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -814,1 +814,1 @@\n-\n+  \/\/ B\n@@ -823,1 +823,45 @@\n-\n+  \/\/ W\n+  __ emit_data64(0x0003000200010000, relocInfo::none);\n+  __ emit_data64(0x0007000600050004, relocInfo::none);\n+  __ emit_data64(0x000B000A00090008, relocInfo::none);\n+  __ emit_data64(0x000F000E000D000C, relocInfo::none);\n+  __ emit_data64(0x0013001200110010, relocInfo::none);\n+  __ emit_data64(0x0017001600150014, relocInfo::none);\n+  __ emit_data64(0x001B001A00190018, relocInfo::none);\n+  __ emit_data64(0x001F001E001D001C, relocInfo::none);\n+  \/\/ D\n+  __ emit_data64(0x0000000100000000, relocInfo::none);\n+  __ emit_data64(0x0000000300000002, relocInfo::none);\n+  __ emit_data64(0x0000000500000004, relocInfo::none);\n+  __ emit_data64(0x0000000700000006, relocInfo::none);\n+  __ emit_data64(0x0000000900000008, relocInfo::none);\n+  __ emit_data64(0x0000000B0000000A, relocInfo::none);\n+  __ emit_data64(0x0000000D0000000C, relocInfo::none);\n+  __ emit_data64(0x0000000F0000000E, relocInfo::none);\n+  \/\/ Q\n+  __ emit_data64(0x0000000000000000, relocInfo::none);\n+  __ emit_data64(0x0000000000000001, relocInfo::none);\n+  __ emit_data64(0x0000000000000002, relocInfo::none);\n+  __ emit_data64(0x0000000000000003, relocInfo::none);\n+  __ emit_data64(0x0000000000000004, relocInfo::none);\n+  __ emit_data64(0x0000000000000005, relocInfo::none);\n+  __ emit_data64(0x0000000000000006, relocInfo::none);\n+  __ emit_data64(0x0000000000000007, relocInfo::none);\n+  \/\/ D - FP\n+  __ emit_data64(0x3F80000000000000, relocInfo::none); \/\/ 0.0f, 1.0f\n+  __ emit_data64(0x4040000040000000, relocInfo::none); \/\/ 2.0f, 3.0f\n+  __ emit_data64(0x40A0000040800000, relocInfo::none); \/\/ 4.0f, 5.0f\n+  __ emit_data64(0x40E0000040C00000, relocInfo::none); \/\/ 6.0f, 7.0f\n+  __ emit_data64(0x4110000041000000, relocInfo::none); \/\/ 8.0f, 9.0f\n+  __ emit_data64(0x4130000041200000, relocInfo::none); \/\/ 10.0f, 11.0f\n+  __ emit_data64(0x4150000041400000, relocInfo::none); \/\/ 12.0f, 13.0f\n+  __ emit_data64(0x4170000041600000, relocInfo::none); \/\/ 14.0f, 15.0f\n+  \/\/ Q - FP\n+  __ emit_data64(0x0000000000000000, relocInfo::none); \/\/ 0.0d\n+  __ emit_data64(0x3FF0000000000000, relocInfo::none); \/\/ 1.0d\n+  __ emit_data64(0x4000000000000000, relocInfo::none); \/\/ 2.0d\n+  __ emit_data64(0x4008000000000000, relocInfo::none); \/\/ 3.0d\n+  __ emit_data64(0x4010000000000000, relocInfo::none); \/\/ 4.0d\n+  __ emit_data64(0x4014000000000000, relocInfo::none); \/\/ 5.0d\n+  __ emit_data64(0x4018000000000000, relocInfo::none); \/\/ 6.0d\n+  __ emit_data64(0x401c000000000000, relocInfo::none); \/\/ 7.0d\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":46,"deletions":2,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -8403,1 +8403,0 @@\n-  predicate(Matcher::vector_element_basic_type(n) == T_BYTE);\n@@ -8408,1 +8407,2 @@\n-     __ load_iota_indices($dst$$XMMRegister, vlen_in_bytes);\n+     BasicType bt = Matcher::vector_element_basic_type(this);\n+     __ load_iota_indices($dst$$XMMRegister, vlen_in_bytes, bt);\n@@ -8420,1 +8420,1 @@\n-     int vlen = Matcher::vector_length(this);\n+     int vlen_in_bytes = Matcher::vector_length_in_bytes(this);\n@@ -8424,4 +8424,1 @@\n-     __ load_iota_indices($dst$$XMMRegister, vlen);\n-     if (elem_bt != T_BYTE) {\n-       __ vconvert_b2x(elem_bt, $dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-     }\n+     __ load_iota_indices($dst$$XMMRegister, vlen_in_bytes, elem_bt);\n@@ -8439,1 +8436,1 @@\n-     int vlen = Matcher::vector_length(this);\n+     int vlen_in_bytes = Matcher::vector_length_in_bytes(this);\n@@ -8443,4 +8440,1 @@\n-     __ load_iota_indices($dst$$XMMRegister, vlen);\n-     if (elem_bt != T_BYTE) {\n-       __ vconvert_b2x(elem_bt, $dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-     }\n+     __ load_iota_indices($dst$$XMMRegister, vlen_in_bytes, elem_bt);\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":6,"deletions":12,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1181,0 +1181,12 @@\n+                                                                                                                                               \\\n+  do_intrinsic(_IndexVector, jdk_internal_vm_vector_VectorSupport, index_vector_op_name, index_vector_op_sig, F_S)                             \\\n+    do_signature(index_vector_op_sig, \"(Ljava\/lang\/Class;\"                                                                                     \\\n+                                       \"Ljava\/lang\/Class;\"                                                                                     \\\n+                                       \"I\"                                                                                                     \\\n+                                       \"Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;\"                                                         \\\n+                                       \"I\"                                                                                                     \\\n+                                       \"Ljdk\/internal\/vm\/vector\/VectorSupport$VectorSpecies;\"                                                  \\\n+                                       \"Ljdk\/internal\/vm\/vector\/VectorSupport$IndexOperation;)\"                                                \\\n+                                       \"Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;\")                                                        \\\n+    do_name(index_vector_op_name, \"indexVector\")                                                                                               \\\n+                                                                                                                                               \\\n@@ -1289,1 +1301,1 @@\n-  LAST_COMPILER_INLINE = _VectorCompressExpand,\n+  LAST_COMPILER_INLINE = _IndexVector,\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -779,0 +779,1 @@\n+  case vmIntrinsics::_IndexVector:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -719,0 +719,2 @@\n+  case vmIntrinsics::_IndexVector:\n+    return inline_index_vector();\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -351,0 +351,1 @@\n+  bool inline_index_vector();\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2847,0 +2847,152 @@\n+\n+\/\/ public static\n+\/\/ <V extends Vector<E>,\n+\/\/  E,\n+\/\/  S extends VectorSpecies<E>>\n+\/\/  V indexVector(Class<? extends V> vClass, Class<E> eClass,\n+\/\/                int length,\n+\/\/                V v, int step, S s,\n+\/\/                IndexOperation<V, S> defaultImpl)\n+bool LibraryCallKit::inline_index_vector() {\n+  const TypeInstPtr* vector_klass = gvn().type(argument(0))->isa_instptr();\n+  const TypeInstPtr* elem_klass   = gvn().type(argument(1))->isa_instptr();\n+  const TypeInt*     vlen         = gvn().type(argument(2))->isa_int();\n+\n+  if (vector_klass == NULL || elem_klass == NULL || vlen == NULL ||\n+      vector_klass->const_oop() == NULL || !vlen->is_con() ||\n+      elem_klass->const_oop() == NULL) {\n+    if (C->print_intrinsics()) {\n+      tty->print_cr(\"  ** missing constant: vclass=%s etype=%s vlen=%s\",\n+                    NodeClassNames[argument(0)->Opcode()],\n+                    NodeClassNames[argument(1)->Opcode()],\n+                    NodeClassNames[argument(2)->Opcode()]);\n+    }\n+    return false; \/\/ not enough info for intrinsification\n+  }\n+\n+  if (!is_klass_initialized(vector_klass)) {\n+    if (C->print_intrinsics()) {\n+      tty->print_cr(\"  ** klass argument not initialized\");\n+    }\n+    return false;\n+  }\n+\n+  ciType* elem_type = elem_klass->const_oop()->as_instance()->java_mirror_type();\n+  if (!elem_type->is_primitive_type()) {\n+    if (C->print_intrinsics()) {\n+      tty->print_cr(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n+    }\n+    return false; \/\/ should be primitive type\n+  }\n+\n+  int num_elem = vlen->get_con();\n+  BasicType elem_bt = elem_type->basic_type();\n+\n+  \/\/ Check whether the iota index generation op is supported by the current hardware\n+  if (!arch_supports_vector(Op_VectorLoadConst, num_elem, elem_bt, VecMaskNotUsed)) {\n+    if (C->print_intrinsics()) {\n+      tty->print_cr(\"  ** not supported: vlen=%d etype=%s\", num_elem, type2name(elem_bt));\n+    }\n+    return false; \/\/ not supported\n+  }\n+\n+  int mul_op = VectorSupport::vop2ideal(VectorSupport::VECTOR_OP_MUL, elem_bt);\n+  int vmul_op = VectorNode::opcode(mul_op, elem_bt);\n+  bool needs_mul = true;\n+  Node* scale = argument(4);\n+  const TypeInt* scale_type = gvn().type(scale)->isa_int();\n+  \/\/ Multiply is not needed if the scale is a constant \"1\".\n+  if (scale_type && scale_type->is_con() && scale_type->get_con() == 1) {\n+    needs_mul = false;\n+  } else {\n+    \/\/ Check whether the vector multiply op is supported by the current hardware\n+    if (!arch_supports_vector(vmul_op, num_elem, elem_bt, VecMaskNotUsed)) {\n+      if (C->print_intrinsics()) {\n+        tty->print_cr(\"  ** not supported: vlen=%d etype=%s\", num_elem, type2name(elem_bt));\n+      }\n+      return false; \/\/ not supported\n+    }\n+\n+    \/\/ Check whether the scalar cast op is supported by the current hardware\n+    if (is_floating_point_type(elem_bt) || elem_bt == T_LONG) {\n+      int cast_op = elem_bt == T_LONG ? Op_ConvI2L :\n+                    elem_bt == T_FLOAT? Op_ConvI2F : Op_ConvI2D;\n+      if (!Matcher::match_rule_supported(cast_op)) {\n+        if (C->print_intrinsics()) {\n+          tty->print_cr(\"  ** Rejected op (%s) because architecture does not support it\",\n+                        NodeClassNames[cast_op]);\n+        }\n+        return false; \/\/ not supported\n+      }\n+    }\n+  }\n+\n+  ciKlass* vbox_klass = vector_klass->const_oop()->as_instance()->java_lang_Class_klass();\n+  const TypeInstPtr* vbox_type = TypeInstPtr::make_exact(TypePtr::NotNull, vbox_klass);\n+  Node* opd = unbox_vector(argument(3), vbox_type, elem_bt, num_elem);\n+  if (opd == NULL) {\n+    if (C->print_intrinsics()) {\n+      tty->print_cr(\"  ** unbox failed vector=%s\",\n+                    NodeClassNames[argument(3)->Opcode()]);\n+    }\n+    return false;\n+  }\n+\n+  int add_op = VectorSupport::vop2ideal(VectorSupport::VECTOR_OP_ADD, elem_bt);\n+  int vadd_op = VectorNode::opcode(add_op, elem_bt);\n+  bool needs_add = true;\n+  \/\/ The addition is not needed if all the element values of \"opd\" are zero\n+  if (VectorNode::is_all_zeros_vector(opd)) {\n+    needs_add = false;\n+  } else {\n+    \/\/ Check whether the vector addition op is supported by the current hardware\n+    if (!arch_supports_vector(vadd_op, num_elem, elem_bt, VecMaskNotUsed)) {\n+      if (C->print_intrinsics()) {\n+        tty->print_cr(\"  ** not supported: vlen=%d etype=%s\", num_elem, type2name(elem_bt));\n+      }\n+      return false; \/\/ not supported\n+    }\n+  }\n+\n+  \/\/ Compute the iota indice vector\n+  const TypeVect* vt = TypeVect::make(elem_bt, num_elem);\n+  Node* index = gvn().transform(new VectorLoadConstNode(gvn().makecon(TypeInt::ZERO), vt));\n+\n+  \/\/ Broadcast the \"scale\" to a vector, and multiply the \"scale\" with iota indice vector.\n+  if (needs_mul) {\n+    switch (elem_bt) {\n+      case T_BOOLEAN: \/\/ fall-through\n+      case T_BYTE:    \/\/ fall-through\n+      case T_SHORT:   \/\/ fall-through\n+      case T_CHAR:    \/\/ fall-through\n+      case T_INT: {\n+        \/\/ no conversion needed\n+        break;\n+      }\n+      case T_LONG: {\n+        scale = gvn().transform(new ConvI2LNode(scale));\n+        break;\n+      }\n+      case T_FLOAT: {\n+        scale = gvn().transform(new ConvI2FNode(scale));\n+        break;\n+      }\n+      case T_DOUBLE: {\n+        scale = gvn().transform(new ConvI2DNode(scale));\n+        break;\n+      }\n+      default: fatal(\"%s\", type2name(elem_bt));\n+    }\n+    scale = gvn().transform(VectorNode::scalar2vector(scale, num_elem, Type::get_const_basic_type(elem_bt)));\n+    index = gvn().transform(VectorNode::make(vmul_op, index, scale, vt));\n+  }\n+\n+  \/\/ Add \"opd\" if addition is needed.\n+  if (needs_add) {\n+    index = gvn().transform(VectorNode::make(vadd_op, opd, index, vt));\n+  }\n+  Node* vbox = box_vector(index, vbox_type, elem_bt, num_elem);\n+  set_result(vbox);\n+  C->set_max_vector_size(MAX2(C->max_vector_size(), (uint)(num_elem * type2aelembytes(elem_bt))));\n+  return true;\n+}\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":152,"deletions":0,"binary":false,"changes":152,"status":"modified"},{"patch":"@@ -243,1 +243,1 @@\n-    \/\/FIXME @IntrinsicCandidate\n+    @IntrinsicCandidate\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/vector\/VectorSupport.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,105 @@\n+\/\/\n+\/\/ Copyright (c) 2022, Arm Limited. All rights reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it\n+\/\/ under the terms of the GNU General Public License version 2 only, as\n+\/\/ published by the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT\n+\/\/ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+\/\/ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+\/\/ version 2 for more details (a copy is included in the LICENSE file that\n+\/\/ accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version\n+\/\/ 2 along with this work; if not, write to the Free Software Foundation,\n+\/\/ Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+\/\/ or visit www.oracle.com if you need additional information or have any\n+\/\/ questions.\n+\/\/\n+\/\/\n+package org.openjdk.bench.jdk.incubator.vector;\n+\n+import java.util.concurrent.TimeUnit;\n+import jdk.incubator.vector.*;\n+import org.openjdk.jmh.annotations.*;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class IndexVectorBenchmark {\n+    @Param({\"1024\"})\n+    private int size;\n+\n+    private byte[] ba;\n+    private short[] sa;\n+    private int[] ia;\n+    private long[] la;\n+    private float[] fa;\n+    private double[] da;\n+\n+    private static final VectorSpecies<Byte> bspecies = VectorSpecies.ofLargestShape(byte.class);\n+    private static final VectorSpecies<Short> sspecies = VectorSpecies.ofLargestShape(short.class);\n+    private static final VectorSpecies<Integer> ispecies = VectorSpecies.ofLargestShape(int.class);\n+    private static final VectorSpecies<Long> lspecies = VectorSpecies.ofLargestShape(long.class);\n+    private static final VectorSpecies<Float> fspecies = VectorSpecies.ofLargestShape(float.class);\n+    private static final VectorSpecies<Double> dspecies = VectorSpecies.ofLargestShape(double.class);\n+\n+    @Setup(Level.Trial)\n+    public void Setup() {\n+        ba = new byte[size];\n+        sa = new short[size];\n+        ia = new int[size];\n+        la = new long[size];\n+        fa = new float[size];\n+        da = new double[size];\n+    }\n+\n+    @Benchmark\n+    public void byteIndexVector() {\n+        for (int i = 0; i < size; i += bspecies.length()) {\n+            ((ByteVector) bspecies.broadcast(0).addIndex(i % 2)).intoArray(ba, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void shortIndexVector() {\n+        for (int i = 0; i < size; i += sspecies.length()) {\n+            ((ShortVector) sspecies.broadcast(0).addIndex(i % 5)).intoArray(sa, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void intIndexVector() {\n+        for (int i = 0; i < size; i += ispecies.length()) {\n+            ((IntVector) ispecies.broadcast(0).addIndex(i % 5)).intoArray(ia, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void longIndexVector() {\n+        for (int i = 0; i < size; i += lspecies.length()) {\n+            ((LongVector) lspecies.broadcast(0).addIndex(i % 5)).intoArray(la, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void floatIndexVector() {\n+        for (int i = 0; i < size; i += fspecies.length()) {\n+            ((FloatVector) fspecies.broadcast(0).addIndex(i % 5)).intoArray(fa, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void doubleIndexVector() {\n+        for (int i = 0; i < size; i += dspecies.length()) {\n+            ((DoubleVector) dspecies.broadcast(0).addIndex(i % 5)).intoArray(da, i);\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/IndexVectorBenchmark.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"}]}