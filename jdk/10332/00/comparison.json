{"files":[{"patch":"@@ -218,0 +218,5 @@\n+      case Op_VectorLoadConst:\n+        if (is_floating_point_type(bt)) {\n+          return false;\n+        }\n+        break;\n@@ -460,2 +465,2 @@\n-instruct vloadconB(vReg dst, immI0 src) %{\n-  predicate(Matcher::vector_element_basic_type(n) == T_BYTE);\n+instruct vloadcon(vReg dst, immI0 src) %{\n+  predicate(is_integral_type(Matcher::vector_element_basic_type(n)));\n@@ -463,1 +468,1 @@\n-  format %{ \"vloadconB $dst, $src\\t# load\/generate iota indices\" %}\n+  format %{ \"vloadcon $dst, $src\\t# load\/generate iota indices\" %}\n@@ -465,0 +470,1 @@\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n@@ -468,1 +474,3 @@\n-      __ lea(rscratch1, ExternalAddress(StubRoutines::aarch64::vector_iota_indices()));\n+      \/\/ The offset based on the iota indices stub for B\/H\/S\/D is 0\/16\/32\/48.\n+      int offset = exact_log2(type2aelembytes(bt)) << 4;\n+      __ lea(rscratch1, ExternalAddress(StubRoutines::aarch64::vector_iota_indices() + offset));\n@@ -475,1 +483,2 @@\n-      __ sve_index($dst$$FloatRegister, __ B, 0, 1);\n+      Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+      __ sve_index($dst$$FloatRegister, size, 0, 1);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad","additions":14,"deletions":5,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -208,0 +208,5 @@\n+      case Op_VectorLoadConst:\n+        if (is_floating_point_type(bt)) {\n+          return false;\n+        }\n+        break;\n@@ -399,2 +404,2 @@\n-instruct vloadconB(vReg dst, immI0 src) %{\n-  predicate(Matcher::vector_element_basic_type(n) == T_BYTE);\n+instruct vloadcon(vReg dst, immI0 src) %{\n+  predicate(is_integral_type(Matcher::vector_element_basic_type(n)));\n@@ -402,1 +407,1 @@\n-  format %{ \"vloadconB $dst, $src\\t# load\/generate iota indices\" %}\n+  format %{ \"vloadcon $dst, $src\\t# load\/generate iota indices\" %}\n@@ -404,0 +409,1 @@\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n@@ -407,1 +413,3 @@\n-      __ lea(rscratch1, ExternalAddress(StubRoutines::aarch64::vector_iota_indices()));\n+      \/\/ The offset based on the iota indices stub for B\/H\/S\/D is 0\/16\/32\/48.\n+      int offset = exact_log2(type2aelembytes(bt)) << 4;\n+      __ lea(rscratch1, ExternalAddress(StubRoutines::aarch64::vector_iota_indices() + offset));\n@@ -414,1 +422,2 @@\n-      __ sve_index($dst$$FloatRegister, __ B, 0, 1);\n+      Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+      __ sve_index($dst$$FloatRegister, size, 0, 1);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4","additions":14,"deletions":5,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -633,0 +633,1 @@\n+    \/\/ B\n@@ -635,0 +636,9 @@\n+    \/\/ H\n+    __ emit_data64(0x0003000200010000, relocInfo::none);\n+    __ emit_data64(0x0007000600050004, relocInfo::none);\n+    \/\/ S\n+    __ emit_data64(0x0000000100000000, relocInfo::none);\n+    __ emit_data64(0x0000000300000002, relocInfo::none);\n+    \/\/ D\n+    __ emit_data64(0x0000000000000000, relocInfo::none);\n+    __ emit_data64(0x0000000000000001, relocInfo::none);\n@@ -7849,1 +7859,3 @@\n-    StubRoutines::aarch64::_vector_iota_indices    = generate_iota_indices(\"iota_indices\");\n+    if (UseSVE == 0) {\n+      StubRoutines::aarch64::_vector_iota_indices = generate_iota_indices(\"iota_indices\");\n+    }\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1694,2 +1694,4 @@\n-void C2_MacroAssembler::load_iota_indices(XMMRegister dst, int vlen_in_bytes) {\n-  ExternalAddress addr(StubRoutines::x86::vector_iota_indices());\n+void C2_MacroAssembler::load_iota_indices(XMMRegister dst, int vlen_in_bytes, BasicType bt) {\n+  \/\/ The offset based on the iota indices stub for B\/W\/D\/Q is 0\/64\/128\/256.\n+  int offset = exact_log2(type2aelembytes(bt)) << 6;\n+  ExternalAddress addr(StubRoutines::x86::vector_iota_indices() + offset);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -162,1 +162,1 @@\n-  void load_iota_indices(XMMRegister dst, int vlen_in_bytes);\n+  void load_iota_indices(XMMRegister dst, int vlen_in_bytes, BasicType bt);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -814,1 +814,1 @@\n-\n+  \/\/ B\n@@ -823,1 +823,27 @@\n-\n+  \/\/ W\n+  __ emit_data64(0x0003000200010000, relocInfo::none);\n+  __ emit_data64(0x0007000600050004, relocInfo::none);\n+  __ emit_data64(0x000B000A00090008, relocInfo::none);\n+  __ emit_data64(0x000F000E000D000C, relocInfo::none);\n+  __ emit_data64(0x0013001200110010, relocInfo::none);\n+  __ emit_data64(0x0017001600150014, relocInfo::none);\n+  __ emit_data64(0x001B001A00190018, relocInfo::none);\n+  __ emit_data64(0x001F001E001D001C, relocInfo::none);\n+  \/\/ D\n+  __ emit_data64(0x0000000100000000, relocInfo::none);\n+  __ emit_data64(0x0000000300000002, relocInfo::none);\n+  __ emit_data64(0x0000000500000004, relocInfo::none);\n+  __ emit_data64(0x0000000700000006, relocInfo::none);\n+  __ emit_data64(0x0000000900000008, relocInfo::none);\n+  __ emit_data64(0x0000000B0000000A, relocInfo::none);\n+  __ emit_data64(0x0000000D0000000C, relocInfo::none);\n+  __ emit_data64(0x0000000F0000000E, relocInfo::none);\n+  \/\/ Q\n+  __ emit_data64(0x0000000000000000, relocInfo::none);\n+  __ emit_data64(0x0000000000000001, relocInfo::none);\n+  __ emit_data64(0x0000000000000002, relocInfo::none);\n+  __ emit_data64(0x0000000000000003, relocInfo::none);\n+  __ emit_data64(0x0000000000000004, relocInfo::none);\n+  __ emit_data64(0x0000000000000005, relocInfo::none);\n+  __ emit_data64(0x0000000000000006, relocInfo::none);\n+  __ emit_data64(0x0000000000000007, relocInfo::none);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":28,"deletions":2,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2000,0 +2000,5 @@\n+    case Op_VectorLoadConst:\n+      if (is_floating_point_type(bt)) {\n+        return false;\n+      }\n+      break;\n@@ -8413,1 +8418,1 @@\n-  predicate(Matcher::vector_element_basic_type(n) == T_BYTE);\n+  predicate(is_integral_type(Matcher::vector_element_basic_type(n)));\n@@ -8418,1 +8423,2 @@\n-     __ load_iota_indices($dst$$XMMRegister, vlen_in_bytes);\n+     BasicType bt = Matcher::vector_element_basic_type(this);\n+     __ load_iota_indices($dst$$XMMRegister, vlen_in_bytes, bt);\n@@ -8430,1 +8436,1 @@\n-     int vlen = Matcher::vector_length(this);\n+     int vlen_in_bytes = Matcher::vector_length_in_bytes(this);\n@@ -8434,4 +8440,1 @@\n-     __ load_iota_indices($dst$$XMMRegister, vlen);\n-     if (elem_bt != T_BYTE) {\n-       __ vconvert_b2x(elem_bt, $dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-     }\n+     __ load_iota_indices($dst$$XMMRegister, vlen_in_bytes, elem_bt);\n@@ -8449,1 +8452,1 @@\n-     int vlen = Matcher::vector_length(this);\n+     int vlen_in_bytes = Matcher::vector_length_in_bytes(this);\n@@ -8453,4 +8456,1 @@\n-     __ load_iota_indices($dst$$XMMRegister, vlen);\n-     if (elem_bt != T_BYTE) {\n-       __ vconvert_b2x(elem_bt, $dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-     }\n+     __ load_iota_indices($dst$$XMMRegister, vlen_in_bytes, elem_bt);\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -1172,0 +1172,12 @@\n+                                                                                                                                               \\\n+  do_intrinsic(_IndexVector, jdk_internal_vm_vector_VectorSupport, index_vector_op_name, index_vector_op_sig, F_S)                             \\\n+    do_signature(index_vector_op_sig, \"(Ljava\/lang\/Class;\"                                                                                     \\\n+                                       \"Ljava\/lang\/Class;\"                                                                                     \\\n+                                       \"I\"                                                                                                     \\\n+                                       \"Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;\"                                                         \\\n+                                       \"I\"                                                                                                     \\\n+                                       \"Ljdk\/internal\/vm\/vector\/VectorSupport$VectorSpecies;\"                                                  \\\n+                                       \"Ljdk\/internal\/vm\/vector\/VectorSupport$IndexOperation;)\"                                                \\\n+                                       \"Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;\")                                                        \\\n+    do_name(index_vector_op_name, \"indexVector\")                                                                                               \\\n+                                                                                                                                               \\\n@@ -1280,1 +1292,1 @@\n-  LAST_COMPILER_INLINE = _VectorCompressExpand,\n+  LAST_COMPILER_INLINE = _IndexVector,\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -767,0 +767,1 @@\n+  case vmIntrinsics::_IndexVector:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -715,0 +715,2 @@\n+  case vmIntrinsics::_IndexVector:\n+    return inline_index_vector();\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -351,0 +351,1 @@\n+  bool inline_index_vector();\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2853,0 +2853,143 @@\n+\n+\/\/ public static\n+\/\/ <V extends Vector<E>,\n+\/\/  E,\n+\/\/  S extends VectorSpecies<E>>\n+\/\/  V indexVector(Class<? extends V> vClass, Class<E> eClass,\n+\/\/                int length,\n+\/\/                V v, int step, S s,\n+\/\/                IndexOperation<V, S> defaultImpl)\n+bool LibraryCallKit::inline_index_vector() {\n+  const TypeInstPtr* vector_klass = gvn().type(argument(0))->isa_instptr();\n+  const TypeInstPtr* elem_klass   = gvn().type(argument(1))->isa_instptr();\n+  const TypeInt*     vlen         = gvn().type(argument(2))->isa_int();\n+\n+  if (vector_klass == NULL || elem_klass == NULL || vlen == NULL ||\n+      vector_klass->const_oop() == NULL || !vlen->is_con() ||\n+      elem_klass->const_oop() == NULL) {\n+    if (C->print_intrinsics()) {\n+      tty->print_cr(\"  ** missing constant: vclass=%s etype=%s vlen=%s\",\n+                    NodeClassNames[argument(0)->Opcode()],\n+                    NodeClassNames[argument(1)->Opcode()],\n+                    NodeClassNames[argument(2)->Opcode()]);\n+    }\n+    return false; \/\/ not enough info for intrinsification\n+  }\n+\n+  if (!is_klass_initialized(vector_klass)) {\n+    if (C->print_intrinsics()) {\n+      tty->print_cr(\"  ** klass argument not initialized\");\n+    }\n+    return false;\n+  }\n+\n+  ciType* elem_type = elem_klass->const_oop()->as_instance()->java_mirror_type();\n+  if (!elem_type->is_primitive_type()) {\n+    if (C->print_intrinsics()) {\n+      tty->print_cr(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n+    }\n+    return false; \/\/ should be primitive type\n+  }\n+\n+  int num_elem = vlen->get_con();\n+  BasicType elem_bt = elem_type->basic_type();\n+  BasicType iota_bt = elem_bt;\n+  \/\/ The iota indices are integral type\n+  if (is_floating_point_type(elem_bt)) {\n+    iota_bt = elem_bt == T_FLOAT ? T_INT : T_LONG;\n+  }\n+\n+  \/\/ Get the vector add\/mul op based on the basic element type\n+  int add_op = VectorSupport::vop2ideal(VectorSupport::VECTOR_OP_ADD, elem_bt);\n+  int mul_op = VectorSupport::vop2ideal(VectorSupport::VECTOR_OP_MUL, elem_bt);\n+  int vadd_op = VectorNode::opcode(add_op, elem_bt);\n+  int vmul_op = VectorNode::opcode(mul_op, elem_bt);\n+\n+  \/\/ Check whether the basic ops are supported by the current hardware\n+  if (!arch_supports_vector(Op_VectorLoadConst, num_elem, iota_bt, VecMaskNotUsed) ||\n+      !arch_supports_vector(vmul_op, num_elem, elem_bt, VecMaskNotUsed) ||\n+      !arch_supports_vector(vadd_op, num_elem, elem_bt, VecMaskNotUsed)) {\n+    if (C->print_intrinsics()) {\n+      tty->print_cr(\"  ** not supported: vlen=%d etype=%s\", num_elem, type2name(elem_bt));\n+    }\n+    return false; \/\/ not supported\n+  }\n+\n+  \/\/ If it is a floating point type vector, additionally check whether the\n+  \/\/ relative vector cast op is supported by the current hardware\n+  if (is_floating_point_type(elem_bt)) {\n+    int vcast_op = elem_bt == T_FLOAT ? Op_VectorCastI2X : Op_VectorCastL2X;\n+    if (!arch_supports_vector(vcast_op, num_elem, elem_bt, VecMaskNotUsed)) {\n+      if (C->print_intrinsics()) {\n+        tty->print_cr(\"  ** not supported: vlen=%d etype=%s\", num_elem, type2name(elem_bt));\n+      }\n+      return false; \/\/ not supported\n+    }\n+  }\n+\n+  ciKlass* vbox_klass = vector_klass->const_oop()->as_instance()->java_lang_Class_klass();\n+  const TypeInstPtr* vbox_type = TypeInstPtr::make_exact(TypePtr::NotNull, vbox_klass);\n+  Node* opd = unbox_vector(argument(3), vbox_type, elem_bt, num_elem);\n+  if (opd == NULL) {\n+    if (C->print_intrinsics()) {\n+      tty->print_cr(\"  ** unbox failed vector=%s\",\n+                    NodeClassNames[argument(3)->Opcode()]);\n+    }\n+    return false;\n+  }\n+\n+  \/\/ Compute the iota indice vector\n+  const TypeVect* vt = TypeVect::make(elem_bt, num_elem);\n+  const TypeVect* iota_vt = TypeVect::make(iota_bt, num_elem);\n+  Node* iota = gvn().transform(new VectorLoadConstNode(gvn().makecon(TypeInt::ZERO), iota_vt));\n+  if (elem_bt == T_FLOAT) {\n+    iota = gvn().transform(new VectorCastI2XNode(iota, vt));\n+  } else if (elem_bt == T_DOUBLE) {\n+    iota = gvn().transform(new VectorCastL2XNode(iota, vt));\n+  }\n+\n+  Node* index = NULL;\n+  Node* scale = argument(4);\n+  const TypeInt* scale_type = gvn().type(scale)->isa_int();\n+  if (scale_type && scale_type->is_con() && scale_type->get_con() == 1) {\n+    index = iota;\n+  } else {\n+    \/\/ Multiply the \"scale\" with \"iota\" if it is not \"1\".\n+    \/\/ Broadcast the \"scale\" to a vector\n+    switch (elem_bt) {\n+      case T_BOOLEAN: \/\/ fall-through\n+      case T_BYTE:    \/\/ fall-through\n+      case T_SHORT:   \/\/ fall-through\n+      case T_CHAR:    \/\/ fall-through\n+      case T_INT: {\n+        \/\/ no conversion needed\n+        break;\n+      }\n+      case T_LONG: {\n+        scale = gvn().transform(new ConvI2LNode(scale));\n+        break;\n+      }\n+      case T_FLOAT: {\n+        scale = gvn().transform(new ConvI2FNode(scale));\n+        break;\n+      }\n+      case T_DOUBLE: {\n+        scale = gvn().transform(new ConvI2LNode(scale));\n+        scale = gvn().transform(new ConvL2DNode(scale));\n+        break;\n+      }\n+      default: fatal(\"%s\", type2name(elem_bt));\n+    }\n+    scale = gvn().transform(VectorNode::scalar2vector(scale, num_elem, Type::get_const_basic_type(elem_bt)));\n+    index = gvn().transform(VectorNode::make(vmul_op, iota, scale, vt));\n+  }\n+\n+  \/\/ Add \"opd\" if it is not a zero vector.\n+  if (!VectorNode::is_all_zeros_vector(opd)) {\n+    index = gvn().transform(VectorNode::make(vadd_op, opd, index, vt));\n+  }\n+  Node* vbox = box_vector(index, vbox_type, elem_bt, num_elem);\n+  set_result(vbox);\n+  C->set_max_vector_size(MAX2(C->max_vector_size(), (uint)(num_elem * type2aelembytes(elem_bt))));\n+  return true;\n+}\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":143,"deletions":0,"binary":false,"changes":143,"status":"modified"},{"patch":"@@ -243,1 +243,1 @@\n-    \/\/FIXME @IntrinsicCandidate\n+    @IntrinsicCandidate\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/vector\/VectorSupport.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,105 @@\n+\/\/\n+\/\/ Copyright (c) 2022, Arm Limited. All rights reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it\n+\/\/ under the terms of the GNU General Public License version 2 only, as\n+\/\/ published by the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT\n+\/\/ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+\/\/ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+\/\/ version 2 for more details (a copy is included in the LICENSE file that\n+\/\/ accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version\n+\/\/ 2 along with this work; if not, write to the Free Software Foundation,\n+\/\/ Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+\/\/ or visit www.oracle.com if you need additional information or have any\n+\/\/ questions.\n+\/\/\n+\/\/\n+package org.openjdk.bench.jdk.incubator.vector;\n+\n+import java.util.concurrent.TimeUnit;\n+import jdk.incubator.vector.*;\n+import org.openjdk.jmh.annotations.*;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class IndexVectorBenchmark {\n+    @Param({\"1024\"})\n+    private int size;\n+\n+    private byte[] ba;\n+    private short[] sa;\n+    private int[] ia;\n+    private long[] la;\n+    private float[] fa;\n+    private double[] da;\n+\n+    private static final VectorSpecies<Byte> bspecies = VectorSpecies.ofLargestShape(byte.class);\n+    private static final VectorSpecies<Short> sspecies = VectorSpecies.ofLargestShape(short.class);\n+    private static final VectorSpecies<Integer> ispecies = VectorSpecies.ofLargestShape(int.class);\n+    private static final VectorSpecies<Long> lspecies = VectorSpecies.ofLargestShape(long.class);\n+    private static final VectorSpecies<Float> fspecies = VectorSpecies.ofLargestShape(float.class);\n+    private static final VectorSpecies<Double> dspecies = VectorSpecies.ofLargestShape(double.class);\n+\n+    @Setup(Level.Trial)\n+    public void Setup() {\n+        ba = new byte[size];\n+        sa = new short[size];\n+        ia = new int[size];\n+        la = new long[size];\n+        fa = new float[size];\n+        da = new double[size];\n+    }\n+\n+    @Benchmark\n+    public void byteIndexVector() {\n+        for (int i = 0; i < size; i += bspecies.length()) {\n+            ((ByteVector) bspecies.broadcast(0).addIndex(i % 2)).intoArray(ba, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void shortIndexVector() {\n+        for (int i = 0; i < size; i += sspecies.length()) {\n+            ((ShortVector) sspecies.broadcast(0).addIndex(i % 5)).intoArray(sa, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void intIndexVector() {\n+        for (int i = 0; i < size; i += ispecies.length()) {\n+            ((IntVector) ispecies.broadcast(0).addIndex(i % 5)).intoArray(ia, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void longIndexVector() {\n+        for (int i = 0; i < size; i += lspecies.length()) {\n+            ((LongVector) lspecies.broadcast(0).addIndex(i % 5)).intoArray(la, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void floatIndexVector() {\n+        for (int i = 0; i < size; i += fspecies.length()) {\n+            ((FloatVector) fspecies.broadcast(0).addIndex(i % 5)).intoArray(fa, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void doubleIndexVector() {\n+        for (int i = 0; i < size; i += dspecies.length()) {\n+            ((DoubleVector) dspecies.broadcast(0).addIndex(i % 5)).intoArray(da, i);\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/IndexVectorBenchmark.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"}]}