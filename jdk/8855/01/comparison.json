{"files":[{"patch":"@@ -202,4 +202,0 @@\n-        static BasicType basicType(Wrapper type) {\n-            char c = type.basicTypeChar();\n-            return basicType(c);\n-        }\n@@ -208,1 +204,1 @@\n-            return basicType(Wrapper.forPrimitiveType(type));\n+            return basicType(Wrapper.forPrimitiveType(type).basicTypeChar());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaForm.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -37,3 +37,0 @@\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.ConcurrentMap;\n-import java.util.function.Function;\n@@ -375,1 +372,1 @@\n-        \/\/ Element list containing String constants, or null for arguments\n+        \/\/ Element list containing interleaving String constants\n@@ -399,0 +396,2 @@\n+                } else {\n+                    elements.add(null);\n@@ -400,1 +399,0 @@\n-                elements.add(null);\n@@ -412,0 +410,2 @@\n+        } else {\n+            elements.add(null);\n@@ -448,35 +448,12 @@\n-    private static MethodHandle generateMHInlineCopy(MethodType mt, List<String> elements) {\n-\n-        \/\/ Fast-path unary concatenations\n-        if (elements.size() == 1) {\n-            String s0 = elements.get(0);\n-            if (s0 == null) {\n-                return unaryConcat(mt.parameterType(0));\n-            } else {\n-                return MethodHandles.insertArguments(unaryConcat(Object.class), 0, s0);\n-            }\n-        }\n-        \/\/ Fast-path binary concatenations\n-        if (elements.size() == 2) {\n-            \/\/ Two arguments\n-            String s0 = elements.get(0);\n-            String s1 = elements.get(1);\n-\n-            if (mt.parameterCount() == 2 &&\n-                    !mt.parameterType(0).isPrimitive() &&\n-                    !mt.parameterType(1).isPrimitive() &&\n-                    s0 == null &&\n-                    s1 == null) {\n-                return simpleConcat();\n-            } else if (mt.parameterCount() == 1) {\n-                \/\/ One argument, one constant\n-                String constant;\n-                int constIdx;\n-                if (s1 == null) {\n-                    constant = s0;\n-                    constIdx = 0;\n-                } else {\n-                    constant = s1;\n-                    constIdx = 1;\n-                }\n-                if (constant.isEmpty()) {\n+    private static MethodHandle generateMHInlineCopy(MethodType mt, List<String> constants) {\n+        int paramCount = mt.parameterCount();\n+        String suffix = constants.get(paramCount);\n+\n+        \/\/ Fast-path trivial concatenations\n+        if (paramCount == 0) {\n+            return MethodHandles.insertArguments(newStringifier(), 0, suffix == null ? \"\" : suffix);\n+        }\n+        if (paramCount == 1) {\n+            String prefix = constants.get(0);\n+            if (prefix == null) {\n+                if (suffix == null) {\n@@ -484,6 +461,7 @@\n-                } else if (!mt.parameterType(0).isPrimitive()) {\n-                    \/\/ Non-primitive argument\n-                    return MethodHandles.insertArguments(simpleConcat(), constIdx, constant);\n-                }\n-            }\n-            \/\/ else... fall-through to slow-path\n+                } else if (!mt.hasPrimitives()) {\n+                    return MethodHandles.insertArguments(simpleConcat(), 1, suffix);\n+                } \/\/ else fall-through\n+            } else if (suffix == null && !mt.hasPrimitives()) {\n+                \/\/ Non-primitive argument\n+                return MethodHandles.insertArguments(simpleConcat(), 0, prefix);\n+            } \/\/ fall-through if there's both a prefix and suffix\n@@ -491,0 +469,6 @@\n+        if (paramCount == 2 && !mt.hasPrimitives() && suffix == null\n+                && constants.get(0) == null && constants.get(1) == null) {\n+            \/\/ Two reference arguments, no surrounding constants\n+            return simpleConcat();\n+        }\n+        \/\/ else... fall-through to slow-path\n@@ -528,0 +512,2 @@\n+        \/\/ Calculate the initialLengthCoder value by looking at all constant values and summing up\n+        \/\/ their lengths and adjusting the encoded coder bit if needed\n@@ -530,0 +516,7 @@\n+        for (int i = 0; i < paramCount; i++) {\n+            var constant = constants.get(i);\n+            if (constant != null) {\n+                initialLengthCoder = JLA.stringConcatMix(initialLengthCoder, constant);\n+            }\n+        } \/\/ deal with suffix later, if needed\n+\n@@ -533,30 +526,1 @@\n-\n-        \/\/ We need one prepender per argument, but also need to fold in constants. We do so by greedily\n-        \/\/ create prependers that fold in surrounding constants into the argument prepender. This reduces\n-        \/\/ the number of unique MH combinator tree shapes we'll create in an application.\n-        String constant = null;\n-        int pos = 0;\n-        for (String el : elements) {\n-            \/\/ Do the prepend, and put \"new\" index at index 1\n-            if (el != null) {\n-                \/\/ Constant element\n-\n-                \/\/ Eagerly update the initialLengthCoder value\n-                initialLengthCoder = JLA.stringConcatMix(initialLengthCoder, el);\n-\n-                \/\/ Save the constant and fold it either into the next\n-                \/\/ argument prepender, or into the newArray combinator\n-                assert (constant == null);\n-                constant = el;\n-            } else {\n-                \/\/ Add prepender, along with any prefix constant\n-                mh = MethodHandles.filterArgumentsWithCombiner(\n-                        mh, 1,\n-                        prepender(constant, ptypes[pos]),\n-                        1, 0, \/\/ indexCoder, storage\n-                        2 + pos  \/\/ selected argument\n-                );\n-                constant = null;\n-                pos++;\n-            }\n-        }\n+        mh = filterInPrependers(mh, constants, ptypes);\n@@ -566,2 +530,2 @@\n-        if (constant != null) {\n-            \/\/ newArray variant that deals with prepending the trailing constant\n+        if (suffix != null) {\n+            \/\/ newArray variant that deals with prepending any trailing constant\n@@ -569,7 +533,5 @@\n-            \/\/ initialLengthCoder has been adjusted to have the correct coder\n-            \/\/ and length already, but to avoid binding an extra variable to\n-            \/\/ the method handle we now adjust the length to be correct for the\n-            \/\/ first prepender above, while adjusting for the missing length of\n-            \/\/ the constant in StringConcatHelper\n-            initialLengthCoder -= constant.length();\n-            newArrayCombinator = newArrayWithSuffix(constant);\n+            \/\/ initialLengthCoder is adjusted to have the correct coder\n+            \/\/ and length: The newArrayWithSuffix method expects only the coder of the\n+            \/\/ suffix to be encoded into indexCoder\n+            initialLengthCoder = JLA.stringConcatMix(initialLengthCoder, suffix) - suffix.length();\n+            newArrayCombinator = newArrayWithSuffix(suffix);\n@@ -602,29 +564,1 @@\n-        pos = -1;\n-        MethodHandle mix = null;\n-        for (String el : elements) {\n-            \/\/ Constants already handled in the code above\n-            if (el == null) {\n-                    if (pos >= 0) {\n-                        \/\/ Compute new \"index\" in-place using old value plus the appropriate argument.\n-                        mh = MethodHandles.filterArgumentsWithCombiner(mh, 0, mix,\n-                                0, \/\/ old-index\n-                                1 + pos \/\/ selected argument\n-                        );\n-                    }\n-\n-                    Class<?> argClass = ptypes[++pos];\n-                    mix = mixer(argClass);\n-            }\n-        }\n-\n-        \/\/ Insert the initialLengthCoder value into the final mixer, then\n-        \/\/ fold that into the base method handle\n-        if (pos >= 0) {\n-            mix = MethodHandles.insertArguments(mix, 0, initialLengthCoder);\n-            mh = MethodHandles.foldArgumentsWithCombiner(mh, 0, mix,\n-                    1 + pos \/\/ selected argument\n-            );\n-        } else {\n-            \/\/ No mixer (constants only concat), insert initialLengthCoder directly\n-            mh = MethodHandles.insertArguments(mh, 0, initialLengthCoder);\n-        }\n+        mh = filterAndFoldInMixers(mh, initialLengthCoder, ptypes);\n@@ -642,3 +576,19 @@\n-    private static MethodHandle prepender(String prefix, Class<?> cl) {\n-        if (prefix == null) {\n-            return NULL_PREPENDERS.computeIfAbsent(cl, NULL_PREPEND);\n+    \/\/ We need one prepender per argument, but also need to fold in constants. We do so by greedily\n+    \/\/ creating prependers that fold in surrounding constants into the argument prepender. This reduces\n+    \/\/ the number of unique MH combinator tree shapes we'll create in an application.\n+    \/\/ Additionally we do this in chunks to reduce the number of combinators bound to the root tree,\n+    \/\/ which simplifies the shape and makes construction of similar trees use less unique LF classes\n+    private static MethodHandle filterInPrependers(MethodHandle mh, List<String> constants, Class<?>[] ptypes) {\n+        int pos;\n+        int[] argPositions = null;\n+        MethodHandle prepend;\n+        for (pos = 0; pos < ptypes.length - 3; pos += 4) {\n+            prepend = prepender(pos, constants, ptypes, 4);\n+            argPositions = filterPrependArgPositions(argPositions, pos, 4);\n+            mh = MethodHandles.filterArgumentsWithCombiner(mh, 1, prepend, argPositions);\n+        }\n+        if (pos < ptypes.length) {\n+            int count = ptypes.length - pos;\n+            prepend = prepender(pos, constants, ptypes, count);\n+            argPositions = filterPrependArgPositions(argPositions, pos, count);\n+            mh = MethodHandles.filterArgumentsWithCombiner(mh, 1, prepend, argPositions);\n@@ -646,2 +596,1 @@\n-        return MethodHandles.insertArguments(\n-                        PREPENDERS.computeIfAbsent(cl, PREPEND), 3, prefix);\n+        return mh;\n@@ -650,2 +599,11 @@\n-    private static MethodHandle mixer(Class<?> cl) {\n-        return MIXERS.computeIfAbsent(cl, MIX);\n+    static int[] filterPrependArgPositions(int[] argPositions, int pos, int count) {\n+        if (argPositions == null || argPositions.length != count + 2) {\n+            argPositions = new int[count + 2];\n+            argPositions[0] = 1; \/\/ indexCoder\n+            argPositions[1] = 0; \/\/ storage\n+        }\n+        int limit = count + 2;\n+        for (int i = 2; i < limit; i++) {\n+            argPositions[i] = i + pos;\n+        }\n+        return argPositions;\n@@ -654,5 +612,88 @@\n-    \/\/ These are deliberately not lambdas to optimize startup time:\n-    private static final Function<Class<?>, MethodHandle> PREPEND = new Function<>() {\n-        @Override\n-        public MethodHandle apply(Class<?> c) {\n-            MethodHandle prepend = JLA.stringConcatHelper(\"prepend\",\n+\n+    \/\/ We need one mixer per argument.\n+    private static MethodHandle filterAndFoldInMixers(MethodHandle mh, long initialLengthCoder, Class<?>[] ptypes) {\n+        int pos;\n+        int[] argPositions = null;\n+        for (pos = 0; pos < ptypes.length - 4; pos += 4) {\n+            \/\/ Compute new \"index\" in-place pairwise using old value plus the appropriate arguments.\n+            MethodHandle mix = mixer(ptypes[pos], ptypes[pos + 1], ptypes[pos + 2], ptypes[pos + 3]);\n+            argPositions = filterMixerArgPositions(argPositions, pos, 4);\n+            mh = MethodHandles.filterArgumentsWithCombiner(mh, 0,\n+                    mix, argPositions);\n+        }\n+\n+        if (pos < ptypes.length) {\n+            \/\/ Mix in the last 1 to 4 parameters, insert the initialLengthCoder into the final mixer and\n+            \/\/ fold the result into the main combinator\n+            mh = foldInLastMixers(mh, initialLengthCoder, pos, ptypes, ptypes.length - pos);\n+        } else if (ptypes.length == 0) {\n+            \/\/ No mixer (constants only concat), insert initialLengthCoder directly\n+            mh = MethodHandles.insertArguments(mh, 0, initialLengthCoder);\n+        }\n+        return mh;\n+    }\n+\n+    static int[] filterMixerArgPositions(int[] argPositions, int pos, int count) {\n+        if (argPositions == null || argPositions.length != count + 2) {\n+            argPositions = new int[count + 1];\n+            argPositions[0] = 0; \/\/ indexCoder\n+        }\n+        int limit = count + 1;\n+        for (int i = 1; i < limit; i++) {\n+            argPositions[i] = i + pos;\n+        }\n+        return argPositions;\n+    }\n+\n+\n+    private static MethodHandle foldInLastMixers(MethodHandle mh, long initialLengthCoder, int pos, Class<?>[] ptypes, int count) {\n+        MethodHandle mix = switch (count) {\n+            case 1 -> mixer(ptypes[pos]);\n+            case 2 -> mixer(ptypes[pos], ptypes[pos + 1]);\n+            case 3 -> mixer(ptypes[pos], ptypes[pos + 1], ptypes[pos + 2]);\n+            case 4 -> mixer(ptypes[pos], ptypes[pos + 1], ptypes[pos + 2], ptypes[pos + 3]);\n+            default -> throw new IllegalArgumentException(\"Unexpected count: \" + count);\n+        };\n+        mix = MethodHandles.insertArguments(mix,0, initialLengthCoder);\n+        if (count == 1) {\n+            return MethodHandles.foldArgumentsWithCombiner(mh, 0, mix,\n+                    1 + pos \/\/ selected arguments\n+            );\n+        } else if (count == 2) {\n+            return MethodHandles.foldArgumentsWithCombiner(mh, 0, mix,\n+                    1 + pos, 2 + pos \/\/ selected arguments\n+            );\n+        } else if (count == 3) {\n+            return MethodHandles.foldArgumentsWithCombiner(mh, 0, mix,\n+                    1 + pos, 2 + pos, 3 + pos \/\/ selected arguments\n+            );\n+        } else {\n+            return MethodHandles.foldArgumentsWithCombiner(mh, 0, mix,\n+                    1 + pos, 2 + pos, 3 + pos, 4 + pos \/\/ selected arguments\n+            );\n+        }\n+    }\n+\n+    \/\/ Simple prependers, single argument. May be used directly or as a\n+    \/\/ building block for complex prepender combinators.\n+    private static MethodHandle prepender(String prefix, Class<?> cl) {\n+        MethodHandle prepend;\n+        int idx = classIndex(cl);\n+        if (prefix == null) {\n+            prepend = NULL_PREPENDERS[idx];\n+            if (prepend == null) {\n+                NULL_PREPENDERS[idx] = prepend = MethodHandles.insertArguments(\n+                                prepender(cl), 3, (String)null);\n+            }\n+        } else {\n+            prepend = MethodHandles.insertArguments(\n+                    prepender(cl), 3, prefix);\n+        }\n+        return prepend;\n+    }\n+\n+    private static MethodHandle prepender(Class<?> cl) {\n+        int idx = classIndex(cl);\n+        MethodHandle prepend = PREPENDERS[idx];\n+        if (prepend == null) {\n+            PREPENDERS[idx] = prepend = JLA.stringConcatHelper(\"prepend\",\n@@ -660,2 +701,1 @@\n-                            Wrapper.asPrimitiveType(c), String.class));\n-            return prepend.rebind();\n+                            Wrapper.asPrimitiveType(cl), String.class)).rebind();\n@@ -663,1 +703,17 @@\n-    };\n+        return prepend;\n+    }\n+\n+    private static final int INT_IDX = 0,\n+            CHAR_IDX = 1,\n+            LONG_IDX = 2,\n+            BOOLEAN_IDX = 3,\n+            STRING_IDX = 4,\n+            TYPE_COUNT = 5;\n+    private static int classIndex(Class<?> cl) {\n+        if (cl == String.class)  return STRING_IDX;\n+        if (cl == int.class)     return INT_IDX;\n+        if (cl == boolean.class) return BOOLEAN_IDX;\n+        if (cl == char.class)    return CHAR_IDX;\n+        if (cl == long.class)    return LONG_IDX;\n+        throw new IllegalArgumentException(\"Unexpected class: \" + cl);\n+    }\n@@ -665,5 +721,56 @@\n-    private static final Function<Class<?>, MethodHandle> NULL_PREPEND = new Function<>() {\n-        @Override\n-        public MethodHandle apply(Class<?> c) {\n-            return MethodHandles.insertArguments(\n-                    PREPENDERS.computeIfAbsent(c, PREPEND), 3, (String)null);\n+    \/\/ Constant argument lists used by the prepender MH builders\n+    private static final int[] PREPEND_FILTER_FIRST_ARGS  = new int[] { 0, 1, 2 };\n+    private static final int[] PREPEND_FILTER_SECOND_ARGS = new int[] { 0, 1, 3 };\n+    private static final int[] PREPEND_FILTER_THIRD_ARGS  = new int[] { 0, 1, 4 };\n+    private static final int[] PREPEND_FILTER_FIRST_PAIR_ARGS  = new int[] { 0, 1, 2, 3 };\n+    private static final int[] PREPEND_FILTER_SECOND_PAIR_ARGS = new int[] { 0, 1, 4, 5 };\n+\n+    \/\/ Base MH for complex prepender combinators.\n+    private static final MethodHandle PREPEND_BASE = MethodHandles.dropArguments(\n+            MethodHandles.identity(long.class), 1, byte[].class);\n+\n+    private static final @Stable MethodHandle[][] DOUBLE_PREPENDERS = new MethodHandle[TYPE_COUNT][TYPE_COUNT];\n+    private static MethodHandle prepender(String prefix, Class<?> cl, String prefix2, Class<?> cl2) {\n+        int idx1 = classIndex(cl);\n+        int idx2 = classIndex(cl2);\n+        MethodHandle prepend = DOUBLE_PREPENDERS[idx1][idx2];\n+        if (prepend == null) {\n+            prepend = DOUBLE_PREPENDERS[idx1][idx2] =\n+                    MethodHandles.dropArguments(PREPEND_BASE, 2, cl, cl2);\n+        }\n+        prepend = MethodHandles.filterArgumentsWithCombiner(prepend, 0, prepender(prefix, cl),\n+                PREPEND_FILTER_FIRST_ARGS);\n+        return MethodHandles.filterArgumentsWithCombiner(prepend, 0, prepender(prefix2, cl2),\n+                PREPEND_FILTER_SECOND_ARGS);\n+    }\n+\n+    private static MethodHandle prepender(int pos, List<String> constants, Class<?>[] ptypes, int count) {\n+        \/\/ build the simple cases directly\n+        if (count == 1) {\n+            return prepender(constants.get(pos), ptypes[pos]);\n+        }\n+        if (count == 2) {\n+            return prepender(constants.get(pos), ptypes[pos], constants.get(pos + 1), ptypes[pos + 1]);\n+        }\n+        \/\/ build a tree from an unbound prepender, allowing us to bind the constants in a batch as a final step\n+        MethodHandle prepend = PREPEND_BASE;\n+        if (count == 3) {\n+            prepend = MethodHandles.dropArguments(prepend, 2,\n+                    ptypes[pos], ptypes[pos + 1], ptypes[pos + 2]);\n+            prepend = MethodHandles.filterArgumentsWithCombiner(prepend, 0,\n+                    prepender(constants.get(pos), ptypes[pos], constants.get(pos + 1), ptypes[pos + 1]),\n+                    PREPEND_FILTER_FIRST_PAIR_ARGS);\n+            return MethodHandles.filterArgumentsWithCombiner(prepend, 0,\n+                    prepender(constants.get(pos + 2), ptypes[pos + 2]),\n+                    PREPEND_FILTER_THIRD_ARGS);\n+        } else if (count == 4) {\n+            prepend = MethodHandles.dropArguments(prepend, 2,\n+                    ptypes[pos], ptypes[pos + 1], ptypes[pos + 2], ptypes[pos + 3]);\n+            prepend = MethodHandles.filterArgumentsWithCombiner(prepend, 0,\n+                    prepender(constants.get(pos), ptypes[pos], constants.get(pos + 1), ptypes[pos + 1]),\n+                    PREPEND_FILTER_FIRST_PAIR_ARGS);\n+            return MethodHandles.filterArgumentsWithCombiner(prepend, 0,\n+                    prepender(constants.get(pos + 2), ptypes[pos + 2], constants.get(pos + 3), ptypes[pos + 3]),\n+                    PREPEND_FILTER_SECOND_PAIR_ARGS);\n+        } else {\n+            throw new IllegalArgumentException(\"Unexpected count: \" + count);\n@@ -671,1 +778,1 @@\n-    };\n+    }\n@@ -673,6 +780,10 @@\n-    private static final Function<Class<?>, MethodHandle> MIX = new Function<>() {\n-        @Override\n-        public MethodHandle apply(Class<?> c) {\n-            MethodHandle mix = JLA.stringConcatHelper(\"mix\",\n-                    methodType(long.class, long.class, Wrapper.asPrimitiveType(c)));\n-            return mix.rebind();\n+    \/\/ Constant argument lists used by the mixer MH builders\n+    private static final int[] MIX_FILTER_SECOND_ARGS = new int[] { 0, 2 };\n+    private static final int[] MIX_FILTER_THIRD_ARGS  = new int[] { 0, 3 };\n+    private static final int[] MIX_FILTER_SECOND_PAIR_ARGS = new int[] { 0, 3, 4 };\n+    private static MethodHandle mixer(Class<?> cl) {\n+        int index = classIndex(cl);\n+        MethodHandle mix = MIXERS[index];\n+        if (mix == null) {\n+            MIXERS[index] = mix = JLA.stringConcatHelper(\"mix\",\n+                    methodType(long.class, long.class, Wrapper.asPrimitiveType(cl))).rebind();\n@@ -680,1 +791,30 @@\n-    };\n+        return mix;\n+    }\n+\n+    private static final @Stable MethodHandle[][] DOUBLE_MIXERS = new MethodHandle[TYPE_COUNT][TYPE_COUNT];\n+    private static MethodHandle mixer(Class<?> cl, Class<?> cl2) {\n+        int idx1 = classIndex(cl);\n+        int idx2 = classIndex(cl2);\n+        MethodHandle mix = DOUBLE_MIXERS[idx1][idx2];\n+        if (mix == null) {\n+            mix = mixer(cl);\n+            mix = MethodHandles.dropArguments(mix, 2, cl2);\n+            DOUBLE_MIXERS[idx1][idx2] = mix = MethodHandles.filterArgumentsWithCombiner(mix, 0,\n+                    mixer(cl2), MIX_FILTER_SECOND_ARGS);\n+        }\n+        return mix;\n+    }\n+\n+    private static MethodHandle mixer(Class<?> cl, Class<?> cl2, Class<?> cl3) {\n+        MethodHandle mix = mixer(cl, cl2);\n+        mix = MethodHandles.dropArguments(mix, 3, cl3);\n+        return MethodHandles.filterArgumentsWithCombiner(mix, 0,\n+                mixer(cl3), MIX_FILTER_THIRD_ARGS);\n+    }\n+\n+    private static MethodHandle mixer(Class<?> cl, Class<?> cl2, Class<?> cl3, Class<?> cl4) {\n+        MethodHandle mix = mixer(cl, cl2);\n+        mix = MethodHandles.dropArguments(mix, 3, cl3, cl4);\n+        return MethodHandles.filterArgumentsWithCombiner(mix, 0,\n+                mixer(cl3, cl4), MIX_FILTER_SECOND_PAIR_ARGS);\n+    }\n@@ -828,11 +968,4 @@\n-    private static final ConcurrentMap<Class<?>, MethodHandle> PREPENDERS;\n-    private static final ConcurrentMap<Class<?>, MethodHandle> NULL_PREPENDERS;\n-    private static final ConcurrentMap<Class<?>, MethodHandle> MIXERS;\n-    private static final long INITIAL_CODER;\n-\n-    static {\n-        INITIAL_CODER = JLA.stringConcatInitialCoder();\n-        PREPENDERS = new ConcurrentHashMap<>();\n-        NULL_PREPENDERS = new ConcurrentHashMap<>();\n-        MIXERS = new ConcurrentHashMap<>();\n-    }\n+    private static final @Stable MethodHandle[] NULL_PREPENDERS = new MethodHandle[TYPE_COUNT];\n+    private static final @Stable MethodHandle[] PREPENDERS      = new MethodHandle[TYPE_COUNT];\n+    private static final @Stable MethodHandle[] MIXERS          = new MethodHandle[TYPE_COUNT];\n+    private static final long INITIAL_CODER = JLA.stringConcatInitialCoder();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/StringConcatFactory.java","additions":286,"deletions":153,"binary":false,"changes":439,"status":"modified"}]}