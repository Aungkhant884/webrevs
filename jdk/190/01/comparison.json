{"files":[{"patch":"@@ -99,0 +99,3 @@\n+  JvmtiThreadState *state = JvmtiThreadState::state_for(JavaThread::current());\n+  GrowableArray<Klass*>* redef_classes = state->get_classes_being_redefined();\n+\n@@ -100,0 +103,6 @@\n+\n+  if (redef_classes == NULL) {\n+    redef_classes = new(ResourceObj::C_HEAP, mtClass) GrowableArray<Klass*>(1, mtClass);\n+    state->set_classes_being_redefined(redef_classes);\n+  }\n+\n@@ -103,1 +112,4 @@\n-    \/\/ Go through classes each time until none are being redefined.\n+    \/\/ Go through classes each time until none are being redefined. Skip\n+    \/\/ the ones that are being redefined by this thread currently. Class file\n+    \/\/ load hook event may trigger new class redefine when we are redefining\n+    \/\/ a class (after lock_classes()).\n@@ -105,4 +117,10 @@\n-      if (get_ik(_class_defs[i].klass)->is_being_redefined()) {\n-        ml.wait();\n-        has_redefined = true;\n-        break;  \/\/ for loop\n+      InstanceKlass* ik = get_ik(_class_defs[i].klass);\n+      \/\/ Check if we are currently redefining the class in this thread already.\n+      if (redef_classes->contains(ik)) {\n+        assert(ik->is_being_redefined(), \"sanity\");\n+      } else {\n+        if (ik->is_being_redefined()) {\n+          ml.wait();\n+          has_redefined = true;\n+          break;  \/\/ for loop\n+        }\n@@ -112,0 +130,1 @@\n+\n@@ -113,1 +132,3 @@\n-    get_ik(_class_defs[i].klass)->set_is_being_redefined(true);\n+    InstanceKlass* ik = get_ik(_class_defs[i].klass);\n+    redef_classes->push(ik); \/\/ Add to the _classes_being_redefined list\n+    ik->set_is_being_redefined(true);\n@@ -119,0 +140,4 @@\n+  JvmtiThreadState *state = JvmtiThreadState::state_for(JavaThread::current());\n+  GrowableArray<Klass*>* redef_classes = state->get_classes_being_redefined();\n+  assert(redef_classes != NULL, \"_classes_being_redefined is not allocated\");\n+\n@@ -120,2 +145,9 @@\n-  for (int i = 0; i < _class_count; i++) {\n-    assert(get_ik(_class_defs[i].klass)->is_being_redefined(),\n+\n+  for (int i = _class_count - 1; i >= 0; i--) {\n+    InstanceKlass* def_ik = get_ik(_class_defs[i].klass);\n+    if (redef_classes->length() > 0) {\n+      \/\/ Remove the class from _classes_being_redefined list\n+      Klass* k = redef_classes->pop();\n+      assert(def_ik == k, \"unlocking wrong class\");\n+    }\n+    assert(def_ik->is_being_redefined(),\n@@ -123,1 +155,7 @@\n-    get_ik(_class_defs[i].klass)->set_is_being_redefined(false);\n+\n+    \/\/ Unlock after we finish all redefines for this class within\n+    \/\/ the thread. Same class can be pushed to the list multiple\n+    \/\/ times (not more than once by each recursive redefinition).\n+    if (!redef_classes->contains(def_ik)) {\n+      def_ik->set_is_being_redefined(false);\n+    }\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":47,"deletions":9,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+  _classes_being_redefined = NULL;\n@@ -109,0 +110,4 @@\n+  if (_classes_being_redefined != NULL) {\n+    delete _classes_being_redefined; \/\/ free the GrowableArray on C heap\n+  }\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiThreadState.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -102,0 +102,1 @@\n+  GrowableArray<Klass*>* _classes_being_redefined;\n@@ -247,0 +248,9 @@\n+  \/\/ Get the classes that are currently being redefined by this thread.\n+  inline GrowableArray<Klass*>* get_classes_being_redefined() {\n+    return _classes_being_redefined;\n+  }\n+\n+  inline void set_classes_being_redefined(GrowableArray<Klass*>* redef_classes) {\n+    _classes_being_redefined = redef_classes;\n+  }\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiThreadState.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,117 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8241390\n+ * @summary Test recursively redefines the same class. The test hangs if\n+ * a deadlock happens.\n+ * @requires vm.jvmti\n+ * @library \/test\/lib\n+ * @modules java.instrument\n+ * @compile TransformerDeadlockTest.java\n+ * @run driver TransformerDeadlockTest\n+ *\/\n+\n+import jdk.test.lib.process.ProcessTools;\n+\n+import java.lang.instrument.ClassFileTransformer;\n+import java.lang.instrument.IllegalClassFormatException;\n+import java.lang.instrument.Instrumentation;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.security.ProtectionDomain;\n+\n+\n+public class TransformerDeadlockTest {\n+\n+    private static String manifest = \"Premain-Class: \" +\n+                    TransformerDeadlockTest.Agent.class.getName() + \"\\n\"\n+                    + \"Can-Retransform-Classes: true\\n\"\n+                    + \"Can-Retransform-Classes: true\\n\";\n+\n+    private static String CP = System.getProperty(\"test.classes\");\n+\n+    public static void main(String args[]) throws Throwable {\n+        String agentJar = buildAgent();\n+        ProcessTools.executeProcess(\n+                ProcessTools.createJavaProcessBuilder(\n+                        \"-javaagent:\" + agentJar,\n+                        TransformerDeadlockTest.Agent.class.getName())\n+        ).shouldHaveExitValue(0);\n+    }\n+\n+    private static String buildAgent() throws Exception {\n+        Path jar = Files.createTempFile(Paths.get(\".\"), null, \".jar\");\n+        String jarPath = jar.toAbsolutePath().toString();\n+        ClassFileInstaller.writeJar(jarPath,\n+                ClassFileInstaller.Manifest.fromString(manifest),\n+                TransformerDeadlockTest.class.getName());\n+        return jarPath;\n+    }\n+\n+    public static class Agent implements ClassFileTransformer {\n+        private static Instrumentation instrumentation;\n+\n+        public static void premain(String agentArgs, Instrumentation inst) {\n+            instrumentation = inst;\n+        }\n+\n+        @Override\n+        public byte[] transform(\n+                ClassLoader loader,\n+                String className,\n+                Class<?> classBeingRedefined,\n+                ProtectionDomain protectionDomain,\n+                byte[] classfileBuffer)\n+                throws IllegalClassFormatException {\n+\n+            if (!TransformerDeadlockTest.class.getName().replace(\".\", \"\/\").equals(className)) {\n+                return null;\n+            }\n+            invokeRetransform();\n+            return classfileBuffer;\n+\n+        }\n+\n+        public static void main(String[] args) throws Exception {\n+            instrumentation.addTransformer(new TransformerDeadlockTest.Agent(), true);\n+\n+            try {\n+                instrumentation.retransformClasses(TransformerDeadlockTest.class);\n+            } catch (Exception e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        private static void invokeRetransform() {\n+            try {\n+                instrumentation.retransformClasses(TransformerDeadlockTest.class);\n+            } catch (Exception e) {\n+                throw new RuntimeException(e);\n+            } finally {\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/RedefineClasses\/TransformerDeadlockTest.java","additions":117,"deletions":0,"binary":false,"changes":117,"status":"added"}]}