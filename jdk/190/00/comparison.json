{"files":[{"patch":"@@ -99,0 +99,3 @@\n+  JvmtiThreadState *state = JvmtiThreadState::state_for(JavaThread::current());\n+  GrowableArray<Klass*>* cls = state->get_classes_being_redefined();\n+\n@@ -100,0 +103,6 @@\n+\n+  if (cls == NULL) {\n+    cls = new(ResourceObj::C_HEAP, mtClass) GrowableArray<Klass*>(1, mtClass);\n+    state->set_classes_being_redefined(cls);\n+  }\n+\n@@ -103,1 +112,4 @@\n-    \/\/ Go through classes each time until none are being redefined.\n+    \/\/ Go through classes each time until none are being redefined. Skip\n+    \/\/ the ones that are being redefined by this thread currently. Class file\n+    \/\/ load hook event may trigger new class redefine when we are redefining\n+    \/\/ a class (after lock_classes()).\n@@ -105,4 +117,10 @@\n-      if (get_ik(_class_defs[i].klass)->is_being_redefined()) {\n-        ml.wait();\n-        has_redefined = true;\n-        break;  \/\/ for loop\n+      InstanceKlass* ik = get_ik(_class_defs[i].klass);\n+      \/\/ Check if we are currently redefining the class in this thread already.\n+      if (cls->contains(ik)) {\n+        assert(ik->is_being_redefined(), \"sanity\");\n+      } else {\n+        if (ik->is_being_redefined()) {\n+          ml.wait();\n+          has_redefined = true;\n+          break;  \/\/ for loop\n+        }\n@@ -112,0 +130,1 @@\n+\n@@ -113,1 +132,3 @@\n-    get_ik(_class_defs[i].klass)->set_is_being_redefined(true);\n+    InstanceKlass* ik = get_ik(_class_defs[i].klass);\n+    cls->push(ik); \/\/ Add to the _classes_being_redefined list\n+    ik->set_is_being_redefined(true);\n@@ -119,0 +140,4 @@\n+  JvmtiThreadState *state = JvmtiThreadState::state_for(JavaThread::current());\n+  GrowableArray<Klass*>* cls = state->get_classes_being_redefined();\n+  assert(cls != NULL, \"_classes_being_redefined is not allocated\");\n+\n@@ -120,2 +145,9 @@\n-  for (int i = 0; i < _class_count; i++) {\n-    assert(get_ik(_class_defs[i].klass)->is_being_redefined(),\n+\n+  for (int i = _class_count - 1; i >= 0; i--) {\n+    InstanceKlass* def_ik = get_ik(_class_defs[i].klass);\n+    if (cls->length() > 0) {\n+      \/\/ Remove the class from _classes_being_redefined list\n+      Klass* k = cls->pop();\n+      assert(def_ik == k, \"unlocking wrong class\");\n+    }\n+    assert(def_ik->is_being_redefined(),\n@@ -123,1 +155,5 @@\n-    get_ik(_class_defs[i].klass)->set_is_being_redefined(false);\n+\n+    \/\/ Unlock after we finish all redefines for this class within the thread.\n+    if (!cls->contains(def_ik)) {\n+      def_ik->set_is_being_redefined(false);\n+    }\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":45,"deletions":9,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+  _classes_being_redefined = NULL;\n@@ -109,0 +110,4 @@\n+  if (_classes_being_redefined != NULL) {\n+    delete _classes_being_redefined; \/\/ free the GrowableArray on C heap\n+  }\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiThreadState.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -102,0 +102,1 @@\n+  GrowableArray<Klass*>* _classes_being_redefined;\n@@ -247,0 +248,9 @@\n+  \/\/ Get the classes that are currently being redefined by this thread.\n+  inline GrowableArray<Klass*>* get_classes_being_redefined() {\n+    return _classes_being_redefined;\n+  }\n+\n+  inline void set_classes_being_redefined(GrowableArray<Klass*>* cls) {\n+    _classes_being_redefined = cls;\n+  }\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiThreadState.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,58 @@\n+#!\/bin\/sh\n+\n+#\n+# Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+if [ \"${TESTSRC}\" = \"\" ]\n+then\n+  echo \"TESTSRC not set.  Test cannot execute.  Failed.\"\n+  exit 1\n+fi\n+echo \"TESTSRC=${TESTSRC}\"\n+\n+if [ \"${TESTJAVA}\" = \"\" ]\n+then\n+  echo \"TESTJAVA not set.  Test cannot execute.  Failed.\"\n+  exit 1\n+fi\n+echo \"TESTJAVA=${TESTJAVA}\"\n+\n+if [ \"${COMPILEJAVA}\" = \"\" ]\n+then\n+  COMPILEJAVA=\"${TESTJAVA}\"\n+fi\n+echo \"COMPILEJAVA=${COMPILEJAVA}\"\n+\n+if [ \"${TESTCLASSES}\" = \"\" ]\n+then\n+  echo \"TESTCLASSES not set.  Test cannot execute.  Failed.\"\n+  exit 1\n+fi\n+\n+JAVAC=\"${COMPILEJAVA}\/bin\/javac -g\"\n+JAR=\"${COMPILEJAVA}\/bin\/jar\"\n+\n+cp ${TESTSRC}\/$2.java $2.java\n+${JAVAC} ${TESTJAVACOPTS} ${TESTTOOLVMOPTS} $2.java\n+${JAR} ${TESTTOOLVMOPTS} cvfm $1.jar ${TESTSRC}\/$1.mf $2.class\n+rm -f $2.class $2.java\n","filename":"test\/jdk\/java\/lang\/instrument\/MakeAgentJAR.sh","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.instrument.ClassFileTransformer;\n+import java.lang.instrument.IllegalClassFormatException;\n+import java.lang.instrument.Instrumentation;\n+import java.security.ProtectionDomain;\n+\n+\/**\n+ * @test\n+ * @bug 8241390\n+ * @summary Test recursively redefines the same class. The test hangs if\n+ * a deadlock happens.\n+ * @run build TransformerDeadlockTest\n+ * @run shell MakeAgentJAR.sh TransformerDeadlockTest TransformerDeadlockTest\n+ * @run main\/othervm\/native -javaagent:TransformerDeadlockTest.jar TransformerDeadlockTest\n+ *\/\n+public class TransformerDeadlockTest implements ClassFileTransformer {\n+    private static Instrumentation instrumentation;\n+\n+    public static void premain(String agentArgs, Instrumentation inst) {\n+        instrumentation = inst;\n+    }\n+\n+    @Override\n+    public byte[] transform(\n+            ClassLoader loader,\n+            String className,\n+            Class<?> classBeingRedefined,\n+            ProtectionDomain protectionDomain,\n+            byte[] classfileBuffer)\n+            throws IllegalClassFormatException {\n+\n+        if (!TransformerDeadlockTest.class.getName().replace(\".\", \"\/\").equals(className)) {\n+            return null;\n+        }\n+        invokeRetransform();\n+        return classfileBuffer;\n+\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        instrumentation.addTransformer(new TransformerDeadlockTest(), true);\n+\n+        try {\n+            instrumentation.retransformClasses(TransformerDeadlockTest.class);\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static void invokeRetransform() {\n+        try {\n+            instrumentation.retransformClasses(TransformerDeadlockTest.class);\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/instrument\/TransformerDeadlockTest.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -0,0 +1,4 @@\n+Manifest-Version: 1.0\n+Premain-Class: TransformerDeadlockTest\n+Can-Redefine-Classes: true\n+Can-Retransform-Classes: true\n","filename":"test\/jdk\/java\/lang\/instrument\/TransformerDeadlockTest.mf","additions":4,"deletions":0,"binary":false,"changes":4,"status":"added"}]}