{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,0 @@\n-import java.awt.Color;\n-import java.awt.GraphicsEnvironment;\n@@ -31,0 +29,1 @@\n+import java.awt.GraphicsEnvironment;\n@@ -35,1 +34,0 @@\n-import java.util.concurrent.ConcurrentHashMap;\n@@ -37,0 +35,3 @@\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import sun.java2d.InvalidPipeException;\n@@ -39,1 +40,0 @@\n-import sun.java2d.loops.CompositeType;\n@@ -82,1 +82,1 @@\n-                throw new IllegalArgumentException(\"Invalid Image variant\");\n+                throw new InvalidPipeException(\"Invalid Image variant\");\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/image\/SurfaceManager.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -28,7 +28,0 @@\n-import java.awt.Graphics;\n-import java.awt.Graphics2D;\n-import java.awt.RenderingHints;\n-import java.awt.RenderingHints.Key;\n-import java.awt.geom.Area;\n-import java.awt.geom.AffineTransform;\n-import java.awt.geom.NoninvertibleTransformException;\n@@ -37,10 +30,0 @@\n-import java.awt.image.BufferedImage;\n-import java.awt.image.BufferedImageOp;\n-import java.awt.image.RenderedImage;\n-import java.awt.image.renderable.RenderableImage;\n-import java.awt.image.renderable.RenderContext;\n-import java.awt.image.AffineTransformOp;\n-import java.awt.image.Raster;\n-import java.awt.image.WritableRaster;\n-import java.awt.Image;\n-import java.awt.Composite;\n@@ -48,3 +31,3 @@\n-import java.awt.image.ColorModel;\n-import java.awt.GraphicsConfiguration;\n-import java.awt.Paint;\n+import java.awt.Composite;\n+import java.awt.Font;\n+import java.awt.FontMetrics;\n@@ -52,0 +35,4 @@\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.GraphicsConfiguration;\n+import java.awt.Image;\n@@ -53,0 +40,1 @@\n+import java.awt.Paint;\n@@ -54,4 +42,3 @@\n-import java.awt.TexturePaint;\n-import java.awt.geom.Rectangle2D;\n-import java.awt.geom.PathIterator;\n-import java.awt.geom.GeneralPath;\n+import java.awt.Rectangle;\n+import java.awt.RenderingHints;\n+import java.awt.RenderingHints.Key;\n@@ -60,5 +47,1 @@\n-import java.awt.FontMetrics;\n-import java.awt.Rectangle;\n-import java.text.AttributedCharacterIterator;\n-import java.awt.Font;\n-import java.awt.image.ImageObserver;\n+import java.awt.TexturePaint;\n@@ -66,0 +49,1 @@\n+import java.awt.font.FontRenderContext;\n@@ -68,0 +52,22 @@\n+import java.awt.geom.AffineTransform;\n+import java.awt.geom.Area;\n+import java.awt.geom.GeneralPath;\n+import java.awt.geom.NoninvertibleTransformException;\n+import java.awt.geom.PathIterator;\n+import java.awt.geom.Rectangle2D;\n+import java.awt.image.AffineTransformOp;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.BufferedImageOp;\n+import java.awt.image.ColorModel;\n+import java.awt.image.ImageObserver;\n+import java.awt.image.MultiResolutionImage;\n+import java.awt.image.Raster;\n+import java.awt.image.RenderedImage;\n+import java.awt.image.VolatileImage;\n+import java.awt.image.WritableRaster;\n+import java.awt.image.renderable.RenderContext;\n+import java.awt.image.renderable.RenderableImage;\n+import java.lang.annotation.Native;\n+import java.text.AttributedCharacterIterator;\n+import java.util.Iterator;\n+import java.util.Map;\n@@ -69,0 +75,3 @@\n+import sun.awt.ConstrainableGraphics;\n+import sun.awt.SunHints;\n+import sun.awt.image.MultiResolutionToolkitImage;\n@@ -70,0 +79,2 @@\n+import sun.awt.image.ToolkitImage;\n+import sun.awt.util.PerformanceLogger;\n@@ -72,0 +83,9 @@\n+import sun.java2d.loops.Blit;\n+import sun.java2d.loops.CompositeType;\n+import sun.java2d.loops.FontInfo;\n+import sun.java2d.loops.MaskFill;\n+import sun.java2d.loops.RenderLoops;\n+import sun.java2d.loops.SurfaceType;\n+import sun.java2d.loops.XORComposite;\n+import sun.java2d.pipe.DrawImagePipe;\n+import sun.java2d.pipe.LoopPipe;\n@@ -74,0 +94,1 @@\n+import sun.java2d.pipe.Region;\n@@ -75,1 +96,0 @@\n-import sun.java2d.pipe.ValidatePipe;\n@@ -77,1 +97,0 @@\n-import sun.java2d.pipe.Region;\n@@ -79,18 +98,1 @@\n-import sun.java2d.pipe.DrawImagePipe;\n-import sun.java2d.pipe.LoopPipe;\n-import sun.java2d.loops.FontInfo;\n-import sun.java2d.loops.RenderLoops;\n-import sun.java2d.loops.CompositeType;\n-import sun.java2d.loops.SurfaceType;\n-import sun.java2d.loops.Blit;\n-import sun.java2d.loops.MaskFill;\n-import java.awt.font.FontRenderContext;\n-import sun.java2d.loops.XORComposite;\n-import sun.awt.ConstrainableGraphics;\n-import sun.awt.SunHints;\n-import sun.awt.util.PerformanceLogger;\n-import java.util.Map;\n-import java.util.Iterator;\n-\n-import java.lang.annotation.Native;\n-import java.awt.image.MultiResolutionImage;\n+import sun.java2d.pipe.ValidatePipe;\n@@ -101,3 +103,0 @@\n-import java.awt.image.VolatileImage;\n-import sun.awt.image.MultiResolutionToolkitImage;\n-import sun.awt.image.ToolkitImage;\n@@ -3105,54 +3104,8 @@\n-\n-        if (img instanceof VolatileImage) {\n-            final SurfaceData sd = SurfaceManager.getManager(img)\n-                    .getPrimarySurfaceData();\n-            final double scaleX = sd.getDefaultScaleX();\n-            final double scaleY = sd.getDefaultScaleY();\n-            if (scaleX == 1 && scaleY == 1) {\n-                return null;\n-            }\n-            sx1 = Region.clipRound(sx1 * scaleX);\n-            sx2 = Region.clipRound(sx2 * scaleX);\n-            sy1 = Region.clipRound(sy1 * scaleY);\n-            sy2 = Region.clipRound(sy2 * scaleY);\n-\n-            AffineTransform tx = null;\n-            if (xform != null) {\n-                tx = new AffineTransform(transform);\n-                transform(xform);\n-            }\n-            boolean result = scaleImage(img, dx1, dy1, dx2, dy2,\n-                                        sx1, sy1, sx2, sy2,\n-                                        bgcolor, observer);\n-            if (tx != null) {\n-                transform.setTransform(tx);\n-                invalidateTransform();\n-            }\n-            return result;\n-        } else if (img instanceof MultiResolutionImage) {\n-            \/\/ get scaled destination image size\n-\n-            int width = img.getWidth(observer);\n-            int height = img.getHeight(observer);\n-\n-            MultiResolutionImage mrImage = (MultiResolutionImage) img;\n-            Image resolutionVariant = getResolutionVariant(mrImage, width, height,\n-                                                           dx1, dy1, dx2, dy2,\n-                                                           sx1, sy1, sx2, sy2,\n-                                                           xform);\n-\n-            if (resolutionVariant != img && resolutionVariant != null) {\n-                \/\/ recalculate source region for the resolution variant\n-\n-                ImageObserver rvObserver = MultiResolutionToolkitImage.\n-                        getResolutionVariantObserver(img, observer,\n-                                width, height, -1, -1);\n-\n-                int rvWidth = resolutionVariant.getWidth(rvObserver);\n-                int rvHeight = resolutionVariant.getHeight(rvObserver);\n-\n-                if (rvWidth < 0 || rvHeight < 0) {\n-                    \/\/ The resolution variant is not loaded yet, try to use default resolution\n-                    resolutionVariant = mrImage.getResolutionVariant(width, height);\n-                    rvWidth = resolutionVariant.getWidth(rvObserver);\n-                    rvHeight = resolutionVariant.getHeight(rvObserver);\n+        try {\n+            if (img instanceof VolatileImage) {\n+                final SurfaceData sd = SurfaceManager.getManager(img)\n+                        .getPrimarySurfaceData();\n+                final double scaleX = sd.getDefaultScaleX();\n+                final double scaleY = sd.getDefaultScaleY();\n+                if (scaleX == 1 && scaleY == 1) {\n+                    return null;\n@@ -3160,12 +3113,45 @@\n-\n-                if (0 < width && 0 < height && 0 < rvWidth && 0 < rvHeight) {\n-\n-                    double widthScale = ((double) rvWidth) \/ width;\n-                    double heightScale = ((double) rvHeight) \/ height;\n-\n-                    if (resolutionVariant instanceof VolatileImage) {\n-                        SurfaceData sd = SurfaceManager\n-                                .getManager(resolutionVariant)\n-                                .getPrimarySurfaceData();\n-                        widthScale *= sd.getDefaultScaleX();\n-                        heightScale *= sd.getDefaultScaleY();\n+                sx1 = Region.clipRound(sx1 * scaleX);\n+                sx2 = Region.clipRound(sx2 * scaleX);\n+                sy1 = Region.clipRound(sy1 * scaleY);\n+                sy2 = Region.clipRound(sy2 * scaleY);\n+\n+                AffineTransform tx = null;\n+                if (xform != null) {\n+                    tx = new AffineTransform(transform);\n+                    transform(xform);\n+                }\n+                boolean result = scaleImage(img, dx1, dy1, dx2, dy2,\n+                                            sx1, sy1, sx2, sy2,\n+                                            bgcolor, observer);\n+                if (tx != null) {\n+                    transform.setTransform(tx);\n+                    invalidateTransform();\n+                }\n+                return result;\n+            } else if (img instanceof MultiResolutionImage) {\n+                \/\/ get scaled destination image size\n+\n+                int width = img.getWidth(observer);\n+                int height = img.getHeight(observer);\n+\n+                MultiResolutionImage mrImage = (MultiResolutionImage) img;\n+                Image resolutionVariant = getResolutionVariant(mrImage, width, height,\n+                                                               dx1, dy1, dx2, dy2,\n+                                                               sx1, sy1, sx2, sy2,\n+                                                               xform);\n+\n+                if (resolutionVariant != img && resolutionVariant != null) {\n+                    \/\/ recalculate source region for the resolution variant\n+\n+                    ImageObserver rvObserver = MultiResolutionToolkitImage.\n+                            getResolutionVariantObserver(img, observer,\n+                                    width, height, -1, -1);\n+\n+                    int rvWidth = resolutionVariant.getWidth(rvObserver);\n+                    int rvHeight = resolutionVariant.getHeight(rvObserver);\n+\n+                    if (rvWidth < 0 || rvHeight < 0) {\n+                        \/\/ The resolution variant is not loaded yet, try to use default resolution\n+                        resolutionVariant = mrImage.getResolutionVariant(width, height);\n+                        rvWidth = resolutionVariant.getWidth(rvObserver);\n+                        rvHeight = resolutionVariant.getHeight(rvObserver);\n@@ -3174,15 +3160,35 @@\n-                    sx1 = Region.clipScale(sx1, widthScale);\n-                    sy1 = Region.clipScale(sy1, heightScale);\n-                    sx2 = Region.clipScale(sx2, widthScale);\n-                    sy2 = Region.clipScale(sy2, heightScale);\n-\n-                    observer = rvObserver;\n-                    img = resolutionVariant;\n-\n-                    if (xform != null) {\n-                        assert dx1 == 0 && dy1 == 0;\n-                        assert dx2 == img.getWidth(observer);\n-                        assert dy2 == img.getHeight(observer);\n-                        AffineTransform renderTX = new AffineTransform(xform);\n-                        renderTX.scale(1 \/ widthScale, 1 \/ heightScale);\n-                        return transformImage(img, renderTX, observer);\n+                    if (0 < width && 0 < height && 0 < rvWidth && 0 < rvHeight) {\n+\n+                        double widthScale = ((double) rvWidth) \/ width;\n+                        double heightScale = ((double) rvHeight) \/ height;\n+\n+                        if (resolutionVariant instanceof VolatileImage) {\n+                            SurfaceData sd = SurfaceManager\n+                                    .getManager(resolutionVariant)\n+                                    .getPrimarySurfaceData();\n+                            widthScale *= sd.getDefaultScaleX();\n+                            heightScale *= sd.getDefaultScaleY();\n+                        }\n+\n+                        sx1 = Region.clipScale(sx1, widthScale);\n+                        sy1 = Region.clipScale(sy1, heightScale);\n+                        sx2 = Region.clipScale(sx2, widthScale);\n+                        sy2 = Region.clipScale(sy2, heightScale);\n+\n+                        observer = rvObserver;\n+                        img = resolutionVariant;\n+\n+                        if (xform != null) {\n+                            assert dx1 == 0 && dy1 == 0;\n+                            assert dx2 == img.getWidth(observer);\n+                            assert dy2 == img.getHeight(observer);\n+                            AffineTransform renderTX = new AffineTransform(xform);\n+                            renderTX.scale(1 \/ widthScale, 1 \/ heightScale);\n+                            return transformImage(img, renderTX, observer);\n+                        }\n+\n+                        return scaleImage(img, dx1, dy1, dx2, dy2,\n+                                          sx1, sy1, sx2, sy2,\n+                                          bgcolor, observer);\n+                    } else {\n+                        return false; \/\/ Image variant is not initialized yet\n@@ -3190,6 +3196,0 @@\n-\n-                    return scaleImage(img, dx1, dy1, dx2, dy2,\n-                                      sx1, sy1, sx2, sy2,\n-                                      bgcolor, observer);\n-                } else {\n-                    return false; \/\/ Image variant is not initialized yet\n@@ -3198,0 +3198,2 @@\n+        } catch (InvalidPipeException e) {\n+            return false;\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/SunGraphics2D.java","additions":141,"deletions":139,"binary":false,"changes":280,"status":"modified"},{"patch":"@@ -0,0 +1,166 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.GraphicsConfiguration;\n+import java.awt.Image;\n+import java.awt.ImageCapabilities;\n+import java.awt.geom.AffineTransform;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.ImageObserver;\n+import java.awt.image.ImageProducer;\n+import java.awt.image.VolatileImage;\n+\n+import static java.awt.image.BufferedImage.TYPE_INT_ARGB_PRE;\n+\n+\/**\n+ * @test\n+ * @bug 7183828\n+ * @summary Tests that no exceptions are thrown when we draw the custom image\n+ *\/\n+public final class CustomImage extends Image {\n+\n+    public static void main(String[] args) {\n+        Image ci = new CustomImage();\n+        VolatileImage cvi = new CustomVolatileImage();\n+\n+        BufferedImage bi = generateImage();\n+        Graphics2D g2d = bi.createGraphics();\n+        \/\/ Custom Image\n+        test(g2d.drawImage(ci, 0, 0, null), bi);\n+        test(g2d.drawImage(ci, 0, 0, 5, 5, 0, 0, 5, 5, Color.BLUE, null), bi);\n+        test(g2d.drawImage(ci, 0, 0, 9, 9, Color.BLUE, null), bi);\n+        test(g2d.drawImage(ci, 0, 0, 5, 5, 0, 0, 9, 9, Color.BLUE, null), bi);\n+        test(g2d.drawImage(ci, AffineTransform.getRotateInstance(30), null), bi);\n+        \/\/ Custom VolatileImage\n+        test(g2d.drawImage(cvi, 0, 0, null), bi);\n+        test(g2d.drawImage(cvi, 0, 0, 5, 5, 0, 0, 5, 5, Color.BLUE, null), bi);\n+        test(g2d.drawImage(cvi, 0, 0, 9, 9, Color.BLUE, null), bi);\n+        test(g2d.drawImage(cvi, 0, 0, 5, 5, 0, 0, 9, 9, Color.BLUE, null), bi);\n+        test(g2d.drawImage(cvi, AffineTransform.getRotateInstance(30), null), bi);\n+\n+        g2d.dispose();\n+    }\n+\n+    private static BufferedImage generateImage() {\n+        BufferedImage bi = new BufferedImage(100, 100, TYPE_INT_ARGB_PRE);\n+        Graphics g = bi.createGraphics();\n+        g.setColor(Color.GREEN);\n+        g.fillRect(0, 0, 100, 100);\n+        g.dispose();\n+        return bi;\n+    }\n+\n+    private static void test(boolean complete, BufferedImage bi) {\n+        if (complete) {\n+            throw new RuntimeException(\"Custom image successfully drawn\");\n+        }\n+        for (int y = 0; y < bi.getHeight(); ++y) {\n+            for (int x = 0; x < bi.getWidth(); ++x) {\n+                if (bi.getRGB(x, y) != Color.GREEN.getRGB()) {\n+                    throw new RuntimeException(\"The image was changed\");\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public int getWidth(ImageObserver observer) {\n+        return 100;\n+    }\n+\n+    @Override\n+    public int getHeight(ImageObserver observer) {\n+        return 100;\n+    }\n+\n+    @Override\n+    public ImageProducer getSource() {\n+        return null;\n+    }\n+\n+    @Override\n+    public Graphics getGraphics() {\n+        return null;\n+    }\n+\n+    @Override\n+    public Object getProperty(String name, ImageObserver observer) {\n+        return null;\n+    }\n+\n+    private static final class CustomVolatileImage extends VolatileImage {\n+\n+        @Override\n+        public BufferedImage getSnapshot() {\n+            return null;\n+        }\n+\n+        @Override\n+        public int getWidth() {\n+            return 100;\n+        }\n+\n+        @Override\n+        public int getHeight() {\n+            return 100;\n+        }\n+\n+        @Override\n+        public Graphics2D createGraphics() {\n+            return null;\n+        }\n+\n+        @Override\n+        public int validate(GraphicsConfiguration gc) {\n+            return 0;\n+        }\n+\n+        @Override\n+        public boolean contentsLost() {\n+            return false;\n+        }\n+\n+        @Override\n+        public ImageCapabilities getCapabilities() {\n+            return null;\n+        }\n+\n+        @Override\n+        public int getWidth(ImageObserver observer) {\n+            return 100;\n+        }\n+\n+        @Override\n+        public int getHeight(ImageObserver observer) {\n+            return 100;\n+        }\n+\n+        @Override\n+        public Object getProperty(String name, ImageObserver observer) {\n+            return null;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/image\/DrawImage\/CustomImage.java","additions":166,"deletions":0,"binary":false,"changes":166,"status":"added"}]}