{"files":[{"patch":"@@ -0,0 +1,358 @@\n+\/*\n+ * Copyright (c) 2022 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8292278\n+ * @summary Basic tests where jit compilation of test methods is controlled with a compilation policy\n+ * @modules java.base\/jdk.internal.vm\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ *\n+ * @run main\/othervm   --enable-preview\n+ *                     -XX:+UnlockDiagnosticVMOptions   -XX:+WhiteBoxAPI\n+ *                     -Xbootclasspath\/a:.\n+ *                     -Xbatch\n+ *                     -XX:-TieredCompilation\n+ *                     -XX:CompileCommand=dontinline,*::*dontinline*\n+ *                     -XX:CompileCommand=dontinline,*::*dontjit*\n+ *                     -XX:CompileCommand=exclude,*::*dontjit*\n+ *                     -XX:CompileCommand=dontinline,java\/lang\/String*.*\n+ *                     MovingCompWindow\n+ *\/\n+\n+import java.lang.reflect.Method;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.regex.Pattern;\n+\n+import jdk.internal.vm.Continuation;\n+import jdk.internal.vm.ContinuationScope;\n+import static jdk.test.lib.Asserts.*;\n+\n+import compiler.whitebox.CompilerWhiteBoxTest;\n+import jdk.test.whitebox.WhiteBox;\n+\n+public class MovingCompWindow {\n+    static final ContinuationScope THE_SCOPE = new ContinuationScope() {};\n+\n+    public static final Pattern COMP_NONE  = Pattern.compile(\"COMP_NONE\");\n+    public static final Pattern COMP_ALL   = Pattern.compile(\"COMP_ALL\");\n+    public static final Pattern CONT_METHS = Pattern.compile(\"^(enter|enter0|yield|yield0)$\");\n+\n+    public static boolean callSystemGC;\n+    public static int compLevel;\n+\n+    public static final WhiteBox WB = WhiteBox.getWhiteBox();\n+\n+    public static void main(String[] args) {\n+        \/\/ Run tests with C2 compilations\n+        compLevel = CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION;\n+\n+        \/\/ Run tests, call System.GC().\n+        \/\/ GC forces allocation of new StackChunk because the existing will get FLAG_GC_MODE set.\n+        callSystemGC = true;\n+        runTests();\n+    }\n+\n+    public static void runTests() {\n+        System.out.println(\"$$$0 Running test cases with the following settings:\");\n+        System.out.println(\"compLevel=\" + compLevel);\n+        System.out.println(\"callSystemGC=\" + callSystemGC);\n+        System.out.println();\n+\n+        runTests(new CompilationPolicy(7 \/*warmup*\/, 1 \/* length comp. window *\/));\n+    }\n+\n+    public static void runTests(CompilationPolicy compPolicy) {\n+        System.out.println(\"$$$1 Running test cases with the following policy:\");\n+        compPolicy.print(); System.out.println();\n+\n+        new ContinuationRunYieldRunTest().runTestCase(3, compPolicy);\n+    }\n+\n+    \/\/ Control which frames are compiled\/interpreted when calling Continuation.yield()\n+    \/\/ With COMP_WINDOW the methods in the window are supposed to be compiled and others\n+    \/\/ are interpreted. With DEOPT_WINDOW vice versa.\n+    \/\/ The methods that are subject to the CompilationPolicy are set with setMethods().\n+    \/\/ Their order has to correspond to the stack order when calling yield().\n+    public static class CompilationPolicy {\n+        public int warmupIterations;\n+        public Pattern methodPattern;\n+        public Pattern contMethPattern;\n+\n+        public CompWindowMode compWindowMode;\n+        public int winPos;\n+        public int winLen;\n+\n+        public Method[] methods;\n+\n+        public enum CompWindowMode {\n+            NO_COMP_WINDOW, COMP_WINDOW, DEOPT_WINDOW\n+        }\n+\n+        public CompilationPolicy(int warmupIterations, Pattern methodPattern, Pattern contMethPattern) {\n+            this(warmupIterations, 0, methodPattern, contMethPattern, CompWindowMode.NO_COMP_WINDOW);\n+        }\n+\n+        public CompilationPolicy(int warmupIterations, int windowLength, Pattern methodPattern, Pattern contMethPattern) {\n+            this(warmupIterations, windowLength, methodPattern, contMethPattern, CompWindowMode.COMP_WINDOW);\n+        }\n+\n+        public CompilationPolicy(int warmupIterations, int windowLength, Pattern methodPattern, Pattern contMethPattern,\n+                                 CompWindowMode startMode) {\n+            this.warmupIterations = warmupIterations;\n+            this.methodPattern = methodPattern;\n+            this.contMethPattern = contMethPattern;\n+            this.winPos = 0;\n+            this.winLen = windowLength;\n+            this.compWindowMode = startMode;\n+        }\n+\n+        public CompilationPolicy(int warmupIterations, int windowLength) {\n+            this(warmupIterations, windowLength, COMP_ALL, CONT_METHS);\n+        }\n+\n+        public int warmupIterations() {\n+            return this.warmupIterations;\n+        }\n+\n+        public void compileMethods() {\n+            log(\"Compilation window mode: \" + compWindowMode + \" winPos=\" + winPos + \" winLen=\" + winLen);\n+            for (int i = 0; i < methods.length; i++) {\n+                Method meth = methods[i];\n+                boolean inWindow = i >= winPos && i < (winPos+winLen);\n+                boolean shouldBeCompiled = compWindowMode == CompWindowMode.NO_COMP_WINDOW\n+                    || (inWindow && compWindowMode == CompWindowMode.COMP_WINDOW)\n+                    || (!inWindow && compWindowMode == CompWindowMode.DEOPT_WINDOW);\n+                boolean isCompiled = WB.isMethodCompiled(meth);\n+                log(\"methods[\"+i+\"] inWindow=\"+inWindow + \" isCompiled=\"+isCompiled+\" shouldBeCompiled=\"+shouldBeCompiled+\" method=`\"+meth+\"`\");\n+                if (isCompiled != shouldBeCompiled) {\n+                    if (shouldBeCompiled) {\n+                        log(\"           Compiling methods[\"+i+\"]\");\n+                        enqForCompilation(meth);\n+                        assertTrue(WB.isMethodCompiled(meth), \"Run with -Xbatch\");\n+                    } else {\n+                        assertFalse(WB.isMethodQueuedForCompilation(meth), \"Run with -Xbatch\");\n+                        log(\"           Deoptimizing methods[\"+i+\"]\");\n+                        WB.deoptimizeMethod(meth);\n+                    }\n+                }\n+            }\n+        }\n+\n+        @SuppressWarnings(\"deprecation\")\n+        public boolean enqForCompilation(Method meth) {\n+            return WB.enqueueMethodForCompilation(meth, compLevel);\n+        }\n+\n+        public void log(String m) {\n+            System.out.println(m);\n+        }\n+\n+        public void print() {\n+            log(\"warmupIterations=\" + warmupIterations);\n+            log(\"methodPattern=\" + methodPattern);\n+            log(\"continuationMethPattern=\" + contMethPattern);\n+            log(\"compWindowMode=\" + compWindowMode);\n+            log(\"winLen=\" + winLen);\n+        }\n+\n+        public void setMethods(Method[] methods) {\n+            this.methods = methods;\n+            if (compWindowMode == CompWindowMode.NO_COMP_WINDOW) {\n+                winLen = methods.length;\n+            }\n+        }\n+\n+        public boolean shiftWindow() {\n+            if(compWindowMode == CompWindowMode.NO_COMP_WINDOW) return false;\n+            if (++winPos == methods.length) {\n+                winPos = 0;\n+                if (compWindowMode == CompWindowMode.DEOPT_WINDOW) {\n+                    compWindowMode = CompWindowMode.COMP_WINDOW;\n+                    return false; \/\/ we're done\n+                }\n+                compWindowMode = CompWindowMode.DEOPT_WINDOW;\n+            }\n+            return true; \/\/ continue\n+        }\n+    }\n+\n+    \/**\n+     * Base class for test cases\n+     *\/\n+    public static abstract class TestCaseBase implements Runnable {\n+        public int yieldCalls;\n+        public int warmUpCount;\n+        public CompilationPolicy compPolicy;\n+\n+        public void log_dontjit() {\n+            System.out.println();\n+        }\n+\n+        public void log_dontjit(String m) {\n+            if (warmUpCount > 0) {\n+                System.out.print(\"[\" + warmUpCount + \"] \");\n+            }\n+            System.out.println(m);\n+        }\n+\n+        public void runTestCase(int yieldCalls, CompilationPolicy compPolicy) {\n+            this.yieldCalls = yieldCalls;\n+            log_dontjit(\">>>> Executing test case \" + getClass().getName() + \" (yieldCalls=\" + yieldCalls + \")\");\n+            init(compPolicy);\n+            try {\n+                log_dontjit(\"Warm-up test case\");\n+                for(warmUpCount = 1; warmUpCount <= compPolicy.warmupIterations(); warmUpCount++) {\n+                    testEntry_dontinline();\n+                }\n+                warmUpCount = 0;\n+                log_dontjit(\"Warm-up test case DONE\");\n+\n+                do {\n+                    log_dontjit(\"@@ Compiling test methods according to compilation policy\");\n+                    compPolicy.compileMethods();\n+\n+                    log_dontjit(\"Running test case (Reresolve Call Sites)\");\n+                    testEntry_dontinline();\n+                    log_dontjit(\"Running test case DONE  (Reresolve Call Sites)\");\n+\n+                    log_dontjit(\"Running test case\");\n+                    testEntry_dontinline();\n+                    log_dontjit(\"Running test case DONE\");\n+                } while(compPolicy.shiftWindow());\n+            } finally {\n+                log_dontjit(\"<<<< Finished test case \" + getClass().getName()); log_dontjit();\n+            }\n+        }\n+\n+        public void init(CompilationPolicy compPolicy) {\n+            this.compPolicy = compPolicy;\n+            ArrayList<Method> selectedMethods = new ArrayList<Method>();\n+            Pattern p = compPolicy.methodPattern;\n+            if (p != COMP_NONE) {\n+                Class<? extends TestCaseBase> c = getClass();\n+                Method methods[] = c.getDeclaredMethods();\n+                for (Method meth : methods) {\n+                    if (p == COMP_ALL || p.matcher(meth.getName()).matches()) {\n+                        if (!meth.getName().contains(\"dontjit\")) {\n+                            selectedMethods.add(meth);\n+                        }\n+                    }\n+                }\n+            }\n+\n+            p = compPolicy.contMethPattern;\n+            if (compPolicy.contMethPattern != COMP_NONE) {\n+                Class<?> c = Continuation.class;\n+                Method methods[] = c .getDeclaredMethods();\n+                for (Method meth : methods) {\n+                    if (p.matcher(meth.getName()).matches()) {\n+                        selectedMethods.add(meth);\n+                    }\n+                }\n+            }\n+            \/\/ Sort in caller\/callee order by the \"ord\" method name prefix\n+            selectedMethods.sort(new Comparator<Method>() {\n+                    @Override\n+                    public int compare(Method m1, Method m2) {\n+                        String n1 = m1.getName();\n+                        String n2 = m2.getName();\n+                        \/\/ log_dontjit(\"n1=\" + n1 + \" n2=\" + n2);\n+                        int p1 = -1;\n+                        int p2 = -1;\n+                        int i = n1.indexOf(\"ord\");\n+                        if (i >= 0) {\n+                            p1 = Integer.parseInt(n1.substring(i+3, i+6));\n+                        }\n+                        i = n2.indexOf(\"ord\");\n+                        if (i >= 0) {\n+                            p2 = Integer.parseInt(n2.substring(i+3, i+6));\n+                        }\n+                        if (p1 < 0) p1 = getScoreKnownMethods(n1);\n+                        if (p2 < 0) p2 = getScoreKnownMethods(n2);\n+                        assertFalse(p1 == -1 || p2 == -1, \"Cannot compare \" + n1 + \" with \" + n2);\n+                        return p1 - p2;\n+                    }\n+\n+                    private int getScoreKnownMethods(String n) {\n+                        int p = -1;\n+                        if (n.equals(\"enter\"))  p = 20;   \/\/ Continuation.enter\n+                        if (n.equals(\"enter0\")) p = 30;   \/\/ Continuation.enter0\n+                        if (n.equals(\"run\"))    p = 50;   \/\/ Called by Continuation.enter0\n+                        if (n.equals(\"yield\"))  p = 1000; \/\/ caller of yield0\n+                        if (n.equals(\"yield0\")) p = 2000; \/\/ top frame\n+                        return p;\n+                    }\n+                });\n+            compPolicy.setMethods(selectedMethods.toArray(new Method[selectedMethods.size()]));\n+        }\n+\n+        public void testEntry_dontinline() {\n+            Continuation cont = new Continuation(THE_SCOPE, this);\n+            do {\n+                cont.run();\n+                if (callSystemGC) System.gc();\n+                checkFrames_dontjit(cont);\n+            } while (!cont.isDone());\n+        }\n+\n+        public void checkFrames_dontjit(Continuation cont) {\n+        } \/\/ Override in subclass as appropriate\n+\n+        @Override\n+        public void run() {\n+            fail(\"Should not call TestCaseBase::run\");\n+        }\n+\n+        public void sleep(Duration d) {\n+            try { Thread.sleep(d); }\n+            catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Trivial run\/yield\/run test\n+     *\/\n+    public static class ContinuationRunYieldRunTest extends TestCaseBase {\n+        public String sField;\n+\n+        @Override\n+        public void run() {\n+            log_dontjit(\"Continuation running on thread \" + Thread.currentThread());\n+            for(int i = 0; i < yieldCalls; i++) {\n+                log_dontjit(\"Yield #\" + i);\n+                String s1 = \"str1\";\n+                Continuation.yield(THE_SCOPE);\n+                String s2 = s1+\"str2\";\n+                sField = s2;\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/internal\/vm\/Continuation\/MovingCompWindow.java","additions":358,"deletions":0,"binary":false,"changes":358,"status":"added"}]}