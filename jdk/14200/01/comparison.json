{"files":[{"patch":"@@ -4594,0 +4594,49 @@\n+\n+\/\/ BOOLEAN\n+\n+instruct extractUB_ireg(iRegINoSp dst, vReg src, iRegI idx, vReg tmp) %{\n+  match(Set dst (ExtractUB src idx));\n+  effect(TEMP tmp);\n+  format %{ \"extractUB_ireg $dst, $src, $idx\\t# variable index. KILL $tmp\" %}\n+  ins_encode %{\n+    \/\/ Input \"src\" is a vector of boolean represented as\n+    \/\/ bytes with 0x00\/0x01 as element values.\n+    \/\/ \"idx\" is expected to be in range.\n+\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $src);\n+    __ mov($tmp$$FloatRegister, __ B, 0, $idx$$Register);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ tbl($tmp$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+             $src$$FloatRegister, 1, $tmp$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_tbl($tmp$$FloatRegister, __ B, $src$$FloatRegister, $tmp$$FloatRegister);\n+    }\n+    __ smov($dst$$Register, $tmp$$FloatRegister, __ B, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct extractUB_index_lt16(iRegINoSp dst, vReg src, immI idx) %{\n+  predicate(n->in(2)->get_int() < 16);\n+  match(Set dst (ExtractUB src idx));\n+  format %{ \"extractUB_index_lt16 $dst, $src, $idx\\t# index < 16\" %}\n+  ins_encode %{\n+    __ smov($dst$$Register, $src$$FloatRegister, __ B, (int)($idx$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct extractUB_index_ge16(iRegINoSp dst, vReg src, immI idx, vReg tmp) %{\n+  predicate(n->in(2)->get_int() >= 16);\n+  match(Set dst (ExtractUB src idx));\n+  effect(TEMP tmp);\n+  format %{ \"extractUB_index_ge16 $dst, $src, $idx\\t# index >=16. KILL $tmp\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    __ sve_extract_integral($dst$$Register, T_BYTE, $src$$FloatRegister,\n+                            (int)($idx$$constant), $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad","additions":49,"deletions":0,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -3125,0 +3125,28 @@\n+\n+\/\/ BOOLEAN\n+\n+instruct extractUB_ireg(iRegINoSp dst, vReg src, iRegI idx, vReg tmp) %{\n+  match(Set dst (ExtractUB src idx));\n+  effect(TEMP tmp);\n+  format %{ \"extractUB_ireg $dst, $src, $idx\\t# variable index. KILL $tmp\" %}\n+  ins_encode %{\n+    \/\/ Input \"src\" is a vector of boolean represented as\n+    \/\/ bytes with 0x00\/0x01 as element values.\n+    \/\/ \"idx\" is expected to be in range.\n+\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $src);\n+    __ mov($tmp$$FloatRegister, __ B, 0, $idx$$Register);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ tbl($tmp$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+             $src$$FloatRegister, 1, $tmp$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_tbl($tmp$$FloatRegister, __ B, $src$$FloatRegister, $tmp$$FloatRegister);\n+    }\n+    __ smov($dst$$Register, $tmp$$FloatRegister, __ B, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+EXTRACT_INT_SMALL(UB, 16, iRegINoSp, smov, B)\n+EXTRACT_INT_LARGE(UB, 16, iRegINoSp, T_BYTE)\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -1089,1 +1089,1 @@\n-                                     \"Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;\"                                                           \\\n+                                     \"Ljdk\/internal\/vm\/vector\/VectorSupport$VectorPayload;\"                                                    \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2521,1 +2521,1 @@\n-\/\/  <V extends Vector<E>,\n+\/\/  <VM extends VectorPayload,\n@@ -2523,3 +2523,4 @@\n-\/\/  long extract(Class<? extends V> vectorClass, Class<E> elementType, int vlen,\n-\/\/               V vec, int ix,\n-\/\/               VecExtractOp<V> defaultImpl)\n+\/\/  long extract(Class<? extends VM> vClass, Class<E> eClass,\n+\/\/               int length,\n+\/\/               VM vm, int i,\n+\/\/               VecExtractOp<VM> defaultImpl)\n@@ -2535,1 +2536,1 @@\n-  if (vector_klass->const_oop() == nullptr || elem_klass->const_oop() == nullptr || !vlen->is_con() || !idx->is_con()) {\n+  if (vector_klass->const_oop() == nullptr || elem_klass->const_oop() == nullptr || !vlen->is_con()) {\n@@ -2537,1 +2538,1 @@\n-      tty->print_cr(\"  ** missing constant: vclass=%s etype=%s vlen=%s idx=%s\",\n+      tty->print_cr(\"  ** missing constant: vclass=%s etype=%s vlen=%s\",\n@@ -2540,2 +2541,1 @@\n-                    NodeClassNames[argument(2)->Opcode()],\n-                    NodeClassNames[argument(4)->Opcode()]);\n+                    NodeClassNames[argument(2)->Opcode()]);\n@@ -2560,8 +2560,0 @@\n-  int vopc = ExtractNode::opcode(elem_bt);\n-  if (!arch_supports_vector(vopc, num_elem, elem_bt, VecMaskNotUsed)) {\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not supported: arity=1 op=extract vlen=%d etype=%s ismask=no\",\n-                    num_elem, type2name(elem_bt));\n-    }\n-    return false; \/\/ not supported\n-  }\n@@ -2572,4 +2564,1 @@\n-  Node* opd = unbox_vector(argument(3), vbox_type, elem_bt, num_elem);\n-  if (opd == nullptr) {\n-    return false;\n-  }\n+  Node* opd = nullptr;\n@@ -2577,2 +2566,2 @@\n-  ConINode* idx_con = gvn().intcon(idx->get_con())->as_ConI();\n-  Node* operation = gvn().transform(ExtractNode::make(opd, idx_con, elem_bt));\n+  if (is_vector_mask(vbox_klass)) {\n+    \/\/ vbox_klass is mask. This is used for VectorMask.laneIsSet(int).\n@@ -2580,7 +2569,28 @@\n-  Node* bits = nullptr;\n-  switch (elem_bt) {\n-    case T_BYTE:\n-    case T_SHORT:\n-    case T_INT: {\n-      bits = gvn().transform(new ConvI2LNode(operation));\n-      break;\n+    Node* pos = argument(4); \/\/ can be variable\n+    if (arch_supports_vector(Op_ExtractUB, num_elem, elem_bt, VecMaskUseAll)) {\n+      \/\/ Transform mask to vector with type of boolean and utilize ExtractUB node.\n+      opd = unbox_vector(argument(3), vbox_type, elem_bt, num_elem);\n+      if (opd == nullptr) {\n+        return false;\n+      }\n+      opd = gvn().transform(VectorStoreMaskNode::make(gvn(), opd, elem_bt, num_elem));\n+      opd = gvn().transform(new ExtractUBNode(opd, pos));\n+      opd = gvn().transform(new ConvI2LNode(opd));\n+    } else if (arch_supports_vector(Op_VectorMaskToLong, num_elem, elem_bt, VecMaskUseLoad)) {\n+      opd = unbox_vector(argument(3), vbox_type, elem_bt, num_elem);\n+      if (opd == nullptr) {\n+        return false;\n+      }\n+      \/\/ VectorMaskToLongNode requires the input is either a mask or a vector with BOOLEAN type.\n+      if (opd->bottom_type()->isa_vectmask() == nullptr) {\n+        opd = gvn().transform(VectorStoreMaskNode::make(gvn(), opd, elem_bt, num_elem));\n+      }\n+      \/\/ ((toLong() >>> pos) & 1L\n+      opd = gvn().transform(new VectorMaskToLongNode(opd, TypeLong::LONG));\n+      opd = gvn().transform(new URShiftLNode(opd, pos));\n+      opd = gvn().transform(new AndLNode(opd, gvn().makecon(TypeLong::ONE)));\n+    } else {\n+      if (C->print_intrinsics()) {\n+        tty->print_cr(\"  ** Rejected mask extraction because architecture does not support it\");\n+      }\n+      return false; \/\/ not supported\n@@ -2588,4 +2598,7 @@\n-    case T_FLOAT: {\n-      bits = gvn().transform(new MoveF2INode(operation));\n-      bits = gvn().transform(new ConvI2LNode(bits));\n-      break;\n+  } else {\n+    \/\/ vbox_klass is vector. This is used for Vector.lane(int).\n+    if (!idx->is_con()) {\n+      if (C->print_intrinsics()) {\n+        tty->print_cr(\"  ** missing constant: idx=%s\", NodeClassNames[argument(4)->Opcode()]);\n+      }\n+      return false; \/\/ not enough info for intrinsification\n@@ -2593,3 +2606,8 @@\n-    case T_DOUBLE: {\n-      bits = gvn().transform(new MoveD2LNode(operation));\n-      break;\n+\n+    int vopc = ExtractNode::opcode(elem_bt);\n+    if (!arch_supports_vector(vopc, num_elem, elem_bt, VecMaskNotUsed)) {\n+      if (C->print_intrinsics()) {\n+        tty->print_cr(\"  ** not supported: arity=1 op=extract vlen=%d etype=%s ismask=no\",\n+                      num_elem, type2name(elem_bt));\n+      }\n+      return false; \/\/ not supported\n@@ -2597,3 +2615,4 @@\n-    case T_LONG: {\n-      bits = operation; \/\/ no conversion needed\n-      break;\n+\n+    opd = unbox_vector(argument(3), vbox_type, elem_bt, num_elem);\n+    if (opd == nullptr) {\n+      return false;\n@@ -2601,2 +2620,1 @@\n-    default: fatal(\"%s\", type2name(elem_bt));\n-  }\n+    ConINode* idx_con = gvn().intcon(idx->get_con())->as_ConI();\n@@ -2604,1 +2622,25 @@\n-  set_result(bits);\n+    opd = gvn().transform(ExtractNode::make(opd, idx_con, elem_bt));\n+    switch (elem_bt) {\n+      case T_BYTE:\n+      case T_SHORT:\n+      case T_INT: {\n+        opd = gvn().transform(new ConvI2LNode(opd));\n+        break;\n+      }\n+      case T_FLOAT: {\n+        opd = gvn().transform(new MoveF2INode(opd));\n+        opd = gvn().transform(new ConvI2LNode(opd));\n+        break;\n+      }\n+      case T_DOUBLE: {\n+        opd = gvn().transform(new MoveD2LNode(opd));\n+        break;\n+      }\n+      case T_LONG: {\n+        \/\/ no conversion needed\n+        break;\n+      }\n+      default: fatal(\"%s\", type2name(elem_bt));\n+    }\n+  }\n+  set_result(opd);\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":84,"deletions":42,"binary":false,"changes":126,"status":"modified"},{"patch":"@@ -1205,1 +1205,1 @@\n-\/\/ Extract a scalar element of vector.\n+\/\/ Extract a scalar element of vector by constant position.\n@@ -1207,1 +1207,2 @@\n-  assert(pos->get_int() < Matcher::max_vector_size(bt), \"pos in range\");\n+  assert(pos->get_int() >= 0 &&\n+         pos->get_int() < Matcher::max_vector_size(bt), \"pos in range\");\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1283,3 +1283,1 @@\n-  ExtractNode(Node* src, ConINode* pos) : Node(nullptr, src, (Node*)pos) {\n-    assert(in(2)->get_int() >= 0, \"positive constants\");\n-  }\n+  ExtractNode(Node* src, Node* pos) : Node(nullptr, src, pos) {}\n@@ -1287,2 +1285,0 @@\n-  uint  pos() const { return in(2)->get_int(); }\n-\n@@ -1297,1 +1293,1 @@\n-  ExtractBNode(Node* src, ConINode* pos) : ExtractNode(src, pos) {}\n+  ExtractBNode(Node* src, Node* pos) : ExtractNode(src, pos) {}\n@@ -1307,1 +1303,1 @@\n-  ExtractUBNode(Node* src, ConINode* pos) : ExtractNode(src, pos) {}\n+  ExtractUBNode(Node* src, Node* pos) : ExtractNode(src, pos) {}\n@@ -1309,1 +1305,1 @@\n-  virtual const Type* bottom_type() const { return TypeInt::UBYTE; }\n+  virtual const Type* bottom_type() const { return TypeInt::BOOL; }\n@@ -1317,1 +1313,1 @@\n-  ExtractCNode(Node* src, ConINode* pos) : ExtractNode(src, pos) {}\n+  ExtractCNode(Node* src, Node* pos) : ExtractNode(src, pos) {}\n@@ -1327,1 +1323,1 @@\n-  ExtractSNode(Node* src, ConINode* pos) : ExtractNode(src, pos) {}\n+  ExtractSNode(Node* src, Node* pos) : ExtractNode(src, pos) {}\n@@ -1337,1 +1333,1 @@\n-  ExtractINode(Node* src, ConINode* pos) : ExtractNode(src, pos) {}\n+  ExtractINode(Node* src, Node* pos) : ExtractNode(src, pos) {}\n@@ -1347,1 +1343,1 @@\n-  ExtractLNode(Node* src, ConINode* pos) : ExtractNode(src, pos) {}\n+  ExtractLNode(Node* src, Node* pos) : ExtractNode(src, pos) {}\n@@ -1357,1 +1353,1 @@\n-  ExtractFNode(Node* src, ConINode* pos) : ExtractNode(src, pos) {}\n+  ExtractFNode(Node* src, Node* pos) : ExtractNode(src, pos) {}\n@@ -1367,1 +1363,1 @@\n-  ExtractDNode(Node* src, ConINode* pos) : ExtractNode(src, pos) {}\n+  ExtractDNode(Node* src, Node* pos) : ExtractNode(src, pos) {}\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":10,"deletions":14,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -273,2 +273,2 @@\n-    public interface VecExtractOp<V extends Vector<?>> {\n-        long apply(V v, int i);\n+    public interface VecExtractOp<VM extends VectorPayload> {\n+        long apply(VM vm, int i);\n@@ -279,1 +279,1 @@\n-    <V extends Vector<E>,\n+    <VM extends VectorPayload,\n@@ -281,1 +281,1 @@\n-    long extract(Class<? extends V> vClass, Class<E> eClass,\n+    long extract(Class<? extends VM> vClass, Class<E> eClass,\n@@ -283,2 +283,2 @@\n-                 V v, int i,\n-                 VecExtractOp<V> defaultImpl) {\n+                 VM vm, int i,\n+                 VecExtractOp<VM> defaultImpl) {\n@@ -286,1 +286,1 @@\n-        return defaultImpl.apply(v, i);\n+        return defaultImpl.apply(vm, i);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/vector\/VectorSupport.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -70,12 +70,0 @@\n-    @Override\n-    @ForceInline\n-    public boolean laneIsSet(int i) {\n-        int length = length();\n-        Objects.checkIndex(i, length);\n-        if (length <= Long.SIZE) {\n-            return ((toLong() >>> i) & 1L) == 1;\n-        } else {\n-            return getBits()[i];\n-        }\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractMask.java","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -758,0 +758,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Byte128Mask.class, byte.class, VLENGTH,\n+                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte128Vector.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -790,0 +790,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Byte256Mask.class, byte.class, VLENGTH,\n+                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte256Vector.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -854,0 +854,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Byte512Mask.class, byte.class, VLENGTH,\n+                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte512Vector.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -742,0 +742,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Byte64Mask.class, byte.class, VLENGTH,\n+                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte64Vector.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -728,0 +728,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(ByteMaxMask.class, byte.class, VLENGTH,\n+                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteMaxVector.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -719,0 +719,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Double128Mask.class, double.class, VLENGTH,\n+                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double128Vector.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -723,0 +723,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Double256Mask.class, double.class, VLENGTH,\n+                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double256Vector.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -731,0 +731,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Double512Mask.class, double.class, VLENGTH,\n+                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double512Vector.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -717,0 +717,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Double64Mask.class, double.class, VLENGTH,\n+                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double64Vector.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -716,0 +716,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(DoubleMaxMask.class, double.class, VLENGTH,\n+                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleMaxVector.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -723,0 +723,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Float128Mask.class, float.class, VLENGTH,\n+                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float128Vector.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -731,0 +731,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Float256Mask.class, float.class, VLENGTH,\n+                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float256Vector.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -747,0 +747,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Float512Mask.class, float.class, VLENGTH,\n+                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float512Vector.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -719,0 +719,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Float64Mask.class, float.class, VLENGTH,\n+                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float64Vector.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -716,0 +716,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(FloatMaxMask.class, float.class, VLENGTH,\n+                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatMaxVector.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -734,0 +734,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Int128Mask.class, int.class, VLENGTH,\n+                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int128Vector.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -742,0 +742,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Int256Mask.class, int.class, VLENGTH,\n+                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int256Vector.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -758,0 +758,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Int512Mask.class, int.class, VLENGTH,\n+                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int512Vector.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -730,0 +730,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Int64Mask.class, int.class, VLENGTH,\n+                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int64Vector.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -728,0 +728,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(IntMaxMask.class, int.class, VLENGTH,\n+                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntMaxVector.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -720,0 +720,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Long128Mask.class, long.class, VLENGTH,\n+                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long128Vector.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -724,0 +724,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Long256Mask.class, long.class, VLENGTH,\n+                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long256Vector.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -732,0 +732,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Long512Mask.class, long.class, VLENGTH,\n+                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long512Vector.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -718,0 +718,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Long64Mask.class, long.class, VLENGTH,\n+                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long64Vector.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -718,0 +718,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(LongMaxMask.class, long.class, VLENGTH,\n+                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongMaxVector.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -742,0 +742,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Short128Mask.class, short.class, VLENGTH,\n+                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short128Vector.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -758,0 +758,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Short256Mask.class, short.class, VLENGTH,\n+                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short256Vector.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -790,0 +790,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Short512Mask.class, short.class, VLENGTH,\n+                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short512Vector.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -734,0 +734,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Short64Mask.class, short.class, VLENGTH,\n+                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short64Vector.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -728,0 +728,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(ShortMaxMask.class, short.class, VLENGTH,\n+                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortMaxVector.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1001,0 +1001,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract($masktype$.class, $type$.class, VLENGTH,\n+                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-VectorBits.java.template","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,578 @@\n+\/*\n+ * Copyright (c) 2023, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.jdk.incubator.vector;\n+\n+import java.util.concurrent.TimeUnit;\n+import jdk.incubator.vector.*;\n+import org.openjdk.jmh.annotations.*;\n+\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+@Fork(jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class VectorExtractBenchmark {\n+    private int idx = 0;\n+    private boolean[] res = new boolean[8];\n+\n+    private static final VectorMask bmask64 = VectorMask.fromLong(ByteVector.SPECIES_64, 1L);\n+    private static final VectorMask bmask128 = VectorMask.fromLong(ByteVector.SPECIES_128, 1L);\n+    private static final VectorMask bmask256 = VectorMask.fromLong(ByteVector.SPECIES_256, 1L);\n+    private static final VectorMask bmask512 = VectorMask.fromLong(ByteVector.SPECIES_512, 1L);\n+\n+    private static final VectorMask smask64 = VectorMask.fromLong(ShortVector.SPECIES_64, 1L);\n+    private static final VectorMask smask128 = VectorMask.fromLong(ShortVector.SPECIES_128, 1L);\n+    private static final VectorMask smask256 = VectorMask.fromLong(ShortVector.SPECIES_256, 1L);\n+    private static final VectorMask smask512 = VectorMask.fromLong(ShortVector.SPECIES_512, 1L);\n+\n+    private static final VectorMask imask64 = VectorMask.fromLong(IntVector.SPECIES_64, 1L);\n+    private static final VectorMask imask128 = VectorMask.fromLong(IntVector.SPECIES_128, 1L);\n+    private static final VectorMask imask256 = VectorMask.fromLong(IntVector.SPECIES_256, 1L);\n+    private static final VectorMask imask512 = VectorMask.fromLong(IntVector.SPECIES_512, 1L);\n+\n+    private static final VectorMask lmask64 = VectorMask.fromLong(LongVector.SPECIES_64, 1L);\n+    private static final VectorMask lmask128 = VectorMask.fromLong(LongVector.SPECIES_128, 1L);\n+    private static final VectorMask lmask256 = VectorMask.fromLong(LongVector.SPECIES_256, 1L);\n+    private static final VectorMask lmask512 = VectorMask.fromLong(LongVector.SPECIES_512, 1L);\n+\n+    private static final VectorMask fmask64 = VectorMask.fromLong(FloatVector.SPECIES_64, 1L);\n+    private static final VectorMask fmask128 = VectorMask.fromLong(FloatVector.SPECIES_128, 1L);\n+    private static final VectorMask fmask256 = VectorMask.fromLong(FloatVector.SPECIES_256, 1L);\n+    private static final VectorMask fmask512 = VectorMask.fromLong(FloatVector.SPECIES_512, 1L);\n+\n+    private static final VectorMask dmask64 = VectorMask.fromLong(DoubleVector.SPECIES_64, 1L);\n+    private static final VectorMask dmask128 = VectorMask.fromLong(DoubleVector.SPECIES_128, 1L);\n+    private static final VectorMask dmask256 = VectorMask.fromLong(DoubleVector.SPECIES_256, 1L);\n+    private static final VectorMask dmask512 = VectorMask.fromLong(DoubleVector.SPECIES_512, 1L);\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetByte64_con() {\n+        res[0] = bmask64.laneIsSet(0);\n+        res[1] = bmask64.laneIsSet(1);\n+        res[2] = bmask64.laneIsSet(2);\n+        res[3] = bmask64.laneIsSet(3);\n+        res[4] = bmask64.laneIsSet(4);\n+        res[5] = bmask64.laneIsSet(5);\n+        res[6] = bmask64.laneIsSet(6);\n+        res[7] = bmask64.laneIsSet(7);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetByte64_var() {\n+        res[0] = bmask64.laneIsSet(idx);\n+        res[1] = bmask64.laneIsSet(idx + 1);\n+        res[2] = bmask64.laneIsSet(idx + 2);\n+        res[3] = bmask64.laneIsSet(idx + 3);\n+        res[4] = bmask64.laneIsSet(idx + 4);\n+        res[5] = bmask64.laneIsSet(idx + 5);\n+        res[6] = bmask64.laneIsSet(idx + 6);\n+        res[7] = bmask64.laneIsSet(idx + 7);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetByte128_con() {\n+        res[0] = bmask128.laneIsSet(0);\n+        res[1] = bmask128.laneIsSet(1);\n+        res[2] = bmask128.laneIsSet(2);\n+        res[3] = bmask128.laneIsSet(3);\n+        res[4] = bmask128.laneIsSet(12);\n+        res[5] = bmask128.laneIsSet(13);\n+        res[6] = bmask128.laneIsSet(14);\n+        res[7] = bmask128.laneIsSet(15);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetByte128_var() {\n+        res[0] = bmask128.laneIsSet(idx);\n+        res[1] = bmask128.laneIsSet(idx + 1);\n+        res[2] = bmask128.laneIsSet(idx + 2);\n+        res[3] = bmask128.laneIsSet(idx + 3);\n+        res[4] = bmask128.laneIsSet(idx + 12);\n+        res[5] = bmask128.laneIsSet(idx + 13);\n+        res[6] = bmask128.laneIsSet(idx + 14);\n+        res[7] = bmask128.laneIsSet(idx + 15);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetByte256_con() {\n+        res[0] = bmask256.laneIsSet(0);\n+        res[1] = bmask256.laneIsSet(1);\n+        res[2] = bmask256.laneIsSet(2);\n+        res[3] = bmask256.laneIsSet(3);\n+        res[4] = bmask256.laneIsSet(28);\n+        res[5] = bmask256.laneIsSet(29);\n+        res[6] = bmask256.laneIsSet(30);\n+        res[7] = bmask256.laneIsSet(31);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetByte256_var() {\n+        res[0] = bmask256.laneIsSet(idx);\n+        res[1] = bmask256.laneIsSet(idx + 1);\n+        res[2] = bmask256.laneIsSet(idx + 2);\n+        res[3] = bmask256.laneIsSet(idx + 3);\n+        res[4] = bmask256.laneIsSet(idx + 28);\n+        res[5] = bmask256.laneIsSet(idx + 29);\n+        res[6] = bmask256.laneIsSet(idx + 30);\n+        res[7] = bmask256.laneIsSet(idx + 31);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetByte512_con() {\n+        res[0] = bmask512.laneIsSet(0);\n+        res[1] = bmask512.laneIsSet(1);\n+        res[2] = bmask512.laneIsSet(2);\n+        res[3] = bmask512.laneIsSet(3);\n+        res[4] = bmask512.laneIsSet(60);\n+        res[5] = bmask512.laneIsSet(61);\n+        res[6] = bmask512.laneIsSet(62);\n+        res[7] = bmask512.laneIsSet(63);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetByte512_var() {\n+        res[0] = bmask512.laneIsSet(idx);\n+        res[1] = bmask512.laneIsSet(idx + 1);\n+        res[2] = bmask512.laneIsSet(idx + 2);\n+        res[3] = bmask512.laneIsSet(idx + 3);\n+        res[4] = bmask512.laneIsSet(idx + 60);\n+        res[5] = bmask512.laneIsSet(idx + 61);\n+        res[6] = bmask512.laneIsSet(idx + 62);\n+        res[7] = bmask512.laneIsSet(idx + 63);\n+        return res;\n+    }\n+\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetShort64_con() {\n+        res[0] = smask64.laneIsSet(0);\n+        res[1] = smask64.laneIsSet(1);\n+        res[2] = smask64.laneIsSet(2);\n+        res[3] = smask64.laneIsSet(3);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetShort64_var() {\n+        res[0] = smask64.laneIsSet(idx);\n+        res[1] = smask64.laneIsSet(idx + 1);\n+        res[2] = smask64.laneIsSet(idx + 2);\n+        res[3] = smask64.laneIsSet(idx + 3);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetShort128_con() {\n+        res[0] = smask128.laneIsSet(0);\n+        res[1] = smask128.laneIsSet(1);\n+        res[2] = smask128.laneIsSet(2);\n+        res[3] = smask128.laneIsSet(3);\n+        res[4] = smask128.laneIsSet(4);\n+        res[5] = smask128.laneIsSet(5);\n+        res[6] = smask128.laneIsSet(6);\n+        res[7] = smask128.laneIsSet(7);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetShort128_var() {\n+        res[0] = smask128.laneIsSet(idx);\n+        res[1] = smask128.laneIsSet(idx + 1);\n+        res[2] = smask128.laneIsSet(idx + 2);\n+        res[3] = smask128.laneIsSet(idx + 3);\n+        res[4] = smask128.laneIsSet(idx + 4);\n+        res[5] = smask128.laneIsSet(idx + 5);\n+        res[6] = smask128.laneIsSet(idx + 6);\n+        res[7] = smask128.laneIsSet(idx + 7);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetShort256_con() {\n+        res[0] = smask256.laneIsSet(0);\n+        res[1] = smask256.laneIsSet(1);\n+        res[2] = smask256.laneIsSet(2);\n+        res[3] = smask256.laneIsSet(3);\n+        res[4] = smask256.laneIsSet(12);\n+        res[5] = smask256.laneIsSet(13);\n+        res[6] = smask256.laneIsSet(14);\n+        res[7] = smask256.laneIsSet(15);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetShort256_var() {\n+        res[0] = smask256.laneIsSet(idx);\n+        res[1] = smask256.laneIsSet(idx + 1);\n+        res[2] = smask256.laneIsSet(idx + 2);\n+        res[3] = smask256.laneIsSet(idx + 3);\n+        res[4] = smask256.laneIsSet(idx + 12);\n+        res[5] = smask256.laneIsSet(idx + 13);\n+        res[6] = smask256.laneIsSet(idx + 14);\n+        res[7] = smask256.laneIsSet(idx + 15);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetShort512_con() {\n+        res[0] = smask512.laneIsSet(0);\n+        res[1] = smask512.laneIsSet(1);\n+        res[2] = smask512.laneIsSet(2);\n+        res[3] = smask512.laneIsSet(3);\n+        res[4] = smask512.laneIsSet(28);\n+        res[5] = smask512.laneIsSet(29);\n+        res[6] = smask512.laneIsSet(30);\n+        res[7] = smask512.laneIsSet(31);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetShort512_var() {\n+        res[0] = smask512.laneIsSet(idx);\n+        res[1] = smask512.laneIsSet(idx + 1);\n+        res[2] = smask512.laneIsSet(idx + 2);\n+        res[3] = smask512.laneIsSet(idx + 3);\n+        res[4] = smask512.laneIsSet(idx + 28);\n+        res[5] = smask512.laneIsSet(idx + 29);\n+        res[6] = smask512.laneIsSet(idx + 30);\n+        res[7] = smask512.laneIsSet(idx + 31);\n+        return res;\n+    }\n+\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetInt64_con() {\n+        res[0] = imask64.laneIsSet(0);\n+        res[1] = imask64.laneIsSet(1);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetInt64_var() {\n+        res[0] = imask64.laneIsSet(idx);\n+        res[1] = imask64.laneIsSet(idx + 1);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetInt128_con() {\n+        res[0] = imask128.laneIsSet(0);\n+        res[1] = imask128.laneIsSet(1);\n+        res[2] = imask128.laneIsSet(2);\n+        res[3] = imask128.laneIsSet(3);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetInt128_var() {\n+        res[0] = imask128.laneIsSet(idx);\n+        res[1] = imask128.laneIsSet(idx + 1);\n+        res[2] = imask128.laneIsSet(idx + 2);\n+        res[3] = imask128.laneIsSet(idx + 3);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetInt256_con() {\n+        res[0] = imask256.laneIsSet(0);\n+        res[1] = imask256.laneIsSet(1);\n+        res[2] = imask256.laneIsSet(2);\n+        res[3] = imask256.laneIsSet(3);\n+        res[4] = imask256.laneIsSet(4);\n+        res[5] = imask256.laneIsSet(5);\n+        res[6] = imask256.laneIsSet(6);\n+        res[7] = imask256.laneIsSet(7);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetInt256_var() {\n+        res[0] = imask256.laneIsSet(idx);\n+        res[1] = imask256.laneIsSet(idx + 1);\n+        res[2] = imask256.laneIsSet(idx + 2);\n+        res[3] = imask256.laneIsSet(idx + 3);\n+        res[4] = imask256.laneIsSet(idx + 4);\n+        res[5] = imask256.laneIsSet(idx + 5);\n+        res[6] = imask256.laneIsSet(idx + 6);\n+        res[7] = imask256.laneIsSet(idx + 7);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetInt512_con() {\n+        res[0] = imask512.laneIsSet(0);\n+        res[1] = imask512.laneIsSet(1);\n+        res[2] = imask512.laneIsSet(2);\n+        res[3] = imask512.laneIsSet(3);\n+        res[4] = imask512.laneIsSet(12);\n+        res[5] = imask512.laneIsSet(13);\n+        res[6] = imask512.laneIsSet(14);\n+        res[7] = imask512.laneIsSet(15);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetInt512_var() {\n+        res[0] = imask512.laneIsSet(idx);\n+        res[1] = imask512.laneIsSet(idx + 1);\n+        res[2] = imask512.laneIsSet(idx + 2);\n+        res[3] = imask512.laneIsSet(idx + 3);\n+        res[4] = imask512.laneIsSet(idx + 12);\n+        res[5] = imask512.laneIsSet(idx + 13);\n+        res[6] = imask512.laneIsSet(idx + 14);\n+        res[7] = imask512.laneIsSet(idx + 15);\n+        return res;\n+    }\n+\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetLong64_con() {\n+        res[0] = lmask64.laneIsSet(0);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetLong64_var() {\n+        res[0] = lmask64.laneIsSet(idx);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetLong128_con() {\n+        res[0] = lmask128.laneIsSet(0);\n+        res[1] = lmask128.laneIsSet(1);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetLong128_var() {\n+        res[0] = lmask128.laneIsSet(idx);\n+        res[1] = lmask128.laneIsSet(idx + 1);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetLong256_con() {\n+        res[0] = lmask256.laneIsSet(0);\n+        res[1] = lmask256.laneIsSet(1);\n+        res[2] = lmask256.laneIsSet(2);\n+        res[3] = lmask256.laneIsSet(3);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetLong256_var() {\n+        res[0] = lmask256.laneIsSet(idx);\n+        res[1] = lmask256.laneIsSet(idx + 1);\n+        res[2] = lmask256.laneIsSet(idx + 2);\n+        res[3] = lmask256.laneIsSet(idx + 3);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetLong512_con() {\n+        res[0] = lmask512.laneIsSet(0);\n+        res[1] = lmask512.laneIsSet(1);\n+        res[2] = lmask512.laneIsSet(2);\n+        res[3] = lmask512.laneIsSet(3);\n+        res[4] = lmask512.laneIsSet(4);\n+        res[5] = lmask512.laneIsSet(5);\n+        res[6] = lmask512.laneIsSet(6);\n+        res[7] = lmask512.laneIsSet(7);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetLong512_var() {\n+        res[0] = lmask512.laneIsSet(idx);\n+        res[1] = lmask512.laneIsSet(idx + 1);\n+        res[2] = lmask512.laneIsSet(idx + 2);\n+        res[3] = lmask512.laneIsSet(idx + 3);\n+        res[4] = lmask512.laneIsSet(idx + 4);\n+        res[5] = lmask512.laneIsSet(idx + 5);\n+        res[6] = lmask512.laneIsSet(idx + 6);\n+        res[7] = lmask512.laneIsSet(idx + 7);\n+        return res;\n+    }\n+\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetFloat64_con() {\n+        res[0] = fmask64.laneIsSet(0);\n+        res[1] = fmask64.laneIsSet(1);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetFloat64_var() {\n+        res[0] = fmask64.laneIsSet(idx);\n+        res[1] = fmask64.laneIsSet(idx + 1);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetFloat128_con() {\n+        res[0] = fmask128.laneIsSet(0);\n+        res[1] = fmask128.laneIsSet(1);\n+        res[2] = fmask128.laneIsSet(2);\n+        res[3] = fmask128.laneIsSet(3);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetFloat128_var() {\n+        res[0] = fmask128.laneIsSet(idx);\n+        res[1] = fmask128.laneIsSet(idx + 1);\n+        res[2] = fmask128.laneIsSet(idx + 2);\n+        res[3] = fmask128.laneIsSet(idx + 3);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetFloat256_con() {\n+        res[0] = fmask256.laneIsSet(0);\n+        res[1] = fmask256.laneIsSet(1);\n+        res[2] = fmask256.laneIsSet(2);\n+        res[3] = fmask256.laneIsSet(3);\n+        res[4] = fmask256.laneIsSet(4);\n+        res[5] = fmask256.laneIsSet(5);\n+        res[6] = fmask256.laneIsSet(6);\n+        res[7] = fmask256.laneIsSet(7);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetFloat256_var() {\n+        res[0] = fmask256.laneIsSet(idx);\n+        res[1] = fmask256.laneIsSet(idx + 1);\n+        res[2] = fmask256.laneIsSet(idx + 2);\n+        res[3] = fmask256.laneIsSet(idx + 3);\n+        res[4] = fmask256.laneIsSet(idx + 4);\n+        res[5] = fmask256.laneIsSet(idx + 5);\n+        res[6] = fmask256.laneIsSet(idx + 6);\n+        res[7] = fmask256.laneIsSet(idx + 7);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetFloat512_con() {\n+        res[0] = fmask512.laneIsSet(0);\n+        res[1] = fmask512.laneIsSet(1);\n+        res[2] = fmask512.laneIsSet(2);\n+        res[3] = fmask512.laneIsSet(3);\n+        res[4] = fmask512.laneIsSet(12);\n+        res[5] = fmask512.laneIsSet(13);\n+        res[6] = fmask512.laneIsSet(14);\n+        res[7] = fmask512.laneIsSet(15);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetFloat512_var() {\n+        res[0] = fmask512.laneIsSet(idx);\n+        res[1] = fmask512.laneIsSet(idx + 1);\n+        res[2] = fmask512.laneIsSet(idx + 2);\n+        res[3] = fmask512.laneIsSet(idx + 3);\n+        res[4] = fmask512.laneIsSet(idx + 12);\n+        res[5] = fmask512.laneIsSet(idx + 13);\n+        res[6] = fmask512.laneIsSet(idx + 14);\n+        res[7] = fmask512.laneIsSet(idx + 15);\n+        return res;\n+    }\n+\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetDouble64_con() {\n+        res[0] = dmask64.laneIsSet(0);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetDouble64_var() {\n+        res[0] = dmask64.laneIsSet(idx);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetDouble128_con() {\n+        res[0] = dmask128.laneIsSet(0);\n+        res[1] = dmask128.laneIsSet(1);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetDouble128_var() {\n+        res[0] = dmask128.laneIsSet(idx);\n+        res[1] = dmask128.laneIsSet(idx + 1);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetDouble256_con() {\n+        res[0] = dmask256.laneIsSet(0);\n+        res[1] = dmask256.laneIsSet(1);\n+        res[2] = dmask256.laneIsSet(2);\n+        res[3] = dmask256.laneIsSet(3);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetDouble256_var() {\n+        res[0] = dmask256.laneIsSet(idx);\n+        res[1] = dmask256.laneIsSet(idx + 1);\n+        res[2] = dmask256.laneIsSet(idx + 2);\n+        res[3] = dmask256.laneIsSet(idx + 3);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetDouble512_con() {\n+        res[0] = dmask512.laneIsSet(0);\n+        res[1] = dmask512.laneIsSet(1);\n+        res[2] = dmask512.laneIsSet(2);\n+        res[3] = dmask512.laneIsSet(3);\n+        res[4] = dmask512.laneIsSet(4);\n+        res[5] = dmask512.laneIsSet(5);\n+        res[6] = dmask512.laneIsSet(6);\n+        res[7] = dmask512.laneIsSet(7);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetDouble512_var() {\n+        res[0] = dmask512.laneIsSet(idx);\n+        res[1] = dmask512.laneIsSet(idx + 1);\n+        res[2] = dmask512.laneIsSet(idx + 2);\n+        res[3] = dmask512.laneIsSet(idx + 3);\n+        res[4] = dmask512.laneIsSet(idx + 4);\n+        res[5] = dmask512.laneIsSet(idx + 5);\n+        res[6] = dmask512.laneIsSet(idx + 6);\n+        res[7] = dmask512.laneIsSet(idx + 7);\n+        return res;\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/VectorExtractBenchmark.java","additions":578,"deletions":0,"binary":false,"changes":578,"status":"added"}]}