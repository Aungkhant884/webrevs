{"files":[{"patch":"@@ -49,1 +49,1 @@\n- * with an element, like the raw type {@code java.util.Set}, {@code\n+ * with an element, like the raw type {@code java.util.Set},{@code\n@@ -60,1 +60,1 @@\n- * models the declarations, <em>definitions<\/em>, of elements while\n+ * models the declarations, that is <em>definitions<\/em>, of elements while\n@@ -64,1 +64,4 @@\n- * definition. For example, consider the uses of {@code\n+ * definition. In some sense, the information in the definition is\n+ * shared by all the uses.\n+\n+ * <p>For example, consider the uses of {@code\n@@ -85,42 +88,7 @@\n- * <p>Due to the {@code javax.lang.model} API already including a\n- * separation between definitions ({@link javax.lang.model.element})\n- * and uses ({@link javax.lang.model.type}), adding support for type\n- * annotations as a language feature in the API was straightforward:\n- *\n- * <ul>\n- *\n- * <li>Existing annotation-reading methods were pulled out of {@link\n- * javax.lang.model.element.Element} into a new interface, {@link\n- * AnnotatedConstruct}.\n- *\n- * <li>{@link javax.lang.model.element.Element} extended {@code\n- * AnnotatedConstruct}, preserving the existing ability to read\n- * declaration annotations.\n- *\n- * <li>{@link javax.lang.model.type.TypeMirror} was retrofitted to\n- * extend {@code AnnotatedConstruct}, adding the ability to read type\n- * annotations.\n- *\n- * <\/ul>\n- *\n- * In contrast, core reflection did <em>not<\/em> have a separation\n- * between definition and usages for types, {@link java.lang.Class\n- * java.lang.Class} is used for both purposes. When support for type\n- * annotations was added to that API, a new interface hierarchy of\n- * {@linkplain java.lang.reflect.AnnotatedType annotated types} needed\n- * to be added, with separate interfaces to model {@linkplain\n- * java.lang.reflect.AnnotatedArrayType arrays}, {@linkplain\n- * java.lang.reflect.AnnotatedParameterizedType parameterized types},\n- * {@linkplain java.lang.reflect.AnnotatedTypeVariable type\n- * variables}, and {@linkplain java.lang.reflect.AnnotatedWildcardType\n- * wildcards}. In addition, new methods returning these new annotated\n- * type objects had to be added to {@code java.lang.Class}, {@code\n- * java.lang.Method}, {@code java.lang.Constructor}, and elsewhere.\n- *\n- * <p> The core reflection updates to support type annotations needed\n- * many more new interfaces and new methods compared to the {@code\n- * javax.lang.model} changes because of the lack of separation between\n- * the definition and use of a type. The {@linkplain\n- * java.lang.reflect.AnnotatedType annotated type hierarchy} was\n- * needed to provide the structure to support use-specific\n- * information.\n+ * <p>Another example, consider the declaration of the generic\n+ * interface (JLS {@jls 9.1.2}) {@code java.util.Set} which has one\n+ * type parameter. This declaration captures commonality between the\n+ * many parameterized types (JLS {@jls 4.5}) derived from that\n+ * declaration such as {@code java.util.Set<String>}, {@code\n+ * java.util.Set<E>}, {@code java.util.Set<?>}, and also the raw type\n+ * (JLS {@jls 4.8}) {@code java.util.Set}.\n@@ -154,1 +122,5 @@\n- * to} the element for {@code java.util.Set}.\n+ * to} the element for {@code java.util.Set}. Several kinds of types\n+ * can be {@linkplain\n+ * javax.lang.model.util.Types#asElement(TypeMirror) mapped to\n+ * elements}, but other kinds of types do <em>not<\/em> have an element\n+ * mapping.\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/package-info.java","additions":18,"deletions":46,"binary":false,"changes":64,"status":"modified"}]}