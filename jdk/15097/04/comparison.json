{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -113,0 +113,1 @@\n+ * @see javax.lang.model##elementsAndTypes Elements and Types\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/package-info.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * model\"}, a model of the declarations and types of the Java\n+ * model\"}, a reflective API that models the declarations and types of the Java\n@@ -55,0 +55,83 @@\n+ * <h2><a id=elementsAndTypes>Elements and Types<\/a><\/h2>\n+ *\n+ * <h3><a id=DefUse>Definitions and Uses<\/a><\/h3>\n+ *\n+ * In broad terms the {@link javax.lang.model.element element} package\n+ * models the declarations, that is the <em>definitions<\/em>, of elements while\n+ * the {@link javax.lang.model.type type} package models <em>uses<\/em>\n+ * of types. In general, distinct uses can have individualized\n+ * information separate from the information associated with the\n+ * definition. In some sense, the information in the definition is\n+ * shared by all the uses.\n+\n+ * <p>For example, consider the uses of {@code\n+ * java.lang.String} in the string processing method {@code\n+ * identityOrEmpty} below:\n+ *\n+ * {@snippet lang=java :\n+ * \/\/ Return the argument if it is non-null and the empty string otherwise.\n+ * public static @DefinitelyNotNull String identityOrEmpty(@MightBeNull String argument) {\n+ *    ...\n+ * }\n+ * }\n+ *\n+ * The return type of the method is a {@code String} annotated with\n+ * a {@code @DefinitelyNotNull} type annotation while the type of\n+ * the parameter is a {@code String} annotated with a {@code\n+ * @MightBeNull} type annotation. In a reflective API, since the set\n+ * of annotations is different for the two <em>uses<\/em> of {@code\n+ * String} as a type, the return type and argument type would need to\n+ * be represented by different objects to distinguish between these two\n+ * cases. The <em>definition<\/em> of {@code java.lang.String} itself\n+ * is annotated with neither of the type annotations in question.\n+ *\n+ * <p>Another example, consider the declaration of the generic\n+ * interface (JLS {@jls 9.1.2}) {@code java.util.Set} which has one\n+ * type parameter. This declaration captures commonality between the\n+ * many parameterized types (JLS {@jls 4.5}) derived from that\n+ * declaration such as {@code java.util.Set<String>}, {@code\n+ * java.util.Set<E>}, {@code java.util.Set<?>}, and also the raw type\n+ * (JLS {@jls 4.8}) {@code java.util.Set}.\n+ *\n+ * <h3><a id=elementTypeMapping>Mapping between Elements and Types<\/a><\/h3>\n+ *\n+ * While distinct concepts, there are bidirectional (partial) mappings\n+ * between elements and types, between definitions and uses. For\n+ * example, roughly speaking, information that would be invariant for\n+ * all uses of a type can be retrieved from the element defining a\n+ * type. For example, consider a {@link\n+ * javax.lang.model.type.DeclaredType DeclaredType} type mirror\n+ * modeling a use of {@code java.lang.String}. Calling {@link\n+ * javax.lang.model.type.DeclaredType#asElement()} would return the\n+ * {@link javax.lang.model.element.TypeElement} for {@code\n+ * java.lang.String}. From the {@code TypeElement}, common information\n+ * such as {@linkplain\n+ * javax.lang.model.element.TypeElement#getSimpleName() name} and\n+ * {@linkplain javax.lang.model.element.TypeElement#getModifiers()\n+ * modifiers} can be retrieved.\n+ *\n+ * <p>All elements can be {@linkplain\n+ * javax.lang.model.element.Element#asType() mapped to} some type.\n+ * The elements for classes and interfaces get {@linkplain\n+ * javax.lang.model.element.TypeElement#asType() mapped to} a\n+ * prototypical type.  (If a class or interface is generic, its\n+ * prototypical type mirror is parameterized with type arguments\n+ * matching the type variables of the declaration, all\n+ * unannotated. Otherwise, for a non-generic class or interface, the\n+ * prototypical type mirror corresponds to an unannotated use of the\n+ * type.)  Conversely, in general, many types can map to the same\n+ * {@linkplain javax.lang.model.element.TypeElement type element}. For\n+ * example, the type mirror for the raw type {@code java.util.Set},\n+ * the prototypical type {@code java.util.Set<E>}, and the type {@code\n+ * java.util.Set<String>} would all {@linkplain\n+ * javax.lang.model.type.DeclaredType#asElement() map to} the type\n+ * element for {@code java.util.Set}. Several kinds of types can be\n+ * mapped to elements, but other kinds of types do <em>not<\/em> have\n+ * an {@linkplain javax.lang.model.util.Types#asElement(TypeMirror)\n+ * element mapping}.  For example, the type mirror of an {@linkplain\n+ * javax.lang.model.type.ExecutableType executable type} does\n+ * <em>not<\/em> have an element mapping while a {@linkplain\n+ * javax.lang.model.type.DeclaredType declared type} would map to a\n+ * {@linkplain javax.lang.model.element.TypeElement type element}, as\n+ * discussed above.\n+ *\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/package-info.java","additions":85,"deletions":2,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+ * @see javax.lang.model##elementsAndTypes Elements and Types\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/type\/package-info.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}