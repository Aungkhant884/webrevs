{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,0 +55,101 @@\n+ * <h2><a id=elementsAndTypes>Elements and Types<\/a><\/h2>\n+ *\n+ * <h3><a id=DefUse>Definitions and Uses<\/a><\/h3>\n+ *\n+ * In broad terms the {@link javax.lang.model.element element} package\n+ * models the declarations, <em>definitions<\/em>, of elements while\n+ * the {@link javax.lang.model.type type} package models <em>uses<\/em>\n+ * of types. In general, distinct uses can have individualized\n+ * information separate from the information associated with the\n+ * definition. For example, consider the uses of {@code\n+ * java.lang.String} in the string processing method {@code\n+ * identityOrEmpty} below:\n+ *\n+ * {@snippet lang=java :\n+ * \/\/ Return the argument if it is non-null and the empty string otherwise.\n+ * public static @DefinitelyNotNull String identityOrEmpty(@MightBeNull String argument) {\n+ *    ...\n+ * }\n+ * }\n+ *\n+ * The return type of the method is a {@code String} annotated with\n+ * a {@code @DefinitelyNotNull} type annotation while the type of\n+ * the parameter is a {@code String} annotated with a {@code\n+ * @MightBeNull} type annotation. In a reflective API, since the set\n+ * of annotations is different for the two <em>uses<\/em> of {@code\n+ * String} as a type, the return type and argument type would need to\n+ * be represented by different objects to distinguish between these two\n+ * cases. The <em>definition<\/em> of {@code java.lang.String} itself\n+ * is annotated with neither of the type annotations in question.\n+ *\n+ * <p>Due to the {@code javax.lang.model} API already including a\n+ * separation between definitions ({@link javax.lang.model.element})\n+ * and uses ({@link javax.lang.model.type}), adding support for type\n+ * annotations as a language feature in the API was straightforward:\n+ *\n+ * <ul>\n+ *\n+ * <li>Existing annotation-reading methods were pulled out of {@link\n+ * javax.lang.model.element.Element} into a new interface, {@link\n+ * AnnotatedConstruct}.\n+ *\n+ * <li>{@link javax.lang.model.element.Element} extended {@code\n+ * AnnotatedConstruct}, preserving the existing ability to read\n+ * declaration annotations.\n+ *\n+ * <li>{@link javax.lang.model.type.TypeMirror} was retrofitted to\n+ * extend {@code AnnotatedConstruct}, adding the ability to read type\n+ * annotations.\n+ *\n+ * <\/ul>\n+ *\n+ * In contrast, core reflection did <em>not<\/em> have a separation\n+ * between definition and usages for types, {@link java.lang.Class\n+ * java.lang.Class} is used for both purposes. When support for type\n+ * annotations was added to that API, a new interface hierarchy of\n+ * {@linkplain java.lang.reflect.AnnotatedType annotated types} needed\n+ * to be added, with separate interfaces to model {@linkplain\n+ * java.lang.reflect.AnnotatedArrayType arrays}, {@linkplain\n+ * java.lang.reflect.AnnotatedParameterizedType parameterized types},\n+ * {@linkplain java.lang.reflect.AnnotatedTypeVariable type\n+ * variables}, and {@linkplain java.lang.reflect.AnnotatedWildcardType\n+ * wildcards}. In addition, new methods returning these new annotated\n+ * type objects had to be added to {@code java.lang.Class}, {@code\n+ * java.lang.Method}, {@code java.lang.Constructor}, and elsewhere.\n+ *\n+ * <p> The core reflection updates to support type annotations needed\n+ * many more new interfaces and new methods compared to the {@code\n+ * javax.lang.model} changes because of the lack of separation between\n+ * the definition and use of a type. The {@linkplain\n+ * java.lang.reflect.AnnotatedType annotated type hierarchy} was\n+ * needed to provide the structure to support use-specific\n+ * information.\n+ *\n+ * <h3><a id=elementTypeMapping>Mapping between Elements and Types<\/a><\/h3>\n+ *\n+ * While distinct concepts, there are bidirectional (partial) mappings\n+ * between elements and types, between definitions and uses. For\n+ * example, roughly speaking, information that would be invariant for\n+ * all uses of a type can be retrieved from the element defining a\n+ * type. For example, consider a {@link\n+ * javax.lang.model.type.DeclaredType DeclaredType} type mirror\n+ * modeling a use of {@code java.lang.String}. Calling {@link\n+ * javax.lang.model.type.DeclaredType#asElement()} would return the\n+ * {@link javax.lang.model.element.TypeElement} for {@code\n+ * java.lang.String}. From the {@code TypeElement}, common information\n+ * such as {@linkplain\n+ * javax.lang.model.element.TypeElement#getSimpleName() name} and\n+ * {@linkplain javax.lang.model.element.TypeElement#getModifiers()\n+ * modifiers} can be retrieved.\n+ *\n+ * <p>All elements can be {@linkplain\n+ * javax.lang.model.element.Element#asType() mapped to} some type. For\n+ * classes and interfaces, their elements get {@linkplain\n+ * javax.lang.model.element.TypeElement#asType() mapped to} a\n+ * prototypical type. Conversely, in general, many types can map to a\n+ * given type element. For example, the type mirror for the raw type\n+ * {@code java.util.Set}, the prototypical type {@code\n+ * java.util.Set<E>}, and the type {@code java.util.Set<String>} would\n+ * all {@linkplain javax.lang.model.type.DeclaredType#asElement() map\n+ * to} the element for {@code java.util.Set}.\n+ *\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/package-info.java","additions":102,"deletions":1,"binary":false,"changes":103,"status":"modified"}]}