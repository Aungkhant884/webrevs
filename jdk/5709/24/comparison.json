{"files":[{"patch":"@@ -4000,1 +4000,4 @@\n-        private final Object a, b;\n+        @SuppressWarnings(\"serial\")\n+        private final Object a;\n+        @SuppressWarnings(\"serial\")\n+        private final Object b;\n@@ -4069,1 +4072,6 @@\n-        private final Object dst, a1, a2;\n+        @SuppressWarnings(\"serial\")\n+        private final Object dst;\n+        @SuppressWarnings(\"serial\")\n+        private final Object a1;\n+        @SuppressWarnings(\"serial\")\n+        private final Object  a2;\n@@ -4118,1 +4126,4 @@\n-        private final Object a, b;\n+        @SuppressWarnings(\"serial\")\n+        private final Object a;\n+        @SuppressWarnings(\"serial\")\n+        private final Object b;\n","filename":"src\/java.base\/share\/classes\/java\/util\/DualPivotQuicksort.java","additions":14,"deletions":3,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -74,0 +74,1 @@\n+    @SuppressWarnings(\"serial\") \/\/ Type of field is not Serializable\n","filename":"src\/java.rmi\/share\/classes\/sun\/rmi\/server\/UnicastRef.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -227,0 +227,8 @@\n+    \/\/ For serialization lint checking; may be moved elsewhere\n+    public final Type objectStreamFieldType;\n+    public final Type objectInputStreamType;\n+    public final Type objectOutputStreamType;\n+    public final Type ioExceptionType;\n+    public final Type objectStreamExceptionType;\n+    public final Type externalizableType;\n+\n@@ -593,0 +601,7 @@\n+        \/\/ For serialization lint checking; may be moved elsewhere\n+        objectStreamFieldType = enterClass(\"java.io.ObjectStreamField\");\n+        objectInputStreamType = enterClass(\"java.io.ObjectInputStream\");\n+        objectOutputStreamType = enterClass(\"java.io.ObjectOutputStream\");\n+        ioExceptionType = enterClass(\"java.io.IOException\");\n+        objectStreamExceptionType = enterClass(\"java.io.ObjectStreamException\");\n+        externalizableType = enterClass(\"java.io.Externalizable\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -32,0 +32,10 @@\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.Modifier;\n+import javax.lang.model.element.NestingKind;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.type.TypeMirror;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.util.ElementFilter;\n+import javax.lang.model.util.ElementKindVisitor14;\n@@ -2958,1 +2968,1 @@\n-                    isSerializable(clazztype)) {\n+                    rs.isSerializable(clazztype)) {\n@@ -3083,1 +3093,1 @@\n-            if (needsRecovery && isSerializable(pt())) {\n+            if (needsRecovery && rs.isSerializable(pt())) {\n@@ -3584,1 +3594,1 @@\n-                    isSerializable(pt());\n+                    rs.isSerializable(pt());\n@@ -5369,1 +5379,1 @@\n-                if (isSerializable(c.type)) {\n+                if (rs.isSerializable(c.type)) {\n@@ -5504,1 +5514,2 @@\n-        \/\/ Check for proper use of serialVersionUID\n+        \/\/ Check for proper use of serialVersionUID and other\n+        \/\/ serialization-related fields and methods\n@@ -5506,2 +5517,1 @@\n-                && isSerializable(c.type)\n-                && (c.flags() & (Flags.ENUM | Flags.INTERFACE)) == 0\n+                && rs.isSerializable(c.type)\n@@ -5509,1 +5519,1 @@\n-            checkSerialVersionUID(tree, c, env);\n+            chk.checkSerialStructure(tree, c);\n@@ -5530,53 +5540,0 @@\n-        \/** check if a type is a subtype of Serializable, if that is available. *\/\n-        boolean isSerializable(Type t) {\n-            try {\n-                syms.serializableType.complete();\n-            }\n-            catch (CompletionFailure e) {\n-                return false;\n-            }\n-            return types.isSubtype(t, syms.serializableType);\n-        }\n-\n-        \/** Check that an appropriate serialVersionUID member is defined. *\/\n-        private void checkSerialVersionUID(JCClassDecl tree, ClassSymbol c, Env<AttrContext> env) {\n-\n-            \/\/ check for presence of serialVersionUID\n-            VarSymbol svuid = null;\n-            for (Symbol sym : c.members().getSymbolsByName(names.serialVersionUID)) {\n-                if (sym.kind == VAR) {\n-                    svuid = (VarSymbol)sym;\n-                    break;\n-                }\n-            }\n-\n-            if (svuid == null) {\n-                if (!c.isRecord())\n-                    log.warning(LintCategory.SERIAL, tree.pos(), Warnings.MissingSVUID(c));\n-                return;\n-            }\n-\n-            \/\/ Check if @SuppressWarnings(\"serial\") is an annotation of serialVersionUID.\n-            \/\/ See JDK-8231622 for more information.\n-            Lint lint = env.info.lint.augment(svuid);\n-            if (lint.isSuppressed(LintCategory.SERIAL)) {\n-                return;\n-            }\n-\n-            \/\/ check that it is static final\n-            if ((svuid.flags() & (STATIC | FINAL)) !=\n-                (STATIC | FINAL))\n-                log.warning(LintCategory.SERIAL,\n-                        TreeInfo.diagnosticPositionFor(svuid, tree), Warnings.ImproperSVUID(c));\n-\n-            \/\/ check that it is long\n-            else if (!svuid.type.hasTag(LONG))\n-                log.warning(LintCategory.SERIAL,\n-                        TreeInfo.diagnosticPositionFor(svuid, tree), Warnings.LongSVUID(c));\n-\n-            \/\/ check constant\n-            else if (svuid.getConstValue() == null)\n-                log.warning(LintCategory.SERIAL,\n-                        TreeInfo.diagnosticPositionFor(svuid, tree), Warnings.ConstantSVUID(c));\n-        }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":18,"deletions":61,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.util.function.BiConsumer;\n@@ -74,0 +75,7 @@\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.TypeMirror;\n+import javax.lang.model.util.ElementFilter;\n+import javax.lang.model.util.ElementKindVisitor14;\n@@ -4345,0 +4353,694 @@\n+\n+    \/** check if a type is a subtype of Externalizable, if that is available. *\/\n+    boolean isExternalizable(Type t) {\n+        try {\n+            syms.externalizableType.complete();\n+        }\n+        catch (CompletionFailure e) {\n+            return false;\n+        }\n+        return types.isSubtype(t, syms.externalizableType);\n+    }\n+\n+    \/**\n+     * Check structure of serialization declarations.\n+     *\/\n+    public void checkSerialStructure(JCClassDecl tree, ClassSymbol c) {\n+        (new SerialTypeVisitor()).visit(c, tree);\n+    }\n+\n+    \/**\n+     * This visitor will warn if a serialization-related field or\n+     * method is declared in a suspicious or incorrect way. In\n+     * particular, it will warn for cases where the runtime\n+     * serialization mechanism will silently ignore a mis-declared\n+     * entity.\n+     *\n+     * Distinguished serialization-related fields and methods:\n+     *\n+     * Methods:\n+     *\n+     * private void writeObject(ObjectOutputStream stream) throws IOException\n+     * ANY-ACCESS-MODIFIER Object writeReplace() throws ObjectStreamException\n+     *\n+     * private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException\n+     * private void readObjectNoData() throws ObjectStreamException\n+     * ANY-ACCESS-MODIFIER Object readResolve() throws ObjectStreamException\n+     *\n+     * Fields:\n+     *\n+     * private static final long serialVersionUID\n+     * private static final ObjectStreamField[] serialPersistentFields\n+     *\n+     * Externalizable: methods defined on the interface\n+     * public void writeExternal(ObjectOutput) throws IOException\n+     * public void readExternal(ObjectInput) throws IOException\n+     *\/\n+    private class SerialTypeVisitor extends ElementKindVisitor14<Void, JCClassDecl> {\n+        SerialTypeVisitor() {\n+            this.lint = Check.this.lint;\n+        }\n+\n+        private static final Set<String> serialMethodNames =\n+            Set.of(\"writeObject\", \"writeReplace\",\n+                   \"readObject\",  \"readObjectNoData\",\n+                   \"readResolve\");\n+\n+        private static final Set<String> serialFieldNames =\n+            Set.of(\"serialVersionUID\", \"serialPersistentFields\");\n+\n+        \/\/ Type of serialPersistentFields\n+        private final Type OSF_TYPE = new Type.ArrayType(syms.objectStreamFieldType, syms.arrayClass);\n+\n+        Lint lint;\n+\n+        @Override\n+        public Void defaultAction(Element e, JCClassDecl p) {\n+            throw new IllegalArgumentException(Objects.requireNonNullElse(e.toString(), \"\"));\n+        }\n+\n+        @Override\n+        public Void visitType(TypeElement e, JCClassDecl p) {\n+            runUnderLint(e, p, (symbol, param) -> super.visitType(symbol, param));\n+            return null;\n+        }\n+\n+        @Override\n+        public Void visitTypeAsClass(TypeElement e,\n+                                     JCClassDecl p) {\n+            \/\/ Anonymous classes filtered out by caller.\n+\n+            ClassSymbol c = (ClassSymbol)e;\n+\n+            checkCtorAccess(p, c);\n+\n+            \/\/ Check for missing serialVersionUID; check *not* done\n+            \/\/ for enums or records.\n+            VarSymbol svuidSym = null;\n+            for (Symbol sym : c.members().getSymbolsByName(names.serialVersionUID)) {\n+                if (sym.kind == VAR) {\n+                    svuidSym = (VarSymbol)sym;\n+                    break;\n+                }\n+            }\n+\n+            if (svuidSym == null) {\n+                log.warning(LintCategory.SERIAL, p.pos(), Warnings.MissingSVUID(c));\n+            }\n+\n+            \/\/ Check for serialPersistentFields to gate checks for\n+            \/\/ non-serializable non-transient instance fields\n+            boolean serialPersistentFieldsPresent =\n+                    c.members()\n+                     .getSymbolsByName(names.serialPersistentFields, sym -> sym.kind == VAR)\n+                     .iterator()\n+                     .hasNext();\n+\n+            \/\/ Check declarations of serialization-related methods and\n+            \/\/ fields\n+            for(Symbol el : c.getEnclosedElements()) {\n+                runUnderLint(el, p, (enclosed, tree) -> {\n+                    String name = null;\n+                    switch(enclosed.getKind()) {\n+                    case FIELD -> {\n+                        if (!serialPersistentFieldsPresent) {\n+                            var flags = enclosed.flags();\n+                            if ( ((flags & TRANSIENT) == 0) &&\n+                                 ((flags & STATIC) == 0)) {\n+                                Type varType = enclosed.asType();\n+                                if (!canBeSerialized(varType)) {\n+                                    \/\/ Note per JLS arrays are\n+                                    \/\/ serializable even if the\n+                                    \/\/ component type is not.\n+                                    log.warning(LintCategory.SERIAL,\n+                                                TreeInfo.diagnosticPositionFor(enclosed, tree),\n+                                                Warnings.NonSerializableInstanceField);\n+                                } else if (varType.hasTag(ARRAY)) {\n+                                    ArrayType arrayType = (ArrayType)varType;\n+                                    Type elementType = arrayType.elemtype;\n+                                    while (elementType.hasTag(ARRAY)) {\n+                                        arrayType = (ArrayType)elementType;\n+                                        elementType = arrayType.elemtype;\n+                                    }\n+                                    if (!canBeSerialized(elementType)) {\n+                                        log.warning(LintCategory.SERIAL,\n+                                                    TreeInfo.diagnosticPositionFor(enclosed, tree),\n+                                                    Warnings.NonSerializableInstanceFieldArray(elementType));\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                        name = enclosed.getSimpleName().toString();\n+                        if (serialFieldNames.contains(name)) {\n+                            VarSymbol field = (VarSymbol)enclosed;\n+                            switch (name) {\n+                            case \"serialVersionUID\"       ->  checkSerialVersionUID(tree, e, field);\n+                            case \"serialPersistentFields\" ->  checkSerialPersistentFields(tree, e, field);\n+                            default -> throw new AssertionError();\n+                            }\n+                        }\n+                    }\n+\n+                    \/\/ Correctly checking the serialization-related\n+                    \/\/ methods is subtle. For the methods declared to be\n+                    \/\/ private or directly declared in the class, the\n+                    \/\/ enclosed elements of the class can be checked in\n+                    \/\/ turn. However, writeReplace and readResolve can be\n+                    \/\/ declared in a superclass and inherited. Note that\n+                    \/\/ the runtime lookup walks the superclass chain\n+                    \/\/ looking for writeReplace\/readResolve via\n+                    \/\/ Class.getDeclaredMethod. This differs from calling\n+                    \/\/ Elements.getAllMembers(TypeElement) as the latter\n+                    \/\/ will also pull in default methods from\n+                    \/\/ superinterfaces. In other words, the runtime checks\n+                    \/\/ (which long predate default methods on interfaces)\n+                    \/\/ do not admit the possibility of inheriting methods\n+                    \/\/ this way, a difference from general inheritance.\n+\n+                    \/\/ The current implementation just checks the enclosed\n+                    \/\/ elements and does not directly check the inherited\n+                    \/\/ methods. If all the types are being checked this is\n+                    \/\/ less of a concern; however, there are cases that\n+                    \/\/ could be missed. In particular, readResolve and\n+                    \/\/ writeReplace could, in principle, by inherited from\n+                    \/\/ a non-serializable superclass and thus not checked\n+                    \/\/ even if compiled with a serializable child class.\n+                    case METHOD -> {\n+                        var method = (MethodSymbol)enclosed;\n+                        name = method.getSimpleName().toString();\n+                        if (serialMethodNames.contains(name)) {\n+                            switch (name) {\n+                            case \"writeObject\"      -> checkWriteObject(tree, e, method);\n+                            case \"writeReplace\"     -> checkWriteReplace(tree,e, method);\n+                            case \"readObject\"       -> checkReadObject(tree,e, method);\n+                            case \"readObjectNoData\" -> checkReadObjectNoData(tree, e, method);\n+                            case \"readResolve\"      -> checkReadResolve(tree, e, method);\n+                            default ->  throw new AssertionError();\n+                            }\n+                        }\n+                    }\n+                    }\n+                });\n+            }\n+\n+            return null;\n+        }\n+\n+        boolean canBeSerialized(Type type) {\n+            return type.isPrimitive() || rs.isSerializable(type);\n+        }\n+\n+        \/**\n+         * Check that Externalizable class needs a public no-arg\n+         * constructor.\n+         *\n+         * Check that a Serializable class has access to the no-arg\n+         * constructor of its first nonserializable superclass.\n+         *\/\n+        private void checkCtorAccess(JCClassDecl tree, ClassSymbol c) {\n+            if (isExternalizable(c.type)) {\n+                for(var sym : c.getEnclosedElements()) {\n+                    if (sym.isConstructor() &&\n+                        ((sym.flags() & PUBLIC) == PUBLIC)) {\n+                        if (((MethodSymbol)sym).getParameters().isEmpty()) {\n+                            return;\n+                        }\n+                    }\n+                }\n+                log.warning(LintCategory.SERIAL, tree.pos(),\n+                            Warnings.ExternalizableMissingPublicNoArgCtor);\n+\n+            } else {\n+                \/\/ Approximate access to the no-arg constructor up in\n+                \/\/ the superclass chain by checking that the\n+                \/\/ constructor is not private. This may not handle\n+                \/\/ some cross-package situations correctly.\n+                Type superClass = c.getSuperclass();\n+                \/\/ java.lang.Object is *not* Serializable so this loop\n+                \/\/ should terminate.\n+                \/\/ TOOD: checking needed for error types?\n+                while (rs.isSerializable(superClass) ) {\n+                    try {\n+                        superClass = (Type)((TypeElement)(((DeclaredType)superClass)).asElement()).getSuperclass();\n+                    } catch(ClassCastException cce) {\n+                        return ; \/\/ Don't try to recover\n+                    }\n+                }\n+                \/\/ Non-Serializable super class\n+                try {\n+                    ClassSymbol supertype = ((ClassSymbol)(((DeclaredType)superClass).asElement()));\n+                    for(var sym : supertype.getEnclosedElements()) {\n+                        if (sym.isConstructor()) {\n+                            MethodSymbol ctor = (MethodSymbol)sym;\n+                            if (ctor.getParameters().isEmpty()) {\n+                                if (((ctor.flags() & PRIVATE) == PRIVATE) ||\n+                                    \/\/ Handle nested classes and implicit this$0\n+                                    (supertype.getNestingKind() == NestingKind.MEMBER &&\n+                                     ((supertype.flags() & STATIC) == 0)))\n+                                    log.warning(LintCategory.SERIAL, tree.pos(),\n+                                                Warnings.SerializableMissingAccessNoArgCtor(supertype.getQualifiedName()));\n+                            }\n+                        }\n+                    }\n+                } catch (ClassCastException cce) {\n+                    return ; \/\/ Don't try to recover\n+                }\n+                return;\n+            }\n+        }\n+\n+        private void checkSerialVersionUID(JCClassDecl tree, Element e, VarSymbol svuid) {\n+            \/\/ To be effective, serialVersionUID must be marked static\n+            \/\/ and final, but private is recommended. But alas, in\n+            \/\/ practice there are many non-private serialVersionUID\n+            \/\/ fields.\n+             if ((svuid.flags() & (STATIC | FINAL)) !=\n+                 (STATIC | FINAL)) {\n+                 log.warning(LintCategory.SERIAL,\n+                             TreeInfo.diagnosticPositionFor(svuid, tree),\n+                             Warnings.ImproperSVUID((Symbol)e));\n+             }\n+\n+             \/\/ check svuid has type long\n+             if (!svuid.type.hasTag(LONG)) {\n+                 log.warning(LintCategory.SERIAL,\n+                             TreeInfo.diagnosticPositionFor(svuid, tree),\n+                             Warnings.LongSVUID((Symbol)e));\n+             }\n+\n+             if (svuid.getConstValue() == null)\n+                 log.warning(LintCategory.SERIAL,\n+                            TreeInfo.diagnosticPositionFor(svuid, tree),\n+                             Warnings.ConstantSVUID((Symbol)e));\n+        }\n+\n+        private void checkSerialPersistentFields(JCClassDecl tree, Element e, VarSymbol spf) {\n+            \/\/ To be effective, serialPersisentFields must be private, static, and final.\n+             if ((spf.flags() & (PRIVATE | STATIC | FINAL)) !=\n+                 (PRIVATE | STATIC | FINAL)) {\n+                 log.warning(LintCategory.SERIAL,\n+                             TreeInfo.diagnosticPositionFor(spf, tree), Warnings.ImproperSPF);\n+             }\n+\n+             if (!types.isSameType(spf.type, OSF_TYPE)) {\n+                 log.warning(LintCategory.SERIAL,\n+                             TreeInfo.diagnosticPositionFor(spf, tree), Warnings.OSFArraySPF);\n+             }\n+\n+            if (isExternalizable((Type)(e.asType()))) {\n+                log.warning(LintCategory.SERIAL, tree.pos(),\n+                            Warnings.IneffectualSerialFieldExternalizable);\n+            }\n+\n+            \/\/ Warn if serialPersistentFields is initialized to a\n+            \/\/ literal null.\n+            JCTree spfDecl = TreeInfo.declarationFor(spf, tree);\n+            if (spfDecl != null && spfDecl.getTag() == VARDEF) {\n+                JCVariableDecl variableDef = (JCVariableDecl) spfDecl;\n+                JCExpression initExpr = variableDef.init;\n+                 if (initExpr != null && TreeInfo.isNull(initExpr)) {\n+                     log.warning(LintCategory.SERIAL, initExpr.pos(),\n+                                 Warnings.SPFNullInit);\n+                 }\n+            }\n+        }\n+\n+        \/*\n+         * Methods can have modifiers: public, protected, private,\n+         * abstract, static, final, synchronized, native, strictfp\n+         *\/\n+\n+        private void checkWriteObject(JCClassDecl tree, Element e, MethodSymbol method) {\n+            \/\/ The \"synchronized\" modifier is seen in the wild on\n+            \/\/ readObject and writeObject methods and is generally\n+            \/\/ innocuous.\n+\n+            \/\/ private void writeObject(ObjectOutputStream stream) throws IOException\n+            checkPrivateNonStaticMethod(tree, method);\n+            checkReturnType(tree, e, method, syms.voidType);\n+            checkOneArg(tree, e, method, syms.objectOutputStreamType);\n+            checkExceptions(tree, e, method, syms.ioExceptionType);\n+            checkExternalizable(tree, e, method);\n+        }\n+\n+        private void checkWriteReplace(JCClassDecl tree, Element e, MethodSymbol method) {\n+            \/\/ ANY-ACCESS-MODIFIER Object writeReplace() throws\n+            \/\/ ObjectStreamException\n+\n+            \/\/ Excluding abstract, could have a more complicated\n+            \/\/ rule based on abstract-ness of the class?\n+            checkConcreteInstanceMethod(tree, e, method);\n+            checkReturnType(tree, e, method, syms.objectType);\n+            checkNoArgs(tree, e, method);\n+            checkExceptions(tree, e, method, syms.objectStreamExceptionType);\n+        }\n+\n+        private void checkReadObject(JCClassDecl tree, Element e, MethodSymbol method) {\n+            \/\/ The \"synchronized\" modifier is seen in the wild on\n+            \/\/ readObject and writeObject methods and is generally\n+            \/\/ innocuous.\n+\n+            \/\/ private void readObject(ObjectInputStream stream)\n+            \/\/   throws IOException, ClassNotFoundException\n+            checkPrivateNonStaticMethod(tree, method);\n+            checkReturnType(tree, e, method, syms.voidType);\n+            checkOneArg(tree, e, method, syms.objectInputStreamType);\n+            checkExceptions(tree, e, method, syms.ioExceptionType, syms.classNotFoundExceptionType);\n+            checkExternalizable(tree, e, method);\n+        }\n+\n+        private void checkReadObjectNoData(JCClassDecl tree, Element e, MethodSymbol method) {\n+            \/\/ private void readObjectNoData() throws ObjectStreamException\n+            checkPrivateNonStaticMethod(tree, method);\n+            checkReturnType(tree, e, method, syms.voidType);\n+            checkNoArgs(tree, e, method);\n+            checkExceptions(tree, e, method, syms.objectStreamExceptionType);\n+            checkExternalizable(tree, e, method);\n+        }\n+\n+        private void checkReadResolve(JCClassDecl tree, Element e, MethodSymbol method) {\n+            \/\/ ANY-ACCESS-MODIFIER Object readResolve()\n+            \/\/ throws ObjectStreamException\n+\n+            \/\/ Excluding abstract, could have a more complicated\n+            \/\/ rule based on abstract-ness of the class?\n+            checkConcreteInstanceMethod(tree, e, method);\n+            checkReturnType(tree,e, method, syms.objectType);\n+            checkNoArgs(tree, e, method);\n+            checkExceptions(tree, e, method, syms.objectStreamExceptionType);\n+        }\n+\n+        void checkPrivateNonStaticMethod(JCClassDecl tree, MethodSymbol method) {\n+            var flags = method.flags();\n+            if ((flags & PRIVATE) == 0) {\n+                log.warning(LintCategory.SERIAL,\n+                            TreeInfo.diagnosticPositionFor(method, tree),\n+                            Warnings.SerialMethodNotPrivate(method.getSimpleName()));\n+            }\n+\n+            if ((flags & STATIC) != 0) {\n+                log.warning(LintCategory.SERIAL,\n+                            TreeInfo.diagnosticPositionFor(method, tree),\n+                            Warnings.SerialMethodStatic(method.getSimpleName()));\n+            }\n+        }\n+\n+        \/**\n+         * Per section 1.12 \"Serialization of Enum Constants\" of\n+         * the serialization specification, due to the special\n+         * serialization handling of enums, any writeObject,\n+         * readObject, writeReplace, and readResolve methods are\n+         * ignored as are serialPersistentFields and\n+         * serialVersionUID fields.\n+         *\/\n+        @Override\n+        public Void visitTypeAsEnum(TypeElement e,\n+                                    JCClassDecl p) {\n+            for(Element el : e.getEnclosedElements()) {\n+                runUnderLint(el, p, (enclosed, tree) -> {\n+                    String name = enclosed.getSimpleName().toString();\n+                    switch(enclosed.getKind()) {\n+                    case FIELD -> {\n+                        if (serialFieldNames.contains(name)) {\n+                            log.warning(LintCategory.SERIAL, tree.pos(),\n+                                        Warnings.IneffectualSerialFieldEnum(name));\n+                        }\n+                    }\n+\n+                    case METHOD -> {\n+                        if (serialMethodNames.contains(name)) {\n+                            log.warning(LintCategory.SERIAL, tree.pos(),\n+                                        Warnings.IneffectualSerialMethodEnum(name));\n+                        }\n+                    }\n+                    }\n+                });\n+            }\n+            return null;\n+        }\n+\n+        \/**\n+         * Serialization-related fields and methods on interfaces are ineffectual.\n+         *\/\n+        @Override\n+        public Void visitTypeAsInterface(TypeElement e,\n+                                         JCClassDecl p) {\n+            for(Element el : e.getEnclosedElements()) {\n+                runUnderLint(el, p, (enclosed, tree) -> {\n+                    String name = null;\n+                    switch(enclosed.getKind()) {\n+                    case FIELD -> {\n+                        var field = (VarSymbol)enclosed;\n+                        name = field.getSimpleName().toString();\n+                        switch(name) {\n+                        case \"serialPersistentFields\" -> {\n+                            log.warning(LintCategory.SERIAL,\n+                                        TreeInfo.diagnosticPositionFor(field, tree),\n+                                        Warnings.IneffectualSerialFieldInterface);\n+                        }\n+\n+                        case \"serialVersionUID\" -> {\n+                            checkSerialVersionUID(tree, e, field);\n+                        }\n+                        }\n+                    }\n+\n+                    case METHOD -> {\n+                        var method = (MethodSymbol)enclosed;\n+                        name = enclosed.getSimpleName().toString();\n+                        if (serialMethodNames.contains(name)) {\n+                            switch (name) {\n+                            case\n+                                \"readObject\",\n+                                \"readObjectNoData\",\n+                                \"writeObject\"      -> checkPrivateMethod(tree, e, method);\n+\n+                            case\n+                                \"writeReplace\",\n+                                \"readResolve\"      -> checkDefaultIneffective(tree, e, method);\n+\n+                            default ->  throw new AssertionError();\n+                            }\n+\n+                        }\n+                    }\n+                    }\n+                });\n+            }\n+\n+            return null;\n+        }\n+\n+        private void checkPrivateMethod(JCClassDecl tree,\n+                                        Element e,\n+                                        MethodSymbol method) {\n+            if ((method.flags() & PRIVATE) == 0) {\n+                log.warning(LintCategory.SERIAL,\n+                            TreeInfo.diagnosticPositionFor(method, tree),\n+                            Warnings.NonPrivateMethodWeakerAccess);\n+            }\n+        }\n+\n+        private void checkDefaultIneffective(JCClassDecl tree,\n+                                             Element e,\n+                                             MethodSymbol method) {\n+            if ((method.flags() & DEFAULT) == DEFAULT) {\n+                log.warning(LintCategory.SERIAL,\n+                            TreeInfo.diagnosticPositionFor(method, tree),\n+                            Warnings.DefaultIneffective);\n+\n+            }\n+        }\n+\n+        @Override\n+        public Void visitTypeAsAnnotationType(TypeElement e,\n+                                              JCClassDecl p) {\n+            \/\/ Per the JLS, annotation types are not serializeable\n+            return null;\n+        }\n+\n+        \/**\n+         * From the Java Object Serialization Specification, 1.13\n+         * Serialization of Records:\n+         *\n+         * \"The process by which record objects are serialized or\n+         * externalized cannot be customized; any class-specific\n+         * writeObject, readObject, readObjectNoData, writeExternal,\n+         * and readExternal methods defined by record classes are\n+         * ignored during serialization and deserialization. However,\n+         * a substitute object to be serialized or a designate\n+         * replacement may be specified, by the writeReplace and\n+         * readResolve methods, respectively. Any\n+         * serialPersistentFields field declaration is\n+         * ignored. Documenting serializable fields and data for\n+         * record classes is unnecessary, since there is no variation\n+         * in the serial form, other than whether a substitute or\n+         * replacement object is used. The serialVersionUID of a\n+         * record class is 0L unless explicitly declared. The\n+         * requirement for matching serialVersionUID values is waived\n+         * for record classes.\"\n+         *\/\n+        @Override\n+        public Void visitTypeAsRecord(TypeElement e,\n+                                      JCClassDecl p) {\n+            for(Element el : e.getEnclosedElements()) {\n+                runUnderLint(el, p, (enclosed, tree) -> {\n+                    String name = enclosed.getSimpleName().toString();\n+                    switch(enclosed.getKind()) {\n+                    case FIELD -> {\n+                        switch(name) {\n+                        case \"serialPersistentFields\" -> {\n+                            log.warning(LintCategory.SERIAL, tree.pos(),\n+                                        Warnings.IneffectualSerialFieldRecord);\n+                        }\n+\n+                        case \"serialVersionUID\" -> {\n+                            \/\/ TODO: Extra warning that svuid value not\n+                            \/\/ checked to match for records?\n+                            checkSerialVersionUID(tree, e, (VarSymbol)enclosed);\n+                        }\n+\n+                        }\n+                    }\n+\n+                    case METHOD -> {\n+                        var method = (MethodSymbol)enclosed;\n+                        switch(name) {\n+                        case \"writeReplace\" -> checkWriteReplace(tree, e, method);\n+                        case \"readResolve\"  -> checkReadResolve(tree, e, method);\n+                        default -> {\n+                            if (serialMethodNames.contains(name)) {\n+                                log.warning(LintCategory.SERIAL, tree.pos(),\n+                                            Warnings.IneffectualSerialMethodRecord(name));\n+                            }\n+                        }\n+                        }\n+\n+                    }\n+                    }\n+                });\n+            }\n+            return null;\n+        }\n+\n+        void checkConcreteInstanceMethod(JCClassDecl tree,\n+                                         Element enclosing,\n+                                         MethodSymbol method) {\n+            if ((method.flags() & (STATIC | ABSTRACT)) != 0) {\n+                    log.warning(LintCategory.SERIAL,\n+                                TreeInfo.diagnosticPositionFor(method, tree),\n+                                Warnings.SerialConcreteInstanceMethod(method.getSimpleName()));\n+            }\n+        }\n+\n+        private void checkReturnType(JCClassDecl tree,\n+                                     Element enclosing,\n+                                     MethodSymbol method,\n+                                     Type expectedReturnType) {\n+            \/\/ Note: there may be complications checking writeReplace\n+            \/\/ and readResolve since they return Object and could, in\n+            \/\/ principle, have covariant overrides and any synthetic\n+            \/\/ bridge method would not be represented here for\n+            \/\/ checking.\n+            Type rtype = method.getReturnType();\n+            if (!types.isSameType(expectedReturnType, rtype)) {\n+                log.warning(LintCategory.SERIAL,\n+                            TreeInfo.diagnosticPositionFor(method, tree),\n+                            Warnings.SerialMethodUnexpectedReturnType(method.getSimpleName(),\n+                                                                      rtype, expectedReturnType));\n+            }\n+        }\n+\n+        private void checkOneArg(JCClassDecl tree,\n+                                 Element enclosing,\n+                                 MethodSymbol method,\n+                                 Type expectedType) {\n+            String name = method.getSimpleName().toString();\n+\n+            var parameters= method.getParameters();\n+\n+            if (parameters.size() != 1) {\n+                log.warning(LintCategory.SERIAL,\n+                            TreeInfo.diagnosticPositionFor(method, tree),\n+                            Warnings.SerialMethodOneArg(method.getSimpleName(), parameters.size()));\n+                return;\n+            }\n+\n+            Type parameterType = parameters.get(0).asType();\n+            if (!types.isSameType(parameterType, expectedType)) {\n+                log.warning(LintCategory.SERIAL,\n+                            TreeInfo.diagnosticPositionFor(method, tree),\n+                            Warnings.SerialMethodParameterType(method.getSimpleName(),\n+                                                               expectedType,\n+                                                               parameterType));\n+            }\n+        }\n+\n+        private void checkNoArgs(JCClassDecl tree, Element enclosing, MethodSymbol method) {\n+            var parameters= method.getParameters();\n+            if (!parameters.isEmpty()) {\n+                log.warning(LintCategory.SERIAL,\n+                            TreeInfo.diagnosticPositionFor(parameters.get(0), tree),\n+                            Warnings.SerialMethodNoArgs(method.getSimpleName()));\n+            }\n+        }\n+\n+        private void checkExternalizable(JCClassDecl tree, Element enclosing, MethodSymbol method) {\n+            \/\/if the enclosing class is externalizable, warn for the method\n+            if (isExternalizable((Type)enclosing.asType())) {\n+                log.warning(LintCategory.SERIAL, tree.pos(),\n+                            Warnings.IneffectualSerialMethodExternalizable(method.getSimpleName()));\n+            }\n+            return;\n+        }\n+\n+        private void checkExceptions(JCClassDecl tree,\n+                                     Element enclosing,\n+                                     MethodSymbol method,\n+                                     Type... declaredExceptions) {\n+            for (Type thrownType: method.getThrownTypes()) {\n+                \/\/ For each exception in the throws clause of the\n+                \/\/ method, if not an Error and not a RuntimeException,\n+                \/\/ check if the exception is a subtype of a declared\n+                \/\/ exception from the throws clause of the\n+                \/\/ serialization method in question.\n+                if (types.isSubtype(thrownType, syms.runtimeExceptionType) ||\n+                    types.isSubtype(thrownType, syms.errorType) ) {\n+                    continue;\n+                } else {\n+                    boolean declared = false;\n+                    for (Type declaredException : declaredExceptions) {\n+                        if (types.isSubtype(thrownType, declaredException)) {\n+                            declared = true;\n+                            continue;\n+                        }\n+                    }\n+                    if (!declared) {\n+                        log.warning(LintCategory.SERIAL,\n+                                    TreeInfo.diagnosticPositionFor(method, tree),\n+                                    Warnings.SerialMethodUnexpectedException(method.getSimpleName(),\n+                                                                             thrownType));\n+                    }\n+                }\n+            }\n+            return;\n+        }\n+\n+        private <E extends Element> Void runUnderLint(E symbol, JCClassDecl p, BiConsumer<E, JCClassDecl> task) {\n+            Lint prevLint = lint;\n+            try {\n+                lint = lint.augment((Symbol) symbol);\n+\n+                if (lint.isEnabled(LintCategory.SERIAL)) {\n+                    task.accept(symbol, p);\n+                }\n+\n+                return null;\n+            } finally {\n+                lint = prevLint;\n+            }\n+        }\n+\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":702,"deletions":0,"binary":false,"changes":702,"status":"modified"},{"patch":"@@ -3911,0 +3911,11 @@\n+    \/** check if a type is a subtype of Serializable, if that is available.*\/\n+    boolean isSerializable(Type t) {\n+        try {\n+            syms.serializableType.complete();\n+        }\n+        catch (CompletionFailure e) {\n+            return false;\n+        }\n+        return types.isSubtype(t, syms.serializableType);\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1849,0 +1849,8 @@\n+compiler.warn.improper.SPF=\\\n+    serialPersistentFields must be declared private static final to be effective\n+\n+compiler.warn.SPF.null.init=\\\n+    serialPersistentFields ineffective if initialized to null.\\n\\\n+    Initialize to an empty array to indicate no fields\n+\n+\n@@ -1869,0 +1877,3 @@\n+compiler.warn.OSF.array.SPF=\\\n+    serialPersistentFields must be of type java.io.ObjectStreamField[] to be effective\n+\n@@ -1873,0 +1884,79 @@\n+# 0: name\n+compiler.warn.serializable.missing.access.no.arg.ctor=\\\n+    cannot access a no-arg constructor in first non-serializable superclass {0}\n+\n+# 0: name\n+compiler.warn.serial.method.not.private=\\\n+    serialization-related method {0} not declared private\n+\n+# 0: name\n+compiler.warn.serial.concrete.instance.method=\\\n+    serialization-related method {0} must be a concrete instance method to be effective, neither abstract nor static\n+\n+# 0: name\n+compiler.warn.serial.method.static=\\\n+    serialization-related method {0} declared static; must instead be an instance method to be effective\n+\n+# 0: name\n+compiler.warn.serial.method.no.args=\\\n+    to be effective serialization-related method {0} must have no parameters\n+\n+# 0: name, 1: number\n+compiler.warn.serial.method.one.arg=\\\n+    to be effective serialization-related method {0} must have exactly one parameter rather than {1} parameters\n+\n+# 0: name, 1: type, 2: type\n+compiler.warn.serial.method.parameter.type=\\\n+    sole parameter of serialization-related method {0} must have type {1} to be effective rather than type {2}\n+\n+# 0: name, 1: type, 2: type\n+compiler.warn.serial.method.unexpected.return.type=\\\n+    serialization-related method {0} declared with a return type of {1} rather than expected type {2}.\\n\\\n+    As declared, the method will be ineffective for serialization\n+\n+# 0: name, 1: type\n+compiler.warn.serial.method.unexpected.exception=\\\n+    serialization-related method {0} declared to throw an unexpected type {1}\n+\n+compiler.warn.ineffectual.serial.field.interface=\\\n+    serialPersistentFields is not effective in an interface\n+\n+# 0: string\n+compiler.warn.ineffectual.serial.field.enum=\\\n+     serialization-related field {0} is not effective in an enum class\n+\n+# 0: string\n+compiler.warn.ineffectual.serial.method.enum=\\\n+    serialization-related method {0} is not effective in an enum class\n+\n+compiler.warn.ineffectual.serial.field.record=\\\n+    serialPersistentFields is not effective in a record class\n+\n+# 0: string\n+compiler.warn.ineffectual.serial.method.record=\\\n+    serialization-related method {0} is ineffectual in a record class\n+\n+# 0: name\n+compiler.warn.ineffectual.serial.method.externalizable=\\\n+    serialization-related method {0} is not effective in an Externalizable class\n+\n+compiler.warn.ineffectual.serial.field.externalizable=\\\n+    serialPersistentFields is not effective in an Externalizable class\n+\n+compiler.warn.externalizable.missing.public.no.arg.ctor=\\\n+    an Externalizable class needs a public no-arg constructor\n+\n+compiler.warn.non.serializable.instance.field=\\\n+    non-transient instance field of a serializable class declared with a non-serializable type\n+\n+# 0: type\n+compiler.warn.non.serializable.instance.field.array=\\\n+    non-transient instance field of a serializable class declared with an array having a non-serializable base component type {0}\n+\n+compiler.warn.non.private.method.weaker.access=\\\n+    serialization-related method declared non-private in an interface will prevent\\n\\\n+    classes implementing the interface from declaring the method as private\n+\n+compiler.warn.default.ineffective=\\\n+    serialization-related default method from an interface will not be run by serialization for an implementing class\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":90,"deletions":0,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -243,2 +243,2 @@\n-    Warn about Serializable classes that do not provide a serial version ID. \\n\\\n-\\                         Also warn about access to non-public members from a serializable element.\n+    Warn about Serializable classes that do not have a serialVersionUID field. \\n\\\n+\\                         Also warn about other suspect declarations in Serializable and Externalizable classes and interfaces.\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/javac.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -79,0 +79,1 @@\n+    @SuppressWarnings(\"serial\")\n","filename":"src\/jdk.internal.opt\/share\/classes\/jdk\/internal\/joptsimple\/OptionException.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -103,0 +103,1 @@\n+        @SuppressWarnings(\"serial\") \/\/ not statically serializable\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/ConstantPool.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2009, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,0 +46,1 @@\n+    @SuppressWarnings(\"serial\") \/\/ Array component type is not Serializable\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/InternalError.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -96,0 +96,1 @@\n+        @SuppressWarnings(\"serial\") \/\/ Array component type is not Serializable\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/JavapTask.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,0 +66,1 @@\n+        @SuppressWarnings(\"serial\") \/\/ Array component type is not Serializable\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jdeps\/JdepsTask.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+    @SuppressWarnings(\"serial\") \/\/ Array component type is not Serializable\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jdeps\/MultiReleaseException.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.warn.improper.SPF\n+\/\/ key: compiler.warn.OSF.array.SPF\n+\/\/ key: compiler.warn.SPF.null.init\n+\n+\/\/ options: -Xlint:serial\n+\n+import java.io.Serializable;\n+\n+class ImproperSPF implements Serializable {\n+    \/\/ Proper declaration of serialPersistentFields is:\n+    \/\/ private static final ObjectStreamField[] serialPersistentFields = ...\n+    public \/*instance*\/ Object serialPersistentFields = null;\n+\n+    private static final long serialVersionUID = 42;\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ImproperSPF.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -25,0 +25,3 @@\n+\/\/ key: compiler.warn.constant.SVUID\n+\/\/ key: compiler.warn.long.SVUID\n+\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ImproperSVUID.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.warn.ineffectual.serial.field.enum\n+\/\/ key: compiler.warn.ineffectual.serial.method.enum\n+\n+\/\/ options: -Xlint:serial\n+\n+import java.io.*;\n+\n+enum IneffectualSerialEnum implements Serializable {\n+    INSTANCE;\n+\n+    \/\/ The serialVersionUID field is ineffectual for enum classes.\n+    private static final long serialVersionUID = 42;\n+\n+    \/\/ The readObject method is ineffectual for enum classes.\n+    private void readObject(ObjectInputStream stream)\n+        throws IOException, ClassNotFoundException {\n+        stream.defaultReadObject();\n+        return;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/IneffectualSerialEnum.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.warn.ineffectual.serial.method.externalizable\n+\/\/ key: compiler.warn.ineffectual.serial.field.externalizable\n+\/\/ key: compiler.warn.externalizable.missing.public.no.arg.ctor\n+\n+\/\/ options: -Xlint:serial\n+\n+import java.io.*;\n+\n+class IneffectualSerialExtern implements Externalizable {\n+    private static final long serialVersionUID = 42;\n+\n+    \/\/ Must have a public no-arg constructor\n+    public IneffectualSerialExtern(int foo) {}\n+\n+    public void writeExternal(ObjectOutput out) throws IOException {\n+        return;\n+    }\n+\n+    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n+        return;\n+    }\n+\n+    \/\/ ineffectual\n+    private static final ObjectStreamField[] serialPersistentFields = {};\n+\n+    \/\/ The readObject method is ineffectual for Externalizable classes.\n+    private void readObject(ObjectInputStream stream)\n+        throws IOException, ClassNotFoundException {\n+        stream.defaultReadObject();\n+        return;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/IneffectualSerialExtern.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.warn.ineffectual.serial.field.record\n+\/\/ key: compiler.warn.ineffectual.serial.method.record\n+\n+\/\/ options: -Xlint:serial\n+\n+import java.io.*;\n+\n+record IneffectualSerialRecord(int foo) implements Serializable {\n+\n+    \/\/ A serialPersistentFields is ineffectual for enum classes.\n+    private static final ObjectStreamField[] serialPersistentFields = {};\n+\n+    \/\/ The readObject method is ineffectual for record classes.\n+    private void readObject(ObjectInputStream stream)\n+        throws IOException, ClassNotFoundException {\n+        stream.defaultReadObject();\n+        return;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/IneffectualSerialRecord.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.warn.non.private.method.weaker.access\n+\/\/ key: compiler.warn.default.ineffective\n+\/\/ key: compiler.warn.ineffectual.serial.field.interface\n+\n+\/\/ options: -Xlint:serial\n+\n+import java.io.*;\n+\n+interface SerialInterfaceMethodsAndFields extends Serializable {\n+    public static final ObjectStreamField[] serialPersistentFields = {};\n+    public void readObject(ObjectInputStream stream)\n+        throws IOException, ClassNotFoundException;\n+    public void readObjectNoData() throws ObjectStreamException;\n+    public void writeObject(ObjectOutputStream stream) throws IOException;\n+\n+    default public Object readResolve() throws ObjectStreamException {\n+        return null;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/SerialInterfaceMethodsAndFields.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.warn.serializable.missing.access.no.arg.ctor\n+\/\/ key: compiler.warn.non.serializable.instance.field\n+\/\/ key: compiler.warn.non.serializable.instance.field.array\n+\n+\/\/ options: -Xlint:serial\n+\n+import java.io.*;\n+\n+class SerialMissingNoArgCtor {\n+    public SerialMissingNoArgCtor(int foo) {\n+    }\n+\n+    \/\/ Not accessible to SerialSubclass\n+    private SerialMissingNoArgCtor() {}\n+\n+    \/\/ SerialSubclass does not have access to a non-arg ctor in the\n+    \/\/ first non-serializable superclass in its superclass chain.\n+    static class SerialSubclass extends SerialMissingNoArgCtor\n+        implements Serializable {\n+\n+        private static final long serialVersionUID = 42;\n+\n+        \/\/ non-serializable non-transient instance field\n+        private Object datum = null;\n+\n+        \/\/ base component type of array is non-serializable\n+        private Object[] data = null;\n+\n+        public SerialSubclass() {\n+            super(1);\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/SerialMissingNoArgCtor.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.warn.serial.method.not.private\n+\/\/ key: compiler.warn.serial.method.static\n+\/\/ key: compiler.warn.serial.method.unexpected.return.type\n+\/\/ key: compiler.warn.serial.concrete.instance.method\n+\/\/ key: compiler.warn.serial.method.one.arg\n+\/\/ key: compiler.warn.serial.method.parameter.type\n+\/\/ key: compiler.warn.serial.method.no.args\n+\/\/ key: compiler.warn.serial.method.unexpected.exception\n+\n+\/\/ options: -Xlint:serial\n+\n+import java.io.*;\n+\n+\n+abstract class SerialNonPrivateMethod implements Serializable {\n+    private static final long serialVersionUID = 42;\n+\n+    private static class CustomObjectOutputStream extends ObjectOutputStream {\n+        public CustomObjectOutputStream() throws IOException,\n+                                                 SecurityException {}\n+    }\n+\n+    \/\/ Should be private and have a single argument of type\n+    \/\/ ObjectOutputStream\n+    void writeObject(CustomObjectOutputStream stream) throws IOException {\n+        stream.defaultWriteObject();\n+    }\n+\n+    \/\/ Should be private non-static and have one argument\n+    private static void readObject(ObjectInputStream stream, int retries)\n+        throws IOException, ClassNotFoundException {\n+        stream.defaultReadObject();\n+    }\n+\n+    \/\/ Should return void\n+    private int readObjectNoData() throws ObjectStreamException {\n+        return 42;\n+    }\n+\n+    \/\/ Should be concrete instance method\n+    public abstract Object writeReplace() throws ObjectStreamException;\n+\n+    \/\/ Should have no arguments and throw ObjectStreamException\n+    \/*package*\/ Object readResolve(int foo)\n+        throws ReflectiveOperationException { \/\/ Checked exception\n+        return null;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/SerialNonPrivateMethod.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8202056\n+ * @compile\/ref=CtorAccess.out -XDrawDiagnostics -Xlint:serial CtorAccess.java\n+ *\/\n+\n+import java.io.*;\n+\n+class CtorAccess {\n+    public CtorAccess(int i) {}\n+\n+    \/\/ Cannot by accessed by SerialSubclass\n+    private CtorAccess(){}\n+\n+    static class SerialSubclass\n+        extends CtorAccess\n+        implements Serializable {\n+        private static final long serialVersionUID = 42;\n+        SerialSubclass() {\n+            super(42);\n+        }\n+    }\n+\n+    \/\/ *not* static\n+    class MemberSuper {\n+        \/\/ Implicit this$0 argument\n+        public MemberSuper() {}\n+    }\n+\n+    class SerialMemberSub\n+        extends MemberSuper\n+        implements Serializable {\n+\n+        SerialMemberSub(){super();}\n+        private static final long serialVersionUID = 42;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/warnings\/Serial\/CtorAccess.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,3 @@\n+CtorAccess.java:15:12: compiler.warn.serializable.missing.access.no.arg.ctor: CtorAccess\n+CtorAccess.java:30:5: compiler.warn.serializable.missing.access.no.arg.ctor: CtorAccess.MemberSuper\n+2 warnings\n","filename":"test\/langtools\/tools\/javac\/warnings\/Serial\/CtorAccess.out","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8202056\n+ * @compile\/ref=DeepNestingSuppression.out -XDrawDiagnostics -Xlint:serial DeepNestingSuppression.java\n+ *\/\n+\n+import java.io.Serializable;\n+\n+\/*\n+ * Verify suppressing serial warnings works through several levels of\n+ * nested types.\n+ *\/\n+class DeepNestingSuppression {\n+\n+    @SuppressWarnings(\"serial\")\n+    static class SuppressedOuter {\n+        static class Intermediate {\n+            static class Inner implements Serializable {\n+                \/\/ warning for int rather than long svuid\n+                private static final int serialVersionUID = 42;\n+            }\n+        }\n+    }\n+\n+    static class Outer {\n+        static class Intermediate {\n+            static class Inner implements Serializable {\n+                \/\/ warning for int rather than long svuid\n+                private static final int serialVersionUID = 42;\n+            }\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/warnings\/Serial\/DeepNestingSuppression.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+DeepNestingSuppression.java:29:42: compiler.warn.long.SVUID: DeepNestingSuppression.Outer.Intermediate.Inner\n+1 warning\n","filename":"test\/langtools\/tools\/javac\/warnings\/Serial\/DeepNestingSuppression.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8202056\n+ * @compile\/ref=EnumSerial.out -XDrawDiagnostics -Xlint:serial EnumSerial.java\n+ *\/\n+\n+import java.io.*;\n+\n+enum EnumSerial implements Serializable {\n+    INSTANCE;\n+\n+    \/\/ Verify a warning is generated in an enum class for each of the\n+    \/\/ distinguished serial fields and methods.\n+\n+    private static final long serialVersionUID = 42;\n+    private static final ObjectStreamField[] serialPersistentFields = {};\n+\n+    private void writeObject(ObjectOutputStream stream) throws IOException {\n+        stream.defaultWriteObject();\n+    }\n+\n+    private Object writeReplace() throws ObjectStreamException {\n+        return null;\n+    }\n+\n+    private void readObject(ObjectInputStream stream)\n+        throws IOException, ClassNotFoundException {\n+        stream.defaultReadObject();\n+    }\n+\n+    private void readObjectNoData() throws ObjectStreamException {\n+        return;\n+    }\n+\n+    private Object readResolve() throws ObjectStreamException {\n+        return null;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/warnings\/Serial\/EnumSerial.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,8 @@\n+EnumSerial.java:9:1: compiler.warn.ineffectual.serial.field.enum: serialVersionUID\n+EnumSerial.java:9:1: compiler.warn.ineffectual.serial.field.enum: serialPersistentFields\n+EnumSerial.java:9:1: compiler.warn.ineffectual.serial.method.enum: writeObject\n+EnumSerial.java:9:1: compiler.warn.ineffectual.serial.method.enum: writeReplace\n+EnumSerial.java:9:1: compiler.warn.ineffectual.serial.method.enum: readObject\n+EnumSerial.java:9:1: compiler.warn.ineffectual.serial.method.enum: readObjectNoData\n+EnumSerial.java:9:1: compiler.warn.ineffectual.serial.method.enum: readResolve\n+7 warnings\n","filename":"test\/langtools\/tools\/javac\/warnings\/Serial\/EnumSerial.out","additions":8,"deletions":0,"binary":false,"changes":8,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8202056\n+ * @compile\/ref=Extern.out -XDrawDiagnostics -Xlint:serial Extern.java\n+ *\/\n+\n+import java.io.*;\n+\n+class Extern implements Externalizable {\n+    private static final long serialVersionUID = 42;\n+\n+    \/\/ No-arg constructor on an Externalizable class must be public\n+    protected Extern() {}\n+\n+    \/\/ ineffectual\n+    private static final ObjectStreamField[] serialPersistentFields = {};\n+\n+    public void writeExternal(ObjectOutput out) throws IOException {\n+        return;\n+    }\n+\n+    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n+        return;\n+    }\n+\n+    \/\/ ineffectual\n+    private void readObject(ObjectInputStream stream)\n+        throws IOException, ClassNotFoundException {\n+        stream.defaultReadObject();\n+    }\n+\n+    \/\/ ineffectual\n+    private void writeObject(ObjectOutputStream stream) throws IOException {\n+        stream.defaultWriteObject();\n+    }\n+\n+    \/\/ ineffectual\n+    private void readObjectNoData() throws ObjectStreamException {\n+        return;\n+    }\n+\n+    \/\/ (possibly) effective\n+    private Object writeReplace() throws ObjectStreamException {\n+        return null;\n+    }\n+\n+    \/\/ (possibly) effective\n+    private Object readResolve() throws ObjectStreamException {\n+        return null;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/warnings\/Serial\/Extern.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,6 @@\n+Extern.java:9:1: compiler.warn.externalizable.missing.public.no.arg.ctor\n+Extern.java:9:1: compiler.warn.ineffectual.serial.field.externalizable\n+Extern.java:9:1: compiler.warn.ineffectual.serial.method.externalizable: readObject\n+Extern.java:9:1: compiler.warn.ineffectual.serial.method.externalizable: writeObject\n+Extern.java:9:1: compiler.warn.ineffectual.serial.method.externalizable: readObjectNoData\n+5 warnings\n","filename":"test\/langtools\/tools\/javac\/warnings\/Serial\/Extern.out","additions":6,"deletions":0,"binary":false,"changes":6,"status":"added"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8202056\n+ * @compile\/ref=ImproperReturnTypes.out -XDrawDiagnostics -Xlint:serial ImproperReturnTypes.java\n+ *\/\n+\n+import java.io.*;\n+\n+class ImproperReturnTypes implements Serializable {\n+    private static final long serialVersionUID = 42;\n+\n+    \/*\n+     * Serialization-related methods return either void or Object:\n+     *\n+     * private             void   writeObject(ObjectOutputStream stream) throws IOException\n+     * ANY-ACCESS-MODIFIER Object writeReplace() throws ObjectStreamException\n+     *\n+     * private             void   readObject(ObjectInputStream stream)\n+     *                            throws IOException, ClassNotFoundException\n+     * private             void   readObjectNoData() throws ObjectStreamException\n+     * ANY-ACCESS-MODIFIER Object readResolve() throws ObjectStreamException\n+     *\/\n+\n+    private int writeObject(ObjectOutputStream stream) throws IOException {\n+        stream.defaultWriteObject();\n+        return 0;\n+    }\n+\n+    private int writeReplace() throws ObjectStreamException {\n+        return 1;\n+    }\n+\n+    private int readObject(ObjectInputStream stream)\n+        throws IOException, ClassNotFoundException {\n+        stream.defaultReadObject();\n+        return 2;\n+    }\n+\n+    private int readObjectNoData() throws ObjectStreamException {\n+        return 3;\n+    }\n+\n+    private int readResolve() throws ObjectStreamException {\n+        return 4;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/warnings\/Serial\/ImproperReturnTypes.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -0,0 +1,6 @@\n+ImproperReturnTypes.java:24:17: compiler.warn.serial.method.unexpected.return.type: writeObject, int, void\n+ImproperReturnTypes.java:29:17: compiler.warn.serial.method.unexpected.return.type: writeReplace, int, java.lang.Object\n+ImproperReturnTypes.java:33:17: compiler.warn.serial.method.unexpected.return.type: readObject, int, void\n+ImproperReturnTypes.java:39:17: compiler.warn.serial.method.unexpected.return.type: readObjectNoData, int, void\n+ImproperReturnTypes.java:43:17: compiler.warn.serial.method.unexpected.return.type: readResolve, int, java.lang.Object\n+5 warnings\n","filename":"test\/langtools\/tools\/javac\/warnings\/Serial\/ImproperReturnTypes.out","additions":6,"deletions":0,"binary":false,"changes":6,"status":"added"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8202056\n+ * @compile\/ref=ImproperSerialPF.out -XDrawDiagnostics -Xlint:serial ImproperSerialPF.java\n+ *\/\n+\n+import java.io.*;\n+\n+class ImproperSerialPF implements Serializable {\n+    \/\/ Proper declaration of serialPersistentFields is:\n+    \/\/ private static final ObjectStreamField[] serialPersistentFields = ...\n+    public \/*instance*\/ Object serialPersistentFields = Boolean.TRUE;\n+\n+    private static final long serialVersionUID = 42;\n+\n+    static class LiteralNullSPF implements Serializable {\n+        private static final ObjectStreamField[] serialPersistentFields = null;\n+\n+        private static final long serialVersionUID = 42;\n+    }\n+\n+    \/\/ Casting obscures the simple syntactic null-check\n+    static class CastedNullSPF implements Serializable {\n+        private static final ObjectStreamField[] serialPersistentFields =\n+            (ObjectStreamField[])null;\n+\n+        private static final long serialVersionUID = 42;\n+    }\n+\n+    \/\/ Conditional obscures the simple syntactic null-check too\n+    static class ConditionalNullSPF implements Serializable {\n+        private static final ObjectStreamField[] serialPersistentFields =\n+            (true ? null : null);\n+\n+        private static final long serialVersionUID = 42;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/warnings\/Serial\/ImproperSerialPF.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,4 @@\n+ImproperSerialPF.java:17:75: compiler.warn.SPF.null.init\n+ImproperSerialPF.java:12:32: compiler.warn.improper.SPF\n+ImproperSerialPF.java:12:32: compiler.warn.OSF.array.SPF\n+3 warnings\n","filename":"test\/langtools\/tools\/javac\/warnings\/Serial\/ImproperSerialPF.out","additions":4,"deletions":0,"binary":false,"changes":4,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8202056\n+ * @compile\/ref=InstanceField.out -XDrawDiagnostics -Xlint:serial InstanceField.java\n+ *\/\n+\n+import java.io.*;\n+\n+class IntanceField implements Serializable {\n+    private static final long serialVersionUID = 42;\n+\n+    \/\/ Non-transient instance fields in a serializable class w\/o\n+    \/\/ serialPersistentFields defined should get warnings if the type\n+    \/\/ of the field cannot be serialized.\n+\n+    private Object foo;\n+\n+    private Object[] foos;\n+\n+    private Thread[][] ArrayOfArrayOfThreads;\n+\n+    \/\/ No warnings\n+\n+    private static Object bar;\n+\n+    private static Object[] bars;\n+\n+    private int baz;\n+\n+    private double[] quux;\n+\n+    static class NestedInstance implements Serializable {\n+        private static final long serialVersionUID = 24;\n+\n+        \/\/ Should disable instance field warnings\n+        private static final ObjectStreamField[] serialPersistentFields = {};\n+\n+        private Object foo;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/warnings\/Serial\/InstanceField.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,4 @@\n+InstanceField.java:16:20: compiler.warn.non.serializable.instance.field\n+InstanceField.java:18:22: compiler.warn.non.serializable.instance.field.array: java.lang.Object\n+InstanceField.java:20:24: compiler.warn.non.serializable.instance.field.array: java.lang.Thread\n+3 warnings\n","filename":"test\/langtools\/tools\/javac\/warnings\/Serial\/InstanceField.out","additions":4,"deletions":0,"binary":false,"changes":4,"status":"added"},{"patch":"@@ -0,0 +1,14 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8202056\n+ * @compile\/ref=InterfaceFields.out -XDrawDiagnostics -Xlint:serial InterfaceFields.java\n+ *\/\n+\n+import java.io.*;\n+\n+interface InterfaceFields extends Serializable {\n+    public static final int serialVersionUID = 12345;\n+\n+    public static final ObjectStreamField[] serialPersistentFields = {};\n+}\n+\n","filename":"test\/langtools\/tools\/javac\/warnings\/Serial\/InterfaceFields.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"added"},{"patch":"@@ -0,0 +1,3 @@\n+InterfaceFields.java:10:29: compiler.warn.long.SVUID: InterfaceFields\n+InterfaceFields.java:12:45: compiler.warn.ineffectual.serial.field.interface\n+2 warnings\n","filename":"test\/langtools\/tools\/javac\/warnings\/Serial\/InterfaceFields.out","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8202056\n+ * @compile\/ref=InterfaceNonPrivateMethods.out -XDrawDiagnostics -Xlint:serial InterfaceNonPrivateMethods.java\n+ *\/\n+\n+import java.io.*;\n+\n+\/\/ Holder class\n+class InterfaceNonPrivateMethods {\n+\n+    interface NonPrivateMethods extends Serializable {\n+        public void readObject(ObjectInputStream stream)\n+            throws IOException, ClassNotFoundException;\n+        public void readObjectNoData() throws ObjectStreamException;\n+        public void writeObject(ObjectOutputStream stream) throws IOException;\n+\n+        \/\/ Ineffective default methods; serialization only looks up\n+        \/\/ superclass chain\n+        public default Object writeReplace() throws ObjectStreamException {\n+            return null;\n+        }\n+        public default Object readResolve() throws ObjectStreamException {\n+            return null;\n+        }\n+    }\n+\n+    interface NonPrivateMethodsDefaults extends Serializable {\n+        default public void readObject(ObjectInputStream stream)\n+            throws IOException, ClassNotFoundException {\n+            return;\n+        }\n+        default public void readObjectNoData()\n+            throws ObjectStreamException {\n+            return;\n+        }\n+        default public void writeObject(ObjectOutputStream stream)\n+            throws IOException {\n+            return;\n+        }\n+    }\n+}\n+\n","filename":"test\/langtools\/tools\/javac\/warnings\/Serial\/InterfaceNonPrivateMethods.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,9 @@\n+InterfaceNonPrivateMethods.java:13:21: compiler.warn.non.private.method.weaker.access\n+InterfaceNonPrivateMethods.java:15:21: compiler.warn.non.private.method.weaker.access\n+InterfaceNonPrivateMethods.java:16:21: compiler.warn.non.private.method.weaker.access\n+InterfaceNonPrivateMethods.java:20:31: compiler.warn.default.ineffective\n+InterfaceNonPrivateMethods.java:23:31: compiler.warn.default.ineffective\n+InterfaceNonPrivateMethods.java:29:29: compiler.warn.non.private.method.weaker.access\n+InterfaceNonPrivateMethods.java:33:29: compiler.warn.non.private.method.weaker.access\n+InterfaceNonPrivateMethods.java:37:29: compiler.warn.non.private.method.weaker.access\n+8 warnings\n","filename":"test\/langtools\/tools\/javac\/warnings\/Serial\/InterfaceNonPrivateMethods.out","additions":9,"deletions":0,"binary":false,"changes":9,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8202056\n+ * @compile\/ref=RecordSerial.out -XDrawDiagnostics -Xlint:serial RecordSerial.java\n+ *\/\n+\n+import java.io.*;\n+\n+record RecordSerial(int foo) implements Serializable {\n+    \/\/ Verify a warning is generated in a record class for each of the\n+    \/\/ ineffectual serial fields and methods.\n+\n+    \/\/ partially effective\n+    private static final long serialVersionUID = 42;\n+\n+    \/\/ ineffectual\n+    private static final ObjectStreamField[] serialPersistentFields = {};\n+\n+    \/\/ ineffectual\n+    private void writeObject(ObjectOutputStream stream) throws IOException {\n+        stream.defaultWriteObject();\n+    }\n+\n+    \/\/ (possibly) effective\n+    private Object writeReplace() throws ObjectStreamException {\n+        return null;\n+    }\n+\n+    \/\/ ineffectual\n+    private void readObject(ObjectInputStream stream)\n+        throws IOException, ClassNotFoundException {\n+        stream.defaultReadObject();\n+    }\n+\n+    \/\/ ineffectual\n+    private void readObjectNoData() throws ObjectStreamException {\n+        return;\n+    }\n+\n+    \/\/ (possibly) effective\n+    private Object readResolve() throws ObjectStreamException {\n+        return null;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/warnings\/Serial\/RecordSerial.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,5 @@\n+RecordSerial.java:9:1: compiler.warn.ineffectual.serial.field.record\n+RecordSerial.java:9:1: compiler.warn.ineffectual.serial.method.record: writeObject\n+RecordSerial.java:9:1: compiler.warn.ineffectual.serial.method.record: readObject\n+RecordSerial.java:9:1: compiler.warn.ineffectual.serial.method.record: readObjectNoData\n+4 warnings\n","filename":"test\/langtools\/tools\/javac\/warnings\/Serial\/RecordSerial.out","additions":5,"deletions":0,"binary":false,"changes":5,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8202056\n+ * @compile\/ref=SerialMethodArity.out -XDrawDiagnostics -Xlint:serial SerialMethodArity.java\n+ *\/\n+\n+import java.io.*;\n+\n+class SerialMethodMods implements Serializable {\n+    private static final long serialVersionUID = 42;\n+\n+    private static class CustomObjectOutputStream extends ObjectOutputStream {\n+        public CustomObjectOutputStream() throws IOException,\n+                                                 SecurityException {}\n+    }\n+\n+    \/\/ Should have a single parameter of exact type ObjectOutputStream\n+    private void writeObject(CustomObjectOutputStream stream) throws IOException {\n+        stream.defaultWriteObject();\n+    }\n+\n+    \/\/ Should have a single parameter of exact type ObjectInputStream\n+    private void readObject(ObjectInputStream stream, int retries)\n+        throws IOException, ClassNotFoundException {\n+        stream.defaultReadObject();\n+    }\n+\n+    \/\/ Should have no arguments\n+    private void readObjectNoData(int retries) throws ObjectStreamException {}\n+\n+    \/\/ Should have no arguments\n+    public Object writeReplace(int arg0, int arg1) throws ObjectStreamException {\n+        return null;\n+    }\n+\n+    \/\/ Should have no arguments\n+    public Object readResolve(double foo, float bar) throws ObjectStreamException {\n+        return null;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/warnings\/Serial\/SerialMethodArity.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,6 @@\n+SerialMethodArity.java:18:18: compiler.warn.serial.method.parameter.type: writeObject, java.io.ObjectOutputStream, SerialMethodMods.CustomObjectOutputStream\n+SerialMethodArity.java:23:18: compiler.warn.serial.method.one.arg: readObject, 2\n+SerialMethodArity.java:29:39: compiler.warn.serial.method.no.args: readObjectNoData\n+SerialMethodArity.java:32:36: compiler.warn.serial.method.no.args: writeReplace\n+SerialMethodArity.java:37:38: compiler.warn.serial.method.no.args: readResolve\n+5 warnings\n","filename":"test\/langtools\/tools\/javac\/warnings\/Serial\/SerialMethodArity.out","additions":6,"deletions":0,"binary":false,"changes":6,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8202056\n+ * @compile\/ref=SerialMethodMods.out -XDrawDiagnostics -Xlint:serial SerialMethodMods.java\n+ *\/\n+\n+import java.io.*;\n+\n+abstract class SerialMethodMods implements Serializable {\n+    private static final long serialVersionUID = 42;\n+\n+    \/\/ Should be private\n+    void writeObject(ObjectOutputStream stream) throws IOException {\n+        stream.defaultWriteObject();\n+    }\n+\n+    \/\/ Should be private\n+    public void readObject(ObjectInputStream stream)\n+        throws IOException, ClassNotFoundException {\n+        stream.defaultReadObject();\n+    }\n+\n+    \/\/ Should be concrete instance method\n+    private static void readObjectNoData() throws ObjectStreamException {}\n+\n+    \/\/ Should be concrete instance method\n+    public abstract Object writeReplace() throws ObjectStreamException;\n+\n+    \/\/ Should be concrete instance method\n+    public static Object readResolve() throws ObjectStreamException {\n+        return null;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/warnings\/Serial\/SerialMethodMods.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,6 @@\n+SerialMethodMods.java:13:10: compiler.warn.serial.method.not.private: writeObject\n+SerialMethodMods.java:18:17: compiler.warn.serial.method.not.private: readObject\n+SerialMethodMods.java:24:25: compiler.warn.serial.method.static: readObjectNoData\n+SerialMethodMods.java:27:28: compiler.warn.serial.concrete.instance.method: writeReplace\n+SerialMethodMods.java:30:26: compiler.warn.serial.concrete.instance.method: readResolve\n+5 warnings\n","filename":"test\/langtools\/tools\/javac\/warnings\/Serial\/SerialMethodMods.out","additions":6,"deletions":0,"binary":false,"changes":6,"status":"added"},{"patch":"@@ -0,0 +1,218 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8202056\n+ * @compile\/ref=SerialMethodThrows.out -XDrawDiagnostics -Xlint:serial SerialMethodThrows.java\n+ *\/\n+\n+import java.io.*;\n+\n+\/*\n+ * Container class for various serializable classes with different\n+ * kinds of throws clauses. Canonical serialization method signatures:\n+ *\n+ * private void writeObject(ObjectOutputStream stream)\n+ * throws IOException\n+ *\n+ * ANY-ACCESS-MODIFIER Object writeReplace()\n+ * throws ObjectStreamException\n+ *\n+ * private void readObject(ObjectInputStream stream)\n+ * throws IOException, ClassNotFoundException\n+ *\n+ * private void readObjectNoData()\n+ * throws ObjectStreamException\n+ *\n+ * ANY-ACCESS-MODIFIER Object readResolve()\n+ * throws ObjectStreamException\n+ *\/\n+class SerialMethodThrows {\n+\n+    \/\/ Being declared to throw no exceptions is fine and should not\n+    \/\/ generate any warnings.\n+    static class NoThrows implements Serializable {\n+        private static final long serialVersionUID = 42;\n+\n+        private void writeObject(ObjectOutputStream stream) {\n+            try {\n+                stream.defaultWriteObject();\n+            } catch (IOException e) {\n+                ;\n+            }\n+        }\n+\n+        private Object writeReplace() {\n+            return null;\n+        }\n+\n+        private void readObject(ObjectInputStream stream) {\n+            try {\n+                stream.defaultReadObject();\n+            } catch (IOException | ClassNotFoundException e) {\n+                ;\n+            }\n+        }\n+\n+        private void readObjectNoData() {}\n+\n+        private Object readResolve() {\n+            return null;\n+        }\n+    }\n+\n+    \/\/ Being declared to throw the canonical exceptions is fine and\n+    \/\/ should not generate any warnings.\n+    static class ErrorThrows implements Serializable {\n+        private static final long serialVersionUID = 42;\n+\n+        private void writeObject(ObjectOutputStream stream)\n+            throws Error {\n+            try {\n+                stream.defaultWriteObject();\n+            } catch (IOException e) {\n+                ;\n+            }\n+        }\n+\n+        private Object writeReplace()\n+            throws Error {\n+            return null;\n+        }\n+\n+        private void readObject(ObjectInputStream stream)\n+            throws Error {\n+            try {\n+                stream.defaultReadObject();\n+            } catch (IOException | ClassNotFoundException e) {\n+                ;\n+            }\n+        }\n+\n+        private void readObjectNoData()\n+        throws Error {}\n+\n+        private Object readResolve()\n+            throws Error {\n+            return null;\n+        }\n+    }\n+\n+    \/\/ Being declared to throw the canonical exceptions is fine and\n+    \/\/ should not generate any warnings.\n+    static class ExactThrows implements Serializable {\n+        private static final long serialVersionUID = 42;\n+\n+        private void writeObject(ObjectOutputStream stream)\n+            throws IOException {\n+            stream.defaultWriteObject();\n+        }\n+\n+        private Object writeReplace()\n+            throws ObjectStreamException {\n+            return null;\n+        }\n+\n+        private void readObject(ObjectInputStream stream)\n+            throws IOException, ClassNotFoundException {\n+            stream.defaultReadObject();\n+        }\n+\n+        private void readObjectNoData()\n+        throws ObjectStreamException {}\n+\n+        private Object readResolve()\n+            throws ObjectStreamException {\n+            return null;\n+        }\n+    }\n+\n+    \/\/ Being declared to throw subclasses of the canonical exceptions\n+    \/\/ is fine and should not generate any warnings.\n+    static class SubclassThrows implements Serializable {\n+        private static final long serialVersionUID = 42;\n+\n+        private void writeObject(ObjectOutputStream stream)\n+            throws CustomIOException {\n+            try {\n+                stream.defaultWriteObject();\n+            } catch (IOException e) {\n+                ;\n+            }\n+        }\n+\n+        private Object writeReplace()\n+            throws CustomObjectStreamException {\n+            return null;\n+        }\n+\n+        private void readObject(ObjectInputStream stream)\n+            throws CustomIOException, CustomClassNotFoundException {\n+            try {\n+                stream.defaultReadObject();\n+            } catch (IOException | ClassNotFoundException e) {\n+                ;\n+            }\n+        }\n+\n+        private void readObjectNoData()\n+        throws CustomObjectStreamException {}\n+\n+        private Object readResolve()\n+            throws CustomObjectStreamException {\n+            return null;\n+        }\n+    }\n+\n+    private static class CustomIOException extends IOException{\n+        private static final long serialVersionUID = 1;\n+    }\n+\n+    private static class CustomObjectStreamException extends ObjectStreamException {\n+        private static final long serialVersionUID = 2;\n+    }\n+\n+    private static class CustomClassNotFoundException extends ClassNotFoundException {\n+        private static final long serialVersionUID = 3;\n+    }\n+\n+    \/\/ Use to trigger warnings\n+    private static class CustomException extends Exception {\n+        private static final long serialVersionUID = 3;\n+    }\n+\n+    \/\/ Being declared to throw subclasses of the canonical exceptions\n+    \/\/ is fine and should not generate any warnings.\n+    static class CustomThrows implements Serializable {\n+        private static final long serialVersionUID = 42;\n+\n+        private void writeObject(ObjectOutputStream stream)\n+            throws CustomException {\n+            try {\n+                stream.defaultWriteObject();\n+            } catch (IOException e) {\n+                ;\n+            }\n+        }\n+\n+        private Object writeReplace()\n+            throws CustomException {\n+            return null;\n+        }\n+\n+        private void readObject(ObjectInputStream stream)\n+            throws CustomException {\n+            try {\n+                stream.defaultReadObject();\n+            } catch (IOException | ClassNotFoundException e) {\n+                ;\n+            }\n+        }\n+\n+        private void readObjectNoData()\n+        throws CustomException {}\n+\n+        private Object readResolve()\n+            throws CustomException {\n+            return null;\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/warnings\/Serial\/SerialMethodThrows.java","additions":218,"deletions":0,"binary":false,"changes":218,"status":"added"},{"patch":"@@ -0,0 +1,6 @@\n+SerialMethodThrows.java:187:22: compiler.warn.serial.method.unexpected.exception: writeObject, SerialMethodThrows.CustomException\n+SerialMethodThrows.java:196:24: compiler.warn.serial.method.unexpected.exception: writeReplace, SerialMethodThrows.CustomException\n+SerialMethodThrows.java:201:22: compiler.warn.serial.method.unexpected.exception: readObject, SerialMethodThrows.CustomException\n+SerialMethodThrows.java:210:22: compiler.warn.serial.method.unexpected.exception: readObjectNoData, SerialMethodThrows.CustomException\n+SerialMethodThrows.java:213:24: compiler.warn.serial.method.unexpected.exception: readResolve, SerialMethodThrows.CustomException\n+5 warnings\n","filename":"test\/langtools\/tools\/javac\/warnings\/Serial\/SerialMethodThrows.out","additions":6,"deletions":0,"binary":false,"changes":6,"status":"added"}]}