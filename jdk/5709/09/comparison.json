{"files":[{"patch":"@@ -4000,1 +4000,4 @@\n-        private final Object a, b;\n+        @SuppressWarnings(\"serial\")\n+        private final Object a;\n+        @SuppressWarnings(\"serial\")\n+        private final Object b;\n@@ -4069,1 +4072,6 @@\n-        private final Object dst, a1, a2;\n+        @SuppressWarnings(\"serial\")\n+        private final Object dst;\n+        @SuppressWarnings(\"serial\")\n+        private final Object a1;\n+        @SuppressWarnings(\"serial\")\n+        private final Object  a2;\n@@ -4118,1 +4126,4 @@\n-        private final Object a, b;\n+        @SuppressWarnings(\"serial\")\n+        private final Object a;\n+        @SuppressWarnings(\"serial\")\n+        private final Object b;\n","filename":"src\/java.base\/share\/classes\/java\/util\/DualPivotQuicksort.java","additions":14,"deletions":3,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -82,0 +82,1 @@\n+    @SuppressWarnings(\"serial\")\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/http\/KeepAliveCache.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -122,0 +122,1 @@\n+    @SuppressWarnings(\"serial\")\n@@ -124,0 +125,1 @@\n+    @SuppressWarnings(\"serial\")\n","filename":"src\/java.base\/unix\/classes\/sun\/net\/www\/protocol\/http\/ntlm\/NTLMAuthentication.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -74,0 +74,1 @@\n+    @SuppressWarnings(\"serial\")\n","filename":"src\/java.rmi\/share\/classes\/sun\/rmi\/server\/UnicastRef.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -227,0 +227,8 @@\n+    \/\/ For serialization lint checking; may be moved elsewhere\n+    public final Type objectStreamFieldType;\n+    public final Type objectInputStreamType;\n+    public final Type objectOutputStreamType;\n+    public final Type ioExceptionType;\n+    public final Type objectStreamExceptionType;\n+    public final Type externalizableType;\n+\n@@ -593,0 +601,7 @@\n+        \/\/ For serialization lint checking; may be moved elsewhere\n+        objectStreamFieldType = enterClass(\"java.io.ObjectStreamField\");\n+        objectInputStreamType = enterClass(\"java.io.ObjectInputStream\");\n+        objectOutputStreamType = enterClass(\"java.io.ObjectOutputStream\");\n+        ioExceptionType = enterClass(\"java.io.IOException\");\n+        objectStreamExceptionType = enterClass(\"java.io.ObjectStreamException\");\n+        externalizableType = enterClass(\"java.io.Externalizable\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -32,0 +32,10 @@\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.Modifier;\n+import javax.lang.model.element.NestingKind;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.type.TypeMirror;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.util.ElementFilter;\n+import javax.lang.model.util.ElementKindVisitor14;\n@@ -5503,1 +5513,2 @@\n-        \/\/ Check for proper use of serialVersionUID\n+        \/\/ Check for proper use of serialVersionUID and other\n+        \/\/ serialization-related fields and methods\n@@ -5506,1 +5517,1 @@\n-                && (c.flags() & (Flags.ENUM | Flags.INTERFACE)) == 0\n+            \/* && (c.flags() & (Flags.ENUM | Flags.INTERFACE)) == 0 *\/\n@@ -5508,1 +5519,2 @@\n-            checkSerialVersionUID(tree, c, env);\n+            \/\/ checkSerialVersionUID(tree, c, env);\n+            checkSerialStructure(tree, c, env);\n@@ -5540,0 +5552,11 @@\n+        \/** check if a type is a subtype of Externalizable, if that is available. *\/\n+        boolean isExternalizable(Type t) {\n+            try {\n+                syms.externalizableType.complete();\n+            }\n+            catch (CompletionFailure e) {\n+                return false;\n+            }\n+            return types.isSubtype(t, syms.externalizableType);\n+        }\n+\n@@ -5582,0 +5605,734 @@\n+        \/**\n+         * Check structure of serialization declarations.\n+         *\/\n+        private void checkSerialStructure(JCClassDecl tree, ClassSymbol c, Env<AttrContext> env) {\n+            (new SerialTypeVisitor()).visit(c, tree);\n+        }\n+\n+    \/**\n+     * This visitor will warn if a serialization-related field or\n+     * method is declared in a suspicious or incorrect way. In\n+     * particular, it will warn for cases where the runtime\n+     * serialization mechanism will silently ignore a mis-declared\n+     * entity.\n+     *\n+     * Distinguished serialization-related fields and methods:\n+     *\n+     * Methods:\n+     *\n+     * private void writeObject(ObjectOutputStream stream) throws IOException\n+     * ANY-ACCESS-MODIFIER Object writeReplace() throws ObjectStreamException\n+     *\n+     * private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException\n+     * private void readObjectNoData() throws ObjectStreamException\n+     * ANY-ACCESS-MODIFIER Object readResolve() throws ObjectStreamException\n+     *\n+     * Fields:\n+     *\n+     * private static final long serialVersionUID\n+     * private static final ObjectStreamField[] serialPersistentFields\n+     *\n+     * Externalizable: methods defined on the interface\n+     * public void writeExternal(ObjectOutput) throws IOException\n+     * public void readExternal(ObjectInput) throws IOException\n+     *\/\n+    private class SerialTypeVisitor extends ElementKindVisitor14<Void, JCClassDecl> {\n+        SerialTypeVisitor(){super();}\n+\n+        private static final Set<String> serialMethodNames =\n+            Set.of(\"writeObject\", \"writeReplace\",\n+                   \"readObject\",  \"readObjectNoData\",\n+                   \"readResolve\");\n+\n+        private static final Set<String> serialFieldNames =\n+            Set.of(\"serialVersionUID\", \"serialPersistentFields\");\n+\n+        \/\/ TODO these checks should likely be expressed in terms of javac flags\n+        private static final Set<Modifier> PRIVATE_STATIC_FINAL_MODS =\n+            Set.of(Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL);\n+\n+        private static final Set<Modifier> STATIC_FINAL_MODS = Set.of(Modifier.STATIC, Modifier.FINAL);\n+\n+        private static final Set<Modifier> ABSTRACT_STATIC_MODS = Set.of(Modifier.ABSTRACT, Modifier.STATIC);\n+\n+        private static final Set<Modifier> PRIVATE_MODS = Set.of(Modifier.PRIVATE);\n+        private static final Set<Modifier> STATIC_MODS =  Set.of(Modifier.STATIC);\n+\n+        \/\/ Type of serialVersionUID\n+        private final Type LONG_TYPE = syms.longType;\n+\n+        \/\/ Type of serialPersistentFields\n+        private final Type OSF_TYPE = new Type.ArrayType(syms.objectStreamFieldType, syms.arrayClass);\n+\n+        private final Type OIS_TYPE = syms.objectInputStreamType;\n+        private final Type OOS_TYPE = syms.objectOutputStreamType;\n+        private final Type VOID_TYPE = syms.voidType;\n+        private final Type OBJECT_TYPE = syms.objectType;\n+\n+        \/\/ Exception types used in serialization-related methods' throws clauses\n+        private final Type IOE_TYPE = syms.ioExceptionType;\n+        private final Type OSE_TYPE = syms.objectStreamExceptionType;\n+        private final Type CNFE_TYPE = syms.classNotFoundExceptionType;\n+        private final Type J_L_ERROR_TYPE = syms.errorType;\n+        private final Type RUNTIME_EXCEPTION_TYPE = syms.runtimeExceptionType;\n+\n+        \/\/             final TypeMirror SERIAL_ANNOTATION =\n+        \/\/                 Objects.requireNonNull(elementUtils.getTypeElement(\"java.io.Serial\").asType());\n+\n+        @Override\n+        public Void defaultAction(Element e, JCClassDecl p) {\n+            throw new IllegalArgumentException(Objects.requireNonNullElse(e.toString(), \"\"));\n+        }\n+\n+        @Override\n+        public Void visitTypeAsClass(TypeElement e,\n+                                     JCClassDecl tree) {\n+            ClassSymbol c = (ClassSymbol)e;\n+\n+\/\/          if (c.isAnonymous())\n+\/\/              return null;\n+\n+            if (checkSuppressSerialWarningNested(e))\n+                return null;\n+\n+            checkCtorAccess(tree, c);\n+\n+            \/\/ Check for missing serialVersionUID; check *not* done\n+            \/\/ for enums or records.\n+            VarSymbol svuidSym = null;\n+            for (Symbol sym : c.members().getSymbolsByName(names.serialVersionUID)) {\n+                if (sym.kind == VAR) {\n+                    svuidSym = (VarSymbol)sym;\n+                    break;\n+                }\n+            }\n+\n+            if (svuidSym == null) {\n+                log.warning(LintCategory.SERIAL, tree.pos(), Warnings.MissingSVUID(c));\n+            }\n+\n+            \/\/ Check for serialPersistentFields to gate checks for\n+            \/\/ non-serializable non-transient instance fields\n+            boolean serialPersistentFieldsPresent = false;\n+            for (Symbol sym : c.members().getSymbolsByName(names.serialPersistentFields)) {\n+                if (sym.kind == VAR) {\n+                    serialPersistentFieldsPresent = true;\n+                    break;\n+                }\n+            }\n+\n+            \/\/ Check declarations of serialization-related methods and\n+            \/\/ fields\n+            for(Element enclosed : e.getEnclosedElements()) {\n+                if (checkSuppressSerialWarning(enclosed))\n+                    continue;\n+\n+                String name = null;\n+                switch(enclosed.getKind()) {\n+                case FIELD -> {\n+                    if (!serialPersistentFieldsPresent) {\n+                        var modifiers = enclosed.getModifiers();\n+                        if (!modifiers.contains(Modifier.TRANSIENT) &&\n+                            !modifiers.contains(Modifier.STATIC)) {\n+                            TypeMirror varType = enclosed.asType();\n+                            if (!isSerializable((Type)varType) &&\n+                                !varType.getKind().isPrimitive()) {\n+                                \/\/ Note per JLS arrays are\n+                                \/\/ serializable even if the component\n+                                \/\/ type is not.\n+                                log.warning(LintCategory.SERIAL,\n+                                            TreeInfo.diagnosticPositionFor((Symbol)enclosed, tree),\n+                                            Warnings.NonSerializableInstanceField);\n+                            }\n+                        }\n+                    }\n+\n+                    name = enclosed.getSimpleName().toString();\n+                    if (serialFieldNames.contains(name)) {\n+                        VarSymbol field = (VarSymbol)enclosed;\n+                        switch (name) {\n+                        case \"serialVersionUID\"       ->  checkSerialVersionUID(tree, e, field);\n+                        case \"serialPersistentFields\" ->  checkSerialPersistentFields(tree, e, field);\n+                        default -> throw new AssertionError();\n+                        }\n+                    }\n+                }\n+\n+                \/\/ Correctly checking the serialization-related\n+                \/\/ methods is subtle. For the methods declared to be\n+                \/\/ private or directly declared in the class, the\n+                \/\/ enclosed elements of the class can be checked in\n+                \/\/ turn. However, writeReplace and readResolve can be\n+                \/\/ declared in a superclass and inherited. Note that\n+                \/\/ the runtime lookup walks the superclass chain\n+                \/\/ looking for writeReplace\/readResolve via\n+                \/\/ Class.getDeclaredMethod. This differs from calling\n+                \/\/ Elements.getAllMembers(TypeElement) as the latter\n+                \/\/ will also pull in default methods from\n+                \/\/ superinterfaces. In other words, the runtime checks\n+                \/\/ (which long predate default methods on interfaces)\n+                \/\/ do not admit the possibility of inheriting methods\n+                \/\/ this way, a difference from general inheritance.\n+\n+                \/\/ The current implementation just checks the enclosed\n+                \/\/ elements and does not directly check the inherited\n+                \/\/ methods. If all the types are being checked this is\n+                \/\/ less of a concern; however, there are cases that\n+                \/\/ could be missed. In particular, readResolve and\n+                \/\/ writeReplace could, in principle, by inherited from\n+                \/\/ a non-serializable superclass and thus not checked\n+                \/\/ even if compiled with a serializable child class.\n+                case METHOD -> {\n+                    var method = toMethod(enclosed);\n+                    name = enclosed.getSimpleName().toString();\n+                    if (serialMethodNames.contains(name)) {\n+                        switch (name) {\n+                        case \"writeObject\"      -> checkWriteObject(tree, e, method);\n+                        case \"writeReplace\"     -> checkWriteReplace(tree,e, method);\n+                        case \"readObject\"       -> checkReadObject(tree,e, method);\n+                        case \"readObjectNoData\" -> checkReadObjectNoData(tree, e, method);\n+                        case \"readResolve\"      -> checkReadResolve(tree, e, method);\n+                        default ->  throw new AssertionError();\n+                        }\n+                    }\n+                }\n+                }\n+            }\n+\n+            return null;\n+        }\n+\n+\n+        \/**\n+         * Check that Externalizable class needs a public no-arg\n+         * constructor.\n+         *\n+         * Check that a Serializable class has access to the no-arg\n+         * constructor of its first nonserializable superclass.\n+         *\/\n+        private void checkCtorAccess(JCClassDecl tree, Element e) {\n+            ClassSymbol c = (ClassSymbol) e;\n+\n+            if (isExternalizable(c.type)) {\n+                for(var ctor : ElementFilter.constructorsIn(c.getEnclosedElements())) {\n+                    if (ctor.getParameters().isEmpty() &&\n+                        ctor.getModifiers().contains(Modifier.PUBLIC))\n+                        return;\n+                }\n+                log.warning(LintCategory.SERIAL, tree.pos(),\n+                            Warnings.ExternalizableMissingPublicNoArgCtor);\n+\n+            } else {\n+                \/\/ Approximate access to the no-arg constructor up in\n+                \/\/ the superclass chain by checking that the\n+                \/\/ constructor is not private. This may not handle\n+                \/\/ some cross-package situations correctly.\n+                Type superClass = c.getSuperclass();\n+                \/\/ java.lang.Object is *not* Serializable so this loop\n+                \/\/ should terminate.\n+                \/\/ TOOD: checking needed for error types?\n+                while (isSerializable(superClass) ) {\n+                    try {\n+                        superClass = (Type)((TypeElement)(((DeclaredType)superClass)).asElement()).getSuperclass();\n+                    } catch(ClassCastException cce) {\n+                        return ; \/\/ Don't try to recover\n+                    }\n+                }\n+                \/\/ Non-Serializable super class\n+                try {\n+                    TypeElement supertype = ((TypeElement)(((DeclaredType)superClass).asElement()));\n+                    for (var ctor:\n+                             ElementFilter.constructorsIn(supertype.getEnclosedElements()) ) {\n+                        if (ctor.getParameters().isEmpty()) {\n+                            if (ctor.getModifiers().contains(Modifier.PRIVATE) ||\n+                                \/\/ Handle nested classes and implicit this$0\n+                                (supertype.getNestingKind() == NestingKind.MEMBER &&\n+                                 !supertype.getModifiers().contains(Modifier.STATIC)))\n+                                log.warning(LintCategory.SERIAL, tree.pos(),\n+                                            Warnings.SerializableMissingAccessNoArgCtor((Symbol)supertype));\n+                        }\n+                    }\n+                } catch (ClassCastException cce) {\n+                    return ; \/\/ Don't try to recover\n+                }\n+                return;\n+            }\n+        }\n+\n+        private void checkSerialVersionUID(JCClassDecl tree, Element e, VarSymbol svuid) {\n+            \/\/ To be effective, serialVersionUID must be marked static\n+            \/\/ and final, but private is recommended.\n+\n+            \/\/ But alas, in practice there are many non-private\n+            \/\/ serialVersionUID fields\n+\n+             if ((svuid.flags() & (STATIC | FINAL)) !=\n+                 (STATIC | FINAL)) {\n+                 log.warning(LintCategory.SERIAL,\n+                             TreeInfo.diagnosticPositionFor(svuid, tree), Warnings.ImproperSVUID((Symbol)e));\n+             }\n+\n+             \/\/ check svuid has type long\n+             if (!svuid.type.hasTag(LONG)) {\n+                 log.warning(LintCategory.SERIAL,\n+                             TreeInfo.diagnosticPositionFor(svuid, tree),\n+                             Warnings.LongSVUID((Symbol)e));\n+             }\n+             \n+             if (svuid.getConstValue() == null)\n+                 log.warning(LintCategory.SERIAL,\n+                            TreeInfo.diagnosticPositionFor(svuid, tree),\n+                             Warnings.ConstantSVUID((Symbol)e));\n+        }\n+\n+        private void checkSerialPersistentFields(JCClassDecl tree, Element e, VarSymbol spf) {\n+            \/\/ To be effective, serialPersisentFields must be private, static, and final.\n+             if ((spf.flags() & (PRIVATE | STATIC | FINAL)) !=\n+                 (PRIVATE | STATIC | FINAL)) {\n+                 log.warning(LintCategory.SERIAL,\n+                             TreeInfo.diagnosticPositionFor(spf, tree), Warnings.ImproperSPF);\n+             }\n+\n+             if (!types.isSameType(spf.type, OSF_TYPE)) {\n+                 log.warning(LintCategory.SERIAL,\n+                             TreeInfo.diagnosticPositionFor(spf, tree), Warnings.OSFArraySPF);\n+             }\n+\n+            if (isExternalizable((Type)(e.asType()))) {\n+                log.warning(LintCategory.SERIAL, tree.pos(),\n+                            Warnings.IneffectualSerialFieldExternalizable);\n+            }\n+\n+            \/\/ If additional compile-time information is\n+            \/\/ available, should check for a \"constant null\"\n+            \/\/ assignment to this field. A null value makes having\n+            \/\/ the field a no-op.\n+        }\n+\n+        \/*\n+         * Methods can have modifiers: public, protected, private,\n+         * abstract, static, final, synchronized, native, strictfp\n+         *\/\n+\n+        private void checkWriteObject(JCClassDecl tree, Element e, ExecutableElement method) {\n+            \/\/ The \"synchronized\" modifier is seen in the wild on\n+            \/\/ readObject and writeObject methods and is generally\n+            \/\/ innocuous.\n+\n+            \/\/ private void writeObject(ObjectOutputStream stream) throws IOException\n+            checkPrivateNonStaticMethod(tree, (MethodSymbol)method);\n+            checkReturnTypeOfMethod(tree, e, method, VOID_TYPE);\n+            checkOneArg(tree, e, method, OOS_TYPE);\n+            checkExceptions(tree, e, method, IOE_TYPE);\n+            checkExternalizable(tree, e, method);\n+        }\n+\n+        private void checkWriteReplace(JCClassDecl tree, Element e, ExecutableElement method) {\n+            \/\/ ANY-ACCESS-MODIFIER Object writeReplace() throws\n+            \/\/ ObjectStreamException\n+\n+            \/\/ Excluding abstract, could have a more complicated\n+            \/\/ rule based on abstract-ness of the class?\n+            checkExcludedModifiers(tree, e, method, ABSTRACT_STATIC_MODS);\n+            checkReturnTypeOfMethod(tree, e, method, OBJECT_TYPE);\n+            checkNoArgs(tree, e, method);\n+            checkExceptions(tree, e, method, OSE_TYPE);\n+        }\n+\n+        private void checkReadObject(JCClassDecl tree, Element e, ExecutableElement method) {\n+            MethodSymbol methodSym = (MethodSymbol)method;\n+            \/\/ The \"synchronized\" modifier is seen in the wild on\n+            \/\/ readObject and writeObject methods and is generally\n+            \/\/ innocuous.\n+\n+            \/\/ private void readObject(ObjectInputStream stream)\n+            \/\/   throws IOException, ClassNotFoundException\n+            checkPrivateNonStaticMethod(tree, (MethodSymbol)method);\n+            checkReturnTypeOfMethod(tree, e, method, VOID_TYPE);\n+            checkOneArg(tree, e, method, OIS_TYPE);\n+            checkExceptions(tree, e, method, IOE_TYPE, CNFE_TYPE);\n+            checkExternalizable(tree, e, method);\n+        }\n+\n+        private void checkReadObjectNoData(JCClassDecl tree, Element e, ExecutableElement method) {\n+            \/\/ private void readObjectNoData() throws ObjectStreamException\n+            checkPrivateNonStaticMethod(tree, (MethodSymbol)method);\n+            checkReturnTypeOfMethod(tree, e, method, VOID_TYPE);\n+            checkNoArgs(tree, e, method);\n+            checkExceptions(tree, e, method, OSE_TYPE);\n+            checkExternalizable(tree, e, method);\n+        }\n+\n+        private void checkReadResolve(JCClassDecl tree, Element e, ExecutableElement method) {\n+            \/\/ ANY-ACCESS-MODIFIER Object readResolve()\n+            \/\/ throws ObjectStreamException\n+\n+            \/\/ Excluding abstract, could have a more complicated\n+            \/\/ rule based on abstract-ness of the class?\n+            checkExcludedModifiers(tree, e, method, ABSTRACT_STATIC_MODS);\n+            checkReturnTypeOfMethod(tree,e, method, OBJECT_TYPE);\n+            checkNoArgs(tree, e, method);\n+            checkExceptions(tree, e, method, OSE_TYPE);\n+        }\n+\n+        void checkPrivateNonStaticMethod(JCClassDecl tree, MethodSymbol method) {\n+            var flags = method.flags();\n+            if ((flags & PRIVATE) == 0) {\n+                log.warning(LintCategory.SERIAL,\n+                            TreeInfo.diagnosticPositionFor(method, tree),\n+                            Warnings.SerialMethodNotPrivate(method));\n+            }\n+\n+            if ((flags & STATIC) != 0) {\n+                log.warning(LintCategory.SERIAL,\n+                            TreeInfo.diagnosticPositionFor(method, tree),\n+                            Warnings.SerialMethodStatic(method));\n+            }\n+        }\n+\n+\n+        \/**\n+         * Per section 1.12 \"Serialization of Enum Constants\" of\n+         * the serialization specification, due to the special\n+         * serialization handling of enums, any writeObject,\n+         * readObject, writeReplace, and readResolve methods are\n+         * ignored as are serialPersistentFields and\n+         * serialVersionUID fields.\n+         *\/\n+        @Override\n+        public Void visitTypeAsEnum(TypeElement e,\n+                                    JCClassDecl tree) {\n+            if (checkSuppressSerialWarningNested(e)) {\n+                return null;\n+            }\n+\n+            for(Element enclosed : e.getEnclosedElements()) {\n+                if (checkSuppressSerialWarning(enclosed))\n+                    continue;\n+\n+                String name = enclosed.getSimpleName().toString();\n+                switch(enclosed.getKind()) {\n+                case FIELD -> {\n+                    if (serialFieldNames.contains(name)) {\n+                        log.warning(LintCategory.SERIAL, tree.pos(),\n+                                    Warnings.IneffectualSerialFieldEnum((Symbol)enclosed));\n+                    }\n+                }\n+\n+                case METHOD -> {\n+                    if (serialMethodNames.contains(name)) {\n+                        log.warning(LintCategory.SERIAL, tree.pos(),\n+                                    Warnings.IneffectualSerialMethodEnum((Symbol)enclosed));\n+                    }\n+                }\n+                }\n+            }\n+            return null;\n+        }\n+\n+        \/**\n+         * Serialization-related fields and methods on interfaces are ineffectual.\n+         *\/\n+        @Override\n+        public Void visitTypeAsInterface(TypeElement e,\n+                                         JCClassDecl tree) {\n+            if (checkSuppressSerialWarningNested(e)) {\n+                return null;\n+            }\n+\n+            for(Element enclosed : e.getEnclosedElements()) {\n+                if (checkSuppressSerialWarning(enclosed))\n+                    continue;\n+\n+                String name = null;\n+                switch(enclosed.getKind()) {\n+                case FIELD -> {\n+                    name = enclosed.getSimpleName().toString();\n+                    if (serialFieldNames.contains(name)) {\n+                        \/\/ System.out.println(\"Serial field name \" + name +\n+                        \/\/                   \" in \" + e.getKind() + \" \" + e.toString());\n+                        int i = 2 + 2;\n+                    }\n+                }\n+\n+                case METHOD -> {\n+                    var method = toMethod(enclosed);\n+                    name = enclosed.getSimpleName().toString();\n+                    if (serialMethodNames.contains(name)) {\n+                        switch (name) {\n+                        case\n+                            \"readObject\",\n+                            \"readObjectNoData\",\n+                            \"writeObject\"      -> checkPrivateMethod(tree, e, method);\n+\n+                        case\n+                            \"writeReplace\",\n+                            \"readResolve\"      -> checkDefaultIneffective(tree, e, method);\n+\n+                        default ->  throw new AssertionError();\n+                        }\n+\n+                    }\n+                }\n+                }\n+            }\n+\n+            return null;\n+        }\n+\n+        private void checkPrivateMethod(JCClassDecl tree,\n+                                        Element e,\n+                                        ExecutableElement method) {\n+            if (!method.getModifiers().contains(Modifier.PRIVATE)) {\n+                log.warning(LintCategory.SERIAL,\n+                            TreeInfo.diagnosticPositionFor((Symbol)method, tree),\n+                            Warnings.NonPrivateMethodWeakerAccess);\n+\n+            }\n+        }\n+\n+        private void checkDefaultIneffective(JCClassDecl tree,\n+                                             Element e,\n+                                             ExecutableElement method) {\n+            if (method.getModifiers().contains(Modifier.DEFAULT)) {\n+                log.warning(LintCategory.SERIAL,\n+                            TreeInfo.diagnosticPositionFor((Symbol)method, tree),\n+                            Warnings.DefaultIneffective);\n+\n+            }\n+        }\n+\n+        @Override\n+        public Void visitTypeAsAnnotationType(TypeElement e,\n+                                              JCClassDecl p) {\n+            \/\/ Per the JLS, annotation types are not serializeable\n+            return null;\n+        }\n+\n+        \/**\n+         * From the Java Object Serialization Specification, 1.13\n+         * Serialization of Records:\n+         *\n+         * \"The process by which record objects are serialized or\n+         * externalized cannot be customized; any class-specific\n+         * writeObject, readObject, readObjectNoData,\n+         * writeExternal, and readExternal methods defined by\n+         * record classes are ignored during serialization and\n+         * deserialization. However, a substitute object to be\n+         * serialized or a designate replacement may be specified,\n+         * by the writeReplace and readResolve methods,\n+         * respectively. Any serialPersistentFields field\n+         * declaration is ignored. Documenting serializable fields\n+         * and data for record classes is unnecessary, since there\n+         * is no variation in the serial form, other than whether\n+         * a substitute or replacement object is used. The\n+         * serialVersionUID of a record class is 0L unless\n+         * explicitly declared. The requirement for matching\n+         * serialVersionUID values is waived for record classes.\"\n+         *\/\n+\n+        @Override\n+        public Void visitTypeAsRecord(TypeElement e,\n+                                      JCClassDecl tree) {\n+            if (checkSuppressSerialWarningNested(e)) {\n+                return null;\n+            }\n+\n+            for(Element enclosed : e.getEnclosedElements()) {\n+                if (checkSuppressSerialWarning(enclosed))\n+                    continue;\n+\n+                String name = enclosed.getSimpleName().toString();\n+                switch(enclosed.getKind()) {\n+                case FIELD -> {\n+                    switch(name) {\n+                    case \"serialPersistentFields\" -> {\n+                        log.warning(LintCategory.SERIAL, tree.pos(),\n+                                    Warnings.IneffectualSerialFieldRecord);\n+                    }\n+\n+                    case \"serialVersionUID\" -> {\n+                        \/\/ TODO Extra warning that svuid value not\n+                        \/\/ checked to match for records?\n+                        checkSerialVersionUID(tree, e, (VarSymbol)enclosed);\n+                    }\n+\n+                    }\n+                }\n+\n+                case METHOD -> {\n+                    var method = toMethod(enclosed);\n+                    switch(name) {\n+                    case \"writeReplace\" -> checkWriteReplace(tree, e, method);\n+                    case \"readResolve\"  -> checkReadResolve(tree, e, method);\n+                    default -> {\n+                        if (serialMethodNames.contains(name)) {\n+                            log.warning(LintCategory.SERIAL, tree.pos(),\n+                                        Warnings.IneffectualSerialMethodRecord((Symbol)enclosed));\n+                        }\n+                    }\n+                    }\n+\n+                }\n+                }\n+            }\n+            return null;\n+        }\n+\n+        \/\/ Note that since SuppressWarnings has source retention,\n+        \/\/ this check will only be effective when run against\n+        \/\/ source files.\n+        boolean checkSuppressSerialWarning(Element e) {\n+            SuppressWarnings suppress = e.getAnnotation(SuppressWarnings.class);\n+            if (suppress == null)\n+                return false;\n+            else {\n+                for (String warning : suppress.value()) {\n+                    if (\"serial\".equals(warning))\n+                        return true;\n+                }\n+                return false;\n+            }\n+        }\n+\n+        boolean checkSuppressSerialWarningNested(TypeElement e) {\n+            if (checkSuppressSerialWarning(e))\n+                return true;\n+            else {\n+                NestingKind nestingKind = e.getNestingKind();\n+                while (nestingKind == NestingKind.MEMBER) {\n+                    Element enclosing = e.getEnclosingElement();\n+                    boolean enclosingSuppression = checkSuppressSerialWarning(enclosing);\n+                    if (enclosingSuppression)\n+                        return true;\n+                    else {\n+                        ElementKind enclosingKind = enclosing.getKind();\n+                        if (enclosingKind.isClass() ||  enclosingKind.isInterface()) {\n+                            e = (TypeElement) enclosing;\n+                            nestingKind = e.getNestingKind();\n+                        } else {\n+                            return false;\n+                        }\n+                    }\n+                }\n+                return false;\n+            }\n+        }\n+\n+        void checkExcludedModifiers(JCClassDecl tree,\n+                                    Element enclosing,\n+                                    Element element,\n+                                    Set<Modifier> excludedMods) {\n+            checkExcludedModifiers(tree, enclosing, element, excludedMods, null);\n+        }\n+\n+\n+        void checkExcludedModifiers(JCClassDecl tree,\n+                                    Element enclosing,\n+                                    Element element,\n+                                    Set<Modifier> excludedMods,\n+                                    Warning warningKey) {\n+            String name = element.getSimpleName().toString();\n+            Set<Modifier> mods = element.getModifiers();\n+            for (Modifier excludedMod : excludedMods) {\n+                if (mods.contains(excludedMod) ) {\n+                    if (warningKey == null) {\n+                        System.out.println(\"Serialization-related declaration \" + name +\n+                                           \" in \" + enclosing.getKind() + \" \" + enclosing.toString() +\n+                                           \" has unexpected modifier \" + excludedMod);\n+                    } else {\n+                        log.warning(LintCategory.SERIAL,\n+                                    TreeInfo.diagnosticPositionFor((Symbol)element, tree),\n+                                    warningKey);\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void checkReturnTypeOfMethod(JCClassDecl tree,\n+                                             Element enclosing,\n+                                             ExecutableElement method,\n+                                             TypeMirror expectedReturnType) {\n+            String name = method.getSimpleName().toString();\n+            TypeMirror tm = method.getReturnType();\n+            if (!types.isSameType((Type)expectedReturnType, \/* fixme*\/ (Type)tm)) {\n+                System.out.println(\"Unexpected return type \" + tm + \" on \" + name +\n+                                   \" in \" + enclosing.getKind() + \" \" + enclosing.toString());\n+            }\n+        }\n+\n+        private void checkOneArg(JCClassDecl tree,\n+                                 Element enclosing,\n+                                 ExecutableElement method,\n+                                 TypeMirror expected) {\n+            String name = method.getSimpleName().toString();\n+\n+            var parameters= method.getParameters();\n+\n+            if (parameters.size() != 1) {\n+                System.out.println(\"Unexpected parameters \" + parameters + \" on \" + name +\n+                                   \" in \" + enclosing.getKind() + \" \" + enclosing.toString());\n+                return;\n+            }\n+\n+            TypeMirror parameterType = parameters.get(0).asType();\n+            if (!types.isSameType(\/* fixme*\/ (Type)parameterType, (Type)expected)) {\n+                System.out.println(\"Unexpected parameter type \" + parameterType + \" on \" + name +\n+                                   \" in \" + enclosing.getKind() + \" \" + enclosing.toString());\n+            }\n+            return;\n+        }\n+\n+        private void checkNoArgs(JCClassDecl tree, Element enclosing, ExecutableElement method) {\n+            String name = method.getSimpleName().toString();\n+            var parameters= method.getParameters();\n+            if (!parameters.isEmpty()) {\n+                System.out.println(\"Unexpected parameters \" + parameters + \" on \" + name +\n+                                   \" in \" + enclosing.getKind() + \" \" + enclosing.toString());\n+            }\n+        }\n+\n+        private void checkExternalizable(JCClassDecl tree, Element enclosing, ExecutableElement method) {\n+            \/\/if the enclosing class is externalizable, warn for the method\n+            if (isExternalizable((Type)enclosing.asType())) {\n+                log.warning(LintCategory.SERIAL, tree.pos(),\n+                            Warnings.IneffectualSerialMethodExternalizable((Symbol)method));\n+            }\n+            return;\n+        }\n+\n+        private void checkExceptions(JCClassDecl tree,\n+                                     Element enclosing,\n+                                     ExecutableElement method,\n+                                     TypeMirror... declaredExceptions) {\n+            for (TypeMirror thrownType: method.getThrownTypes()) {\n+                \/\/ If not an Error and not a RuntimeException, check if a subtype of a blessed exception\n+                if (types.isSubtype(\/*fixme*\/(Type)thrownType, RUNTIME_EXCEPTION_TYPE) ||\n+                    types.isSubtype(\/*fixme*\/(Type)thrownType, J_L_ERROR_TYPE) ) {\n+                    continue;\n+                } else {\n+                    boolean declared = false;\n+                    for (TypeMirror declaredException : declaredExceptions) {\n+                        if (types.isSubtype(\/*fixme*\/(Type)thrownType, \/*fixme*\/(Type)declaredException)) {\n+                            declared = true;\n+                            continue;\n+                        }\n+                    }\n+                    if (!declared) {\n+                        System.out.println(\"Serialization-related method \" + method +\n+                                           \" in \" + enclosing.getKind() + \" \" + enclosing.toString() +\n+                                           \" has unexpected throws clause including \" + thrownType);\n+\n+                    }\n+                }\n+            }\n+            return;\n+        }\n+\n+        \/\/ Implicit cast to ExecutableElement; could also use a kind visitor.\n+        ExecutableElement toMethod(Element element) {\n+            return ElementFilter.methodsIn(List.of(element)).get(0);\n+        }\n+    }\n+\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":760,"deletions":3,"binary":false,"changes":763,"status":"modified"},{"patch":"@@ -1849,0 +1849,3 @@\n+compiler.warn.improper.SPF=\\\n+    serialPersistentFields must be declared private static final to be effective\n+\n@@ -1869,0 +1872,3 @@\n+compiler.warn.OSF.array.SPF=\\\n+    serialPersistentFields must be of type ObjectStreamField[] to be effective\n+\n@@ -1873,0 +1879,47 @@\n+# 0: symbol\n+compiler.warn.serializable.missing.access.no.arg.ctor=\\\n+    cannot access a no-arg constructor in non-serializable superclass {0}\n+\n+# 0: symbol\n+compiler.warn.serial.method.not.private=\\\n+    serialization-related method {0} not declared private\n+\n+# 0: symbol\n+compiler.warn.serial.method.static=\\\n+    serialization-related method {0} declared static; must be an instance method to be effective\n+\n+# 0: symbol\n+compiler.warn.ineffectual.serial.field.enum=\\\n+     serialization-related field {0} is ineffectual in an enum class\n+\n+# 0: symbol\n+compiler.warn.ineffectual.serial.method.enum=\\\n+    serialization-related method {0} is ineffectual in an enum class\n+\n+compiler.warn.ineffectual.serial.field.record=\\\n+    serialPersistentFields is ineffectual in a record class\n+\n+# 0: symbol\n+compiler.warn.ineffectual.serial.method.record=\\\n+    serialization-related method {0} is ineffectual in a record class\n+\n+# 0: symbol\n+compiler.warn.ineffectual.serial.method.externalizable=\\\n+    serialization-related method {0} is ineffectual in an Externalizable class\n+\n+compiler.warn.ineffectual.serial.field.externalizable=\\\n+    serialPersistentFields is ineffectual in an Externalizable class\n+\n+compiler.warn.externalizable.missing.public.no.arg.ctor=\\\n+    an Externalizable class needs a public no-arg constructor\n+\n+compiler.warn.non.serializable.instance.field=\\\n+    non-transient instance field of a serializable class declared with a non-serializable type\n+\n+compiler.warn.non.private.method.weaker.access=\\\n+    serialization-related method declared non-private in an interface will prevent\\n\\\n+    classes implementing the interface from declaring the method as private\n+\n+compiler.warn.default.ineffective=\\\n+    serialization-related default method from an interface will not be run by serialization for an implementing class\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":53,"deletions":0,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -79,0 +79,1 @@\n+    @SuppressWarnings(\"serial\")\n","filename":"src\/jdk.internal.opt\/share\/classes\/jdk\/internal\/joptsimple\/OptionException.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -103,0 +103,1 @@\n+        @SuppressWarnings(\"serial\") \/\/ not statically serializable\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/ConstantPool.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.warn.improper.SPF\n+\/\/ key: compiler.warn.OSF.array.SPF\n+\n+\/\/ options: -Xlint:serial\n+\n+import java.io.Serializable;\n+\n+class ImproperSPF implements Serializable {\n+    \/\/ Proper declaration of serialPersistentFields is:\n+    \/\/ private static final ObjectStreamField[] serialPersistentFields = ...\n+    public \/*instance*\/ Object serialPersistentFields = null;\n+\n+    private static final long serialVersionUID = 42;\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ImproperSPF.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -25,0 +25,3 @@\n+\/\/ key: compiler.warn.constant.SVUID\n+\/\/ key: compiler.warn.long.SVUID\n+\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ImproperSVUID.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.warn.ineffectual.serial.field.enum\n+\/\/ key: compiler.warn.ineffectual.serial.method.enum\n+\n+\/\/ options: -Xlint:serial\n+\n+import java.io.*;\n+\n+enum IneffectualSerialEnum implements Serializable {\n+    INSTANCE;\n+\n+    \/\/ The serialVersionUID field is ineffectual for enum classes.\n+    private static final long serialVersionUID = 42;\n+\n+    \/\/ The readObject method is ineffectual for enum classes.\n+    private void readObject(ObjectInputStream stream)\n+        throws IOException, ClassNotFoundException {\n+        stream.defaultReadObject();\n+        return;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/IneffectualSerialEnum.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.warn.ineffectual.serial.method.externalizable\n+\/\/ key: compiler.warn.ineffectual.serial.field.externalizable\n+\/\/ key: compiler.warn.externalizable.missing.public.no.arg.ctor\n+\n+\/\/ options: -Xlint:serial\n+\n+import java.io.*;\n+\n+class IneffectualSerialExtern implements Externalizable {\n+    private static final long serialVersionUID = 42;\n+\n+    \/\/ Must have a public no-arg constructor\n+    public IneffectualSerialExtern(int foo) {}\n+\n+    public void writeExternal(ObjectOutput out) throws IOException {\n+        return;\n+    }\n+\n+    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n+        return;\n+    }\n+\n+    \/\/ ineffectual\n+    private static final ObjectStreamField[] serialPersistentFields = {};\n+\n+    \/\/ The readObject method is ineffectual for Externalizable classes.\n+    private void readObject(ObjectInputStream stream)\n+        throws IOException, ClassNotFoundException {\n+        stream.defaultReadObject();\n+        return;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/IneffectualSerialExtern.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.warn.ineffectual.serial.field.record\n+\/\/ key: compiler.warn.ineffectual.serial.method.record\n+\n+\/\/ options: -Xlint:serial\n+\n+import java.io.*;\n+\n+record IneffectualSerialRecord(int foo) implements Serializable {\n+\n+    \/\/ A serialPersistentFields is ineffectual for enum classes.\n+    private static final ObjectStreamField[] serialPersistentFields = {};\n+\n+    \/\/ The readObject method is ineffectual for record classes.\n+    private void readObject(ObjectInputStream stream)\n+        throws IOException, ClassNotFoundException {\n+        stream.defaultReadObject();\n+        return;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/IneffectualSerialRecord.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.warn.non.private.method.weaker.access\n+\/\/ key: compiler.warn.default.ineffective\n+\n+\/\/ options: -Xlint:serial\n+\n+import java.io.*;\n+\n+interface SerialInterfaceNonPrivateMethods extends Serializable {\n+    public void readObject(ObjectInputStream stream)\n+        throws IOException, ClassNotFoundException;\n+    public void readObjectNoData() throws ObjectStreamException;\n+    public void writeObject(ObjectOutputStream stream) throws IOException;\n+\n+    default public Object readResolve() throws ObjectStreamException {\n+        return null;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/SerialInterfaceNonPrivateMethods.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.warn.serializable.missing.access.no.arg.ctor\n+\/\/ key: compiler.warn.non.serializable.instance.field\n+\n+\/\/ options: -Xlint:serial\n+\n+import java.io.*;\n+\n+class SerialMissingNoArgCtor {\n+    public SerialMissingNoArgCtor(int foo) {\n+    }\n+\n+    \/\/ Not accessible to SerialSubclass\n+    private SerialMissingNoArgCtor() {}\n+\n+    \/\/ SerialSubclass does not have access to a non-arg ctor in the\n+    \/\/ first non-serializable superclass in its superclass chain.\n+    static class SerialSubclass extends SerialMissingNoArgCtor\n+        implements Serializable {\n+\n+        private static final long serialVersionUID = 42;\n+\n+        \/\/ non-serializable non-transient instance field\n+        private Object data = null;\n+\n+        public SerialSubclass() {\n+            super(1);\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/SerialMissingNoArgCtor.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.warn.serial.method.not.private\n+\/\/ key: compiler.warn.serial.method.static\n+\n+\/\/ options: -Xlint:serial\n+\n+import java.io.*;\n+\n+\n+class SerialNonPrivateMethod implements Serializable {\n+    private static final long serialVersionUID = 42;\n+\n+    \/\/ Should be private\n+    void writeObject(ObjectOutputStream stream) throws IOException {\n+        stream.defaultWriteObject();\n+    }\n+    \n+    \/\/ Should be private non-static\n+   private static void readObject(ObjectInputStream stream)\n+        throws IOException, ClassNotFoundException {\n+        stream.defaultReadObject();\n+    }\n+\n+    \/\/ Make static once additional warning in place\n+    \/\/ private void readObjectNoData() throws ObjectStreamException\n+\n+    \/*\n+     * ANY-ACCESS-MODIFIER Object writeReplace() throws ObjectStreamException\n+     *\n+     * ANY-ACCESS-MODIFIER Object readResolve() throws ObjectStreamException\n+     *\n+     *\/\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/SerialNonPrivateMethod.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -33,0 +33,1 @@\n+import java.io.File;\n@@ -35,0 +36,2 @@\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.FileVisitResult;\n@@ -37,0 +40,1 @@\n+import java.nio.file.SimpleFileVisitor;\n@@ -52,0 +56,14 @@\n+        \/\/ Clean any existing class files in output directory\n+        Files.walkFileTree(testOutputPath,\n+                           new SimpleFileVisitor<Path>() {\n+                               @Override\n+                               public FileVisitResult visitFile(Path path,\n+                                                         BasicFileAttributes attrs) {\n+                                   File file = path.toFile();\n+                                   if (file.getName().endsWith(\".class\")) {\n+                                       file.delete();\n+                                   }\n+                                   return FileVisitResult.CONTINUE;\n+                               }\n+                           });\n+\n","filename":"test\/langtools\/tools\/javac\/processing\/ReportOnImportedModuleAnnotation\/ReportOnImportedModuleAnnotation.java","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8202056\n+ * @compile\/ref=CtorAccess.out -XDrawDiagnostics -Xlint:serial CtorAccess.java\n+ *\/\n+\n+\n+import java.io.*;\n+\n+class CtorAccess {\n+    public CtorAccess(int i) {}\n+\n+    \/\/ Cannot by accessed by SerialSubclass\n+    private CtorAccess(){}\n+\n+    static class SerialSubclass\n+        extends CtorAccess\n+        implements Serializable {\n+        private static final long serialVersionUID = 42;\n+        SerialSubclass() {\n+            super(42);\n+        }\n+    }\n+\n+    \/\/ *not* static\n+    class MemberSuper {\n+        \/\/ Implicit this$0 argument\n+        public MemberSuper() {}\n+    }\n+\n+    class SerialMemberSub\n+        extends MemberSuper\n+        implements Serializable {\n+\n+        SerialMemberSub(){super();}\n+        private static final long serialVersionUID = 42;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/warnings\/Serial\/CtorAccess.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,3 @@\n+CtorAccess.java:16:12: compiler.warn.serializable.missing.access.no.arg.ctor: CtorAccess\n+CtorAccess.java:31:5: compiler.warn.serializable.missing.access.no.arg.ctor: CtorAccess.MemberSuper\n+2 warnings\n","filename":"test\/langtools\/tools\/javac\/warnings\/Serial\/CtorAccess.out","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -0,0 +1,16 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8202056\n+ * @compile\/ref=EnumSerial.out -XDrawDiagnostics -Xlint:serial EnumSerial.java\n+ *\/\n+\n+import java.io.Serializable;\n+\n+\n+enum EnumSerial implements Serializable {\n+    INSTANCE;\n+\n+    \/\/ Verify a warning is generated in an enum for each of the\n+    \/\/ distinguished serial fields and methods.\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/warnings\/Serial\/DeepNesting.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"added"},{"patch":"@@ -0,0 +1,1 @@\n+ \n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/warnings\/Serial\/DeepNesting.out","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8202056\n+ * @compile\/ref=DeepNestingSuppression.out -XDrawDiagnostics -Xlint:serial DeepNestingSuppression.java\n+ *\/\n+\n+import java.io.Serializable;\n+\n+\n+\/*\n+ * Verify suppressing serial warnings works through several levels of\n+ * nested types.\n+ *\/\n+class DeepNestingSuppression {\n+\n+    @SuppressWarnings(\"serial\")\n+    static class SuppressedOuter {\n+        static class Intermediate {\n+            static class Inner implements Serializable {\n+                \/\/ warning for int rather than long svuid\n+                private static final int serialVersionUID = 42;\n+            }\n+        }\n+    }\n+\n+    static class Outer {\n+        static class Intermediate {\n+            static class Inner implements Serializable {\n+                \/\/ warning for int rather than long svuid\n+                private static final int serialVersionUID = 42;\n+            }\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/warnings\/Serial\/DeepNestingSuppression.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+DeepNestingSuppression.java:30:42: compiler.warn.long.SVUID: DeepNestingSuppression.Outer.Intermediate.Inner\n+1 warning\n","filename":"test\/langtools\/tools\/javac\/warnings\/Serial\/DeepNestingSuppression.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8202056\n+ * @compile\/ref=EnumSerial.out -XDrawDiagnostics -Xlint:serial EnumSerial.java\n+ *\/\n+\n+import java.io.*;\n+\n+enum EnumSerial implements Serializable {\n+    INSTANCE;\n+\n+    \/\/ Verify a warning is generated in an enum for each of the\n+    \/\/ distinguished serial fields and methods.\n+\n+    private static final long serialVersionUID = 42;\n+    private static final ObjectStreamField[] serialPersistentFields = {};\n+\n+    private void writeObject(ObjectOutputStream stream) throws IOException {\n+        stream.defaultWriteObject();\n+    }\n+\n+    private Object writeReplace() throws ObjectStreamException {\n+        return null;\n+    }\n+\n+    private void readObject(ObjectInputStream stream)\n+        throws IOException, ClassNotFoundException {\n+        stream.defaultReadObject();\n+    }\n+\n+    private void readObjectNoData() throws ObjectStreamException {\n+        return;\n+    }\n+\n+    private Object readResolve() throws ObjectStreamException {\n+        return null;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/warnings\/Serial\/EnumSerial.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,8 @@\n+EnumSerial.java:9:1: compiler.warn.ineffectual.serial.field.enum: serialVersionUID\n+EnumSerial.java:9:1: compiler.warn.ineffectual.serial.field.enum: serialPersistentFields\n+EnumSerial.java:9:1: compiler.warn.ineffectual.serial.method.enum: writeObject(java.io.ObjectOutputStream)\n+EnumSerial.java:9:1: compiler.warn.ineffectual.serial.method.enum: writeReplace()\n+EnumSerial.java:9:1: compiler.warn.ineffectual.serial.method.enum: readObject(java.io.ObjectInputStream)\n+EnumSerial.java:9:1: compiler.warn.ineffectual.serial.method.enum: readObjectNoData()\n+EnumSerial.java:9:1: compiler.warn.ineffectual.serial.method.enum: readResolve()\n+7 warnings\n","filename":"test\/langtools\/tools\/javac\/warnings\/Serial\/EnumSerial.out","additions":8,"deletions":0,"binary":false,"changes":8,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8202056\n+ * @compile\/ref=Extern.out -XDrawDiagnostics -Xlint:serial Extern.java\n+ *\/\n+\n+\n+import java.io.*;\n+\n+class Extern implements Externalizable {\n+    private static final long serialVersionUID = 42;\n+\n+    \/\/ No-arg constructor on an Externalizable class must be public\n+    protected Extern() {}\n+\n+    \/\/ ineffectual\n+    private static final ObjectStreamField[] serialPersistentFields = {};\n+\n+    public void writeExternal(ObjectOutput out) throws IOException {\n+        return;\n+    }\n+\n+    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n+        return;\n+    }\n+\n+    \/\/ ineffectual\n+    private void readObject(ObjectInputStream stream)\n+        throws IOException, ClassNotFoundException {\n+        stream.defaultReadObject();\n+    }\n+\n+    \/\/ ineffectual\n+    private void writeObject(ObjectOutputStream stream) throws IOException {\n+        stream.defaultWriteObject();\n+    }\n+\n+    \/\/ ineffectual\n+    private void readObjectNoData() throws ObjectStreamException {\n+        return;\n+    }\n+\n+    \/\/ (possibly) effective\n+    private Object writeReplace() throws ObjectStreamException {\n+        return null;\n+    }\n+\n+    \/\/ (possibly) effective\n+    private Object readResolve() throws ObjectStreamException {\n+        return null;\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/warnings\/Serial\/Extern.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,6 @@\n+Extern.java:10:1: compiler.warn.externalizable.missing.public.no.arg.ctor\n+Extern.java:10:1: compiler.warn.ineffectual.serial.field.externalizable\n+Extern.java:10:1: compiler.warn.ineffectual.serial.method.externalizable: readObject(java.io.ObjectInputStream)\n+Extern.java:10:1: compiler.warn.ineffectual.serial.method.externalizable: writeObject(java.io.ObjectOutputStream)\n+Extern.java:10:1: compiler.warn.ineffectual.serial.method.externalizable: readObjectNoData()\n+5 warnings\n","filename":"test\/langtools\/tools\/javac\/warnings\/Serial\/Extern.out","additions":6,"deletions":0,"binary":false,"changes":6,"status":"added"},{"patch":"@@ -0,0 +1,15 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8202056\n+ * @compile\/ref=ImproperSerialPF.out -XDrawDiagnostics -Xlint:serial ImproperSerialPF.java\n+ *\/\n+\n+import java.io.*;\n+\n+class ImproperSerialPF implements Serializable {\n+    \/\/ Proper declaration of serialPersistentFields is:\n+    \/\/ private static final ObjectStreamField[] serialPersistentFields = ...\n+    public \/*instance*\/ Object serialPersistentFields = null;\n+\n+    private static final long serialVersionUID = 42;\n+}\n","filename":"test\/langtools\/tools\/javac\/warnings\/Serial\/ImproperSerialPF.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"},{"patch":"@@ -0,0 +1,3 @@\n+ImproperSerialPF.java:12:32: compiler.warn.improper.SPF\n+ImproperSerialPF.java:12:32: compiler.warn.OSF.array.SPF\n+2 warnings\n","filename":"test\/langtools\/tools\/javac\/warnings\/Serial\/ImproperSerialPF.out","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8202056\n+ * @compile\/ref=InstanceField.out -XDrawDiagnostics -Xlint:serial InstanceField.java\n+ *\/\n+\n+\n+import java.io.*;\n+\n+class IntanceField implements Serializable {\n+    private static final long serialVersionUID = 42;\n+\n+    \/\/ Non-transient instance fields in a serializable class w\/o\n+    \/\/ serialPersistentFields defined should get warnings if the type\n+    \/\/ of the field cannot be serialized.\n+\n+    private Object foo;\n+\n+    \/\/ No warnings\n+\n+    private Object[] foos; \/\/ Per JLS Object[] is a subtype of Serializable\n+\n+    private static Object bar;\n+\n+    private static Object[] bars;\n+\n+    private int baz;\n+\n+    private double[] quux;\n+\n+    static class NestedInstance implements Serializable {\n+        private static final long serialVersionUID = 24;\n+\n+        \/\/ Should disable instance field warnings\n+        private static final ObjectStreamField[] serialPersistentFields = {};\n+\n+        private Object foo;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/warnings\/Serial\/InstanceField.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+InstanceField.java:17:20: compiler.warn.non.serializable.instance.field\n+1 warning\n","filename":"test\/langtools\/tools\/javac\/warnings\/Serial\/InstanceField.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8202056\n+ * @compile\/ref=InterfaceNonPrivateMethods.out -XDrawDiagnostics -Xlint:serial InterfaceNonPrivateMethods.java\n+ *\/\n+\n+import java.io.*;\n+\n+\/\/ Holder class\n+class InterfaceNonPrivateMethods {\n+\n+    interface NonPrivateMethods extends Serializable {\n+        public void readObject(ObjectInputStream stream)\n+            throws IOException, ClassNotFoundException;\n+        public void readObjectNoData() throws ObjectStreamException;\n+        public void writeObject(ObjectOutputStream stream) throws IOException;\n+\n+        \/\/ Ineffective default methods; serialization only looks up\n+        \/\/ superclass chain\n+        public default Object writeReplace() throws ObjectStreamException {\n+            return null;\n+        }\n+        public default Object readResolve() throws ObjectStreamException {\n+            return null;\n+        }\n+    }\n+\n+    interface NonPrivateMethodsDefaults extends Serializable {\n+        default public void readObject(ObjectInputStream stream)\n+            throws IOException, ClassNotFoundException {\n+            return;\n+        }\n+        default public void readObjectNoData()\n+            throws ObjectStreamException {\n+            return;\n+        }\n+        default public void writeObject(ObjectOutputStream stream)\n+            throws IOException {\n+            return;\n+        }\n+    }\n+}\n+\n","filename":"test\/langtools\/tools\/javac\/warnings\/Serial\/InterfaceNonPrivateMethods.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,9 @@\n+InterfaceNonPrivateMethods.java:13:21: compiler.warn.non.private.method.weaker.access\n+InterfaceNonPrivateMethods.java:15:21: compiler.warn.non.private.method.weaker.access\n+InterfaceNonPrivateMethods.java:16:21: compiler.warn.non.private.method.weaker.access\n+InterfaceNonPrivateMethods.java:20:31: compiler.warn.default.ineffective\n+InterfaceNonPrivateMethods.java:23:31: compiler.warn.default.ineffective\n+InterfaceNonPrivateMethods.java:29:29: compiler.warn.non.private.method.weaker.access\n+InterfaceNonPrivateMethods.java:33:29: compiler.warn.non.private.method.weaker.access\n+InterfaceNonPrivateMethods.java:37:29: compiler.warn.non.private.method.weaker.access\n+8 warnings\n","filename":"test\/langtools\/tools\/javac\/warnings\/Serial\/InterfaceNonPrivateMethods.out","additions":9,"deletions":0,"binary":false,"changes":9,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8202056\n+ * @compile\/ref=RecordSerial.out -XDrawDiagnostics -Xlint:serial RecordSerial.java\n+ *\/\n+\n+import java.io.*;\n+\n+record RecordSerial(int foo) implements Serializable {\n+    \/\/ Verify a warning is generated in an enum for each of the\n+    \/\/ ineffectual serial fields and methods.\n+\n+    \/\/ partially effective\n+    private static final long serialVersionUID = 42;\n+\n+    \/\/ ineffectual\n+    private static final ObjectStreamField[] serialPersistentFields = {};\n+\n+    \/\/ ineffectual\n+    private void writeObject(ObjectOutputStream stream) throws IOException {\n+        stream.defaultWriteObject();\n+    }\n+\n+    \/\/ (possibly) effective\n+    private Object writeReplace() throws ObjectStreamException {\n+        return null;\n+    }\n+\n+    \/\/ ineffectual\n+    private void readObject(ObjectInputStream stream)\n+        throws IOException, ClassNotFoundException {\n+        stream.defaultReadObject();\n+    }\n+\n+    \/\/ ineffectual\n+    private void readObjectNoData() throws ObjectStreamException {\n+        return;\n+    }\n+\n+    \/\/ (possibly) effective\n+    private Object readResolve() throws ObjectStreamException {\n+        return null;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/warnings\/Serial\/RecordSerial.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,5 @@\n+RecordSerial.java:9:1: compiler.warn.ineffectual.serial.field.record\n+RecordSerial.java:9:1: compiler.warn.ineffectual.serial.method.record: writeObject(java.io.ObjectOutputStream)\n+RecordSerial.java:9:1: compiler.warn.ineffectual.serial.method.record: readObject(java.io.ObjectInputStream)\n+RecordSerial.java:9:1: compiler.warn.ineffectual.serial.method.record: readObjectNoData()\n+4 warnings\n","filename":"test\/langtools\/tools\/javac\/warnings\/Serial\/RecordSerial.out","additions":5,"deletions":0,"binary":false,"changes":5,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8202056\n+ * @compile\/ref=SerialMethodMods.out -XDrawDiagnostics -Xlint:serial SerialMethodMods.java\n+ *\/\n+\n+\n+import java.io.*;\n+\n+class SerialMethodMods implements Serializable {\n+    private static final long serialVersionUID = 42;\n+\n+    \/\/ Should be private\n+    void writeObject(ObjectOutputStream stream) throws IOException {\n+        stream.defaultWriteObject();\n+    }\n+    \n+    \/\/ Should be private\n+    public void readObject(ObjectInputStream stream)\n+        throws IOException, ClassNotFoundException {\n+        stream.defaultReadObject();\n+    }\n+\n+    \/\/ Make static once additional warning in place\n+    \/\/ private void readObjectNoData() throws ObjectStreamException\n+\n+    \/*\n+     * ANY-ACCESS-MODIFIER Object writeReplace() throws ObjectStreamException\n+     *\n+     * ANY-ACCESS-MODIFIER Object readResolve() throws ObjectStreamException\n+     *\n+     *\/\n+}\n","filename":"test\/langtools\/tools\/javac\/warnings\/Serial\/SerialMethodMods.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,3 @@\n+SerialMethodMods.java:14:10: compiler.warn.serial.method.not.private: writeObject(java.io.ObjectOutputStream)\n+SerialMethodMods.java:19:17: compiler.warn.serial.method.not.private: readObject(java.io.ObjectInputStream)\n+2 warnings\n","filename":"test\/langtools\/tools\/javac\/warnings\/Serial\/SerialMethodMods.out","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"}]}