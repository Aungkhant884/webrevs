{"files":[{"patch":"@@ -5752,0 +5752,1 @@\n+                        VarSymbol field = (VarSymbol)enclosed;\n@@ -5753,2 +5754,2 @@\n-                        case \"serialVersionUID\"       ->  checkSerialVersionUID(tree, e, enclosed);\n-                        case \"serialPersistentFields\" ->  checkSerialPersistentFields(tree, e, enclosed);\n+                        case \"serialVersionUID\"       ->  checkSerialVersionUID(tree, e, field);\n+                        case \"serialPersistentFields\" ->  checkSerialPersistentFields(tree, e, field);\n@@ -5780,1 +5781,4 @@\n-                \/\/ could be missed.\n+                \/\/ could be missed. In particular, readResolve and\n+                \/\/ writeReplace could, in principle, by inherited from\n+                \/\/ a non-serializable superclass and thus not checked\n+                \/\/ even if compiled with a serializable child class.\n@@ -5858,3 +5862,3 @@\n-        private void checkSerialVersionUID(JCClassDecl tree, Element e, Element field) {\n-            \/\/ To be effective, serialVersionUID must be marked\n-            \/\/ static and final, but private is recommended.\n+        private void checkSerialVersionUID(JCClassDecl tree, Element e, VarSymbol svuid) {\n+            \/\/ To be effective, serialVersionUID must be marked static\n+            \/\/ and final, but private is recommended.\n@@ -5865,7 +5869,5 @@\n-            \/\/ TODO: need to pass in warningKey of type Warning...\n-\/\/             if ((svuid.flags() & (STATIC | FINAL)) !=\n-\/\/                 (STATIC | FINAL))\n-\/\/                 log.warning(LintCategory.SERIAL,\n-\/\/                         TreeInfo.diagnosticPositionFor(svuid, tree), Warnings.ImproperSVUID(c));\n-\n-            checkMandatoryModifiers(tree, e, field, STATIC_FINAL_MODS, Warnings.ImproperSVUID( (Symbol) e));\n+             if ((svuid.flags() & (STATIC | FINAL)) !=\n+                 (STATIC | FINAL)) {\n+                 log.warning(LintCategory.SERIAL,\n+                             TreeInfo.diagnosticPositionFor(svuid, tree), Warnings.ImproperSVUID((Symbol)e));\n+             }\n@@ -5877,1 +5879,1 @@\n-            checkTypeOfField(tree, e, field, LONG_TYPE, Warnings.LongSVUID((Symbol) e));\n+            checkTypeOfField(tree, e, svuid, LONG_TYPE, Warnings.LongSVUID((Symbol) e));\n@@ -5879,2 +5881,1 @@\n-            VarSymbol svuidField = (VarSymbol)field;\n-            if (svuidField.getConstValue() == null)\n+            if (svuid.getConstValue() == null)\n@@ -5882,1 +5883,1 @@\n-                            TreeInfo.diagnosticPositionFor(svuidField, tree),\n+                            TreeInfo.diagnosticPositionFor(svuid, tree),\n@@ -5886,1 +5887,1 @@\n-        private void checkSerialPersistentFields(JCClassDecl tree, Element e, Element field) {\n+        private void checkSerialPersistentFields(JCClassDecl tree, Element e, VarSymbol spf) {\n@@ -5888,2 +5889,7 @@\n-            checkMandatoryModifiers(tree, e, field, PRIVATE_STATIC_FINAL_MODS, null \/*FIXME*\/);\n-            checkTypeOfField(tree, e, field, OSF_TYPE);\n+             if ((spf.flags() & (PRIVATE | STATIC | FINAL)) !=\n+                 (PRIVATE | STATIC | FINAL)) {\n+                 log.warning(LintCategory.SERIAL,\n+                             TreeInfo.diagnosticPositionFor(spf, tree), Warnings.ImproperSPF);\n+             }\n+\n+             \/\/ TOOD: checkTypeOfField(tree, e, spf, OSF_TYPE);\n@@ -5895,1 +5901,0 @@\n-\n@@ -5913,2 +5918,1 @@\n-            checkMandatoryModifiers(tree, e, method, PRIVATE_MODS, null \/*FIXME*\/);\n-            checkExcludedModifiers(tree, e,  method, STATIC_MODS);\n+            checkPrivateNonStaticMethod(tree, (MethodSymbol)method);\n@@ -5934,0 +5938,1 @@\n+            MethodSymbol methodSym = (MethodSymbol)method;\n@@ -5939,3 +5944,2 @@\n-            \/\/ throws IOException, ClassNotFoundException\n-            checkMandatoryModifiers(tree, e, method, PRIVATE_MODS, null \/*FIXME*\/);\n-            checkExcludedModifiers(tree, e,  method, STATIC_MODS);\n+            \/\/   throws IOException, ClassNotFoundException\n+            checkPrivateNonStaticMethod(tree, (MethodSymbol)method);\n@@ -5949,4 +5953,2 @@\n-            \/\/ private void readObjectNoData()\n-            \/\/ throws ObjectStreamException\n-            checkMandatoryModifiers(tree, e, method, PRIVATE_MODS, null \/*FIXME*\/);\n-            checkExcludedModifiers(tree, e,  method, STATIC_MODS);\n+            \/\/ private void readObjectNoData() throws ObjectStreamException\n+            checkPrivateNonStaticMethod(tree, (MethodSymbol)method);\n@@ -5971,0 +5973,15 @@\n+        void checkPrivateNonStaticMethod(JCClassDecl tree, MethodSymbol method) {\n+            var flags = method.flags();\n+            if ((flags & PRIVATE) == 0) {\n+                log.warning(LintCategory.SERIAL,\n+                            TreeInfo.diagnosticPositionFor(method, tree),\n+                            Warnings.SerialMethodNotPrivate(method));\n+            }\n+\n+            if ((flags & STATIC) != 0) {\n+                log.warning(LintCategory.SERIAL,\n+                            TreeInfo.diagnosticPositionFor(method, tree),\n+                            Warnings.SerialMethodStatic(method));\n+            }\n+        }\n+\n@@ -6135,1 +6152,1 @@\n-                        checkSerialVersionUID(tree, e, enclosed);\n+                        checkSerialVersionUID(tree, e, (VarSymbol)enclosed);\n@@ -6200,22 +6217,0 @@\n-        void checkMandatoryModifiers(JCClassDecl tree,\n-                                     Element enclosing,\n-                                     Element element,\n-                                     Set<Modifier> mandatoryMods,\n-                                     Warning warningKey) {\n-            String name = element.getSimpleName().toString();\n-            Set<Modifier> mods = element.getModifiers();\n-            for (Modifier mandatoryMod : mandatoryMods) {\n-                if (!mods.contains(mandatoryMod) ) {\n-                    if (warningKey == null) {\n-                        System.out.println(\"Serialization-related declaration \" + name +\n-                                           \" in \" + enclosing.getKind() + \" \" + enclosing.toString() +\n-                                           \" is missing expected modifier \" + mandatoryMod);\n-                    } else {\n-                        log.warning(LintCategory.SERIAL,\n-                                    TreeInfo.diagnosticPositionFor((Symbol)element, tree),\n-                                    warningKey);\n-                    }\n-                }\n-            }\n-        }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":48,"deletions":53,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -1849,0 +1849,3 @@\n+compiler.warn.improper.SPF=\\\n+    serialPersistentFields must be declared private static final to be effective\n+\n@@ -1877,0 +1880,8 @@\n+# 0: symbol\n+compiler.warn.serial.method.not.private=\\\n+    serialization-related method {0} not declared private\n+\n+# 0: symbol\n+compiler.warn.serial.method.static=\\\n+    serialization-related method {0} declared static; must be an instance method to be effective\n+\n@@ -1879,1 +1890,1 @@\n-     serialiation-related field {0} is ineffectual in an enum class\n+     serialization-related field {0} is ineffectual in an enum class\n@@ -1883,1 +1894,1 @@\n-    serialiation-related method {0} is ineffectual in an enum class\n+    serialization-related method {0} is ineffectual in an enum class\n@@ -1890,1 +1901,1 @@\n-    serialiation-related method {0} is ineffectual in a record class\n+    serialization-related method {0} is ineffectual in a record class\n@@ -1894,1 +1905,1 @@\n-    serialiation-related method {0} is ineffectual in an Externalizable class\n+    serialization-related method {0} is ineffectual in an Externalizable class\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.warn.improper.SPF\n+\n+\/\/ options: -Xlint:serial\n+\n+import java.io.Serializable;\n+\n+class ImproperSPF implements Serializable {\n+    \/\/ Proper declaration of serialPersistentFields is:\n+    \/\/ private static final ObjectStreamField[] serialPersistentFields = ...\n+    public \/*instance*\/ Object serialPersistentFields = null;\n+\n+    private static final long serialVersionUID = 42;\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ImproperSPF.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.warn.serial.method.not.private\n+\/\/ key: compiler.warn.serial.method.static\n+\n+\/\/ options: -Xlint:serial\n+\n+import java.io.*;\n+\n+\n+class SerialNonPrivateMethod implements Serializable {\n+    private static final long serialVersionUID = 42;\n+\n+    \/\/ Should be private\n+    void writeObject(ObjectOutputStream stream) throws IOException {\n+        stream.defaultWriteObject();\n+    }\n+    \n+    \/\/ Should be private non-static\n+   private static void readObject(ObjectInputStream stream)\n+        throws IOException, ClassNotFoundException {\n+        stream.defaultReadObject();\n+    }\n+\n+    \/\/ Make static once additional warning in place\n+    \/\/ private void readObjectNoData() throws ObjectStreamException\n+\n+    \/*\n+     * ANY-ACCESS-MODIFIER Object writeReplace() throws ObjectStreamException\n+     *\n+     * ANY-ACCESS-MODIFIER Object readResolve() throws ObjectStreamException\n+     *\n+     *\/\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/SerialNonPrivateMethod.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,15 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8202056\n+ * @compile\/ref=ImproperSerialPF.out -XDrawDiagnostics -Xlint:serial ImproperSerialPF.java\n+ *\/\n+\n+import java.io.*;\n+\n+class ImproperSerialPF implements Serializable {\n+    \/\/ Proper declaration of serialPersistentFields is:\n+    \/\/ private static final ObjectStreamField[] serialPersistentFields = ...\n+    public \/*instance*\/ Object serialPersistentFields = null;\n+\n+    private static final long serialVersionUID = 42;\n+}\n","filename":"test\/langtools\/tools\/javac\/warnings\/Serial\/ImproperSerialPF.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+ImproperSerialPF.java:12:32: compiler.warn.improper.SPF\n+1 warning\n","filename":"test\/langtools\/tools\/javac\/warnings\/Serial\/ImproperSerialPF.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8202056\n+ * @compile\/ref=SerialMethodMods.out -XDrawDiagnostics -Xlint:serial SerialMethodMods.java\n+ *\/\n+\n+\n+import java.io.*;\n+\n+class SerialMethodMods implements Serializable {\n+    private static final long serialVersionUID = 42;\n+\n+    \/\/ Should be private\n+    void writeObject(ObjectOutputStream stream) throws IOException {\n+        stream.defaultWriteObject();\n+    }\n+    \n+    \/\/ Should be private\n+    public void readObject(ObjectInputStream stream)\n+        throws IOException, ClassNotFoundException {\n+        stream.defaultReadObject();\n+    }\n+\n+    \/\/ Make static once additional warning in place\n+    \/\/ private void readObjectNoData() throws ObjectStreamException\n+\n+    \/*\n+     * ANY-ACCESS-MODIFIER Object writeReplace() throws ObjectStreamException\n+     *\n+     * ANY-ACCESS-MODIFIER Object readResolve() throws ObjectStreamException\n+     *\n+     *\/\n+}\n","filename":"test\/langtools\/tools\/javac\/warnings\/Serial\/SerialMethodMods.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,3 @@\n+SerialMethodMods.java:14:10: compiler.warn.serial.method.not.private: writeObject(java.io.ObjectOutputStream)\n+SerialMethodMods.java:19:17: compiler.warn.serial.method.not.private: readObject(java.io.ObjectInputStream)\n+2 warnings\n","filename":"test\/langtools\/tools\/javac\/warnings\/Serial\/SerialMethodMods.out","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"}]}