{"files":[{"patch":"@@ -516,28 +516,0 @@\n-\/\/ When entering signal handling with a valid current Thread, we switch to the\n-\/\/  Thread's secondary resource area. That lets us safely use resource area\n-\/\/  memory during signal handling even if the signal left the primary area in\n-\/\/  an inconsistent state. We then swap back to the primary area upon leaving\n-\/\/  the signal handler.\n-\/\/ Note that signal handlers can nest, and in theory we should do this on each\n-\/\/  signal handler invocation, building up a stack of fresh resource areas.\n-\/\/  But that is either expensive (would have to preallocate them all upfront,\n-\/\/  and then, how many?) or dangerous (would have to allocate them on demand\n-\/\/  in the signal handler for each recursion) and its really not\n-\/\/  worth the trouble. We keep matters simple with just two resource areas.\n-class ResourceAreaSwitcher : public StackObj {\n-  Thread* const _t;\n-public:\n-  ResourceAreaSwitcher(Thread* t) : _t(t) {\n-    if (_t != NULL) {\n-      \/\/ Note: does nothing if we already use the secondary RA\n-      _t->switch_to_secondary_resource_area();\n-    }\n-  }\n-  ~ResourceAreaSwitcher() {\n-    if (_t != NULL) {\n-      \/\/ Note: does nothing if we already use the primary RA\n-      _t->switch_to_primary_resource_area();\n-    }\n-  }\n-};\n-\n@@ -621,1 +593,1 @@\n-  ResourceAreaSwitcher resourceAreaSwitcher(t);\n+  Thread::ResourceAreaSwitcher ra_switcher(t);\n","filename":"src\/hotspot\/os\/posix\/signals_posix.cpp","additions":1,"deletions":29,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -575,0 +575,4 @@\n+  \/\/ This makes it safe to use ResourceArea memory while in this function (which may\n+  \/\/ have been triggered by an asynchronous signal).\n+  Thread::ResourceAreaSwitcher ra_switcher(thread);\n+\n","filename":"src\/hotspot\/share\/prims\/forte.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -283,0 +283,7 @@\n+\/\/ Primary and secondary resource areas:\n+\/\/\n+\/\/ A thread has, beside its normal resource area (the primary), a secondary one.\n+\/\/ This can be used when we are unsure about the state of the primary area, e.g.\n+\/\/ when running inside a signal handler which may have left the primary area in\n+\/\/ an inconsistent state.\n+\n@@ -284,1 +291,4 @@\n-  _resource_area = _resource_areas[0];\n+  _secondary_resource_area_switch_count --;\n+  if (_secondary_resource_area_switch_count == 0) {\n+    _resource_area = _resource_areas[0];\n+  }\n@@ -288,1 +298,4 @@\n-  _resource_area = _resource_areas[1];\n+  if (_secondary_resource_area_switch_count == 0) {\n+    _resource_area = _resource_areas[1];\n+  }\n+  _secondary_resource_area_switch_count ++;\n@@ -295,0 +308,13 @@\n+  _secondary_resource_area_switch_count = 0;\n+}\n+\n+Thread::ResourceAreaSwitcher::ResourceAreaSwitcher(Thread* t) : _t(t) {\n+  if (_t != NULL) {\n+    _t->switch_to_secondary_resource_area();\n+  }\n+}\n+\n+Thread::ResourceAreaSwitcher::~ResourceAreaSwitcher() {\n+  if (_t != NULL) {\n+    _t->switch_to_primary_resource_area();\n+  }\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":28,"deletions":2,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -410,3 +410,9 @@\n-  \/\/ Switch between primary and secondary resource areas\n-  void switch_to_primary_resource_area();\n-  void switch_to_secondary_resource_area();\n+  \/\/ A RAII object to switch the thread to the secondary resource area. Use this in\n+  \/\/ situations where you plan to use resource area memory but are unsure about\n+  \/\/ the state of the primary resource area (e.g. while handling async signals).\n+  class ResourceAreaSwitcher : public StackObj {\n+    Thread* const _t; \/\/ NULL is allowed and result in noop\n+  public:\n+    ResourceAreaSwitcher(Thread* t);\n+    ~ResourceAreaSwitcher();\n+  };\n@@ -544,0 +550,3 @@\n+  \/\/ The number of times we switched to the second resource area.\n+  int _secondary_resource_area_switch_count;\n+\n@@ -545,0 +554,2 @@\n+  void switch_to_primary_resource_area();\n+  void switch_to_secondary_resource_area();\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":14,"deletions":3,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1465,0 +1465,6 @@\n+  \/\/ Switch to the secondary resource area for the current thread to make it safe to use\n+  \/\/ RA memory during error reporting. This is just needed for the rare case that the primary\n+  \/\/ RA is broken, but we did enter via assert, not via signal (in fact, the broken primary RA\n+  \/\/ may have caused the assert).\n+  Thread::ResourceAreaSwitcher ra_switcher(Thread::current_or_null_safe());\n+\n@@ -1506,9 +1512,0 @@\n-    \/\/ Switch to the secondary resource area for the current thread to make it safe to use\n-    \/\/ RA memory during error reporting. This is just needed for the rare case that the primary\n-    \/\/ RA is broken, but we did enter via assert, not via signal (in fact, the broken primary RA\n-    \/\/ may have caused the assert).\n-    if (_thread) {\n-      _thread->switch_to_secondary_resource_area();\n-    }\n-\n-\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"}]}