{"files":[{"patch":"@@ -374,1 +374,0 @@\n-  HeapWord* prev_p = nullptr;\n@@ -377,1 +376,0 @@\n-    prev_p = p;\n@@ -381,5 +379,0 @@\n-  if (top() != end()) {\n-    guarantee(top() == block_start_const(end()-1) &&\n-              top() == block_start_const(top()),\n-              \"top should be start of unallocated block, if it exists\");\n-  }\n@@ -518,34 +511,0 @@\n-#define OBJ_SAMPLE_INTERVAL 0\n-#define BLOCK_SAMPLE_INTERVAL 100\n-\n-void TenuredSpace::verify() const {\n-  HeapWord* p = bottom();\n-  HeapWord* prev_p = nullptr;\n-  int objs = 0;\n-  int blocks = 0;\n-\n-  while (p < top()) {\n-    size_t size = cast_to_oop(p)->size();\n-    \/\/ For a sampling of objects in the space, find it using the\n-    \/\/ block offset table.\n-    if (blocks == BLOCK_SAMPLE_INTERVAL) {\n-      guarantee(p == block_start_const(p + (size\/2)),\n-                \"check offset computation\");\n-      blocks = 0;\n-    } else {\n-      blocks++;\n-    }\n-\n-    if (objs == OBJ_SAMPLE_INTERVAL) {\n-      oopDesc::verify(cast_to_oop(p));\n-      objs = 0;\n-    } else {\n-      objs++;\n-    }\n-    prev_p = p;\n-    p += size;\n-  }\n-  guarantee(p == top(), \"end of last object must match end of space\");\n-}\n-\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/space.cpp","additions":0,"deletions":41,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -197,3 +197,0 @@\n-\n-  \/\/ Debugging\n-  virtual void verify() const = 0;\n@@ -399,1 +396,1 @@\n-  void verify() const override;\n+  void verify() const;\n@@ -429,3 +426,0 @@\n-\n-  \/\/ Debugging\n-  void verify() const override;\n","filename":"src\/hotspot\/share\/gc\/shared\/space.hpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"}]}