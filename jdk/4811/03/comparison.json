{"files":[{"patch":"@@ -53,0 +53,1 @@\n+import java.util.HashSet;\n@@ -56,0 +57,1 @@\n+import java.util.Set;\n@@ -59,0 +61,1 @@\n+import java.util.stream.Collectors;\n@@ -176,0 +179,6 @@\n+    \/** History of calls to checkOutput *\/\n+    private final Map<FileAndFlag, Set<StringsAndStacktrace>> checkOutputCalls = new HashMap<>();\n+    \/\/ The below two records are implicitly static\n+    private record FileAndFlag(String file, boolean expectFound) { }\n+    private record StringsAndStacktrace(List<String> strings, List<StackWalker.StackFrame> stackFrames) { }\n+\n@@ -310,0 +319,1 @@\n+        checkOutputCalls.clear();\n@@ -501,0 +511,7 @@\n+     *\n+     * @throws IllegalArgumentException as a protective measure against a\n+     * situation where there exists a pair of strings s1 and s2 among the\n+     * provided so far such that s1.contains(s2). Such a situation is confusing\n+     * and might indicate a bug because in order for the check to succeed, it\n+     * suffices for the output to (not) contain only one of these strings. Which\n+     * one, depends on the {@code expectFound} flag.\n@@ -522,0 +539,7 @@\n+     *\n+     * @throws IllegalArgumentException as a protective measure against a\n+     * situation where there exists a pair of strings s1 and s2 among the\n+     * provided so far such that s1.contains(s2). Such a situation is confusing\n+     * and might indicate a bug because in order for the check to succeed, it\n+     * suffices for the output to (not) contain only one of these strings. Which\n+     * one, depends on the {@code expectFound} flag.\n@@ -529,0 +553,1 @@\n+        checkConfusingStrings(path, fileString, expectedFound, strings);\n@@ -546,0 +571,92 @@\n+    \/*\n+     * This method might double-count confusing strings because the call data is\n+     * stored unconditionally. This is to report all errors at once.\n+     *\/\n+    private void checkConfusingStrings(String path, String fileString, boolean expectedFound, String... strings) {\n+        FileAndFlag key = new FileAndFlag(path, expectedFound);\n+        \/\/ get the relevant stacktrace (i.e. without topmost frames related to JavadocTester)\n+        List<StackWalker.StackFrame> frames = StackWalker.getInstance(StackWalker.Option.RETAIN_CLASS_REFERENCE)\n+                .walk(s -> s.dropWhile(f -> f.getDeclaringClass() == JavadocTester.class).toList());\n+        StringsAndStacktrace value = new StringsAndStacktrace(List.of(strings), frames);\n+        Set<StringsAndStacktrace> prevSet = checkOutputCalls.getOrDefault(key, Set.of());\n+        checkOutputCalls.put(key, mergeSets(prevSet, Set.of(value)));\n+        Map<String, Set<String>> thisCallConfusingStrings = findConfusingStrings(Arrays.asList(strings));\n+        String details = \"\";\n+        if (!thisCallConfusingStrings.isEmpty()) {\n+            details += \"Confusing strings in this call:\\n\";\n+            details += \"Currently called from:\\n\\n\" + stringFromStackFrames(value.stackFrames()).indent(4) + \"\\n\";\n+            details += describeConfusingStrings(fileString, thisCallConfusingStrings);\n+        }\n+        for (var stringsAndStacktrace : prevSet) {\n+            Map<String, Set<String>> prevCallConfusingStrings = findConfusingStrings(mergeLists(stringsAndStacktrace.strings(), List.of(strings)));\n+            if (!prevCallConfusingStrings.equals(thisCallConfusingStrings)) {\n+                details += \"Confusing strings across this and previous calls:\\n\";\n+                details += \"Currently called from:\\n\\n\" + stringFromStackFrames(value.stackFrames()).indent(4) + \"\\n\";\n+                details += \"Previously called from:\\n\\n\" + stringFromStackFrames(stringsAndStacktrace.stackFrames()).indent(4) + \"\\n\";\n+                details += describeConfusingStrings(fileString, prevCallConfusingStrings) + \"\\n\";\n+            }\n+        }\n+        if (!details.isEmpty()) {\n+\/\/            System.out.println(details);\n+            throw new IllegalArgumentException(details);\n+        }\n+    }\n+\n+    private static String describeConfusingStrings(String fileString, Map<String, Set<String>> thisCallConfusingStrings) {\n+        StringBuilder detail = new StringBuilder();\n+        thisCallConfusingStrings.forEach((subString, superStrings) -> {\n+            long count = Pattern.compile(Pattern.quote(subString)).matcher(fileString).results().count();\n+            String sup = String.join(\"\\n\\n\", superStrings);\n+            detail.append(\n+                    \"\"\"\n+                    substring:\n+                    %s\n+                    number of occurrences in the output:\n+                    %s\n+                    superstrings:\n+                    %s\n+\n+                    \"\"\".formatted(subString, count, sup));\n+        });\n+        return detail.toString().indent(4);\n+    }\n+\n+    private static String stringFromStackFrames(List<StackWalker.StackFrame> value) {\n+        return value.stream().map(Object::toString).collect(Collectors.joining(\"\\n\"));\n+    }\n+\n+    private static <T> Set<T> mergeSets(Set<T> a, Set<T> b) {\n+        var merged = new HashSet<>(a);\n+        merged.addAll(b);\n+        return merged;\n+    }\n+\n+    private static <T> List<T> mergeLists(List<T> a, List<T> b) {\n+        var merged = new ArrayList<>(a);\n+        merged.addAll(b);\n+        return merged;\n+    }\n+\n+    \/*\n+     * 1. This algorithm runs in the order of O(N^2). Given that the typical\n+     * number N of strings is small, this is not an issue.\n+     *\n+     * 2. This algorithm goes the extra mile so as to be helpful: it not only\n+     * detects that there are problematic strings, but also points to the\n+     * specific pairs that conflict.\n+     *\/\n+    private static Map<String, Set<String>> findConfusingStrings(List<String> strings) {\n+        Map<String, Set<String>> r = new HashMap<>();\n+        for (int i = 0; i < strings.size(); i++) {\n+            var s1 = strings.get(i);\n+            for (int j = 0; j < strings.size(); j++) {\n+                var s2 = strings.get(j);\n+                if (i == j) \/\/ do not count self\n+                    continue;\n+                if (s1.contains(s2))\n+                    r.merge(s2, Set.of(s1), JavadocTester::mergeSets);\n+            }\n+        }\n+        return r;\n+    }\n+\n@@ -555,1 +672,1 @@\n-     * Checks that there are no duplicate lines that either match or don't match a given patter,\n+     * Checks that there are no duplicate lines that either match or don't match a given pattern,\n","filename":"test\/langtools\/jdk\/javadoc\/lib\/javadoc\/tester\/JavadocTester.java","additions":118,"deletions":1,"binary":false,"changes":119,"status":"modified"}]}