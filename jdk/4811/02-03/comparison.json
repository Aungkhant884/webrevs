{"files":[{"patch":"@@ -1,97 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8270836\n- * @library \/tools\/lib ..\/lib\n- * @modules jdk.javadoc\/jdk.javadoc.internal.tool\n- * @build javadoc.tester.* toolbox.ToolBox\n- * @run testng TestJavadocTester\n- *\/\n-\n-import javadoc.tester.JavadocTester;\n-import toolbox.ToolBox;\n-\n-import java.io.IOException;\n-import java.nio.file.Path;\n-import java.util.List;\n-\n-import static org.testng.Assert.expectThrows;\n-\n-\/*\n- * ATTENTION: this test is run using @org.testng.annotations.Test,\n- *            not javadoc.tester.JavadocTester.Test\n- *\/\n-public class TestJavadocTester extends JavadocTester {\n-\n-    private TestJavadocTester() { }\n-\n-    @org.testng.annotations.Test\n-    public void testCheckOutput() throws IOException {\n-        List<List<String>> listOfStringArguments = List.of(\n-                List.of(\"abcd\", \"abc\"),\n-                List.of(\"abcde\", \"a\", \"abc\"),\n-                List.of(\"abc\", \"abc\"),\n-                List.of(\"\", \"abcd\")\n-        );\n-        new ToolBox().writeJavaFiles(Path.of(\".\"), \"\/** First sentence. *\/ public class MyClass { }\");\n-        javadoc(\"-d\", \"out\", \"MyClass.java\");\n-        \/\/ (1) these checks must throw\n-        for (Output out : Output.values()) {\n-            for (boolean expect : new boolean[]{false, true}) {\n-                for (List<String> args : listOfStringArguments) {\n-                    String[] strs = args.toArray(new String[0]);\n-                    expectThrows(IllegalArgumentException.class, () -> checkOutput(out, expect, strs));\n-                }\n-            }\n-        }\n-        \/\/ these must throw too\n-        for (boolean expect : new boolean[]{false, true}) {\n-            for (List<String> args : listOfStringArguments) {\n-                String[] strings = args.toArray(new String[0]);\n-                expectThrows(IllegalArgumentException.class, () -> checkOutput(\"MyClass.html\", expect, strings));\n-            }\n-        }\n-        \/\/ (2) sanity check: these won't throw anything\n-        for (Output out : Output.values()) {\n-            for (boolean expect : new boolean[]{false, true}) {\n-                checkOutput(out, expect, \"abcd\");\n-                checkOutput(out, expect, \"a\", \"b\");\n-                checkOutput(out, expect, \"\");\n-            }\n-        }\n-        \/\/ neither will these:\n-        for (boolean expect : new boolean[]{false, true}) {\n-            checkOutput(\"MyClass.html\", expect, \"abcd\");\n-            checkOutput(\"MyClass.html\", expect, \"a\", \"b\");\n-            checkOutput(\"MyClass.html\", expect, \"\");\n-        }\n-        \/\/ checkOrder won't throw when used as a substitute for the above\n-        \/\/ cases of checkOutput that threw\n-        for (List<String> args : listOfStringArguments) {\n-            String[] strings = args.toArray(new String[0]);\n-            checkOrder(\"MyClass.html\", strings);\n-        }\n-    }\n-}\n","filename":"test\/langtools\/jdk\/javadoc\/lib\/TestJavadocTester.java","additions":0,"deletions":97,"binary":false,"changes":97,"status":"deleted"},{"patch":"@@ -53,0 +53,1 @@\n+import java.util.HashSet;\n@@ -56,0 +57,1 @@\n+import java.util.Set;\n@@ -59,0 +61,1 @@\n+import java.util.stream.Collectors;\n@@ -176,0 +179,6 @@\n+    \/** History of calls to checkOutput *\/\n+    private final Map<FileAndFlag, Set<StringsAndStacktrace>> checkOutputCalls = new HashMap<>();\n+    \/\/ The below two records are implicitly static\n+    private record FileAndFlag(String file, boolean expectFound) { }\n+    private record StringsAndStacktrace(List<String> strings, List<StackWalker.StackFrame> stackFrames) { }\n+\n@@ -310,0 +319,1 @@\n+        checkOutputCalls.clear();\n@@ -503,4 +513,5 @@\n-     * situation where the provided array of strings contains a pair of strings\n-     * s1 and s2 such that s1.startsWith(s2). Such a situation is problematic\n-     * because in order to match s1 and s2, it suffices for the output to\n-     * contain only s1.\n+     * situation where there exists a pair of strings s1 and s2 among the\n+     * provided so far such that s1.contains(s2). Such a situation is confusing\n+     * and might indicate a bug because in order for the check to succeed, it\n+     * suffices for the output to (not) contain only one of these strings. Which\n+     * one, depends on the {@code expectFound} flag.\n@@ -530,4 +541,5 @@\n-     * situation where the provided array of strings contains a pair of strings\n-     * s1 and s2 such that s1.startsWith(s2). Such a situation is problematic\n-     * because in order to match s1 and s2, it suffices for the output to\n-     * contain only s1.\n+     * situation where there exists a pair of strings s1 and s2 among the\n+     * provided so far such that s1.contains(s2). Such a situation is confusing\n+     * and might indicate a bug because in order for the check to succeed, it\n+     * suffices for the output to (not) contain only one of these strings. Which\n+     * one, depends on the {@code expectFound} flag.\n@@ -541,2 +553,1 @@\n-        if (checkIfPrefixes(strings))\n-            throw new IllegalArgumentException(\"Prefix strings detected; use checkOrder instead or fix the strings.\");\n+        checkConfusingStrings(path, fileString, expectedFound, strings);\n@@ -560,6 +571,88 @@\n-    private static boolean checkIfPrefixes(String... strings) {\n-        String[] copy = Arrays.copyOf(strings, strings.length);\n-        Arrays.sort(copy);\n-        for (int i = 0; i < copy.length - 1; i++) {\n-            if (copy[i + 1].startsWith(copy[i]))\n-                return true;\n+    \/*\n+     * This method might double-count confusing strings because the call data is\n+     * stored unconditionally. This is to report all errors at once.\n+     *\/\n+    private void checkConfusingStrings(String path, String fileString, boolean expectedFound, String... strings) {\n+        FileAndFlag key = new FileAndFlag(path, expectedFound);\n+        \/\/ get the relevant stacktrace (i.e. without topmost frames related to JavadocTester)\n+        List<StackWalker.StackFrame> frames = StackWalker.getInstance(StackWalker.Option.RETAIN_CLASS_REFERENCE)\n+                .walk(s -> s.dropWhile(f -> f.getDeclaringClass() == JavadocTester.class).toList());\n+        StringsAndStacktrace value = new StringsAndStacktrace(List.of(strings), frames);\n+        Set<StringsAndStacktrace> prevSet = checkOutputCalls.getOrDefault(key, Set.of());\n+        checkOutputCalls.put(key, mergeSets(prevSet, Set.of(value)));\n+        Map<String, Set<String>> thisCallConfusingStrings = findConfusingStrings(Arrays.asList(strings));\n+        String details = \"\";\n+        if (!thisCallConfusingStrings.isEmpty()) {\n+            details += \"Confusing strings in this call:\\n\";\n+            details += \"Currently called from:\\n\\n\" + stringFromStackFrames(value.stackFrames()).indent(4) + \"\\n\";\n+            details += describeConfusingStrings(fileString, thisCallConfusingStrings);\n+        }\n+        for (var stringsAndStacktrace : prevSet) {\n+            Map<String, Set<String>> prevCallConfusingStrings = findConfusingStrings(mergeLists(stringsAndStacktrace.strings(), List.of(strings)));\n+            if (!prevCallConfusingStrings.equals(thisCallConfusingStrings)) {\n+                details += \"Confusing strings across this and previous calls:\\n\";\n+                details += \"Currently called from:\\n\\n\" + stringFromStackFrames(value.stackFrames()).indent(4) + \"\\n\";\n+                details += \"Previously called from:\\n\\n\" + stringFromStackFrames(stringsAndStacktrace.stackFrames()).indent(4) + \"\\n\";\n+                details += describeConfusingStrings(fileString, prevCallConfusingStrings) + \"\\n\";\n+            }\n+        }\n+        if (!details.isEmpty()) {\n+\/\/            System.out.println(details);\n+            throw new IllegalArgumentException(details);\n+        }\n+    }\n+\n+    private static String describeConfusingStrings(String fileString, Map<String, Set<String>> thisCallConfusingStrings) {\n+        StringBuilder detail = new StringBuilder();\n+        thisCallConfusingStrings.forEach((subString, superStrings) -> {\n+            long count = Pattern.compile(Pattern.quote(subString)).matcher(fileString).results().count();\n+            String sup = String.join(\"\\n\\n\", superStrings);\n+            detail.append(\n+                    \"\"\"\n+                    substring:\n+                    %s\n+                    number of occurrences in the output:\n+                    %s\n+                    superstrings:\n+                    %s\n+\n+                    \"\"\".formatted(subString, count, sup));\n+        });\n+        return detail.toString().indent(4);\n+    }\n+\n+    private static String stringFromStackFrames(List<StackWalker.StackFrame> value) {\n+        return value.stream().map(Object::toString).collect(Collectors.joining(\"\\n\"));\n+    }\n+\n+    private static <T> Set<T> mergeSets(Set<T> a, Set<T> b) {\n+        var merged = new HashSet<>(a);\n+        merged.addAll(b);\n+        return merged;\n+    }\n+\n+    private static <T> List<T> mergeLists(List<T> a, List<T> b) {\n+        var merged = new ArrayList<>(a);\n+        merged.addAll(b);\n+        return merged;\n+    }\n+\n+    \/*\n+     * 1. This algorithm runs in the order of O(N^2). Given that the typical\n+     * number N of strings is small, this is not an issue.\n+     *\n+     * 2. This algorithm goes the extra mile so as to be helpful: it not only\n+     * detects that there are problematic strings, but also points to the\n+     * specific pairs that conflict.\n+     *\/\n+    private static Map<String, Set<String>> findConfusingStrings(List<String> strings) {\n+        Map<String, Set<String>> r = new HashMap<>();\n+        for (int i = 0; i < strings.size(); i++) {\n+            var s1 = strings.get(i);\n+            for (int j = 0; j < strings.size(); j++) {\n+                var s2 = strings.get(j);\n+                if (i == j) \/\/ do not count self\n+                    continue;\n+                if (s1.contains(s2))\n+                    r.merge(s2, Set.of(s1), JavadocTester::mergeSets);\n+            }\n@@ -567,1 +660,1 @@\n-        return false;\n+        return r;\n","filename":"test\/langtools\/jdk\/javadoc\/lib\/javadoc\/tester\/JavadocTester.java","additions":110,"deletions":17,"binary":false,"changes":127,"status":"modified"}]}