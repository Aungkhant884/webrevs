{"files":[{"patch":"@@ -674,0 +674,12 @@\n+\/\/ Gets the exploded path for the named module. The memory for the path\n+\/\/ is allocated on the C heap if `c_heap` is true otherwise in the resource area.\n+static const char* get_exploded_module_path(const char* module_name, bool c_heap) {\n+  const char *home = Arguments::get_java_home();\n+  const char file_sep = os::file_separator()[0];\n+  \/\/ 10 represents the length of \"modules\" + 2 file separators + \\0\n+  size_t len = strlen(home) + strlen(module_name) + 10;\n+  char *path = c_heap ? NEW_C_HEAP_ARRAY(char, len, mtModule) : NEW_RESOURCE_ARRAY(char, len);\n+  jio_snprintf(path, len, \"%s%cmodules%c%s\", home, file_sep, file_sep, module_name);\n+  return path;\n+}\n+\n@@ -683,6 +695,1 @@\n-  const char *home = Arguments::get_java_home();\n-  const char file_sep = os::file_separator()[0];\n-  \/\/ 10 represents the length of \"modules\" + 2 file separators + \\0\n-  size_t len = strlen(home) + strlen(module_name) + 10;\n-  char *path = NEW_RESOURCE_ARRAY(char, len);\n-  jio_snprintf(path, len, \"%s%cmodules%c%s\", home, file_sep, file_sep, module_name);\n+  const char *path = get_exploded_module_path(module_name, false);\n@@ -1418,0 +1425,14 @@\n+bool ClassLoader::is_module_observable(const char* module_name) {\n+  assert(JImageOpen != NULL, \"jimage library should have been opened\");\n+  if (JImage_file == NULL) {\n+    struct stat st;\n+    const char *path = get_exploded_module_path(module_name, true);\n+    bool res = os::stat(path, &st) == 0;\n+    FREE_C_HEAP_ARRAY(char, path);\n+    return res;\n+  }\n+  jlong size;\n+  const char *jimage_version = get_jimage_version_string();\n+  return (*JImageFindResource)(JImage_file, module_name, jimage_version, \"module-info.class\", &size) != 0;\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":27,"deletions":6,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -377,0 +377,4 @@\n+  \/\/ Determines if the named module is present in the\n+  \/\/ modules jimage file or in the exploded modules directory.\n+  static bool is_module_observable(const char* module_name);\n+\n","filename":"src\/hotspot\/share\/classfile\/classLoader.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -744,0 +744,4 @@\n+  template(serializeSavedPropertiesToByteArray_name,   \"serializeSavedPropertiesToByteArray\")                     \\\n+  template(encodeThrowable_name,                       \"encodeThrowable\")                                         \\\n+  template(encodeThrowable_signature,                  \"(Ljava\/lang\/Throwable;JI)I\")                              \\\n+  template(decodeAndThrowThrowable_name,               \"decodeAndThrowThrowable\")                                 \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"runtime\/javaThread.inline.hpp\"\n@@ -231,3 +232,11 @@\n-    if (thread != nullptr) {\n-      ResourceMark rm;\n-      tty->print(\"JVMCITrace-%d[%s]:%*c\", level, thread->name(), level, ' ');\n+    if (thread != nullptr && thread->is_Java_thread()) {\n+      ResourceMark rm(thread);\n+      JavaThreadState state = JavaThread::cast(thread)->thread_state();\n+      if (state == _thread_in_vm || state == _thread_in_Java || state == _thread_new) {\n+        tty->print(\"JVMCITrace-%d[%s]:%*c\", level, thread->name(), level, ' ');\n+      } else {\n+        \/\/ According to check_access_thread_state, it's unsafe to\n+        \/\/ resolve the j.l.Thread object unless the thread is in\n+        \/\/ one of the states above.\n+        tty->print(\"JVMCITrace-%d[%s@\" PTR_FORMAT \"]:%*c\", level, thread->type_name(), p2i(thread), level, ' ');\n+      }\n","filename":"src\/hotspot\/share\/jvmci\/jvmci.cpp","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -145,2 +145,2 @@\n-  JVMCITraceMark jtm(\"CompilerToVM::\" #name);            \\\n-  C2V_BLOCK(result_type, name, signature)\n+  C2V_BLOCK(result_type, name, signature)                \\\n+  JVMCITraceMark jtm(\"CompilerToVM::\" #name);\n@@ -156,2 +156,2 @@\n-  JVMCITraceMark jtm(\"CompilerToVM::\" #name);            \\\n-  C2V_BLOCK(result_type, name, signature)\n+  C2V_BLOCK(result_type, name, signature)                \\\n+  JVMCITraceMark jtm(\"CompilerToVM::\" #name);\n@@ -506,1 +506,1 @@\n-    JVMCIENV->runtime()->initialize(JVMCIENV);\n+    JVMCIENV->runtime()->initialize(JVMCI_CHECK_NULL);\n@@ -2315,1 +2315,0 @@\n-  JVMCITraceMark jtm(\"isCurrentThreadAttached\");\n@@ -2318,0 +2317,1 @@\n+    JVMCITraceMark jtm(\"isCurrentThreadAttached\");\n@@ -2334,1 +2334,0 @@\n-  JVMCITraceMark jtm(\"getCurrentJavaThread\");\n@@ -2380,1 +2379,0 @@\n-  JVMCITraceMark jtm(\"attachCurrentThread\");\n@@ -2384,0 +2382,1 @@\n+    JVMCITraceMark jtm(\"attachCurrentThread\");\n@@ -2438,1 +2437,0 @@\n-  JVMCITraceMark jtm(\"detachCurrentThread\");\n@@ -2442,0 +2440,1 @@\n+    JVMCITraceMark jtm(\"detachCurrentThread\");\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+#include \"runtime\/thread.inline.hpp\"\n@@ -47,0 +48,3 @@\n+jbyte* JVMCIEnv::_serialized_saved_properties = nullptr;\n+int JVMCIEnv::_serialized_saved_properties_len = 0;\n+\n@@ -101,4 +105,6 @@\n-void JVMCIEnv::copy_saved_properties() {\n-  assert(!is_hotspot(), \"can only copy saved properties from HotSpot to native image\");\n-\n-  JavaThread* THREAD = JavaThread::current(); \/\/ For exception macros.\n+jbyte* JVMCIEnv::get_serialized_saved_properties(int& props_len, TRAPS) {\n+  jbyte* props = _serialized_saved_properties;\n+  if (props == nullptr) {\n+    \/\/ load VMSupport\n+    Symbol* klass = vmSymbols::jdk_internal_vm_VMSupport();\n+    Klass* k = SystemDictionary::resolve_or_fail(klass, true, CHECK_NULL);\n@@ -106,9 +112,3 @@\n-  Klass* k = SystemDictionary::resolve_or_fail(vmSymbols::jdk_vm_ci_services_Services(), Handle(), Handle(), true, THREAD);\n-  if (HAS_PENDING_EXCEPTION) {\n-    JVMCIRuntime::fatal_exception(NULL, \"Error initializing jdk.vm.ci.services.Services\");\n-  }\n-  InstanceKlass* ik = InstanceKlass::cast(k);\n-  if (ik->should_be_initialized()) {\n-    ik->initialize(THREAD);\n-    if (HAS_PENDING_EXCEPTION) {\n-      JVMCIRuntime::fatal_exception(NULL, \"Error initializing jdk.vm.ci.services.Services\");\n+    InstanceKlass* ik = InstanceKlass::cast(k);\n+    if (ik->should_be_initialized()) {\n+      ik->initialize(CHECK_NULL);\n@@ -116,1 +116,0 @@\n-  }\n@@ -118,7 +117,26 @@\n-  \/\/ Get the serialized saved properties from HotSpot\n-  TempNewSymbol serializeSavedProperties = SymbolTable::new_symbol(\"serializeSavedProperties\");\n-  JavaValue result(T_OBJECT);\n-  JavaCallArguments args;\n-  JavaCalls::call_static(&result, ik, serializeSavedProperties, vmSymbols::void_byte_array_signature(), &args, THREAD);\n-  if (HAS_PENDING_EXCEPTION) {\n-    JVMCIRuntime::fatal_exception(NULL, \"Error calling jdk.vm.ci.services.Services.serializeSavedProperties\");\n+    \/\/ invoke the serializeSavedPropertiesToByteArray method\n+    JavaValue result(T_OBJECT);\n+    JavaCallArguments args;\n+\n+    Symbol* signature = vmSymbols::void_byte_array_signature();\n+    JavaCalls::call_static(&result,\n+                           ik,\n+                           vmSymbols::serializeSavedPropertiesToByteArray_name(),\n+                           signature,\n+                           &args,\n+                           CHECK_NULL);\n+\n+    oop res = result.get_oop();\n+    assert(res->is_typeArray(), \"must be\");\n+    assert(TypeArrayKlass::cast(res->klass())->element_type() == T_BYTE, \"must be\");\n+    typeArrayOop ba = typeArrayOop(res);\n+    props_len = ba->length();\n+\n+    \/\/ Copy serialized saved properties from HotSpot object into C heap\n+    props = NEW_C_HEAP_ARRAY(jbyte, props_len, mtJVMCI);\n+    memcpy(props, ba->byte_at_addr(0), props_len);\n+\n+    _serialized_saved_properties_len = props_len;\n+    _serialized_saved_properties = props;\n+  } else {\n+    props_len = _serialized_saved_properties_len;\n@@ -126,5 +144,2 @@\n-  oop res = result.get_oop();\n-  assert(res->is_typeArray(), \"must be\");\n-  assert(TypeArrayKlass::cast(res->klass())->element_type() == T_BYTE, \"must be\");\n-  typeArrayOop ba = typeArrayOop(res);\n-  int serialized_properties_len = ba->length();\n+  return props;\n+}\n@@ -132,3 +147,3 @@\n-  \/\/ Copy serialized saved properties from HotSpot object into native buffer\n-  jbyte* serialized_properties = NEW_RESOURCE_ARRAY(jbyte, serialized_properties_len);\n-  memcpy(serialized_properties, ba->byte_at_addr(0), serialized_properties_len);\n+void JVMCIEnv::copy_saved_properties(jbyte* properties, int properties_len, JVMCI_TRAPS) {\n+  assert(!is_hotspot(), \"can only copy saved properties from HotSpot to native image\");\n+  JavaThread* thread = JavaThread::current(); \/\/ For exception macros.\n@@ -137,1 +152,1 @@\n-  JVMCIPrimitiveArray buf = new_byteArray(serialized_properties_len, this);\n+  JVMCIPrimitiveArray buf = new_byteArray(properties_len, this);\n@@ -139,2 +154,1 @@\n-    describe_pending_exception(true);\n-    fatal(\"Error in copy_saved_properties\");\n+    _runtime->fatal_exception(JVMCIENV, \"Error in copy_saved_properties\");\n@@ -142,1 +156,1 @@\n-  copy_bytes_from(serialized_properties, buf, 0, serialized_properties_len);\n+  copy_bytes_from(properties, buf, 0, properties_len);\n@@ -144,2 +158,1 @@\n-    describe_pending_exception(true);\n-    fatal(\"Error in copy_saved_properties\");\n+    _runtime->fatal_exception(JVMCIENV, \"Error in copy_saved_properties\");\n@@ -151,5 +164,8 @@\n-  JNIAccessMark jni(this, THREAD);\n-  jni()->CallStaticVoidMethod(servicesClass, initializeSavedProperties, buf.as_jobject());\n-  if (jni()->ExceptionCheck()) {\n-    jni()->ExceptionDescribe();\n-    fatal(\"Error calling jdk.vm.ci.services.Services.initializeSavedProperties\");\n+  bool exception = false;\n+  {\n+    JNIAccessMark jni(this, thread);\n+    jni()->CallStaticVoidMethod(servicesClass, initializeSavedProperties, buf.as_jobject());\n+    exception = jni()->ExceptionCheck();\n+  }\n+  if (exception) {\n+    _runtime->fatal_exception(JVMCIENV, \"Error calling jdk.vm.ci.services.Services.initializeSavedProperties\");\n@@ -305,1 +321,1 @@\n-  virtual int encode(JavaThread* THREAD, Klass* runtimeKlass, jlong buffer, int buffer_size) = 0;\n+  virtual int encode(JavaThread* THREAD, Klass* vmSupport, jlong buffer, int buffer_size) = 0;\n@@ -308,1 +324,1 @@\n-  virtual void decode(JavaThread* THREAD, Klass* runtimeKlass, jlong buffer) = 0;\n+  virtual void decode(JavaThread* THREAD, Klass* vmSupport, jlong buffer) = 0;\n@@ -312,1 +328,1 @@\n-    \/\/ Resolve HotSpotJVMCIRuntime class explicitly as HotSpotJVMCI::compute_offsets\n+    \/\/ Resolve VMSupport class explicitly as HotSpotJVMCI::compute_offsets\n@@ -314,1 +330,2 @@\n-    Klass* runtimeKlass = SystemDictionary::resolve_or_fail(vmSymbols::jdk_vm_ci_hotspot_HotSpotJVMCIRuntime(), true, CHECK);\n+    Klass* vmSupport = SystemDictionary::resolve_or_fail(vmSymbols::jdk_internal_vm_VMSupport(), true, THREAD);\n+    guarantee(!HAS_PENDING_EXCEPTION, \"\");\n@@ -321,1 +338,1 @@\n-        decode(THREAD, runtimeKlass, 0L);\n+        decode(THREAD, vmSupport, 0L);\n@@ -324,1 +341,1 @@\n-      int res = encode(THREAD, runtimeKlass, buffer, buffer_size);\n+      int res = encode(THREAD, vmSupport, buffer, buffer_size);\n@@ -329,1 +346,1 @@\n-        decode(THREAD, runtimeKlass, -2L);\n+        decode(THREAD, vmSupport, -2L);\n@@ -335,1 +352,1 @@\n-          decode(THREAD, runtimeKlass, -1L);\n+          decode(THREAD, vmSupport, -1L);\n@@ -337,1 +354,1 @@\n-          decode(THREAD, runtimeKlass, -2L);\n+          decode(THREAD, vmSupport, -2L);\n@@ -346,1 +363,1 @@\n-        decode(THREAD, runtimeKlass, buffer);\n+        decode(THREAD, vmSupport, buffer);\n@@ -348,1 +365,1 @@\n-          _to_env->throw_InternalError(\"HotSpotJVMCIRuntime.decodeAndThrowThrowable should have thrown an exception\");\n+          _to_env->throw_InternalError(\"decodeAndThrowThrowable should have thrown an exception\");\n@@ -361,1 +378,1 @@\n-  int encode(JavaThread* THREAD, Klass* runtimeKlass, jlong buffer, int buffer_size) {\n+  int encode(JavaThread* THREAD, Klass* vmSupport, jlong buffer, int buffer_size) {\n@@ -368,1 +385,1 @@\n-                            runtimeKlass,\n+                            vmSupport,\n@@ -374,1 +391,1 @@\n-  void decode(JavaThread* THREAD, Klass* runtimeKlass, jlong buffer) {\n+  void decode(JavaThread* THREAD, Klass* vmSupport, jlong buffer) {\n@@ -376,2 +393,2 @@\n-    jni()->CallStaticVoidMethod(JNIJVMCI::HotSpotJVMCIRuntime::clazz(),\n-                                JNIJVMCI::HotSpotJVMCIRuntime::decodeAndThrowThrowable_method(),\n+    jni()->CallStaticVoidMethod(JNIJVMCI::VMSupport::clazz(),\n+                                JNIJVMCI::VMSupport::decodeAndThrowThrowable_method(),\n@@ -390,1 +407,1 @@\n-  int encode(JavaThread* THREAD, Klass* runtimeKlass, jlong buffer, int buffer_size) {\n+  int encode(JavaThread* THREAD, Klass* vmSupport, jlong buffer, int buffer_size) {\n@@ -392,2 +409,2 @@\n-    return jni()->CallStaticIntMethod(JNIJVMCI::HotSpotJVMCIRuntime::clazz(),\n-                                      JNIJVMCI::HotSpotJVMCIRuntime::encodeThrowable_method(),\n+    return jni()->CallStaticIntMethod(JNIJVMCI::VMSupport::clazz(),\n+                                      JNIJVMCI::VMSupport::encodeThrowable_method(),\n@@ -397,1 +414,1 @@\n-  void decode(JavaThread* THREAD, Klass* runtimeKlass, jlong buffer) {\n+  void decode(JavaThread* THREAD, Klass* vmSupport, jlong buffer) {\n@@ -402,1 +419,1 @@\n-                            runtimeKlass,\n+                            vmSupport,\n@@ -419,0 +436,10 @@\n+jboolean JVMCIEnv::transfer_pending_exception_to_jni(JavaThread* THREAD, JVMCIEnv* hotspot_env, JVMCIEnv* jni_env) {\n+  if (HAS_PENDING_EXCEPTION) {\n+    Handle throwable = Handle(THREAD, PENDING_EXCEPTION);\n+    CLEAR_PENDING_EXCEPTION;\n+    translate_to_jni_exception(THREAD, throwable, hotspot_env, jni_env);\n+    return true;\n+  }\n+  return false;\n+}\n+\n@@ -421,15 +448,6 @@\n-    if (HAS_PENDING_EXCEPTION) {\n-      Handle throwable = Handle(THREAD, PENDING_EXCEPTION);\n-      CLEAR_PENDING_EXCEPTION;\n-      translate_to_jni_exception(THREAD, throwable, this, peer_env);\n-      return true;\n-    }\n-  } else {\n-    jthrowable ex = nullptr;\n-    {\n-      JNIAccessMark jni(this, THREAD);\n-      ex = jni()->ExceptionOccurred();\n-      if (ex != nullptr) {\n-        jni()->ExceptionClear();\n-      }\n-    }\n+    return transfer_pending_exception_to_jni(THREAD, this, peer_env);\n+  }\n+  jthrowable ex = nullptr;\n+  {\n+    JNIAccessMark jni(this, THREAD);\n+    ex = jni()->ExceptionOccurred();\n@@ -437,2 +455,1 @@\n-      translate_from_jni_exception(THREAD, ex, peer_env, this);\n-      return true;\n+      jni()->ExceptionClear();\n@@ -441,0 +458,4 @@\n+  if (ex != nullptr) {\n+    translate_from_jni_exception(THREAD, ex, peer_env, this);\n+    return true;\n+  }\n@@ -444,1 +465,0 @@\n-\n@@ -472,1 +492,2 @@\n-      jio_snprintf(message, 256, \"Uncaught exception exiting JVMCIEnv scope entered at %s:%d\", _file, _line);\n+      jio_snprintf(message, 256, \"Uncaught exception exiting %s JVMCIEnv scope entered at %s:%d\",\n+          is_hotspot() ? \"HotSpot\" : \"libjvmci\", _file, _line);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.cpp","additions":101,"deletions":80,"binary":false,"changes":181,"status":"modified"},{"patch":"@@ -183,0 +183,6 @@\n+  \/\/ Used by copy_saved_properties() to avoid OutOfMemoryErrors when\n+  \/\/ initializing a libjvmci runtime in low HotSpot heap conditions.\n+  \/\/ Must hold JVMCI_lock when initializing.\n+  static jbyte* _serialized_saved_properties;\n+  static int _serialized_saved_properties_len;\n+\n@@ -224,3 +230,7 @@\n-  \/\/ Initializes Services.savedProperties in the shared library by copying\n-  \/\/ the values from the same field in the HotSpot heap.\n-  void copy_saved_properties();\n+  \/\/ Gets the serialized saved properties from the HotSpot heap.\n+  \/\/ The length of the returned array is saved in `len`.\n+  jbyte* get_serialized_saved_properties(int& len, TRAPS);\n+\n+  \/\/ Initializes Services.savedProperties in the shared library from the given\n+  \/\/ properties in the format produced by `get_serialized_saved_properties`.\n+  void copy_saved_properties(jbyte* properties, int properties_len, JVMCI_TRAPS);\n@@ -236,0 +246,5 @@\n+  \/\/ If there is a pending HotSpot exception, clears it and translates it to the shared library heap.\n+  \/\/ The translated exception is pending in the shared library upon returning.\n+  \/\/ Returns true if a pending exception was transferred, false otherwise.\n+  static jboolean transfer_pending_exception_to_jni(JavaThread* THREAD, JVMCIEnv* hotspot_env, JVMCIEnv* jni_env);\n+\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.hpp","additions":18,"deletions":3,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -349,1 +349,1 @@\n-      \/* values across all JavaVMs executing on the same native image. *\/                   \\\n+      \/* value across all JavaVMs executing on the same native image. *\/                    \\\n","filename":"src\/hotspot\/share\/jvmci\/jvmciJavaClasses.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -194,2 +194,0 @@\n-    jvmci_method(CallStaticBooleanMethod, GetStaticMethodID, call_static, bool, HotSpotJVMCIRuntime, encodeThrowable, encodeThrowable_signature, (JVMCIObject throwable, jlong buffer, int buffer_size)) \\\n-    jvmci_method(CallStaticVoidMethod, GetStaticMethodID, call_static, void, HotSpotJVMCIRuntime, decodeAndThrowThrowable, long_void_signature, (jlong buffer)) \\\n@@ -219,0 +217,4 @@\n+  start_class(VMSupport, jdk_internal_vm_VMSupport)                                                           \\\n+    jvmci_method(CallStaticIntMethod, GetStaticMethodID, call_static, int, VMSupport, encodeThrowable, encodeThrowable_signature, (JVMCIObject throwable, jlong buffer, int buffer_size)) \\\n+    jvmci_method(CallStaticVoidMethod, GetStaticMethodID, call_static, void, VMSupport, decodeAndThrowThrowable, long_void_signature, (jlong buffer)) \\\n+  end_class                                                                                                   \\\n","filename":"src\/hotspot\/share\/jvmci\/jvmciJavaClasses.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -752,1 +752,1 @@\n-  initialize(JVMCIENV);\n+  initialize(JVMCI_CHECK);\n@@ -1318,1 +1318,1 @@\n-  initialize(JVMCIENV);\n+  initialize(JVMCI_CHECK);\n@@ -1373,1 +1373,1 @@\n-void JVMCIRuntime::initialize(JVMCIEnv* JVMCIENV) {\n+void JVMCIRuntime::initialize(JVMCI_TRAPS) {\n@@ -1379,0 +1379,5 @@\n+  JavaThread* THREAD = JavaThread::current();\n+\n+  int properties_len = 0;\n+  jbyte* properties = NULL;\n+\n@@ -1400,1 +1405,0 @@\n-    JavaThread* THREAD = JavaThread::current();\n@@ -1444,1 +1448,6 @@\n-      JVMCIENV->copy_saved_properties();\n+      Handle properties_exception;\n+      properties = JVMCIENV->get_serialized_saved_properties(properties_len, THREAD);\n+      if (JVMCIEnv::transfer_pending_exception_to_jni(THREAD, nullptr, JVMCIENV)) {\n+        return;\n+      }\n+      JVMCIENV->copy_saved_properties(properties, properties_len, JVMCI_CHECK);\n@@ -1487,1 +1496,1 @@\n-  initialize(JVMCIENV);\n+  initialize(JVMCI_CHECK_(JVMCIObject()));\n@@ -1995,1 +2004,7 @@\n-    fatal_exception(JVMCIENV, \"Exception during HotSpotJVMCIRuntime initialization\");\n+    if (PrintWarnings) {\n+      ResourceMark rm(thread);\n+      warning(\"HotSpotJVMCIRuntime initialization failed when compiling %s\", method->name_and_sig_as_C_string());\n+      JVMCIENV->describe_pending_exception(true);\n+    }\n+    compile_state->set_failure(false, \"exception during HotSpotJVMCIRuntime initialization\");\n+    return;\n@@ -1999,1 +2014,5 @@\n-    JVMCIENV->describe_pending_exception(true);\n+    if (PrintWarnings) {\n+      ResourceMark rm(thread);\n+      warning(\"Error creating JVMCI wrapper for %s\", method->name_and_sig_as_C_string());\n+      JVMCIENV->describe_pending_exception(true);\n+    }\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":27,"deletions":8,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -82,3 +82,0 @@\n-  template(encodeThrowable_name,                                  \"encodeThrowable\")                                                      \\\n-  template(encodeThrowable_signature,                             \"(Ljava\/lang\/Throwable;JI)I\")                                           \\\n-  template(decodeAndThrowThrowable_name,                          \"decodeAndThrowThrowable\")                                              \\\n","filename":"src\/hotspot\/share\/jvmci\/vmSymbols_jvmci.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1957,2 +1957,4 @@\n-    if (!create_numbered_module_property(\"jdk.module.addmods\", \"jdk.internal.vm.ci\", addmods_count++)) {\n-      return false;\n+    if (ClassLoader::is_module_observable(\"jdk.internal.vm.ci\")) {\n+      if (!create_numbered_module_property(\"jdk.module.addmods\", \"jdk.internal.vm.ci\", addmods_count++)) {\n+        return false;\n+      }\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,284 @@\n+\/*\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.vm;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.zip.GZIPInputStream;\n+import java.util.zip.GZIPOutputStream;\n+\n+\/**\n+ * Support for translating exceptions between the HotSpot heap and libjvmci heap.\n+ *\/\n+@SuppressWarnings(\"serial\")\n+final class TranslatedException extends Exception {\n+\n+    \/**\n+     * The value returned by {@link #encodeThrowable(Throwable)} when encoding fails due to an\n+     * {@link OutOfMemoryError}.\n+     *\/\n+    private static final byte[] FALLBACK_ENCODED_OUTOFMEMORYERROR_BYTES;\n+\n+    \/**\n+     * The value returned by {@link #encodeThrowable(Throwable)} when encoding fails for any reason\n+     * other than {@link OutOfMemoryError}.\n+     *\/\n+    private static final byte[] FALLBACK_ENCODED_THROWABLE_BYTES;\n+    static {\n+        try {\n+            FALLBACK_ENCODED_THROWABLE_BYTES = encodeThrowable(new TranslatedException(\"error during encoding\", \"<unknown>\"), false);\n+            FALLBACK_ENCODED_OUTOFMEMORYERROR_BYTES = encodeThrowable(new OutOfMemoryError(), false);\n+        } catch (IOException e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+    \/**\n+     * Class name of exception that could not be instantiated.\n+     *\/\n+    private String originalExceptionClassName;\n+\n+    private TranslatedException(String message, String originalExceptionClassName) {\n+        super(message);\n+        this.originalExceptionClassName = originalExceptionClassName;\n+    }\n+\n+    \/**\n+     * No need to record an initial stack trace since it will be manually overwritten.\n+     *\/\n+    @SuppressWarnings(\"sync-override\")\n+    @Override\n+    public Throwable fillInStackTrace() {\n+        return this;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        String s;\n+        if (originalExceptionClassName.equals(TranslatedException.class.getName())) {\n+            s = getClass().getName();\n+        } else {\n+            s = getClass().getName() + \"[\" + originalExceptionClassName + \"]\";\n+        }\n+        String message = getMessage();\n+        return (message != null) ? (s + \": \" + message) : s;\n+    }\n+\n+    \/**\n+     * Prints a stack trace for {@code throwable} if the system property\n+     * {@code \"jdk.internal.vm.TranslatedException.debug\"} is true.\n+     *\/\n+    private static void debugPrintStackTrace(Throwable throwable) {\n+        if (Boolean.getBoolean(\"jdk.internal.vm.TranslatedException.debug\")) {\n+            System.err.print(\"DEBUG: \");\n+            throwable.printStackTrace();\n+        }\n+    }\n+\n+    private static Throwable initCause(Throwable throwable, Throwable cause) {\n+        if (cause != null) {\n+            try {\n+                throwable.initCause(cause);\n+            } catch (IllegalStateException e) {\n+                \/\/ Cause could not be set or overwritten.\n+                debugPrintStackTrace(e);\n+            }\n+        }\n+        return throwable;\n+    }\n+\n+    private static Throwable create(String className, String message, Throwable cause) {\n+        \/\/ Try create with reflection first.\n+        try {\n+            Class<?> cls = Class.forName(className);\n+            if (cause != null) {\n+                \/\/ Handle known exception types whose cause must be set in the constructor\n+                if (cls == InvocationTargetException.class) {\n+                    return new InvocationTargetException(cause, message);\n+                }\n+                if (cls == ExceptionInInitializerError.class) {\n+                    return new ExceptionInInitializerError(cause);\n+                }\n+            }\n+            if (message == null) {\n+                return initCause((Throwable) cls.getConstructor().newInstance(), cause);\n+            }\n+            return initCause((Throwable) cls.getDeclaredConstructor(String.class).newInstance(message), cause);\n+        } catch (Throwable translationFailure) {\n+            debugPrintStackTrace(translationFailure);\n+            return initCause(new TranslatedException(message, className), cause);\n+        }\n+    }\n+\n+    private static String emptyIfNull(String value) {\n+        return value == null ? \"\" : value;\n+    }\n+\n+    private static String emptyAsNull(String value) {\n+        return value.isEmpty() ? null : value;\n+    }\n+\n+    \/**\n+     * Encodes {@code throwable} including its stack and causes as a {@linkplain GZIPOutputStream\n+     * compressed} byte array that can be decoded by {@link #decodeThrowable}.\n+     *\/\n+    static byte[] encodeThrowable(Throwable throwable) {\n+        try {\n+            return encodeThrowable(throwable, true);\n+        } catch (OutOfMemoryError e) {\n+            return FALLBACK_ENCODED_OUTOFMEMORYERROR_BYTES;\n+        } catch (Throwable e) {\n+            return FALLBACK_ENCODED_THROWABLE_BYTES;\n+        }\n+    }\n+\n+    private static byte[] encodeThrowable(Throwable throwable, boolean withCauseAndStack) throws IOException {\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        try (DataOutputStream dos = new DataOutputStream(new GZIPOutputStream(baos))) {\n+            List<Throwable> throwables = new ArrayList<>();\n+            for (Throwable current = throwable; current != null; current = current.getCause()) {\n+                throwables.add(current);\n+                if (!withCauseAndStack) {\n+                    break;\n+                }\n+            }\n+\n+            \/\/ Encode from inner most cause outwards\n+            Collections.reverse(throwables);\n+\n+            for (Throwable current : throwables) {\n+                dos.writeUTF(current.getClass().getName());\n+                dos.writeUTF(emptyIfNull(current.getMessage()));\n+                StackTraceElement[] stackTrace = withCauseAndStack ? current.getStackTrace() : null;\n+                if (stackTrace == null) {\n+                    stackTrace = new StackTraceElement[0];\n+                }\n+                dos.writeInt(stackTrace.length);\n+                for (int i = 0; i < stackTrace.length; i++) {\n+                    StackTraceElement frame = stackTrace[i];\n+                    if (frame != null) {\n+                        dos.writeUTF(emptyIfNull(frame.getClassLoaderName()));\n+                        dos.writeUTF(emptyIfNull(frame.getModuleName()));\n+                        dos.writeUTF(emptyIfNull(frame.getModuleVersion()));\n+                        dos.writeUTF(emptyIfNull(frame.getClassName()));\n+                        dos.writeUTF(emptyIfNull(frame.getMethodName()));\n+                        dos.writeUTF(emptyIfNull(frame.getFileName()));\n+                        dos.writeInt(frame.getLineNumber());\n+                    }\n+                }\n+            }\n+        }\n+        return baos.toByteArray();\n+    }\n+\n+    \/**\n+     * Gets the stack of the current thread as of the first native method. The chopped\n+     * frames are for the VM call to {@link VMSupport#decodeAndThrowThrowable}.\n+     *\/\n+    private static StackTraceElement[] getMyStackTrace() {\n+        Exception ex = new Exception();\n+        StackTraceElement[] stack = ex.getStackTrace();\n+        for (int i = 0; i < stack.length; i++) {\n+            StackTraceElement e = stack[i];\n+            boolean isNativeMethodInCompilerToVM = e.getLineNumber() == -1 && e.getClassName().equals(\"jdk.vm.ci.hotspot.CompilerToVM\");\n+            if (e.isNativeMethod() || isNativeMethodInCompilerToVM) {\n+                StackTraceElement[] res = Arrays.copyOfRange(stack, i, stack.length);\n+                return res;\n+            }\n+        }\n+        \/\/ This should never happen but since this is exception handling\n+        \/\/ code, be defensive instead raising a nested exception.\n+        return new StackTraceElement[0];\n+    }\n+\n+    \/**\n+     * Decodes {@code encodedThrowable} into a {@link TranslatedException}.\n+     *\n+     * @param encodedThrowable an encoded exception in the format specified by\n+     *            {@link #encodeThrowable}\n+     *\/\n+    static Throwable decodeThrowable(byte[] encodedThrowable) {\n+        try (DataInputStream dis = new DataInputStream(new GZIPInputStream(new ByteArrayInputStream(encodedThrowable)))) {\n+            Throwable cause = null;\n+            Throwable throwable = null;\n+            StackTraceElement[] myStack = getMyStackTrace();\n+            while (dis.available() != 0) {\n+                String exceptionClassName = dis.readUTF();\n+                String exceptionMessage = emptyAsNull(dis.readUTF());\n+                throwable = create(exceptionClassName, exceptionMessage, cause);\n+                int stackTraceDepth = dis.readInt();\n+                StackTraceElement[] stackTrace = new StackTraceElement[stackTraceDepth + myStack.length];\n+                int stackTraceIndex = 0;\n+                int myStackIndex = 0;\n+                for (int j = 0; j < stackTraceDepth; j++) {\n+                    String classLoaderName = emptyAsNull(dis.readUTF());\n+                    String moduleName = emptyAsNull(dis.readUTF());\n+                    String moduleVersion = emptyAsNull(dis.readUTF());\n+                    String className = emptyAsNull(dis.readUTF());\n+                    String methodName = emptyAsNull(dis.readUTF());\n+                    String fileName = emptyAsNull(dis.readUTF());\n+                    int lineNumber = dis.readInt();\n+                    StackTraceElement ste = new StackTraceElement(classLoaderName, moduleName, moduleVersion, className, methodName, fileName, lineNumber);\n+\n+                    if (ste.isNativeMethod()) {\n+                        \/\/ Best effort attempt to weave stack traces from two heaps into\n+                        \/\/ a single stack trace using native method frames as stitching points.\n+                        \/\/ This is not 100% reliable as there's no guarantee that native method\n+                        \/\/ frames only exist for calls between HotSpot and libjvmci.\n+                        while (myStackIndex < myStack.length) {\n+                            StackTraceElement suffixSTE = myStack[myStackIndex++];\n+                            if (suffixSTE.isNativeMethod()) {\n+                                break;\n+                            }\n+                            stackTrace[stackTraceIndex++] = suffixSTE;\n+                        }\n+                    }\n+                    stackTrace[stackTraceIndex++] = ste;\n+                }\n+                while (myStackIndex < myStack.length) {\n+                    stackTrace[stackTraceIndex++] = myStack[myStackIndex++];\n+                }\n+                if (stackTraceIndex != stackTrace.length) {\n+                    \/\/ Remove null entries at end of stackTrace\n+                    stackTrace = Arrays.copyOf(stackTrace, stackTraceIndex);\n+                }\n+                throwable.setStackTrace(stackTrace);\n+                cause = throwable;\n+            }\n+            return throwable;\n+        } catch (Throwable translationFailure) {\n+            debugPrintStackTrace(translationFailure);\n+            return new TranslatedException(\"Error decoding exception: \" + encodedThrowable, translationFailure.getClass().getName());\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/TranslatedException.java","additions":284,"deletions":0,"binary":false,"changes":284,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,3 @@\n+import jdk.internal.misc.VM;\n+import jdk.internal.misc.Unsafe;\n+\n@@ -36,1 +39,1 @@\n- * Support class used by JVMTI and VM attach mechanism.\n+ * Support class used by JVMCI, JVMTI and VM attach mechanism.\n@@ -40,0 +43,1 @@\n+    private static final Unsafe U = Unsafe.getUnsafe();\n@@ -41,0 +45,1 @@\n+\n@@ -54,3 +59,6 @@\n-     * Write the given properties list to a byte array and return it. Properties with\n-     * a key or value that is not a String is filtered out. The stream written to the byte\n-     * array is ISO 8859-1 encoded.\n+     * Writes the given properties list to a byte array and return it. The stream written\n+     * to the byte array is ISO 8859-1 encoded.\n+     *\n+     * @param filter if true, then entries in {@code p} with a key or value that is not a\n+     *               String are filtered out. Otherwise, the caller guarantees {@code p}\n+     *               only contains String keys and values.\n@@ -58,1 +66,1 @@\n-    private static byte[] serializePropertiesToByteArray(Properties p) throws IOException {\n+    private static byte[] serializePropertiesToByteArray(Properties p, boolean filter) throws IOException {\n@@ -61,1 +69,3 @@\n-        Properties props = new Properties();\n+        Properties props;\n+        if (filter) {\n+            props = new Properties();\n@@ -63,5 +73,8 @@\n-        \/\/ stringPropertyNames() returns a snapshot of the property keys\n-        Set<String> keyset = p.stringPropertyNames();\n-        for (String key : keyset) {\n-            String value = p.getProperty(key);\n-            props.put(key, value);\n+            \/\/ stringPropertyNames() returns a snapshot of the property keys\n+            Set<String> keyset = p.stringPropertyNames();\n+            for (String key : keyset) {\n+                String value = p.getProperty(key);\n+                props.put(key, value);\n+            }\n+        } else {\n+            props = p;\n@@ -75,1 +88,1 @@\n-        return serializePropertiesToByteArray(System.getProperties());\n+        return serializePropertiesToByteArray(System.getProperties(), true);\n@@ -79,1 +92,17 @@\n-        return serializePropertiesToByteArray(getAgentProperties());\n+        return serializePropertiesToByteArray(getAgentProperties(), true);\n+    }\n+\n+    \/**\n+     * Serializes {@link VM#getSavedProperties()} to a byte array.\n+     *\n+     * Used by JVMCI to copy properties into libjvmci.\n+     *\/\n+    public static byte[] serializeSavedPropertiesToByteArray() throws IOException {\n+        Properties props = new Properties();\n+        for (var e : VM.getSavedProperties().entrySet()) {\n+            props.put(e.getKey(), e.getValue());\n+        }\n+        if (props.get(\"oome\") != null) {\n+            throw new OutOfMemoryError(\"forced OOME\");\n+        }\n+        return serializePropertiesToByteArray(props, false);\n@@ -91,0 +120,36 @@\n+\n+    \/**\n+     * Decodes the exception encoded in {@code buffer} and throws it.\n+     *\n+     * @param buffer a native byte buffer containing an exception encoded by\n+     *            {@link #encodeThrowable}\n+     *\/\n+    public static void decodeAndThrowThrowable(long buffer) throws Throwable {\n+        int encodingLength = U.getInt(buffer);\n+        byte[] encoding = new byte[encodingLength];\n+        U.copyMemory(null, buffer + 4, encoding, Unsafe.ARRAY_BYTE_BASE_OFFSET, encodingLength);\n+        throw TranslatedException.decodeThrowable(encoding);\n+    }\n+\n+    \/**\n+     * If {@code bufferSize} is large enough, encodes {@code throwable} into a byte array and writes\n+     * it to {@code buffer}. The encoding in {@code buffer} can be decoded by\n+     * {@link #decodeAndThrowThrowable}.\n+     *\n+     * @param throwable the exception to encode\n+     * @param buffer a native byte buffer\n+     * @param bufferSize the size of {@code buffer} in bytes\n+     * @return the number of bytes written into {@code buffer} if {@code bufferSize} is large\n+     *         enough, otherwise {@code -N} where {@code N} is the value {@code bufferSize} needs to\n+     *         be to fit the encoding\n+     *\/\n+    public static int encodeThrowable(Throwable throwable, long buffer, int bufferSize) {\n+        byte[] encoding = TranslatedException.encodeThrowable(throwable);\n+        int requiredSize = 4 + encoding.length;\n+        if (bufferSize < requiredSize) {\n+            return -requiredSize;\n+        }\n+        U.putInt(buffer, encoding.length);\n+        U.copyMemory(encoding, Unsafe.ARRAY_BYTE_BASE_OFFSET, null, buffer + 4, encoding.length);\n+        return requiredSize;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/VMSupport.java","additions":79,"deletions":14,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -209,58 +209,0 @@\n-    \/**\n-     * Decodes the exception encoded in {@code buffer} and throws it.\n-     *\n-     * @param errorOrBuffer an error code or a native byte buffer containing an exception encoded by\n-     *            {@link #encodeThrowable}. Error code values and their meanings are:\n-     *\n-     *            <pre>\n-     *             0: native memory for the buffer could not be allocated\n-     *            -1: an OutOfMemoryError was thrown while encoding the exception\n-     *            -2: some other throwable was thrown while encoding the exception\n-     *            <\/pre>\n-     *\/\n-    @VMEntryPoint\n-    static void decodeAndThrowThrowable(long errorOrBuffer) throws Throwable {\n-        if (errorOrBuffer >= -2L && errorOrBuffer <= 0) {\n-            String context = String.format(\"while encoding an exception to translate it from %s to %s\",\n-                            IS_IN_NATIVE_IMAGE ? \"HotSpot\" : \"libjvmci\",\n-                            IS_IN_NATIVE_IMAGE ? \"libjvmci\" : \"HotSpot\");\n-            if (errorOrBuffer == 0) {\n-                throw new InternalError(\"native buffer could not be allocated \" + context);\n-            }\n-            if (errorOrBuffer == -1L) {\n-                throw new OutOfMemoryError(\"OutOfMemoryError occurred \" + context);\n-            }\n-            throw new InternalError(\"unexpected problem occurred \" + context);\n-        }\n-        Unsafe unsafe = UnsafeAccess.UNSAFE;\n-        int encodingLength = unsafe.getInt(errorOrBuffer);\n-        byte[] encoding = new byte[encodingLength];\n-        unsafe.copyMemory(null, errorOrBuffer + 4, encoding, Unsafe.ARRAY_BYTE_BASE_OFFSET, encodingLength);\n-        throw TranslatedException.decodeThrowable(encoding);\n-    }\n-\n-    \/**\n-     * If {@code bufferSize} is large enough, encodes {@code throwable} into a byte array and writes\n-     * it to {@code buffer}. The encoding in {@code buffer} can be decoded by\n-     * {@link #decodeAndThrowThrowable}.\n-     *\n-     * @param throwable the exception to encode\n-     * @param buffer a native byte buffer\n-     * @param bufferSize the size of {@code buffer} in bytes\n-     * @return the number of bytes written into {@code buffer} if {@code bufferSize} is large\n-     *         enough, otherwise {@code -N} where {@code N} is the value {@code bufferSize} needs to\n-     *         be to fit the encoding\n-     *\/\n-    @VMEntryPoint\n-    static int encodeThrowable(Throwable throwable, long buffer, int bufferSize) throws Throwable {\n-        byte[] encoding = TranslatedException.encodeThrowable(throwable);\n-        int requiredSize = 4 + encoding.length;\n-        if (bufferSize < requiredSize) {\n-            return -requiredSize;\n-        }\n-        Unsafe unsafe = UnsafeAccess.UNSAFE;\n-        unsafe.putInt(buffer, encoding.length);\n-        unsafe.copyMemory(encoding, Unsafe.ARRAY_BYTE_BASE_OFFSET, null, buffer + 4, encoding.length);\n-        return requiredSize;\n-    }\n-\n@@ -1333,1 +1275,1 @@\n-                throw new JVMCIError(Option.ForceTranslateFailure + \" filter does not match \" + FORCE_TRANSLATE_FAILURE_FILTER_RE + \": \" + filter);\n+                throw new IllegalArgumentException(Option.ForceTranslateFailure + \" filter does not match \" + FORCE_TRANSLATE_FAILURE_FILTER_RE + \": \" + filter);\n@@ -1353,1 +1295,1 @@\n-                throw new JVMCIError(\"translation of \" + translatedObject + \" failed due to matching \" + Option.ForceTranslateFailure + \" filter \\\"\" + filter + \"\\\"\");\n+                throw new RuntimeException(\"translation of \" + translatedObject + \" failed due to matching \" + Option.ForceTranslateFailure + \" filter \\\"\" + filter + \"\\\"\");\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotJVMCIRuntime.java","additions":2,"deletions":60,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -1,275 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.vm.ci.hotspot;\n-\n-import java.io.ByteArrayInputStream;\n-import java.io.ByteArrayOutputStream;\n-import java.io.DataInputStream;\n-import java.io.DataOutputStream;\n-import java.io.IOException;\n-import java.lang.reflect.InvocationTargetException;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.zip.GZIPInputStream;\n-import java.util.zip.GZIPOutputStream;\n-\n-import jdk.vm.ci.common.JVMCIError;\n-\n-\/**\n- * Support for translating exceptions between different runtime heaps.\n- *\/\n-@SuppressWarnings(\"serial\")\n-final class TranslatedException extends Exception {\n-\n-    \/**\n-     * The value returned by {@link #encodeThrowable(Throwable)} when encoding fails due to an\n-     * {@link OutOfMemoryError}.\n-     *\/\n-    private static final byte[] FALLBACK_ENCODED_OUTOFMEMORYERROR_BYTES;\n-\n-    \/**\n-     * The value returned by {@link #encodeThrowable(Throwable)} when encoding fails for any reason\n-     * other than {@link OutOfMemoryError}.\n-     *\/\n-    private static final byte[] FALLBACK_ENCODED_THROWABLE_BYTES;\n-    static {\n-        try {\n-            FALLBACK_ENCODED_THROWABLE_BYTES = encodeThrowable(new TranslatedException(\"error during encoding\", \"<unknown>\"), false);\n-            FALLBACK_ENCODED_OUTOFMEMORYERROR_BYTES = encodeThrowable(new OutOfMemoryError(), false);\n-        } catch (IOException e) {\n-            throw new JVMCIError(e);\n-        }\n-    }\n-\n-    \/**\n-     * Class name of exception that could not be instantiated.\n-     *\/\n-    private String originalExceptionClassName;\n-\n-    private TranslatedException(String message, String originalExceptionClassName) {\n-        super(message);\n-        this.originalExceptionClassName = originalExceptionClassName;\n-    }\n-\n-    \/**\n-     * No need to record an initial stack trace since it will be manually overwritten.\n-     *\/\n-    @SuppressWarnings(\"sync-override\")\n-    @Override\n-    public Throwable fillInStackTrace() {\n-        return this;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        String s;\n-        if (originalExceptionClassName.equals(TranslatedException.class.getName())) {\n-            s = getClass().getName();\n-        } else {\n-            s = getClass().getName() + \"[\" + originalExceptionClassName + \"]\";\n-        }\n-        String message = getMessage();\n-        return (message != null) ? (s + \": \" + message) : s;\n-    }\n-\n-    \/**\n-     * Prints a stack trace for {@code throwable} and returns {@code true}. Used to print stack\n-     * traces only when assertions are enabled.\n-     *\/\n-    private static boolean printStackTrace(Throwable throwable) {\n-        throwable.printStackTrace();\n-        return true;\n-    }\n-\n-    private static Throwable initCause(Throwable throwable, Throwable cause) {\n-        if (cause != null) {\n-            try {\n-                throwable.initCause(cause);\n-            } catch (IllegalStateException e) {\n-                \/\/ Cause could not be set or overwritten.\n-                assert printStackTrace(e);\n-            }\n-        }\n-        return throwable;\n-    }\n-\n-    private static Throwable create(String className, String message, Throwable cause) {\n-        \/\/ Try create with reflection first.\n-        try {\n-            Class<?> cls = Class.forName(className);\n-            if (cause != null) {\n-                \/\/ Handle known exception types whose cause must be set in the constructor\n-                if (cls == InvocationTargetException.class) {\n-                    return new InvocationTargetException(cause, message);\n-                }\n-                if (cls == ExceptionInInitializerError.class) {\n-                    return new ExceptionInInitializerError(cause);\n-                }\n-            }\n-            if (message == null) {\n-                return initCause((Throwable) cls.getConstructor().newInstance(), cause);\n-            }\n-            return initCause((Throwable) cls.getDeclaredConstructor(String.class).newInstance(message), cause);\n-        } catch (Throwable translationFailure) {\n-            return initCause(new TranslatedException(message, className), cause);\n-        }\n-    }\n-\n-    private static String emptyIfNull(String value) {\n-        return value == null ? \"\" : value;\n-    }\n-\n-    private static String emptyAsNull(String value) {\n-        return value.isEmpty() ? null : value;\n-    }\n-\n-    \/**\n-     * Encodes {@code throwable} including its stack and causes as a {@linkplain GZIPOutputStream\n-     * compressed} byte array that can be decoded by {@link #decodeThrowable}.\n-     *\/\n-    static byte[] encodeThrowable(Throwable throwable) throws Throwable {\n-        try {\n-            return encodeThrowable(throwable, true);\n-        } catch (OutOfMemoryError e) {\n-            return FALLBACK_ENCODED_OUTOFMEMORYERROR_BYTES;\n-        } catch (Throwable e) {\n-            return FALLBACK_ENCODED_THROWABLE_BYTES;\n-        }\n-    }\n-\n-    private static byte[] encodeThrowable(Throwable throwable, boolean withCauseAndStack) throws IOException {\n-        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-        try (DataOutputStream dos = new DataOutputStream(new GZIPOutputStream(baos))) {\n-            List<Throwable> throwables = new ArrayList<>();\n-            for (Throwable current = throwable; current != null; current = current.getCause()) {\n-                throwables.add(current);\n-                if (!withCauseAndStack) {\n-                    break;\n-                }\n-            }\n-\n-            \/\/ Encode from inner most cause outwards\n-            Collections.reverse(throwables);\n-\n-            for (Throwable current : throwables) {\n-                dos.writeUTF(current.getClass().getName());\n-                dos.writeUTF(emptyIfNull(current.getMessage()));\n-                StackTraceElement[] stackTrace = withCauseAndStack ? current.getStackTrace() : null;\n-                if (stackTrace == null) {\n-                    stackTrace = new StackTraceElement[0];\n-                }\n-                dos.writeInt(stackTrace.length);\n-                for (int i = 0; i < stackTrace.length; i++) {\n-                    StackTraceElement frame = stackTrace[i];\n-                    if (frame != null) {\n-                        dos.writeUTF(emptyIfNull(frame.getClassLoaderName()));\n-                        dos.writeUTF(emptyIfNull(frame.getModuleName()));\n-                        dos.writeUTF(emptyIfNull(frame.getModuleVersion()));\n-                        dos.writeUTF(emptyIfNull(frame.getClassName()));\n-                        dos.writeUTF(emptyIfNull(frame.getMethodName()));\n-                        dos.writeUTF(emptyIfNull(frame.getFileName()));\n-                        dos.writeInt(frame.getLineNumber());\n-                    }\n-                }\n-            }\n-        }\n-        return baos.toByteArray();\n-    }\n-\n-    \/**\n-     * Gets the stack of the current thread without the frames between this call and the one just\n-     * below the frame of the first method in {@link CompilerToVM}. The chopped frames are for the\n-     * VM call to {@link HotSpotJVMCIRuntime#decodeAndThrowThrowable}.\n-     *\/\n-    private static StackTraceElement[] getMyStackTrace() {\n-        StackTraceElement[] stack = new Exception().getStackTrace();\n-        for (int i = 0; i < stack.length; i++) {\n-            StackTraceElement e = stack[i];\n-            if (e.getClassName().equals(CompilerToVM.class.getName())) {\n-                return Arrays.copyOfRange(stack, i, stack.length);\n-            }\n-        }\n-        \/\/ This should never happen but since we're in exception handling\n-        \/\/ code, just return a safe value instead raising a nested exception.\n-        return new StackTraceElement[0];\n-    }\n-\n-    \/**\n-     * Decodes {@code encodedThrowable} into a {@link TranslatedException}.\n-     *\n-     * @param encodedThrowable an encoded exception in the format specified by\n-     *            {@link #encodeThrowable}\n-     *\/\n-    static Throwable decodeThrowable(byte[] encodedThrowable) {\n-        try (DataInputStream dis = new DataInputStream(new GZIPInputStream(new ByteArrayInputStream(encodedThrowable)))) {\n-            Throwable cause = null;\n-            Throwable throwable = null;\n-            StackTraceElement[] myStack = getMyStackTrace();\n-            while (dis.available() != 0) {\n-                String exceptionClassName = dis.readUTF();\n-                String exceptionMessage = emptyAsNull(dis.readUTF());\n-                throwable = create(exceptionClassName, exceptionMessage, cause);\n-                int stackTraceDepth = dis.readInt();\n-                StackTraceElement[] stackTrace = new StackTraceElement[stackTraceDepth + myStack.length];\n-                int stackTraceIndex = 0;\n-                int myStackIndex = 0;\n-                for (int j = 0; j < stackTraceDepth; j++) {\n-                    String classLoaderName = emptyAsNull(dis.readUTF());\n-                    String moduleName = emptyAsNull(dis.readUTF());\n-                    String moduleVersion = emptyAsNull(dis.readUTF());\n-                    String className = emptyAsNull(dis.readUTF());\n-                    String methodName = emptyAsNull(dis.readUTF());\n-                    String fileName = emptyAsNull(dis.readUTF());\n-                    int lineNumber = dis.readInt();\n-                    StackTraceElement ste = new StackTraceElement(classLoaderName, moduleName, moduleVersion, className, methodName, fileName, lineNumber);\n-\n-                    if (ste.isNativeMethod()) {\n-                        \/\/ Best effort attempt to weave stack traces from two heaps into\n-                        \/\/ a single stack trace using native method frames as stitching points.\n-                        \/\/ This is not 100% reliable as there's no guarantee that native method\n-                        \/\/ frames only exist for calls between HotSpot and libjvmci.\n-                        while (myStackIndex < myStack.length) {\n-                            StackTraceElement suffixSTE = myStack[myStackIndex++];\n-                            if (suffixSTE.isNativeMethod()) {\n-                                break;\n-                            }\n-                            stackTrace[stackTraceIndex++] = suffixSTE;\n-                        }\n-                    }\n-                    stackTrace[stackTraceIndex++] = ste;\n-                }\n-                while (myStackIndex < myStack.length) {\n-                    stackTrace[stackTraceIndex++] = myStack[myStackIndex++];\n-                }\n-                throwable.setStackTrace(stackTrace);\n-                cause = throwable;\n-            }\n-            return throwable;\n-        } catch (Throwable translationFailure) {\n-            assert printStackTrace(translationFailure);\n-            return new TranslatedException(\"Error decoding exception: \" + encodedThrowable, translationFailure.getClass().getName());\n-        }\n-    }\n-}\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/TranslatedException.java","additions":0,"deletions":275,"binary":false,"changes":275,"status":"deleted"},{"patch":"@@ -26,3 +26,0 @@\n-import java.io.ByteArrayOutputStream;\n-import java.io.DataInputStream;\n-import java.io.DataOutputStream;\n@@ -37,0 +34,1 @@\n+import java.util.Properties;\n@@ -45,2 +43,0 @@\n-import static java.nio.charset.StandardCharsets.UTF_8;\n-\n@@ -269,70 +265,2 @@\n-     * A Java {@code char} has a maximal UTF8 length of 3.\n-     *\/\n-    private static final int MAX_UNICODE_IN_UTF8_LENGTH = 3;\n-\n-    \/**\n-     * {@link DataOutputStream#writeUTF(String)} only supports values whose UTF8 encoding length is\n-     * less than 65535.\n-     *\/\n-    private static final int MAX_UTF8_PROPERTY_STRING_LENGTH = 65535 \/ MAX_UNICODE_IN_UTF8_LENGTH;\n-\n-    \/**\n-     * Serializes the {@linkplain #getSavedProperties() saved system properties} to a byte array for\n-     * the purpose of {@linkplain #initializeSavedProperties(byte[]) initializing} the initial\n-     * properties in the JVMCI shared library.\n-     *\/\n-    @VMEntryPoint\n-    private static byte[] serializeSavedProperties() throws IOException {\n-        if (IS_IN_NATIVE_IMAGE) {\n-            throw new InternalError(\"Can only serialize saved properties in HotSpot runtime\");\n-        }\n-        return serializeProperties(Services.getSavedProperties());\n-    }\n-\n-    private static byte[] serializeProperties(Map<String, String> props) throws IOException {\n-        \/\/ Compute size of output on the assumption that\n-        \/\/ all system properties have ASCII names and values\n-        int estimate = 4 + 4;\n-        int nonUtf8Props = 0;\n-        for (Map.Entry<String, String> e : props.entrySet()) {\n-            String name = e.getKey();\n-            String value = e.getValue();\n-            estimate += (2 + (name.length())) + (2 + (value.length()));\n-            if (name.length() > MAX_UTF8_PROPERTY_STRING_LENGTH || value.length() > MAX_UTF8_PROPERTY_STRING_LENGTH) {\n-                nonUtf8Props++;\n-            }\n-        }\n-\n-        ByteArrayOutputStream baos = new ByteArrayOutputStream(estimate);\n-        DataOutputStream out = new DataOutputStream(baos);\n-        out.writeInt(props.size() - nonUtf8Props);\n-        out.writeInt(nonUtf8Props);\n-        for (Map.Entry<String, String> e : props.entrySet()) {\n-            String name = e.getKey();\n-            String value = e.getValue();\n-            if (name.length() <= MAX_UTF8_PROPERTY_STRING_LENGTH && value.length() <= MAX_UTF8_PROPERTY_STRING_LENGTH) {\n-                out.writeUTF(name);\n-                out.writeUTF(value);\n-            }\n-        }\n-        if (nonUtf8Props != 0) {\n-            for (Map.Entry<String, String> e : props.entrySet()) {\n-                String name = e.getKey();\n-                String value = e.getValue();\n-                if (name.length() > MAX_UTF8_PROPERTY_STRING_LENGTH || value.length() > MAX_UTF8_PROPERTY_STRING_LENGTH) {\n-                    byte[] utf8Name = name.getBytes(UTF_8);\n-                    byte[] utf8Value = value.getBytes(UTF_8);\n-                    out.writeInt(utf8Name.length);\n-                    out.write(utf8Name);\n-                    out.writeInt(utf8Value.length);\n-                    out.write(utf8Value);\n-                }\n-            }\n-        }\n-        return baos.toByteArray();\n-    }\n-\n-    \/**\n-     * Initialized the {@linkplain #getSavedProperties() saved system properties} in the JVMCI\n-     * shared library from the {@linkplain #serializeSavedProperties() serialized saved properties}\n-     * in the HotSpot runtime.\n+     * Initializes {@link #savedProperties} from the byte array returned by\n+     * {@code jdk.internal.vm.VMSupport.serializeSavedPropertiesToByteArray()}.\n@@ -345,26 +273,5 @@\n-        savedProperties = Collections.unmodifiableMap(deserializeProperties(serializedProperties));\n-    }\n-\n-    private static Map<String, String> deserializeProperties(byte[] serializedProperties) throws IOException {\n-        DataInputStream in = new DataInputStream(new ByteArrayInputStream(serializedProperties));\n-        int utf8Props = in.readInt();\n-        int nonUtf8Props = in.readInt();\n-        Map<String, String> props = new HashMap<>(utf8Props + nonUtf8Props);\n-        int index = 0;\n-        while (in.available() != 0) {\n-            if (index < utf8Props) {\n-                String name = in.readUTF();\n-                String value = in.readUTF();\n-                props.put(name, value);\n-            } else {\n-                int nameLen = in.readInt();\n-                byte[] nameBytes = new byte[nameLen];\n-                in.read(nameBytes);\n-                int valueLen = in.readInt();\n-                byte[] valueBytes = new byte[valueLen];\n-                in.read(valueBytes);\n-                String name = new String(nameBytes, UTF_8);\n-                String value = new String(valueBytes, UTF_8);\n-                props.put(name, value);\n-            }\n-            index++;\n+        Properties props = new Properties();\n+        props.load(new ByteArrayInputStream(serializedProperties));\n+        Map<String, String> map = new HashMap<>(props.size());\n+        for (var e : props.entrySet()) {\n+            map.put((String) e.getKey(), (String) e.getValue());\n@@ -372,1 +279,2 @@\n-        return props;\n+\n+        savedProperties = Collections.unmodifiableMap(map);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.services\/src\/jdk\/vm\/ci\/services\/Services.java","additions":10,"deletions":102,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -1,93 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @requires vm.jvmci\n- * @modules jdk.internal.vm.ci\/jdk.vm.ci.services:+open\n- * @library \/compiler\/jvmci\/jdk.vm.ci.hotspot.test\/src\n- * @run testng\/othervm\n- *      -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI -XX:-UseJVMCICompiler\n- *      jdk.vm.ci.hotspot.test.TestServices\n- *\/\n-\n-package jdk.vm.ci.hotspot.test;\n-\n-import java.lang.reflect.Field;\n-import java.lang.reflect.Method;\n-import java.util.HashMap;\n-import java.util.Map;\n-\n-import org.testng.Assert;\n-import org.testng.annotations.Test;\n-\n-import jdk.vm.ci.services.Services;\n-\n-public class TestServices {\n-\n-    @SuppressWarnings(\"unchecked\")\n-    @Test\n-    public void serializeSavedPropertiesTest() throws Exception {\n-\n-        Field f = Services.class.getDeclaredField(\"MAX_UTF8_PROPERTY_STRING_LENGTH\");\n-        f.setAccessible(true);\n-        int maxUtf8PropertyStringLength = (int) f.get(null);\n-\n-        Method serializeProperties = Services.class.getDeclaredMethod(\"serializeProperties\", Map.class);\n-        Method deserializeProperties = Services.class.getDeclaredMethod(\"deserializeProperties\", byte[].class);\n-        serializeProperties.setAccessible(true);\n-        deserializeProperties.setAccessible(true);\n-\n-        Map<String, String> props = new HashMap<>(Services.getSavedProperties());\n-        String[] names = {\n-                        new String(new char[maxUtf8PropertyStringLength - 100]).replace('\\0', 'x'),\n-                        new String(new char[maxUtf8PropertyStringLength - 1]).replace('\\0', 'x'),\n-                        new String(new char[maxUtf8PropertyStringLength]).replace('\\0', 'y'),\n-                        new String(new char[maxUtf8PropertyStringLength + 1]).replace('\\0', 'z'),\n-                        new String(new char[maxUtf8PropertyStringLength + 100]).replace('\\0', 'z')\n-        };\n-        String[] values = {\n-                        new String(new char[maxUtf8PropertyStringLength - 100]).replace('\\0', '1'),\n-                        new String(new char[maxUtf8PropertyStringLength - 1]).replace('\\0', '1'),\n-                        new String(new char[maxUtf8PropertyStringLength]).replace('\\0', '2'),\n-                        new String(new char[maxUtf8PropertyStringLength + 1]).replace('\\0', '1'),\n-                        new String(new char[maxUtf8PropertyStringLength + 100]).replace('\\0', '3')\n-        };\n-        for (String name : names) {\n-            for (String value : values) {\n-                props.put(name, value);\n-            }\n-        }\n-\n-        byte[] data = (byte[]) serializeProperties.invoke(null, props);\n-\n-        Map<String, String> newProps = (Map<String, String>) deserializeProperties.invoke(null, data);\n-\n-        Assert.assertEquals(props.size(), newProps.size());\n-        for (String name : props.keySet()) {\n-            String expect = props.get(name);\n-            String actual = newProps.get(name);\n-            Assert.assertEquals(expect, actual);\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.hotspot.test\/src\/jdk\/vm\/ci\/hotspot\/test\/TestServices.java","additions":0,"deletions":93,"binary":false,"changes":93,"status":"deleted"},{"patch":"@@ -1,153 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @requires vm.jvmci\n- * @modules jdk.internal.vm.ci\/jdk.vm.ci.hotspot:+open\n- *          java.base\/jdk.internal.misc\n- * @library \/compiler\/jvmci\/jdk.vm.ci.hotspot.test\/src\n- * @run testng\/othervm\n- *      -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI -XX:-UseJVMCICompiler\n- *      jdk.vm.ci.hotspot.test.TestTranslatedException\n- *\/\n-\n-package jdk.vm.ci.hotspot.test;\n-\n-import java.io.ByteArrayOutputStream;\n-import java.io.PrintStream;\n-import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Method;\n-\n-import org.testng.Assert;\n-import org.testng.annotations.Test;\n-\n-import jdk.internal.misc.Unsafe;\n-import jdk.vm.ci.hotspot.HotSpotJVMCIRuntime;\n-\n-public class TestTranslatedException {\n-    @SuppressWarnings(\"serial\")\n-    public static class Untranslatable extends RuntimeException {\n-        public Untranslatable(String message, Throwable cause) {\n-            super(message, cause);\n-        }\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    @Test\n-    public void encodeDecodeTest() throws Exception {\n-\n-        Class<?> translatedExceptionClass = Class.forName(\"jdk.vm.ci.hotspot.TranslatedException\");\n-\n-        Method encode = translatedExceptionClass.getDeclaredMethod(\"encodeThrowable\", Throwable.class);\n-        Method decode = translatedExceptionClass.getDeclaredMethod(\"decodeThrowable\", byte[].class);\n-        encode.setAccessible(true);\n-        decode.setAccessible(true);\n-\n-        Throwable throwable = new ExceptionInInitializerError(new InvocationTargetException(new Untranslatable(\"test exception\", new NullPointerException()), \"invoke\"));\n-        for (int i = 0; i < 10; i++) {\n-            throwable = new ExceptionInInitializerError(new InvocationTargetException(new RuntimeException(String.valueOf(i), throwable), \"invoke\"));\n-        }\n-        byte[] encoding = (byte[]) encode.invoke(null, throwable);\n-        Throwable decoded = (Throwable) decode.invoke(null, encoding);\n-        assertThrowableEquals(throwable, decoded);\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    @Test\n-    public void encodeDecodeTest2() throws Exception {\n-        Unsafe unsafe = Unsafe.getUnsafe();\n-        int bufferSize = 512;\n-        long buffer = 0L;\n-        while (true) {\n-            buffer = unsafe.allocateMemory(bufferSize);\n-            try {\n-                Throwable throwable = new ExceptionInInitializerError(new InvocationTargetException(new Untranslatable(\"test exception\", new NullPointerException()), \"invoke\"));\n-                for (int i = 0; i < 10; i++) {\n-                    throwable = new ExceptionInInitializerError(new InvocationTargetException(new RuntimeException(String.valueOf(i), throwable), \"invoke\"));\n-                }\n-\n-                Method encode = HotSpotJVMCIRuntime.class.getDeclaredMethod(\"encodeThrowable\", Throwable.class, long.class, int.class);\n-                Method decode = HotSpotJVMCIRuntime.class.getDeclaredMethod(\"decodeAndThrowThrowable\", long.class);\n-                encode.setAccessible(true);\n-                decode.setAccessible(true);\n-\n-                int res = (Integer) encode.invoke(null, throwable, buffer, bufferSize);\n-\n-                if (res < 0) {\n-                    bufferSize = -res;\n-                } else {\n-                    try {\n-                        decode.invoke(null, buffer);\n-                        throw new AssertionError(\"expected decodeAndThrowThrowable to throw an exception\");\n-                    } catch (InvocationTargetException e) {\n-                        Throwable decoded = e.getCause();\n-                        assertThrowableEquals(throwable, decoded);\n-                    }\n-                    return;\n-                }\n-            } finally {\n-                unsafe.freeMemory(buffer);\n-            }\n-        }\n-    }\n-\n-    private static void assertThrowableEquals(Throwable original, Throwable decoded) {\n-        try {\n-            Assert.assertEquals(original == null, decoded == null);\n-            while (original != null) {\n-                if (Untranslatable.class.equals(original.getClass())) {\n-                    Assert.assertEquals(\"jdk.vm.ci.hotspot.TranslatedException\", decoded.getClass().getName());\n-                    Assert.assertEquals(\"jdk.vm.ci.hotspot.TranslatedException[jdk.vm.ci.hotspot.test.TestTranslatedException$Untranslatable]: test exception\", decoded.toString());\n-                    Assert.assertEquals(\"test exception\", original.getMessage());\n-                } else {\n-                    Assert.assertEquals(original.getClass().getName(), decoded.getClass().getName());\n-                    Assert.assertEquals(original.getMessage(), decoded.getMessage());\n-                }\n-                StackTraceElement[] originalStack = original.getStackTrace();\n-                StackTraceElement[] decodedStack = decoded.getStackTrace();\n-                Assert.assertEquals(originalStack.length, decodedStack.length);\n-                for (int i = 0, n = originalStack.length; i < n; ++i) {\n-                    StackTraceElement originalStackElement = originalStack[i];\n-                    StackTraceElement decodedStackElement = decodedStack[i];\n-                    Assert.assertEquals(originalStackElement.getClassLoaderName(), decodedStackElement.getClassLoaderName());\n-                    Assert.assertEquals(originalStackElement.getModuleName(), decodedStackElement.getModuleName());\n-                    Assert.assertEquals(originalStackElement.getClassName(), decodedStackElement.getClassName());\n-                    Assert.assertEquals(originalStackElement.getMethodName(), decodedStackElement.getMethodName());\n-                    Assert.assertEquals(originalStackElement.getFileName(), decodedStackElement.getFileName());\n-                    Assert.assertEquals(originalStackElement.getLineNumber(), decodedStackElement.getLineNumber());\n-                }\n-                original = original.getCause();\n-                decoded = decoded.getCause();\n-            }\n-        } catch (AssertionError e) {\n-            System.err.println(\"original:[\");\n-            original.printStackTrace(System.err);\n-            System.err.println(\"]\");\n-            System.err.println(\"decoded:[\");\n-            original.printStackTrace(System.err);\n-            System.err.println(\"]\");\n-            throw e;\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.hotspot.test\/src\/jdk\/vm\/ci\/hotspot\/test\/TestTranslatedException.java","additions":0,"deletions":153,"binary":false,"changes":153,"status":"deleted"},{"patch":"@@ -0,0 +1,134 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @modules java.base\/jdk.internal.vm\n+ *          java.base\/jdk.internal.misc\n+ * @run testng\/othervm\n+ *      jdk.internal.vm.test.TestTranslatedException\n+ *\/\n+package jdk.internal.vm.test;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.PrintStream;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.vm.VMSupport;\n+\n+public class TestTranslatedException {\n+    @SuppressWarnings(\"serial\")\n+    public static class Untranslatable extends RuntimeException {\n+        public Untranslatable(String message, Throwable cause) {\n+            super(message, cause);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Test\n+    public void encodeDecodeTest() throws Exception {\n+        Throwable throwable = new ExceptionInInitializerError(new InvocationTargetException(new Untranslatable(\"test exception\", new NullPointerException()), \"invoke\"));\n+        for (int i = 0; i < 10; i++) {\n+            throwable = new ExceptionInInitializerError(new InvocationTargetException(new RuntimeException(String.valueOf(i), throwable), \"invoke\"));\n+        }\n+        encodeDecode(throwable);\n+    }\n+    @SuppressWarnings(\"unchecked\")\n+    @Test\n+    public void encodeDecodeTest2() throws Exception {\n+        Throwable throwable = new ExceptionInInitializerError(new InvocationTargetException(new Untranslatable(\"test exception\", new NullPointerException()), \"invoke\"));\n+        for (int i = 0; i < 10; i++) {\n+            throwable = new ExceptionInInitializerError(new InvocationTargetException(new RuntimeException(String.valueOf(i), throwable), \"invoke\"));\n+        }\n+        encodeDecode(throwable);\n+    }\n+\n+    private void encodeDecode(Throwable throwable) throws Exception {\n+        Unsafe unsafe = Unsafe.getUnsafe();\n+        int bufferSize = 512;\n+        long buffer = 0L;\n+        while (true) {\n+            buffer = unsafe.allocateMemory(bufferSize);\n+            try {\n+                int res = VMSupport.encodeThrowable(throwable, buffer, bufferSize);\n+                if (res < 0) {\n+                    bufferSize = -res;\n+                } else {\n+                    try {\n+                        VMSupport.decodeAndThrowThrowable(buffer);\n+                        throw new AssertionError(\"expected decodeAndThrowThrowable to throw an exception\");\n+                    } catch (Throwable decoded) {\n+                        assertThrowableEquals(throwable, decoded);\n+                    }\n+                    return;\n+                }\n+            } finally {\n+                unsafe.freeMemory(buffer);\n+            }\n+        }\n+    }\n+\n+    private static void assertThrowableEquals(Throwable original, Throwable decoded) {\n+        try {\n+            Assert.assertEquals(original == null, decoded == null);\n+            while (original != null) {\n+                if (Untranslatable.class.equals(original.getClass())) {\n+                    Assert.assertEquals(decoded.getClass().getName(), \"jdk.internal.vm.TranslatedException\");\n+                    Assert.assertEquals(decoded.toString(), \"jdk.internal.vm.TranslatedException[jdk.internal.vm.test.TestTranslatedException$Untranslatable]: test exception\");\n+                    Assert.assertEquals(original.getMessage(), \"test exception\");\n+                } else {\n+                    Assert.assertEquals(decoded.getClass().getName(), original.getClass().getName());\n+                    Assert.assertEquals(decoded.getMessage(), original.getMessage());\n+                }\n+                StackTraceElement[] originalStack = original.getStackTrace();\n+                StackTraceElement[] decodedStack = decoded.getStackTrace();\n+                Assert.assertEquals(originalStack.length, decodedStack.length);\n+                for (int i = 0, n = originalStack.length; i < n; ++i) {\n+                    StackTraceElement originalStackElement = originalStack[i];\n+                    StackTraceElement decodedStackElement = decodedStack[i];\n+                    Assert.assertEquals(decodedStackElement.getClassLoaderName(), originalStackElement.getClassLoaderName());\n+                    Assert.assertEquals(decodedStackElement.getModuleName(), originalStackElement.getModuleName());\n+                    Assert.assertEquals(decodedStackElement.getClassName(), originalStackElement.getClassName());\n+                    Assert.assertEquals(decodedStackElement.getMethodName(), originalStackElement.getMethodName());\n+                    Assert.assertEquals(decodedStackElement.getFileName(), originalStackElement.getFileName());\n+                    Assert.assertEquals(decodedStackElement.getLineNumber(), originalStackElement.getLineNumber());\n+                }\n+                original = original.getCause();\n+                decoded = decoded.getCause();\n+            }\n+        } catch (AssertionError e) {\n+            System.err.println(\"original:[\");\n+            original.printStackTrace(System.err);\n+            System.err.println(\"]\");\n+            System.err.println(\"decoded:[\");\n+            original.printStackTrace(System.err);\n+            System.err.println(\"]\");\n+            throw e;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/internal\/vm\/TestTranslatedException.java","additions":134,"deletions":0,"binary":false,"changes":134,"status":"added"}]}