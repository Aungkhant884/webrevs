{"files":[{"patch":"@@ -32,0 +32,1 @@\n+import java.lang.reflect.Constructor;\n@@ -47,2 +48,2 @@\n-     * The value returned by {@link #encodeThrowable(Throwable)} when encoding fails due to an\n-     * {@link OutOfMemoryError}.\n+     * The value returned by {@link #encodeThrowable(Throwable)} when encoding\n+     * fails due to an {@link OutOfMemoryError}.\n@@ -53,2 +54,2 @@\n-     * The value returned by {@link #encodeThrowable(Throwable)} when encoding fails for any reason\n-     * other than {@link OutOfMemoryError}.\n+     * The value returned by {@link #encodeThrowable(Throwable)} when encoding\n+     * fails for any reason other than {@link OutOfMemoryError}.\n@@ -59,2 +60,5 @@\n-            FALLBACK_ENCODED_THROWABLE_BYTES = encodeThrowable(new TranslatedException(\"error during encoding\", \"<unknown>\"), false);\n-            FALLBACK_ENCODED_OUTOFMEMORYERROR_BYTES = encodeThrowable(new OutOfMemoryError(), false);\n+            FALLBACK_ENCODED_THROWABLE_BYTES =\n+                encodeThrowable(new TranslatedException(\"error during encoding\",\n+                                                        \"<unknown>\"), false);\n+            FALLBACK_ENCODED_OUTOFMEMORYERROR_BYTES =\n+                encodeThrowable(new OutOfMemoryError(), false);\n@@ -77,1 +81,2 @@\n-     * No need to record an initial stack trace since it will be manually overwritten.\n+     * No need to record an initial stack trace since\n+     * it will be manually overwritten.\n@@ -125,1 +130,2 @@\n-                \/\/ Handle known exception types whose cause must be set in the constructor\n+                \/\/ Handle known exception types whose cause must\n+                \/\/ be set in the constructor\n@@ -134,1 +140,2 @@\n-                return initCause((Throwable) cls.getConstructor().newInstance(), cause);\n+                Constructor<?> cons = cls.getConstructor();\n+                return initCause((Throwable) cons.newInstance(), cause);\n@@ -136,1 +143,2 @@\n-            return initCause((Throwable) cls.getDeclaredConstructor(String.class).newInstance(message), cause);\n+            Constructor<?> cons = cls.getDeclaredConstructor(String.class);\n+            return initCause((Throwable) cons.newInstance(message), cause);\n@@ -165,1 +173,2 @@\n-    private static byte[] encodeThrowable(Throwable throwable, boolean withCauseAndStack) throws IOException {\n+    private static byte[] encodeThrowable(Throwable throwable,\n+                                          boolean withCauseAndStack) throws IOException {\n@@ -213,4 +222,2 @@\n-            boolean isNativeMethodInCompilerToVM = e.getLineNumber() == -1 && e.getClassName().equals(\"jdk.vm.ci.hotspot.CompilerToVM\");\n-            if (e.isNativeMethod() || isNativeMethodInCompilerToVM) {\n-                StackTraceElement[] res = Arrays.copyOfRange(stack, i, stack.length);\n-                return res;\n+            if (e.isNativeMethod()) {\n+                return Arrays.copyOfRange(stack, i, stack.length);\n@@ -231,1 +238,2 @@\n-        try (DataInputStream dis = new DataInputStream(new GZIPInputStream(new ByteArrayInputStream(encodedThrowable)))) {\n+        ByteArrayInputStream bais = new ByteArrayInputStream(encodedThrowable);\n+        try (DataInputStream dis = new DataInputStream(new GZIPInputStream(bais))) {\n@@ -251,1 +259,7 @@\n-                    StackTraceElement ste = new StackTraceElement(classLoaderName, moduleName, moduleVersion, className, methodName, fileName, lineNumber);\n+                    StackTraceElement ste = new StackTraceElement(classLoaderName,\n+                                                                  moduleName,\n+                                                                  moduleVersion,\n+                                                                  className,\n+                                                                  methodName,\n+                                                                  fileName,\n+                                                                  lineNumber);\n@@ -281,1 +295,2 @@\n-            return new TranslatedException(\"Error decoding exception: \" + encodedThrowable, translationFailure.getClass().getName());\n+            return new TranslatedException(\"Error decoding exception: \" + encodedThrowable,\n+                                           translationFailure.getClass().getName());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/TranslatedException.java","additions":33,"deletions":18,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -61,4 +61,0 @@\n-     *\n-     * @param filter if true, then entries in {@code p} with a key or value that is not a\n-     *               String are filtered out. Otherwise, the caller guarantees {@code p}\n-     *               only contains String keys and values.\n@@ -66,1 +62,1 @@\n-    private static byte[] serializePropertiesToByteArray(Properties p, boolean filter) throws IOException {\n+    private static byte[] serializePropertiesToByteArray(Properties p) throws IOException {\n@@ -68,0 +64,3 @@\n+        p.store(out, null);\n+        return out.toByteArray();\n+    }\n@@ -69,3 +68,6 @@\n-        Properties props;\n-        if (filter) {\n-            props = new Properties();\n+    \/**\n+     * @returns a Properties object containing only the entries in {@code p}\n+     *          whose key and value are both Strings\n+     *\/\n+    private static Properties onlyStrings(Properties p) {\n+        Properties props = new Properties();\n@@ -73,8 +75,5 @@\n-            \/\/ stringPropertyNames() returns a snapshot of the property keys\n-            Set<String> keyset = p.stringPropertyNames();\n-            for (String key : keyset) {\n-                String value = p.getProperty(key);\n-                props.put(key, value);\n-            }\n-        } else {\n-            props = p;\n+        \/\/ stringPropertyNames() returns a snapshot of the property keys\n+        Set<String> keyset = p.stringPropertyNames();\n+        for (String key : keyset) {\n+            String value = p.getProperty(key);\n+            props.put(key, value);\n@@ -82,3 +81,1 @@\n-\n-        props.store(out, null);\n-        return out.toByteArray();\n+        return props;\n@@ -88,1 +85,1 @@\n-        return serializePropertiesToByteArray(System.getProperties(), true);\n+        return serializePropertiesToByteArray(onlyStrings(System.getProperties()));\n@@ -92,1 +89,1 @@\n-        return serializePropertiesToByteArray(getAgentProperties(), true);\n+        return serializePropertiesToByteArray(onlyStrings(getAgentProperties()));\n@@ -105,4 +102,1 @@\n-        if (props.get(\"oome\") != null) {\n-            throw new OutOfMemoryError(\"forced OOME\");\n-        }\n-        return serializePropertiesToByteArray(props, false);\n+        return serializePropertiesToByteArray(props);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/VMSupport.java","additions":19,"deletions":25,"binary":false,"changes":44,"status":"modified"}]}