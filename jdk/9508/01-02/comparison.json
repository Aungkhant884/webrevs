{"files":[{"patch":"@@ -265,1 +265,1 @@\n-  unsigned int bit1 = abs_con & (0-abs_con);       \/\/ Extract low bit\n+  unsigned int bit1 = submultiple_power_of_2(abs_con);\n@@ -368,1 +368,1 @@\n-  julong bit1 = abs_con & (0-abs_con);      \/\/ Extract low bit\n+  julong bit1 = submultiple_power_of_2(abs_con);\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -122,0 +122,10 @@\n+\/\/ Return the largest power of two that is a submultiple of the given value.\n+\/\/ This is the same as the numeric value of the least-significant set bit.\n+\/\/ For unsigned values, it replaces the old trick of (value & -value).\n+\/\/ precondition: value > 0.\n+template<typename T, ENABLE_IF(std::is_integral<T>::value)>\n+inline T submultiple_power_of_2(T value) {\n+  assert(value > 0, \"Invalid value\");\n+  return value & -value;\n+}\n+\n","filename":"src\/hotspot\/share\/utilities\/powerOfTwo.hpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -29,2 +29,4 @@\n- * @requires vm.compiler2.enabled\n- * @run driver compiler.rangechecks.TestRangeCheckHoistingScaledIV\n+ * @requires vm.debug & vm.compiler2.enabled\n+ * @modules jdk.incubator.vector\n+ * @compile --enable-preview -source ${jdk.version} TestRangeCheckHoistingScaledIV.java\n+ * @run main\/othervm --enable-preview compiler.rangechecks.TestRangeCheckHoistingScaledIV\n@@ -35,1 +37,7 @@\n-import compiler.lib.ir_framework.*;\n+import java.lang.foreign.MemorySegment;\n+import java.nio.ByteOrder;\n+\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n@@ -39,1 +47,5 @@\n-    private static final int SIZE = 16000;\n+    \/\/ Inner class for test loops\n+    class Launcher {\n+        private static final int SIZE = 16000;\n+        private static final VectorSpecies<Byte> SPECIES = ByteVector.SPECIES_64;\n+        private static final ByteOrder ORDER = ByteOrder.nativeOrder();\n@@ -41,3 +53,2 @@\n-    private static int[] a = new int[SIZE];\n-    private static int[] b = new int[SIZE];\n-    private static int count = 567;\n+        private static byte[] ta = new byte[SIZE];\n+        private static byte[] tb = new byte[SIZE];\n@@ -45,3 +56,2 @@\n-    \/\/ If the loop predication successfully hoists range checks in below\n-    \/\/ loops, there is only uncommon trap with reason='predicate' and no\n-    \/\/ uncommon trap with reason='range_check'.\n+        private static MemorySegment sa = MemorySegment.ofArray(ta);\n+        private static MemorySegment sb = MemorySegment.ofArray(tb);\n@@ -49,7 +59,1 @@\n-    @Test\n-    @IR(failOn = {IRNode.RANGE_CHECK_TRAP})\n-    public static void ivMul3() {\n-        for (int i = 0; i < count; i++) {\n-            b[3 * i] = a[3 * i];\n-        }\n-    }\n+        private static int count = 789;\n@@ -57,5 +61,5 @@\n-    @Test\n-    @IR(failOn = {IRNode.RANGE_CHECK_TRAP})\n-    public static void ivMul6() {\n-        for (int i = 0; i < count; i++) {\n-            b[6 * i] = a[6 * i];\n+        \/\/ Normal array accesses with int range checks\n+        public static void scaledIntIV() {\n+            for (int i = 0; i < count; i += 2) {\n+                tb[7 * i] = ta[3 * i];\n+            }\n@@ -63,1 +67,0 @@\n-    }\n@@ -65,5 +68,6 @@\n-    @Test\n-    @IR(failOn = {IRNode.RANGE_CHECK_TRAP})\n-    public static void ivMul7() {\n-        for (int i = 0; i < count; i++) {\n-            b[7 * i] = a[7 * i];\n+        \/\/ Memory segment accesses with long range checks\n+        public static void scaledLongIV() {\n+            for (long l = 0; l < count; l += 64) {\n+                ByteVector v = ByteVector.fromMemorySegment(SPECIES, sa, l * 6, ORDER);\n+                v.intoMemorySegment(sb, l * 15, ORDER);\n+            }\n@@ -71,1 +75,0 @@\n-    }\n@@ -73,5 +76,5 @@\n-    @Test\n-    @IR(failOn = {IRNode.RANGE_CHECK_TRAP})\n-    public static void ivMulMinus3() {\n-        for (int i = 0; i > -count; i--) {\n-            b[-3 * i] = a[-3 * i];\n+        public static void main(String[] args) {\n+            for (int i = 0; i < 20000; i++) {\n+                scaledIntIV();\n+                scaledLongIV();\n+            }\n@@ -81,7 +84,7 @@\n-    @Test\n-    @IR(failOn = {IRNode.RANGE_CHECK_TRAP})\n-    public static void ivMulMinus6() {\n-        for (int i = 0; i > -count; i--) {\n-            b[-6 * i] = a[-6 * i];\n-        }\n-    }\n+    public static void main(String[] args) throws Exception {\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n+                \"--enable-preview\", \"--add-modules\", \"jdk.incubator.vector\",\n+                \"-Xbatch\", \"-XX:+TraceLoopPredicate\", Launcher.class.getName());\n+        OutputAnalyzer analyzer = new OutputAnalyzer(pb.start());\n+        analyzer.shouldHaveExitValue(0);\n+        analyzer.outputTo(System.out);\n@@ -89,7 +92,5 @@\n-    @Test\n-    @IR(failOn = {IRNode.RANGE_CHECK_TRAP})\n-    public static void ivMulMinus9() {\n-        for (int i = 0; i > -count; i--) {\n-            b[-9 * i] = a[-9 * i];\n-        }\n-    }\n+        \/\/ Check if int range checks are hoisted\n+        analyzer.stdoutShouldContain(\"rc_predicate init * 3 <u range\");\n+        analyzer.stdoutShouldContain(\"rc_predicate (limit - 2) * 3 <u range\");\n+        analyzer.stdoutShouldContain(\"rc_predicate init * 7 <u range\");\n+        analyzer.stdoutShouldContain(\"rc_predicate (limit - 2) * 7 <u range\");\n@@ -97,2 +98,5 @@\n-    public static void main(String[] args) {\n-        TestFramework.run();\n+        \/\/ Check if long range checks are hoisted\n+        analyzer.stdoutShouldContain(\"rc_predicate init * 6 <u range\");\n+        analyzer.stdoutShouldContain(\"rc_predicate (limit - 64) * 6 <u range\");\n+        analyzer.stdoutShouldContain(\"rc_predicate init * 15 <u range\");\n+        analyzer.stdoutShouldContain(\"rc_predicate (limit - 64) * 15 <u range\");\n","filename":"test\/hotspot\/jtreg\/compiler\/rangechecks\/TestRangeCheckHoistingScaledIV.java","additions":54,"deletions":50,"binary":false,"changes":104,"status":"modified"}]}