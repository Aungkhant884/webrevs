[{"commit":{"message":"8289996: Fix array range check hoisting for some scaled loop iv\n\nRecently we found some array range checks in loops are not hoisted by\nC2's loop predication phase as expected. Below is a typical case.\n\n  for (int i = 0; i < size; i++) {\n    b[3 * i] = a[3 * i];\n  }\n\nIdeally, C2 can hoist the range check of an array access in loop if the\narray index is a linear function of the loop's induction variable (iv).\nSay, range check in `arr[exp]` can be hoisted if\n\n  exp = k1 * iv + k2 + inv\n\nwhere `k1` and `k2` are compile-time constants, and `inv` is an optional\nloop invariant. But in above case, C2 igvn does some strength reduction\non the `MulINode` used to compute `3*i`. It results in the linear index\nexpression not being recognized. So far we found 2 ideal transformations\nthat may affect linear expression recognition. They are\n\n- `k * iv` --> `iv << m + iv << n` if k is the sum of 2 pow-of-2 values\n- `k * iv` --> `iv << m - iv` if k+1 is a pow-of-2 value\n\nTo avoid range check hoisting and further optimizations being broken, we\nhave tried improving the linear recognition. But after some experiments,\nwe found complex and recursive pattern match does not always work well.\nIn this patch we propose to defer these 2 ideal transformations to the\nphase of post loop igvn. In other words, these 2 strength reductions can\nonly be done after all loop optimizations are over.\n\nTested hotspot::hotspot_all_no_apps, jdk::tier1~3 and langtools::tier1.\nWe also tested the performance via JMH and see obvious improvement.\n\nBenchmark                        Improvement\nRangeCheckHoisting.ivScaled3          +21.2%\nRangeCheckHoisting.ivScaled7           +6.6%"},"files":[{"filename":"src\/hotspot\/share\/opto\/mulnode.cpp"},{"filename":"test\/hotspot\/jtreg\/compiler\/rangechecks\/TestRangeCheckHoistingScaledIV.java"},{"filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/RangeCheckHoisting.java"}],"sha":"f65be1c8ad8289b81d8f22b27e0e32ab27c49a76"}]