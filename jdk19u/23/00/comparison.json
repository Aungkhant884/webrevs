{"files":[{"patch":"@@ -70,0 +70,2 @@\n+\n+import jdk.internal.misc.CarrierThreadLocal;\n@@ -2557,2 +2559,10 @@\n-            public <T> T getCarrierThreadLocal(ThreadLocal<T> local) {\n-                return local.getCarrierThreadLocal();\n+            public <T> T getCarrierThreadLocal(CarrierThreadLocal<T> local) {\n+                return ((ThreadLocal<T>)local).getCarrierThreadLocal();\n+            }\n+\n+            public <T> void setCarrierThreadLocal(CarrierThreadLocal<T> local, T value) {\n+                ((ThreadLocal<T>)local).setCarrierThreadLocal(value);\n+            }\n+\n+            public void removeCarrierThreadLocal(CarrierThreadLocal<?> local) {\n+                ((ThreadLocal<?>)local).removeCarrierThreadLocal();\n@@ -2561,2 +2571,2 @@\n-            public <T> void setCarrierThreadLocal(ThreadLocal<T> local, T value) {\n-                local.setCarrierThreadLocal(value);\n+            public boolean isCarrierThreadLocalPresent(CarrierThreadLocal<?> local) {\n+                return ((ThreadLocal<?>)local).isCarrierThreadLocalPresent();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -32,0 +32,2 @@\n+\n+import jdk.internal.misc.CarrierThreadLocal;\n@@ -175,0 +177,1 @@\n+        assert this instanceof CarrierThreadLocal<T>;\n@@ -196,1 +199,1 @@\n-     * Returns {@code true} if there is a value in the current thread's copy of\n+     * Returns {@code true} if there is a value in the current carrier thread's copy of\n@@ -199,1 +202,1 @@\n-     * @return {@code true} if current thread has associated value in this\n+     * @return {@code true} if current carrier thread has associated value in this\n@@ -202,2 +205,6 @@\n-    boolean isPresent() {\n-        Thread t = Thread.currentThread();\n+    boolean isCarrierThreadLocalPresent() {\n+        assert this instanceof CarrierThreadLocal<T>;\n+        return isPresent(Thread.currentCarrierThread());\n+    }\n+\n+    private boolean isPresent(Thread t) {\n@@ -227,2 +234,2 @@\n-        if (this instanceof TerminatingThreadLocal) {\n-            TerminatingThreadLocal.register((TerminatingThreadLocal<?>) this);\n+        if (this instanceof TerminatingThreadLocal<?> ttl) {\n+            TerminatingThreadLocal.register(ttl);\n@@ -252,0 +259,1 @@\n+        assert this instanceof CarrierThreadLocal<T>;\n@@ -279,1 +287,10 @@\n-         ThreadLocalMap m = getMap(Thread.currentThread());\n+         remove(Thread.currentThread());\n+     }\n+\n+     void removeCarrierThreadLocal() {\n+         assert this instanceof CarrierThreadLocal<T>;\n+         remove(Thread.currentCarrierThread());\n+     }\n+\n+     private void remove(Thread t) {\n+         ThreadLocalMap m = getMap(t);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ThreadLocal.java","additions":24,"deletions":7,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.lang.invoke.MethodHandles;\n@@ -48,0 +47,1 @@\n+import jdk.internal.misc.CarrierThreadLocal;\n@@ -459,1 +459,1 @@\n-    <T> T getCarrierThreadLocal(ThreadLocal<T> local);\n+    <T> T getCarrierThreadLocal(CarrierThreadLocal<T> local);\n@@ -464,1 +464,12 @@\n-    <T> void setCarrierThreadLocal(ThreadLocal<T> local, T value);\n+    <T> void setCarrierThreadLocal(CarrierThreadLocal<T> local, T value);\n+\n+    \/**\n+     * Removes the value of the current carrier thread's copy of a thread-local.\n+     *\/\n+    void removeCarrierThreadLocal(CarrierThreadLocal<?> local);\n+\n+    \/**\n+     * Returns {@code true} if there is a value in the current carrier thread's copy of\n+     * thread-local, even if that values is {@code null}.\n+     *\/\n+    boolean isCarrierThreadLocalPresent(CarrierThreadLocal<?> local);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":14,"deletions":3,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.misc;\n+\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n+\n+\/**\n+ * A {@link ThreadLocal} variant which binds its value to current thread's\n+ * carrier thread.\n+ *\/\n+public class CarrierThreadLocal<T> extends ThreadLocal<T> {\n+\n+    @Override\n+    public T get() {\n+        return JLA.getCarrierThreadLocal(this);\n+    }\n+\n+    @Override\n+    public void set(T value) {\n+        JLA.setCarrierThreadLocal(this, value);\n+    }\n+\n+    @Override\n+    public void remove() {\n+        JLA.removeCarrierThreadLocal(this);\n+    }\n+\n+    public boolean isPresent() {\n+        return JLA.isCarrierThreadLocalPresent(this);\n+    }\n+\n+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/CarrierThreadLocal.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -32,2 +32,3 @@\n- * A thread-local variable that is notified when a thread terminates and\n- * it has been initialized in the terminating thread (even if it was\n+ * A per-carrier-thread-local variable that is notified when a thread terminates and\n+ * it has been initialized in the terminating carrier thread or a virtual thread\n+ * that had the terminating carrier thread as its carrier thread (even if it was\n@@ -36,1 +37,1 @@\n-public class TerminatingThreadLocal<T> extends ThreadLocal<T> {\n+public class TerminatingThreadLocal<T> extends CarrierThreadLocal<T> {\n@@ -82,2 +83,1 @@\n-        if (!Thread.currentThread().isVirtual())\n-            REGISTRY.get().add(tl);\n+        REGISTRY.get().add(tl);\n@@ -92,2 +92,1 @@\n-        if (!Thread.currentThread().isVirtual())\n-            REGISTRY.get().remove(tl);\n+        REGISTRY.get().remove(tl);\n@@ -97,2 +96,2 @@\n-     * a per-thread registry of TerminatingThreadLocal(s) that have been registered\n-     * but later not unregistered in a particular thread.\n+     * a per-carrier-thread registry of TerminatingThreadLocal(s) that have been registered\n+     * but later not unregistered in a particular carrier-thread.\n@@ -100,2 +99,2 @@\n-    public static final ThreadLocal<Collection<TerminatingThreadLocal<?>>> REGISTRY =\n-        new ThreadLocal<>() {\n+    public static final CarrierThreadLocal<Collection<TerminatingThreadLocal<?>>> REGISTRY =\n+        new CarrierThreadLocal<>() {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/TerminatingThreadLocal.java","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -30,2 +30,1 @@\n-import jdk.internal.access.JavaLangAccess;\n-import jdk.internal.access.SharedSecrets;\n+import jdk.internal.misc.CarrierThreadLocal;\n@@ -49,1 +48,0 @@\n-    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n@@ -86,2 +84,2 @@\n-    \/\/ per thread IOVecWrapper\n-    private static final ThreadLocal<IOVecWrapper> cached = new ThreadLocal<>();\n+    \/\/ per carrier-thread IOVecWrapper\n+    private static final CarrierThreadLocal<IOVecWrapper> cached = new CarrierThreadLocal<>();\n@@ -100,1 +98,1 @@\n-        IOVecWrapper wrapper = JLA.getCarrierThreadLocal(cached);\n+        IOVecWrapper wrapper = cached.get();\n@@ -109,1 +107,1 @@\n-            JLA.setCarrierThreadLocal(cached, wrapper);\n+            cached.set(wrapper);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/IOVecWrapper.java","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -41,2 +41,0 @@\n-import jdk.internal.access.JavaLangAccess;\n-import jdk.internal.access.SharedSecrets;\n@@ -48,1 +46,0 @@\n-    private static JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n@@ -58,2 +55,2 @@\n-    \/\/ Per-thread cache of temporary direct buffers\n-    private static ThreadLocal<BufferCache> bufferCache = new TerminatingThreadLocal<>() {\n+    \/\/ Per-carrier-thread cache of temporary direct buffers\n+    private static TerminatingThreadLocal<BufferCache> bufferCache = new TerminatingThreadLocal<>() {\n@@ -233,1 +230,1 @@\n-        BufferCache cache = JLA.getCarrierThreadLocal(bufferCache);\n+        BufferCache cache = bufferCache.get();\n@@ -260,1 +257,1 @@\n-        BufferCache cache = JLA.getCarrierThreadLocal(bufferCache);\n+        BufferCache cache = bufferCache.get();\n@@ -297,1 +294,1 @@\n-        BufferCache cache = JLA.getCarrierThreadLocal(bufferCache);\n+        BufferCache cache = bufferCache.get();\n@@ -319,1 +316,1 @@\n-        BufferCache cache = JLA.getCarrierThreadLocal(bufferCache);\n+        BufferCache cache = bufferCache.get();\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/Util.java","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import jdk.internal.access.JavaLangAccess;\n-import jdk.internal.access.SharedSecrets;\n@@ -38,1 +36,0 @@\n-    private static JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n@@ -43,1 +40,2 @@\n-    private static ThreadLocal<NativeBuffer[]> threadLocal = new TerminatingThreadLocal<>() {\n+    \/\/ per-carrier-thread cache of NativeBuffer(s)\n+    private static final TerminatingThreadLocal<NativeBuffer[]> threadLocal = new TerminatingThreadLocal<>() {\n@@ -76,1 +74,1 @@\n-        NativeBuffer[] buffers = JLA.getCarrierThreadLocal(threadLocal);\n+        NativeBuffer[] buffers = threadLocal.get();\n@@ -110,1 +108,1 @@\n-        NativeBuffer[] buffers = JLA.getCarrierThreadLocal(threadLocal);\n+        NativeBuffer[] buffers = threadLocal.get();\n@@ -114,1 +112,1 @@\n-            JLA.setCarrierThreadLocal(threadLocal, buffers);\n+            threadLocal.set(buffers);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/fs\/NativeBuffers.java","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.util.concurrent.TimeUnit;\n@@ -33,1 +34,1 @@\n- * @bug 8202788\n+ * @bug 8202788 8291897\n@@ -36,1 +37,3 @@\n- * @run main TestTerminatingThreadLocal\n+ * @requires vm.continuations\n+ * @enablePreview\n+ * @run main\/othervm -Djdk.virtualThreadScheduler.parallelism=1 -Djdk.virtualThreadScheduler.maxPoolSize=2 TestTerminatingThreadLocal\n@@ -41,1 +44,1 @@\n-        ttlTestSet(42,   112);\n+        ttlTestSet(42, 112);\n@@ -43,1 +46,3 @@\n-        ttlTestSet(42,  null);\n+        ttlTestSet(42, null);\n+\n+        ttlTestVirtual(666, ThreadLocal::get, 666);\n@@ -47,8 +52,8 @@\n-        ttlTest(v0, ttl -> {                                         }    );\n-        ttlTest(v0, ttl -> { ttl.get();                              }, v0);\n-        ttlTest(v0, ttl -> { ttl.get();   ttl.remove();              }    );\n-        ttlTest(v0, ttl -> { ttl.get();   ttl.set(v1);               }, v1);\n-        ttlTest(v0, ttl -> { ttl.set(v1);                            }, v1);\n-        ttlTest(v0, ttl -> { ttl.set(v1); ttl.remove();              }    );\n-        ttlTest(v0, ttl -> { ttl.set(v1); ttl.remove(); ttl.get();   }, v0);\n-        ttlTest(v0, ttl -> { ttl.get();   ttl.remove(); ttl.set(v1); }, v1);\n+        ttlTestPlatform(v0, ttl -> {                                         }    );\n+        ttlTestPlatform(v0, ttl -> { ttl.get();                              }, v0);\n+        ttlTestPlatform(v0, ttl -> { ttl.get();   ttl.remove();              }    );\n+        ttlTestPlatform(v0, ttl -> { ttl.get();   ttl.set(v1);               }, v1);\n+        ttlTestPlatform(v0, ttl -> { ttl.set(v1);                            }, v1);\n+        ttlTestPlatform(v0, ttl -> { ttl.set(v1); ttl.remove();              }    );\n+        ttlTestPlatform(v0, ttl -> { ttl.set(v1); ttl.remove(); ttl.get();   }, v0);\n+        ttlTestPlatform(v0, ttl -> { ttl.get();   ttl.remove(); ttl.set(v1); }, v1);\n@@ -57,0 +62,1 @@\n+\n@@ -58,4 +64,3 @@\n-    static <T> void ttlTest(T initialValue,\n-                            Consumer<? super TerminatingThreadLocal<T>> ttlOps,\n-                            T... expectedTerminatedValues)\n-    {\n+    static <T> void ttlTestPlatform(T initialValue,\n+                                    Consumer<? super TerminatingThreadLocal<T>> ttlOps,\n+                                    T... expectedTerminatedValues) {\n@@ -76,1 +81,1 @@\n-        Thread thread = new Thread(() -> ttlOps.accept(ttl));\n+        Thread thread = new Thread(() -> ttlOps.accept(ttl), \"ttl-test-platform\");\n@@ -90,0 +95,92 @@\n+\n+    @SafeVarargs\n+    static <T> void ttlTestVirtual(T initialValue,\n+                                   Consumer<? super TerminatingThreadLocal<T>> ttlOps,\n+                                   T... expectedTerminatedValues) {\n+        List<T> terminatedValues = new CopyOnWriteArrayList<>();\n+\n+        TerminatingThreadLocal<T> ttl = new TerminatingThreadLocal<>() {\n+            @Override\n+            protected void threadTerminated(T value) {\n+                terminatedValues.add(value);\n+            }\n+\n+            @Override\n+            protected T initialValue() {\n+                return initialValue;\n+            }\n+        };\n+\n+        var lock = new Lock();\n+\n+        var blockerThread = Thread.startVirtualThread(() -> {\n+            \/\/ force compensation in carrier thread pool which will spin another\n+            \/\/ carrier thread so that we can later observe it being terminated...\n+            synchronized (lock) {\n+                while (!lock.unblock) {\n+                    try {\n+                        lock.wait();\n+                    } catch (InterruptedException e) {\n+                        throw new RuntimeException(e);\n+                    }\n+                }\n+            }\n+            \/\/ keep thread running in a non-blocking-fashion which keeps\n+            \/\/ it bound to carrier thread\n+            while (!lock.unspin) {\n+                Thread.onSpinWait();\n+            }\n+        });\n+\n+        Thread thread = Thread\n+            .ofVirtual()\n+            .allowSetThreadLocals(false)\n+            .inheritInheritableThreadLocals(false)\n+            .name(\"ttl-test-virtual\")\n+            .unstarted(() -> ttlOps.accept(ttl));\n+        thread.start();\n+        try {\n+            thread.join();\n+        } catch (InterruptedException e) {\n+            throw new RuntimeException(e);\n+        }\n+\n+        if (!terminatedValues.isEmpty()) {\n+            throw new AssertionError(\"Unexpected terminated values after virtual thread.join(): \" +\n+                                     terminatedValues);\n+        }\n+\n+        \/\/ we now unblock the blocker thread but keep it running\n+        synchronized (lock) {\n+            lock.unblock = true;\n+            lock.notify();\n+        }\n+\n+        \/\/ carrier thread pool has a 30 second keep-alive time to terminate excessive carrier\n+        \/\/ threads. Since blockerThread is still pinning one of them we hope for the other\n+        \/\/ thread to be terminated...\n+        try {\n+            TimeUnit.SECONDS.sleep(31);\n+        } catch (InterruptedException e) {\n+            throw new RuntimeException(e);\n+        }\n+\n+        if (!terminatedValues.equals(Arrays.asList(expectedTerminatedValues))) {\n+            throw new AssertionError(\"Expected terminated values: \" +\n+                                     Arrays.toString(expectedTerminatedValues) +\n+                                     \" but got: \" + terminatedValues);\n+        }\n+\n+        \/\/ we now terminate the blocker thread\n+        lock.unspin = true;\n+        try {\n+            blockerThread.join();\n+        } catch (InterruptedException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    static class Lock {\n+        boolean unblock;\n+        volatile boolean unspin;\n+    }\n","filename":"test\/jdk\/jdk\/internal\/misc\/TerminatingThreadLocal\/TestTerminatingThreadLocal.java","additions":115,"deletions":18,"binary":false,"changes":133,"status":"modified"}]}