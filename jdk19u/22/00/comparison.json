{"files":[{"patch":"@@ -66,1 +66,1 @@\n-     * @return the return value from the attempt to compensate\n+     * @return the return value from the attempt to compensate or -1 if not attempted\n@@ -84,1 +84,1 @@\n-        return 0;\n+        return -1;\n@@ -90,2 +90,2 @@\n-     * @return the return value from the attempt to compensate when blocking is true,\n-     * another value when blocking is false\n+     * @return the return value from the attempt to compensate, -1 if not attempted\n+     * or blocking is false\n@@ -94,1 +94,1 @@\n-        return (blocking) ? begin() : 0;\n+        return (blocking) ? begin() : -1;\n@@ -102,1 +102,1 @@\n-        if (compensateReturn > 0) {\n+        if (compensateReturn >= 0) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/Blocker.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,148 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8292240\n+ * @summary Test the scenario where a blocking operation pins a virtual thread to its\n+ *   carrier thread (cT1) and doesn't activate a spare. Subsequent blocking operations\n+ *   that pin a virtual thread to cT1 should attempt to activate a spare.\n+ * @requires vm.continuations\n+ * @enablePreview\n+ * @run main\/othervm\n+ *     -Djdk.virtualThreadScheduler.parallelism=1\n+ *     -Djdk.virtualThreadScheduler.maxPoolSize=2 ActiviateSpareCarrier 100\n+ *\/\n+\n+import java.time.Duration;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.concurrent.ForkJoinWorkerThread;\n+import java.util.stream.Collectors;\n+\n+public class ActiviateSpareCarrier {\n+\n+    private static final int DEFAULT_ITERTAIONS = 10_000;\n+\n+    private static final Object LOCK = new Object();\n+\n+    public static void main(String[] args) throws Exception {\n+        int iterations;\n+        if (args.length == 0) {\n+            iterations = DEFAULT_ITERTAIONS;\n+        } else {\n+            iterations = Integer.parseInt(args[0]);\n+        }\n+        for (int i = 0; i < iterations; i++) {\n+            test(i);\n+        }\n+    }\n+\n+    \/**\n+     * This method creates 3 virtual threads:\n+     * - thread1 blocks in Object.wait, activating a spare carrier thread\n+     * - thread2 is started and runs on the spare carrier thread\n+     * - thread1 is notified causing it to re-adjust the release count and terminate\n+     * - thread3 is started and should run on the one active thread\n+     *\n+     * This method need invoked at least twice in the same VM.\n+     *\/\n+    private static void test(int i) throws Exception {\n+        System.out.printf(\"---- %d ----%n\", i);\n+\n+        \/\/ thread1 blocks in wait, this triggers a tryCompensate to activate a spare thread\n+        Thread thread1 = Thread.ofVirtual().unstarted(() -> {\n+            System.out.println(Thread.currentThread());\n+            synchronized (LOCK) {\n+                try {\n+                    LOCK.wait();\n+                } catch (InterruptedException e) { }\n+            }\n+        });\n+        System.out.printf(\"starting waiter thread #%d%n\", thread1.threadId());\n+        thread1.start();\n+\n+        \/\/ wait for thread1 to block in Object.wait\n+        while (thread1.getState() != Thread.State.WAITING) {\n+            Thread.sleep(10);\n+        }\n+\n+        \/\/ start another virtual thread, it should run on the spare carrier thread\n+        startAndJoinVirtualThread();\n+\n+        \/\/ notify thread1, this releases the blocker\n+        synchronized (LOCK) {\n+            LOCK.notifyAll();\n+        }\n+        joinThread(thread1);\n+\n+        \/\/ start another virtual thread after counts have been re-adjusted\n+        startAndJoinVirtualThread();\n+    }\n+\n+    \/**\n+     * Start a virtual thread and wait for it to terminate.\n+     *\/\n+    private static void startAndJoinVirtualThread() throws InterruptedException {\n+        Thread thread = Thread.ofVirtual().unstarted(() -> {\n+            System.out.println(Thread.currentThread());\n+        });\n+        System.out.format(\"starting #%d%n\", thread.threadId());\n+        thread.start();\n+        joinThread(thread);\n+    }\n+\n+    \/**\n+     * Wait for the give thread to terminate with diagnostic output if the thread does\n+     * not terminate quickly.\n+     *\/\n+    private static void joinThread(Thread thread) throws InterruptedException {\n+        long tid = thread.threadId();\n+        System.out.printf(\"Waiting for #%d to terminate%n\", tid);\n+        boolean terminated = thread.join(Duration.ofSeconds(2));\n+        if (!terminated) {\n+            System.out.printf(\"#%d did not terminate quickly, continue to wait...%n\", tid);\n+            printForkJoinWorkerThreads();\n+            thread.join();\n+        }\n+        System.out.printf(\"#%d terminated%n\", tid);\n+    }\n+\n+    \/**\n+     * Print the list of ForkJoinWorkerThreads and their stack traces.\n+     *\/\n+    private static void printForkJoinWorkerThreads() {\n+        List<Thread> threads = Thread.getAllStackTraces().keySet().stream()\n+                .filter(t -> t instanceof ForkJoinWorkerThread)\n+                .sorted(Comparator.comparingLong(Thread::threadId))\n+                .collect(Collectors.toList());\n+        System.out.println(\"ForkJoinWorkerThreads:\");\n+        for (Thread t : threads) {\n+            System.out.printf(\"    %s%n\", t);\n+            StackTraceElement[] stack = t.getStackTrace();\n+            for (StackTraceElement e : stack) {\n+                System.out.printf(\"      %s%n\", e);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/ActiviateSpareCarrier.java","additions":148,"deletions":0,"binary":false,"changes":148,"status":"added"}]}