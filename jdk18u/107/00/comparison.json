{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-#include \"classfile\/systemDictionary.hpp\"\n@@ -284,25 +283,0 @@\n-static bool is_klass_initialized(Symbol* klass_name) {\n-  VM_ENTRY_MARK;\n-  InstanceKlass* ik = SystemDictionary::find_instance_klass(klass_name, Handle(), Handle());\n-  return ik != nullptr && ik->is_initialized();\n-}\n-\n-bool ciInstanceKlass::is_box_cache_valid() const {\n-  BasicType box_type = box_klass_type();\n-\n-  if (box_type != T_OBJECT) {\n-    switch(box_type) {\n-      case T_INT:     return is_klass_initialized(java_lang_Integer_IntegerCache::symbol());\n-      case T_CHAR:    return is_klass_initialized(java_lang_Character_CharacterCache::symbol());\n-      case T_SHORT:   return is_klass_initialized(java_lang_Short_ShortCache::symbol());\n-      case T_BYTE:    return is_klass_initialized(java_lang_Byte_ByteCache::symbol());\n-      case T_LONG:    return is_klass_initialized(java_lang_Long_LongCache::symbol());\n-      case T_BOOLEAN:\n-      case T_FLOAT:\n-      case T_DOUBLE:  return true;\n-      default:;\n-    }\n-  }\n-  return false;\n-}\n-\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.cpp","additions":1,"deletions":27,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -268,1 +268,0 @@\n-  bool is_box_cache_valid() const;\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -585,56 +585,0 @@\n-static bool has_non_debug_usages(Node* n) {\n-  for (DUIterator_Fast imax, i = n->fast_outs(imax); i < imax; i++) {\n-    Node* m = n->fast_out(i);\n-    if (!m->is_SafePoint()\n-        || (m->is_Call() && m->as_Call()->has_non_debug_use(n))) {\n-      return true;\n-    }\n-  }\n-  return false;\n-}\n-\n-static bool is_box_cache_valid(CallNode* call) {\n-  ciInstanceKlass* klass = call->as_CallStaticJava()->method()->holder();\n-  return klass->is_box_cache_valid();\n-}\n-\n-\/\/ delay box in runtime, treat box as a scalarized object\n-static void scalarize_debug_usages(CallNode* call, Node* resproj) {\n-  GraphKit kit(call->jvms());\n-  PhaseGVN& gvn = kit.gvn();\n-\n-  ProjNode* res = resproj->as_Proj();\n-  ciInstanceKlass* klass = call->as_CallStaticJava()->method()->holder();\n-  int n_fields = klass->nof_nonstatic_fields();\n-  assert(n_fields == 1, \"the klass must be an auto-boxing klass\");\n-\n-  for (DUIterator_Last imin, i = res->last_outs(imin); i >= imin;) {\n-    SafePointNode* sfpt = res->last_out(i)->as_SafePoint();\n-    uint first_ind = sfpt->req() - sfpt->jvms()->scloff();\n-    Node* sobj = new SafePointScalarObjectNode(gvn.type(res)->isa_oopptr(),\n-#ifdef ASSERT\n-                                                call,\n-#endif \/\/ ASSERT\n-                                                first_ind, n_fields, true);\n-    sobj->init_req(0, kit.root());\n-    sfpt->add_req(call->in(TypeFunc::Parms));\n-    sobj = gvn.transform(sobj);\n-    JVMState* jvms = sfpt->jvms();\n-    jvms->set_endoff(sfpt->req());\n-    int start = jvms->debug_start();\n-    int end   = jvms->debug_end();\n-    int num_edges = sfpt->replace_edges_in_range(res, sobj, start, end, &gvn);\n-    i -= num_edges;\n-  }\n-\n-  assert(res->outcnt() == 0, \"the box must have no use after replace\");\n-\n-#ifndef PRODUCT\n-  if (PrintEliminateAllocations) {\n-    tty->print(\"++++ Eliminated: %d \", call->_idx);\n-    call->as_CallStaticJava()->method()->print_short_name(tty);\n-    tty->cr();\n-  }\n-#endif\n-}\n-\n@@ -690,16 +634,3 @@\n-  bool result_not_used = false;\n-\n-  if (is_pure_call()) {\n-    \/\/ Disabled due to JDK-8276112\n-    if (false && is_boxing_late_inline() && callprojs.resproj != nullptr) {\n-      \/\/ replace box node to scalar node only in case it is directly referenced by debug info\n-      assert(call->as_CallStaticJava()->is_boxing_method(), \"sanity\");\n-      if (!has_non_debug_usages(callprojs.resproj) && is_box_cache_valid(call)) {\n-        scalarize_debug_usages(call, callprojs.resproj);\n-      }\n-    }\n-\n-    \/\/ The call is marked as pure (no important side effects), but result isn't used.\n-    \/\/ It's safe to remove the call.\n-    result_not_used = (callprojs.resproj == NULL || callprojs.resproj->outcnt() == 0);\n-  }\n+  \/\/ The call is marked as pure (no important side effects), but result isn't used.\n+  \/\/ It's safe to remove the call.\n+  bool result_not_used = (callprojs.resproj == NULL || callprojs.resproj->outcnt() == 0);\n@@ -707,1 +638,1 @@\n-  if (result_not_used) {\n+  if (is_pure_call() && result_not_used) {\n@@ -835,2 +766,0 @@\n-  virtual bool is_boxing_late_inline() const { return true; }\n-\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":5,"deletions":76,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,1 +77,0 @@\n-  virtual bool      is_boxing_late_inline() const  { return false; }\n","filename":"src\/hotspot\/share\/opto\/callGenerator.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1570,2 +1570,1 @@\n-                                                     uint n_fields,\n-                                                     bool is_auto_box) :\n+                                                     uint n_fields) :\n@@ -1574,2 +1573,1 @@\n-  _n_fields(n_fields),\n-  _is_auto_box(is_auto_box)\n+  _n_fields(n_fields)\n@@ -1582,2 +1580,1 @@\n-      && !(alloc->Opcode() == Op_VectorBox)\n-      && (!alloc->is_CallStaticJava() || !alloc->as_CallStaticJava()->is_boxing_method())) {\n+      && !(alloc->Opcode() == Op_VectorBox)) {\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -515,1 +515,0 @@\n-  bool _is_auto_box; \/\/ True if the scalarized object is an auto box.\n@@ -528,1 +527,1 @@\n-                            uint first_index, uint n_fields, bool is_auto_box = false);\n+                            uint first_index, uint n_fields);\n@@ -541,1 +540,0 @@\n-  bool is_auto_box() const { return _is_auto_box; }\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -828,3 +828,2 @@\n-      ScopeValue* klass_sv = new ConstantOopWriteValue(cik->java_mirror()->constant_encoding());\n-      sv = spobj->is_auto_box() ? new AutoBoxObjectValue(spobj->_idx, klass_sv)\n-                                    : new ObjectValue(spobj->_idx, klass_sv);\n+      sv = new ObjectValue(spobj->_idx,\n+                           new ConstantOopWriteValue(cik->java_mirror()->constant_encoding()));\n@@ -1102,3 +1101,2 @@\n-          ScopeValue* klass_sv = new ConstantOopWriteValue(cik->java_mirror()->constant_encoding());\n-          ObjectValue* sv = spobj->is_auto_box() ? new AutoBoxObjectValue(spobj->_idx, klass_sv)\n-                                        : new ObjectValue(spobj->_idx, klass_sv);\n+          ObjectValue* sv = new ObjectValue(spobj->_idx,\n+                                            new ConstantOopWriteValue(cik->java_mirror()->constant_encoding()));\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -942,1 +942,1 @@\n-#if COMPILER2_OR_JVMCI\n+#if INCLUDE_JVMCI\n@@ -1070,0 +1070,1 @@\n+#endif \/\/ INCLUDE_JVMCI\n@@ -1071,0 +1072,1 @@\n+#if COMPILER2_OR_JVMCI\n@@ -1087,1 +1089,3 @@\n-      if (sv->is_auto_box()) {\n+#if INCLUDE_JVMCI\n+      CompiledMethod* cm = fr->cb()->as_compiled_method_or_null();\n+      if (cm->is_compiled_by_jvmci() && sv->is_auto_box()) {\n@@ -1095,0 +1099,1 @@\n+#endif \/\/ INCLUDE_JVMCI\n@@ -1438,0 +1443,1 @@\n+#if INCLUDE_JVMCI\n@@ -1442,0 +1448,1 @@\n+#endif \/\/ INCLUDE_JVMCI\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -163,2 +163,0 @@\n-#endif\n-\n@@ -166,0 +164,1 @@\n+#endif\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,78 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Huawei Technologies Co., Ltd. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8261137\n- * @requires vm.flagless\n- * @requires vm.debug == true & vm.compiler2.enabled\n- * @summary Verify that box object is scalarized in case it is directly referenced by debug info.\n- * @library \/test\/lib\n- *\n- * @run driver compiler.eliminateAutobox.TestEliminateBoxInDebugInfo\n- *\/\n-package compiler.eliminateAutobox;\n-\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.process.ProcessTools;\n-\n-public class TestEliminateBoxInDebugInfo {\n-    public static void runTest() throws Exception {\n-        String[] arguments = {\n-            \"-XX:CompileCommand=compileonly,compiler\/eliminateAutobox\/TestEliminateBoxInDebugInfo$Test.foo\",\n-            \"-XX:CompileCommand=dontinline,compiler\/eliminateAutobox\/TestEliminateBoxInDebugInfo$Test.black\",\n-            \"-Xbatch\",\n-            \"-XX:+PrintEliminateAllocations\",\n-            Test.class.getName()\n-        };\n-        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(arguments);\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n-        output.shouldHaveExitValue(0)\n-              .stdoutShouldContain(\"++++ Eliminated: \");\n-    }\n-\n-    public static void main(String[] args) throws Exception {\n-        runTest();\n-    }\n-\n-    static class Test {\n-        public static void main(String[] args) throws Exception {\n-            \/\/ warmup\n-            for (int i = 0; i < 100000; i++) {\n-               foo(1000 + (i % 1000));\n-            }\n-        }\n-\n-        public static int foo(int value) {\n-            Integer ii = Integer.valueOf(value);\n-            int sum = 0;\n-            if (value > 999) {\n-                sum += ii.intValue();\n-            }\n-            black();\n-            return sum;\n-        }\n-\n-        public static void black() {}\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/eliminateAutobox\/TestEliminateBoxInDebugInfo.java","additions":0,"deletions":78,"binary":false,"changes":78,"status":"deleted"}]}