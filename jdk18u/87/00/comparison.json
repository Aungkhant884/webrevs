{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,5 @@\n+    public static final char PACKAGE_SEPARATOR_INTERNAL = '\/';\n+    public static final char HIDDEN_SEPARATOR_INTERNAL = '.';\n+    public static final char PACKAGE_SEPARATOR_JAVA = HIDDEN_SEPARATOR_INTERNAL;\n+    public static final char HIDDEN_SEPARATOR_JAVA = PACKAGE_SEPARATOR_INTERNAL;\n+\n@@ -90,2 +95,3 @@\n-     * Classes for lambdas can have {@code \/} characters that are not package separators. These are\n-     * distinguished by being followed by a character that is not a\n+     * Hidden classes have {@code \/} characters in their internal names and {@code .} characters in their names returned\n+     * by {@link Class#getName()} that are not package separators.\n+     * These are distinguished by being followed by a character that is not a\n@@ -94,0 +100,4 @@\n+     *\n+     * @param name the name to perform the replacements on\n+     * @param packageSeparator the {@link Character} used as the package separator, e.g. {@code \/} in internal form\n+     * @param hiddenSeparator the {@link Character} used as the hidden class separator, e.g. {@code .} in internal form\n@@ -95,1 +105,2 @@\n-    private static String replacePackageSeparatorsWithDot(String name) {\n+    private static String replacePackageAndHiddenSeparators(String name, Character packageSeparator, Character hiddenSeparator) {\n+        int index = name.indexOf(hiddenSeparator);   \/\/ check if it's a hidden class\n@@ -97,1 +108,0 @@\n-        int i = 0;\n@@ -99,8 +109,6 @@\n-        while (i < length - 1) {\n-            char ch = name.charAt(i);\n-            if (ch == '\/' && Character.isJavaIdentifierStart(name.charAt(i + 1))) {\n-                buf.append('.');\n-            } else {\n-                buf.append(ch);\n-            }\n-            i++;\n+        if (index < 0) {\n+            buf.append(name.replace(packageSeparator, hiddenSeparator));\n+        } else {\n+            buf.append(name.substring(0, index).replace(packageSeparator, hiddenSeparator));\n+            buf.append(packageSeparator);\n+            buf.append(name.substring(index + 1));\n@@ -108,1 +116,0 @@\n-        buf.append(name.charAt(length - 1));\n@@ -125,1 +132,2 @@\n-                String result = replacePackageSeparatorsWithDot(name.substring(1, name.length() - 1));\n+                String type = name.substring(1, name.length() - 1);\n+                String result = replacePackageAndHiddenSeparators(type, PACKAGE_SEPARATOR_INTERNAL, HIDDEN_SEPARATOR_INTERNAL);\n@@ -127,1 +135,1 @@\n-                    final int lastDot = result.lastIndexOf('.');\n+                    final int lastDot = result.lastIndexOf(HIDDEN_SEPARATOR_INTERNAL);\n@@ -135,1 +143,5 @@\n-                return classForNameCompatible ? replacePackageSeparatorsWithDot(name) : internalNameToJava(name.substring(1), qualified, classForNameCompatible) + \"[]\";\n+                if (classForNameCompatible) {\n+                    return replacePackageAndHiddenSeparators(name, PACKAGE_SEPARATOR_INTERNAL, HIDDEN_SEPARATOR_INTERNAL);\n+                } else {\n+                    return internalNameToJava(name.substring(1), qualified, false) + \"[]\";\n+                }\n@@ -216,1 +228,1 @@\n-            return className.replace('.', '\/');\n+            return replacePackageAndHiddenSeparators(className, PACKAGE_SEPARATOR_JAVA, HIDDEN_SEPARATOR_JAVA);\n@@ -255,1 +267,3 @@\n-                result.append(\"L\").append(base.replace('.', '\/')).append(\";\");\n+                result.append(\"L\")\n+                        .append(replacePackageAndHiddenSeparators(base, PACKAGE_SEPARATOR_JAVA, HIDDEN_SEPARATOR_JAVA))\n+                        .append(\";\");\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.meta\/src\/jdk\/vm\/ci\/meta\/MetaUtil.java","additions":33,"deletions":19,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -45,0 +45,2 @@\n+import static jdk.vm.ci.meta.MetaUtil.internalNameToJava;\n+import static jdk.vm.ci.meta.MetaUtil.toInternalName;\n@@ -166,3 +168,3 @@\n-    public void internalNameTest() {\n-        \/\/ Verify that the last slash in lambda types are not replaced with a '.' as they\n-        \/\/ are part of the type name.\n+    public void lambdaInternalNameTest() {\n+        \/\/ Verify that the last dot in lambda types is properly handled when transitioning from internal name to java\n+        \/\/ name and vice versa.\n@@ -172,4 +174,3 @@\n-        int typeNameLen = TestResolvedJavaType.class.getSimpleName().length();\n-        int index = typeName.indexOf(TestResolvedJavaType.class.getSimpleName());\n-        String suffix = typeName.substring(index + typeNameLen, typeName.length() - 1);\n-        assertEquals(TestResolvedJavaType.class.getName() + suffix, lambdaType.toJavaName());\n+        String javaName = lambda.getClass().getName();\n+        assertEquals(typeName, toInternalName(javaName));\n+        assertEquals(javaName, internalNameToJava(typeName, true, true));\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.runtime.test\/src\/jdk\/vm\/ci\/runtime\/test\/TestResolvedJavaType.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"}]}