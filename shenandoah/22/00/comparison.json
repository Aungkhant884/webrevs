{"files":[{"patch":"@@ -2042,1 +2042,1 @@\n-    \/\/ We update references for global and young collections.\n+    \/\/ We update references for global, old, and young collections.\n@@ -2051,1 +2051,1 @@\n-        if (r->affiliation() == YOUNG_GENERATION || !_heap->mode()->is_generational()) {\n+        if (!_heap->mode()->is_generational() || r->affiliation() == YOUNG_GENERATION) {\n@@ -2056,1 +2056,1 @@\n-            \/\/ Old region in a global cycle.\n+            \/\/ Old region in an old or global cycle.\n@@ -2060,1 +2060,1 @@\n-          } else if (ShenandoahBarrierSet::barrier_set()->card_table()->is_dirty(MemRegion(r->bottom(), r->top()))) {\n+          } else {\n@@ -2062,23 +2062,17 @@\n-            if (r->is_humongous()) {\n-              r->oop_iterate_humongous(&cl);\n-            } else {\n-              \/\/ We don't have liveness information about this region.\n-              \/\/ Therefore we process all objects, rather than just marked ones.\n-              \/\/ Otherwise subsequent traversals will encounter stale pointers.\n-\n-              \/\/ HEY! kelvin thinks we don't have to update refs throughout the entire region r.  We only need\n-              \/\/ to update refs for objects that span dirty cards.  The code in process clusters does that.  We cannot invoke process_clusters\n-              \/\/ because that's designed to process transitive closure of live objects.  Here, we are just looking\n-              \/\/ one level deep in each of the relevant regions.  But we can copy and paste some of the code from\n-              \/\/ there.\n-\n-              \/\/ HEY moreover!  Need to figure out how regions are partitioned between worker threads.  Is it possible\n-              \/\/ that each region is being processed redundantly by each worker thread?\n-\n-              HeapWord *p = r->bottom();\n-              ShenandoahObjectToOopBoundedClosure<T> objs(&cl, p, update_watermark);\n-              \/\/ Anything beyond update_watermark is not yet allocated or initialized.\n-              while (p < update_watermark) {\n-                oop obj = oop(p);\n-                objs.do_object(obj);\n-                p += obj->size();\n+            if (!ShenandoahUseSimpleCardScanning) {\n+              _heap->card_scan()->process_region(r, &cl);\n+            } else if (ShenandoahBarrierSet::barrier_set()->card_table()->is_dirty(MemRegion(r->bottom(), r->top()))) {\n+              if (r->is_humongous()) {\n+                r->oop_iterate_humongous(&cl);\n+              } else {\n+                \/\/ We don't have liveness information about this region.\n+                \/\/ Therefore we process all objects, rather than just marked ones.\n+                \/\/ Otherwise subsequent traversals will encounter stale pointers.\n+                HeapWord *p = r->bottom();\n+                ShenandoahObjectToOopBoundedClosure<T> objs(&cl, p, update_watermark);\n+                \/\/ Anything beyond update_watermark is not yet allocated or initialized.\n+                while (p < update_watermark) {\n+                  oop obj = oop(p);\n+                  objs.do_object(obj);\n+                  p += obj->size();\n+                }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":21,"deletions":27,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -110,21 +110,1 @@\n-      HeapWord *start_of_range = region->bottom();\n-      size_t start_cluster_no = rs->cluster_for_addr(start_of_range);\n-\n-      \/\/ region->end() represents the end of memory spanned by this region, but not all of this\n-      \/\/   memory is eligible to be scanned because some of this memory has not yet been allocated.\n-      \/\/\n-      \/\/ region->top() represents the end of allocated memory within this region.  Any addresses\n-      \/\/   beyond region->top() should not be scanned as that memory does not hold valid objects.\n-      HeapWord *end_of_range = region->top();\n-\n-      \/\/ end_of_range may point to the middle of a cluster because region->top() may be different than region->end.\n-      \/\/ We want to assure that our process_clusters() request spans all relevant clusters.  Note that each cluster\n-      \/\/ processed will avoid processing beyond end_of_range.\n-\n-      size_t num_heapwords = end_of_range - start_of_range;\n-      unsigned int cluster_size = CardTable::card_size_in_words *\n-        ShenandoahCardCluster<ShenandoahDirectCardMarkRememberedSet>::CardsPerCluster;\n-      size_t num_clusters = (size_t) ((num_heapwords - 1 + cluster_size) \/ cluster_size);\n-\n-      \/\/ Remembered set scanner\n-      rs->process_clusters(start_cluster_no, num_clusters, end_of_range, &cl);\n+      rs->process_region(region, &cl);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.cpp","additions":1,"deletions":21,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -216,0 +216,1 @@\n+#include \"gc\/shenandoah\/shenandoahHeapRegion.hpp\"\n@@ -932,0 +933,2 @@\n+  template <typename ClosureType>\n+  inline void process_region(ShenandoahHeapRegion* region, ClosureType *cl);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -541,0 +541,27 @@\n+template<typename RememberedSet>\n+template <typename ClosureType>\n+inline void\n+ShenandoahScanRemembered<RememberedSet>::process_region(ShenandoahHeapRegion *region, ClosureType *cl) {\n+  HeapWord *start_of_range = region->bottom();\n+  size_t start_cluster_no = cluster_for_addr(start_of_range);\n+\n+  \/\/ region->end() represents the end of memory spanned by this region, but not all of this\n+  \/\/   memory is eligible to be scanned because some of this memory has not yet been allocated.\n+  \/\/\n+  \/\/ region->top() represents the end of allocated memory within this region.  Any addresses\n+  \/\/   beyond region->top() should not be scanned as that memory does not hold valid objects.\n+  HeapWord *end_of_range = region->top();\n+\n+  \/\/ end_of_range may point to the middle of a cluster because region->top() may be different than region->end.\n+  \/\/ We want to assure that our process_clusters() request spans all relevant clusters.  Note that each cluster\n+  \/\/ processed will avoid processing beyond end_of_range.\n+\n+  size_t num_heapwords = end_of_range - start_of_range;\n+  unsigned int cluster_size = CardTable::card_size_in_words *\n+    ShenandoahCardCluster<ShenandoahDirectCardMarkRememberedSet>::CardsPerCluster;\n+  size_t num_clusters = (size_t) ((num_heapwords - 1 + cluster_size) \/ cluster_size);\n+\n+  \/\/ Remembered set scanner\n+  process_clusters(start_cluster_no, num_clusters, end_of_range, cl);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.inline.hpp","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"}]}