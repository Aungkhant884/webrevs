{"files":[{"patch":"@@ -1,103 +0,0 @@\n-\/\/\n-\/\/ The anticipated benefits of an alternative SATB-based implementation of the remembered set are several fold:\n-\/\/\n-\/\/  1. The representation of remembered set is more concise (1 bit per card) and there is no remembered set maintenance\n-\/\/     required for ShenandoahHeapRegions that correspond to young-gen memory.  Besides requiring less memory overall,\n-\/\/     additional benefits of the more concise remembered set representation are improved cache hit rates and more efficient\n-\/\/     scanning and maintenance of remembered set information by GC threads.\n-\/\/  2. While the mutator overhead is similar between the modified SATB barrier mechanism and direct card marking, the\n-\/\/     SATB mechanism offers the potential of improved accuracy within the remembered set.  This is because direct card\n-\/\/     marking unconditionally marks every old-gen page that is overwritten with a pointer value, even when the new pointer\n-\/\/     value might refer to old-gen memory.  With the modified SATB mechanism, background GC threads process the addresses\n-\/\/     logged within the SATB buffer and mark cards as dirty only if the pointer found at an overwritten old-gen address\n-\/\/     refers to young-gen memory.  There are (at least) two options here:\n-\/\/\n-\/\/      a) Just blindly dirty each card that is overwritten with a pointer value, regardless of the written value, as with\n-\/\/         the implementation of traditional direct card marking.  When this card's memory region is eventually scanned, the\n-\/\/         the implementation of remembered set scanning will clear the page if it no longer holds references to young-gen\n-\/\/         memory.\n-\/\/      b) When the thread-local SATB becomes full, the thread examines the content of each overwritten address and only\n-\/\/         forwards the address to be marked as dirty if the address holds a young-gen reference.  Presumably, the value\n-\/\/         just recently written by this same thread will be available in the L1 cache and fetching this single reference\n-\/\/         \"now\" is more efficient than reading the entire card's memory at remembered set scanning time only to discover\n-\/\/         then that the card represents no references to young-gen memory.\n-\/\/\n-\/\/     Experiments with each approach may help decide between approaches.\n-\/\/\n-\/\/  3. Potentially, the incremental overhead of adding remembered set logging to the existing SATB barrier is lower than\n-\/\/     the incremental overhead of adding an independent and distinct new write barrier for card marking.  This is especially\n-\/\/     true during times that the SATB barrier is already enabled (which might represent 30-50% of execution for GC-intensive\n-\/\/     workloads).  It may even be true during times that the SATB is disabled.  This is because even when the SATB is disabled,\n-\/\/     register allocation is constrained by the reality that SATB will be enabled some of the time, so registers allocated for\n-\/\/     SATB-buffer maintenance will sit idle during times when the SATB barrier is disabled.  In tight loops that write pointer\n-\/\/     values, for example, the SATB implementation might dedicate registers to holding thread-local information associated with\n-\/\/     maintenance of the SATB buffer such as the address of the SATB buffer and the next available buffer slot within this buffer.\n-\/\/     In the traditional card-marking remembered set implementation, an additional register might be dedicated to holding a\n-\/\/     reference to the base of the card table.\n-\/\/\n-\/\/ Note that a ShenandoahBufferWithSATBRememberedSet maintains the remembered set only for memory regions that correspond to\n-\/\/ old-generation memory.  Anticipate that the implementation will use double indirection.\n-\/\/\n-\/\/ To Do:\n-\/\/\n-\/\/  1. Figure out which region an old-gen address belongs to\n-\/\/  2. Find the cluster and card numbers that corresponds to that region\n-\/\/\n-\/\/ Old-gen memory is not necessarily contiguous.  It may be comprised of multiple heap regions.\n-\/\/\n-\/\/ The memory overhead for crossing map and card-table entries is given by the following analysis:\n-\/\/   For each 512-byte card-entry span, we have the following overhead:\n-\/\/    2 bytes for the object_starts map\n-\/\/    1 bit for the card-table entry\n-\/\/  =====\n-\/\/    2 bytes (rounded down) out of 512 bytes is 0.39% bookkeeping overhead\n-\n-\n-\/\/ ShenandoahBufferWithSATBRememberedSet is not implemented correctly in its current form.\n-\/\/\n-\/\/ This class is a placeholder to support a possible future implementation of remembered set that uses a generalization of the\n-\/\/ existing SATB pre-write barrier to maintain remembered set information rather than using unconditional direct card marking in\n-\/\/ a post-write barrier.\n-class ShenandoahBufferWithSATBRememberedSet: public CHeapObj<mtGC> {\n-\n-  \/\/ The current implementation is simply copied from the implementation of class ShenandoahDirectCardMarkRememberedSet\n-\n-  \/\/ Use symbolic constants defined in cardTable.hpp\n-  \/\/  CardTable::card_shift = 9;\n-  \/\/  CardTable::card_size = 512;\n-  \/\/  CardTable::card_size_in_words = 64;\n-\n-  \/\/  CardTable::clean_card_val()\n-  \/\/  CardTable::dirty_card_val()\n-\n-  ShenandoahHeap *_heap;\n-  uint32_t _card_shift;\n-  size_t _card_count;\n-  uint32_t _cluster_count;\n-  HeapWord *_whole_heap_base;\n-  HeapWord *_whole_heap_end;\n-\n-public:\n-  ShenandoahBufferWithSATBRememberedSet(size_t card_count);\n-  ~ShenandoahBufferWithSATBRememberedSet();\n-\n-  uint32_t card_index_for_addr(HeapWord *p);\n-  HeapWord *addr_for_card_index(uint32_t card_index);\n-  bool is_card_dirty(uint32_t card_index);\n-  void mark_card_as_dirty(uint32_t card_index);\n-  void mark_card_as_clean(uint32_t card_index);\n-  void mark_overreach_card_as_dirty(uint32_t card_index);\n-  bool is_card_dirty(HeapWord *p);\n-  void mark_card_as_dirty(HeapWord *p);\n-  void mark_card_as_clean(HeapWord *p);\n-  void mark_overreach_card_as_dirty(void *p);\n-  uint32_t cluster_count();\n-\n-  \/\/ Called by multiple GC threads at start of concurrent mark and\/ evacuation phases.  Each parallel GC thread typically\n-  \/\/ initializes a different subranges of all overreach entries.\n-  void initialize_overreach(uint32_t first_cluster, uint32_t count);\n-\n-  \/\/ Called by GC thread at end of concurrent mark or evacuation phase.\/ Each parallel GC thread typically merges different\n-  \/\/ subranges of all overreach entries.\n-  void merge_overreach(uint32_t first_cluster, uint32_t count);\n-};\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBufferWithSATBRememberedSet.hpp","additions":0,"deletions":103,"binary":false,"changes":103,"status":"deleted"},{"patch":"@@ -1,52 +0,0 @@\n-\n-\/\/ ShenandoahBufferWithSATBRemberedSet is not currently implemented\n-\n-inline uint32_t\n-ShenandoahBufferWithSATBRememberedSet::card_index_for_addr(HeapWord *p) {\n-  return 0;\n-}\n-\n-inline HeapWord *\n-ShenandoahBufferWithSATBRememberedSet::addr_for_card_index(uint32_t card_index) {\n-  return NULL;\n-}\n-\n-inline bool\n-ShenandoahBufferWithSATBRememberedSet::is_card_dirty(uint32_t card_index) {\n-  return false;\n-}\n-\n-inline void\n-ShenandoahBufferWithSATBRememberedSet::mark_card_as_dirty(uint32_t card_index) {\n-}\n-\n-inline void\n-ShenandoahBufferWithSATBRememberedSet::mark_card_as_clean(uint32_t card_index) {\n-}\n-\n-inline void\n-ShenandoahBufferWithSATBRememberedSet::mark_overreach_card_as_dirty(uint32_t card_index) {\n-}\n-\n-inline bool\n-ShenandoahBufferWithSATBRememberedSet::is_card_dirty(HeapWord *p) {\n-  return false;\n-}\n-\n-\n-inline void\n-ShenandoahBufferWithSATBRememberedSet::mark_card_as_dirty(HeapWord *p) {\n-}\n-\n-inline void\n-ShenandoahBufferWithSATBRememberedSet::mark_card_as_clean(HeapWord *p) {\n-}\n-\n-inline void\n-ShenandoahBufferWithSATBRememberedSet::mark_overreach_card_as_dirty(void *p) {\n-}\n-\n-inline uint32_t\n-ShenandoahBufferWithSATBRememberedSet::cluster_count() {\n-  return 0;\n-}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBufferWithSATBRememberedSet.inline.hpp","additions":0,"deletions":52,"binary":false,"changes":52,"status":"deleted"},{"patch":"@@ -1159,1 +1159,0 @@\n-\n@@ -2721,1 +2720,0 @@\n-        \/\/ Kelvin believes (but has not confirmed) the following:\n@@ -2725,6 +2723,9 @@\n-        \/\/   r->get_update_watermark() represents the value that was held in r->top() at the start of\n-        \/\/       evacuation.  During evacuation, new objects may be allocated within this heap region\n-        \/\/       and this will cause r->top() to increase.  But any objects allocated during the evacuation\n-        \/\/       phase do not need to be scanned by update-refs because the to-space invariant is in force\n-        \/\/       during evacuation and this will assure that any objects residing between\n-        \/\/       r->get_update_watermark() and r->top() hold no pointers to from-space.\n+        \/\/   At the start of evacuation, \"update_watermark\" is initalized to represent the value of top().\n+        \/\/       Objects newly allocated during evacuation do not need to be visited during update-refs\n+        \/\/       because the to-space invariant which is in force throughout evacuation assures that no from-space\n+        \/\/       pointer is written to any newly allocated object.  In the case that survivor objects are evacuated\n+        \/\/       into this region during evacuation, the region's watermark is incremented to represent the end of\n+        \/\/       of the memory range known to hold newly evacuated objects.  Note that incrementing watermark to\n+        \/\/       account for objects newly evacuated into the region may result in otherwise unnecessary updating\n+        \/\/       of references contained within newly allocated objects that happen to be located between the\n+        \/\/       initial value of watermark and the updated value of watermark.\n@@ -2741,2 +2742,5 @@\n-        \/\/ Reality is that this code is likely to be replaced with JVM-292 code before we ever get around to\n-        \/\/ sweeping up garbage objects within old-gen memory.\n+        \/\/ Alternative approaches are also under consideration.  For example:\n+        \/\/  1. Coalesce, fill, and register each range of contiguous dead objects so that subsequent updating of\n+        \/\/     references can be done more efficiently.\n+        \/\/  2. Retain the mark bitmap from the most recently completed old GC effort and use this bitmap to allow\n+        \/\/     skipping over objects that were not live as of the most recently completed old-gen GC effort.\n@@ -2744,1 +2748,1 @@\n-        \/\/ Anything beyond update_watermark is not yet allocated or initialized\n+        \/\/ Anything beyond update_watermark does not need to be updated.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":15,"deletions":11,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-#include \"gc\/shenandoah\/shenandoahScanRemembered.hpp\"\n@@ -49,1 +48,0 @@\n-class ShenandoahDirectCardMarkRememberedSet;\n@@ -71,1 +69,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,2 +29,2 @@\n-#include \"gc\/shared\/referenceDiscoverer.hpp\"\n-#include \"gc\/shared\/referencePolicy.hpp\"\n+\/\/ #include \"gc\/shared\/referenceDiscoverer.hpp\"\n+\/\/ #include \"gc\/shared\/referencePolicy.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahReferenceProcessor.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"precompiled.hpp\"\n@@ -86,61 +87,0 @@\n-\n-\n-\/\/ Implementation is not correct.  ShenandoahBufferWithSATBRememberedSet is a placeholder for future planned improvements.\n-ShenandoahBufferWithSATBRememberedSet::ShenandoahBufferWithSATBRememberedSet(size_t card_count)\n-{\n-  _heap = ShenandoahHeap::heap();\n-\n-  _card_count = card_count;\n-  _cluster_count = _card_count \/\n-      ShenandoahCardCluster<ShenandoahBufferWithSATBRememberedSet>::CardsPerCluster;\n-  _card_shift = CardTable::card_shift;\n-\n-  _whole_heap_base = _heap->base();\n-  _whole_heap_end = _whole_heap_base + _card_count *\n-      ShenandoahCardCluster<ShenandoahBufferWithSATBRememberedSet>::CardsPerCluster;\n-}\n-\n-\/\/ Implementation is not correct.  ShenandoahBufferWithSATBRememberedSet is a placeholder for future planned improvements.\n-ShenandoahBufferWithSATBRememberedSet::~ShenandoahBufferWithSATBRememberedSet()\n-{\n-}\n-\n-\/\/ Implementation is not correct.  ShenandoahBufferWithSATBRememberedSet is a placeholder for future planned improvements.\n-void ShenandoahBufferWithSATBRememberedSet::initialize_overreach(\n-    uint32_t first_cluster, uint32_t count) {\n-}\n-\n-\/\/ Implementation is not correct.  ShenandoahBufferWithSATBRememberedSet is a placeholder for future planned improvements.\n-void ShenandoahBufferWithSATBRememberedSet::merge_overreach(\n-    uint32_t first_cluster, uint32_t count) {\n-}\n-\n-#ifdef IMPLEMENT_THIS_OPTIMIZATION_LATER\n-\n-template <class RememberedSet>\n-bool ShenandoahCardCluster<RememberedSet>::has_object(uint32_t card_index) {\n-  return (object_starts[card_index] & ObjectStartsInCardRegion)? true: false;\n-}\n-\n-template <class RememberedSet>\n-uint32_t ShenandoahCardCluster<RememberedSet>::get_first_start(uint32_t card_index)\n-{\n-  assert(object_starts[card_index] & ObjectStartsInCardRegion);\n-  return (((object_starts[card_index] & FirstStartBits) >> FirstStartShift) *\n-          CardWordOffsetMultiplier);\n-}\n-\n-template <class RememberedSet>\n-uint32_t ShenandoahCardCluster<RememberedSet>::get_last_start(uint32_t card_index) {\n-  assert(object_starts[card_index] & ObjectStartsInCardRegion);\n-  return (((object_starts[card_index] & LastStartBits) >> LastStartShift) *\n-          CardWordOffsetMultiplier);\n-}\n-\n-template <class RememberedSet>\n-uint8_t ShenandoahCardCluster<RememberedSet>::get_crossing_object_start(uint32_t card_index) {\n-  assert((object_starts[card_index] & ObjectStartsInCardRegion) == 0);\n-  return object_starts[card_index] * CardWordOffsetMultiplier;\n-}\n-\n-#endif\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.cpp","additions":1,"deletions":61,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -26,0 +26,11 @@\n+\n+#ifndef SHARE_GC_SHENANDOAH_SHENANDOAHSCANREMEMBERED_HPP\n+#define SHARE_GC_SHENANDOAH_SHENANDOAHSCANREMEMBERED_HPP\n+\n+#include <stdint.h>\n+#include \"memory\/iterator.hpp\"\n+#include \"gc\/shenandoah\/shenandoahCardTable.hpp\"\n+#include \"gc\/shared\/referenceDiscoverer.hpp\"\n+#include \"gc\/shared\/referencePolicy.hpp\"\n+#include \"gc\/shenandoah\/shenandoahReferenceProcessor.hpp\"\n+\n@@ -49,3 +60,1 @@\n-\n-\n-\n+\/\/\n@@ -88,7 +97,3 @@\n-\n-\/\/ The typical parallel remembered set scanning effort consists of the\n-\/\/ following steps, all of which are performed during a JVM safetpoint:\n-\/\/\n-\/\/ At the start of a new concurrent mark or concurrent evacuation\n-\/\/ pass, the gang of Shenandoah worker threads collaborate in\n-\/\/ performing the following actions:\n+\/\/ At the start of a new young-gen concurrent mark pass, the gang of\n+\/\/ Shenandoah worker threads collaborate in performing the following\n+\/\/ actions:\n@@ -102,2 +107,2 @@\n-\/\/    (an instance of ShenandoahBufferWithSATBRememberedSet or\n-\/\/     ShenandoahDirectCardMarkRememberedSet)\n+\/\/    (an instance of ShenandoahDirectCardMarkRememberedSet or an instance\n+\/\/     of a to-be-implemented ShenandoahBufferWithSATBRememberedSet)\n@@ -119,1 +124,1 @@\n-\/\/  Next, we repeat the process for invocations of examineCluster:\n+\/\/  Next, we repeat the process for invocations of process_Clusters.\n@@ -129,8 +134,7 @@\n-\/\/                            ShenandoahConcurrentMark *, cluster_no, cluster_count,\n-\/\/                            HeapWord *end_of_range, OopClosure *oops);\n-\/\/        \/\/ Use the same approach for invocations of replaceClusters()\n-\/\/\n-\/\/      Divide up the clusters so that different threads are\n-\/\/      responsible for processing different clusters.  Processing\n-\/\/      cost may vary greatly between clusters for the following\n-\/\/      reasons:\n+\/\/                             ShenandoahConcurrentMark *, cluster_no, cluster_count,\n+\/\/                             HeapWord *end_of_range, OopClosure *oops);\n+\/\/\n+\/\/  For efficiency, divide up the clusters so that different threads\n+\/\/  are responsible for processing different clusters.  Processing costs\n+\/\/  may vary greatly between clusters for the following reasons:\n+\/\/\n@@ -154,8 +158,7 @@\n-\/\/      Though an initial division of labor between marking threads\n-\/\/      may assign equal numbers of clusters to be scanned by each\n-\/\/      thread, it should be expected that some threads will finish\n-\/\/      their assigned work before others.  Therefore, some amount\n-\/\/      of the full remembered set scanning effort should be held\n-\/\/      back and assigned incrementally to the threads that end up with\n-\/\/      excess capacity.  Consider the following strategy for dividing\n-\/\/      labor:\n+\/\/ Though an initial division of labor between marking threads may\n+\/\/ assign equal numbers of clusters to be scanned by each thread, it\n+\/\/ should be expected that some threads will finish their assigned\n+\/\/ work before others.  Therefore, some amount of the full remembered\n+\/\/ set scanning effort should be held back and assigned incrementally\n+\/\/ to the threads that end up with excess capacity.  Consider the\n+\/\/ following strategy for dividing labor:\n@@ -181,1 +184,1 @@\n-\/\/    assigned to a newly idled worker threads, that thread can move\n+\/\/    assigned to a newly idled worker thread, that thread can move\n@@ -202,0 +205,7 @@\n+\/\/ Though remembered set scanning is designed to run concurrently with\n+\/\/ mutator threads, the current implementation of remembered set\n+\/\/ scanning runs in parallel during a GC safepoint.  Furthermore, the\n+\/\/ current implementation of remembered set scanning never clears a\n+\/\/ card once it has been marked.  Since the current implementation\n+\/\/ never clears marked pages, the current implementation does not\n+\/\/ invoke initialize_overreach() or merge_overreach().\n@@ -203,18 +213,2 @@\n-\/\/ To initiate concurrent scanning, insert the above code sequences\n-\/\/ into strong_roots_do and roots_do methods of ShenandoahRootScanner\n-\/\/ (source file shenandoahRootProcessor.cpp) following the\n-\/\/ construction of tc_cl and rm and before the call to\n-\/\/ _serial_roots.oops_do().\n-\/\/\n-\/\/ To initiate concurrent evacuation, insert the above code sequences\n-\/\/ into ShenandoahRootEvacuator::roots_do() before the invocation of\n-\/\/ _serial_roots.oops_do(oops, worker_id).\n-\n-\n-#ifndef SHARE_GC_SHENANDOAH_SHENANDOAHSCANREMEMBERED_HPP\n-#define SHARE_GC_SHENANDOAH_SHENANDOAHSCANREMEMBERED_HPP\n-\n-#include <stdint.h>\n-#include \"memory\/iterator.hpp\"\n-#include \"gc\/shenandoah\/shenandoahCardTable.hpp\"\n-#include \"gc\/shenandoah\/shenandoahReferenceProcessor.hpp\"\n+\/\/ These limitations will be addressed in future enhancements to the\n+\/\/ existing implementation.\n@@ -227,2 +221,0 @@\n-#include \"gc\/shenandoah\/shenandoahBufferWithSATBRememberedSet.hpp\"\n-\n@@ -462,1 +454,1 @@\n-\/\/     ShenandoahDirectCardMarkRememberedSet, or\n+\/\/     ShenandoahDirectCardMarkRememberedSet, or a to-be-implemented\n@@ -785,4 +777,0 @@\n-  \/\/ What card number corresponds to old-gen heap addresss p.  (If p\n-  \/\/ does not refer to old-gen memory, the returned value is undefined.)\n-  uint32_t cardNoForAddr(HeapWord *p);\n-\n@@ -871,1 +859,2 @@\n-  \/\/ or, when fully implemented:\n+  \/\/ or, after the planned implementation of\n+  \/\/ ShenandoahBufferWithSATBRememberedSet has been completed:\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.hpp","additions":45,"deletions":56,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -37,2 +37,0 @@\n-#include \"gc\/shenandoah\/shenandoahBufferWithSATBRememberedSet.inline.hpp\"\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.inline.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"}]}