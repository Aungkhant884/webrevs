{"files":[{"patch":"@@ -431,0 +431,16 @@\n+\n+\/\/ unlike assert_heaplocked_or_safepoint(), this does not require current thread in safepoint to be a VM-thread\n+void ShenandoahAsserts::assert_heaplocked_or_fullgc_safepoint(const char* file, int line) {\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+\n+  if (heap->lock()->owned_by_self()) {\n+    return;\n+  }\n+\n+  if (ShenandoahSafepoint::is_at_shenandoah_safepoint()) {\n+    return;\n+  }\n+\n+  ShenandoahMessageBuffer msg(\"Heap lock must be owned by current thread, or be at safepoint\");\n+  report_vm_error(file, line, msg.buffer());\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAsserts.cpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -75,0 +75,1 @@\n+  static void assert_heaplocked_or_fullgc_safepoint(const char* file, int line);\n@@ -166,0 +167,3 @@\n+\n+#define shenandoah_assert_heaplocked_or_fullgc_safepoint() \\\n+                    ShenandoahAsserts::assert_heaplocked_or_fullgc_safepoint(__FILE__, __LINE__)\n@@ -216,0 +220,1 @@\n+#define shenandoah_assert_heaplocked_or_fullgc_safepoint()\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAsserts.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -356,0 +356,1 @@\n+  _affiliations = NEW_C_HEAP_ARRAY(uint8_t, _num_regions, mtGC);\n@@ -361,0 +362,1 @@\n+\n@@ -372,0 +374,2 @@\n+\n+      _affiliations[i] = ShenandoahRegionAffiliation::FREE;\n@@ -512,0 +516,1 @@\n+  _affiliations(NULL),\n@@ -769,29 +774,0 @@\n-bool ShenandoahHeap::is_in(const void* p) const {\n-  HeapWord* heap_base = (HeapWord*) base();\n-  HeapWord* last_region_end = heap_base + ShenandoahHeapRegion::region_size_words() * num_regions();\n-  return p >= heap_base && p < last_region_end;\n-}\n-\n-bool ShenandoahHeap::is_in_young(const void* p) const {\n-  return is_in(p) && heap_region_containing(p)->affiliation() == ShenandoahRegionAffiliation::YOUNG_GENERATION;\n-}\n-\n-bool ShenandoahHeap::is_in_old(const void* p) const {\n-  return is_in(p) && heap_region_containing(p)->affiliation() == ShenandoahRegionAffiliation::OLD_GENERATION;\n-}\n-\n-bool ShenandoahHeap::is_in_active_generation(oop obj) const {\n-  if (!mode()->is_generational()) {\n-    \/\/ everything is the same single generation\n-    return true;\n-  }\n-\n-  if (active_generation() == NULL) {\n-    \/\/ no collection is happening, only expect this to be called\n-    \/\/ when concurrent processing is active, but that could change\n-    return false;\n-  }\n-\n-  return active_generation()->contains(obj);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":5,"deletions":29,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -272,0 +272,1 @@\n+  uint8_t* _affiliations;       \/\/ Holds array of enum ShenandoahRegionAffiliation, including FREE status in non-generational mode\n@@ -603,0 +604,3 @@\n+  inline void assert_lock_for_affiliation(ShenandoahRegionAffiliation orig_affiliation,\n+                                          ShenandoahRegionAffiliation new_affiliation);\n+\n@@ -617,1 +621,1 @@\n-  bool is_in(const void* p) const;\n+  inline bool is_in(const void* p) const;\n@@ -619,3 +623,3 @@\n-  bool is_in_active_generation(oop obj) const;\n-  bool is_in_young(const void* p) const;\n-  bool is_in_old(const void* p) const;\n+  inline bool is_in_active_generation(oop obj) const;\n+  inline bool is_in_young(const void* p) const;\n+  inline bool is_in_old(const void* p) const;\n@@ -624,0 +628,6 @@\n+  inline ShenandoahRegionAffiliation region_affiliation(const ShenandoahHeapRegion* r);\n+  inline void set_affiliation(ShenandoahHeapRegion* r, ShenandoahRegionAffiliation new_affiliation);\n+\n+  inline ShenandoahRegionAffiliation region_affiliation(size_t index);\n+  inline void set_affiliation(size_t index, ShenandoahRegionAffiliation new_affiliation);\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -553,0 +553,48 @@\n+bool ShenandoahHeap::is_in(const void* p) const {\n+  HeapWord* heap_base = (HeapWord*) base();\n+  HeapWord* last_region_end = heap_base + ShenandoahHeapRegion::region_size_words() * num_regions();\n+  return p >= heap_base && p < last_region_end;\n+}\n+\n+inline bool ShenandoahHeap::is_in_active_generation(oop obj) const {\n+  if (!mode()->is_generational()) {\n+    \/\/ everything is the same single generation\n+    return true;\n+  }\n+\n+  if (active_generation() == NULL) {\n+    \/\/ no collection is happening, only expect this to be called\n+    \/\/ when concurrent processing is active, but that could change\n+    return false;\n+  }\n+\n+  assert(is_in(obj), \"only check if is in active generation for objects (\" PTR_FORMAT \") in heap\", p2i(obj));\n+  assert((active_generation() == (ShenandoahGeneration*) old_generation()) ||\n+         (active_generation() == (ShenandoahGeneration*) young_generation()) ||\n+         (active_generation() == global_generation()), \"Active generation must be old, young, or global\");\n+\n+  size_t index = heap_region_containing(obj)->index();\n+  switch (_affiliations[index]) {\n+  case ShenandoahRegionAffiliation::FREE:\n+    \/\/ Free regions are in Old, Young, Global\n+    return true;\n+  case ShenandoahRegionAffiliation::YOUNG_GENERATION:\n+    \/\/ Young regions are in young_generation and global_generation, not in old_generation\n+    return (active_generation() != (ShenandoahGeneration*) old_generation());\n+  case ShenandoahRegionAffiliation::OLD_GENERATION:\n+    \/\/ Old regions are in old_generation and global_generation, not in young_generation\n+    return (active_generation() != (ShenandoahGeneration*) young_generation());\n+  default:\n+    assert(false, \"Bad affiliation (%d) for region \" SIZE_FORMAT, _affiliations[index], index);\n+    return false;\n+  }\n+}\n+\n+inline bool ShenandoahHeap::is_in_young(const void* p) const {\n+  return is_in(p) && (_affiliations[heap_region_index_containing(p)] == ShenandoahRegionAffiliation::YOUNG_GENERATION);\n+}\n+\n+inline bool ShenandoahHeap::is_in_old(const void* p) const {\n+  return is_in(p) && (_affiliations[heap_region_index_containing(p)] == ShenandoahRegionAffiliation::OLD_GENERATION);\n+}\n+\n@@ -557,0 +605,44 @@\n+inline ShenandoahRegionAffiliation ShenandoahHeap::region_affiliation(const ShenandoahHeapRegion *r) {\n+  return (ShenandoahRegionAffiliation) _affiliations[r->index()];\n+}\n+\n+inline void ShenandoahHeap::assert_lock_for_affiliation(ShenandoahRegionAffiliation orig_affiliation,\n+                                                        ShenandoahRegionAffiliation new_affiliation) {\n+  \/\/ A lock is required when changing from FREE to NON-FREE.  Though it may be possible to elide the lock when\n+  \/\/ transitioning from in-use to FREE, the current implementation uses a lock for this transition.  A lock is\n+  \/\/ not required to change from YOUNG to OLD (i.e. when promoting humongous region).\n+  \/\/\n+  \/\/         new_affiliation is:     FREE   YOUNG   OLD\n+  \/\/  orig_affiliation is:  FREE      X       L      L\n+  \/\/                       YOUNG      L       X\n+  \/\/                         OLD      L       X      X\n+  \/\/  X means state transition won't happen (so don't care)\n+  \/\/  L means lock should be held\n+  \/\/  Blank means no lock required because affiliation visibility will not be required until subsequent safepoint\n+  \/\/\n+  \/\/ Note: during full GC, all transitions between states are possible.  During Full GC, we should be in a safepoint.\n+\n+  if ((orig_affiliation == ShenandoahRegionAffiliation::FREE) || (new_affiliation == ShenandoahRegionAffiliation::FREE)) {\n+    extern bool _is_at_shenandoah_safepoint();\n+    shenandoah_assert_heaplocked_or_fullgc_safepoint();\n+  }\n+}\n+\n+inline void ShenandoahHeap::set_affiliation(ShenandoahHeapRegion* r, ShenandoahRegionAffiliation new_affiliation) {\n+#ifdef ASSERT\n+  assert_lock_for_affiliation(region_affiliation(r), new_affiliation);\n+#endif\n+  _affiliations[r->index()] = (uint8_t) new_affiliation;\n+}\n+\n+inline ShenandoahRegionAffiliation ShenandoahHeap::region_affiliation(size_t index) {\n+  return (ShenandoahRegionAffiliation) _affiliations[index];\n+}\n+\n+inline void ShenandoahHeap::set_affiliation(size_t index, ShenandoahRegionAffiliation new_affiliation) {\n+#ifdef ASSERT\n+  assert_lock_for_affiliation(region_affiliation(index), new_affiliation);\n+#endif\n+  _affiliations[index] = (uint8_t) new_affiliation;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.inline.hpp","additions":92,"deletions":0,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -79,1 +79,0 @@\n-  _affiliation(FREE),\n@@ -116,1 +115,2 @@\n- switch (_state) {\n+  shenandoah_assert_heaplocked();\n+  switch (_state) {\n@@ -410,1 +410,1 @@\n-  switch (_affiliation) {\n+  switch (ShenandoahHeap::heap()->region_affiliation(this)) {\n@@ -665,0 +665,1 @@\n+  shenandoah_assert_heaplocked();\n@@ -936,0 +937,1 @@\n+  ShenandoahRegionAffiliation region_affiliation = heap->region_affiliation(this);\n@@ -940,1 +942,1 @@\n-                  index(), affiliation_name(_affiliation), affiliation_name(new_affiliation),\n+                  index(), affiliation_name(region_affiliation), affiliation_name(new_affiliation),\n@@ -957,1 +959,1 @@\n-  if (_affiliation == new_affiliation) {\n+  if (region_affiliation == new_affiliation) {\n@@ -962,1 +964,1 @@\n-    _affiliation = new_affiliation;\n+    heap->set_affiliation(this, new_affiliation);\n@@ -967,1 +969,1 @@\n-    index(), affiliation_name(_affiliation), affiliation_name(new_affiliation));\n+    index(), affiliation_name(region_affiliation), affiliation_name(new_affiliation));\n@@ -969,1 +971,1 @@\n-  if (_affiliation == ShenandoahRegionAffiliation::YOUNG_GENERATION) {\n+  if (region_affiliation == ShenandoahRegionAffiliation::YOUNG_GENERATION) {\n@@ -971,1 +973,1 @@\n-  } else if (_affiliation == ShenandoahRegionAffiliation::OLD_GENERATION) {\n+  } else if (region_affiliation == ShenandoahRegionAffiliation::OLD_GENERATION) {\n@@ -990,1 +992,1 @@\n-  _affiliation = new_affiliation;\n+  heap->set_affiliation(this, new_affiliation);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.cpp","additions":12,"deletions":10,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -202,2 +202,2 @@\n-  bool is_young()                  const { return _affiliation == YOUNG_GENERATION; }\n-  bool is_old()                    const { return _affiliation == OLD_GENERATION; }\n+  inline bool is_young() const;\n+  inline bool is_old() const;\n@@ -260,1 +260,0 @@\n-  ShenandoahRegionAffiliation _affiliation;\n@@ -444,3 +443,1 @@\n-  ShenandoahRegionAffiliation affiliation() const {\n-    return _affiliation;\n-  }\n+  inline ShenandoahRegionAffiliation affiliation() const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.hpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -179,0 +179,4 @@\n+inline ShenandoahRegionAffiliation ShenandoahHeapRegion::affiliation() const {\n+  return ShenandoahHeap::heap()->region_affiliation(this);\n+}\n+\n@@ -191,0 +195,8 @@\n+inline bool ShenandoahHeapRegion::is_young() const {\n+  return ShenandoahHeap::heap()->region_affiliation(this) == YOUNG_GENERATION;\n+}\n+\n+inline bool ShenandoahHeapRegion::is_old() const {\n+  return ShenandoahHeap::heap()->region_affiliation(this) == OLD_GENERATION;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.inline.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"}]}