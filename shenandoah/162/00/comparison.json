{"files":[{"patch":"@@ -24,1 +24,0 @@\n-\n@@ -32,1 +31,1 @@\n-#include \"gc\/shenandoah\/shenandoahLogFileOutput.hpp\"\n+#include \"logging\/logStream.hpp\"\n@@ -39,1 +38,1 @@\n-  _last_sample_millis(0), _log_file(nullptr)\n+  _last_sample_millis(0)\n@@ -78,5 +77,0 @@\n-    if (ShenandoahLogRegionSampling) {\n-      _log_file = new ShenandoahLogFileOutput(ShenandoahRegionSamplingFile, _timestamp->get_value());\n-      _log_file->set_option(ShenandoahLogFileCount, ShenandoahLogFileSize);\n-      _log_file->initialize(tty);\n-    }\n@@ -88,1 +82,22 @@\n-  if (_log_file != NULL) FREE_C_HEAP_OBJ(_log_file);\n+}\n+\n+void ShenandoahHeapRegionCounters::write_snapshot(PerfLongVariable** regions,\n+                                             PerfLongVariable* ts,\n+                                             PerfLongVariable* status,\n+                                             size_t num_regions,\n+                                             size_t region_size, size_t protocol_version) {\n+    LogTarget(Debug, gc, region) lt;\n+    if (lt.is_enabled()) {\n+        ResourceMark rm;\n+        LogStream ls(lt);\n+\n+        ls.print_cr(\"%li %li %lu %lu %lu\",\n+                    ts->get_value(), status->get_value(), num_regions, region_size, protocol_version);\n+        if (num_regions > 0) {\n+            ls.print(\"%li\", regions[0]->get_value());\n+        }\n+        for (uint i = 1; i < num_regions; ++i) {\n+            ls.print(\" %li\", regions[i]->get_value());\n+        }\n+        ls.cr();\n+    }\n@@ -122,3 +137,1 @@\n-        if (ShenandoahLogRegionSampling && _log_file != NULL) {\n-          _log_file->write_snapshot(_regions_data, _timestamp, _status, num_regions, rs >> 10, VERSION_NUMBER);\n-        }\n+        write_snapshot(_regions_data, _timestamp, _status, num_regions, rs >> 10, VERSION_NUMBER);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegionCounters.cpp","additions":25,"deletions":12,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"gc\/shenandoah\/shenandoahLogFileOutput.hpp\"\n@@ -93,0 +92,6 @@\n+  void write_snapshot(PerfLongVariable** regions,\n+                      PerfLongVariable* ts,\n+                      PerfLongVariable* status,\n+                      size_t num_regions,\n+                      size_t region_size, size_t protocolVersion);\n+\n@@ -94,1 +99,0 @@\n-  ShenandoahLogFileOutput* _log_file;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegionCounters.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1,408 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Amazon.com, Inc. All rights reserved.\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"jvm.h\"\n-#include \"logging\/logConfiguration.hpp\"\n-#include \"logging\/logFileStreamOutput.hpp\"\n-#include \"runtime\/arguments.hpp\"\n-#include \"runtime\/os.inline.hpp\"\n-#include \"runtime\/perfData.inline.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-#include \"utilities\/defaultStream.hpp\"\n-#include \"utilities\/formatBuffer.hpp\"\n-\n-#include \"gc\/shenandoah\/shenandoahLogFileOutput.hpp\"\n-\n-const char* const ShenandoahLogFileOutput::Prefix = \"file=\";\n-const char* const ShenandoahLogFileOutput::FileOpenMode = \"w+\";\n-const char* const ShenandoahLogFileOutput::PidFilenamePlaceholder = \"%p\";\n-const char* const ShenandoahLogFileOutput::TimestampFilenamePlaceholder = \"%t\";\n-const char* const ShenandoahLogFileOutput::TimestampFormat = \"%Y-%m-%d_%H-%M-%S\";\n-char        ShenandoahLogFileOutput::_pid_str[PidBufferSize];\n-char        ShenandoahLogFileOutput::_vm_start_time_str[StartTimeBufferSize];\n-\n-#define WRITE_LOG_WITH_RESULT_CHECK(op, total)                \\\n-{                                                             \\\n-  int result = op;                                            \\\n-  if (result < 0) {                                           \\\n-    if (!_write_error_is_shown) {                             \\\n-      jio_fprintf(defaultStream::error_stream(),              \\\n-                  \"Could not write log: %s\\n\", name());       \\\n-      jio_fprintf(_stream, \"\\nERROR: Could not write log\\n\"); \\\n-      _write_error_is_shown = true;                           \\\n-      return -1;                                              \\\n-    }                                                         \\\n-  }                                                           \\\n-  total += result;                                            \\\n-}\n-\n-static uint number_of_digits(uint number) {\n-    return number < 10 ? 1 : (number < 100 ? 2 : 3);\n-}\n-\n-static bool is_regular_file(const char* filename) {\n-    struct stat st;\n-    int ret = os::stat(filename, &st);\n-    if (ret != 0) {\n-        return false;\n-    }\n-    return (st.st_mode & S_IFMT) == S_IFREG;\n-}\n-\n-static bool is_fifo_file(const char* filename) {\n-    struct stat st;\n-    int ret = os::stat(filename, &st);\n-    if (ret != 0) {\n-        return false;\n-    }\n-    return S_ISFIFO(st.st_mode);\n-}\n-\n-\/\/ Try to find the next number that should be used for file rotation.\n-\/\/ Return UINT_MAX on error.\n-static uint next_file_number(const char* filename,\n-                             uint number_of_digits,\n-                             uint filecount,\n-                             outputStream* errstream) {\n-    bool found = false;\n-    uint next_num = 0;\n-\n-    \/\/ len is filename + dot + digits + null char\n-    size_t len = strlen(filename) + number_of_digits + 2;\n-    char* archive_name = NEW_C_HEAP_ARRAY(char, len, mtLogging);\n-    char* oldest_name = NEW_C_HEAP_ARRAY(char, len, mtLogging);\n-\n-    for (uint i = 0; i < filecount; i++) {\n-        int ret = jio_snprintf(archive_name, len, \"%s.%0*u\",\n-                               filename, number_of_digits, i);\n-        assert(ret > 0 && static_cast<size_t>(ret) == len - 1,\n-               \"incorrect buffer length calculation\");\n-\n-        if (os::file_exists(archive_name) && !is_regular_file(archive_name)) {\n-            \/\/ We've encountered something that's not a regular file among the\n-            \/\/ possible file rotation targets. Fail immediately to prevent\n-            \/\/ problems later.\n-            errstream->print_cr(\"Possible rotation target file '%s' already exists \"\n-                                \"but is not a regular file.\", archive_name);\n-            next_num = UINT_MAX;\n-            break;\n-        }\n-\n-        \/\/ Stop looking if we find an unused file name\n-        if (!os::file_exists(archive_name)) {\n-            next_num = i;\n-            found = true;\n-            break;\n-        }\n-\n-        \/\/ Keep track of oldest existing log file\n-        if (!found\n-            || os::compare_file_modified_times(oldest_name, archive_name) > 0) {\n-            strcpy(oldest_name, archive_name);\n-            next_num = i;\n-            found = true;\n-        }\n-    }\n-\n-    FREE_C_HEAP_ARRAY(char, oldest_name);\n-    FREE_C_HEAP_ARRAY(char, archive_name);\n-    return next_num;\n-}\n-void ShenandoahLogFileOutput::set_option(uint file_count, size_t rotation_size) {\n-    if (file_count < MaxRotationFileCount) {\n-        _file_count = file_count;\n-    }\n-    _rotate_size = rotation_size;\n-}\n-\n-ShenandoahLogFileOutput::ShenandoahLogFileOutput(const char* name, jlong vm_start_time)\n-  : _name(os::strdup_check_oom(name, mtLogging)), _file_name(NULL), _archive_name(NULL), _stream(NULL), _current_file(0), _file_count(DefaultFileCount), _is_default_file_count(true), _archive_name_len(0),\n-     _rotate_size(DefaultFileSize),  _current_size(0), _rotation_semaphore(1) {\n-  set_file_name_parameters(vm_start_time);\n-  _file_name = make_file_name(name, _pid_str, _vm_start_time_str);\n-}\n-\n-ShenandoahLogFileOutput::~ShenandoahLogFileOutput() {\n-  if (_stream != NULL) {\n-    if (fclose(_stream) != 0) {\n-      jio_fprintf(defaultStream::error_stream(), \"Could not close log file '%s' (%s).\\n\",\n-                  _file_name, os::strerror(errno));\n-    }\n-  }\n-  os::free(_archive_name);\n-  os::free(_file_name);\n-  os::free(const_cast<char*>(_name));\n-}\n-\n-bool ShenandoahLogFileOutput::flush() {\n-  bool result = true;\n-  if (fflush(_stream) != 0) {\n-    if (!_write_error_is_shown) {\n-      jio_fprintf(defaultStream::error_stream(),\n-                  \"Could not flush log: %s (%s (%d))\\n\", name(), os::strerror(errno), errno);\n-      jio_fprintf(_stream, \"\\nERROR: Could not flush log (%d)\\n\", errno);\n-      _write_error_is_shown = true;\n-    }\n-    result = false;\n-  }\n-  return result;\n-}\n-\n-void ShenandoahLogFileOutput::initialize(outputStream* errstream) {\n-\n-    bool file_exist = os::file_exists(_file_name);\n-    if (file_exist && _is_default_file_count && is_fifo_file(_file_name)) {\n-        _file_count = 0; \/\/ Prevent file rotation for fifo's such as named pipes.\n-    }\n-\n-    if (_file_count > 0) {\n-        \/\/ compute digits with filecount - 1 since numbers will start from 0\n-        _file_count_max_digits = number_of_digits(_file_count - 1);\n-        _archive_name_len = 2 + strlen(_file_name) + _file_count_max_digits;\n-        _archive_name = NEW_C_HEAP_ARRAY(char, _archive_name_len, mtLogging);\n-        _archive_name[0] = 0;\n-    }\n-\n-    if (_file_count > 0 && file_exist) {\n-        if (!is_regular_file(_file_name)) {\n-            vm_exit_during_initialization(err_msg(\"Unable to log to file %s with log file rotation: \"\n-                                                   \"%s is not a regular file\", _file_name, _file_name));\n-        }\n-        _current_file = next_file_number(_file_name,\n-                                         _file_count_max_digits,\n-                                         _file_count,\n-                                         errstream);\n-        if (_current_file == UINT_MAX) {\n-            vm_exit_during_initialization(\"Current file reaches the maximum for integer. Unable to initialize the log output.\");\n-        }\n-        archive();\n-        increment_file_count();\n-    }\n-    _stream = os::fopen(_file_name, ShenandoahLogFileOutput::FileOpenMode);\n-    if (_stream == NULL) {\n-        vm_exit_during_initialization(err_msg(\"Error opening log file '%s': %s\",\n-                                              _file_name, os::strerror(errno)));\n-    }\n-    if (_file_count == 0 && is_regular_file(_file_name)) {\n-        os::ftruncate(os::get_fileno(_stream), 0);\n-    }\n-}\n-\n-class ShenandoahRotationLocker : public StackObj {\n-    Semaphore& _sem;\n-\n-public:\n-    ShenandoahRotationLocker(Semaphore& sem) : _sem(sem) {\n-        sem.wait();\n-    }\n-\n-    ~ShenandoahRotationLocker() {\n-        _sem.signal();\n-    }\n-};\n-\n-int ShenandoahLogFileOutput::write_snapshot(PerfLongVariable** regions,\n-                                            PerfLongVariable* ts,\n-                                            PerfLongVariable* status,\n-                                            size_t num_regions,\n-                                            size_t region_size, size_t protocol_version) {\n-  if (_stream == NULL) {\n-      \/\/ An error has occurred with this output, avoid writing to it.\n-      return 0;\n-  }\n-  int written = 0;\n-\n-  FileLocker flocker(_stream);\n-  WRITE_LOG_WITH_RESULT_CHECK(jio_fprintf(_stream, \"%lli %lli %u %u %u\\n\",\n-                                          ts->get_value(),\n-                                          status->get_value(),\n-                                          num_regions,\n-                                          region_size, protocol_version), written);\n-  _current_size += written;\n-  if (num_regions > 0) {\n-    WRITE_LOG_WITH_RESULT_CHECK(jio_fprintf(_stream, \"%lli\", regions[0]->get_value()), written);\n-    _current_size += written;\n-  }\n-  for (uint i = 1; i < num_regions; ++i) {\n-    WRITE_LOG_WITH_RESULT_CHECK(jio_fprintf(_stream, \" %lli\", regions[i]->get_value()), written);\n-    _current_size += written;\n-  }\n-  jio_fprintf(_stream, \"\\n\", written);\n-  _current_size += written;\n-  written = flush() ? written : -1;\n-  if (written > 0) {\n-      _current_size += written;\n-\n-      if (should_rotate()) {\n-          rotate();\n-      }\n-  }\n-\n-  return written;\n-}\n-\n-void ShenandoahLogFileOutput::archive() {\n-    assert(_archive_name != NULL && _archive_name_len > 0, \"Rotation must be configured before using this function.\");\n-    int ret = jio_snprintf(_archive_name, _archive_name_len, \"%s.%0*u\",\n-                           _file_name, _file_count_max_digits, _current_file);\n-    assert(ret >= 0, \"Buffer should always be large enough\");\n-\n-    \/\/ Attempt to remove possibly existing archived log file before we rename.\n-    \/\/ Don't care if it fails, we really only care about the rename that follows.\n-    remove(_archive_name);\n-\n-    \/\/ Rename the file from ex hotspot.log to hotspot.log.2\n-    if (rename(_file_name, _archive_name) == -1) {\n-        jio_fprintf(defaultStream::error_stream(), \"Could not rename log file '%s' to '%s' (%s).\\n\",\n-                    _file_name, _archive_name, os::strerror(errno));\n-    }\n-}\n-\n-void ShenandoahLogFileOutput::force_rotate() {\n-    if (_file_count == 0) {\n-        \/\/ Rotation not possible\n-        return;\n-    }\n-\n-    ShenandoahRotationLocker lock(_rotation_semaphore);\n-    rotate();\n-}\n-\n-void ShenandoahLogFileOutput::rotate() {\n-    if (fclose(_stream)) {\n-        jio_fprintf(defaultStream::error_stream(), \"Error closing file '%s' during log rotation (%s).\\n\",\n-                    _file_name, os::strerror(errno));\n-    }\n-\n-    \/\/ Archive the current log file\n-    archive();\n-\n-    \/\/ Open the active log file using the same stream as before\n-    _stream = os::fopen(_file_name, FileOpenMode);\n-    if (_stream == NULL) {\n-        jio_fprintf(defaultStream::error_stream(), \"Could not reopen file '%s' during log rotation (%s).\\n\",\n-                    _file_name, os::strerror(errno));\n-        return;\n-    }\n-\n-    \/\/ Reset accumulated size, increase current file counter, and check for file count wrap-around.\n-    _current_size = 0;\n-    increment_file_count();\n-}\n-\n-void ShenandoahLogFileOutput::set_file_name_parameters(jlong vm_start_time) {\n-  int res = jio_snprintf(_pid_str, sizeof(_pid_str), \"%d\", os::current_process_id());\n-  assert(res > 0, \"PID buffer too small\");\n-\n-  struct tm local_time;\n-  time_t utc_time = vm_start_time \/ 1000;\n-  os::localtime_pd(&utc_time, &local_time);\n-  res = (int)strftime(_vm_start_time_str, sizeof(_vm_start_time_str), TimestampFormat, &local_time);\n-  assert(res > 0, \"VM start time buffer too small.\");\n-}\n-\n-char* ShenandoahLogFileOutput::make_file_name(const char* file_name,\n-                                              const char* pid_string,\n-                                              const char* timestamp_string) {\n-  char* result = NULL;\n-\n-  \/\/ Lets start finding out if we have any %d and\/or %t in the name.\n-  \/\/ We will only replace the first occurrence of any placeholder\n-  const char* pid = strstr(file_name, PidFilenamePlaceholder);\n-  const char* timestamp = strstr(file_name, TimestampFilenamePlaceholder);\n-\n-  if (pid == NULL && timestamp == NULL) {\n-    \/\/ We found no place-holders, return the simple filename\n-    return os::strdup_check_oom(file_name, mtLogging);\n-  }\n-\n-  \/\/ At least one of the place-holders were found in the file_name\n-  const char* first = \"\";\n-  size_t first_pos = SIZE_MAX;\n-  size_t first_replace_len = 0;\n-\n-  const char* second = \"\";\n-  size_t second_pos = SIZE_MAX;\n-  size_t second_replace_len = 0;\n-\n-  \/\/ If we found a %p, then setup our variables accordingly\n-  if (pid != NULL) {\n-    if (timestamp == NULL || pid < timestamp) {\n-      first = pid_string;\n-      first_pos = pid - file_name;\n-      first_replace_len = strlen(PidFilenamePlaceholder);\n-    } else {\n-      second = pid_string;\n-      second_pos = pid - file_name;\n-      second_replace_len = strlen(PidFilenamePlaceholder);\n-    }\n-  }\n-\n-  if (timestamp != NULL) {\n-    if (pid == NULL || timestamp < pid) {\n-      first = timestamp_string;\n-      first_pos = timestamp - file_name;\n-      first_replace_len = strlen(TimestampFilenamePlaceholder);\n-    } else {\n-      second = timestamp_string;\n-      second_pos = timestamp - file_name;\n-      second_replace_len = strlen(TimestampFilenamePlaceholder);\n-    }\n-  }\n-\n-  size_t first_len = strlen(first);\n-  size_t second_len = strlen(second);\n-\n-  \/\/ Allocate the new buffer, size it to hold all we want to put in there +1.\n-  size_t result_len =  strlen(file_name) + first_len - first_replace_len + second_len - second_replace_len;\n-  result = NEW_C_HEAP_ARRAY(char, result_len + 1, mtLogging);\n-\n-  \/\/ Assemble the strings\n-  size_t file_name_pos = 0;\n-  size_t i = 0;\n-  while (i < result_len) {\n-    if (file_name_pos == first_pos) {\n-      \/\/ We are in the range of the first placeholder\n-      strcpy(result + i, first);\n-      \/\/ Bump output buffer position with length of replacing string\n-      i += first_len;\n-      \/\/ Bump source buffer position to skip placeholder\n-      file_name_pos += first_replace_len;\n-    } else if (file_name_pos == second_pos) {\n-      \/\/ We are in the range of the second placeholder\n-      strcpy(result + i, second);\n-      i += second_len;\n-      file_name_pos += second_replace_len;\n-    } else {\n-      \/\/ Else, copy char by char of the original file\n-      result[i] = file_name[file_name_pos++];\n-      i++;\n-    }\n-  }\n-  \/\/ Add terminating char\n-  result[result_len] = '\\0';\n-  return result;\n-}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahLogFileOutput.cpp","additions":0,"deletions":408,"binary":false,"changes":408,"status":"deleted"},{"patch":"@@ -1,110 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Amazon.com, Inc. All rights reserved.\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_SHENANDOAH_SHENANDOAHLOGFILEOUTPUT_HPP\n-#define SHARE_GC_SHENANDOAH_SHENANDOAHLOGFILEOUTPUT_HPP\n-\n-#include \"logging\/logFileStreamOutput.hpp\"\n-#include \"logging\/logFileOutput.hpp\"\n-#include \"runtime\/semaphore.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-#include \"runtime\/perfData.inline.hpp\"\n-\n-\/\/ Log file output to capture Shenandoah GC data.\n-\n-class ShenandoahLogFileOutput : public CHeapObj<mtClass> {\n-private:\n-    static const char* const FileOpenMode;\n-    static const char* const PidFilenamePlaceholder;\n-    static const char* const TimestampFilenamePlaceholder;\n-    static const char* const TimestampFormat;\n-    static const size_t DefaultFileCount = 5;\n-    static const size_t DefaultFileSize = 20 * M;\n-    static const size_t StartTimeBufferSize = 20;\n-    static const size_t PidBufferSize = 21;\n-    static const uint   MaxRotationFileCount = 1000;\n-    static char         _pid_str[PidBufferSize];\n-    static char         _vm_start_time_str[StartTimeBufferSize];\n-\n-    const char* _name;\n-    char* _file_name;\n-    char* _archive_name;\n-    FILE* _stream;\n-\n-    uint  _current_file;\n-    uint  _file_count;\n-    uint  _file_count_max_digits;\n-    bool  _is_default_file_count;\n-\n-    size_t  _archive_name_len;\n-    size_t  _rotate_size;\n-    size_t  _current_size;\n-\n-    bool _write_error_is_shown;\n-\n-    Semaphore _rotation_semaphore;\n-\n-    bool parse_options(const char* options, outputStream* errstream);\n-    void archive();\n-    void rotate();\n-    char *make_file_name(const char* file_name, const char* pid_string, const char* timestamp_string);\n-\n-    bool should_rotate() {\n-        return _file_count > 0 && _rotate_size > 0 && _current_size >= _rotate_size;\n-    }\n-\n-    void increment_file_count() {\n-        _current_file++;\n-        if (_current_file == _file_count) {\n-            _current_file = 0;\n-        }\n-    }\n-\n-    bool flush();\n-\n-public:\n-    ShenandoahLogFileOutput(const char *name, jlong vm_start_time);\n-    ~ShenandoahLogFileOutput();\n-\n-    void initialize(outputStream* errstream);\n-    void force_rotate();\n-    void set_option(uint file_count, size_t rotation_size);\n-\n-    int write_snapshot(PerfLongVariable** regions,\n-                       PerfLongVariable* ts,\n-                       PerfLongVariable* status,\n-                       size_t num_regions,\n-                       size_t region_size, size_t protocolVersion);\n-\n-    const char* name() const {\n-      return _name;\n-    }\n-\n-    const char* cur_log_file_name();\n-    static const char* const Prefix;\n-    static void set_file_name_parameters(jlong start_time);\n-};\n-#endif \/\/SHARE_GC_SHENANDOAH_SHENANDOAHLOGFILEOUTPUT_HPP\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahLogFileOutput.hpp","additions":0,"deletions":110,"binary":false,"changes":110,"status":"deleted"},{"patch":"@@ -244,3 +244,0 @@\n-  product(bool, ShenandoahLogRegionSampling, false,                         \\\n-          \"Save region sampling stream to ShenandoahRegionSamplingFile\")    \\\n-                                                                            \\\n@@ -253,10 +250,0 @@\n-  product(uintx, ShenandoahLogFileCount, 5, \"Defines the maximum number of \"\\\n-          \"log files. Default is 5, maximum is 1000. Set to 0 to disable \"  \\\n-          \"rotation. Only includes rotated\/archived files. Doesn't include \"\\\n-          \"active log file.\")                                               \\\n-          range(0, 1000)                                                    \\\n-                                                                            \\\n-  product(size_t, ShenandoahLogFileSize, 20 * M, \"Defines the maximum size \"\\\n-          \"of the log file. Files over this size will be rotated. Default \" \\\n-          \"is 20MB. Set to 0 to disable rotation\")                          \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoah_globals.hpp","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- *      -XX:+ShenandoahLogRegionSampling -XX:ShenandoahRegionSamplingFile=region-snapshots-%p.log\n+ *      -Xlog:gc+region=debug:region-snapshots-%p.log::filesize=100,filecount=3\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestRegionSamplingLogging.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,2 +31,1 @@\n-    *      -XX:+ShenandoahLogRegionSampling -XX:ShenandoahRegionSamplingFile=region-snapshots-%p.log\n-    *      -XX:ShenandoahLogFileCount=3 -XX:ShenandoahLogFileSize=100\n+    *      -Xlog:gc+region=debug:region-snapshots-%p.log::filesize=100,filecount=3\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestShenandoahLogRotation.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"}]}