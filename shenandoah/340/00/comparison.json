{"files":[{"patch":"@@ -117,1 +117,0 @@\n-  bool old_bootstrap_requested = false;\n@@ -212,6 +211,0 @@\n-        } else if (_requested_generation == OLD && !old_bootstrap_requested) {\n-          \/\/ Arrange to perform a young GC immediately followed by a bootstrap OLD GC.  OLD GC typically requires more\n-          \/\/ than twice the time required for YOUNG GC, so we run a YOUNG GC to replenish the YOUNG allocation pool before\n-          \/\/ we start the longer OLD GC effort.\n-          old_bootstrap_requested = true;\n-          generation = YOUNG;\n@@ -219,3 +212,0 @@\n-          \/\/ if (old_bootstrap_requested && (_requested_generation == OLD)), this starts the bootstrap GC that\n-          \/\/  immediately follows the preparatory young GC.\n-          \/\/ But we will abandon the planned bootstrap GC if a GLOBAL GC has been now been requested.\n@@ -223,1 +213,0 @@\n-          old_bootstrap_requested = false;\n@@ -405,12 +394,4 @@\n-      if (old_bootstrap_requested) {\n-        _requested_generation = OLD;\n-        _requested_gc_cause = GCCause::_shenandoah_concurrent_gc;\n-      } else {\n-        \/\/ The timed wait is necessary because this thread has a responsibility to send\n-        \/\/ 'alloc_words' to the pacer when it does not perform a GC.\n-        MonitorLocker lock(&_control_lock, Mutex::_no_safepoint_check_flag);\n-        lock.wait(ShenandoahControlIntervalMax);\n-      }\n-    } else {\n-      \/\/ in case of alloc_failure, abandon any plans to do immediate OLD Bootstrap\n-      old_bootstrap_requested = false;\n+      \/\/ The timed wait is necessary because this thread has a responsibility to send\n+      \/\/ 'alloc_words' to the pacer when it does not perform a GC.\n+      MonitorLocker lock(&_control_lock, Mutex::_no_safepoint_check_flag);\n+      lock.wait(ShenandoahControlIntervalMax);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":4,"deletions":23,"binary":false,"changes":27,"status":"modified"}]}