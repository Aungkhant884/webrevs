{"files":[{"patch":"@@ -35,1 +35,0 @@\n-    \/\/ Leaving this here for the day we re-enable class unloading\n@@ -40,0 +39,1 @@\n+  SHENANDOAH_ERGO_OVERRIDE_DEFAULT(ShenandoahUnloadClassesFrequency, 0);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/mode\/shenandoahGenerationalMode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -74,4 +74,10 @@\n-      if (start_old_cycle()) {\n-        log_info(gc)(\"Heuristics request for old collection accepted\");\n-      } else if (start_young_cycle()) {\n-        log_info(gc)(\"Heuristics request for young collection accepted\");\n+      if (should_unload_classes()) {\n+        if (_control_thread->request_concurrent_gc(GLOBAL)) {\n+          log_info(gc)(\"Heuristics request for global (unload classes) accepted.\");\n+        }\n+      } else {\n+        if (start_old_cycle()) {\n+          log_info(gc)(\"Heuristics request for old collection accepted\");\n+        } else if (start_young_cycle()) {\n+          log_info(gc)(\"Heuristics request for young collection accepted\");\n+        }\n@@ -81,1 +87,1 @@\n-        log_info(gc)(\"Heuristics request for young collection accepted\");\n+        log_info(gc)(\"Heuristics request to interrupt old for young collection accepted\");\n@@ -152,0 +158,6 @@\n+bool ShenandoahRegulatorThread::should_unload_classes() {\n+  \/\/ The heuristics delegate this decision to the collector policy, which is based on the number\n+  \/\/ of cycles started.\n+  return _global_heuristics->should_unload_classes();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRegulatorThread.cpp","additions":17,"deletions":5,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -76,0 +76,2 @@\n+  bool should_unload_classes();\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRegulatorThread.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}