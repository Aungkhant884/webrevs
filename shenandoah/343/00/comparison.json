{"files":[{"patch":"@@ -861,4 +861,0 @@\n-  \/\/ Return the object's age (at a safepoint or when object isn't\n-  \/\/ mutable by the mutator)\n-  static inline uint get_object_age(oop obj);\n-\n@@ -868,1 +864,1 @@\n-  static inline uint get_object_age_concurrent(oop obj);\n+  static inline uint get_object_age(oop obj);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+#include \"runtime\/objectMonitor.inline.hpp\"\n@@ -540,5 +541,17 @@\n-  markWord w = obj->has_displaced_mark() ? obj->displaced_mark() : obj->mark();\n-  w = w.set_age(MIN2(markWord::max_age, w.age() + additional_age));\n-  if (obj->has_displaced_mark()) {\n-    obj->set_displaced_mark(w);\n-  } else {\n+  \/\/ This operates on new copy of an object. This means that the object's mark-word\n+  \/\/ is thread-local and therefore safe to access. However, when the mark is\n+  \/\/ displaced (i.e. stack-locked or monitor-locked), then it must be considered\n+  \/\/a shared memory location. It can\/ be accessed by other threads.\n+  \/\/ In particular, a competing evacuating\/ thread can succeed to install its copy\n+  \/\/ as the forwardee and continue to unlock the object, at which point 'our'\n+  \/\/ write to the foreign stack-location would potentially over-write random\n+  \/\/ information on that stack. Writing to a monitor is less problematic,\n+  \/\/ but still not safe: while the ObjectMonitor would not randomly disappear,\n+  \/\/ the other thread would also write to the same displaced header location,\n+  \/\/ possibly leading to increase the age twice.\n+  \/\/ For all these reasons, we take the conservative approach and not attempt\n+  \/\/ to increase the age when the header is displaced.\n+  markWord w = obj->mark();\n+  assert(!w.is_being_inflated(), \"must not inflate monitor before evacuation of object succeeds\");\n+  if (!w.has_displaced_mark_helper()) {\n+    w = w.set_age(MIN2(markWord::max_age, w.age() + additional_age));\n@@ -549,8 +562,0 @@\n-\/\/ Return the object's age (at a safepoint or when object isn't\n-\/\/ mutable by the mutator)\n-uint ShenandoahHeap::get_object_age(oop obj) {\n-  markWord w = obj->has_displaced_mark() ? obj->displaced_mark() : obj->mark();\n-  assert(w.age() <= markWord::max_age, \"Impossible!\");\n-  return w.age();\n-}\n-\n@@ -560,1 +565,1 @@\n-uint ShenandoahHeap::get_object_age_concurrent(oop obj) {\n+uint ShenandoahHeap::get_object_age(oop obj) {\n@@ -564,2 +569,3 @@\n-  \/\/ We can do better for objects with inflated monitor\n-  if (w.is_being_inflated() || w.has_displaced_mark_helper()) {\n+  if (w.has_monitor()) {\n+    w = w.monitor()->header();\n+  } else if (w.is_being_inflated() || w.has_displaced_mark_helper()) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.inline.hpp","additions":22,"deletions":16,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -122,1 +122,1 @@\n-      uint age = ShenandoahHeap::get_object_age_concurrent(obj);\n+      uint age = ShenandoahHeap::get_object_age(obj);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMark.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}