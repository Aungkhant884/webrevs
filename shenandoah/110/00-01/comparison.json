{"files":[{"patch":"@@ -70,2 +70,0 @@\n-  size_t live_bytes_in_collection_set = 0;\n-  size_t collected_region_count = 0;\n@@ -142,2 +140,0 @@\n-      live_bytes_in_collection_set += r->get_live_data_bytes();\n-      collected_region_count++;\n@@ -148,2 +144,1 @@\n-    } else {\n-   }\n+    }\n@@ -151,2 +146,0 @@\n-  cset->set_young_region_count(collected_region_count);\n-  cset->reserve_young_bytes_for_evacuation(live_bytes_in_collection_set);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.cpp","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -55,2 +55,0 @@\n-  size_t region_count = 0;\n-  size_t live_bytes_in_collection_set = 0;\n@@ -60,1 +58,0 @@\n-      region_count++;\n@@ -62,1 +59,0 @@\n-      live_bytes_in_collection_set += r->get_live_data_bytes();\n@@ -65,2 +61,0 @@\n-  cset->set_young_region_count(region_count);\n-  cset->reserve_young_bytes_for_evacuation(live_bytes_in_collection_set);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAggressiveHeuristics.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -83,1 +83,0 @@\n-  size_t region_count = 0;\n@@ -97,1 +96,0 @@\n-      region_count++;\n@@ -101,2 +99,0 @@\n-  cset->set_young_region_count(region_count);\n-  cset->reserve_young_bytes_for_evacuation(live_cset);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahCompactHeuristics.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -327,1 +327,1 @@\n-    potential_evac_supplement = (potential_evac_supplement * ShenandoahBorrowPer128) \/ 128;\n+    potential_evac_supplement = (potential_evac_supplement * ShenandoahBorrowPercent) \/ 100;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -105,1 +105,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -48,4 +48,0 @@\n-    \/\/ no candidates for inclusion in collection set.\n-    collection_set->set_old_region_count(0);\n-    collection_set->reserve_old_bytes_for_evacuation(0);\n-\n@@ -69,1 +65,1 @@\n-  const size_t ratio_bound_on_old_evac_bytes = (young_evacuation_bytes * ShenandoahOldEvacRatioPer128) \/ 128;\n+  const size_t ratio_bound_on_old_evac_bytes = (young_evacuation_bytes * ShenandoahOldEvacRatioPercent) \/ 100;\n@@ -151,2 +147,0 @@\n-  collection_set->reserve_old_bytes_for_evacuation(evacuated_old_bytes);\n-  collection_set->set_old_region_count(included_old_regions);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.cpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -65,1 +65,0 @@\n-  size_t region_count = 0;\n@@ -73,1 +72,0 @@\n-      region_count++;\n@@ -77,2 +75,0 @@\n-  cset->set_young_region_count(region_count);\n-  cset->reserve_young_bytes_for_evacuation(live_cset);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahPassiveHeuristics.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -67,2 +67,0 @@\n-  size_t live_bytes_in_collection_set = 0;\n-  size_t region_count = 0;\n@@ -74,2 +72,0 @@\n-      region_count++;\n-      live_bytes_in_collection_set += r->get_live_data_bytes();\n@@ -78,2 +74,0 @@\n-  cset->set_young_region_count(region_count);\n-  cset->reserve_young_bytes_for_evacuation(live_bytes_in_collection_set);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahStaticHeuristics.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -90,0 +90,14 @@\n+\n+  if (ShenandoahHeap::heap()->mode()->is_generational()) {\n+    if (ShenandoahHeap::heap()->is_aging_cycle()) {\n+      r->decrement_age();\n+    }\n+  }\n+  if (r->affiliation() == YOUNG_GENERATION) {\n+    _young_region_count++;\n+    _young_bytes_to_evacuate += r->get_live_data_bytes();\n+  } else if (r->affiliation() == OLD_GENERATION) {\n+    _old_region_count++;\n+    _old_bytes_to_evacuate += r->get_live_data_bytes();\n+  }\n+\n@@ -114,0 +128,5 @@\n+  _young_region_count = 0;\n+  _old_region_count = 0;\n+  _young_bytes_to_evacuate = 0;\n+  _old_bytes_to_evacuate = 0;\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCollectionSet.cpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -105,1 +105,0 @@\n-  inline void set_old_region_count(size_t num_regions);\n@@ -108,1 +107,0 @@\n-  inline void set_young_region_count(size_t num_regions);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCollectionSet.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -64,0 +64,1 @@\n+#ifdef KELVIN_VERBOSE\n@@ -71,0 +72,1 @@\n+#endif\n@@ -84,8 +86,0 @@\n-void ShenandoahCollectionSet::set_old_region_count(size_t num_regions) {\n-  _old_region_count = num_regions;\n-}\n-\n-void ShenandoahCollectionSet::set_young_region_count(size_t num_regions) {\n-  _young_region_count = num_regions;\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCollectionSet.inline.hpp","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -204,1 +204,2 @@\n-    vmop_entry_final_roots();\n+    \/\/ We chose not to evacuate because we found sufficient immediate garbage.\n+    vmop_entry_final_roots(heap->is_aging_cycle());\n@@ -279,1 +280,1 @@\n-void ShenandoahConcurrentGC::vmop_entry_final_roots() {\n+void ShenandoahConcurrentGC::vmop_entry_final_roots(bool increment_region_ages) {\n@@ -286,1 +287,1 @@\n-  VM_ShenandoahFinalRoots op(this);\n+  VM_ShenandoahFinalRoots op(this, increment_region_ages);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-  void vmop_entry_final_roots();\n+  void vmop_entry_final_roots(bool incr_region_ages);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-HeapWord* ShenandoahFreeSet::allocate_with_affiliation(ShenandoahRegionAffiliation affiliation, ShenandoahAllocRequest& req, bool& in_new_region, bool is_gclab) {\n+HeapWord* ShenandoahFreeSet::allocate_with_affiliation(ShenandoahRegionAffiliation affiliation, ShenandoahAllocRequest& req, bool& in_new_region) {\n@@ -74,1 +74,1 @@\n-        HeapWord* result = try_allocate_in(r, req, in_new_region, is_gclab);\n+        HeapWord* result = try_allocate_in(r, req, in_new_region);\n@@ -99,1 +99,0 @@\n-  bool allocating_gclab = false;\n@@ -107,1 +106,1 @@\n-          HeapWord* result = try_allocate_in(_heap->get_region(idx), req, in_new_region, false);\n+          HeapWord* result = try_allocate_in(_heap->get_region(idx), req, in_new_region);\n@@ -120,1 +119,0 @@\n-      allocating_gclab = true;\n@@ -127,1 +125,1 @@\n-      HeapWord* result = allocate_with_affiliation(req.affiliation(), req, in_new_region, allocating_gclab);\n+      HeapWord* result = allocate_with_affiliation(req.affiliation(), req, in_new_region);\n@@ -132,1 +130,1 @@\n-      result = allocate_with_affiliation(FREE, req, in_new_region, allocating_gclab);\n+      result = allocate_with_affiliation(FREE, req, in_new_region);\n@@ -149,1 +147,1 @@\n-            HeapWord *result = try_allocate_in(r, req, in_new_region, allocating_gclab);\n+            HeapWord *result = try_allocate_in(r, req, in_new_region);\n@@ -168,3 +166,1 @@\n-\/\/ is_gclab denotes this is for evacuation, not promotion.  PLAB allocations do not count as is_gclab.\n-HeapWord* ShenandoahFreeSet::try_allocate_in(ShenandoahHeapRegion* r, ShenandoahAllocRequest& req, bool& in_new_region,\n-                                             bool is_gclab) {\n+HeapWord* ShenandoahFreeSet::try_allocate_in(ShenandoahHeapRegion* r, ShenandoahAllocRequest& req, bool& in_new_region) {\n@@ -305,1 +301,2 @@\n-        assert(!is_gclab, \"old-gen allocations use PLAB or shared allocation\");\n+\n+        assert(req.type() != _alloc_gclab, \"old-gen allocations use PLAB or shared allocation\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":9,"deletions":12,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -51,3 +51,2 @@\n-  HeapWord* try_allocate_in(ShenandoahHeapRegion* region, ShenandoahAllocRequest& req, bool& in_new_region, bool is_gclab);\n-  HeapWord* allocate_with_affiliation(ShenandoahRegionAffiliation affiliation, ShenandoahAllocRequest& req,\n-                                      bool& in_new_region, bool is_gclab);\n+  HeapWord* try_allocate_in(ShenandoahHeapRegion* region, ShenandoahAllocRequest& req, bool& in_new_region);\n+  HeapWord* allocate_with_affiliation(ShenandoahRegionAffiliation affiliation, ShenandoahAllocRequest& req, bool& in_new_region);\n@@ -82,1 +81,1 @@\n-  \/\/ How many regions dedicated to GC allocations (for evacuation or promotion) are currently free?\n+  \/\/ Number of regions dedicated to GC allocations (for evacuation or promotion) that are currently free\n@@ -85,1 +84,1 @@\n-  \/\/ How many regions dedicated to mutator allocations are currently free?\n+  \/\/ Number of regions dedicated to mutator allocations that are currently free\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.hpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -311,1 +311,1 @@\n-      \/\/       2. (young_gen->capacity() scaled by ShenandoahEvacReserve) scaled by ShenandoahOldEvacRatio\n+      \/\/       2. (young_gen->capacity() scaled by ShenandoahEvacReserve) scaled by ShenandoahOldEvacRatioPercent\n@@ -316,1 +316,1 @@\n-      \/\/ Make sure old evacuation is no more than ShenandoahOldEvacRatio of the total evacuation budget.\n+      \/\/ Make sure old evacuation is no more than ShenandoahOldEvacRatioPercent of the total evacuation budget.\n@@ -318,1 +318,1 @@\n-      size_t max_old_evac_portion = (max_total_evac * ShenandoahOldEvacRatioPer128) \/ 128;\n+      size_t max_old_evac_portion = (max_total_evac * ShenandoahOldEvacRatioPercent) \/ 100;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -362,1 +362,2 @@\n-  \/\/ 1. Unadjust the capacity within young-gen and old-gen\n+  \/\/ 1. Unadjust the capacity within young-gen and old-gen to undo the effects of borrowing memory from old-gen.  Note that\n+  \/\/    the entirety of the collection set is now available, so allocation capacity naturally increase at this time.\n@@ -385,1 +386,1 @@\n-  size_t _old_evac_expended;           \/\/ Bytes of old-gen memory expended on old-gen evacuations?\n+  size_t _old_evac_expended;           \/\/ Bytes of old-gen memory expended on old-gen evacuations\n@@ -388,1 +389,1 @@\n-  size_t _young_evac_expended;         \/\/ Bytes old-gen memory has been expended on young-gen evacuations?\n+  size_t _young_evac_expended;         \/\/ Bytes old-gen memory has been expended on young-gen evacuations\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -389,1 +389,1 @@\n-             copy = allocate_from_plab(thread, size, is_promotion);;\n+             copy = allocate_from_plab(thread, size, is_promotion);\n@@ -394,1 +394,1 @@\n-               copy = allocate_from_gclab(thread, size);\n+               copy = allocate_from_plab(thread, size, is_promotion);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -441,0 +441,1 @@\n+  void decrement_age() { if (_age-- == 0) { _age = 0; } }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -196,1 +196,1 @@\n-  vmop_entry_final_roots();\n+  vmop_entry_final_roots(false);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGC.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -177,1 +177,1 @@\n-    data(thread)->_plab_allows_promotion = true;\n+    data(thread)->_plab_allows_promotion = false;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahThreadLocalData.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -82,0 +82,18 @@\n+  if (_incr_region_ages) {\n+    \/\/ TODO: Do we even care about this?  Do we want to parallelize it?\n+    ShenandoahHeap* heap = ShenandoahHeap::heap();\n+    ShenandoahMarkingContext* ctx = heap->complete_marking_context();\n+\n+    for (size_t i = 0; i < heap->num_regions(); i++) {\n+      ShenandoahHeapRegion *r = heap->get_region(i);\n+      if (r->is_active() && r->is_young()) {\n+        HeapWord* tams = ctx->top_at_mark_start(r);\n+        HeapWord* top = r->top();\n+        if (top > tams) {\n+          r->reset_age();\n+        } else {\n+          r->increment_age();\n+        }\n+      }\n+    }\n+  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVMOperations.cpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -137,0 +137,1 @@\n+  bool _incr_region_ages;\n@@ -138,1 +139,1 @@\n-  VM_ShenandoahFinalRoots(ShenandoahConcurrentGC* gc) :\n+  VM_ShenandoahFinalRoots(ShenandoahConcurrentGC* gc, bool incr_region_ages) :\n@@ -140,1 +141,1 @@\n-    _gc(gc) {};\n+    _gc(gc), _incr_region_ages(incr_region_ages) {};\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVMOperations.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -305,2 +305,2 @@\n-          \"ShenandoahOldEvacRatio.  In percents of total old-generation \"   \\\n-          \"heap size.\")                                                     \\\n+          \"ShenandoahOldEvacRatioPercent.  In percents of total \"           \\\n+          \"old-generation heap size.\")                                      \\\n@@ -309,1 +309,1 @@\n-  product(uintx, ShenandoahOldEvacRatioPer128, 16, EXPERIMENTAL,            \\\n+  product(uintx, ShenandoahOldEvacRatioPercent, 12, EXPERIMENTAL,           \\\n@@ -311,2 +311,2 @@\n-          \"a ratio with 128.  The default value 16 denotes that no more \"   \\\n-          \"than one eighth (16\/128) of the collection set evacuation \"      \\\n+          \"a percent ratio.  The default value 12 denotes that no more \"    \\\n+          \"than one eighth (12%) of the collection set evacuation \"         \\\n@@ -317,1 +317,1 @@\n-          \"collections.  A value of 128 allows a mixed evacuation to \"      \\\n+          \"collections.  A value of 100 allows a mixed evacuation to \"      \\\n@@ -326,1 +326,1 @@\n-          range(0,128)                                                      \\\n+          range(0,100)                                                      \\\n@@ -469,1 +469,1 @@\n-  product(uintx, ShenandoahBorrowPer128, 40, EXPERIMENTAL,                  \\\n+  product(uintx, ShenandoahBorrowPercent, 30, EXPERIMENTAL,                 \\\n@@ -472,1 +472,1 @@\n-          \"memory up to ShenandoahBorrowPer128 \/ 128 amount of the \"        \\\n+          \"memory up to ShenandoahBorrowPercent \/ 100 amount of the \"       \\\n@@ -477,7 +477,5 @@\n-          \"set is recycled at the end of updating references.  Note \"       \\\n-          \"that the default value of 40 represents approximately 30% \"      \\\n-          \"of the young-gen memory within the collection set.  This \"       \\\n-          \"reserves roughly 70% of the to-be-reclaimed young \"              \\\n-          \"collection set memory to be allocated during the subsequent \"    \\\n-          \"concurrent mark phase of GC.\")                                   \\\n-          range(0, 128)                                                     \\\n+          \"set is recycled at the end of updating references.  The \"        \\\n+          \"default value of 30 reserves 70% of the to-be-reclaimed \"        \\\n+          \"young collection set memory to be allocated during the \"         \\\n+          \"subsequent concurrent mark phase of GC.\")                        \\\n+          range(0, 100)                                                     \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoah_globals.hpp","additions":14,"deletions":16,"binary":false,"changes":30,"status":"modified"}]}