{"files":[{"patch":"@@ -30,1 +30,1 @@\n-#include \"gc\/shenandoah\/heuristics\/shenandoahHeapStats.hpp\"\n+#include \"gc\/shenandoah\/heuristics\/shenandoahSpaceInfo.hpp\"\n@@ -63,3 +63,2 @@\n-ShenandoahAdaptiveHeuristics::ShenandoahAdaptiveHeuristics(ShenandoahHeapStats* heap_stats) :\n-  ShenandoahHeuristics(),\n-  _heap_stats(heap_stats),\n+ShenandoahAdaptiveHeuristics::ShenandoahAdaptiveHeuristics(ShenandoahSpaceInfo* space_info) :\n+  ShenandoahHeuristics(space_info),\n@@ -95,1 +94,1 @@\n-  size_t capacity    = ShenandoahHeap::heap()->soft_max_capacity();\n+  size_t capacity    = _space_info->soft_max_capacity();\n@@ -139,1 +138,1 @@\n-  size_t available = _heap_stats->available();\n+  size_t available = _space_info->available();\n@@ -146,1 +145,1 @@\n-                        _heap_stats->name(),\n+                        _space_info->name(),\n@@ -210,3 +209,3 @@\n-  size_t capacity = _heap_stats->soft_max_capacity();\n-  size_t available = _heap_stats->soft_available();\n-  size_t allocated = _heap_stats->bytes_allocated_since_gc_start();\n+  size_t capacity = _space_info->soft_max_capacity();\n+  size_t available = _space_info->soft_available();\n+  size_t allocated = _space_info->bytes_allocated_since_gc_start();\n@@ -216,1 +215,1 @@\n-                _heap_stats->name(), available, capacity, allocated);\n+                _space_info->name(), available, capacity, allocated);\n@@ -224,1 +223,1 @@\n-    log_info(gc)(\"Trigger (%s): Free (\" SIZE_FORMAT \"%s) is below minimum threshold (\" SIZE_FORMAT \"%s)\", _heap_stats->name(),\n+    log_info(gc)(\"Trigger (%s): Free (\" SIZE_FORMAT \"%s) is below minimum threshold (\" SIZE_FORMAT \"%s)\", _space_info->name(),\n@@ -236,1 +235,1 @@\n-                   _heap_stats->name(), _gc_times_learned + 1, max_learn,\n+                   _space_info->name(), _gc_times_learned + 1, max_learn,\n@@ -284,1 +283,1 @@\n-                _heap_stats->name(),\n+                _space_info->name(),\n@@ -289,1 +288,1 @@\n-                 _heap_stats->name(), avg_cycle_time * 1000,\n+                 _space_info->name(), avg_cycle_time * 1000,\n@@ -305,1 +304,1 @@\n-                 _heap_stats->name(), avg_cycle_time * 1000,\n+                 _space_info->name(), avg_cycle_time * 1000,\n@@ -346,1 +345,1 @@\n-  return _heap_stats->max_capacity() \/ 100 * ShenandoahMinFreeThreshold;\n+  return _space_info->max_capacity() \/ 100 * ShenandoahMinFreeThreshold;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.cpp","additions":16,"deletions":17,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -31,2 +31,1 @@\n-#include \"gc\/shenandoah\/heuristics\/shenandoahHeapStats.hpp\"\n-#include \"gc\/shenandoah\/shenandoahSharedVariables.hpp\"\n+#include \"gc\/shenandoah\/heuristics\/shenandoahSpaceInfo.hpp\"\n@@ -35,0 +34,1 @@\n+#include \"gc\/shenandoah\/shenandoahSharedVariables.hpp\"\n@@ -57,0 +57,11 @@\n+\/*\n+ * The adaptive heuristic tracks the allocation behavior and average cycle\n+ * time of the application. It attempts to start a cycle with enough time\n+ * to complete before the available memory is exhausted. It errors on the\n+ * side of starting cycles early to avoid allocation failures (degenerated\n+ * cycles).\n+ *\n+ * This heuristic limits the number of regions for evacuation such that the\n+ * evacuation reserve is respected. This helps it avoid allocation failures\n+ * during evacuation. It preferentially selects regions with the most garbage.\n+ *\/\n@@ -59,1 +70,1 @@\n-  ShenandoahAdaptiveHeuristics(ShenandoahHeapStats* heap_stats);\n+  ShenandoahAdaptiveHeuristics(ShenandoahSpaceInfo* space_info);\n@@ -106,2 +117,0 @@\n-  ShenandoahHeapStats* _heap_stats;\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.hpp","additions":14,"deletions":5,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -35,1 +35,2 @@\n-ShenandoahAggressiveHeuristics::ShenandoahAggressiveHeuristics() : ShenandoahHeuristics() {\n+ShenandoahAggressiveHeuristics::ShenandoahAggressiveHeuristics(ShenandoahSpaceInfo* space_info) :\n+  ShenandoahHeuristics(space_info) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAggressiveHeuristics.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,0 +31,4 @@\n+\/*\n+ * This is a diagnostic heuristic that continuously runs collections\n+ * cycles and adds every region with any garbage to the collection set.\n+ *\/\n@@ -33,1 +37,1 @@\n-  ShenandoahAggressiveHeuristics();\n+  ShenandoahAggressiveHeuristics(ShenandoahSpaceInfo* space_info);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAggressiveHeuristics.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -36,1 +36,2 @@\n-ShenandoahCompactHeuristics::ShenandoahCompactHeuristics() : ShenandoahHeuristics() {\n+ShenandoahCompactHeuristics::ShenandoahCompactHeuristics(ShenandoahSpaceInfo* space_info) :\n+  ShenandoahHeuristics(space_info) {\n@@ -49,5 +50,3 @@\n-  ShenandoahHeap* heap = ShenandoahHeap::heap();\n-\n-  size_t max_capacity = heap->max_capacity();\n-  size_t capacity = heap->soft_max_capacity();\n-  size_t available = heap->free_set()->available();\n+  size_t max_capacity = _space_info->max_capacity();\n+  size_t capacity = _space_info->soft_max_capacity();\n+  size_t available = _space_info->available();\n@@ -69,1 +68,1 @@\n-  size_t bytes_allocated = heap->bytes_allocated_since_gc_start();\n+  size_t bytes_allocated = _space_info->bytes_allocated_since_gc_start();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahCompactHeuristics.cpp","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -46,11 +46,12 @@\n-ShenandoahHeuristics::ShenandoahHeuristics() :\n-        _region_data(nullptr),\n-        _degenerated_cycles_in_a_row(0),\n-        _successful_cycles_in_a_row(0),\n-        _guaranteed_gc_interval(0),\n-        _cycle_start(os::elapsedTime()),\n-        _last_cycle_end(0),\n-        _gc_times_learned(0),\n-        _gc_time_penalties(0),\n-        _gc_cycle_time_history(new TruncatedSeq(Moving_Average_Samples, ShenandoahAdaptiveDecayFactor)),\n-        _metaspace_oom()\n+ShenandoahHeuristics::ShenandoahHeuristics(ShenandoahSpaceInfo* space_info) :\n+  _space_info(space_info),\n+  _region_data(nullptr),\n+  _degenerated_cycles_in_a_row(0),\n+  _successful_cycles_in_a_row(0),\n+  _guaranteed_gc_interval(0),\n+  _cycle_start(os::elapsedTime()),\n+  _last_cycle_end(0),\n+  _gc_times_learned(0),\n+  _gc_time_penalties(0),\n+  _gc_cycle_time_history(new TruncatedSeq(Moving_Average_Samples, ShenandoahAdaptiveDecayFactor)),\n+  _metaspace_oom()\n@@ -203,2 +204,2 @@\n-      log_info(gc)(\"Trigger: Time since last GC (%.0f ms) is larger than guaranteed interval (\" UINTX_FORMAT \" ms)\",\n-                   last_time_ms, _guaranteed_gc_interval);\n+      log_info(gc)(\"Trigger (%s): Time since last GC (%.0f ms) is larger than guaranteed interval (\" UINTX_FORMAT \" ms)\",\n+                   _space_info->name(), last_time_ms, _guaranteed_gc_interval);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.cpp","additions":14,"deletions":13,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/shenandoah\/heuristics\/shenandoahSpaceInfo.hpp\"\n@@ -31,1 +32,0 @@\n-#include \"gc\/shenandoah\/heuristics\/shenandoahHeapStats.hpp\"\n@@ -62,0 +62,5 @@\n+\/*\n+ * Shenandoah heuristics are primarily responsible for deciding when to start\n+ * a collection cycle and choosing which regions will be evacuated during the\n+ * cycle.\n+ *\/\n@@ -78,0 +83,3 @@\n+  \/\/ Source of information about the memory space managed by this heuristic\n+  ShenandoahSpaceInfo* _space_info;\n+\n@@ -120,1 +128,1 @@\n-  ShenandoahHeuristics();\n+  ShenandoahHeuristics(ShenandoahSpaceInfo* space_info);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.hpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-  ShenandoahHeuristics(),\n+  ShenandoahHeuristics(generation),\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHENANDOAH_HEURISTICS_SHENANDOAHSPACEINFO_HPP\n+#define SHARE_GC_SHENANDOAH_HEURISTICS_SHENANDOAHSPACEINFO_HPP\n+\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+\/*\n+ * The purpose of this interface is to decouple the heuristics from a\n+ * direct dependency on the ShenandoahHeap singleton instance. This is\n+ * done to facilitate future unit testing of the heuristics and to support\n+ * future operational modes of Shenandoah in which the heap may be split\n+ * into generations.\n+ *\/\n+class ShenandoahSpaceInfo {\n+public:\n+  virtual const char* name() const = 0;\n+  virtual size_t soft_max_capacity() const = 0;\n+  virtual size_t max_capacity() const = 0;\n+  virtual size_t soft_available() const = 0;\n+  virtual size_t available() const = 0;\n+  virtual size_t used() const = 0;\n+  virtual size_t bytes_allocated_since_gc_start() const = 0;\n+};\n+\n+#endif \/\/SHARE_GC_SHENANDOAH_HEURISTICS_SHENANDOAHSPACEINFO_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahSpaceInfo.hpp","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -36,1 +36,2 @@\n-ShenandoahStaticHeuristics::ShenandoahStaticHeuristics() : ShenandoahHeuristics() {\n+ShenandoahStaticHeuristics::ShenandoahStaticHeuristics(ShenandoahSpaceInfo* space_info) :\n+  ShenandoahHeuristics(space_info) {\n@@ -44,5 +45,3 @@\n-  ShenandoahHeap* heap = ShenandoahHeap::heap();\n-\n-  size_t max_capacity = heap->max_capacity();\n-  size_t capacity = heap->soft_max_capacity();\n-  size_t available = heap->free_set()->available();\n+  size_t max_capacity = _space_info->max_capacity();\n+  size_t capacity = _space_info->soft_max_capacity();\n+  size_t available = _space_info->available();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahStaticHeuristics.cpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-#include \"shenandoahAdaptiveHeuristics.hpp\"\n@@ -142,1 +141,1 @@\n-                 _heap_stats->name(),\n+                 _space_info->name(),\n@@ -153,1 +152,1 @@\n-                 _heap_stats->name(),\n+                 _space_info->name(),\n@@ -164,1 +163,1 @@\n-                 _heap_stats->name(), mixed_candidates);\n+                 _space_info->name(), mixed_candidates);\n@@ -176,2 +175,2 @@\n-  size_t capacity = _heap_stats->soft_max_capacity();\n-  size_t usage = _heap_stats->used();\n+  size_t capacity = _space_info->soft_max_capacity();\n+  size_t usage = _space_info->used();\n@@ -179,1 +178,1 @@\n-  size_t allocated = _heap_stats->bytes_allocated_since_gc_start();\n+  size_t allocated = _space_info->bytes_allocated_since_gc_start();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahYoungHeuristics.cpp","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"gc\/shenandoah\/heuristics\/shenandoahHeapStats.hpp\"\n+#include \"gc\/shenandoah\/heuristics\/shenandoahSpaceInfo.hpp\"\n@@ -34,1 +34,1 @@\n-ShenandoahHeuristics* ShenandoahMode::initialize_heuristics(ShenandoahHeapStats* heap_info) const {\n+ShenandoahHeuristics* ShenandoahMode::initialize_heuristics(ShenandoahSpaceInfo* space_info) const {\n@@ -40,1 +40,1 @@\n-    return new ShenandoahAggressiveHeuristics();\n+    return new ShenandoahAggressiveHeuristics(space_info);\n@@ -42,1 +42,1 @@\n-    return new ShenandoahStaticHeuristics();\n+    return new ShenandoahStaticHeuristics(space_info);\n@@ -44,1 +44,1 @@\n-    return new ShenandoahAdaptiveHeuristics(heap_info);\n+    return new ShenandoahAdaptiveHeuristics(space_info);\n@@ -46,1 +46,1 @@\n-    return new ShenandoahCompactHeuristics();\n+    return new ShenandoahCompactHeuristics(space_info);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/mode\/shenandoahMode.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-class ShenandoahHeapStats;\n+class ShenandoahSpaceInfo;\n@@ -55,1 +55,1 @@\n-  virtual ShenandoahHeuristics* initialize_heuristics(ShenandoahHeapStats* heap_info) const;\n+  virtual ShenandoahHeuristics* initialize_heuristics(ShenandoahSpaceInfo* space_info) const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/mode\/shenandoahMode.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"gc\/shenandoah\/heuristics\/shenandoahSpaceInfo.hpp\"\n@@ -28,1 +29,1 @@\n-#include \"gc\/shenandoah\/heuristics\/shenandoahHeapStats.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n@@ -60,1 +61,1 @@\n-ShenandoahHeuristics* ShenandoahPassiveMode::initialize_heuristics(ShenandoahHeapStats* heap_info) const {\n+ShenandoahHeuristics* ShenandoahPassiveMode::initialize_heuristics(ShenandoahSpaceInfo* space_info) const {\n@@ -64,1 +65,1 @@\n-  return new ShenandoahPassiveHeuristics();\n+  return new ShenandoahPassiveHeuristics(space_info);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/mode\/shenandoahPassiveMode.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-  virtual ShenandoahHeuristics* initialize_heuristics(ShenandoahHeapStats* heap_info) const;\n+  virtual ShenandoahHeuristics* initialize_heuristics(ShenandoahSpaceInfo* space_info) const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/mode\/shenandoahPassiveMode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"gc\/shenandoah\/heuristics\/shenandoahHeapStats.hpp\"\n+#include \"gc\/shenandoah\/heuristics\/shenandoahSpaceInfo.hpp\"\n@@ -41,1 +41,1 @@\n-class ShenandoahGeneration : public CHeapObj<mtGC>, public ShenandoahHeapStats {\n+class ShenandoahGeneration : public CHeapObj<mtGC>, public ShenandoahSpaceInfo {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2662,5 +2662,0 @@\n-size_t ShenandoahHeap::bytes_allocated_since_gc_start() {\n-  assert(!mode()->is_generational(), \"This is used for heuristics that are not compatible with generational mode\");\n-  return global_generation()->bytes_allocated_since_gc_start();\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"gc\/shenandoah\/heuristics\/shenandoahSpaceInfo.hpp\"\n@@ -246,1 +247,0 @@\n-  size_t bytes_allocated_since_gc_start();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}