{"files":[{"patch":"@@ -70,0 +70,2 @@\n+  size_t ignore_threshold = ShenandoahHeapRegion::region_size_bytes() * ShenandoahIgnoreGarbageThreshold \/ 100;\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n@@ -88,18 +90,0 @@\n-  ShenandoahHeap* heap = ShenandoahHeap::heap();\n-  size_t max_cset    = (size_t) (heap->get_young_evac_reserve() \/ ShenandoahEvacWaste);\n-  size_t capacity    = heap->young_generation()->soft_max_capacity();\n-\n-  \/\/ As currently implemented, we are not enforcing that new_garbage > min_garbage\n-  \/\/ size_t free_target = (capacity \/ 100) * ShenandoahMinFreeThreshold + max_cset;\n-  \/\/ size_t min_garbage = (free_target > actual_free ? (free_target - actual_free) : 0);\n-\n-  log_info(gc, ergo)(\"Adaptive CSet Selection. Max CSet: \" SIZE_FORMAT \"%s, Actual Free: \" SIZE_FORMAT \"%s.\",\n-                     byte_size_in_proper_unit(max_cset),    proper_unit_for_byte_size(max_cset),\n-                     byte_size_in_proper_unit(actual_free), proper_unit_for_byte_size(actual_free));\n-\n-  \/\/ Better select garbage-first regions\n-  QuickSort::sort<RegionData>(data, (int)size, compare_by_garbage, false);\n-\n-  size_t cur_cset = 0;\n-  \/\/ size_t cur_garbage = 0;\n-\n@@ -111,7 +95,52 @@\n-  for (size_t idx = 0; idx < size; idx++) {\n-    ShenandoahHeapRegion* r = data[idx]._region;\n-    size_t new_cset;\n-    if (is_generational && (r->age() >= InitialTenuringThreshold)) {\n-      \/\/ Entire region will be promoted, This region does not impact young-gen evacuation reserve.  Memory has already\n-      \/\/ been set aside to hold evacuation results as advance_promotion_reserve.\n-      new_cset = cur_cset;\n+  bool is_global = (_generation->generation_mode() == GLOBAL);\n+  size_t capacity = heap->young_generation()->max_capacity();\n+  size_t cur_young_garbage = 0;\n+\n+  \/\/ Better select garbage-first regions\n+  QuickSort::sort<RegionData>(data, (int)size, compare_by_garbage, false);\n+\n+  if (is_generational) {\n+    if (is_global) {\n+      size_t max_young_cset    = (size_t) (heap->get_young_evac_reserve() \/ ShenandoahEvacWaste);\n+      size_t young_cur_cset = 0;\n+      size_t max_old_cset    = (size_t) (heap->get_old_evac_reserve() \/ ShenandoahEvacWaste);\n+      size_t old_cur_cset = 0;\n+      size_t free_target = (capacity * ShenandoahMinFreeThreshold) \/ 100 + max_young_cset;\n+      size_t min_garbage = (free_target > actual_free) ? (free_target - actual_free) : 0;\n+\n+      log_info(gc, ergo)(\"Adaptive CSet Selection for GLOBAL. Max Young Cset: \" SIZE_FORMAT\n+                         \"%s, Max Old CSet: \" SIZE_FORMAT \"%s, Actual Free: \" SIZE_FORMAT \"%s.\",\n+                         byte_size_in_proper_unit(max_young_cset),    proper_unit_for_byte_size(max_young_cset),\n+                         byte_size_in_proper_unit(max_old_cset),    proper_unit_for_byte_size(max_old_cset),\n+                         byte_size_in_proper_unit(actual_free), proper_unit_for_byte_size(actual_free));\n+\n+      for (size_t idx = 0; idx < size; idx++) {\n+        ShenandoahHeapRegion* r = data[idx]._region;\n+        bool add_region = false;\n+        if (r->is_old()) {\n+          size_t new_cset = old_cur_cset + r->get_live_data_bytes();\n+          if ((new_cset <= max_old_cset) && (r->garbage() > garbage_threshold)) {\n+            add_region = true;\n+            old_cur_cset = new_cset;\n+          }\n+        } else if (r->age() >= InitialTenuringThreshold) {\n+          \/\/ Entire region will be promoted, This region does not impact young-gen or old-gen evacuation reserve.\n+          \/\/ This region has been pre-selected and its impact on promotion reserve is already accounted for.\n+          add_region = true;\n+          cur_young_garbage += r->garbage();\n+        } else {\n+          size_t new_cset = young_cur_cset + r->get_live_data_bytes();\n+          size_t region_garbage = r->garbage();\n+          size_t new_garbage = cur_young_garbage + region_garbage;\n+          bool add_regardless = (region_garbage > ignore_threshold) && (new_garbage < min_garbage);\n+          if ((new_cset <= max_young_cset) && (add_regardless || (region_garbage > garbage_threshold))) {\n+            add_region = true;\n+            young_cur_cset = new_cset;\n+            cur_young_garbage = new_garbage;\n+          }\n+        }\n+\n+        if (add_region) {\n+          cset->add_region(r);\n+        }\n+      }\n@@ -119,1 +148,30 @@\n-      new_cset = cur_cset + r->get_live_data_bytes();\n+      \/\/ This is young-gen collection.\n+      size_t max_cset    = (size_t) (heap->get_young_evac_reserve() \/ ShenandoahEvacWaste);\n+      size_t cur_cset = 0;\n+      size_t free_target = (capacity * ShenandoahMinFreeThreshold) \/ 100 + max_cset;\n+      size_t min_garbage = (free_target > actual_free) ? (free_target - actual_free) : 0;\n+\n+      log_info(gc, ergo)(\"Adaptive CSet Selection for YOUNG. Max CSet: \" SIZE_FORMAT \"%s, Actual Free: \" SIZE_FORMAT \"%s.\",\n+                         byte_size_in_proper_unit(max_cset),    proper_unit_for_byte_size(max_cset),\n+                         byte_size_in_proper_unit(actual_free), proper_unit_for_byte_size(actual_free));\n+\n+      for (size_t idx = 0; idx < size; idx++) {\n+        ShenandoahHeapRegion* r = data[idx]._region;\n+        size_t new_cset;\n+        size_t region_garbage = r->garbage();\n+        size_t new_garbage = cur_young_garbage + region_garbage;\n+        if (r->age() >= InitialTenuringThreshold) {\n+          \/\/ Entire region will be promoted, This region does not impact young-gen evacuation reserve.  Memory has already\n+          \/\/ been set aside to hold evacuation results as advance_promotion_reserve.\n+          new_cset = cur_cset;\n+        } else {\n+          new_cset = cur_cset + r->get_live_data_bytes();\n+        }\n+        bool add_regardless = (region_garbage > ignore_threshold) && (new_garbage < min_garbage);\n+        if ((new_cset <= max_cset) &&\n+            (add_regardless || (region_garbage > garbage_threshold) || (r->age() >= InitialTenuringThreshold))) {\n+          cset->add_region(r);\n+          cur_cset = new_cset;\n+          cur_young_garbage = new_garbage;\n+        }\n+      }\n@@ -121,26 +179,22 @@\n-    \/\/ As currently implemented, we are not enforcing that new_garbage > min_garbage\n-    \/\/ size_t new_garbage = cur_garbage + r->garbage();\n-\n-    \/\/ Note that live data bytes within a region is not the same as heap_region_size - garbage.  This is because\n-    \/\/ each region contains a combination of used memory (which is garbage plus live) and unused memory, which has not\n-    \/\/ yet been allocated.  It may be the case that the region on this iteration has too much live data to be added to\n-    \/\/ the collection set while one or more regions seen on subsequent iterations of this loop can be added to the collection\n-    \/\/ set because they have smaller live memory, even though they also have smaller garbage (and necessarily a larger\n-    \/\/ amount of unallocated memory).\n-\n-    \/\/ BANDAID: In an earlier version of this code, this was written:\n-    \/\/   if ((new_cset <= max_cset) && ((new_garbage < min_garbage) || (r->garbage() > garbage_threshold)))\n-    \/\/ The problem with the original code is that in some cases the collection set would include hundreds of regions,\n-    \/\/ each with less than 100 bytes of garbage.  Evacuating these regions is counterproductive.\n-\n-    \/\/ TODO: Think about changing the description and defaults for ShenandoahGarbageThreshold and ShenandoahMinFreeThreshold.\n-    \/\/ If \"customers\" want to evacuate regions with smaller amounts of garbage contained therein, they should specify a lower\n-    \/\/ value of ShenandoahGarbageThreshold.  As implemented currently, we may experience back-to-back collections if there is\n-    \/\/ not enough memory to be reclaimed.  Let's not let pursuit of min_garbage drive us to make poor decisions.  Maybe we\n-    \/\/ want yet another global parameter to allow a region to be placed into the collection set if\n-    \/\/ (((new_garbage < min_garbage) && (r->garbage() > ShenandoahSmallerGarbageThreshold)) || (r->garbage() > garbage_threshold))\n-\n-    if ((new_cset <= max_cset) && ((r->garbage() > garbage_threshold) || (r->age() >= InitialTenuringThreshold))) {\n-      cset->add_region(r);\n-      cur_cset = new_cset;\n-      \/\/ cur_garbage = new_garbage;\n+  } else {\n+    \/\/ Traditional Shenandoah (non-generational)\n+    size_t max_cset    = (size_t) (heap->get_young_evac_reserve() \/ ShenandoahEvacWaste);\n+    size_t cur_cset = 0;\n+    size_t free_target = (capacity * ShenandoahMinFreeThreshold) \/ 100 + max_cset;\n+    size_t min_garbage = (free_target > actual_free) ? (free_target - actual_free) : 0;\n+\n+    log_info(gc, ergo)(\"Adaptive CSet Selection. Max CSet: \" SIZE_FORMAT \"%s, Actual Free: \" SIZE_FORMAT \"%s.\",\n+                         byte_size_in_proper_unit(max_cset),    proper_unit_for_byte_size(max_cset),\n+                         byte_size_in_proper_unit(actual_free), proper_unit_for_byte_size(actual_free));\n+\n+    for (size_t idx = 0; idx < size; idx++) {\n+      ShenandoahHeapRegion* r = data[idx]._region;\n+      size_t new_cset = cur_cset + r->get_live_data_bytes();\n+      size_t region_garbage = r->garbage();\n+      size_t new_garbage = cur_young_garbage + region_garbage;\n+      bool add_regardless = (region_garbage > ignore_threshold) && (new_garbage < min_garbage);\n+      if ((new_cset <= max_cset) && (add_regardless || (region_garbage > garbage_threshold))) {\n+        cset->add_region(r);\n+        cur_cset = new_cset;\n+        cur_young_garbage = new_garbage;\n+      }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.cpp","additions":106,"deletions":52,"binary":false,"changes":158,"status":"modified"},{"patch":"@@ -92,0 +92,2 @@\n+        \/\/ Note that we keep going even if one region is excluded from selection.  Subsequent regions may be selected\n+        \/\/ if they have smaller live data.\n@@ -100,0 +102,1 @@\n+  bool is_generational = heap->mode()->is_generational();\n@@ -135,1 +138,0 @@\n-\n@@ -147,1 +149,0 @@\n-\n@@ -151,12 +152,3 @@\n-        if (collection_set->is_preselected(i)) {\n-          \/\/ If regions is presected, we know mode()->is_generational() and region->age() >= InitialTenuringThreshold)\n-\n-          \/\/ TODO: Deprecate and\/or refine ShenandoahTenuredRegionUsageBias.  If we preselect the regions, we can just\n-          \/\/ set garbage to \"max\" value, which is the region size rather than doing this extra work to bias selection.\n-          \/\/ May also want to exercise more discretion in select_aged_regions() if we decide there are good reasons\n-          \/\/ to not promote all eligible aged regions on the current GC pass.\n-\n-          \/\/ If we're at tenure age, bias at least once.\n-          for (uint j = region->age() + 1 - InitialTenuringThreshold; j > 0; j--) {\n-            garbage = (garbage + ShenandoahTenuredRegionUsageBias) * ShenandoahTenuredRegionUsageBias;\n-          }\n+        if (is_generational && collection_set->is_preselected(i)) {\n+          \/\/ If region is preselected, we know mode()->is_generational() and region->age() >= InitialTenuringThreshold)\n+          garbage = ShenandoahHeapRegion::region_size_bytes();\n@@ -207,1 +199,1 @@\n-\n+  \n@@ -209,1 +201,0 @@\n-\n@@ -212,8 +203,1 @@\n-\n-      \/\/ We can shrink old_evac_reserve() if the chosen collection set is smaller than maximum allowed.\n-      size_t bytes_reserved_for_old_evacuation = collection_set->get_old_bytes_reserved_for_evacuation();\n-      if (bytes_reserved_for_old_evacuation * ShenandoahEvacWaste < heap->get_old_evac_reserve()) {\n-        size_t old_evac_reserve = (size_t) (bytes_reserved_for_old_evacuation * ShenandoahEvacWaste);\n-        heap->set_old_evac_reserve(old_evac_reserve);\n-      }\n-    }\n+    } \n@@ -222,0 +206,1 @@\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.cpp","additions":9,"deletions":24,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -61,1 +61,0 @@\n-\n@@ -77,4 +76,5 @@\n-    if (r->get_live_data_bytes() <= remaining_old_evacuation_budget) {\n-      \/\/ Decrement remaining evacuation budget by bytes that will be copied.  If the cumulative loss of free memory from\n-      \/\/ regions that are to be collected exceeds excess_old_capacity_for_evacuation,  decrease\n-      \/\/ remaining_old_evacuation_budget by this loss as well.\n+\n+    \/\/ It's probably overkill to compensate with lost_evacuation_capacity.  But it's the safe thing to do and\n+    \/\/  has minimal impact on content of primed collection set.\n+    if (r->get_live_data_bytes() + lost_evacuation_capacity <= remaining_old_evacuation_budget) {\n+      \/\/ Decrement remaining evacuation budget by bytes that will be copied.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -757,1 +757,1 @@\n-        log_info(gc, ergo)(\"After generational memory budget adjustments, old avaiable: \" SIZE_FORMAT\n+        log_info(gc, ergo)(\"After generational memory budget adjustments, old available: \" SIZE_FORMAT\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -471,1 +471,0 @@\n-\n@@ -581,1 +580,6 @@\n-    size_t old_reserve = (_heap->old_generation()->max_capacity() \/ 100) * ShenandoahOldEvacReserve;\n+    \/\/ Note that all allocations performed from old-gen are performed by GC, generally using PLABs for both\n+    \/\/ promotions and evacuations.  The partition between which old memory is reserved for evacuation and\n+    \/\/ which is reserved for promotion is enforced using thread-local variables that prescribe intentons within\n+    \/\/ each PLAB.  We do not reserve any of old-gen memory in order to facilitate the loaning of old-gen memory\n+    \/\/ to young-gen purposes.\n+    size_t old_reserve = 0;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -224,1 +224,2 @@\n-void ShenandoahGeneration::compute_evacuation_budgets(ShenandoahHeap* heap, ShenandoahCollectionSet* collection_set,\n+void ShenandoahGeneration::compute_evacuation_budgets(ShenandoahHeap* heap, bool* preselected_regions,\n+                                                      ShenandoahCollectionSet* collection_set,\n@@ -238,1 +239,0 @@\n-    bool preselected_regions[num_regions];\n@@ -255,0 +255,1 @@\n+    size_t young_evac_reserve_max = 0;\n@@ -271,1 +272,1 @@\n-      size_t young_evac_reserve_max =\n+      young_evac_reserve_max =\n@@ -382,0 +383,1 @@\n+\n@@ -394,0 +396,2 @@\n+        \/\/ In this case, there's no memory available for new allocations while evacuating and updating, unless we\n+        \/\/ find more old-gen memory to borrow below.\n@@ -424,2 +428,2 @@\n-    size_t old_evacuation_committed = (size_t) (ShenandoahEvacWaste *\n-                                                collection_set->get_old_bytes_reserved_for_evacuation());\n+    size_t old_evacuated = collection_set->get_old_bytes_reserved_for_evacuation();\n+    size_t old_evacuated_committed = (size_t) (ShenandoahEvacWaste * old_evacuated);\n@@ -427,2 +431,12 @@\n-    size_t immediate_garbage_regions = collection_set->get_immediate_trash() \/ region_size_bytes;\n-\n+    \/\/ Immediate garbage found during choose_collection_set() is all young\n+    size_t immediate_garbage = collection_set->get_immediate_trash();\n+    size_t old_available = old_generation->available();\n+    size_t young_available = young_generation->available() + immediate_garbage;\n+\n+    assert(consumed_by_advance_promotion >= collection_set->get_young_bytes_to_be_promoted() * ShenandoahEvacWaste,\n+           \"Advance promotion should be at least young_bytes_to_be_promoted * ShenandoahEvacWaste\");\n+\n+    assert(consumed_by_advance_promotion <= (collection_set->get_young_bytes_to_be_promoted() * ShenandoahEvacWaste * 33) \/ 32,\n+           \"Round-off errors should be less than 3.125%%, consumed by advance: \" SIZE_FORMAT \", promoted: \" SIZE_FORMAT,\n+           consumed_by_advance_promotion, (size_t) (collection_set->get_young_bytes_to_be_promoted() * ShenandoahEvacWaste));\n+  \n@@ -430,1 +444,1 @@\n-    if (old_evacuation_committed > old_evacuation_reserve) {\n+    if (old_evacuated_committed > old_evacuation_reserve) {\n@@ -432,2 +446,8 @@\n-      assert(old_evacuation_committed < (33 * old_evacuation_reserve) \/ 32, \"Round-off errors should be less than 3.125%%\");\n-      old_evacuation_committed = old_evacuation_reserve;\n+      assert(old_evacuated_committed <= (33 * old_evacuation_reserve) \/ 32,\n+             \"Round-off errors should be less than 3.125%%, committed: \" SIZE_FORMAT \", reserved: \" SIZE_FORMAT,\n+             old_evacuated_committed, old_evacuation_reserve);\n+      old_evacuated_committed = old_evacuation_reserve;\n+    } else if (old_evacuated_committed < old_evacuation_reserve) {\n+      \/\/ This may happen if the old-gen collection consumes less than full budget.\n+      old_evacuation_reserve = old_evacuated_committed;\n+      heap->set_old_evac_reserve(old_evacuation_reserve);\n@@ -438,4 +458,7 @@\n-    size_t young_evacuation_reserve_used =\n-      collection_set->get_young_bytes_reserved_for_evacuation() - collection_set->get_young_bytes_to_be_promoted();\n-    young_evacuation_reserve_used = (size_t) (ShenandoahEvacWaste * young_evacuation_reserve_used);\n-    heap->set_young_evac_reserve(young_evacuation_reserve_used);\n+    size_t young_promoted = collection_set->get_young_bytes_to_be_promoted();\n+    size_t young_promoted_reserve_used = (size_t) (ShenandoahEvacWaste * young_promoted);\n+\n+    size_t young_evacuated = collection_set->get_young_bytes_reserved_for_evacuation() - young_promoted;\n+    size_t young_evacuated_reserve_used = (size_t) (ShenandoahEvacWaste * young_evacuated);\n+\n+    heap->set_young_evac_reserve(young_evacuated_reserve_used);\n@@ -444,2 +467,2 @@\n-    if (young_evacuation_reserve_used > young_generation->available()) {\n-      size_t short_fall = young_evacuation_reserve_used - young_generation->available();\n+    if (young_evacuated_reserve_used > young_available) {\n+      size_t short_fall = young_evacuated_reserve_used - young_available;\n@@ -462,2 +485,4 @@\n-    size_t old_bytes_loaned = old_regions_loaned_for_young_evac * region_size_bytes;\n-    \/\/ Need to enforce that old_evacuation_committed + old_bytes_loaned >= minimum_evacuation_reserve\n+    size_t old_bytes_loaned_for_young_evac = old_regions_loaned_for_young_evac * region_size_bytes;\n+    size_t old_bytes_reserved_for_alloc_supplement = 0;\n+    size_t old_regions_reserved_for_alloc_supplement = 0;\n+    \/\/ Need to enforce that old_evacuated_committed + old_bytes_loaned_for_young_evac >= minimum_evacuation_reserve\n@@ -465,5 +490,13 @@\n-    if (old_evacuation_committed + old_bytes_loaned < minimum_evacuation_reserve) {\n-      \/\/ Pretend the old_evacuation_commitment is larger than what will be evacuated to assure that promotions\n-      \/\/ do not fill the minimum_evacuation_reserve.  Note that regions loaned from old-gen will be returned\n-      \/\/ to old-gen before we start a subsequent evacuation.\n-      old_evacuation_committed = minimum_evacuation_reserve - old_bytes_loaned;\n+    if (old_evacuated_committed + old_bytes_loaned_for_young_evac < minimum_evacuation_reserve) {\n+      \/\/ Reserve some of the regions available to loan for use as allocation supplement to assure memory not consumed by promotion\n+      size_t excess_bytes = minimum_evacuation_reserve - (old_evacuated_committed + old_bytes_loaned_for_young_evac);\n+      size_t excess_regions = (excess_bytes - 1 + region_size_bytes) \/ region_size_bytes;\n+      if (regions_available_to_loan <= excess_regions) {\n+        excess_regions = regions_available_to_loan;\n+        \/\/ Since we can't reserve entire excess for alloc supplement, pretend more is consumed by old-evacuation\n+        old_evacuated_committed =\n+          minimum_evacuation_reserve - old_bytes_loaned_for_young_evac - excess_regions * region_size_bytes;\n+      }\n+      regions_available_to_loan -= excess_regions;\n+      old_bytes_reserved_for_alloc_supplement = excess_regions * region_size_bytes;\n+      old_regions_reserved_for_alloc_supplement = excess_regions;\n@@ -477,1 +510,1 @@\n-    \/\/  1. old_gen->available - (old_evacuation_committed + old_bytes_loaned + consumed_by_advance_promotion)\n+    \/\/  1. old_gen->available - (old_evacuation_committed + old_bytes_loaned_for_young_evac + consumed_by_advance_promotion)\n@@ -480,3 +513,4 @@\n-    assert(old_generation->available() > old_evacuation_committed, \"Cannot evacuate more than available\");\n-    assert(old_generation->available() > old_evacuation_committed + old_bytes_loaned, \"Cannot loan more than available\");\n-    assert(old_generation->available() > old_evacuation_committed + old_bytes_loaned + consumed_by_advance_promotion,\n+    assert(old_available > old_evacuated_committed, \"Cannot evacuate more than available\");\n+    assert(old_available > old_evacuated_committed + old_bytes_loaned_for_young_evac,\n+           \"Cannot loan young evac more than available\");\n+    assert(old_available > old_evacuated_committed + old_bytes_loaned_for_young_evac + consumed_by_advance_promotion,\n@@ -484,0 +518,3 @@\n+    assert(old_available > (old_evacuated_committed + old_bytes_loaned_for_young_evac +\n+                                          consumed_by_advance_promotion + old_bytes_reserved_for_alloc_supplement),\n+           \"Cannot loan for alloc supplement more than available\");\n@@ -485,2 +522,2 @@\n-    size_t old_avail = old_generation->available();\n-    size_t promotion_reserve = old_avail - (old_evacuation_committed + consumed_by_advance_promotion + old_bytes_loaned);\n+    size_t promotion_reserve = old_available - (old_evacuated_committed + consumed_by_advance_promotion +\n+                                                old_bytes_loaned_for_young_evac + old_bytes_reserved_for_alloc_supplement);\n@@ -489,1 +526,3 @@\n-    \/\/ but this constraint was too limiting, resulting in failure of legitimate promotions.\n+    \/\/ but this constraint was too limiting, resulting in failure of legitimate promotions.  This was tried before we \n+    \/\/ had special handling in place for advance promotion.  We should retry now that advance promotion is handled\n+    \/\/ specially.\n@@ -499,3 +538,4 @@\n-    young_evacuation_reserve_used -= consumed_by_advance_promotion;\n-    if (young_evacuation_reserve_used < promotion_reserve) {\n-      \/\/ Shrink promotion_reserve if its larger than the memory to be consumed by evacuating all young objects in\n+\n+    \/\/ young_evacuation_reserve_used already excludes bytes known to be promoted, which equals consumed_by_advance_promotion\n+    if (young_evacuated_reserve_used < promotion_reserve) {\n+      \/\/ Shrink promotion_reserve if it is larger than the memory to be consumed by evacuating all young objects in\n@@ -503,1 +543,2 @@\n-      promotion_reserve = young_evacuation_reserve_used;\n+      \/\/ young_evacuation_reserve_used does not include live memory within tenure-aged regions.\n+      promotion_reserve = young_evacuated_reserve_used;\n@@ -506,1 +547,2 @@\n-    assert(old_avail >= promotion_reserve + old_evacuation_committed + old_bytes_loaned + consumed_by_advance_promotion,\n+    assert(old_available >= (promotion_reserve + old_evacuated_committed + old_bytes_loaned_for_young_evac +\n+                             consumed_by_advance_promotion + old_bytes_reserved_for_alloc_supplement),\n@@ -508,4 +550,6 @@\n-    log_info(gc, ergo)(\"Old available: \" SIZE_FORMAT \", Original promotion reserve: \" SIZE_FORMAT \", Old evacuation reserve: \"\n-                       SIZE_FORMAT \", Advance promotion reserve supplement: \" SIZE_FORMAT \", Old loaned to young: \" SIZE_FORMAT,\n-                       old_avail, promotion_reserve, old_evacuation_committed, consumed_by_advance_promotion,\n-                       old_regions_loaned_for_young_evac * region_size_bytes);\n+    log_debug(gc)(\"Old available: \" SIZE_FORMAT \", Original promotion reserve: \" SIZE_FORMAT \", Old evacuation reserve: \"\n+                  SIZE_FORMAT \", Advance promotion reserve supplement: \" SIZE_FORMAT\n+                  \", Old loaned for young evacuation: \" SIZE_FORMAT \", Old reserved for alloc supplement: \" SIZE_FORMAT,\n+                  old_available, promotion_reserve, old_evacuated_committed, consumed_by_advance_promotion,\n+                  old_regions_loaned_for_young_evac * region_size_bytes, old_bytes_reserved_for_alloc_supplement);\n+\n@@ -531,1 +575,1 @@\n-    \/\/        (promotion_reserve + old_evacuation_commitment + old_bytes_loaned)\n+    \/\/        (promotion_reserve + old_evacuation_commitment + old_bytes_loaned_for_young_evac)\n@@ -536,0 +580,3 @@\n+    \/\/ Regardless of how many regions may be available to be loaned, we can loan no more regions than\n+    \/\/ the total number of young regions to be evacuated.  Call this the regions_for_runway.\n+\n@@ -538,3 +585,10 @@\n-    if (young_regions_evacuated > old_regions_loaned_for_young_evac) {\n-      regions_for_runway = young_regions_evacuated - old_regions_loaned_for_young_evac;\n-      old_regions_loaned_for_young_evac = young_regions_evacuated;\n+    size_t already_loaned_regions = old_regions_loaned_for_young_evac + old_regions_reserved_for_alloc_supplement;\n+    if (already_loaned_regions == 0) {\n+      regions_for_runway = young_regions_evacuated;\n+    } else if (young_regions_evacuated > already_loaned_regions) {\n+      regions_for_runway = young_regions_evacuated - already_loaned_regions;\n+    } else {\n+      regions_for_runway = 0;\n+    }\n+\n+    if (regions_available_to_loan > regions_for_runway) {\n@@ -542,0 +596,3 @@\n+    } else {\n+      regions_for_runway = regions_available_to_loan;\n+      regions_available_to_loan = 0;\n@@ -544,1 +601,1 @@\n-    size_t allocation_supplement = regions_for_runway * region_size_bytes;\n+    size_t allocation_supplement = regions_for_runway * region_size_bytes + old_bytes_reserved_for_alloc_supplement;\n@@ -547,4 +604,0 @@\n-    size_t promotion_budget = heap->get_promoted_reserve();\n-    size_t old_evac_budget = heap->get_old_evac_reserve();\n-    size_t alloc_budget_evac_and_update = allocation_supplement + young_generation->available();\n-\n@@ -555,10 +608,34 @@\n-    log_info(gc, ergo)(\"Memory reserved for evacuation and update-refs includes promotion budget: \" SIZE_FORMAT\n-                       \"%s, young evacuation budget: \" SIZE_FORMAT \"%s, old evacuation budget: \" SIZE_FORMAT\n-                       \"%s, empty-region allocation budget: \" SIZE_FORMAT \"%s, including supplement: \" SIZE_FORMAT \"%s\",\n-                       byte_size_in_proper_unit(promotion_budget), proper_unit_for_byte_size(promotion_budget),\n-                       byte_size_in_proper_unit(young_evacuation_reserve_used),\n-                       proper_unit_for_byte_size(young_evacuation_reserve_used),\n-                       byte_size_in_proper_unit(old_evac_budget), proper_unit_for_byte_size(old_evac_budget),\n-                       byte_size_in_proper_unit(alloc_budget_evac_and_update),\n-                       proper_unit_for_byte_size(alloc_budget_evac_and_update),\n-                       byte_size_in_proper_unit(allocation_supplement), proper_unit_for_byte_size(allocation_supplement));\n+    log_debug(gc)(\"Memory reserved for young evacuation: \" SIZE_FORMAT \"%s for evacuating \" SIZE_FORMAT\n+                  \"%s out of young available: \" SIZE_FORMAT \"%s\",\n+                  byte_size_in_proper_unit(young_evacuated_reserve_used),\n+                  proper_unit_for_byte_size(young_evacuated_reserve_used),\n+                  byte_size_in_proper_unit(young_evacuated), proper_unit_for_byte_size(young_evacuated),\n+                  byte_size_in_proper_unit(young_available), proper_unit_for_byte_size(young_available));\n+  \n+    log_debug(gc)(\"Memory reserved for old evacuation: \" SIZE_FORMAT \"%s for evacuating \" SIZE_FORMAT\n+                  \"%s out of old available: \" SIZE_FORMAT \"%s\",\n+                  byte_size_in_proper_unit(old_evacuated), proper_unit_for_byte_size(old_evacuated),\n+                  byte_size_in_proper_unit(old_evacuated), proper_unit_for_byte_size(old_evacuated),\n+                  byte_size_in_proper_unit(old_available), proper_unit_for_byte_size(old_available));\n+\n+    assert(old_available > old_evacuation_reserve + promotion_reserve + old_bytes_loaned_for_young_evac + allocation_supplement,\n+           \"old_available must be larger than accumulated reserves\");\n+\n+    size_t regular_promotion = promotion_reserve - consumed_by_advance_promotion;\n+    size_t excess =\n+      old_available - (old_evacuation_reserve + promotion_reserve + old_bytes_loaned_for_young_evac + allocation_supplement);\n+    log_info(gc, ergo)(\"Old available: \" SIZE_FORMAT \"%s is partitioned into old evacuation budget: \" SIZE_FORMAT\n+                       \"%s, aged region promotion budget: \" SIZE_FORMAT\n+                       \"%s, regular region promotion budget: \" SIZE_FORMAT\n+                       \"%s, loaned for young evacuation: \" SIZE_FORMAT\n+                       \"%s, loaned for young allocations: \" SIZE_FORMAT\n+                       \"%s, excess: \" SIZE_FORMAT \"%s\",\n+                       byte_size_in_proper_unit(old_available), proper_unit_for_byte_size(old_available),\n+                       byte_size_in_proper_unit(old_evacuation_reserve), proper_unit_for_byte_size(old_evacuation_reserve),\n+                       byte_size_in_proper_unit(consumed_by_advance_promotion),\n+                       proper_unit_for_byte_size(consumed_by_advance_promotion),\n+                       byte_size_in_proper_unit(regular_promotion), proper_unit_for_byte_size(regular_promotion),\n+                       byte_size_in_proper_unit(old_bytes_loaned_for_young_evac),\n+                       proper_unit_for_byte_size(old_bytes_loaned_for_young_evac),\n+                       byte_size_in_proper_unit(allocation_supplement), proper_unit_for_byte_size(allocation_supplement),\n+                       byte_size_in_proper_unit(excess), proper_unit_for_byte_size(excess));\n@@ -593,0 +670,5 @@\n+    bool* preselected_regions = nullptr;\n+    if (heap->mode()->is_generational()) {\n+      preselected_regions = (bool*) alloca(heap->num_regions() * sizeof(bool));\n+    }\n+\n@@ -595,0 +677,1 @@\n+\n@@ -606,5 +689,8 @@\n-    compute_evacuation_budgets(heap, collection_set, old_regions_loaned_for_young_evac, regions_available_to_loan,\n-                               minimum_evacuation_reserve, consumed_by_advance_promotion);\n-    _heuristics->choose_collection_set(heap->collection_set(), heap->old_heuristics());\n-    adjust_evacuation_budgets(heap, collection_set, old_regions_loaned_for_young_evac, regions_available_to_loan,\n-                              minimum_evacuation_reserve, consumed_by_advance_promotion);\n+    compute_evacuation_budgets(heap, preselected_regions, collection_set, old_regions_loaned_for_young_evac,\n+                               regions_available_to_loan, minimum_evacuation_reserve, consumed_by_advance_promotion);\n+    _heuristics->choose_collection_set(collection_set, heap->old_heuristics());\n+    if (!collection_set->is_empty()) {\n+      adjust_evacuation_budgets(heap, collection_set, old_regions_loaned_for_young_evac, regions_available_to_loan,\n+                                minimum_evacuation_reserve, consumed_by_advance_promotion);\n+    }\n+    \/\/ otherwise, this is an abbreviated cycle and we make no use of evacuation budgets.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":149,"deletions":63,"binary":false,"changes":212,"status":"modified"},{"patch":"@@ -115,1 +115,1 @@\n-  void compute_evacuation_budgets(ShenandoahHeap* heap, ShenandoahCollectionSet* collection_set,\n+  void compute_evacuation_budgets(ShenandoahHeap* heap, bool* preselected_regions, ShenandoahCollectionSet* collection_set, \n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -660,9 +660,11 @@\n-  if (FLAG_IS_CMDLINE(NewSize) && !FLAG_IS_CMDLINE(MaxNewSize) && !FLAG_IS_CMDLINE(NewRatio)) {\n-    capacity = MIN2(NewSize, capacity);\n-  } else {\n-    capacity \/= NewRatio + 1;\n-    if (FLAG_IS_CMDLINE(NewSize)) {\n-      capacity = MAX2(NewSize, capacity);\n-    }\n-    if (FLAG_IS_CMDLINE(MaxNewSize)) {\n-      capacity = MIN2(MaxNewSize, capacity);\n+  if (strcmp(ShenandoahGCMode, \"generational\") == 0) {\n+    if (FLAG_IS_CMDLINE(NewSize) && !FLAG_IS_CMDLINE(MaxNewSize) && !FLAG_IS_CMDLINE(NewRatio)) {\n+      capacity = MIN2(NewSize, capacity);\n+    } else {\n+      capacity \/= NewRatio + 1;\n+      if (FLAG_IS_CMDLINE(NewSize)) {\n+        capacity = MAX2(NewSize, capacity);\n+      }\n+      if (FLAG_IS_CMDLINE(MaxNewSize)) {\n+        capacity = MIN2(MaxNewSize, capacity);\n+      }\n@@ -671,0 +673,1 @@\n+  \/\/ else, make no adjustment to global capacity\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -540,1 +540,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahReferenceProcessor.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -104,0 +104,9 @@\n+  product(uintx, ShenandoahIgnoreGarbageThreshold, 5, EXPERIMENTAL,         \\\n+          \"When less than this amount of garbage (as a percentage of \"      \\\n+          \"region size) exists within a region, the region will not be \"    \\\n+          \"added to the collection set, even when the heuristic has \"       \\\n+          \"chosen to aggressively add regions with less than \"              \\\n+          \"ShenandoahGarbageThreshold amount of garbage into the \"          \\\n+          \"collection set.\")                                                \\\n+          range(0,100)                                                      \\\n+                                                                            \\\n@@ -494,16 +503,0 @@\n-  product(uintx, ShenandoahTenuredRegionUsageBias, 16, EXPERIMENTAL,        \\\n-          \"The collection set is comprised of heap regions that contain \"   \\\n-          \"the greatest amount of garbage.  \"                               \\\n-          \"For purposes of selecting regions to be included in the \"        \\\n-          \"collection set, regions that have reached the tenure age will \"  \\\n-          \"be treated as if their contained garbage is the contained \"      \\\n-          \"garbage multiplied by ShenandoahTenuredRegionUsageBias as \"      \\\n-          \"many times as the age of the region meets or exceeds \"           \\\n-          \"tenure age.  For example, if tenure age is 7, \"                  \\\n-          \"the region age is 9, ShenandoahTenuredRegionUsageBias is \"       \\\n-          \"16, and the region is 12.5% garbage, this region \"               \\\n-          \"will by treated as if its garbage content is \"                   \\\n-          \"12.5% * 16 * 16 * 16 = 51,200% when comparing this region \"      \\\n-          \" to untenured regions.\")                                         \\\n-          range(1,128)                                                      \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoah_globals.hpp","additions":9,"deletions":16,"binary":false,"changes":25,"status":"modified"}]}