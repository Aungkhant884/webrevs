{"files":[{"patch":"@@ -206,0 +206,1 @@\n+  collection_set->set_immediate_trash(immediate_garbage);\n@@ -212,0 +213,1 @@\n+      \/\/ We can shrink old_evac_reserve() if the chosen collection set is smaller than maximum allowed.\n@@ -220,86 +222,0 @@\n-    ShenandoahYoungGeneration* young_generation = heap->young_generation();\n-    size_t young_evacuation_reserve = (young_generation->soft_max_capacity() * ShenandoahEvacReserve) \/ 100;\n-\n-    \/\/ At this point, young_generation->available() does not know about recently discovered immediate garbage.\n-    \/\/ What memory it does think to be available is not entirely trustworthy because any available memory associated\n-    \/\/ with a region that is placed into the collection set becomes unavailable when the region is chosen\n-    \/\/ for the collection set.  We'll compute an approximation of young available.  If young_available is zero,\n-    \/\/ we'll need to borrow from old-gen in order to evacuate.  If there's nothing to borrow, we're going to\n-    \/\/ degenerate to full GC.\n-\n-    \/\/ TODO: young_available can include available (between top() and end()) within each young region that is not\n-    \/\/ part of the collection set.  Making this memory available to the young_evacuation_reserve allows a larger\n-    \/\/ young collection set to be chosen when available memory is under extreme pressure.  Implementing this \"improvement\"\n-    \/\/ is tricky, because the incremental construction of the collection set actually changes the amount of memory\n-    \/\/ available to hold evacuated young-gen objects.  As currently implemented, the memory that is available within\n-    \/\/ non-empty regions that are not selected as part of the collection set can be allocated by the mutator while\n-    \/\/ GC is evacuating and updating references.\n-\n-    size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n-    size_t free_affiliated_regions = immediate_regions + free_regions;\n-    size_t young_available = (free_affiliated_regions + young_generation->free_unaffiliated_regions()) * region_size_bytes;\n-\n-    size_t regions_available_to_loan = 0;\n-\n-    if (heap->mode()->is_generational()) {\n-      \/\/  Now that we've primed the collection set, we can figure out how much memory to reserve for evacuation\n-      \/\/  of young-gen objects.\n-      \/\/\n-      \/\/  YoungEvacuationReserve for young generation: how much memory are we reserving to hold the results\n-      \/\/     of evacuating young collection set regions?  This is typically smaller than the total amount\n-      \/\/     of available memory, and is also smaller than the total amount of marked live memory within\n-      \/\/     young-gen.  This value is the minimum of:\n-      \/\/       1. young_gen->available() + (old_gen->available - (OldEvacuationReserve + PromotionReserve))\n-      \/\/       2. young_gen->capacity() * ShenandoahEvacReserve\n-      \/\/\n-      \/\/     Note that any region added to the collection set will be completely evacuated and its memory will\n-      \/\/     be completely recycled at the end of GC.  The recycled memory will be at least as great as the\n-      \/\/     memory borrowed from old-gen.  Enforce that the amount borrowed from old-gen for YoungEvacuationReserve\n-      \/\/     is an integral number of entire heap regions.\n-      \/\/\n-      young_evacuation_reserve -= heap->get_old_evac_reserve();\n-\n-      \/\/ Though we cannot know the evacuation_supplement until after we have computed the collection set, we do\n-      \/\/ know that every young-gen region added to the collection set will have a net positive impact on available\n-      \/\/ memory within young-gen, since each contributes a positive amount of garbage to available.  Thus, even\n-      \/\/ without knowing the exact composition of the collection set, we can allow young_evacuation_reserve to\n-      \/\/ exceed young_available if there are empty regions available within old-gen to hold the results of evacuation.\n-\n-      ShenandoahGeneration* old_generation = heap->old_generation();\n-\n-      \/\/ Not all of what is currently available within young-gen can be reserved to hold the results of young-gen\n-      \/\/ evacuation.  This is because memory available within any heap region that is placed into the collection set\n-      \/\/ is not available to be allocated during evacuation.  To be safe, we assure that all memory required for evacuation\n-      \/\/ is available within \"virgin\" heap regions.\n-\n-      const size_t available_young_regions = free_regions + immediate_regions + young_generation->free_unaffiliated_regions();\n-      const size_t available_old_regions = old_generation->free_unaffiliated_regions();\n-      size_t already_reserved_old_bytes = heap->get_old_evac_reserve() + heap->get_promoted_reserve();\n-      size_t regions_reserved_for_evac_and_promotion = (already_reserved_old_bytes + region_size_bytes - 1) \/ region_size_bytes;\n-      regions_available_to_loan = available_old_regions - regions_reserved_for_evac_and_promotion;\n-\n-      if (available_young_regions * region_size_bytes < young_evacuation_reserve) {\n-        \/\/ Try to borrow old-gen regions in order to avoid shrinking young_evacuation_reserve\n-        size_t loan_request = young_evacuation_reserve - available_young_regions * region_size_bytes;\n-        size_t loaned_region_request = (loan_request + region_size_bytes - 1) \/ region_size_bytes;\n-        if (loaned_region_request > regions_available_to_loan) {\n-          \/\/ Scale back young_evacuation_reserve to consume all available young and old regions.  After the\n-          \/\/ collection set is chosen, we may get some of this memory back for pacing allocations during evacuation\n-          \/\/ and update refs.\n-          loaned_region_request = regions_available_to_loan;\n-          young_evacuation_reserve = (available_young_regions + loaned_region_request) * region_size_bytes;\n-        } else {\n-          \/\/ No need to scale back young_evacuation_reserve.\n-        }\n-      } else {\n-        \/\/ No need scale back young_evacuation_reserve and no need to borrow from old-gen.  We may even have some\n-        \/\/ available_young_regions to support allocation pacing.\n-      }\n-\n-    } else if (young_evacuation_reserve > young_available) {\n-      \/\/ In non-generational mode, there's no old-gen memory to borrow from\n-      young_evacuation_reserve = young_available;\n-    }\n-\n-    heap->set_young_evac_reserve(young_evacuation_reserve);\n-\n@@ -309,49 +225,0 @@\n-\n-    \/\/ Now compute the evacuation supplement, which is extra memory borrowed from old-gen that can be allocated\n-    \/\/ by mutators while GC is working on evacuation and update-refs.\n-\n-    \/\/ During evacuation and update refs, we will be able to allocate any memory that is currently available\n-    \/\/ plus any memory that can be borrowed on the collateral of the current collection set, reserving a certain\n-    \/\/ percentage of the anticipated replenishment from collection set memory to be allocated during the subsequent\n-    \/\/ concurrent marking effort.  This is how much I can repay.\n-    size_t potential_supplement_regions = collection_set->get_young_region_count();\n-\n-    \/\/ Though I can repay potential_supplement_regions, I can't borrow them unless they are available in old-gen.\n-    if (potential_supplement_regions > regions_available_to_loan) {\n-      potential_supplement_regions = regions_available_to_loan;\n-    }\n-\n-    size_t potential_evac_supplement;\n-\n-    \/\/ How much of the potential_supplement_regions will be consumed by young_evacuation_reserve: borrowed_evac_regions.\n-    const size_t available_unaffiliated_young_regions = young_generation->free_unaffiliated_regions();\n-    const size_t available_affiliated_regions = free_regions + immediate_regions;\n-    const size_t available_young_regions = available_unaffiliated_young_regions + available_affiliated_regions;\n-    size_t young_evac_regions = (young_evacuation_reserve + region_size_bytes - 1) \/ region_size_bytes;\n-    size_t borrowed_evac_regions = (young_evac_regions > available_young_regions)? young_evac_regions - available_young_regions: 0;\n-\n-    potential_supplement_regions -= borrowed_evac_regions;\n-    potential_evac_supplement = potential_supplement_regions * region_size_bytes;\n-\n-    \/\/ Leave some allocation runway for subsequent concurrent mark phase.\n-    potential_evac_supplement = (potential_evac_supplement * ShenandoahBorrowPercent) \/ 100;\n-\n-    heap->set_alloc_supplement_reserve(potential_evac_supplement);\n-\n-    size_t promotion_budget = heap->get_promoted_reserve();\n-    size_t old_evac_budget = heap->get_old_evac_reserve();\n-    size_t alloc_budget_evac_and_update = potential_evac_supplement + young_available;\n-\n-    \/\/ TODO: young_available, which feeds into alloc_budget_evac_and_update is lacking memory available within\n-    \/\/ existing young-gen regions that were not selected for the collection set.  Add this in and adjust the\n-    \/\/ log message (where it says \"empty-region allocation budget\").\n-\n-    log_info(gc, ergo)(\"Memory reserved for evacuation and update-refs includes promotion budget: \" SIZE_FORMAT\n-                       \"%s, young evacuation budget: \" SIZE_FORMAT \"%s, old evacuation budget: \" SIZE_FORMAT\n-                       \"%s, empty-region allocation budget: \" SIZE_FORMAT \"%s, including supplement: \" SIZE_FORMAT \"%s\",\n-                       byte_size_in_proper_unit(promotion_budget), proper_unit_for_byte_size(promotion_budget),\n-                       byte_size_in_proper_unit(young_evacuation_reserve), proper_unit_for_byte_size(young_evacuation_reserve),\n-                       byte_size_in_proper_unit(old_evac_budget), proper_unit_for_byte_size(old_evac_budget),\n-                       byte_size_in_proper_unit(alloc_budget_evac_and_update),\n-                       proper_unit_for_byte_size(alloc_budget_evac_and_update),\n-                       byte_size_in_proper_unit(potential_evac_supplement), proper_unit_for_byte_size(potential_evac_supplement));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.cpp","additions":2,"deletions":135,"binary":false,"changes":137,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+  size_t collected_old_bytes = 0;\n@@ -55,41 +56,0 @@\n-  \/\/ TODO:\n-  \/\/ The max_old_evacuation_bytes and promotion_budget_bytes constants represent a first\n-  \/\/ approximation to desired operating parameters.  Eventually, these values should be determined\n-  \/\/ by heuristics and should adjust dynamically based on most current execution behavior.  In the\n-  \/\/ interim, we offer command-line options to set the values of these configuration parameters.\n-\n-  \/\/ max_old_evacuation_bytes represents a bound on how much evacuation effort is dedicated\n-  \/\/ to old-gen regions.\n-  size_t max_old_evacuation_bytes = (heap->old_generation()->soft_max_capacity() * ShenandoahOldEvacReserve) \/ 100;\n-  const size_t young_evacuation_bytes = (heap->young_generation()->soft_max_capacity() * ShenandoahEvacReserve) \/ 100;\n-  const size_t ratio_bound_on_old_evac_bytes = (young_evacuation_bytes * ShenandoahOldEvacRatioPercent) \/ 100;\n-  if (max_old_evacuation_bytes > ratio_bound_on_old_evac_bytes) {\n-    max_old_evacuation_bytes = ratio_bound_on_old_evac_bytes;\n-  }\n-\n-  \/\/ Usually, old-evacuation is limited by the CPU bounds on effort.  However, it can also be bounded by available\n-  \/\/ memory within old-gen to hold the results of evacuation.  When we are bound by memory availability, we need\n-  \/\/ to account below for the loss of available memory from within each region that is added to the old-gen collection\n-  \/\/ set.\n-  size_t old_available = heap->old_generation()->available();\n-  size_t excess_old_capacity_for_evacuation;\n-  if (max_old_evacuation_bytes > old_available) {\n-    max_old_evacuation_bytes = old_available;\n-    excess_old_capacity_for_evacuation = 0;\n-  } else {\n-    excess_old_capacity_for_evacuation = old_available - max_old_evacuation_bytes;\n-  }\n-\n-  \/\/ promotion_budget_bytes represents an \"arbitrary\" bound on how many bytes can be consumed by young-gen\n-  \/\/ objects promoted into old-gen memory.  We need to avoid a scenario under which promotion of objects\n-  \/\/ depletes old-gen available memory to the point that there is insufficient memory to hold old-gen objects\n-  \/\/ that need to be evacuated from within the old-gen collection set.\n-  \/\/\n-  \/\/ Key idea: if there is not sufficient memory within old-gen to hold an object that wants to be promoted, defer\n-  \/\/ promotion until a subsequent evacuation pass.  Enforcement is provided at the time PLABs and shared allocations\n-  \/\/ in old-gen memory are requested.\n-\n-  const size_t promotion_budget_bytes = heap->get_promoted_reserve();\n-\n-  \/\/ old_evacuation_budget is an upper bound on the amount of live memory that can be evacuated.\n-  \/\/\n@@ -100,6 +60,1 @@\n-  \/\/ budget is constrained by availability of free memory.  See remaining_old_evacuation_budget below.\n-\n-  size_t old_evacuation_budget = (size_t) (max_old_evacuation_bytes \/ ShenandoahEvacWaste);\n-\n-  log_info(gc)(\"Choose old regions for mixed collection: old evacuation budget: \" SIZE_FORMAT \"%s\",\n-                byte_size_in_proper_unit(old_evacuation_budget), proper_unit_for_byte_size(old_evacuation_budget));\n+  \/\/ budget is constrained by availability of free memory.\n@@ -107,0 +62,1 @@\n+  size_t old_evacuation_budget = (size_t) (heap->get_old_evac_reserve() \/ ShenandoahEvacWaste);\n@@ -109,0 +65,3 @@\n+  log_info(gc)(\"Choose old regions for mixed collection: old evacuation budget: \" SIZE_FORMAT \"%s, candidates: %u\",\n+               byte_size_in_proper_unit(old_evacuation_budget), proper_unit_for_byte_size(old_evacuation_budget),\n+               unprocessed_old_collection_candidates());\n@@ -110,3 +69,2 @@\n-  \/\/ The number of old-gen regions that were selected as candidates for collection at the end of the most recent\n-  \/\/ old-gen concurrent marking phase and have not yet been collected is represented by\n-  \/\/ unprocessed_old_collection_candidates()\n+  \/\/ The number of old-gen regions that were selected as candidates for collection at the end of the most recent old-gen\n+  \/\/ concurrent marking phase and have not yet been collected is represented by unprocessed_old_collection_candidates()\n@@ -117,1 +75,0 @@\n-\n@@ -120,4 +77,1 @@\n-    if ((r->get_live_data_bytes() <= remaining_old_evacuation_budget) &&\n-        ((lost_evacuation_capacity + r->free() <= excess_old_capacity_for_evacuation)\n-         || (r->get_live_data_bytes() + r->free() <= remaining_old_evacuation_budget))) {\n-\n+    if (r->get_live_data_bytes() <= remaining_old_evacuation_budget) {\n@@ -129,10 +83,0 @@\n-      if (lost_evacuation_capacity > excess_old_capacity_for_evacuation) {\n-        \/\/ This is slightly conservative because we really only need to remove from the remaining evacuation budget\n-        \/\/ the amount by which lost_evacution_capacity exceeds excess_old_capacity_for_evacuation, but this is relatively\n-        \/\/ rare event and current thought is to be a bit conservative rather than mess up the math on code that is so\n-        \/\/ difficult to test and maintain...\n-\n-        \/\/ Once we have crossed the threshold of lost_evacuation_capacity exceeding excess_old_capacity_for_evacuation,\n-        \/\/ every subsequent iteration of this loop will further decrease remaining_old_evacuation_budget.\n-        remaining_old_evacuation_budget -= r->free();\n-      }\n@@ -142,0 +86,1 @@\n+      collected_old_bytes += r->garbage();\n@@ -149,2 +94,4 @@\n-    log_info(gc)(\"Old-gen piggyback evac (\" UINT32_FORMAT \" regions, \" SIZE_FORMAT \" %s)\",\n-                 included_old_regions, byte_size_in_proper_unit(evacuated_old_bytes), proper_unit_for_byte_size(evacuated_old_bytes));\n+    log_info(gc)(\"Old-gen piggyback evac (\" UINT32_FORMAT \" regions, evacuating \" SIZE_FORMAT \"%s, reclaiming: \" SIZE_FORMAT \"%s)\",\n+                 included_old_regions,\n+                 byte_size_in_proper_unit(evacuated_old_bytes), proper_unit_for_byte_size(evacuated_old_bytes),\n+                 byte_size_in_proper_unit(collected_old_bytes), proper_unit_for_byte_size(collected_old_bytes));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.cpp","additions":14,"deletions":67,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -224,1 +224,1 @@\n-void  ShenandoahGeneration::prepare_regions_and_collection_set(bool concurrent) {\n+void ShenandoahGeneration::prepare_regions_and_collection_set(bool concurrent) {\n@@ -250,1 +250,1 @@\n-    heap->collection_set()->clear();\n+    collection_set->clear();\n@@ -256,0 +256,1 @@\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -689,0 +689,1 @@\n+  shenandoah_assert_heaplocked();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}