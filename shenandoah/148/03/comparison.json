{"files":[{"patch":"@@ -70,0 +70,2 @@\n+  size_t ignore_threshold = ShenandoahHeapRegion::region_size_bytes() * ShenandoahIgnoreGarbageThreshold \/ 100;\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n@@ -88,18 +90,0 @@\n-  ShenandoahHeap* heap = ShenandoahHeap::heap();\n-  size_t max_cset    = (size_t) (heap->get_young_evac_reserve() \/ ShenandoahEvacWaste);\n-  size_t capacity    = heap->young_generation()->soft_max_capacity();\n-\n-  \/\/ As currently implemented, we are not enforcing that new_garbage > min_garbage\n-  \/\/ size_t free_target = (capacity \/ 100) * ShenandoahMinFreeThreshold + max_cset;\n-  \/\/ size_t min_garbage = (free_target > actual_free ? (free_target - actual_free) : 0);\n-\n-  log_info(gc, ergo)(\"Adaptive CSet Selection. Max CSet: \" SIZE_FORMAT \"%s, Actual Free: \" SIZE_FORMAT \"%s.\",\n-                     byte_size_in_proper_unit(max_cset),    proper_unit_for_byte_size(max_cset),\n-                     byte_size_in_proper_unit(actual_free), proper_unit_for_byte_size(actual_free));\n-\n-  \/\/ Better select garbage-first regions\n-  QuickSort::sort<RegionData>(data, (int)size, compare_by_garbage, false);\n-\n-  size_t cur_cset = 0;\n-  \/\/ size_t cur_garbage = 0;\n-\n@@ -111,7 +95,52 @@\n-  for (size_t idx = 0; idx < size; idx++) {\n-    ShenandoahHeapRegion* r = data[idx]._region;\n-    size_t new_cset;\n-    if (is_generational && (r->age() >= InitialTenuringThreshold)) {\n-      \/\/ Entire region will be promoted, This region does not impact young-gen evacuation reserve.  Memory has already\n-      \/\/ been set aside to hold evacuation results as advance_promotion_reserve.\n-      new_cset = cur_cset;\n+  bool is_global = (_generation->generation_mode() == GLOBAL);\n+  size_t capacity = heap->young_generation()->max_capacity();\n+  size_t cur_young_garbage = 0;\n+\n+  \/\/ Better select garbage-first regions\n+  QuickSort::sort<RegionData>(data, (int)size, compare_by_garbage, false);\n+\n+  if (is_generational) {\n+    if (is_global) {\n+      size_t max_young_cset    = (size_t) (heap->get_young_evac_reserve() \/ ShenandoahEvacWaste);\n+      size_t young_cur_cset = 0;\n+      size_t max_old_cset    = (size_t) (heap->get_old_evac_reserve() \/ ShenandoahEvacWaste);\n+      size_t old_cur_cset = 0;\n+      size_t free_target = (capacity * ShenandoahMinFreeThreshold) \/ 100 + max_young_cset;\n+      size_t min_garbage = (free_target > actual_free) ? (free_target - actual_free) : 0;\n+\n+      log_info(gc, ergo)(\"Adaptive CSet Selection for GLOBAL. Max Young Cset: \" SIZE_FORMAT\n+                         \"%s, Max Old CSet: \" SIZE_FORMAT \"%s, Actual Free: \" SIZE_FORMAT \"%s.\",\n+                         byte_size_in_proper_unit(max_young_cset),    proper_unit_for_byte_size(max_young_cset),\n+                         byte_size_in_proper_unit(max_old_cset),    proper_unit_for_byte_size(max_old_cset),\n+                         byte_size_in_proper_unit(actual_free), proper_unit_for_byte_size(actual_free));\n+\n+      for (size_t idx = 0; idx < size; idx++) {\n+        ShenandoahHeapRegion* r = data[idx]._region;\n+        bool add_region = false;\n+        if (r->is_old()) {\n+          size_t new_cset = old_cur_cset + r->get_live_data_bytes();\n+          if ((new_cset <= max_old_cset) && (r->garbage() > garbage_threshold)) {\n+            add_region = true;\n+            old_cur_cset = new_cset;\n+          }\n+        } else if (r->age() >= InitialTenuringThreshold) {\n+          \/\/ Entire region will be promoted, This region does not impact young-gen or old-gen evacuation reserve.\n+          \/\/ This region has been pre-selected and its impact on promotion reserve is already accounted for.\n+          add_region = true;\n+          cur_young_garbage += r->garbage();\n+        } else {\n+          size_t new_cset = young_cur_cset + r->get_live_data_bytes();\n+          size_t region_garbage = r->garbage();\n+          size_t new_garbage = cur_young_garbage + region_garbage;\n+          bool add_regardless = (region_garbage > ignore_threshold) && (new_garbage < min_garbage);\n+          if ((new_cset <= max_young_cset) && (add_regardless || (region_garbage > garbage_threshold))) {\n+            add_region = true;\n+            young_cur_cset = new_cset;\n+            cur_young_garbage = new_garbage;\n+          }\n+        }\n+\n+        if (add_region) {\n+          cset->add_region(r);\n+        }\n+      }\n@@ -119,1 +148,30 @@\n-      new_cset = cur_cset + r->get_live_data_bytes();\n+      \/\/ This is young-gen collection.\n+      size_t max_cset    = (size_t) (heap->get_young_evac_reserve() \/ ShenandoahEvacWaste);\n+      size_t cur_cset = 0;\n+      size_t free_target = (capacity * ShenandoahMinFreeThreshold) \/ 100 + max_cset;\n+      size_t min_garbage = (free_target > actual_free) ? (free_target - actual_free) : 0;\n+\n+      log_info(gc, ergo)(\"Adaptive CSet Selection for YOUNG. Max CSet: \" SIZE_FORMAT \"%s, Actual Free: \" SIZE_FORMAT \"%s.\",\n+                         byte_size_in_proper_unit(max_cset),    proper_unit_for_byte_size(max_cset),\n+                         byte_size_in_proper_unit(actual_free), proper_unit_for_byte_size(actual_free));\n+\n+      for (size_t idx = 0; idx < size; idx++) {\n+        ShenandoahHeapRegion* r = data[idx]._region;\n+        size_t new_cset;\n+        size_t region_garbage = r->garbage();\n+        size_t new_garbage = cur_young_garbage + region_garbage;\n+        if (r->age() >= InitialTenuringThreshold) {\n+          \/\/ Entire region will be promoted, This region does not impact young-gen evacuation reserve.  Memory has already\n+          \/\/ been set aside to hold evacuation results as advance_promotion_reserve.\n+          new_cset = cur_cset;\n+        } else {\n+          new_cset = cur_cset + r->get_live_data_bytes();\n+        }\n+        bool add_regardless = (region_garbage > ignore_threshold) && (new_garbage < min_garbage);\n+        if ((new_cset <= max_cset) &&\n+            (add_regardless || (region_garbage > garbage_threshold) || (r->age() >= InitialTenuringThreshold))) {\n+          cset->add_region(r);\n+          cur_cset = new_cset;\n+          cur_young_garbage = new_garbage;\n+        }\n+      }\n@@ -121,26 +179,22 @@\n-    \/\/ As currently implemented, we are not enforcing that new_garbage > min_garbage\n-    \/\/ size_t new_garbage = cur_garbage + r->garbage();\n-\n-    \/\/ Note that live data bytes within a region is not the same as heap_region_size - garbage.  This is because\n-    \/\/ each region contains a combination of used memory (which is garbage plus live) and unused memory, which has not\n-    \/\/ yet been allocated.  It may be the case that the region on this iteration has too much live data to be added to\n-    \/\/ the collection set while one or more regions seen on subsequent iterations of this loop can be added to the collection\n-    \/\/ set because they have smaller live memory, even though they also have smaller garbage (and necessarily a larger\n-    \/\/ amount of unallocated memory).\n-\n-    \/\/ BANDAID: In an earlier version of this code, this was written:\n-    \/\/   if ((new_cset <= max_cset) && ((new_garbage < min_garbage) || (r->garbage() > garbage_threshold)))\n-    \/\/ The problem with the original code is that in some cases the collection set would include hundreds of regions,\n-    \/\/ each with less than 100 bytes of garbage.  Evacuating these regions is counterproductive.\n-\n-    \/\/ TODO: Think about changing the description and defaults for ShenandoahGarbageThreshold and ShenandoahMinFreeThreshold.\n-    \/\/ If \"customers\" want to evacuate regions with smaller amounts of garbage contained therein, they should specify a lower\n-    \/\/ value of ShenandoahGarbageThreshold.  As implemented currently, we may experience back-to-back collections if there is\n-    \/\/ not enough memory to be reclaimed.  Let's not let pursuit of min_garbage drive us to make poor decisions.  Maybe we\n-    \/\/ want yet another global parameter to allow a region to be placed into the collection set if\n-    \/\/ (((new_garbage < min_garbage) && (r->garbage() > ShenandoahSmallerGarbageThreshold)) || (r->garbage() > garbage_threshold))\n-\n-    if ((new_cset <= max_cset) && ((r->garbage() > garbage_threshold) || (r->age() >= InitialTenuringThreshold))) {\n-      cset->add_region(r);\n-      cur_cset = new_cset;\n-      \/\/ cur_garbage = new_garbage;\n+  } else {\n+    \/\/ Traditional Shenandoah (non-generational)\n+    size_t max_cset    = (size_t) (heap->get_young_evac_reserve() \/ ShenandoahEvacWaste);\n+    size_t cur_cset = 0;\n+    size_t free_target = (capacity * ShenandoahMinFreeThreshold) \/ 100 + max_cset;\n+    size_t min_garbage = (free_target > actual_free) ? (free_target - actual_free) : 0;\n+\n+    log_info(gc, ergo)(\"Adaptive CSet Selection. Max CSet: \" SIZE_FORMAT \"%s, Actual Free: \" SIZE_FORMAT \"%s.\",\n+                         byte_size_in_proper_unit(max_cset),    proper_unit_for_byte_size(max_cset),\n+                         byte_size_in_proper_unit(actual_free), proper_unit_for_byte_size(actual_free));\n+\n+    for (size_t idx = 0; idx < size; idx++) {\n+      ShenandoahHeapRegion* r = data[idx]._region;\n+      size_t new_cset = cur_cset + r->get_live_data_bytes();\n+      size_t region_garbage = r->garbage();\n+      size_t new_garbage = cur_young_garbage + region_garbage;\n+      bool add_regardless = (region_garbage > ignore_threshold) && (new_garbage < min_garbage);\n+      if ((new_cset <= max_cset) && (add_regardless || (region_garbage > garbage_threshold))) {\n+        cset->add_region(r);\n+        cur_cset = new_cset;\n+        cur_young_garbage = new_garbage;\n+      }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.cpp","additions":106,"deletions":52,"binary":false,"changes":158,"status":"modified"},{"patch":"@@ -92,0 +92,2 @@\n+        \/\/ Note that we keep going even if one region is excluded from selection.  Subsequent regions may be selected\n+        \/\/ if they have smaller live data.\n@@ -100,0 +102,1 @@\n+  bool is_generational = heap->mode()->is_generational();\n@@ -134,1 +137,0 @@\n-\n@@ -146,1 +148,0 @@\n-\n@@ -150,1 +151,1 @@\n-        if (collection_set->is_preselected(i)) {\n+        if (is_generational && collection_set->is_preselected(i)) {\n@@ -152,10 +153,1 @@\n-\n-          \/\/ TODO: Deprecate and\/or refine ShenandoahTenuredRegionUsageBias.  If we preselect the regions, we can just\n-          \/\/ set garbage to \"max\" value, which is the region size rather than doing this extra work to bias selection.\n-          \/\/ May also want to exercise more discretion in select_aged_regions() if we decide there are good reasons\n-          \/\/ to not promote all eligible aged regions on the current GC pass.\n-\n-          \/\/ If we're at tenure age, bias at least once.\n-          for (uint j = region->age() + 1 - InitialTenuringThreshold; j > 0; j--) {\n-            garbage = (garbage + ShenandoahTenuredRegionUsageBias) * ShenandoahTenuredRegionUsageBias;\n-          }\n+          garbage = ShenandoahHeapRegion::region_size_bytes();\n@@ -205,1 +197,2 @@\n-\n+  collection_set->set_immediate_trash(immediate_garbage);\n+  \n@@ -207,1 +200,0 @@\n-\n@@ -210,7 +202,1 @@\n-\n-      size_t bytes_reserved_for_old_evacuation = collection_set->get_old_bytes_reserved_for_evacuation();\n-      if (bytes_reserved_for_old_evacuation * ShenandoahEvacWaste < heap->get_old_evac_reserve()) {\n-        size_t old_evac_reserve = (size_t) (bytes_reserved_for_old_evacuation * ShenandoahEvacWaste);\n-        heap->set_old_evac_reserve(old_evac_reserve);\n-      }\n-    }\n+    } \n@@ -219,85 +205,0 @@\n-    ShenandoahYoungGeneration* young_generation = heap->young_generation();\n-    size_t young_evacuation_reserve = (young_generation->soft_max_capacity() * ShenandoahEvacReserve) \/ 100;\n-\n-    \/\/ At this point, young_generation->available() does not know about recently discovered immediate garbage.\n-    \/\/ What memory it does think to be available is not entirely trustworthy because any available memory associated\n-    \/\/ with a region that is placed into the collection set becomes unavailable when the region is chosen\n-    \/\/ for the collection set.  We'll compute an approximation of young available.  If young_available is zero,\n-    \/\/ we'll need to borrow from old-gen in order to evacuate.  If there's nothing to borrow, we're going to\n-    \/\/ degenerate to full GC.\n-\n-    \/\/ TODO: young_available can include available (between top() and end()) within each young region that is not\n-    \/\/ part of the collection set.  Making this memory available to the young_evacuation_reserve allows a larger\n-    \/\/ young collection set to be chosen when available memory is under extreme pressure.  Implementing this \"improvement\"\n-    \/\/ is tricky, because the incremental construction of the collection set actually changes the amount of memory\n-    \/\/ available to hold evacuated young-gen objects.  As currently implemented, the memory that is available within\n-    \/\/ non-empty regions that are not selected as part of the collection set can be allocated by the mutator while\n-    \/\/ GC is evacuating and updating references.\n-\n-    size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n-    size_t free_affiliated_regions = immediate_regions + free_regions;\n-    size_t young_available = (free_affiliated_regions + young_generation->free_unaffiliated_regions()) * region_size_bytes;\n-\n-    size_t regions_available_to_loan = 0;\n-\n-    if (heap->mode()->is_generational()) {\n-      \/\/  Now that we've primed the collection set, we can figure out how much memory to reserve for evacuation\n-      \/\/  of young-gen objects.\n-      \/\/\n-      \/\/  YoungEvacuationReserve for young generation: how much memory are we reserving to hold the results\n-      \/\/     of evacuating young collection set regions?  This is typically smaller than the total amount\n-      \/\/     of available memory, and is also smaller than the total amount of marked live memory within\n-      \/\/     young-gen.  This value is the minimum of:\n-      \/\/       1. young_gen->available() + (old_gen->available - (OldEvacuationReserve + PromotionReserve))\n-      \/\/       2. young_gen->capacity() * ShenandoahEvacReserve\n-      \/\/\n-      \/\/     Note that any region added to the collection set will be completely evacuated and its memory will\n-      \/\/     be completely recycled at the end of GC.  The recycled memory will be at least as great as the\n-      \/\/     memory borrowed from old-gen.  Enforce that the amount borrowed from old-gen for YoungEvacuationReserve\n-      \/\/     is an integral number of entire heap regions.\n-      \/\/\n-      young_evacuation_reserve -= heap->get_old_evac_reserve();\n-\n-      \/\/ Though we cannot know the evacuation_supplement until after we have computed the collection set, we do\n-      \/\/ know that every young-gen region added to the collection set will have a net positive impact on available\n-      \/\/ memory within young-gen, since each contributes a positive amount of garbage to available.  Thus, even\n-      \/\/ without knowing the exact composition of the collection set, we can allow young_evacuation_reserve to\n-      \/\/ exceed young_available if there are empty regions available within old-gen to hold the results of evacuation.\n-\n-      ShenandoahGeneration* old_generation = heap->old_generation();\n-\n-      \/\/ Not all of what is currently available within young-gen can be reserved to hold the results of young-gen\n-      \/\/ evacuation.  This is because memory available within any heap region that is placed into the collection set\n-      \/\/ is not available to be allocated during evacuation.  To be safe, we assure that all memory required for evacuation\n-      \/\/ is available within \"virgin\" heap regions.\n-\n-      const size_t available_young_regions = free_regions + immediate_regions + young_generation->free_unaffiliated_regions();\n-      const size_t available_old_regions = old_generation->free_unaffiliated_regions();\n-      size_t already_reserved_old_bytes = heap->get_old_evac_reserve() + heap->get_promoted_reserve();\n-      size_t regions_reserved_for_evac_and_promotion = (already_reserved_old_bytes + region_size_bytes - 1) \/ region_size_bytes;\n-      regions_available_to_loan = available_old_regions - regions_reserved_for_evac_and_promotion;\n-\n-      if (available_young_regions * region_size_bytes < young_evacuation_reserve) {\n-        \/\/ Try to borrow old-gen regions in order to avoid shrinking young_evacuation_reserve\n-        size_t loan_request = young_evacuation_reserve - available_young_regions * region_size_bytes;\n-        size_t loaned_region_request = (loan_request + region_size_bytes - 1) \/ region_size_bytes;\n-        if (loaned_region_request > regions_available_to_loan) {\n-          \/\/ Scale back young_evacuation_reserve to consume all available young and old regions.  After the\n-          \/\/ collection set is chosen, we may get some of this memory back for pacing allocations during evacuation\n-          \/\/ and update refs.\n-          loaned_region_request = regions_available_to_loan;\n-          young_evacuation_reserve = (available_young_regions + loaned_region_request) * region_size_bytes;\n-        } else {\n-          \/\/ No need to scale back young_evacuation_reserve.\n-        }\n-      } else {\n-        \/\/ No need scale back young_evacuation_reserve and no need to borrow from old-gen.  We may even have some\n-        \/\/ available_young_regions to support allocation pacing.\n-      }\n-\n-    } else if (young_evacuation_reserve > young_available) {\n-      \/\/ In non-generational mode, there's no old-gen memory to borrow from\n-      young_evacuation_reserve = young_available;\n-    }\n-\n-    heap->set_young_evac_reserve(young_evacuation_reserve);\n@@ -308,49 +209,0 @@\n-\n-    \/\/ Now compute the evacuation supplement, which is extra memory borrowed from old-gen that can be allocated\n-    \/\/ by mutators while GC is working on evacuation and update-refs.\n-\n-    \/\/ During evacuation and update refs, we will be able to allocate any memory that is currently available\n-    \/\/ plus any memory that can be borrowed on the collateral of the current collection set, reserving a certain\n-    \/\/ percentage of the anticipated replenishment from collection set memory to be allocated during the subsequent\n-    \/\/ concurrent marking effort.  This is how much I can repay.\n-    size_t potential_supplement_regions = collection_set->get_young_region_count();\n-\n-    \/\/ Though I can repay potential_supplement_regions, I can't borrow them unless they are available in old-gen.\n-    if (potential_supplement_regions > regions_available_to_loan) {\n-      potential_supplement_regions = regions_available_to_loan;\n-    }\n-\n-    size_t potential_evac_supplement;\n-\n-    \/\/ How much of the potential_supplement_regions will be consumed by young_evacuation_reserve: borrowed_evac_regions.\n-    const size_t available_unaffiliated_young_regions = young_generation->free_unaffiliated_regions();\n-    const size_t available_affiliated_regions = free_regions + immediate_regions;\n-    const size_t available_young_regions = available_unaffiliated_young_regions + available_affiliated_regions;\n-    size_t young_evac_regions = (young_evacuation_reserve + region_size_bytes - 1) \/ region_size_bytes;\n-    size_t borrowed_evac_regions = (young_evac_regions > available_young_regions)? young_evac_regions - available_young_regions: 0;\n-\n-    potential_supplement_regions -= borrowed_evac_regions;\n-    potential_evac_supplement = potential_supplement_regions * region_size_bytes;\n-\n-    \/\/ Leave some allocation runway for subsequent concurrent mark phase.\n-    potential_evac_supplement = (potential_evac_supplement * ShenandoahBorrowPercent) \/ 100;\n-\n-    heap->set_alloc_supplement_reserve(potential_evac_supplement);\n-\n-    size_t promotion_budget = heap->get_promoted_reserve();\n-    size_t old_evac_budget = heap->get_old_evac_reserve();\n-    size_t alloc_budget_evac_and_update = potential_evac_supplement + young_available;\n-\n-    \/\/ TODO: young_available, which feeds into alloc_budget_evac_and_update is lacking memory available within\n-    \/\/ existing young-gen regions that were not selected for the collection set.  Add this in and adjust the\n-    \/\/ log message (where it says \"empty-region allocation budget\").\n-\n-    log_info(gc, ergo)(\"Memory reserved for evacuation and update-refs includes promotion budget: \" SIZE_FORMAT\n-                       \"%s, young evacuation budget: \" SIZE_FORMAT \"%s, old evacuation budget: \" SIZE_FORMAT\n-                       \"%s, empty-region allocation budget: \" SIZE_FORMAT \"%s, including supplement: \" SIZE_FORMAT \"%s\",\n-                       byte_size_in_proper_unit(promotion_budget), proper_unit_for_byte_size(promotion_budget),\n-                       byte_size_in_proper_unit(young_evacuation_reserve), proper_unit_for_byte_size(young_evacuation_reserve),\n-                       byte_size_in_proper_unit(old_evac_budget), proper_unit_for_byte_size(old_evac_budget),\n-                       byte_size_in_proper_unit(alloc_budget_evac_and_update),\n-                       proper_unit_for_byte_size(alloc_budget_evac_and_update),\n-                       byte_size_in_proper_unit(potential_evac_supplement), proper_unit_for_byte_size(potential_evac_supplement));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.cpp","additions":8,"deletions":156,"binary":false,"changes":164,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+  size_t collected_old_bytes = 0;\n@@ -55,41 +56,0 @@\n-  \/\/ TODO:\n-  \/\/ The max_old_evacuation_bytes and promotion_budget_bytes constants represent a first\n-  \/\/ approximation to desired operating parameters.  Eventually, these values should be determined\n-  \/\/ by heuristics and should adjust dynamically based on most current execution behavior.  In the\n-  \/\/ interim, we offer command-line options to set the values of these configuration parameters.\n-\n-  \/\/ max_old_evacuation_bytes represents a bound on how much evacuation effort is dedicated\n-  \/\/ to old-gen regions.\n-  size_t max_old_evacuation_bytes = (heap->old_generation()->soft_max_capacity() * ShenandoahOldEvacReserve) \/ 100;\n-  const size_t young_evacuation_bytes = (heap->young_generation()->soft_max_capacity() * ShenandoahEvacReserve) \/ 100;\n-  const size_t ratio_bound_on_old_evac_bytes = (young_evacuation_bytes * ShenandoahOldEvacRatioPercent) \/ 100;\n-  if (max_old_evacuation_bytes > ratio_bound_on_old_evac_bytes) {\n-    max_old_evacuation_bytes = ratio_bound_on_old_evac_bytes;\n-  }\n-\n-  \/\/ Usually, old-evacuation is limited by the CPU bounds on effort.  However, it can also be bounded by available\n-  \/\/ memory within old-gen to hold the results of evacuation.  When we are bound by memory availability, we need\n-  \/\/ to account below for the loss of available memory from within each region that is added to the old-gen collection\n-  \/\/ set.\n-  size_t old_available = heap->old_generation()->available();\n-  size_t excess_old_capacity_for_evacuation;\n-  if (max_old_evacuation_bytes > old_available) {\n-    max_old_evacuation_bytes = old_available;\n-    excess_old_capacity_for_evacuation = 0;\n-  } else {\n-    excess_old_capacity_for_evacuation = old_available - max_old_evacuation_bytes;\n-  }\n-\n-  \/\/ promotion_budget_bytes represents an \"arbitrary\" bound on how many bytes can be consumed by young-gen\n-  \/\/ objects promoted into old-gen memory.  We need to avoid a scenario under which promotion of objects\n-  \/\/ depletes old-gen available memory to the point that there is insufficient memory to hold old-gen objects\n-  \/\/ that need to be evacuated from within the old-gen collection set.\n-  \/\/\n-  \/\/ Key idea: if there is not sufficient memory within old-gen to hold an object that wants to be promoted, defer\n-  \/\/ promotion until a subsequent evacuation pass.  Enforcement is provided at the time PLABs and shared allocations\n-  \/\/ in old-gen memory are requested.\n-\n-  const size_t promotion_budget_bytes = heap->get_promoted_reserve();\n-\n-  \/\/ old_evacuation_budget is an upper bound on the amount of live memory that can be evacuated.\n-  \/\/\n@@ -100,7 +60,2 @@\n-  \/\/ budget is constrained by availability of free memory.  See remaining_old_evacuation_budget below.\n-\n-  size_t old_evacuation_budget = (size_t) (max_old_evacuation_bytes \/ ShenandoahEvacWaste);\n-\n-  log_info(gc)(\"Choose old regions for mixed collection: old evacuation budget: \" SIZE_FORMAT \"%s\",\n-                byte_size_in_proper_unit(old_evacuation_budget), proper_unit_for_byte_size(old_evacuation_budget));\n-\n+  \/\/ budget is constrained by availability of free memory.\n+  size_t old_evacuation_budget = (size_t) (heap->get_old_evac_reserve() \/ ShenandoahEvacWaste);\n@@ -109,0 +64,3 @@\n+  log_info(gc)(\"Choose old regions for mixed collection: old evacuation budget: \" SIZE_FORMAT \"%s, candidates: %u\",\n+               byte_size_in_proper_unit(old_evacuation_budget), proper_unit_for_byte_size(old_evacuation_budget),\n+               unprocessed_old_collection_candidates());\n@@ -110,3 +68,2 @@\n-  \/\/ The number of old-gen regions that were selected as candidates for collection at the end of the most recent\n-  \/\/ old-gen concurrent marking phase and have not yet been collected is represented by\n-  \/\/ unprocessed_old_collection_candidates()\n+  \/\/ The number of old-gen regions that were selected as candidates for collection at the end of the most recent old-gen\n+  \/\/ concurrent marking phase and have not yet been collected is represented by unprocessed_old_collection_candidates()\n@@ -117,1 +74,0 @@\n-\n@@ -120,3 +76,0 @@\n-    if ((r->get_live_data_bytes() <= remaining_old_evacuation_budget) &&\n-        ((lost_evacuation_capacity + r->free() <= excess_old_capacity_for_evacuation)\n-         || (r->get_live_data_bytes() + r->free() <= remaining_old_evacuation_budget))) {\n@@ -124,3 +77,4 @@\n-      \/\/ Decrement remaining evacuation budget by bytes that will be copied.  If the cumulative loss of free memory from\n-      \/\/ regions that are to be collected exceeds excess_old_capacity_for_evacuation,  decrease\n-      \/\/ remaining_old_evacuation_budget by this loss as well.\n+    \/\/ It's probably overkill to compensate with lost_evacuation_capacity.  But it's the safe thing to do and\n+    \/\/  has minimal impact on content of primed collection set.\n+    if (r->get_live_data_bytes() + lost_evacuation_capacity <= remaining_old_evacuation_budget) {\n+      \/\/ Decrement remaining evacuation budget by bytes that will be copied.\n@@ -129,10 +83,0 @@\n-      if (lost_evacuation_capacity > excess_old_capacity_for_evacuation) {\n-        \/\/ This is slightly conservative because we really only need to remove from the remaining evacuation budget\n-        \/\/ the amount by which lost_evacution_capacity exceeds excess_old_capacity_for_evacuation, but this is relatively\n-        \/\/ rare event and current thought is to be a bit conservative rather than mess up the math on code that is so\n-        \/\/ difficult to test and maintain...\n-\n-        \/\/ Once we have crossed the threshold of lost_evacuation_capacity exceeding excess_old_capacity_for_evacuation,\n-        \/\/ every subsequent iteration of this loop will further decrease remaining_old_evacuation_budget.\n-        remaining_old_evacuation_budget -= r->free();\n-      }\n@@ -142,0 +86,1 @@\n+      collected_old_bytes += r->garbage();\n@@ -149,2 +94,4 @@\n-    log_info(gc)(\"Old-gen piggyback evac (\" UINT32_FORMAT \" regions, \" SIZE_FORMAT \" %s)\",\n-                 included_old_regions, byte_size_in_proper_unit(evacuated_old_bytes), proper_unit_for_byte_size(evacuated_old_bytes));\n+    log_info(gc)(\"Old-gen piggyback evac (\" UINT32_FORMAT \" regions, evacuating \" SIZE_FORMAT \"%s, reclaiming: \" SIZE_FORMAT \"%s)\",\n+                 included_old_regions,\n+                 byte_size_in_proper_unit(evacuated_old_bytes), proper_unit_for_byte_size(evacuated_old_bytes),\n+                 byte_size_in_proper_unit(collected_old_bytes), proper_unit_for_byte_size(collected_old_bytes));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.cpp","additions":17,"deletions":70,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -757,1 +757,1 @@\n-        log_info(gc, ergo)(\"After generational memory budget adjustments, old avaiable: \" SIZE_FORMAT\n+        log_info(gc, ergo)(\"After generational memory budget adjustments, old available: \" SIZE_FORMAT\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -471,1 +471,0 @@\n-\n@@ -581,1 +580,6 @@\n-    size_t old_reserve = (_heap->old_generation()->max_capacity() \/ 100) * ShenandoahOldEvacReserve;\n+    \/\/ Note that all allocations performed from old-gen are performed by GC, generally using PLABs for both\n+    \/\/ promotions and evacuations.  The partition between which old memory is reserved for evacuation and\n+    \/\/ which is reserved for promotion is enforced using thread-local variables that prescribe intentons within\n+    \/\/ each PLAB.  We do not reserve any of old-gen memory in order to facilitate the loaning of old-gen memory\n+    \/\/ to young-gen purposes.\n+    size_t old_reserve = 0;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -224,1 +224,420 @@\n-void  ShenandoahGeneration::prepare_regions_and_collection_set(bool concurrent) {\n+void ShenandoahGeneration::compute_evacuation_budgets(ShenandoahHeap* heap, bool* preselected_regions,\n+                                                      ShenandoahCollectionSet* collection_set,\n+                                                      size_t &old_regions_loaned_for_young_evac, size_t &regions_available_to_loan,\n+                                                      size_t &minimum_evacuation_reserve, size_t &consumed_by_advance_promotion) {\n+  size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n+  minimum_evacuation_reserve = ShenandoahOldCompactionReserve * region_size_bytes;\n+  old_regions_loaned_for_young_evac = 0;\n+  regions_available_to_loan = 0;\n+  consumed_by_advance_promotion = 0;\n+  if (heap->mode()->is_generational()) {\n+    ShenandoahGeneration* old_generation = heap->old_generation();\n+    ShenandoahYoungGeneration* young_generation = heap->young_generation();\n+    size_t avail_evac_reserve_for_loan_to_young_gen = 0;\n+    size_t old_evacuation_reserve = 0;\n+    size_t num_regions = heap->num_regions();\n+\n+    \/\/ During initialization and phase changes, it is more likely that fewer objects die young and old-gen\n+    \/\/ memory is not yet full (or is in the process of being replaced).  During these times especially, it\n+    \/\/ is beneficial to loan memory from old-gen to young-gen during the evacuation and update-refs phases\n+    \/\/ of execution.\n+\n+    \/\/ Calculate EvacuationReserve before PromotionReserve.  Evacuation is more critical than promotion.\n+    \/\/ If we cannot evacuate old-gen, we will not be able to reclaim old-gen memory.  Promotions are less\n+    \/\/ critical.  If we cannot promote, there may be degradation of young-gen memory because old objects\n+    \/\/ accumulate there until they can be promoted.  This increases the young-gen marking and evacuation work.\n+\n+    \/\/ Do not fill up old-gen memory with promotions.  Reserve some amount of memory for compaction purposes.\n+    ShenandoahOldHeuristics* old_heuristics = heap->old_heuristics();\n+    size_t young_evac_reserve_max = 0;\n+    if (old_heuristics->unprocessed_old_collection_candidates() > 0) {\n+      \/\/ Compute old_evacuation_reserve: how much memory are we reserving to hold the results of\n+      \/\/ evacuating old-gen heap regions?  In order to sustain a consistent pace of young-gen collections,\n+      \/\/ the goal is to maintain a consistent value for this parameter (when the candidate set is not\n+      \/\/ empty).  This value is the minimum of:\n+      \/\/   1. old_gen->available()\n+      \/\/   2. old-gen->capacity() * ShenandoahOldEvacReserve) \/ 100\n+      \/\/       (e.g. old evacuation should be no larger than 5% of old_gen capacity)\n+      \/\/   3. ((young_gen->capacity * ShenandoahEvacReserve \/ 100) * ShenandoahOldEvacRatioPercent) \/ 100\n+      \/\/       (e.g. old evacuation should be no larger than 12% of young-gen evacuation)\n+      old_evacuation_reserve = old_generation->available();\n+      assert(old_evacuation_reserve > minimum_evacuation_reserve, \"Old-gen available has not been preserved!\");\n+      size_t old_evac_reserve_max = old_generation->soft_max_capacity() * ShenandoahOldEvacReserve \/ 100;\n+      if (old_evac_reserve_max < old_evacuation_reserve) {\n+        old_evacuation_reserve = old_evac_reserve_max;\n+      }\n+      young_evac_reserve_max =\n+        (((young_generation->soft_max_capacity() * ShenandoahEvacReserve) \/ 100) * ShenandoahOldEvacRatioPercent) \/ 100;\n+      if (young_evac_reserve_max < old_evacuation_reserve) {\n+        old_evacuation_reserve = young_evac_reserve_max;\n+      }\n+    }\n+\n+    if (minimum_evacuation_reserve > old_generation->available()) {\n+      \/\/ Due to round-off errors during enforcement of minimum_evacuation_reserve during previous GC passes,\n+      \/\/ there can be slight discrepancies here.\n+      minimum_evacuation_reserve = old_generation->available();\n+    }\n+    if (old_evacuation_reserve < minimum_evacuation_reserve) {\n+      \/\/ Even if there's nothing to be evacuated on this cycle, we still need to reserve this memory for future\n+      \/\/ evacuations.  It is ok to loan this memory to young-gen if we don't need it for evacuation on this pass.\n+      avail_evac_reserve_for_loan_to_young_gen = minimum_evacuation_reserve - old_evacuation_reserve;\n+      old_evacuation_reserve = minimum_evacuation_reserve;\n+    }\n+\n+    heap->set_old_evac_reserve(old_evacuation_reserve);\n+    heap->reset_old_evac_expended();\n+\n+    \/\/ Compute the young evauation reserve: This is how much memory is available for evacuating young-gen objects.\n+    \/\/ We ignore the possible effect of promotions, which reduce demand for young-gen evacuation memory.\n+    \/\/\n+    \/\/ TODO: We could give special treatment to the regions that have reached promotion age, because we know their\n+    \/\/ live data is entirely eligible for promotion.  This knowledge can feed both into calculations of young-gen\n+    \/\/ evacuation reserve and promotion reserve.\n+    \/\/\n+    \/\/  young_evacuation_reserve for young generation: how much memory are we reserving to hold the results\n+    \/\/  of evacuating young collection set regions?  This is typically smaller than the total amount\n+    \/\/  of available memory, and is also smaller than the total amount of marked live memory within\n+    \/\/  young-gen.  This value is the smaller of\n+    \/\/\n+    \/\/    1. (young_gen->capacity() * ShenandoahEvacReserve) \/ 100\n+    \/\/    2. (young_gen->available() + old_gen_memory_available_to_be_loaned\n+    \/\/\n+    \/\/  ShenandoahEvacReserve represents the configured taget size of the evacuation region.  We can only honor\n+    \/\/  this target if there is memory available to hold the evacuations.  Memory is available if it is already\n+    \/\/  free within young gen, or if it can be borrowed from old gen.  Since we have not yet chosen the collection\n+    \/\/  sets, we do not yet know the exact accounting of how many regions will be freed by this collection pass.\n+    \/\/  What we do know is that there will be at least one evacuated young-gen region for each old-gen region that\n+    \/\/  is loaned to the evacuation effort (because regions to be collected consume more memory than the compacted\n+    \/\/  regions that will replace them).  In summary, if there are old-gen regions that are available to hold the\n+    \/\/  results of young-gen evacuations, it is safe to loan them for this purpose.  At this point, we have not yet\n+    \/\/  established a promoted_reserve.  We'll do that after we choose the collection set and analyze its impact\n+    \/\/  on available memory.\n+    \/\/\n+    \/\/ We do not know the evacuation_supplement until after we have computed the collection set.  It is not always\n+    \/\/ the case that young-regions inserted into the collection set will result in net decrease of in-use regions\n+    \/\/ because ShenandoahEvacWaste times multiplied by memory within the region may be larger than the region size.\n+    \/\/ The problem is especially relevant to regions that have been inserted into the collection set because they have\n+    \/\/ reached tenure age.  These regions tend to have much higher utilization (e.g. 95%).  These regions also offer\n+    \/\/ a unique opportunity because we know that every live object contained within the region is elgible to be\n+    \/\/ promoted.  Thus, the following implementation treats these regions specially:\n+    \/\/\n+    \/\/  1. Before beginning collection set selection, we tally the total amount of live memory held within regions\n+    \/\/     that are known to have reached tenure age.  If this memory times ShenandoahEvacWaste is available within\n+    \/\/     old-gen memory, establish an advance promotion reserve to hold all or some percentage of these objects.\n+    \/\/     This advance promotion reserve is excluded from memory available for holding old-gen evacuations and cannot\n+    \/\/     be \"loaned\" to young gen.\n+    \/\/\n+    \/\/  2. Tenure-aged regions are included in the collection set iff their evacuation size * ShenandoahEvacWaste fits\n+    \/\/     within the advance promotion reserve.  It is counter productive to evacuate these regions if they cannot be\n+    \/\/     evacuated directly into old-gen memory.  So if there is not sufficient memory to hold copies of their\n+    \/\/     live data right now, we'll just let these regions remain in young for now, to be evacuated by a subsequent\n+    \/\/     evacuation pass.\n+    \/\/\n+    \/\/  3. Next, we calculate a young-gen evacuation budget, which is the smaller of the two quantities mentioned\n+    \/\/     above.  old_gen_memory_available_to_be_loaned is calculated as:\n+    \/\/       old_gen->available - (advance-promotion-reserve + old-gen_evacuation_reserve)\n+    \/\/\n+    \/\/  4. When choosing the collection set, special care is taken to assure that the amount of loaned memory required to\n+    \/\/     hold the results of evacuation is smaller than the total memory occupied by the regions added to the collection\n+    \/\/     set.  We need to take these precautions because we do not know how much memory will be reclaimed by evacuation\n+    \/\/     until after the collection set has been constructed.  The algorithm is as follows:\n+    \/\/\n+    \/\/     a. We feed into the algorithm (i) young available at the start of evacuation and (ii) the amount of memory\n+    \/\/        loaned from old-gen that is available to hold the results of evacuation.\n+    \/\/     b. As candidate regions are added into the young-gen collection set, we maintain accumulations of the amount\n+    \/\/        of memory spanned by the collection set regions and the amount of memory that must be reserved to hold\n+    \/\/        evacuation results (by multiplying live-data size by ShenandoahEvacWaste).  We process candidate regions\n+    \/\/        in order of decreasing amounts of garbage.  We skip over (and do not include into the collection set) any\n+    \/\/        regions that do not satisfy all of the following conditions:\n+    \/\/\n+    \/\/          i. The amount of live data within the region as scaled by ShenandoahEvacWaste must fit within the\n+    \/\/             relevant evacuation reserve (live data of old-gen regions must fit within the old-evac-reserve, live\n+    \/\/             data of young-gen tenure-aged regions must fit within the advance promotion reserve, live data within\n+    \/\/             other young-gen regions must fit within the youn-gen evacuation reserve).\n+    \/\/         ii. The accumulation of memory consumed by evacuation must not exceed the accumulation of memory reclaimed\n+    \/\/             through evacuation by more than young-gen available.\n+    \/\/        iii. Other conditions may be enforced as appropriate for specific heuristics.\n+    \/\/\n+    \/\/       Note that regions are considered for inclusion in the selection set in order of decreasing amounts of garbage.\n+    \/\/       It is possible that a region with a larger amount of garbage will be rejected because it also has a larger\n+    \/\/       amount of live data and some region that follows this region in candidate order is included in the collection\n+    \/\/       set (because it has less live data and thus can fit within the evacuation limits even though it has less\n+    \/\/       garbage).\n+\n+    size_t young_evacuation_reserve = (young_generation->max_capacity() * ShenandoahEvacReserve) \/ 100;\n+    \/\/ old evacuation can pack into existing partially used regions.  young evacuation and loans for young allocations\n+    \/\/ need to target regions that do not already hold any old-gen objects.  Round down.\n+    regions_available_to_loan = old_generation->free_unaffiliated_regions();\n+    consumed_by_advance_promotion = _heuristics->select_aged_regions(old_generation->available() - old_evacuation_reserve,\n+                                                                     num_regions, preselected_regions);\n+    size_t net_available_old_regions =\n+      (old_generation->available() - old_evacuation_reserve - consumed_by_advance_promotion) \/ region_size_bytes;\n+\n+    if (regions_available_to_loan > net_available_old_regions) {\n+      regions_available_to_loan = net_available_old_regions;\n+    }\n+\n+    \/\/ Otherwise, regions_available_to_loan is less than net_available_old_regions because available memory is\n+    \/\/ scattered between multiple partially used regions.\n+\n+    if (young_evacuation_reserve > young_generation->available()) {\n+      size_t short_fall = young_evacuation_reserve - young_generation->available();\n+      if (regions_available_to_loan * region_size_bytes >= short_fall) {\n+        old_regions_loaned_for_young_evac = (short_fall + region_size_bytes - 1) \/ region_size_bytes;\n+        regions_available_to_loan -= old_regions_loaned_for_young_evac;\n+      } else {\n+        old_regions_loaned_for_young_evac = regions_available_to_loan;\n+        regions_available_to_loan = 0;\n+        young_evacuation_reserve = young_generation->available() + old_regions_loaned_for_young_evac * region_size_bytes;\n+        \/\/ In this case, there's no memory available for new allocations while evacuating and updating, unless we\n+        \/\/ find more old-gen memory to borrow below.\n+      }\n+    } else {\n+      old_regions_loaned_for_young_evac = 0;\n+    }\n+    \/\/ In generational mode, we may end up choosing a young collection set that contains so many promotable objects\n+    \/\/ that there is not sufficient space in old generation to hold the promoted objects.  That is ok because we have\n+    \/\/ assured there is sufficient space in young generation to hold the rejected promotion candidates.  These rejected\n+    \/\/ promotion candidates will presumably be promoted in a future evacuation cycle.\n+    heap->set_young_evac_reserve(young_evacuation_reserve);\n+    collection_set->establish_preselected(preselected_regions);\n+  } else {\n+    \/\/ Not generational mode: limit young evac reserve by young available; no need to establish old_evac_reserve.\n+    ShenandoahYoungGeneration* young_generation = heap->young_generation();\n+    size_t young_evac_reserve = (young_generation->soft_max_capacity() * ShenandoahEvacReserve) \/ 100;\n+    if (young_evac_reserve > young_generation->available()) {\n+      young_evac_reserve = young_generation->available();\n+    }\n+    heap->set_young_evac_reserve(young_evac_reserve);\n+  }\n+}\n+\n+\/\/ Having chosen the collection set, adjust the budgets for generatioal mode based on its composition.  Note\n+\/\/ that young_generation->available() now knows about recently discovered immediate garbage.\n+void ShenandoahGeneration::adjust_evacuation_budgets(ShenandoahHeap* heap, ShenandoahCollectionSet* collection_set,\n+                                                     size_t old_regions_loaned_for_young_evac, size_t regions_available_to_loan,\n+                                                     size_t minimum_evacuation_reserve, size_t consumed_by_advance_promotion) {\n+  if (heap->mode()->is_generational()) {\n+    size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n+    ShenandoahGeneration* old_generation = heap->old_generation();\n+    ShenandoahYoungGeneration* young_generation = heap->young_generation();\n+    size_t old_evacuated = collection_set->get_old_bytes_reserved_for_evacuation();\n+    size_t old_evacuated_committed = (size_t) (ShenandoahEvacWaste * old_evacuated);\n+    size_t old_evacuation_reserve = heap->get_old_evac_reserve();\n+    \/\/ Immediate garbage found during choose_collection_set() is all young\n+    size_t immediate_garbage = collection_set->get_immediate_trash();\n+    size_t old_available = old_generation->available();\n+    size_t young_available = young_generation->available() + immediate_garbage;\n+\n+    assert(consumed_by_advance_promotion >= collection_set->get_young_bytes_to_be_promoted() * ShenandoahEvacWaste,\n+           \"Advance promotion should be at least young_bytes_to_be_promoted * ShenandoahEvacWaste\");\n+\n+    assert(consumed_by_advance_promotion <= (collection_set->get_young_bytes_to_be_promoted() * ShenandoahEvacWaste * 33) \/ 32,\n+           \"Round-off errors should be less than 3.125%%, consumed by advance: \" SIZE_FORMAT \", promoted: \" SIZE_FORMAT,\n+           consumed_by_advance_promotion, (size_t) (collection_set->get_young_bytes_to_be_promoted() * ShenandoahEvacWaste));\n+  \n+    collection_set->abandon_preselected();\n+    if (old_evacuated_committed > old_evacuation_reserve) {\n+      \/\/ This should only happen due to round-off errors when enforcing ShenandoahEvacWaste\n+      assert(old_evacuated_committed <= (33 * old_evacuation_reserve) \/ 32,\n+             \"Round-off errors should be less than 3.125%%, committed: \" SIZE_FORMAT \", reserved: \" SIZE_FORMAT,\n+             old_evacuated_committed, old_evacuation_reserve);\n+      old_evacuated_committed = old_evacuation_reserve;\n+    } else if (old_evacuated_committed < old_evacuation_reserve) {\n+      \/\/ This may happen if the old-gen collection consumes less than full budget.\n+      old_evacuation_reserve = old_evacuated_committed;\n+      heap->set_old_evac_reserve(old_evacuation_reserve);\n+    }\n+\n+    \/\/ Recompute old_regions_loaned_for_young_evac because young-gen collection set may not need all the memory\n+    \/\/ originally reserved.\n+    size_t young_promoted = collection_set->get_young_bytes_to_be_promoted();\n+    size_t young_promoted_reserve_used = (size_t) (ShenandoahEvacWaste * young_promoted);\n+\n+    size_t young_evacuated = collection_set->get_young_bytes_reserved_for_evacuation() - young_promoted;\n+    size_t young_evacuated_reserve_used = (size_t) (ShenandoahEvacWaste * young_evacuated);\n+\n+    heap->set_young_evac_reserve(young_evacuated_reserve_used);\n+\n+    \/\/ Adjust old_regions_loaned_for_young_evac to feed into calculations of promoted_reserve\n+    if (young_evacuated_reserve_used > young_available) {\n+      size_t short_fall = young_evacuated_reserve_used - young_available;\n+\n+      \/\/ region_size_bytes is a power of 2.  loan an integral number of regions.\n+      size_t revised_loan_for_young_evacuation = (short_fall + region_size_bytes - 1) \/ region_size_bytes;\n+\n+      \/\/ Undo the previous loan\n+      regions_available_to_loan += old_regions_loaned_for_young_evac;\n+      old_regions_loaned_for_young_evac = revised_loan_for_young_evacuation;\n+      \/\/ And make a new loan\n+      assert(regions_available_to_loan > old_regions_loaned_for_young_evac, \"Cannot loan regions that we do not have\");\n+      regions_available_to_loan -= old_regions_loaned_for_young_evac;\n+    } else {\n+      \/\/ Undo the prevous loan\n+      regions_available_to_loan += old_regions_loaned_for_young_evac;\n+      old_regions_loaned_for_young_evac = 0;\n+    }\n+\n+    size_t old_bytes_loaned_for_young_evac = old_regions_loaned_for_young_evac * region_size_bytes;\n+    size_t old_bytes_reserved_for_alloc_supplement = 0;\n+    size_t old_regions_reserved_for_alloc_supplement = 0;\n+    \/\/ Need to enforce that old_evacuated_committed + old_bytes_loaned_for_young_evac >= minimum_evacuation_reserve\n+    \/\/ in order to prevent promotion reserve from violating minimum evacuation reserve.\n+    if (old_evacuated_committed + old_bytes_loaned_for_young_evac < minimum_evacuation_reserve) {\n+      \/\/ Reserve some of the regions available to loan for use as allocation supplement to assure memory not consumed by promotion\n+      size_t excess_bytes = minimum_evacuation_reserve - (old_evacuated_committed + old_bytes_loaned_for_young_evac);\n+      size_t excess_regions = (excess_bytes - 1 + region_size_bytes) \/ region_size_bytes;\n+      if (regions_available_to_loan <= excess_regions) {\n+        excess_regions = regions_available_to_loan;\n+        \/\/ Since we can't reserve entire excess for alloc supplement, pretend more is consumed by old-evacuation\n+        old_evacuated_committed =\n+          minimum_evacuation_reserve - old_bytes_loaned_for_young_evac - excess_regions * region_size_bytes;\n+      }\n+      regions_available_to_loan -= excess_regions;\n+      old_bytes_reserved_for_alloc_supplement = excess_regions * region_size_bytes;\n+      old_regions_reserved_for_alloc_supplement = excess_regions;\n+    }\n+\n+    \/\/ Limit promoted_reserve so that we can set aside memory to be loaned from old-gen to young-gen.  This\n+    \/\/ value is not \"critical\".  If we underestimate, certain promotions will simply be deferred.  If we put\n+    \/\/ \"all the rest\" of old-gen memory into the promotion reserve, we'll have nothing left to loan to young-gen\n+    \/\/ during the evac and update phases of GC.  So we \"limit\" the sizes of the promotion budget to be the smaller of:\n+    \/\/\n+    \/\/  1. old_gen->available - (old_evacuation_committed + old_bytes_loaned_for_young_evac + consumed_by_advance_promotion)\n+    \/\/  2. young bytes reserved for evacuation\n+\n+    assert(old_available > old_evacuated_committed, \"Cannot evacuate more than available\");\n+    assert(old_available > old_evacuated_committed + old_bytes_loaned_for_young_evac,\n+           \"Cannot loan young evac more than available\");\n+    assert(old_available > old_evacuated_committed + old_bytes_loaned_for_young_evac + consumed_by_advance_promotion,\n+           \"Cannot promote more than available\");\n+    assert(old_available > (old_evacuated_committed + old_bytes_loaned_for_young_evac +\n+                                          consumed_by_advance_promotion + old_bytes_reserved_for_alloc_supplement),\n+           \"Cannot loan for alloc supplement more than available\");\n+\n+    size_t promotion_reserve = old_available - (old_evacuated_committed + consumed_by_advance_promotion +\n+                                                old_bytes_loaned_for_young_evac + old_bytes_reserved_for_alloc_supplement);\n+\n+    \/\/ We experimented with constraining promoted_reserve to be no larger than 4 times the size of previously_promoted,\n+    \/\/ but this constraint was too limiting, resulting in failure of legitimate promotions.  This was tried before we \n+    \/\/ had special handling in place for advance promotion.  We should retry now that advance promotion is handled\n+    \/\/ specially.\n+\n+    \/\/ We had also experimented with constraining promoted_reserve to be no more than young_evacuation_committed\n+    \/\/ divided by promotion_divisor, where:\n+    \/\/  size_t promotion_divisor = (0x02 << InitialTenuringThreshold) - 1;\n+    \/\/ This also was found to be too limiting, resulting in failure of legitimate promotions.\n+    \/\/\n+    \/\/ Both experiments were conducted in the presence of other bugs which could have been the root cause for\n+    \/\/ the failures identified above as being \"too limiting\".  TODO: conduct new experiments with the more limiting\n+    \/\/ values of young_evacuation_reserved_used.\n+\n+    \/\/ young_evacuation_reserve_used already excludes bytes known to be promoted, which equals consumed_by_advance_promotion\n+    if (young_evacuated_reserve_used < promotion_reserve) {\n+      \/\/ Shrink promotion_reserve if it is larger than the memory to be consumed by evacuating all young objects in\n+      \/\/ collection set, including anticipated waste.  There's no benefit in using a larger promotion_reserve.\n+      \/\/ young_evacuation_reserve_used does not include live memory within tenure-aged regions.\n+      promotion_reserve = young_evacuated_reserve_used;\n+    }\n+\n+    assert(old_available >= (promotion_reserve + old_evacuated_committed + old_bytes_loaned_for_young_evac +\n+                             consumed_by_advance_promotion + old_bytes_reserved_for_alloc_supplement),\n+           \"Budget exceeds available old-gen memory\");\n+    log_debug(gc)(\"Old available: \" SIZE_FORMAT \", Original promotion reserve: \" SIZE_FORMAT \", Old evacuation reserve: \"\n+                  SIZE_FORMAT \", Advance promotion reserve supplement: \" SIZE_FORMAT\n+                  \", Old loaned for young evacuation: \" SIZE_FORMAT \", Old reserved for alloc supplement: \" SIZE_FORMAT,\n+                  old_available, promotion_reserve, old_evacuated_committed, consumed_by_advance_promotion,\n+                  old_regions_loaned_for_young_evac * region_size_bytes, old_bytes_reserved_for_alloc_supplement);\n+\n+    promotion_reserve += consumed_by_advance_promotion;\n+    heap->set_promoted_reserve(promotion_reserve);\n+    heap->reset_promoted_expended();\n+    if (collection_set->get_old_bytes_reserved_for_evacuation() == 0) {\n+      \/\/ Setting old evacuation reserve to zero denotes that there is no old-gen evacuation in this pass.\n+      heap->set_old_evac_reserve(0);\n+    }\n+\n+    size_t old_gen_usage_base = old_generation->used() - collection_set->get_old_garbage();\n+    heap->capture_old_usage(old_gen_usage_base);\n+\n+    \/\/ Compute the evacuation supplement, which is extra memory borrowed from old-gen that can be allocated\n+    \/\/ by mutators while GC is working on evacuation and update-refs.  This memory can be temporarily borrowed\n+    \/\/ from old-gen allotment, then repaid at the end of update-refs from the recycled collection set.  After\n+    \/\/ we have computed the collection set based on the parameters established above, we can make additional\n+    \/\/ loans based on our knowledge of the collection set to determine how much allocation we can allow\n+    \/\/ during the evacuation and update-refs phases of execution.  The total available supplement is the smaller of:\n+    \/\/\n+    \/\/   1. old_gen->available() -\n+    \/\/        (promotion_reserve + old_evacuation_commitment + old_bytes_loaned_for_young_evac)\n+    \/\/   2. The replenishment budget (number of regions in collection set - the number of regions already\n+    \/\/         under lien for the young_evacuation_reserve)\n+    \/\/\n+\n+    \/\/ Regardless of how many regions may be available to be loaned, we can loan no more regions than\n+    \/\/ the total number of young regions to be evacuated.  Call this the regions_for_runway.\n+\n+    size_t young_regions_evacuated = collection_set->get_young_region_count();\n+    size_t regions_for_runway = 0;\n+    size_t already_loaned_regions = old_regions_loaned_for_young_evac + old_regions_reserved_for_alloc_supplement;\n+    if (already_loaned_regions == 0) {\n+      regions_for_runway = young_regions_evacuated;\n+    } else if (young_regions_evacuated > already_loaned_regions) {\n+      regions_for_runway = young_regions_evacuated - already_loaned_regions;\n+    } else {\n+      regions_for_runway = 0;\n+    }\n+\n+    if (regions_available_to_loan > regions_for_runway) {\n+      regions_available_to_loan -= regions_for_runway;\n+    } else {\n+      regions_for_runway = regions_available_to_loan;\n+      regions_available_to_loan = 0;\n+    }\n+\n+    size_t allocation_supplement = regions_for_runway * region_size_bytes + old_bytes_reserved_for_alloc_supplement;\n+    heap->set_alloc_supplement_reserve(allocation_supplement);\n+\n+    \/\/ TODO: young_available, which feeds into alloc_budget_evac_and_update is lacking memory available within\n+    \/\/ existing young-gen regions that were not selected for the collection set.  Add this in and adjust the\n+    \/\/ log message (where it says \"empty-region allocation budget\").\n+\n+    log_debug(gc)(\"Memory reserved for young evacuation: \" SIZE_FORMAT \"%s for evacuating \" SIZE_FORMAT\n+                  \"%s out of young available: \" SIZE_FORMAT \"%s\",\n+                  byte_size_in_proper_unit(young_evacuated_reserve_used),\n+                  proper_unit_for_byte_size(young_evacuated_reserve_used),\n+                  byte_size_in_proper_unit(young_evacuated), proper_unit_for_byte_size(young_evacuated),\n+                  byte_size_in_proper_unit(young_available), proper_unit_for_byte_size(young_available));\n+  \n+    log_debug(gc)(\"Memory reserved for old evacuation: \" SIZE_FORMAT \"%s for evacuating \" SIZE_FORMAT\n+                  \"%s out of old available: \" SIZE_FORMAT \"%s\",\n+                  byte_size_in_proper_unit(old_evacuated), proper_unit_for_byte_size(old_evacuated),\n+                  byte_size_in_proper_unit(old_evacuated), proper_unit_for_byte_size(old_evacuated),\n+                  byte_size_in_proper_unit(old_available), proper_unit_for_byte_size(old_available));\n+\n+    assert(old_available > old_evacuation_reserve + promotion_reserve + old_bytes_loaned_for_young_evac + allocation_supplement,\n+           \"old_available must be larger than accumulated reserves\");\n+\n+    size_t regular_promotion = promotion_reserve - consumed_by_advance_promotion;\n+    size_t excess =\n+      old_available - (old_evacuation_reserve + promotion_reserve + old_bytes_loaned_for_young_evac + allocation_supplement);\n+    log_info(gc, ergo)(\"Old available: \" SIZE_FORMAT \"%s is partitioned into old evacuation budget: \" SIZE_FORMAT\n+                       \"%s, aged region promotion budget: \" SIZE_FORMAT\n+                       \"%s, regular region promotion budget: \" SIZE_FORMAT\n+                       \"%s, loaned for young evacuation: \" SIZE_FORMAT\n+                       \"%s, loaned for young allocations: \" SIZE_FORMAT\n+                       \"%s, excess: \" SIZE_FORMAT \"%s\",\n+                       byte_size_in_proper_unit(old_available), proper_unit_for_byte_size(old_available),\n+                       byte_size_in_proper_unit(old_evacuation_reserve), proper_unit_for_byte_size(old_evacuation_reserve),\n+                       byte_size_in_proper_unit(consumed_by_advance_promotion),\n+                       proper_unit_for_byte_size(consumed_by_advance_promotion),\n+                       byte_size_in_proper_unit(regular_promotion), proper_unit_for_byte_size(regular_promotion),\n+                       byte_size_in_proper_unit(old_bytes_loaned_for_young_evac),\n+                       proper_unit_for_byte_size(old_bytes_loaned_for_young_evac),\n+                       byte_size_in_proper_unit(allocation_supplement), proper_unit_for_byte_size(allocation_supplement),\n+                       byte_size_in_proper_unit(excess), proper_unit_for_byte_size(excess));\n+  }\n+  \/\/ else, not generational: no evacuation budget adjustments required\n+}\n+\n+void ShenandoahGeneration::prepare_regions_and_collection_set(bool concurrent) {\n@@ -247,17 +666,2 @@\n-    ShenandoahGCPhase phase(concurrent ? ShenandoahPhaseTimings::choose_cset :\n-                            ShenandoahPhaseTimings::degen_gc_choose_cset);\n-    ShenandoahHeapLocker locker(heap->lock());\n-    heap->collection_set()->clear();\n-\n-    size_t minimum_evacuation_reserve = ShenandoahOldCompactionReserve * region_size_bytes;\n-    size_t avail_evac_reserve_for_loan_to_young_gen = 0;\n-    size_t old_regions_loaned_for_young_evac = 0;\n-    size_t regions_available_to_loan = 0;\n-    size_t old_evacuation_reserve = 0;\n-    size_t num_regions = heap->num_regions();\n-    size_t consumed_by_advance_promotion = 0;\n-    bool* preselected_regions = NEW_C_HEAP_ARRAY(bool, num_regions, mtGC);\n-    for (unsigned int i = 0; i < num_regions; i++) {\n-      preselected_regions[i] = false;\n-    }\n-\n+    size_t old_regions_loaned_for_young_evac, regions_available_to_loan, minimum_evacuation_reserve, consumed_by_advance_promotion;\n+    bool* preselected_regions = nullptr;\n@@ -265,38 +669,3 @@\n-      ShenandoahGeneration* old_generation = heap->old_generation();\n-      ShenandoahYoungGeneration* young_generation = heap->young_generation();\n-\n-      \/\/ During initialization and phase changes, it is more likely that fewer objects die young and old-gen\n-      \/\/ memory is not yet full (or is in the process of being replaced).  During these times especially, it\n-      \/\/ is beneficial to loan memory from old-gen to young-gen during the evacuation and update-refs phases\n-      \/\/ of execution.\n-\n-      \/\/ Calculate EvacuationReserve before PromotionReserve.  Evacuation is more critical than promotion.\n-      \/\/ If we cannot evacuate old-gen, we will not be able to reclaim old-gen memory.  Promotions are less\n-      \/\/ critical.  If we cannot promote, there may be degradation of young-gen memory because old objects\n-      \/\/ accumulate there until they can be promoted.  This increases the young-gen marking and evacuation work.\n-\n-      \/\/ Do not fill up old-gen memory with promotions.  Reserve some amount of memory for compaction purposes.\n-      ShenandoahOldHeuristics* old_heuristics = heap->old_heuristics();\n-      if (old_heuristics->unprocessed_old_collection_candidates() > 0) {\n-\n-        \/\/ Compute old_evacuation_reserve: how much memory are we reserving to hold the results of\n-        \/\/ evacuating old-gen heap regions?  In order to sustain a consistent pace of young-gen collections,\n-        \/\/ the goal is to maintain a consistent value for this parameter (when the candidate set is not\n-        \/\/ empty).  This value is the minimum of:\n-        \/\/   1. old_gen->available()\n-        \/\/   2. old-gen->capacity() * ShenandoahOldEvacReserve) \/ 100\n-        \/\/       (e.g. old evacuation should be no larger than 5% of old_gen capacity)\n-        \/\/   3. ((young_gen->capacity * ShenandoahEvacReserve \/ 100) * ShenandoahOldEvacRatioPercent) \/ 100\n-        \/\/       (e.g. old evacuation should be no larger than 12% of young-gen evacuation)\n-\n-        old_evacuation_reserve = old_generation->available();\n-        assert(old_evacuation_reserve > minimum_evacuation_reserve, \"Old-gen available has not been preserved!\");\n-        size_t old_evac_reserve_max = old_generation->soft_max_capacity() * ShenandoahOldEvacReserve \/ 100;\n-        if (old_evac_reserve_max < old_evacuation_reserve) {\n-          old_evacuation_reserve = old_evac_reserve_max;\n-        }\n-        size_t young_evac_reserve_max =\n-          (((young_generation->soft_max_capacity() * ShenandoahEvacReserve) \/ 100) * ShenandoahOldEvacRatioPercent) \/ 100;\n-        if (young_evac_reserve_max < old_evacuation_reserve) {\n-          old_evacuation_reserve = young_evac_reserve_max;\n-        }\n+      preselected_regions = (bool*) alloca(heap->num_regions() * sizeof(bool));\n+      for (unsigned int i = 0; i < heap->num_regions(); i++) {\n+        preselected_regions[i] = false;\n@@ -304,134 +673,0 @@\n-\n-      if (minimum_evacuation_reserve > old_generation->available()) {\n-        \/\/ Due to round-off errors during enforcement of minimum_evacuation_reserve during previous GC passes,\n-        \/\/ there can be slight discrepancies here.\n-        minimum_evacuation_reserve = old_generation->available();\n-      }\n-      if (old_evacuation_reserve < minimum_evacuation_reserve) {\n-        \/\/ Even if there's nothing to be evacuated on this cycle, we still need to reserve this memory for future\n-        \/\/ evacuations.  It is ok to loan this memory to young-gen if we don't need it for evacuation on this pass.\n-        avail_evac_reserve_for_loan_to_young_gen = minimum_evacuation_reserve - old_evacuation_reserve;\n-        old_evacuation_reserve = minimum_evacuation_reserve;\n-      }\n-\n-      heap->set_old_evac_reserve(old_evacuation_reserve);\n-      heap->reset_old_evac_expended();\n-\n-      \/\/ Compute the young evauation reserve: This is how much memory is available for evacuating young-gen objects.\n-      \/\/ We ignore the possible effect of promotions, which reduce demand for young-gen evacuation memory.\n-      \/\/\n-      \/\/ TODO: We could give special treatment to the regions that have reached promotion age, because we know their\n-      \/\/ live data is entirely eligible for promotion.  This knowledge can feed both into calculations of young-gen\n-      \/\/ evacuation reserve and promotion reserve.\n-      \/\/\n-      \/\/  young_evacuation_reserve for young generation: how much memory are we reserving to hold the results\n-      \/\/  of evacuating young collection set regions?  This is typically smaller than the total amount\n-      \/\/  of available memory, and is also smaller than the total amount of marked live memory within\n-      \/\/  young-gen.  This value is the smaller of\n-      \/\/\n-      \/\/    1. (young_gen->capacity() * ShenandoahEvacReserve) \/ 100\n-      \/\/    2. (young_gen->available() + old_gen_memory_available_to_be_loaned\n-      \/\/\n-      \/\/  ShenandoahEvacReserve represents the configured taget size of the evacuation region.  We can only honor\n-      \/\/  this target if there is memory available to hold the evacuations.  Memory is available if it is already\n-      \/\/  free within young gen, or if it can be borrowed from old gen.  Since we have not yet chosen the collection\n-      \/\/  sets, we do not yet know the exact accounting of how many regions will be freed by this collection pass.\n-      \/\/  What we do know is that there will be at least one evacuated young-gen region for each old-gen region that\n-      \/\/  is loaned to the evacuation effort (because regions to be collected consume more memory than the compacted\n-      \/\/  regions that will replace them).  In summary, if there are old-gen regions that are available to hold the\n-      \/\/  results of young-gen evacuations, it is safe to loan them for this purpose.  At this point, we have not yet\n-      \/\/  established a promoted_reserve.  We'll do that after we choose the collection set and analyze its impact\n-      \/\/  on available memory.\n-      \/\/\n-      \/\/ We do not know the evacuation_supplement until after we have computed the collection set.  It is not always\n-      \/\/ the case that young-regions inserted into the collection set will result in net decrease of in-use regions\n-      \/\/ because ShenandoahEvacWaste times multiplied by memory within the region may be larger than the region size.\n-      \/\/ The problem is especially relevant to regions that have been inserted into the collection set because they have\n-      \/\/ reached tenure age.  These regions tend to have much higher utilization (e.g. 95%).  These regions also offer\n-      \/\/ a unique opportunity because we know that every live object contained within the region is elgible to be\n-      \/\/ promoted.  Thus, the following implementation treats these regions specially:\n-      \/\/\n-      \/\/  1. Before beginning collection set selection, we tally the total amount of live memory held within regions\n-      \/\/     that are known to have reached tenure age.  If this memory times ShenandoahEvacWaste is available within\n-      \/\/     old-gen memory, establish an advance promotion reserve to hold all or some percentage of these objects.\n-      \/\/     This advance promotion reserve is excluded from memory available for holding old-gen evacuations and cannot\n-      \/\/     be \"loaned\" to young gen.\n-      \/\/\n-      \/\/  2. Tenure-aged regions are included in the collection set iff their evacuation size * ShenandoahEvacWaste fits\n-      \/\/     within the advance promotion reserve.  It is counter productive to evacuate these regions if they cannot be\n-      \/\/     evacuated directly into old-gen memory.  So if there is not sufficient memory to hold copies of their\n-      \/\/     live data right now, we'll just let these regions remain in young for now, to be evacuated by a subsequent\n-      \/\/     evacuation pass.\n-      \/\/\n-      \/\/  3. Next, we calculate a young-gen evacuation budget, which is the smaller of the two quantities mentioned\n-      \/\/     above.  old_gen_memory_available_to_be_loaned is calculated as:\n-      \/\/       old_gen->available - (advance-promotion-reserve + old-gen_evacuation_reserve)\n-      \/\/\n-      \/\/  4. When choosing the collection set, special care is taken to assure that the amount of loaned memory required to\n-      \/\/     hold the results of evacuation is smaller than the total memory occupied by the regions added to the collection\n-      \/\/     set.  We need to take these precautions because we do not know how much memory will be reclaimed by evacuation\n-      \/\/     until after the collection set has been constructed.  The algorithm is as follows:\n-      \/\/\n-      \/\/     a. We feed into the algorithm (i) young available at the start of evacuation and (ii) the amount of memory\n-      \/\/        loaned from old-gen that is available to hold the results of evacuation.\n-      \/\/     b. As candidate regions are added into the young-gen collection set, we maintain accumulations of the amount\n-      \/\/        of memory spanned by the collection set regions and the amount of memory that must be reserved to hold\n-      \/\/        evacuation results (by multiplying live-data size by ShenandoahEvacWaste).  We process candidate regions\n-      \/\/        in order of decreasing amounts of garbage.  We skip over (and do not include into the collection set) any\n-      \/\/        regions that do not satisfy all of the following conditions:\n-      \/\/\n-      \/\/          i. The amount of live data within the region as scaled by ShenandoahEvacWaste must fit within the\n-      \/\/             relevant evacuation reserve (live data of old-gen regions must fit within the old-evac-reserve, live\n-      \/\/             data of young-gen tenure-aged regions must fit within the advance promotion reserve, live data within\n-      \/\/             other young-gen regions must fit within the youn-gen evacuation reserve).\n-      \/\/         ii. The accumulation of memory consumed by evacuation must not exceed the accumulation of memory reclaimed\n-      \/\/             through evacuation by more than young-gen available.\n-      \/\/        iii. Other conditions may be enforced as appropriate for specific heuristics.\n-      \/\/\n-      \/\/       Note that regions are considered for inclusion in the selection set in order of decreasing amounts of garbage.\n-      \/\/       It is possible that a region with a larger amount of garbage will be rejected because it also has a larger\n-      \/\/       amount of live data and some region that follows this region in candidate order is included in the collection\n-      \/\/       set (because it has less live data and thus can fit within the evacuation limits even though it has less\n-      \/\/       garbage).\n-\n-      size_t young_evacuation_reserve = (young_generation->max_capacity() * ShenandoahEvacReserve) \/ 100;\n-      \/\/ old evacuation can pack into existing partially used regions.  young evacuation and loans for young allocations\n-      \/\/ need to target regions that do not already hold any old-gen objects.  Round down.\n-      regions_available_to_loan = old_generation->free_unaffiliated_regions();\n-      consumed_by_advance_promotion = _heuristics->select_aged_regions(old_generation->available() - old_evacuation_reserve,\n-                                                                       num_regions, preselected_regions);\n-      size_t net_available_old_regions =\n-        (old_generation->available() - old_evacuation_reserve - consumed_by_advance_promotion) \/ region_size_bytes;\n-\n-      if (regions_available_to_loan > net_available_old_regions) {\n-        regions_available_to_loan = net_available_old_regions;\n-      }\n-      \/\/ Otherwise, regions_available_to_loan is less than net_available_old_regions because available memory is\n-      \/\/ scattered between multiple partially used regions.\n-\n-      if (young_evacuation_reserve > young_generation->available()) {\n-        size_t short_fall = young_evacuation_reserve - young_generation->available();\n-        if (regions_available_to_loan * region_size_bytes >= short_fall) {\n-          old_regions_loaned_for_young_evac = (short_fall + region_size_bytes - 1) \/ region_size_bytes;\n-          regions_available_to_loan -= old_regions_loaned_for_young_evac;\n-        } else {\n-          old_regions_loaned_for_young_evac = regions_available_to_loan;\n-          regions_available_to_loan = 0;\n-          young_evacuation_reserve = young_generation->available() + old_regions_loaned_for_young_evac * region_size_bytes;\n-        }\n-      } else {\n-        old_regions_loaned_for_young_evac = 0;\n-      }\n-      \/\/ In generational mode, we may end up choosing a young collection set that contains so many promotable objects\n-      \/\/ that there is not sufficient space in old generation to hold the promoted objects.  That is ok because we have\n-      \/\/ assured there is sufficient space in young generation to hold the rejected promotion candidates.  These rejected\n-      \/\/ promotion candidates will presumably be promoted in a future evacuation cycle.\n-      heap->set_young_evac_reserve(young_evacuation_reserve);\n-    } else {\n-      \/\/ Not generational mode: limit young evac reserve by young available; no need to establish old_evac_reserve.\n-      ShenandoahYoungGeneration* young_generation = heap->young_generation();\n-      size_t young_evac_reserve = (young_generation->soft_max_capacity() * ShenandoahEvacReserve) \/ 100;\n-      if (young_evac_reserve > young_generation->available()) {\n-        young_evac_reserve = young_generation->available();\n-      }\n-      heap->set_young_evac_reserve(young_evac_reserve);\n@@ -440,0 +675,5 @@\n+    ShenandoahGCPhase phase(concurrent ? ShenandoahPhaseTimings::choose_cset :\n+                            ShenandoahPhaseTimings::degen_gc_choose_cset);\n+\n+    ShenandoahHeapLocker locker(heap->lock());\n+    collection_set->clear();\n@@ -448,1 +688,3 @@\n-    collection_set->establish_preselected(preselected_regions);\n+    \/\/ Budgeting parameters to compute_evacuation_budgets are passed by reference.\n+    compute_evacuation_budgets(heap, preselected_regions, collection_set, old_regions_loaned_for_young_evac,\n+                               regions_available_to_loan, minimum_evacuation_reserve, consumed_by_advance_promotion);\n@@ -450,149 +692,3 @@\n-    collection_set->abandon_preselected();\n-    FREE_C_HEAP_ARRAY(bool, preselected_regions);\n-\n-    \/\/ At this point, young_generation->available() knows about recently discovered immediate garbage.  We also\n-    \/\/ know the composition of the chosen collection set.\n-\n-    if (heap->mode()->is_generational()) {\n-      ShenandoahGeneration* old_generation = heap->old_generation();\n-      ShenandoahYoungGeneration* young_generation = heap->young_generation();\n-      size_t old_evacuation_committed = (size_t) (ShenandoahEvacWaste *\n-                                                  collection_set->get_old_bytes_reserved_for_evacuation());\n-      size_t immediate_garbage_regions = collection_set->get_immediate_trash() \/ region_size_bytes;\n-\n-      if (old_evacuation_committed > old_evacuation_reserve) {\n-        \/\/ This should only happen due to round-off errors when enforcing ShenandoahEvacWaste\n-        assert(old_evacuation_committed < (33 * old_evacuation_reserve) \/ 32, \"Round-off errors should be less than 3.125%%\");\n-        old_evacuation_committed = old_evacuation_reserve;\n-      }\n-\n-      \/\/ Recompute old_regions_loaned_for_young_evac because young-gen collection set may not need all the memory\n-      \/\/ originally reserved.\n-\n-      size_t young_evacuation_reserve_used =\n-        collection_set->get_young_bytes_reserved_for_evacuation() - collection_set->get_young_bytes_to_be_promoted();\n-      young_evacuation_reserve_used = (size_t) (ShenandoahEvacWaste * young_evacuation_reserve_used);\n-      heap->set_young_evac_reserve(young_evacuation_reserve_used);\n-\n-      \/\/ Adjust old_regions_loaned_for_young_evac to feed into calculations of promoted_reserve\n-      if (young_evacuation_reserve_used > young_generation->available()) {\n-        size_t short_fall = young_evacuation_reserve_used - young_generation->available();\n-\n-        \/\/ region_size_bytes is a power of 2.  loan an integral number of regions.\n-        size_t revised_loan_for_young_evacuation = (short_fall + region_size_bytes - 1) \/ region_size_bytes;\n-\n-        \/\/ Undo the previous loan\n-        regions_available_to_loan += old_regions_loaned_for_young_evac;\n-        old_regions_loaned_for_young_evac = revised_loan_for_young_evacuation;\n-        \/\/ And make a new loan\n-        assert(regions_available_to_loan > old_regions_loaned_for_young_evac, \"Cannot loan regions that we do not have\");\n-        regions_available_to_loan -= old_regions_loaned_for_young_evac;\n-      } else {\n-        \/\/ Undo the prevous loan\n-        regions_available_to_loan += old_regions_loaned_for_young_evac;\n-        old_regions_loaned_for_young_evac = 0;\n-      }\n-\n-      size_t old_bytes_loaned = old_regions_loaned_for_young_evac * region_size_bytes;\n-      \/\/ Need to enforce that old_evacuation_committed + old_bytes_loaned >= minimum_evacuation_reserve\n-      \/\/ in order to prevent promotion reserve from violating minimum evacuation reserve.\n-      if (old_evacuation_committed + old_bytes_loaned < minimum_evacuation_reserve) {\n-        \/\/ Pretend the old_evacuation_commitment is larger than what will be evacuated to assure that promotions\n-        \/\/ do not fill the minimum_evacuation_reserve.  Note that regions loaned from old-gen will be returned\n-        \/\/ to old-gen before we start a subsequent evacuation.\n-        old_evacuation_committed = minimum_evacuation_reserve - old_bytes_loaned;\n-      }\n-\n-      \/\/ Limit promoted_reserve so that we can set aside memory to be loaned from old-gen to young-gen.  This\n-      \/\/ value is not \"critical\".  If we underestimate, certain promotions will simply be deferred.  If we put\n-      \/\/ \"all the rest\" of old-gen memory into the promotion reserve, we'll have nothing left to loan to young-gen\n-      \/\/ during the evac and update phases of GC.  So we \"limit\" the sizes of the promotion budget to be the smaller of:\n-      \/\/\n-      \/\/  1. old_gen->available - (old_evacuation_committed + old_bytes_loaned + consumed_by_advance_promotion)\n-      \/\/  2. young bytes reserved for evacuation\n-\n-      assert(old_generation->available() > old_evacuation_committed, \"Cannot evacuate more than available\");\n-      assert(old_generation->available() > old_evacuation_committed + old_bytes_loaned, \"Cannot loan more than available\");\n-      assert(old_generation->available() > old_evacuation_committed + old_bytes_loaned + consumed_by_advance_promotion,\n-             \"Cannot promote more than available\");\n-\n-      size_t old_avail = old_generation->available();\n-      size_t promotion_reserve = old_avail - (old_evacuation_committed + consumed_by_advance_promotion + old_bytes_loaned);\n-\n-      \/\/ We experimented with constraining promoted_reserve to be no larger than 4 times the size of previously_promoted,\n-      \/\/ but this constraint was too limiting, resulting in failure of legitimate promotions.\n-\n-      \/\/ We had also experimented with constraining promoted_reserve to be no more than young_evacuation_committed\n-      \/\/ divided by promotion_divisor, where:\n-      \/\/  size_t promotion_divisor = (0x02 << InitialTenuringThreshold) - 1;\n-      \/\/ This also was found to be too limiting, resulting in failure of legitimate promotions.\n-      \/\/\n-      \/\/ Both experiments were conducted in the presence of other bugs which could have been the root cause for\n-      \/\/ the failures identified above as being \"too limiting\".  TODO: conduct new experiments with the more limiting\n-      \/\/ values of young_evacuation_reserved_used.\n-      young_evacuation_reserve_used -= consumed_by_advance_promotion;\n-      if (young_evacuation_reserve_used < promotion_reserve) {\n-        \/\/ Shrink promotion_reserve if its larger than the memory to be consumed by evacuating all young objects in\n-        \/\/ collection set, including anticipated waste.  There's no benefit in using a larger promotion_reserve.\n-        promotion_reserve = young_evacuation_reserve_used;\n-      }\n-\n-      assert(old_avail >= promotion_reserve + old_evacuation_committed + old_bytes_loaned + consumed_by_advance_promotion,\n-             \"Budget exceeds available old-gen memory\");\n-      log_info(gc, ergo)(\"Old available: \" SIZE_FORMAT \", Original promotion reserve: \" SIZE_FORMAT \", Old evacuation reserve: \"\n-                         SIZE_FORMAT \", Advance promotion reserve supplement: \" SIZE_FORMAT \", Old loaned to young: \" SIZE_FORMAT,\n-                         old_avail, promotion_reserve, old_evacuation_committed, consumed_by_advance_promotion,\n-                         old_regions_loaned_for_young_evac * region_size_bytes);\n-      promotion_reserve += consumed_by_advance_promotion;\n-      heap->set_promoted_reserve(promotion_reserve);\n-      heap->reset_promoted_expended();\n-      if (collection_set->get_old_bytes_reserved_for_evacuation() == 0) {\n-        \/\/ Setting old evacuation reserve to zero denotes that there is no old-gen evacuation in this pass.\n-        heap->set_old_evac_reserve(0);\n-      }\n-\n-      size_t old_gen_usage_base = old_generation->used() - collection_set->get_old_garbage();\n-      heap->capture_old_usage(old_gen_usage_base);\n-\n-      \/\/ Compute the evacuation supplement, which is extra memory borrowed from old-gen that can be allocated\n-      \/\/ by mutators while GC is working on evacuation and update-refs.  This memory can be temporarily borrowed\n-      \/\/ from old-gen allotment, then repaid at the end of update-refs from the recycled collection set.  After\n-      \/\/ we have computed the collection set based on the parameters established above, we can make additional\n-      \/\/ loans based on our knowledge of the collection set to determine how much allocation we can allow\n-      \/\/ during the evacuation and update-refs phases of execution.  The total available supplement is the smaller of:\n-      \/\/\n-      \/\/   1. old_gen->available() -\n-      \/\/        (promotion_reserve + old_evacuation_commitment + old_bytes_loaned)\n-      \/\/   2. The replenishment budget (number of regions in collection set - the number of regions already\n-      \/\/         under lien for the young_evacuation_reserve)\n-      \/\/\n-\n-      size_t young_regions_evacuated = collection_set->get_young_region_count();\n-      size_t regions_for_runway = 0;\n-      if (young_regions_evacuated > old_regions_loaned_for_young_evac) {\n-        regions_for_runway = young_regions_evacuated - old_regions_loaned_for_young_evac;\n-        old_regions_loaned_for_young_evac = young_regions_evacuated;\n-        regions_available_to_loan -= regions_for_runway;\n-      }\n-\n-      size_t allocation_supplement = regions_for_runway * region_size_bytes;\n-      heap->set_alloc_supplement_reserve(allocation_supplement);\n-\n-      size_t promotion_budget = heap->get_promoted_reserve();\n-      size_t old_evac_budget = heap->get_old_evac_reserve();\n-      size_t alloc_budget_evac_and_update = allocation_supplement + young_generation->available();\n-\n-      \/\/ TODO: young_available, which feeds into alloc_budget_evac_and_update is lacking memory available within\n-      \/\/ existing young-gen regions that were not selected for the collection set.  Add this in and adjust the\n-      \/\/ log message (where it says \"empty-region allocation budget\").\n-\n-      log_info(gc, ergo)(\"Memory reserved for evacuation and update-refs includes promotion budget: \" SIZE_FORMAT\n-                         \"%s, young evacuation budget: \" SIZE_FORMAT \"%s, old evacuation budget: \" SIZE_FORMAT\n-                         \"%s, empty-region allocation budget: \" SIZE_FORMAT \"%s, including supplement: \" SIZE_FORMAT \"%s\",\n-                         byte_size_in_proper_unit(promotion_budget), proper_unit_for_byte_size(promotion_budget),\n-                         byte_size_in_proper_unit(young_evacuation_reserve_used),\n-                         proper_unit_for_byte_size(young_evacuation_reserve_used),\n-                         byte_size_in_proper_unit(old_evac_budget), proper_unit_for_byte_size(old_evac_budget),\n-                         byte_size_in_proper_unit(alloc_budget_evac_and_update),\n-                         proper_unit_for_byte_size(alloc_budget_evac_and_update),\n-                         byte_size_in_proper_unit(allocation_supplement), proper_unit_for_byte_size(allocation_supplement));\n+    if (!collection_set->is_empty()) {\n+      adjust_evacuation_budgets(heap, collection_set, old_regions_loaned_for_young_evac, regions_available_to_loan,\n+                                minimum_evacuation_reserve, consumed_by_advance_promotion);\n@@ -600,0 +696,1 @@\n+    \/\/ otherwise, this is an abbreviated cycle and we make no use of evacuation budgets.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":437,"deletions":340,"binary":false,"changes":777,"status":"modified"},{"patch":"@@ -114,0 +114,10 @@\n+  \/\/ Compute evacuation budgets prior to choosing collection set.\n+  void compute_evacuation_budgets(ShenandoahHeap* heap, bool* preselected_regions, ShenandoahCollectionSet* collection_set, \n+                                  size_t &old_regions_loaned_for_young_evac, size_t &regions_available_to_loan,\n+                                  size_t &minimum_evacuation_reserve, size_t &consumed_by_advance_promotion);\n+\n+  \/\/ Adjust evacuation budgets after choosing collection set.\n+  void adjust_evacuation_budgets(ShenandoahHeap* heap, ShenandoahCollectionSet* collection_set,\n+                                 size_t old_regions_loaned_for_young_evac, size_t regions_available_to_loan,\n+                                 size_t minimum_evacuation_reserve, size_t consumed_by_advance_promotion);\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -660,9 +660,11 @@\n-  if (FLAG_IS_CMDLINE(NewSize) && !FLAG_IS_CMDLINE(MaxNewSize) && !FLAG_IS_CMDLINE(NewRatio)) {\n-    capacity = MIN2(NewSize, capacity);\n-  } else {\n-    capacity \/= NewRatio + 1;\n-    if (FLAG_IS_CMDLINE(NewSize)) {\n-      capacity = MAX2(NewSize, capacity);\n-    }\n-    if (FLAG_IS_CMDLINE(MaxNewSize)) {\n-      capacity = MIN2(MaxNewSize, capacity);\n+  if (strcmp(ShenandoahGCMode, \"generational\") == 0) {\n+    if (FLAG_IS_CMDLINE(NewSize) && !FLAG_IS_CMDLINE(MaxNewSize) && !FLAG_IS_CMDLINE(NewRatio)) {\n+      capacity = MIN2(NewSize, capacity);\n+    } else {\n+      capacity \/= NewRatio + 1;\n+      if (FLAG_IS_CMDLINE(NewSize)) {\n+        capacity = MAX2(NewSize, capacity);\n+      }\n+      if (FLAG_IS_CMDLINE(MaxNewSize)) {\n+        capacity = MIN2(MaxNewSize, capacity);\n+      }\n@@ -671,0 +673,1 @@\n+  \/\/ else, make no adjustment to global capacity\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -689,0 +689,1 @@\n+  shenandoah_assert_heaplocked();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -540,1 +540,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahReferenceProcessor.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -104,0 +104,9 @@\n+  product(uintx, ShenandoahIgnoreGarbageThreshold, 5, EXPERIMENTAL,         \\\n+          \"When less than this amount of garbage (as a percentage of \"      \\\n+          \"region size) exists within a region, the region will not be \"    \\\n+          \"added to the collection set, even when the heuristic has \"       \\\n+          \"chosen to aggressively add regions with less than \"              \\\n+          \"ShenandoahGarbageThreshold amount of garbage into the \"          \\\n+          \"collection set.\")                                                \\\n+          range(0,100)                                                      \\\n+                                                                            \\\n@@ -502,16 +511,0 @@\n-  product(uintx, ShenandoahTenuredRegionUsageBias, 16, EXPERIMENTAL,        \\\n-          \"The collection set is comprised of heap regions that contain \"   \\\n-          \"the greatest amount of garbage.  \"                               \\\n-          \"For purposes of selecting regions to be included in the \"        \\\n-          \"collection set, regions that have reached the tenure age will \"  \\\n-          \"be treated as if their contained garbage is the contained \"      \\\n-          \"garbage multiplied by ShenandoahTenuredRegionUsageBias as \"      \\\n-          \"many times as the age of the region meets or exceeds \"           \\\n-          \"tenure age.  For example, if tenure age is 7, \"                  \\\n-          \"the region age is 9, ShenandoahTenuredRegionUsageBias is \"       \\\n-          \"16, and the region is 12.5% garbage, this region \"               \\\n-          \"will by treated as if its garbage content is \"                   \\\n-          \"12.5% * 16 * 16 * 16 = 51,200% when comparing this region \"      \\\n-          \" to untenured regions.\")                                         \\\n-          range(1,128)                                                      \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoah_globals.hpp","additions":9,"deletions":16,"binary":false,"changes":25,"status":"modified"}]}