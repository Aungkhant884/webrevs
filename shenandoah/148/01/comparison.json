{"files":[{"patch":"@@ -206,0 +206,1 @@\n+  collection_set->set_immediate_trash(immediate_garbage);\n@@ -212,0 +213,1 @@\n+      \/\/ We can shrink old_evac_reserve() if the chosen collection set is smaller than maximum allowed.\n@@ -220,86 +222,0 @@\n-    ShenandoahYoungGeneration* young_generation = heap->young_generation();\n-    size_t young_evacuation_reserve = (young_generation->soft_max_capacity() * ShenandoahEvacReserve) \/ 100;\n-\n-    \/\/ At this point, young_generation->available() does not know about recently discovered immediate garbage.\n-    \/\/ What memory it does think to be available is not entirely trustworthy because any available memory associated\n-    \/\/ with a region that is placed into the collection set becomes unavailable when the region is chosen\n-    \/\/ for the collection set.  We'll compute an approximation of young available.  If young_available is zero,\n-    \/\/ we'll need to borrow from old-gen in order to evacuate.  If there's nothing to borrow, we're going to\n-    \/\/ degenerate to full GC.\n-\n-    \/\/ TODO: young_available can include available (between top() and end()) within each young region that is not\n-    \/\/ part of the collection set.  Making this memory available to the young_evacuation_reserve allows a larger\n-    \/\/ young collection set to be chosen when available memory is under extreme pressure.  Implementing this \"improvement\"\n-    \/\/ is tricky, because the incremental construction of the collection set actually changes the amount of memory\n-    \/\/ available to hold evacuated young-gen objects.  As currently implemented, the memory that is available within\n-    \/\/ non-empty regions that are not selected as part of the collection set can be allocated by the mutator while\n-    \/\/ GC is evacuating and updating references.\n-\n-    size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n-    size_t free_affiliated_regions = immediate_regions + free_regions;\n-    size_t young_available = (free_affiliated_regions + young_generation->free_unaffiliated_regions()) * region_size_bytes;\n-\n-    size_t regions_available_to_loan = 0;\n-\n-    if (heap->mode()->is_generational()) {\n-      \/\/  Now that we've primed the collection set, we can figure out how much memory to reserve for evacuation\n-      \/\/  of young-gen objects.\n-      \/\/\n-      \/\/  YoungEvacuationReserve for young generation: how much memory are we reserving to hold the results\n-      \/\/     of evacuating young collection set regions?  This is typically smaller than the total amount\n-      \/\/     of available memory, and is also smaller than the total amount of marked live memory within\n-      \/\/     young-gen.  This value is the minimum of:\n-      \/\/       1. young_gen->available() + (old_gen->available - (OldEvacuationReserve + PromotionReserve))\n-      \/\/       2. young_gen->capacity() * ShenandoahEvacReserve\n-      \/\/\n-      \/\/     Note that any region added to the collection set will be completely evacuated and its memory will\n-      \/\/     be completely recycled at the end of GC.  The recycled memory will be at least as great as the\n-      \/\/     memory borrowed from old-gen.  Enforce that the amount borrowed from old-gen for YoungEvacuationReserve\n-      \/\/     is an integral number of entire heap regions.\n-      \/\/\n-      young_evacuation_reserve -= heap->get_old_evac_reserve();\n-\n-      \/\/ Though we cannot know the evacuation_supplement until after we have computed the collection set, we do\n-      \/\/ know that every young-gen region added to the collection set will have a net positive impact on available\n-      \/\/ memory within young-gen, since each contributes a positive amount of garbage to available.  Thus, even\n-      \/\/ without knowing the exact composition of the collection set, we can allow young_evacuation_reserve to\n-      \/\/ exceed young_available if there are empty regions available within old-gen to hold the results of evacuation.\n-\n-      ShenandoahGeneration* old_generation = heap->old_generation();\n-\n-      \/\/ Not all of what is currently available within young-gen can be reserved to hold the results of young-gen\n-      \/\/ evacuation.  This is because memory available within any heap region that is placed into the collection set\n-      \/\/ is not available to be allocated during evacuation.  To be safe, we assure that all memory required for evacuation\n-      \/\/ is available within \"virgin\" heap regions.\n-\n-      const size_t available_young_regions = free_regions + immediate_regions + young_generation->free_unaffiliated_regions();\n-      const size_t available_old_regions = old_generation->free_unaffiliated_regions();\n-      size_t already_reserved_old_bytes = heap->get_old_evac_reserve() + heap->get_promoted_reserve();\n-      size_t regions_reserved_for_evac_and_promotion = (already_reserved_old_bytes + region_size_bytes - 1) \/ region_size_bytes;\n-      regions_available_to_loan = available_old_regions - regions_reserved_for_evac_and_promotion;\n-\n-      if (available_young_regions * region_size_bytes < young_evacuation_reserve) {\n-        \/\/ Try to borrow old-gen regions in order to avoid shrinking young_evacuation_reserve\n-        size_t loan_request = young_evacuation_reserve - available_young_regions * region_size_bytes;\n-        size_t loaned_region_request = (loan_request + region_size_bytes - 1) \/ region_size_bytes;\n-        if (loaned_region_request > regions_available_to_loan) {\n-          \/\/ Scale back young_evacuation_reserve to consume all available young and old regions.  After the\n-          \/\/ collection set is chosen, we may get some of this memory back for pacing allocations during evacuation\n-          \/\/ and update refs.\n-          loaned_region_request = regions_available_to_loan;\n-          young_evacuation_reserve = (available_young_regions + loaned_region_request) * region_size_bytes;\n-        } else {\n-          \/\/ No need to scale back young_evacuation_reserve.\n-        }\n-      } else {\n-        \/\/ No need scale back young_evacuation_reserve and no need to borrow from old-gen.  We may even have some\n-        \/\/ available_young_regions to support allocation pacing.\n-      }\n-\n-    } else if (young_evacuation_reserve > young_available) {\n-      \/\/ In non-generational mode, there's no old-gen memory to borrow from\n-      young_evacuation_reserve = young_available;\n-    }\n-\n-    heap->set_young_evac_reserve(young_evacuation_reserve);\n-\n@@ -309,49 +225,0 @@\n-\n-    \/\/ Now compute the evacuation supplement, which is extra memory borrowed from old-gen that can be allocated\n-    \/\/ by mutators while GC is working on evacuation and update-refs.\n-\n-    \/\/ During evacuation and update refs, we will be able to allocate any memory that is currently available\n-    \/\/ plus any memory that can be borrowed on the collateral of the current collection set, reserving a certain\n-    \/\/ percentage of the anticipated replenishment from collection set memory to be allocated during the subsequent\n-    \/\/ concurrent marking effort.  This is how much I can repay.\n-    size_t potential_supplement_regions = collection_set->get_young_region_count();\n-\n-    \/\/ Though I can repay potential_supplement_regions, I can't borrow them unless they are available in old-gen.\n-    if (potential_supplement_regions > regions_available_to_loan) {\n-      potential_supplement_regions = regions_available_to_loan;\n-    }\n-\n-    size_t potential_evac_supplement;\n-\n-    \/\/ How much of the potential_supplement_regions will be consumed by young_evacuation_reserve: borrowed_evac_regions.\n-    const size_t available_unaffiliated_young_regions = young_generation->free_unaffiliated_regions();\n-    const size_t available_affiliated_regions = free_regions + immediate_regions;\n-    const size_t available_young_regions = available_unaffiliated_young_regions + available_affiliated_regions;\n-    size_t young_evac_regions = (young_evacuation_reserve + region_size_bytes - 1) \/ region_size_bytes;\n-    size_t borrowed_evac_regions = (young_evac_regions > available_young_regions)? young_evac_regions - available_young_regions: 0;\n-\n-    potential_supplement_regions -= borrowed_evac_regions;\n-    potential_evac_supplement = potential_supplement_regions * region_size_bytes;\n-\n-    \/\/ Leave some allocation runway for subsequent concurrent mark phase.\n-    potential_evac_supplement = (potential_evac_supplement * ShenandoahBorrowPercent) \/ 100;\n-\n-    heap->set_alloc_supplement_reserve(potential_evac_supplement);\n-\n-    size_t promotion_budget = heap->get_promoted_reserve();\n-    size_t old_evac_budget = heap->get_old_evac_reserve();\n-    size_t alloc_budget_evac_and_update = potential_evac_supplement + young_available;\n-\n-    \/\/ TODO: young_available, which feeds into alloc_budget_evac_and_update is lacking memory available within\n-    \/\/ existing young-gen regions that were not selected for the collection set.  Add this in and adjust the\n-    \/\/ log message (where it says \"empty-region allocation budget\").\n-\n-    log_info(gc, ergo)(\"Memory reserved for evacuation and update-refs includes promotion budget: \" SIZE_FORMAT\n-                       \"%s, young evacuation budget: \" SIZE_FORMAT \"%s, old evacuation budget: \" SIZE_FORMAT\n-                       \"%s, empty-region allocation budget: \" SIZE_FORMAT \"%s, including supplement: \" SIZE_FORMAT \"%s\",\n-                       byte_size_in_proper_unit(promotion_budget), proper_unit_for_byte_size(promotion_budget),\n-                       byte_size_in_proper_unit(young_evacuation_reserve), proper_unit_for_byte_size(young_evacuation_reserve),\n-                       byte_size_in_proper_unit(old_evac_budget), proper_unit_for_byte_size(old_evac_budget),\n-                       byte_size_in_proper_unit(alloc_budget_evac_and_update),\n-                       proper_unit_for_byte_size(alloc_budget_evac_and_update),\n-                       byte_size_in_proper_unit(potential_evac_supplement), proper_unit_for_byte_size(potential_evac_supplement));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.cpp","additions":2,"deletions":135,"binary":false,"changes":137,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+  size_t collected_old_bytes = 0;\n@@ -55,41 +56,0 @@\n-  \/\/ TODO:\n-  \/\/ The max_old_evacuation_bytes and promotion_budget_bytes constants represent a first\n-  \/\/ approximation to desired operating parameters.  Eventually, these values should be determined\n-  \/\/ by heuristics and should adjust dynamically based on most current execution behavior.  In the\n-  \/\/ interim, we offer command-line options to set the values of these configuration parameters.\n-\n-  \/\/ max_old_evacuation_bytes represents a bound on how much evacuation effort is dedicated\n-  \/\/ to old-gen regions.\n-  size_t max_old_evacuation_bytes = (heap->old_generation()->soft_max_capacity() * ShenandoahOldEvacReserve) \/ 100;\n-  const size_t young_evacuation_bytes = (heap->young_generation()->soft_max_capacity() * ShenandoahEvacReserve) \/ 100;\n-  const size_t ratio_bound_on_old_evac_bytes = (young_evacuation_bytes * ShenandoahOldEvacRatioPercent) \/ 100;\n-  if (max_old_evacuation_bytes > ratio_bound_on_old_evac_bytes) {\n-    max_old_evacuation_bytes = ratio_bound_on_old_evac_bytes;\n-  }\n-\n-  \/\/ Usually, old-evacuation is limited by the CPU bounds on effort.  However, it can also be bounded by available\n-  \/\/ memory within old-gen to hold the results of evacuation.  When we are bound by memory availability, we need\n-  \/\/ to account below for the loss of available memory from within each region that is added to the old-gen collection\n-  \/\/ set.\n-  size_t old_available = heap->old_generation()->available();\n-  size_t excess_old_capacity_for_evacuation;\n-  if (max_old_evacuation_bytes > old_available) {\n-    max_old_evacuation_bytes = old_available;\n-    excess_old_capacity_for_evacuation = 0;\n-  } else {\n-    excess_old_capacity_for_evacuation = old_available - max_old_evacuation_bytes;\n-  }\n-\n-  \/\/ promotion_budget_bytes represents an \"arbitrary\" bound on how many bytes can be consumed by young-gen\n-  \/\/ objects promoted into old-gen memory.  We need to avoid a scenario under which promotion of objects\n-  \/\/ depletes old-gen available memory to the point that there is insufficient memory to hold old-gen objects\n-  \/\/ that need to be evacuated from within the old-gen collection set.\n-  \/\/\n-  \/\/ Key idea: if there is not sufficient memory within old-gen to hold an object that wants to be promoted, defer\n-  \/\/ promotion until a subsequent evacuation pass.  Enforcement is provided at the time PLABs and shared allocations\n-  \/\/ in old-gen memory are requested.\n-\n-  const size_t promotion_budget_bytes = heap->get_promoted_reserve();\n-\n-  \/\/ old_evacuation_budget is an upper bound on the amount of live memory that can be evacuated.\n-  \/\/\n@@ -100,6 +60,1 @@\n-  \/\/ budget is constrained by availability of free memory.  See remaining_old_evacuation_budget below.\n-\n-  size_t old_evacuation_budget = (size_t) (max_old_evacuation_bytes \/ ShenandoahEvacWaste);\n-\n-  log_info(gc)(\"Choose old regions for mixed collection: old evacuation budget: \" SIZE_FORMAT \"%s\",\n-                byte_size_in_proper_unit(old_evacuation_budget), proper_unit_for_byte_size(old_evacuation_budget));\n+  \/\/ budget is constrained by availability of free memory.\n@@ -107,0 +62,1 @@\n+  size_t old_evacuation_budget = (size_t) (heap->get_old_evac_reserve() \/ ShenandoahEvacWaste);\n@@ -109,0 +65,3 @@\n+  log_info(gc)(\"Choose old regions for mixed collection: old evacuation budget: \" SIZE_FORMAT \"%s, candidates: %u\",\n+               byte_size_in_proper_unit(old_evacuation_budget), proper_unit_for_byte_size(old_evacuation_budget),\n+               unprocessed_old_collection_candidates());\n@@ -110,3 +69,2 @@\n-  \/\/ The number of old-gen regions that were selected as candidates for collection at the end of the most recent\n-  \/\/ old-gen concurrent marking phase and have not yet been collected is represented by\n-  \/\/ unprocessed_old_collection_candidates()\n+  \/\/ The number of old-gen regions that were selected as candidates for collection at the end of the most recent old-gen\n+  \/\/ concurrent marking phase and have not yet been collected is represented by unprocessed_old_collection_candidates()\n@@ -117,1 +75,0 @@\n-\n@@ -120,4 +77,1 @@\n-    if ((r->get_live_data_bytes() <= remaining_old_evacuation_budget) &&\n-        ((lost_evacuation_capacity + r->free() <= excess_old_capacity_for_evacuation)\n-         || (r->get_live_data_bytes() + r->free() <= remaining_old_evacuation_budget))) {\n-\n+    if (r->get_live_data_bytes() <= remaining_old_evacuation_budget) {\n@@ -129,10 +83,0 @@\n-      if (lost_evacuation_capacity > excess_old_capacity_for_evacuation) {\n-        \/\/ This is slightly conservative because we really only need to remove from the remaining evacuation budget\n-        \/\/ the amount by which lost_evacution_capacity exceeds excess_old_capacity_for_evacuation, but this is relatively\n-        \/\/ rare event and current thought is to be a bit conservative rather than mess up the math on code that is so\n-        \/\/ difficult to test and maintain...\n-\n-        \/\/ Once we have crossed the threshold of lost_evacuation_capacity exceeding excess_old_capacity_for_evacuation,\n-        \/\/ every subsequent iteration of this loop will further decrease remaining_old_evacuation_budget.\n-        remaining_old_evacuation_budget -= r->free();\n-      }\n@@ -142,0 +86,1 @@\n+      collected_old_bytes += r->garbage();\n@@ -149,2 +94,4 @@\n-    log_info(gc)(\"Old-gen piggyback evac (\" UINT32_FORMAT \" regions, \" SIZE_FORMAT \" %s)\",\n-                 included_old_regions, byte_size_in_proper_unit(evacuated_old_bytes), proper_unit_for_byte_size(evacuated_old_bytes));\n+    log_info(gc)(\"Old-gen piggyback evac (\" UINT32_FORMAT \" regions, evacuating \" SIZE_FORMAT \"%s, reclaiming: \" SIZE_FORMAT \"%s)\",\n+                 included_old_regions,\n+                 byte_size_in_proper_unit(evacuated_old_bytes), proper_unit_for_byte_size(evacuated_old_bytes),\n+                 byte_size_in_proper_unit(collected_old_bytes), proper_unit_for_byte_size(collected_old_bytes));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.cpp","additions":14,"deletions":67,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -224,1 +224,346 @@\n-void  ShenandoahGeneration::prepare_regions_and_collection_set(bool concurrent) {\n+void ShenandoahGeneration::compute_evacuation_budgets(ShenandoahHeap* heap, ShenandoahCollectionSet* collection_set,\n+                                                      size_t &old_regions_loaned_for_young_evac, size_t &regions_available_to_loan,\n+                                                      size_t &minimum_evacuation_reserve, size_t &consumed_by_advance_promotion) {\n+  size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n+  minimum_evacuation_reserve = ShenandoahOldCompactionReserve * region_size_bytes;\n+  old_regions_loaned_for_young_evac = 0;\n+  regions_available_to_loan = 0;\n+  consumed_by_advance_promotion = 0;\n+  if (heap->mode()->is_generational()) {\n+    ShenandoahGeneration* old_generation = heap->old_generation();\n+    ShenandoahYoungGeneration* young_generation = heap->young_generation();\n+    size_t avail_evac_reserve_for_loan_to_young_gen = 0;\n+    size_t old_evacuation_reserve = 0;\n+    size_t num_regions = heap->num_regions();\n+    bool preselected_regions[num_regions];\n+    for (unsigned int i = 0; i < num_regions; i++) {\n+      preselected_regions[i] = false;\n+    }\n+\n+    \/\/ During initialization and phase changes, it is more likely that fewer objects die young and old-gen\n+    \/\/ memory is not yet full (or is in the process of being replaced).  During these times especially, it\n+    \/\/ is beneficial to loan memory from old-gen to young-gen during the evacuation and update-refs phases\n+    \/\/ of execution.\n+\n+    \/\/ Calculate EvacuationReserve before PromotionReserve.  Evacuation is more critical than promotion.\n+    \/\/ If we cannot evacuate old-gen, we will not be able to reclaim old-gen memory.  Promotions are less\n+    \/\/ critical.  If we cannot promote, there may be degradation of young-gen memory because old objects\n+    \/\/ accumulate there until they can be promoted.  This increases the young-gen marking and evacuation work.\n+\n+    \/\/ Do not fill up old-gen memory with promotions.  Reserve some amount of memory for compaction purposes.\n+    ShenandoahOldHeuristics* old_heuristics = heap->old_heuristics();\n+    if (old_heuristics->unprocessed_old_collection_candidates() > 0) {\n+      \/\/ Compute old_evacuation_reserve: how much memory are we reserving to hold the results of\n+      \/\/ evacuating old-gen heap regions?  In order to sustain a consistent pace of young-gen collections,\n+      \/\/ the goal is to maintain a consistent value for this parameter (when the candidate set is not\n+      \/\/ empty).  This value is the minimum of:\n+      \/\/   1. old_gen->available()\n+      \/\/   2. old-gen->capacity() * ShenandoahOldEvacReserve) \/ 100\n+      \/\/       (e.g. old evacuation should be no larger than 5% of old_gen capacity)\n+      \/\/   3. ((young_gen->capacity * ShenandoahEvacReserve \/ 100) * ShenandoahOldEvacRatioPercent) \/ 100\n+      \/\/       (e.g. old evacuation should be no larger than 12% of young-gen evacuation)\n+      old_evacuation_reserve = old_generation->available();\n+      assert(old_evacuation_reserve > minimum_evacuation_reserve, \"Old-gen available has not been preserved!\");\n+      size_t old_evac_reserve_max = old_generation->soft_max_capacity() * ShenandoahOldEvacReserve \/ 100;\n+      if (old_evac_reserve_max < old_evacuation_reserve) {\n+        old_evacuation_reserve = old_evac_reserve_max;\n+      }\n+      size_t young_evac_reserve_max =\n+        (((young_generation->soft_max_capacity() * ShenandoahEvacReserve) \/ 100) * ShenandoahOldEvacRatioPercent) \/ 100;\n+      if (young_evac_reserve_max < old_evacuation_reserve) {\n+        old_evacuation_reserve = young_evac_reserve_max;\n+      }\n+    }\n+\n+    if (minimum_evacuation_reserve > old_generation->available()) {\n+      \/\/ Due to round-off errors during enforcement of minimum_evacuation_reserve during previous GC passes,\n+      \/\/ there can be slight discrepancies here.\n+      minimum_evacuation_reserve = old_generation->available();\n+    }\n+    if (old_evacuation_reserve < minimum_evacuation_reserve) {\n+      \/\/ Even if there's nothing to be evacuated on this cycle, we still need to reserve this memory for future\n+      \/\/ evacuations.  It is ok to loan this memory to young-gen if we don't need it for evacuation on this pass.\n+      avail_evac_reserve_for_loan_to_young_gen = minimum_evacuation_reserve - old_evacuation_reserve;\n+      old_evacuation_reserve = minimum_evacuation_reserve;\n+    }\n+\n+    heap->set_old_evac_reserve(old_evacuation_reserve);\n+    heap->reset_old_evac_expended();\n+\n+    \/\/ Compute the young evauation reserve: This is how much memory is available for evacuating young-gen objects.\n+    \/\/ We ignore the possible effect of promotions, which reduce demand for young-gen evacuation memory.\n+    \/\/\n+    \/\/ TODO: We could give special treatment to the regions that have reached promotion age, because we know their\n+    \/\/ live data is entirely eligible for promotion.  This knowledge can feed both into calculations of young-gen\n+    \/\/ evacuation reserve and promotion reserve.\n+    \/\/\n+    \/\/  young_evacuation_reserve for young generation: how much memory are we reserving to hold the results\n+    \/\/  of evacuating young collection set regions?  This is typically smaller than the total amount\n+    \/\/  of available memory, and is also smaller than the total amount of marked live memory within\n+    \/\/  young-gen.  This value is the smaller of\n+    \/\/\n+    \/\/    1. (young_gen->capacity() * ShenandoahEvacReserve) \/ 100\n+    \/\/    2. (young_gen->available() + old_gen_memory_available_to_be_loaned\n+    \/\/\n+    \/\/  ShenandoahEvacReserve represents the configured taget size of the evacuation region.  We can only honor\n+    \/\/  this target if there is memory available to hold the evacuations.  Memory is available if it is already\n+    \/\/  free within young gen, or if it can be borrowed from old gen.  Since we have not yet chosen the collection\n+    \/\/  sets, we do not yet know the exact accounting of how many regions will be freed by this collection pass.\n+    \/\/  What we do know is that there will be at least one evacuated young-gen region for each old-gen region that\n+    \/\/  is loaned to the evacuation effort (because regions to be collected consume more memory than the compacted\n+    \/\/  regions that will replace them).  In summary, if there are old-gen regions that are available to hold the\n+    \/\/  results of young-gen evacuations, it is safe to loan them for this purpose.  At this point, we have not yet\n+    \/\/  established a promoted_reserve.  We'll do that after we choose the collection set and analyze its impact\n+    \/\/  on available memory.\n+    \/\/\n+    \/\/ We do not know the evacuation_supplement until after we have computed the collection set.  It is not always\n+    \/\/ the case that young-regions inserted into the collection set will result in net decrease of in-use regions\n+    \/\/ because ShenandoahEvacWaste times multiplied by memory within the region may be larger than the region size.\n+    \/\/ The problem is especially relevant to regions that have been inserted into the collection set because they have\n+    \/\/ reached tenure age.  These regions tend to have much higher utilization (e.g. 95%).  These regions also offer\n+    \/\/ a unique opportunity because we know that every live object contained within the region is elgible to be\n+    \/\/ promoted.  Thus, the following implementation treats these regions specially:\n+    \/\/\n+    \/\/  1. Before beginning collection set selection, we tally the total amount of live memory held within regions\n+    \/\/     that are known to have reached tenure age.  If this memory times ShenandoahEvacWaste is available within\n+    \/\/     old-gen memory, establish an advance promotion reserve to hold all or some percentage of these objects.\n+    \/\/     This advance promotion reserve is excluded from memory available for holding old-gen evacuations and cannot\n+    \/\/     be \"loaned\" to young gen.\n+    \/\/\n+    \/\/  2. Tenure-aged regions are included in the collection set iff their evacuation size * ShenandoahEvacWaste fits\n+    \/\/     within the advance promotion reserve.  It is counter productive to evacuate these regions if they cannot be\n+    \/\/     evacuated directly into old-gen memory.  So if there is not sufficient memory to hold copies of their\n+    \/\/     live data right now, we'll just let these regions remain in young for now, to be evacuated by a subsequent\n+    \/\/     evacuation pass.\n+    \/\/\n+    \/\/  3. Next, we calculate a young-gen evacuation budget, which is the smaller of the two quantities mentioned\n+    \/\/     above.  old_gen_memory_available_to_be_loaned is calculated as:\n+    \/\/       old_gen->available - (advance-promotion-reserve + old-gen_evacuation_reserve)\n+    \/\/\n+    \/\/  4. When choosing the collection set, special care is taken to assure that the amount of loaned memory required to\n+    \/\/     hold the results of evacuation is smaller than the total memory occupied by the regions added to the collection\n+    \/\/     set.  We need to take these precautions because we do not know how much memory will be reclaimed by evacuation\n+    \/\/     until after the collection set has been constructed.  The algorithm is as follows:\n+    \/\/\n+    \/\/     a. We feed into the algorithm (i) young available at the start of evacuation and (ii) the amount of memory\n+    \/\/        loaned from old-gen that is available to hold the results of evacuation.\n+    \/\/     b. As candidate regions are added into the young-gen collection set, we maintain accumulations of the amount\n+    \/\/        of memory spanned by the collection set regions and the amount of memory that must be reserved to hold\n+    \/\/        evacuation results (by multiplying live-data size by ShenandoahEvacWaste).  We process candidate regions\n+    \/\/        in order of decreasing amounts of garbage.  We skip over (and do not include into the collection set) any\n+    \/\/        regions that do not satisfy all of the following conditions:\n+    \/\/\n+    \/\/          i. The amount of live data within the region as scaled by ShenandoahEvacWaste must fit within the\n+    \/\/             relevant evacuation reserve (live data of old-gen regions must fit within the old-evac-reserve, live\n+    \/\/             data of young-gen tenure-aged regions must fit within the advance promotion reserve, live data within\n+    \/\/             other young-gen regions must fit within the youn-gen evacuation reserve).\n+    \/\/         ii. The accumulation of memory consumed by evacuation must not exceed the accumulation of memory reclaimed\n+    \/\/             through evacuation by more than young-gen available.\n+    \/\/        iii. Other conditions may be enforced as appropriate for specific heuristics.\n+    \/\/\n+    \/\/       Note that regions are considered for inclusion in the selection set in order of decreasing amounts of garbage.\n+    \/\/       It is possible that a region with a larger amount of garbage will be rejected because it also has a larger\n+    \/\/       amount of live data and some region that follows this region in candidate order is included in the collection\n+    \/\/       set (because it has less live data and thus can fit within the evacuation limits even though it has less\n+    \/\/       garbage).\n+\n+    size_t young_evacuation_reserve = (young_generation->max_capacity() * ShenandoahEvacReserve) \/ 100;\n+    \/\/ old evacuation can pack into existing partially used regions.  young evacuation and loans for young allocations\n+    \/\/ need to target regions that do not already hold any old-gen objects.  Round down.\n+    regions_available_to_loan = old_generation->free_unaffiliated_regions();\n+    consumed_by_advance_promotion = _heuristics->select_aged_regions(old_generation->available() - old_evacuation_reserve,\n+                                                                     num_regions, preselected_regions);\n+    size_t net_available_old_regions =\n+      (old_generation->available() - old_evacuation_reserve - consumed_by_advance_promotion) \/ region_size_bytes;\n+\n+    if (regions_available_to_loan > net_available_old_regions) {\n+      regions_available_to_loan = net_available_old_regions;\n+    }\n+    \/\/ Otherwise, regions_available_to_loan is less than net_available_old_regions because available memory is\n+    \/\/ scattered between multiple partially used regions.\n+\n+    if (young_evacuation_reserve > young_generation->available()) {\n+      size_t short_fall = young_evacuation_reserve - young_generation->available();\n+      if (regions_available_to_loan * region_size_bytes >= short_fall) {\n+        old_regions_loaned_for_young_evac = (short_fall + region_size_bytes - 1) \/ region_size_bytes;\n+        regions_available_to_loan -= old_regions_loaned_for_young_evac;\n+      } else {\n+        old_regions_loaned_for_young_evac = regions_available_to_loan;\n+        regions_available_to_loan = 0;\n+        young_evacuation_reserve = young_generation->available() + old_regions_loaned_for_young_evac * region_size_bytes;\n+      }\n+    } else {\n+      old_regions_loaned_for_young_evac = 0;\n+    }\n+    \/\/ In generational mode, we may end up choosing a young collection set that contains so many promotable objects\n+    \/\/ that there is not sufficient space in old generation to hold the promoted objects.  That is ok because we have\n+    \/\/ assured there is sufficient space in young generation to hold the rejected promotion candidates.  These rejected\n+    \/\/ promotion candidates will presumably be promoted in a future evacuation cycle.\n+    heap->set_young_evac_reserve(young_evacuation_reserve);\n+    collection_set->establish_preselected(preselected_regions);\n+  } else {\n+    \/\/ Not generational mode: limit young evac reserve by young available; no need to establish old_evac_reserve.\n+    ShenandoahYoungGeneration* young_generation = heap->young_generation();\n+    size_t young_evac_reserve = (young_generation->soft_max_capacity() * ShenandoahEvacReserve) \/ 100;\n+    if (young_evac_reserve > young_generation->available()) {\n+      young_evac_reserve = young_generation->available();\n+    }\n+    heap->set_young_evac_reserve(young_evac_reserve);\n+  }\n+}\n+\n+\/\/ Having chosen the collection set, adjust the budgets for generatioal mode based on its composition.  Note\n+\/\/ that young_generation->available() now knows about recently discovered immediate garbage.\n+void ShenandoahGeneration::adjust_evacuation_budgets(ShenandoahHeap* heap, ShenandoahCollectionSet* collection_set,\n+                                                     size_t old_regions_loaned_for_young_evac, size_t regions_available_to_loan,\n+                                                     size_t minimum_evacuation_reserve, size_t consumed_by_advance_promotion) {\n+  if (heap->mode()->is_generational()) {\n+    size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n+    ShenandoahGeneration* old_generation = heap->old_generation();\n+    ShenandoahYoungGeneration* young_generation = heap->young_generation();\n+    size_t old_evacuation_committed = (size_t) (ShenandoahEvacWaste *\n+                                                collection_set->get_old_bytes_reserved_for_evacuation());\n+    size_t old_evacuation_reserve = heap->get_old_evac_reserve();\n+    size_t immediate_garbage_regions = collection_set->get_immediate_trash() \/ region_size_bytes;\n+\n+    collection_set->abandon_preselected();\n+    if (old_evacuation_committed > old_evacuation_reserve) {\n+      \/\/ This should only happen due to round-off errors when enforcing ShenandoahEvacWaste\n+      assert(old_evacuation_committed < (33 * old_evacuation_reserve) \/ 32, \"Round-off errors should be less than 3.125%%\");\n+      old_evacuation_committed = old_evacuation_reserve;\n+    }\n+\n+    \/\/ Recompute old_regions_loaned_for_young_evac because young-gen collection set may not need all the memory\n+    \/\/ originally reserved.\n+    size_t young_evacuation_reserve_used =\n+      collection_set->get_young_bytes_reserved_for_evacuation() - collection_set->get_young_bytes_to_be_promoted();\n+    young_evacuation_reserve_used = (size_t) (ShenandoahEvacWaste * young_evacuation_reserve_used);\n+    heap->set_young_evac_reserve(young_evacuation_reserve_used);\n+\n+    \/\/ Adjust old_regions_loaned_for_young_evac to feed into calculations of promoted_reserve\n+    if (young_evacuation_reserve_used > young_generation->available()) {\n+      size_t short_fall = young_evacuation_reserve_used - young_generation->available();\n+\n+      \/\/ region_size_bytes is a power of 2.  loan an integral number of regions.\n+      size_t revised_loan_for_young_evacuation = (short_fall + region_size_bytes - 1) \/ region_size_bytes;\n+\n+      \/\/ Undo the previous loan\n+      regions_available_to_loan += old_regions_loaned_for_young_evac;\n+      old_regions_loaned_for_young_evac = revised_loan_for_young_evacuation;\n+      \/\/ And make a new loan\n+      assert(regions_available_to_loan > old_regions_loaned_for_young_evac, \"Cannot loan regions that we do not have\");\n+      regions_available_to_loan -= old_regions_loaned_for_young_evac;\n+    } else {\n+      \/\/ Undo the prevous loan\n+      regions_available_to_loan += old_regions_loaned_for_young_evac;\n+      old_regions_loaned_for_young_evac = 0;\n+    }\n+\n+    size_t old_bytes_loaned = old_regions_loaned_for_young_evac * region_size_bytes;\n+    \/\/ Need to enforce that old_evacuation_committed + old_bytes_loaned >= minimum_evacuation_reserve\n+    \/\/ in order to prevent promotion reserve from violating minimum evacuation reserve.\n+    if (old_evacuation_committed + old_bytes_loaned < minimum_evacuation_reserve) {\n+      \/\/ Pretend the old_evacuation_commitment is larger than what will be evacuated to assure that promotions\n+      \/\/ do not fill the minimum_evacuation_reserve.  Note that regions loaned from old-gen will be returned\n+      \/\/ to old-gen before we start a subsequent evacuation.\n+      old_evacuation_committed = minimum_evacuation_reserve - old_bytes_loaned;\n+    }\n+\n+    \/\/ Limit promoted_reserve so that we can set aside memory to be loaned from old-gen to young-gen.  This\n+    \/\/ value is not \"critical\".  If we underestimate, certain promotions will simply be deferred.  If we put\n+    \/\/ \"all the rest\" of old-gen memory into the promotion reserve, we'll have nothing left to loan to young-gen\n+    \/\/ during the evac and update phases of GC.  So we \"limit\" the sizes of the promotion budget to be the smaller of:\n+    \/\/\n+    \/\/  1. old_gen->available - (old_evacuation_committed + old_bytes_loaned + consumed_by_advance_promotion)\n+    \/\/  2. young bytes reserved for evacuation\n+\n+    assert(old_generation->available() > old_evacuation_committed, \"Cannot evacuate more than available\");\n+    assert(old_generation->available() > old_evacuation_committed + old_bytes_loaned, \"Cannot loan more than available\");\n+    assert(old_generation->available() > old_evacuation_committed + old_bytes_loaned + consumed_by_advance_promotion,\n+           \"Cannot promote more than available\");\n+\n+    size_t old_avail = old_generation->available();\n+    size_t promotion_reserve = old_avail - (old_evacuation_committed + consumed_by_advance_promotion + old_bytes_loaned);\n+\n+    \/\/ We experimented with constraining promoted_reserve to be no larger than 4 times the size of previously_promoted,\n+    \/\/ but this constraint was too limiting, resulting in failure of legitimate promotions.\n+\n+    \/\/ We had also experimented with constraining promoted_reserve to be no more than young_evacuation_committed\n+    \/\/ divided by promotion_divisor, where:\n+    \/\/  size_t promotion_divisor = (0x02 << InitialTenuringThreshold) - 1;\n+    \/\/ This also was found to be too limiting, resulting in failure of legitimate promotions.\n+    \/\/\n+    \/\/ Both experiments were conducted in the presence of other bugs which could have been the root cause for\n+    \/\/ the failures identified above as being \"too limiting\".  TODO: conduct new experiments with the more limiting\n+    \/\/ values of young_evacuation_reserved_used.\n+    young_evacuation_reserve_used -= consumed_by_advance_promotion;\n+    if (young_evacuation_reserve_used < promotion_reserve) {\n+      \/\/ Shrink promotion_reserve if its larger than the memory to be consumed by evacuating all young objects in\n+      \/\/ collection set, including anticipated waste.  There's no benefit in using a larger promotion_reserve.\n+      promotion_reserve = young_evacuation_reserve_used;\n+    }\n+\n+    assert(old_avail >= promotion_reserve + old_evacuation_committed + old_bytes_loaned + consumed_by_advance_promotion,\n+           \"Budget exceeds available old-gen memory\");\n+    log_info(gc, ergo)(\"Old available: \" SIZE_FORMAT \", Original promotion reserve: \" SIZE_FORMAT \", Old evacuation reserve: \"\n+                       SIZE_FORMAT \", Advance promotion reserve supplement: \" SIZE_FORMAT \", Old loaned to young: \" SIZE_FORMAT,\n+                       old_avail, promotion_reserve, old_evacuation_committed, consumed_by_advance_promotion,\n+                       old_regions_loaned_for_young_evac * region_size_bytes);\n+    promotion_reserve += consumed_by_advance_promotion;\n+    heap->set_promoted_reserve(promotion_reserve);\n+    heap->reset_promoted_expended();\n+    if (collection_set->get_old_bytes_reserved_for_evacuation() == 0) {\n+      \/\/ Setting old evacuation reserve to zero denotes that there is no old-gen evacuation in this pass.\n+      heap->set_old_evac_reserve(0);\n+    }\n+\n+    size_t old_gen_usage_base = old_generation->used() - collection_set->get_old_garbage();\n+    heap->capture_old_usage(old_gen_usage_base);\n+\n+    \/\/ Compute the evacuation supplement, which is extra memory borrowed from old-gen that can be allocated\n+    \/\/ by mutators while GC is working on evacuation and update-refs.  This memory can be temporarily borrowed\n+    \/\/ from old-gen allotment, then repaid at the end of update-refs from the recycled collection set.  After\n+    \/\/ we have computed the collection set based on the parameters established above, we can make additional\n+    \/\/ loans based on our knowledge of the collection set to determine how much allocation we can allow\n+    \/\/ during the evacuation and update-refs phases of execution.  The total available supplement is the smaller of:\n+    \/\/\n+    \/\/   1. old_gen->available() -\n+    \/\/        (promotion_reserve + old_evacuation_commitment + old_bytes_loaned)\n+    \/\/   2. The replenishment budget (number of regions in collection set - the number of regions already\n+    \/\/         under lien for the young_evacuation_reserve)\n+    \/\/\n+\n+    size_t young_regions_evacuated = collection_set->get_young_region_count();\n+    size_t regions_for_runway = 0;\n+    if (young_regions_evacuated > old_regions_loaned_for_young_evac) {\n+      regions_for_runway = young_regions_evacuated - old_regions_loaned_for_young_evac;\n+      old_regions_loaned_for_young_evac = young_regions_evacuated;\n+      regions_available_to_loan -= regions_for_runway;\n+    }\n+\n+    size_t allocation_supplement = regions_for_runway * region_size_bytes;\n+    heap->set_alloc_supplement_reserve(allocation_supplement);\n+\n+    size_t promotion_budget = heap->get_promoted_reserve();\n+    size_t old_evac_budget = heap->get_old_evac_reserve();\n+    size_t alloc_budget_evac_and_update = allocation_supplement + young_generation->available();\n+\n+    \/\/ TODO: young_available, which feeds into alloc_budget_evac_and_update is lacking memory available within\n+    \/\/ existing young-gen regions that were not selected for the collection set.  Add this in and adjust the\n+    \/\/ log message (where it says \"empty-region allocation budget\").\n+\n+    log_info(gc, ergo)(\"Memory reserved for evacuation and update-refs includes promotion budget: \" SIZE_FORMAT\n+                       \"%s, young evacuation budget: \" SIZE_FORMAT \"%s, old evacuation budget: \" SIZE_FORMAT\n+                       \"%s, empty-region allocation budget: \" SIZE_FORMAT \"%s, including supplement: \" SIZE_FORMAT \"%s\",\n+                       byte_size_in_proper_unit(promotion_budget), proper_unit_for_byte_size(promotion_budget),\n+                       byte_size_in_proper_unit(young_evacuation_reserve_used),\n+                       proper_unit_for_byte_size(young_evacuation_reserve_used),\n+                       byte_size_in_proper_unit(old_evac_budget), proper_unit_for_byte_size(old_evac_budget),\n+                       byte_size_in_proper_unit(alloc_budget_evac_and_update),\n+                       proper_unit_for_byte_size(alloc_budget_evac_and_update),\n+                       byte_size_in_proper_unit(allocation_supplement), proper_unit_for_byte_size(allocation_supplement));\n+  }\n+  \/\/ else, not generational: no evacuation budget adjustments required\n+}\n+\n+void ShenandoahGeneration::prepare_regions_and_collection_set(bool concurrent) {\n@@ -247,0 +592,1 @@\n+    size_t old_regions_loaned_for_young_evac, regions_available_to_loan, minimum_evacuation_reserve, consumed_by_advance_promotion;\n@@ -250,189 +596,1 @@\n-    heap->collection_set()->clear();\n-\n-    size_t minimum_evacuation_reserve = ShenandoahOldCompactionReserve * region_size_bytes;\n-    size_t avail_evac_reserve_for_loan_to_young_gen = 0;\n-    size_t old_regions_loaned_for_young_evac = 0;\n-    size_t regions_available_to_loan = 0;\n-    size_t old_evacuation_reserve = 0;\n-    size_t num_regions = heap->num_regions();\n-    size_t consumed_by_advance_promotion = 0;\n-    bool preselected_regions[num_regions];\n-    for (unsigned int i = 0; i < num_regions; i++) {\n-      preselected_regions[i] = false;\n-    }\n-    if (heap->mode()->is_generational()) {\n-      ShenandoahGeneration* old_generation = heap->old_generation();\n-      ShenandoahYoungGeneration* young_generation = heap->young_generation();\n-\n-      \/\/ During initialization and phase changes, it is more likely that fewer objects die young and old-gen\n-      \/\/ memory is not yet full (or is in the process of being replaced).  During these times especially, it\n-      \/\/ is beneficial to loan memory from old-gen to young-gen during the evacuation and update-refs phases\n-      \/\/ of execution.\n-\n-      \/\/ Calculate EvacuationReserve before PromotionReserve.  Evacuation is more critical than promotion.\n-      \/\/ If we cannot evacuate old-gen, we will not be able to reclaim old-gen memory.  Promotions are less\n-      \/\/ critical.  If we cannot promote, there may be degradation of young-gen memory because old objects\n-      \/\/ accumulate there until they can be promoted.  This increases the young-gen marking and evacuation work.\n-\n-      \/\/ Do not fill up old-gen memory with promotions.  Reserve some amount of memory for compaction purposes.\n-      ShenandoahOldHeuristics* old_heuristics = heap->old_heuristics();\n-      if (old_heuristics->unprocessed_old_collection_candidates() > 0) {\n-\n-        \/\/ Compute old_evacuation_reserve: how much memory are we reserving to hold the results of\n-        \/\/ evacuating old-gen heap regions?  In order to sustain a consistent pace of young-gen collections,\n-        \/\/ the goal is to maintain a consistent value for this parameter (when the candidate set is not\n-        \/\/ empty).  This value is the minimum of:\n-        \/\/   1. old_gen->available()\n-        \/\/   2. old-gen->capacity() * ShenandoahOldEvacReserve) \/ 100\n-        \/\/       (e.g. old evacuation should be no larger than 5% of old_gen capacity)\n-        \/\/   3. ((young_gen->capacity * ShenandoahEvacReserve \/ 100) * ShenandoahOldEvacRatioPercent) \/ 100\n-        \/\/       (e.g. old evacuation should be no larger than 12% of young-gen evacuation)\n-\n-        old_evacuation_reserve = old_generation->available();\n-        assert(old_evacuation_reserve > minimum_evacuation_reserve, \"Old-gen available has not been preserved!\");\n-        size_t old_evac_reserve_max = old_generation->soft_max_capacity() * ShenandoahOldEvacReserve \/ 100;\n-        if (old_evac_reserve_max < old_evacuation_reserve) {\n-          old_evacuation_reserve = old_evac_reserve_max;\n-        }\n-        size_t young_evac_reserve_max =\n-          (((young_generation->soft_max_capacity() * ShenandoahEvacReserve) \/ 100) * ShenandoahOldEvacRatioPercent) \/ 100;\n-        if (young_evac_reserve_max < old_evacuation_reserve) {\n-          old_evacuation_reserve = young_evac_reserve_max;\n-        }\n-      }\n-\n-      if (minimum_evacuation_reserve > old_generation->available()) {\n-        \/\/ Due to round-off errors during enforcement of minimum_evacuation_reserve during previous GC passes,\n-        \/\/ there can be slight discrepancies here.\n-        minimum_evacuation_reserve = old_generation->available();\n-      }\n-      if (old_evacuation_reserve < minimum_evacuation_reserve) {\n-        \/\/ Even if there's nothing to be evacuated on this cycle, we still need to reserve this memory for future\n-        \/\/ evacuations.  It is ok to loan this memory to young-gen if we don't need it for evacuation on this pass.\n-        avail_evac_reserve_for_loan_to_young_gen = minimum_evacuation_reserve - old_evacuation_reserve;\n-        old_evacuation_reserve = minimum_evacuation_reserve;\n-      }\n-\n-      heap->set_old_evac_reserve(old_evacuation_reserve);\n-      heap->reset_old_evac_expended();\n-\n-      \/\/ Compute the young evauation reserve: This is how much memory is available for evacuating young-gen objects.\n-      \/\/ We ignore the possible effect of promotions, which reduce demand for young-gen evacuation memory.\n-      \/\/\n-      \/\/ TODO: We could give special treatment to the regions that have reached promotion age, because we know their\n-      \/\/ live data is entirely eligible for promotion.  This knowledge can feed both into calculations of young-gen\n-      \/\/ evacuation reserve and promotion reserve.\n-      \/\/\n-      \/\/  young_evacuation_reserve for young generation: how much memory are we reserving to hold the results\n-      \/\/  of evacuating young collection set regions?  This is typically smaller than the total amount\n-      \/\/  of available memory, and is also smaller than the total amount of marked live memory within\n-      \/\/  young-gen.  This value is the smaller of\n-      \/\/\n-      \/\/    1. (young_gen->capacity() * ShenandoahEvacReserve) \/ 100\n-      \/\/    2. (young_gen->available() + old_gen_memory_available_to_be_loaned\n-      \/\/\n-      \/\/  ShenandoahEvacReserve represents the configured taget size of the evacuation region.  We can only honor\n-      \/\/  this target if there is memory available to hold the evacuations.  Memory is available if it is already\n-      \/\/  free within young gen, or if it can be borrowed from old gen.  Since we have not yet chosen the collection\n-      \/\/  sets, we do not yet know the exact accounting of how many regions will be freed by this collection pass.\n-      \/\/  What we do know is that there will be at least one evacuated young-gen region for each old-gen region that\n-      \/\/  is loaned to the evacuation effort (because regions to be collected consume more memory than the compacted\n-      \/\/  regions that will replace them).  In summary, if there are old-gen regions that are available to hold the\n-      \/\/  results of young-gen evacuations, it is safe to loan them for this purpose.  At this point, we have not yet\n-      \/\/  established a promoted_reserve.  We'll do that after we choose the collection set and analyze its impact\n-      \/\/  on available memory.\n-      \/\/\n-      \/\/ We do not know the evacuation_supplement until after we have computed the collection set.  It is not always\n-      \/\/ the case that young-regions inserted into the collection set will result in net decrease of in-use regions\n-      \/\/ because ShenandoahEvacWaste times multiplied by memory within the region may be larger than the region size.\n-      \/\/ The problem is especially relevant to regions that have been inserted into the collection set because they have\n-      \/\/ reached tenure age.  These regions tend to have much higher utilization (e.g. 95%).  These regions also offer\n-      \/\/ a unique opportunity because we know that every live object contained within the region is elgible to be\n-      \/\/ promoted.  Thus, the following implementation treats these regions specially:\n-      \/\/\n-      \/\/  1. Before beginning collection set selection, we tally the total amount of live memory held within regions\n-      \/\/     that are known to have reached tenure age.  If this memory times ShenandoahEvacWaste is available within\n-      \/\/     old-gen memory, establish an advance promotion reserve to hold all or some percentage of these objects.\n-      \/\/     This advance promotion reserve is excluded from memory available for holding old-gen evacuations and cannot\n-      \/\/     be \"loaned\" to young gen.\n-      \/\/\n-      \/\/  2. Tenure-aged regions are included in the collection set iff their evacuation size * ShenandoahEvacWaste fits\n-      \/\/     within the advance promotion reserve.  It is counter productive to evacuate these regions if they cannot be\n-      \/\/     evacuated directly into old-gen memory.  So if there is not sufficient memory to hold copies of their\n-      \/\/     live data right now, we'll just let these regions remain in young for now, to be evacuated by a subsequent\n-      \/\/     evacuation pass.\n-      \/\/\n-      \/\/  3. Next, we calculate a young-gen evacuation budget, which is the smaller of the two quantities mentioned\n-      \/\/     above.  old_gen_memory_available_to_be_loaned is calculated as:\n-      \/\/       old_gen->available - (advance-promotion-reserve + old-gen_evacuation_reserve)\n-      \/\/\n-      \/\/  4. When choosing the collection set, special care is taken to assure that the amount of loaned memory required to\n-      \/\/     hold the results of evacuation is smaller than the total memory occupied by the regions added to the collection\n-      \/\/     set.  We need to take these precautions because we do not know how much memory will be reclaimed by evacuation\n-      \/\/     until after the collection set has been constructed.  The algorithm is as follows:\n-      \/\/\n-      \/\/     a. We feed into the algorithm (i) young available at the start of evacuation and (ii) the amount of memory\n-      \/\/        loaned from old-gen that is available to hold the results of evacuation.\n-      \/\/     b. As candidate regions are added into the young-gen collection set, we maintain accumulations of the amount\n-      \/\/        of memory spanned by the collection set regions and the amount of memory that must be reserved to hold\n-      \/\/        evacuation results (by multiplying live-data size by ShenandoahEvacWaste).  We process candidate regions\n-      \/\/        in order of decreasing amounts of garbage.  We skip over (and do not include into the collection set) any\n-      \/\/        regions that do not satisfy all of the following conditions:\n-      \/\/\n-      \/\/          i. The amount of live data within the region as scaled by ShenandoahEvacWaste must fit within the\n-      \/\/             relevant evacuation reserve (live data of old-gen regions must fit within the old-evac-reserve, live\n-      \/\/             data of young-gen tenure-aged regions must fit within the advance promotion reserve, live data within\n-      \/\/             other young-gen regions must fit within the youn-gen evacuation reserve).\n-      \/\/         ii. The accumulation of memory consumed by evacuation must not exceed the accumulation of memory reclaimed\n-      \/\/             through evacuation by more than young-gen available.\n-      \/\/        iii. Other conditions may be enforced as appropriate for specific heuristics.\n-      \/\/\n-      \/\/       Note that regions are considered for inclusion in the selection set in order of decreasing amounts of garbage.\n-      \/\/       It is possible that a region with a larger amount of garbage will be rejected because it also has a larger\n-      \/\/       amount of live data and some region that follows this region in candidate order is included in the collection\n-      \/\/       set (because it has less live data and thus can fit within the evacuation limits even though it has less\n-      \/\/       garbage).\n-\n-      size_t young_evacuation_reserve = (young_generation->max_capacity() * ShenandoahEvacReserve) \/ 100;\n-      \/\/ old evacuation can pack into existing partially used regions.  young evacuation and loans for young allocations\n-      \/\/ need to target regions that do not already hold any old-gen objects.  Round down.\n-      regions_available_to_loan = old_generation->free_unaffiliated_regions();\n-      consumed_by_advance_promotion = _heuristics->select_aged_regions(old_generation->available() - old_evacuation_reserve,\n-                                                                       num_regions, preselected_regions);\n-      size_t net_available_old_regions =\n-        (old_generation->available() - old_evacuation_reserve - consumed_by_advance_promotion) \/ region_size_bytes;\n-\n-      if (regions_available_to_loan > net_available_old_regions) {\n-        regions_available_to_loan = net_available_old_regions;\n-      }\n-      \/\/ Otherwise, regions_available_to_loan is less than net_available_old_regions because available memory is\n-      \/\/ scattered between multiple partially used regions.\n-\n-      if (young_evacuation_reserve > young_generation->available()) {\n-        size_t short_fall = young_evacuation_reserve - young_generation->available();\n-        if (regions_available_to_loan * region_size_bytes >= short_fall) {\n-          old_regions_loaned_for_young_evac = (short_fall + region_size_bytes - 1) \/ region_size_bytes;\n-          regions_available_to_loan -= old_regions_loaned_for_young_evac;\n-        } else {\n-          old_regions_loaned_for_young_evac = regions_available_to_loan;\n-          regions_available_to_loan = 0;\n-          young_evacuation_reserve = young_generation->available() + old_regions_loaned_for_young_evac * region_size_bytes;\n-        }\n-      } else {\n-        old_regions_loaned_for_young_evac = 0;\n-      }\n-      \/\/ In generational mode, we may end up choosing a young collection set that contains so many promotable objects\n-      \/\/ that there is not sufficient space in old generation to hold the promoted objects.  That is ok because we have\n-      \/\/ assured there is sufficient space in young generation to hold the rejected promotion candidates.  These rejected\n-      \/\/ promotion candidates will presumably be promoted in a future evacuation cycle.\n-      heap->set_young_evac_reserve(young_evacuation_reserve);\n-    } else {\n-      \/\/ Not generational mode: limit young evac reserve by young available; no need to establish old_evac_reserve.\n-      ShenandoahYoungGeneration* young_generation = heap->young_generation();\n-      size_t young_evac_reserve = (young_generation->soft_max_capacity() * ShenandoahEvacReserve) \/ 100;\n-      if (young_evac_reserve > young_generation->available()) {\n-        young_evac_reserve = young_generation->available();\n-      }\n-      heap->set_young_evac_reserve(young_evac_reserve);\n-    }\n-\n+    collection_set->clear();\n@@ -447,1 +605,3 @@\n-    collection_set->establish_preselected(preselected_regions);\n+    \/\/ Budgeting parameters to compute_evacuation_budgets are passed by reference.\n+    compute_evacuation_budgets(heap, collection_set, old_regions_loaned_for_young_evac, regions_available_to_loan,\n+                               minimum_evacuation_reserve, consumed_by_advance_promotion);\n@@ -449,149 +609,2 @@\n-    collection_set->abandon_preselected();\n-\n-    \/\/ At this point, young_generation->available() knows about recently discovered immediate garbage.  We also\n-    \/\/ know the composition of the chosen collection set.\n-\n-    if (heap->mode()->is_generational()) {\n-      ShenandoahGeneration* old_generation = heap->old_generation();\n-      ShenandoahYoungGeneration* young_generation = heap->young_generation();\n-      size_t old_evacuation_committed = (size_t) (ShenandoahEvacWaste *\n-                                                  collection_set->get_old_bytes_reserved_for_evacuation());\n-      size_t immediate_garbage_regions = collection_set->get_immediate_trash() \/ region_size_bytes;\n-\n-      if (old_evacuation_committed > old_evacuation_reserve) {\n-        \/\/ This should only happen due to round-off errors when enforcing ShenandoahEvacWaste\n-        assert(old_evacuation_committed < (33 * old_evacuation_reserve) \/ 32, \"Round-off errors should be less than 3.125%%\");\n-        old_evacuation_committed = old_evacuation_reserve;\n-      }\n-\n-      \/\/ Recompute old_regions_loaned_for_young_evac because young-gen collection set may not need all the memory\n-      \/\/ originally reserved.\n-\n-      size_t young_evacuation_reserve_used =\n-        collection_set->get_young_bytes_reserved_for_evacuation() - collection_set->get_young_bytes_to_be_promoted();\n-      young_evacuation_reserve_used = (size_t) (ShenandoahEvacWaste * young_evacuation_reserve_used);\n-      heap->set_young_evac_reserve(young_evacuation_reserve_used);\n-\n-      \/\/ Adjust old_regions_loaned_for_young_evac to feed into calculations of promoted_reserve\n-      if (young_evacuation_reserve_used > young_generation->available()) {\n-        size_t short_fall = young_evacuation_reserve_used - young_generation->available();\n-\n-        \/\/ region_size_bytes is a power of 2.  loan an integral number of regions.\n-        size_t revised_loan_for_young_evacuation = (short_fall + region_size_bytes - 1) \/ region_size_bytes;\n-\n-        \/\/ Undo the previous loan\n-        regions_available_to_loan += old_regions_loaned_for_young_evac;\n-        old_regions_loaned_for_young_evac = revised_loan_for_young_evacuation;\n-        \/\/ And make a new loan\n-        assert(regions_available_to_loan > old_regions_loaned_for_young_evac, \"Cannot loan regions that we do not have\");\n-        regions_available_to_loan -= old_regions_loaned_for_young_evac;\n-      } else {\n-        \/\/ Undo the prevous loan\n-        regions_available_to_loan += old_regions_loaned_for_young_evac;\n-        old_regions_loaned_for_young_evac = 0;\n-      }\n-\n-      size_t old_bytes_loaned = old_regions_loaned_for_young_evac * region_size_bytes;\n-      \/\/ Need to enforce that old_evacuation_committed + old_bytes_loaned >= minimum_evacuation_reserve\n-      \/\/ in order to prevent promotion reserve from violating minimum evacuation reserve.\n-      if (old_evacuation_committed + old_bytes_loaned < minimum_evacuation_reserve) {\n-        \/\/ Pretend the old_evacuation_commitment is larger than what will be evacuated to assure that promotions\n-        \/\/ do not fill the minimum_evacuation_reserve.  Note that regions loaned from old-gen will be returned\n-        \/\/ to old-gen before we start a subsequent evacuation.\n-        old_evacuation_committed = minimum_evacuation_reserve - old_bytes_loaned;\n-      }\n-\n-      \/\/ Limit promoted_reserve so that we can set aside memory to be loaned from old-gen to young-gen.  This\n-      \/\/ value is not \"critical\".  If we underestimate, certain promotions will simply be deferred.  If we put\n-      \/\/ \"all the rest\" of old-gen memory into the promotion reserve, we'll have nothing left to loan to young-gen\n-      \/\/ during the evac and update phases of GC.  So we \"limit\" the sizes of the promotion budget to be the smaller of:\n-      \/\/\n-      \/\/  1. old_gen->available - (old_evacuation_committed + old_bytes_loaned + consumed_by_advance_promotion)\n-      \/\/  2. young bytes reserved for evacuation\n-\n-      assert(old_generation->available() > old_evacuation_committed, \"Cannot evacuate more than available\");\n-      assert(old_generation->available() > old_evacuation_committed + old_bytes_loaned, \"Cannot loan more than available\");\n-      assert(old_generation->available() > old_evacuation_committed + old_bytes_loaned + consumed_by_advance_promotion,\n-             \"Cannot promote more than available\");\n-\n-      size_t old_avail = old_generation->available();\n-      size_t promotion_reserve = old_avail - (old_evacuation_committed + consumed_by_advance_promotion + old_bytes_loaned);\n-\n-      \/\/ We experimented with constraining promoted_reserve to be no larger than 4 times the size of previously_promoted,\n-      \/\/ but this constraint was too limiting, resulting in failure of legitimate promotions.\n-\n-      \/\/ We had also experimented with constraining promoted_reserve to be no more than young_evacuation_committed\n-      \/\/ divided by promotion_divisor, where:\n-      \/\/  size_t promotion_divisor = (0x02 << InitialTenuringThreshold) - 1;\n-      \/\/ This also was found to be too limiting, resulting in failure of legitimate promotions.\n-      \/\/\n-      \/\/ Both experiments were conducted in the presence of other bugs which could have been the root cause for\n-      \/\/ the failures identified above as being \"too limiting\".  TODO: conduct new experiments with the more limiting\n-      \/\/ values of young_evacuation_reserved_used.\n-      young_evacuation_reserve_used -= consumed_by_advance_promotion;\n-      if (young_evacuation_reserve_used < promotion_reserve) {\n-        \/\/ Shrink promotion_reserve if its larger than the memory to be consumed by evacuating all young objects in\n-        \/\/ collection set, including anticipated waste.  There's no benefit in using a larger promotion_reserve.\n-        promotion_reserve = young_evacuation_reserve_used;\n-      }\n-\n-      assert(old_avail >= promotion_reserve + old_evacuation_committed + old_bytes_loaned + consumed_by_advance_promotion,\n-             \"Budget exceeds available old-gen memory\");\n-      log_info(gc, ergo)(\"Old available: \" SIZE_FORMAT \", Original promotion reserve: \" SIZE_FORMAT \", Old evacuation reserve: \"\n-                         SIZE_FORMAT \", Advance promotion reserve supplement: \" SIZE_FORMAT \", Old loaned to young: \" SIZE_FORMAT,\n-                         old_avail, promotion_reserve, old_evacuation_committed, consumed_by_advance_promotion,\n-                         old_regions_loaned_for_young_evac * region_size_bytes);\n-      promotion_reserve += consumed_by_advance_promotion;\n-      heap->set_promoted_reserve(promotion_reserve);\n-      heap->reset_promoted_expended();\n-      if (collection_set->get_old_bytes_reserved_for_evacuation() == 0) {\n-        \/\/ Setting old evacuation reserve to zero denotes that there is no old-gen evacuation in this pass.\n-        heap->set_old_evac_reserve(0);\n-      }\n-\n-      size_t old_gen_usage_base = old_generation->used() - collection_set->get_old_garbage();\n-      heap->capture_old_usage(old_gen_usage_base);\n-\n-      \/\/ Compute the evacuation supplement, which is extra memory borrowed from old-gen that can be allocated\n-      \/\/ by mutators while GC is working on evacuation and update-refs.  This memory can be temporarily borrowed\n-      \/\/ from old-gen allotment, then repaid at the end of update-refs from the recycled collection set.  After\n-      \/\/ we have computed the collection set based on the parameters established above, we can make additional\n-      \/\/ loans based on our knowledge of the collection set to determine how much allocation we can allow\n-      \/\/ during the evacuation and update-refs phases of execution.  The total available supplement is the smaller of:\n-      \/\/\n-      \/\/   1. old_gen->available() -\n-      \/\/        (promotion_reserve + old_evacuation_commitment + old_bytes_loaned)\n-      \/\/   2. The replenishment budget (number of regions in collection set - the number of regions already\n-      \/\/         under lien for the young_evacuation_reserve)\n-      \/\/\n-\n-      size_t young_regions_evacuated = collection_set->get_young_region_count();\n-      size_t regions_for_runway = 0;\n-      if (young_regions_evacuated > old_regions_loaned_for_young_evac) {\n-        regions_for_runway = young_regions_evacuated - old_regions_loaned_for_young_evac;\n-        old_regions_loaned_for_young_evac = young_regions_evacuated;\n-        regions_available_to_loan -= regions_for_runway;\n-      }\n-\n-      size_t allocation_supplement = regions_for_runway * region_size_bytes;\n-      heap->set_alloc_supplement_reserve(allocation_supplement);\n-\n-      size_t promotion_budget = heap->get_promoted_reserve();\n-      size_t old_evac_budget = heap->get_old_evac_reserve();\n-      size_t alloc_budget_evac_and_update = allocation_supplement + young_generation->available();\n-\n-      \/\/ TODO: young_available, which feeds into alloc_budget_evac_and_update is lacking memory available within\n-      \/\/ existing young-gen regions that were not selected for the collection set.  Add this in and adjust the\n-      \/\/ log message (where it says \"empty-region allocation budget\").\n-\n-      log_info(gc, ergo)(\"Memory reserved for evacuation and update-refs includes promotion budget: \" SIZE_FORMAT\n-                         \"%s, young evacuation budget: \" SIZE_FORMAT \"%s, old evacuation budget: \" SIZE_FORMAT\n-                         \"%s, empty-region allocation budget: \" SIZE_FORMAT \"%s, including supplement: \" SIZE_FORMAT \"%s\",\n-                         byte_size_in_proper_unit(promotion_budget), proper_unit_for_byte_size(promotion_budget),\n-                         byte_size_in_proper_unit(young_evacuation_reserve_used),\n-                         proper_unit_for_byte_size(young_evacuation_reserve_used),\n-                         byte_size_in_proper_unit(old_evac_budget), proper_unit_for_byte_size(old_evac_budget),\n-                         byte_size_in_proper_unit(alloc_budget_evac_and_update),\n-                         proper_unit_for_byte_size(alloc_budget_evac_and_update),\n-                         byte_size_in_proper_unit(allocation_supplement), proper_unit_for_byte_size(allocation_supplement));\n-    }\n+    adjust_evacuation_budgets(heap, collection_set, old_regions_loaned_for_young_evac, regions_available_to_loan,\n+                              minimum_evacuation_reserve, consumed_by_advance_promotion);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":353,"deletions":340,"binary":false,"changes":693,"status":"modified"},{"patch":"@@ -114,0 +114,10 @@\n+  \/\/ Compute evacuation budgets prior to choosing collection set.\n+  void compute_evacuation_budgets(ShenandoahHeap* heap, ShenandoahCollectionSet* collection_set,\n+                                  size_t &old_regions_loaned_for_young_evac, size_t &regions_available_to_loan,\n+                                  size_t &minimum_evacuation_reserve, size_t &consumed_by_advance_promotion);\n+\n+  \/\/ Adjust evacuation budgets after choosing collection set.\n+  void adjust_evacuation_budgets(ShenandoahHeap* heap, ShenandoahCollectionSet* collection_set,\n+                                 size_t old_regions_loaned_for_young_evac, size_t regions_available_to_loan,\n+                                 size_t minimum_evacuation_reserve, size_t consumed_by_advance_promotion);\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -689,0 +689,1 @@\n+  shenandoah_assert_heaplocked();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}