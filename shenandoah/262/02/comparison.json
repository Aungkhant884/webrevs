{"files":[{"patch":"@@ -529,0 +529,2 @@\n+        \/\/ Coalescing threads detected the cancellation request and aborted. Stay\n+        \/\/ in this state so control thread may resume the coalescing work.\n@@ -533,1 +535,20 @@\n-      assert(old_generation->state() == ShenandoahOldGeneration::BOOTSTRAPPING, \"Finished with filling, should be bootstrapping\");\n+      \/\/ It is possible for a young generation request to preempt this nascent old\n+      \/\/ collection cycle _after_ we've finished making the old regions parseable (filling),\n+      \/\/ but _before_ we have unset the preemption flag. It is also possible for an\n+      \/\/ allocation failure to occur after the threads have finished filling. We must\n+      \/\/ check if we have been cancelled before we start a bootstrap cycle.\n+      if (check_cancellation_or_degen(ShenandoahGC::_degenerated_outside_cycle)) {\n+        if (heap->cancelled_gc()) {\n+          \/\/ If this was a preemption request, the cancellation would have been cleared\n+          \/\/ so that we run a concurrent young cycle. If the cancellation is still set,\n+          \/\/ then this is an allocation failure and we need to run a degenerated cycle.\n+          \/\/ If this is a preemption request, we're just going to fall through and run\n+          \/\/ the bootstrap cycle to start the old generation cycle (the bootstrap cycle is\n+          \/\/ a concurrent young cycle - which is what we're being asked to do in that case).\n+          \/\/ If the cycle is cancelled for any other reason, we return from here and let\n+          \/\/ the control thread return to the top of its decision loop.\n+          log_info(gc)(\"Preparation for old generation cycle was cancelled\");\n+          return;\n+        }\n+      }\n+      old_generation->transition_to(ShenandoahOldGeneration::BOOTSTRAPPING);\n@@ -541,0 +562,1 @@\n+      set_gc_mode(bootstrapping_old);\n@@ -559,3 +581,1 @@\n-      \/\/ done by the bootstrapping young cycle. In order to simplify the debugging\n-      \/\/ effort, the old cycle will ONLY complete the mark phase. No actual\n-      \/\/ collection of the old generation is happening here.\n+      \/\/ done by the bootstrapping young cycle.\n@@ -1019,0 +1039,1 @@\n+    case bootstrapping_old: return \"bootstrap\";\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":25,"deletions":4,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -77,0 +77,1 @@\n+    bootstrapping_old,\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -270,1 +270,0 @@\n-    transition_to(BOOTSTRAPPING);\n@@ -273,0 +272,1 @@\n+    \/\/ Otherwise, we were preempted before the work was done.\n@@ -274,1 +274,0 @@\n-    \/\/ Otherwise, we got preempted before the work was done.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -87,1 +87,0 @@\n-gc\/shenandoah\/TestArrayCopyStress.java#generational 8306334 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}