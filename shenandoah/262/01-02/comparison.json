{"files":[{"patch":"@@ -529,0 +529,2 @@\n+        \/\/ Coalescing threads detected the cancellation request and aborted. Stay\n+        \/\/ in this state so control thread may resume the coalescing work.\n@@ -533,3 +535,0 @@\n-      assert(old_generation->state() == ShenandoahOldGeneration::BOOTSTRAPPING, \"Finished with filling, should be bootstrapping\");\n-    }\n-    case ShenandoahOldGeneration::BOOTSTRAPPING: {\n@@ -538,2 +537,3 @@\n-      \/\/ but _before_ we have unset the preemption flag. So, we must check if we\n-      \/\/ have been preempted before we start a bootstrap cycle.\n+      \/\/ but _before_ we have unset the preemption flag. It is also possible for an\n+      \/\/ allocation failure to occur after the threads have finished filling. We must\n+      \/\/ check if we have been cancelled before we start a bootstrap cycle.\n@@ -554,1 +554,3 @@\n-\n+      old_generation->transition_to(ShenandoahOldGeneration::BOOTSTRAPPING);\n+    }\n+    case ShenandoahOldGeneration::BOOTSTRAPPING: {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -270,1 +270,0 @@\n-    transition_to(BOOTSTRAPPING);\n@@ -273,0 +272,1 @@\n+    \/\/ Otherwise, we were preempted before the work was done.\n@@ -274,1 +274,0 @@\n-    \/\/ Otherwise, we got preempted before the work was done.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"}]}