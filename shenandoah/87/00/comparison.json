{"files":[{"patch":"@@ -420,1 +420,1 @@\n-    \/\/ HEY! Could we optimize here by checking that dst is in an old region?\n+    \/\/ TODO: Could we optimize here by checking that dst is in an old region?\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -105,1 +105,1 @@\n-  \/\/ HEY! heuristics are notified of allocation failures here and other outcomes\n+  \/\/ Heuristics are notified of allocation failures here and other outcomes\n@@ -107,3 +107,2 @@\n-  \/\/ degenerated cycle should be 'promoted' to a full cycle. This changes the\n-  \/\/ threading model for them somewhat, as they are now evaluated on a separate\n-  \/\/ thread.\n+  \/\/ degenerated cycle should be 'promoted' to a full cycle. The decision to\n+  \/\/ trigger a cycle or not is evaluated on the regulator thread.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -576,2 +576,0 @@\n-  \/\/ HEY! All callers (at the time of this writing) have already asserted the mark context is complete.\n-  \/\/ assert(ctx->is_complete(), \"sanity\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.inline.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-  \/\/ HEY! This will push array chunks into the mark queue with no regard for\n+  \/\/ TODO: This will push array chunks into the mark queue with no regard for\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMark.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-      \/\/ HEY! Allocations move the watermark when top moves, however compacting\n+      \/\/ Allocations move the watermark when top moves, however compacting\n@@ -67,3 +67,2 @@\n-      \/\/ higher than top). I think the right way™ to check for new allocations\n-      \/\/ is to compare top with the TAMS as is done earlier in this function.\n-      \/\/ if (r->top() != r->get_update_watermark()) {\n+      \/\/ higher than top). The right way™ to check for new allocations is to compare\n+      \/\/ top with the TAMS as is done earlier in this function.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkClosures.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -541,1 +541,1 @@\n-    \/\/ HEY!  We don't really need object_starts entries for every card entry.  We only need these for\n+    \/\/ TODO: We don't really need object_starts entries for every card entry.  We only need these for\n@@ -878,1 +878,1 @@\n-  \/\/ HEY!  We really don't want to share all of these APIs with arbitrary consumers of the ShenandoahScanRemembered abstraction.\n+  \/\/ TODO:  We really don't want to share all of these APIs with arbitrary consumers of the ShenandoahScanRemembered abstraction.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}