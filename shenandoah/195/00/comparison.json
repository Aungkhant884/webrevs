{"files":[{"patch":"@@ -265,2 +265,2 @@\n-        \/\/ TODO: Fix allocate_aligned() to provide min_size() allocation if insufficient memory for desired size.\n-        \/\/       Then add: assert(result != nullptr, \"Allocation cannot fail\");\n+        assert(result != nullptr, \"Allocation cannot fail\");\n+        size = req.actual_size();\n@@ -273,2 +273,1 @@\n-\n-        if (result != nullptr && free > usable_free) {\n+        if (free > usable_free) {\n@@ -293,0 +292,4 @@\n+        if (result != nullptr) {\n+          \/\/ Record actual allocation size\n+          req.set_actual_size(size);\n+        }\n@@ -300,0 +303,1 @@\n+    \/\/ inelastic PLAB\n@@ -315,0 +319,1 @@\n+      size = req.actual_size();\n@@ -331,0 +336,4 @@\n+    if (result != nullptr) {\n+      \/\/ Record actual allocation size\n+      req.set_actual_size(size);\n+    }\n@@ -334,3 +343,0 @@\n-    \/\/ Record actual allocation size\n-    req.set_actual_size(size);\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":13,"deletions":7,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -351,1 +351,1 @@\n-  inline HeapWord* allocate_aligned(size_t word_size, ShenandoahAllocRequest req, size_t alignment_in_words);\n+  inline HeapWord* allocate_aligned(size_t word_size, ShenandoahAllocRequest &req, size_t alignment_in_words);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-HeapWord* ShenandoahHeapRegion::allocate_aligned(size_t size, ShenandoahAllocRequest req, size_t alignment_in_bytes) {\n+HeapWord* ShenandoahHeapRegion::allocate_aligned(size_t size, ShenandoahAllocRequest &req, size_t alignment_in_bytes) {\n@@ -40,0 +40,1 @@\n+  assert(req.is_lab_alloc(), \"allocate_aligned() only applies to LAB allocations\");\n@@ -43,2 +44,2 @@\n-  HeapWord* obj = top();\n-  uintptr_t addr_as_int = (uintptr_t) obj;\n+  HeapWord* orig_top = top();\n+  size_t addr_as_int = (uintptr_t) orig_top;\n@@ -46,0 +47,4 @@\n+  \/\/ unalignment_bytes is the amount by which current top() exceeds the desired alignment point.  We subtract this amount\n+  \/\/ from alignment_in_bytes to determine padding required to next alignment point.\n+\n+  \/\/ top is HeapWord-aligned so unalignment_bytes is a multiple of HeapWordSize\n@@ -47,1 +52,1 @@\n-  assert(unalignment_bytes % HeapWordSize == 0, \"top should be multiple of HeapWordSize\");\n+  size_t unalignment_words = unalignment_bytes \/ HeapWordSize;\n@@ -49,3 +54,11 @@\n-  size_t pad_words = 0;\n-  if (unalignment_bytes > 0) {\n-    pad_words = (alignment_in_bytes - unalignment_bytes) \/ HeapWordSize;\n+  size_t pad_words;\n+  HeapWord* aligned_obj;\n+  if (unalignment_words > 0) {\n+    pad_words = (alignment_in_bytes \/ HeapWordSize) - unalignment_words;\n+    if (pad_words < ShenandoahHeap::min_fill_size()) {\n+      pad_words += (alignment_in_bytes \/ HeapWordSize);\n+    }\n+    aligned_obj = orig_top + pad_words;\n+  } else {\n+    pad_words = 0;\n+    aligned_obj = orig_top;\n@@ -53,2 +66,11 @@\n-  if ((pad_words > 0) && (pad_words < ShenandoahHeap::min_fill_size())) {\n-    pad_words += alignment_in_bytes \/ HeapWordSize;\n+\n+  if (pointer_delta(end(), aligned_obj) < size) {\n+    size = pointer_delta(end(), aligned_obj);\n+    \/\/ Force size to align on multiple of alignment_in_bytes\n+    size_t byte_size = size * HeapWordSize;\n+    size_t excess_bytes = byte_size % alignment_in_bytes;\n+    \/\/ Note: excess_bytes is a multiple of HeapWordSize because it is the difference of HeapWord-aligned end\n+    \/\/       and proposed HeapWord-aligned object address.\n+    if (excess_bytes > 0) {\n+      size -= excess_bytes \/ HeapWordSize;\n+    }\n@@ -56,1 +78,5 @@\n-  if (pointer_delta(end(), obj + pad_words) >= size) {\n+\n+  \/\/ Both originally requested size and adjusted size must be properly aligned\n+  assert ((size * HeapWordSize) % alignment_in_bytes == 0, \"Size must be multiple of alignment constraint\");\n+  if (size >= req.min_size()) {\n+    \/\/ Even if req.min_size() is not a multiple of card size, we know that size is.\n@@ -58,4 +84,2 @@\n-      ShenandoahHeap::fill_with_object(obj, pad_words);\n-      \/\/ register the filled pad object\n-      ShenandoahHeap::heap()->card_scan()->register_object(obj);\n-      obj += pad_words;\n+      ShenandoahHeap::fill_with_object(orig_top, pad_words);\n+      ShenandoahHeap::heap()->card_scan()->register_object(orig_top);\n@@ -64,2 +88,0 @@\n-    \/\/ We don't need to register the PLAB.  Its content will be registered as objects are allocated within it and\/or\n-    \/\/ when the PLAB is retired.\n@@ -69,1 +91,2 @@\n-    HeapWord* new_top = obj + size;\n+    HeapWord* new_top = aligned_obj + size;\n+    assert(new_top <= end(), \"PLAB cannot span end of heap region\");\n@@ -71,0 +94,1 @@\n+    req.set_actual_size(size);\n@@ -72,3 +96,2 @@\n-    assert(is_aligned(obj, alignment_in_bytes), \"obj is not aligned: \" PTR_FORMAT, p2i(obj));\n-\n-    return obj;\n+    assert(is_aligned(aligned_obj, alignment_in_bytes), \"obj is not aligned: \" PTR_FORMAT, p2i(aligned_obj));\n+    return aligned_obj;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.inline.hpp","additions":43,"deletions":20,"binary":false,"changes":63,"status":"modified"}]}