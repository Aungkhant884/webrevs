{"files":[{"patch":"@@ -277,1 +277,2 @@\n-\/\/ this would return the first address of the range that this card covers.\n+\/\/ this would return the first address of the range that this card covers, which is\n+\/\/ where the card's first object also begins.\n@@ -298,0 +299,1 @@\n+    assert(oopDesc::is_oop(cast_to_oop(left)), \"Should be an object\");\n@@ -319,0 +321,1 @@\n+  \/\/ Recall that we already dealt with the co-initial object case above\n@@ -321,3 +324,1 @@\n-  \/\/ follows, the loop should never be needed because:\n-  \/\/ [TODO: assert as many of these conditions as one may be able to\n-  \/\/  efficiently check.]\n+  \/\/ follows, the (ifdef'd out) loop should never be needed.\n@@ -328,2 +329,2 @@\n-  \/\/    of races between reading and writing the object start array, or\n-  \/\/    of asking partially initialized objects their size.\n+  \/\/    of races between reading from and writing to the object start array,\n+  \/\/    or of asking partially initialized objects their size (in the loop below).\n@@ -336,2 +337,0 @@\n-  \/\/    [TODO: Compare with the performance of a logarithmic BOT alternative,\n-  \/\/    e.g. as used by G1.]\n@@ -339,0 +338,1 @@\n+  assert(oopDesc::is_oop(obj), \"Should be an object\");\n@@ -344,2 +344,0 @@\n-  \/\/ Recall that we already dealt with the co-initial object case above\n-  assert(p < left, \"obj should start before left\");\n@@ -674,3 +672,8 @@\n-      \/\/ TODO: cache so as to not call block_start() repeatedly\n-      \/\/ on a very large object. Check: may be upper_bound below\n-      \/\/ and its use above already takes care of this.\n+      \/\/ NOTE: We'll not call block_start() repeatedly\n+      \/\/ on a very large object if its head card is dirty. If not,\n+      \/\/ (i.e. the head card is clean) we'll call it each time we\n+      \/\/ process a new dirty range on the object. This is always\n+      \/\/ the case for large object arrays, which are typically more\n+      \/\/ common.\n+      \/\/ TODO: It is worthwhile to memoize this, so as to avoid that\n+      \/\/ overhead, and it is easy to do, but deferred to a follow-up.\n@@ -683,3 +686,0 @@\n-#define OBJ_MARK_IMPRECISE false   \/\/ indicates that objects are _always_ imprecisely marked:\n-                                   \/\/ this is not true today, as GC closures are precise, but\n-                                   \/\/ compiler & interpreter are imprecise.\n@@ -687,12 +687,24 @@\n-        if (OBJ_MARK_IMPRECISE) {\n-          \/\/ If we always dirty non-array objects imprecisely (i.e. only the head),\n-          \/\/ then we'll scan this object when we process the (potentially dirty)\n-          \/\/ card in which it starts, so we can skip over it now.\n-          log_debug(gc, remset)(\"Skipping non-objArray suffix in [\" INTPTR_FORMAT \", \" INTPTR_FORMAT \")\",\n-                                p2i(left), p2i(p + obj->size()));\n-          \/\/ It's tempting to assert that if the card on which it starts is clean,\n-          \/\/ then it must contain no cross-generational pointers. However, that check\n-          \/\/ would be too strong, because such mutations will be found by\n-          \/\/ our SATB barrier processing, and need not be found here.\n-          assert(obj == cast_to_oop(p), \"Inconsistency detected\");\n-          if (ctx == nullptr || p >= tams) {\n+        \/\/ The mutator (both compiler and interpreter, but not JNI?)\n+        \/\/ typically dirty imprecisely (i.e. only the head of an object),\n+        \/\/ but GC closures typically dirty the object precisely. (It would\n+        \/\/ be nice to have everything be precise for maximum efficiency.)\n+        \/\/\n+        \/\/ To handle this, we check the head card of the object here and,\n+        \/\/ if dirty, (arrange to) scan the object in its entirety. If we\n+        \/\/ find the head card clean, we'll scan only the portion of the\n+        \/\/ object lying in the dirty card range below, assuming this was\n+        \/\/ the result of precise marking by GC closures.\n+\n+        \/\/ index of the \"head card\" for p\n+        const size_t hc_index = _rs->card_index_for_addr(p);\n+        if (ctbm[hc_index] == CardTable::dirty_card_val()) {\n+          \/\/ Scan or skip the object, depending on location of its\n+          \/\/ head card, and remember that we'll have processed all\n+          \/\/ the objects back up to p, which is thus an upper bound\n+          \/\/ for the next iteration of a dirty card loop.\n+          upper_bound = p;   \/\/ remember upper bound for next chunk\n+          if (p < start_addr) {\n+            \/\/ if object starts in a previous slice, it'll be handled\n+            \/\/ in its entirety by the thread processing that slice; we can\n+            \/\/ skip over it and avoid an unnecessary extra scan.\n+            assert(obj == cast_to_oop(p), \"Inconsistency detected\");\n@@ -701,20 +713,5 @@\n-            p = ctx->get_next_marked_addr(p, right);\n-          }\n-          assert(p > left, \"Should have processed into the range\");\n-        } else {\n-          \/\/ The compiler and interpreter typically dirty the head of an object,\n-          \/\/ but GC may dirty the object precisely. To handle this, we check the\n-          \/\/ head card of the object here and, if dirty, scan the object in its\n-          \/\/ entirety. If we find the head card clean, we'll scan only the\n-          \/\/ portion of the object lying in the dirty card range below,\n-          \/\/ assuming precise marking by GC closures.\n-          const size_t h_index = _rs->card_index_for_addr(p);\n-          if (ctbm[h_index] == CardTable::dirty_card_val()) {\n-            \/\/ Scan or skip, and remember for next chunk\n-            upper_bound = p;   \/\/ remember upper bound for next chunk\n-            if (p < start_addr) {\n-              \/\/ if object starts in a previous slice, it'll be handled\n-              \/\/ in its entirety by the thread processing that slice; we can\n-              \/\/ skip over it.\n-              assert(obj == cast_to_oop(p), \"Inconsistency detected\");\n-              p += obj->size();\n+            \/\/ the object starts in our slice, we scan it in its entirety\n+            assert(obj == cast_to_oop(p), \"Inconsistency detected\");\n+            if (ctx == nullptr || ctx->is_marked(obj)) {\n+              \/\/ Scan the object in its entirety\n+              p += obj->oop_iterate_size(cl);\n@@ -722,10 +719,4 @@\n-              assert(obj == cast_to_oop(p), \"Inconsistency detected\");\n-              if (ctx == nullptr || ctx->is_marked(obj)) {\n-                \/\/ Scan the object in its entirety\n-                p += obj->oop_iterate_size(cl);\n-              } else {\n-                assert(p < tams, \"Error 1 in ctx\/marking\/tams logic\");\n-                \/\/ Skip over any intermediate dead objects\n-                p = ctx->get_next_marked_addr(p, tams);\n-                assert(p <= tams, \"Error 2 in ctx\/marking\/tams logic\");\n-              }\n+              assert(p < tams, \"Error 1 in ctx\/marking\/tams logic\");\n+              \/\/ Skip over any intermediate dead objects\n+              p = ctx->get_next_marked_addr(p, tams);\n+              assert(p <= tams, \"Error 2 in ctx\/marking\/tams logic\");\n@@ -733,1 +724,0 @@\n-            assert(p > left, \"Should have processed into the range\");\n@@ -735,0 +725,1 @@\n+          assert(p > left, \"Should have processed into interior of dirty range\");\n@@ -784,1 +775,0 @@\n-#undef OBJ_MARK_IMPRECISE \/\/ false\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.inline.hpp","additions":50,"deletions":60,"binary":false,"changes":110,"status":"modified"}]}