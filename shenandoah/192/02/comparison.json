{"files":[{"patch":"@@ -200,1 +200,0 @@\n-\n@@ -202,1 +201,0 @@\n-\n@@ -230,1 +228,0 @@\n-\n@@ -242,1 +239,5 @@\n-        usable_free -= CardTable::card_size();\n+        if (usable_free > CardTable::card_size()) {\n+          usable_free -= CardTable::card_size();\n+        } else {\n+          assert(usable_free == 0, \"usable_free is a multiple of card_size and card_size > min_fill_size\");\n+        }\n@@ -246,0 +247,5 @@\n+      size_t remnant = size % CardTable::card_size_in_words();\n+      if (remnant > 0) {\n+        \/\/ Since we have Elastic TLABs, align size up.  This is consistent with aligning min_size up.\n+        size = size - remnant + CardTable::card_size_in_words();\n+      }\n@@ -248,0 +254,1 @@\n+        assert(size % CardTable::card_size_in_words() == 0, \"usable_free is a multiple of card table size\");\n@@ -249,1 +256,8 @@\n-      if (size >= req.min_size()) {\n+\n+      size_t adjusted_min_size = req.min_size();\n+      remnant = adjusted_min_size % CardTable::card_size_in_words();\n+      if (remnant > 0) {\n+        \/\/ Round up adjusted_min_size to a multiple of alignment size\n+        adjusted_min_size = adjusted_min_size - remnant + CardTable::card_size_in_words();\n+      }\n+      if (size >= adjusted_min_size) {\n@@ -251,0 +265,9 @@\n+        \/\/ TODO: Fix allocate_aligned() to provide min_size() allocation if insufficient memory for desired size.\n+        \/\/       Then add: assert(result != nullptr, \"Allocation cannot fail\");\n+        assert(r->top() <= r->end(), \"Allocation cannot span end of region\");\n+        \/\/ actual_size() will be set to size below.\n+        assert((result == nullptr) || (size % CardTable::card_size_in_words() == 0),\n+               \"PLAB size must be multiple of card size\");\n+        assert((result == nullptr) || (((uintptr_t) result) % CardTable::card_size_in_words() == 0),\n+               \"PLAB start must align with card boundary\");\n+\n@@ -261,0 +284,1 @@\n+      \/\/ Otherwise, leave result == NULL because the adjusted size is smaller than min size.\n@@ -282,1 +306,5 @@\n-      usable_free -= CardTable::card_size();\n+      if (usable_free > CardTable::card_size_in_words()) {\n+        usable_free -= CardTable::card_size_in_words();\n+      } else {\n+        assert(usable_free == 0, \"usable_free is a multiple of card_size and card_size > min_fill_size\");\n+      }\n@@ -284,0 +312,1 @@\n+    assert(size % CardTable::card_size_in_words() == 0, \"PLAB size must be multiple of remembered set card size\");\n@@ -285,2 +314,0 @@\n-      assert(size % CardTable::card_size_in_words() == 0, \"PLAB size must be multiple of remembered set card size\");\n-\n@@ -288,1 +315,5 @@\n-      if (result != nullptr) {\n+      assert(result != nullptr, \"Allocation cannot fail\");\n+      assert(r->top() <= r->end(), \"Allocation cannot span end of region\");\n+      assert(req.actual_size() % CardTable::card_size_in_words() == 0, \"PLAB start must align with card boundary\");\n+      assert(((uintptr_t) result) % CardTable::card_size_in_words() == 0, \"PLAB start must align with card boundary\");\n+      if (free > usable_free) {\n@@ -312,1 +343,1 @@\n-      \/\/ assert(req.is_gc_alloc(), \"Should be gc_alloc since req wasn't mutator alloc\");\n+      assert(req.is_gc_alloc(), \"Should be gc_alloc since req wasn't mutator alloc\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":41,"deletions":10,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -993,1 +993,1 @@\n-         \"adjusted_capacity (\" SIZE_FORMAT \") and used regions size (\" SIZE_FORMAT \") should be multiples of region_size_bytes\",\n+         \"adjusted capacity (\" SIZE_FORMAT \") and used regions size (\" SIZE_FORMAT \") should be multiples of region_size_bytes\",\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,7 +47,11 @@\n-  size_t unalignment_words = unalignment_bytes \/ HeapWordSize;\n-  if (pointer_delta(end(), obj + unalignment_words) >= size) {\n-    if (unalignment_words > 0) {\n-      size_t pad_words = (alignment_in_bytes \/ HeapWordSize) - unalignment_words;\n-      if (pad_words < ShenandoahHeap::min_fill_size()) {\n-        pad_words += (alignment_in_bytes \/ HeapWordSize);\n-      }\n+  assert(unalignment_bytes % HeapWordSize == 0, \"top should be multiple of HeapWordSize\");\n+\n+  size_t pad_words = 0;\n+  if (unalignment_bytes > 0) {\n+    pad_words = (alignment_in_bytes - unalignment_bytes) \/ HeapWordSize;\n+  }\n+  if ((pad_words > 0) && (pad_words < ShenandoahHeap::min_fill_size())) {\n+    pad_words += alignment_in_bytes \/ HeapWordSize;\n+  }\n+  if (pointer_delta(end(), obj + pad_words) >= size) {\n+    if (pad_words > 0) {\n@@ -55,0 +59,1 @@\n+      \/\/ register the filled pad object\n@@ -59,0 +64,2 @@\n+    \/\/ We don't need to register the PLAB.  Its content will be registered as objects are allocated within it and\/or\n+    \/\/ when the PLAB is retired.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.inline.hpp","additions":14,"deletions":7,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -795,1 +795,0 @@\n-\n@@ -797,1 +796,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVerifier.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"}]}