{"files":[{"patch":"@@ -36,0 +36,1 @@\n+#include \"logging\/logStream.hpp\"\n@@ -40,1 +41,1 @@\n-AgeTable::AgeTable(bool global) {\n+AgeTable::AgeTable(bool global) : _use_perf_data(UsePerfData && global) {\n@@ -44,1 +45,1 @@\n-  if (UsePerfData && global) {\n+  if (_use_perf_data) {\n@@ -73,1 +74,1 @@\n-void AgeTable::merge(AgeTable* subTable) {\n+void AgeTable::merge(const AgeTable* subTable) {\n@@ -108,19 +109,4 @@\n-  if (log_is_enabled(Trace, gc, age) || UsePerfData || AgeTableTracer::is_tenuring_distribution_event_enabled()) {\n-    log_trace(gc, age)(\"Age table with threshold %u (max threshold \" UINTX_FORMAT \")\",\n-                       tenuring_threshold, MaxTenuringThreshold);\n-\n-    size_t total = 0;\n-    uint age = 1;\n-    while (age < table_size) {\n-      size_t wordSize = sizes[age];\n-      total += wordSize;\n-      if (wordSize > 0) {\n-        log_trace(gc, age)(\"- age %3u: \" SIZE_FORMAT_W(10) \" bytes, \" SIZE_FORMAT_W(10) \" total\",\n-                            age, wordSize * oopSize, total * oopSize);\n-      }\n-      AgeTableTracer::send_tenuring_distribution_event(age, wordSize * oopSize);\n-      if (UsePerfData) {\n-        _perf_sizes[age]->set_value(wordSize * oopSize);\n-      }\n-      age++;\n-    }\n+  LogTarget(Trace, gc, age) lt;\n+  if (lt.is_enabled() || _use_perf_data || AgeTableTracer::is_tenuring_distribution_event_enabled()) {\n+    LogStream st(lt);\n+    print_on(&st, tenuring_threshold);\n@@ -130,0 +116,20 @@\n+void AgeTable::print_on(outputStream* st, uint tenuring_threshold) {\n+  st->print_cr(\"Age table with threshold %u (max threshold \" UINTX_FORMAT \")\",\n+           tenuring_threshold, MaxTenuringThreshold);\n+\n+  size_t total = 0;\n+  uint age = 1;\n+  while (age < table_size) {\n+    size_t word_size = sizes[age];\n+    total += word_size;\n+    if (word_size > 0) {\n+      st->print_cr(\"- age %3u: \" SIZE_FORMAT_W(10) \" bytes, \" SIZE_FORMAT_W(10) \" total\",\n+                   age, word_size * oopSize, total * oopSize);\n+    }\n+    AgeTableTracer::send_tenuring_distribution_event(age, word_size * oopSize);\n+    if (_use_perf_data) {\n+      _perf_sizes[age]->set_value(word_size * oopSize);\n+    }\n+    age++;\n+  }\n+}\n\\ No newline at end of file\n","filename":"src\/hotspot\/share\/gc\/shared\/ageTable.cpp","additions":28,"deletions":22,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-  void merge(AgeTable* subTable);\n+  void merge(const AgeTable* subTable);\n@@ -71,0 +71,1 @@\n+  void print_on(outputStream* st, uint tenuring_threshold);\n@@ -73,1 +74,1 @@\n-\n+  bool _use_perf_data;\n","filename":"src\/hotspot\/share\/gc\/shared\/ageTable.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -115,2 +115,2 @@\n-      log_info(gc, ergo)(\"Adaptive CSet Selection for GLOBAL. Max Young Cset: \" SIZE_FORMAT\n-                         \"%s, Max Old CSet: \" SIZE_FORMAT \"%s, Actual Free: \" SIZE_FORMAT \"%s.\",\n+      log_info(gc, ergo)(\"Adaptive CSet Selection for GLOBAL. Max Young Evacuation: \" SIZE_FORMAT\n+                         \"%s, Max Old Evacuation: \" SIZE_FORMAT \"%s, Actual Free: \" SIZE_FORMAT \"%s.\",\n@@ -167,1 +167,1 @@\n-      log_info(gc, ergo)(\"Adaptive CSet Selection for YOUNG. Max CSet: \" SIZE_FORMAT \"%s, Actual Free: \" SIZE_FORMAT \"%s.\",\n+      log_info(gc, ergo)(\"Adaptive CSet Selection for YOUNG. Max Evacuation: \" SIZE_FORMAT \"%s, Actual Free: \" SIZE_FORMAT \"%s.\",\n@@ -173,3 +173,0 @@\n-        size_t new_cset;\n-        size_t region_garbage = r->garbage();\n-        size_t new_garbage = cur_young_garbage + region_garbage;\n@@ -184,1 +181,0 @@\n-            new_cset = cur_cset;\n@@ -191,1 +187,1 @@\n-            new_cset = cur_cset + r->get_live_data_bytes();\n+            size_t new_cset = cur_cset + r->get_live_data_bytes();\n@@ -217,1 +213,1 @@\n-    log_info(gc, ergo)(\"Adaptive CSet Selection. Max CSet: \" SIZE_FORMAT \"%s, Actual Free: \" SIZE_FORMAT \"%s.\",\n+    log_info(gc, ergo)(\"Adaptive CSet Selection. Max Evacuation: \" SIZE_FORMAT \"%s, Actual Free: \" SIZE_FORMAT \"%s.\",\n@@ -366,2 +362,2 @@\n-                 byte_size_in_proper_unit(available),     proper_unit_for_byte_size(available),\n-                 byte_size_in_proper_unit(min_threshold), proper_unit_for_byte_size(min_threshold));\n+                 byte_size_in_proper_unit(allocation_headroom), proper_unit_for_byte_size(allocation_headroom),\n+                 byte_size_in_proper_unit(min_threshold),       proper_unit_for_byte_size(min_threshold));\n@@ -378,2 +374,2 @@\n-                   byte_size_in_proper_unit(available),      proper_unit_for_byte_size(available),\n-                   byte_size_in_proper_unit(init_threshold), proper_unit_for_byte_size(init_threshold));\n+                   byte_size_in_proper_unit(allocation_headroom), proper_unit_for_byte_size(allocation_headroom),\n+                   byte_size_in_proper_unit(init_threshold),      proper_unit_for_byte_size(init_threshold));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.cpp","additions":9,"deletions":13,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -235,3 +235,14 @@\n-  size_t bytes_evacuated = collection_set->get_bytes_reserved_for_evacuation();\n-  log_info(gc, ergo)(\"Total Evacuation: \" SIZE_FORMAT \"%s\",\n-                     byte_size_in_proper_unit(bytes_evacuated), proper_unit_for_byte_size(bytes_evacuated));\n+  if (collection_set->garbage() > 0) {\n+    size_t young_evac_bytes = collection_set->get_young_bytes_reserved_for_evacuation();\n+    size_t promote_evac_bytes = collection_set->get_young_bytes_to_be_promoted();\n+    size_t old_evac_bytes = collection_set->get_old_bytes_reserved_for_evacuation();\n+    size_t total_evac_bytes = young_evac_bytes + promote_evac_bytes + old_evac_bytes;\n+    log_info(gc, ergo)(\"Evacuation Targets: YOUNG: \" SIZE_FORMAT \"%s, \"\n+                       \"PROMOTE: \" SIZE_FORMAT \"%s, \"\n+                       \"OLD: \" SIZE_FORMAT \"%s, \"\n+                       \"TOTAL: \" SIZE_FORMAT \"%s\",\n+                       byte_size_in_proper_unit(young_evac_bytes), proper_unit_for_byte_size(young_evac_bytes),\n+                       byte_size_in_proper_unit(promote_evac_bytes), proper_unit_for_byte_size(promote_evac_bytes),\n+                       byte_size_in_proper_unit(old_evac_bytes), proper_unit_for_byte_size(old_evac_bytes),\n+                       byte_size_in_proper_unit(total_evac_bytes), proper_unit_for_byte_size(total_evac_bytes));\n+  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.cpp","additions":14,"deletions":3,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -51,3 +51,1 @@\n-  size_t                _evacuation_reserve; \/\/ How many bytes reserved in generation for evacuation replicas.  This does\n-                                             \/\/ not include bytes reserved for old-generation replicas.  The value is\n-                                             \/\/ conservative in that memory may be reserved for objects that will be promoted.\n+\n@@ -107,1 +105,0 @@\n-  inline void reserve_young_bytes_for_evacuation(size_t byte_count);\n@@ -110,1 +107,0 @@\n-  inline void reserve_old_bytes_for_evacuation(size_t byte_count);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCollectionSet.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-  return _young_bytes_to_evacuate;\n+  return _young_bytes_to_evacuate - _young_bytes_to_promote;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCollectionSet.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"gc\/shenandoah\/shenandoahEvacTracker.hpp\"\n@@ -401,0 +402,2 @@\n+  ShenandoahCycleStats evac_stats = heap->evac_tracker()->flush_cycle_to_global();\n+\n@@ -408,0 +411,2 @@\n+      ShenandoahEvacuationTracker::print_evacuations_on(&ls, &evac_stats.workers,\n+                                                             &evac_stats.mutators);\n@@ -416,0 +421,1 @@\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,135 @@\n+\/*\n+ * Copyright (c) 2022, Amazon, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"gc\/shenandoah\/shenandoahEvacTracker.hpp\"\n+#include \"gc\/shenandoah\/shenandoahThreadLocalData.hpp\"\n+#include \"gc\/shenandoah\/shenandoahRootProcessor.hpp\"\n+#include \"runtime\/threadSMR.inline.hpp\"\n+#include \"runtime\/thread.hpp\"\n+\n+ShenandoahEvacuationStats::ShenandoahEvacuationStats()\n+  : _evacuations_completed(0), _bytes_completed(0),\n+    _evacuations_attempted(0), _bytes_attempted(0),\n+    _age_table(false) {}\n+\n+void ShenandoahEvacuationStats::begin_evacuation(size_t bytes) {\n+  ++_evacuations_attempted;\n+  _bytes_attempted += bytes;\n+}\n+\n+void ShenandoahEvacuationStats::end_evacuation(size_t bytes, uint age) {\n+  ++_evacuations_completed;\n+  _bytes_completed += bytes;\n+  if (age > 0) {\n+    _age_table.add(age, bytes \/ oopSize);\n+  }\n+}\n+\n+void ShenandoahEvacuationStats::accumulate(const ShenandoahEvacuationStats* other) {\n+  _evacuations_completed += other->_evacuations_completed;\n+  _bytes_completed += other->_bytes_completed;\n+  _evacuations_attempted += other->_evacuations_attempted;\n+  _bytes_attempted += other->_bytes_attempted;\n+\n+  _age_table.merge(&other->_age_table);\n+}\n+\n+void ShenandoahEvacuationStats::reset() {\n+  _evacuations_completed = _evacuations_attempted = 0;\n+  _bytes_completed = _bytes_attempted = 0;\n+  _age_table.clear();\n+}\n+\n+void ShenandoahEvacuationStats::print_on(outputStream* st) {\n+  size_t abandoned_size = _bytes_attempted - _bytes_completed;\n+  size_t abandoned_count = _evacuations_attempted - _evacuations_completed;\n+  st->print_cr(\"Evacuated \" SIZE_FORMAT \"%s across \" SIZE_FORMAT \" objects, \"\n+            \"abandoned \" SIZE_FORMAT \"%s across \" SIZE_FORMAT \" objects.\",\n+            byte_size_in_proper_unit(_bytes_completed),\n+            proper_unit_for_byte_size(_bytes_completed), _evacuations_completed,\n+            byte_size_in_proper_unit(abandoned_size),\n+            proper_unit_for_byte_size(abandoned_size), abandoned_count);\n+  _age_table.print_on(st, InitialTenuringThreshold);\n+}\n+\n+void ShenandoahEvacuationTracker::print_global_on(outputStream* st) {\n+  print_evacuations_on(st, &_workers_global, &_mutators_global);\n+}\n+\n+void ShenandoahEvacuationTracker::print_evacuations_on(outputStream* st,\n+                                                       ShenandoahEvacuationStats* workers,\n+                                                       ShenandoahEvacuationStats* mutators) {\n+  st->print(\"Workers: \");\n+  workers->print_on(st);\n+  st->cr();\n+  st->print(\"Mutators: \");\n+  mutators->print_on(st);\n+  st->cr();\n+\n+  AgeTable region_ages(false);\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  for (uint i = 0; i < heap->num_regions(); ++i) {\n+    ShenandoahHeapRegion* r = heap->get_region(i);\n+    if (r->age() > 0 && r->age() < AgeTable::table_size) {\n+      region_ages.add(r->age(), r->get_live_data_words());\n+    }\n+  }\n+  st->print(\"Regions: \");\n+  region_ages.print_on(st, InitialTenuringThreshold);\n+}\n+\n+class ShenandoahStatAggregator : public ThreadClosure {\n+ public:\n+  ShenandoahEvacuationStats* _target;\n+  explicit ShenandoahStatAggregator(ShenandoahEvacuationStats* target) : _target(target) {}\n+  virtual void do_thread(Thread* thread) override {\n+    ShenandoahEvacuationStats* local = ShenandoahThreadLocalData::evacuation_stats(thread);\n+    _target->accumulate(local);\n+    local->reset();\n+  }\n+};\n+\n+ShenandoahCycleStats ShenandoahEvacuationTracker::flush_cycle_to_global() {\n+  ShenandoahEvacuationStats mutators, workers;\n+\n+  ThreadsListHandle java_threads_iterator;\n+  ShenandoahStatAggregator aggregate_mutators(&mutators);\n+  java_threads_iterator.threads_do(&aggregate_mutators);\n+\n+  ShenandoahStatAggregator aggregate_workers(&workers);\n+  ShenandoahHeap::heap()->gc_threads_do(&aggregate_workers);\n+\n+  _mutators_global.accumulate(&mutators);\n+  _workers_global.accumulate(&workers);\n+\n+  return {workers, mutators};\n+}\n+\n+void ShenandoahEvacuationTracker::begin_evacuation(Thread* thread, size_t bytes) {\n+  ShenandoahThreadLocalData::begin_evacuation(thread, bytes);\n+}\n+\n+void ShenandoahEvacuationTracker::end_evacuation(Thread* thread, size_t bytes, uint age) {\n+  ShenandoahThreadLocalData::end_evacuation(thread, bytes, age);\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahEvacTracker.cpp","additions":135,"deletions":0,"binary":false,"changes":135,"status":"added"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2022, Amazon, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHENANDOAH_SHENANDOAHEVACTRACKER_HPP\n+#define SHARE_GC_SHENANDOAH_SHENANDOAHEVACTRACKER_HPP\n+\n+#include \"gc\/shared\/ageTable.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+\n+class ShenandoahEvacuationStats : public CHeapObj<mtGC> {\n+ private:\n+  size_t _evacuations_completed;\n+  size_t _bytes_completed;\n+  size_t _evacuations_attempted;\n+  size_t _bytes_attempted;\n+\n+  AgeTable _age_table;\n+\n+ public:\n+  ShenandoahEvacuationStats();\n+  void begin_evacuation(size_t bytes);\n+  void end_evacuation(size_t bytes, uint age);\n+\n+  void print_on(outputStream* st);\n+  void accumulate(const ShenandoahEvacuationStats* other);\n+  void reset();\n+};\n+\n+struct ShenandoahCycleStats {\n+  ShenandoahEvacuationStats workers;\n+  ShenandoahEvacuationStats mutators;\n+};\n+\n+class ShenandoahEvacuationTracker : public CHeapObj<mtGC> {\n+ private:\n+  ShenandoahEvacuationStats  _workers_global;\n+  ShenandoahEvacuationStats  _mutators_global;\n+\n+ public:\n+  void begin_evacuation(Thread* thread, size_t bytes);\n+  void end_evacuation(Thread* thread, size_t bytes, uint age);\n+\n+  void print_global_on(outputStream* st);\n+  static void print_evacuations_on(outputStream* st, ShenandoahEvacuationStats* workers, ShenandoahEvacuationStats* mutators);\n+\n+  ShenandoahCycleStats flush_cycle_to_global();\n+ private:\n+};\n+\n+#endif \/\/SHARE_GC_SHENANDOAH_SHENANDOAHEVACTRACKER_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahEvacTracker.hpp","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -472,1 +472,1 @@\n-    size_t young_evacuated = collection_set->get_young_bytes_reserved_for_evacuation() - young_promoted;\n+    size_t young_evacuated = collection_set->get_young_bytes_reserved_for_evacuation();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -531,0 +531,1 @@\n+  _evac_tracker(new ShenandoahEvacuationTracker()),\n@@ -854,0 +855,37 @@\n+void ShenandoahHeap::report_promotion_failure(Thread* thread, size_t size) {\n+  \/\/ We squelch excessive reports to reduce noise in logs.  Squelch enforcement is not \"perfect\" because\n+  \/\/ this same code can be in-lined in multiple contexts, and each context will have its own copy of the static\n+  \/\/ last_report_epoch and this_epoch_report_count variables.\n+  const uint MaxReportsPerEpoch = 4;\n+  static uint last_report_epoch = 0;\n+  static uint epoch_report_count = 0;\n+\n+  size_t promotion_reserve;\n+  size_t promotion_expended;\n+\n+  size_t gc_id = control_thread()->get_gc_id();\n+\n+  if ((gc_id != last_report_epoch) || (epoch_report_count++ < MaxReportsPerEpoch)) {\n+    {\n+      \/\/ Promotion failures should be very rare.  Invest in providing useful diagnostic info.\n+      ShenandoahHeapLocker locker(lock());\n+      promotion_reserve = get_promoted_reserve();\n+      promotion_expended = get_promoted_expended();\n+    }\n+    PLAB* plab = ShenandoahThreadLocalData::plab(thread);\n+    size_t words_remaining = (plab == nullptr)? 0: plab->words_remaining();\n+    const char* promote_enabled = ShenandoahThreadLocalData::allow_plab_promotions(thread)? \"enabled\": \"disabled\";\n+\n+    log_info(gc, ergo)(\"Promotion failed, size \" SIZE_FORMAT \", has plab? %s, PLAB remaining: \" SIZE_FORMAT\n+                       \", plab promotions %s, promotion reserve: \" SIZE_FORMAT \", promotion expended: \" SIZE_FORMAT,\n+                       size, plab == nullptr? \"no\": \"yes\",\n+                       words_remaining, promote_enabled, promotion_reserve, promotion_expended);\n+    if ((gc_id == last_report_epoch) && (epoch_report_count >= MaxReportsPerEpoch)) {\n+      log_info(gc, ergo)(\"Squelching additional promotion failure reports for epoch %d\", last_report_epoch);\n+    } else if (gc_id != last_report_epoch) {\n+      last_report_epoch = gc_id;;\n+      epoch_report_count = 1;\n+    }\n+  }\n+}\n+\n@@ -1734,0 +1772,4 @@\n+    ls.cr();\n+\n+    evac_tracker()->print_global_on(&ls);\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":42,"deletions":0,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"gc\/shenandoah\/shenandoahEvacTracker.hpp\"\n@@ -534,1 +535,2 @@\n-  ShenandoahPhaseTimings*    _phase_timings;\n+  ShenandoahPhaseTimings*       _phase_timings;\n+  ShenandoahEvacuationTracker*  _evac_tracker;\n@@ -550,1 +552,2 @@\n-  ShenandoahPhaseTimings*    phase_timings()     const { return _phase_timings;     }\n+  ShenandoahPhaseTimings*      phase_timings()   const { return _phase_timings;     }\n+  ShenandoahEvacuationTracker* evac_tracker()    const { return  _evac_tracker;     }\n@@ -830,0 +833,1 @@\n+  static inline uint get_object_age(oop obj);\n@@ -842,0 +846,2 @@\n+\n+  void report_promotion_failure(Thread* thread, size_t size);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -454,49 +454,1 @@\n-\n-        \/\/ We squelch excessive reports to reduce noise in logs.  Squelch enforcement is not \"perfect\" because\n-        \/\/ this same code can be in-lined in multiple contexts, and each context will have its own copy of the static\n-        \/\/ last_report_epoch and this_epoch_report_count variables.\n-        const uint MaxReportsPerEpoch = 4;\n-        static uint last_report_epoch = 0;\n-        static uint epoch_report_count = 0;\n-        PLAB* plab = ShenandoahThreadLocalData::plab(thread);\n-        size_t words_remaining = (plab == nullptr)? 0: plab->words_remaining();\n-        const char* promote_enabled = ShenandoahThreadLocalData::allow_plab_promotions(thread)? \"enabled\": \"disabled\";\n-        size_t promotion_reserve;\n-        size_t promotion_expended;\n-        \/\/ We can only query GCId::current() if current thread is a named thread.  If current thread is not a\n-        \/\/ named thread, then we don't even try to squelch the promotion failure report, we don't update the\n-        \/\/ the last_report_epoch, and we don't increment the epoch_report_count\n-        if (thread->is_Named_thread()) {\n-          uint gc_id = GCId::current();\n-          if ((gc_id != last_report_epoch) || (epoch_report_count++ < MaxReportsPerEpoch)) {\n-            {\n-              \/\/ Promotion failures should be very rare.  Invest in providing useful diagnostic info.\n-              ShenandoahHeapLocker locker(lock());\n-              promotion_reserve = get_promoted_reserve();\n-              promotion_expended = get_promoted_expended();\n-            }\n-            log_info(gc, ergo)(\"Promotion failed, size \" SIZE_FORMAT \", has plab? %s, PLAB remaining: \" SIZE_FORMAT\n-                               \", plab promotions %s, promotion reserve: \" SIZE_FORMAT \", promotion expended: \" SIZE_FORMAT,\n-                               size, plab == nullptr? \"no\": \"yes\",\n-                               words_remaining, promote_enabled, promotion_reserve, promotion_expended);\n-            if ((gc_id == last_report_epoch) && (epoch_report_count >= MaxReportsPerEpoch)) {\n-              log_info(gc, ergo)(\"Squelching additional promotion failure reports for epoch %d\\n\", last_report_epoch);\n-            } else if (gc_id != last_report_epoch) {\n-              last_report_epoch = gc_id;;\n-              epoch_report_count = 1;\n-            }\n-          }\n-        } else if (epoch_report_count < MaxReportsPerEpoch) {\n-          \/\/ Unnamed threads are much less common than named threads.  In the rare case that an unnamed thread experiences\n-          \/\/ a promotion failure before a named thread within a given epoch, the report for the unnamed thread will be squelched.\n-          {\n-            \/\/ Promotion failures should be very rare.  Invest in providing useful diagnostic info.\n-            ShenandoahHeapLocker locker(lock());\n-            promotion_reserve = get_promoted_reserve();\n-            promotion_expended = get_promoted_expended();\n-          }\n-          log_info(gc, ergo)(\"Promotion failed (unfiltered), size \" SIZE_FORMAT \", has plab? %s, PLAB remaining: \" SIZE_FORMAT\n-                             \", plab promotions %s, promotion reserve: \" SIZE_FORMAT \", promotion expended: \" SIZE_FORMAT,\n-                             size, plab == nullptr? \"no\": \"yes\",\n-                             words_remaining, promote_enabled, promotion_reserve, promotion_expended);\n-        }\n+        report_promotion_failure(thread, size);\n@@ -520,0 +472,1 @@\n+  _evac_tracker->begin_evacuation(thread, size * HeapWordSize);\n@@ -534,0 +487,1 @@\n+    _evac_tracker->end_evacuation(thread, size * HeapWordSize, ShenandoahHeap::get_object_age(copy_val));\n@@ -591,0 +545,5 @@\n+uint ShenandoahHeap::get_object_age(oop obj) {\n+  markWord w = obj->has_displaced_mark() ? obj->displaced_mark() : obj->mark();\n+  return w.age();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.inline.hpp","additions":8,"deletions":49,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"gc\/shenandoah\/shenandoahEvacTracker.hpp\"\n@@ -44,1 +45,1 @@\n-  bool                    _plab_allows_promotion; \/\/ If false, no more promotion by this thread during this evacuation phase.\n+\n@@ -51,0 +52,1 @@\n+\n@@ -63,0 +65,1 @@\n+  bool   _plab_allows_promotion; \/\/ If false, no more promotion by this thread during this evacuation phase.\n@@ -65,0 +68,2 @@\n+  ShenandoahEvacuationStats* _evacuation_stats;\n+\n@@ -78,1 +83,3 @@\n-    _plab_retries_enabled(true) {\n+    _plab_allows_promotion(true),\n+    _plab_retries_enabled(true),\n+    _evacuation_stats(new ShenandoahEvacuationStats()) {\n@@ -89,0 +96,4 @@\n+\n+    \/\/ TODO: Preserve these stats somewhere for mutator threads.\n+    delete _evacuation_stats;\n+    _evacuation_stats = nullptr;\n@@ -142,0 +153,12 @@\n+  static void begin_evacuation(Thread* thread, size_t bytes) {\n+    data(thread)->_evacuation_stats->begin_evacuation(bytes);\n+  }\n+\n+  static void end_evacuation(Thread* thread, size_t bytes, uint age) {\n+    data(thread)->_evacuation_stats->end_evacuation(bytes, age);\n+  }\n+\n+  static ShenandoahEvacuationStats* evacuation_stats(Thread* thread) {\n+    return data(thread)->_evacuation_stats;\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahThreadLocalData.hpp","additions":25,"deletions":2,"binary":false,"changes":27,"status":"modified"}]}