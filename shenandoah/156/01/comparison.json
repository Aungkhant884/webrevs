{"files":[{"patch":"@@ -126,1 +126,2 @@\n-        } else if (r->age() >= InitialTenuringThreshold) {\n+        } else if (cset->is_preselected(r->index())) {\n+          assert(r->age() >= InitialTenuringThreshold, \"Preselected regions must have tenure age\");\n@@ -131,1 +132,6 @@\n-        } else {\n+          \/\/ Since all live data in this region is being evacuated from young-gen, it is as if this memory\n+          \/\/ is garbage insofar as young-gen is concerned.  Counting this as garbage reduces the need to\n+          \/\/ reclaim highly utilized young-gen regions just for the sake of finding min_garbage to reclaim\n+          \/\/ within youn-gen memory\n+          cur_young_garbage += r->get_live_data_bytes();\n+        } else if (r->age() < InitialTenuringThreshold) {\n@@ -142,0 +148,2 @@\n+        \/\/ Note that we do not add aged regions if they were not pre-selected.  The reason they were not preselected\n+        \/\/ is because there is not sufficient room in old-gen to hold their to-be-promoted live objects.\n@@ -148,1 +156,2 @@\n-      \/\/ This is young-gen collection.\n+      \/\/ This is young-gen collection or a mixed evacuation.  If this is mixed evacuation, the old-gen candidate regions\n+      \/\/ have already been added.\n@@ -163,13 +172,31 @@\n-        if (r->age() >= InitialTenuringThreshold) {\n-          \/\/ Entire region will be promoted, This region does not impact young-gen evacuation reserve.  Memory has already\n-          \/\/ been set aside to hold evacuation results as advance_promotion_reserve.\n-          new_cset = cur_cset;\n-        } else {\n-          new_cset = cur_cset + r->get_live_data_bytes();\n-        }\n-        bool add_regardless = (region_garbage > ignore_threshold) && (new_garbage < min_garbage);\n-        if ((new_cset <= max_cset) &&\n-            (add_regardless || (region_garbage > garbage_threshold) || (r->age() >= InitialTenuringThreshold))) {\n-          cset->add_region(r);\n-          cur_cset = new_cset;\n-          cur_young_garbage = new_garbage;\n+        bool add_region = false;\n+\n+        if (!r->is_old()) {\n+          if (cset->is_preselected(r->index())) {\n+            assert(r->age() >= InitialTenuringThreshold, \"Preselected regions must have tenure age\");\n+            \/\/ Entire region will be promoted, This region does not impact young-gen evacuation reserve.  Memory has already\n+            \/\/ been set aside to hold evacuation results as advance_promotion_reserve.\n+            add_region = true;\n+            new_cset = cur_cset;\n+            \/\/ Since all live data in this region is being evacuated from young-gen, it is as if this memory\n+            \/\/ is garbage insofar as young-gen is concerned.  Counting this as garbage reduces the need to\n+            \/\/ reclaim highly utilized young-gen regions just for the sake of finding min_garbage to reclaim\n+            \/\/ within youn-gen memory\n+            cur_young_garbage += r->get_live_data_bytes();\n+          } else if  (r->age() < InitialTenuringThreshold) {\n+            new_cset = cur_cset + r->get_live_data_bytes();\n+            size_t region_garbage = r->garbage();\n+            size_t new_garbage = cur_young_garbage + region_garbage;\n+            bool add_regardless = (region_garbage > ignore_threshold) && (new_garbage < min_garbage);\n+            if ((new_cset <= max_cset) && (add_regardless || (region_garbage > garbage_threshold))) {\n+              add_region = true;\n+              cur_cset = new_cset;\n+              cur_young_garbage = new_garbage;\n+            }\n+          }\n+          \/\/ Note that we do not add aged regions if they were not pre-selected.  The reason they were not preselected\n+          \/\/ is because there is not sufficient room in old-gen to hold their to-be-promoted live objects.\n+\n+          if (add_region) {\n+            cset->add_region(r);\n+          }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.cpp","additions":43,"deletions":16,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -130,1 +130,0 @@\n-  _old_region_count = 0;\n@@ -133,0 +132,2 @@\n+\n+  _old_region_count = 0;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCollectionSet.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -441,0 +441,1 @@\n+\n@@ -449,0 +450,5 @@\n+\n+      \/\/ If we shrink old_evacuation_reserve by more than a region size, we can expand regions_available_to_loan.\n+      \/\/ Can only give back regions that are fully unused, so round down.\n+      size_t old_evac_regions_unused = (old_evacuation_reserve - old_evacuated_committed) \/ region_size_bytes;\n+      regions_available_to_loan += old_evac_regions_unused;\n@@ -473,0 +479,1 @@\n+\n@@ -475,1 +482,1 @@\n-      regions_available_to_loan -= old_regions_loaned_for_young_evac;\n+      regions_available_to_loan -= revised_loan_for_young_evacuation;\n@@ -507,2 +514,3 @@\n-    \/\/  1. old_gen->available - (old_evacuation_committed + old_bytes_loaned_for_young_evac + consumed_by_advance_promotion)\n-    \/\/  2. young bytes reserved for evacuation\n+    \/\/  1. old_gen->available - (old_evacuation_committed + old_bytes_loaned_for_young_evac + consumed_by_advance_promotion\n+    \/\/                           + old_bytes_[already]_ reserved_for_alloc_supplement)\n+    \/\/  2. young bytes reserved for evacuation (we can't promote more than young is evacuating)\n@@ -519,2 +527,4 @@\n-    size_t promotion_reserve = old_available - (old_evacuated_committed + consumed_by_advance_promotion +\n-                                                old_bytes_loaned_for_young_evac + old_bytes_reserved_for_alloc_supplement);\n+    size_t promotion_reserve = regions_available_to_loan * region_size_bytes;\n+    assert(promotion_reserve <= old_available - (old_evacuated_committed + consumed_by_advance_promotion +\n+                                                 old_bytes_loaned_for_young_evac + old_bytes_reserved_for_alloc_supplement),\n+           \"Byte reserves do not match region reserves\");\n@@ -555,0 +565,4 @@\n+\n+    size_t promotion_regions = (promotion_reserve + region_size_bytes - 1) \/ region_size_bytes;\n+    assert(regions_available_to_loan >= promotion_regions, \"Promoting more regions than memory is available\");\n+    regions_available_to_loan -= promotion_regions;\n@@ -618,1 +632,1 @@\n-    assert(old_available > old_evacuation_reserve + promotion_reserve + old_bytes_loaned_for_young_evac + allocation_supplement,\n+    assert(old_available >= old_evacuation_reserve + promotion_reserve + old_bytes_loaned_for_young_evac + allocation_supplement,\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":20,"deletions":6,"binary":false,"changes":26,"status":"modified"}]}