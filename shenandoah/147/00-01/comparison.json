{"files":[{"patch":"@@ -236,0 +236,3 @@\n+\n+  \/\/ The collector reserve may eat into what the mutator is allowed to use. Make sure we are looking\n+  \/\/ at what is available to the mutator when deciding whether to start a GC.\n@@ -244,0 +247,12 @@\n+  \/\/ Allocation spikes are a characteristic of both the application ahd the JVM configuration.  On the JVM command line,\n+  \/\/ the application developer may want to supply a hint of the nature of spikes that are inherent in the application\n+  \/\/ workload, and this information would normally be independent of heap size (not a percentage thereof).  On the\n+  \/\/ other hand, some allocation spikes are correlated with JVM configuration.  For example, there are allocation\n+  \/\/ spikes at the starts of concurrent marking and evacuation to refresh all local allocation buffers.  The nature\n+  \/\/ of these spikes is determined by LAB min and max sizes and numbers of threads, but also on frequency of GC passes,\n+  \/\/ and on \"periodic\" behavior of these threads  If GC frequency is much higher than the periodic trigger for mutator\n+  \/\/ threads, then many of the mutator threads may be able to \"sit out\" of most GC passes.  Though the thread's stack\n+  \/\/ must be scanned, the thread does not need to refresh its LABs if it sits idle throughout the duration of the GC\n+  \/\/ pass.  The best prediction for this aspect of spikes in allocation patterns is probably recent past history.\n+  \/\/ TODO: and dive deeper into _gc_time_penalties as this may also need to be corrected\n+\n@@ -245,1 +260,1 @@\n-  \/\/   1. Some space to absorb allocation spikes\n+  \/\/   1. Some space to absorb allocation spikes (ShenandoahAllocSpikeFactor)\n@@ -281,16 +296,0 @@\n-  \/\/ ShenandoahAllocSpikeFactor is the percentage of capacity that we endeavor to assure to be free at the end of the GC\n-  \/\/ cycle.\n-  \/\/ TODO: Correct the representation of this quantity\n-  \/\/       (and dive deeper into _gc_time_penalties as this may also need to be corrected)\n-  \/\/\n-  \/\/       Allocation spikes are a characteristic of both the application ahd the JVM configuration.  On the JVM command line,\n-  \/\/       the application developer may want to supply a hint of the nature of spikes that are inherent in the application\n-  \/\/       workload, and this information would normally be independent of heap size (not a percentage thereof).  On the\n-  \/\/       other hand, some allocation spikes are correlated with JVM configuration.  For example, there are allocation\n-  \/\/       spikes at the starts of concurrent marking and evacuation to refresh all local allocation buffers.  The nature\n-  \/\/       of these spikes is determined by LAB min and max sizes and numbers of threads, but also on frequency of GC passes,\n-  \/\/       and on \"periodic\" behavior of these threads  If GC frequency is much higher than the periodic trigger for mutator\n-  \/\/       threads, then many of the mutator threads may be able to \"sit out\" of most GC passes.  Though the thread's stack\n-  \/\/       must be scanned, the thread does not need to refresh its LABs if it sits idle throughout the duration of the GC\n-  \/\/       pass.  The best prediction for this aspect of spikes in allocation patterns is probably recent past history.\n-  \/\/\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.cpp","additions":16,"deletions":17,"binary":false,"changes":33,"status":"modified"}]}