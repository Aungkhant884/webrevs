{"files":[{"patch":"@@ -237,0 +237,32 @@\n+  \/\/ The collector reserve may eat into what the mutator is allowed to use. Make sure we are looking\n+  \/\/ at what is available to the mutator when deciding whether to start a GC.\n+  size_t usable = ShenandoahHeap::heap()->free_set()->available();\n+  if (usable < available) {\n+    log_debug(gc)(\"Usable (\" SIZE_FORMAT \"%s) is less than available (\" SIZE_FORMAT \"%s)\",\n+                  byte_size_in_proper_unit(usable), proper_unit_for_byte_size(usable),\n+                  byte_size_in_proper_unit(available), proper_unit_for_byte_size(available));\n+    available = usable;\n+  }\n+\n+  \/\/ Allocation spikes are a characteristic of both the application ahd the JVM configuration.  On the JVM command line,\n+  \/\/ the application developer may want to supply a hint of the nature of spikes that are inherent in the application\n+  \/\/ workload, and this information would normally be independent of heap size (not a percentage thereof).  On the\n+  \/\/ other hand, some allocation spikes are correlated with JVM configuration.  For example, there are allocation\n+  \/\/ spikes at the starts of concurrent marking and evacuation to refresh all local allocation buffers.  The nature\n+  \/\/ of these spikes is determined by LAB min and max sizes and numbers of threads, but also on frequency of GC passes,\n+  \/\/ and on \"periodic\" behavior of these threads  If GC frequency is much higher than the periodic trigger for mutator\n+  \/\/ threads, then many of the mutator threads may be able to \"sit out\" of most GC passes.  Though the thread's stack\n+  \/\/ must be scanned, the thread does not need to refresh its LABs if it sits idle throughout the duration of the GC\n+  \/\/ pass.  The best prediction for this aspect of spikes in allocation patterns is probably recent past history.\n+  \/\/ TODO: and dive deeper into _gc_time_penalties as this may also need to be corrected\n+\n+  \/\/ Check if allocation headroom is still okay. This also factors in:\n+  \/\/   1. Some space to absorb allocation spikes (ShenandoahAllocSpikeFactor)\n+  \/\/   2. Accumulated penalties from Degenerated and Full GC\n+  size_t allocation_headroom = available;\n+  size_t spike_headroom = capacity \/ 100 * ShenandoahAllocSpikeFactor;\n+  size_t penalties      = capacity \/ 100 * _gc_time_penalties;\n+\n+  allocation_headroom -= MIN2(allocation_headroom, penalties);\n+  allocation_headroom -= MIN2(allocation_headroom, spike_headroom);\n+\n@@ -243,1 +275,1 @@\n-  if (available < min_threshold) {\n+  if (allocation_headroom < min_threshold) {\n@@ -255,1 +287,1 @@\n-    if (available < init_threshold) {\n+    if (allocation_headroom < init_threshold) {\n@@ -264,21 +296,0 @@\n-  \/\/ Check if allocation headroom is still okay. This also factors in:\n-  \/\/   1. Some space to absorb allocation spikes\n-  \/\/   2. Accumulated penalties from Degenerated and Full GC\n-  size_t allocation_headroom = available;\n-\n-  \/\/ ShenandoahAllocSpikeFactor is the percentage of capacity that we endeavor to assure to be free at the end of the GC\n-  \/\/ cycle.\n-  \/\/ TODO: Correct the representation of this quantity\n-  \/\/       (and dive deeper into _gc_time_penalties as this may also need to be corrected)\n-  \/\/\n-  \/\/       Allocation spikes are a characteristic of both the application ahd the JVM configuration.  On the JVM command line,\n-  \/\/       the application developer may want to supply a hint of the nature of spikes that are inherent in the application\n-  \/\/       workload, and this information would normally be independent of heap size (not a percentage thereof).  On the\n-  \/\/       other hand, some allocation spikes are correlated with JVM configuration.  For example, there are allocation\n-  \/\/       spikes at the starts of concurrent marking and evacuation to refresh all local allocation buffers.  The nature\n-  \/\/       of these spikes is determined by LAB min and max sizes and numbers of threads, but also on frequency of GC passes,\n-  \/\/       and on \"periodic\" behavior of these threads  If GC frequency is much higher than the periodic trigger for mutator\n-  \/\/       threads, then many of the mutator threads may be able to \"sit out\" of most GC passes.  Though the thread's stack\n-  \/\/       must be scanned, the thread does not need to refresh its LABs if it sits idle throughout the duration of the GC\n-  \/\/       pass.  The best prediction for this aspect of spikes in allocation patterns is probably recent past history.\n-  \/\/\n@@ -314,2 +325,0 @@\n-  size_t spike_headroom = capacity \/ 100 * ShenandoahAllocSpikeFactor;\n-  size_t penalties      = capacity \/ 100 * _gc_time_penalties;\n@@ -326,3 +335,0 @@\n-  allocation_headroom -= MIN2(allocation_headroom, spike_headroom);\n-  allocation_headroom -= MIN2(allocation_headroom, penalties);\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.cpp","additions":34,"deletions":28,"binary":false,"changes":62,"status":"modified"}]}