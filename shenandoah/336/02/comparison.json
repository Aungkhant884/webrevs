{"files":[{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/shenandoah\/shenandoahFreeSet.hpp\"\n@@ -48,0 +49,12 @@\n+\/\/ sort by increasing index\n+int ShenandoahOldHeuristics::compare_by_index(RegionData a, RegionData b) {\n+  if (a._region->index() < b._region->index()) {\n+    return -1;\n+  } else if (a._region->index() > b._region->index()) {\n+    return 1;\n+  } else {\n+    \/\/ quicksort may compare to self during search for pivot\n+    return 0;\n+  }\n+}\n+\n@@ -353,0 +366,1 @@\n+\n@@ -388,0 +402,34 @@\n+  size_t defrag_count = 0;\n+  if (cand_idx > _last_old_collection_candidate) {\n+    \/\/ Sort the regions that were initially rejected from the collection set in order of index.\n+    QuickSort::sort<RegionData>(candidates + _last_old_collection_candidate, cand_idx - _last_old_collection_candidate,\n+                                compare_by_index, false);\n+\n+    size_t first_unselected_old_region = candidates[_last_old_collection_candidate]._region->index();\n+    size_t last_unselected_old_region = candidates[cand_idx - 1]._region->index();\n+    size_t span_of_uncollected_regions = 1 + last_unselected_old_region - first_unselected_old_region;\n+    size_t total_uncollected_old_regions = cand_idx - _last_old_collection_candidate;\n+\n+    \/\/ Add no more than 1\/8 of the existing old-gen regions to the set of mixed evacuation candidates.\n+    const int MAX_FRACTION_OF_HUMONGOUS_DEFRAG_REGIONS = 8;\n+    size_t bound_on_additional_regions = cand_idx \/ MAX_FRACTION_OF_HUMONGOUS_DEFRAG_REGIONS;\n+\n+    \/\/ The heuristic old_is_fragmented trigger may be seeking to achieve up to 7\/8 density.  Allow ourselves to overshoot\n+    \/\/ that target (at 15\/16) so we will not have to do another defragmenting old collection right away.\n+    while ((defrag_count < bound_on_additional_regions) &&\n+           (total_uncollected_old_regions < 15 * span_of_uncollected_regions \/ 16)) {\n+      ShenandoahHeapRegion* r = candidates[_last_old_collection_candidate]._region;\n+      assert (r->is_regular(), \"Only regular regions are in the candidate set\");\n+      size_t region_garbage = candidates[_last_old_collection_candidate]._region->garbage();\n+      size_t region_free = r->free();\n+      candidates_garbage += region_garbage;\n+      unfragmented += region_free;\n+      defrag_count++;\n+      _last_old_collection_candidate++;\n+\n+      \/\/ We now have one fewer uncollected regions, and our uncollected span shrinks because we have removed its first region.\n+      total_uncollected_old_regions--;\n+      span_of_uncollected_regions = 1 + last_unselected_old_region - candidates[_last_old_collection_candidate]._region->index();\n+    }\n+  }\n+\n@@ -396,2 +444,2 @@\n-               \"consolidated with free: \" SIZE_FORMAT \"%s, over \" SIZE_FORMAT \" regions, \"\n-               \"Old-Gen Immediate Garbage: \" SIZE_FORMAT \"%s over \" SIZE_FORMAT \" regions.\",\n+               \"consolidated with free: \" SIZE_FORMAT \"%s, over \" SIZE_FORMAT \" regions (humongous defragmentation: \"\n+               SIZE_FORMAT \" regions), Old-Gen Immediate Garbage: \" SIZE_FORMAT \"%s over \" SIZE_FORMAT \" regions.\",\n@@ -399,1 +447,2 @@\n-               byte_size_in_proper_unit(unfragmented),        proper_unit_for_byte_size(unfragmented), old_candidates,\n+               byte_size_in_proper_unit(unfragmented),        proper_unit_for_byte_size(unfragmented),\n+               old_candidates, defrag_count,\n@@ -474,5 +523,0 @@\n-void ShenandoahOldHeuristics::trigger_old_has_grown() {\n-  _growth_trigger = true;\n-}\n-\n-\n@@ -507,0 +551,2 @@\n+    const size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n+\n@@ -509,0 +555,2 @@\n+\n+    \/\/ used_regions includes humongous regions\n@@ -511,0 +559,10 @@\n+\n+    size_t first_active_region = heap->free_set()->first_old_region();\n+    size_t last_active_region = heap->free_set()->last_old_region();\n+    size_t span_of_active_regions = (last_active_region > first_active_region)? last_active_region + 1 - first_active_region: 0;\n+\n+    size_t first_old_region, last_old_region;\n+    double density;\n+    fragmentation_trigger_reason(density, first_old_region, last_old_region);\n+    size_t span_of_old_regions = (last_old_region > first_old_region)? last_old_region + 1 - first_old_region: 0;\n+\n@@ -512,1 +570,5 @@\n-    double percent = percent_of(fragmented_free, used_regions_size);\n+\n+    \/\/ New active regions may have came into play following the trigger.\n+    size_t first_region = MIN2(first_active_region, first_old_region);\n+    size_t last_region = MAX2(last_active_region, last_old_region);\n+\n@@ -514,2 +576,5 @@\n-                 SIZE_FORMAT \"%s available bytes spread between \" SIZE_FORMAT \" regions (%.1f%% free)\",\n-                 byte_size_in_proper_unit(fragmented_free), proper_unit_for_byte_size(fragmented_free), used_regions, percent);\n+                 SIZE_FORMAT \"%s available bytes spread between range spanned from \"\n+                 SIZE_FORMAT \" to \" SIZE_FORMAT \" (\" SIZE_FORMAT\n+                 \"), density at time of trigger: %.1f%%\",\n+                 byte_size_in_proper_unit(fragmented_free), proper_unit_for_byte_size(fragmented_free),\n+                 first_region, last_region, (last_region + 1 - first_region), density * 100);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.cpp","additions":76,"deletions":11,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -97,0 +97,5 @@\n+  \/\/ Motivation for a fragmentation_trigger\n+  double _fragmentation_density;\n+  size_t _fragmentation_first_old_region;\n+  size_t _fragmentation_last_old_region;\n+\n@@ -105,0 +110,2 @@\n+  static int compare_by_index(RegionData a, RegionData b);\n+\n@@ -156,2 +163,13 @@\n-  void trigger_old_is_fragmented() { _fragmentation_trigger = true; }\n-  void trigger_old_has_grown();\n+  void trigger_old_is_fragmented(double density, size_t first_old_index, size_t last_old_index) {\n+    _fragmentation_trigger = true;\n+    _fragmentation_density = density;\n+    _fragmentation_first_old_region = first_old_index;\n+    _fragmentation_last_old_region = last_old_index;\n+  }\n+  void trigger_old_has_grown() { _growth_trigger = true; }\n+\n+  void fragmentation_trigger_reason(double &density, size_t &first_index, size_t &last_index) {\n+    density = _fragmentation_density;\n+    first_index = _fragmentation_first_old_region;\n+    last_index = _fragmentation_last_old_region;\n+  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.hpp","additions":20,"deletions":2,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -121,0 +121,1 @@\n+    bool humongous_alloc_failure_pending = _humongous_alloc_failure_gc.is_set();\n@@ -158,2 +159,3 @@\n-      \/\/ Do not bother with degenerated cycle if old generation evacuation failed\n-      if (ShenandoahDegeneratedGC && heuristics->should_degenerate_cycle() && !old_gen_evacuation_failed) {\n+      \/\/ Do not bother with degenerated cycle if old generation evacuation failed or if humongous allocation failed\n+      if (ShenandoahDegeneratedGC && heuristics->should_degenerate_cycle() &&\n+          !old_gen_evacuation_failed && !humongous_alloc_failure_pending) {\n@@ -164,0 +166,7 @@\n+        \/\/ TODO: if humongous_alloc_failure_pending, there might be value in trying a \"compacting\" degen before\n+        \/\/ going all the way to full.  But it's a lot of work to implement this, and it may not provide value.\n+        \/\/ A compacting degen can move young regions around without doing full old-gen mark (relying upon the\n+        \/\/ remembered set scan), so it might be faster than a full gc.\n+        \/\/\n+        \/\/ Longer term, think about how to defragment humongous memory concurrently.\n+\n@@ -976,0 +985,1 @@\n+  bool is_humongous = req.size() > ShenandoahHeapRegion::region_size_words();\n@@ -977,1 +987,1 @@\n-  if (try_set_alloc_failure_gc()) {\n+  if (try_set_alloc_failure_gc(is_humongous)) {\n@@ -994,0 +1004,1 @@\n+  bool is_humongous = (words > ShenandoahHeapRegion::region_size_words());\n@@ -995,1 +1006,1 @@\n-  if (try_set_alloc_failure_gc()) {\n+  if (try_set_alloc_failure_gc(is_humongous)) {\n@@ -1007,0 +1018,1 @@\n+  _humongous_alloc_failure_gc.unset();\n@@ -1011,1 +1023,4 @@\n-bool ShenandoahControlThread::try_set_alloc_failure_gc() {\n+bool ShenandoahControlThread::try_set_alloc_failure_gc(bool is_humongous) {\n+  if (is_humongous) {\n+    _humongous_alloc_failure_gc.try_set();\n+  }\n@@ -1019,0 +1034,4 @@\n+bool ShenandoahControlThread::is_humongous_alloc_failure_gc() {\n+  return _humongous_alloc_failure_gc.is_set();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":24,"deletions":5,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -122,1 +122,2 @@\n-  bool try_set_alloc_failure_gc();\n+  bool try_set_alloc_failure_gc(bool is_humongous);\n+\n@@ -125,0 +126,1 @@\n+\n@@ -128,0 +130,3 @@\n+  \/\/ True if humongous allocation failure flag has been set.\n+  bool is_humongous_alloc_failure_gc();\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -221,0 +221,5 @@\n+inline bool ShenandoahSetsOfFree::is_empty(ShenandoahFreeMemoryType which_set) const {\n+  assert (which_set > NotFree && which_set < NumFreeSets, \"selected free set must be valid\");\n+  return (leftmost(which_set) > rightmost(which_set));\n+}\n+\n@@ -459,0 +464,24 @@\n+\/\/ Returns _max if there are no regular old regions\n+size_t ShenandoahFreeSet::first_old_region() {\n+  \/\/ if there are no OldCollector regions, leftmost equals max\n+  for (size_t i  = 0; i < _free_sets.leftmost(OldCollector); i++) {\n+    ShenandoahHeapRegion* r = _heap->get_region(i);\n+    if (r->is_old() && r->is_regular()) {\n+      return i;\n+    }\n+  }\n+  return _free_sets.leftmost(OldCollector); \/\/ which may equal max\n+}\n+\n+\/\/ Returns 0 if there are no regular old regions\n+size_t ShenandoahFreeSet::last_old_region() {\n+  \/\/ if there are no OldCollector regions, leftmost equals max\n+  for (size_t i = _free_sets.max() - 1; i > _free_sets.rightmost(OldCollector); i--) {\n+    ShenandoahHeapRegion* r = _heap->get_region(i);\n+    if (r->is_old() && r->is_regular()) {\n+      return i;\n+    }\n+  }\n+  return _free_sets.rightmost(OldCollector); \/\/ which may equal 0\n+}\n+\n@@ -541,8 +570,13 @@\n-      for (size_t idx = _free_sets.leftmost(Mutator); idx <= _free_sets.rightmost(Mutator); idx++) {\n-        ShenandoahHeapRegion* r = _heap->get_region(idx);\n-        if (_free_sets.in_free_set(idx, Mutator) && (allow_new_region || r->is_affiliated())) {\n-          \/\/ try_allocate_in() increases used if the allocation is successful.\n-          HeapWord* result;\n-          size_t min_size = (req.type() == ShenandoahAllocRequest::_alloc_tlab)? req.min_size(): req.size();\n-          if ((alloc_capacity(r) >= min_size) && ((result = try_allocate_in(r, req, in_new_region)) != nullptr)) {\n-            return result;\n+      \/\/ Allocate within mutator free from high memory to low so as to preserve low memory for humongous allocations\n+      if (!_free_sets.is_empty(Mutator)) {\n+        \/\/ Use signed idx.  Otherwise, loop will never terminate.\n+        int leftmost = (int) _free_sets.leftmost(Mutator);\n+        for (int idx = (int) _free_sets.rightmost(Mutator); idx >= leftmost; idx--) {\n+          ShenandoahHeapRegion* r = _heap->get_region(idx);\n+          if (_free_sets.in_free_set(idx, Mutator) && (allow_new_region || r->is_affiliated())) {\n+            \/\/ try_allocate_in() increases used if the allocation is successful.\n+            HeapWord* result;\n+            size_t min_size = (req.type() == ShenandoahAllocRequest::_alloc_tlab)? req.min_size(): req.size();\n+            if ((alloc_capacity(r) >= min_size) && ((result = try_allocate_in(r, req, in_new_region)) != nullptr)) {\n+              return result;\n+            }\n@@ -1051,2 +1085,6 @@\n-void ShenandoahFreeSet::find_regions_with_alloc_capacity(size_t &young_cset_regions, size_t &old_cset_regions) {\n-\n+void ShenandoahFreeSet::find_regions_with_alloc_capacity(size_t &young_cset_regions, size_t &old_cset_regions,\n+                                                         size_t &first_old_region, size_t &last_old_region,\n+                                                         size_t &old_region_count) {\n+  first_old_region = _heap->num_regions();\n+  last_old_region = 0;\n+  old_region_count = 0;\n@@ -1065,0 +1103,6 @@\n+    } else if (region->is_old() && region->is_regular()) {\n+      old_region_count++;\n+      if (first_old_region > idx) {\n+        first_old_region = idx;\n+      }\n+      last_old_region = idx;\n@@ -1153,1 +1197,2 @@\n-void ShenandoahFreeSet::prepare_to_rebuild(size_t &young_cset_regions, size_t &old_cset_regions) {\n+void ShenandoahFreeSet::prepare_to_rebuild(size_t &young_cset_regions, size_t &old_cset_regions,\n+                                           size_t &first_old_region, size_t &last_old_region, size_t &old_region_count) {\n@@ -1161,1 +1206,1 @@\n-  find_regions_with_alloc_capacity(young_cset_regions, old_cset_regions);\n+  find_regions_with_alloc_capacity(young_cset_regions, old_cset_regions, first_old_region, last_old_region, old_region_count);\n@@ -1312,0 +1357,1 @@\n+  bool dump_region_map = ShenandoahGenerationalLogFreeMap;\n@@ -1313,2 +1359,3 @@\n-  \/\/ Dump of the FreeSet details is only enabled if assertions are enabled\n-  {\n+  dump_region_map = true;\n+#endif\n+  if (dump_region_map) {\n@@ -1400,1 +1447,0 @@\n-#endif\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":61,"deletions":15,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -0,0 +1,1 @@\n+\n@@ -100,0 +101,2 @@\n+  inline bool is_empty(ShenandoahFreeMemoryType which_set) const;\n+\n@@ -200,1 +203,2 @@\n-  void prepare_to_rebuild(size_t &young_cset_regions, size_t &old_cset_regions);\n+  void prepare_to_rebuild(size_t &young_cset_regions, size_t &old_cset_regions,\n+                          size_t &first_old_region, size_t &last_old_region, size_t &old_region_count);\n@@ -217,0 +221,4 @@\n+  \/\/ index of first and regular old regions\n+  size_t first_old_region();\n+  size_t last_old_region();\n+\n@@ -225,1 +233,2 @@\n-  void find_regions_with_alloc_capacity(size_t &young_cset_regions, size_t &old_cset_regions);\n+  void find_regions_with_alloc_capacity(size_t &young_cset_regions, size_t &old_cset_regions,\n+                                        size_t &first_old_region, size_t &last_old_region, size_t &old_region_count);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.hpp","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1547,1 +1547,2 @@\n-    heap->free_set()->prepare_to_rebuild(young_cset_regions, old_cset_regions);\n+    size_t first_old, last_old, num_old;\n+    heap->free_set()->prepare_to_rebuild(young_cset_regions, old_cset_regions, first_old, last_old, num_old);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -764,1 +764,2 @@\n-    heap->free_set()->prepare_to_rebuild(young_cset_regions, old_cset_regions);\n+    size_t first_old, last_old, num_old;\n+    heap->free_set()->prepare_to_rebuild(young_cset_regions, old_cset_regions, first_old, last_old, num_old);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -425,1 +425,2 @@\n-    _free_set->prepare_to_rebuild(young_cset_regions, old_cset_regions);\n+    size_t first_old, last_old, num_old;\n+    _free_set->prepare_to_rebuild(young_cset_regions, old_cset_regions, first_old, last_old, num_old);\n@@ -2464,3 +2465,5 @@\n-  bool has_forwarded = has_forwarded_objects()? 1: 0;\n-  bool updating_or_evacuating = _gc_state.is_set(UPDATEREFS | EVACUATION)? 1: 0;\n-  assert (has_forwarded == updating_or_evacuating, \"Has forwarded objects iff updating or evacuating\");\n+  bool has_forwarded = has_forwarded_objects();\n+  bool updating_or_evacuating = _gc_state.is_set(UPDATEREFS | EVACUATION);\n+  bool evacuating = _gc_state.is_set(EVACUATION);\n+  assert ((has_forwarded == updating_or_evacuating) || (evacuating && !has_forwarded && collection_set()->is_empty()),\n+          \"Updating or evacuating iff has forwarded objects, or if evacuation phase is promoting in place without forwarding\");\n@@ -3111,1 +3114,2 @@\n-  _free_set->prepare_to_rebuild(young_cset_regions, old_cset_regions);\n+  size_t first_old_region, last_old_region, old_region_count;\n+  _free_set->prepare_to_rebuild(young_cset_regions, old_cset_regions, first_old_region, last_old_region, old_region_count);\n@@ -3137,10 +3141,32 @@\n-    size_t old_available = old_generation()->available();\n-    size_t old_unaffiliated_available = old_generation()->free_unaffiliated_regions() * region_size_bytes;\n-    size_t old_fragmented_available;\n-    assert(old_available >= old_unaffiliated_available, \"unaffiliated available is a subset of total available\");\n-    old_fragmented_available = old_available - old_unaffiliated_available;\n-\n-    size_t old_capacity = old_generation()->max_capacity();\n-    size_t heap_capacity = capacity();\n-    if ((old_capacity > heap_capacity \/ 8) && (old_fragmented_available > old_capacity \/ 8)) {\n-      old_heuristics()->trigger_old_is_fragmented();\n+    size_t old_region_span = (first_old_region <= last_old_region)? (last_old_region + 1 - first_old_region): 0;\n+    size_t allowed_old_gen_span = num_regions() - (ShenandoahGenerationalHumongousReserve * num_regions() \/ 100);\n+\n+    \/\/ Tolerate lower density if total span is small.  Here's the implementation:\n+    \/\/   if old_gen spans more than 100% and density < 87.5%, trigger old-defrag\n+    \/\/   else if old_gen spans more than 87.5% and density < 75%, trigger old-defrag\n+    \/\/   else if old_gen spans more than 75% and density < 62.5%, trigger old-defrag\n+    \/\/   else if old_gen spans more than 62.5% and density < 50%, trigger old-defrag\n+    \/\/   else if old_gen spans more than 50% and density < 37.5%, trigger old-defrag\n+\n+    ShenandoahGeneration* old_gen = old_generation();\n+    size_t old_available = old_gen->available();\n+    size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n+    size_t old_unaffiliated_available = old_gen->free_unaffiliated_regions() * region_size_bytes;\n+    assert(old_available >= old_unaffiliated_available, \"sanity\");\n+    size_t old_fragmented_available = old_available - old_unaffiliated_available;\n+\n+    size_t old_bytes_consumed = old_region_count * region_size_bytes - old_fragmented_available;\n+    size_t old_bytes_spanned = old_region_span * region_size_bytes;\n+    double old_density = ((double) old_bytes_consumed) \/ old_bytes_spanned;\n+\n+    uint eighths = 8;\n+    bool triggered = false;\n+    for (uint i = 0; i < 5; i++) {\n+      size_t span_threshold = eighths * allowed_old_gen_span \/ 8;\n+      eighths--;\n+      double density_threshold = eighths \/ 8.0;\n+      if ((old_region_span >= span_threshold) && (old_density < density_threshold)) {\n+        old_heuristics()->trigger_old_is_fragmented(old_density, first_old_region, last_old_region);\n+        triggered = true;\n+        break;\n+      }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":41,"deletions":15,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -345,1 +345,2 @@\n-    heap->free_set()->prepare_to_rebuild(cset_young_regions, cset_old_regions);\n+    size_t first_old, last_old, num_old;\n+    heap->free_set()->prepare_to_rebuild(cset_young_regions, cset_old_regions, first_old, last_old, num_old);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -38,0 +38,18 @@\n+  product(uintx, ShenandoahGenerationalHumongousReserve, 16, EXPERIMENTAL,  \\\n+          \"(Generational mode only) What percent of the heap should be \"    \\\n+          \"reserved for humongous objects if possible.  Old-generation \"    \\\n+          \"collections will endeavor to evacuate old-gen regions within \"   \\\n+          \"this reserved area even if these regions do not contain high \"   \\\n+          \"percentage of garbage.  Setting a larger value will cause \"      \\\n+          \"more frequent old-gen collections.  A smaller value will \"       \\\n+          \"increase the likelihood that humongous object allocations \"      \\\n+          \"fail, resulting in stop-the-world full GCs.\")                    \\\n+          range(0,100)                                                      \\\n+                                                                            \\\n+  product(bool, ShenandoahGenerationalLogFreeMap, false, EXPERIMENTAL,      \\\n+          \"(Generational mode only) If GC logging is enabled, display \"     \\\n+          \"a map of region usage each time the free set is rebuilt. \"       \\\n+          \"This map helps identify issues with humongous memory \"           \\\n+          \"fragmentation and helps visualize old-gen and young-gen \"        \\\n+          \"status.  This memory map is always displayed in debug builds\")   \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoah_globals.hpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"}]}