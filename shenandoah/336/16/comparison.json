{"files":[{"patch":"@@ -49,0 +49,12 @@\n+\/\/ sort by increasing index\n+int ShenandoahOldHeuristics::compare_by_index(RegionData a, RegionData b) {\n+  if (a._region->index() < b._region->index()) {\n+    return -1;\n+  } else if (a._region->index() > b._region->index()) {\n+    return 1;\n+  } else {\n+    \/\/ quicksort may compare to self during search for pivot\n+    return 0;\n+  }\n+}\n+\n@@ -358,0 +370,1 @@\n+\n@@ -393,0 +406,45 @@\n+  size_t defrag_count = 0;\n+  if (cand_idx > _last_old_collection_candidate) {\n+    \/\/ Above, we have added into the set of mixed-evacuation candidates all old-gen regions for which the live memory\n+    \/\/ that they contain is below a particular old-garbage threshold.  Regions that were not selected for the collection\n+    \/\/ set hold enough live memory that it is not considered efficient (by \"garbage-first standards\") to compact these\n+    \/\/ at the current time.\n+    \/\/\n+    \/\/ However, if any of these regions that were rejected from the collection set reside within areas of memory that\n+    \/\/ might interfere with future humongous allocation requests, we will prioritize them for evacuation at this time.\n+    \/\/ Humongous allocations target the bottom of the heap.  We want old-gen regions to congregate at the top of the\n+    \/\/ heap.\n+    \/\/\n+    \/\/ Sort the regions that were initially rejected from the collection set in order of index.  This allows us to\n+    \/\/ focus our attention on the regions that have low index value (i.e. the old-gen regions at the bottom of the heap).\n+    QuickSort::sort<RegionData>(candidates + _last_old_collection_candidate, cand_idx - _last_old_collection_candidate,\n+                                compare_by_index, false);\n+\n+    size_t first_unselected_old_region = candidates[_last_old_collection_candidate]._region->index();\n+    size_t last_unselected_old_region = candidates[cand_idx - 1]._region->index();\n+    size_t span_of_uncollected_regions = 1 + last_unselected_old_region - first_unselected_old_region;\n+    size_t total_uncollected_old_regions = cand_idx - _last_old_collection_candidate;\n+\n+    \/\/ Add no more than 1\/8 of the existing old-gen regions to the set of mixed evacuation candidates.\n+    const int MAX_FRACTION_OF_HUMONGOUS_DEFRAG_REGIONS = 8;\n+    size_t bound_on_additional_regions = cand_idx \/ MAX_FRACTION_OF_HUMONGOUS_DEFRAG_REGIONS;\n+\n+    \/\/ The heuristic old_is_fragmented trigger may be seeking to achieve up to 7\/8 density.  Allow ourselves to overshoot\n+    \/\/ that target (at 15\/16) so we will not have to do another defragmenting old collection right away.\n+    while ((defrag_count < bound_on_additional_regions) &&\n+           (total_uncollected_old_regions < 15 * span_of_uncollected_regions \/ 16)) {\n+      ShenandoahHeapRegion* r = candidates[_last_old_collection_candidate]._region;\n+      assert (r->is_regular(), \"Only regular regions are in the candidate set\");\n+      size_t region_garbage = candidates[_last_old_collection_candidate]._region->garbage();\n+      size_t region_free = r->free();\n+      candidates_garbage += region_garbage;\n+      unfragmented += region_free;\n+      defrag_count++;\n+      _last_old_collection_candidate++;\n+\n+      \/\/ We now have one fewer uncollected regions, and our uncollected span shrinks because we have removed its first region.\n+      total_uncollected_old_regions--;\n+      span_of_uncollected_regions = 1 + last_unselected_old_region - candidates[_last_old_collection_candidate]._region->index();\n+    }\n+  }\n+\n@@ -401,2 +459,2 @@\n-               \"consolidated with free: \" SIZE_FORMAT \"%s, over \" SIZE_FORMAT \" regions, \"\n-               \"Old-Gen Immediate Garbage: \" SIZE_FORMAT \"%s over \" SIZE_FORMAT \" regions.\",\n+               \"consolidated with free: \" SIZE_FORMAT \"%s, over \" SIZE_FORMAT \" regions (humongous defragmentation: \"\n+               SIZE_FORMAT \" regions), Old-Gen Immediate Garbage: \" SIZE_FORMAT \"%s over \" SIZE_FORMAT \" regions.\",\n@@ -404,1 +462,2 @@\n-               byte_size_in_proper_unit(unfragmented),        proper_unit_for_byte_size(unfragmented), old_candidates,\n+               byte_size_in_proper_unit(unfragmented),        proper_unit_for_byte_size(unfragmented),\n+               old_candidates, defrag_count,\n@@ -479,5 +538,0 @@\n-void ShenandoahOldHeuristics::trigger_old_has_grown() {\n-  _growth_trigger = true;\n-}\n-\n-\n@@ -500,0 +554,1 @@\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n@@ -501,1 +556,0 @@\n-    ShenandoahHeap* heap = ShenandoahHeap::heap();\n@@ -510,1 +564,0 @@\n-  ShenandoahHeap* heap = ShenandoahHeap::heap();\n@@ -514,0 +567,2 @@\n+\n+    \/\/ used_regions includes humongous regions\n@@ -516,0 +571,5 @@\n+\n+    size_t first_old_region, last_old_region;\n+    double density;\n+    fragmentation_trigger_reason(density, first_old_region, last_old_region);\n+    size_t span_of_old_regions = (last_old_region >= first_old_region)? last_old_region + 1 - first_old_region: 0;\n@@ -517,1 +577,1 @@\n-    double percent = percent_of(fragmented_free, used_regions_size);\n+\n@@ -519,2 +579,4 @@\n-                 SIZE_FORMAT \"%s available bytes spread between \" SIZE_FORMAT \" regions (%.1f%% free)\",\n-                 byte_size_in_proper_unit(fragmented_free), proper_unit_for_byte_size(fragmented_free), used_regions, percent);\n+                 SIZE_FORMAT \"%s available bytes spread between range spanned from \"\n+                 SIZE_FORMAT \" to \" SIZE_FORMAT \" (\" SIZE_FORMAT \"), density: %.1f%%\",\n+                 byte_size_in_proper_unit(fragmented_free), proper_unit_for_byte_size(fragmented_free),\n+                 first_old_region, last_old_region, span_of_old_regions, density * 100);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.cpp","additions":75,"deletions":13,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -97,0 +97,5 @@\n+  \/\/ Motivation for a fragmentation_trigger\n+  double _fragmentation_density;\n+  size_t _fragmentation_first_old_region;\n+  size_t _fragmentation_last_old_region;\n+\n@@ -105,0 +110,2 @@\n+  static int compare_by_index(RegionData a, RegionData b);\n+\n@@ -156,2 +163,14 @@\n-  void trigger_old_is_fragmented() { _fragmentation_trigger = true; }\n-  void trigger_old_has_grown();\n+\n+  inline void trigger_old_is_fragmented(double density, size_t first_old_index, size_t last_old_index) {\n+    _fragmentation_trigger = true;\n+    _fragmentation_density = density;\n+    _fragmentation_first_old_region = first_old_index;\n+    _fragmentation_last_old_region = last_old_index;\n+  }\n+  void trigger_old_has_grown() { _growth_trigger = true; }\n+\n+  inline void fragmentation_trigger_reason(double &density, size_t &first_index, size_t &last_index) {\n+    density = _fragmentation_density;\n+    first_index = _fragmentation_first_old_region;\n+    last_index = _fragmentation_last_old_region;\n+  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.hpp","additions":21,"deletions":2,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -174,0 +174,2 @@\n+    \/\/ TODO: Not sure there is value in logging free-set status right here.  Note that whenever the free set is rebuilt,\n+    \/\/ it logs the newly rebuilt status.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -120,0 +120,1 @@\n+    bool humongous_alloc_failure_pending = _humongous_alloc_failure_gc.is_set();\n@@ -157,2 +158,3 @@\n-      \/\/ Do not bother with degenerated cycle if old generation evacuation failed\n-      if (ShenandoahDegeneratedGC && heuristics->should_degenerate_cycle() && !old_gen_evacuation_failed) {\n+      \/\/ Do not bother with degenerated cycle if old generation evacuation failed or if humongous allocation failed\n+      if (ShenandoahDegeneratedGC && heuristics->should_degenerate_cycle() &&\n+          !old_gen_evacuation_failed && !humongous_alloc_failure_pending) {\n@@ -163,0 +165,7 @@\n+        \/\/ TODO: if humongous_alloc_failure_pending, there might be value in trying a \"compacting\" degen before\n+        \/\/ going all the way to full.  But it's a lot of work to implement this, and it may not provide value.\n+        \/\/ A compacting degen can move young regions around without doing full old-gen mark (relying upon the\n+        \/\/ remembered set scan), so it might be faster than a full gc.\n+        \/\/\n+        \/\/ Longer term, think about how to defragment humongous memory concurrently.\n+\n@@ -966,0 +975,1 @@\n+  bool is_humongous = req.size() > ShenandoahHeapRegion::region_size_words();\n@@ -967,1 +977,1 @@\n-  if (try_set_alloc_failure_gc()) {\n+  if (try_set_alloc_failure_gc(is_humongous)) {\n@@ -984,0 +994,1 @@\n+  bool is_humongous = (words > ShenandoahHeapRegion::region_size_words());\n@@ -985,1 +996,1 @@\n-  if (try_set_alloc_failure_gc()) {\n+  if (try_set_alloc_failure_gc(is_humongous)) {\n@@ -997,0 +1008,1 @@\n+  _humongous_alloc_failure_gc.unset();\n@@ -1001,1 +1013,4 @@\n-bool ShenandoahControlThread::try_set_alloc_failure_gc() {\n+bool ShenandoahControlThread::try_set_alloc_failure_gc(bool is_humongous) {\n+  if (is_humongous) {\n+    _humongous_alloc_failure_gc.try_set();\n+  }\n@@ -1009,0 +1024,4 @@\n+bool ShenandoahControlThread::is_humongous_alloc_failure_gc() {\n+  return _humongous_alloc_failure_gc.is_set();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":24,"deletions":5,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -91,0 +91,1 @@\n+  ShenandoahSharedFlag _humongous_alloc_failure_gc;\n@@ -121,1 +122,2 @@\n-  bool try_set_alloc_failure_gc();\n+  bool try_set_alloc_failure_gc(bool is_humongous);\n+\n@@ -124,0 +126,1 @@\n+\n@@ -127,0 +130,3 @@\n+  \/\/ True if humongous allocation failure flag has been set.\n+  bool is_humongous_alloc_failure_gc();\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.hpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -221,0 +221,5 @@\n+inline bool ShenandoahSetsOfFree::is_empty(ShenandoahFreeMemoryType which_set) const {\n+  assert (which_set > NotFree && which_set < NumFreeSets, \"selected free set must be valid\");\n+  return (leftmost(which_set) > rightmost(which_set));\n+}\n+\n@@ -541,8 +546,13 @@\n-      for (size_t idx = _free_sets.leftmost(Mutator); idx <= _free_sets.rightmost(Mutator); idx++) {\n-        ShenandoahHeapRegion* r = _heap->get_region(idx);\n-        if (_free_sets.in_free_set(idx, Mutator) && (allow_new_region || r->is_affiliated())) {\n-          \/\/ try_allocate_in() increases used if the allocation is successful.\n-          HeapWord* result;\n-          size_t min_size = (req.type() == ShenandoahAllocRequest::_alloc_tlab)? req.min_size(): req.size();\n-          if ((alloc_capacity(r) >= min_size) && ((result = try_allocate_in(r, req, in_new_region)) != nullptr)) {\n-            return result;\n+      \/\/ Allocate within mutator free from high memory to low so as to preserve low memory for humongous allocations\n+      if (!_free_sets.is_empty(Mutator)) {\n+        \/\/ Use signed idx.  Otherwise, loop will never terminate.\n+        int leftmost = (int) _free_sets.leftmost(Mutator);\n+        for (int idx = (int) _free_sets.rightmost(Mutator); idx >= leftmost; idx--) {\n+          ShenandoahHeapRegion* r = _heap->get_region(idx);\n+          if (_free_sets.in_free_set(idx, Mutator) && (allow_new_region || r->is_affiliated())) {\n+            \/\/ try_allocate_in() increases used if the allocation is successful.\n+            HeapWord* result;\n+            size_t min_size = (req.type() == ShenandoahAllocRequest::_alloc_tlab)? req.min_size(): req.size();\n+            if ((alloc_capacity(r) >= min_size) && ((result = try_allocate_in(r, req, in_new_region)) != nullptr)) {\n+              return result;\n+            }\n@@ -1042,2 +1052,6 @@\n-void ShenandoahFreeSet::find_regions_with_alloc_capacity(size_t &young_cset_regions, size_t &old_cset_regions) {\n-\n+void ShenandoahFreeSet::find_regions_with_alloc_capacity(size_t &young_cset_regions, size_t &old_cset_regions,\n+                                                         size_t &first_old_region, size_t &last_old_region,\n+                                                         size_t &old_region_count) {\n+  first_old_region = _heap->num_regions();\n+  last_old_region = 0;\n+  old_region_count = 0;\n@@ -1056,0 +1070,6 @@\n+    } else if (region->is_old() && region->is_regular()) {\n+      old_region_count++;\n+      if (first_old_region > idx) {\n+        first_old_region = idx;\n+      }\n+      last_old_region = idx;\n@@ -1144,1 +1164,2 @@\n-void ShenandoahFreeSet::prepare_to_rebuild(size_t &young_cset_regions, size_t &old_cset_regions) {\n+void ShenandoahFreeSet::prepare_to_rebuild(size_t &young_cset_regions, size_t &old_cset_regions,\n+                                           size_t &first_old_region, size_t &last_old_region, size_t &old_region_count) {\n@@ -1152,1 +1173,1 @@\n-  find_regions_with_alloc_capacity(young_cset_regions, old_cset_regions);\n+  find_regions_with_alloc_capacity(young_cset_regions, old_cset_regions, first_old_region, last_old_region, old_region_count);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":33,"deletions":12,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -0,0 +1,1 @@\n+\n@@ -100,0 +101,2 @@\n+  inline bool is_empty(ShenandoahFreeMemoryType which_set) const;\n+\n@@ -190,1 +193,2 @@\n-  void prepare_to_rebuild(size_t &young_cset_regions, size_t &old_cset_regions);\n+  void prepare_to_rebuild(size_t &young_cset_regions, size_t &old_cset_regions,\n+                          size_t &first_old_region, size_t &last_old_region, size_t &old_region_count);\n@@ -215,1 +219,2 @@\n-  void find_regions_with_alloc_capacity(size_t &young_cset_regions, size_t &old_cset_regions);\n+  void find_regions_with_alloc_capacity(size_t &young_cset_regions, size_t &old_cset_regions,\n+                                        size_t &first_old_region, size_t &last_old_region, size_t &old_region_count);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.hpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1546,1 +1546,2 @@\n-    heap->free_set()->prepare_to_rebuild(young_cset_regions, old_cset_regions);\n+    size_t first_old, last_old, num_old;\n+    heap->free_set()->prepare_to_rebuild(young_cset_regions, old_cset_regions, first_old, last_old, num_old);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -764,1 +764,2 @@\n-    heap->free_set()->prepare_to_rebuild(young_cset_regions, old_cset_regions);\n+    size_t first_old, last_old, num_old;\n+    heap->free_set()->prepare_to_rebuild(young_cset_regions, old_cset_regions, first_old, last_old, num_old);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -425,1 +425,2 @@\n-    _free_set->prepare_to_rebuild(young_cset_regions, old_cset_regions);\n+    size_t first_old, last_old, num_old;\n+    _free_set->prepare_to_rebuild(young_cset_regions, old_cset_regions, first_old, last_old, num_old);\n@@ -2436,1 +2437,1 @@\n-          \"Updating or evacuating iff has forwarded object, or evacuation phase is promoting in place without forwarding\");\n+          \"Updating or evacuating iff has forwarded objects, or if evacuation phase is promoting in place without forwarding\");\n@@ -3081,1 +3082,8 @@\n-  _free_set->prepare_to_rebuild(young_cset_regions, old_cset_regions);\n+  size_t first_old_region, last_old_region, old_region_count;\n+  _free_set->prepare_to_rebuild(young_cset_regions, old_cset_regions, first_old_region, last_old_region, old_region_count);\n+  \/\/ If there are no old regions, first_old_region will be greater than last_old_region\n+  assert((first_old_region > last_old_region) ||\n+         ((last_old_region + 1 - first_old_region >= old_region_count) &&\n+          get_region(first_old_region)->is_old() && get_region(last_old_region)->is_old()),\n+         \"sanity: old_region_count: \" SIZE_FORMAT \", first_old_region: \" SIZE_FORMAT \", last_old_region: \" SIZE_FORMAT,\n+         old_region_count, first_old_region, last_old_region);\n@@ -3107,10 +3115,30 @@\n-    size_t old_available = old_generation()->available();\n-    size_t old_unaffiliated_available = old_generation()->free_unaffiliated_regions() * region_size_bytes;\n-    size_t old_fragmented_available;\n-    assert(old_available >= old_unaffiliated_available, \"unaffiliated available is a subset of total available\");\n-    old_fragmented_available = old_available - old_unaffiliated_available;\n-\n-    size_t old_capacity = old_generation()->max_capacity();\n-    size_t heap_capacity = capacity();\n-    if ((old_capacity > heap_capacity \/ 8) && (old_fragmented_available > old_capacity \/ 8)) {\n-      old_heuristics()->trigger_old_is_fragmented();\n+    size_t old_region_span = (first_old_region <= last_old_region)? (last_old_region + 1 - first_old_region): 0;\n+    size_t allowed_old_gen_span = num_regions() - (ShenandoahGenerationalHumongousReserve * num_regions() \/ 100);\n+\n+    \/\/ Tolerate lower density if total span is small.  Here's the implementation:\n+    \/\/   if old_gen spans more than 100% and density < 87.5%, trigger old-defrag\n+    \/\/   else if old_gen spans more than 87.5% and density < 75%, trigger old-defrag\n+    \/\/   else if old_gen spans more than 75% and density < 62.5%, trigger old-defrag\n+    \/\/   else if old_gen spans more than 62.5% and density < 50%, trigger old-defrag\n+    \/\/   else if old_gen spans more than 50% and density < 37.5%, trigger old-defrag\n+\n+    ShenandoahGeneration* old_gen = old_generation();\n+    size_t old_available = old_gen->available();\n+    size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n+    size_t old_unaffiliated_available = old_gen->free_unaffiliated_regions() * region_size_bytes;\n+    assert(old_available >= old_unaffiliated_available, \"sanity\");\n+    size_t old_fragmented_available = old_available - old_unaffiliated_available;\n+\n+    size_t old_bytes_consumed = old_region_count * region_size_bytes - old_fragmented_available;\n+    size_t old_bytes_spanned = old_region_span * region_size_bytes;\n+    double old_density = ((double) old_bytes_consumed) \/ old_bytes_spanned;\n+\n+    uint eighths = 8;\n+    for (uint i = 0; i < 5; i++) {\n+      size_t span_threshold = eighths * allowed_old_gen_span \/ 8;\n+      eighths--;\n+      double density_threshold = eighths \/ 8.0;\n+      if ((old_region_span >= span_threshold) && (old_density < density_threshold)) {\n+        old_heuristics()->trigger_old_is_fragmented(old_density, first_old_region, last_old_region);\n+        break;\n+      }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":41,"deletions":13,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -347,1 +347,2 @@\n-    heap->free_set()->prepare_to_rebuild(cset_young_regions, cset_old_regions);\n+    size_t first_old, last_old, num_old;\n+    heap->free_set()->prepare_to_rebuild(cset_young_regions, cset_old_regions, first_old, last_old, num_old);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -38,1 +38,12 @@\n-  product(double, ShenandoahMinOldGenGrowthPercent,12.5, EXPERIMENTAL,      \\\n+  product(uintx, ShenandoahGenerationalHumongousReserve, 0, EXPERIMENTAL,   \\\n+          \"(Generational mode only) What percent of the heap should be \"    \\\n+          \"reserved for humongous objects if possible.  Old-generation \"    \\\n+          \"collections will endeavor to evacuate old-gen regions within \"   \\\n+          \"this reserved area even if these regions do not contain high \"   \\\n+          \"percentage of garbage.  Setting a larger value will cause \"      \\\n+          \"more frequent old-gen collections.  A smaller value will \"       \\\n+          \"increase the likelihood that humongous object allocations \"      \\\n+          \"fail, resulting in stop-the-world full GCs.\")                    \\\n+          range(0,100)                                                      \\\n+                                                                            \\\n+  product(double, ShenandoahMinOldGenGrowthPercent, 12.5, EXPERIMENTAL,     \\\n@@ -480,1 +491,1 @@\n-  product(uintx, ShenandoahFullGCThreshold, 64, EXPERIMENTAL,               \\\n+  product(uintx, ShenandoahFullGCThreshold, 3, EXPERIMENTAL,                \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoah_globals.hpp","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"}]}