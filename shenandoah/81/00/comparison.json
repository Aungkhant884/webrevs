{"files":[{"patch":"@@ -297,12 +297,0 @@\n-bool ShenandoahOldHeuristics::should_defer_gc() {\n-  if (unprocessed_old_collection_candidates() > 0) {\n-    \/\/ Cannot start a new old-gen GC until previous one has finished.\n-    \/\/\n-    \/\/ Future refinement: under certain circumstances, we might be more sophisticated about this choice.\n-    \/\/ For example, we could choose to abandon the previous old collection before it has completed evacuations,\n-    \/\/ but this would require that we coalesce and fill all garbage within unevacuated collection-set regions.\n-    return true;\n-  }\n-  return false;\n-}\n-\n@@ -318,0 +306,4 @@\n+void ShenandoahOldHeuristics::handle_promotion_failure() {\n+  _promotion_failed = true;\n+}\n+\n@@ -319,0 +311,1 @@\n+  _promotion_failed = false;\n@@ -327,1 +320,6 @@\n-  if (should_defer_gc()) {\n+  \/\/ Cannot start a new old-gen GC until previous one has finished.\n+  \/\/\n+  \/\/ Future refinement: under certain circumstances, we might be more sophisticated about this choice.\n+  \/\/ For example, we could choose to abandon the previous old collection before it has completed evacuations,\n+  \/\/ but this would require that we coalesce and fill all garbage within unevacuated collection-set regions.\n+  if (unprocessed_old_collection_candidates() > 0) {\n@@ -330,0 +328,9 @@\n+\n+  \/\/ If there's been a promotion failure (and we don't have regions already scheduled for evacuation),\n+  \/\/ start a new old generation collection.\n+  if (_promotion_failed) {\n+    log_info(gc)(\"Trigger: Promotion Failure\");\n+    return true;\n+  }\n+\n+  \/\/ Otherwise, defer to configured heuristic for gc trigger.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.cpp","additions":20,"deletions":13,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -69,0 +69,3 @@\n+  \/\/ Flag is set when promotion failure is detected (by gc thread), cleared when old generation collection begins (by control thread)\n+  volatile bool _promotion_failed;\n+\n@@ -72,1 +75,0 @@\n-\n@@ -111,2 +113,0 @@\n-  bool should_defer_gc();\n-\n@@ -117,0 +117,5 @@\n+  \/\/ Notify the heuristic of promotion failures. The promotion attempt will be skipped and the object will\n+  \/\/ be evacuated into the young generation. The collection should complete normally, but we want to schedule\n+  \/\/ an old collection as soon as possible.\n+  void handle_promotion_failure();\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.hpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -145,0 +145,1 @@\n+      bool old_gen_evacuation_failed = heap->clear_old_evacuation_failure();\n@@ -146,1 +147,2 @@\n-      if (ShenandoahDegeneratedGC && heuristics->should_degenerate_cycle()) {\n+      \/\/ Do not bother with degenerated cycle if old generation evacuation failed.\n+      if (ShenandoahDegeneratedGC && heuristics->should_degenerate_cycle() && !old_gen_evacuation_failed) {\n@@ -373,1 +375,2 @@\n-    {\n+    \/\/ Don't wait around if there was an allocation failure - start the next cycle immediately.\n+    if (!is_alloc_failure_gc()) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -827,0 +827,10 @@\n+void ShenandoahHeap::handle_old_evacuation_failure() {\n+  if (_old_gen_oom_evac.try_set()) {\n+    log_info(gc)(\"Old gen evac failure.\");\n+  }\n+}\n+\n+void ShenandoahHeap::handle_promotion_failure() {\n+  old_heuristics()->handle_promotion_failure();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -671,0 +671,1 @@\n+  ShenandoahSharedFlag _old_gen_oom_evac;\n@@ -674,0 +675,2 @@\n+  void handle_old_evacuation_failure();\n+  void handle_promotion_failure();\n@@ -694,0 +697,2 @@\n+  inline bool clear_old_evacuation_failure();\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -318,1 +318,2 @@\n-  if (ShenandoahThreadLocalData::is_oom_during_evac(Thread::current())) {\n+  assert(thread == Thread::current(), \"Expected thread parameter to be current thread.\");\n+  if (ShenandoahThreadLocalData::is_oom_during_evac(thread)) {\n@@ -391,3 +392,11 @@\n-    if (target_gen == OLD_GENERATION && from_region->affiliation() == YOUNG_GENERATION) {\n-      \/\/ TODO: Inform old generation heuristic of promotion failure\n-      return NULL;\n+    if (target_gen == OLD_GENERATION) {\n+      assert(mode()->is_generational(), \"Should only be here in generational mode.\");\n+      if (from_region->is_young()) {\n+        \/\/ Signal that promotion failed. Will evacuate this old object somewhere in young gen.\n+        handle_promotion_failure();\n+        return NULL;\n+      } else {\n+        \/\/ Remember that evacuation to old gen failed. We'll want to trigger a full gc to recover from this\n+        \/\/ after the evacuation threads have finished.\n+        handle_old_evacuation_failure();\n+      }\n@@ -469,0 +478,4 @@\n+inline bool ShenandoahHeap::clear_old_evacuation_failure() {\n+  return _old_gen_oom_evac.try_unset();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.inline.hpp","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"}]}