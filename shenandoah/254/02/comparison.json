{"files":[{"patch":"@@ -201,1 +201,1 @@\n-    case GLOBAL: {\n+    case GLOBAL_GEN: {\n@@ -203,2 +203,9 @@\n-      ShenandoahMarkConcurrentRootsTask<GLOBAL> task(task_queues(), nullptr, rp,\n-                                                     ShenandoahPhaseTimings::conc_mark_roots, workers->active_workers());\n+      ShenandoahMarkConcurrentRootsTask<GLOBAL_GEN> task(task_queues(), nullptr, rp,\n+                                                         ShenandoahPhaseTimings::conc_mark_roots, workers->active_workers());\n+      workers->run_task(&task);\n+      break;\n+    }\n+    case GLOBAL_NON_GEN: {\n+      assert(old_task_queues() == nullptr, \"Non-generational mark should not have old gen mark queues\");\n+      ShenandoahMarkConcurrentRootsTask<GLOBAL_NON_GEN> task(task_queues(), nullptr, rp,\n+                                                         ShenandoahPhaseTimings::conc_mark_roots, workers->active_workers());\n@@ -253,1 +260,7 @@\n-      case GLOBAL: {\n+      case GLOBAL_GEN: {\n+        TaskTerminator terminator(nworkers, task_queues());\n+        ShenandoahConcurrentMarkingTask<GLOBAL_GEN> task(this, &terminator);\n+        workers->run_task(&task);\n+        break;\n+      }\n+      case GLOBAL_NON_GEN: {\n@@ -255,1 +268,1 @@\n-        ShenandoahConcurrentMarkingTask<GLOBAL> task(this, &terminator);\n+        ShenandoahConcurrentMarkingTask<GLOBAL_NON_GEN> task(this, &terminator);\n@@ -321,2 +334,7 @@\n-    case GLOBAL:{\n-      ShenandoahFinalMarkingTask<GLOBAL> task(this, &terminator, ShenandoahStringDedup::is_enabled());\n+    case GLOBAL_GEN:{\n+      ShenandoahFinalMarkingTask<GLOBAL_GEN> task(this, &terminator, ShenandoahStringDedup::is_enabled());\n+      heap->workers()->run_task(&task);\n+      break;\n+    }\n+    case GLOBAL_NON_GEN:{\n+      ShenandoahFinalMarkingTask<GLOBAL_NON_GEN> task(this, &terminator, ShenandoahStringDedup::is_enabled());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentMark.cpp","additions":25,"deletions":7,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"gc\/shenandoah\/shenandoahGlobalGeneration.hpp\"\n@@ -64,1 +65,1 @@\n-  _requested_generation(ShenandoahGenerationType::GLOBAL),\n+  _requested_generation(select_global_generation()),\n@@ -96,1 +97,1 @@\n-  ShenandoahGenerationType generation = GLOBAL;\n+  ShenandoahGenerationType generation = select_global_generation();\n@@ -163,1 +164,1 @@\n-        generation = GLOBAL;\n+        generation = select_global_generation();\n@@ -168,1 +169,1 @@\n-      generation = GLOBAL;\n+      generation = select_global_generation();\n@@ -184,1 +185,1 @@\n-      generation = GLOBAL;\n+      generation = select_global_generation();\n@@ -222,1 +223,1 @@\n-        if (generation == GLOBAL) {\n+        if (generation == select_global_generation()) {\n@@ -248,1 +249,1 @@\n-    if (generation == GLOBAL && (alloc_failure_pending || implicit_gc_requested || explicit_gc_requested || ShenandoahAlwaysClearSoftRefs)) {\n+    if (generation == select_global_generation() && (alloc_failure_pending || implicit_gc_requested || explicit_gc_requested || ShenandoahAlwaysClearSoftRefs)) {\n@@ -294,1 +295,1 @@\n-            generation = GLOBAL;\n+            generation = select_global_generation();\n@@ -351,1 +352,1 @@\n-        assert(generation == GLOBAL, \"Only unload classes during GLOBAL cycle\");\n+        assert(generation == select_global_generation(), \"Only unload classes during GLOBAL cycle\");\n@@ -474,1 +475,6 @@\n-    case GLOBAL: {\n+    case OLD: {\n+      log_info(gc, ergo)(\"Start GC cycle (OLD)\");\n+      service_concurrent_old_cycle(heap, cause);\n+      break;\n+    }\n+    case GLOBAL_GEN: {\n@@ -479,3 +485,3 @@\n-    case OLD: {\n-      log_info(gc, ergo)(\"Start GC cycle (OLD)\");\n-      service_concurrent_old_cycle(heap, cause);\n+    case GLOBAL_NON_GEN: {\n+      log_info(gc, ergo)(\"Start GC cycle\");\n+      service_concurrent_cycle(heap->global_generation(), cause, false);\n@@ -491,1 +497,1 @@\n-                                    \"At end of Interrupted Concurrent Bootstrap GC\";\n+            \"At end of Interrupted Concurrent Bootstrap GC\";\n@@ -494,1 +500,1 @@\n-                                    \"At end of Concurrent Bootstrap GC\";\n+            \"At end of Concurrent Bootstrap GC\";\n@@ -1025,0 +1031,8 @@\n+\n+ShenandoahGenerationType ShenandoahControlThread::select_global_generation() {\n+  if (ShenandoahHeap::heap()->mode()->is_generational()) {\n+    return GLOBAL_GEN;\n+  } else {\n+    return GLOBAL_NON_GEN;\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":29,"deletions":15,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -187,0 +187,2 @@\n+  static ShenandoahGenerationType select_global_generation();\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-#include \"gc\/shenandoah\/shenandoahGeneration.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGlobalGeneration.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-  bool is_global() const { return _type == GLOBAL; }\n+  bool is_global() const { return _type == GLOBAL_GEN || _type == GLOBAL_NON_GEN; }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,3 +29,4 @@\n-    YOUNG,\n-    OLD,\n-    GLOBAL\n+    GLOBAL_NON_GEN,  \/\/ Global, non-generational\n+    GLOBAL_GEN,      \/\/ Global, generational\n+    YOUNG,           \/\/ Young,  generational\n+    OLD              \/\/ Old,    generational\n@@ -36,1 +37,3 @@\n-    case GLOBAL:\n+    case GLOBAL_NON_GEN:\n+      return \"\";\n+    case GLOBAL_GEN:\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationType.hpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -35,2 +35,2 @@\n-  ShenandoahGlobalGeneration(uint max_queues, size_t max_capacity, size_t soft_max_capacity)\n-  : ShenandoahGeneration(GLOBAL, max_queues, max_capacity, soft_max_capacity) { }\n+  ShenandoahGlobalGeneration(bool generational, uint max_queues, size_t max_capacity, size_t soft_max_capacity)\n+  : ShenandoahGeneration(generational ? GLOBAL_GEN : GLOBAL_NON_GEN, max_queues, max_capacity, soft_max_capacity) { }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGlobalGeneration.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -190,2 +190,1 @@\n-  initialize_generations();\n-  initialize_heuristics();\n+  initialize_heuristics_generations();\n@@ -454,3 +453,7 @@\n-    case YOUNG:  return _generation_sizer.max_young_size();\n-    case OLD:    return max_capacity() - _generation_sizer.min_young_size();\n-    case GLOBAL: return max_capacity();\n+    case YOUNG:\n+      return _generation_sizer.max_young_size();\n+    case OLD:\n+      return max_capacity() - _generation_sizer.min_young_size();\n+    case GLOBAL_GEN:\n+    case GLOBAL_NON_GEN:\n+      return max_capacity();\n@@ -465,3 +468,7 @@\n-    case YOUNG:  return _generation_sizer.min_young_size();\n-    case OLD:    return max_capacity() - _generation_sizer.max_young_size();\n-    case GLOBAL: return min_capacity();\n+    case YOUNG:\n+      return _generation_sizer.min_young_size();\n+    case OLD:\n+      return max_capacity() - _generation_sizer.max_young_size();\n+    case GLOBAL_GEN:\n+    case GLOBAL_NON_GEN:\n+      return min_capacity();\n@@ -474,17 +481,1 @@\n-void ShenandoahHeap::initialize_generations() {\n-  \/\/ Max capacity is the maximum _allowed_ capacity. That is, the maximum allowed capacity\n-  \/\/ for old would be total heap - minimum capacity of young. This means the sum of the maximum\n-  \/\/ allowed for old and young could exceed the total heap size. It remains the case that the\n-  \/\/ _actual_ capacity of young + old = total.\n-  _generation_sizer.heap_size_changed(soft_max_capacity());\n-  size_t initial_capacity_young = _generation_sizer.max_young_size();\n-  size_t max_capacity_young = _generation_sizer.max_young_size();\n-  size_t initial_capacity_old = max_capacity() - max_capacity_young;\n-  size_t max_capacity_old = max_capacity() - initial_capacity_young;\n-\n-  _young_generation = new ShenandoahYoungGeneration(_max_workers, max_capacity_young, initial_capacity_young);\n-  _old_generation = new ShenandoahOldGeneration(_max_workers, max_capacity_old, initial_capacity_old);\n-  _global_generation = new ShenandoahGlobalGeneration(_max_workers, soft_max_capacity(), soft_max_capacity());\n-}\n-\n-void ShenandoahHeap::initialize_heuristics() {\n+void ShenandoahHeap::initialize_heuristics_generations() {\n@@ -518,0 +509,14 @@\n+  \/\/ Max capacity is the maximum _allowed_ capacity. That is, the maximum allowed capacity\n+  \/\/ for old would be total heap - minimum capacity of young. This means the sum of the maximum\n+  \/\/ allowed for old and young could exceed the total heap size. It remains the case that the\n+  \/\/ _actual_ capacity of young + old = total.\n+  _generation_sizer.heap_size_changed(soft_max_capacity());\n+  size_t initial_capacity_young = _generation_sizer.max_young_size();\n+  size_t max_capacity_young = _generation_sizer.max_young_size();\n+  size_t initial_capacity_old = max_capacity() - max_capacity_young;\n+  size_t max_capacity_old = max_capacity() - initial_capacity_young;\n+\n+  _young_generation = new ShenandoahYoungGeneration(_max_workers, max_capacity_young, initial_capacity_young);\n+  _old_generation = new ShenandoahOldGeneration(_max_workers, max_capacity_old, initial_capacity_old);\n+  _global_generation = new ShenandoahGlobalGeneration(_gc_mode->is_generational(), _max_workers, soft_max_capacity(), soft_max_capacity());\n+\n@@ -3132,1 +3137,6 @@\n-void ShenandoahGenerationRegionClosure<GLOBAL>::heap_region_do(ShenandoahHeapRegion* region) {\n+void ShenandoahGenerationRegionClosure<GLOBAL_GEN>::heap_region_do(ShenandoahHeapRegion* region) {\n+  _cl->heap_region_do(region);\n+}\n+\n+template<>\n+void ShenandoahGenerationRegionClosure<GLOBAL_NON_GEN>::heap_region_do(ShenandoahHeapRegion* region) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":36,"deletions":26,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -194,3 +194,1 @@\n-  void initialize_mode();\n-  void initialize_heuristics();\n-  void initialize_generations();\n+  void initialize_heuristics_generations();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -160,3 +160,7 @@\n-    case GLOBAL: return 0;\n-    case OLD:    return 2;\n-    case YOUNG:  return 4;\n+    case GLOBAL_NON_GEN:\n+    case GLOBAL_GEN:\n+      return 0;\n+    case OLD:\n+      return 2;\n+    case YOUNG:\n+      return 4;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegionCounters.cpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -101,2 +101,5 @@\n-    case GLOBAL:\n-      mark_loop_prework<GLOBAL, CANCELLABLE, STRING_DEDUP>(worker_id, terminator, rp, req, update_refs);\n+    case GLOBAL_GEN:\n+      mark_loop_prework<GLOBAL_GEN, CANCELLABLE, STRING_DEDUP>(worker_id, terminator, rp, req, update_refs);\n+      break;\n+    case GLOBAL_NON_GEN:\n+      mark_loop_prework<GLOBAL_NON_GEN, CANCELLABLE, STRING_DEDUP>(worker_id, terminator, rp, req, update_refs);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMark.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-  static bool in_generation(oop obj);\n+  static bool in_generation(ShenandoahHeap* const heap, oop obj);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMark.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -266,1 +266,1 @@\n-bool ShenandoahMark::in_generation(oop obj) {\n+bool ShenandoahMark::in_generation(ShenandoahHeap* const heap, oop obj) {\n@@ -269,1 +269,1 @@\n-    return ShenandoahHeap::heap()->is_in_young(obj);\n+    return heap->is_in_young(obj);\n@@ -271,2 +271,2 @@\n-    return ShenandoahHeap::heap()->is_in_old(obj);\n-  } else if (GENERATION == GLOBAL) {\n+    return heap->is_in_old(obj);\n+  } else if (GENERATION == GLOBAL_GEN || GENERATION == GLOBAL_NON_GEN) {\n@@ -281,0 +281,3 @@\n+  \/\/ Note: This is a very hot code path, so the code should be conditional on GENERATION template\n+  \/\/ parameter where possible, in order to generate the most efficient code.\n+\n@@ -288,1 +291,1 @@\n-    if (in_generation<GENERATION>(obj)) {\n+    if (in_generation<GENERATION>(heap, obj)) {\n@@ -291,14 +294,11 @@\n-      \/\/ TODO: This is v-call on very hot path, can we sense the same from GENERATION?\n-      if (heap->mode()->is_generational()) {\n-        \/\/ TODO: As implemented herein, GLOBAL collections reconstruct the card table during GLOBAL concurrent\n-        \/\/ marking. Note that the card table is cleaned at init_mark time so it needs to be reconstructed to support\n-        \/\/ future young-gen collections.  It might be better to reconstruct card table in\n-        \/\/ ShenandoahHeapRegion::global_oop_iterate_and_fill_dead.  We could either mark all live memory as dirty, or could\n-        \/\/ use the GLOBAL update-refs scanning of pointers to determine precisely which cards to flag as dirty.\n-        if (GENERATION == YOUNG && heap->is_in_old(p)) {\n-          \/\/ Mark card as dirty because remembered set scanning still finds interesting pointer.\n-          heap->mark_card_as_dirty((HeapWord*)p);\n-        } else if (GENERATION == GLOBAL && heap->is_in_old(p) && heap->is_in_young(obj)) {\n-          \/\/ Mark card as dirty because GLOBAL marking finds interesting pointer.\n-          heap->mark_card_as_dirty((HeapWord*)p);\n-        }\n+      \/\/ TODO: As implemented herein, GLOBAL_GEN collections reconstruct the card table during GLOBAL_GEN concurrent\n+      \/\/ marking. Note that the card table is cleaned at init_mark time so it needs to be reconstructed to support\n+      \/\/ future young-gen collections.  It might be better to reconstruct card table in\n+      \/\/ ShenandoahHeapRegion::global_oop_iterate_and_fill_dead.  We could either mark all live memory as dirty, or could\n+      \/\/ use the GLOBAL update-refs scanning of pointers to determine precisely which cards to flag as dirty.\n+      if (GENERATION == YOUNG && heap->is_in_old(p)) {\n+        \/\/ Mark card as dirty because remembered set scanning still finds interesting pointer.\n+        heap->mark_card_as_dirty((HeapWord*)p);\n+      } else if (GENERATION == GLOBAL_GEN && heap->is_in_old(p) && heap->is_in_young(obj)) {\n+        \/\/ Mark card as dirty because GLOBAL marking finds interesting pointer.\n+        heap->mark_card_as_dirty((HeapWord*)p);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMark.inline.hpp","additions":19,"deletions":19,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-        if (_control_thread->request_concurrent_gc(GLOBAL)) {\n+        if (_control_thread->request_concurrent_gc(ShenandoahControlThread::select_global_generation())) {\n@@ -151,1 +151,1 @@\n-  return _global_heuristics->should_start_gc() && _control_thread->request_concurrent_gc(GLOBAL);\n+  return _global_heuristics->should_start_gc() && _control_thread->request_concurrent_gc(ShenandoahControlThread::select_global_generation());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRegulatorThread.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -142,2 +142,7 @@\n-    case GLOBAL: {\n-      ShenandoahInitMarkRootsClosure<GLOBAL> init_mark(task_queues()->queue(worker_id));\n+    case GLOBAL_NON_GEN: {\n+      ShenandoahInitMarkRootsClosure<GLOBAL_NON_GEN> init_mark(task_queues()->queue(worker_id));\n+      _root_scanner.roots_do(&init_mark, worker_id);\n+      break;\n+    }\n+    case GLOBAL_GEN: {\n+      ShenandoahInitMarkRootsClosure<GLOBAL_GEN> init_mark(task_queues()->queue(worker_id));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahSTWMark.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -48,3 +48,0 @@\n-  if (!heap->mode()->is_generational()) {                                       \\\n-    return prefix \"\" postfix;                                                   \\\n-  }                                                                             \\\n@@ -52,1 +49,3 @@\n-    case GLOBAL:                                                                \\\n+    case GLOBAL_NON_GEN:                                                        \\\n+      return prefix \"\" postfix;                                                 \\\n+    case GLOBAL_GEN:                                                            \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahUtils.hpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"}]}