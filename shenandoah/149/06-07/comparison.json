{"files":[{"patch":"@@ -39,0 +39,1 @@\n+#ifdef ASSERT\n@@ -40,0 +41,1 @@\n+#endif\n@@ -269,6 +271,4 @@\n-  log_info(gc)(\"Old-Gen Collectable Regions: \" UINT32_FORMAT \", \"\n-               \"Collectable Garbage: \" SIZE_FORMAT \"%s, \"\n-               \"Immediate Garbage: \" SIZE_FORMAT \"%s\",\n-               _last_old_collection_candidate,\n-               byte_size_in_proper_unit(collectable_garbage), proper_unit_for_byte_size(collectable_garbage),\n-               byte_size_in_proper_unit(immediate_garbage), proper_unit_for_byte_size(immediate_garbage));\n+  log_info(gc)(\"Old-Gen Collectable Garbage: \" SIZE_FORMAT \"%s over \" UINT32_FORMAT \" regions, \"\n+               \"Old-Gen Immediate Garbage: \" SIZE_FORMAT \"%s over \" SIZE_FORMAT \" regions.\",\n+               byte_size_in_proper_unit(collectable_garbage), proper_unit_for_byte_size(collectable_garbage), _last_old_collection_candidate,\n+               byte_size_in_proper_unit(immediate_garbage), proper_unit_for_byte_size(immediate_garbage), immediate_regions);\n@@ -284,1 +284,0 @@\n-  assert(_generation->generation_mode() == OLD, \"This service only available for old-gc heuristics\");\n@@ -289,1 +288,0 @@\n-  assert(_generation->generation_mode() == OLD, \"This service only available for old-gc heuristics\");\n@@ -314,1 +312,1 @@\n-uint ShenandoahOldHeuristics::last_old_region_index() {\n+uint ShenandoahOldHeuristics::last_old_region_index() const {\n@@ -350,2 +348,1 @@\n-  \/\/ For example, we could choose to abandon the previous old collection before it has completed evacuations,\n-  \/\/ but this would require that we coalesce and fill all garbage within unevacuated collection-set regions.\n+  \/\/ For example, we could choose to abandon the previous old collection before it has completed evacuations.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.cpp","additions":8,"deletions":11,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -43,3 +43,7 @@\n-  \/\/ These members are used to keep track of which candidate regions have yet\n-  \/\/ to be added to a mixed collection. There is also some special handling\n-  \/\/ for pinned regions.\n+  \/\/ The regions are sorted into a `_region_data` array (declared in base\n+  \/\/ class) in decreasing order of garbage. The heuristic will give priority\n+  \/\/ to regions containing more garbage.\n+\n+  \/\/ The following members are used to keep track of which candidate regions\n+  \/\/ have yet to be added to a mixed collection. There is also some special\n+  \/\/ handling for pinned regions, described further below.\n@@ -49,1 +53,1 @@\n-  uint _start_candidate;\n+  debug_only(uint _start_candidate);\n@@ -53,2 +57,4 @@\n-  \/\/ collection will have their pointers shifted down so that they are at the\n-  \/\/ front of the line for the next mixed collection.\n+  \/\/ collection will have been skipped. These regions are still contain garbage,\n+  \/\/ so we want to include them at the start of the list of candidates for the\n+  \/\/ _next_ mixed collection cycle. This variable is the index of the _first_\n+  \/\/ old region which is pinned when the mixed collection set is formed.\n@@ -58,1 +64,2 @@\n-  \/\/ No regions after this will be considered for inclusion in a mixed cset.\n+  \/\/ No regions after this will be considered for inclusion in a mixed collection\n+  \/\/ set.\n@@ -61,2 +68,2 @@\n-  \/\/ This index points to the front of the line of candidates to be added to the\n-  \/\/ mixed collection set. It is updated as regions are added to the collection set.\n+  \/\/ This index points to the first candidate in line to be added to the mixed\n+  \/\/ collection set. It is updated as regions are added to the collection set.\n@@ -72,1 +79,2 @@\n-  \/\/ Flag is set when promotion failure is detected (by gc thread), cleared when old generation collection begins (by control thread)\n+  \/\/ Flag is set when promotion failure is detected (by gc thread), and cleared when\n+  \/\/ old generation collection begins (by control thread).\n@@ -109,1 +117,1 @@\n-  uint last_old_region_index();\n+  uint last_old_region_index() const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.hpp","additions":19,"deletions":11,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -105,0 +105,1 @@\n+  \/\/ Returns true if the cycle has been cancelled or degenerated.\n@@ -106,0 +107,2 @@\n+\n+  \/\/ Returns true if the old generation marking completed (i.e., final mark executed for old generation).\n@@ -115,0 +118,1 @@\n+  \/\/ Return true if setting the flag which indicates allocation failure succeeds.\n@@ -116,0 +120,1 @@\n+  \/\/ Notify threads waiting for GC to complete.\n@@ -117,0 +122,1 @@\n+  \/\/ True if allocation failure flag has been set.\n@@ -131,0 +137,1 @@\n+  \/\/ Returns true if the old generation marking was interrupted to allow a young cycle.\n@@ -133,0 +140,1 @@\n+  \/\/ Returns true if the soft maximum heap has been changed using management APIs.\n@@ -151,0 +159,1 @@\n+  \/\/ Return true if the request to start a concurrent GC for the given generation succeeded.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -123,1 +123,1 @@\n-  \/\/ Used by concurrent and degenerated GC to reset regions.\n+  \/\/ Called before init mark, expected to prepare regions for marking.\n@@ -126,1 +126,1 @@\n-  \/\/ Return true iff prepared collection set includes at least one old-gen HeapRegion.\n+  \/\/ Called during final mark, chooses collection set, rebuilds free set.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -41,0 +41,5 @@\n+      \/\/ _ctx may be null when this closure is used to sync only the pin status\n+      \/\/ update the watermark of old regions. For old regions we cannot reset\n+      \/\/ the TAMS because we rely on that to keep promoted objects alive after\n+      \/\/ old marking is complete.\n+\n@@ -70,2 +75,1 @@\n-    if (_ctx != nullptr) {\n-      assert(_ctx->top_at_mark_start(r) == r->top(),\n+    assert(_ctx == nullptr || _ctx->top_at_mark_start(r) == r->top(),\n@@ -73,1 +77,0 @@\n-    }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkClosures.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -345,0 +345,43 @@\n+\/\/ This diagram depicts the expected state transitions for marking the old generation\n+\/\/ and preparing for old collections. When a young generation cycle executes, the\n+\/\/ remembered set scan must visit objects in old regions. Visiting an object which\n+\/\/ has become dead on previous old cycles will result in crashes. To avoid visiting\n+\/\/ such objects, the remembered set scan will use the old generation mark bitmap when\n+\/\/ possible. It is _not_ possible to use the old generation bitmap when old marking\n+\/\/ is active (bitmap is not complete). For this reason, the old regions are made\n+\/\/ parseable _before_ the old generation bitmap is reset. The diagram does not depict\n+\/\/ global and full collections, both of which cancel any old generation activity.\n+\/\/\n+\/\/                              +-----------------+\n+\/\/               +------------> |      IDLE       |\n+\/\/               |   +--------> |                 |\n+\/\/               |   |          +-----------------+\n+\/\/               |   |            |\n+\/\/               |   |            | Begin Old Mark\n+\/\/               |   |            v\n+\/\/               |   |          +-----------------+     +--------------------+\n+\/\/               |   |          |     FILLING     | <-> |      YOUNG GC      |\n+\/\/               |   |          |                 |     | (RSet Uses Bitmap) |\n+\/\/               |   |          +-----------------+     +--------------------+\n+\/\/               |   |            |\n+\/\/               |   |            | Reset Bitmap\n+\/\/               |   |            v\n+\/\/               |   |          +-----------------+\n+\/\/               |   |          |    BOOTSTRAP    |\n+\/\/               |   |          |                 |\n+\/\/               |   |          +-----------------+\n+\/\/               |   |            |\n+\/\/               |   |            | Continue Marking\n+\/\/               |   |            v\n+\/\/               |   |          +-----------------+     +----------------------+\n+\/\/               |   |          |    MARKING      | <-> |       YOUNG GC       |\n+\/\/               |   +----------|                 |     | (RSet Parses Region) |\n+\/\/               |              +-----------------+     +----------------------+\n+\/\/               |                |\n+\/\/               |                | Has Candidates\n+\/\/               |                v\n+\/\/               |              +-----------------+\n+\/\/               |              |     WAITING     |\n+\/\/               +------------- |                 |\n+\/\/                              +-----------------+\n+\/\/\n@@ -400,1 +443,1 @@\n-  heuristics()->record_success_concurrent(false);\n+  heuristics()->record_success_concurrent(abbreviated);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.cpp","additions":44,"deletions":1,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-    \/\/ This is not a bug. When the young generation marking is complete,\n+    \/\/ This is not a bug. When the bootstrapping marking phase is complete,\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahYoungGeneration.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}