{"files":[{"patch":"@@ -28,0 +28,1 @@\n+#include \"compiler\/compilerDefinitions.inline.hpp\"\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shenandoah\/c1\/shenandoahBarrierSetC1_aarch64.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-  assert(newval != NULL, \"new val must be register\");\n+  assert(newval != noreg, \"new val must be register\");\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shenandoah\/c1\/shenandoahBarrierSetC1_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -290,1 +290,1 @@\n-  __ cmpptr(pre_val, (int32_t) NULL_WORD);\n+  __ cmpptr(pre_val, NULL_WORD);\n@@ -918,1 +918,1 @@\n-    assert(res != NULL, \"need result register\");\n+    assert(res != noreg, \"need result register\");\n@@ -1008,1 +1008,1 @@\n-  __ cmpptr(pre_val_reg, (int32_t)NULL_WORD);\n+  __ cmpptr(pre_val_reg, NULL_WORD);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shenandoah\/shenandoahBarrierSetAssembler_x86.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -382,38 +382,0 @@\n-void CardTable::dirty(MemRegion mr) {\n-  CardValue* first = byte_for(mr.start());\n-  CardValue* last  = byte_after(mr.last());\n-  memset(first, dirty_card, last-first);\n-}\n-\n-MemRegion CardTable::dirty_card_range_after_reset(MemRegion mr,\n-                                                  bool reset,\n-                                                  int reset_val) {\n-  for (int i = 0; i < _cur_covered_regions; i++) {\n-    MemRegion mri = mr.intersection(_covered[i]);\n-    if (!mri.is_empty()) {\n-      CardValue* cur_entry, *next_entry, *limit;\n-      for (cur_entry = byte_for(mri.start()), limit = byte_for(mri.last());\n-           cur_entry <= limit;\n-           cur_entry  = next_entry) {\n-        next_entry = cur_entry + 1;\n-        if (*cur_entry == dirty_card) {\n-          size_t dirty_cards;\n-          \/\/ Accumulate maximal dirty card range, starting at cur_entry\n-          for (dirty_cards = 1;\n-               next_entry <= limit && *next_entry == dirty_card;\n-               dirty_cards++, next_entry++);\n-          MemRegion cur_cards(addr_for(cur_entry),\n-                              dirty_cards * _card_size_in_words);\n-          if (reset) {\n-            for (size_t i = 0; i < dirty_cards; i++) {\n-              cur_entry[i] = reset_val;\n-            }\n-          }\n-          return cur_cards;\n-        }\n-      }\n-    }\n-  }\n-  return MemRegion(mr.end(), mr.end());\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTable.cpp","additions":0,"deletions":38,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"gc\/shared\/gcUtil.hpp\"\n@@ -150,1 +149,1 @@\n- protected:\n+protected:\n@@ -157,4 +156,0 @@\n-  size_t _default_plab_sz;\n-  size_t _desired_net_plab_sz;\/\/ Output of filter (below), suitably trimmed and quantized\n-  AdaptiveWeightedAverage\n-         _filter;             \/\/ Integrator with decay\n@@ -169,8 +164,2 @@\n-  virtual void log_plab_allocation();\n-  virtual void log_sizing(size_t calculated, size_t net_desired);\n-\n-  \/\/ helper for adjust_desired_plab_sz().\n-  virtual size_t compute_desired_plab_sz();\n-\n- public:\n-  PLABStats(const char* description, size_t default_per_thread_plab_size, size_t desired_net_plab_sz, unsigned wt) :\n+public:\n+  PLABStats(const char* description) :\n@@ -181,4 +170,1 @@\n-    _unused(0),\n-    _default_plab_sz(default_per_thread_plab_size),\n-    _desired_net_plab_sz(desired_net_plab_sz),\n-    _filter(wt)\n+    _unused(0)\n@@ -203,7 +189,0 @@\n-  \/\/ Calculates plab size for current number of gc worker threads.\n-  size_t desired_plab_sz(uint no_of_gc_workers);\n-\n-  \/\/ Updates the current desired PLAB size. Computes the new desired PLAB size with one gc worker thread,\n-  \/\/ updates _desired_plab_sz and clears sensor accumulators.\n-  void adjust_desired_plab_sz();\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/plab.hpp","additions":4,"deletions":25,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2825,2 +2825,0 @@\n-               u->Opcode() == Op_StoreIConditional ||\n-               u->Opcode() == Op_StoreLConditional ||\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -216,1 +216,1 @@\n-  res = load_reference_barrier(decorators, res, reinterpret_cast<T*>(NULL));\n+  res = load_reference_barrier(decorators, res, static_cast<T*>(nullptr));\n@@ -227,1 +227,1 @@\n-  previous = load_reference_barrier<T>(decorators, previous, reinterpret_cast<T*>(NULL));\n+  previous = load_reference_barrier<T>(decorators, previous, static_cast<T*>(nullptr));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -86,0 +86,1 @@\n+#include \"code\/codeCache.hpp\"\n@@ -2254,0 +2255,2 @@\n+    ShenandoahIsAliveSelector is_alive;\n+    CodeCache::UnloadingScope scope(is_alive.is_alive_closure());\n@@ -2258,2 +2261,1 @@\n-    ShenandoahIsAliveSelector is_alive;\n-    ShenandoahClassUnloadingTask unlink_task(phase, is_alive.is_alive_closure(), num_workers, purged_class);\n+    ShenandoahClassUnloadingTask unlink_task(phase, num_workers, purged_class);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"}]}