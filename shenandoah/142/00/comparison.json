{"files":[{"patch":"@@ -220,23 +220,29 @@\n-  size_t old_available, young_available;\n-  {\n-    ShenandoahYoungGeneration* young_gen = heap->young_generation();\n-    ShenandoahGeneration* old_gen = heap->old_generation();\n-    ShenandoahHeapLocker locker(heap->lock());\n-\n-    size_t old_usage_before_evac = heap->capture_old_usage(0);\n-    size_t old_usage_now = old_gen->used();\n-    size_t promoted_bytes = old_usage_now - old_usage_before_evac;\n-    heap->set_previous_promotion(promoted_bytes);\n-\n-    young_gen->unadjust_available();\n-    old_gen->unadjust_available();\n-    \/\/ No need to old_gen->increase_used().  That was done when plabs were allocated, accounting for both old evacs and promotions.\n-\n-    young_available = young_gen->adjusted_available();\n-    old_available = old_gen->adjusted_available();\n-\n-    heap->set_alloc_supplement_reserve(0);\n-    heap->set_young_evac_reserve(0);\n-    heap->set_old_evac_reserve(0);\n-    heap->reset_old_evac_expended();\n-    heap->set_promotion_reserve(0);\n+  if (heap->mode()->is_generational()) {\n+    size_t old_available, young_available;\n+    {\n+      ShenandoahYoungGeneration* young_gen = heap->young_generation();\n+      ShenandoahGeneration* old_gen = heap->old_generation();\n+      ShenandoahHeapLocker locker(heap->lock());\n+\n+      size_t old_usage_before_evac = heap->capture_old_usage(0);\n+      size_t old_usage_now = old_gen->used();\n+      size_t promoted_bytes = old_usage_now - old_usage_before_evac;\n+      heap->set_previous_promotion(promoted_bytes);\n+\n+      young_gen->unadjust_available();\n+      old_gen->unadjust_available();\n+      \/\/ No need to old_gen->increase_used().\n+      \/\/ That was done when plabs were allocated, accounting for both old evacs and promotions.\n+\n+      young_available = young_gen->adjusted_available();\n+      old_available = old_gen->adjusted_available();\n+\n+      heap->set_alloc_supplement_reserve(0);\n+      heap->set_young_evac_reserve(0);\n+      heap->set_old_evac_reserve(0);\n+      heap->reset_old_evac_expended();\n+      heap->set_promotion_reserve(0);\n+    }\n+    log_info(gc, ergo)(\"At end of concurrent GC, old_available: \" SIZE_FORMAT \"%s, young_available: \" SIZE_FORMAT \"%s\",\n+                       byte_size_in_proper_unit(old_available), proper_unit_for_byte_size(old_available),\n+                       byte_size_in_proper_unit(young_available), proper_unit_for_byte_size(young_available));\n@@ -244,3 +250,0 @@\n-  log_info(gc, ergo)(\"At end of concurrent GC, old_available: \" SIZE_FORMAT \"%s, young_available: \" SIZE_FORMAT \"%s\",\n-                     byte_size_in_proper_unit(old_available), proper_unit_for_byte_size(old_available),\n-                     byte_size_in_proper_unit(young_available), proper_unit_for_byte_size(young_available));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":29,"deletions":26,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -56,0 +56,8 @@\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  if (heap->mode()->is_generational()) {\n+    size_t old_available = heap->old_generation()->available();\n+    size_t young_available = heap->young_generation()->available();\n+    log_info(gc, ergo)(\"At end of Degenerated GC, old_available: \" SIZE_FORMAT \"%s, young_available: \" SIZE_FORMAT \"%s\",\n+                       byte_size_in_proper_unit(old_available), proper_unit_for_byte_size(old_available),\n+                       byte_size_in_proper_unit(young_available), proper_unit_for_byte_size(young_available));\n+  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahDegeneratedGC.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -170,1 +170,7 @@\n-\n+  if (heap->mode()->is_generational()) {\n+    size_t old_available = heap->old_generation()->available();\n+    size_t young_available = heap->young_generation()->available();\n+    log_info(gc, ergo)(\"At end of Full GC, old_available: \" SIZE_FORMAT \"%s, young_available: \" SIZE_FORMAT \"%s\",\n+                       byte_size_in_proper_unit(old_available), proper_unit_for_byte_size(old_available),\n+                       byte_size_in_proper_unit(young_available), proper_unit_for_byte_size(young_available));\n+  }\n@@ -185,4 +191,5 @@\n-  \/\/ There will be no concurrent allocations during full GC so reset these coordination variables.\n-  heap->young_generation()->unadjust_available();\n-  heap->old_generation()->unadjust_available();\n-  \/\/ No need to old_gen->increase_used().  That was done when plabs were allocated, accounting for both old evacs and promotions.\n+  if (heap->mode()->is_generational()) {\n+    \/\/ There will be no concurrent allocations during full GC so reset these coordination variables.\n+    heap->young_generation()->unadjust_available();\n+    heap->old_generation()->unadjust_available();\n+    \/\/ No need to old_gen->increase_used().  That was done when plabs were allocated, accounting for both old evacs and promotions.\n@@ -190,5 +197,5 @@\n-  heap->set_alloc_supplement_reserve(0);\n-  heap->set_young_evac_reserve(0);\n-  heap->set_old_evac_reserve(0);\n-  heap->reset_old_evac_expended();\n-  heap->set_promotion_reserve(0);\n+    heap->set_alloc_supplement_reserve(0);\n+    heap->set_young_evac_reserve(0);\n+    heap->set_old_evac_reserve(0);\n+    heap->reset_old_evac_expended();\n+    heap->set_promotion_reserve(0);\n@@ -196,1 +203,0 @@\n-  if (heap->mode()->is_generational()) {\n@@ -517,1 +523,1 @@\n-        (from_region_age + object_age > InitialTenuringThreshold)) {\n+        (from_region_age + object_age >= InitialTenuringThreshold)) {\n@@ -826,0 +832,1 @@\n+    bool is_generational = _heap->mode()->is_generational();\n@@ -830,1 +837,2 @@\n-      r->make_regular_bypass();\n+      \/\/ If generational, leave affiliation alone.\n+      r->make_regular_bypass(!is_generational);\n@@ -1249,0 +1257,1 @@\n+    bool is_generational = _heap->mode()->is_generational();\n@@ -1263,1 +1272,1 @@\n-      r->make_regular_bypass();\n+      r->make_regular_bypass(!is_generational);\n@@ -1278,1 +1287,1 @@\n-    if (_heap->mode()->is_generational() && live != 0) {\n+    if (is_generational && live != 0) {\n@@ -1337,1 +1346,2 @@\n-          r->make_regular_bypass();\n+          \/\/ Consider regions emptied by humongous evacuation to be young\n+          r->make_regular_bypass(true);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":26,"deletions":16,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -113,1 +113,1 @@\n-void ShenandoahHeapRegion::make_regular_bypass() {\n+void ShenandoahHeapRegion::make_regular_bypass(bool make_young_affiliation) {\n@@ -125,6 +125,3 @@\n-      \/\/ TODO: Changing this region to young during compaction may not be\n-      \/\/ technically correct here because it completely disregards the ages\n-      \/\/ and origins of the objects being moved. It is, however, certainly\n-      \/\/ more correct than putting live objects into a region without a\n-      \/\/ generational affiliation.\n-      set_affiliation(YOUNG_GENERATION);\n+      if (make_young_affiliation) {\n+        set_affiliation(YOUNG_GENERATION);\n+      }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.cpp","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -172,1 +172,1 @@\n-  void make_regular_bypass();\n+  void make_regular_bypass(bool make_young_affiliation);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}