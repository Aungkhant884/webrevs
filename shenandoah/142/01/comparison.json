{"files":[{"patch":"@@ -220,23 +220,29 @@\n-  size_t old_available, young_available;\n-  {\n-    ShenandoahYoungGeneration* young_gen = heap->young_generation();\n-    ShenandoahGeneration* old_gen = heap->old_generation();\n-    ShenandoahHeapLocker locker(heap->lock());\n-\n-    size_t old_usage_before_evac = heap->capture_old_usage(0);\n-    size_t old_usage_now = old_gen->used();\n-    size_t promoted_bytes = old_usage_now - old_usage_before_evac;\n-    heap->set_previous_promotion(promoted_bytes);\n-\n-    young_gen->unadjust_available();\n-    old_gen->unadjust_available();\n-    \/\/ No need to old_gen->increase_used().  That was done when plabs were allocated, accounting for both old evacs and promotions.\n-\n-    young_available = young_gen->adjusted_available();\n-    old_available = old_gen->adjusted_available();\n-\n-    heap->set_alloc_supplement_reserve(0);\n-    heap->set_young_evac_reserve(0);\n-    heap->set_old_evac_reserve(0);\n-    heap->reset_old_evac_expended();\n-    heap->set_promotion_reserve(0);\n+  if (heap->mode()->is_generational()) {\n+    size_t old_available, young_available;\n+    {\n+      ShenandoahYoungGeneration* young_gen = heap->young_generation();\n+      ShenandoahGeneration* old_gen = heap->old_generation();\n+      ShenandoahHeapLocker locker(heap->lock());\n+\n+      size_t old_usage_before_evac = heap->capture_old_usage(0);\n+      size_t old_usage_now = old_gen->used();\n+      size_t promoted_bytes = old_usage_now - old_usage_before_evac;\n+      heap->set_previous_promotion(promoted_bytes);\n+\n+      young_gen->unadjust_available();\n+      old_gen->unadjust_available();\n+      \/\/ No need to old_gen->increase_used().\n+      \/\/ That was done when plabs were allocated, accounting for both old evacs and promotions.\n+\n+      young_available = young_gen->adjusted_available();\n+      old_available = old_gen->adjusted_available();\n+\n+      heap->set_alloc_supplement_reserve(0);\n+      heap->set_young_evac_reserve(0);\n+      heap->set_old_evac_reserve(0);\n+      heap->reset_old_evac_expended();\n+      heap->set_promotion_reserve(0);\n+    }\n+    log_info(gc, ergo)(\"At end of concurrent GC, old_available: \" SIZE_FORMAT \"%s, young_available: \" SIZE_FORMAT \"%s\",\n+                       byte_size_in_proper_unit(old_available), proper_unit_for_byte_size(old_available),\n+                       byte_size_in_proper_unit(young_available), proper_unit_for_byte_size(young_available));\n@@ -244,3 +250,0 @@\n-  log_info(gc, ergo)(\"At end of concurrent GC, old_available: \" SIZE_FORMAT \"%s, young_available: \" SIZE_FORMAT \"%s\",\n-                     byte_size_in_proper_unit(old_available), proper_unit_for_byte_size(old_available),\n-                     byte_size_in_proper_unit(young_available), proper_unit_for_byte_size(young_available));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":29,"deletions":26,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -56,0 +56,8 @@\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  if (heap->mode()->is_generational()) {\n+    size_t old_available = heap->old_generation()->available();\n+    size_t young_available = heap->young_generation()->available();\n+    log_info(gc, ergo)(\"At end of Degenerated GC, old_available: \" SIZE_FORMAT \"%s, young_available: \" SIZE_FORMAT \"%s\",\n+                       byte_size_in_proper_unit(old_available), proper_unit_for_byte_size(old_available),\n+                       byte_size_in_proper_unit(young_available), proper_unit_for_byte_size(young_available));\n+  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahDegeneratedGC.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -170,1 +170,7 @@\n-\n+  if (heap->mode()->is_generational()) {\n+    size_t old_available = heap->old_generation()->available();\n+    size_t young_available = heap->young_generation()->available();\n+    log_info(gc, ergo)(\"At end of Full GC, old_available: \" SIZE_FORMAT \"%s, young_available: \" SIZE_FORMAT \"%s\",\n+                       byte_size_in_proper_unit(old_available), proper_unit_for_byte_size(old_available),\n+                       byte_size_in_proper_unit(young_available), proper_unit_for_byte_size(young_available));\n+  }\n@@ -185,4 +191,5 @@\n-  \/\/ There will be no concurrent allocations during full GC so reset these coordination variables.\n-  heap->young_generation()->unadjust_available();\n-  heap->old_generation()->unadjust_available();\n-  \/\/ No need to old_gen->increase_used().  That was done when plabs were allocated, accounting for both old evacs and promotions.\n+  if (heap->mode()->is_generational()) {\n+    \/\/ There will be no concurrent allocations during full GC so reset these coordination variables.\n+    heap->young_generation()->unadjust_available();\n+    heap->old_generation()->unadjust_available();\n+    \/\/ No need to old_gen->increase_used().  That was done when plabs were allocated, accounting for both old evacs and promotions.\n@@ -190,5 +197,5 @@\n-  heap->set_alloc_supplement_reserve(0);\n-  heap->set_young_evac_reserve(0);\n-  heap->set_old_evac_reserve(0);\n-  heap->reset_old_evac_expended();\n-  heap->set_promotion_reserve(0);\n+    heap->set_alloc_supplement_reserve(0);\n+    heap->set_young_evac_reserve(0);\n+    heap->set_old_evac_reserve(0);\n+    heap->reset_old_evac_expended();\n+    heap->set_promotion_reserve(0);\n@@ -196,1 +203,0 @@\n-  if (heap->mode()->is_generational()) {\n@@ -517,1 +523,1 @@\n-        (from_region_age + object_age > InitialTenuringThreshold)) {\n+        (from_region_age + object_age >= InitialTenuringThreshold)) {\n@@ -826,0 +832,1 @@\n+    bool is_generational = _heap->mode()->is_generational();\n@@ -830,0 +837,1 @@\n+      \/\/ Leave afffiliation unchanged.\n@@ -1249,0 +1257,1 @@\n+    bool is_generational = _heap->mode()->is_generational();\n@@ -1263,0 +1272,4 @@\n+      if (!is_generational) {\n+        r->make_young_maybe();\n+      }\n+      \/\/ else, generational mode compaction has already established affiliation.\n@@ -1278,1 +1291,1 @@\n-    if (_heap->mode()->is_generational() && live != 0) {\n+    if (is_generational && live != 0) {\n@@ -1337,0 +1350,1 @@\n+          \/\/ Leave humongous region affiliation unchanged.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":27,"deletions":13,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -113,0 +113,20 @@\n+\/\/ Change affiliation to YOUNG_GENERATION if _state is not _pinned_cset, _regular, or _pinned.  This implements\n+\/\/ behavior previously performed as a side effect of make_regular_bypass().\n+void ShenandoahHeapRegion::make_young_maybe() {\n+ switch (_state) {\n+   case _empty_uncommitted:\n+   case _empty_committed:\n+   case _cset:\n+   case _humongous_start:\n+   case _humongous_cont:\n+     set_affiliation(YOUNG_GENERATION);\n+     return;\n+   case _pinned_cset:\n+   case _regular:\n+   case _pinned:\n+     return;\n+   default:\n+     assert(false, \"Unexpected _state in make_young_maybe\");\n+  }\n+}\n+\n@@ -125,6 +145,0 @@\n-      \/\/ TODO: Changing this region to young during compaction may not be\n-      \/\/ technically correct here because it completely disregards the ages\n-      \/\/ and origins of the objects being moved. It is, however, certainly\n-      \/\/ more correct than putting live objects into a region without a\n-      \/\/ generational affiliation.\n-      set_affiliation(YOUNG_GENERATION);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.cpp","additions":20,"deletions":6,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -172,0 +172,1 @@\n+  void make_young_maybe();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}