{"files":[{"patch":"@@ -354,12 +354,8 @@\n-  if (UseCondCardMark) {\n-    LIR_Opr cur_value = gen->new_register(T_INT);\n-    __ move(card_addr, cur_value);\n-\n-    LabelObj* L_already_dirty = new LabelObj();\n-    __ cmp(lir_cond_equal, cur_value, dirty);\n-    __ branch(lir_cond_equal, L_already_dirty->label());\n-    __ move(dirty, card_addr);\n-    __ branch_destination(L_already_dirty->label());\n-  } else {\n-    __ move(dirty, card_addr);\n-  }\n+  LIR_Opr cur_value = gen->new_register(T_INT);\n+  __ move(card_addr, cur_value);\n+\n+  LabelObj* L_already_dirty = new LabelObj();\n+  __ cmp(lir_cond_equal, cur_value, dirty);\n+  __ branch(lir_cond_equal, L_already_dirty->label());\n+  __ move(dirty, card_addr);\n+  __ branch_destination(L_already_dirty->label());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c1\/shenandoahBarrierSetC1.cpp","additions":8,"deletions":12,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -516,16 +516,1 @@\n-  Node*   zero = __ ConI(0); \/\/ Dirty card value\n-\n-  if (UseCondCardMark) {\n-    \/\/ The classic GC reference write barrier is typically implemented\n-    \/\/ as a store into the global card mark table.  Unfortunately\n-    \/\/ unconditional stores can result in false sharing and excessive\n-    \/\/ coherence traffic as well as false transactional aborts.\n-    \/\/ UseCondCardMark enables MP \"polite\" conditional card mark\n-    \/\/ stores.  In theory we could relax the load from ctrl() to\n-    \/\/ no_ctrl, but that doesn't buy much latitude.\n-    Node* card_val = __ load( __ ctrl(), card_adr, TypeInt::BYTE, T_BYTE, adr_type);\n-    __ if_then(card_val, BoolTest::ne, zero);\n-  }\n-\n-  \/\/ Smash zero into card\n-  __ store(__ ctrl(), card_adr, zero, T_BYTE, adr_type, MemNode::unordered);\n+  Node* dirty = __ ConI(CardTable::dirty_card_val()); \/\/ Dirty card value\n@@ -533,3 +518,5 @@\n-  if (UseCondCardMark) {\n-    __ end_if();\n-  }\n+  \/\/ Check if card is dirty, and make it so, if not\n+  Node* card_val = __ load( __ ctrl(), card_adr, TypeInt::BYTE, T_BYTE, adr_type);\n+  __ if_then(card_val, BoolTest::ne, dirty);\n+  __ store(__ ctrl(), card_adr, dirty, T_BYTE, adr_type, MemNode::unordered);\n+  __ end_if();\n@@ -1021,1 +1008,1 @@\n-      if (UseCondCardMark && mem->is_Load()) {\n+      if (mem->is_Load()) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahBarrierSetC2.cpp","additions":7,"deletions":20,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -44,3 +44,0 @@\n-  \/\/ This helps most multi-core hardware hosts, enable by default\n-  SHENANDOAH_ERGO_ENABLE_FLAG(UseCondCardMark);\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/mode\/shenandoahGenerationalMode.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -192,1 +192,3 @@\n-    *byte = CardTable::dirty_card_val();\n+    if (*byte != CardTable::dirty_card_val()) {\n+      *byte = CardTable::dirty_card_val();\n+    }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.inline.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"}]}