{"files":[{"patch":"@@ -0,0 +1,9 @@\n+## GenShen: the Generational Shenandoah project\n+\n+Gen Shen stands for Generational Shenandoah,\n+and it also means \"deep roots\" in Mandarin.\n+\n+Documents in this directory:\n+- [glossary.md](glossary.md): glossary of terms used in our documents,\n+- [workplan.summary.md](workplan.summary.md): summary of the plan of record that we strive to follow,\n+- [design.summary.md](design.summary.md): summary of design points that we rely upon as working hypotheses.\n","filename":"genshen-docs\/README.md","additions":9,"deletions":0,"binary":false,"changes":9,"status":"added"},{"patch":"@@ -0,0 +1,329 @@\n+## Design Points\n+\n+This section discusses design decisions, as guided by the following tenets.\n+\n+### Tenets\n+\n+1. Don’t punish the mutator: While mutator code must be added to \n+   implement generational collection, degradations of\n+   mutator throughput and responsiveness \n+   should be contained as much as possible.\n+   If in doubt between design choices, \n+   pick the one that promises to minimize mutator overhead.\n+2. Safeguard incremental progress with milestones that demonstrate key capabilities.\n+3. Minimize the overall development effort.  This includes containing\n+   efforts to prepare and present each milestone deliverable \n+   that do not directly contribute to the end product.\n+\n+### Design Decisions\n+\n+While it is probable that we may revisit some of the following design\n+decisions if we run into implementation difficulties or performance\n+problems, the following is the current plan of record.\n+\n+1. This document is maintained alongside the source code. \n+   1. It is organized hierarchically with sections\n+      dedicated to major design decisions.\n+      Further, more detailed decisions are organized in top-down fashion,\n+      with overarching design decisions preceding derivative design decisions.\n+      The topic numbers assigned to particular design decisions may evolve over time.\n+   2. There is a separate \"rationale\" document that explains more of the reasoning behind design decisions\n+      and links relevant portions between documents.\n+2. Genshen changes to the Shenandoah implementation will be\n+   compartmented.  See discussion [here](rationale.summary.md#compartmentalization\").\n+3. We will support concurrent collection of old gen and young gen,\n+   with the expectation that a single old collection will typically\n+   overlap with the execution of many young collections.\n+4. In order to minimize performance impact on the mutator, we will use\n+   a single Load-Reference-Barrier to implement both evacuation\n+   from young gen and from old gen.\n+   1. Tenuring will be implemented as part of young evacuation.\n+   2. All evacuation for both young and old gen regions\n+      happens under the control of the same GC threads and is\n+      supported by the same Load Reference Barrier (LRB) as in\n+      vanilla Shenandoah, with only small refinements to the\n+      implementation of slow-path code within the LRB.\n+   3. See discussion [here](rationale.summary.md#load-reference-barrier).\n+5. An old collection begins at the same time as a young gen\n+   collection, with both collections leveraging the\n+   results of a single shared root scan.\n+6. Old collection generally runs at lower priority (e.g., fewer\n+   numbers of parallel threads or greater “nice” values for\n+   concurrent threads) than young collection because\n+   replenishing the allocation pool to support ongoing allocation\n+   needs of mutator threads requires urgent completion of young GC.\n+   See discussion [here](rationale.summary.md#prioritization).\n+7. Although the planned future production release of GenShen will\n+   run young collection concurrently with old collection, support\n+   will also be implemented and maintained for alternating executions\n+   of young collections with global collections.  See\n+   discussion [here](rationale.summary.md#young-global-discussion).\n+   1. Since this is not a production release, efficiency of\n+      implementation is not a primary concern.\n+   2. Regression tests will exercise the implementation of this mode\n+      of operation.\n+8. A regression test suite will be developed and maintained to\n+   support all of the enhanced capabilities of GenShen, including\n+   capabilities that are enabled and disabled at build time for the\n+   JVM.\n+9. Though old collections start at the same time as young\n+   collections collections, they do not necessarily end at the same\n+   time.  Typically, many young-gen collections will be completed\n+   concurrently during the time that a single old-gen collection is\n+   running.  See discussion [here](rationale.summary.md#concurrency-of-young-and-old).\n+10. Root scanning will be performed during a JVM safe point.\n+11. Scanning of the remembered set will be performed by parallel\n+    young-gen GC threads during a JVM safe point.  A side\n+    effect of scanning is to mark as CLEAN any cards of the remembered\n+    set that are found by remembered set scanning to no longer be\n+    DIRTY. \n+12. The remembered set maintains a start-of-object representation to\n+    facilitate quick identification of where the first object\n+    pertaining to each DIRTY card region begins.  See discussion\n+    [here](rationale.summary.md#remembered-set-starting-offsets).\n+    This requires that:\n+    1. Newly promoted objects be registered with the remembered set\n+       and start-of-object support by post-processing the associated GCLAB block, and\n+    2. When entire regions are promoted out of young collections into\n+       old gen, the objects contained within those regions must be\n+       registered with the remembered set and the start-of-object support.\n+13. Young marking, including scanning of root pointers,\n+    will place discovered references to old gen into a thread-local SATB\n+    buffer so that they can be processed by an old-gen collection\n+    thread.  See discussion [here](rationale.summary.md#satb-keep-old-alive-entries). \n+    1. Possible optimization: refrain from logging old-gen pointers\n+       that refer to already marked old objects into the SATB buffer.\n+14. The default size of the SATB buffer will increase from 1024 to\n+    4096 words because we will be placing more information into the\n+    SATB buffer.\n+15. Whenever the SATB buffer is full, the slow path for adding to\n+    the SATB buffer will attempt to compress the buffer contents before\n+    communicating the buffer to GC threads.  If compression leaves a\n+    minimum of 256 slots available within the SATB buffer, the thread\n+    continues to add values to the existing buffer.  Compression\n+    consists of:\n+    1. For pointers to young gen:\n+       1. If concurrent marking of young gen is disabled, ignore the\n+          pointer.\n+       2. Otherwise, if the object referenced by this pointer has\n+          already been marked, ignore the pointer.\n+       3. If we choose to use SATB-based remembered set, ignore all\n+          overwritten address values that reside within young gen.\n+    2. For pointers to old gen:\n+       1. If concurrent marking of old gen is disabled, ignore the\n+          pointer.\n+       2. Otherwise, if the object referenced by this pointer\n+          has already been marked, ignore the pointer.\n+       3. If we choose to use an SATB-based remembered set:\n+          - If the card corresponding to an overwritten old gen\n+            address is already DIRTY, ignore this overwritten\n+            address.\n+          - Otherwise, fetch the pointer value held at the overwritten\n+            address.  If the fetched pointer value does not\n+            refer to young gen, ignore this overwritten address.\n+          - Otherwise, use a hash table (suggested size 127) to sift\n+            redundant DIRTY card references for the current batch of\n+            overwritten old-gen addresses.  Preserve only one address\n+            for each card entry that needs to be marked as DIRTY.\n+    3. SATB buffers will be processed by both a young GC\n+       thread and an old GC thread.\n+       1. The young GC thread will mark objects referenced\n+          by young pointers.\n+       2. The old GC thread will:\n+          1. Mark objects referenced by old-gen pointers, and\n+          2. If we choose to use SATB-based remembered set: mark as DIRTY\n+             the card entries corresponding to overwritten addresses.\n+16. GC uses a G1-style heuristic to choose collection sets for both\n+    young and old memory areas.  The collection set represents the\n+    heap regions that offer the greatest opportunity to quickly reclaim\n+    garbage, as with the existing Shenandoah implementation.  See\n+    discussion [here](rationale.summary.md#g1-heuristic).\n+17. Following an evacuation phase that evacuates\n+    both old and young heap regions, the update-references phase is\n+    required to update references throughout all \n+    old regions that were not selected as part of the old\n+    collection set in addition to updating references in young\n+    heap regions.\n+    1. If a particular young collection evacuation phase does not\n+       evacuate any old regions, then its update references phase can\n+       focus solely on young heap regions and the\n+       remembered set.\n+18. Tenuring is based on object age with the enhancements described\n+    below.  See discussion [here](rationale.summary.md#tenuring).\n+    1. The variable TenureCycle counts how many GC cycles correspond to\n+       each increment of an object’s age.  Object ages are not\n+       necessarily incremented each time a GC cycle is completed.  They\n+       are incremented each time TenureCycle GC cycles have been\n+       completed.\n+    2. The variable TenureAge represents the age at which an object\n+       becomes eligible for tenuring.\n+    3. During GC cycles that correspond to TenureCycle, the “age” of\n+       individual objects is incremented by 1 plus the size of the\n+       object’s original heap region age when the object is evacuated.\n+    4. During GC cycles that correspond to TenureCycle, the “age” of\n+       each heap region that has been fully allocated (i.e. no more\n+       available memory for allocation) and that is not in the\n+       collection set is incremented by 1 at the end of the evacuation\n+       phase.  If the resulting “age” equals TenureAge, then the entire\n+       region is reassigned to become part of old gen.\n+       1. The update-refs phase will process this heap region even\n+          though it is “now” considered to be part of old gen.\n+       2. Each of the objects contained within the promoted region\n+          shall be registered with the remembered set abstraction.\n+       3. Each of the objects contained within the promoted region\n+         be scanned to determine any references to young-gen\n+         memory that are contained therein.  For any such pointers, set\n+         the associated card table entry to DIRTY.\n+19. During evacuation, each running mutator thread has both a TLAB\n+    and a GCLAB.\n+    1. The TLAB is associated with a young heap region.\n+    2. The GCLAB is associated with an old heap region.\n+    3. When the mutator’s load reference barrier encounters a\n+       reference for which the associated object needs to be tenured, it\n+       allocates the copy memory from the GCLAB.\n+    4. When the mutator’s load reference barrier encounters a\n+       reference for which the associated object resides within the\n+       collection set of old gen, it allocates the copy memory from the\n+       GCLAB.\n+    5. When the mutator’s load reference barrier encounters a\n+       reference for which the associated object needs to be evacuated to\n+       young gen, it allocates the copy memory from the TLAB.\n+    6. We initially plan to use the same size for TLAB and GCLAB, but\n+       this decision may be revisited.\n+    7. If the size of the object to be evacuated is larger than half\n+       the size of the respective local allocation buffer, allocation\n+       of the replica memory is handled by alternative allocators, to be\n+       designed.  Call these \"odd\" objects.\n+20. During evacuation, each evacuating GC thread will maintain two\n+    GCLAB buffers:\n+    1. GCLAB-Young is associated with young gen.\n+    2. GCLAB-Old is associated with old gen.\n+    3. If the object to be evacuated currently resides in old gen or\n+      if it resides in young gen and it is to be tenured, allocate the\n+      copy memory from GCLAB-Old.\n+    4. Otherwise, allocate the copy memory from GCLAB-Young.\n+    5. At the end of the evacuation phase, consider repurposing any\n+       unspent GCLAB-Young as a TLAB if there is sufficient unallocated\n+       memory remaining within it.\n+    6. At the end of the evacuation phase, consider preserving the\n+       GCLAB-Old for use as a GCLAB for a mutator thread during the next\n+       young collections collection or as a GCLAB-Old during the next\n+       old-gen evacuation pass.\n+    7. See 19.7.\n+21. A certain budget of CPU time is provisioned to perform young-gen\n+    GC in order to support a particular planned workload.\n+    1. The resources dedicated to young-gen GC are limited in order\n+       to assure a certain amount of CPU time is available to mutator\n+       threads.\n+    2. Command line options allow user control over provisioning.  A\n+       TBD API may allow services to adjust provisioning dynamically.\n+    3. In the ideal, provisioning is adjusted automatically based on\n+       TBD heuristics.\n+    4. The provisioned CPU resources can support a range of service\n+       quality, reclaiming large numbers of heap regions with a low GC\n+       frequency or reclaiming small numbers of heap regions with a\n+       high GC frequency.  Given a particular frequency of GC cycles,\n+       the same CPU resources can evacuate a large number of sparsely\n+       populated heap regions or a small number of densely populated\n+       heap regions.  Tradeoffs between these configuration extremes\n+       may be adjusted under software control or by TBD\n+       heuristics.\n+    5. For each young-gen GC pass, a certain TBD percentage\n+       of CPU resources are reserved for old-gen evacuation and\n+       update-refs activities.\n+       1. The old-gen CPU resource budget represents the total amount\n+          of old-gen memory that can be relocated, and is quantified as\n+          a multiple N of the heap region size.\n+       2. The old-gen GC threads determine the composition of the\n+          old-gen collection set, up to but never exceeding the upper\n+          bound N on cumulative evacuation size.\n+       3. The old-gen GC thread may select for the collection set\n+          N heap regions which are known to have 100%\n+          utilization, 2N heap regions known to have 50% utilization,\n+          5N heap regions known to have 20% utilization, and so on.\n+       4. If the old-gen GC refrains from delegating N heap regions\n+          worth of evacuation work to the young-gen evacuation phase,\n+          then the young GC is free to use the excess CPU resources to\n+          more aggressively evacuate more of its own young heap regions,\n+          using a larger than normal young-gen collection set.\n+       5. The budget for updating old-gen references must be large\n+          enough to handle the total old-gen memory size - N.  In the\n+          case that old-gen GC configures a collection set that\n+          represents its full evacuation capacity of N heap regions, the\n+          number of old-gen heap regions that are not part of the\n+          old-gen collection set is never larger than this quantity.\n+          In the case that old-gen GC configures a smaller collection\n+          set, then for each fraction of a heap region that is not\n+          evacuated, this much more of a heap region might have to be\n+          processed during the update-refs phase of GC.  We estimate\n+          that the cost of evacuating M bytes of memory is similar to\n+          the cost of updating the references within M bytes of\n+          memory.\n+22. A smaller (generally) budget of CPU time is provisioned to\n+    perform old-gen GC in order to support a particular planned\n+    workload.\n+    1. The resources dedicated to young-gen GC are limited in order\n+       to assure a certain amount of CPU time is available to mutator\n+       threads.\n+    2. Command-line options allow user control over provisioning.  A\n+       TBD API may allow services to adjust provisioning dynamically.\n+    3. In the ideal, provisioning is adjusted automatically based on\n+       TBD heuristics.\n+    4. As with young-gen GC, the CPU resources provisioned for\n+       old-gen GC can support a range of service quality.\n+    5. The CPU resources dedicated to old-gen collection do not have\n+       responsibility for evacuating old regions as all evacuation\n+       is performed by young-gen GC threads.  Instead, the CPU\n+       resources dedicated to old-gen GC activities are used for\n+       activities such as the following:\n+       1. Processing the content of SATB buffers:\n+          - If old collection is in concurrent marking phase, mark\n+            objects referenced by any keep-alive pointers.\n+          - If we are using SATB-based remembered set, update the\n+            remembered set based on overwritten addresses reported in the\n+            SATB buffer.\n+       2. During concurrent marking, scan the contents of previously\n+          marked objects to complete the transitive closure of\n+          reachability.\n+       3. Perform heuristic computations:\n+          - Determine when to start the next old-gen GC cycle.\n+          - Determine which old regions to evacuate on this and future\n+            passes of young-gen GC.\n+          - Adjust young-gen efficiency parameters such as: How many\n+            heap regions should be dedicated to young gen?  What is\n+            optimal value of TenureCycle?  What is optimal value of\n+            TenureAge?  How much CPU time should be dedicated to\n+            young-gen GC?\n+          - Adjust old-gen efficiency parameters such as: How much CPU\n+            time should be dedicated to old-gen GC?  How many heap regions\n+            should be dedicated to old gen?  Should any heap regions be\n+            decommissioned and returned to the operating system in order\n+            to shrink the memory footprint of this service?\n+       4. Perform routine maintenance as time and schedule permits:\n+          - Potentially sweep up dead memory, accumulating ages at\n+            which dead objects were reclaimed within old regions.\n+          - Potentially, sweep through evacuated memory to accumulate\n+            ages at which dead objects were reclaimed.\n+          - Organize free lists for fast and efficient allocation of\n+            GCLAB and Odd object allocations.\n+          - Return emptied old regions to the free set.\n+          - Eventually, reference processing and string deduplication\n+            should be performed by lower priority old-gen threads\n+            rather than higher priority young-gen threads.\n+       5. Following completion of each old-gen concurrent mark pass,\n+          select regions to be included in the old-gen collection set:\n+          - No more than a total of N bytes of old gen is evacuated by\n+            each pass of the young-gen evacuator.\n+          - If old-gen GC threads desire to evacuate M, which is more\n+            than N bytes of old gen, it does so by piggy backing on\n+            multiple subsequent young-gen evacuation passes, selecting\n+            evacuating no more than the accumulation of N total heap\n+            regions in each of the following young-gen evacuation passes.\n+          - Since it is most efficient to evacuate all M > N regions\n+            of old-gen memory with a single young-gen evacuation pass,\n+            configure the old-gen collection set to include all M\n+            regions if there are sufficient free regions available to\n+            afford the young-gen allocator to continue allocating new\n+            objects during the longer delay that would be required to\n+            evacuate more than the traditionally budgeted N regions of\n+            old-gen memory.\n","filename":"genshen-docs\/design.summary.md","additions":329,"deletions":0,"binary":false,"changes":329,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+## Glossary for the Generational Shenandoah (GenShen) Project\n+\n+Shen := Shenandoah := the Shenandoah garbage collector\n+\n+GenShen := Generational Shenandoah\n+\n+gen := generation\n+young gen := the young generation\n+old gen := the old generation\n+\n+collector := garbage collector\n+young collector := young gen collector\n+old collector := old gen collector\n+global collector := single-generation collector that works on the entire heap\n+\n+young\/old\/global collection := a complete cycle through the phases of the young\/old\/global collector\n+\n+cset := collection set\n+remset := remembered set\n+rset := remembered set\n+\n+parallel := same task, dealt with by multiple threads\n+concurrent := different tasks, operated upon simultaneously\n+conc := concurrent\n+\n+conc mark := concurrent marking\n+conc global GC := concurrent global GC, like vanilla Shen\n+evac := evacuation (phase)\n+UR := update references (phase)\n+\n+LRB := Load Reference Barrier\n+SATB := Snapshot At The Beginning\n+TLAB := Thread-Local Allocation Buffer for a mutator thread\n+GCLAB := like a TLAB, but for a GC thread\n+\n+young region := a heap region affiliated with young gen\n+old region := a heap region affiliated with old gen\n+free region := a region that is not affiliated with either generation and available for future reuse by allocators \n+\n+young object := an object in young gen\n+old object := an object in old gen\n+\n+block := an identifiable chunk of space in a region that is or was occupied by a Java object\n+block start := a pointer to the beginning of a block\n","filename":"genshen-docs\/glossary.md","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,395 @@\n+# Summary Plan of Record: GenShen Prototype (2020)\n+\n+## Planned Milestones\n+\n+### Overview of Initial Milestones\n+\n+1. Pure young collection. (Young gen size unlimited. Old gen untouched.)\n+2. Size-restricted young gen.\n+3. Tenuring and promotion.\n+4. Global collection after young collection.\n+5. Young collection after global collection, repeat alternations.\n+6. Concurrent old marking.\n+7. Concurrent old and young collections.\n+\n+Young collection reclaims garbage only from heap regions that are\n+identified as belonging to the young generation.\n+\n+Old collection reclaims garbage only from heap regions that are\n+identified as belonging to the old generation, which holds objects\n+that have been promoted from young generation.\n+\n+Global collection reclaims garbage from heap regions belonging to\n+either the young generation or the old generation.\n+\n+### Milestone 1: GC of Young Gen Only\n+\n+This demonstration proves successful implementation of:\n+\n+1. Separating out that certain heap regions comprise young gen and\n+   other heap regions are considered to represent old gen. \n+2. Confirming that card marking does not crash.  (Does not prove that\n+   card marking works because we have no objects in old gen.) \n+3. Confirming that remembered set scanning does not crash.  (Does not\n+   prove that remembered set scanning works because we have no objects in\n+   old gen.) \n+4. Demonstrating a simplified form of young collection.\n+\n+Tasks\n+\n+1. Integrate various completed code patches into a common branch\n+2. Test and debug existing code\n+\n+### Milestone 2: Restrict Size of Young Gen\n+\n+This milestone constrains the young generation to a certain number of\n+regions.  After that number is reached, allocation fails.  For now, the\n+number can be fixed, say 25% of all regions, and we can simply crash\n+thereafter. \n+\n+Tasks\n+\n+1. Establish a mechanism to specify and enforce a limit on the number\n+   of heap regions that may comprise young-gen memory.\n+2. Adjust the GC triggering mechanism so that the size of young gen\n+   does not have reason to exceed the young-gen size during young-gen\n+   GC, where the size of young-gen is affected by GC in the\n+   following ways:\n+   1. Certain free heap regions may be added to young gen in order to\n+      support allocation requests that are made by concurrent mutator\n+      threads while GC is being performed.\n+   2. At the end of GC, all heap regions that were part of the\n+      collection set are removed from young-gen memory and placed\n+      in the free pool.\n+\n+\n+### Milestone 3: Young Collection with Promotion of Tenured Objects\n+\n+Add to Milestone 2 the capability of promoting young gen objects.\n+Don’t worry about odd objects or humongous objects at this time.\n+Demonstrate: \n+\n+1. That we can promote objects into old gen.\n+2. That card-marking works.\n+3. That remembered set scanning works (correctly, but perhaps not with\n+   full desired efficiency). \n+\n+The following tasks must be implemented:\n+\n+1. The collection set is selected as a subset of all young collections\n+   heap regions using TBD heuristics. \n+2. During young collection, each time an object is evacuated to a\n+   young consolidation region, the object’s age is incremented. \n+    1. For simplicity, don’t try to implement the complete region\n+       aging or promotion at this time. \n+    2. Also for simplicity, don’t try to implement the TenureCycle\n+       optimization. \n+3. During young collection, each GC thread maintains both a young\n+   GCLAB and and old GCLAB.\n+    1. When evacuating an object whose incremented age is less than\n+       TenureAge, allocate memory for the object’s copy from within the\n+       young GCLAB. \n+    2. When evacuating an object whose incremented age is >=\n+       TenureAge, allocate memory for the object’s copy from within the\n+       old GCLAB. \n+    3. Don’t support Odd or Humongous objects for simplicity.\n+4. During young collection, each mutator thread maintains both a TLAB\n+   and a GCLAB.  The GCLAB is associated with old gen. \n+    1. When evacuating an object whose incremented age is less than\n+       TenureAge, allocate memory for the object’s copy from within the\n+       TLAB. \n+    2. When evacuating an object whose incremented age is >=\n+       TenureAge, allocate memory for the object’s copy from within the\n+       GCLAB. \n+5. Perform maintenance on the contents of each retired old GCLAB,\n+   where this maintenance consists of: \n+    1. Registering each object’s starting location and length with the\n+       remembered set abstraction so that remembered set scanning can\n+       quickly find the first object within each DIRTY card region, \n+    2. Updating the card table to reflect all references from this\n+       object into young gen,  \n+    3. Evacuating all objects directly referenced from this object\n+       which reside within a collection set and have not yet been\n+       evacuated, and \n+    4. Healing all pointers from within newly evacuated old objects\n+       that refer to objects residing within the collection set. \n+    5. The last two items listed above are already performed by\n+       traditional Shenandoah but can be merged with the implementation of\n+       the other maintenance activities in order to perform all this work\n+       in a consolidated pass. \n+\n+### Milestone 4: Sequential Execution of Multiple Young Collections Followed by Multiple Global Collections\n+\n+__Demonstrated Concurrency Between Young-Gen and Old-Gen Activities__\n+\n+   ✓ denotes that this combination of activities is allowed.\n+\n+   ✗ denotes that this combination of activities is disallowed.\n+\n+|                |  Old-Gen Mark  | Old-Gen Evac  | Old-Gen Idle |\n+|:--------------:|:--------------:|:-------------:|:------------:|\n+| Young Gen Mark |      ✓         |     ✗         |     ✓        |\n+| Young Gen Evac |      ✗         |     ✓         |     ✓        |\n+| Young Gen Idle |      ✗         |     ✗         |     ✓        |\n+\n+Add to Milestone 3 the ability to switch to global collection after a\n+series of young Collections.\n+\n+1. The switch is triggered by a simple TBD test, such as when the\n+   space available within old gen is less than the size of young gen. \n+2. The global collection continues to run with the card-marking\n+   barrier enabled though the card values will not be consulted further.\n+3. For this demonstration, the switch to global collections is\n+   one-way.  Following this switch, we can no longer perform young\n+   collections. \n+4. For this demonstration, the global collection does not distinguish\n+   between young regions and old regions. \n+    1. Evacuation of objects that resided in an old region is handled\n+    the same as evacuation of objects that resided in a young heap\n+    region. \n+5. This demonstrates that:\n+    1. Promotion of objects works.  The objects that have been promoted\n+    into old gen maintain whatever protocols and invariants are\n+    assumed by Shenandoah GC. \n+    2. That we can manage the transition from young GC to global GC.\n+    3. That global collection, insofar as we characterize it, works.\n+    4. That Young collections do not corrupt the heap.\n+\n+Tasks:\n+\n+1. Fix bugs in existing code enhancements.\n+2. Implement the transition from young collection to global collection\n+3. Implement global collection with write barrier for card-table marking\n+\n+### Milestone 5: Interleaved Execution of Young and Global Collections\n+\n+__Demonstrated Concurrency Between Young-Gen and Old-Gen Activities__\n+\n+   ✓ denotes that this combination of activities is allowed.\n+\n+   ✗ denotes that this combination of activities is disallowed.\n+\n+|                |  Old-Gen Mark  | Old-Gen Evac  | Old-Gen Idle |\n+|:--------------:|:--------------:|:-------------:|:------------:|\n+| Young Gen Mark |      ✓         |     ✗         |     ✓        |\n+| Young Gen Evac |      ✗         |     ✓         |     ✓        |\n+| Young Gen Idle |      ✗         |     ✗         |     ✓        |\n+\n+Add to Milestone 4 the ability to switch back to Young Collection upon\n+completion of a global collection. \n+\n+1. Assume that the global collection is successful in reclaiming\n+   necessary memory.  No heuristics to resize oldgen or young gen at\n+   this time. Specify sizes of each on command line. \n+2. The switch to old collection is triggered by exhaustion of old gen.\n+   At least one young collection is assumed to execute following\n+   completion of each global collection. \n+3. For this demonstration, the global collection does distinguish\n+   between young collections and old regions. \n+    1. Objects in the old collection set are evacuated to old\n+       consolidation regions. \n+    2. Objects in the young collection set are evacuated\n+       to young collections consolidation regions. \n+    3. There is no tenuring of objects during a global collection (for\n+       simplicity). \n+\n+This demonstrates that:\n+\n+1. Promotion of objects works.  The objects that have been promoted\n+   into old gen maintain whatever protocols and invariants are\n+   assumed by Shenandoah GC. \n+2. That we can manage the transition from young GC to global GC.\n+3. That we can manage the transition from global GC to young GC.\n+4. That the transition from global GC to young GC\n+   establishes all invariants required for correct operation of young\n+   GC. \n+\n+Tasks:\n+\n+1. Distinguish between “global collection” for purposes of\n+   maintaining support for non-generational GC and “global collection”\n+   for purposes of supporting sequential interleaving of young GC\n+   and global GC.\n+2. Implement the transition from global GC to young GC.\n+3. Initialize the remembered set for each consolidation heap region\n+   of old gen to all CLEAN before allocating any GCLAB buffers within\n+   the consolidation heap region.\n+4. At the start of global evacuation, select the collection set as\n+   some combination of existing young regions and\n+   old regions based on heuristics TBD.\n+5. During global collection, maintain old-gen GCLABs for all GC\n+   threads and mutator threads.\n+6. During global collection, distinguish evacuation behavior\n+   depending on whether an object to be evacuated resides within the\n+   young collection set or the old collection set since\n+   young objects are evacuated into young \n+   consolidation regions and old objects are evacuated into old\n+   consolidation regions;\n+7. Add minimal logging reports to describe behavior of young-gen and global\n+   GC.\n+8. During global collection, perform maintenance on the contents of\n+   each retired old GCLAB, where this maintenance consists of:\n+   1. Registering each object’s starting location and length with the\n+      remembered set abstraction so that remembered set scanning can\n+      quickly find the first object within each DIRTY card region,\n+   2. Updating the card table to reflect all references from this\n+      object into young gen,\n+   3. Evacuating all objects directly referenced from this object\n+      that reside within a collection set and that have not already been\n+      evacuated, and\n+   4. Healing all pointers from within new replica objects residing in old\n+      gen that refer to objects residing within the collection set.\n+   5. The last two items listed above are already performed by\n+      traditional Shenandoah but can be merged with the implementation of\n+      the other maintenance activities in order to perform all this work\n+      in a consolidated pass.\n+\n+### Milestone 6: GC of young collections with Concurrent Marking (but not Collecting) of Old Gen\n+\n+__Demonstrated Concurrency Between Young-Gen and Old-Gen Activities__\n+\n+   ✓ denotes that this combination of activities is allowed.\n+\n+   ✗ denotes that this combination of activities is disallowed.\n+\n+|                |  Old-Gen Mark  | Old-Gen Evac  | Old-Gen Idle |\n+|:--------------:|:--------------:|:-------------:|:------------:|\n+| Young Gen Mark |      ✓         |     NA         |     ✓        |\n+| Young Gen Evac |      ✓         |     NA         |     ✓        |\n+| Young Gen Idle |      ✓         |     NA         |     ✓        |\n+\n+This demonstration relies on GC log reports to show that marking of\n+old gen runs concurrently with marking of young gen.\n+Since the results of old-gen marking are not used to support old-gen\n+evacuation, this demonstration does not prove that old-gen marking\n+produces correct results.\n+\n+All pointers to old-gen memory that are discovered during scan of\n+young-gen memory are communicated to the old-gen concurrent mark\n+threads by inserting these pointer values into a SATB buffer as\n+keep-alive values.  Every SATB buffer is post-processed both by a\n+young-gen GC thread and by an old-gen GC thread.\n+\n+Pointers from old-gen memory to young-gen memory that are discovered\n+during the marking of old-gen are ignored.\n+\n+At the start of young-gen concurrent marking, the remembered set is\n+scanned to detect all inter-generational references.\n+\n+The SATB write barrier remains enabled as long as either young-gen or\n+old-gen concurrent marking is active.\n+\n+Tasks:\n+\n+1. Each young GC thread has a dedicated SATB buffer into which it places\n+   discovered references to old-gen memory.\n+2. SATB write barrier is left enabled as long as either young\n+   or old marking is active.\n+3. SATB buffer is enlarged to 4096 entries.\n+4. SATB buffer compression is enhanced to deal with the mix of old\n+   and young pointers.\n+5. SATB buffer processing is performed by both a young collection\n+   thread and an old collection thread.  Pointers to\n+   old gen within the SATB buffer are marked and added to the old-gen\n+   closure queues so that they can be subsequently scanned.\n+6. Certain GC threads (or work items) are dedicated to old GC\n+   and others are dedicated to young GC.\n+7. Old-gen GC threads process the closure of previously marked\n+   old-gen objects, scanning all references contained therein.\n+8. Old-gen GC threads add to the old-gen closures all old-gen objects\n+   referenced by SATB buffers if those objects were not previously marked.\n+\n+### Milestone 7: Concurrent Young and Old Collections\n+\n+\n+__Demonstrated Concurrency Between Young-Gen and Old-Gen Activities__\n+\n+   ✓ denotes that this combination of activities is allowed.\n+\n+   ✗ denotes that this combination of activities is disallowed.\n+\n+|                |  Old-Gen Mark  | Old-Gen Evac  | Old-Gen Idle |\n+|:--------------:|:--------------:|:-------------:|:------------:|\n+| Young Gen Mark |      ✓         |     ✗         |     ✓        |\n+| Young Gen Evac |      ✓         |     ✓         |     ✓        |\n+| Young Gen Idle |      ✓         |     ✗         |     ✓        |\n+\n+In this demonstration, old-gen concurrent marking runs concurrently with all\n+phases of young-gen GC.  Old-gen evacuation only runs while young-gen\n+evacuation is running.  In the case that old-gen needs to evacuate so\n+much memory that doing so in a single uninterruptible batch would\n+significantly extend the duration of the young-gen evacuation phase,\n+the total old-gen evacuation workload is divided into multiple smaller\n+batches of evacuation work, each batch being processed concurrently\n+with a different young-gen evacuation cycle. \n+\n+The demonstration:\n+\n+1. Uses logging reports to describe the results of young\n+   collection and old collection.\n+2. Shows for some “simple” workload (Heapothysis or\n+   Extremem?) that generational GC provides performance benefits over\n+   non-generational GC.\n+\n+Tasks\n+\n+1. Add minimal logging reports to describe behavior of old-gen\n+   GC.\n+2. Decide which old regions comprise the old collection set.\n+3. Divide the old collection set into multiple collection subsets.\n+4. For each of the collection subsets\n+   1. Communicate the subset to young GC tasks to process these\n+      evacuations when it begins its next evacuation cycle.\n+   2. Wait for young GC tasks to signal completion of the evacuation\n+      cycle.\n+\n+## Proposed Future Milestones Not Yet Fully Planned\n+\n+### Milestone 8: Performance Improvements\n+\n+1. Remembered Set scanning sets cards to CLEAN if they are no longer\n+   DIRTY.\n+2. Remembered Set scanning maintains and utilizes start-offset data\n+   structure to quickly find the first object to be scanned within each\n+   DIRTY card.\n+3. Remembered set scanning refrains from scanning the portions of\n+   large objects and arrays that overlap card regions that are not\n+   DIRTY.\n+\n+### Milestone 9: Fix Known Bugs\n+\n+We are aware of bugs in our existing card-marking implementation.\n+\n+### Milestone 10: Multiple Young-Gen Evacuations Process Old Collection Set\n+\n+### Milestone 11: Odd Objects (larger than 50% of TLAB\/GCLAB size)\n+\n+By default, the promotion of such objects is handled by a\n+slower-than-normal path.  Instead of allocating old gen from the\n+GCLAB, the mutator thread obtains memory for the copy by directly\n+accessing free lists. See existing code that does that already. \n+\n+### Micro Milestone 12: Collect and Report New Metrics\n+\n+### Micro Milestone 13: SATB-Based Remembered Set\n+\n+### Micro Milestone 14: Heuristic Pacing of Young Collection Frequency\n+\n+### Micro Milestone 15: Heuristic Pacing of Old Collection Frequency\n+\n+### Micro Milestone 16: Heuristic Sizing of Young and Old Sizes\n+\n+### Micro Milestone 17: Heuristic Adjustments of Tenuring Strategies\n+\n+### Micro Milestone 18: Overlap Evacuation of Cycle N with Marking of Cycle N+1\n+\n+### Micro Milestone 19: Humongous Objects\n+\n+### Micro Milestone 20: Reference Processing\n+\n+### Micro Milestone 21: String Dedup\n+\n+### Micro Milestone 22: Degenerated GC\n+\n+### Micro Milesones TBD: Various Performance Improvements\n+\n","filename":"genshen-docs\/workplan.summary.md","additions":395,"deletions":0,"binary":false,"changes":395,"status":"added"},{"patch":"@@ -45,1 +45,8 @@\n-  if (UseZGC || UseShenandoahGC) {\n+  if (UseShenandoahGC) {\n+    if (strcmp(ShenandoahGCMode, \"generational\") == 0) {\n+      return Shenandoah;\n+    }\n+    return NA;\n+  }\n+\n+  if (UseZGC) {\n","filename":"src\/hotspot\/share\/gc\/shared\/gcConfiguration.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -213,0 +213,2 @@\n+  BarrierSet::set_barrier_set(new ShenandoahBarrierSet(this, _heap_region));\n+\n@@ -222,1 +224,0 @@\n-  BarrierSet::set_barrier_set(new ShenandoahBarrierSet(this, _heap_region));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -221,0 +221,9 @@\n+tier1_gc_shenandoah_generational = \\\n+  gc\/shenandoah\/generational\/\n+\n+# No tier 2 tests for shenandoah_generational at this time\n+tier2_gc_shenandoah_generational =\n+\n+# No tier 3 tests for shenandoah_generational at this time\n+tier3_gc_shenandoah_generational =\n+\n@@ -254,0 +263,1 @@\n+# include shenandoah generational tests in tier3 shenandoah\n@@ -261,0 +271,1 @@\n+  :hotspot_gc_shenandoah_generational \\\n@@ -268,0 +279,5 @@\n+hotspot_gc_shenandoah_generational = \\\n+  :tier1_gc_shenandoah_generational \\\n+  :tier2_gc_shenandoah_generational \\\n+  :tier3_gc_shenandoah_generational\n+\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2021, Amazon, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package gc.shenandoah.generational;\n+\n+import sun.hotspot.WhiteBox;\n+\n+\/*\n+ * @test TestCLIModeGenerational\n+ * @requires vm.gc.Shenandoah\n+ * @summary Test argument processing for -XX:+ShenandoahGCMode=generational.\n+ * @library \/testlibrary \/test\/lib \/\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *      -XX:+IgnoreUnrecognizedVMOptions \n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+ *      gc.shenandoah.generational.TestCLIModeGenerational\n+ *\/\n+\n+public class TestCLIModeGenerational {\n+\n+  private static WhiteBox wb = WhiteBox.getWhiteBox();\n+\n+  public static void main(String args[]) throws Exception {\n+    Boolean using_shenandoah = wb.getBooleanVMFlag(\"UseShenandoahGC\");\n+    String gc_mode = wb.getStringVMFlag(\"ShenandoahGCMode\");\n+    if (!using_shenandoah || !gc_mode.equals(\"generational\"))\n+      throw new IllegalStateException(\"Command-line options not honored!\");\n+  }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/generational\/TestCLIModeGenerational.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ * Copyright (c) 2021, Amazon, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package gc.shenandoah.generational;\n+\n+import sun.hotspot.WhiteBox;\n+import java.util.Random;\n+\n+\/*\n+ * @test TestSimpleGenerational\n+ * @requires vm.gc.Shenandoah\n+ * @summary Confirm that card marking and remembered set scanning do not crash.\n+ * @library \/testlibrary \/test\/lib \/\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *      -XX:+IgnoreUnrecognizedVMOptions \n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+ *      gc.shenandoah.generational.TestSimpleGenerational\n+ *\/\n+\n+\/* This used to be part of the run command, but caused problems.\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *\/\n+\n+public class TestSimpleGenerational {\n+  private static WhiteBox wb = WhiteBox.getWhiteBox();\n+  static private final int SeedForRandom = 46;\n+  \/\/ Sequence of random numbers should end with same value\n+  private static int ExpectedLastRandom = 272454100;\n+\n+\n+  public static class Node {\n+    static private final int NeighborCount = 5;\n+    static private final int IntArraySize = 8;\n+    static private Random random = new Random(SeedForRandom);\n+\n+    private int val;\n+    private Object field_o;\n+\n+    \/\/ Each Node instance holds references to two \"private\" arrays.\n+    \/\/ One array holds raw seething bits (primitive integers) and the\n+    \/\/ holds references.\n+    \n+    private int[] field_ints;\n+    private Node [] neighbors;\n+\n+    public Node(int val) {\n+      this.val = val;\n+      this.field_o = new Object();\n+      this.field_ints = new int[IntArraySize];\n+      this.field_ints[0] = 0xca;\n+      this.field_ints[1] = 0xfe;\n+      this.field_ints[2] = 0xba;\n+      this.field_ints[3] = 0xbe;\n+      this.field_ints[4] = 0xba;\n+      this.field_ints[5] = 0xad;\n+      this.field_ints[6] = 0xba;\n+      this.field_ints[7] = 0xbe;\n+\n+      this.neighbors = new Node[NeighborCount];\n+    }\n+\n+    public int value() {\n+      return val;\n+    }\n+\n+    \/\/ Copy each neighbor of n into a new node's neighbor array.\n+    \/\/ Then overwrite arbitrarily selected neighbor with newly allocated\n+    \/\/ leaf node.\n+    public static Node upheaval(Node n) {\n+      int first_val = random.nextInt();\n+      if (first_val < 0) first_val = -first_val;\n+      if (first_val < 0) first_val = 0;\n+      Node result = new Node(first_val);\n+      if (n != null) {\n+        for (int i = 0; i < NeighborCount; i++)\n+          result.neighbors[i] = n.neighbors[i];\n+      }\n+      int second_val = random.nextInt();\n+      if (second_val < 0) second_val = -second_val;\n+      if (second_val < 0) second_val = 0;\n+    \n+      int overwrite_index = first_val % NeighborCount;\n+      result.neighbors[overwrite_index] = new Node(second_val);\n+      return result;\n+    }\n+  }\n+\n+  public static void main(String args[]) throws Exception {\n+    Node n = null;\n+\n+    if (!wb.getBooleanVMFlag(\"UseShenandoahGC\") || \n+        !wb.getStringVMFlag(\"ShenandoahGCMode\").equals(\"generational\"))\n+      throw new IllegalStateException(\"Command-line options not honored!\");\n+\n+    for (int count = 10000; count > 0; count--) {\n+      n = Node.upheaval(n);\n+    }\n+\n+    if (n.value() != ExpectedLastRandom)\n+      throw new IllegalStateException(\"Random number sequence ended badly!\");\n+\n+  }\n+\n+}\n+\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/generational\/TestSimpleGenerational.java","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"}]}