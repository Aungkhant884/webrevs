{"files":[{"patch":"@@ -312,8 +312,0 @@\n-  if (ShenandoahHeap::heap()->mode()->is_generational()\n-    && (_generation->generation_mode() == YOUNG || (_generation->generation_mode() == GLOBAL && ShenandoahVerify))) {\n-    \/\/ The current implementation of swap_remembered_set() copies the write-card-table\n-    \/\/ to the read-card-table. The remembered sets are also swapped for GLOBAL collections\n-    \/\/ so that the verifier works with the correct copy of the card table when verifying.\n-    _generation->swap_remembered_set();\n-  }\n-\n@@ -610,0 +602,19 @@\n+\n+  if (heap->mode()->is_generational()) {\n+      if (_generation->generation_mode() == YOUNG || (_generation->generation_mode() == GLOBAL && ShenandoahVerify)) {\n+      \/\/ The current implementation of swap_remembered_set() copies the write-card-table\n+      \/\/ to the read-card-table. The remembered sets are also swapped for GLOBAL collections\n+      \/\/ so that the verifier works with the correct copy of the card table when verifying.\n+      _generation->swap_remembered_set();\n+    }\n+\n+    if (_generation->generation_mode() == GLOBAL) {\n+      heap->cancel_old_gc();\n+    } else if (heap->is_concurrent_old_mark_in_progress()) {\n+      \/\/ Purge the SATB buffers, transferring any valid, old pointers to the\n+      \/\/ old generation mark queue. Any pointers in a young region will be\n+      \/\/ abandoned.\n+      heap->transfer_old_pointers_from_satb();\n+    }\n+  }\n+\n@@ -1134,7 +1145,0 @@\n-  if (heap->is_concurrent_old_mark_in_progress()) {\n-    \/\/ Purge the SATB buffers, transferring any valid, old pointers to the\n-    \/\/ old generation mark queue. From here on, no mutator will have access\n-    \/\/ to anything that will be trashed and recycled.\n-    heap->purge_old_satb_buffers(false \/* abandon *\/);\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":19,"deletions":15,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -470,1 +470,5 @@\n-  if (!heap->cancelled_gc()) {\n+  if (heap->cancelled_gc()) {\n+    \/\/ Young generation bootstrap cycle has failed. Concurrent mark for old generation\n+    \/\/ is not going to resume after degenerated young cycle completes.\n+    log_info(gc)(\"Bootstrap cycle for old generation was cancelled.\");\n+  } else {\n@@ -666,4 +670,0 @@\n-\n-  \/\/ Just in case degenerated cycle preempted old-gen marking, clear the old-gen task queues.\n-  heap->young_generation()->set_old_gen_task_queues(NULL);\n-\n@@ -673,2 +673,4 @@\n-  assert(heap->old_generation()->task_queues()->is_empty(), \"Unexpected old generation marking tasks\");\n-  assert(heap->global_generation()->task_queues()->is_empty(), \"Unexpected global generation marking tasks\");\n+  if (_degen_generation->generation_mode() == GLOBAL) {\n+    assert(heap->old_generation()->task_queues()->is_empty(), \"Unexpected old generation marking tasks\");\n+    assert(heap->global_generation()->task_queues()->is_empty(), \"Unexpected global generation marking tasks\");\n+  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -93,5 +93,13 @@\n-  \/\/ We can't easily clear the old mark in progress flag because it must be done\n-  \/\/ on a safepoint (not sure if that is a hard requirement). At any rate, once\n-  \/\/ we are in a degenerated cycle, there should be no more old marking.\n-  if (heap->is_concurrent_old_mark_in_progress()) {\n-    heap->old_generation()->cancel_marking();\n+#ifdef ASSERT\n+  if (heap->mode()->is_generational()) {\n+    if (_generation->generation_mode() == GenerationMode::GLOBAL) {\n+      \/\/ We can only get to a degenerated global cycle _after_ a concurrent global cycle\n+      \/\/ has been cancelled. In which case, we expect the concurrent global cycle to have\n+      \/\/ cancelled the old gc already.\n+      assert(!heap->is_old_gc_active(), \"Old GC should not be active during global cycle.\");\n+    }\n+\n+    if (!heap->is_concurrent_old_mark_in_progress()) {\n+      \/\/ If we are not marking the old generation, there should be nothing in the old mark queues\n+      assert(heap->old_generation()->task_queues()->is_empty(), \"Old gen task queues should be empty.\");\n+    }\n@@ -99,1 +107,1 @@\n-  assert(heap->old_generation()->task_queues()->is_empty(), \"Old gen task queues should be empty.\");\n+#endif\n@@ -116,0 +124,8 @@\n+      if (heap->is_concurrent_old_mark_in_progress()) {\n+        \/\/ We have come straight into a degenerated cycle without running a concurrent cycle\n+        \/\/ first and the SATB barrier is enabled to support concurrent old marking. The SATB buffer\n+        \/\/ may hold a mix of old and young pointers. The old pointers need to be transferred\n+        \/\/ to the old generation mark queues and the young pointers are _not_ part of this\n+        \/\/ snapshot, so they must be dropped here.\n+        heap->transfer_old_pointers_from_satb();\n+      }\n@@ -128,2 +144,11 @@\n-      if (heap->is_concurrent_mark_in_progress()) {\n-        heap->cancel_concurrent_mark();\n+      if (!heap->mode()->is_generational()) {\n+        if (heap->is_concurrent_mark_in_progress()) {\n+          heap->cancel_concurrent_mark();\n+        }\n+      } else {\n+        if (_generation->is_concurrent_mark_in_progress()) {\n+          \/\/ We want to allow old generation marking to be punctuated by young collections\n+          \/\/ (even if they have degenerated). If this is a global cycle, we'd have cancelled\n+          \/\/ the entire old gc before coming into this switch.\n+          _generation->cancel_marking();\n+        }\n@@ -296,1 +321,1 @@\n-  assert(!ShenandoahHeap::heap()->is_concurrent_mark_in_progress(), \"Should be reset\");\n+  assert(!_generation->is_concurrent_mark_in_progress(), \"Should be reset\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahDegeneratedGC.cpp","additions":34,"deletions":9,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -197,0 +197,5 @@\n+  if (heap->mode()->is_generational()) {\n+    \/\/ Full GC supersedes any marking or coalescing in old generation.\n+    heap->cancel_old_gc();\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -400,1 +400,1 @@\n-    set_concurrent_mark_in_progress(false);\n+    set_mark_incomplete();\n@@ -402,1 +402,0 @@\n-  set_mark_incomplete();\n@@ -404,1 +403,0 @@\n-\n@@ -406,0 +404,1 @@\n+  set_concurrent_mark_in_progress(false);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -112,1 +112,1 @@\n-  virtual void prepare_gc(bool do_old_gc_bootstrap);\n+  void prepare_gc(bool do_old_gc_bootstrap);\n@@ -118,1 +118,1 @@\n-  void cancel_marking();\n+  virtual void cancel_marking();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-  if (in_progress && heap->is_concurrent_old_mark_in_progress()) {\n+  if (in_progress && heap->mode()->is_generational()) {\n@@ -66,3 +66,1 @@\n-    heap->purge_old_satb_buffers(true \/* abandon *\/);\n-    heap->old_generation()->cancel_marking();\n-    heap->young_generation()->set_old_gen_task_queues(nullptr);\n+    heap->cancel_old_gc();\n@@ -91,10 +89,0 @@\n-\n-void ShenandoahGlobalGeneration::prepare_gc(bool do_old_gc_bootstrap) {\n-  ShenandoahGeneration::prepare_gc(do_old_gc_bootstrap);\n-\n-  ShenandoahHeap* heap = ShenandoahHeap::heap();\n-  if (heap->mode()->is_generational()) {\n-    heap->cancel_mixed_collections();\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGlobalGeneration.cpp","additions":2,"deletions":14,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -45,2 +45,0 @@\n-  virtual void prepare_gc(bool do_old_gc_bootstrap) override;\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGlobalGeneration.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -984,1 +984,2 @@\n-void ShenandoahHeap::cancel_mixed_collections() {\n+void ShenandoahHeap::cancel_old_gc() {\n+  shenandoah_assert_safepoint();\n@@ -986,0 +987,7 @@\n+  log_info(gc)(\"Terminating old gc cycle.\");\n+\n+  \/\/ Stop marking\n+  old_generation()->cancel_marking();\n+  \/\/ Stop coalescing undead objects\n+  set_concurrent_prep_for_mixed_evacuation_in_progress(false);\n+  \/\/ Stop tracking old regions\n@@ -987,0 +995,9 @@\n+  \/\/ Remove old generation access to young generation mark queues\n+  young_generation()->set_old_gen_task_queues(nullptr);\n+}\n+\n+bool ShenandoahHeap::is_old_gc_active() {\n+  return is_concurrent_old_mark_in_progress()\n+      || is_concurrent_prep_for_mixed_evacuation_in_progress()\n+      || old_heuristics()->unprocessed_old_or_hidden_collection_candidates() > 0\n+      || young_generation()->old_gen_task_queues() != nullptr;\n@@ -2114,12 +2131,4 @@\n-      JavaThread* java_thread = JavaThread::cast(thread);\n-      if (java_thread->thread_state() == _thread_in_Java) {\n-        \/\/ ThreadBlockInVM requires thread state to be _thread_in_vm.  If we are in Java, safely transition thread state.\n-        ThreadInVMfromJava transition(java_thread);\n-        \/\/ We need to provide a safepoint here.  Otherwise we might spin forever if a SP is pending.\n-        ThreadBlockInVM sp(JavaThread::cast(thread));\n-        SpinPause();\n-      } else {\n-        \/\/ We need to provide a safepoint here.  Otherwise we might spin forever if a SP is pending.\n-        ThreadBlockInVM sp(JavaThread::cast(thread));\n-        SpinPause();\n-      }\n+      \/\/ We need to provide a safepoint here, otherwise we might\n+      \/\/ spin forever if a SP is pending.\n+      ThreadBlockInVM sp(JavaThread::cast(thread));\n+      SpinPause();\n@@ -2813,2 +2822,2 @@\n-void ShenandoahHeap::purge_old_satb_buffers(bool abandon) {\n-  ((ShenandoahOldGeneration*)_old_generation)->purge_satb_buffers(abandon);\n+void ShenandoahHeap::transfer_old_pointers_from_satb() {\n+  ((ShenandoahOldGeneration*) _old_generation)->transfer_pointers_from_satb();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":24,"deletions":15,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -813,1 +813,2 @@\n-  void cancel_mixed_collections();\n+  void cancel_old_gc();\n+  bool is_old_gc_active();\n@@ -841,1 +842,1 @@\n-  void purge_old_satb_buffers(bool abandon);\n+  void transfer_old_pointers_from_satb();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -828,1 +828,1 @@\n-                  \", watermark: \" PTR_FORMAT \", top_bitmap: \" PTR_FORMAT \"\\n\",\n+                  \", watermark: \" PTR_FORMAT \", top_bitmap: \" PTR_FORMAT,\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -303,2 +303,4 @@\n-      assert(heap->is_in_young(obj), \"Expected young object.\");\n-      heap->mark_card_as_dirty(p);\n+      if (heap->is_in(p)) {\n+        assert(heap->is_in_young(obj), \"Expected young object.\");\n+        heap->mark_card_as_dirty(p);\n+      }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMark.inline.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -92,1 +92,1 @@\n-    log_debug(gc)(\"Capturing TAMS for %s Region \" SIZE_FORMAT \", was: %llx, now: %llx\\n\",\n+    log_debug(gc)(\"Capturing TAMS for %s Region \" SIZE_FORMAT \", was: %llx, now: %llx\",\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkingContext.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -149,1 +149,1 @@\n-    if (check_cancellation_and_abort(ShenandoahDegenPoint::_degenerated_mark)) {\n+    if (heap->cancelled_gc()) {\n@@ -186,0 +186,9 @@\n+\n+  assert(!heap->is_concurrent_strong_root_in_progress(), \"No evacuations during old gc.\");\n+\n+  \/\/ We must execute this vm operation if we completed final mark. We cannot\n+  \/\/ return from here with weak roots in progress. This is not a valid gc state\n+  \/\/ for any young collections (or allocation failures) that interrupt the old\n+  \/\/ collection.\n+  vmop_entry_final_roots(false);\n+\n@@ -192,1 +201,0 @@\n-\n@@ -195,1 +203,1 @@\n-  if (check_cancellation_and_abort(ShenandoahDegenPoint::_degenerated_evac)) {\n+  if (heap->cancelled_gc()) {\n@@ -199,4 +207,0 @@\n-  assert(!heap->is_concurrent_strong_root_in_progress(), \"No evacuations during old gc.\");\n-\n-  vmop_entry_final_roots(false);\n-\n@@ -205,4 +209,3 @@\n-      \/\/ If old-gen degenerates instead of resuming, we'll just start up an out-of-cycle degenerated GC.\n-      \/\/ This should be a rare event.  Normally, we'll resume the coalesce-and-fill effort after the\n-      \/\/ preempting young-gen GC finishes.\n-      check_cancellation_and_abort(ShenandoahDegenPoint::_degenerated_outside_cycle);\n+      \/\/ If an allocation failure occurs during coalescing, we will run a degenerated\n+      \/\/ cycle for the young generation. This should be a rare event.  Normally, we'll\n+      \/\/ resume the coalesce-and-fill effort after the preempting young-gen GC finishes.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGC.cpp","additions":14,"deletions":11,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -84,2 +84,1 @@\n-      if (region->is_old()) {\n-        if (!region->is_trash()) {\n+      if (region->is_old() && region->is_active()) {\n@@ -87,3 +86,2 @@\n-        } else {\n-          ++_trashed_oops;\n-        }\n+      } else {\n+        ++_trashed_oops;\n@@ -161,1 +159,9 @@\n-void ShenandoahOldGeneration::purge_satb_buffers(bool abandon) {\n+void ShenandoahOldGeneration::cancel_marking() {\n+  if (is_concurrent_mark_in_progress()) {\n+    ShenandoahBarrierSet::satb_mark_queue_set().abandon_partial_marking();\n+  }\n+\n+  ShenandoahGeneration::cancel_marking();\n+}\n+\n+void ShenandoahOldGeneration::transfer_pointers_from_satb() {\n@@ -166,5 +172,2 @@\n-  if (abandon) {\n-    ShenandoahBarrierSet::satb_mark_queue_set().abandon_partial_marking();\n-  } else {\n-    uint nworkers = heap->workers()->active_workers();\n-    StrongRootsScope scope(nworkers);\n+  uint nworkers = heap->workers()->active_workers();\n+  StrongRootsScope scope(nworkers);\n@@ -172,3 +175,2 @@\n-    ShenandoahPurgeSATBTask purge_satb_task(task_queues());\n-    heap->workers()->run_task(&purge_satb_task);\n-  }\n+  ShenandoahPurgeSATBTask purge_satb_task(task_queues());\n+  heap->workers()->run_task(&purge_satb_task);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.cpp","additions":16,"deletions":14,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -49,0 +49,2 @@\n+  virtual void cancel_marking() override;\n+\n@@ -71,1 +73,1 @@\n-  void purge_satb_buffers(bool abandon);\n+  void transfer_pointers_from_satb();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"}]}