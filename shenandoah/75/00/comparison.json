{"files":[{"patch":"@@ -127,0 +127,7 @@\n+        if (heap->mode()->is_generational() && (region->age() >= InitialTenuringThreshold)) {\n+          \/\/ Bias selection of regions that have reached tenure age\n+          for (int i = region->age() - InitialTenuringThreshold; i >= 0; i--) {\n+            \/\/ Avoid floating-point math with integer multiply and shift.\n+            garbage = (garbage * ShenandoahTenuredRegionUsageBias) >> ShenandoahTenuredRegionUsageBiasLogBase2;\n+          }\n+        }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -87,0 +87,2 @@\n+  assert(!r->is_humongous(), \"Only add regular regions to the collection set\");\n+\n@@ -89,0 +91,1 @@\n+  _has_old_regions |= r->is_old();\n@@ -91,2 +94,0 @@\n-  _has_old_regions |= r->is_old();\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCollectionSet.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -93,2 +93,4 @@\n-          \/\/ First, clear the remembered set\n-          scanner->reset_remset(r->bottom(), size);\n+          \/\/ First, clear the remembered set for all spanned humongous regions\n+          size_t num_regions = (size + ShenandoahHeapRegion::region_size_words() - 1) \/ ShenandoahHeapRegion::region_size_words();\n+          size_t region_span = num_regions * ShenandoahHeapRegion::region_size_words();\n+          scanner->reset_remset(r->bottom(), region_span);\n@@ -97,1 +99,1 @@\n-          do {\n+          while (num_regions-- != 0) {\n@@ -101,1 +103,1 @@\n-          } while (humongous_region->top() < end_object);\n+          }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1157,0 +1157,1 @@\n+\n@@ -1162,0 +1163,60 @@\n+      if (_sh->check_cancelled_gc_and_yield(_concurrent)) {\n+        break;\n+      }\n+    }\n+  }\n+};\n+\n+\/\/ Unlike ShenandoahEvacuationTask, this iterates over all regions rather than just the collection set.\n+\/\/ This is needed in order to promote humongous start regions if age() >= tenure threshold.\n+class ShenandoahGenerationalEvacuationTask : public AbstractGangTask {\n+private:\n+  ShenandoahHeap* const _sh;\n+  ShenandoahRegionIterator *_regions;\n+  bool _concurrent;\n+public:\n+  ShenandoahGenerationalEvacuationTask(ShenandoahHeap* sh,\n+                                       ShenandoahRegionIterator* iterator,\n+                                       bool concurrent) :\n+    AbstractGangTask(\"Shenandoah Evacuation\"),\n+    _sh(sh),\n+    _regions(iterator),\n+    _concurrent(concurrent)\n+  {}\n+\n+  void work(uint worker_id) {\n+    if (_concurrent) {\n+      ShenandoahConcurrentWorkerSession worker_session(worker_id);\n+      ShenandoahSuspendibleThreadSetJoiner stsj(ShenandoahSuspendibleWorkers);\n+      ShenandoahEvacOOMScope oom_evac_scope;\n+      do_work();\n+    } else {\n+      ShenandoahParallelWorkerSession worker_session(worker_id);\n+      ShenandoahEvacOOMScope oom_evac_scope;\n+      do_work();\n+    }\n+  }\n+\n+private:\n+  void do_work() {\n+    ShenandoahConcurrentEvacuateRegionObjectClosure cl(_sh);\n+    ShenandoahHeapRegion* r;\n+    while ((r = _regions->next()) != nullptr) {\n+      log_debug(gc)(\"GenerationalEvacuationTask do_work(), looking at %s region \" SIZE_FORMAT \", (age: %d) [%s, %s]\",\n+                    r->is_old()? \"old\": r->is_young()? \"young\": \"free\", r->index(), r->age(),\n+                    r->is_active()? \"active\": \"inactive\",\n+                    r->is_humongous()? (r->is_humongous_start()? \"humongous_start\": \"humongous_continuation\"): \"regular\");\n+      if (r->is_cset()) {\n+        assert(r->has_live(), \"Region \" SIZE_FORMAT \" should have been reclaimed early\", r->index());\n+        _sh->marked_object_iterate(r, &cl);\n+        if (ShenandoahPacing) {\n+          _sh->pacer()->report_evac(r->used() >> LogHeapWordSize);\n+        }\n+      } else if (r->is_young() && r->is_active() && r->is_humongous_start() && (r->age() > InitialTenuringThreshold)) {\n+        \/\/ We promote humongous_start regions along with their affiliated continuations during evacuation rather than\n+        \/\/ doing this work during a safepoint.  We cannot put humongous regions into the collection set because that\n+        \/\/ triggers the load-reference barrier (LRB) to copy on reference fetch.\n+        r->promote_humongous();\n+      }\n+      \/\/ else, region is free, or OLD, or not in collection set, or humongous_continuation,\n+      \/\/ or is young humongous_start that is too young to be promoted\n@@ -1171,2 +1232,8 @@\n-  ShenandoahEvacuationTask task(this, _collection_set, concurrent);\n-  workers()->run_task(&task);\n+  if (ShenandoahHeap::heap()->mode()->is_generational()) {\n+    ShenandoahRegionIterator regions;\n+    ShenandoahGenerationalEvacuationTask task(this, &regions, concurrent);\n+    workers()->run_task(&task);\n+  } else {\n+    ShenandoahEvacuationTask task(this, _collection_set, concurrent);\n+    workers()->run_task(&task);\n+  }\n@@ -2185,0 +2252,2 @@\n+\n+      log_debug(gc)(\"ShenandoahUpdateHeapRefsTask::do_work(%u) looking at region \" SIZE_FORMAT, worker_id, r->index());\n@@ -2360,7 +2429,0 @@\n-\n-  \/\/ HEY! this code and rebuild free set used to be in op_final_updaterefs\n-  if (mode()->is_generational() && is_gc_generation_young() && ShenandoahPromoteTenuredRegions) {\n-    ShenandoahGCPhase phase(ShenandoahPhaseTimings::final_update_refs_promote_tenured_regions);\n-    ShenandoahHeapLocker locker(lock());\n-    young_generation()->promote_tenured_regions();\n-  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":71,"deletions":9,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -514,49 +514,0 @@\n-\/\/ This function does not set card dirty bits.  The decision of which cards to dirty is best\n-\/\/ made in the caller's context.\n-void ShenandoahHeapRegion::fill_dead_and_register_for_promotion() {\n-  ShenandoahHeap* heap = ShenandoahHeap::heap();\n-  ShenandoahMarkingContext* marking_context = heap->marking_context();\n-  HeapWord* obj_addr = bottom();\n-  RememberedScanner* rem_set_scanner = heap->card_scan();\n-  \/\/ Objects allocated above TAMS are not marked, but are considered live for purposes of current GC efforts.\n-  HeapWord* t = marking_context->top_at_mark_start(this);\n-\n-  assert(!is_humongous(), \"no humongous region here\");\n-  assert(heap->active_generation()->is_mark_complete(), \"sanity\");\n-\n-  \/\/ end() might be overkill as end of range, but top() may not align with card boundary.\n-  rem_set_scanner->reset_object_range(bottom(), end());\n-  while (obj_addr < t) {\n-    oop obj = cast_to_oop(obj_addr);\n-    if (marking_context->is_marked(obj)) {\n-      assert(obj->klass() != NULL, \"klass should not be NULL\");\n-      \/\/ when promoting an entire region, we have to register the marked objects as well\n-      rem_set_scanner->register_object_wo_lock(obj_addr);\n-      obj_addr += obj->size();\n-    } else {\n-      \/\/ Object is not marked.  Coalesce and fill dead object with dead neighbors.\n-      HeapWord* next_marked_obj = marking_context->get_next_marked_addr(obj_addr, t);\n-      assert(next_marked_obj <= t, \"next marked object cannot exceed top\");\n-      size_t fill_size = next_marked_obj - obj_addr;\n-      assert(fill_size >= (size_t) oopDesc::header_size(),\n-             \"fill size \" SIZE_FORMAT \" for obj @ \" PTR_FORMAT \", next_marked: \" PTR_FORMAT \", TAMS: \" PTR_FORMAT \" is too small\",\n-             fill_size, p2i(obj_addr), p2i(next_marked_obj), p2i(t));\n-      ShenandoahHeap::fill_with_object(obj_addr, fill_size);\n-      rem_set_scanner->register_object_wo_lock(obj_addr);\n-      obj_addr = next_marked_obj;\n-    }\n-  }\n-\n-  \/\/ Any object above TAMS and below top() is considered live.\n-  t = top();\n-  while (obj_addr < t) {\n-    oop obj = cast_to_oop(obj_addr);\n-    assert(obj->klass() != NULL, \"klass should not be NULL\");\n-    \/\/ when promoting an entire region, we have to register the marked objects as well\n-    rem_set_scanner->register_object_wo_lock(obj_addr);\n-    obj_addr += obj->size();\n-  }\n-\n-  \/\/ Remembered set scanning stops at top() so no need to fill beyond it.\n-}\n-\n@@ -919,21 +870,1 @@\n-size_t ShenandoahHeapRegion::promote(bool promoting_all) {\n-  \/\/ TODO: Not sure why region promotion must be performed at safepoint.  Reconsider this requirement.\n-  assert(SafepointSynchronize::is_at_safepoint(), \"must be at a safepoint\");\n-\n-  \/\/ Note that region promotion occurs at a safepoint following all evacuation.  When a region is promoted, we leave\n-  \/\/ its TAMS and update_watermark information as is.\n-  \/\/\n-  \/\/ Note that update_watermark represents the state of this region as of the moment at which the most recent evacuation\n-  \/\/ began.  The value of update_watermark is the same for old regions and young regions, as both participate equally in\n-  \/\/ the processes of a mixed evacuation.\n-  \/\/\n-  \/\/ The meaning of TAMS is different for young-gen and old-gen regions.  For a young-gen region, TAMS represents\n-  \/\/ top() at start of most recent young-gen concurrent mark.  For an old-gen region, TAMS represents top() at start\n-  \/\/ of most recent old-gen concurrent mark().  In the case that a young-gen heap region is promoted into old-gen,\n-  \/\/ we can preserve its TAMS information with the following understandings:\n-  \/\/   1. The most recent young-GC concurrent mark phase began at the same time or after the most recent old-GC\n-  \/\/      concurrent mark phase.\n-  \/\/   2. After the region is promoted, it is still the case that any object within the region that is beneath TAMS\n-  \/\/      and is considered alive for the current old GC pass will be \"marked\" within the current marking context, and\n-  \/\/      any object within the region that is above TAMS will be considered alive for the current old GC pass.  Objects\n-  \/\/      that were dead at promotion time will all reside below TAMS and will be unmarked.\n+size_t ShenandoahHeapRegion::promote_humongous() {\n@@ -943,1 +874,3 @@\n-  assert(affiliation() == YOUNG_GENERATION, \"Only young regions can be promoted\");\n+  assert(is_young(), \"Only young regions can be promoted\");\n+  assert(is_humongous_start(), \"Should not promote humongous continuation in isolation\");\n+  assert(age() >= InitialTenuringThreshold, \"Only promote regions that are sufficiently aged\");\n@@ -948,38 +881,31 @@\n-  if (is_humongous_start()) {\n-    oop obj = cast_to_oop(bottom());\n-    assert(marking_context->is_marked(obj), \"promoted humongous object should be alive\");\n-\n-    \/\/ Since the humongous region holds only one object, no lock is necessary for this register_object() invocation.\n-    heap->card_scan()->register_object_wo_lock(bottom());\n-    size_t index_limit = index() + ShenandoahHeapRegion::required_regions(obj->size() * HeapWordSize);\n-\n-    \/\/ For this region and each humongous continuation region spanned by this humongous object, change\n-    \/\/ affiliation to OLD_GENERATION and adjust the generation-use tallies.  The remnant of memory\n-    \/\/ in the last humongous region that is not spanned by obj is currently not used.\n-    for (size_t i = index(); i < index_limit; i++) {\n-      ShenandoahHeapRegion* r = heap->get_region(i);\n-      log_debug(gc)(\"promoting region \" SIZE_FORMAT \", from \" SIZE_FORMAT \" to \" SIZE_FORMAT,\n-        r->index(), (size_t) r->bottom(), (size_t) r->top());\n-      if (r->top() < r->end()) {\n-        ShenandoahHeap::fill_with_object(r->top(), (r->end() - r->top()) \/ HeapWordSize);\n-        heap->card_scan()->register_object_wo_lock(r->top());\n-        heap->card_scan()->mark_range_as_clean(top(), r->end() - r->top());\n-      }\n-      \/\/ We mark the entire humongous object's range as dirty after loop terminates, so no need to dirty the range here\n-      r->set_affiliation(OLD_GENERATION);\n-      log_debug(gc)(\"promoting humongous region \" SIZE_FORMAT \", dirtying cards from \" SIZE_FORMAT \" to \" SIZE_FORMAT,\n-                    i, (size_t) r->bottom(), (size_t) r->top());\n-      old_generation->increase_used(r->used());\n-      young_generation->decrease_used(r->used());\n-    }\n-    if (promoting_all || obj->is_typeArray()) {\n-      \/\/ Primitive arrays don't need to be scanned.  Likewise, if we are promoting_all, there's nothing\n-      \/\/ left in young-gen, so there can exist no \"interesting\" pointers.  See above TODO question about requiring\n-      \/\/ region promotion at safepoint.  If we're not at a safepoint, then we can't really \"promote all\" without\n-      \/\/ directing new allocations to old-gen.  That's probably not what we want.  The whole \"promote-all strategy\"\n-      \/\/ probably needs to be revisited at some future point.\n-      heap->card_scan()->mark_range_as_clean(bottom(), obj->size());\n-    } else {\n-      heap->card_scan()->mark_range_as_dirty(bottom(), obj->size());\n-    }\n-    return index_limit - index();\n+  oop obj = cast_to_oop(bottom());\n+  assert(marking_context->is_marked(obj), \"promoted humongous object should be alive\");\n+\n+  size_t spanned_regions = ShenandoahHeapRegion::required_regions(obj->size() * HeapWordSize);\n+  size_t index_limit = index() + spanned_regions;\n+\n+  log_debug(gc)(\"promoting humongous region \" SIZE_FORMAT \", spanning \" SIZE_FORMAT, index(), spanned_regions);\n+\n+  \/\/ Since this region may have served previously as OLD, it may hold obsolete object range info.\n+  heap->card_scan()->reset_object_range(bottom(), bottom() + spanned_regions * ShenandoahHeapRegion::region_size_words());\n+  \/\/ Since the humongous region holds only one object, no lock is necessary for this register_object() invocation.\n+  heap->card_scan()->register_object_wo_lock(bottom());\n+\n+  \/\/ For this region and each humongous continuation region spanned by this humongous object, change\n+  \/\/ affiliation to OLD_GENERATION and adjust the generation-use tallies.  The remnant of memory\n+  \/\/ in the last humongous region that is not spanned by obj is currently not used.\n+  for (size_t i = index(); i < index_limit; i++) {\n+    ShenandoahHeapRegion* r = heap->get_region(i);\n+    log_debug(gc)(\"promoting humongous region \" SIZE_FORMAT \", from \" PTR_FORMAT \" to \" PTR_FORMAT,\n+                  r->index(), p2i(r->bottom()), p2i(r->top()));\n+    \/\/ We mark the entire humongous object's range as dirty after loop terminates, so no need to dirty the range here\n+    r->set_affiliation(OLD_GENERATION);\n+    old_generation->increase_used(r->used());\n+    young_generation->decrease_used(r->used());\n+  }\n+  if (obj->is_typeArray()) {\n+    \/\/ Primitive arrays don't need to be scanned.  See above TODO question about requiring\n+    \/\/ region promotion at safepoint.\n+    log_debug(gc)(\"Clean cards for promoted humongous object (Region \" SIZE_FORMAT \") from \" PTR_FORMAT \" to \" PTR_FORMAT,\n+                  index(), p2i(bottom()), p2i(bottom() + obj->size()));\n+    heap->card_scan()->mark_range_as_clean(bottom(), obj->size());\n@@ -987,21 +913,3 @@\n-    log_debug(gc)(\"promoting region \" SIZE_FORMAT \", dirtying cards from \" SIZE_FORMAT \" to \" SIZE_FORMAT,\n-      index(), (size_t) bottom(), (size_t) top());\n-    assert(!is_humongous_continuation(), \"should not promote humongous object continuation in isolation\");\n-\n-    fill_dead_and_register_for_promotion();\n-    \/\/ Rather than scanning entire contents of the promoted region right now to determine which\n-    \/\/ cards to mark as dirty, we just mark them all as dirty (unless promoting_all).  Later, when we\n-    \/\/ scan the remembered set, we will clear cards that are found to not contain live references to\n-    \/\/ young memory.  Ultimately, this approach is more efficient as it only scans the \"dirty\" cards\n-    \/\/ once and the clean cards once.  The alternative approach of scanning all cards now and then\n-    \/\/ scanning dirty cards again at next concurrent mark pass scans the clean cards once and the dirty\n-    \/\/ cards twice.\n-    if (promoting_all) {\n-      heap->card_scan()->mark_range_as_clean(bottom(), top() - bottom());\n-    } else {\n-      heap->card_scan()->mark_range_as_dirty(bottom(), top() - bottom());\n-    }\n-    set_affiliation(OLD_GENERATION);\n-    old_generation->increase_used(used());\n-    young_generation->decrease_used(used());\n-    return 1;\n+    log_debug(gc)(\"Dirty cards for promoted humongous object (Region \" SIZE_FORMAT \") from \" PTR_FORMAT \" to \" PTR_FORMAT,\n+                  index(), p2i(bottom()), p2i(bottom() + obj->size()));\n+    heap->card_scan()->mark_range_as_dirty(bottom(), obj->size());\n@@ -1009,0 +917,1 @@\n+  return index_limit - index();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.cpp","additions":39,"deletions":130,"binary":false,"changes":169,"status":"modified"},{"patch":"@@ -422,6 +422,2 @@\n-  \/\/ Adjusts remembered set information by setting all cards to clean if promoting all, setting\n-  \/\/ all cards to dirty otherwise.\n-  \/\/\n-  \/\/ Returns the number of regions promoted, which is generally one, but may be greater than 1 if\n-  \/\/ this is humongous region with multiple continuations.\n-  size_t promote(bool promoting_all);\n+  \/\/ Sets all remembered set cards to dirty.  Returns the number of regions spanned by the associated humongous object.\n+  size_t promote_humongous();\n@@ -437,4 +433,0 @@\n-  \/\/ Process the contents of a region when it is being promoted en masse by registering each marked object, coalescing\n-  \/\/ contiguous ranges of unmarked objects into registered dead objects.  Do not touch card marks.\n-  void fill_dead_and_register_for_promotion();\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.hpp","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -187,1 +187,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMark.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -121,1 +121,0 @@\n-  f(final_update_refs_promote_tenured_regions,      \"  Promote Tenured Regions\")       \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahPhaseTimings.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -109,0 +109,1 @@\n+    log_debug(gc)(\"ShenandoahScanRememberedTask::work(%u), looking at region \" SIZE_FORMAT, worker_id, region->index());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -658,1 +658,1 @@\n-              \/\/ between multiple threads.\n+              \/\/ between multiple threads.  Also, skip parts of the array that are not marked as dirty.\n@@ -793,0 +793,3 @@\n+  log_debug(gc)(\"Remembered set scan processing Region \" SIZE_FORMAT \", from \" PTR_FORMAT \" to \" PTR_FORMAT \", using %s table\",\n+                region->index(), p2i(region->bottom()), p2i(end_of_range),\n+                use_write_table? \"read\/write (updating)\": \"read (marking)\");\n@@ -801,2 +804,4 @@\n-  \/\/ Remembered set scanner\n-  process_clusters(start_cluster_no, num_clusters, end_of_range, cl, use_write_table);\n+  if (!region->is_humongous_continuation()) {\n+    \/\/ Remembered set scanner\n+    process_clusters(start_cluster_no, num_clusters, end_of_range, cl, use_write_table);\n+  }\n@@ -813,0 +818,1 @@\n+\/\/ This is used only for debug verification so don't worry about making the scan parallel.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.inline.hpp","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -53,36 +53,0 @@\n-class ShenandoahPromoteTenuredRegionsTask : public AbstractGangTask {\n-private:\n-  ShenandoahRegionIterator* _regions;\n-public:\n-  volatile size_t _promoted;\n-\n-  ShenandoahPromoteTenuredRegionsTask(ShenandoahRegionIterator* regions) :\n-    AbstractGangTask(\"Shenandoah Promote Tenured Regions\"),\n-    _regions(regions),\n-    _promoted(0) {\n-  }\n-\n-  void work(uint worker_id) {\n-    ShenandoahParallelWorkerSession worker_session(worker_id);\n-    ShenandoahHeapRegion* r = _regions->next();\n-    while (r != NULL) {\n-      if (r->is_young() && r->age() >= InitialTenuringThreshold && ((r->is_regular() && !r->has_young_lab_flag()) || r->is_humongous_start())) {\n-        \/\/ The thread that first encounters a humongous start region promotes the associated humonogous continuations,\n-        \/\/ so we do not process humongous continuations directly.  Below, we rely on promote() to promote related\n-        \/\/ continuation regions when encountering a homongous start.\n-        size_t promoted = r->promote(false);\n-        Atomic::add(&_promoted, promoted);\n-      }\n-      r = _regions->next();\n-    }\n-  }\n-};\n-\n-void ShenandoahYoungGeneration::promote_tenured_regions() {\n-  ShenandoahHeap::heap()->set_young_lab_region_flags();\n-  ShenandoahRegionIterator regions;\n-  ShenandoahPromoteTenuredRegionsTask task(&regions);\n-  ShenandoahHeap::heap()->workers()->run_task(&task);\n-  log_info(gc)(\"Promoted \" SIZE_FORMAT \" regions.\", task._promoted);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahYoungGeneration.cpp","additions":0,"deletions":36,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-  void promote_tenured_regions();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahYoungGeneration.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -381,0 +381,17 @@\n+  product(uintx, ShenandoahTenuredRegionUsageBias, 192, EXPERIMENTAL,       \\\n+          \"The collection set is comprised of heap regions that contain \"   \\\n+          \"the greatest amount of garbage.  \"                               \\\n+          \"For purposes of selecting regions to be included in the \"        \\\n+          \"collection set, regions that have reached the tenure age will \"  \\\n+          \"be treated as if their contained garbage is the actual \"         \\\n+          \"contained garbage multiplied by \"                                \\\n+          \"(ShenandoahTenuredRegionUsageBias \/ 128 (e.g. 150% for the \"     \\\n+          \"default value) as many times as the region's age meets or \"      \\\n+          \"exceeds the tenure age.  For example, if tenure age is 7, \"      \\\n+          \"the region age is 9, ShenandoahTenuredRegionUsageBias is \"       \\\n+          \"192, and the region is 12.5% garbage, this region \"              \\\n+          \"will by treated as if its garbage content is \"                   \\\n+          \"1\/8 * 27\/8 = 42.2% when comparing this region to untenured \"     \\\n+          \"regions.\")                                                       \\\n+          range(128, 256)                                                   \\\n+                                                                            \\\n@@ -394,0 +411,3 @@\n+\/\/ 2^ShenandoahTenuredRegionUsageBiasLogBase2 is 128\n+#define ShenandoahTenuredRegionUsageBiasLogBase2 7\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoah_globals.hpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"}]}