{"files":[{"patch":"@@ -103,0 +103,1 @@\n+      \/\/ Note: unsigned result from adjusted_unaffiliated_regions() will never be less than zero, but it may equal zero.\n@@ -109,0 +110,1 @@\n+      \/\/ Note: unsigned result from adjusted_unaffiliated_regions() will never be less than zero, but it may equal zero.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -198,2 +198,2 @@\n-    \/\/ Since we probably have not yet reclaimed the most recently selected collection set, we have to defer\n-    \/\/ unadjust_available() invocations until after Full GC finishes its efforts.\n+    \/\/ Defer unadjust_available() invocations until after Full GC finishes its efforts because Full GC makes use\n+    \/\/ of young-gen memory that may have been loaned from old-gen.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -986,1 +986,1 @@\n-size_t ShenandoahGeneration::adjusted_unaffiliated_regions() {\n+size_t ShenandoahGeneration::adjusted_unaffiliated_regions() const {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -102,1 +102,1 @@\n-  virtual size_t adjusted_unaffiliated_regions();\n+  virtual size_t adjusted_unaffiliated_regions() const;\n@@ -169,0 +169,1 @@\n+  \/\/ Return the updated value of affiliated_region_count\n@@ -170,0 +171,2 @@\n+\n+  \/\/ Return the updated value of affiliated_region_count\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1015,0 +1015,7 @@\n+  \/\/ TODO: Consider not promoting humongous objects that represent primitive arrays.  Leaving a primitive array\n+  \/\/ (obj->is_typeArray()) in young-gen is harmless because these objects are never relocated and they are not\n+  \/\/ scanned.  Leaving primitive arrays in young-gen memory allows their memory to be reclaimed more quickly when\n+  \/\/ it becomes garbage.  Better to not make this change until sizes of young-gen and old-gen are completely\n+  \/\/ adaptive, as leaving primitive arrays in young-gen might be perceived as an \"astonishing result\" by someone\n+  \/\/ has carefully analyzed the required sizes of an application's young-gen and old-gen.\n+\n@@ -1040,0 +1047,10 @@\n+      \/\/ There are not enough available old regions to promote this humongous region at this time, so defer promotion.\n+      \/\/ TODO: Consider allowing the promotion now, with the expectation that we can resize and\/or collect OLD\n+      \/\/ momentarily to address the transient violation of budgets.  Some problems that need to be addressed in order\n+      \/\/ to allow transient violation of capacity budgets are:\n+      \/\/  1. Various size_t subtractions assume usage is less than capacity, and thus assume there will be no\n+      \/\/     arithmetic underflow when we subtract usage from capacity.  The results of such size_t subtractions\n+      \/\/     would need to be guarded and special handling provided.\n+      \/\/  2. ShenandoahVerifier enforces that usage is less than capacity.  If we are going to relax this constraint,\n+      \/\/     we need to think about what conditions allow the constraint to be violated and document and implement the\n+      \/\/     changes.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.cpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -343,0 +343,2 @@\n+\/\/ This closure computes the amounts of used, committed, and garbage memory and the number of regions contained within\n+\/\/ a subset (e.g. the young generation or old generation) of the total heap.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVerifier.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}