{"files":[{"patch":"@@ -100,0 +100,20 @@\n+  bool allow_new_region = true;\n+  switch (req.affiliation()) {\n+    case ShenandoahRegionAffiliation::OLD_GENERATION:\n+      if (_heap->old_generation()->adjusted_unaffiliated_regions() <= 0) {\n+        allow_new_region = false;\n+      }\n+      break;\n+\n+    case ShenandoahRegionAffiliation::YOUNG_GENERATION:\n+      if (_heap->young_generation()->adjusted_unaffiliated_regions() <= 0) {\n+        allow_new_region = false;\n+      }\n+      break;\n+\n+    case ShenandoahRegionAffiliation::FREE:\n+    default:\n+      ShouldNotReachHere();\n+      break;\n+  }\n+\n@@ -105,1 +125,2 @@\n-        if (is_mutator_free(idx)) {\n+        ShenandoahHeapRegion* r = _heap->get_region(idx);\n+        if (is_mutator_free(idx) && (allow_new_region || r->affiliation() != ShenandoahRegionAffiliation::FREE)) {\n@@ -107,1 +128,1 @@\n-          HeapWord* result = try_allocate_in(_heap->get_region(idx), req, in_new_region);\n+          HeapWord* result = try_allocate_in(r, req, in_new_region);\n@@ -130,4 +151,6 @@\n-      \/\/ Then try a free region that is dedicated to GC allocations.\n-      result = allocate_with_affiliation(FREE, req, in_new_region);\n-      if (result != NULL) {\n-        return result;\n+      if (allow_new_region) {\n+        \/\/ Then try a free region that is dedicated to GC allocations.\n+        result = allocate_with_affiliation(FREE, req, in_new_region);\n+        if (result != NULL) {\n+          return result;\n+        }\n@@ -141,10 +164,12 @@\n-      \/\/ Try to steal an empty region from the mutator view.\n-      for (size_t c = _mutator_rightmost + 1; c > _mutator_leftmost; c--) {\n-        size_t idx = c - 1;\n-        if (is_mutator_free(idx)) {\n-          ShenandoahHeapRegion* r = _heap->get_region(idx);\n-          if (can_allocate_from(r)) {\n-            flip_to_gc(r);\n-            HeapWord *result = try_allocate_in(r, req, in_new_region);\n-            if (result != NULL) {\n-              return result;\n+      if (allow_new_region) {\n+        \/\/ Try to steal an empty region from the mutator view.\n+        for (size_t c = _mutator_rightmost + 1; c > _mutator_leftmost; c--) {\n+          size_t idx = c - 1;\n+          if (is_mutator_free(idx)) {\n+            ShenandoahHeapRegion* r = _heap->get_region(idx);\n+            if (can_allocate_from(r)) {\n+              flip_to_gc(r);\n+              HeapWord *result = try_allocate_in(r, req, in_new_region);\n+              if (result != NULL) {\n+                return result;\n+              }\n@@ -179,1 +204,0 @@\n-\n@@ -181,1 +205,0 @@\n-\n@@ -246,0 +269,3 @@\n+      } else {\n+        log_info(gc, ergo)(\"Failed to shrink TLAB or GCLAB request (\" SIZE_FORMAT \") in region \" SIZE_FORMAT \" to \" SIZE_FORMAT\n+                           \" because min_size() is \" SIZE_FORMAT, req.size(), r->index(), size, req.min_size());\n@@ -375,0 +401,3 @@\n+  assert(req.affiliation() == ShenandoahRegionAffiliation::YOUNG_GENERATION, \"Humongous regions always allocated in YOUNG\");\n+  size_t avail_young_regions = _heap->young_generation()->adjusted_unaffiliated_regions();\n+\n@@ -376,1 +405,1 @@\n-  if (num > mutator_count()) {\n+  if (num > mutator_count() || (num > avail_young_regions)) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":48,"deletions":19,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -198,3 +198,3 @@\n-    \/\/ There will be no concurrent allocations during full GC so reset these coordination variables.\n-    heap->young_generation()->unadjust_available();\n-    heap->old_generation()->unadjust_available();\n+    \/\/ Since we probably have not yet reclaimed the most recently selected collection set, we have to defer\n+    \/\/ unadjust_available() invocations until after Full GC finishes its efforts.\n+\n@@ -356,0 +356,4 @@\n+  \/\/ Having reclaimed all dead memory, it is now safe to restore capacities to original values.\n+  heap->young_generation()->unadjust_available();\n+  heap->old_generation()->unadjust_available();\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -917,1 +917,1 @@\n-void ShenandoahGeneration::increment_affiliated_region_count() {\n+size_t ShenandoahGeneration::increment_affiliated_region_count() {\n@@ -919,0 +919,1 @@\n+  return _affiliated_region_count;\n@@ -921,1 +922,1 @@\n-void ShenandoahGeneration::decrement_affiliated_region_count() {\n+size_t ShenandoahGeneration::decrement_affiliated_region_count() {\n@@ -923,0 +924,1 @@\n+  return _affiliated_region_count;\n@@ -980,0 +982,9 @@\n+size_t ShenandoahGeneration::adjusted_capacity() const {\n+  return _adjusted_capacity;\n+}\n+\n+size_t ShenandoahGeneration::adjusted_unaffiliated_regions() {\n+  assert(adjusted_capacity() > used_regions_size(), \"adjusted_unaffiliated_regions() cannot return negative\");\n+  return (adjusted_capacity() - used_regions_size()) \/ ShenandoahHeapRegion::region_size_bytes();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -98,0 +98,5 @@\n+  virtual size_t adjusted_capacity() const;\n+\n+  \/\/ This is the number of FREE regions that are eligible to be affiliated with this generation according to the current\n+  \/\/ adjusted capacity.\n+  virtual size_t adjusted_unaffiliated_regions();\n@@ -164,2 +169,2 @@\n-  void increment_affiliated_region_count();\n-  void decrement_affiliated_region_count();\n+  size_t increment_affiliated_region_count();\n+  size_t decrement_affiliated_region_count();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.hpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -43,0 +43,5 @@\n+size_t ShenandoahGlobalGeneration::used_regions() const {\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  return heap->old_generation()->used_regions() + heap->young_generation()->used_regions();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGlobalGeneration.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+#include \"gc\/shenandoah\/shenandoahYoungGeneration.hpp\"\n+#include \"gc\/shenandoah\/shenandoahOldGeneration.hpp\"\n@@ -33,2 +35,2 @@\n-  ShenandoahGlobalGeneration(uint max_queues)\n-  : ShenandoahGeneration(GLOBAL, max_queues, 0, 0) { }\n+  ShenandoahGlobalGeneration(uint max_queues, size_t max_capacity, size_t soft_max_capacity)\n+  : ShenandoahGeneration(GLOBAL, max_queues, max_capacity, soft_max_capacity) { }\n@@ -41,0 +43,1 @@\n+  virtual size_t used_regions() const override;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGlobalGeneration.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -458,1 +458,2 @@\n-  _global_generation = new ShenandoahGlobalGeneration(_max_workers);\n+  _global_generation = new ShenandoahGlobalGeneration(_max_workers, max_capacity_new + max_capacity_old,\n+                                                      soft_max_capacity_new + soft_max_capacity_old);\n@@ -686,0 +687,2 @@\n+    \/\/ capacity must be a multiple of ShenandoahHeapRegion::region_size_bytes()\n+    capacity &= ~ShenandoahHeapRegion::region_size_bytes_mask();\n@@ -1230,0 +1233,6 @@\n+\n+          \/\/ TODO: if ShenandoahElasticTLAB and req.is_lab_alloc(), we should endeavor to shrink the TLAB request\n+          \/\/ in order to avoid allocation failure and degeneration of GC.\n+\n+          log_info(gc, ergo)(\"Rejecting mutator alloc of \" SIZE_FORMAT \" because young available is: \" SIZE_FORMAT,\n+                             requested_bytes, young_generation()->adjusted_available());\n@@ -1482,1 +1491,10 @@\n-        r->promote_humongous();\n+        if (r->promote_humongous() == 0) {\n+          \/\/ We chose not to promote because old-gen is out of memory.  Report and handle the promotion failure because\n+          \/\/ this suggests need for expanding old-gen and\/or performing collection of old-gen.\n+          ShenandoahHeap* heap = ShenandoahHeap::heap();\n+          oop obj = cast_to_oop(r->bottom());\n+          size_t size = obj->size();\n+          Thread* thread = Thread::current();\n+          heap->report_promotion_failure(thread, size);\n+          heap->handle_promotion_failure();\n+        }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":20,"deletions":2,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -779,1 +779,0 @@\n-  void handle_promotion_failure();\n@@ -782,0 +781,3 @@\n+  void handle_promotion_failure();\n+  void report_promotion_failure(Thread* thread, size_t size);\n+\n@@ -857,1 +859,0 @@\n-  void report_promotion_failure(Thread* thread, size_t size);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -977,0 +977,1 @@\n+  size_t regions;\n@@ -983,1 +984,3 @@\n-      heap->young_generation()->increment_affiliated_region_count();\n+      regions = heap->young_generation()->increment_affiliated_region_count();\n+      assert(regions * ShenandoahHeapRegion::region_size_bytes() <= heap->young_generation()->adjusted_capacity(),\n+             \"Number of young regions cannot exceed adjusted capacity\");\n@@ -986,1 +989,3 @@\n-      heap->old_generation()->increment_affiliated_region_count();\n+      regions = heap->old_generation()->increment_affiliated_region_count();\n+      assert(regions * ShenandoahHeapRegion::region_size_bytes() <= heap->old_generation()->adjusted_capacity(),\n+             \"Number of old regions cannot exceed adjusted capacity\");\n@@ -995,0 +1000,1 @@\n+\/\/ Returns number of regions promoted, or zero if we choose not to promote.\n@@ -1012,1 +1018,25 @@\n-  log_debug(gc)(\"promoting humongous region \" SIZE_FORMAT \", spanning \" SIZE_FORMAT, index(), spanned_regions);\n+  {\n+    \/\/ We need to grab the heap lock in order to avoid a race when changing the affiliations of spanned_regions from\n+    \/\/ young to old.\n+    ShenandoahHeapLocker locker(heap->lock());\n+    size_t available_old_regions = old_generation->adjusted_unaffiliated_regions();\n+    if (spanned_regions <= available_old_regions) {\n+      log_debug(gc)(\"promoting humongous region \" SIZE_FORMAT \", spanning \" SIZE_FORMAT, index(), spanned_regions);\n+\n+      \/\/ For this region and each humongous continuation region spanned by this humongous object, change\n+      \/\/ affiliation to OLD_GENERATION and adjust the generation-use tallies.  The remnant of memory\n+      \/\/ in the last humongous region that is not spanned by obj is currently not used.\n+      for (size_t i = index(); i < index_limit; i++) {\n+        ShenandoahHeapRegion* r = heap->get_region(i);\n+        log_debug(gc)(\"promoting humongous region \" SIZE_FORMAT \", from \" PTR_FORMAT \" to \" PTR_FORMAT,\n+                      r->index(), p2i(r->bottom()), p2i(r->top()));\n+        \/\/ We mark the entire humongous object's range as dirty after loop terminates, so no need to dirty the range here\n+        r->set_affiliation(OLD_GENERATION);\n+        old_generation->increase_used(r->used());\n+        young_generation->decrease_used(r->used());\n+      }\n+      \/\/ Then fall through to finish the promotion after releasing the heap lock.\n+    } else {\n+      return 0;\n+    }\n+  }\n@@ -1019,12 +1049,0 @@\n-  \/\/ For this region and each humongous continuation region spanned by this humongous object, change\n-  \/\/ affiliation to OLD_GENERATION and adjust the generation-use tallies.  The remnant of memory\n-  \/\/ in the last humongous region that is not spanned by obj is currently not used.\n-  for (size_t i = index(); i < index_limit; i++) {\n-    ShenandoahHeapRegion* r = heap->get_region(i);\n-    log_debug(gc)(\"promoting humongous region \" SIZE_FORMAT \", from \" PTR_FORMAT \" to \" PTR_FORMAT,\n-                  r->index(), p2i(r->bottom()), p2i(r->top()));\n-    \/\/ We mark the entire humongous object's range as dirty after loop terminates, so no need to dirty the range here\n-    r->set_affiliation(OLD_GENERATION);\n-    old_generation->increase_used(r->used());\n-    young_generation->decrease_used(r->used());\n-  }\n@@ -1032,2 +1050,1 @@\n-    \/\/ Primitive arrays don't need to be scanned.  See above TODO question about requiring\n-    \/\/ region promotion at safepoint.\n+    \/\/ Primitive arrays don't need to be scanned.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.cpp","additions":34,"deletions":17,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -345,1 +345,1 @@\n-  size_t _used, _committed, _garbage;\n+  size_t _used, _committed, _garbage, _regions;\n@@ -347,1 +347,1 @@\n-  ShenandoahCalculateRegionStatsClosure() : _used(0), _committed(0), _garbage(0) {};\n+  ShenandoahCalculateRegionStatsClosure() : _used(0), _committed(0), _garbage(0), _regions(0) {};\n@@ -351,1 +351,1 @@\n-    log_debug(gc)(\"ShenandoahCalculatRegionStatsClosure added \" SIZE_FORMAT \" for %s Region \" SIZE_FORMAT \", yielding: \" SIZE_FORMAT,\n+    log_debug(gc)(\"ShenandoahCalculateRegionStatsClosure added \" SIZE_FORMAT \" for %s Region \" SIZE_FORMAT \", yielding: \" SIZE_FORMAT,\n@@ -355,0 +355,1 @@\n+    _regions++;\n@@ -360,0 +361,4 @@\n+  size_t regions() { return _regions; }\n+\n+  \/\/ span is the total memory affiliated with these stats (some of which is in use and other is available)\n+  size_t span() { return _regions * ShenandoahHeapRegion::region_size_bytes(); }\n@@ -398,0 +403,11 @@\n+\n+    guarantee(stats.regions() == generation->used_regions(),\n+              \"%s: generation (%s) used regions (\" SIZE_FORMAT \") must equal regions that are in use (\" SIZE_FORMAT \")\",\n+              label, generation->name(), generation->used_regions(), stats.regions());\n+\n+    size_t capacity = generation->adjusted_capacity();\n+    guarantee(stats.span() <= capacity,\n+              \"%s: generation (%s) size spanned by regions (\" SIZE_FORMAT \") must not exceed current capacity (\" SIZE_FORMAT \"%s)\",\n+              label, generation->name(), stats.regions(),\n+              byte_size_in_proper_unit(capacity), proper_unit_for_byte_size(capacity));\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVerifier.cpp","additions":19,"deletions":3,"binary":false,"changes":22,"status":"modified"}]}