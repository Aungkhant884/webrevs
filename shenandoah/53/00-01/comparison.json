{"files":[{"patch":"@@ -674,1 +674,0 @@\n-      shenandoah_assert_correct(p, obj);\n@@ -676,0 +675,6 @@\n+        \/\/ TODO: This worries me. Here we are asserting that an unmarked from-space object is 'correct'.\n+        \/\/ Normally, I would call this a bogus assert, but there seems to be a legitimate use-case for\n+        \/\/ accessing from-space objects during class unloading. However, the from-space object may have\n+        \/\/ been \"filled\". We've made no effort to prevent old generation classes being unloaded by young\n+        \/\/ gen (and vice-versa).\n+        shenandoah_assert_correct(p, obj);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -171,4 +171,1 @@\n-    if (req.affiliation() == ShenandoahRegionAffiliation::OLD_GENERATION) {\n-      \/\/ This free region might have garbage in its remembered set representation.\n-      _heap->clear_cards_for(r);\n-    }\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -755,1 +755,1 @@\n-  return heap_region_containing(p)->affiliation() == ShenandoahRegionAffiliation::YOUNG_GENERATION;\n+  return is_in(p) && heap_region_containing(p)->affiliation() == ShenandoahRegionAffiliation::YOUNG_GENERATION;\n@@ -759,1 +759,1 @@\n-  return heap_region_containing(p)->affiliation() == ShenandoahRegionAffiliation::OLD_GENERATION;\n+  return is_in(p) && heap_region_containing(p)->affiliation() == ShenandoahRegionAffiliation::OLD_GENERATION;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -143,0 +143,1 @@\n+  friend class ShenandoahOldGC;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -613,0 +613,2 @@\n+  heap->clear_cards_for(this);\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"prims\/jvmtiTagMap.hpp\"\n@@ -96,3 +97,2 @@\n-    \/\/ Believe notifying JVMTI that the tagmap table will need cleaning is not relevant following old-gen mark\n-    \/\/ so commenting out for now:\n-    \/\/   JvmtiTagMap::set_needs_cleaning();\n+    \/\/ We need to do this because weak root cleaning reports the number of dead handles\n+    JvmtiTagMap::set_needs_cleaning();\n@@ -107,0 +107,3 @@\n+    heap->set_unload_classes(false);\n+    heap->prepare_concurrent_roots();\n+\n@@ -139,0 +142,1 @@\n+    heap->set_concurrent_weak_root_in_progress(false);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGC.cpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"}]}