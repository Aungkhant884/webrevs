{"files":[{"patch":"@@ -62,1 +62,9 @@\n-const char *affiliation_name(ShenandoahRegionAffiliation type) {\n+const char* affiliation_name(oop ptr) {\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  assert(heap->is_in(ptr), \"Oop must be in the heap.\");\n+  ShenandoahHeapRegion* region = heap->heap_region_containing(ptr);\n+  return affiliation_name(region->affiliation());\n+}\n+\n+\n+const char* affiliation_name(ShenandoahRegionAffiliation type) {\n@@ -71,1 +79,2 @@\n-      return \"UnrecognizedAffiliation\";\n+      ShouldNotReachHere();\n+      return nullptr;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/mode\/shenandoahGenerationalMode.cpp","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"oops\/oop.hpp\"\n@@ -42,1 +43,2 @@\n-const char *affiliation_name(ShenandoahRegionAffiliation type);\n+const char* affiliation_name(oop ptr);\n+const char* affiliation_name(ShenandoahRegionAffiliation type);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/mode\/shenandoahGenerationalMode.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -110,0 +110,1 @@\n+      _heap->is_in_active_generation(obj) &&\n@@ -117,0 +118,1 @@\n+      _heap->is_in_active_generation(obj) &&\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.inline.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -510,1 +510,1 @@\n-  ShenandoahReferenceProcessor* rp = heap->ref_processor();\n+  ShenandoahReferenceProcessor* rp = _generation->ref_processor();\n@@ -647,1 +647,1 @@\n-  heap->ref_processor()->process_references(ShenandoahPhaseTimings::conc_weak_refs, heap->workers(), true \/* concurrent *\/);\n+  _generation->ref_processor()->process_references(ShenandoahPhaseTimings::conc_weak_refs, heap->workers(), true \/* concurrent *\/);\n@@ -674,2 +674,9 @@\n-      shenandoah_assert_correct(p, obj);\n-      Atomic::cmpxchg(p, obj, oop(NULL));\n+      if (_heap->is_in_active_generation(obj)) {\n+        \/\/ TODO: This worries me. Here we are asserting that an unmarked from-space object is 'correct'.\n+        \/\/ Normally, I would call this a bogus assert, but there seems to be a legitimate use-case for\n+        \/\/ accessing from-space objects during class unloading. However, the from-space object may have\n+        \/\/ been \"filled\". We've made no effort to prevent old generation classes being unloaded by young\n+        \/\/ gen (and vice-versa).\n+        shenandoah_assert_correct(p, obj);\n+        Atomic::cmpxchg(p, obj, oop(NULL));\n+      }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -89,1 +89,1 @@\n-    ShenandoahReferenceProcessor* rp = heap->ref_processor();\n+    ShenandoahReferenceProcessor* rp = heap->active_generation()->ref_processor();\n@@ -139,1 +139,1 @@\n-    ShenandoahReferenceProcessor* rp = heap->ref_processor();\n+    ShenandoahReferenceProcessor* rp = heap->active_generation()->ref_processor();\n@@ -217,1 +217,1 @@\n-  ShenandoahReferenceProcessor* rp = heap->ref_processor();\n+  ShenandoahReferenceProcessor* rp = _generation->ref_processor();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentMark.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -171,4 +171,1 @@\n-    if (req.affiliation() == ShenandoahRegionAffiliation::OLD_GENERATION) {\n-      \/\/ This free region might have garbage in its remembered set representation.\n-      _heap->clear_cards_for(r);\n-    }\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -187,1 +187,1 @@\n-    ShenandoahReferenceProcessor* rp = heap->ref_processor();\n+    ShenandoahReferenceProcessor* rp = heap->global_generation()->ref_processor();\n@@ -302,1 +302,1 @@\n-  ShenandoahReferenceProcessor* rp = heap->ref_processor();\n+  ShenandoahReferenceProcessor* rp = heap->global_generation()->ref_processor();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"gc\/shenandoah\/shenandoahReferenceProcessor.hpp\"\n@@ -262,0 +263,2 @@\n+\n+  ref_processor()->abandon_partial_discovery();\n@@ -265,1 +268,1 @@\n-                                           uint max_queues,\n+                                           uint max_workers,\n@@ -269,1 +272,2 @@\n-  _task_queues(new ShenandoahObjToScanQueueSet(max_queues)),\n+  _task_queues(new ShenandoahObjToScanQueueSet(max_workers)),\n+  _ref_processor(new ShenandoahReferenceProcessor(MAX2(max_workers, 1U))),\n@@ -273,2 +277,2 @@\n-  assert(max_queues > 0, \"At least one queue\");\n-  for (uint i = 0; i < max_queues; ++i) {\n+  assert(max_workers > 0, \"At least one queue\");\n+  for (uint i = 0; i < max_workers; ++i) {\n@@ -305,1 +309,1 @@\n-  ShenandoahReferenceProcessor* rp = heap->ref_processor();\n+  ShenandoahReferenceProcessor* rp = ref_processor();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+class ShenandoahReferenceProcessor;\n@@ -46,0 +47,2 @@\n+  ShenandoahReferenceProcessor* const _ref_processor;\n+\n@@ -54,1 +57,1 @@\n-  ShenandoahGeneration(GenerationMode generation_mode, uint max_queues, size_t max_capacity, size_t soft_max_capacity);\n+  ShenandoahGeneration(GenerationMode generation_mode, uint max_workers, size_t max_capacity, size_t soft_max_capacity);\n@@ -61,0 +64,2 @@\n+  ShenandoahReferenceProcessor* ref_processor() { return _ref_processor; }\n+\n@@ -99,0 +104,3 @@\n+  \/\/ Return true if this object is affiliated with this generation.\n+  virtual bool contains(oop obj) const = 0;\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.hpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -51,0 +51,2 @@\n+  bool contains(oop obj) const override { return true; }\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGlobalGeneration.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -529,1 +529,0 @@\n-  _ref_processor(new ShenandoahReferenceProcessor(MAX2(_max_workers, 1U))),\n@@ -756,1 +755,1 @@\n-  return heap_region_containing(p)->affiliation() == ShenandoahRegionAffiliation::YOUNG_GENERATION;\n+  return is_in(p) && heap_region_containing(p)->affiliation() == ShenandoahRegionAffiliation::YOUNG_GENERATION;\n@@ -760,1 +759,16 @@\n-  return heap_region_containing(p)->affiliation() == ShenandoahRegionAffiliation::OLD_GENERATION;\n+  return is_in(p) && heap_region_containing(p)->affiliation() == ShenandoahRegionAffiliation::OLD_GENERATION;\n+}\n+\n+bool ShenandoahHeap::is_in_active_generation(oop obj) const {\n+  if (!mode()->is_generational()) {\n+    \/\/ everything is the same single generation\n+    return true;\n+  }\n+\n+  if (active_generation() == NULL) {\n+    \/\/ no collection is happening, only expect this to be called\n+    \/\/ when concurrent processing is active, but that could change\n+    return false;\n+  }\n+\n+  return active_generation()->contains(obj);\n@@ -1745,1 +1759,1 @@\n-  ref_processor()->process_references(phase, workers(), false \/* concurrent *\/);\n+  active_generation()->ref_processor()->process_references(phase, workers(), false \/* concurrent *\/);\n@@ -1864,3 +1878,0 @@\n-\n-  \/\/ HEY! Previously, only ShenandoahConcurrentMark::cancel (static) cleared ref processor.\n-  ref_processor()->abandon_partial_discovery();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":18,"deletions":7,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -143,0 +143,1 @@\n+  friend class ShenandoahOldGC;\n@@ -159,1 +160,1 @@\n-  ShenandoahGeneration* active_generation() {\n+  ShenandoahGeneration* active_generation() const {\n@@ -485,8 +486,0 @@\n-\/\/ ---------- Reference processing\n-\/\/\n-private:\n-  ShenandoahReferenceProcessor* const _ref_processor;\n-\n-public:\n-  ShenandoahReferenceProcessor* ref_processor() { return _ref_processor; }\n-\n@@ -527,0 +520,1 @@\n+  bool is_in_active_generation(oop obj) const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -407,1 +407,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.inline.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -613,0 +613,2 @@\n+  heap->clear_cards_for(this);\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -113,1 +113,2 @@\n-  heap->ref_processor()->set_mark_closure(worker_id, cl);\n+  assert(heap->active_generation()->generation_mode() == GENERATION, \"Sanity\");\n+  heap->active_generation()->ref_processor()->set_mark_closure(worker_id, cl);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMark.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"prims\/jvmtiTagMap.hpp\"\n@@ -75,1 +76,0 @@\n-  entry_coalesce_and_fill();\n@@ -97,3 +97,2 @@\n-    \/\/ Believe notifying JVMTI that the tagmap table will need cleaning is not relevant following old-gen mark\n-    \/\/ so commenting out for now:\n-    \/\/   JvmtiTagMap::set_needs_cleaning();\n+    \/\/ We need to do this because weak root cleaning reports the number of dead handles\n+    JvmtiTagMap::set_needs_cleaning();\n@@ -108,0 +107,3 @@\n+    heap->set_unload_classes(false);\n+    heap->prepare_concurrent_roots();\n+\n@@ -132,2 +134,0 @@\n-  entry_old_evacuations();\n-\n@@ -138,5 +138,0 @@\n-  \/\/ Concurrent stack processing\n-  if (heap->is_evacuation_in_progress()) {\n-    entry_thread_roots();\n-  }\n-\n@@ -147,0 +142,1 @@\n+    heap->set_concurrent_weak_root_in_progress(false);\n@@ -164,6 +160,12 @@\n-  \/\/ Processing strong roots\n-  \/\/ This may be skipped if there is nothing to update\/evacuate.\n-  \/\/ If so, strong_root_in_progress would be unset.\n-  if (heap->is_concurrent_strong_root_in_progress()) {\n-    entry_strong_roots();\n-  }\n+  \/\/ Coalesce and fill objects _after_ weak root processing and class unloading.\n+  \/\/ Weak root and reference processing makes assertions about unmarked referents\n+  \/\/ that will fail if they've been overwritten with filler objects. There is also\n+  \/\/ a case in the LRB that permits access to from-space objects for the purpose\n+  \/\/ of class unloading that is unlikely to function correctly if the object has\n+  \/\/ been filled.\n+  entry_coalesce_and_fill();\n+\n+  \/\/ Prepare for old evacuations (actual evacuations will happen on subsequent young collects).\n+  entry_old_evacuations();\n+\n+  assert(!heap->is_concurrent_strong_root_in_progress(), \"No evacuations during old gc.\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGC.cpp","additions":19,"deletions":17,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"gc\/shenandoah\/shenandoahReferenceProcessor.hpp\"\n@@ -131,1 +132,4 @@\n-  : ShenandoahGeneration(OLD, max_queues, max_capacity, soft_max_capacity) {}\n+  : ShenandoahGeneration(OLD, max_queues, max_capacity, soft_max_capacity) {\n+  \/\/ Always clear references for old generation\n+  ref_processor()->set_soft_reference_policy(true);\n+}\n@@ -174,0 +178,4 @@\n+\n+bool ShenandoahOldGeneration::contains(oop obj) const {\n+  return ShenandoahHeap::heap()->is_in_old(obj);\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.cpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-  const char* name() const;\n+  const char* name() const override;\n@@ -39,2 +39,1 @@\n-  bool contains(ShenandoahHeapRegion* region) const;\n-  void parallel_heap_region_iterate(ShenandoahHeapRegionClosure* cl);\n+  bool contains(ShenandoahHeapRegion* region) const override;\n@@ -42,1 +41,1 @@\n-  void heap_region_iterate(ShenandoahHeapRegionClosure* cl);\n+  bool contains(oop obj) const override;\n@@ -44,1 +43,5 @@\n-  void set_concurrent_mark_in_progress(bool in_progress);\n+  void parallel_heap_region_iterate(ShenandoahHeapRegionClosure* cl) override;\n+\n+  void heap_region_iterate(ShenandoahHeapRegionClosure* cl) override;\n+\n+  void set_concurrent_mark_in_progress(bool in_progress) override;\n@@ -66,1 +69,1 @@\n-  bool is_concurrent_mark_in_progress();\n+  bool is_concurrent_mark_in_progress() override;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.hpp","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/shenandoah\/mode\/shenandoahGenerationalMode.hpp\"\n@@ -270,0 +271,1 @@\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n@@ -286,0 +288,5 @@\n+  if (!heap->is_in_active_generation(referent)) {\n+    log_trace(gc,ref)(\"Referent outside of active generation: \" PTR_FORMAT, p2i(referent));\n+    return false;\n+  }\n+\n@@ -374,1 +381,2 @@\n-  log_trace(gc, ref)(\"Encountered Reference: \" PTR_FORMAT \" (%s)\", p2i(reference), reference_type_name(type));\n+  log_trace(gc, ref)(\"Encountered Reference: \" PTR_FORMAT \" (%s, %s)\",\n+          p2i(reference), reference_type_name(type), affiliation_name(reference));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahReferenceProcessor.cpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-  ShenandoahReferenceProcessor* rp = heap->ref_processor();\n+  ShenandoahReferenceProcessor* rp = heap->active_generation()->ref_processor();\n@@ -123,1 +123,1 @@\n-  ShenandoahReferenceProcessor* rp = ShenandoahHeap::heap()->ref_processor();\n+  ShenandoahReferenceProcessor* rp = ShenandoahHeap::heap()->active_generation()->ref_processor();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahSTWMark.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -73,1 +73,1 @@\n-  _tracer->report_gc_reference_stats(_heap->ref_processor()->reference_process_stats());\n+  _tracer->report_gc_reference_stats(_generation->ref_processor()->reference_process_stats());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahUtils.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -130,0 +130,4 @@\n+\n+bool ShenandoahYoungGeneration::contains(oop obj) const {\n+  return ShenandoahHeap::heap()->is_in_young(obj);\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahYoungGeneration.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-  virtual const char* name() const;\n+  const char* name() const override;\n@@ -39,2 +39,2 @@\n-  virtual void set_concurrent_mark_in_progress(bool in_progress);\n-  virtual void parallel_heap_region_iterate(ShenandoahHeapRegionClosure* cl);\n+  void set_concurrent_mark_in_progress(bool in_progress) override;\n+  void parallel_heap_region_iterate(ShenandoahHeapRegionClosure* cl) override;\n@@ -42,1 +42,1 @@\n-  void heap_region_iterate(ShenandoahHeapRegionClosure* cl);\n+  void heap_region_iterate(ShenandoahHeapRegionClosure* cl) override;\n@@ -44,1 +44,2 @@\n-  bool contains(ShenandoahHeapRegion* region) const;\n+  bool contains(ShenandoahHeapRegion* region) const override;\n+  bool contains(oop obj) const override;\n@@ -53,1 +54,1 @@\n-  ShenandoahObjToScanQueueSet* old_gen_task_queues() const {\n+  ShenandoahObjToScanQueueSet* old_gen_task_queues() const override {\n@@ -57,1 +58,1 @@\n-  virtual void reserve_task_queues(uint workers);\n+  void reserve_task_queues(uint workers) override;\n@@ -60,1 +61,1 @@\n-  bool is_concurrent_mark_in_progress();\n+  bool is_concurrent_mark_in_progress() override;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahYoungGeneration.hpp","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"}]}