{"files":[{"patch":"@@ -248,1 +248,1 @@\n-  \/\/       accomodation to give us enough runway to recalibrate our \"average allocation rate\".\n+  \/\/       accommodation to give us enough runway to recalibrate our \"average allocation rate\".\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -71,2 +71,0 @@\n-  \/\/ This counts bytes of memory used by humongous regions to be promoted in place.\n-  size_t humongous_bytes_promoted = 0;\n@@ -144,1 +142,0 @@\n-          humongous_bytes_promoted += obj->size() * HeapWordSize;\n@@ -154,1 +151,0 @@\n-  heap->reserve_promotable_humongous_usage(humongous_bytes_promoted);\n@@ -156,1 +152,0 @@\n-  heap->reserve_promotable_regular_usage(regular_regions_promoted_usage);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahGenerationalHeuristics.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -110,6 +110,0 @@\n-  \/\/ A private work method invoked by the public compute_tenuring_threshold() method.\n-  \/\/ This uses the data in the ShenandoahAgeCensus object's _global_age_table and the\n-  \/\/ current _epoch to compute a new tenuring threshold, which will be remembered\n-  \/\/ until the next invocation of compute_tenuring_threshold.\n-  uint compute_tenuring_threshold_work();\n-\n@@ -124,0 +118,4 @@\n+\n+  \/\/ This uses the data in the ShenandoahAgeCensus object's _global_age_table and the\n+  \/\/ current _epoch to compute a new tenuring threshold, which will be remembered\n+  \/\/ until the next invocation of compute_tenuring_threshold.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAgeCensus.hpp","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -82,4 +82,0 @@\n-  CardValue* read_byte_map_base() {\n-    return _read_byte_map_base;\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCardTable.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -97,1 +97,0 @@\n-    _young_region_count++;\n@@ -104,1 +103,0 @@\n-    _old_region_count++;\n@@ -107,1 +105,0 @@\n-    _old_available_bytes_collected += free;\n@@ -138,1 +135,0 @@\n-  _young_region_count = 0;\n@@ -141,2 +137,0 @@\n-\n-  _old_region_count = 0;\n@@ -146,1 +140,0 @@\n-  _old_available_bytes_collected = 0;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCollectionSet.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -57,3 +57,0 @@\n-  size_t                _young_region_count;\n-  size_t                _old_region_count;\n-\n@@ -71,1 +68,0 @@\n-  size_t                _old_available_bytes_collected;\n@@ -103,6 +99,0 @@\n-  \/\/ This represents total amount of work to be performed by evacuation, including evacuations to young, to old,\n-  \/\/ and promotions from young to old.  This equals get_young_bytes_reserved_for_evacuation() plus\n-  \/\/ get_old_bytes_reserved_for_evacuation().\n-  \/\/ TODO: Seems unused.\n-  inline size_t get_bytes_reserved_for_evacuation();\n-\n@@ -117,5 +107,0 @@\n-  size_t get_old_available_bytes_collected() { return _old_available_bytes_collected; }\n-\n-  inline size_t get_old_region_count();\n-  inline size_t get_young_region_count();\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCollectionSet.hpp","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -69,12 +69,0 @@\n-size_t ShenandoahCollectionSet::get_bytes_reserved_for_evacuation() {\n-  return _young_bytes_to_evacuate + _old_bytes_to_evacuate;\n-}\n-\n-size_t ShenandoahCollectionSet::get_old_region_count() {\n-  return _old_region_count;\n-}\n-\n-size_t ShenandoahCollectionSet::get_young_region_count() {\n-  return _young_region_count;\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCollectionSet.inline.hpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -260,5 +260,0 @@\n-\n-      size_t old_usage_before_evac = heap->capture_old_usage(0);\n-      size_t old_usage_now = old_gen->used();\n-      size_t promoted_bytes = old_usage_now - old_usage_before_evac;\n-      heap->set_previous_promotion(promoted_bytes);\n@@ -267,1 +262,0 @@\n-      heap->reset_old_evac_expended();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -91,1 +91,0 @@\n-  ShenandoahSharedFlag _humongous_alloc_failure_gc;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -335,1 +335,0 @@\n-    heap->reset_old_evac_expended();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahDegeneratedGC.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -898,1 +898,1 @@\n-  };\n+  }\n@@ -974,9 +974,0 @@\n-bool ShenandoahFreeSet::has_alloc_capacity(size_t idx) const {\n-  ShenandoahHeapRegion* r = _heap->get_region(idx);\n-  return alloc_capacity(r) > 0;\n-}\n-\n-bool ShenandoahFreeSet::has_no_alloc_capacity(ShenandoahHeapRegion *r) const {\n-  return alloc_capacity(r) == 0;\n-}\n-\n@@ -1201,1 +1192,1 @@\n-    young_capacity -= xfer_bytes;;\n+    young_capacity -= xfer_bytes;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":2,"deletions":11,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -175,8 +175,0 @@\n-  void adjust_bounds_for_additional_old_collector_free_region(size_t idx);\n-\n-  void recompute_bounds();\n-  void adjust_bounds();\n-  bool touches_bounds(size_t num) const;\n-\n-  \/\/ Used of free set represents the amount of is_mutator_free set that has been consumed since most recent rebuild.\n-  void increase_used(size_t amount);\n@@ -189,1 +181,0 @@\n-  bool has_alloc_capacity(size_t idx) const;\n@@ -191,1 +182,0 @@\n-  bool has_no_alloc_capacity(ShenandoahHeapRegion *r) const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.hpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -212,1 +212,0 @@\n-    heap->reset_old_evac_expended();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -606,1 +606,1 @@\n-      \/\/ is to choose the youngest age that demonstrates no \"significant\" futher loss of population since the previous\n+      \/\/ is to choose the youngest age that demonstrates no \"significant\" further loss of population since the previous\n@@ -608,1 +608,1 @@\n-      \/\/ samples, whereas we expect to observe exponetial population decay for ages younger than the tenure age.\n+      \/\/ samples, whereas we expect to observe exponential population decay for ages younger than the tenure age.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -138,4 +138,0 @@\n-  void set_soft_max_capacity(size_t soft_max_capacity) {\n-    _soft_max_capacity = soft_max_capacity;\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -600,1 +600,0 @@\n-  _old_evac_expended(0),\n@@ -602,2 +601,0 @@\n-  _captured_old_usage(0),\n-  _previous_promotion(0),\n@@ -620,1 +617,1 @@\n-  _generation_sizer(&_mmu_tracker),\n+  _generation_sizer(),\n@@ -976,1 +973,1 @@\n-      last_report_epoch = gc_id;;\n+      last_report_epoch = gc_id;\n@@ -1183,4 +1180,0 @@\n-bool ShenandoahHeap::is_old_gc_active() {\n-  return _old_generation->state() != ShenandoahOldGeneration::IDLE;\n-}\n-\n@@ -1930,31 +1923,0 @@\n-class ShenandoahTagGCLABClosure : public ThreadClosure {\n-public:\n-  void do_thread(Thread* thread) {\n-    PLAB* gclab = ShenandoahThreadLocalData::gclab(thread);\n-    assert(gclab != nullptr, \"GCLAB should be initialized for %s\", thread->name());\n-    if (gclab->words_remaining() > 0) {\n-      ShenandoahHeapRegion* r = ShenandoahHeap::heap()->heap_region_containing(gclab->allocate(0));\n-      r->set_young_lab_flag();\n-    }\n-  }\n-};\n-\n-void ShenandoahHeap::set_young_lab_region_flags() {\n-  if (!UseTLAB) {\n-    return;\n-  }\n-  for (size_t i = 0; i < _num_regions; i++) {\n-    _regions[i]->clear_young_lab_flags();\n-  }\n-  ShenandoahTagGCLABClosure cl;\n-  workers()->threads_do(&cl);\n-  for (JavaThreadIteratorWithHandle jtiwh; JavaThread *t = jtiwh.next(); ) {\n-    cl.do_thread(t);\n-    ThreadLocalAllocBuffer& tlab = t->tlab();\n-    if (tlab.end() != nullptr) {\n-      ShenandoahHeapRegion* r = heap_region_containing(tlab.start());\n-      r->set_young_lab_flag();\n-    }\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":2,"deletions":40,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -226,8 +226,6 @@\n-           size_t _initial_size;\n-           size_t _minimum_size;\n-           size_t _promotion_potential;\n-           size_t _pad_for_promote_in_place;    \/\/ bytes of filler\n-           size_t _promotable_humongous_regions;\n-           size_t _promotable_humongous_usage;\n-           size_t _regular_regions_promoted_in_place;\n-           size_t _regular_usage_promoted_in_place;\n+  size_t _initial_size;\n+  size_t _minimum_size;\n+  size_t _promotion_potential;\n+  size_t _pad_for_promote_in_place;    \/\/ bytes of filler\n+  size_t _promotable_humongous_regions;\n+  size_t _regular_regions_promoted_in_place;\n@@ -368,3 +366,0 @@\n-  \/\/ How many full-gc cycles have been completed?\n-  volatile size_t _completed_fullgc_cycles;\n-\n@@ -374,3 +369,0 @@\n-  \/\/ Allocation of old GCLABs (aka PLABs) assures that _old_evac_expended + request-size < _old_evac_reserved.  If the allocation\n-  \/\/  is authorized, increment _old_evac_expended by request size.  This allocation ignores old_gen->available().\n-\n@@ -378,2 +370,0 @@\n-  volatile size_t _old_evac_expended;  \/\/ Bytes of old-gen memory expended on old-gen evacuations\n-\n@@ -382,4 +372,0 @@\n-  size_t _captured_old_usage;          \/\/ What was old usage (bytes) when last captured?\n-\n-  size_t _previous_promotion;          \/\/ Bytes promoted during previous evacuation\n-\n@@ -447,4 +433,0 @@\n-  inline size_t capture_old_usage(size_t usage);\n-  inline void set_previous_promotion(size_t promoted_bytes);\n-  inline size_t get_previous_promotion() const;\n-\n@@ -459,1 +441,0 @@\n-  inline void reserve_promotable_humongous_usage(size_t bytes) { _promotable_humongous_usage = bytes; }\n@@ -461,1 +442,0 @@\n-  inline void reserve_promotable_regular_usage(size_t used_bytes) { _regular_usage_promoted_in_place = used_bytes; }\n@@ -464,1 +444,0 @@\n-  inline size_t get_promotable_humongous_usage() { return _promotable_humongous_usage; }\n@@ -466,1 +445,0 @@\n-  inline size_t get_regular_usage_promoted_in_place() { return _regular_usage_promoted_in_place; }\n@@ -483,4 +461,0 @@\n-  inline void reset_old_evac_expended();\n-  inline size_t expend_old_evac(size_t increment);\n-  inline size_t get_old_evac_expended();\n-\n@@ -671,1 +645,0 @@\n-  inline void set_affiliation(size_t index, ShenandoahAffiliation new_affiliation);\n@@ -760,2 +733,0 @@\n-  void set_young_lab_region_flags();\n-\n@@ -858,2 +829,0 @@\n-  void dirty_cards(HeapWord* start, HeapWord* end);\n-  void clear_cards(HeapWord* start, HeapWord* end);\n@@ -864,1 +833,0 @@\n-  bool is_old_gc_active();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":6,"deletions":38,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -665,7 +665,0 @@\n-inline void ShenandoahHeap::set_affiliation(size_t index, ShenandoahAffiliation new_affiliation) {\n-#ifdef ASSERT\n-  assert_lock_for_affiliation(region_affiliation(index), new_affiliation);\n-#endif\n-  _affiliations[index] = (uint8_t) new_affiliation;\n-}\n-\n@@ -766,16 +759,0 @@\n-\/\/ returns previous value\n-size_t ShenandoahHeap::capture_old_usage(size_t old_usage) {\n-  size_t previous_value = _captured_old_usage;\n-  _captured_old_usage = old_usage;\n-  return previous_value;\n-}\n-\n-void ShenandoahHeap::set_previous_promotion(size_t promoted_bytes) {\n-  shenandoah_assert_heaplocked();\n-  _previous_promotion = promoted_bytes;\n-}\n-\n-size_t ShenandoahHeap::get_previous_promotion() const {\n-  return _previous_promotion;\n-}\n-\n@@ -800,12 +777,0 @@\n-inline void ShenandoahHeap::reset_old_evac_expended() {\n-  Atomic::store(&_old_evac_expended, (size_t) 0);\n-}\n-\n-inline size_t ShenandoahHeap::expend_old_evac(size_t increment) {\n-  return Atomic::add(&_old_evac_expended, increment);\n-}\n-\n-inline size_t ShenandoahHeap::get_old_evac_expended() {\n-  return Atomic::load(&_old_evac_expended);\n-}\n-\n@@ -993,12 +958,0 @@\n-inline void ShenandoahHeap::dirty_cards(HeapWord* start, HeapWord* end) {\n-  assert(mode()->is_generational(), \"Should only be used for generational mode\");\n-  size_t words = pointer_delta(end, start);\n-  _card_scan->mark_range_as_dirty(start, words);\n-}\n-\n-inline void ShenandoahHeap::clear_cards(HeapWord* start, HeapWord* end) {\n-  assert(mode()->is_generational(), \"Should only be used for generational mode\");\n-  size_t words = pointer_delta(end, start);\n-  _card_scan->mark_range_as_clean(start, words);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.inline.hpp","additions":0,"deletions":47,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -80,1 +80,0 @@\n-  _has_young_lab(false),\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -219,4 +219,0 @@\n-  void clear_young_lab_flags();\n-  void set_young_lab_flag();\n-  bool has_young_lab_flag();\n-\n@@ -258,2 +254,0 @@\n-  bool _has_young_lab;\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -224,12 +224,0 @@\n-inline void ShenandoahHeapRegion::clear_young_lab_flags() {\n-  _has_young_lab = false;\n-}\n-\n-inline void ShenandoahHeapRegion::set_young_lab_flag() {\n-  _has_young_lab = true;\n-}\n-\n-inline bool ShenandoahHeapRegion::has_young_lab_flag() {\n-  return _has_young_lab;\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.inline.hpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -185,1 +185,1 @@\n-  double _most_recent_periodic_time_stamp = os::elapsedTime();\n+  _most_recent_periodic_time_stamp = os::elapsedTime();\n@@ -190,1 +190,1 @@\n-ShenandoahGenerationSizer::ShenandoahGenerationSizer(ShenandoahMmuTracker* mmu_tracker)\n+ShenandoahGenerationSizer::ShenandoahGenerationSizer()\n@@ -192,1 +192,0 @@\n-    _use_adaptive_sizing(true),\n@@ -194,3 +193,1 @@\n-    _max_desired_young_regions(0),\n-    _resize_increment(double(YoungGenerationSizeIncrement) \/ 100.0),\n-    _mmu_tracker(mmu_tracker) {\n+    _max_desired_young_regions(0) {\n@@ -203,1 +200,0 @@\n-      _use_adaptive_sizing = false;\n@@ -222,1 +218,0 @@\n-      _use_adaptive_sizing = _min_desired_young_regions != _max_desired_young_regions;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMmuTracker.cpp","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -118,4 +118,0 @@\n-  \/\/ False when using a fixed young generation size due to command-line options,\n-  \/\/ true otherwise.\n-  bool _use_adaptive_sizing;\n-\n@@ -125,3 +121,0 @@\n-  double _resize_increment;\n-  ShenandoahMmuTracker* _mmu_tracker;\n-\n@@ -136,1 +129,1 @@\n-  explicit ShenandoahGenerationSizer(ShenandoahMmuTracker* mmu_tracker);\n+  ShenandoahGenerationSizer();\n@@ -154,4 +147,0 @@\n-  bool use_adaptive_sizing() const {\n-    return _use_adaptive_sizing;\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMmuTracker.hpp","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -458,1 +458,1 @@\n-void ShenandoahReferenceProcessor::process_references(ShenandoahRefProcThreadLocal& refproc_data, uint worker_id) {;\n+void ShenandoahReferenceProcessor::process_references(ShenandoahRefProcThreadLocal& refproc_data, uint worker_id) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahReferenceProcessor.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -318,5 +318,0 @@\n-\n-ShenandoahVerifyNoYoungRefsClosure::ShenandoahVerifyNoYoungRefsClosure():\n-  _heap(ShenandoahHeap::heap()) {\n-  assert(_heap->mode()->is_generational(), \"Don't use when non-generational\");\n-}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -220,1 +220,0 @@\n-  ~ShenandoahDirectCardMarkRememberedSet();\n@@ -233,1 +232,0 @@\n-  inline void mark_read_card_as_clean(size_t card_index);\n@@ -824,1 +822,0 @@\n-  void mark_read_card_as_clean(size_t card_index) { _rs->mark_read_card_clean(card_index); }\n@@ -1070,11 +1067,0 @@\n-\/\/ Verify that the oop doesn't point into the young generation\n-class ShenandoahVerifyNoYoungRefsClosure: public BasicOopIterateClosure {\n-  ShenandoahHeap* _heap;\n-  template<class T> void work(T* p);\n-\n- public:\n-  ShenandoahVerifyNoYoungRefsClosure();\n-\n-  virtual void do_oop(narrowOop* p) { work(p); }\n-  virtual void do_oop(oop* p)       { work(p); }\n-};\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.hpp","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -140,6 +140,0 @@\n-inline void\n-ShenandoahDirectCardMarkRememberedSet::mark_read_card_as_clean(size_t index) {\n-  CardValue* bp = &(_card_table->read_byte_map())[index];\n-  bp[0] = CardTable::clean_card_val();\n-}\n-\n@@ -358,1 +352,1 @@\n-ShenandoahScanRemembered<RememberedSet>::card_index_for_addr(HeapWord *p) { return _rs->card_index_for_addr(p); };\n+ShenandoahScanRemembered<RememberedSet>::card_index_for_addr(HeapWord *p) { return _rs->card_index_for_addr(p); }\n@@ -1018,9 +1012,0 @@\n-template<class T>\n-inline void ShenandoahVerifyNoYoungRefsClosure::work(T* p) {\n-  T o = RawAccess<>::oop_load(p);\n-  if (!CompressedOops::is_null(o)) {\n-    oop obj = CompressedOops::decode_not_null(o);\n-    assert(!_heap->is_in_young(obj), \"Found a young ref\");\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.inline.hpp","additions":1,"deletions":16,"binary":false,"changes":17,"status":"modified"}]}