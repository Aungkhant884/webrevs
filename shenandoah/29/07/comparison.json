{"files":[{"patch":"@@ -0,0 +1,305 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.hpp\"\n+#include \"gc\/shenandoah\/heuristics\/shenandoahAdaptiveOldHeuristics.hpp\"\n+#include \"gc\/shenandoah\/shenandoahCollectionSet.hpp\"\n+#include \"gc\/shenandoah\/shenandoahFreeSet.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGeneration.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeapRegion.inline.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"logging\/logTag.hpp\"\n+#include \"utilities\/quickSort.hpp\"\n+\n+\/\/ These constants are used to adjust the margin of error for the moving\n+\/\/ average of the allocation rate and cycle time. The units are standard\n+\/\/ deviations.\n+const double ShenandoahAdaptiveOldHeuristics::FULL_PENALTY_SD = 0.2;\n+const double ShenandoahAdaptiveOldHeuristics::DEGENERATE_PENALTY_SD = 0.1;\n+\n+\/\/ These are used to decide if we want to make any adjustments at all\n+\/\/ at the end of a successful concurrent cycle.\n+const double ShenandoahAdaptiveOldHeuristics::LOWEST_EXPECTED_AVAILABLE_AT_END = -0.5;\n+const double ShenandoahAdaptiveOldHeuristics::HIGHEST_EXPECTED_AVAILABLE_AT_END = 0.5;\n+\n+\/\/ These values are the confidence interval expressed as standard deviations.\n+\/\/ At the minimum confidence level, there is a 25% chance that the true value of\n+\/\/ the estimate (average cycle time or allocation rate) is not more than\n+\/\/ MINIMUM_CONFIDENCE standard deviations away from our estimate. Similarly, the\n+\/\/ MAXIMUM_CONFIDENCE interval here means there is a one in a thousand chance\n+\/\/ that the true value of our estimate is outside the interval. These are used\n+\/\/ as bounds on the adjustments applied at the outcome of a GC cycle.\n+const double ShenandoahAdaptiveOldHeuristics::MINIMUM_CONFIDENCE = 0.319; \/\/ 25%\n+const double ShenandoahAdaptiveOldHeuristics::MAXIMUM_CONFIDENCE = 3.291; \/\/ 99.9%\n+\n+ShenandoahAdaptiveOldHeuristics::ShenandoahAdaptiveOldHeuristics(ShenandoahGeneration* generation) :\n+  ShenandoahOldHeuristics(generation),\n+  _margin_of_error_sd(ShenandoahAdaptiveInitialConfidence),\n+  _spike_threshold_sd(ShenandoahAdaptiveInitialSpikeThreshold),\n+  _last_trigger(OTHER) { }\n+\n+ShenandoahAdaptiveOldHeuristics::~ShenandoahAdaptiveOldHeuristics() {}\n+\n+void ShenandoahAdaptiveOldHeuristics::choose_collection_set_from_regiondata(ShenandoahCollectionSet* cset,\n+                                                                            RegionData* data, size_t size,\n+                                                                            size_t actual_free) {\n+  size_t garbage_threshold = ShenandoahHeapRegion::region_size_bytes() * ShenandoahGarbageThreshold \/ 100;\n+\n+  \/\/ The logic for cset selection in adaptive is as follows:\n+  \/\/\n+  \/\/   1. We cannot get cset larger than available free space. Otherwise we guarantee OOME\n+  \/\/      during evacuation, and thus guarantee full GC. In practice, we also want to let\n+  \/\/      application to allocate something. This is why we limit CSet to some fraction of\n+  \/\/      available space. In non-overloaded heap, max_cset would contain all plausible candidates\n+  \/\/      over garbage threshold.\n+  \/\/\n+  \/\/   2. We should not get cset too low so that free threshold would not be met right\n+  \/\/      after the cycle. Otherwise we get back-to-back cycles for no reason if heap is\n+  \/\/      too fragmented. In non-overloaded non-fragmented heap min_garbage would be around zero.\n+  \/\/\n+  \/\/ Therefore, we start by sorting the regions by garbage. Then we unconditionally add the best candidates\n+  \/\/ before we meet min_garbage. Then we add all candidates that fit with a garbage threshold before\n+  \/\/ we hit max_cset. When max_cset is hit, we terminate the cset selection. Note that in this scheme,\n+  \/\/ ShenandoahGarbageThreshold is the soft threshold which would be ignored until min_garbage is hit.\n+\n+  size_t capacity    = _generation->soft_max_capacity();\n+  size_t max_cset    = (size_t)((1.0 * capacity \/ 100 * ShenandoahEvacReserve) \/ ShenandoahEvacWaste);\n+  size_t free_target = (capacity \/ 100 * ShenandoahMinFreeThreshold) + max_cset;\n+  size_t min_garbage = (free_target > actual_free ? (free_target - actual_free) : 0);\n+\n+  log_info(gc, ergo)(\"Adaptive CSet Selection. Target Free: \" SIZE_FORMAT \"%s, Actual Free: \"\n+                     SIZE_FORMAT \"%s, Max CSet: \" SIZE_FORMAT \"%s, Min Garbage: \" SIZE_FORMAT \"%s\",\n+                     byte_size_in_proper_unit(free_target), proper_unit_for_byte_size(free_target),\n+                     byte_size_in_proper_unit(actual_free), proper_unit_for_byte_size(actual_free),\n+                     byte_size_in_proper_unit(max_cset),    proper_unit_for_byte_size(max_cset),\n+                     byte_size_in_proper_unit(min_garbage), proper_unit_for_byte_size(min_garbage));\n+\n+\n+  \/\/ Better select garbage-first regions\n+  QuickSort::sort<RegionData>(data, (int)size, compare_by_garbage, false);\n+\n+  size_t cur_cset = 0;\n+  size_t cur_garbage = 0;\n+\n+  for (size_t idx = 0; idx < size; idx++) {\n+    ShenandoahHeapRegion* r = data[idx]._region;\n+\n+    size_t new_cset    = cur_cset + r->get_live_data_bytes();\n+    size_t new_garbage = cur_garbage + r->garbage();\n+\n+    if (new_cset > max_cset) {\n+      break;\n+    }\n+\n+    if ((new_garbage < min_garbage) || (r->garbage() > garbage_threshold)) {\n+      cset->add_region(r);\n+      cur_cset = new_cset;\n+      cur_garbage = new_garbage;\n+    }\n+  }\n+}\n+\n+void ShenandoahAdaptiveOldHeuristics::record_cycle_start() {\n+  ShenandoahHeuristics::record_cycle_start();\n+  _allocation_rate.allocation_counter_reset();\n+}\n+\n+void ShenandoahAdaptiveOldHeuristics::record_success_concurrent() {\n+  ShenandoahHeuristics::record_success_concurrent();\n+\n+  size_t available = ShenandoahHeap::heap()->free_set()->available();\n+\n+  _available.add(available);\n+  double z_score = 0.0;\n+  if (_available.sd() > 0) {\n+    z_score = (available - _available.avg()) \/ _available.sd();\n+  }\n+\n+  log_debug(gc, ergo)(\"Available: \" SIZE_FORMAT \" %sB, z-score=%.3f. Average available: %.1f %sB +\/- %.1f %sB.\",\n+                      byte_size_in_proper_unit(available), proper_unit_for_byte_size(available),\n+                      z_score,\n+                      byte_size_in_proper_unit(_available.avg()), proper_unit_for_byte_size(_available.avg()),\n+                      byte_size_in_proper_unit(_available.sd()), proper_unit_for_byte_size(_available.sd()));\n+\n+  \/\/ In the case when a concurrent GC cycle completes successfully but with an\n+  \/\/ unusually small amount of available memory we will adjust our trigger\n+  \/\/ parameters so that they are more likely to initiate a new cycle.\n+  \/\/ Conversely, when a GC cycle results in an above average amount of available\n+  \/\/ memory, we will adjust the trigger parameters to be less likely to initiate\n+  \/\/ a GC cycle.\n+  \/\/\n+  \/\/ The z-score we've computed is in no way statistically related to the\n+  \/\/ trigger parameters, but it has the nice property that worse z-scores for\n+  \/\/ available memory indicate making larger adjustments to the trigger\n+  \/\/ parameters. It also results in fewer adjustments as the application\n+  \/\/ stabilizes.\n+  \/\/\n+  \/\/ In order to avoid making endless and likely unnecessary adjustments to the\n+  \/\/ trigger parameters, the change in available memory (with respect to the\n+  \/\/ average) at the end of a cycle must be beyond these threshold values.\n+  if (z_score < LOWEST_EXPECTED_AVAILABLE_AT_END ||\n+      z_score > HIGHEST_EXPECTED_AVAILABLE_AT_END) {\n+    \/\/ The sign is flipped because a negative z-score indicates that the\n+    \/\/ available memory at the end of the cycle is below average. Positive\n+    \/\/ adjustments make the triggers more sensitive (i.e., more likely to fire).\n+    \/\/ The z-score also gives us a measure of just how far below normal. This\n+    \/\/ property allows us to adjust the trigger parameters proportionally.\n+    \/\/\n+    \/\/ The `100` here is used to attenuate the size of our adjustments. This\n+    \/\/ number was chosen empirically. It also means the adjustments at the end of\n+    \/\/ a concurrent cycle are an order of magnitude smaller than the adjustments\n+    \/\/ made for a degenerated or full GC cycle (which themselves were also\n+    \/\/ chosen empirically).\n+    adjust_last_trigger_parameters(z_score \/ -100);\n+  }\n+}\n+\n+void ShenandoahAdaptiveOldHeuristics::record_success_degenerated() {\n+  ShenandoahHeuristics::record_success_degenerated();\n+  \/\/ Adjust both trigger's parameters in the case of a degenerated GC because\n+  \/\/ either of them should have triggered earlier to avoid this case.\n+  adjust_margin_of_error(DEGENERATE_PENALTY_SD);\n+  adjust_spike_threshold(DEGENERATE_PENALTY_SD);\n+}\n+\n+void ShenandoahAdaptiveOldHeuristics::record_success_full() {\n+  ShenandoahHeuristics::record_success_full();\n+  \/\/ Adjust both trigger's parameters in the case of a full GC because\n+  \/\/ either of them should have triggered earlier to avoid this case.\n+  adjust_margin_of_error(FULL_PENALTY_SD);\n+  adjust_spike_threshold(FULL_PENALTY_SD);\n+}\n+\n+static double saturate(double value, double min, double max) {\n+  return MAX2(MIN2(value, max), min);\n+}\n+\n+bool ShenandoahAdaptiveOldHeuristics::should_start_gc() {\n+  size_t max_capacity = _generation->max_capacity();\n+  size_t capacity = _generation->soft_max_capacity();\n+  size_t available = _generation->available();\n+  size_t allocated = _generation->bytes_allocated_since_gc_start();\n+\n+  \/\/ Make sure the code below treats available without the soft tail.\n+  size_t soft_tail = max_capacity - capacity;\n+  available = (available > soft_tail) ? (available - soft_tail) : 0;\n+\n+  \/\/ Track allocation rate even if we decide to start a cycle for other reasons.\n+  double rate = _allocation_rate.sample(allocated);\n+  _last_trigger = OTHER;\n+\n+  size_t min_threshold = capacity \/ 100 * ShenandoahMinFreeThreshold;\n+  if (available < min_threshold) {\n+    log_info(gc)(\"Trigger (%s): Free (\" SIZE_FORMAT \"%s) is below minimum threshold (\" SIZE_FORMAT \"%s)\",\n+                 _generation->name(),\n+                 byte_size_in_proper_unit(available),     proper_unit_for_byte_size(available),\n+                 byte_size_in_proper_unit(min_threshold), proper_unit_for_byte_size(min_threshold));\n+    return true;\n+  }\n+\n+  \/\/ Check if are need to learn a bit about the application\n+  const size_t max_learn = ShenandoahLearningSteps;\n+  if (_gc_times_learned < max_learn) {\n+    size_t init_threshold = capacity \/ 100 * ShenandoahInitFreeThreshold;\n+    if (available < init_threshold) {\n+      log_info(gc)(\"Trigger (%s): Learning \" SIZE_FORMAT \" of \" SIZE_FORMAT \". Free (\" SIZE_FORMAT \"%s) is below initial threshold (\" SIZE_FORMAT \"%s)\",\n+                   _generation->name(), _gc_times_learned + 1, max_learn,\n+                   byte_size_in_proper_unit(available),      proper_unit_for_byte_size(available),\n+                   byte_size_in_proper_unit(init_threshold), proper_unit_for_byte_size(init_threshold));\n+      return true;\n+    }\n+  }\n+\n+  \/\/ Check if allocation headroom is still okay. This also factors in:\n+  \/\/   1. Some space to absorb allocation spikes\n+  \/\/   2. Accumulated penalties from Degenerated and Full GC\n+  size_t allocation_headroom = available;\n+\n+  size_t spike_headroom = capacity \/ 100 * ShenandoahAllocSpikeFactor;\n+  size_t penalties      = capacity \/ 100 * _gc_time_penalties;\n+\n+  allocation_headroom -= MIN2(allocation_headroom, spike_headroom);\n+  allocation_headroom -= MIN2(allocation_headroom, penalties);\n+\n+  double avg_cycle_time = _gc_time_history->davg() + (_margin_of_error_sd * _gc_time_history->dsd());\n+  double avg_alloc_rate = _allocation_rate.upper_bound(_margin_of_error_sd);\n+  if (avg_cycle_time > allocation_headroom \/ avg_alloc_rate) {\n+    log_info(gc)(\"Trigger (%s): Average GC time (%.2f ms) is above the time for average allocation rate (%.0f %sB\/s) to deplete free headroom (\" SIZE_FORMAT \"%s) (margin of error = %.2f)\",\n+                 _generation->name(), avg_cycle_time * 1000,\n+                 byte_size_in_proper_unit(avg_alloc_rate), proper_unit_for_byte_size(avg_alloc_rate),\n+                 byte_size_in_proper_unit(allocation_headroom), proper_unit_for_byte_size(allocation_headroom),\n+                 _margin_of_error_sd);\n+\n+    log_info(gc, ergo)(\"Free headroom: \" SIZE_FORMAT \"%s (free) - \" SIZE_FORMAT \"%s (spike) - \" SIZE_FORMAT \"%s (penalties) = \" SIZE_FORMAT \"%s\",\n+                       byte_size_in_proper_unit(available),           proper_unit_for_byte_size(available),\n+                       byte_size_in_proper_unit(spike_headroom),      proper_unit_for_byte_size(spike_headroom),\n+                       byte_size_in_proper_unit(penalties),           proper_unit_for_byte_size(penalties),\n+                       byte_size_in_proper_unit(allocation_headroom), proper_unit_for_byte_size(allocation_headroom));\n+\n+    _last_trigger = RATE;\n+    return true;\n+  }\n+\n+  bool is_spiking = _allocation_rate.is_spiking(rate, _spike_threshold_sd);\n+  if (is_spiking && avg_cycle_time > allocation_headroom \/ rate) {\n+    log_info(gc)(\"Trigger (%s): Average GC time (%.2f ms) is above the time for instantaneous allocation rate (%.0f %sB\/s) to deplete free headroom (\" SIZE_FORMAT \"%s) (spike threshold = %.2f)\",\n+                 _generation->name(), avg_cycle_time * 1000,\n+                 byte_size_in_proper_unit(rate), proper_unit_for_byte_size(rate),\n+                 byte_size_in_proper_unit(allocation_headroom), proper_unit_for_byte_size(allocation_headroom),\n+                 _spike_threshold_sd);\n+    _last_trigger = SPIKE;\n+    return true;\n+  }\n+\n+  return ShenandoahHeuristics::should_start_gc();\n+}\n+\n+void ShenandoahAdaptiveOldHeuristics::adjust_last_trigger_parameters(double amount) {\n+  switch (_last_trigger) {\n+    case RATE:\n+      adjust_margin_of_error(amount);\n+      break;\n+    case SPIKE:\n+      adjust_spike_threshold(amount);\n+      break;\n+    case OTHER:\n+      \/\/ nothing to adjust here.\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+  }\n+}\n+\n+void ShenandoahAdaptiveOldHeuristics::adjust_margin_of_error(double amount) {\n+  _margin_of_error_sd = saturate(_margin_of_error_sd + amount, MINIMUM_CONFIDENCE, MAXIMUM_CONFIDENCE);\n+  log_debug(gc, ergo)(\"Margin of error now %.2f\", _margin_of_error_sd);\n+}\n+\n+void ShenandoahAdaptiveOldHeuristics::adjust_spike_threshold(double amount) {\n+  _spike_threshold_sd = saturate(_spike_threshold_sd - amount, MINIMUM_CONFIDENCE, MAXIMUM_CONFIDENCE);\n+  log_debug(gc, ergo)(\"Spike threshold now: %.2f\", _spike_threshold_sd);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveOldHeuristics.cpp","additions":305,"deletions":0,"binary":false,"changes":305,"status":"added"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHENANDOAH_HEURISTICS_SHENANDOAHADAPTIVEOLDHEURISTICS_HPP\n+#define SHARE_GC_SHENANDOAH_HEURISTICS_SHENANDOAHADAPTIVEOLDHEURISTICS_HPP\n+\n+#include \"gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.hpp\"\n+#include \"gc\/shenandoah\/shenandoahPhaseTimings.hpp\"\n+#include \"utilities\/numberSeq.hpp\"\n+\n+class ShenandoahAllocationRate;\n+\n+class ShenandoahAdaptiveOldHeuristics : public ShenandoahOldHeuristics {\n+public:\n+  ShenandoahAdaptiveOldHeuristics(ShenandoahGeneration* generation);\n+\n+  virtual ~ShenandoahAdaptiveOldHeuristics();\n+\n+  virtual void choose_collection_set_from_regiondata(ShenandoahCollectionSet* cset,\n+                                                     RegionData* data, size_t size,\n+                                                     size_t actual_free);\n+\n+  void record_cycle_start();\n+  void record_success_concurrent();\n+  void record_success_degenerated();\n+  void record_success_full();\n+\n+  virtual bool should_start_gc();\n+\n+  virtual const char* name()     { return \"AdaptiveOld\"; }\n+  virtual bool is_diagnostic()   { return false; }\n+  virtual bool is_experimental() { return false; }\n+\n+ private:\n+  \/\/ These are used to adjust the margin of error and the spike threshold\n+  \/\/ in response to GC cycle outcomes. These values are shared, but the\n+  \/\/ margin of error and spike threshold trend in opposite directions.\n+  const static double FULL_PENALTY_SD;\n+  const static double DEGENERATE_PENALTY_SD;\n+\n+  const static double MINIMUM_CONFIDENCE;\n+  const static double MAXIMUM_CONFIDENCE;\n+\n+  const static double LOWEST_EXPECTED_AVAILABLE_AT_END;\n+  const static double HIGHEST_EXPECTED_AVAILABLE_AT_END;\n+\n+  friend class ShenandoahAllocationRate;\n+\n+  \/\/ Used to record the last trigger that signaled to start a GC.\n+  \/\/ This itself is used to decide whether or not to adjust the margin of\n+  \/\/ error for the average cycle time and allocation rate or the allocation\n+  \/\/ spike detection threshold.\n+  enum Trigger {\n+    SPIKE, RATE, OTHER\n+  };\n+\n+  void adjust_last_trigger_parameters(double amount);\n+  void adjust_margin_of_error(double amount);\n+  void adjust_spike_threshold(double amount);\n+\n+  ShenandoahAllocationRate _allocation_rate;\n+\n+  \/\/ The margin of error expressed in standard deviations to add to our\n+  \/\/ average cycle time and allocation rate. As this value increases we\n+  \/\/ tend to over estimate the rate at which mutators will deplete the\n+  \/\/ heap. In other words, erring on the side of caution will trigger more\n+  \/\/ concurrent GCs.\n+  double _margin_of_error_sd;\n+\n+  \/\/ The allocation spike threshold is expressed in standard deviations.\n+  \/\/ If the standard deviation of the most recent sample of the allocation\n+  \/\/ rate exceeds this threshold, a GC cycle is started. As this value\n+  \/\/ decreases the sensitivity to allocation spikes increases. In other\n+  \/\/ words, lowering the spike threshold will tend to increase the number\n+  \/\/ of concurrent GCs.\n+  double _spike_threshold_sd;\n+\n+  \/\/ Remember which trigger is responsible for the last GC cycle. When the\n+  \/\/ outcome of the cycle is evaluated we will adjust the parameters for the\n+  \/\/ corresponding triggers. Note that successful outcomes will raise\n+  \/\/ the spike threshold and lower the margin of error.\n+  Trigger _last_trigger;\n+\n+  \/\/ Keep track of the available memory at the end of a GC cycle. This\n+  \/\/ establishes what is 'normal' for the application and is used as a\n+  \/\/ source of feedback to adjust trigger parameters.\n+  TruncatedSeq _available;\n+};\n+\n+#endif \/\/ SHARE_GC_SHENANDOAH_HEURISTICS_SHENANDOAHADAPTIVEOLDHEURISTICS_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveOldHeuristics.hpp","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"gc\/shenandoah\/heuristics\/shenandoahAggressiveOldHeuristics.hpp\"\n+#include \"gc\/shenandoah\/shenandoahCollectionSet.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeapRegion.inline.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"logging\/logTag.hpp\"\n+#include \"runtime\/os.hpp\"\n+\n+ShenandoahAggressiveOldHeuristics::ShenandoahAggressiveOldHeuristics(ShenandoahGeneration* generation) : ShenandoahOldHeuristics(generation) {\n+  \/\/ Do not shortcut evacuation\n+  SHENANDOAH_ERGO_OVERRIDE_DEFAULT(ShenandoahImmediateThreshold, 100);\n+\n+  \/\/ Aggressive evacuates everything, so it needs as much evac space as it can get\n+  SHENANDOAH_ERGO_ENABLE_FLAG(ShenandoahEvacReserveOverflow);\n+\n+  \/\/ If class unloading is globally enabled, aggressive does unloading even with\n+  \/\/ concurrent cycles.\n+  if (ClassUnloading) {\n+    SHENANDOAH_ERGO_OVERRIDE_DEFAULT(ShenandoahUnloadClassesFrequency, 1);\n+  }\n+}\n+\n+void ShenandoahAggressiveOldHeuristics::choose_collection_set_from_regiondata(ShenandoahCollectionSet* cset,\n+                                                                             RegionData* data, size_t size,\n+                                                                             size_t free) {\n+  for (size_t idx = 0; idx < size; idx++) {\n+    ShenandoahHeapRegion* r = data[idx]._region;\n+    if (r->garbage() > 0) {\n+      cset->add_region(r);\n+    }\n+  }\n+}\n+\n+bool ShenandoahAggressiveOldHeuristics::should_start_gc() {\n+  log_info(gc)(\"Trigger: Start next cycle immediately\");\n+  return true;\n+}\n+\n+bool ShenandoahAggressiveOldHeuristics::should_unload_classes() {\n+  if (!can_unload_classes_normal()) return false;\n+  if (has_metaspace_oom()) return true;\n+  \/\/ Randomly unload classes with 50% chance.\n+  return (os::random() & 1) == 1;\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAggressiveOldHeuristics.cpp","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHENANDOAH_HEURISTICS_SHENANDOAHAGGRESSIVEOLDHEURISTICS_HPP\n+#define SHARE_GC_SHENANDOAH_HEURISTICS_SHENANDOAHAGGRESSIVEOLDHEURISTICS_HPP\n+\n+#include \"gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.hpp\"\n+\n+class ShenandoahAggressiveOldHeuristics : public ShenandoahOldHeuristics {\n+public:\n+  ShenandoahAggressiveOldHeuristics(ShenandoahGeneration* generation);\n+\n+  virtual void choose_collection_set_from_regiondata(ShenandoahCollectionSet* cset,\n+                                                     RegionData* data, size_t size,\n+                                                     size_t free);\n+\n+  virtual bool should_start_gc();\n+\n+  virtual bool should_unload_classes();\n+\n+  virtual const char* name()     { return \"AggressiveOld\"; }\n+  virtual bool is_diagnostic()   { return true; }\n+  virtual bool is_experimental() { return false; }\n+};\n+\n+#endif \/\/ SHARE_GC_SHENANDOAH_HEURISTICS_SHENANDOAHAGGRESSIVEOLDHEURISTICS_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAggressiveOldHeuristics.hpp","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"gc\/shenandoah\/shenandoahCollectionSet.hpp\"\n+#include \"gc\/shenandoah\/heuristics\/shenandoahCompactOldHeuristics.hpp\"\n+#include \"gc\/shenandoah\/shenandoahFreeSet.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGeneration.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeapRegion.inline.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"logging\/logTag.hpp\"\n+\n+ShenandoahCompactOldHeuristics::ShenandoahCompactOldHeuristics(ShenandoahGeneration* generation) :\n+  ShenandoahOldHeuristics(generation) {\n+  SHENANDOAH_ERGO_ENABLE_FLAG(ExplicitGCInvokesConcurrent);\n+  SHENANDOAH_ERGO_ENABLE_FLAG(ShenandoahImplicitGCInvokesConcurrent);\n+  SHENANDOAH_ERGO_ENABLE_FLAG(ShenandoahUncommit);\n+  SHENANDOAH_ERGO_ENABLE_FLAG(ShenandoahAlwaysClearSoftRefs);\n+  SHENANDOAH_ERGO_OVERRIDE_DEFAULT(ShenandoahAllocationThreshold,  10);\n+  SHENANDOAH_ERGO_OVERRIDE_DEFAULT(ShenandoahImmediateThreshold,   100);\n+  SHENANDOAH_ERGO_OVERRIDE_DEFAULT(ShenandoahUncommitDelay,        1000);\n+  SHENANDOAH_ERGO_OVERRIDE_DEFAULT(ShenandoahGuaranteedGCInterval, 30000);\n+  SHENANDOAH_ERGO_OVERRIDE_DEFAULT(ShenandoahGarbageThreshold,     10);\n+}\n+\n+bool ShenandoahCompactOldHeuristics::should_start_gc() {\n+  size_t max_capacity = _generation->max_capacity();\n+  size_t capacity = _generation->soft_max_capacity();\n+  size_t available = _generation->available();\n+\n+  \/\/ Make sure the code below treats available without the soft tail.\n+  size_t soft_tail = max_capacity - capacity;\n+  available = (available > soft_tail) ? (available - soft_tail) : 0;\n+\n+  size_t threshold_bytes_allocated = capacity \/ 100 * ShenandoahAllocationThreshold;\n+  size_t min_threshold = capacity \/ 100 * ShenandoahMinFreeThreshold;\n+\n+  if (available < min_threshold) {\n+    log_info(gc)(\"Trigger: Free (\" SIZE_FORMAT \"%s) is below minimum threshold (\" SIZE_FORMAT \"%s)\",\n+                 byte_size_in_proper_unit(available),     proper_unit_for_byte_size(available),\n+                 byte_size_in_proper_unit(min_threshold), proper_unit_for_byte_size(min_threshold));\n+    return true;\n+  }\n+\n+  size_t bytes_allocated = _generation->bytes_allocated_since_gc_start();\n+  if (bytes_allocated > threshold_bytes_allocated) {\n+    log_info(gc)(\"Trigger: Allocated since last cycle (\" SIZE_FORMAT \"%s) is larger than allocation threshold (\" SIZE_FORMAT \"%s)\",\n+                 byte_size_in_proper_unit(bytes_allocated),           proper_unit_for_byte_size(bytes_allocated),\n+                 byte_size_in_proper_unit(threshold_bytes_allocated), proper_unit_for_byte_size(threshold_bytes_allocated));\n+    return true;\n+  }\n+\n+  return ShenandoahHeuristics::should_start_gc();\n+}\n+\n+void ShenandoahCompactOldHeuristics::choose_collection_set_from_regiondata(ShenandoahCollectionSet* cset,\n+                                                                           RegionData* data, size_t size,\n+                                                                           size_t actual_free) {\n+  \/\/ Do not select too large CSet that would overflow the available free space\n+  size_t max_cset = actual_free * 3 \/ 4;\n+\n+  log_info(gc, ergo)(\"CSet Selection. Actual Free: \" SIZE_FORMAT \"%s, Max CSet: \" SIZE_FORMAT \"%s\",\n+                     byte_size_in_proper_unit(actual_free), proper_unit_for_byte_size(actual_free),\n+                     byte_size_in_proper_unit(max_cset),    proper_unit_for_byte_size(max_cset));\n+\n+  size_t threshold = ShenandoahHeapRegion::region_size_bytes() * ShenandoahGarbageThreshold \/ 100;\n+\n+  size_t live_cset = 0;\n+  for (size_t idx = 0; idx < size; idx++) {\n+    ShenandoahHeapRegion* r = data[idx]._region;\n+    size_t new_cset = live_cset + r->get_live_data_bytes();\n+    if (new_cset < max_cset && r->garbage() > threshold) {\n+      live_cset = new_cset;\n+      cset->add_region(r);\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahCompactOldHeuristics.cpp","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHENANDOAH_HEURISTICS_SHENANDOAHCOMPACTOLDHEURISTICS_HPP\n+#define SHARE_GC_SHENANDOAH_HEURISTICS_SHENANDOAHCOMPACTOLDHEURISTICS_HPP\n+\n+#include \"gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.hpp\"\n+\n+class ShenandoahCompactOldHeuristics : public ShenandoahOldHeuristics {\n+public:\n+  ShenandoahCompactOldHeuristics(ShenandoahGeneration* generation);\n+\n+  virtual bool should_start_gc();\n+\n+  virtual void choose_collection_set_from_regiondata(ShenandoahCollectionSet* cset,\n+                                                     RegionData* data, size_t size,\n+                                                     size_t actual_free);\n+\n+  virtual const char* name()     { return \"CompactOld\"; }\n+  virtual bool is_diagnostic()   { return false; }\n+  virtual bool is_experimental() { return false; }\n+};\n+\n+#endif \/\/ SHARE_GC_SHENANDOAH_HEURISTICS_SHENANDOAHCOMPACTOLDHEURISTICS_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahCompactOldHeuristics.hpp","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2018, 2021, Red Hat, Inc. All rights reserved.\n@@ -49,0 +49,1 @@\n+  _generation(generation),\n@@ -57,2 +58,1 @@\n-  _metaspace_oom(),\n-  _generation(generation)\n+  _metaspace_oom()\n@@ -75,3 +75,1 @@\n-void ShenandoahHeuristics::choose_collection_set(ShenandoahCollectionSet* collection_set) {\n-  assert(collection_set->count() == 0, \"Must be empty\");\n-\n+void ShenandoahHeuristics::choose_collection_set(ShenandoahCollectionSet* collection_set, ShenandoahOldHeuristics* old_heuristics) {\n@@ -80,0 +78,3 @@\n+  assert(collection_set->count() == 0, \"Must be empty\");\n+  assert(_generation->generation_mode() != OLD, \"Old GC invokes ShenandoahOldHeuristics::choose_collection_set()\");\n+\n@@ -119,5 +120,2 @@\n-      } else if (_generation->generation_mode() != OLD) {\n-        \/\/ HEY! At this stage in development our concurrent old\n-        \/\/ marking does NOT complete the subsequent phases of the collection\n-        \/\/ and we don't want regions stuck in the 'in_cset' state because\n-        \/\/ various asserts will trip.\n+      } else {\n+        assert (_generation->generation_mode() != OLD, \"OLD is handled elsewhere\");\n@@ -165,0 +163,8 @@\n+\n+    if (old_heuristics != NULL) {\n+      old_heuristics->prime_collection_set(collection_set);\n+    }\n+    \/\/ else, this is global collection and doesn't need to prime_collection_set\n+\n+    \/\/ Add young-gen regions into the collection set.  This is a virtual call, implemented differently by each\n+    \/\/ of the heuristics subclasses.\n@@ -224,1 +230,1 @@\n-          \"In range before adjustment: \" INTX_FORMAT, _gc_time_penalties);\n+         \"In range before adjustment: \" INTX_FORMAT, _gc_time_penalties);\n@@ -236,1 +242,1 @@\n-          \"In range after adjustment: \" INTX_FORMAT, _gc_time_penalties);\n+         \"In range after adjustment: \" INTX_FORMAT, _gc_time_penalties);\n@@ -306,3 +312,3 @@\n-  return (_generation->generation_mode() == GLOBAL)\n-      || (_generation->generation_mode() == YOUNG && region->affiliation() == YOUNG_GENERATION)\n-      || (_generation->generation_mode() == OLD && region->affiliation() == OLD_GENERATION);\n+  return ((_generation->generation_mode() == GLOBAL)\n+          || (_generation->generation_mode() == YOUNG && region->affiliation() == YOUNG_GENERATION)\n+          || (_generation->generation_mode() == OLD && region->affiliation() == OLD_GENERATION));\n@@ -310,0 +316,1 @@\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.cpp","additions":23,"deletions":16,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -72,0 +72,15 @@\n+  ShenandoahGeneration* _generation;\n+\n+  \/\/ if (_generation->generation_mode() == GLOBAL) _region_data represents\n+  \/\/  the results of most recently completed global marking pass\n+  \/\/ if (_generation->generation_mode() == OLD) _region_data represents\n+  \/\/  the results of most recently completed old-gen marking pass\n+  \/\/ if (_generation->generation_mode() == YOUNG) _region_data represents\n+  \/\/  the resulits of most recently completed young-gen marking pass\n+  \/\/\n+  \/\/ Note that there is some redundancy represented in _region_data because\n+  \/\/ each instance is an array large enough to hold all regions.  However,\n+  \/\/ any region in young-gen is not in old-gen.  And any time we are\n+  \/\/ making use of the GLOBAL data, there is no need to maintain the\n+  \/\/ YOUNG or OLD data.  Consider this redundancy of data structure to\n+  \/\/ have negligible cost unless proven otherwise.\n@@ -87,2 +102,0 @@\n-  ShenandoahGeneration* _generation;\n-\n@@ -91,0 +104,4 @@\n+  \/\/ TODO: We need to enhance this API to give visibility to accompanying old-gen evacuation effort.\n+  \/\/ In the case that the old-gen evacuation effort is small or zero, the young-gen heuristics\n+  \/\/ should feel free to dedicate increased efforts to young-gen evacuation.\n+\n@@ -125,1 +142,1 @@\n-  virtual void choose_collection_set(ShenandoahCollectionSet* collection_set);\n+  virtual void choose_collection_set(ShenandoahCollectionSet* collection_set, ShenandoahOldHeuristics* old_heuristics);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.hpp","additions":20,"deletions":3,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -0,0 +1,317 @@\n+\/*\n+ * Copyright (c) 2021, Amazon.com, Inc. or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.hpp\"\n+#include \"utilities\/quickSort.hpp\"\n+\n+ShenandoahOldHeuristics::ShenandoahOldHeuristics(ShenandoahGeneration* generation) :\n+    ShenandoahHeuristics(generation),\n+    _old_collection_candidates(0),\n+    _next_old_collection_candidate(0),\n+    _hidden_old_collection_candidates(0),\n+    _hidden_next_old_collection_candidate(0),\n+    _old_coalesce_and_fill_candidates(0),\n+    _first_coalesce_and_fill_candidate(0)\n+{\n+}\n+\n+void ShenandoahOldHeuristics::prime_collection_set(ShenandoahCollectionSet* collection_set) {\n+  uint included_old_regions = 0;\n+  size_t evacuated_old_bytes = 0;\n+\n+  \/\/ TODO:\n+  \/\/ The max_old_evacuation_bytes and promotion_budget_bytes constants represent a first\n+  \/\/ approximation to desired operating parameters.  Eventually, these values should be determined\n+  \/\/ by heuristics and should adjust dynamically based on most current execution behavior.  In the\n+  \/\/ interrim, we may choose to offer command-line options to set the values of these configuration\n+  \/\/ parameters.\n+\n+  \/\/ max_old_evacuation_bytes represents an \"arbitrary\" bound on how much evacuation effort is dedicated\n+  \/\/ to old-gen regions.\n+  const size_t max_old_evacuation_bytes = (ShenandoahHeapRegion::region_size_bytes() * 8);\n+\n+  \/\/ promotion_budget_bytes represents an \"arbitrary\" bound on how many bytes can be consumed by young-gen\n+  \/\/ objects promoted into old-gen memory.  We need to avoid a scenario under which promotion of objects\n+  \/\/ depletes old-gen available memory to the point that there is insufficient memory to hold old-gen objects\n+  \/\/ that need to be evacuated from within the old-gen collection set.\n+  \/\/\n+  \/\/ TODO We should probably enforce this, but there is no enforcement currently.  Key idea: if there is not\n+  \/\/ sufficient memory within old-gen to hold an object that wants to be promoted, defer promotion until a\n+  \/\/ subsequent evacuation pass.  Since enforcement may be expensive, requiring frequent synchronization\n+  \/\/ between mutator and GC threads, here's an alternative \"greedy\" mitigation strategy: Set the parameter's\n+  \/\/ value so overflow is \"very rare\".  In the case that we experience overflow, evacuate what we can from\n+  \/\/ within the old collection set, but don't evacuate everything.  At the end of evacuation, any collection\n+  \/\/ set region that was not fully evacuated cannot be recycled.  It becomes a prime candidate for the next\n+  \/\/ collection set selection.  Here, we'd rather fall back to this contingent behavior than force a full STW\n+  \/\/ collection.\n+  const size_t promotion_budget_bytes = (ShenandoahHeapRegion::region_size_bytes() \/ 2);\n+\n+  \/\/ old_evacuation_budget is an upper bound on the amount of live memory that can be evacuated.\n+  \/\/\n+  \/\/ If a region is put into the collection set, then this region's free (not yet used) bytes are no longer\n+  \/\/ \"available\" to hold the results of other evacuations.  This may cause a decrease in the remaining amount\n+  \/\/ of memory that can still be evacuated.  We address this by reducing the evacuation budget by the amount\n+  \/\/ of live memory in that region and by the amount of unallocated memory in that region if the evacuation\n+  \/\/ budget is constrained by availability of free memory.  See remaining_old_evacuation_budget below.\n+\n+  \/\/ Allow no more evacuation than exists free-space within old-gen memory\n+  size_t old_evacuation_budget = ((_generation->available() > promotion_budget_bytes)\n+                                  ? _generation->available() - promotion_budget_bytes: 0);\n+\n+  \/\/ But if the amount of available free space in old-gen memory exceeds the pacing bound on how much old-gen\n+  \/\/ memory can be evacuated during each evacuation pass, then cut the old-gen evacuation further.  The pacing\n+  \/\/ bound is designed to assure that old-gen evacuations to not excessively slow the evacuation pass in order\n+  \/\/ to assure that young-gen GC cadence is not disrupted.\n+\n+  \/\/ excess_free_capacity represents availability of memory to hold evacuations beyond what is required to hold\n+  \/\/ planned evacuations.  It may go negative if we choose to collect regions with large amounts of free memory.\n+  long long excess_free_capacity;\n+  if (old_evacuation_budget > max_old_evacuation_bytes) {\n+    excess_free_capacity = old_evacuation_budget - max_old_evacuation_bytes;\n+    old_evacuation_budget = max_old_evacuation_bytes;\n+  } else\n+    excess_free_capacity = 0;\n+\n+  size_t remaining_old_evacuation_budget = old_evacuation_budget;\n+\n+  \/\/ The number of old-gen regions that were selected as candidates for collection at the end of the most recent\n+  \/\/ old-gen concurrent marking phase and have not yet been collected is represented by\n+  \/\/ unprocessed_old_collection_candidates()\n+  while (unprocessed_old_collection_candidates() > 0) {\n+    \/\/ Old collection candidates are sorted in order of decreasing garbage contained therein.\n+    ShenandoahHeapRegion* r = next_old_collection_candidate();\n+\n+    \/\/ Assuming region r is added to the collection set, what will be the remaining_old_evacuation_budget after\n+    \/\/ accounting for the loss of region r's free() memory.\n+    size_t adjusted_remaining_old_evacuation_budget;\n+\n+    \/\/ If we choose region r to be collected, then we need to decrease the capacity to hold other evacuations by\n+    \/\/ the size of r's free memory.\n+    excess_free_capacity -= r->free();\n+    \/\/ If subtracting r->free from excess_free_capacity() makes it go negative, that means we are going to have\n+    \/\/ to decrease the evacuation budget.\n+    if (excess_free_capacity < 0) {\n+      if (remaining_old_evacuation_budget < (size_t) -excess_free_capacity) {\n+        \/\/ By setting adjusted_remaining_old_evacuation_budget to 0, we prevent further additions to the old-gen\n+        \/\/ collection set, unless the region has zero live data bytes.\n+        adjusted_remaining_old_evacuation_budget = 0;\n+      } else {\n+        \/\/ Adding negative excess_free_capacity decreases the adjusted_remaining_old_evacuation_budget\n+        adjusted_remaining_old_evacuation_budget = remaining_old_evacuation_budget + excess_free_capacity;\n+      }\n+    } else {\n+      adjusted_remaining_old_evacuation_budget = remaining_old_evacuation_budget;\n+    }\n+\n+    if (r->get_live_data_bytes() > adjusted_remaining_old_evacuation_budget) {\n+      break;\n+    }\n+    collection_set->add_region(r);\n+    included_old_regions++;\n+    evacuated_old_bytes += r->get_live_data_bytes();\n+    consume_old_collection_candidate();\n+    remaining_old_evacuation_budget = adjusted_remaining_old_evacuation_budget - r->get_live_data_bytes();\n+  }\n+\n+  if (included_old_regions > 0) {\n+    log_info(gc)(\"Old-gen piggyback evac (%llu regions, %llu bytes)\",\n+                 (unsigned long long) included_old_regions,\n+                 (unsigned long long) evacuated_old_bytes);\n+  }\n+}\n+\n+\n+void ShenandoahOldHeuristics::choose_collection_set(ShenandoahCollectionSet* collection_set, ShenandoahOldHeuristics* old_heuristics) {\n+  assert(collection_set->count() == 0, \"Must be empty\");\n+\n+  \/\/ Old-gen doesn't actually choose a collection set to be evacuated by its own gang of worker tasks.\n+  \/\/ Instead, it computes the set of regions to be evacuated by subsequent young-gen evacuation passes.\n+  prepare_for_old_collections();\n+}\n+\n+void ShenandoahOldHeuristics::prepare_for_old_collections() {\n+  assert(_generation->generation_mode() == OLD, \"This service only available for old-gc heuristics\");\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  uint free_regions = 0;\n+  size_t cand_idx = 0;\n+  size_t total_garbage = 0;\n+  size_t num_regions = heap->num_regions();\n+\n+  RegionData* candidates = _region_data;\n+  for (size_t i = 0; i < num_regions; i++) {\n+    ShenandoahHeapRegion* region = heap->get_region(i);\n+    if (!in_generation(region)) {\n+      continue;\n+    } else {\n+      size_t garbage = region->garbage();\n+      total_garbage += garbage;\n+\n+      candidates[cand_idx]._region = region;\n+      candidates[cand_idx]._garbage = garbage;\n+      cand_idx++;\n+    }\n+  }\n+\n+  \/\/ Give special treatment to humongous regions.  Assume humongous regions is entirely\n+  \/\/ garbage or entirely non-garbage.  Assume that a head humongous region and the associated\n+  \/\/ humongous continuous regions are uniformly entirely garbage or entirely non-garbage.\n+  \/\/\n+  \/\/ Sift garbage humongous regions to front, non-garbage humongous regions to end of array.\n+  size_t first_non_humongous_empty = 0;\n+  size_t first_humongous_non_empty = cand_idx;\n+\n+  size_t i = 0;\n+  while (i < first_humongous_non_empty) {\n+    ShenandoahHeapRegion* region = candidates[i]._region;\n+    if (region->is_humongous()) {\n+      if (region->get_live_data_bytes() == 0) {\n+        \/\/ Humongous region is entirely garbage.  Reclaim it.\n+        if (i == first_non_humongous_empty) {\n+          first_non_humongous_empty++;\n+        } else {\n+          RegionData swap_tmp = candidates[i];\n+          candidates[i] = candidates[first_non_humongous_empty];\n+          candidates[first_non_humongous_empty++] = swap_tmp;\n+        }\n+        i++;\n+      } else {\n+        \/\/ Humongous region is non garbage.  Don't reclaim it.\n+        if (i + 1 == first_humongous_non_empty) {\n+          first_humongous_non_empty--;\n+          i++;\n+        } else {\n+          RegionData swap_tmp = candidates[i];\n+          candidates[i] = candidates[--first_humongous_non_empty];\n+          candidates[first_humongous_non_empty] = swap_tmp;\n+          \/\/ Do not increment i so we can revisit swapped entry on next iteration\n+        }\n+      }\n+    } else {\n+      i++;\n+    }\n+  }\n+\n+\n+  \/\/ Prioritize regions to select garbage-first regions\n+  QuickSort::sort<RegionData>(candidates + first_non_humongous_empty, (int)(first_humongous_non_empty - first_non_humongous_empty),\n+                              compare_by_garbage, false);\n+\n+  \/\/ Any old-gen region that contains (ShenandoahGarbageThreshold (default value 25))% garbage or more is to\n+  \/\/ be evacuated.\n+  \/\/\n+  \/\/ TODO: it probably makes sense to define old-generation collection_threshold_garbage_percent differently\n+  \/\/ than the young-gen ShenandoahGarbageThreshold.  So a different command-line option might allow specification\n+  \/\/ distinct values for each.  Even better, allow collection_threshold_garbage_percent to be determined\n+  \/\/ adaptively, by heuristics.\n+\n+  const size_t collection_threshold_garbage_percent = ShenandoahGarbageThreshold;\n+\n+  size_t region_size = ShenandoahHeapRegion::region_size_bytes();\n+  for (size_t i = first_non_humongous_empty; i < first_humongous_non_empty; i++) {\n+    \/\/ Do approximate percent to avoid floating point math\n+    size_t percent_garbage = candidates[i]._garbage * 100 \/ region_size;\n+\n+    if (percent_garbage < collection_threshold_garbage_percent) {\n+      _hidden_next_old_collection_candidate = 0;\n+      _hidden_old_collection_candidates = i;\n+      _first_coalesce_and_fill_candidate = i;\n+      _old_coalesce_and_fill_candidates = cand_idx - i;\n+\n+      \/\/ Note that we do not coalesce and fill occupied humongous regions\n+      \/\/ HR: humongous regions, RR: regular regions, CF: coalesce and fill regions\n+      log_info(gc)(\"Old-gen mark evac (%u HR, %llu RR), %llu CF)\",\n+                   (unsigned int) first_non_humongous_empty,\n+                   (unsigned long long) (_hidden_old_collection_candidates - first_non_humongous_empty),\n+                   (unsigned long long) _old_coalesce_and_fill_candidates);\n+      return;\n+    }\n+  }\n+\n+  \/\/ If we reach here, all of non-humogous old-gen regions are candidates for collection set.\n+  _hidden_next_old_collection_candidate = 0;\n+  _hidden_old_collection_candidates = first_humongous_non_empty;\n+  _first_coalesce_and_fill_candidate = 0;\n+  _old_coalesce_and_fill_candidates = 0;\n+\n+  \/\/ Note that we do not coalesce and fill occupied humongous regions\n+  \/\/ HR: humongous regions, RR: regular regions, CF: coalesce and fill regions\n+  log_info(gc)(\"Old-gen mark evac (%u HR, %llu RR), %llu CF)\",\n+               (unsigned int) first_non_humongous_empty,\n+               (unsigned long long) (_hidden_old_collection_candidates - first_non_humongous_empty),\n+               (unsigned long long) _old_coalesce_and_fill_candidates);\n+}\n+\n+void ShenandoahOldHeuristics::start_old_evacuations() {\n+  assert(_generation->generation_mode() == OLD, \"This service only available for old-gc heuristics\");\n+\n+  _old_collection_candidates = _hidden_old_collection_candidates;\n+  _next_old_collection_candidate = _hidden_next_old_collection_candidate;\n+\n+  _hidden_old_collection_candidates = 0;}\n+\n+\n+uint ShenandoahOldHeuristics::unprocessed_old_collection_candidates() {\n+  assert(_generation->generation_mode() == OLD, \"This service only available for old-gc heuristics\");\n+  return _old_collection_candidates + _hidden_old_collection_candidates;\n+}\n+\n+ShenandoahHeapRegion* ShenandoahOldHeuristics::next_old_collection_candidate() {\n+  assert(_generation->generation_mode() == OLD, \"This service only available for old-gc heuristics\");\n+  return _region_data[_next_old_collection_candidate]._region;\n+}\n+\n+void ShenandoahOldHeuristics::consume_old_collection_candidate() {\n+  assert(_generation->generation_mode() == OLD, \"This service only available for old-gc heuristics\");\n+  _next_old_collection_candidate++;\n+  _old_collection_candidates--;\n+}\n+\n+uint ShenandoahOldHeuristics::old_coalesce_and_fill_candidates() {\n+  assert(_generation->generation_mode() == OLD, \"This service only available for old-gc heuristics\");\n+  return _old_coalesce_and_fill_candidates;\n+}\n+\n+void ShenandoahOldHeuristics::get_coalesce_and_fill_candidates(ShenandoahHeapRegion** buffer) {\n+  assert(_generation->generation_mode() == OLD, \"This service only available for old-gc heuristics\");\n+  uint count = _old_coalesce_and_fill_candidates;\n+  int index = _first_coalesce_and_fill_candidate;\n+  while (count-- > 0) {\n+    *buffer++ = _region_data[index++]._region;\n+  }\n+}\n+\n+bool ShenandoahOldHeuristics::should_defer_gc() {\n+  if (unprocessed_old_collection_candidates() > 0) {\n+    \/\/ Cannot start a new old-gen GC until previous one has finished.\n+    \/\/\n+    \/\/ Future refinement: under certain circumstances, we might be more sophisticated about this choice.\n+    \/\/ For example, we could choose to abandon the prevoius old collection before it has completed evacuations,\n+    \/\/ but this would require that we coalesce and fill all garbage within unevacuated collection-set regions.\n+    return true;\n+  }\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.cpp","additions":317,"deletions":0,"binary":false,"changes":317,"status":"added"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2021, Amazon.com, Inc. or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHENANDOAH_HEURISTICS_SHENANDOAHOLDHEURISTICS_HPP\n+#define SHARE_GC_SHENANDOAH_HEURISTICS_SHENANDOAHOLDHEURISTICS_HPP\n+\n+#include \"gc\/shenandoah\/shenandoahCollectionSet.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGeneration.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeapRegion.inline.hpp\"\n+#include \"gc\/shenandoah\/heuristics\/shenandoahHeuristics.hpp\"\n+\n+class ShenandoahOldHeuristics : public ShenandoahHeuristics {\n+\n+protected:\n+\n+  \/\/ if (_generation->generation_mode() == OLD) _old_collection_candidates\n+  \/\/  represent the number of regions selected for collection following the\n+  \/\/  most recently completed old-gen mark that have not yet been selected\n+  \/\/  for evacuation and _next_collection_candidate is the index within\n+  \/\/  _region_data of the next candidate region to be selected for evacuation.\n+  \/\/ if (_generation->generation_mode() != OLD) these two variables are\n+  \/\/  not used.\n+  uint _old_collection_candidates;\n+  uint _next_old_collection_candidate;\n+\n+  \/\/ At the time we select the old-gen collection set, _hidden_old_collection_candidates\n+  \/\/ and _hidden_next_old_collection_candidates are set to remember the intended old-gen\n+  \/\/ collection set.  After all old-gen regions not in the old-gen collection set have been\n+  \/\/ coalesced and filled, the content of these variables is copied to _old_collection_candidates\n+  \/\/ and _next_old_collection_candidates so that evacuations can begin evacuating these regions.\n+  uint _hidden_old_collection_candidates;\n+  uint _hidden_next_old_collection_candidate;\n+\n+  \/\/ if (_generation->generation_mode() == OLD)\n+  \/\/  _old_coalesce_and_fill_candidates represents the number of regions\n+  \/\/  that were chosen for the garbage contained therein to be coalesced\n+  \/\/  and filled and _first_coalesce_and_fill_candidate represents the\n+  \/\/  the index of the first such region within the _region_data array.\n+  \/\/ if (_generation->generation_mode() != OLD) these two variables are\n+  \/\/  not used.\n+  uint _old_coalesce_and_fill_candidates;\n+  uint _first_coalesce_and_fill_candidate;\n+\n+  \/\/ Prepare for evacuation of old-gen regions by capturing the mark results of a recently completed concurrent mark pass.\n+  void prepare_for_old_collections();\n+\n+public:\n+  ShenandoahOldHeuristics(ShenandoahGeneration* generation);\n+\n+  virtual void choose_collection_set(ShenandoahCollectionSet* collection_set, ShenandoahOldHeuristics* old_heuristics);\n+\n+  void prime_collection_set(ShenandoahCollectionSet* set);\n+\n+  \/\/ Having coalesced and filled all old-gen heap regions that are not part of the old-gen collection set, begin\n+  \/\/ evacuating the collection set.\n+  void start_old_evacuations();\n+\n+  \/\/ How many old-collection candidates have not yet been processed?\n+  uint unprocessed_old_collection_candidates();\n+\n+  \/\/ Return the next old-collection candidate in order of decreasing amounts of garbage.  (We process most-garbage regions\n+  \/\/ first.)  This does not consume the candidate.  If the candidate is selected for inclusion in a collection set, then\n+  \/\/ the candidate is consumed by invoking consume_old_collection_candidate().\n+  ShenandoahHeapRegion* next_old_collection_candidate();\n+\n+  \/\/ Adjust internal state to reflect that one fewer old-collection candidate remains to be processed.\n+  void consume_old_collection_candidate();\n+\n+  \/\/ How many old-collection regions were identified at the end of the most recent old-gen mark to require their\n+  \/\/ unmarked objects to be coalesced and filled?\n+  uint old_coalesce_and_fill_candidates();\n+\n+  \/\/ Fill in buffer with all of the old-collection regions that were identified at the end of the most recent old-gen\n+  \/\/ mark to require their unmarked objects to be coalesced and filled.  The buffer array must have at least\n+  \/\/ old_coalesce_and_fill_candidates() entries, or memory may be corrupted when this function overwrites the\n+  \/\/ end of the array.\n+  void get_coalesce_and_fill_candidates(ShenandoahHeapRegion** buffer);\n+\n+  bool should_defer_gc();\n+\n+};\n+\n+#endif \/\/ SHARE_GC_SHENANDOAH_HEURISTICS_SHENANDOAHOLDHEURISTICS_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.hpp","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"gc\/shenandoah\/heuristics\/shenandoahPassiveOldHeuristics.hpp\"\n+#include \"gc\/shenandoah\/shenandoahCollectionSet.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeapRegion.inline.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"logging\/logTag.hpp\"\n+\n+bool ShenandoahPassiveOldHeuristics::should_start_gc() {\n+  \/\/ Never do concurrent GCs.\n+  return false;\n+}\n+\n+bool ShenandoahPassiveOldHeuristics::should_unload_classes() {\n+  \/\/ Always unload classes, if we can.\n+  return can_unload_classes();\n+}\n+\n+bool ShenandoahPassiveOldHeuristics::should_degenerate_cycle() {\n+  \/\/ Always fail to Degenerated GC, if enabled\n+  return ShenandoahDegeneratedGC;\n+}\n+\n+void ShenandoahPassiveOldHeuristics::choose_collection_set_from_regiondata(ShenandoahCollectionSet* cset,\n+                                                                           RegionData* data, size_t size,\n+                                                                           size_t actual_free) {\n+  assert(ShenandoahDegeneratedGC, \"This path is only taken for Degenerated GC\");\n+\n+  \/\/ Do not select too large CSet that would overflow the available free space.\n+  \/\/ Take at least the entire evacuation reserve, and be free to overflow to free space.\n+  size_t max_capacity = ShenandoahHeap::heap()->max_capacity();\n+  size_t available = MAX2(max_capacity \/ 100 * ShenandoahEvacReserve, actual_free);\n+  size_t max_cset  = (size_t)(available \/ ShenandoahEvacWaste);\n+\n+  log_info(gc, ergo)(\"CSet Selection. Actual Free: \" SIZE_FORMAT \"%s, Max CSet: \" SIZE_FORMAT \"%s\",\n+                     byte_size_in_proper_unit(actual_free), proper_unit_for_byte_size(actual_free),\n+                     byte_size_in_proper_unit(max_cset),    proper_unit_for_byte_size(max_cset));\n+\n+  size_t threshold = ShenandoahHeapRegion::region_size_bytes() * ShenandoahGarbageThreshold \/ 100;\n+\n+  size_t live_cset = 0;\n+  for (size_t idx = 0; idx < size; idx++) {\n+    ShenandoahHeapRegion* r = data[idx]._region;\n+    size_t new_cset = live_cset + r->get_live_data_bytes();\n+    if (new_cset < max_cset && r->garbage() > threshold) {\n+      live_cset = new_cset;\n+      cset->add_region(r);\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahPassiveOldHeuristics.cpp","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHENANDOAH_HEURISTICS_SHENANDOAHPASSIVEOLDHEURISTICS_HPP\n+#define SHARE_GC_SHENANDOAH_HEURISTICS_SHENANDOAHPASSIVEOLDHEURISTICS_HPP\n+\n+#include \"gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.hpp\"\n+\n+class ShenandoahPassiveOldHeuristics : public ShenandoahOldHeuristics {\n+public:\n+  ShenandoahPassiveOldHeuristics(ShenandoahGeneration* generation)\n+    : ShenandoahOldHeuristics(generation) {}\n+\n+  virtual bool should_start_gc();\n+\n+  virtual bool should_unload_classes();\n+\n+  virtual bool should_degenerate_cycle();\n+\n+  virtual void choose_collection_set_from_regiondata(ShenandoahCollectionSet* set,\n+                                                     RegionData* data, size_t data_size,\n+                                                     size_t free);\n+\n+  virtual const char* name()     { return \"PassiveOld\"; }\n+  virtual bool is_diagnostic()   { return true; }\n+  virtual bool is_experimental() { return false; }\n+};\n+\n+#endif \/\/ SHARE_GC_SHENANDOAH_HEURISTICS_SHENANDOAHPASSIVEOLDHEURISTICS_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahPassiveOldHeuristics.hpp","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"gc\/shenandoah\/heuristics\/shenandoahStaticOldHeuristics.hpp\"\n+#include \"gc\/shenandoah\/shenandoahCollectionSet.hpp\"\n+#include \"gc\/shenandoah\/shenandoahFreeSet.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeapRegion.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGeneration.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"logging\/logTag.hpp\"\n+\n+ShenandoahStaticOldHeuristics::ShenandoahStaticOldHeuristics(ShenandoahGeneration* generation) :\n+  ShenandoahOldHeuristics(generation) {\n+  SHENANDOAH_ERGO_ENABLE_FLAG(ExplicitGCInvokesConcurrent);\n+  SHENANDOAH_ERGO_ENABLE_FLAG(ShenandoahImplicitGCInvokesConcurrent);\n+}\n+\n+ShenandoahStaticOldHeuristics::~ShenandoahStaticOldHeuristics() {}\n+\n+bool ShenandoahStaticOldHeuristics::should_start_gc() {\n+  size_t max_capacity = _generation->max_capacity();\n+  size_t capacity = _generation->soft_max_capacity();\n+  size_t available = _generation->available();\n+\n+  \/\/ Make sure the code below treats available without the soft tail.\n+  size_t soft_tail = max_capacity - capacity;\n+  available = (available > soft_tail) ? (available - soft_tail) : 0;\n+\n+  size_t threshold_available = capacity \/ 100 * ShenandoahMinFreeThreshold;\n+\n+  if (available < threshold_available) {\n+    log_info(gc)(\"Trigger: Free (\" SIZE_FORMAT \"%s) is below minimum threshold (\" SIZE_FORMAT \"%s)\",\n+                 byte_size_in_proper_unit(available), proper_unit_for_byte_size(available),\n+                 byte_size_in_proper_unit(threshold_available), proper_unit_for_byte_size(threshold_available));\n+    return true;\n+  }\n+  return ShenandoahHeuristics::should_start_gc();\n+}\n+\n+void ShenandoahStaticOldHeuristics::choose_collection_set_from_regiondata(ShenandoahCollectionSet* cset,\n+                                                                          RegionData* data, size_t size,\n+                                                                          size_t free) {\n+  size_t threshold = ShenandoahHeapRegion::region_size_bytes() * ShenandoahGarbageThreshold \/ 100;\n+\n+  for (size_t idx = 0; idx < size; idx++) {\n+    ShenandoahHeapRegion* r = data[idx]._region;\n+    if (r->garbage() > threshold) {\n+      cset->add_region(r);\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahStaticOldHeuristics.cpp","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHENANDOAH_HEURISTICS_SHENANDOAHSTATICOLDHEURISTICS_HPP\n+#define SHARE_GC_SHENANDOAH_HEURISTICS_SHENANDOAHSTATICOLDHEURISTICS_HPP\n+\n+#include \"gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.hpp\"\n+\n+class ShenandoahStaticOldHeuristics : public ShenandoahOldHeuristics {\n+public:\n+  ShenandoahStaticOldHeuristics(ShenandoahGeneration* generation);\n+\n+  virtual ~ShenandoahStaticOldHeuristics();\n+\n+  virtual bool should_start_gc();\n+\n+  virtual void choose_collection_set_from_regiondata(ShenandoahCollectionSet* cset,\n+                                                     RegionData* data, size_t size,\n+                                                     size_t free);\n+\n+  virtual const char* name()     { return \"StaticOld\"; }\n+  virtual bool is_diagnostic()   { return false; }\n+  virtual bool is_experimental() { return false; }\n+};\n+\n+#endif \/\/ SHARE_GC_SHENANDOAH_HEURISTICS_SHENANDOAHSTATICOLDHEURISTICS_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahStaticOldHeuristics.hpp","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"gc\/shenandoah\/heuristics\/shenandoahAdaptiveOldHeuristics.hpp\"\n@@ -28,0 +29,1 @@\n+#include \"gc\/shenandoah\/heuristics\/shenandoahAggressiveOldHeuristics.hpp\"\n@@ -29,0 +31,1 @@\n+#include \"gc\/shenandoah\/heuristics\/shenandoahCompactOldHeuristics.hpp\"\n@@ -30,0 +33,1 @@\n+#include \"gc\/shenandoah\/heuristics\/shenandoahStaticOldHeuristics.hpp\"\n@@ -51,0 +55,18 @@\n+\n+ShenandoahOldHeuristics* ShenandoahMode::initialize_old_heuristics(ShenandoahGeneration* generation) const {\n+\n+  assert(ShenandoahGCHeuristics != NULL, \"ShenandoahGCHeuristics should not equal NULL\");\n+  if (strcmp(ShenandoahGCHeuristics, \"aggressive\") == 0) {\n+    return new ShenandoahAggressiveOldHeuristics(generation);\n+  } else if (strcmp(ShenandoahGCHeuristics, \"static\") == 0) {\n+    return new ShenandoahStaticOldHeuristics(generation);\n+  } else if (strcmp(ShenandoahGCHeuristics, \"adaptive\") == 0) {\n+    return new ShenandoahAdaptiveOldHeuristics(generation);\n+  } else if (strcmp(ShenandoahGCHeuristics, \"compact\") == 0) {\n+    return new ShenandoahCompactOldHeuristics(generation);\n+  } else {\n+    vm_exit_during_initialization(\"Unknown -XX:ShenandoahGCHeuristics option\");\n+    ShouldNotReachHere();\n+    return NULL;\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/mode\/shenandoahMode.cpp","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2019, 2021, Red Hat, Inc. All rights reserved.\n@@ -34,0 +34,1 @@\n+class ShenandoahOldHeuristics;\n@@ -55,0 +56,1 @@\n+  virtual ShenandoahOldHeuristics* initialize_old_heuristics(ShenandoahGeneration* generation) const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/mode\/shenandoahMode.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/shenandoah\/heuristics\/shenandoahPassiveOldHeuristics.hpp\"\n@@ -62,0 +63,5 @@\n+\n+ShenandoahOldHeuristics* ShenandoahPassiveMode::initialize_old_heuristics(ShenandoahGeneration* generation) const {\n+  assert(ShenandoahGCHeuristics != NULL, \"ShenandoahGCHeuristics should not equal NULL\");\n+  return new ShenandoahPassiveOldHeuristics(generation);\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/mode\/shenandoahPassiveMode.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2019, 2021, Red Hat, Inc. All rights reserved.\n@@ -34,0 +34,1 @@\n+  virtual ShenandoahOldHeuristics* initialize_old_heuristics(ShenandoahGeneration* generation) const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/mode\/shenandoahPassiveMode.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -49,0 +49,2 @@\n+\n+protected:\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -74,3 +74,1 @@\n-void ShenandoahGeneration::initialize_heuristics(ShenandoahMode* gc_mode) {\n-  _heuristics = gc_mode->initialize_heuristics(this);\n-\n+void ShenandoahGeneration::confirm_heuristics_mode() {\n@@ -89,0 +87,13 @@\n+ShenandoahOldHeuristics* ShenandoahGeneration::initialize_old_heuristics(ShenandoahMode* gc_mode) {\n+  ShenandoahOldHeuristics* old_heuristics = gc_mode->initialize_old_heuristics(this);\n+  _heuristics = old_heuristics;\n+  confirm_heuristics_mode();\n+  return old_heuristics;\n+}\n+\n+ShenandoahHeuristics* ShenandoahGeneration::initialize_heuristics(ShenandoahMode* gc_mode) {\n+  _heuristics = gc_mode->initialize_heuristics(this);\n+  confirm_heuristics_mode();\n+  return _heuristics;\n+}\n+\n@@ -151,1 +162,1 @@\n-    _heuristics->choose_collection_set(heap->collection_set());\n+    _heuristics->choose_collection_set(heap->collection_set(), heap->old_heuristics());\n@@ -276,1 +287,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"gc\/shenandoah\/heuristics\/shenandoahHeuristics.hpp\"\n+#include \"gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.hpp\"\n@@ -63,1 +63,3 @@\n-  void initialize_heuristics(ShenandoahMode* gc_mode);\n+  ShenandoahHeuristics* initialize_heuristics(ShenandoahMode* gc_mode);\n+\n+  ShenandoahOldHeuristics* initialize_old_heuristics(ShenandoahMode* gc_mode);\n@@ -124,1 +126,1 @@\n- protected:\n+protected:\n@@ -127,0 +129,3 @@\n+\n+private:\n+  void confirm_heuristics_mode();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.hpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -482,0 +482,2 @@\n+  \/\/ ojo: want to instantiate a ShenandoahOldHeuristics object here\n+  _old_heuristics = _old_generation->initialize_old_heuristics(_gc_mode);\n@@ -484,1 +486,0 @@\n-  _old_generation->initialize_heuristics(_gc_mode);\n@@ -495,0 +496,1 @@\n+  _old_heuristics(nullptr),\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+class ShenandoahOldHeuristics;\n@@ -149,0 +150,1 @@\n+  ShenandoahOldHeuristics* _old_heuristics;\n@@ -164,0 +166,4 @@\n+  ShenandoahOldHeuristics* old_heuristics() {\n+    return _old_heuristics;\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -406,0 +406,33 @@\n+\/\/ oop_iterate without closure\n+void ShenandoahHeapRegion::oop_fill_and_coalesce() {\n+  HeapWord* obj_addr = bottom();\n+  HeapWord* t = top();\n+\n+  assert(!is_humongous(), \"No need to fill or coalesce humongous regions\");\n+  if (!is_active()) return;\n+\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  ShenandoahMarkingContext* marking_context = heap->marking_context();\n+\n+  \/\/ Expect this to be invoked only from within threads perfoming old-gen GC, and expect\n+  \/\/ old-gen marking to be completed before these threads invoke this service.\n+  assert(heap->active_generation()->is_mark_complete(), \"sanity\");\n+\n+  while (obj_addr < t) {\n+    oop obj = oop(obj_addr);\n+    if (marking_context->is_marked(obj)) {\n+      assert(obj->klass() != NULL, \"klass should not be NULL\");\n+      obj_addr += obj->size();\n+    } else {\n+      \/\/ Object is not marked.  Coalesce and fill dead object with dead neighbors.\n+      HeapWord* next_marked_obj = marking_context->get_next_marked_addr(obj_addr, t);\n+      assert(next_marked_obj <= t, \"next marked object cannot exceed top\");\n+      size_t fill_size = next_marked_obj - obj_addr;\n+      ShenandoahHeap::fill_with_object(obj_addr, fill_size);\n+      heap->card_scan()->coalesce_objects(obj_addr, fill_size);\n+      obj_addr = next_marked_obj;\n+    }\n+  }\n+}\n+\n+\n@@ -409,0 +442,2 @@\n+    \/\/ TODO: This doesn't look right.  This registers objects if !reregister, and it isn't filling if fill_dead_objects.\n+    \/\/ Furthermore, register and fill should be done after iterating.\n@@ -434,2 +469,0 @@\n-    HeapWord* fill_addr = NULL;\n-    size_t fill_size = 0;\n@@ -439,9 +472,0 @@\n-        if (fill_addr != NULL) {\n-           if (reregister_coalesced_objects) { \/\/ change existing crossing map information\n-            heap->card_scan()->coalesce_objects(fill_addr, fill_size);\n-          } else {              \/\/ establish new crossing map information\n-             heap->card_scan()->register_object(fill_addr);\n-          }\n-          ShenandoahHeap::fill_with_object(fill_addr, fill_size);\n-          fill_addr = NULL;\n-        }\n@@ -449,1 +473,1 @@\n-        if (!reregister_coalesced_objects)\n+        if (!reregister_coalesced_objects) {\n@@ -451,0 +475,1 @@\n+        }\n@@ -453,6 +478,9 @@\n-        int size = obj->size();\n-        if (fill_addr == NULL) {\n-          fill_addr = obj_addr;\n-          fill_size = size;\n-        } else {\n-          fill_size += size;\n+        \/\/ Object is not marked.  Coalesce and fill dead object with dead neighbors.\n+        HeapWord* next_marked_obj = marking_context->get_next_marked_addr(obj_addr, t);\n+        assert(next_marked_obj <= t, \"next marked object cannot exceed top\");\n+        size_t fill_size = next_marked_obj - obj_addr;\n+        ShenandoahHeap::fill_with_object(obj_addr, fill_size);\n+        if (reregister_coalesced_objects) {\n+          heap->card_scan()->coalesce_objects(obj_addr, fill_size);\n+        } else {              \/\/ establish new crossing map information\n+          heap->card_scan()->register_object(obj_addr);\n@@ -460,9 +488,1 @@\n-        obj_addr += size;\n-      }\n-    }\n-    if (fill_addr != NULL) {\n-      ShenandoahHeap::fill_with_object(fill_addr, fill_size);\n-      if (reregister_coalesced_objects) { \/\/ change existing crossing map information\n-        heap->card_scan()->coalesce_objects(fill_addr, fill_size);\n-      } else {              \/\/ establish new crossing map information\n-        heap->card_scan()->register_object(fill_addr);\n+        obj_addr = next_marked_obj;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.cpp","additions":47,"deletions":27,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -363,0 +363,3 @@\n+  \/\/ coalesce contiguous spans of garbage objects by filling header and reregistering start locations with remembered set.\n+  void oop_fill_and_coalesce();\n+\n@@ -414,0 +417,1 @@\n+  void oop_iterate_objects(bool fill_dead_objects, bool reregister_coalesced_objects);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/shenandoah\/shenandoahMonitoringSupport.hpp\"\n@@ -31,0 +32,36 @@\n+#include \"gc\/shenandoah\/shenandoahGeneration.hpp\"\n+#include \"gc\/shenandoah\/heuristics\/shenandoahHeuristics.hpp\"\n+#include \"gc\/shenandoah\/shenandoahWorkerPolicy.hpp\"\n+#include \"utilities\/events.hpp\"\n+\n+class ShenandoahConcurrentCoalesceAndFillTask : public AbstractGangTask {\n+private:\n+  \/\/ remember nworkers, coalesce_and_fill_region_array,coalesce_and_fill_regions_count\n+\n+  uint _nworkers;\n+  ShenandoahHeapRegion** _coalesce_and_fill_region_array;\n+  uint _coalesce_and_fill_region_count;\n+\n+public:\n+  ShenandoahConcurrentCoalesceAndFillTask(uint nworkers,\n+                                          ShenandoahHeapRegion** coalesce_and_fill_region_array, uint region_count) :\n+    AbstractGangTask(\"Shenandoah Concurrent Coalesce and Fill\"),\n+    _nworkers(nworkers),\n+    _coalesce_and_fill_region_array(coalesce_and_fill_region_array),\n+    _coalesce_and_fill_region_count(region_count) {\n+  }\n+\n+  void work(uint worker_id) {\n+    ShenandoahHeap* heap = ShenandoahHeap::heap();\n+\n+    for (uint region_idx = worker_id; region_idx < _coalesce_and_fill_region_count; region_idx += _nworkers) {\n+      ShenandoahHeapRegion* r = _coalesce_and_fill_region_array[region_idx];\n+      if (!r->is_humongous())\n+        r->oop_fill_and_coalesce();\n+      else {\n+        \/\/ there's only one object in this region and it's not garbage, so no need to coalesce or fill\n+      }\n+    }\n+  }\n+};\n+\n@@ -35,0 +72,7 @@\n+void ShenandoahOldGC::entry_old_evacuations() {\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  ShenandoahOldHeuristics* old_heuristics = heap->old_heuristics();\n+  entry_coalesce_and_fill();\n+  old_heuristics->start_old_evacuations();\n+}\n+\n@@ -47,0 +91,2 @@\n+  entry_old_evacuations();\n+\n@@ -87,0 +133,45 @@\n+\n+void ShenandoahOldGC::entry_coalesce_and_fill_message(char *buf, size_t len) const {\n+  \/\/ ShenandoahHeap* const heap = ShenandoahHeap::heap();\n+  jio_snprintf(buf, len, \"Coalescing and filling (%s)\", _generation->name());\n+}\n+\n+void ShenandoahOldGC::op_coalesce_and_fill() {\n+  ShenandoahHeap* const heap = ShenandoahHeap::heap();\n+\n+  WorkGang* workers = heap->workers();\n+  uint nworkers = workers->active_workers();\n+\n+  assert(_generation->generation_mode() == OLD, \"Only old-GC does coalesce and fill\");\n+\n+  ShenandoahOldHeuristics* old_heuristics = heap->old_heuristics();\n+  uint coalesce_and_fill_regions_count = old_heuristics->old_coalesce_and_fill_candidates();\n+  ShenandoahHeapRegion* coalesce_and_fill_region_array[coalesce_and_fill_regions_count];\n+\n+  old_heuristics->get_coalesce_and_fill_candidates(coalesce_and_fill_region_array);\n+  ShenandoahConcurrentCoalesceAndFillTask task(nworkers, coalesce_and_fill_region_array, coalesce_and_fill_regions_count);\n+\n+\n+  \/\/ TODO:  We need to implement preemption of coalesce and fill.  If young-gen wants to run while we're working on this,\n+  \/\/ we should preempt this code and then resume it after young-gen has finished.  This requires that we \"remember\" the state\n+  \/\/ of each worker thread so it can be resumed where it left off.  Note that some worker threads may have processed more regions\n+  \/\/ than others at the time of preemption.\n+\n+  workers->run_task(&task);\n+}\n+\n+void ShenandoahOldGC::entry_coalesce_and_fill() {\n+  char msg[1024];\n+  ShenandoahHeap* const heap = ShenandoahHeap::heap();\n+\n+  entry_coalesce_and_fill_message(msg, sizeof(msg));\n+  ShenandoahConcurrentPhase gc_phase(msg, ShenandoahPhaseTimings::coalesce_and_fill);\n+\n+  TraceCollectorStats tcs(heap->monitoring_support()->concurrent_collection_counters());\n+  EventMark em(\"%s\", msg);\n+  ShenandoahWorkerScope scope(heap->workers(),\n+                              ShenandoahWorkerPolicy::calc_workers_for_conc_marking(),\n+                              \"concurrent coalesce and fill\");\n+\n+  op_coalesce_and_fill();\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGC.cpp","additions":91,"deletions":0,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -38,0 +38,2 @@\n+  void entry_old_evacuations();\n+  void entry_coalesce_and_fill();\n@@ -39,0 +41,2 @@\n+  void op_coalesce_and_fill();\n+  void entry_coalesce_and_fill_message(char *buf, size_t len) const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGC.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -67,0 +67,2 @@\n+  f(coalesce_and_fill,                              \"Coalesce and Fill Old Dead\")      \\\n+  SHENANDOAH_PAR_PHASE_DO(coalesce_and_fill_,       \"    CFOD: \", f)                   \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahPhaseTimings.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-  _old_heuristics = get_heuristics(heap->old_generation());\n+  _old_heuristics = heap->old_heuristics();\n@@ -137,1 +137,1 @@\n-  return _old_heuristics->should_start_gc() && _control_thread->request_concurrent_gc(OLD);\n+  return !_old_heuristics->should_defer_gc() && _old_heuristics->should_start_gc() && _control_thread->request_concurrent_gc(OLD);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRegulatorThread.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.hpp\"\n@@ -77,1 +78,1 @@\n-  ShenandoahHeuristics* _old_heuristics;\n+  ShenandoahOldHeuristics* _old_heuristics;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRegulatorThread.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,209 @@\n+\/*\n+ * Copyright (c) 2021, Amazon, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package gc.shenandoah.generational;\n+\n+import sun.hotspot.WhiteBox;\n+import java.util.Random;\n+import java.util.HashMap;\n+\n+\/* WARNING!\n+ *  As of the date on which this test was added into the jtreg suite, heuristic\n+ *  of old-gen GC passes is very simplistic.  A further shortcoming of the\n+ *  Generational Shenandoah as of introduction of this test is that it does\n+ *  not currently support full GC.  If garbage collection falls behind mutator\n+ *  allocations, a full GC will be triggered and Generational Shenandoah will\n+ *  abort itself with an assertion error.  Both of these limitations will be\n+ *  addressed in future releases of Generational Shenandoah.\n+ *\n+ *  To avoid the risk of false regressions identified by this test, the heap\n+ *  size is set artificially high.  Though this test is known to run reliably\n+ *  in 66 MB heap, the heap size for this test run is currently set to 256 MB.\n+ *\/\n+\n+\/*\n+ * @test TestConcurrentEvac\n+ * @requires vm.gc.Shenandoah\n+ * @summary Confirm that card marking and remembered set scanning do not crash.\n+ * @library \/testlibrary \/test\/lib \/\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *      -Xms256m -Xmx256m\n+ *      -XX:+IgnoreUnrecognizedVMOptions\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+ *      -XX:NewRatio=1 -XX:+UnlockExperimentalVMOptions\n+ *      -XX:ShenandoahGuaranteedGCInterval=3000\n+ *      -XX:-UseDynamicNumberOfGCThreads -XX:-ShenandoahPacing\n+ *      gc.shenandoah.generational.TestConcurrentEvac\n+ *\/\n+\n+public class TestConcurrentEvac {\n+  private static WhiteBox wb = WhiteBox.getWhiteBox();\n+\n+  static private final int SeedForRandom = 46;\n+  \/\/ Sequence of random numbers should end with same value\n+\n+  \/\/ Smaller table will cause creation of more old-gen garbage\n+  \/\/ as previous entries in table are overwritten with new values.\n+  static private final int TableSize = 53;\n+  static private final int MaxStringLength = 47;\n+  static private final int SentenceLength = 5;\n+\n+  static private Random random = new Random(SeedForRandom);\n+\n+  public static class Node {\n+    static private final int NeighborCount = 48;\n+    static private final int ChildOverwriteCount = 32;\n+    static private final int IntArraySize = 128;\n+\n+    private String name;\n+\n+    \/\/ Each Node instance holds an array containing all substrings of\n+    \/\/ its name\n+\n+    \/\/ This array has entries from 0 .. (name.length() - 1).\n+    \/\/ num_substrings[i] represents the number of substrings that\n+    \/\/ correspond to a name of length i+1.\n+    private static int [] num_substrings;\n+\n+    static {\n+      \/\/ Initialize num_substrings.\n+      \/\/ For a name of length N, there are\n+      \/\/  N substrings of length 1\n+      \/\/  N-1 substrings of length 2\n+      \/\/  N-2 substrings of length 3\n+      \/\/  ...\n+      \/\/  1 substring of length N\n+      \/\/ Note that:\n+      \/\/   num_substrings[0] = 1\n+      \/\/   num_substrings[1] = 3\n+      \/\/   num_substrings[i] = (i+1)+num_substrings[i-1]\n+\n+      num_substrings = new int[MaxStringLength];\n+      num_substrings[0] = 1;\n+      for (int i = 1; i < MaxStringLength; i++)\n+        num_substrings[i] = (i+1)+num_substrings[i-1];\n+    }\n+\n+    private String [] substrings;\n+    private Node [] neighbors;\n+\n+    public Node(String name) {\n+      this.name = name;\n+      this.substrings = new String[num_substrings[name.length() - 1]];\n+\n+      int index = 0;\n+      for (int substring_length = 1;\n+           substring_length <= name.length(); substring_length++) {\n+        for (int offset = 0;\n+             offset + substring_length <= name.length(); offset++) {\n+          this.substrings[index++] = name.substring(offset,\n+                                                    offset + substring_length);\n+        }\n+      }\n+    }\n+\n+    public String value() {\n+      return name;\n+    }\n+\n+    public String arbitrary_substring() {\n+      int index = TestConcurrentEvac.randomUnsignedInt() % substrings.length;\n+      return substrings[index];\n+    }\n+  }\n+\n+\n+  \/\/ Return random int between 1 and MaxStringLength inclusive\n+  static int randomStringLength() {\n+    int length = randomUnsignedInt();\n+    length %= (MaxStringLength - 1);\n+    length += 1;\n+    return length;\n+  }\n+\n+  static String randomCharacter() {\n+    int index = randomUnsignedInt() % 52;\n+    return (\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\".\n+            substring(index, index+1));\n+  }\n+\n+  static String randomString() {\n+    int length = randomStringLength();\n+    String result = new String(); \/\/ make the compiler work for this garbage...\n+    for (int i = 0; i < length; i++)\n+      result += randomCharacter();\n+    return result;\n+  }\n+\n+  static int randomUnsignedInt() {\n+    int result = random.nextInt();\n+    if (result < 0) result = -result;\n+    if (result < 0) result = 0;\n+    return result;\n+  }\n+\n+  static int randomIndex() {\n+    int index = randomUnsignedInt();\n+    index %= TableSize;\n+    return index;\n+  }\n+\n+  public static void main(String args[]) throws Exception {\n+    HashMap<Integer, Node> table = new HashMap<Integer, Node>(TableSize);\n+\n+    if (!wb.getBooleanVMFlag(\"UseShenandoahGC\") ||\n+        !wb.getStringVMFlag(\"ShenandoahGCMode\").equals(\"generational\"))\n+      throw new IllegalStateException(\"Command-line options not honored!\");\n+\n+    for (int count = java.lang.Integer.MAX_VALUE\/1024; count >= 0; count--) {\n+      int index = randomIndex();\n+      String name = randomString();\n+      table.put(index, new Node(name));\n+    }\n+\n+    String conclusion = \"\";\n+\n+    for (int i = 0; i < SentenceLength; i++) {\n+      Node a_node = table.get(randomIndex());\n+      if (a_node == null)\n+        i--;\n+      else {\n+        String a_string = a_node.arbitrary_substring();\n+        conclusion += a_string;\n+        conclusion += \" \";\n+      }\n+    }\n+    conclusion = conclusion.substring(0, conclusion.length() - 1);\n+\n+    System.out.println(\"Conclusion is [\" + conclusion + \"]\");\n+\n+    if (!conclusion.equals(\"cTy cTykJ kAkKAOWYEHbxFCmRIlyk xjYMdNmtAQXNGdIc sqHKsWnJIP\"))\n+      throw new IllegalStateException(\"Random sequence of words did not end well!\");\n+\n+  }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/generational\/TestConcurrentEvac.java","additions":209,"deletions":0,"binary":false,"changes":209,"status":"added"}]}