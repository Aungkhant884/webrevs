{"files":[{"patch":"@@ -467,1 +467,1 @@\n-  \/\/ garbage or entirely non-garbage.  Assume that if a head humongous region and the associated\n+  \/\/ garbage or entirely non-garbage.  Assume that a head humongous region and the associated\n@@ -474,1 +474,4 @@\n-  for (size_t i = 0; i < cand_idx; i++) {\n+  \/\/ This loop is written as while rather than for because of\n+  \/\/ suspected gcc error in translating\/optimizing for-loop\n+  size_t i = 0;\n+  while (i < first_humongous_non_empty) {\n@@ -479,1 +482,1 @@\n-        if (i == first_non_humongous_empty)\n+        if (i == first_non_humongous_empty) {\n@@ -481,1 +484,1 @@\n-        else {\n+        } else {\n@@ -486,0 +489,1 @@\n+        i++;\n@@ -488,1 +492,1 @@\n-        if (i + 1 == first_humongous_non_empty)\n+        if (i + 1 == first_humongous_non_empty) {\n@@ -490,1 +494,2 @@\n-        else {\n+          i++;\n+        } else {\n@@ -494,3 +499,1 @@\n-\n-          \/\/ Decrement i so I can look at this updated entry on next iteration\n-          i--;\n+          \/\/ Do not increment i so we can revisit swapped entry on next iteration\n@@ -499,0 +502,2 @@\n+    } else {\n+      i++;\n@@ -579,1 +584,1 @@\n-uint ShenandoahHeuristics::get_coalesce_and_fill_candidates(ShenandoahHeapRegion** buffer) {\n+void ShenandoahHeuristics::get_coalesce_and_fill_candidates(ShenandoahHeapRegion** buffer) {\n@@ -585,1 +590,0 @@\n-  return count;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.cpp","additions":15,"deletions":11,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -97,2 +97,1 @@\n-  \/\/  _old_heuristcs points to the ShenandoahHeuristics object that\n-  \/\/  represents old-gen.\n+  \/\/  _old_heuristics points to the ShenandoahHeuristics object that represents old-gen.\n@@ -242,2 +241,2 @@\n-  \/\/ end of the array.\n-  uint get_coalesce_and_fill_candidates(ShenandoahHeapRegion** buffer);\n+  \/\/ end of the array. \n+  void get_coalesce_and_fill_candidates(ShenandoahHeapRegion** buffer);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.hpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -80,0 +80,1 @@\n+\n@@ -81,3 +82,0 @@\n-  uint coalesce_and_fill_candidates = old_heuristics->old_coalesce_and_fill_candidates();\n-  ShenandoahHeapRegion* regions_to_coalesce_and_fill[coalesce_and_fill_candidates];\n-  old_heuristics->get_coalesce_and_fill_candidates(regions_to_coalesce_and_fill);\n@@ -151,1 +149,1 @@\n-  \/\/ HEY!  We need to implement preemption of coalesce and fill.  If young-gen wants to run while we're working on this,\n+  \/\/ TODO:  We need to implement preemption of coalesce and fill.  If young-gen wants to run while we're working on this,\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGC.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"}]}