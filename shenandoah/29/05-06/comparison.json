{"files":[{"patch":"@@ -99,1 +99,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, 2021, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2018, 2021, Red Hat, Inc. All rights reserved.\n@@ -27,0 +27,1 @@\n+#include \"gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveOldHeuristics.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, 2021, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2018, 2021, Red Hat, Inc. All rights reserved.\n@@ -29,1 +29,0 @@\n-#include \"gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.hpp\"\n@@ -33,0 +32,2 @@\n+class ShenandoahAllocationRate;\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveOldHeuristics.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019 Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2018, 2019, Red Hat, Inc. All rights reserved.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAggressiveHeuristics.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, 2021, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2018, 2021, Red Hat, Inc. All rights reserved.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAggressiveOldHeuristics.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, 2021, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2018, 2021, Red Hat, Inc. All rights reserved.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAggressiveOldHeuristics.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, 2021, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2018, 2021, Red Hat, Inc. All rights reserved.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahCompactOldHeuristics.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, 2021, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2018, 2021, Red Hat, Inc. All rights reserved.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahCompactOldHeuristics.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, 2021, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2018, 2021, Red Hat, Inc. All rights reserved.\n@@ -167,1 +167,1 @@\n-    \/\/ else, thisi s global collection and doesn't need to prime_collection_set()\n+    \/\/ else, this is global collection and doesn't need to prime_collection_set\n@@ -178,0 +178,1 @@\n+\n@@ -204,1 +205,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -154,2 +154,0 @@\n-\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-#include \"gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.hpp\"\n@@ -27,0 +26,2 @@\n+\n+#include \"gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.hpp\"\n@@ -44,4 +45,6 @@\n-  \/\/ TODO: These macro definitions represent a first approximation to desired operating parameters.\n-  \/\/ Eventually, these values should be determined by heuristics and should adjust dynamically based\n-  \/\/ on most current execution behavior.  In the interrim, we may choose to offer command-line options\n-  \/\/ to set the values of these configuration parameters.\n+  \/\/ TODO:\n+  \/\/ The max_old_evacuation_bytes and promotion_budget_bytes constants represent a first\n+  \/\/ approximation to desired operating parameters.  Eventually, these values should be determined\n+  \/\/ by heuristics and should adjust dynamically based on most current execution behavior.  In the\n+  \/\/ interrim, we may choose to offer command-line options to set the values of these configuration\n+  \/\/ parameters.\n@@ -49,3 +52,3 @@\n-  \/\/ MAX_OLD_EVACUATION_BYTES represents an \"arbitrary\" bound on how much evacuation effort is dedicated to\n-  \/\/ old-gen regions.\n-#define MAX_OLD_EVACUATION_BYTES (ShenandoahHeapRegion::region_size_bytes() * 8)\n+  \/\/ max_old_evacuation_bytes represents an \"arbitrary\" bound on how much evacuation effort is dedicated\n+  \/\/ to old-gen regions.\n+  const size_t max_old_evacuation_bytes = (ShenandoahHeapRegion::region_size_bytes() * 8);\n@@ -53,1 +56,1 @@\n-  \/\/ PROMOTION_BUDGET_BYTES represents an \"arbitrary\" bound on how many bytes can be consumed by young-gen\n+  \/\/ promotion_budget_bytes represents an \"arbitrary\" bound on how many bytes can be consumed by young-gen\n@@ -67,1 +70,1 @@\n-#define PROMOTION_BUDGET_BYTES (ShenandoahHeapRegion::region_size_bytes() \/ 2)\n+  const size_t promotion_budget_bytes = (ShenandoahHeapRegion::region_size_bytes() \/ 2);\n@@ -69,3 +72,1 @@\n-  \/\/ If a region is put into the collection set, then this region's free (not yet used) bytes are no longer\n-  \/\/ \"available\" to hold the results of other evacuations.  This causes further decrease in the value of\n-  \/\/ AVAILABLE_OLD_BYTES.\n+  \/\/ old_evacuation_budget is an upper bound on the amount of live memory that can be evacuated.\n@@ -73,3 +74,5 @@\n-  \/\/ We address this by reducing the evacuation budget by the amount of live memory in that region and by the\n-  \/\/ amount of unallocated memory in that region if the evacuation budget is constrained by availability of\n-  \/\/ free memory.\n+  \/\/ If a region is put into the collection set, then this region's free (not yet used) bytes are no longer\n+  \/\/ \"available\" to hold the results of other evacuations.  This may cause a decrease in the remaining amount\n+  \/\/ of memory that can still be evacuated.  We address this by reducing the evacuation budget by the amount\n+  \/\/ of live memory in that region and by the amount of unallocated memory in that region if the evacuation\n+  \/\/ budget is constrained by availability of free memory.  See remaining_old_evacuation_budget below.\n@@ -78,1 +81,2 @@\n-  size_t old_evacuation_budget = (_generation->available() > PROMOTION_BUDGET_BYTES)? _generation->available() - PROMOTION_BUDGET_BYTES: 0;\n+  size_t old_evacuation_budget = ((_generation->available() > promotion_budget_bytes)\n+                                  ? _generation->available() - promotion_budget_bytes: 0);\n@@ -80,4 +84,4 @@\n-  \/\/ But if the amount of available free space in old-gen memory exceeds the pacing bound on how much old-gen memory can be\n-  \/\/ evacuated during each evacuation pass, then cut the old-gen evacuation further.  The pacing bound is designed to assure\n-  \/\/ that old-gen evacuations to not excessively slow the evacuation pass in order to assure that young-gen GC cadence is\n-  \/\/ not disrupted.\n+  \/\/ But if the amount of available free space in old-gen memory exceeds the pacing bound on how much old-gen\n+  \/\/ memory can be evacuated during each evacuation pass, then cut the old-gen evacuation further.  The pacing\n+  \/\/ bound is designed to assure that old-gen evacuations to not excessively slow the evacuation pass in order\n+  \/\/ to assure that young-gen GC cadence is not disrupted.\n@@ -85,2 +89,2 @@\n-  \/\/ Represents availability of memory to hold evacuations beyond what is required to hold planned evacuations.  May go\n-  \/\/ negative if we choose to collect regions with large amounts of free memory.\n+  \/\/ excess_free_capacity represents availability of memory to hold evacuations beyond what is required to hold\n+  \/\/ planned evacuations.  It may go negative if we choose to collect regions with large amounts of free memory.\n@@ -88,3 +92,3 @@\n-  if (old_evacuation_budget > MAX_OLD_EVACUATION_BYTES) {\n-    excess_free_capacity = old_evacuation_budget - MAX_OLD_EVACUATION_BYTES;\n-    old_evacuation_budget = MAX_OLD_EVACUATION_BYTES;\n+  if (old_evacuation_budget > max_old_evacuation_bytes) {\n+    excess_free_capacity = old_evacuation_budget - max_old_evacuation_bytes;\n+    old_evacuation_budget = max_old_evacuation_bytes;\n@@ -96,2 +100,3 @@\n-  \/\/ The number of old-gen regions that were selected as candidates for collection at the end of the most recent old-gen\n-  \/\/ concurrent marking phase and have not yet been collected is represented by unprocessed_old_collection_candidates()\n+  \/\/ The number of old-gen regions that were selected as candidates for collection at the end of the most recent\n+  \/\/ old-gen concurrent marking phase and have not yet been collected is represented by\n+  \/\/ unprocessed_old_collection_candidates()\n@@ -102,2 +107,2 @@\n-    \/\/ Assuming region r is added to the collection set, what will be the remaining_old_evacuation_budget after accounting\n-    \/\/ for the loss of region r's free() memory.\n+    \/\/ Assuming region r is added to the collection set, what will be the remaining_old_evacuation_budget after\n+    \/\/ accounting for the loss of region r's free() memory.\n@@ -106,1 +111,2 @@\n-    \/\/ If we choose region r to be collected, then we need to decrease the capacity to hold other evacuations by the size of r's free memory.\n+    \/\/ If we choose region r to be collected, then we need to decrease the capacity to hold other evacuations by\n+    \/\/ the size of r's free memory.\n@@ -108,2 +114,2 @@\n-    \/\/ If subtracting r->free from excess_free_capacity() makes it go negative, that means we are going to have to decrease the\n-    \/\/ evacuation budget.\n+    \/\/ If subtracting r->free from excess_free_capacity() makes it go negative, that means we are going to have\n+    \/\/ to decrease the evacuation budget.\n@@ -112,2 +118,2 @@\n-        \/\/ By setting adjusted_remaining_old_evacuation_budget to 0, we prevent further additions to the old-gen collection set,\n-        \/\/ unless the region has zero live data bytes.\n+        \/\/ By setting adjusted_remaining_old_evacuation_budget to 0, we prevent further additions to the old-gen\n+        \/\/ collection set, unless the region has zero live data bytes.\n@@ -216,5 +222,9 @@\n-  \/\/ Any old-gen region that contains (ShenandoahGarbageThreshold\n-  \/\/ (default value 25))% garbage or more is to be evacuated.  In the\n-  \/\/ future, this threshold percentage may be specified on the command\n-  \/\/ line or preferrably determined by dynamic heuristics.\n-#define CollectionThresholdGarbagePercent ShenandoahGarbageThreshold\n+  \/\/ Any old-gen region that contains (ShenandoahGarbageThreshold (default value 25))% garbage or more is to\n+  \/\/ be evacuated.\n+  \/\/\n+  \/\/ TODO: it probably makes sense to define old-generation collection_threshold_garbage_percent differently\n+  \/\/ than the young-gen ShenandoahGarbageThreshold.  So a different command-line option might allow specification\n+  \/\/ distinct values for each.  Even better, allow collection_threshold_garbage_percent to be determined\n+  \/\/ adaptively, by heuristics.\n+\n+  const size_t collection_threshold_garbage_percent = ShenandoahGarbageThreshold;\n@@ -227,1 +237,1 @@\n-    if (percent_garbage < CollectionThresholdGarbagePercent) {\n+    if (percent_garbage < collection_threshold_garbage_percent) {\n@@ -249,2 +259,0 @@\n-#undef CollectionThresholdGarbagePercent\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.cpp","additions":51,"deletions":43,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, 2021, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2018, 2021, Red Hat, Inc. All rights reserved.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahPassiveOldHeuristics.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, 2021, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2018, 2021, Red Hat, Inc. All rights reserved.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahPassiveOldHeuristics.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,3 +30,0 @@\n-\/\/ TODO: Make this a subclass of ShenandoahHeuristics and create a \"tailored\" copy of this class to be subclass of\n-\/\/ ShenandoahOldHeuristics.  Fix the constructor implementation to invoke ShenandoahHeuristics() superclass constructor.\n-\/\/ Change ShenandoahMode::initialize_old_heuristics() to return the subclass of ShenandoahOldHeuristics.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahStaticHeuristics.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, 2021, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2018, 2021, Red Hat, Inc. All rights reserved.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahStaticOldHeuristics.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, 2021, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2018, 2021, Red Hat, Inc. All rights reserved.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahStaticOldHeuristics.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}