{"files":[{"patch":"@@ -57,2 +57,2 @@\n-ShenandoahAdaptiveHeuristics::ShenandoahAdaptiveHeuristics(ShenandoahGeneration* generation, ShenandoahHeuristics* old_heuristics) :\n-  ShenandoahHeuristics(generation, old_heuristics),\n+ShenandoahAdaptiveHeuristics::ShenandoahAdaptiveHeuristics(ShenandoahGeneration* generation) :\n+  ShenandoahHeuristics(generation),\n@@ -205,4 +205,0 @@\n-  if (ShenandoahHeuristics::should_defer_gc()) {\n-    return false;\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.cpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-  ShenandoahAdaptiveHeuristics(ShenandoahGeneration* generation, ShenandoahHeuristics* old_heuristics);\n+  ShenandoahAdaptiveHeuristics(ShenandoahGeneration* generation);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,304 @@\n+\/*\n+ * Copyright (c) 2018, 2019, 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"gc\/shenandoah\/heuristics\/shenandoahAdaptiveOldHeuristics.hpp\"\n+#include \"gc\/shenandoah\/shenandoahCollectionSet.hpp\"\n+#include \"gc\/shenandoah\/shenandoahFreeSet.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGeneration.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeapRegion.inline.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"logging\/logTag.hpp\"\n+#include \"utilities\/quickSort.hpp\"\n+\n+\/\/ These constants are used to adjust the margin of error for the moving\n+\/\/ average of the allocation rate and cycle time. The units are standard\n+\/\/ deviations.\n+const double ShenandoahAdaptiveOldHeuristics::FULL_PENALTY_SD = 0.2;\n+const double ShenandoahAdaptiveOldHeuristics::DEGENERATE_PENALTY_SD = 0.1;\n+\n+\/\/ These are used to decide if we want to make any adjustments at all\n+\/\/ at the end of a successful concurrent cycle.\n+const double ShenandoahAdaptiveOldHeuristics::LOWEST_EXPECTED_AVAILABLE_AT_END = -0.5;\n+const double ShenandoahAdaptiveOldHeuristics::HIGHEST_EXPECTED_AVAILABLE_AT_END = 0.5;\n+\n+\/\/ These values are the confidence interval expressed as standard deviations.\n+\/\/ At the minimum confidence level, there is a 25% chance that the true value of\n+\/\/ the estimate (average cycle time or allocation rate) is not more than\n+\/\/ MINIMUM_CONFIDENCE standard deviations away from our estimate. Similarly, the\n+\/\/ MAXIMUM_CONFIDENCE interval here means there is a one in a thousand chance\n+\/\/ that the true value of our estimate is outside the interval. These are used\n+\/\/ as bounds on the adjustments applied at the outcome of a GC cycle.\n+const double ShenandoahAdaptiveOldHeuristics::MINIMUM_CONFIDENCE = 0.319; \/\/ 25%\n+const double ShenandoahAdaptiveOldHeuristics::MAXIMUM_CONFIDENCE = 3.291; \/\/ 99.9%\n+\n+ShenandoahAdaptiveOldHeuristics::ShenandoahAdaptiveOldHeuristics(ShenandoahGeneration* generation) :\n+  ShenandoahOldHeuristics(generation),\n+  _margin_of_error_sd(ShenandoahAdaptiveInitialConfidence),\n+  _spike_threshold_sd(ShenandoahAdaptiveInitialSpikeThreshold),\n+  _last_trigger(OTHER) { }\n+\n+ShenandoahAdaptiveOldHeuristics::~ShenandoahAdaptiveOldHeuristics() {}\n+\n+void ShenandoahAdaptiveOldHeuristics::choose_collection_set_from_regiondata(ShenandoahCollectionSet* cset,\n+                                                                            RegionData* data, size_t size,\n+                                                                            size_t actual_free) {\n+  size_t garbage_threshold = ShenandoahHeapRegion::region_size_bytes() * ShenandoahGarbageThreshold \/ 100;\n+\n+  \/\/ The logic for cset selection in adaptive is as follows:\n+  \/\/\n+  \/\/   1. We cannot get cset larger than available free space. Otherwise we guarantee OOME\n+  \/\/      during evacuation, and thus guarantee full GC. In practice, we also want to let\n+  \/\/      application to allocate something. This is why we limit CSet to some fraction of\n+  \/\/      available space. In non-overloaded heap, max_cset would contain all plausible candidates\n+  \/\/      over garbage threshold.\n+  \/\/\n+  \/\/   2. We should not get cset too low so that free threshold would not be met right\n+  \/\/      after the cycle. Otherwise we get back-to-back cycles for no reason if heap is\n+  \/\/      too fragmented. In non-overloaded non-fragmented heap min_garbage would be around zero.\n+  \/\/\n+  \/\/ Therefore, we start by sorting the regions by garbage. Then we unconditionally add the best candidates\n+  \/\/ before we meet min_garbage. Then we add all candidates that fit with a garbage threshold before\n+  \/\/ we hit max_cset. When max_cset is hit, we terminate the cset selection. Note that in this scheme,\n+  \/\/ ShenandoahGarbageThreshold is the soft threshold which would be ignored until min_garbage is hit.\n+\n+  size_t capacity    = _generation->soft_max_capacity();\n+  size_t max_cset    = (size_t)((1.0 * capacity \/ 100 * ShenandoahEvacReserve) \/ ShenandoahEvacWaste);\n+  size_t free_target = (capacity \/ 100 * ShenandoahMinFreeThreshold) + max_cset;\n+  size_t min_garbage = (free_target > actual_free ? (free_target - actual_free) : 0);\n+\n+  log_info(gc, ergo)(\"Adaptive CSet Selection. Target Free: \" SIZE_FORMAT \"%s, Actual Free: \"\n+                     SIZE_FORMAT \"%s, Max CSet: \" SIZE_FORMAT \"%s, Min Garbage: \" SIZE_FORMAT \"%s\",\n+                     byte_size_in_proper_unit(free_target), proper_unit_for_byte_size(free_target),\n+                     byte_size_in_proper_unit(actual_free), proper_unit_for_byte_size(actual_free),\n+                     byte_size_in_proper_unit(max_cset),    proper_unit_for_byte_size(max_cset),\n+                     byte_size_in_proper_unit(min_garbage), proper_unit_for_byte_size(min_garbage));\n+\n+\n+  \/\/ Better select garbage-first regions\n+  QuickSort::sort<RegionData>(data, (int)size, compare_by_garbage, false);\n+\n+  size_t cur_cset = 0;\n+  size_t cur_garbage = 0;\n+\n+  for (size_t idx = 0; idx < size; idx++) {\n+    ShenandoahHeapRegion* r = data[idx]._region;\n+\n+    size_t new_cset    = cur_cset + r->get_live_data_bytes();\n+    size_t new_garbage = cur_garbage + r->garbage();\n+\n+    if (new_cset > max_cset) {\n+      break;\n+    }\n+\n+    if ((new_garbage < min_garbage) || (r->garbage() > garbage_threshold)) {\n+      cset->add_region(r);\n+      cur_cset = new_cset;\n+      cur_garbage = new_garbage;\n+    }\n+  }\n+}\n+\n+void ShenandoahAdaptiveOldHeuristics::record_cycle_start() {\n+  ShenandoahHeuristics::record_cycle_start();\n+  _allocation_rate.allocation_counter_reset();\n+}\n+\n+void ShenandoahAdaptiveOldHeuristics::record_success_concurrent() {\n+  ShenandoahHeuristics::record_success_concurrent();\n+\n+  size_t available = ShenandoahHeap::heap()->free_set()->available();\n+\n+  _available.add(available);\n+  double z_score = 0.0;\n+  if (_available.sd() > 0) {\n+    z_score = (available - _available.avg()) \/ _available.sd();\n+  }\n+\n+  log_debug(gc, ergo)(\"Available: \" SIZE_FORMAT \" %sB, z-score=%.3f. Average available: %.1f %sB +\/- %.1f %sB.\",\n+                      byte_size_in_proper_unit(available), proper_unit_for_byte_size(available),\n+                      z_score,\n+                      byte_size_in_proper_unit(_available.avg()), proper_unit_for_byte_size(_available.avg()),\n+                      byte_size_in_proper_unit(_available.sd()), proper_unit_for_byte_size(_available.sd()));\n+\n+  \/\/ In the case when a concurrent GC cycle completes successfully but with an\n+  \/\/ unusually small amount of available memory we will adjust our trigger\n+  \/\/ parameters so that they are more likely to initiate a new cycle.\n+  \/\/ Conversely, when a GC cycle results in an above average amount of available\n+  \/\/ memory, we will adjust the trigger parameters to be less likely to initiate\n+  \/\/ a GC cycle.\n+  \/\/\n+  \/\/ The z-score we've computed is in no way statistically related to the\n+  \/\/ trigger parameters, but it has the nice property that worse z-scores for\n+  \/\/ available memory indicate making larger adjustments to the trigger\n+  \/\/ parameters. It also results in fewer adjustments as the application\n+  \/\/ stabilizes.\n+  \/\/\n+  \/\/ In order to avoid making endless and likely unnecessary adjustments to the\n+  \/\/ trigger parameters, the change in available memory (with respect to the\n+  \/\/ average) at the end of a cycle must be beyond these threshold values.\n+  if (z_score < LOWEST_EXPECTED_AVAILABLE_AT_END ||\n+      z_score > HIGHEST_EXPECTED_AVAILABLE_AT_END) {\n+    \/\/ The sign is flipped because a negative z-score indicates that the\n+    \/\/ available memory at the end of the cycle is below average. Positive\n+    \/\/ adjustments make the triggers more sensitive (i.e., more likely to fire).\n+    \/\/ The z-score also gives us a measure of just how far below normal. This\n+    \/\/ property allows us to adjust the trigger parameters proportionally.\n+    \/\/\n+    \/\/ The `100` here is used to attenuate the size of our adjustments. This\n+    \/\/ number was chosen empirically. It also means the adjustments at the end of\n+    \/\/ a concurrent cycle are an order of magnitude smaller than the adjustments\n+    \/\/ made for a degenerated or full GC cycle (which themselves were also\n+    \/\/ chosen empirically).\n+    adjust_last_trigger_parameters(z_score \/ -100);\n+  }\n+}\n+\n+void ShenandoahAdaptiveOldHeuristics::record_success_degenerated() {\n+  ShenandoahHeuristics::record_success_degenerated();\n+  \/\/ Adjust both trigger's parameters in the case of a degenerated GC because\n+  \/\/ either of them should have triggered earlier to avoid this case.\n+  adjust_margin_of_error(DEGENERATE_PENALTY_SD);\n+  adjust_spike_threshold(DEGENERATE_PENALTY_SD);\n+}\n+\n+void ShenandoahAdaptiveOldHeuristics::record_success_full() {\n+  ShenandoahHeuristics::record_success_full();\n+  \/\/ Adjust both trigger's parameters in the case of a full GC because\n+  \/\/ either of them should have triggered earlier to avoid this case.\n+  adjust_margin_of_error(FULL_PENALTY_SD);\n+  adjust_spike_threshold(FULL_PENALTY_SD);\n+}\n+\n+static double saturate(double value, double min, double max) {\n+  return MAX2(MIN2(value, max), min);\n+}\n+\n+bool ShenandoahAdaptiveOldHeuristics::should_start_gc() {\n+  size_t max_capacity = _generation->max_capacity();\n+  size_t capacity = _generation->soft_max_capacity();\n+  size_t available = _generation->available();\n+  size_t allocated = _generation->bytes_allocated_since_gc_start();\n+\n+  \/\/ Make sure the code below treats available without the soft tail.\n+  size_t soft_tail = max_capacity - capacity;\n+  available = (available > soft_tail) ? (available - soft_tail) : 0;\n+\n+  \/\/ Track allocation rate even if we decide to start a cycle for other reasons.\n+  double rate = _allocation_rate.sample(allocated);\n+  _last_trigger = OTHER;\n+\n+  size_t min_threshold = capacity \/ 100 * ShenandoahMinFreeThreshold;\n+  if (available < min_threshold) {\n+    log_info(gc)(\"Trigger (%s): Free (\" SIZE_FORMAT \"%s) is below minimum threshold (\" SIZE_FORMAT \"%s)\",\n+                 _generation->name(),\n+                 byte_size_in_proper_unit(available),     proper_unit_for_byte_size(available),\n+                 byte_size_in_proper_unit(min_threshold), proper_unit_for_byte_size(min_threshold));\n+    return true;\n+  }\n+\n+  \/\/ Check if are need to learn a bit about the application\n+  const size_t max_learn = ShenandoahLearningSteps;\n+  if (_gc_times_learned < max_learn) {\n+    size_t init_threshold = capacity \/ 100 * ShenandoahInitFreeThreshold;\n+    if (available < init_threshold) {\n+      log_info(gc)(\"Trigger (%s): Learning \" SIZE_FORMAT \" of \" SIZE_FORMAT \". Free (\" SIZE_FORMAT \"%s) is below initial threshold (\" SIZE_FORMAT \"%s)\",\n+                   _generation->name(), _gc_times_learned + 1, max_learn,\n+                   byte_size_in_proper_unit(available),      proper_unit_for_byte_size(available),\n+                   byte_size_in_proper_unit(init_threshold), proper_unit_for_byte_size(init_threshold));\n+      return true;\n+    }\n+  }\n+\n+  \/\/ Check if allocation headroom is still okay. This also factors in:\n+  \/\/   1. Some space to absorb allocation spikes\n+  \/\/   2. Accumulated penalties from Degenerated and Full GC\n+  size_t allocation_headroom = available;\n+\n+  size_t spike_headroom = capacity \/ 100 * ShenandoahAllocSpikeFactor;\n+  size_t penalties      = capacity \/ 100 * _gc_time_penalties;\n+\n+  allocation_headroom -= MIN2(allocation_headroom, spike_headroom);\n+  allocation_headroom -= MIN2(allocation_headroom, penalties);\n+\n+  double avg_cycle_time = _gc_time_history->davg() + (_margin_of_error_sd * _gc_time_history->dsd());\n+  double avg_alloc_rate = _allocation_rate.upper_bound(_margin_of_error_sd);\n+  if (avg_cycle_time > allocation_headroom \/ avg_alloc_rate) {\n+    log_info(gc)(\"Trigger (%s): Average GC time (%.2f ms) is above the time for average allocation rate (%.0f %sB\/s) to deplete free headroom (\" SIZE_FORMAT \"%s) (margin of error = %.2f)\",\n+                 _generation->name(), avg_cycle_time * 1000,\n+                 byte_size_in_proper_unit(avg_alloc_rate), proper_unit_for_byte_size(avg_alloc_rate),\n+                 byte_size_in_proper_unit(allocation_headroom), proper_unit_for_byte_size(allocation_headroom),\n+                 _margin_of_error_sd);\n+\n+    log_info(gc, ergo)(\"Free headroom: \" SIZE_FORMAT \"%s (free) - \" SIZE_FORMAT \"%s (spike) - \" SIZE_FORMAT \"%s (penalties) = \" SIZE_FORMAT \"%s\",\n+                       byte_size_in_proper_unit(available),           proper_unit_for_byte_size(available),\n+                       byte_size_in_proper_unit(spike_headroom),      proper_unit_for_byte_size(spike_headroom),\n+                       byte_size_in_proper_unit(penalties),           proper_unit_for_byte_size(penalties),\n+                       byte_size_in_proper_unit(allocation_headroom), proper_unit_for_byte_size(allocation_headroom));\n+\n+    _last_trigger = RATE;\n+    return true;\n+  }\n+\n+  bool is_spiking = _allocation_rate.is_spiking(rate, _spike_threshold_sd);\n+  if (is_spiking && avg_cycle_time > allocation_headroom \/ rate) {\n+    log_info(gc)(\"Trigger (%s): Average GC time (%.2f ms) is above the time for instantaneous allocation rate (%.0f %sB\/s) to deplete free headroom (\" SIZE_FORMAT \"%s) (spike threshold = %.2f)\",\n+                 _generation->name(), avg_cycle_time * 1000,\n+                 byte_size_in_proper_unit(rate), proper_unit_for_byte_size(rate),\n+                 byte_size_in_proper_unit(allocation_headroom), proper_unit_for_byte_size(allocation_headroom),\n+                 _spike_threshold_sd);\n+    _last_trigger = SPIKE;\n+    return true;\n+  }\n+\n+  return ShenandoahHeuristics::should_start_gc();\n+}\n+\n+void ShenandoahAdaptiveOldHeuristics::adjust_last_trigger_parameters(double amount) {\n+  switch (_last_trigger) {\n+    case RATE:\n+      adjust_margin_of_error(amount);\n+      break;\n+    case SPIKE:\n+      adjust_spike_threshold(amount);\n+      break;\n+    case OTHER:\n+      \/\/ nothing to adjust here.\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+  }\n+}\n+\n+void ShenandoahAdaptiveOldHeuristics::adjust_margin_of_error(double amount) {\n+  _margin_of_error_sd = saturate(_margin_of_error_sd + amount, MINIMUM_CONFIDENCE, MAXIMUM_CONFIDENCE);\n+  log_debug(gc, ergo)(\"Margin of error now %.2f\", _margin_of_error_sd);\n+}\n+\n+void ShenandoahAdaptiveOldHeuristics::adjust_spike_threshold(double amount) {\n+  _spike_threshold_sd = saturate(_spike_threshold_sd - amount, MINIMUM_CONFIDENCE, MAXIMUM_CONFIDENCE);\n+  log_debug(gc, ergo)(\"Spike threshold now: %.2f\", _spike_threshold_sd);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveOldHeuristics.cpp","additions":304,"deletions":0,"binary":false,"changes":304,"status":"added"},{"patch":"@@ -0,0 +1,110 @@\n+\/*\n+ * Copyright (c) 2018, 2019, 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHENANDOAH_HEURISTICS_SHENANDOAHADAPTIVEOLDHEURISTICS_HPP\n+#define SHARE_GC_SHENANDOAH_HEURISTICS_SHENANDOAHADAPTIVEOLDHEURISTICS_HPP\n+\n+#include \"gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.hpp\"\n+#include \"gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.hpp\"\n+#include \"gc\/shenandoah\/shenandoahPhaseTimings.hpp\"\n+#include \"utilities\/numberSeq.hpp\"\n+\n+class ShenandoahAdaptiveOldHeuristics : public ShenandoahOldHeuristics {\n+public:\n+  ShenandoahAdaptiveOldHeuristics(ShenandoahGeneration* generation);\n+\n+  virtual ~ShenandoahAdaptiveOldHeuristics();\n+\n+  virtual void choose_collection_set_from_regiondata(ShenandoahCollectionSet* cset,\n+                                                     RegionData* data, size_t size,\n+                                                     size_t actual_free);\n+\n+  void record_cycle_start();\n+  void record_success_concurrent();\n+  void record_success_degenerated();\n+  void record_success_full();\n+\n+  virtual bool should_start_gc();\n+\n+  virtual const char* name()     { return \"AdaptiveOld\"; }\n+  virtual bool is_diagnostic()   { return false; }\n+  virtual bool is_experimental() { return false; }\n+\n+ private:\n+  \/\/ These are used to adjust the margin of error and the spike threshold\n+  \/\/ in response to GC cycle outcomes. These values are shared, but the\n+  \/\/ margin of error and spike threshold trend in opposite directions.\n+  const static double FULL_PENALTY_SD;\n+  const static double DEGENERATE_PENALTY_SD;\n+\n+  const static double MINIMUM_CONFIDENCE;\n+  const static double MAXIMUM_CONFIDENCE;\n+\n+  const static double LOWEST_EXPECTED_AVAILABLE_AT_END;\n+  const static double HIGHEST_EXPECTED_AVAILABLE_AT_END;\n+\n+  friend class ShenandoahAllocationRate;\n+\n+  \/\/ Used to record the last trigger that signaled to start a GC.\n+  \/\/ This itself is used to decide whether or not to adjust the margin of\n+  \/\/ error for the average cycle time and allocation rate or the allocation\n+  \/\/ spike detection threshold.\n+  enum Trigger {\n+    SPIKE, RATE, OTHER\n+  };\n+\n+  void adjust_last_trigger_parameters(double amount);\n+  void adjust_margin_of_error(double amount);\n+  void adjust_spike_threshold(double amount);\n+\n+  ShenandoahAllocationRate _allocation_rate;\n+\n+  \/\/ The margin of error expressed in standard deviations to add to our\n+  \/\/ average cycle time and allocation rate. As this value increases we\n+  \/\/ tend to over estimate the rate at which mutators will deplete the\n+  \/\/ heap. In other words, erring on the side of caution will trigger more\n+  \/\/ concurrent GCs.\n+  double _margin_of_error_sd;\n+\n+  \/\/ The allocation spike threshold is expressed in standard deviations.\n+  \/\/ If the standard deviation of the most recent sample of the allocation\n+  \/\/ rate exceeds this threshold, a GC cycle is started. As this value\n+  \/\/ decreases the sensitivity to allocation spikes increases. In other\n+  \/\/ words, lowering the spike threshold will tend to increase the number\n+  \/\/ of concurrent GCs.\n+  double _spike_threshold_sd;\n+\n+  \/\/ Remember which trigger is responsible for the last GC cycle. When the\n+  \/\/ outcome of the cycle is evaluated we will adjust the parameters for the\n+  \/\/ corresponding triggers. Note that successful outcomes will raise\n+  \/\/ the spike threshold and lower the margin of error.\n+  Trigger _last_trigger;\n+\n+  \/\/ Keep track of the available memory at the end of a GC cycle. This\n+  \/\/ establishes what is 'normal' for the application and is used as a\n+  \/\/ source of feedback to adjust trigger parameters.\n+  TruncatedSeq _available;\n+};\n+\n+#endif \/\/ SHARE_GC_SHENANDOAH_HEURISTICS_SHENANDOAHADAPTIVEOLDHEURISTICS_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveOldHeuristics.hpp","additions":110,"deletions":0,"binary":false,"changes":110,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2018, 2019 Red Hat, Inc. All rights reserved.\n@@ -34,1 +34,1 @@\n-ShenandoahAggressiveHeuristics::ShenandoahAggressiveHeuristics(ShenandoahGeneration* generation, ShenandoahHeuristics* old_heuristics) : ShenandoahHeuristics(generation, old_heuristics) {\n+ShenandoahAggressiveHeuristics::ShenandoahAggressiveHeuristics(ShenandoahGeneration* generation) : ShenandoahHeuristics(generation) {\n@@ -60,3 +60,0 @@\n-  if (ShenandoahHeuristics::should_defer_gc()) {\n-    return false;\n-  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAggressiveHeuristics.cpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-  ShenandoahAggressiveHeuristics(ShenandoahGeneration* generation, ShenandoahHeuristics* old_heuristics);\n+  ShenandoahAggressiveHeuristics(ShenandoahGeneration* generation);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAggressiveHeuristics.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2018, 2019, 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"gc\/shenandoah\/heuristics\/shenandoahAggressiveOldHeuristics.hpp\"\n+#include \"gc\/shenandoah\/shenandoahCollectionSet.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeapRegion.inline.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"logging\/logTag.hpp\"\n+#include \"runtime\/os.hpp\"\n+\n+ShenandoahAggressiveOldHeuristics::ShenandoahAggressiveOldHeuristics(ShenandoahGeneration* generation) : ShenandoahOldHeuristics(generation) {\n+  \/\/ Do not shortcut evacuation\n+  SHENANDOAH_ERGO_OVERRIDE_DEFAULT(ShenandoahImmediateThreshold, 100);\n+\n+  \/\/ Aggressive evacuates everything, so it needs as much evac space as it can get\n+  SHENANDOAH_ERGO_ENABLE_FLAG(ShenandoahEvacReserveOverflow);\n+\n+  \/\/ If class unloading is globally enabled, aggressive does unloading even with\n+  \/\/ concurrent cycles.\n+  if (ClassUnloading) {\n+    SHENANDOAH_ERGO_OVERRIDE_DEFAULT(ShenandoahUnloadClassesFrequency, 1);\n+  }\n+}\n+\n+void ShenandoahAggressiveOldHeuristics::choose_collection_set_from_regiondata(ShenandoahCollectionSet* cset,\n+                                                                             RegionData* data, size_t size,\n+                                                                             size_t free) {\n+  for (size_t idx = 0; idx < size; idx++) {\n+    ShenandoahHeapRegion* r = data[idx]._region;\n+    if (r->garbage() > 0) {\n+      cset->add_region(r);\n+    }\n+  }\n+}\n+\n+bool ShenandoahAggressiveOldHeuristics::should_start_gc() {\n+  log_info(gc)(\"Trigger: Start next cycle immediately\");\n+  return true;\n+}\n+\n+bool ShenandoahAggressiveOldHeuristics::should_unload_classes() {\n+  if (!can_unload_classes_normal()) return false;\n+  if (has_metaspace_oom()) return true;\n+  \/\/ Randomly unload classes with 50% chance.\n+  return (os::random() & 1) == 1;\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAggressiveOldHeuristics.cpp","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2018, 2019, 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHENANDOAH_HEURISTICS_SHENANDOAHAGGRESSIVEOLDHEURISTICS_HPP\n+#define SHARE_GC_SHENANDOAH_HEURISTICS_SHENANDOAHAGGRESSIVEOLDHEURISTICS_HPP\n+\n+#include \"gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.hpp\"\n+\n+class ShenandoahAggressiveOldHeuristics : public ShenandoahOldHeuristics {\n+public:\n+  ShenandoahAggressiveOldHeuristics(ShenandoahGeneration* generation);\n+\n+  virtual void choose_collection_set_from_regiondata(ShenandoahCollectionSet* cset,\n+                                                     RegionData* data, size_t size,\n+                                                     size_t free);\n+\n+  virtual bool should_start_gc();\n+\n+  virtual bool should_unload_classes();\n+\n+  virtual const char* name()     { return \"AggressiveOld\"; }\n+  virtual bool is_diagnostic()   { return true; }\n+  virtual bool is_experimental() { return false; }\n+};\n+\n+#endif \/\/ SHARE_GC_SHENANDOAH_HEURISTICS_SHENANDOAHAGGRESSIVEOLDHEURISTICS_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAggressiveOldHeuristics.hpp","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -35,2 +35,2 @@\n-ShenandoahCompactHeuristics::ShenandoahCompactHeuristics(ShenandoahGeneration* generation, ShenandoahHeuristics* old_heuristics) :\n-  ShenandoahHeuristics(generation, old_heuristics) {\n+ShenandoahCompactHeuristics::ShenandoahCompactHeuristics(ShenandoahGeneration* generation) :\n+  ShenandoahHeuristics(generation) {\n@@ -53,4 +53,0 @@\n-  if (ShenandoahHeuristics::should_defer_gc()) {\n-    return false;\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahCompactHeuristics.cpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-  ShenandoahCompactHeuristics(ShenandoahGeneration* generation, ShenandoahHeuristics* old_heuristics);\n+  ShenandoahCompactHeuristics(ShenandoahGeneration* generation);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahCompactHeuristics.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * Copyright (c) 2018, 2019, 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"gc\/shenandoah\/shenandoahCollectionSet.hpp\"\n+#include \"gc\/shenandoah\/heuristics\/shenandoahCompactOldHeuristics.hpp\"\n+#include \"gc\/shenandoah\/shenandoahFreeSet.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGeneration.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeapRegion.inline.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"logging\/logTag.hpp\"\n+\n+ShenandoahCompactOldHeuristics::ShenandoahCompactOldHeuristics(ShenandoahGeneration* generation) :\n+  ShenandoahOldHeuristics(generation) {\n+  SHENANDOAH_ERGO_ENABLE_FLAG(ExplicitGCInvokesConcurrent);\n+  SHENANDOAH_ERGO_ENABLE_FLAG(ShenandoahImplicitGCInvokesConcurrent);\n+  SHENANDOAH_ERGO_ENABLE_FLAG(ShenandoahUncommit);\n+  SHENANDOAH_ERGO_ENABLE_FLAG(ShenandoahAlwaysClearSoftRefs);\n+  SHENANDOAH_ERGO_OVERRIDE_DEFAULT(ShenandoahAllocationThreshold,  10);\n+  SHENANDOAH_ERGO_OVERRIDE_DEFAULT(ShenandoahImmediateThreshold,   100);\n+  SHENANDOAH_ERGO_OVERRIDE_DEFAULT(ShenandoahUncommitDelay,        1000);\n+  SHENANDOAH_ERGO_OVERRIDE_DEFAULT(ShenandoahGuaranteedGCInterval, 30000);\n+  SHENANDOAH_ERGO_OVERRIDE_DEFAULT(ShenandoahGarbageThreshold,     10);\n+}\n+\n+bool ShenandoahCompactOldHeuristics::should_start_gc() {\n+  size_t max_capacity = _generation->max_capacity();\n+  size_t capacity = _generation->soft_max_capacity();\n+  size_t available = _generation->available();\n+\n+  \/\/ Make sure the code below treats available without the soft tail.\n+  size_t soft_tail = max_capacity - capacity;\n+  available = (available > soft_tail) ? (available - soft_tail) : 0;\n+\n+  size_t threshold_bytes_allocated = capacity \/ 100 * ShenandoahAllocationThreshold;\n+  size_t min_threshold = capacity \/ 100 * ShenandoahMinFreeThreshold;\n+\n+  if (available < min_threshold) {\n+    log_info(gc)(\"Trigger: Free (\" SIZE_FORMAT \"%s) is below minimum threshold (\" SIZE_FORMAT \"%s)\",\n+                 byte_size_in_proper_unit(available),     proper_unit_for_byte_size(available),\n+                 byte_size_in_proper_unit(min_threshold), proper_unit_for_byte_size(min_threshold));\n+    return true;\n+  }\n+\n+  size_t bytes_allocated = _generation->bytes_allocated_since_gc_start();\n+  if (bytes_allocated > threshold_bytes_allocated) {\n+    log_info(gc)(\"Trigger: Allocated since last cycle (\" SIZE_FORMAT \"%s) is larger than allocation threshold (\" SIZE_FORMAT \"%s)\",\n+                 byte_size_in_proper_unit(bytes_allocated),           proper_unit_for_byte_size(bytes_allocated),\n+                 byte_size_in_proper_unit(threshold_bytes_allocated), proper_unit_for_byte_size(threshold_bytes_allocated));\n+    return true;\n+  }\n+\n+  return ShenandoahHeuristics::should_start_gc();\n+}\n+\n+void ShenandoahCompactOldHeuristics::choose_collection_set_from_regiondata(ShenandoahCollectionSet* cset,\n+                                                                           RegionData* data, size_t size,\n+                                                                           size_t actual_free) {\n+  \/\/ Do not select too large CSet that would overflow the available free space\n+  size_t max_cset = actual_free * 3 \/ 4;\n+\n+  log_info(gc, ergo)(\"CSet Selection. Actual Free: \" SIZE_FORMAT \"%s, Max CSet: \" SIZE_FORMAT \"%s\",\n+                     byte_size_in_proper_unit(actual_free), proper_unit_for_byte_size(actual_free),\n+                     byte_size_in_proper_unit(max_cset),    proper_unit_for_byte_size(max_cset));\n+\n+  size_t threshold = ShenandoahHeapRegion::region_size_bytes() * ShenandoahGarbageThreshold \/ 100;\n+\n+  size_t live_cset = 0;\n+  for (size_t idx = 0; idx < size; idx++) {\n+    ShenandoahHeapRegion* r = data[idx]._region;\n+    size_t new_cset = live_cset + r->get_live_data_bytes();\n+    if (new_cset < max_cset && r->garbage() > threshold) {\n+      live_cset = new_cset;\n+      cset->add_region(r);\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahCompactOldHeuristics.cpp","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2018, 2019, 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHENANDOAH_HEURISTICS_SHENANDOAHCOMPACTOLDHEURISTICS_HPP\n+#define SHARE_GC_SHENANDOAH_HEURISTICS_SHENANDOAHCOMPACTOLDHEURISTICS_HPP\n+\n+#include \"gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.hpp\"\n+\n+class ShenandoahCompactOldHeuristics : public ShenandoahOldHeuristics {\n+public:\n+  ShenandoahCompactOldHeuristics(ShenandoahGeneration* generation);\n+\n+  virtual bool should_start_gc();\n+\n+  virtual void choose_collection_set_from_regiondata(ShenandoahCollectionSet* cset,\n+                                                     RegionData* data, size_t size,\n+                                                     size_t actual_free);\n+\n+  virtual const char* name()     { return \"CompactOld\"; }\n+  virtual bool is_diagnostic()   { return false; }\n+  virtual bool is_experimental() { return false; }\n+};\n+\n+#endif \/\/ SHARE_GC_SHENANDOAH_HEURISTICS_SHENANDOAHCOMPACTOLDHEURISTICS_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahCompactOldHeuristics.hpp","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2018, 2020, 2021, Red Hat, Inc. All rights reserved.\n@@ -39,1 +39,0 @@\n-#include \"utilities\/quickSort.hpp\"\n@@ -49,2 +48,1 @@\n-ShenandoahHeuristics::ShenandoahHeuristics(ShenandoahGeneration* generation,\n-                                           ShenandoahHeuristics* old_heuristics) :\n+ShenandoahHeuristics::ShenandoahHeuristics(ShenandoahGeneration* generation) :\n@@ -52,1 +50,0 @@\n-  _old_heuristics(old_heuristics),\n@@ -54,6 +51,0 @@\n-  _old_collection_candidates(0),\n-  _next_old_collection_candidate(0),\n-  _hidden_old_collection_candidates(0),\n-  _hidden_next_old_collection_candidate(0),\n-  _old_coalesce_and_fill_candidates(0),\n-  _first_coalesce_and_fill_candidate(0),\n@@ -84,101 +75,1 @@\n-void ShenandoahHeuristics::prime_collection_set_with_old_candidates(ShenandoahCollectionSet* collection_set) {\n-  uint included_old_regions = 0;\n-  size_t evacuated_old_bytes = 0;\n-\n-  \/\/ TODO: These macro definitions represent a first approximation to desired operating parameters.\n-  \/\/ Eventually, these values should be determined by heuristics and should adjust dynamically based\n-  \/\/ on most current execution behavior.  In the interrim, we may choose to offer command-line options\n-  \/\/ to set the values of these configuration parameters.\n-\n-  \/\/ MAX_OLD_EVACUATION_BYTES represents an \"arbitrary\" bound on how much evacuation effort is dedicated to\n-  \/\/ old-gen regions.\n-#define MAX_OLD_EVACUATION_BYTES (ShenandoahHeapRegion::region_size_bytes() * 8)\n-\n-  \/\/ PROMOTION_BUDGET_BYTES represents an \"arbitrary\" bound on how many bytes can be consumed by young-gen\n-  \/\/ objects promoted into old-gen memory.  We need to avoid a scenario under which promotion of objects\n-  \/\/ depletes old-gen available memory to the point that there is insufficient memory to hold old-gen objects\n-  \/\/ that need to be evacuated from within the old-gen collection set.\n-  \/\/\n-  \/\/ TODO We should probably enforce this, but there is no enforcement currently.  Key idea: if there is not\n-  \/\/ sufficient memory within old-gen to hold an object that wants to be promoted, defer promotion until a\n-  \/\/ subsequent evacuation pass.  Since enforcement may be expensive, requiring frequent synchronization\n-  \/\/ between mutator and GC threads, here's an alternative \"greedy\" mitigation strategy: Set the parameter's\n-  \/\/ value so overflow is \"very rare\".  In the case that we experience overflow, evacuate what we can from\n-  \/\/ within the old collection set, but don't evacuate everything.  At the end of evacuation, any collection\n-  \/\/ set region that was not fully evacuated cannot be recycled.  It becomes a prime candidate for the next\n-  \/\/ collection set selection.  Here, we'd rather fall back to this contingent behavior than force a full STW\n-  \/\/ collection.\n-#define PROMOTION_BUDGET_BYTES (ShenandoahHeapRegion::region_size_bytes() \/ 2)\n-\n-  \/\/ If a region is put into the collection set, then this region's free (not yet used) bytes are no longer\n-  \/\/ \"available\" to hold the results of other evacuations.  This causes further decrease in the value of\n-  \/\/ AVAILABLE_OLD_BYTES.\n-  \/\/\n-  \/\/ We address this by reducing the evacuation budget by the amount of live memory in that region and by the\n-  \/\/ amount of unallocated memory in that region if the evacuation budget is constrained by availability of\n-  \/\/ free memory.\n-\n-  \/\/ Allow no more evacuation than exists free-space within old-gen memory\n-  size_t old_evacuation_budget = (_old_heuristics->_generation->available() > PROMOTION_BUDGET_BYTES)? _old_heuristics->_generation->available() - PROMOTION_BUDGET_BYTES: 0;\n-\n-  \/\/ But if the amount of available free space in old-gen memory exceeds the pacing bound on how much old-gen memory can be\n-  \/\/ evacuated during each evacuation pass, then cut the old-gen evacuation further.  The pacing bound is designed to assure\n-  \/\/ that old-gen evacuations to not excessively slow the evacuation pass in order to assure that young-gen GC cadence is\n-  \/\/ not disrupted.\n-\n-  \/\/ Represents availability of memory to hold evacuations beyond what is required to hold planned evacuations.  May go\n-  \/\/ negative if we choose to collect regions with large amounts of free memory.\n-  long long excess_free_capacity;\n-  if (old_evacuation_budget > MAX_OLD_EVACUATION_BYTES) {\n-    excess_free_capacity = old_evacuation_budget - MAX_OLD_EVACUATION_BYTES;\n-    old_evacuation_budget = MAX_OLD_EVACUATION_BYTES;\n-  } else\n-    excess_free_capacity = 0;\n-\n-  size_t remaining_old_evacuation_budget = old_evacuation_budget;\n-\n-  \/\/ The number of old-gen regions that were selected as candidates for collection at the end of the most recent old-gen\n-  \/\/ concurrent marking phase and have not yet been collected is represented by unprocessed_old_collection_candidates()\n-  while (_old_heuristics->unprocessed_old_collection_candidates() > 0) {\n-    \/\/ Old collection candidates are sorted in order of decreasing garbage contained therein.\n-    ShenandoahHeapRegion* r = _old_heuristics->next_old_collection_candidate();\n-\n-    \/\/ Assuming region r is added to the collection set, what will be the remaining_old_evacuation_budget after accounting\n-    \/\/ for the loss of region r's free() memory.\n-    size_t adjusted_remaining_old_evacuation_budget;\n-\n-    \/\/ If we choose region r to be collected, then we need to decrease the capacity to hold other evacuations by the size of r's free memory.\n-    excess_free_capacity -= r->free();\n-    \/\/ If subtracting r->free from excess_free_capacity() makes it go negative, that means we are going to have to decrease the\n-    \/\/ evacuation budget.\n-    if (excess_free_capacity < 0) {\n-      if (remaining_old_evacuation_budget < (size_t) -excess_free_capacity) {\n-        \/\/ By setting adjusted_remaining_old_evacuation_budget to 0, we prevent further additions to the old-gen collection set,\n-        \/\/ unless the region has zero live data bytes.\n-        adjusted_remaining_old_evacuation_budget = 0;\n-      } else {\n-        \/\/ Adding negative excess_free_capacity decreases the adjusted_remaining_old_evacuation_budget\n-        adjusted_remaining_old_evacuation_budget = remaining_old_evacuation_budget + excess_free_capacity;\n-      }\n-    } else {\n-      adjusted_remaining_old_evacuation_budget = remaining_old_evacuation_budget;\n-    }\n-\n-    if (r->get_live_data_bytes() > adjusted_remaining_old_evacuation_budget) {\n-      break;\n-    }\n-    collection_set->add_region(r);\n-    included_old_regions++;\n-    evacuated_old_bytes += r->get_live_data_bytes();\n-    _old_heuristics->consume_old_collection_candidate();\n-    remaining_old_evacuation_budget = adjusted_remaining_old_evacuation_budget - r->get_live_data_bytes();\n-  }\n-\n-  if (included_old_regions > 0) {\n-    log_info(gc)(\"Old-gen piggyback evac (%llu regions, %llu bytes)\",\n-                 (unsigned long long) included_old_regions,\n-                 (unsigned long long) evacuated_old_bytes);\n-  }\n-}\n-\n-void ShenandoahHeuristics::prepare_for_other_collection(ShenandoahCollectionSet* collection_set) {\n+void ShenandoahHeuristics::choose_collection_set(ShenandoahCollectionSet* collection_set, ShenandoahOldHeuristics* old_heuristics) {\n@@ -187,0 +78,3 @@\n+  assert(collection_set->count() == 0, \"Must be empty\");\n+  assert(_generation->generation_mode() != OLD, \"Old GC invokes ShenandoahOldHeuristics::choose_collection_set()\");\n+\n@@ -270,2 +164,2 @@\n-    if (_old_heuristics != NULL) {\n-      prime_collection_set_with_old_candidates(collection_set);\n+    if (old_heuristics != NULL) {\n+      old_heuristics->prime_collection_set(collection_set);\n@@ -273,0 +167,1 @@\n+    \/\/ else, thisi s global collection and doesn't need to prime_collection_set()\n@@ -300,12 +195,0 @@\n-void ShenandoahHeuristics::choose_collection_set(ShenandoahCollectionSet* collection_set) {\n-  assert(collection_set->count() == 0, \"Must be empty\");\n-\n-  if (_generation->generation_mode() == OLD) {\n-    \/\/ Old-gen doesn't actually choose a collection set to be evacuated by its own gang of worker tasks.\n-    \/\/ Instead, it computes the set of regions to be evacuated by subsequent young-gen evacuation passes.\n-    prepare_for_old_collections();\n-  } else {\n-    prepare_for_other_collection(collection_set);\n-  }\n-}\n-\n@@ -320,14 +203,0 @@\n-bool ShenandoahHeuristics::should_defer_gc() {\n-  if ((_generation->generation_mode() == OLD) && (unprocessed_old_collection_candidates() > 0)) {\n-    \/\/ Cannot start a new old-gen GC until previous one has finished.\n-    \/\/\n-    \/\/ Future refinement: under certain circumstances, we might be more\n-    \/\/ sophisticated about this choice.  But if we choose to abandon\n-    \/\/ previous old collection before it has completed evacuations,\n-    \/\/ we would need to coalesce and fill all garbage within\n-    \/\/ unevacuated collection-set regions.\n-    return true;\n-  }\n-  return false;\n-}\n-\n@@ -336,3 +205,0 @@\n-  if (should_defer_gc())\n-    return false;\n-\n@@ -451,148 +317,0 @@\n-void ShenandoahHeuristics::prepare_for_old_collections() {\n-  assert(_generation->generation_mode() == OLD, \"This service only available for old-gc heuristics\");\n-  ShenandoahHeap* heap = ShenandoahHeap::heap();\n-  uint free_regions = 0;\n-  size_t cand_idx = 0;\n-  size_t total_garbage = 0;\n-  size_t num_regions = heap->num_regions();\n-\n-  RegionData* candidates = _region_data;\n-  for (size_t i = 0; i < num_regions; i++) {\n-    ShenandoahHeapRegion* region = heap->get_region(i);\n-    if (!in_generation(region))\n-      continue;\n-    else {\n-      size_t garbage = region->garbage();\n-      total_garbage += garbage;\n-\n-      candidates[cand_idx]._region = region;\n-      candidates[cand_idx]._garbage = garbage;\n-      cand_idx++;\n-    }\n-  }\n-\n-  \/\/ Give special treatment to humongous regions.  Assume humongous regions is entirely\n-  \/\/ garbage or entirely non-garbage.  Assume that a head humongous region and the associated\n-  \/\/ humongous continuous regions are uniformly entirely garbage or entirely non-garbage.\n-  \/\/\n-  \/\/ Sift garbage humongous regions to front, non-garbage humongous regions to end of array.\n-  size_t first_non_humongous_empty = 0;\n-  size_t first_humongous_non_empty = cand_idx;\n-\n-  \/\/ This loop is written as while rather than for because of\n-  \/\/ suspected gcc error in translating\/optimizing for-loop\n-  size_t i = 0;\n-  while (i < first_humongous_non_empty) {\n-    ShenandoahHeapRegion* region = candidates[i]._region;\n-    if (region->is_humongous()) {\n-      if (region->get_live_data_bytes() == 0) {\n-        \/\/ Humongous region is entirely garbage.  Reclaim it.\n-        if (i == first_non_humongous_empty) {\n-          first_non_humongous_empty++;\n-        } else {\n-          RegionData swap_tmp = candidates[i];\n-          candidates[i] = candidates[first_non_humongous_empty];\n-          candidates[first_non_humongous_empty++] = swap_tmp;\n-        }\n-        i++;\n-      } else {\n-        \/\/ Humongous region is non garbage.  Don't reclaim it.\n-        if (i + 1 == first_humongous_non_empty) {\n-          first_humongous_non_empty--;\n-          i++;\n-        } else {\n-          RegionData swap_tmp = candidates[i];\n-          candidates[i] = candidates[--first_humongous_non_empty];\n-          candidates[first_humongous_non_empty] = swap_tmp;\n-          \/\/ Do not increment i so we can revisit swapped entry on next iteration\n-        }\n-      }\n-    } else {\n-      i++;\n-    }\n-  }\n-\n-\n-  \/\/ Prioritize regions to select garbage-first regions\n-  QuickSort::sort<RegionData>(candidates + first_non_humongous_empty, (int)(first_humongous_non_empty - first_non_humongous_empty),\n-                              compare_by_garbage, false);\n-\n-  \/\/ Any old-gen region that contains 50% garbage or more is to be\n-  \/\/ evacuated.  In the future, this threshold percentage may be specified on\n-  \/\/ the command line or preferrably determined by dynamic heuristics.\n-#define CollectionThresholdGarbagePercent 50\n-\n-  size_t region_size = ShenandoahHeapRegion::region_size_bytes();\n-  for (size_t i = first_non_humongous_empty; i < first_humongous_non_empty; i++) {\n-    \/\/ Do approximate percent to avoid floating point math\n-    size_t percent_garbage = candidates[i]._garbage * 100 \/ region_size;\n-\n-    if (percent_garbage < CollectionThresholdGarbagePercent) {\n-      _hidden_next_old_collection_candidate = 0;\n-      _hidden_old_collection_candidates = i;\n-      _first_coalesce_and_fill_candidate = i;\n-      _old_coalesce_and_fill_candidates = cand_idx - i;\n-\n-      \/\/ Note that we do not coalesce and fill occupied humongous regions\n-      \/\/ HR: humongous regions, RR: regular regions, CF: coalesce and fill regions\n-      log_info(gc)(\"Old-gen mark evac (%u HR, %llu RR), %llu CF)\",\n-                   (unsigned int) first_non_humongous_empty,\n-                   (unsigned long long) (_hidden_old_collection_candidates - first_non_humongous_empty),\n-                   (unsigned long long) _old_coalesce_and_fill_candidates);\n-      return;\n-    }\n-  }\n-\n-  \/\/ If we reach here, all of non-humogous old-gen regions are candidates for collection set.\n-  _hidden_next_old_collection_candidate = 0;\n-  _hidden_old_collection_candidates = first_humongous_non_empty;\n-  _first_coalesce_and_fill_candidate = 0;\n-  _old_coalesce_and_fill_candidates = 0;\n-\n-#undef CollectionThresholdGarbagePercent\n-\n-  \/\/ Note that we do not coalesce and fill occupied humongous regions\n-  \/\/ HR: humongous regions, RR: regular regions, CF: coalesce and fill regions\n-  log_info(gc)(\"Old-gen mark evac (%u HR, %llu RR), %llu CF)\",\n-               (unsigned int) first_non_humongous_empty,\n-               (unsigned long long) (_hidden_old_collection_candidates - first_non_humongous_empty),\n-               (unsigned long long) _old_coalesce_and_fill_candidates);\n-}\n-\n-void ShenandoahHeuristics::start_old_evacuations() {\n-  assert(_generation->generation_mode() == OLD, \"This service only available for old-gc heuristics\");\n-\n-  _old_collection_candidates = _hidden_old_collection_candidates;\n-  _next_old_collection_candidate = _hidden_next_old_collection_candidate;\n-\n-  _hidden_old_collection_candidates = 0;}\n-\n-\n-uint ShenandoahHeuristics::unprocessed_old_collection_candidates() {\n-  assert(_generation->generation_mode() == OLD, \"This service only available for old-gc heuristics\");\n-  return _old_collection_candidates + _hidden_old_collection_candidates;\n-}\n-\n-ShenandoahHeapRegion* ShenandoahHeuristics::next_old_collection_candidate() {\n-  assert(_generation->generation_mode() == OLD, \"This service only available for old-gc heuristics\");\n-  return _region_data[_next_old_collection_candidate]._region;\n-}\n-\n-void ShenandoahHeuristics::consume_old_collection_candidate() {\n-  assert(_generation->generation_mode() == OLD, \"This service only available for old-gc heuristics\");\n-  _next_old_collection_candidate++;\n-  _old_collection_candidates--;\n-}\n-\n-uint ShenandoahHeuristics::old_coalesce_and_fill_candidates() {\n-  assert(_generation->generation_mode() == OLD, \"This service only available for old-gc heuristics\");\n-  return _old_coalesce_and_fill_candidates;\n-}\n-\n-void ShenandoahHeuristics::get_coalesce_and_fill_candidates(ShenandoahHeapRegion** buffer) {\n-  assert(_generation->generation_mode() == OLD, \"This service only available for old-gc heuristics\");\n-  uint count = _old_coalesce_and_fill_candidates;\n-  int index = _first_coalesce_and_fill_candidate;\n-  while (count-- > 0)\n-    *buffer++ = _region_data[index++]._region;\n-}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.cpp","additions":9,"deletions":291,"binary":false,"changes":300,"status":"modified"},{"patch":"@@ -61,20 +61,0 @@\n-\/\/ TODO: Probably want to subclass ShenandoahHeuristics.\n-\/\/\n-\/\/ As currently implemented, we have three instances of\n-\/\/ ShenandoahHeuristics, for GLOBAL, OLD, and YOUNG.  Each instance\n-\/\/ needs different information.\n-\/\/\n-\/\/ In particular:\n-\/\/  YOUNG needs a pointer to OLD so it can ask if there are OLD regions\n-\/\/   wanting to be evacuated.\n-\/\/  OLD needs to keep track of which OLD regions need to be evacuated and\n-\/\/   which OLD regions need their garbage to be coalesced and filled.\n-\/\/   OLD also needs to know when all of its candidate evacuation regions\n-\/\/   have been evacuated because it cannot trigger a new OLD\n-\/\/   concurrent mark until that has happened.\n-\/\/  GLOBAL: not sure what this needs, or how it interacts with OLD, YOUNG\n-\/\/   heuristics.\n-\/\/\n-\/\/ For expediency, we'll have a single class that is a \"union\" of\n-\/\/ necessary functionality.\n-\n@@ -94,6 +74,0 @@\n-  \/\/ if (_generation->generation_mode() != YOUNG)\n-  \/\/  _old_heuristics = NULL;\n-  \/\/ else\n-  \/\/  _old_heuristics points to the ShenandoahHeuristics object that represents old-gen.\n-  ShenandoahHeuristics *_old_heuristics;\n-\n@@ -115,28 +89,0 @@\n-  \/\/ if (_generation->generation_mode() == OLD) _old_collection_candidates\n-  \/\/  represent the number of regions selected for collection following the\n-  \/\/  most recently completed old-gen mark that have not yet been selected\n-  \/\/  for evacuation and _next_collection_candidate is the index within\n-  \/\/  _region_data of the next candidate region to be selected for evacuation.\n-  \/\/ if (_generation->generation_mode() != OLD) these two variables are\n-  \/\/  not used.\n-  uint _old_collection_candidates;\n-  uint _next_old_collection_candidate;\n-\n-  \/\/ At the time we select the old-gen collection set, _hidden_old_collection_candidates\n-  \/\/ and _hidden_next_old_collection_candidates are set to remember the intended old-gen\n-  \/\/ collection set.  After all old-gen regions not in the old-gen collection set have been\n-  \/\/ coalesced and filled, the content of these variables is copied to _old_collection_candidates\n-  \/\/ and _next_old_collection_candidates so that evacuations can begin evacuating these regions.\n-  uint _hidden_old_collection_candidates;\n-  uint _hidden_next_old_collection_candidate;\n-\n-  \/\/ if (_generation->generation_mode() == OLD)\n-  \/\/  _old_coalesce_and_fill_candidates represents the number of regions\n-  \/\/  that were chosen for the garbage contained therein to be coalesced\n-  \/\/  and filled and _first_coalesce_and_fill_candidate represents the\n-  \/\/  the index of the first such region within the _region_data array.\n-  \/\/ if (_generation->generation_mode() != OLD) these two variables are\n-  \/\/  not used.\n-  uint _old_coalesce_and_fill_candidates;\n-  uint _first_coalesce_and_fill_candidate;\n-\n@@ -170,8 +116,0 @@\n-  void prime_collection_set_with_old_candidates(ShenandoahCollectionSet* set);\n-\n-  \/\/ Prepare for evacuation of old-gen regions by capturing the mark results of a recently completed concurrent mark pass.\n-  void prepare_for_old_collections();\n-\n-  \/\/ Prepare for global or young-gen collection\n-  void prepare_for_other_collection(ShenandoahCollectionSet* set);\n-\n@@ -179,2 +117,1 @@\n-  ShenandoahHeuristics(ShenandoahGeneration* generation,\n-                       ShenandoahHeuristics* old_heuristics);\n+  ShenandoahHeuristics(ShenandoahGeneration* generation);\n@@ -191,2 +128,0 @@\n-  bool should_defer_gc();\n-\n@@ -207,1 +142,1 @@\n-  virtual void choose_collection_set(ShenandoahCollectionSet* collection_set);\n+  virtual void choose_collection_set(ShenandoahCollectionSet* collection_set, ShenandoahOldHeuristics* old_heuristics);\n@@ -221,28 +156,0 @@\n-  \/\/ The following methods are only relevant if _generation->generation_mode() == OLD.  These methods perform no\n-  \/\/ synchronization.  It is assumed that all of them are invoked by the same ShenandoahControlThread.\n-\n-  \/\/ Having coalesced and filled all old-gen heap regions that are not part of the old-gen collection set, begin\n-  \/\/ evacuating the collection set.\n-  void start_old_evacuations();\n-\n-  \/\/ How many old-collection candidates have not yet been processed?\n-  uint unprocessed_old_collection_candidates();\n-\n-  \/\/ Return the next old-collection candidate in order of decreasing amounts of garbage.  (We process most-garbage regions\n-  \/\/ first.)  This does not consume the candidate.  If the candidate is selected for inclusion in a collection set, then\n-  \/\/ the candidate is consumed by invoking consume_old_collection_candidate().\n-  ShenandoahHeapRegion* next_old_collection_candidate();\n-\n-  \/\/ Adjust internal state to reflect that one fewer old-collection candidate remains to be processed.\n-  void consume_old_collection_candidate();\n-\n-  \/\/ How many old-collection regions were identified at the end of the most recent old-gen mark to require their\n-  \/\/ unmarked objects to be coalesced and filled?\n-  uint old_coalesce_and_fill_candidates();\n-\n-  \/\/ Fill in buffer with all of the old-collection regions that were identified at the end of the most recent old-gen\n-  \/\/ mark to require their unmarked objects to be coalesced and filled.  The buffer array must have at least\n-  \/\/ old_coalesce_and_fill_candidates() entries, or memory may be corrupted when this function overwrites the\n-  \/\/ end of the array.\n-  void get_coalesce_and_fill_candidates(ShenandoahHeapRegion** buffer);\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.hpp","additions":2,"deletions":95,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -0,0 +1,309 @@\n+\/*\n+ * Copyright (c) 2021, Amazon.com, Inc. or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.hpp\"\n+#include \"precompiled.hpp\"\n+#include \"utilities\/quickSort.hpp\"\n+\n+ShenandoahOldHeuristics::ShenandoahOldHeuristics(ShenandoahGeneration* generation) :\n+    ShenandoahHeuristics(generation),\n+    _old_collection_candidates(0),\n+    _next_old_collection_candidate(0),\n+    _hidden_old_collection_candidates(0),\n+    _hidden_next_old_collection_candidate(0),\n+    _old_coalesce_and_fill_candidates(0),\n+    _first_coalesce_and_fill_candidate(0)\n+{\n+}\n+\n+void ShenandoahOldHeuristics::prime_collection_set(ShenandoahCollectionSet* collection_set) {\n+  uint included_old_regions = 0;\n+  size_t evacuated_old_bytes = 0;\n+\n+  \/\/ TODO: These macro definitions represent a first approximation to desired operating parameters.\n+  \/\/ Eventually, these values should be determined by heuristics and should adjust dynamically based\n+  \/\/ on most current execution behavior.  In the interrim, we may choose to offer command-line options\n+  \/\/ to set the values of these configuration parameters.\n+\n+  \/\/ MAX_OLD_EVACUATION_BYTES represents an \"arbitrary\" bound on how much evacuation effort is dedicated to\n+  \/\/ old-gen regions.\n+#define MAX_OLD_EVACUATION_BYTES (ShenandoahHeapRegion::region_size_bytes() * 8)\n+\n+  \/\/ PROMOTION_BUDGET_BYTES represents an \"arbitrary\" bound on how many bytes can be consumed by young-gen\n+  \/\/ objects promoted into old-gen memory.  We need to avoid a scenario under which promotion of objects\n+  \/\/ depletes old-gen available memory to the point that there is insufficient memory to hold old-gen objects\n+  \/\/ that need to be evacuated from within the old-gen collection set.\n+  \/\/\n+  \/\/ TODO We should probably enforce this, but there is no enforcement currently.  Key idea: if there is not\n+  \/\/ sufficient memory within old-gen to hold an object that wants to be promoted, defer promotion until a\n+  \/\/ subsequent evacuation pass.  Since enforcement may be expensive, requiring frequent synchronization\n+  \/\/ between mutator and GC threads, here's an alternative \"greedy\" mitigation strategy: Set the parameter's\n+  \/\/ value so overflow is \"very rare\".  In the case that we experience overflow, evacuate what we can from\n+  \/\/ within the old collection set, but don't evacuate everything.  At the end of evacuation, any collection\n+  \/\/ set region that was not fully evacuated cannot be recycled.  It becomes a prime candidate for the next\n+  \/\/ collection set selection.  Here, we'd rather fall back to this contingent behavior than force a full STW\n+  \/\/ collection.\n+#define PROMOTION_BUDGET_BYTES (ShenandoahHeapRegion::region_size_bytes() \/ 2)\n+\n+  \/\/ If a region is put into the collection set, then this region's free (not yet used) bytes are no longer\n+  \/\/ \"available\" to hold the results of other evacuations.  This causes further decrease in the value of\n+  \/\/ AVAILABLE_OLD_BYTES.\n+  \/\/\n+  \/\/ We address this by reducing the evacuation budget by the amount of live memory in that region and by the\n+  \/\/ amount of unallocated memory in that region if the evacuation budget is constrained by availability of\n+  \/\/ free memory.\n+\n+  \/\/ Allow no more evacuation than exists free-space within old-gen memory\n+  size_t old_evacuation_budget = (_generation->available() > PROMOTION_BUDGET_BYTES)? _generation->available() - PROMOTION_BUDGET_BYTES: 0;\n+\n+  \/\/ But if the amount of available free space in old-gen memory exceeds the pacing bound on how much old-gen memory can be\n+  \/\/ evacuated during each evacuation pass, then cut the old-gen evacuation further.  The pacing bound is designed to assure\n+  \/\/ that old-gen evacuations to not excessively slow the evacuation pass in order to assure that young-gen GC cadence is\n+  \/\/ not disrupted.\n+\n+  \/\/ Represents availability of memory to hold evacuations beyond what is required to hold planned evacuations.  May go\n+  \/\/ negative if we choose to collect regions with large amounts of free memory.\n+  long long excess_free_capacity;\n+  if (old_evacuation_budget > MAX_OLD_EVACUATION_BYTES) {\n+    excess_free_capacity = old_evacuation_budget - MAX_OLD_EVACUATION_BYTES;\n+    old_evacuation_budget = MAX_OLD_EVACUATION_BYTES;\n+  } else\n+    excess_free_capacity = 0;\n+\n+  size_t remaining_old_evacuation_budget = old_evacuation_budget;\n+\n+  \/\/ The number of old-gen regions that were selected as candidates for collection at the end of the most recent old-gen\n+  \/\/ concurrent marking phase and have not yet been collected is represented by unprocessed_old_collection_candidates()\n+  while (unprocessed_old_collection_candidates() > 0) {\n+    \/\/ Old collection candidates are sorted in order of decreasing garbage contained therein.\n+    ShenandoahHeapRegion* r = next_old_collection_candidate();\n+\n+    \/\/ Assuming region r is added to the collection set, what will be the remaining_old_evacuation_budget after accounting\n+    \/\/ for the loss of region r's free() memory.\n+    size_t adjusted_remaining_old_evacuation_budget;\n+\n+    \/\/ If we choose region r to be collected, then we need to decrease the capacity to hold other evacuations by the size of r's free memory.\n+    excess_free_capacity -= r->free();\n+    \/\/ If subtracting r->free from excess_free_capacity() makes it go negative, that means we are going to have to decrease the\n+    \/\/ evacuation budget.\n+    if (excess_free_capacity < 0) {\n+      if (remaining_old_evacuation_budget < (size_t) -excess_free_capacity) {\n+        \/\/ By setting adjusted_remaining_old_evacuation_budget to 0, we prevent further additions to the old-gen collection set,\n+        \/\/ unless the region has zero live data bytes.\n+        adjusted_remaining_old_evacuation_budget = 0;\n+      } else {\n+        \/\/ Adding negative excess_free_capacity decreases the adjusted_remaining_old_evacuation_budget\n+        adjusted_remaining_old_evacuation_budget = remaining_old_evacuation_budget + excess_free_capacity;\n+      }\n+    } else {\n+      adjusted_remaining_old_evacuation_budget = remaining_old_evacuation_budget;\n+    }\n+\n+    if (r->get_live_data_bytes() > adjusted_remaining_old_evacuation_budget) {\n+      break;\n+    }\n+    collection_set->add_region(r);\n+    included_old_regions++;\n+    evacuated_old_bytes += r->get_live_data_bytes();\n+    consume_old_collection_candidate();\n+    remaining_old_evacuation_budget = adjusted_remaining_old_evacuation_budget - r->get_live_data_bytes();\n+  }\n+\n+  if (included_old_regions > 0) {\n+    log_info(gc)(\"Old-gen piggyback evac (%llu regions, %llu bytes)\",\n+                 (unsigned long long) included_old_regions,\n+                 (unsigned long long) evacuated_old_bytes);\n+  }\n+}\n+\n+\n+void ShenandoahOldHeuristics::choose_collection_set(ShenandoahCollectionSet* collection_set, ShenandoahOldHeuristics* old_heuristics) {\n+  assert(collection_set->count() == 0, \"Must be empty\");\n+\n+  \/\/ Old-gen doesn't actually choose a collection set to be evacuated by its own gang of worker tasks.\n+  \/\/ Instead, it computes the set of regions to be evacuated by subsequent young-gen evacuation passes.\n+  prepare_for_old_collections();\n+}\n+\n+void ShenandoahOldHeuristics::prepare_for_old_collections() {\n+  assert(_generation->generation_mode() == OLD, \"This service only available for old-gc heuristics\");\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  uint free_regions = 0;\n+  size_t cand_idx = 0;\n+  size_t total_garbage = 0;\n+  size_t num_regions = heap->num_regions();\n+\n+  RegionData* candidates = _region_data;\n+  for (size_t i = 0; i < num_regions; i++) {\n+    ShenandoahHeapRegion* region = heap->get_region(i);\n+    if (!in_generation(region))\n+      continue;\n+    else {\n+      size_t garbage = region->garbage();\n+      total_garbage += garbage;\n+\n+      candidates[cand_idx]._region = region;\n+      candidates[cand_idx]._garbage = garbage;\n+      cand_idx++;\n+    }\n+  }\n+\n+  \/\/ Give special treatment to humongous regions.  Assume humongous regions is entirely\n+  \/\/ garbage or entirely non-garbage.  Assume that a head humongous region and the associated\n+  \/\/ humongous continuous regions are uniformly entirely garbage or entirely non-garbage.\n+  \/\/\n+  \/\/ Sift garbage humongous regions to front, non-garbage humongous regions to end of array.\n+  size_t first_non_humongous_empty = 0;\n+  size_t first_humongous_non_empty = cand_idx;\n+\n+  \/\/ This loop is written as while rather than for because of\n+  \/\/ suspected gcc error in translating\/optimizing for-loop\n+  size_t i = 0;\n+  while (i < first_humongous_non_empty) {\n+    ShenandoahHeapRegion* region = candidates[i]._region;\n+    if (region->is_humongous()) {\n+      if (region->get_live_data_bytes() == 0) {\n+        \/\/ Humongous region is entirely garbage.  Reclaim it.\n+        if (i == first_non_humongous_empty) {\n+          first_non_humongous_empty++;\n+        } else {\n+          RegionData swap_tmp = candidates[i];\n+          candidates[i] = candidates[first_non_humongous_empty];\n+          candidates[first_non_humongous_empty++] = swap_tmp;\n+        }\n+        i++;\n+      } else {\n+        \/\/ Humongous region is non garbage.  Don't reclaim it.\n+        if (i + 1 == first_humongous_non_empty) {\n+          first_humongous_non_empty--;\n+          i++;\n+        } else {\n+          RegionData swap_tmp = candidates[i];\n+          candidates[i] = candidates[--first_humongous_non_empty];\n+          candidates[first_humongous_non_empty] = swap_tmp;\n+          \/\/ Do not increment i so we can revisit swapped entry on next iteration\n+        }\n+      }\n+    } else {\n+      i++;\n+    }\n+  }\n+\n+\n+  \/\/ Prioritize regions to select garbage-first regions\n+  QuickSort::sort<RegionData>(candidates + first_non_humongous_empty, (int)(first_humongous_non_empty - first_non_humongous_empty),\n+                              compare_by_garbage, false);\n+\n+  \/\/ Any old-gen region that contains 50% garbage or more is to be\n+  \/\/ evacuated.  In the future, this threshold percentage may be specified on\n+  \/\/ the command line or preferrably determined by dynamic heuristics.\n+#define CollectionThresholdGarbagePercent 50\n+\n+  size_t region_size = ShenandoahHeapRegion::region_size_bytes();\n+  for (size_t i = first_non_humongous_empty; i < first_humongous_non_empty; i++) {\n+    \/\/ Do approximate percent to avoid floating point math\n+    size_t percent_garbage = candidates[i]._garbage * 100 \/ region_size;\n+\n+    if (percent_garbage < CollectionThresholdGarbagePercent) {\n+      _hidden_next_old_collection_candidate = 0;\n+      _hidden_old_collection_candidates = i;\n+      _first_coalesce_and_fill_candidate = i;\n+      _old_coalesce_and_fill_candidates = cand_idx - i;\n+\n+      \/\/ Note that we do not coalesce and fill occupied humongous regions\n+      \/\/ HR: humongous regions, RR: regular regions, CF: coalesce and fill regions\n+      log_info(gc)(\"Old-gen mark evac (%u HR, %llu RR), %llu CF)\",\n+                   (unsigned int) first_non_humongous_empty,\n+                   (unsigned long long) (_hidden_old_collection_candidates - first_non_humongous_empty),\n+                   (unsigned long long) _old_coalesce_and_fill_candidates);\n+      return;\n+    }\n+  }\n+\n+  \/\/ If we reach here, all of non-humogous old-gen regions are candidates for collection set.\n+  _hidden_next_old_collection_candidate = 0;\n+  _hidden_old_collection_candidates = first_humongous_non_empty;\n+  _first_coalesce_and_fill_candidate = 0;\n+  _old_coalesce_and_fill_candidates = 0;\n+\n+#undef CollectionThresholdGarbagePercent\n+\n+  \/\/ Note that we do not coalesce and fill occupied humongous regions\n+  \/\/ HR: humongous regions, RR: regular regions, CF: coalesce and fill regions\n+  log_info(gc)(\"Old-gen mark evac (%u HR, %llu RR), %llu CF)\",\n+               (unsigned int) first_non_humongous_empty,\n+               (unsigned long long) (_hidden_old_collection_candidates - first_non_humongous_empty),\n+               (unsigned long long) _old_coalesce_and_fill_candidates);\n+}\n+\n+void ShenandoahOldHeuristics::start_old_evacuations() {\n+  assert(_generation->generation_mode() == OLD, \"This service only available for old-gc heuristics\");\n+\n+  _old_collection_candidates = _hidden_old_collection_candidates;\n+  _next_old_collection_candidate = _hidden_next_old_collection_candidate;\n+\n+  _hidden_old_collection_candidates = 0;}\n+\n+\n+uint ShenandoahOldHeuristics::unprocessed_old_collection_candidates() {\n+  assert(_generation->generation_mode() == OLD, \"This service only available for old-gc heuristics\");\n+  return _old_collection_candidates + _hidden_old_collection_candidates;\n+}\n+\n+ShenandoahHeapRegion* ShenandoahOldHeuristics::next_old_collection_candidate() {\n+  assert(_generation->generation_mode() == OLD, \"This service only available for old-gc heuristics\");\n+  return _region_data[_next_old_collection_candidate]._region;\n+}\n+\n+void ShenandoahOldHeuristics::consume_old_collection_candidate() {\n+  assert(_generation->generation_mode() == OLD, \"This service only available for old-gc heuristics\");\n+  _next_old_collection_candidate++;\n+  _old_collection_candidates--;\n+}\n+\n+uint ShenandoahOldHeuristics::old_coalesce_and_fill_candidates() {\n+  assert(_generation->generation_mode() == OLD, \"This service only available for old-gc heuristics\");\n+  return _old_coalesce_and_fill_candidates;\n+}\n+\n+void ShenandoahOldHeuristics::get_coalesce_and_fill_candidates(ShenandoahHeapRegion** buffer) {\n+  assert(_generation->generation_mode() == OLD, \"This service only available for old-gc heuristics\");\n+  uint count = _old_coalesce_and_fill_candidates;\n+  int index = _first_coalesce_and_fill_candidate;\n+  while (count-- > 0)\n+    *buffer++ = _region_data[index++]._region;\n+}\n+\n+bool ShenandoahOldHeuristics::should_defer_gc() {\n+  if (unprocessed_old_collection_candidates() > 0) {\n+    \/\/ Cannot start a new old-gen GC until previous one has finished.\n+    \/\/\n+    \/\/ Future refinement: under certain circumstances, we might be more sophisticated about this choice.\n+    \/\/ For example, we could choose to abandon the prevoius old collection before it has completed evacuations,\n+    \/\/ but this would require that we coalesce and fill all garbage within unevacuated collection-set regions.\n+    return true;\n+  }\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.cpp","additions":309,"deletions":0,"binary":false,"changes":309,"status":"added"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2021, Amazon.com, Inc. or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHENANDOAH_HEURISTICS_SHENANDOAHOLDHEURISTICS_HPP\n+#define SHARE_GC_SHENANDOAH_HEURISTICS_SHENANDOAHOLDHEURISTICS_HPP\n+\n+#include \"gc\/shenandoah\/shenandoahCollectionSet.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGeneration.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeapRegion.inline.hpp\"\n+#include \"gc\/shenandoah\/heuristics\/shenandoahHeuristics.hpp\"\n+\n+class ShenandoahOldHeuristics : public ShenandoahHeuristics {\n+\n+protected:\n+\n+  \/\/ if (_generation->generation_mode() == OLD) _old_collection_candidates\n+  \/\/  represent the number of regions selected for collection following the\n+  \/\/  most recently completed old-gen mark that have not yet been selected\n+  \/\/  for evacuation and _next_collection_candidate is the index within\n+  \/\/  _region_data of the next candidate region to be selected for evacuation.\n+  \/\/ if (_generation->generation_mode() != OLD) these two variables are\n+  \/\/  not used.\n+  uint _old_collection_candidates;\n+  uint _next_old_collection_candidate;\n+\n+  \/\/ At the time we select the old-gen collection set, _hidden_old_collection_candidates\n+  \/\/ and _hidden_next_old_collection_candidates are set to remember the intended old-gen\n+  \/\/ collection set.  After all old-gen regions not in the old-gen collection set have been\n+  \/\/ coalesced and filled, the content of these variables is copied to _old_collection_candidates\n+  \/\/ and _next_old_collection_candidates so that evacuations can begin evacuating these regions.\n+  uint _hidden_old_collection_candidates;\n+  uint _hidden_next_old_collection_candidate;\n+\n+  \/\/ if (_generation->generation_mode() == OLD)\n+  \/\/  _old_coalesce_and_fill_candidates represents the number of regions\n+  \/\/  that were chosen for the garbage contained therein to be coalesced\n+  \/\/  and filled and _first_coalesce_and_fill_candidate represents the\n+  \/\/  the index of the first such region within the _region_data array.\n+  \/\/ if (_generation->generation_mode() != OLD) these two variables are\n+  \/\/  not used.\n+  uint _old_coalesce_and_fill_candidates;\n+  uint _first_coalesce_and_fill_candidate;\n+\n+  \/\/ Prepare for evacuation of old-gen regions by capturing the mark results of a recently completed concurrent mark pass.\n+  void prepare_for_old_collections();\n+\n+public:\n+  ShenandoahOldHeuristics(ShenandoahGeneration* generation);\n+\n+  virtual void choose_collection_set(ShenandoahCollectionSet* collection_set, ShenandoahOldHeuristics* old_heuristics);\n+\n+  void prime_collection_set(ShenandoahCollectionSet* set);\n+\n+  \/\/ Having coalesced and filled all old-gen heap regions that are not part of the old-gen collection set, begin\n+  \/\/ evacuating the collection set.\n+  void start_old_evacuations();\n+\n+  \/\/ How many old-collection candidates have not yet been processed?\n+  uint unprocessed_old_collection_candidates();\n+\n+  \/\/ Return the next old-collection candidate in order of decreasing amounts of garbage.  (We process most-garbage regions\n+  \/\/ first.)  This does not consume the candidate.  If the candidate is selected for inclusion in a collection set, then\n+  \/\/ the candidate is consumed by invoking consume_old_collection_candidate().\n+  ShenandoahHeapRegion* next_old_collection_candidate();\n+\n+  \/\/ Adjust internal state to reflect that one fewer old-collection candidate remains to be processed.\n+  void consume_old_collection_candidate();\n+\n+  \/\/ How many old-collection regions were identified at the end of the most recent old-gen mark to require their\n+  \/\/ unmarked objects to be coalesced and filled?\n+  uint old_coalesce_and_fill_candidates();\n+\n+  \/\/ Fill in buffer with all of the old-collection regions that were identified at the end of the most recent old-gen\n+  \/\/ mark to require their unmarked objects to be coalesced and filled.  The buffer array must have at least\n+  \/\/ old_coalesce_and_fill_candidates() entries, or memory may be corrupted when this function overwrites the\n+  \/\/ end of the array.\n+  void get_coalesce_and_fill_candidates(ShenandoahHeapRegion** buffer);\n+\n+  bool should_defer_gc();\n+\n+};\n+\n+#endif \/\/ SHARE_GC_SHENANDOAH_HEURISTICS_SHENANDOAHOLDHEURISTICS_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.hpp","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -32,2 +32,2 @@\n-  ShenandoahPassiveHeuristics(ShenandoahGeneration* generation, ShenandoahHeuristics* old_heuristics)\n-    : ShenandoahHeuristics(generation, old_heuristics) {}\n+  ShenandoahPassiveHeuristics(ShenandoahGeneration* generation)\n+    : ShenandoahHeuristics(generation) {}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahPassiveHeuristics.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2018, 2019, 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"gc\/shenandoah\/heuristics\/shenandoahPassiveOldHeuristics.hpp\"\n+#include \"gc\/shenandoah\/shenandoahCollectionSet.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeapRegion.inline.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"logging\/logTag.hpp\"\n+\n+bool ShenandoahPassiveOldHeuristics::should_start_gc() {\n+  \/\/ Never do concurrent GCs.\n+  return false;\n+}\n+\n+bool ShenandoahPassiveOldHeuristics::should_unload_classes() {\n+  \/\/ Always unload classes, if we can.\n+  return can_unload_classes();\n+}\n+\n+bool ShenandoahPassiveOldHeuristics::should_degenerate_cycle() {\n+  \/\/ Always fail to Degenerated GC, if enabled\n+  return ShenandoahDegeneratedGC;\n+}\n+\n+void ShenandoahPassiveOldHeuristics::choose_collection_set_from_regiondata(ShenandoahCollectionSet* cset,\n+                                                                           RegionData* data, size_t size,\n+                                                                           size_t actual_free) {\n+  assert(ShenandoahDegeneratedGC, \"This path is only taken for Degenerated GC\");\n+\n+  \/\/ Do not select too large CSet that would overflow the available free space.\n+  \/\/ Take at least the entire evacuation reserve, and be free to overflow to free space.\n+  size_t max_capacity = ShenandoahHeap::heap()->max_capacity();\n+  size_t available = MAX2(max_capacity \/ 100 * ShenandoahEvacReserve, actual_free);\n+  size_t max_cset  = (size_t)(available \/ ShenandoahEvacWaste);\n+\n+  log_info(gc, ergo)(\"CSet Selection. Actual Free: \" SIZE_FORMAT \"%s, Max CSet: \" SIZE_FORMAT \"%s\",\n+                     byte_size_in_proper_unit(actual_free), proper_unit_for_byte_size(actual_free),\n+                     byte_size_in_proper_unit(max_cset),    proper_unit_for_byte_size(max_cset));\n+\n+  size_t threshold = ShenandoahHeapRegion::region_size_bytes() * ShenandoahGarbageThreshold \/ 100;\n+\n+  size_t live_cset = 0;\n+  for (size_t idx = 0; idx < size; idx++) {\n+    ShenandoahHeapRegion* r = data[idx]._region;\n+    size_t new_cset = live_cset + r->get_live_data_bytes();\n+    if (new_cset < max_cset && r->garbage() > threshold) {\n+      live_cset = new_cset;\n+      cset->add_region(r);\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahPassiveOldHeuristics.cpp","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2018, 2019, 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHENANDOAH_HEURISTICS_SHENANDOAHPASSIVEOLDHEURISTICS_HPP\n+#define SHARE_GC_SHENANDOAH_HEURISTICS_SHENANDOAHPASSIVEOLDHEURISTICS_HPP\n+\n+#include \"gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.hpp\"\n+\n+class ShenandoahPassiveOldHeuristics : public ShenandoahOldHeuristics {\n+public:\n+  ShenandoahPassiveOldHeuristics(ShenandoahGeneration* generation)\n+    : ShenandoahOldHeuristics(generation) {}\n+\n+  virtual bool should_start_gc();\n+\n+  virtual bool should_unload_classes();\n+\n+  virtual bool should_degenerate_cycle();\n+\n+  virtual void choose_collection_set_from_regiondata(ShenandoahCollectionSet* set,\n+                                                     RegionData* data, size_t data_size,\n+                                                     size_t free);\n+\n+  virtual const char* name()     { return \"PassiveOld\"; }\n+  virtual bool is_diagnostic()   { return true; }\n+  virtual bool is_experimental() { return false; }\n+};\n+\n+#endif \/\/ SHARE_GC_SHENANDOAH_HEURISTICS_SHENANDOAHPASSIVEOLDHEURISTICS_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahPassiveOldHeuristics.hpp","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -35,2 +35,2 @@\n-ShenandoahStaticHeuristics::ShenandoahStaticHeuristics(ShenandoahGeneration* generation, ShenandoahHeuristics* old_heuristics) :\n-  ShenandoahHeuristics(generation, old_heuristics) {\n+ShenandoahStaticHeuristics::ShenandoahStaticHeuristics(ShenandoahGeneration* generation) :\n+  ShenandoahHeuristics(generation) {\n@@ -48,4 +48,0 @@\n-  if (ShenandoahHeuristics::should_defer_gc()) {\n-    return false;\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahStaticHeuristics.cpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -30,0 +30,3 @@\n+\/\/ TODO: Make this a subclass of ShenandoahHeuristics and create a \"tailored\" copy of this class to be subclass of\n+\/\/ ShenandoahOldHeuristics.  Fix the constructor implementation to invoke ShenandoahHeuristics() superclass constructor.\n+\/\/ Change ShenandoahMode::initialize_old_heuristics() to return the subclass of ShenandoahOldHeuristics.\n@@ -32,1 +35,1 @@\n-  ShenandoahStaticHeuristics(ShenandoahGeneration* generation, ShenandoahHeuristics* heuristics);\n+  ShenandoahStaticHeuristics(ShenandoahGeneration* generation);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahStaticHeuristics.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2018, 2019, 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"gc\/shenandoah\/heuristics\/shenandoahStaticOldHeuristics.hpp\"\n+#include \"gc\/shenandoah\/shenandoahCollectionSet.hpp\"\n+#include \"gc\/shenandoah\/shenandoahFreeSet.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeapRegion.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGeneration.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"logging\/logTag.hpp\"\n+\n+ShenandoahStaticOldHeuristics::ShenandoahStaticOldHeuristics(ShenandoahGeneration* generation) :\n+  ShenandoahOldHeuristics(generation) {\n+  SHENANDOAH_ERGO_ENABLE_FLAG(ExplicitGCInvokesConcurrent);\n+  SHENANDOAH_ERGO_ENABLE_FLAG(ShenandoahImplicitGCInvokesConcurrent);\n+}\n+\n+ShenandoahStaticOldHeuristics::~ShenandoahStaticOldHeuristics() {}\n+\n+bool ShenandoahStaticOldHeuristics::should_start_gc() {\n+  size_t max_capacity = _generation->max_capacity();\n+  size_t capacity = _generation->soft_max_capacity();\n+  size_t available = _generation->available();\n+\n+  \/\/ Make sure the code below treats available without the soft tail.\n+  size_t soft_tail = max_capacity - capacity;\n+  available = (available > soft_tail) ? (available - soft_tail) : 0;\n+\n+  size_t threshold_available = capacity \/ 100 * ShenandoahMinFreeThreshold;\n+\n+  if (available < threshold_available) {\n+    log_info(gc)(\"Trigger: Free (\" SIZE_FORMAT \"%s) is below minimum threshold (\" SIZE_FORMAT \"%s)\",\n+                 byte_size_in_proper_unit(available), proper_unit_for_byte_size(available),\n+                 byte_size_in_proper_unit(threshold_available), proper_unit_for_byte_size(threshold_available));\n+    return true;\n+  }\n+  return ShenandoahHeuristics::should_start_gc();\n+}\n+\n+void ShenandoahStaticOldHeuristics::choose_collection_set_from_regiondata(ShenandoahCollectionSet* cset,\n+                                                                          RegionData* data, size_t size,\n+                                                                          size_t free) {\n+  size_t threshold = ShenandoahHeapRegion::region_size_bytes() * ShenandoahGarbageThreshold \/ 100;\n+\n+  for (size_t idx = 0; idx < size; idx++) {\n+    ShenandoahHeapRegion* r = data[idx]._region;\n+    if (r->garbage() > threshold) {\n+      cset->add_region(r);\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahStaticOldHeuristics.cpp","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2018, 2019, 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHENANDOAH_HEURISTICS_SHENANDOAHSTATICOLDHEURISTICS_HPP\n+#define SHARE_GC_SHENANDOAH_HEURISTICS_SHENANDOAHSTATICOLDHEURISTICS_HPP\n+\n+#include \"gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.hpp\"\n+\n+class ShenandoahStaticOldHeuristics : public ShenandoahOldHeuristics {\n+public:\n+  ShenandoahStaticOldHeuristics(ShenandoahGeneration* generation);\n+\n+  virtual ~ShenandoahStaticOldHeuristics();\n+\n+  virtual bool should_start_gc();\n+\n+  virtual void choose_collection_set_from_regiondata(ShenandoahCollectionSet* cset,\n+                                                     RegionData* data, size_t size,\n+                                                     size_t free);\n+\n+  virtual const char* name()     { return \"StaticOld\"; }\n+  virtual bool is_diagnostic()   { return false; }\n+  virtual bool is_experimental() { return false; }\n+};\n+\n+#endif \/\/ SHARE_GC_SHENANDOAH_HEURISTICS_SHENANDOAHSTATICOLDHEURISTICS_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahStaticOldHeuristics.hpp","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"gc\/shenandoah\/heuristics\/shenandoahAdaptiveOldHeuristics.hpp\"\n@@ -28,0 +29,1 @@\n+#include \"gc\/shenandoah\/heuristics\/shenandoahAggressiveOldHeuristics.hpp\"\n@@ -29,0 +31,1 @@\n+#include \"gc\/shenandoah\/heuristics\/shenandoahCompactOldHeuristics.hpp\"\n@@ -30,0 +33,1 @@\n+#include \"gc\/shenandoah\/heuristics\/shenandoahStaticOldHeuristics.hpp\"\n@@ -33,1 +37,1 @@\n-ShenandoahHeuristics* ShenandoahMode::initialize_heuristics(ShenandoahGeneration* generation, ShenandoahHeuristics* old_heuristics) const {\n+ShenandoahHeuristics* ShenandoahMode::initialize_heuristics(ShenandoahGeneration* generation) const {\n@@ -37,1 +41,1 @@\n-      return new ShenandoahAggressiveHeuristics(generation, old_heuristics);\n+      return new ShenandoahAggressiveHeuristics(generation);\n@@ -39,1 +43,1 @@\n-      return new ShenandoahStaticHeuristics(generation, old_heuristics);\n+      return new ShenandoahStaticHeuristics(generation);\n@@ -41,1 +45,1 @@\n-      return new ShenandoahAdaptiveHeuristics(generation, old_heuristics);\n+      return new ShenandoahAdaptiveHeuristics(generation);\n@@ -43,1 +47,20 @@\n-      return new ShenandoahCompactHeuristics(generation, old_heuristics);\n+      return new ShenandoahCompactHeuristics(generation);\n+    } else {\n+      vm_exit_during_initialization(\"Unknown -XX:ShenandoahGCHeuristics option\");\n+    }\n+  }\n+  ShouldNotReachHere();\n+  return NULL;\n+}\n+\n+ShenandoahOldHeuristics* ShenandoahMode::initialize_old_heuristics(ShenandoahGeneration* generation) const {\n+\n+  if (ShenandoahGCHeuristics != NULL) {\n+    if (strcmp(ShenandoahGCHeuristics, \"aggressive\") == 0) {\n+      return new ShenandoahAggressiveOldHeuristics(generation);\n+    } else if (strcmp(ShenandoahGCHeuristics, \"static\") == 0) {\n+      return new ShenandoahStaticOldHeuristics(generation);\n+    } else if (strcmp(ShenandoahGCHeuristics, \"adaptive\") == 0) {\n+      return new ShenandoahAdaptiveOldHeuristics(generation);\n+    } else if (strcmp(ShenandoahGCHeuristics, \"compact\") == 0) {\n+      return new ShenandoahCompactOldHeuristics(generation);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/mode\/shenandoahMode.cpp","additions":28,"deletions":5,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2019, 2021, Red Hat, Inc. All rights reserved.\n@@ -34,0 +34,1 @@\n+class ShenandoahOldHeuristics;\n@@ -54,1 +55,2 @@\n-  virtual ShenandoahHeuristics* initialize_heuristics(ShenandoahGeneration* generation, ShenandoahHeuristics* old_heuristics) const;\n+  virtual ShenandoahHeuristics* initialize_heuristics(ShenandoahGeneration* generation) const;\n+  virtual ShenandoahOldHeuristics* initialize_old_heuristics(ShenandoahGeneration* generation) const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/mode\/shenandoahMode.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/shenandoah\/heuristics\/shenandoahPassiveOldHeuristics.hpp\"\n@@ -55,1 +56,1 @@\n-ShenandoahHeuristics* ShenandoahPassiveMode::initialize_heuristics(ShenandoahGeneration* generation, ShenandoahHeuristics* old_heuristics) const {\n+ShenandoahHeuristics* ShenandoahPassiveMode::initialize_heuristics(ShenandoahGeneration* generation) const {\n@@ -57,1 +58,9 @@\n-    return new ShenandoahPassiveHeuristics(generation, old_heuristics);\n+    return new ShenandoahPassiveHeuristics(generation);\n+  }\n+  ShouldNotReachHere();\n+  return NULL;\n+}\n+\n+ShenandoahOldHeuristics* ShenandoahPassiveMode::initialize_old_heuristics(ShenandoahGeneration* generation) const {\n+  if (ShenandoahGCHeuristics != NULL) {\n+    return new ShenandoahPassiveOldHeuristics(generation);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/mode\/shenandoahPassiveMode.cpp","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2019, 2021, Red Hat, Inc. All rights reserved.\n@@ -33,1 +33,2 @@\n-  virtual ShenandoahHeuristics* initialize_heuristics(ShenandoahGeneration* generation, ShenandoahHeuristics* old_heuristics) const;\n+  virtual ShenandoahHeuristics* initialize_heuristics(ShenandoahGeneration* generation) const;\n+  virtual ShenandoahOldHeuristics* initialize_old_heuristics(ShenandoahGeneration* generation) const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/mode\/shenandoahPassiveMode.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -74,3 +74,1 @@\n-ShenandoahHeuristics* ShenandoahGeneration::initialize_heuristics(ShenandoahMode* gc_mode, ShenandoahHeuristics* old_heuristics) {\n-  _heuristics = gc_mode->initialize_heuristics(this, old_heuristics);\n-\n+void ShenandoahGeneration::confirm_heuristics_mode() {\n@@ -87,0 +85,12 @@\n+}\n+\n+ShenandoahOldHeuristics* ShenandoahGeneration::initialize_old_heuristics(ShenandoahMode* gc_mode) {\n+  ShenandoahOldHeuristics* old_heuristics = gc_mode->initialize_old_heuristics(this);\n+  _heuristics = old_heuristics;\n+  confirm_heuristics_mode();\n+  return old_heuristics;\n+}\n+\n+ShenandoahHeuristics* ShenandoahGeneration::initialize_heuristics(ShenandoahMode* gc_mode) {\n+  _heuristics = gc_mode->initialize_heuristics(this);\n+  confirm_heuristics_mode();\n@@ -151,1 +161,1 @@\n-    _heuristics->choose_collection_set(heap->collection_set());\n+    _heuristics->choose_collection_set(heap->collection_set(), heap->old_heuristics());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"gc\/shenandoah\/heuristics\/shenandoahHeuristics.hpp\"\n+#include \"gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.hpp\"\n@@ -63,1 +63,3 @@\n-  ShenandoahHeuristics* initialize_heuristics(ShenandoahMode* gc_mode, ShenandoahHeuristics* old_heuristics);\n+  ShenandoahHeuristics* initialize_heuristics(ShenandoahMode* gc_mode);\n+\n+  ShenandoahOldHeuristics* initialize_old_heuristics(ShenandoahMode* gc_mode);\n@@ -127,0 +129,3 @@\n+\n+ private:\n+  void confirm_heuristics_mode();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.hpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -482,3 +482,4 @@\n-  ShenandoahHeuristics* old_heuristics = _old_generation->initialize_heuristics(_gc_mode, NULL);\n-  _global_generation->initialize_heuristics(_gc_mode, NULL);\n-  _young_generation->initialize_heuristics(_gc_mode, old_heuristics);\n+  \/\/ ojo: want to instantiate a ShenandoahOldHeuristics object here\n+  _old_heuristics = _old_generation->initialize_old_heuristics(_gc_mode);\n+  _global_generation->initialize_heuristics(_gc_mode);\n+  _young_generation->initialize_heuristics(_gc_mode);\n@@ -495,0 +496,1 @@\n+  _old_heuristics(NULL),\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+class ShenandoahOldHeuristics;\n@@ -149,0 +150,1 @@\n+  ShenandoahOldHeuristics* _old_heuristics;\n@@ -164,0 +166,4 @@\n+  ShenandoahOldHeuristics* old_heuristics() {\n+    return _old_heuristics;\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-  ShenandoahHeuristics* old_heuristics = heap->old_generation()->heuristics();\n+  ShenandoahOldHeuristics* old_heuristics = heap->old_heuristics();\n@@ -144,1 +144,1 @@\n-  ShenandoahHeuristics* old_heuristics = heap->old_generation()->heuristics();\n+  ShenandoahOldHeuristics* old_heuristics = heap->old_heuristics();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGC.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-  _old_heuristics = get_heuristics(heap->old_generation());\n+  _old_heuristics = heap->old_heuristics();\n@@ -137,1 +137,1 @@\n-  return _old_heuristics->should_start_gc() && _control_thread->request_concurrent_gc(OLD);\n+  return !_old_heuristics->should_defer_gc() && _old_heuristics->should_start_gc() && _control_thread->request_concurrent_gc(OLD);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRegulatorThread.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.hpp\"\n@@ -77,1 +78,1 @@\n-  ShenandoahHeuristics* _old_heuristics;\n+  ShenandoahOldHeuristics* _old_heuristics;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRegulatorThread.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}