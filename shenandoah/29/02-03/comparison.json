{"files":[{"patch":"@@ -84,2 +84,3 @@\n-void ShenandoahHeuristics::choose_collection_set(ShenandoahCollectionSet* collection_set) {\n-  assert(collection_set->count() == 0, \"Must be empty\");\n+void ShenandoahHeuristics::prime_collection_set_with_old_candidates(ShenandoahCollectionSet* collection_set) {\n+  uint included_old_regions = 0;\n+  size_t evacuated_old_bytes = 0;\n@@ -87,6 +88,101 @@\n-  if (_generation->generation_mode() == OLD) {\n-    \/\/ Old-gen doesn't actually choose a collection set to be evacuated by its own gang of worker tasks.\n-    \/\/ Instead, it computes the set of regions to be evacuated by subsequent young-gen evacuation passes.\n-    prepare_for_old_collections();\n-  } else {\n-    ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  \/\/ TODO: These macro definitions represent a first approximation to desired operating parameters.\n+  \/\/ Eventually, these values should be determined by heuristics and should adjust dynamically based\n+  \/\/ on most current execution behavior.  In the interrim, we may choose to offer command-line options\n+  \/\/ to set the values of these configuration parameters.\n+\n+  \/\/ MAX_OLD_EVACUATION_BYTES represents an \"arbitrary\" bound on how much evacuation effort is dedicated to\n+  \/\/ old-gen regions.\n+#define MAX_OLD_EVACUATION_BYTES (ShenandoahHeapRegion::region_size_bytes() * 8)\n+\n+  \/\/ PROMOTION_BUDGET_BYTES represents an \"arbitrary\" bound on how many bytes can be consumed by young-gen\n+  \/\/ objects promoted into old-gen memory.  We need to avoid a scenario under which promotion of objects\n+  \/\/ depletes old-gen available memory to the point that there is insufficient memory to hold old-gen objects\n+  \/\/ that need to be evacuated from within the old-gen collection set.\n+  \/\/\n+  \/\/ TODO We should probably enforce this, but there is no enforcement currently.  Key idea: if there is not\n+  \/\/ sufficient memory within old-gen to hold an object that wants to be promoted, defer promotion until a\n+  \/\/ subsequent evacuation pass.  Since enforcement may be expensive, requiring frequent synchronization\n+  \/\/ between mutator and GC threads, here's an alternative \"greedy\" mitigation strategy: Set the parameter's\n+  \/\/ value so overflow is \"very rare\".  In the case that we experience overflow, evacuate what we can from\n+  \/\/ within the old collection set, but don't evacuate everything.  At the end of evacuation, any collection\n+  \/\/ set region that was not fully evacuated cannot be recycled.  It becomes a prime candidate for the next\n+  \/\/ collection set selection.  Here, we'd rather fall back to this contingent behavior than force a full STW\n+  \/\/ collection.\n+#define PROMOTION_BUDGET_BYTES (ShenandoahHeapRegion::region_size_bytes() \/ 2)\n+\n+  \/\/ If a region is put into the collection set, then this region's free (not yet used) bytes are no longer\n+  \/\/ \"available\" to hold the results of other evacuations.  This causes further decrease in the value of\n+  \/\/ AVAILABLE_OLD_BYTES.\n+  \/\/\n+  \/\/ We address this by reducing the evacuation budget by the amount of live memory in that region and by the\n+  \/\/ amount of unallocated memory in that region if the evacuation budget is constrained by availability of\n+  \/\/ free memory.\n+\n+  \/\/ Allow no more evacuation than exists free-space within old-gen memory\n+  size_t old_evacuation_budget = (_old_heuristics->_generation->available() > PROMOTION_BUDGET_BYTES)? _old_heuristics->_generation->available() - PROMOTION_BUDGET_BYTES: 0;\n+\n+  \/\/ But if the amount of available free space in old-gen memory exceeds the pacing bound on how much old-gen memory can be\n+  \/\/ evacuated during each evacuation pass, then cut the old-gen evacuation further.  The pacing bound is designed to assure\n+  \/\/ that old-gen evacuations to not excessively slow the evacuation pass in order to assure that young-gen GC cadence is\n+  \/\/ not disrupted.\n+\n+  \/\/ Represents availability of memory to hold evacuations beyond what is required to hold planned evacuations.  May go\n+  \/\/ negative if we choose to collect regions with large amounts of free memory.\n+  long long excess_free_capacity;\n+  if (old_evacuation_budget > MAX_OLD_EVACUATION_BYTES) {\n+    excess_free_capacity = old_evacuation_budget - MAX_OLD_EVACUATION_BYTES;\n+    old_evacuation_budget = MAX_OLD_EVACUATION_BYTES;\n+  } else\n+    excess_free_capacity = 0;\n+\n+  size_t remaining_old_evacuation_budget = old_evacuation_budget;\n+\n+  \/\/ The number of old-gen regions that were selected as candidates for collection at the end of the most recent old-gen\n+  \/\/ concurrent marking phase and have not yet been collected is represented by unprocessed_old_collection_candidates()\n+  while (_old_heuristics->unprocessed_old_collection_candidates() > 0) {\n+    \/\/ Old collection candidates are sorted in order of decreasing garbage contained therein.\n+    ShenandoahHeapRegion* r = _old_heuristics->next_old_collection_candidate();\n+\n+    \/\/ Assuming region r is added to the collection set, what will be the remaining_old_evacuation_budget after accounting\n+    \/\/ for the loss of region r's free() memory.\n+    size_t adjusted_remaining_old_evacuation_budget;\n+\n+    \/\/ If we choose region r to be collected, then we need to decrease the capacity to hold other evacuations by the size of r's free memory.\n+    excess_free_capacity -= r->free();\n+    \/\/ If subtracting r->free from excess_free_capacity() makes it go negative, that means we are going to have to decrease the\n+    \/\/ evacuation budget.\n+    if (excess_free_capacity < 0) {\n+      if (remaining_old_evacuation_budget < (size_t) -excess_free_capacity) {\n+        \/\/ By setting adjusted_remaining_old_evacuation_budget to 0, we prevent further additions to the old-gen collection set,\n+        \/\/ unless the region has zero live data bytes.\n+        adjusted_remaining_old_evacuation_budget = 0;\n+      } else {\n+        \/\/ Adding negative excess_free_capacity decreases the adjusted_remaining_old_evacuation_budget\n+        adjusted_remaining_old_evacuation_budget = remaining_old_evacuation_budget + excess_free_capacity;\n+      }\n+    } else {\n+      adjusted_remaining_old_evacuation_budget = remaining_old_evacuation_budget;\n+    }\n+\n+    if (r->get_live_data_bytes() > adjusted_remaining_old_evacuation_budget) {\n+      break;\n+    }\n+    collection_set->add_region(r);\n+    included_old_regions++;\n+    evacuated_old_bytes += r->get_live_data_bytes();\n+    _old_heuristics->consume_old_collection_candidate();\n+    remaining_old_evacuation_budget = adjusted_remaining_old_evacuation_budget - r->get_live_data_bytes();\n+  }\n+\n+  if (included_old_regions > 0) {\n+    log_info(gc)(\"Old-gen piggyback evac (%llu regions, %llu bytes)\",\n+                 (unsigned long long) included_old_regions,\n+                 (unsigned long long) evacuated_old_bytes);\n+  }\n+}\n+\n+void ShenandoahHeuristics::prepare_for_other_collection(ShenandoahCollectionSet* collection_set) {\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+\n+  \/\/ Check all pinned regions have updated status before choosing the collection set.\n+  heap->assert_pinned_region_status();\n@@ -94,2 +190,1 @@\n-    \/\/ Check all pinned regions have updated status before choosing the collection set.\n-    heap->assert_pinned_region_status();\n+  \/\/ Step 1. Build up the region candidates we care about, rejecting losers and accepting winners right away.\n@@ -97,1 +192,1 @@\n-    \/\/ Step 1. Build up the region candidates we care about, rejecting losers and accepting winners right away.\n+  size_t num_regions = heap->num_regions();\n@@ -99,1 +194,1 @@\n-    size_t num_regions = heap->num_regions();\n+  RegionData* candidates = _region_data;\n@@ -101,1 +196,1 @@\n-    RegionData* candidates = _region_data;\n+  size_t cand_idx = 0;\n@@ -103,1 +198,1 @@\n-    size_t cand_idx = 0;\n+  size_t total_garbage = 0;\n@@ -105,1 +200,2 @@\n-    size_t total_garbage = 0;\n+  size_t immediate_garbage = 0;\n+  size_t immediate_regions = 0;\n@@ -107,2 +203,2 @@\n-    size_t immediate_garbage = 0;\n-    size_t immediate_regions = 0;\n+  size_t free = 0;\n+  size_t free_regions = 0;\n@@ -110,2 +206,1 @@\n-    size_t free = 0;\n-    size_t free_regions = 0;\n+  ShenandoahMarkingContext* const ctx = _generation->complete_marking_context();\n@@ -113,1 +208,8 @@\n-    ShenandoahMarkingContext* const ctx = _generation->complete_marking_context();\n+  for (size_t i = 0; i < num_regions; i++) {\n+    ShenandoahHeapRegion* region = heap->get_region(i);\n+    if (!in_generation(region)) {\n+      continue;\n+    }\n+\n+    size_t garbage = region->garbage();\n+    total_garbage += garbage;\n@@ -115,4 +217,16 @@\n-    for (size_t i = 0; i < num_regions; i++) {\n-      ShenandoahHeapRegion* region = heap->get_region(i);\n-      if (!in_generation(region)) {\n-        continue;\n+    if (region->is_empty()) {\n+      free_regions++;\n+      free += ShenandoahHeapRegion::region_size_bytes();\n+    } else if (region->is_regular()) {\n+      if (!region->has_live() && !heap->mode()->is_generational()) {\n+        \/\/ We can recycle it right away and put it in the free set.\n+        immediate_regions++;\n+        immediate_garbage += garbage;\n+        region->make_trash_immediate();\n+      } else {\n+        assert (_generation->generation_mode() != OLD, \"OLD is handled elsewhere\");\n+\n+        \/\/ This is our candidate for later consideration.\n+        candidates[cand_idx]._region = region;\n+        candidates[cand_idx]._garbage = garbage;\n+        cand_idx++;\n@@ -120,0 +234,1 @@\n+    } else if (region->is_humongous_start()) {\n@@ -121,23 +236,1 @@\n-      size_t garbage = region->garbage();\n-      total_garbage += garbage;\n-\n-      if (region->is_empty()) {\n-        free_regions++;\n-        free += ShenandoahHeapRegion::region_size_bytes();\n-      } else if (region->is_regular()) {\n-        if (!region->has_live() && !heap->mode()->is_generational()) {\n-          \/\/ We can recycle it right away and put it in the free set.\n-          immediate_regions++;\n-          immediate_garbage += garbage;\n-          region->make_trash_immediate();\n-        } else {\n-          assert (_generation->generation_mode() != OLD, \"OLD is handled elsewhere\");\n-\n-          \/\/ This is our candidate for later consideration.\n-          candidates[cand_idx]._region = region;\n-          candidates[cand_idx]._garbage = garbage;\n-          cand_idx++;\n-        }\n-      } else if (region->is_humongous_start()) {\n-\n-        \/\/ Reclaim humongous regions here, and count them as the immediate garbage\n+      \/\/ Reclaim humongous regions here, and count them as the immediate garbage\n@@ -145,5 +238,5 @@\n-        bool reg_live = region->has_live();\n-        bool bm_live = ctx->is_marked(oop(region->bottom()));\n-        assert(reg_live == bm_live,\n-               \"Humongous liveness and marks should agree. Region live: %s; Bitmap live: %s; Region Live Words: \" SIZE_FORMAT,\n-               BOOL_TO_STR(reg_live), BOOL_TO_STR(bm_live), region->get_live_data_words());\n+      bool reg_live = region->has_live();\n+      bool bm_live = ctx->is_marked(oop(region->bottom()));\n+      assert(reg_live == bm_live,\n+             \"Humongous liveness and marks should agree. Region live: %s; Bitmap live: %s; Region Live Words: \" SIZE_FORMAT,\n+             BOOL_TO_STR(reg_live), BOOL_TO_STR(bm_live), region->get_live_data_words());\n@@ -151,9 +244,4 @@\n-        if (!region->has_live()) {\n-          heap->trash_humongous_region_at(region);\n-\n-          \/\/ Count only the start. Continuations would be counted on \"trash\" path\n-          immediate_regions++;\n-          immediate_garbage += garbage;\n-        }\n-      } else if (region->is_trash()) {\n-        \/\/ Count in just trashed collection set, during coalesced CM-with-UR\n+      if (!region->has_live()) {\n+        heap->trash_humongous_region_at(region);\n+\n+        \/\/ Count only the start. Continuations would be counted on \"trash\" path\n@@ -163,0 +251,4 @@\n+    } else if (region->is_trash()) {\n+      \/\/ Count in just trashed collection set, during coalesced CM-with-UR\n+      immediate_regions++;\n+      immediate_garbage += garbage;\n@@ -164,0 +256,1 @@\n+  }\n@@ -165,9 +258,2 @@\n-    \/\/ Step 2. Look back at garbage statistics, and decide if we want to collect anything,\n-    \/\/ given the amount of immediately reclaimable garbage. If we do, figure out the collection set.\n-\n-    assert (immediate_garbage <= total_garbage,\n-            \"Cannot have more immediate garbage than total garbage: \" SIZE_FORMAT \"%s vs \" SIZE_FORMAT \"%s\",\n-            byte_size_in_proper_unit(immediate_garbage), proper_unit_for_byte_size(immediate_garbage),\n-            byte_size_in_proper_unit(total_garbage),     proper_unit_for_byte_size(total_garbage));\n-\n-    size_t immediate_percent = (total_garbage == 0) ? 0 : (immediate_garbage * 100 \/ total_garbage);\n+  \/\/ Step 2. Look back at garbage statistics, and decide if we want to collect anything,\n+  \/\/ given the amount of immediately reclaimable garbage. If we do, figure out the collection set.\n@@ -175,1 +261,4 @@\n-    if (immediate_percent <= ShenandoahImmediateThreshold) {\n+  assert (immediate_garbage <= total_garbage,\n+          \"Cannot have more immediate garbage than total garbage: \" SIZE_FORMAT \"%s vs \" SIZE_FORMAT \"%s\",\n+          byte_size_in_proper_unit(immediate_garbage), proper_unit_for_byte_size(immediate_garbage),\n+          byte_size_in_proper_unit(total_garbage),     proper_unit_for_byte_size(total_garbage));\n@@ -177,3 +266,1 @@\n-      if (_old_heuristics != NULL) {\n-        uint included_old_regions = 0;\n-        size_t evacuated_old_bytes = 0;\n+  size_t immediate_percent = (total_garbage == 0) ? 0 : (immediate_garbage * 100 \/ total_garbage);\n@@ -181,4 +268,1 @@\n-        \/\/ TODO: These macro definitions represent a first approximation to desired operating parameters.\n-        \/\/ Eventually, these values should be determined by heuristics and should adjust dynamically based\n-        \/\/ on most current execution behavior.  In the interrim, we may choose to offer command-line options\n-        \/\/ to set the values of these configuration parameters.\n+  if (immediate_percent <= ShenandoahImmediateThreshold) {\n@@ -186,3 +270,3 @@\n-        \/\/ MAX_OLD_EVACUATION_BYTES represents an \"arbitrary\" bound on how much evacuation effort is dedicated to\n-        \/\/ old-gen regions.\n-#define MAX_OLD_EVACUATION_BYTES (ShenandoahHeapRegion::region_size_bytes() * 8)\n+    if (_old_heuristics != NULL) {\n+      prime_collection_set_with_old_candidates(collection_set);\n+    }\n@@ -190,15 +274,4 @@\n-        \/\/ PROMOTION_BUDGET_BYTES represents an \"arbitrary\" bound on how many bytes can be consumed by young-gen\n-        \/\/ objects promoted into old-gen memory.  We need to avoid a scenario under which promotion of objects\n-        \/\/ depletes old-gen available memory to the point that there is insufficient memory to hold old-gen objects\n-        \/\/ that need to be evacuated from within the old-gen collection set.\n-        \/\/\n-        \/\/ TODO We should probably enforce this, but there is no enforcement currently.  Key idea: if there is not\n-        \/\/ sufficient memory within old-gen to hold an object that wants to be promoted, defer promotion until a\n-        \/\/ subsequent evacuation pass.  Since enforcement may be expensive, requiring frequent synchronization\n-        \/\/ between mutator and GC threads, here's an alternative \"greedy\" mitigation strategy: Set the parameter's\n-        \/\/ value so overflow is \"very rare\".  In the case that we experience overflow, evacuate what we can from\n-        \/\/ within the old collection set, but don't evacuate everything.  At the end of evacuation, any collection\n-        \/\/ set region that was not fully evacuated cannot be recycled.  It becomes a prime candidate for the next\n-        \/\/ collection set selection.  Here, we'd rather fall back to this contingent behavior than force a full STW\n-        \/\/ collection.\n-#define PROMOTION_BUDGET_BYTES (ShenandoahHeapRegion::region_size_bytes() \/ 2)\n+    \/\/ Add young-gen regions into the collection set.  This is a virtual call, implemented differently by each\n+    \/\/ of the heuristics subclasses.\n+    choose_collection_set_from_regiondata(collection_set, candidates, cand_idx, immediate_garbage + free);\n+  }\n@@ -206,70 +279,1 @@\n-        \/\/ If a region is put into the collection set, then this region's free (not yet used) bytes are no longer\n-        \/\/ \"available\" to hold the results of other evacuations.  This causes further decrease in the value of\n-        \/\/ AVAILABLE_OLD_BYTES.\n-        \/\/\n-        \/\/ We address this by reducing the evacuation budget by the amount of live memory in that region and by the\n-        \/\/ amount of unallocated memory in that region if the evacuation budget is constrained by availability of\n-        \/\/ free memory.\n-\n-        \/\/ Allow no more evacuation than exists free-space within old-gen memory\n-        size_t old_evacuation_budget = (_old_heuristics->_generation->available() > PROMOTION_BUDGET_BYTES)? _old_heuristics->_generation->available() - PROMOTION_BUDGET_BYTES: 0;\n-\n-        \/\/ But if the amount of available free space in old-gen memory exceeds the pacing bound on how much old-gen memory can be\n-        \/\/ evacuated during each evacuation pass, then cut the old-gen evacuation further.  The pacing bound is designed to assure\n-        \/\/ that old-gen evacuations to not excessively slow the evacuation pass in order to assure that young-gen GC cadence is\n-        \/\/ not disrupted.\n-\n-        \/\/ Represents availability of memory to hold evacuations beyond what is required to hold planned evacuations.  May go\n-        \/\/ negative if we choose to collect regions with large amounts of free memory.\n-        long long excess_free_capacity;\n-        if (old_evacuation_budget > MAX_OLD_EVACUATION_BYTES) {\n-          excess_free_capacity = old_evacuation_budget - MAX_OLD_EVACUATION_BYTES;\n-          old_evacuation_budget = MAX_OLD_EVACUATION_BYTES;\n-        } else\n-          excess_free_capacity = 0;\n-\n-        size_t remaining_old_evacuation_budget = old_evacuation_budget;\n-\n-        \/\/ The number of old-gen regions that were selected as candidates for collection at the end of the most recent old-gen\n-        \/\/ concurrent marking phase and have not yet been collected is represented by unprocessed_old_collection_candidates()\n-        while (_old_heuristics->unprocessed_old_collection_candidates() > 0) {\n-          \/\/ Old collection candidates are sorted in order of decreasing garbage contained therein.\n-          ShenandoahHeapRegion* r = _old_heuristics->next_old_collection_candidate();\n-\n-          \/\/ Assuming region r is added to the collection set, what will be the remaining_old_evacuation_budget after accounting\n-          \/\/ for the loss of region r's free() memory.\n-          size_t adjusted_remaining_old_evacuation_budget;\n-\n-          \/\/ If we choose region r to be collected, then we need to decrease the capacity to hold other evacuations by the size of r's free memory.\n-          excess_free_capacity -= r->free();\n-          \/\/ If subtracting r->free from excess_free_capacity() makes it go negative, that means we are going to have to decrease the\n-          \/\/ evacuation budget.\n-          if (excess_free_capacity < 0) {\n-            if (remaining_old_evacuation_budget < (size_t) -excess_free_capacity) {\n-              \/\/ By setting adjusted_remaining_old_evacuation_budget to 0, we prevent further additions to the old-gen collection set,\n-              \/\/ unless the region has zero live data bytes.\n-              adjusted_remaining_old_evacuation_budget = 0;\n-            } else {\n-              \/\/ Adding negative excess_free_capacity decreases the adjusted_remaining_old_evacuation_budget\n-              adjusted_remaining_old_evacuation_budget = remaining_old_evacuation_budget + excess_free_capacity;\n-            }\n-          } else {\n-            adjusted_remaining_old_evacuation_budget = remaining_old_evacuation_budget;\n-          }\n-\n-          if (r->get_live_data_bytes() > adjusted_remaining_old_evacuation_budget) {\n-            break;\n-          }\n-          collection_set->add_region(r);\n-          included_old_regions++;\n-          evacuated_old_bytes += r->get_live_data_bytes();\n-          _old_heuristics->consume_old_collection_candidate();\n-          remaining_old_evacuation_budget = adjusted_remaining_old_evacuation_budget - r->get_live_data_bytes();\n-        }\n-\n-        if (included_old_regions > 0) {\n-          log_info(gc)(\"Old-gen piggyback evac (%llu regions, %llu bytes)\",\n-                       (unsigned long long) included_old_regions,\n-                       (unsigned long long) evacuated_old_bytes);\n-        }\n-      }\n+  size_t cset_percent = (total_garbage == 0) ? 0 : (collection_set->garbage() * 100 \/ total_garbage);\n@@ -277,4 +281,5 @@\n-      \/\/ Add young-gen regions into the collection set.  This is a virtual call, implemented differently by each\n-      \/\/ of the heuristics subclasses.\n-      choose_collection_set_from_regiondata(collection_set, candidates, cand_idx, immediate_garbage + free);\n-    }\n+  size_t collectable_garbage = collection_set->garbage() + immediate_garbage;\n+  size_t collectable_garbage_percent = (total_garbage == 0) ? 0 : (collectable_garbage * 100 \/ total_garbage);\n+  log_info(gc, ergo)(\"Collectable Garbage: \" SIZE_FORMAT \"%s (\" SIZE_FORMAT \"%%), \"\n+                     \"Immediate: \" SIZE_FORMAT \"%s (\" SIZE_FORMAT \"%%), \"\n+                     \"CSet: \" SIZE_FORMAT \"%s (\" SIZE_FORMAT \"%%)\",\n@@ -282,1 +287,3 @@\n-    size_t cset_percent = (total_garbage == 0) ? 0 : (collection_set->garbage() * 100 \/ total_garbage);\n+                     byte_size_in_proper_unit(collectable_garbage),\n+                     proper_unit_for_byte_size(collectable_garbage),\n+                     collectable_garbage_percent,\n@@ -284,5 +291,3 @@\n-    size_t collectable_garbage = collection_set->garbage() + immediate_garbage;\n-    size_t collectable_garbage_percent = (total_garbage == 0) ? 0 : (collectable_garbage * 100 \/ total_garbage);\n-    log_info(gc, ergo)(\"Collectable Garbage: \" SIZE_FORMAT \"%s (\" SIZE_FORMAT \"%%), \"\n-                       \"Immediate: \" SIZE_FORMAT \"%s (\" SIZE_FORMAT \"%%), \"\n-                       \"CSet: \" SIZE_FORMAT \"%s (\" SIZE_FORMAT \"%%)\",\n+                     byte_size_in_proper_unit(immediate_garbage),\n+                     proper_unit_for_byte_size(immediate_garbage),\n+                     immediate_percent,\n@@ -290,3 +295,4 @@\n-                       byte_size_in_proper_unit(collectable_garbage),\n-                       proper_unit_for_byte_size(collectable_garbage),\n-                       collectable_garbage_percent,\n+                     byte_size_in_proper_unit(collection_set->garbage()),\n+                     proper_unit_for_byte_size(collection_set->garbage()),\n+                     cset_percent);\n+}\n@@ -294,3 +300,2 @@\n-                       byte_size_in_proper_unit(immediate_garbage),\n-                       proper_unit_for_byte_size(immediate_garbage),\n-                       immediate_percent,\n+void ShenandoahHeuristics::choose_collection_set(ShenandoahCollectionSet* collection_set) {\n+  assert(collection_set->count() == 0, \"Must be empty\");\n@@ -298,3 +303,6 @@\n-                       byte_size_in_proper_unit(collection_set->garbage()),\n-                       proper_unit_for_byte_size(collection_set->garbage()),\n-                       cset_percent);\n+  if (_generation->generation_mode() == OLD) {\n+    \/\/ Old-gen doesn't actually choose a collection set to be evacuated by its own gang of worker tasks.\n+    \/\/ Instead, it computes the set of regions to be evacuated by subsequent young-gen evacuation passes.\n+    prepare_for_old_collections();\n+  } else {\n+    prepare_for_other_collection(collection_set);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.cpp","additions":193,"deletions":185,"binary":false,"changes":378,"status":"modified"},{"patch":"@@ -170,0 +170,8 @@\n+  void prime_collection_set_with_old_candidates(ShenandoahCollectionSet* set);\n+\n+  \/\/ Prepare for evacuation of old-gen regions by capturing the mark results of a recently completed concurrent mark pass.\n+  void prepare_for_old_collections();\n+\n+  \/\/ Prepare for global or young-gen collection\n+  void prepare_for_other_collection(ShenandoahCollectionSet* set);\n+\n@@ -220,3 +228,0 @@\n-  \/\/ Prepare for evacuation of old-gen regions by capturing the mark results of a recently completed concurrent mark pass.\n-  void prepare_for_old_collections();\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.hpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"}]}