{"files":[{"patch":"@@ -57,2 +57,2 @@\n-ShenandoahAdaptiveHeuristics::ShenandoahAdaptiveHeuristics(ShenandoahGeneration* generation) :\n-  ShenandoahHeuristics(generation),\n+ShenandoahAdaptiveHeuristics::ShenandoahAdaptiveHeuristics(ShenandoahGeneration* generation, ShenandoahHeuristics* old_heuristics) :\n+  ShenandoahHeuristics(generation, old_heuristics),\n@@ -99,0 +99,1 @@\n+\n@@ -204,0 +205,4 @@\n+  if (ShenandoahHeuristics::should_defer_gc()) {\n+    return false;\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-  ShenandoahAdaptiveHeuristics(ShenandoahGeneration* generation);\n+  ShenandoahAdaptiveHeuristics(ShenandoahGeneration* generation, ShenandoahHeuristics* old_heuristics);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-ShenandoahAggressiveHeuristics::ShenandoahAggressiveHeuristics(ShenandoahGeneration* generation) : ShenandoahHeuristics(generation) {\n+ShenandoahAggressiveHeuristics::ShenandoahAggressiveHeuristics(ShenandoahGeneration* generation, ShenandoahHeuristics* old_heuristics) : ShenandoahHeuristics(generation, old_heuristics) {\n@@ -60,0 +60,3 @@\n+  if (ShenandoahHeuristics::should_defer_gc()) {\n+    return false;\n+  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAggressiveHeuristics.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-  ShenandoahAggressiveHeuristics(ShenandoahGeneration* generation);\n+  ShenandoahAggressiveHeuristics(ShenandoahGeneration* generation, ShenandoahHeuristics* old_heuristics);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAggressiveHeuristics.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,2 +35,2 @@\n-ShenandoahCompactHeuristics::ShenandoahCompactHeuristics(ShenandoahGeneration* generation) :\n-  ShenandoahHeuristics(generation) {\n+ShenandoahCompactHeuristics::ShenandoahCompactHeuristics(ShenandoahGeneration* generation, ShenandoahHeuristics* old_heuristics) :\n+  ShenandoahHeuristics(generation, old_heuristics) {\n@@ -53,0 +53,4 @@\n+  if (ShenandoahHeuristics::should_defer_gc()) {\n+    return false;\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahCompactHeuristics.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-  ShenandoahCompactHeuristics(ShenandoahGeneration* generation);\n+  ShenandoahCompactHeuristics(ShenandoahGeneration* generation, ShenandoahHeuristics* old_heuristics);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahCompactHeuristics.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"utilities\/quickSort.hpp\"\n@@ -48,1 +49,4 @@\n-ShenandoahHeuristics::ShenandoahHeuristics(ShenandoahGeneration* generation) :\n+ShenandoahHeuristics::ShenandoahHeuristics(ShenandoahGeneration* generation,\n+                                           ShenandoahHeuristics* old_heuristics) :\n+  _generation(generation),\n+  _old_heuristics(old_heuristics),\n@@ -50,0 +54,6 @@\n+  _old_collection_candidates(0),\n+  _next_old_collection_candidate(0),\n+  _hidden_old_collection_candidates(0),\n+  _hidden_next_old_collection_candidate(0),\n+  _old_coalesce_and_fill_candidates(0),\n+  _first_coalesce_and_fill_candidate(0),\n@@ -57,2 +67,1 @@\n-  _metaspace_oom(),\n-  _generation(generation)\n+  _metaspace_oom()\n@@ -78,1 +87,6 @@\n-  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  if (_generation->generation_mode() == OLD) {\n+    \/\/ Old-gen doesn't actually choose a collection set to be evacuated by its own gang of worker tasks.\n+    \/\/ Instead, it computes the set of regions to be evacuated by subsequent young-gen evacuation passes.\n+    prepare_for_old_collections();\n+  } else {\n+    ShenandoahHeap* heap = ShenandoahHeap::heap();\n@@ -80,2 +94,2 @@\n-  \/\/ Check all pinned regions have updated status before choosing the collection set.\n-  heap->assert_pinned_region_status();\n+    \/\/ Check all pinned regions have updated status before choosing the collection set.\n+    heap->assert_pinned_region_status();\n@@ -83,1 +97,1 @@\n-  \/\/ Step 1. Build up the region candidates we care about, rejecting losers and accepting winners right away.\n+    \/\/ Step 1. Build up the region candidates we care about, rejecting losers and accepting winners right away.\n@@ -85,1 +99,1 @@\n-  size_t num_regions = heap->num_regions();\n+    size_t num_regions = heap->num_regions();\n@@ -87,1 +101,1 @@\n-  RegionData* candidates = _region_data;\n+    RegionData* candidates = _region_data;\n@@ -89,1 +103,1 @@\n-  size_t cand_idx = 0;\n+    size_t cand_idx = 0;\n@@ -91,1 +105,1 @@\n-  size_t total_garbage = 0;\n+    size_t total_garbage = 0;\n@@ -93,2 +107,2 @@\n-  size_t immediate_garbage = 0;\n-  size_t immediate_regions = 0;\n+    size_t immediate_garbage = 0;\n+    size_t immediate_regions = 0;\n@@ -96,2 +110,2 @@\n-  size_t free = 0;\n-  size_t free_regions = 0;\n+    size_t free = 0;\n+    size_t free_regions = 0;\n@@ -99,1 +113,1 @@\n-  ShenandoahMarkingContext* const ctx = _generation->complete_marking_context();\n+    ShenandoahMarkingContext* const ctx = _generation->complete_marking_context();\n@@ -101,28 +115,4 @@\n-  for (size_t i = 0; i < num_regions; i++) {\n-    ShenandoahHeapRegion* region = heap->get_region(i);\n-    if (!in_generation(region)) {\n-      continue;\n-    }\n-\n-    size_t garbage = region->garbage();\n-    total_garbage += garbage;\n-\n-    if (region->is_empty()) {\n-      free_regions++;\n-      free += ShenandoahHeapRegion::region_size_bytes();\n-    } else if (region->is_regular()) {\n-      if (!region->has_live() && !heap->mode()->is_generational()) {\n-        \/\/ We can recycle it right away and put it in the free set.\n-        immediate_regions++;\n-        immediate_garbage += garbage;\n-        region->make_trash_immediate();\n-      } else if (_generation->generation_mode() != OLD) {\n-        \/\/ HEY! At this stage in development our concurrent old\n-        \/\/ marking does NOT complete the subsequent phases of the collection\n-        \/\/ and we don't want regions stuck in the 'in_cset' state because\n-        \/\/ various asserts will trip.\n-\n-        \/\/ This is our candidate for later consideration.\n-        candidates[cand_idx]._region = region;\n-        candidates[cand_idx]._garbage = garbage;\n-        cand_idx++;\n+    for (size_t i = 0; i < num_regions; i++) {\n+      ShenandoahHeapRegion* region = heap->get_region(i);\n+      if (!in_generation(region)) {\n+        continue;\n@@ -130,1 +120,0 @@\n-    } else if (region->is_humongous_start()) {\n@@ -132,1 +121,23 @@\n-      \/\/ Reclaim humongous regions here, and count them as the immediate garbage\n+      size_t garbage = region->garbage();\n+      total_garbage += garbage;\n+\n+      if (region->is_empty()) {\n+        free_regions++;\n+        free += ShenandoahHeapRegion::region_size_bytes();\n+      } else if (region->is_regular()) {\n+        if (!region->has_live() && !heap->mode()->is_generational()) {\n+          \/\/ We can recycle it right away and put it in the free set.\n+          immediate_regions++;\n+          immediate_garbage += garbage;\n+          region->make_trash_immediate();\n+        } else {\n+          assert (_generation->generation_mode() != OLD, \"OLD is handled elsewhere\");\n+\n+          \/\/ This is our candidate for later consideration.\n+          candidates[cand_idx]._region = region;\n+          candidates[cand_idx]._garbage = garbage;\n+          cand_idx++;\n+        }\n+      } else if (region->is_humongous_start()) {\n+\n+        \/\/ Reclaim humongous regions here, and count them as the immediate garbage\n@@ -134,5 +145,5 @@\n-      bool reg_live = region->has_live();\n-      bool bm_live = ctx->is_marked(oop(region->bottom()));\n-      assert(reg_live == bm_live,\n-             \"Humongous liveness and marks should agree. Region live: %s; Bitmap live: %s; Region Live Words: \" SIZE_FORMAT,\n-             BOOL_TO_STR(reg_live), BOOL_TO_STR(bm_live), region->get_live_data_words());\n+        bool reg_live = region->has_live();\n+        bool bm_live = ctx->is_marked(oop(region->bottom()));\n+        assert(reg_live == bm_live,\n+               \"Humongous liveness and marks should agree. Region live: %s; Bitmap live: %s; Region Live Words: \" SIZE_FORMAT,\n+               BOOL_TO_STR(reg_live), BOOL_TO_STR(bm_live), region->get_live_data_words());\n@@ -140,4 +151,9 @@\n-      if (!region->has_live()) {\n-        heap->trash_humongous_region_at(region);\n-\n-        \/\/ Count only the start. Continuations would be counted on \"trash\" path\n+        if (!region->has_live()) {\n+          heap->trash_humongous_region_at(region);\n+\n+          \/\/ Count only the start. Continuations would be counted on \"trash\" path\n+          immediate_regions++;\n+          immediate_garbage += garbage;\n+        }\n+      } else if (region->is_trash()) {\n+        \/\/ Count in just trashed collection set, during coalesced CM-with-UR\n@@ -147,4 +163,0 @@\n-    } else if (region->is_trash()) {\n-      \/\/ Count in just trashed collection set, during coalesced CM-with-UR\n-      immediate_regions++;\n-      immediate_garbage += garbage;\n@@ -152,9 +164,0 @@\n-  }\n-\n-  \/\/ Step 2. Look back at garbage statistics, and decide if we want to collect anything,\n-  \/\/ given the amount of immediately reclaimable garbage. If we do, figure out the collection set.\n-\n-  assert (immediate_garbage <= total_garbage,\n-          \"Cannot have more immediate garbage than total garbage: \" SIZE_FORMAT \"%s vs \" SIZE_FORMAT \"%s\",\n-          byte_size_in_proper_unit(immediate_garbage), proper_unit_for_byte_size(immediate_garbage),\n-          byte_size_in_proper_unit(total_garbage),     proper_unit_for_byte_size(total_garbage));\n@@ -162,5 +165,111 @@\n-  size_t immediate_percent = (total_garbage == 0) ? 0 : (immediate_garbage * 100 \/ total_garbage);\n-\n-  if (immediate_percent <= ShenandoahImmediateThreshold) {\n-    choose_collection_set_from_regiondata(collection_set, candidates, cand_idx, immediate_garbage + free);\n-  }\n+    \/\/ Step 2. Look back at garbage statistics, and decide if we want to collect anything,\n+    \/\/ given the amount of immediately reclaimable garbage. If we do, figure out the collection set.\n+\n+    assert (immediate_garbage <= total_garbage,\n+            \"Cannot have more immediate garbage than total garbage: \" SIZE_FORMAT \"%s vs \" SIZE_FORMAT \"%s\",\n+            byte_size_in_proper_unit(immediate_garbage), proper_unit_for_byte_size(immediate_garbage),\n+            byte_size_in_proper_unit(total_garbage),     proper_unit_for_byte_size(total_garbage));\n+\n+    size_t immediate_percent = (total_garbage == 0) ? 0 : (immediate_garbage * 100 \/ total_garbage);\n+\n+    if (immediate_percent <= ShenandoahImmediateThreshold) {\n+\n+      if (_old_heuristics != NULL) {\n+        uint included_old_regions = 0;\n+        size_t evacuated_old_bytes = 0;\n+\n+        \/\/ TODO: These macro definitions represent a first approximation to desired operating parameters.\n+        \/\/ Eventually, these values should be determined by heuristics and should adjust dynamically based\n+        \/\/ on most current execution behavior.  In the interrim, we may choose to offer command-line options\n+        \/\/ to set the values of these configuration parameters.\n+\n+        \/\/ MAX_OLD_EVACUATION_BYTES represents an \"arbitrary\" bound on how much evacuation effort is dedicated to\n+        \/\/ old-gen regions.\n+#define MAX_OLD_EVACUATION_BYTES (ShenandoahHeapRegion::region_size_bytes() * 8)\n+\n+        \/\/ PROMOTION_BUDGET_BYTES represents an \"arbitrary\" bound on how many bytes can be consumed by young-gen\n+        \/\/ objects promoted into old-gen memory.  We need to avoid a scenario under which promotion of objects\n+        \/\/ depletes old-gen available memory to the point that there is insufficient memory to hold old-gen objects\n+        \/\/ that need to be evacuated from within the old-gen collection set.\n+        \/\/\n+        \/\/ TODO We should probably enforce this, but there is no enforcement currently.  Key idea: if there is not\n+        \/\/ sufficient memory within old-gen to hold an object that wants to be promoted, defer promotion until a\n+        \/\/ subsequent evacuation pass.  Since enforcement may be expensive, requiring frequent synchronization\n+        \/\/ between mutator and GC threads, here's an alternative \"greedy\" mitigation strategy: Set the parameter's\n+        \/\/ value so overflow is \"very rare\".  In the case that we experience overflow, evacuate what we can from\n+        \/\/ within the old collection set, but don't evacuate everything.  At the end of evacuation, any collection\n+        \/\/ set region that was not fully evacuated cannot be recycled.  It becomes a prime candidate for the next\n+        \/\/ collection set selection.  Here, we'd rather fall back to this contingent behavior than force a full STW\n+        \/\/ collection.\n+#define PROMOTION_BUDGET_BYTES (ShenandoahHeapRegion::region_size_bytes() \/ 2)\n+\n+        \/\/ If a region is put into the collection set, then this region's free (not yet used) bytes are no longer\n+        \/\/ \"available\" to hold the results of other evacuations.  This causes further decrease in the value of\n+        \/\/ AVAILABLE_OLD_BYTES.\n+        \/\/\n+        \/\/ We address this by reducing the evacuation budget by the amount of live memory in that region and by the\n+        \/\/ amount of unallocated memory in that region if the evacuation budget is constrained by availability of\n+        \/\/ free memory.\n+\n+        \/\/ Allow no more evacuation than exists free-space within old-gen memory\n+        size_t old_evacuation_budget = (_old_heuristics->_generation->available() > PROMOTION_BUDGET_BYTES)? _old_heuristics->_generation->available() - PROMOTION_BUDGET_BYTES: 0;\n+\n+        \/\/ But if the amount of available free space in old-gen memory exceeds the pacing bound on how much old-gen memory can be\n+        \/\/ evacuated during each evacuation pass, then cut the old-gen evacuation further.  The pacing bound is designed to assure\n+        \/\/ that old-gen evacuations to not excessively slow the evacuation pass in order to assure that young-gen GC cadence is\n+        \/\/ not disrupted.\n+\n+        \/\/ Represents availability of memory to hold evacuations beyond what is required to hold planned evacuations.  May go\n+        \/\/ negative if we choose to collect regions with large amounts of free memory.\n+        long long excess_free_capacity;\n+        if (old_evacuation_budget > MAX_OLD_EVACUATION_BYTES) {\n+          excess_free_capacity = old_evacuation_budget - MAX_OLD_EVACUATION_BYTES;\n+          old_evacuation_budget = MAX_OLD_EVACUATION_BYTES;\n+        } else\n+          excess_free_capacity = 0;\n+\n+        size_t remaining_old_evacuation_budget = old_evacuation_budget;\n+\n+        \/\/ The number of old-gen regions that were selected as candidates for collection at the end of the most recent old-gen\n+        \/\/ concurrent marking phase and have not yet been collected is represented by unprocessed_old_collection_candidates()\n+        while (_old_heuristics->unprocessed_old_collection_candidates() > 0) {\n+          \/\/ Old collection candidates are sorted in order of decreasing garbage contained therein.\n+          ShenandoahHeapRegion* r = _old_heuristics->next_old_collection_candidate();\n+\n+          \/\/ Assuming region r is added to the collection set, what will be the remaining_old_evacuation_budget after accounting\n+          \/\/ for the loss of region r's free() memory.\n+          size_t adjusted_remaining_old_evacuation_budget;\n+\n+          \/\/ If we choose region r to be collected, then we need to decrease the capacity to hold other evacuations by the size of r's free memory.\n+          excess_free_capacity -= r->free();\n+          \/\/ If subtracting r->free from excess_free_capacity() makes it go negative, that means we are going to have to decrease the\n+          \/\/ evacuation budget.\n+          if (excess_free_capacity < 0) {\n+            if (remaining_old_evacuation_budget < (size_t) -excess_free_capacity) {\n+              \/\/ By setting adjusted_remaining_old_evacuation_budget to 0, we prevent further additions to the old-gen collection set,\n+              \/\/ unless the region has zero live data bytes.\n+              adjusted_remaining_old_evacuation_budget = 0;\n+            } else {\n+              \/\/ Adding negative excess_free_capacity decreases the adjusted_remaining_old_evacuation_budget\n+              adjusted_remaining_old_evacuation_budget = remaining_old_evacuation_budget + excess_free_capacity;\n+            }\n+          } else {\n+            adjusted_remaining_old_evacuation_budget = remaining_old_evacuation_budget;\n+          }\n+\n+          if (r->get_live_data_bytes() > adjusted_remaining_old_evacuation_budget) {\n+            break;\n+          }\n+          collection_set->add_region(r);\n+          included_old_regions++;\n+          evacuated_old_bytes += r->get_live_data_bytes();\n+          _old_heuristics->consume_old_collection_candidate();\n+          remaining_old_evacuation_budget = adjusted_remaining_old_evacuation_budget - r->get_live_data_bytes();\n+        }\n+\n+        if (included_old_regions > 0) {\n+          log_info(gc)(\"Old-gen piggyback evac (%llu regions, %llu bytes)\",\n+                       (unsigned long long) included_old_regions,\n+                       (unsigned long long) evacuated_old_bytes);\n+        }\n+      }\n@@ -168,1 +277,4 @@\n-  size_t cset_percent = (total_garbage == 0) ? 0 : (collection_set->garbage() * 100 \/ total_garbage);\n+      \/\/ Add young-gen regions into the collection set.  This is a virtual call, implemented differently by each\n+      \/\/ of the heuristics subclasses.\n+      choose_collection_set_from_regiondata(collection_set, candidates, cand_idx, immediate_garbage + free);\n+    }\n@@ -170,2 +282,1 @@\n-  size_t collectable_garbage = collection_set->garbage() + immediate_garbage;\n-  size_t collectable_garbage_percent = (total_garbage == 0) ? 0 : (collectable_garbage * 100 \/ total_garbage);\n+    size_t cset_percent = (total_garbage == 0) ? 0 : (collection_set->garbage() * 100 \/ total_garbage);\n@@ -173,3 +284,5 @@\n-  log_info(gc, ergo)(\"Collectable Garbage: \" SIZE_FORMAT \"%s (\" SIZE_FORMAT \"%%), \"\n-                     \"Immediate: \" SIZE_FORMAT \"%s (\" SIZE_FORMAT \"%%), \"\n-                     \"CSet: \" SIZE_FORMAT \"%s (\" SIZE_FORMAT \"%%)\",\n+    size_t collectable_garbage = collection_set->garbage() + immediate_garbage;\n+    size_t collectable_garbage_percent = (total_garbage == 0) ? 0 : (collectable_garbage * 100 \/ total_garbage);\n+    log_info(gc, ergo)(\"Collectable Garbage: \" SIZE_FORMAT \"%s (\" SIZE_FORMAT \"%%), \"\n+                       \"Immediate: \" SIZE_FORMAT \"%s (\" SIZE_FORMAT \"%%), \"\n+                       \"CSet: \" SIZE_FORMAT \"%s (\" SIZE_FORMAT \"%%)\",\n@@ -177,3 +290,3 @@\n-                     byte_size_in_proper_unit(collectable_garbage),\n-                     proper_unit_for_byte_size(collectable_garbage),\n-                     collectable_garbage_percent,\n+                       byte_size_in_proper_unit(collectable_garbage),\n+                       proper_unit_for_byte_size(collectable_garbage),\n+                       collectable_garbage_percent,\n@@ -181,3 +294,3 @@\n-                     byte_size_in_proper_unit(immediate_garbage),\n-                     proper_unit_for_byte_size(immediate_garbage),\n-                     immediate_percent,\n+                       byte_size_in_proper_unit(immediate_garbage),\n+                       proper_unit_for_byte_size(immediate_garbage),\n+                       immediate_percent,\n@@ -185,3 +298,4 @@\n-                     byte_size_in_proper_unit(collection_set->garbage()),\n-                     proper_unit_for_byte_size(collection_set->garbage()),\n-                     cset_percent);\n+                       byte_size_in_proper_unit(collection_set->garbage()),\n+                       proper_unit_for_byte_size(collection_set->garbage()),\n+                       cset_percent);\n+  }\n@@ -198,0 +312,14 @@\n+bool ShenandoahHeuristics::should_defer_gc() {\n+  if ((_generation->generation_mode() == OLD) && (unprocessed_old_collection_candidates() > 0)) {\n+    \/\/ Cannot start a new old-gen GC until previous one has finished.\n+    \/\/\n+    \/\/ Future refinement: under certain circumstances, we might be more\n+    \/\/ sophisticated about this choice.  But if we choose to abandon\n+    \/\/ previous old collection before it has completed evacuations,\n+    \/\/ we would need to coalesce and fill all garbage within\n+    \/\/ unevacuated collection-set regions.\n+    return true;\n+  }\n+  return false;\n+}\n+\n@@ -199,0 +327,4 @@\n+\n+  if (should_defer_gc())\n+    return false;\n+\n@@ -224,1 +356,1 @@\n-          \"In range before adjustment: \" INTX_FORMAT, _gc_time_penalties);\n+         \"In range before adjustment: \" INTX_FORMAT, _gc_time_penalties);\n@@ -236,1 +368,1 @@\n-          \"In range after adjustment: \" INTX_FORMAT, _gc_time_penalties);\n+         \"In range after adjustment: \" INTX_FORMAT, _gc_time_penalties);\n@@ -307,2 +439,151 @@\n-      || (_generation->generation_mode() == YOUNG && region->affiliation() == YOUNG_GENERATION)\n-      || (_generation->generation_mode() == OLD && region->affiliation() == OLD_GENERATION);\n+    || (_generation->generation_mode() == YOUNG && region->affiliation() == YOUNG_GENERATION)\n+    || (_generation->generation_mode() == OLD && region->affiliation() == OLD_GENERATION);\n+}\n+\n+void ShenandoahHeuristics::prepare_for_old_collections() {\n+  assert(_generation->generation_mode() == OLD, \"This service only available for old-gc heuristics\");\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  uint free_regions = 0;\n+  size_t cand_idx = 0;\n+  size_t total_garbage = 0;\n+  size_t num_regions = heap->num_regions();\n+\n+  RegionData* candidates = _region_data;\n+  for (size_t i = 0; i < num_regions; i++) {\n+    ShenandoahHeapRegion* region = heap->get_region(i);\n+    if (!in_generation(region))\n+      continue;\n+    else {\n+      size_t garbage = region->garbage();\n+      total_garbage += garbage;\n+\n+      candidates[cand_idx]._region = region;\n+      candidates[cand_idx]._garbage = garbage;\n+      cand_idx++;\n+    }\n+  }\n+\n+  \/\/ Give special treatment to humongous regions.  Assume humongous regions is entirely\n+  \/\/ garbage or entirely non-garbage.  Assume that a head humongous region and the associated\n+  \/\/ humongous continuous regions are uniformly entirely garbage or entirely non-garbage.\n+  \/\/\n+  \/\/ Sift garbage humongous regions to front, non-garbage humongous regions to end of array.\n+  size_t first_non_humongous_empty = 0;\n+  size_t first_humongous_non_empty = cand_idx;\n+\n+  \/\/ This loop is written as while rather than for because of\n+  \/\/ suspected gcc error in translating\/optimizing for-loop\n+  size_t i = 0;\n+  while (i < first_humongous_non_empty) {\n+    ShenandoahHeapRegion* region = candidates[i]._region;\n+    if (region->is_humongous()) {\n+      if (region->get_live_data_bytes() == 0) {\n+        \/\/ Humongous region is entirely garbage.  Reclaim it.\n+        if (i == first_non_humongous_empty) {\n+          first_non_humongous_empty++;\n+        } else {\n+          RegionData swap_tmp = candidates[i];\n+          candidates[i] = candidates[first_non_humongous_empty];\n+          candidates[first_non_humongous_empty++] = swap_tmp;\n+        }\n+        i++;\n+      } else {\n+        \/\/ Humongous region is non garbage.  Don't reclaim it.\n+        if (i + 1 == first_humongous_non_empty) {\n+          first_humongous_non_empty--;\n+          i++;\n+        } else {\n+          RegionData swap_tmp = candidates[i];\n+          candidates[i] = candidates[--first_humongous_non_empty];\n+          candidates[first_humongous_non_empty] = swap_tmp;\n+          \/\/ Do not increment i so we can revisit swapped entry on next iteration\n+        }\n+      }\n+    } else {\n+      i++;\n+    }\n+  }\n+\n+\n+  \/\/ Prioritize regions to select garbage-first regions\n+  QuickSort::sort<RegionData>(candidates + first_non_humongous_empty, (int)(first_humongous_non_empty - first_non_humongous_empty),\n+                              compare_by_garbage, false);\n+\n+  \/\/ Any old-gen region that contains 50% garbage or more is to be\n+  \/\/ evacuated.  In the future, this threshold percentage may be specified on\n+  \/\/ the command line or preferrably determined by dynamic heuristics.\n+#define CollectionThresholdGarbagePercent 50\n+\n+  size_t region_size = ShenandoahHeapRegion::region_size_bytes();\n+  for (size_t i = first_non_humongous_empty; i < first_humongous_non_empty; i++) {\n+    \/\/ Do approximate percent to avoid floating point math\n+    size_t percent_garbage = candidates[i]._garbage * 100 \/ region_size;\n+\n+    if (percent_garbage < CollectionThresholdGarbagePercent) {\n+      _hidden_next_old_collection_candidate = 0;\n+      _hidden_old_collection_candidates = i;\n+      _first_coalesce_and_fill_candidate = i;\n+      _old_coalesce_and_fill_candidates = cand_idx - i;\n+\n+      \/\/ Note that we do not coalesce and fill occupied humongous regions\n+      \/\/ HR: humongous regions, RR: regular regions, CF: coalesce and fill regions\n+      log_info(gc)(\"Old-gen mark evac (%u HR, %llu RR), %llu CF)\",\n+                   (unsigned int) first_non_humongous_empty,\n+                   (unsigned long long) (_hidden_old_collection_candidates - first_non_humongous_empty),\n+                   (unsigned long long) _old_coalesce_and_fill_candidates);\n+      return;\n+    }\n+  }\n+\n+  \/\/ If we reach here, all of non-humogous old-gen regions are candidates for collection set.\n+  _hidden_next_old_collection_candidate = 0;\n+  _hidden_old_collection_candidates = first_humongous_non_empty;\n+  _first_coalesce_and_fill_candidate = 0;\n+  _old_coalesce_and_fill_candidates = 0;\n+\n+#undef CollectionThresholdGarbagePercent\n+\n+  \/\/ Note that we do not coalesce and fill occupied humongous regions\n+  \/\/ HR: humongous regions, RR: regular regions, CF: coalesce and fill regions\n+  log_info(gc)(\"Old-gen mark evac (%u HR, %llu RR), %llu CF)\",\n+               (unsigned int) first_non_humongous_empty,\n+               (unsigned long long) (_hidden_old_collection_candidates - first_non_humongous_empty),\n+               (unsigned long long) _old_coalesce_and_fill_candidates);\n+}\n+\n+void ShenandoahHeuristics::start_old_evacuations() {\n+  assert(_generation->generation_mode() == OLD, \"This service only available for old-gc heuristics\");\n+\n+  _old_collection_candidates = _hidden_old_collection_candidates;\n+  _next_old_collection_candidate = _hidden_next_old_collection_candidate;\n+\n+  _hidden_old_collection_candidates = 0;}\n+\n+\n+uint ShenandoahHeuristics::unprocessed_old_collection_candidates() {\n+  assert(_generation->generation_mode() == OLD, \"This service only available for old-gc heuristics\");\n+  return _old_collection_candidates + _hidden_old_collection_candidates;\n+}\n+\n+ShenandoahHeapRegion* ShenandoahHeuristics::next_old_collection_candidate() {\n+  assert(_generation->generation_mode() == OLD, \"This service only available for old-gc heuristics\");\n+  return _region_data[_next_old_collection_candidate]._region;\n+}\n+\n+void ShenandoahHeuristics::consume_old_collection_candidate() {\n+  assert(_generation->generation_mode() == OLD, \"This service only available for old-gc heuristics\");\n+  _next_old_collection_candidate++;\n+  _old_collection_candidates--;\n+}\n+\n+uint ShenandoahHeuristics::old_coalesce_and_fill_candidates() {\n+  assert(_generation->generation_mode() == OLD, \"This service only available for old-gc heuristics\");\n+  return _old_coalesce_and_fill_candidates;\n+}\n+\n+void ShenandoahHeuristics::get_coalesce_and_fill_candidates(ShenandoahHeapRegion** buffer) {\n+  assert(_generation->generation_mode() == OLD, \"This service only available for old-gc heuristics\");\n+  uint count = _old_coalesce_and_fill_candidates;\n+  int index = _first_coalesce_and_fill_candidate;\n+  while (count-- > 0)\n+    *buffer++ = _region_data[index++]._region;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.cpp","additions":373,"deletions":92,"binary":false,"changes":465,"status":"modified"},{"patch":"@@ -61,0 +61,20 @@\n+\/\/ TODO: Probably want to subclass ShenandoahHeuristics.\n+\/\/\n+\/\/ As currently implemented, we have three instances of\n+\/\/ ShenandoahHeuristics, for GLOBAL, OLD, and YOUNG.  Each instance\n+\/\/ needs different information.\n+\/\/\n+\/\/ In particular:\n+\/\/  YOUNG needs a pointer to OLD so it can ask if there are OLD regions\n+\/\/   wanting to be evacuated.\n+\/\/  OLD needs to keep track of which OLD regions need to be evacuated and\n+\/\/   which OLD regions need their garbage to be coalesced and filled.\n+\/\/   OLD also needs to know when all of its candidate evacuation regions\n+\/\/   have been evacuated because it cannot trigger a new OLD\n+\/\/   concurrent mark until that has happened.\n+\/\/  GLOBAL: not sure what this needs, or how it interacts with OLD, YOUNG\n+\/\/   heuristics.\n+\/\/\n+\/\/ For expediency, we'll have a single class that is a \"union\" of\n+\/\/ necessary functionality.\n+\n@@ -72,0 +92,21 @@\n+  ShenandoahGeneration* _generation;\n+\n+  \/\/ if (_generation->generation_mode() != YOUNG)\n+  \/\/  _old_heuristics = NULL;\n+  \/\/ else\n+  \/\/  _old_heuristics points to the ShenandoahHeuristics object that represents old-gen.\n+  ShenandoahHeuristics *_old_heuristics;\n+\n+  \/\/ if (_generation->generation_mode() == GLOBAL) _region_data represents\n+  \/\/  the results of most recently completed global marking pass\n+  \/\/ if (_generation->generation_mode() == OLD) _region_data represents\n+  \/\/  the results of most recently completed old-gen marking pass\n+  \/\/ if (_generation->generation_mode() == YOUNG) _region_data represents\n+  \/\/  the resulits of most recently completed young-gen marking pass\n+  \/\/\n+  \/\/ Note that there is some redundancy represented in _region_data because\n+  \/\/ each instance is an array large enough to hold all regions.  However,\n+  \/\/ any region in young-gen is not in old-gen.  And any time we are\n+  \/\/ making use of the GLOBAL data, there is no need to maintain the\n+  \/\/ YOUNG or OLD data.  Consider this redundancy of data structure to\n+  \/\/ have negligible cost unless proven otherwise.\n@@ -74,0 +115,28 @@\n+  \/\/ if (_generation->generation_mode() == OLD) _old_collection_candidates\n+  \/\/  represent the number of regions selected for collection following the\n+  \/\/  most recently completed old-gen mark that have not yet been selected\n+  \/\/  for evacuation and _next_collection_candidate is the index within\n+  \/\/  _region_data of the next candidate region to be selected for evacuation.\n+  \/\/ if (_generation->generation_mode() != OLD) these two variables are\n+  \/\/  not used.\n+  uint _old_collection_candidates;\n+  uint _next_old_collection_candidate;\n+\n+  \/\/ At the time we select the old-gen collection set, _hidden_old_collection_candidates\n+  \/\/ and _hidden_next_old_collection_candidates are set to remember the intended old-gen\n+  \/\/ collection set.  After all old-gen regions not in the old-gen collection set have been\n+  \/\/ coalesced and filled, the content of these variables is copied to _old_collection_candidates\n+  \/\/ and _next_old_collection_candidates so that evacuations can begin evacuating these regions.\n+  uint _hidden_old_collection_candidates;\n+  uint _hidden_next_old_collection_candidate;\n+\n+  \/\/ if (_generation->generation_mode() == OLD)\n+  \/\/  _old_coalesce_and_fill_candidates represents the number of regions\n+  \/\/  that were chosen for the garbage contained therein to be coalesced\n+  \/\/  and filled and _first_coalesce_and_fill_candidate represents the\n+  \/\/  the index of the first such region within the _region_data array.\n+  \/\/ if (_generation->generation_mode() != OLD) these two variables are\n+  \/\/  not used.\n+  uint _old_coalesce_and_fill_candidates;\n+  uint _first_coalesce_and_fill_candidate;\n+\n@@ -87,2 +156,0 @@\n-  ShenandoahGeneration* _generation;\n-\n@@ -91,0 +158,4 @@\n+  \/\/ TODO: We need to enhance this API to give visibility to accompanying old-gen evacuation effort.\n+  \/\/ In the case that the old-gen evacuation effort is small or zero, the young-gen heuristics\n+  \/\/ should feel free to dedicate increased efforts to young-gen evacuation.\n+\n@@ -100,1 +171,2 @@\n-  ShenandoahHeuristics(ShenandoahGeneration* generation);\n+  ShenandoahHeuristics(ShenandoahGeneration* generation,\n+                       ShenandoahHeuristics* old_heuristics);\n@@ -111,0 +183,2 @@\n+  bool should_defer_gc();\n+\n@@ -137,0 +211,33 @@\n+\n+\n+  \/\/ The following methods are only relevant if _generation->generation_mode() == OLD.  These methods perform no\n+  \/\/ synchronization.  It is assumed that all of them are invoked by the same ShenandoahControlThread.\n+\n+  \/\/ Having coalesced and filled all old-gen heap regions that are not part of the old-gen collection set, begin\n+  \/\/ evacuating the collection set.\n+  void start_old_evacuations();\n+\n+  \/\/ Prepare for evacuation of old-gen regions by capturing the mark results of a recently completed concurrent mark pass.\n+  void prepare_for_old_collections();\n+\n+  \/\/ How many old-collection candidates have not yet been processed?\n+  uint unprocessed_old_collection_candidates();\n+\n+  \/\/ Return the next old-collection candidate in order of decreasing amounts of garbage.  (We process most-garbage regions\n+  \/\/ first.)  This does not consume the candidate.  If the candidate is selected for inclusion in a collection set, then\n+  \/\/ the candidate is consumed by invoking consume_old_collection_candidate().\n+  ShenandoahHeapRegion* next_old_collection_candidate();\n+\n+  \/\/ Adjust internal state to reflect that one fewer old-collection candidate remains to be processed.\n+  void consume_old_collection_candidate();\n+\n+  \/\/ How many old-collection regions were identified at the end of the most recent old-gen mark to require their\n+  \/\/ unmarked objects to be coalesced and filled?\n+  uint old_coalesce_and_fill_candidates();\n+\n+  \/\/ Fill in buffer with all of the old-collection regions that were identified at the end of the most recent old-gen\n+  \/\/ mark to require their unmarked objects to be coalesced and filled.  The buffer array must have at least\n+  \/\/ old_coalesce_and_fill_candidates() entries, or memory may be corrupted when this function overwrites the\n+  \/\/ end of the array.\n+  void get_coalesce_and_fill_candidates(ShenandoahHeapRegion** buffer);\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.hpp","additions":110,"deletions":3,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -32,2 +32,2 @@\n-  ShenandoahPassiveHeuristics(ShenandoahGeneration* generation)\n-    : ShenandoahHeuristics(generation) {}\n+  ShenandoahPassiveHeuristics(ShenandoahGeneration* generation, ShenandoahHeuristics* old_heuristics)\n+    : ShenandoahHeuristics(generation, old_heuristics) {}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahPassiveHeuristics.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,2 +35,2 @@\n-ShenandoahStaticHeuristics::ShenandoahStaticHeuristics(ShenandoahGeneration* generation) :\n-  ShenandoahHeuristics(generation) {\n+ShenandoahStaticHeuristics::ShenandoahStaticHeuristics(ShenandoahGeneration* generation, ShenandoahHeuristics* old_heuristics) :\n+  ShenandoahHeuristics(generation, old_heuristics) {\n@@ -48,0 +48,4 @@\n+  if (ShenandoahHeuristics::should_defer_gc()) {\n+    return false;\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahStaticHeuristics.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-  ShenandoahStaticHeuristics(ShenandoahGeneration* generation);\n+  ShenandoahStaticHeuristics(ShenandoahGeneration* generation, ShenandoahHeuristics* heuristics);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahStaticHeuristics.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-ShenandoahHeuristics* ShenandoahMode::initialize_heuristics(ShenandoahGeneration* generation) const {\n+ShenandoahHeuristics* ShenandoahMode::initialize_heuristics(ShenandoahGeneration* generation, ShenandoahHeuristics* old_heuristics) const {\n@@ -37,1 +37,1 @@\n-      return new ShenandoahAggressiveHeuristics(generation);\n+      return new ShenandoahAggressiveHeuristics(generation, old_heuristics);\n@@ -39,1 +39,1 @@\n-      return new ShenandoahStaticHeuristics(generation);\n+      return new ShenandoahStaticHeuristics(generation, old_heuristics);\n@@ -41,1 +41,1 @@\n-      return new ShenandoahAdaptiveHeuristics(generation);\n+      return new ShenandoahAdaptiveHeuristics(generation, old_heuristics);\n@@ -43,1 +43,1 @@\n-      return new ShenandoahCompactHeuristics(generation);\n+      return new ShenandoahCompactHeuristics(generation, old_heuristics);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/mode\/shenandoahMode.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-  virtual ShenandoahHeuristics* initialize_heuristics(ShenandoahGeneration* generation) const;\n+  virtual ShenandoahHeuristics* initialize_heuristics(ShenandoahGeneration* generation, ShenandoahHeuristics* old_heuristics) const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/mode\/shenandoahMode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-ShenandoahHeuristics* ShenandoahPassiveMode::initialize_heuristics(ShenandoahGeneration* generation) const {\n+ShenandoahHeuristics* ShenandoahPassiveMode::initialize_heuristics(ShenandoahGeneration* generation, ShenandoahHeuristics* old_heuristics) const {\n@@ -57,1 +57,1 @@\n-    return new ShenandoahPassiveHeuristics(generation);\n+    return new ShenandoahPassiveHeuristics(generation, old_heuristics);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/mode\/shenandoahPassiveMode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-  virtual ShenandoahHeuristics* initialize_heuristics(ShenandoahGeneration* generation) const;\n+  virtual ShenandoahHeuristics* initialize_heuristics(ShenandoahGeneration* generation, ShenandoahHeuristics* old_heuristics) const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/mode\/shenandoahPassiveMode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,0 +49,2 @@\n+\n+protected:\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -518,0 +518,1 @@\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -74,2 +74,2 @@\n-void ShenandoahGeneration::initialize_heuristics(ShenandoahMode* gc_mode) {\n-  _heuristics = gc_mode->initialize_heuristics(this);\n+ShenandoahHeuristics* ShenandoahGeneration::initialize_heuristics(ShenandoahMode* gc_mode, ShenandoahHeuristics* old_heuristics) {\n+  _heuristics = gc_mode->initialize_heuristics(this, old_heuristics);\n@@ -87,0 +87,1 @@\n+  return _heuristics;\n@@ -129,1 +130,0 @@\n-\n@@ -276,1 +276,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-  void initialize_heuristics(ShenandoahMode* gc_mode);\n+  ShenandoahHeuristics* initialize_heuristics(ShenandoahMode* gc_mode, ShenandoahHeuristics* old_heuristics);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -482,3 +482,3 @@\n-  _global_generation->initialize_heuristics(_gc_mode);\n-  _young_generation->initialize_heuristics(_gc_mode);\n-  _old_generation->initialize_heuristics(_gc_mode);\n+  ShenandoahHeuristics* old_heuristics = _old_generation->initialize_heuristics(_gc_mode, NULL);\n+  _global_generation->initialize_heuristics(_gc_mode, NULL);\n+  _young_generation->initialize_heuristics(_gc_mode, old_heuristics);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -406,0 +406,33 @@\n+\/\/ oop_iterate without closure\n+void ShenandoahHeapRegion::oop_fill_and_coalesce() {\n+  HeapWord* obj_addr = bottom();\n+  HeapWord* t = top();\n+\n+  assert(!is_humongous(), \"No need to fill or coalesce humongous regions\");\n+  if (!is_active()) return;\n+\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  ShenandoahMarkingContext* marking_context = heap->marking_context();\n+\n+  \/\/ Expect this to be invoked only from within threads perfoming old-gen GC, and expect\n+  \/\/ old-gen marking to be completed before these threads invoke this service.\n+  assert(heap->active_generation()->is_mark_complete(), \"sanity\");\n+\n+  while (obj_addr < t) {\n+    oop obj = oop(obj_addr);\n+    if (marking_context->is_marked(obj)) {\n+      assert(obj->klass() != NULL, \"klass should not be NULL\");\n+      obj_addr += obj->size();\n+    } else {\n+      \/\/ Object is not marked.  Coalesce and fill dead object with dead neighbors.\n+      HeapWord* next_marked_obj = marking_context->get_next_marked_addr(obj_addr, t);\n+      assert(next_marked_obj <= t, \"next marked object cannot exceed top\");\n+      size_t fill_size = next_marked_obj - obj_addr;\n+      ShenandoahHeap::fill_with_object(obj_addr, fill_size);\n+      heap->card_scan()->coalesce_objects(obj_addr, fill_size);\n+      obj_addr = next_marked_obj;\n+    }\n+  }\n+}\n+\n+\n@@ -409,0 +442,2 @@\n+    \/\/ TODO: This doesn't look right.  This registers objects if !reregister, and it isn't filling if fill_dead_objects.\n+    \/\/ Furthermore, register and fill should be done after iterating.\n@@ -434,2 +469,0 @@\n-    HeapWord* fill_addr = NULL;\n-    size_t fill_size = 0;\n@@ -439,9 +472,0 @@\n-        if (fill_addr != NULL) {\n-           if (reregister_coalesced_objects) { \/\/ change existing crossing map information\n-            heap->card_scan()->coalesce_objects(fill_addr, fill_size);\n-          } else {              \/\/ establish new crossing map information\n-             heap->card_scan()->register_object(fill_addr);\n-          }\n-          ShenandoahHeap::fill_with_object(fill_addr, fill_size);\n-          fill_addr = NULL;\n-        }\n@@ -449,1 +473,1 @@\n-        if (!reregister_coalesced_objects)\n+        if (!reregister_coalesced_objects) {\n@@ -451,0 +475,1 @@\n+        }\n@@ -453,6 +478,9 @@\n-        int size = obj->size();\n-        if (fill_addr == NULL) {\n-          fill_addr = obj_addr;\n-          fill_size = size;\n-        } else {\n-          fill_size += size;\n+        \/\/ Object is not marked.  Coalesce and fill dead object with dead neighbors.\n+        HeapWord* next_marked_obj = marking_context->get_next_marked_addr(obj_addr, t);\n+        assert(next_marked_obj <= t, \"next marked object cannot exceed top\");\n+        size_t fill_size = next_marked_obj - obj_addr;\n+        ShenandoahHeap::fill_with_object(obj_addr, fill_size);\n+        if (reregister_coalesced_objects) {\n+          heap->card_scan()->coalesce_objects(obj_addr, fill_size);\n+        } else {              \/\/ establish new crossing map information\n+          heap->card_scan()->register_object(obj_addr);\n@@ -460,9 +488,1 @@\n-        obj_addr += size;\n-      }\n-    }\n-    if (fill_addr != NULL) {\n-      ShenandoahHeap::fill_with_object(fill_addr, fill_size);\n-      if (reregister_coalesced_objects) { \/\/ change existing crossing map information\n-        heap->card_scan()->coalesce_objects(fill_addr, fill_size);\n-      } else {              \/\/ establish new crossing map information\n-        heap->card_scan()->register_object(fill_addr);\n+        obj_addr = next_marked_obj;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.cpp","additions":47,"deletions":27,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -363,0 +363,3 @@\n+  \/\/ coalesce contiguous spans of garbage objects by filling header and reregistering start locations with remembered set.\n+  void oop_fill_and_coalesce();\n+\n@@ -414,0 +417,1 @@\n+  void oop_iterate_objects(bool fill_dead_objects, bool reregister_coalesced_objects);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/shenandoah\/shenandoahMonitoringSupport.hpp\"\n@@ -31,0 +32,36 @@\n+#include \"gc\/shenandoah\/shenandoahGeneration.hpp\"\n+#include \"gc\/shenandoah\/heuristics\/shenandoahHeuristics.hpp\"\n+#include \"gc\/shenandoah\/shenandoahWorkerPolicy.hpp\"\n+#include \"utilities\/events.hpp\"\n+\n+class ShenandoahConcurrentCoalesceAndFillTask : public AbstractGangTask {\n+private:\n+  \/\/ remember nworkers, coalesce_and_fill_region_array,coalesce_and_fill_regions_count\n+\n+  uint _nworkers;\n+  ShenandoahHeapRegion** _coalesce_and_fill_region_array;\n+  uint _coalesce_and_fill_region_count;\n+\n+public:\n+  ShenandoahConcurrentCoalesceAndFillTask(uint nworkers,\n+                                          ShenandoahHeapRegion** coalesce_and_fill_region_array, uint region_count) :\n+    AbstractGangTask(\"Shenandoah Concurrent Coalesce and Fill\"),\n+    _nworkers(nworkers),\n+    _coalesce_and_fill_region_array(coalesce_and_fill_region_array),\n+    _coalesce_and_fill_region_count(region_count) {\n+  }\n+\n+  void work(uint worker_id) {\n+    ShenandoahHeap* heap = ShenandoahHeap::heap();\n+\n+    for (uint region_idx = worker_id; region_idx < _coalesce_and_fill_region_count; region_idx += _nworkers) {\n+      ShenandoahHeapRegion* r = _coalesce_and_fill_region_array[region_idx];\n+      if (!r->is_humongous())\n+        r->oop_fill_and_coalesce();\n+      else {\n+        \/\/ there's only one object in this region and it's not garbage, so no need to coalesce or fill\n+      }\n+    }\n+  }\n+};\n+\n@@ -47,0 +84,6 @@\n+  ShenandoahHeuristics* old_heuristics = heap->old_generation()->heuristics();\n+\n+  entry_coalesce_and_fill();\n+\n+  old_heuristics->start_old_evacuations();\n+\n@@ -87,0 +130,45 @@\n+\n+void ShenandoahOldGC::entry_coalesce_and_fill_message(char *buf, size_t len) const {\n+  \/\/ ShenandoahHeap* const heap = ShenandoahHeap::heap();\n+  jio_snprintf(buf, len, \"Coalescing and filling (%s)\", _generation->name());\n+}\n+\n+void ShenandoahOldGC::op_coalesce_and_fill() {\n+  ShenandoahHeap* const heap = ShenandoahHeap::heap();\n+\n+  WorkGang* workers = heap->workers();\n+  uint nworkers = workers->active_workers();\n+\n+  assert(_generation->generation_mode() == OLD, \"Only old-GC does coalesce and fill\");\n+\n+  ShenandoahHeuristics* old_heuristics = heap->old_generation()->heuristics();\n+  uint coalesce_and_fill_regions_count = old_heuristics->old_coalesce_and_fill_candidates();\n+  ShenandoahHeapRegion* coalesce_and_fill_region_array[coalesce_and_fill_regions_count];\n+\n+  old_heuristics->get_coalesce_and_fill_candidates(coalesce_and_fill_region_array);\n+  ShenandoahConcurrentCoalesceAndFillTask task(nworkers, coalesce_and_fill_region_array, coalesce_and_fill_regions_count);\n+\n+\n+  \/\/ TODO:  We need to implement preemption of coalesce and fill.  If young-gen wants to run while we're working on this,\n+  \/\/ we should preempt this code and then resume it after young-gen has finished.  This requires that we \"remember\" the state\n+  \/\/ of each worker thread so it can be resumed where it left off.  Note that some worker threads may have processed more regions\n+  \/\/ than others at the time of preemption.\n+\n+  workers->run_task(&task);\n+}\n+\n+void ShenandoahOldGC::entry_coalesce_and_fill() {\n+  char msg[1024];\n+  ShenandoahHeap* const heap = ShenandoahHeap::heap();\n+\n+  entry_coalesce_and_fill_message(msg, sizeof(msg));\n+  ShenandoahConcurrentPhase gc_phase(msg, ShenandoahPhaseTimings::coalesce_and_fill);\n+\n+  TraceCollectorStats tcs(heap->monitoring_support()->concurrent_collection_counters());\n+  EventMark em(\"%s\", msg);\n+  ShenandoahWorkerScope scope(heap->workers(),\n+                              ShenandoahWorkerPolicy::calc_workers_for_conc_marking(),\n+                              \"concurrent coalesce and fill\");\n+\n+  op_coalesce_and_fill();\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGC.cpp","additions":88,"deletions":0,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+  void entry_coalesce_and_fill();\n@@ -39,0 +40,2 @@\n+  void op_coalesce_and_fill();\n+  void entry_coalesce_and_fill_message(char *buf, size_t len) const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGC.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -67,0 +67,2 @@\n+  f(coalesce_and_fill,                              \"Coalesce and Fill Old Dead\")      \\\n+  SHENANDOAH_PAR_PHASE_DO(coalesce_and_fill_,       \"    CFOD: \", f)                   \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahPhaseTimings.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,209 @@\n+\/*\n+ * Copyright (c) 2021, Amazon, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package gc.shenandoah.generational;\n+\n+import sun.hotspot.WhiteBox;\n+import java.util.Random;\n+import java.util.HashMap;\n+\n+\/* WARNING!\n+ *  As of the date on which this test was added into the jtreg suite, heuristic\n+ *  of old-gen GC passes is very simplistic.  A further shortcoming of the\n+ *  Generational Shenandoah as of introduction of this test is that it does\n+ *  currently support full GC.  If garbage collection falls behind mutator\n+ *  allocations, a full GC will be triggered and Generational Shenandoah will\n+ *  abort itself with an assertion error.  Both of these limitations will be\n+ *  addressed in future releases of Generational Shenandoah.\n+ *\n+ *  To avoid the risk of false regressions identified by this test, the heap\n+ *  size is set artificially high.  Though this test is known to run reliably\n+ *  in 66 MB heap, the heap size for this test run is currently set to 256 MB.\n+ *\/\n+\n+\/*\n+ * @test TestConcurrentEvac\n+ * @requires vm.gc.Shenandoah\n+ * @summary Confirm that card marking and remembered set scanning do not crash.\n+ * @library \/testlibrary \/test\/lib \/\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *      -Xms256m -Xmx256m\n+ *      -XX:+IgnoreUnrecognizedVMOptions\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+ *      -XX:NewRatio=1 -XX:+UnlockExperimentalVMOptions\n+ *      -XX:ShenandoahGuaranteedGCInterval=3000\n+ *      -XX:-UseDynamicNumberOfGCThreads -XX:-ShenandoahPacing\n+ *      gc.shenandoah.generational.TestConcurrentEvac\n+ *\/\n+\n+public class TestConcurrentEvac {\n+  private static WhiteBox wb = WhiteBox.getWhiteBox();\n+\n+  static private final int SeedForRandom = 46;\n+  \/\/ Sequence of random numbers should end with same value\n+\n+  \/\/ Smaller table will cause creation of more old-gen garbage\n+  \/\/ as previous entries in table are overwritten with new values.\n+  static private final int TableSize = 53;\n+  static private final int MaxStringLength = 47;\n+  static private final int SentenceLength = 5;\n+\n+  static private Random random = new Random(SeedForRandom);\n+\n+  public static class Node {\n+    static private final int NeighborCount = 48;\n+    static private final int ChildOverwriteCount = 32;\n+    static private final int IntArraySize = 128;\n+\n+    private String name;\n+\n+    \/\/ Each Node instance holds an array containing all substrings of\n+    \/\/ its name\n+\n+    \/\/ This array has entries from 0 .. (name.length() - 1).\n+    \/\/ num_substrings[i] represents the number of substrings that\n+    \/\/ correspond to a name of length i+1.\n+    private static int [] num_substrings;\n+\n+    static {\n+      \/\/ Initialize num_substrings.\n+      \/\/ For a name of length N, there are\n+      \/\/  N substrings of length 1\n+      \/\/  N-1 substrings of length 2\n+      \/\/  N-2 substrings of length 3\n+      \/\/  ...\n+      \/\/  1 substring of length N\n+      \/\/ Note that:\n+      \/\/   num_substrings[0] = 1\n+      \/\/   num_substrings[1] = 3\n+      \/\/   num_substrings[i] = (i+1)+num_substrings[i-1]\n+\n+      num_substrings = new int[MaxStringLength];\n+      num_substrings[0] = 1;\n+      for (int i = 1; i < MaxStringLength; i++)\n+        num_substrings[i] = (i+1)+num_substrings[i-1];\n+    }\n+\n+    private String [] substrings;\n+    private Node [] neighbors;\n+\n+    public Node(String name) {\n+      this.name = name;\n+      this.substrings = new String[num_substrings[name.length() - 1]];\n+\n+      int index = 0;\n+      for (int substring_length = 1;\n+           substring_length <= name.length(); substring_length++) {\n+        for (int offset = 0;\n+             offset + substring_length <= name.length(); offset++) {\n+          this.substrings[index++] = name.substring(offset,\n+                                                    offset + substring_length);\n+        }\n+      }\n+    }\n+\n+    public String value() {\n+      return name;\n+    }\n+\n+    public String arbitrary_substring() {\n+      int index = TestConcurrentEvac.randomUnsignedInt() % substrings.length;\n+      return substrings[index];\n+    }\n+  }\n+\n+\n+  \/\/ Return random int between 1 and MaxStringLength inclusive\n+  static int randomStringLength() {\n+    int length = randomUnsignedInt();\n+    length %= (MaxStringLength - 1);\n+    length += 1;\n+    return length;\n+  }\n+\n+  static String randomCharacter() {\n+    int index = randomUnsignedInt() % 52;\n+    return (\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\".\n+            substring(index, index+1));\n+  }\n+\n+  static String randomString() {\n+    int length = randomStringLength();\n+    String result = new String(); \/\/ make the compiler work for this garbage...\n+    for (int i = 0; i < length; i++)\n+      result += randomCharacter();\n+    return result;\n+  }\n+\n+  static int randomUnsignedInt() {\n+    int result = random.nextInt();\n+    if (result < 0) result = -result;\n+    if (result < 0) result = 0;\n+    return result;\n+  }\n+\n+  static int randomIndex() {\n+    int index = randomUnsignedInt();\n+    index %= TableSize;\n+    return index;\n+  }\n+\n+  public static void main(String args[]) throws Exception {\n+    HashMap<Integer, Node> table = new HashMap<Integer, Node>(TableSize);\n+\n+    if (!wb.getBooleanVMFlag(\"UseShenandoahGC\") ||\n+        !wb.getStringVMFlag(\"ShenandoahGCMode\").equals(\"generational\"))\n+      throw new IllegalStateException(\"Command-line options not honored!\");\n+\n+    for (int count = java.lang.Integer.MAX_VALUE\/1024; count >= 0; count--) {\n+      int index = randomIndex();\n+      String name = randomString();\n+      table.put(index, new Node(name));\n+    }\n+\n+    String conclusion = \"\";\n+\n+    for (int i = 0; i < SentenceLength; i++) {\n+      Node a_node = table.get(randomIndex());\n+      if (a_node == null)\n+        i--;\n+      else {\n+        String a_string = a_node.arbitrary_substring();\n+        conclusion += a_string;\n+        conclusion += \" \";\n+      }\n+    }\n+    conclusion = conclusion.substring(0, conclusion.length() - 1);\n+\n+    System.out.println(\"Conclusion is [\" + conclusion + \"]\");\n+\n+    if (!conclusion.equals(\"cTy cTykJ kAkKAOWYEHbxFCmRIlyk xjYMdNmtAQXNGdIc sqHKsWnJIP\"))\n+      throw new IllegalStateException(\"Random sequence of words did not end well!\");\n+\n+  }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/generational\/TestConcurrentEvac.java","additions":209,"deletions":0,"binary":false,"changes":209,"status":"added"}]}