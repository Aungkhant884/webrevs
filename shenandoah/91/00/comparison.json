{"files":[{"patch":"@@ -110,0 +110,1 @@\n+      ShenandoahConcurrentPhase gc_phase(\"Concurrent remembered set scanning\", ShenandoahPhaseTimings::init_scan_rset);\n@@ -115,1 +116,1 @@\n-    if (check_cancellation_and_abort(ShenandoahDegenPoint::_degenerated_outside_cycle)) return false;\n+    if (check_cancellation_and_abort(ShenandoahDegenPoint::_degenerated_roots)) return false;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -138,1 +138,1 @@\n-        _degen_generation = heap->global_generation();\n+        _degen_generation = heap->mode()->is_generational() ? heap->young_generation() : heap->global_generation();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -66,1 +66,2 @@\n-  const char* msg = degen_event_message(_degen_point);\n+  char msg[1024];\n+  degen_event_message(_degen_point, msg, sizeof(msg));\n@@ -113,1 +114,0 @@\n-      \/\/\n@@ -115,0 +115,11 @@\n+\n+      \/\/ Note that we can only do this for \"outside-cycle\" degens, otherwise we would risk\n+      \/\/ changing the cycle parameters mid-cycle during concurrent -> degenerated handover.\n+      heap->set_unload_classes((!heap->mode()->is_generational() || _generation->generation_mode() == GLOBAL) && _generation->heuristics()->can_unload_classes());\n+\n+      if (_generation->generation_mode() == YOUNG || (_generation->generation_mode() == GLOBAL && ShenandoahVerify)) {\n+        \/\/ Swap remembered sets for young, or if the verifier will run during a global collect\n+        _generation->swap_remembered_set();\n+      }\n+\n+    case _degenerated_roots:\n@@ -120,4 +131,0 @@\n-      \/\/ Note that we can only do this for \"outside-cycle\" degens, otherwise we would risk\n-      \/\/ changing the cycle parameters mid-cycle during concurrent -> degenerated handover.\n-      heap->set_unload_classes(_generation->heuristics()->can_unload_classes());\n-\n@@ -357,16 +364,2 @@\n-const char* ShenandoahDegenGC::degen_event_message(ShenandoahDegenPoint point) const {\n-  switch (point) {\n-    case _degenerated_unset:\n-      return \"Pause Degenerated GC (<UNSET>)\";\n-    case _degenerated_outside_cycle:\n-      return \"Pause Degenerated GC (Outside of Cycle)\";\n-    case _degenerated_mark:\n-      return \"Pause Degenerated GC (Mark)\";\n-    case _degenerated_evac:\n-      return \"Pause Degenerated GC (Evacuation)\";\n-    case _degenerated_updaterefs:\n-      return \"Pause Degenerated GC (Update Refs)\";\n-    default:\n-      ShouldNotReachHere();\n-      return \"ERROR\";\n-  }\n+void ShenandoahDegenGC::degen_event_message(ShenandoahDegenPoint point, char* buf, size_t len) const {\n+  jio_snprintf(buf, len, \"Pause Degenerated %s GC (%s)\", _generation->name(), ShenandoahGC::degen_point_to_string(point));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahDegeneratedGC.cpp","additions":15,"deletions":22,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-  const char* degen_event_message(ShenandoahDegenPoint point) const;\n+  void degen_event_message(ShenandoahDegenPoint point, char* buf, size_t len) const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahDegeneratedGC.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,0 +42,2 @@\n+    case _degenerated_roots:\n+      return \"Roots\";\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGC.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+    _degenerated_roots,\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGC.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -164,0 +164,1 @@\n+  \/\/ Must be sure that marking is complete before we swap remembered set.\n@@ -312,1 +313,0 @@\n-  ShenandoahConcurrentPhase gc_phase(\"Concurrent remembered set scanning\", ShenandoahPhaseTimings::init_scan_rset);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1106,1 +1106,22 @@\n-  return _free_set->allocate(req, in_new_region);\n+  HeapWord* result = _free_set->allocate(req, in_new_region);\n+  if (result != NULL && req.affiliation() == ShenandoahRegionAffiliation::OLD_GENERATION) {\n+    \/\/ Register the newly allocated object while we're holding the global lock since there's no synchronization\n+    \/\/ built in to the implementation of register_object().  There are potential races when multiple independent\n+    \/\/ threads are allocating objects, some of which might span the same card region.  For example, consider\n+    \/\/ a card table's memory region within which three objects are being allocated by three different threads:\n+    \/\/\n+    \/\/ objects being \"concurrently\" allocated:\n+    \/\/    [-----a------][-----b-----][--------------c------------------]\n+    \/\/            [---- card table memory range --------------]\n+    \/\/\n+    \/\/ Before any objects are allocated, this card's memory range holds no objects.  Note that:\n+    \/\/   allocation of object a wants to set the has-object, first-start, and last-start attributes of the preceding card region.\n+    \/\/   allocation of object b wants to set the has-object, first-start, and last-start attributes of this card region.\n+    \/\/   allocation of object c also wants to set the has-object, first-start, and last-start attributes of this card region.\n+    \/\/\n+    \/\/ The thread allocating b and the thread allocating c can \"race\" in various ways, resulting in confusion, such as last-start\n+    \/\/ representing object b while first-start represents object c.  This is why we need to require all register_object()\n+    \/\/ invocations to be \"mutually exclusive\" with respect to each card's memory range.\n+    ShenandoahHeap::heap()->card_scan()->register_object(result);\n+  }\n+  return result;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -464,3 +464,1 @@\n-      if (mode()->is_generational() && target_gen == OLD_GENERATION) {\n-        card_scan()->register_object(copy);\n-      }\n+      \/\/ For non-LAB allocations, the object has already been registered\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.inline.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -117,0 +117,5 @@\n+    if (_generation->generation_mode() == YOUNG) {\n+      \/\/ But only scan the remembered set for young generation.\n+      _generation->scan_remembered_set();\n+    }\n+\n@@ -124,1 +129,1 @@\n-  heap->global_generation()->set_mark_complete();\n+  _generation->set_mark_complete();\n@@ -141,1 +146,0 @@\n-      _generation->scan_remembered_set();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahSTWMark.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"}]}