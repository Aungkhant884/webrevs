{"files":[{"patch":"@@ -392,0 +392,3 @@\n+  size_t mixed_evac_live = old_candidates * region_size_bytes - (candidates_garbage + unfragmented);\n+  set_unprocessed_old_collection_candidates_live_memory(mixed_evac_live);\n+\n@@ -398,5 +401,2 @@\n-  size_t mixed_evac_live = old_candidates * region_size_bytes - (candidates_garbage + unfragmented);\n-  set_unprocessed_old_collection_candidates_live_memory(mixed_evac_live);\n-  if (unprocessed_old_collection_candidates() == 0) {\n-    _old_generation->transition_to(ShenandoahOldGeneration::IDLE);\n-  } else {\n+\n+  if (unprocessed_old_collection_candidates() > 0) {\n@@ -404,0 +404,4 @@\n+  } else if (has_coalesce_and_fill_candidates()) {\n+    _old_generation->transition_to(ShenandoahOldGeneration::WAITING_FOR_FILL);\n+  } else {\n+    _old_generation->transition_to(ShenandoahOldGeneration::IDLE);\n@@ -450,4 +454,0 @@\n-uint ShenandoahOldHeuristics::last_old_region_index() const {\n-  return _last_old_region;\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -139,5 +139,1 @@\n-  \/\/ How many old-collection regions were identified at the end of the most recent old-gen mark to require their\n-  \/\/ unmarked objects to be coalesced and filled?\n-  uint last_old_region_index() const;\n-\n-  \/\/ Fill in buffer with all of the old-collection regions that were identified at the end of the most recent old-gen\n+  \/\/ Fill in buffer with all the old-collection regions that were identified at the end of the most recent old-gen\n@@ -149,0 +145,6 @@\n+  \/\/ True if there are old regions that need to be filled.\n+  bool has_coalesce_and_fill_candidates() const { return coalesce_and_fill_candidates_count() > 0; }\n+\n+  \/\/ Return the number of old regions that need to be filled.\n+  size_t coalesce_and_fill_candidates_count() const { return _last_old_region - _next_old_collection_candidate; }\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.hpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -191,7 +191,0 @@\n-  \/\/ Global marking has completed and we may have collected regions with no live objects.\n-  \/\/ We need to fill in any unmarked objects in the old generation so that subsequent\n-  \/\/ remembered set scans will not walk pointers into reclaimed memory.\n-  if (heap->mode()->is_generational() && _generation->is_global()) {\n-    entry_global_coalesce_and_fill();\n-  }\n-\n@@ -599,15 +592,0 @@\n-void ShenandoahConcurrentGC::entry_global_coalesce_and_fill() {\n-  ShenandoahHeap* const heap = ShenandoahHeap::heap();\n-\n-  const char* msg = \"Coalescing and filling old regions in global collect\";\n-  ShenandoahConcurrentPhase gc_phase(msg, ShenandoahPhaseTimings::coalesce_and_fill);\n-\n-  TraceCollectorStats tcs(heap->monitoring_support()->concurrent_collection_counters());\n-  EventMark em(\"%s\", msg);\n-  ShenandoahWorkerScope scope(heap->workers(),\n-                              ShenandoahWorkerPolicy::calc_workers_for_conc_marking(),\n-                              \"concurrent coalesce and fill\");\n-\n-  op_global_coalesce_and_fill();\n-}\n-\n@@ -818,1 +796,1 @@\n-          \/\/ under the same condition (established in preprare_concurrent_roots) after strong\n+          \/\/ under the same condition (established in prepare_concurrent_roots) after strong\n@@ -1320,4 +1298,0 @@\n-void ShenandoahConcurrentGC::op_global_coalesce_and_fill() {\n-  ShenandoahHeap::heap()->coalesce_and_fill_old_regions();\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":1,"deletions":27,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -106,1 +106,0 @@\n-  void entry_global_coalesce_and_fill();\n@@ -126,1 +125,1 @@\n-  void op_global_coalesce_and_fill();\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -99,7 +99,1 @@\n-    if (_generation->is_global()) {\n-      \/\/ We can only get to a degenerated global cycle _after_ a concurrent global cycle\n-      \/\/ has been cancelled. In which case, we expect the concurrent global cycle to have\n-      \/\/ cancelled the old gc already.\n-      assert(!heap->is_old_gc_active(), \"Old GC should not be active during global cycle\");\n-    }\n-\n+    ShenandoahOldGeneration* old_generation = heap->old_generation();\n@@ -108,1 +102,11 @@\n-      assert(heap->old_generation()->task_queues()->is_empty(), \"Old gen task queues should be empty\");\n+      assert(old_generation->task_queues()->is_empty(), \"Old gen task queues should be empty\");\n+    }\n+\n+    if (_generation->is_global()) {\n+      \/\/ If we are in a global cycle, the old generation should not be marking. It is, however,\n+      \/\/ allowed to be holding regions for evacuation or coalescing.\n+      ShenandoahOldGeneration::State state = old_generation->state();\n+      assert(state == ShenandoahOldGeneration::IDLE\n+             || state == ShenandoahOldGeneration::WAITING_FOR_EVAC\n+             || state == ShenandoahOldGeneration::WAITING_FOR_FILL,\n+             \"Old generation cannot be in state: %s\", old_generation->state_name());\n@@ -195,5 +199,0 @@\n-\n-      if (heap->mode()->is_generational() && _generation->is_global()) {\n-        op_global_coalesce_and_fill();\n-      }\n-\n@@ -302,1 +301,1 @@\n-            ((ShenandoahOldHeuristics *) heap->old_generation()->heuristics())->trigger_cannot_expand();\n+            heap->old_heuristics()->trigger_cannot_expand();\n@@ -426,4 +425,0 @@\n-void ShenandoahDegenGC::op_global_coalesce_and_fill() {\n-  ShenandoahHeap::heap()->coalesce_and_fill_old_regions();\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahDegeneratedGC.cpp","additions":13,"deletions":18,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-  void op_global_coalesce_and_fill();\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahDegeneratedGC.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -672,0 +672,17 @@\n+\n+      if (is_global()) {\n+        \/\/ We have just chosen a collection set for a global cycle. The mark bitmap covering old regions is complete, so\n+        \/\/ the remembered set scan can use that to avoid walking into garbage. When the next old mark begins, we will\n+        \/\/ use the mark bitmap to make the old regions parseable by coalescing and filling any unmarked objects. Thus,\n+        \/\/ we prepare for old collections by remembering which regions are old at this time. Note that any objects\n+        \/\/ promoted into old regions will be above TAMS, and so will be considered marked. However, free regions that\n+        \/\/ become old after this point will not be covered correctly by the mark bitmap, so we must be careful not to\n+        \/\/ coalesce those regions. Only the old regions which are not part of the collection set at this point are\n+        \/\/ eligible for coalescing. As implemented now, this has the side effect of possibly initiating mixed-evacuations\n+        \/\/ after a global cycle for old regions that were not included in this collection set.\n+        assert(heap->old_generation()->is_mark_complete(), \"Expected old generation mark to be complete after global cycle.\");\n+        heap->old_heuristics()->prepare_for_old_collections();\n+        log_info(gc)(\"After choosing global collection set, mixed candidates: \" UINT32_FORMAT \", coalescing candidates: \" SIZE_FORMAT,\n+                     heap->old_heuristics()->unprocessed_old_collection_candidates(),\n+                     heap->old_heuristics()->coalesce_and_fill_candidates_count());\n+      }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -189,2 +189,2 @@\n-  void set_mark_complete();\n-  void set_mark_incomplete();\n+  virtual void set_mark_complete();\n+  virtual void set_mark_incomplete();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -111,0 +111,14 @@\n+\n+void ShenandoahGlobalGeneration::set_mark_complete() {\n+  ShenandoahGeneration::set_mark_complete();\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  heap->young_generation()->set_mark_complete();\n+  heap->old_generation()->set_mark_complete();\n+}\n+\n+void ShenandoahGlobalGeneration::set_mark_incomplete() {\n+  ShenandoahGeneration::set_mark_incomplete();\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  heap->young_generation()->set_mark_incomplete();\n+  heap->old_generation()->set_mark_incomplete();\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGlobalGeneration.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-  virtual const char* name() const override;\n+  const char* name() const override;\n@@ -41,6 +41,6 @@\n-  virtual size_t max_capacity() const override;\n-  virtual size_t soft_max_capacity() const override;\n-  virtual size_t used_regions() const override;\n-  virtual size_t used_regions_size() const override;\n-  virtual size_t available() const override;\n-  virtual size_t soft_available() const override;\n+  size_t max_capacity() const override;\n+  size_t soft_max_capacity() const override;\n+  size_t used_regions() const override;\n+  size_t used_regions_size() const override;\n+  size_t available() const override;\n+  size_t soft_available() const override;\n@@ -48,1 +48,1 @@\n-  virtual void set_concurrent_mark_in_progress(bool in_progress) override;\n+  void set_concurrent_mark_in_progress(bool in_progress) override;\n@@ -63,0 +63,4 @@\n+  void set_mark_complete() override;\n+\n+  void set_mark_incomplete() override;\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGlobalGeneration.hpp","additions":12,"deletions":8,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1173,23 +1173,0 @@\n-void ShenandoahHeap::coalesce_and_fill_old_regions() {\n-  class ShenandoahGlobalCoalesceAndFill : public ShenandoahHeapRegionClosure {\n-   public:\n-    virtual void heap_region_do(ShenandoahHeapRegion* region) override {\n-      \/\/ old region is not in the collection set and was not immediately trashed\n-      if (region->is_old() && region->is_active() && !region->is_humongous()) {\n-        \/\/ Reset the coalesce and fill boundary because this is a global collect\n-        \/\/ and cannot be preempted by young collects. We want to be sure the entire\n-        \/\/ region is coalesced here and does not resume from a previously interrupted\n-        \/\/ or completed coalescing.\n-        region->begin_preemptible_coalesce_and_fill();\n-        region->oop_fill_and_coalesce();\n-      }\n-    }\n-\n-    virtual bool is_thread_safe() override {\n-      return true;\n-    }\n-  };\n-  ShenandoahGlobalCoalesceAndFill coalesce;\n-  parallel_heap_region_iterate(&coalesce);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":0,"deletions":23,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -857,1 +857,1 @@\n-  void coalesce_and_fill_old_regions();\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -383,1 +383,4 @@\n-\/\/ global and full collections, both of which cancel any old generation activity.\n+\/\/ cancellation of old collections by global or full collections. However, it does\n+\/\/ depict a transition from IDLE to WAITING_FOR_FILL, which is allowed after a global\n+\/\/ cycle ends. Also note that a global collection will cause any evacuation or fill\n+\/\/ candidates to be abandoned, returning the old generation to the idle state.\n@@ -385,38 +388,38 @@\n-\/\/                              +-----------------+\n-\/\/               +------------> |      IDLE       |\n-\/\/               |   +--------> |                 |\n-\/\/               |   |          +-----------------+\n-\/\/               |   |            |\n-\/\/               |   |            | Begin Old Mark\n-\/\/               |   |            v\n-\/\/               |   |          +-----------------+     +--------------------+\n-\/\/               |   |          |     FILLING     | <-> |      YOUNG GC      |\n-\/\/               |   |    +---> |                 |     | (RSet Uses Bitmap) |\n-\/\/               |   |    |     +-----------------+     +--------------------+\n-\/\/               |   |    |       |\n-\/\/               |   |    |       | Reset Bitmap\n-\/\/               |   |    |       v\n-\/\/               |   |    |     +-----------------+\n-\/\/               |   |    |     |    BOOTSTRAP    |\n-\/\/               |   |    |     |                 |\n-\/\/               |   |    |     +-----------------+\n-\/\/               |   |    |       |\n-\/\/               |   |    |       | Continue Marking\n-\/\/               |   |    |       v\n-\/\/               |   |    |     +-----------------+     +----------------------+\n-\/\/               |   |    |     |    MARKING      | <-> |       YOUNG GC       |\n-\/\/               |   +----|-----|                 |     | (RSet Parses Region) |\n-\/\/               |        |     +-----------------+     +----------------------+\n-\/\/               |        |       |\n-\/\/               |        |       | Has Candidates\n-\/\/               |        |       v\n-\/\/               |        |     +-----------------+\n-\/\/               |        |     |    WAITING FOR  |\n-\/\/               +--------|---- |    EVACUATIONS  |\n-\/\/                        |     +-----------------+\n-\/\/                        |       |\n-\/\/                        |       | All Candidates are Pinned\n-\/\/                        |       v\n-\/\/                        |     +-----------------+\n-\/\/                        |     |    WAITING FOR  |\n-\/\/                        +-----|    FILLING      |\n+\/\/           +----------------> +-----------------+\n+\/\/           |   +------------> |      IDLE       |\n+\/\/           |   |   +--------> |                 |\n+\/\/           |   |   |          +-----------------+\n+\/\/           |   |   |            |\n+\/\/           |   |   |            | Begin Old Mark\n+\/\/           |   |   |            v\n+\/\/           |   |   |          +-----------------+     +--------------------+\n+\/\/           |   |   |          |     FILLING     | <-> |      YOUNG GC      |\n+\/\/           |   |   |    +---> |                 |     | (RSet Uses Bitmap) |\n+\/\/           |   |   |    |     +-----------------+     +--------------------+\n+\/\/           |   |   |    |       |\n+\/\/           |   |   |    |       | Reset Bitmap\n+\/\/           |   |   |    |       v\n+\/\/           |   |   |    |     +-----------------+\n+\/\/           |   |   |    |     |    BOOTSTRAP    |\n+\/\/           |   |   |    |     |                 |\n+\/\/           |   |   |    |     +-----------------+\n+\/\/           |   |   |    |       |\n+\/\/           |   |   |    |       | Continue Marking\n+\/\/           |   |   |    |       v\n+\/\/           |   |   |    |     +-----------------+     +----------------------+\n+\/\/           |   |   |    |     |    MARKING      | <-> |       YOUNG GC       |\n+\/\/           |   |   +----|-----|                 |     | (RSet Parses Region) |\n+\/\/           |   |        |     +-----------------+     +----------------------+\n+\/\/           |   |        |       |\n+\/\/           |   |        |       | Has Candidates\n+\/\/           |   |        |       v\n+\/\/           |   |        |     +-----------------+\n+\/\/           |   |        |     |    WAITING FOR  |\n+\/\/           |   +--------|---> |    EVACUATIONS  |\n+\/\/           |            |     +-----------------+\n+\/\/           |            |       |\n+\/\/           |            |       | All Candidates are Pinned\n+\/\/           |            |       v\n+\/\/           |            |     +-----------------+\n+\/\/           |            +---- |    WAITING FOR  |\n+\/\/           +----------------> |    FILLING      |\n@@ -431,2 +434,1 @@\n-      assert(!heap->mode()->is_generational() ||\n-             (_old_heuristics->unprocessed_old_collection_candidates() == 0), \"Cannot become idle with collection candidates\");\n+      assert(_old_heuristics->unprocessed_old_collection_candidates() == 0, \"Cannot become idle with collection candidates\");\n@@ -451,1 +453,1 @@\n-      assert(_state == MARKING, \"Cannot have old collection candidates without first marking, state is '%s'\", state_name(_state));\n+      assert(_state == IDLE || _state == MARKING, \"Cannot have old collection candidates without first marking, state is '%s'\", state_name(_state));\n@@ -455,2 +457,2 @@\n-      assert(_state == MARKING || _state == WAITING_FOR_EVAC, \"Cannot begin filling without first marking or evacuating, state is '%s'\", state_name(_state));\n-      assert(_old_heuristics->unprocessed_old_collection_candidates() > 0, \"Cannot wait for fill without something to fill.\");\n+      assert(_state == IDLE || _state == MARKING || _state == WAITING_FOR_EVAC, \"Cannot begin filling without first marking or evacuating, state is '%s'\", state_name(_state));\n+      assert(_old_heuristics->has_coalesce_and_fill_candidates(), \"Cannot wait for fill without something to fill.\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.cpp","additions":46,"deletions":44,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -120,0 +120,4 @@\n+  const char* state_name() const {\n+    return state_name(_state);\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-\/\/ % make exploded-test TEST=\"gtest:ShenandoahOld*\" CONF=release TEST_OPTS=\"JAVA_OPTIONS=-XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\"\n+\/\/ % make exploded-test TEST=\"gtest:ShenandoahOld*\" CONF=release TEST_OPTS=\"JAVA_OPTIONS=-XX:+UseShenandoahGC -XX:+UnlockExperimentalVMOptions -XX:ShenandoahGCMode=generational\"\n@@ -100,0 +100,1 @@\n+    region->set_affiliation(OLD_GENERATION);\n@@ -101,2 +102,3 @@\n-    region->increase_live_data_alloc_words(1);\n-    region->set_top(region->bottom() + garbage_bytes \/ HeapWordSize);\n+    size_t live_bytes = ShenandoahHeapRegion::region_size_bytes() - garbage_bytes;\n+    region->increase_live_data_alloc_words(live_bytes \/ HeapWordSize);\n+    region->set_top(region->end());\n@@ -111,1 +113,1 @@\n-      garbage_total += make_garbage_above_threshold(region_idx++);\n+      garbage_total += make_garbage_above_collection_threshold(region_idx++);\n@@ -130,1 +132,1 @@\n-  size_t make_garbage_below_threshold(size_t region_idx) {\n+  size_t make_garbage_below_collection_threshold(size_t region_idx) {\n@@ -134,1 +136,1 @@\n-  size_t make_garbage_above_threshold(size_t region_idx) {\n+  size_t make_garbage_above_collection_threshold(size_t region_idx) {\n@@ -167,1 +169,1 @@\n-  EXPECT_EQ(0U, _heuristics->last_old_region_index());\n+  EXPECT_EQ(0U, _heuristics->coalesce_and_fill_candidates_count());\n@@ -177,1 +179,1 @@\n-  make_garbage_below_threshold(10);\n+  make_garbage_below_collection_threshold(10);\n@@ -179,1 +181,1 @@\n-  EXPECT_EQ(1U, _heuristics->last_old_region_index());\n+  EXPECT_EQ(1U, _heuristics->coalesce_and_fill_candidates_count());\n@@ -187,1 +189,1 @@\n-  make_garbage_above_threshold(10);\n+  make_garbage_above_collection_threshold(10);\n@@ -189,1 +191,1 @@\n-  EXPECT_EQ(1U, _heuristics->last_old_region_index());\n+  EXPECT_EQ(1U, _heuristics->coalesce_and_fill_candidates_count());\n@@ -197,1 +199,1 @@\n-  size_t garbage = make_garbage_above_threshold(10);\n+  size_t garbage = make_garbage_above_collection_threshold(10);\n@@ -209,2 +211,2 @@\n-  size_t g1 = make_garbage_above_threshold(100);\n-  size_t g2 = make_garbage_above_threshold(101);\n+  size_t g1 = make_garbage_above_collection_threshold(100);\n+  size_t g2 = make_garbage_above_collection_threshold(101);\n@@ -234,3 +236,3 @@\n-  size_t g1 = make_garbage_above_threshold(0);\n-  size_t g2 = make_garbage_above_threshold(1);\n-  size_t g3 = make_garbage_above_threshold(2);\n+  size_t g1 = make_garbage_above_collection_threshold(0);\n+  size_t g2 = make_garbage_above_collection_threshold(1);\n+  size_t g3 = make_garbage_above_collection_threshold(2);\n@@ -270,3 +272,3 @@\n-  size_t g1 = make_garbage_above_threshold(0);\n-  size_t g2 = make_garbage_above_threshold(1);\n-  size_t g3 = make_garbage_above_threshold(2);\n+  size_t g1 = make_garbage_above_collection_threshold(0);\n+  size_t g2 = make_garbage_above_collection_threshold(1);\n+  size_t g3 = make_garbage_above_collection_threshold(2);\n@@ -293,3 +295,3 @@\n-  size_t g1 = make_garbage_above_threshold(0);\n-  size_t g2 = make_garbage_above_threshold(1);\n-  size_t g3 = make_garbage_above_threshold(2);\n+  size_t g1 = make_garbage_above_collection_threshold(0);\n+  size_t g2 = make_garbage_above_collection_threshold(1);\n+  size_t g3 = make_garbage_above_collection_threshold(2);\n@@ -318,3 +320,3 @@\n-  size_t g1 = make_garbage_above_threshold(0);\n-  size_t g2 = make_garbage_above_threshold(1);\n-  size_t g3 = make_garbage_above_threshold(2);\n+  size_t g1 = make_garbage_above_collection_threshold(0);\n+  size_t g2 = make_garbage_above_collection_threshold(1);\n+  size_t g3 = make_garbage_above_collection_threshold(2);\n@@ -344,3 +346,3 @@\n-  size_t g1 = make_garbage_above_threshold(0);\n-  size_t g2 = make_garbage_above_threshold(1);\n-  size_t g3 = make_garbage_above_threshold(2);\n+  size_t g1 = make_garbage_above_collection_threshold(0);\n+  size_t g2 = make_garbage_above_collection_threshold(1);\n+  size_t g3 = make_garbage_above_collection_threshold(2);\n","filename":"test\/hotspot\/gtest\/gc\/shenandoah\/test_shenandoahOldHeuristic.cpp","additions":31,"deletions":29,"binary":false,"changes":60,"status":"modified"}]}