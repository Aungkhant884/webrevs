{"files":[{"patch":"@@ -191,7 +191,0 @@\n-  \/\/ Global marking has completed and we may have collected regions with no live objects.\n-  \/\/ We need to fill in any unmarked objects in the old generation so that subsequent\n-  \/\/ remembered set scans will not walk pointers into reclaimed memory.\n-  if (heap->mode()->is_generational() && _generation->is_global()) {\n-    entry_global_coalesce_and_fill();\n-  }\n-\n@@ -599,15 +592,0 @@\n-void ShenandoahConcurrentGC::entry_global_coalesce_and_fill() {\n-  ShenandoahHeap* const heap = ShenandoahHeap::heap();\n-\n-  const char* msg = \"Coalescing and filling old regions in global collect\";\n-  ShenandoahConcurrentPhase gc_phase(msg, ShenandoahPhaseTimings::coalesce_and_fill);\n-\n-  TraceCollectorStats tcs(heap->monitoring_support()->concurrent_collection_counters());\n-  EventMark em(\"%s\", msg);\n-  ShenandoahWorkerScope scope(heap->workers(),\n-                              ShenandoahWorkerPolicy::calc_workers_for_conc_marking(),\n-                              \"concurrent coalesce and fill\");\n-\n-  op_global_coalesce_and_fill();\n-}\n-\n@@ -1320,4 +1298,0 @@\n-void ShenandoahConcurrentGC::op_global_coalesce_and_fill() {\n-  ShenandoahHeap::heap()->coalesce_and_fill_old_regions();\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":0,"deletions":26,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -106,1 +106,0 @@\n-  void entry_global_coalesce_and_fill();\n@@ -126,1 +125,1 @@\n-  void op_global_coalesce_and_fill();\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -195,5 +195,0 @@\n-\n-      if (heap->mode()->is_generational() && _generation->is_global()) {\n-        op_global_coalesce_and_fill();\n-      }\n-\n@@ -426,4 +421,0 @@\n-void ShenandoahDegenGC::op_global_coalesce_and_fill() {\n-  ShenandoahHeap::heap()->coalesce_and_fill_old_regions();\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahDegeneratedGC.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-  void op_global_coalesce_and_fill();\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahDegeneratedGC.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -189,2 +189,2 @@\n-  void set_mark_complete();\n-  void set_mark_incomplete();\n+  virtual void set_mark_complete();\n+  virtual void set_mark_incomplete();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -111,0 +111,14 @@\n+\n+void ShenandoahGlobalGeneration::set_mark_complete() {\n+  ShenandoahGeneration::set_mark_complete();\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  heap->young_generation()->set_mark_complete();\n+  heap->old_generation()->set_mark_complete();\n+}\n+\n+void ShenandoahGlobalGeneration::set_mark_incomplete() {\n+  ShenandoahGeneration::set_mark_incomplete();\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  heap->young_generation()->set_mark_incomplete();\n+  heap->old_generation()->set_mark_incomplete();\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGlobalGeneration.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-  virtual const char* name() const override;\n+  const char* name() const override;\n@@ -41,6 +41,6 @@\n-  virtual size_t max_capacity() const override;\n-  virtual size_t soft_max_capacity() const override;\n-  virtual size_t used_regions() const override;\n-  virtual size_t used_regions_size() const override;\n-  virtual size_t available() const override;\n-  virtual size_t soft_available() const override;\n+  size_t max_capacity() const override;\n+  size_t soft_max_capacity() const override;\n+  size_t used_regions() const override;\n+  size_t used_regions_size() const override;\n+  size_t available() const override;\n+  size_t soft_available() const override;\n@@ -48,1 +48,1 @@\n-  virtual void set_concurrent_mark_in_progress(bool in_progress) override;\n+  void set_concurrent_mark_in_progress(bool in_progress) override;\n@@ -63,0 +63,4 @@\n+  void set_mark_complete() override;\n+\n+  void set_mark_incomplete() override;\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGlobalGeneration.hpp","additions":12,"deletions":8,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1164,23 +1164,0 @@\n-void ShenandoahHeap::coalesce_and_fill_old_regions() {\n-  class ShenandoahGlobalCoalesceAndFill : public ShenandoahHeapRegionClosure {\n-   public:\n-    virtual void heap_region_do(ShenandoahHeapRegion* region) override {\n-      \/\/ old region is not in the collection set and was not immediately trashed\n-      if (region->is_old() && region->is_active() && !region->is_humongous()) {\n-        \/\/ Reset the coalesce and fill boundary because this is a global collect\n-        \/\/ and cannot be preempted by young collects. We want to be sure the entire\n-        \/\/ region is coalesced here and does not resume from a previously interrupted\n-        \/\/ or completed coalescing.\n-        region->begin_preemptible_coalesce_and_fill();\n-        region->oop_fill_and_coalesce();\n-      }\n-    }\n-\n-    virtual bool is_thread_safe() override {\n-      return true;\n-    }\n-  };\n-  ShenandoahGlobalCoalesceAndFill coalesce;\n-  parallel_heap_region_iterate(&coalesce);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":0,"deletions":23,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -857,1 +857,1 @@\n-  void coalesce_and_fill_old_regions();\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}