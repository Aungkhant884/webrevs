{"files":[{"patch":"@@ -392,0 +392,3 @@\n+  size_t mixed_evac_live = old_candidates * region_size_bytes - (candidates_garbage + unfragmented);\n+  set_unprocessed_old_collection_candidates_live_memory(mixed_evac_live);\n+\n@@ -398,5 +401,2 @@\n-  size_t mixed_evac_live = old_candidates * region_size_bytes - (candidates_garbage + unfragmented);\n-  set_unprocessed_old_collection_candidates_live_memory(mixed_evac_live);\n-  if (unprocessed_old_collection_candidates() == 0) {\n-    _old_generation->transition_to(ShenandoahOldGeneration::IDLE);\n-  } else {\n+\n+  if (unprocessed_old_collection_candidates() > 0) {\n@@ -404,0 +404,4 @@\n+  } else if (has_coalesce_and_fill_candidates()) {\n+    _old_generation->transition_to(ShenandoahOldGeneration::WAITING_FOR_FILL);\n+  } else {\n+    _old_generation->transition_to(ShenandoahOldGeneration::IDLE);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.cpp","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -148,0 +148,2 @@\n+  bool has_coalesce_and_fill_candidates() const { return _last_old_region > 0; }\n+  size_t coalesce_and_fill_candidates() const { return _last_old_region; }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -191,7 +191,0 @@\n-  \/\/ Global marking has completed and we may have collected regions with no live objects.\n-  \/\/ We need to fill in any unmarked objects in the old generation so that subsequent\n-  \/\/ remembered set scans will not walk pointers into reclaimed memory.\n-  if (heap->mode()->is_generational() && _generation->is_global()) {\n-    entry_global_coalesce_and_fill();\n-  }\n-\n@@ -599,15 +592,0 @@\n-void ShenandoahConcurrentGC::entry_global_coalesce_and_fill() {\n-  ShenandoahHeap* const heap = ShenandoahHeap::heap();\n-\n-  const char* msg = \"Coalescing and filling old regions in global collect\";\n-  ShenandoahConcurrentPhase gc_phase(msg, ShenandoahPhaseTimings::coalesce_and_fill);\n-\n-  TraceCollectorStats tcs(heap->monitoring_support()->concurrent_collection_counters());\n-  EventMark em(\"%s\", msg);\n-  ShenandoahWorkerScope scope(heap->workers(),\n-                              ShenandoahWorkerPolicy::calc_workers_for_conc_marking(),\n-                              \"concurrent coalesce and fill\");\n-\n-  op_global_coalesce_and_fill();\n-}\n-\n@@ -818,1 +796,1 @@\n-          \/\/ under the same condition (established in preprare_concurrent_roots) after strong\n+          \/\/ under the same condition (established in prepare_concurrent_roots) after strong\n@@ -1320,4 +1298,0 @@\n-void ShenandoahConcurrentGC::op_global_coalesce_and_fill() {\n-  ShenandoahHeap::heap()->coalesce_and_fill_old_regions();\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":1,"deletions":27,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -106,1 +106,0 @@\n-  void entry_global_coalesce_and_fill();\n@@ -126,1 +125,1 @@\n-  void op_global_coalesce_and_fill();\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -99,7 +99,0 @@\n-    if (_generation->is_global()) {\n-      \/\/ We can only get to a degenerated global cycle _after_ a concurrent global cycle\n-      \/\/ has been cancelled. In which case, we expect the concurrent global cycle to have\n-      \/\/ cancelled the old gc already.\n-      assert(!heap->is_old_gc_active(), \"Old GC should not be active during global cycle\");\n-    }\n-\n@@ -195,5 +188,0 @@\n-\n-      if (heap->mode()->is_generational() && _generation->is_global()) {\n-        op_global_coalesce_and_fill();\n-      }\n-\n@@ -426,4 +414,0 @@\n-void ShenandoahDegenGC::op_global_coalesce_and_fill() {\n-  ShenandoahHeap::heap()->coalesce_and_fill_old_regions();\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahDegeneratedGC.cpp","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-  void op_global_coalesce_and_fill();\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahDegeneratedGC.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -672,0 +672,17 @@\n+\n+      if (is_global()) {\n+        \/\/ We have just chosen a collection set for a global cycle. The mark bitmap covering old regions is complete, so\n+        \/\/ the remembered set scan can use that to avoid walking into garbage. When the next old mark begins, we will\n+        \/\/ use the mark bitmap to make the old regions parseable by coalescing and filling any unmarked objects. Thus,\n+        \/\/ we prepare for old collections by remembering which regions are old at this time. Note that any objects\n+        \/\/ promoted into old regions will be above TAMS, and so will be considered marked. However, free regions that\n+        \/\/ become old after this point will not be covered correctly by the mark bitmap, so we must be careful not to\n+        \/\/ coalesce those regions. Only the old regions which are not part of the collection set at this point are\n+        \/\/ eligible for coalescing. As implemented now, this has the side effect of possibly initiating mixed-evacuations\n+        \/\/ after a global cycle for old regions that were not included in this collection set.\n+        assert(heap->old_generation()->is_mark_complete(), \"Expected old generation mark to be complete after global cycle.\");\n+        heap->old_heuristics()->prepare_for_old_collections();\n+        log_info(gc)(\"After choosing global collection set, mixed candidates: \" UINT32_FORMAT \", coalescing candidates: \" SIZE_FORMAT,\n+                heap->old_heuristics()->unprocessed_old_collection_candidates(),\n+                heap->old_heuristics()->coalesce_and_fill_candidates());\n+      }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -189,2 +189,2 @@\n-  void set_mark_complete();\n-  void set_mark_incomplete();\n+  virtual void set_mark_complete();\n+  virtual void set_mark_incomplete();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -111,0 +111,14 @@\n+\n+void ShenandoahGlobalGeneration::set_mark_complete() {\n+  ShenandoahGeneration::set_mark_complete();\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  heap->young_generation()->set_mark_complete();\n+  heap->old_generation()->set_mark_complete();\n+}\n+\n+void ShenandoahGlobalGeneration::set_mark_incomplete() {\n+  ShenandoahGeneration::set_mark_incomplete();\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  heap->young_generation()->set_mark_incomplete();\n+  heap->old_generation()->set_mark_incomplete();\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGlobalGeneration.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-  virtual const char* name() const override;\n+  const char* name() const override;\n@@ -41,6 +41,6 @@\n-  virtual size_t max_capacity() const override;\n-  virtual size_t soft_max_capacity() const override;\n-  virtual size_t used_regions() const override;\n-  virtual size_t used_regions_size() const override;\n-  virtual size_t available() const override;\n-  virtual size_t soft_available() const override;\n+  size_t max_capacity() const override;\n+  size_t soft_max_capacity() const override;\n+  size_t used_regions() const override;\n+  size_t used_regions_size() const override;\n+  size_t available() const override;\n+  size_t soft_available() const override;\n@@ -48,1 +48,1 @@\n-  virtual void set_concurrent_mark_in_progress(bool in_progress) override;\n+  void set_concurrent_mark_in_progress(bool in_progress) override;\n@@ -63,0 +63,4 @@\n+  void set_mark_complete() override;\n+\n+  void set_mark_incomplete() override;\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGlobalGeneration.hpp","additions":12,"deletions":8,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1173,23 +1173,0 @@\n-void ShenandoahHeap::coalesce_and_fill_old_regions() {\n-  class ShenandoahGlobalCoalesceAndFill : public ShenandoahHeapRegionClosure {\n-   public:\n-    virtual void heap_region_do(ShenandoahHeapRegion* region) override {\n-      \/\/ old region is not in the collection set and was not immediately trashed\n-      if (region->is_old() && region->is_active() && !region->is_humongous()) {\n-        \/\/ Reset the coalesce and fill boundary because this is a global collect\n-        \/\/ and cannot be preempted by young collects. We want to be sure the entire\n-        \/\/ region is coalesced here and does not resume from a previously interrupted\n-        \/\/ or completed coalescing.\n-        region->begin_preemptible_coalesce_and_fill();\n-        region->oop_fill_and_coalesce();\n-      }\n-    }\n-\n-    virtual bool is_thread_safe() override {\n-      return true;\n-    }\n-  };\n-  ShenandoahGlobalCoalesceAndFill coalesce;\n-  parallel_heap_region_iterate(&coalesce);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":0,"deletions":23,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -857,1 +857,1 @@\n-  void coalesce_and_fill_old_regions();\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -383,1 +383,3 @@\n-\/\/ global and full collections, both of which cancel any old generation activity.\n+\/\/ cancellation of old collections by global or full collections. However, it does\n+\/\/ depict a transition from IDLE to WAITING_FOR_FILL, which is allowed after a global\n+\/\/ cycle ends.\n@@ -385,38 +387,38 @@\n-\/\/                              +-----------------+\n-\/\/               +------------> |      IDLE       |\n-\/\/               |   +--------> |                 |\n-\/\/               |   |          +-----------------+\n-\/\/               |   |            |\n-\/\/               |   |            | Begin Old Mark\n-\/\/               |   |            v\n-\/\/               |   |          +-----------------+     +--------------------+\n-\/\/               |   |          |     FILLING     | <-> |      YOUNG GC      |\n-\/\/               |   |    +---> |                 |     | (RSet Uses Bitmap) |\n-\/\/               |   |    |     +-----------------+     +--------------------+\n-\/\/               |   |    |       |\n-\/\/               |   |    |       | Reset Bitmap\n-\/\/               |   |    |       v\n-\/\/               |   |    |     +-----------------+\n-\/\/               |   |    |     |    BOOTSTRAP    |\n-\/\/               |   |    |     |                 |\n-\/\/               |   |    |     +-----------------+\n-\/\/               |   |    |       |\n-\/\/               |   |    |       | Continue Marking\n-\/\/               |   |    |       v\n-\/\/               |   |    |     +-----------------+     +----------------------+\n-\/\/               |   |    |     |    MARKING      | <-> |       YOUNG GC       |\n-\/\/               |   +----|-----|                 |     | (RSet Parses Region) |\n-\/\/               |        |     +-----------------+     +----------------------+\n-\/\/               |        |       |\n-\/\/               |        |       | Has Candidates\n-\/\/               |        |       v\n-\/\/               |        |     +-----------------+\n-\/\/               |        |     |    WAITING FOR  |\n-\/\/               +--------|---- |    EVACUATIONS  |\n-\/\/                        |     +-----------------+\n-\/\/                        |       |\n-\/\/                        |       | All Candidates are Pinned\n-\/\/                        |       v\n-\/\/                        |     +-----------------+\n-\/\/                        |     |    WAITING FOR  |\n-\/\/                        +-----|    FILLING      |\n+\/\/           +----------------- +-----------------+\n+\/\/           |   +------------> |      IDLE       |\n+\/\/           |   |   +--------> |                 |\n+\/\/           |   |   |          +-----------------+\n+\/\/           |   |   |            |\n+\/\/           |   |   |            | Begin Old Mark\n+\/\/           |   |   |            v\n+\/\/           |   |   |          +-----------------+     +--------------------+\n+\/\/           |   |   |          |     FILLING     | <-> |      YOUNG GC      |\n+\/\/           |   |   |    +---> |                 |     | (RSet Uses Bitmap) |\n+\/\/           |   |   |    |     +-----------------+     +--------------------+\n+\/\/           |   |   |    |       |\n+\/\/           |   |   |    |       | Reset Bitmap\n+\/\/           |   |   |    |       v\n+\/\/           |   |   |    |     +-----------------+\n+\/\/           |   |   |    |     |    BOOTSTRAP    |\n+\/\/           |   |   |    |     |                 |\n+\/\/           |   |   |    |     +-----------------+\n+\/\/           |   |   |    |       |\n+\/\/           |   |   |    |       | Continue Marking\n+\/\/           |   |   |    |       v\n+\/\/           |   |   |    |     +-----------------+     +----------------------+\n+\/\/           |   |   |    |     |    MARKING      | <-> |       YOUNG GC       |\n+\/\/           |   |   +----|-----|                 |     | (RSet Parses Region) |\n+\/\/           |   |        |     +-----------------+     +----------------------+\n+\/\/           |   |        |       |\n+\/\/           |   |        |       | Has Candidates\n+\/\/           |   |        |       v\n+\/\/           |   |        |     +-----------------+\n+\/\/           |   |        |     |    WAITING FOR  |\n+\/\/           |   +--------|---> |    EVACUATIONS  |\n+\/\/           |            |     +-----------------+\n+\/\/           |            |       |\n+\/\/           |            |       | All Candidates are Pinned\n+\/\/           |            |       v\n+\/\/           |            |     +-----------------+\n+\/\/           |            +---- |    WAITING FOR  |\n+\/\/           +----------------> |    FILLING      |\n@@ -431,2 +433,1 @@\n-      assert(!heap->mode()->is_generational() ||\n-             (_old_heuristics->unprocessed_old_collection_candidates() == 0), \"Cannot become idle with collection candidates\");\n+      assert(_old_heuristics->unprocessed_old_collection_candidates() == 0, \"Cannot become idle with collection candidates\");\n@@ -451,1 +452,1 @@\n-      assert(_state == MARKING, \"Cannot have old collection candidates without first marking, state is '%s'\", state_name(_state));\n+      assert(_state == IDLE || _state == MARKING, \"Cannot have old collection candidates without first marking, state is '%s'\", state_name(_state));\n@@ -455,2 +456,2 @@\n-      assert(_state == MARKING || _state == WAITING_FOR_EVAC, \"Cannot begin filling without first marking or evacuating, state is '%s'\", state_name(_state));\n-      assert(_old_heuristics->unprocessed_old_collection_candidates() > 0, \"Cannot wait for fill without something to fill.\");\n+      assert(_state == IDLE || _state == MARKING || _state == WAITING_FOR_EVAC, \"Cannot begin filling without first marking or evacuating, state is '%s'\", state_name(_state));\n+      assert(_old_heuristics->has_coalesce_and_fill_candidates(), \"Cannot wait for fill without something to fill.\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.cpp","additions":45,"deletions":44,"binary":false,"changes":89,"status":"modified"}]}