{"files":[{"patch":"@@ -170,0 +170,2 @@\n+#define shenandoah_assert_control_or_vm_thread() \\\n+                    assert(Thread::current()->is_VM_thread() || Thread::current() == ShenandoahHeap::heap()->control_thread(), \"Expected control thread or vm thread\")\n@@ -224,0 +226,1 @@\n+#define shenandoah_assert_control_or_vm_thread()\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAsserts.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -994,5 +994,1 @@\n-  #ifdef ASSERT\n-  if (generation_mode() == YOUNG) {\n-    assert(_max_capacity + increment <= ShenandoahHeap::heap()->generation_sizer()->max_young_size(), \"Cannot increase young generation capacity beyond maximum.\");\n-  }\n-  #endif\n+  assert(_max_capacity + increment <= ShenandoahHeap::heap()->max_size_for(this), \"Cannot increase generation capacity beyond maximum.\");\n@@ -1005,5 +1001,1 @@\n-  #ifdef ASSERT\n-  if (generation_mode() == YOUNG) {\n-    assert(_max_capacity - decrement >= ShenandoahHeap::heap()->generation_sizer()->min_young_size(), \"Cannot decrease young generation capacity beyond minimum.\");\n-  }\n-  #endif\n+  assert(_max_capacity - decrement >= ShenandoahHeap::heap()->min_size_for(this), \"Cannot decrease generation capacity beyond minimum.\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -450,0 +450,22 @@\n+size_t ShenandoahHeap::max_size_for(ShenandoahGeneration* generation) const {\n+  switch (generation->generation_mode()) {\n+    case YOUNG:  return _generation_sizer.max_young_size();\n+    case OLD:    return max_capacity() - _generation_sizer.min_young_size();\n+    case GLOBAL: return max_capacity();\n+    default:\n+      ShouldNotReachHere();\n+      return 0;\n+  }\n+}\n+\n+size_t ShenandoahHeap::min_size_for(ShenandoahGeneration* generation) const {\n+  switch (generation->generation_mode()) {\n+    case YOUNG:  return _generation_sizer.min_young_size();\n+    case OLD:    return max_capacity() - _generation_sizer.max_young_size();\n+    case GLOBAL: return min_capacity();\n+    default:\n+      ShouldNotReachHere();\n+      return 0;\n+  }\n+}\n+\n@@ -451,0 +473,4 @@\n+  \/\/ Max capacity is the maximum _allowed_ capacity. That is, the maximum allowed capacity\n+  \/\/ for old would be total heap - minimum capacity of young. This means the sum of the maximum\n+  \/\/ allowed for old and young could exceed the total heap size. It remains the case that the\n+  \/\/ _actual_ capacity of young + old = total.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -541,1 +541,0 @@\n-  ShenandoahControlThread*   control_thread()          { return _control_thread;    }\n@@ -545,0 +544,1 @@\n+  ShenandoahControlThread*   control_thread()          { return _control_thread;    }\n@@ -551,0 +551,3 @@\n+  size_t max_size_for(ShenandoahGeneration* generation) const;\n+  size_t min_size_for(ShenandoahGeneration* generation) const;\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"gc\/shenandoah\/shenandoahAsserts.hpp\"\n@@ -85,1 +86,1 @@\n-  \/\/ This is only called by the control thread or the VM thread.\n+  shenandoah_assert_control_or_vm_thread();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMmuTracker.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}