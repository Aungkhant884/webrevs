{"files":[{"patch":"@@ -320,4 +320,0 @@\n-  \/\/ Make sure the code below treats available without the soft tail.\n-  size_t soft_tail = max_capacity - capacity;\n-  available = (available > soft_tail) ? (available - soft_tail) : 0;\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-  SHENANDOAH_ERGO_OVERRIDE_DEFAULT(NewRatio, 1);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/mode\/shenandoahGenerationalMode.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -994,0 +994,5 @@\n+  #ifdef ASSERT\n+  if (generation_mode() == YOUNG) {\n+    assert(_max_capacity + increment <= ShenandoahHeap::heap()->generation_sizer()->max_young_size(), \"Cannot increase young generation capacity beyond maximum.\");\n+  }\n+  #endif\n@@ -1000,0 +1005,5 @@\n+  #ifdef ASSERT\n+  if (generation_mode() == YOUNG) {\n+    assert(_max_capacity - decrement >= ShenandoahHeap::heap()->generation_sizer()->min_young_size(), \"Cannot decrease young generation capacity beyond minimum.\");\n+  }\n+  #endif\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -171,1 +171,1 @@\n-  \/\/ Scan remembered set at start of concurrent young-gen marking. *\/\n+  \/\/ Scan remembered set at start of concurrent young-gen marking.\n@@ -190,0 +190,4 @@\n+  \/\/ Record the total on-cpu time a thread has spent collecting this\n+  \/\/ generation. This is only called by the control thread (at the start\n+  \/\/ of a collection) and by the VM thread at the end of the collection,\n+  \/\/ so there are no locking concerns.\n@@ -191,0 +195,3 @@\n+\n+  \/\/ This returns the accumulated collection time and resets it to zero.\n+  \/\/ This is used to decide which generation should be resized.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.hpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -451,9 +451,9 @@\n-  size_t max_capacity_new      = young_generation_capacity(max_capacity());\n-  size_t soft_max_capacity_new = young_generation_capacity(soft_max_capacity());\n-  size_t max_capacity_old      = max_capacity() - max_capacity_new;\n-  size_t soft_max_capacity_old = soft_max_capacity() - soft_max_capacity_new;\n-\n-  _young_generation = new ShenandoahYoungGeneration(_max_workers, max_capacity_new, soft_max_capacity_new);\n-  _old_generation = new ShenandoahOldGeneration(_max_workers, max_capacity_old, soft_max_capacity_old);\n-  _global_generation = new ShenandoahGlobalGeneration(_max_workers, max_capacity_new + max_capacity_old,\n-                                                      soft_max_capacity_new + soft_max_capacity_old);\n+  _generation_sizer.heap_size_changed(soft_max_capacity());\n+  size_t initial_capacity_young = _generation_sizer.max_young_size();\n+  size_t max_capacity_young = _generation_sizer.max_young_size();\n+  size_t initial_capacity_old = max_capacity() - max_capacity_young;\n+  size_t max_capacity_old = max_capacity() - initial_capacity_young;\n+\n+  _young_generation = new ShenandoahYoungGeneration(_max_workers, max_capacity_young, initial_capacity_young);\n+  _old_generation = new ShenandoahOldGeneration(_max_workers, max_capacity_old, initial_capacity_old);\n+  _global_generation = new ShenandoahGlobalGeneration(_max_workers, soft_max_capacity(), soft_max_capacity());\n@@ -538,0 +538,2 @@\n+  _mmu_tracker(),\n+  _generation_sizer(&_mmu_tracker),\n@@ -665,31 +667,0 @@\n-\/\/ There are three JVM parameters for setting young gen capacity:\n-\/\/    NewSize, MaxNewSize, NewRatio.\n-\/\/\n-\/\/ If only NewSize is set, it assigns a fixed size and the other two parameters are ignored.\n-\/\/ Otherwise NewRatio applies.\n-\/\/\n-\/\/ If NewSize is set in any combination, it provides a lower bound.\n-\/\/\n-\/\/ If MaxNewSize is set it provides an upper bound.\n-\/\/ If this bound is smaller than NewSize, it supersedes,\n-\/\/ resulting in a fixed size given by MaxNewSize.\n-size_t ShenandoahHeap::young_generation_capacity(size_t capacity) {\n-  if (strcmp(ShenandoahGCMode, \"generational\") == 0) {\n-    if (FLAG_IS_CMDLINE(NewSize) && !FLAG_IS_CMDLINE(MaxNewSize) && !FLAG_IS_CMDLINE(NewRatio)) {\n-      capacity = MIN2(NewSize, capacity);\n-    } else {\n-      capacity \/= NewRatio + 1;\n-      if (FLAG_IS_CMDLINE(NewSize)) {\n-        capacity = MAX2(NewSize, capacity);\n-      }\n-      if (FLAG_IS_CMDLINE(MaxNewSize)) {\n-        capacity = MIN2(MaxNewSize, capacity);\n-      }\n-    }\n-    \/\/ capacity must be a multiple of ShenandoahHeapRegion::region_size_bytes()\n-    capacity &= ~ShenandoahHeapRegion::region_size_bytes_mask();\n-  }\n-  \/\/ else, make no adjustment to global capacity\n-  return capacity;\n-}\n-\n@@ -764,1 +735,2 @@\n-    size_t soft_max_capacity_young = young_generation_capacity(_soft_max_size);\n+    _generation_sizer.heap_size_changed(_soft_max_size);\n+    size_t soft_max_capacity_young = _generation_sizer.max_young_size();\n@@ -1100,1 +1072,1 @@\n-    return _mmu_tracker.adjust_generation_sizes();\n+    return _generation_sizer.adjust_generation_sizes();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":14,"deletions":42,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -226,1 +226,0 @@\n-  static size_t young_generation_capacity(size_t total_capacity);\n@@ -540,0 +539,1 @@\n+  ShenandoahGenerationSizer     _generation_sizer;\n@@ -549,0 +549,1 @@\n+  const ShenandoahGenerationSizer* generation_sizer()  const { return &_generation_sizer;  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -49,1 +49,3 @@\n-    log_info(gc, init)(\"Old Heuristics: %s\", heap->old_generation()->heuristics()->name());\n+    log_info(gc, init)(\"Young Generation Initial Size: \" SIZE_FORMAT \"%s\",\n+                       byte_size_in_proper_unit(heap->young_generation()->soft_max_capacity()),\n+                       proper_unit_for_byte_size(heap->young_generation()->soft_max_capacity()));\n@@ -53,0 +55,7 @@\n+    log_info(gc, init)(\"Old Heuristics: %s\", heap->old_generation()->heuristics()->name());\n+    log_info(gc, init)(\"Old Generation Initial Size: \" SIZE_FORMAT \"%s\",\n+                       byte_size_in_proper_unit(heap->old_generation()->soft_max_capacity()),\n+                       proper_unit_for_byte_size(heap->old_generation()->soft_max_capacity()));\n+    log_info(gc, init)(\"Old Generation Max: \" SIZE_FORMAT \"%s\",\n+                       byte_size_in_proper_unit(heap->old_generation()->max_capacity()),\n+                       proper_unit_for_byte_size(heap->old_generation()->max_capacity()));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahInitLogger.cpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -57,0 +57,2 @@\n+  \/\/ We include only the gc threads because those are the only threads\n+  \/\/ we are responsible for.\n@@ -58,2 +60,0 @@\n-  \/\/ Include VM thread? Compiler threads? or no - because there\n-  \/\/ is nothing the collector can do about those threads.\n@@ -73,5 +73,4 @@\n-  _initial_collector_time_s(0.0),\n-  _initial_process_time_s(0.0),\n-  _resize_increment(YoungGenerationSizeIncrement \/ 100.0),\n-  _mmu_periodic_task(new ShenandoahMmuTask(this)),\n-  _mmu_average(10, ShenandoahAdaptiveDecayFactor) {\n+    _generational_reference_time_s(0.0),\n+    _process_reference_time_s(0.0),\n+    _mmu_periodic_task(new ShenandoahMmuTask(this)),\n+    _mmu_average(10, ShenandoahAdaptiveDecayFactor) {\n@@ -86,1 +85,1 @@\n-  \/\/ This is only called by the control thread.\n+  \/\/ This is only called by the control thread or the VM thread.\n@@ -88,1 +87,1 @@\n-  double elapsed_gc_time_s = collector_time_s - _initial_collector_time_s;\n+  double elapsed_gc_time_s = collector_time_s - _generational_reference_time_s;\n@@ -90,1 +89,1 @@\n-  _initial_collector_time_s = collector_time_s;\n+  _generational_reference_time_s = collector_time_s;\n@@ -96,2 +95,2 @@\n-  double elapsed_process_time_s = process_time_s - _initial_process_time_s;\n-  _initial_process_time_s = process_time_s;\n+  double elapsed_process_time_s = process_time_s - _process_reference_time_s;\n+  _process_reference_time_s = process_time_s;\n@@ -99,2 +98,2 @@\n-  double verify_elapsed = verify_time_s - _initial_verify_collector_time_s;\n-  _initial_verify_collector_time_s = verify_time_s;\n+  double verify_elapsed = verify_time_s - _collector_reference_time_s;\n+  _collector_reference_time_s = verify_time_s;\n@@ -106,1 +105,94 @@\n-bool ShenandoahMmuTracker::adjust_generation_sizes() {\n+void ShenandoahMmuTracker::initialize() {\n+  _process_reference_time_s = process_time_seconds();\n+  _generational_reference_time_s = gc_thread_time_seconds();\n+  _collector_reference_time_s = _generational_reference_time_s;\n+  _mmu_periodic_task->enroll();\n+}\n+\n+ShenandoahGenerationSizer::ShenandoahGenerationSizer(ShenandoahMmuTracker* mmu_tracker)\n+  : _sizer_kind(SizerDefaults),\n+    _use_adaptive_sizing(true),\n+    _min_desired_young_size(0),\n+    _max_desired_young_size(0),\n+    _resize_increment(YoungGenerationSizeIncrement \/ 100.0),\n+    _mmu_tracker(mmu_tracker) {\n+\n+  if (FLAG_IS_CMDLINE(NewRatio)) {\n+    if (FLAG_IS_CMDLINE(NewSize) || FLAG_IS_CMDLINE(MaxNewSize)) {\n+      log_warning(gc, ergo)(\"-XX:NewSize and -XX:MaxNewSize override -XX:NewRatio\");\n+    } else {\n+      _sizer_kind = SizerNewRatio;\n+      _use_adaptive_sizing = false;\n+      return;\n+    }\n+  }\n+\n+  if (NewSize > MaxNewSize) {\n+    if (FLAG_IS_CMDLINE(MaxNewSize)) {\n+      log_warning(gc, ergo)(\"NewSize (\" SIZE_FORMAT \"k) is greater than the MaxNewSize (\" SIZE_FORMAT \"k). \"\n+                            \"A new max generation size of \" SIZE_FORMAT \"k will be used.\",\n+                            NewSize\/K, MaxNewSize\/K, NewSize\/K);\n+    }\n+    FLAG_SET_ERGO(MaxNewSize, NewSize);\n+  }\n+\n+  if (FLAG_IS_CMDLINE(NewSize)) {\n+    _min_desired_young_size = MAX2(NewSize, ShenandoahHeapRegion::region_size_bytes());\n+    if (FLAG_IS_CMDLINE(MaxNewSize)) {\n+      _max_desired_young_size = MAX2(MaxNewSize, ShenandoahHeapRegion::region_size_bytes());\n+      _sizer_kind = SizerMaxAndNewSize;\n+      _use_adaptive_sizing = _min_desired_young_size != _max_desired_young_size;\n+    } else {\n+      _sizer_kind = SizerNewSizeOnly;\n+    }\n+  } else if (FLAG_IS_CMDLINE(MaxNewSize)) {\n+    _max_desired_young_size = MAX2(MaxNewSize, ShenandoahHeapRegion::region_size_bytes());\n+    _sizer_kind = SizerMaxNewSizeOnly;\n+  }\n+}\n+\n+size_t ShenandoahGenerationSizer::calculate_min_size(size_t heap_size) {\n+  size_t default_value = (heap_size * ShenandoahMinYoungPercentage) \/ 100;\n+  return MAX2(ShenandoahHeapRegion::region_size_bytes(), default_value);\n+}\n+\n+size_t ShenandoahGenerationSizer::calculate_max_size(size_t heap_size) {\n+  size_t default_value = (heap_size * ShenandoahMaxYoungPercentage) \/ 100;\n+  return MAX2(ShenandoahHeapRegion::region_size_bytes(), default_value);\n+}\n+\n+void ShenandoahGenerationSizer::recalculate_min_max_young_length(size_t heap_size) {\n+  assert(heap_size > 0, \"Heap must be initialized\");\n+\n+  switch (_sizer_kind) {\n+    case SizerDefaults:\n+      _min_desired_young_size = calculate_min_size(heap_size);\n+      _max_desired_young_size = calculate_max_size(heap_size);\n+      break;\n+    case SizerNewSizeOnly:\n+      _max_desired_young_size = calculate_max_size(heap_size);\n+      _max_desired_young_size = MAX2(_min_desired_young_size, _max_desired_young_size);\n+      break;\n+    case SizerMaxNewSizeOnly:\n+      _min_desired_young_size = calculate_min_size(heap_size);\n+      _min_desired_young_size = MIN2(_min_desired_young_size, _max_desired_young_size);\n+      break;\n+    case SizerMaxAndNewSize:\n+      \/\/ Do nothing. Values set on the command line, don't update them at runtime.\n+      break;\n+    case SizerNewRatio:\n+      _min_desired_young_size = MAX2((heap_size \/ (NewRatio + 1)), ShenandoahHeapRegion::region_size_bytes());\n+      _max_desired_young_size = _min_desired_young_size;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+  }\n+\n+  assert(_min_desired_young_size <= _max_desired_young_size, \"Invalid min\/max young gen size values\");\n+}\n+\n+void ShenandoahGenerationSizer::heap_size_changed(size_t heap_size) {\n+  recalculate_min_max_young_length(heap_size);\n+}\n+\n+bool ShenandoahGenerationSizer::adjust_generation_sizes() {\n@@ -108,1 +200,5 @@\n-  if (_mmu_average.davg() >= double(GCTimeRatio)) {\n+  if (!use_adaptive_sizing()) {\n+    return false;\n+  }\n+\n+  if (_mmu_tracker->average() >= double(GCTimeRatio)) {\n@@ -114,1 +210,0 @@\n-  double old_time_s = old->reset_collection_time();\n@@ -116,1 +211,0 @@\n-  double young_time_s = young->reset_collection_time();\n@@ -118,0 +212,2 @@\n+  double old_time_s = old->reset_collection_time();\n+  double young_time_s = young->reset_collection_time();\n@@ -120,0 +216,3 @@\n+  const double transfer_threshold = 3.0;\n+  double delta = young_time_s - old_time_s;\n+\n@@ -122,4 +221,3 @@\n-  if (old_time_s > young_time_s) {\n-    return transfer_capacity(young, old);\n-  } else {\n-    return transfer_capacity(old, young);\n+  if (abs(delta) <= transfer_threshold) {\n+    log_info(gc, ergo)(\"Difference (%.3f) for thread utilization for each generation is under threshold (%.3f)\", abs(delta), transfer_threshold);\n+    return false;\n@@ -127,1 +225,0 @@\n-}\n@@ -129,4 +226,7 @@\n-size_t percentage_of_heap(size_t bytes) {\n-  size_t heap_capacity = ShenandoahHeap::heap()->max_capacity();\n-  assert(bytes < heap_capacity, \"Must be less than total capacity\");\n-  return size_t(100.0 * double(bytes) \/ double(heap_capacity));\n+  if (delta > 0) {\n+    \/\/ young is busier than old, increase size of young to raise MMU\n+    return transfer_capacity(old, young);\n+  } else {\n+    \/\/ old is busier than young, increase size of old to raise MMU\n+    return transfer_capacity(young, old);\n+  }\n@@ -135,1 +235,1 @@\n-bool ShenandoahMmuTracker::transfer_capacity(ShenandoahGeneration* from, ShenandoahGeneration* to) {\n+bool ShenandoahGenerationSizer::transfer_capacity(ShenandoahGeneration* from, ShenandoahGeneration* to) {\n@@ -147,13 +247,1 @@\n-    size_t new_young_size = from->max_capacity() - bytes_to_transfer;\n-    if (percentage_of_heap(new_young_size) < ShenandoahMinYoungPercentage) {\n-      ShenandoahHeap* heap = ShenandoahHeap::heap();\n-      size_t minimum_size = size_t(ShenandoahMinYoungPercentage \/ 100.0 * heap->max_capacity());\n-      if (from->max_capacity() > minimum_size) {\n-        bytes_to_transfer = from->max_capacity() - minimum_size;\n-      } else {\n-        log_info(gc)(\"Cannot transfer from young: \" SIZE_FORMAT \"%s, at minimum capacity: \" SIZE_FORMAT \"%s\",\n-            byte_size_in_proper_unit(from->max_capacity()), proper_unit_for_byte_size(from->max_capacity()),\n-            byte_size_in_proper_unit(minimum_size), proper_unit_for_byte_size(minimum_size));\n-        return false;\n-      }\n-    }\n+    bytes_to_transfer = adjust_transfer_from_young(from, bytes_to_transfer);\n@@ -161,14 +249,8 @@\n-    assert(to->generation_mode() == YOUNG, \"Can only transfer between young and old.\");\n-    size_t new_young_size = to->max_capacity() + bytes_to_transfer;\n-    if (percentage_of_heap(new_young_size) > ShenandoahMaxYoungPercentage) {\n-      ShenandoahHeap* heap = ShenandoahHeap::heap();\n-      size_t maximum_size = size_t(ShenandoahMaxYoungPercentage \/ 100.0 * heap->max_capacity());\n-      if (maximum_size > to->max_capacity()) {\n-        bytes_to_transfer = maximum_size - to->max_capacity();\n-      } else {\n-        log_info(gc)(\"Cannot transfer to young: \" SIZE_FORMAT \"%s, at maximum capacity: \" SIZE_FORMAT \"%s\",\n-            byte_size_in_proper_unit(to->max_capacity()), proper_unit_for_byte_size(to->max_capacity()),\n-            byte_size_in_proper_unit(maximum_size), proper_unit_for_byte_size(maximum_size));\n-        return false;\n-      }\n-    }\n+    bytes_to_transfer = adjust_transfer_to_young(to, bytes_to_transfer);\n+  }\n+\n+  if (bytes_to_transfer == 0) {\n+    log_debug(gc)(\"No capacity available to transfer from: %s (\" SIZE_FORMAT \"%s) to: %s (\" SIZE_FORMAT \"%s)\",\n+                  from->name(), byte_size_in_proper_unit(from->max_capacity()), proper_unit_for_byte_size(from->max_capacity()),\n+                  to->name(), byte_size_in_proper_unit(to->max_capacity()), proper_unit_for_byte_size(to->max_capacity()));\n+    return false;\n@@ -185,6 +267,31 @@\n-void ShenandoahMmuTracker::initialize() {\n-  _initial_process_time_s = process_time_seconds();\n-  _initial_collector_time_s = gc_thread_time_seconds();\n-  _initial_verify_collector_time_s = _initial_collector_time_s;\n-  _mmu_periodic_task->enroll();\n-}\n\\ No newline at end of file\n+size_t round_down_to_multiple_of_region_size(size_t bytes) {\n+  return (bytes \/ ShenandoahHeapRegion::region_size_bytes()) * ShenandoahHeapRegion::region_size_bytes();\n+}\n+\n+size_t ShenandoahGenerationSizer::adjust_transfer_from_young(ShenandoahGeneration* from, size_t bytes_to_transfer) const {\n+  assert(from->generation_mode() == YOUNG, \"Expect to transfer from young\");\n+  size_t new_young_size = from->max_capacity() - bytes_to_transfer;\n+  size_t minimum_size = min_young_size();\n+  \/\/ Check that we are not going to violate the minimum size constraint.\n+  if (new_young_size < minimum_size) {\n+    assert(minimum_size <= from->max_capacity(), \"Young is under minimum capacity.\");\n+    \/\/ If the transfer violates the minimum size and there is still some capacity to transfer,\n+    \/\/ adjust the transfer to take the size to the minimum. Note that this may be zero.\n+    bytes_to_transfer = round_down_to_multiple_of_region_size(from->max_capacity() - minimum_size);\n+  }\n+  return bytes_to_transfer;\n+}\n+\n+size_t ShenandoahGenerationSizer::adjust_transfer_to_young(ShenandoahGeneration* to, size_t bytes_to_transfer) const {\n+  assert(to->generation_mode() == YOUNG, \"Can only transfer between young and old.\");\n+  size_t new_young_size = to->max_capacity() + bytes_to_transfer;\n+  size_t maximum_size = max_young_size();\n+  \/\/ Check that we are not going to violate the maximum size constraint.\n+  if (new_young_size > maximum_size) {\n+    assert(maximum_size >= to->max_capacity(), \"Young is over maximum capacity\");\n+    \/\/ If the transfer violates the maximum size and there is still some capacity to transfer,\n+    \/\/ adjust the transfer to take the size to the maximum. Note that this may be zero.\n+    bytes_to_transfer = round_down_to_multiple_of_region_size(maximum_size - to->max_capacity());\n+  }\n+  return bytes_to_transfer;\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMmuTracker.cpp","additions":168,"deletions":61,"binary":false,"changes":229,"status":"modified"},{"patch":"@@ -37,2 +37,4 @@\n- * to mutator threads over an arbitrary, fixed interval of time. MMU is measured\n- * by summing all of the time given to the GC threads and comparing this too\n+ * to mutator threads over an arbitrary, fixed interval of time. This interval\n+ * defaults to 5 seconds and is configured by GCPauseIntervalMillis. The class\n+ * maintains a decaying average of the last 10 values. The MMU is measured\n+ * by summing all of the time given to the GC threads and comparing this to\n@@ -52,5 +54,3 @@\n-  double _initial_collector_time_s;\n-  double _initial_process_time_s;\n-  double _initial_verify_collector_time_s;\n-\n-  double _resize_increment;\n+  double _generational_reference_time_s;\n+  double _process_reference_time_s;\n+  double _collector_reference_time_s;\n@@ -61,2 +61,0 @@\n-  bool transfer_capacity(ShenandoahGeneration* from, ShenandoahGeneration* to);\n-\n@@ -86,0 +84,60 @@\n+  double average() {\n+    return _mmu_average.davg();\n+  }\n+};\n+\n+class ShenandoahGenerationSizer {\n+private:\n+  enum SizerKind {\n+    SizerDefaults,\n+    SizerNewSizeOnly,\n+    SizerMaxNewSizeOnly,\n+    SizerMaxAndNewSize,\n+    SizerNewRatio\n+  };\n+  SizerKind _sizer_kind;\n+\n+  \/\/ False when using a fixed young generation size due to command-line options,\n+  \/\/ true otherwise.\n+  bool _use_adaptive_sizing;\n+\n+  size_t _min_desired_young_size;\n+  size_t _max_desired_young_size;\n+\n+  double _resize_increment;\n+  ShenandoahMmuTracker* _mmu_tracker;\n+\n+  static size_t calculate_min_size(size_t heap_size);\n+  static size_t calculate_max_size(size_t heap_size);\n+\n+  \/\/ Update the given values for minimum and maximum young gen length in regions\n+  \/\/ given the number of heap regions depending on the kind of sizing algorithm.\n+  void recalculate_min_max_young_length(size_t heap_size);\n+\n+  \/\/ This will attempt to transfer capacity from one generation to the other. It\n+  \/\/ returns true if a transfer is made, false otherwise.\n+  bool transfer_capacity(ShenandoahGeneration* from, ShenandoahGeneration* to);\n+\n+  \/\/ These two methods are responsible for enforcing the minimum and maximum\n+  \/\/ constraints for the size of the generations.\n+  size_t adjust_transfer_from_young(ShenandoahGeneration* from, size_t bytes_to_transfer) const;\n+  size_t adjust_transfer_to_young(ShenandoahGeneration* to, size_t bytes_to_transfer) const;\n+\n+public:\n+  ShenandoahGenerationSizer(ShenandoahMmuTracker* mmu_tracker);\n+\n+  \/\/ Calculate the maximum length of the young gen given the number of regions\n+  \/\/ depending on the sizing algorithm.\n+  void heap_size_changed(size_t heap_size);\n+\n+  size_t min_young_size() const {\n+    return _min_desired_young_size;\n+  }\n+  size_t max_young_size() const {\n+    return _max_desired_young_size;\n+  }\n+\n+  bool use_adaptive_sizing() const {\n+    return _use_adaptive_sizing;\n+  }\n+\n@@ -90,4 +148,4 @@\n-  \/\/ and defaults to 20% of the heap. The minimum and maximum sizes of the\n-  \/\/ young generation are controlled by ShenandoahMinYoungPercentage and\n-  \/\/ ShenandoahMaxYoungPercentage, respectively. The method returns true\n-  \/\/ when and adjustment is made, false otherwise.\n+  \/\/ and defaults to 20% of the available capacity of the donor generation.\n+  \/\/ The minimum and maximum sizes of the young generation are controlled by\n+  \/\/ ShenandoahMinYoungPercentage and ShenandoahMaxYoungPercentage, respectively.\n+  \/\/ The method returns true when an adjustment is made, false otherwise.\n@@ -97,2 +155,0 @@\n-\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMmuTracker.hpp","additions":71,"deletions":15,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-  if (_old_gen_task_queues != nullptr && in_progress && !heap->is_prepare_for_old_mark_in_progress()) {\n+  if (is_bootstrap_cycle() && in_progress && !heap->is_prepare_for_old_mark_in_progress()) {\n@@ -78,1 +78,1 @@\n-  if (_old_gen_task_queues != NULL) {\n+  if (is_bootstrap_cycle()) {\n@@ -95,1 +95,1 @@\n-  if (_old_gen_task_queues != NULL) {\n+  if (is_bootstrap_cycle()) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahYoungGeneration.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -55,0 +55,6 @@\n+  \/\/ Returns true if the young generation is configured to enqueue old\n+  \/\/ oops for the old generation mark queues.\n+  bool is_bootstrap_cycle() {\n+    return _old_gen_task_queues != nullptr;\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahYoungGeneration.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -284,0 +284,2 @@\n+\n+#undef SKIP_IF_NOT_SHENANDOAH\n\\ No newline at end of file\n","filename":"test\/hotspot\/gtest\/gc\/shenandoah\/test_shenandoahOldHeuristic.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}