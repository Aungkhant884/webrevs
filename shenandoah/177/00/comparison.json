{"files":[{"patch":"@@ -419,1 +419,1 @@\n-  double avg_cycle_time = _gc_time_history->davg() + (_margin_of_error_sd * _gc_time_history->dsd());\n+  double avg_cycle_time = _gc_cycle_time_history->davg() + (_margin_of_error_sd * _gc_cycle_time_history->dsd());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-  _gc_time_history(new TruncatedSeq(10, ShenandoahAdaptiveDecayFactor)),\n+  _gc_cycle_time_history(new TruncatedSeq(10, ShenandoahAdaptiveDecayFactor)),\n@@ -305,1 +305,1 @@\n-    _gc_time_history->add(time_since_last_gc());\n+    _gc_cycle_time_history->add(elapsed_cycle_time());\n@@ -364,1 +364,1 @@\n-double ShenandoahHeuristics::time_since_last_gc() const {\n+double ShenandoahHeuristics::elapsed_cycle_time() const {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -100,1 +100,1 @@\n-  TruncatedSeq* _gc_time_history;\n+  TruncatedSeq* _gc_cycle_time_history;\n@@ -171,1 +171,1 @@\n-  double time_since_last_gc() const;\n+  double elapsed_cycle_time() const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+  SHENANDOAH_ERGO_OVERRIDE_DEFAULT(GCTimeRatio, 70);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/mode\/shenandoahGenerationalMode.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -72,0 +72,7 @@\n+  \/\/ We use this as the time period for tracking minimum mutator utilization (MMU).\n+  \/\/ In generational mode, the MMU is used as a signal to adjust the size of the\n+  \/\/ young generation.\n+  if (FLAG_IS_DEFAULT(GCPauseIntervalMillis)) {\n+    FLAG_SET_DEFAULT(GCPauseIntervalMillis, 5000);\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahArguments.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -166,0 +166,3 @@\n+\n+#define shenandoah_assert_generational() \\\n+                    assert(ShenandoahHeap::heap()->mode()->is_generational(), \"Must be in generational mode here.\")\n@@ -216,0 +219,1 @@\n+#define shenandoah_assert_generational()\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAsserts.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+  size_t _cycle_counter;\n@@ -58,1 +59,0 @@\n-\n@@ -61,2 +61,0 @@\n-  size_t _cycle_counter;\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCollectorPolicy.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1208,0 +1208,1 @@\n+  heap->adjust_generation_sizes();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -451,1 +451,1 @@\n-\n+  GCIdMark gc_id_mark;\n@@ -461,1 +461,0 @@\n-      heap->young_generation()->log_status();\n@@ -467,1 +466,0 @@\n-      heap->global_generation()->log_status();\n@@ -473,1 +471,0 @@\n-      heap->old_generation()->log_status();\n@@ -479,0 +476,1 @@\n+  log_heap_status(heap);\n@@ -486,1 +484,0 @@\n-  GCIdMark gc_id_mark;\n@@ -585,0 +582,9 @@\n+void ShenandoahControlThread::log_heap_status(const ShenandoahHeap* heap) {\n+  if (heap->mode()->is_generational()) {\n+    heap->young_generation()->log_status();\n+    heap->old_generation()->log_status();\n+  } else {\n+    heap->global_generation()->log_status();\n+  }\n+}\n+\n@@ -643,1 +649,0 @@\n-  GCIdMark gc_id_mark;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -192,0 +192,2 @@\n+\n+  void log_heap_status(const ShenandoahHeap* heap);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -299,0 +299,2 @@\n+\n+    heap->adjust_generation_sizes();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahDegeneratedGC.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -335,0 +335,2 @@\n+  heap->adjust_generation_sizes();\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -992,0 +992,12 @@\n+void ShenandoahGeneration::increase_capacity(size_t increment) {\n+  shenandoah_assert_heaplocked_or_safepoint();\n+  _max_capacity += increment;\n+  _soft_max_capacity += increment;\n+}\n+\n+void ShenandoahGeneration::decrease_capacity(size_t decrement) {\n+  shenandoah_assert_heaplocked_or_safepoint();\n+  _max_capacity -= decrement;\n+  _soft_max_capacity -= decrement;\n+}\n+\n@@ -1001,0 +1013,10 @@\n+\n+void ShenandoahGeneration::add_collection_time(double time_seconds) {\n+  _collection_thread_time_s += time_seconds;\n+}\n+\n+double ShenandoahGeneration::reset_collection_time() {\n+  double t = _collection_thread_time_s;\n+  _collection_thread_time_s = 0.0;\n+  return t;\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -49,0 +49,2 @@\n+  double _collection_thread_time_s;\n+\n@@ -107,0 +109,3 @@\n+  void increase_capacity(size_t increment);\n+  void decrease_capacity(size_t decrement);\n+\n@@ -176,0 +181,3 @@\n+\n+  virtual void add_collection_time(double time_seconds);\n+  double reset_collection_time();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -635,0 +635,1 @@\n+  _mmu_tracker.initialize();\n@@ -1117,0 +1118,7 @@\n+bool ShenandoahHeap::adjust_generation_sizes() {\n+  if (mode()->is_generational()) {\n+    return _mmu_tracker.adjust_generation_sizes();\n+  }\n+  return false;\n+}\n+\n@@ -1750,0 +1758,1 @@\n+  tcl->do_thread(_regulator_thread);\n@@ -1781,0 +1790,29 @@\n+void ShenandoahHeap::on_cycle_start(GCCause::Cause cause, ShenandoahGeneration* generation) {\n+  log_info(gc)(\"on_cycle_start: %s\", generation->name());\n+  set_gc_cause(cause);\n+  set_gc_generation(generation);\n+\n+  shenandoah_policy()->record_cycle_start();\n+  generation->heuristics()->record_cycle_start();\n+\n+  \/\/ When a cycle starts, attribute any thread activity when the collector\n+  \/\/ is idle to the global generation.\n+  _mmu_tracker.record(global_generation());\n+}\n+\n+void ShenandoahHeap::on_cycle_end(ShenandoahGeneration* generation) {\n+  log_info(gc)(\"on_cycle_end: %s\", generation->name());\n+  generation->heuristics()->record_cycle_end();\n+\n+  if (mode()->is_generational() &&\n+      ((generation->generation_mode() == GLOBAL) || upgraded_to_full())) {\n+    \/\/ If we just completed a GLOBAL GC, claim credit for completion of young-gen and old-gen GC as well\n+    young_generation()->heuristics()->record_cycle_end();\n+    old_generation()->heuristics()->record_cycle_end();\n+  }\n+  set_gc_cause(GCCause::_no_gc);\n+\n+  \/\/ When a cycle ends, the thread activity is attributed to the respective generation\n+  _mmu_tracker.record(generation);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":38,"deletions":0,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"gc\/shenandoah\/shenandoahMmuTracker.hpp\"\n@@ -537,0 +538,1 @@\n+  ShenandoahMmuTracker          _mmu_tracker;\n@@ -555,0 +557,3 @@\n+  void on_cycle_start(GCCause::Cause cause, ShenandoahGeneration* generation);\n+  void on_cycle_end(ShenandoahGeneration* generation);\n+\n@@ -808,0 +813,1 @@\n+  bool adjust_generation_sizes();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,190 @@\n+\/*\n+ * Copyright (c) 2022, Amazon, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"gc\/shenandoah\/shenandoahMmuTracker.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahOldGeneration.hpp\"\n+#include \"gc\/shenandoah\/shenandoahYoungGeneration.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"runtime\/task.hpp\"\n+#include \"logging\/log.hpp\"\n+\n+\n+class ShenandoahMmuTask : public PeriodicTask {\n+  ShenandoahMmuTracker* _mmu_tracker;\n+public:\n+  ShenandoahMmuTask(ShenandoahMmuTracker* mmu_tracker) :\n+    PeriodicTask(GCPauseIntervalMillis), _mmu_tracker(mmu_tracker) {}\n+\n+  virtual void task() override {\n+    _mmu_tracker->report();\n+  }\n+};\n+\n+class ThreadTimeAccumulator : public ThreadClosure {\n+ public:\n+  size_t total_time;\n+  ThreadTimeAccumulator() : total_time(0) {}\n+  virtual void do_thread(Thread* thread) override {\n+    total_time += os::thread_cpu_time(thread);\n+  }\n+};\n+\n+double ShenandoahMmuTracker::gc_thread_time_seconds() {\n+  ThreadTimeAccumulator cl;\n+  ShenandoahHeap::heap()->gc_threads_do(&cl);\n+  \/\/ Include VM thread? Compiler threads? or no - because there\n+  \/\/ is nothing the collector can do about those threads.\n+  return double(cl.total_time) \/ NANOSECS_PER_SEC;\n+}\n+\n+double ShenandoahMmuTracker::process_time_seconds() {\n+  double process_real_time(0.0), process_user_time(0.0), process_system_time(0.0);\n+  bool valid = os::getTimesSecs(&process_real_time, &process_user_time, &process_system_time);\n+  if (valid) {\n+    return process_user_time + process_system_time;\n+  }\n+  return 0.0;\n+}\n+\n+ShenandoahMmuTracker::ShenandoahMmuTracker() :\n+  _initial_collector_time_s(0.0),\n+  _initial_process_time_s(0.0),\n+  _resize_increment(YoungGenerationSizeIncrement \/ 100.0),\n+  _mmu_periodic_task(new ShenandoahMmuTask(this)),\n+  _mmu_lock(Mutex::nosafepoint - 2, \"ShenandoahMMU_lock\", true),\n+  _mmu_average(10, ShenandoahAdaptiveDecayFactor) {\n+}\n+\n+ShenandoahMmuTracker::~ShenandoahMmuTracker() {\n+  _mmu_periodic_task->disenroll();\n+  delete _mmu_periodic_task;\n+}\n+\n+void ShenandoahMmuTracker::record(ShenandoahGeneration* generation) {\n+  MonitorLocker lock(&_mmu_lock, Mutex::_no_safepoint_check_flag);\n+  double collector_time_s = gc_thread_time_seconds();\n+  double elapsed_gc_time_s = collector_time_s - _initial_collector_time_s;\n+  generation->add_collection_time(elapsed_gc_time_s);\n+  _initial_collector_time_s = collector_time_s;\n+}\n+\n+void ShenandoahMmuTracker::report() {\n+  MonitorLocker lock(&_mmu_lock, Mutex::_no_safepoint_check_flag);\n+  double process_time_s = process_time_seconds();\n+  double elapsed_process_time_s = process_time_s - _initial_process_time_s;\n+  _initial_process_time_s = process_time_s;\n+  double verify_time_s = gc_thread_time_seconds();\n+  double verify_elapsed = verify_time_s - _initial_verify_collector_time_s;\n+  _initial_verify_collector_time_s = verify_time_s;\n+  double verify_mmu = ((elapsed_process_time_s - verify_elapsed) \/ elapsed_process_time_s) * 100;\n+  _mmu_average.add(verify_mmu);\n+  log_info(gc)(\"Average MMU = %.3f\", _mmu_average.davg());\n+}\n+\n+bool ShenandoahMmuTracker::adjust_generation_sizes() {\n+  shenandoah_assert_generational();\n+  if (_mmu_average.davg() >= double(GCTimeRatio)) {\n+    return false;\n+  }\n+\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  ShenandoahOldGeneration *old = heap->old_generation();\n+  double old_time_s = old->reset_collection_time();\n+  ShenandoahYoungGeneration *young = heap->young_generation();\n+  double young_time_s = young->reset_collection_time();\n+  ShenandoahGeneration *global = heap->global_generation();\n+  double global_time_s = global->reset_collection_time();\n+\n+  log_info(gc)(\"Thread Usr+Sys YOUNG = %.3f, OLD = %.3f, GLOBAL = %.3f\", young_time_s, old_time_s, global_time_s);\n+\n+  if (old_time_s > young_time_s) {\n+    return transfer_capacity(young, old);\n+  } else {\n+    return transfer_capacity(old, young);\n+  }\n+}\n+\n+size_t percentage_of_heap(size_t bytes) {\n+  size_t heap_capacity = ShenandoahHeap::heap()->max_capacity();\n+  assert(bytes > heap_capacity, \"Must be less than total capacity\");\n+  return size_t(100.0 * double(bytes) \/ double(heap_capacity));\n+}\n+\n+bool ShenandoahMmuTracker::transfer_capacity(ShenandoahGeneration* from, ShenandoahGeneration* to) {\n+  shenandoah_assert_heaplocked_or_safepoint();\n+\n+  size_t available_regions = from->free_unaffiliated_regions();\n+  if (available_regions <= 0) {\n+    log_info(gc)(\"%s has no regions available for transfer to %s\", from->name(), to->name());\n+    return false;\n+  }\n+\n+  size_t regions_to_transfer = MAX2(1UL, size_t(double(available_regions) * _resize_increment));\n+  size_t bytes_to_transfer = regions_to_transfer * ShenandoahHeapRegion::region_size_bytes();\n+  if (from->generation_mode() == YOUNG) {\n+    size_t new_young_size = from->max_capacity() - bytes_to_transfer;\n+    if (percentage_of_heap(new_young_size) < ShenandoahMinYoungPercentage) {\n+      ShenandoahHeap* heap = ShenandoahHeap::heap();\n+      size_t minimum_size = size_t(ShenandoahMinYoungPercentage \/ 100.0 * heap->max_capacity());\n+      if (from->max_capacity() > minimum_size) {\n+        bytes_to_transfer = from->max_capacity() - minimum_size;\n+      } else {\n+        log_info(gc)(\"Cannot transfer from young: \" SIZE_FORMAT \"%s, at minimum capacity: \" SIZE_FORMAT \"%s\",\n+            byte_size_in_proper_unit(from->max_capacity()), proper_unit_for_byte_size(from->max_capacity()),\n+            byte_size_in_proper_unit(minimum_size), proper_unit_for_byte_size(minimum_size));\n+        return false;\n+      }\n+    }\n+  } else {\n+    assert(to->generation_mode() == YOUNG, \"Can only transfer between young and old.\");\n+    size_t new_young_size = to->max_capacity() + bytes_to_transfer;\n+    if (percentage_of_heap(new_young_size) > ShenandoahMaxYoungPercentage) {\n+      ShenandoahHeap* heap = ShenandoahHeap::heap();\n+      size_t maximum_size = size_t(ShenandoahMaxYoungPercentage \/ 100.0 * heap->max_capacity());\n+      if (maximum_size > to->max_capacity()) {\n+        bytes_to_transfer = maximum_size - to->max_capacity();\n+      } else {\n+        log_info(gc)(\"Cannot transfer to young: \" SIZE_FORMAT \"%s, at maximum capacity: \" SIZE_FORMAT \"%s\",\n+            byte_size_in_proper_unit(to->max_capacity()), proper_unit_for_byte_size(to->max_capacity()),\n+            byte_size_in_proper_unit(maximum_size), proper_unit_for_byte_size(maximum_size));\n+        return false;\n+      }\n+    }\n+  }\n+\n+  assert(bytes_to_transfer <= regions_to_transfer * ShenandoahHeapRegion::region_size_bytes(), \"Cannot transfer more than available in free regions.\");\n+  log_info(gc)(\"Transfer \" SIZE_FORMAT \"%s from %s to %s\", byte_size_in_proper_unit(bytes_to_transfer),\n+               proper_unit_for_byte_size(bytes_to_transfer), from->name(), to->name());\n+  from->decrease_capacity(bytes_to_transfer);\n+  to->increase_capacity(bytes_to_transfer);\n+  return true;\n+}\n+\n+void ShenandoahMmuTracker::initialize() {\n+  _initial_process_time_s = process_time_seconds();\n+  _initial_collector_time_s = gc_thread_time_seconds();\n+  _initial_verify_collector_time_s = _initial_collector_time_s;\n+  _mmu_periodic_task->enroll();\n+}\n\\ No newline at end of file\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMmuTracker.cpp","additions":190,"deletions":0,"binary":false,"changes":190,"status":"added"},{"patch":"@@ -0,0 +1,101 @@\n+\/*\n+ * Copyright (c) 2022, Amazon, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHENANDOAH_SHENANDOAHMMUTRACKER_HPP\n+#define SHARE_GC_SHENANDOAH_SHENANDOAHMMUTRACKER_HPP\n+\n+#include \"memory\/iterator.hpp\"\n+#include \"runtime\/mutex.hpp\"\n+#include \"utilities\/numberSeq.hpp\"\n+\n+class ShenandoahGeneration;\n+class ShenandoahMmuTask;\n+\n+\/**\n+ * This class is responsible for tracking and adjusting the minimum mutator\n+ * utilization (MMU). MMU is defined as the percentage of CPU time available\n+ * to mutator threads over an arbitrary, fixed interval of time. MMU is measured\n+ * by summing all of the time given to the GC threads and comparing this too\n+ * the total CPU time for the process. There are OS APIs to support this on\n+ * all major platforms.\n+ *\n+ * The time spent by GC threads is attributed to the young or old generation.\n+ * The time given to the controller and regulator threads is attributed to the\n+ * global generation. At the end of every collection, the average MMU is inspected.\n+ * If it is below `GCTimeRatio`, this class will attempt to increase the capacity\n+ * of the generation that is consuming the most CPU time. The assumption being\n+ * that increasing memory will reduce the collection frequency and raise the\n+ * MMU.\n+ *\/\n+class ShenandoahMmuTracker {\n+\n+  double _initial_collector_time_s;\n+  double _initial_process_time_s;\n+  double _initial_verify_collector_time_s;\n+\n+  double _resize_increment;\n+\n+  ShenandoahMmuTask* _mmu_periodic_task;\n+  Monitor _mmu_lock;\n+  TruncatedSeq _mmu_average;\n+\n+  bool transfer_capacity(ShenandoahGeneration* from, ShenandoahGeneration* to);\n+\n+  static double gc_thread_time_seconds();\n+  static double process_time_seconds();\n+\n+public:\n+  explicit ShenandoahMmuTracker();\n+  ~ShenandoahMmuTracker();\n+\n+  \/\/ This enrolls the periodic task after everything is initialized.\n+  void initialize();\n+\n+  \/\/ This is called at the start and end of a GC cycle. The GC thread times\n+  \/\/ will be accumulated in this generation. Note that the bootstrap cycle\n+  \/\/ for an old collection should be counted against the old generation.\n+  \/\/ When the collector is idle, it still runs a regulator and a control.\n+  \/\/ The times for these threads are attributed to the global generation.\n+  void record(ShenandoahGeneration* generation);\n+\n+  \/\/ This is called by the periodic task timer. The interval is defined by\n+  \/\/ GCPauseIntervalMillis and defaults to 5 seconds. This method computes\n+  \/\/ the MMU over the elapsed interval and records it in a running average.\n+  \/\/ This method also logs the average MMU.\n+  void report();\n+\n+  \/\/ This is invoked at the end of a collection. This happens on a safepoint\n+  \/\/ to avoid any races with allocators (and to avoid interfering with\n+  \/\/ allocators by taking the heap lock). The amount of capacity to move\n+  \/\/ from one generation to another is controlled by YoungGenerationSizeIncrement\n+  \/\/ and defaults to 20% of the heap. The minimum and maximum sizes of the\n+  \/\/ young generation are controlled by ShenandoahMinYoungPercentage and\n+  \/\/ ShenandoahMaxYoungPercentage, respectively. The method returns true\n+  \/\/ when and adjustment is made, false otherwise.\n+  bool adjust_generation_sizes();\n+};\n+\n+\n+\n+#endif \/\/SHARE_GC_SHENANDOAH_SHENANDOAHMMUTRACKER_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMmuTracker.hpp","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"},{"patch":"@@ -50,2 +50,2 @@\n-  _heap->set_gc_cause(cause);\n-  _heap->set_gc_generation(generation);\n+  _heap->on_cycle_start(cause, _generation);\n+\n@@ -56,2 +56,0 @@\n-  _heap->shenandoah_policy()->record_cycle_start();\n-  generation->heuristics()->record_cycle_start();\n@@ -70,1 +68,0 @@\n-\n@@ -72,8 +69,1 @@\n-\n-  _generation->heuristics()->record_cycle_end();\n-  if (_heap->mode()->is_generational() &&\n-      ((_generation->generation_mode() == GLOBAL) || _heap->upgraded_to_full())) {\n-    \/\/ If we just completed a GLOBAL GC, claim credit for completion of young-gen and old-gen GC as well\n-    _heap->young_generation()->heuristics()->record_cycle_end();\n-    _heap->old_generation()->heuristics()->record_cycle_end();\n-  }\n+  _heap->on_cycle_end(_generation);\n@@ -85,1 +75,1 @@\n-  _heap->set_gc_cause(GCCause::_no_gc);\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahUtils.cpp","additions":4,"deletions":14,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/shenandoah\/shenandoahOldGeneration.hpp\"\n@@ -92,0 +93,9 @@\n+\n+void ShenandoahYoungGeneration::add_collection_time(double time_seconds) {\n+  if (_old_gen_task_queues != NULL) {\n+    \/\/ This is a bootstrap cycle, so attribute time to old gc\n+    ShenandoahHeap::heap()->old_generation()->add_collection_time(time_seconds);\n+  } else {\n+    ShenandoahGeneration::add_collection_time(time_seconds);\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahYoungGeneration.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -59,1 +59,3 @@\n-protected:\n+  virtual void add_collection_time(double time_seconds) override;\n+\n+ protected:\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahYoungGeneration.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -383,0 +383,12 @@\n+  product(uintx, ShenandoahMinYoungPercentage, 20,                                \\\n+          \"The minimum percentage of the heap to use for the young \"        \\\n+          \"generation. Heuristics will not adjust the young generation \"    \\\n+          \"to be less than this.\")                                          \\\n+          range(0, 100)                                                     \\\n+                                                                            \\\n+  product(uintx, ShenandoahMaxYoungPercentage, 80,                                \\\n+          \"The maximum percentage of the heap to use for the young \"        \\\n+          \"generation. Heuristics will not adjust the young generation \"    \\\n+          \"to be more than this.\")                                          \\\n+          range(0, 100)                                                     \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoah_globals.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"}]}