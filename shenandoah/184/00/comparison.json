{"files":[{"patch":"@@ -59,1 +59,1 @@\n-    while (v > 1) {\n+    while (v >= 1) {\n@@ -74,1 +74,1 @@\n-  \/\/ Defensively saturate for product bits:\n+  \/\/ Defensively saturate for product bits\n@@ -123,0 +123,36 @@\n+\/\/ Merge this HdrSeq into hdr2: clear optional and on-by-default\n+\/\/ Note: this method isn't intrinsically MT-safe; callers must take care\n+\/\/ of any mutual exclusion as necessary.\n+void HdrSeq::merge(HdrSeq& hdr2, bool clear_this) {\n+  for (int mag = 0; mag < MagBuckets; mag++) {\n+    if (_hdr[mag] != NULL) {\n+      int* that_bucket = hdr2._hdr[mag];\n+      if (that_bucket == NULL) {\n+        if (clear_this) {\n+          \/\/ the target doesn't have any values, swap in ours.\n+          \/\/ Could this cause native memory fragmentation?\n+          hdr2._hdr[mag] = _hdr[mag];\n+          _hdr[mag] = NULL;\n+        } else {\n+          \/\/ We can't clear this, so we create the entries & add in below\n+          that_bucket = NEW_C_HEAP_ARRAY(int, ValBuckets, mtInternal);\n+          for (int val = 0; val < ValBuckets; val++) {\n+            that_bucket[val] = _hdr[mag][val];\n+          }\n+          hdr2._hdr[mag] = that_bucket;\n+        }\n+      } else {\n+        \/\/ Add in our values into target\n+        for (int val = 0; val < ValBuckets; val++) {\n+          that_bucket[val] += _hdr[mag][val];\n+          if (clear_this) {\n+            _hdr[mag][val] = 0;\n+          }\n+        }\n+      }\n+    }\n+  }\n+  \/\/ Merge up the class hierarchy\n+  NumberSeq::merge(hdr2, clear_this);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahNumberSeq.cpp","additions":38,"deletions":2,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -53,0 +53,3 @@\n+\n+  \/\/ Merge this HdrSeq into hdr2, optionally clearing this HdrSeq\n+  void merge(HdrSeq& hdr2, bool clear_this = true);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahNumberSeq.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -113,0 +113,28 @@\n+\n+void AbsSeq::merge(AbsSeq& abs2, bool clear_this) {\n+\n+  if (num() == 0) return;  \/\/ nothing to do\n+\n+  abs2._num += _num;\n+  abs2._sum += _sum;\n+  abs2._sum_of_squares += _sum_of_squares;\n+\n+  \/\/ Decaying stats need a bit more thought\n+  assert(abs2._alpha == _alpha, \"Caution: merge incompatible?\");\n+\n+  \/\/ Until JDK-... is fixed, we taint the decaying statistics\n+  if (abs2._davg != NAN) {\n+    abs2._davg = NAN;\n+    abs2._dvariance = NAN;\n+  }\n+\n+  if (clear_this) {\n+    _num = 0;\n+    _sum = 0;\n+    _sum_of_squares = 0;\n+    _davg = 0;\n+    _dvariance = 0;\n+  }\n+}\n+\n+\n@@ -140,0 +168,16 @@\n+void NumberSeq::merge(NumberSeq& nseq2, bool clear_this) {\n+\n+  if (num() == 0) return;  \/\/ nothing to do\n+\n+  nseq2._last = _last;   \/\/ this is newer than that\n+  nseq2._maximum = MAX2(_maximum, nseq2._maximum);\n+\n+  AbsSeq::merge(nseq2, clear_this);\n+\n+  if (clear_this) {\n+    _last = 0;\n+    _maximum = 0;\n+    assert(num() == 0, \"Not cleared\");\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/utilities\/numberSeq.cpp","additions":44,"deletions":0,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -86,0 +86,3 @@\n+\n+  \/\/ Merge this AbsSeq into seq2, optionally clearing this AbsSeq\n+  void merge(AbsSeq& seq2, bool clear_this = true);\n@@ -105,0 +108,3 @@\n+\n+  \/\/ Merge this NumberSeq into seq2, optionally clearing this NumberSeq\n+  void merge(NumberSeq& seq2, bool clear_this = true);\n@@ -132,0 +138,3 @@\n+\n+  \/\/ Merge this AbsSeq into seq2, optionally clearing this AbsSeq\n+  void merge(AbsSeq& seq2, bool clear_this = true);\n","filename":"src\/hotspot\/share\/utilities\/numberSeq.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,133 @@\n+\/*\n+ * Copyright (c) 2022, Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/shenandoah\/shenandoahNumberSeq.hpp\"\n+#include <iostream>\n+#include \"unittest.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+\n+class ShenandoahNumberSeqTest: public ::testing::Test {\n+ protected:\n+  const double err = 0.5;\n+\n+  HdrSeq seq1;\n+  HdrSeq seq2;\n+  HdrSeq seq3;\n+\n+  void print() {\n+    if (seq1.num() > 0) {\n+      print(seq1, \"seq1\");\n+    }\n+    if (seq2.num() > 0) {\n+      print(seq2, \"seq2\");\n+    }\n+    if (seq3.num() > 0) {\n+      print(seq3, \"seq3\");\n+    }\n+  }\n+\n+  void print(HdrSeq& seq, const char* msg) {\n+    std::cout << \"[\";\n+    for (int i = 0; i <= 100; i += 10) {\n+      std::cout << \"\\t\" << seq.percentile(i);\n+    }\n+    std::cout << \" ] : \" << msg << \"\\n\";\n+  }\n+};\n+\n+class BasicShenandoahNumberSeqTest: public ShenandoahNumberSeqTest {\n+ public:\n+  BasicShenandoahNumberSeqTest() {\n+    seq1.add(0);\n+    seq1.add(1);\n+    seq1.add(10);\n+    for (int i = 0; i < 7; i++) {\n+      seq1.add(100);\n+    }\n+    ShenandoahNumberSeqTest::print();\n+  }\n+};\n+\n+class ShenandoahNumberSeqMergeTest: public ShenandoahNumberSeqTest {\n+ public:\n+  ShenandoahNumberSeqMergeTest() {\n+    for (int i = 0; i < 80; i++) {\n+      seq1.add(1);\n+      seq3.add(1);\n+    }\n+\n+    for (int i = 0; i < 20; i++) {\n+      seq2.add(100);\n+      seq3.add(100);\n+    }\n+    ShenandoahNumberSeqTest::print();\n+  }\n+};\n+\n+TEST_VM_F(BasicShenandoahNumberSeqTest, maximum_test) {\n+  EXPECT_EQ(seq1.maximum(), 100);\n+}\n+\n+TEST_VM_F(BasicShenandoahNumberSeqTest, minimum_test) {\n+  EXPECT_EQ(0, seq1.percentile(0));\n+}\n+\n+TEST_VM_F(BasicShenandoahNumberSeqTest, percentile_test) {\n+  EXPECT_NEAR(0, seq1.percentile(10), err);\n+  EXPECT_NEAR(1, seq1.percentile(20), err);\n+  EXPECT_NEAR(10, seq1.percentile(30), err);\n+  EXPECT_NEAR(100, seq1.percentile(40), err);\n+  EXPECT_NEAR(100, seq1.percentile(50), err);\n+  EXPECT_NEAR(100, seq1.percentile(75), err);\n+  EXPECT_NEAR(100, seq1.percentile(90), err);\n+  EXPECT_NEAR(100, seq1.percentile(100), err);\n+}\n+\n+TEST_VM_F(ShenandoahNumberSeqMergeTest, merge_test) {\n+  EXPECT_EQ(seq1.num(), 80);\n+  EXPECT_EQ(seq2.num(), 20);\n+  EXPECT_FALSE(isnan(seq2.davg()));  \/\/ Exercise the path; not a nan\n+  EXPECT_FALSE(isnan(seq2.dsd()));\n+  EXPECT_FALSE(isnan(seq2.dvariance()));\n+\n+  std::cout << \"Pre-merge: \\n\";\n+  print();\n+  seq1.merge(seq2);    \/\/ clears seq1, after merging into seq2\n+  std::cout << \"Post-merge: \\n\";\n+  print();\n+\n+  EXPECT_EQ(seq1.num(), 0);\n+  EXPECT_EQ(seq2.num(), 100);\n+  EXPECT_EQ(seq2.num(), seq3.num());\n+  EXPECT_TRUE(isnan(seq2.davg()));  \/\/ until we fix decayed stats\n+  EXPECT_TRUE(isnan(seq2.dvariance()));\n+\n+  EXPECT_EQ(seq2.maximum(), seq3.maximum());\n+  EXPECT_EQ(seq2.percentile(0), seq3.percentile(0));\n+  for (int i = 0; i <= 100; i += 10) {\n+    EXPECT_NEAR(seq2.percentile(i), seq3.percentile(i), err);\n+  }\n+  EXPECT_NEAR(seq2.avg(), seq3.avg(), err);\n+  EXPECT_NEAR(seq2.sd(),  seq3.sd(),  err);\n+}\n","filename":"test\/hotspot\/gtest\/gc\/shenandoah\/test_shenandoahNumberSeq.cpp","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"}]}