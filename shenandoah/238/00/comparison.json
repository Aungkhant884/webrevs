{"files":[{"patch":"@@ -30,0 +30,1 @@\n+#include \"gc\/shenandoah\/shenandoahGeneration.hpp\"\n@@ -61,0 +62,25 @@\n+template <typename T>\n+static void card_mark_barrier(T* field, oop value) {\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  assert(heap->is_in_or_null(value), \"Should be in heap\");\n+  if (heap->mode()->is_generational() && heap->is_in_old(field) && heap->is_in_young(value)) {\n+    \/\/ We expect this to really be needed only during global collections. Young collections\n+    \/\/ discover j.l.r.Refs in the old generation during scanning of dirty cards\n+    \/\/ and these point to (as yet unmarked) referents in the young generation (see\n+    \/\/ ShenandoahReferenceProcessor::should_discover). Those cards will continue to\n+    \/\/ remain dirty on account of this cross-generational pointer to the referent.\n+    \/\/ Similarly, old collections will never discover j.l.r.Refs in the young generation.\n+    \/\/ It is only global collections that discover in both generations. Here we can\n+    \/\/ end up with a j.l.R in the old generation on the discovered list that\n+    \/\/ is not already on a dirty card, but which may here end up with a successor in\n+    \/\/ the discovered list that is in the young generation. This is the singular case\n+    \/\/ where the card needs to be dirtied here. We, however, skip the extra global'ness check\n+    \/\/ and always mark the card (redundantly during young collections).\n+    \/\/ The asserts below check the expected invariants based on the description above.\n+    assert(!heap->active_generation()->is_old(), \"Expecting only young or global\");\n+    assert(heap->card_scan()->is_card_dirty(reinterpret_cast<HeapWord*>(field))\n+           || heap->active_generation()->is_global(), \"Expecting already dirty if young\");\n+    heap->card_scan()->mark_card_as_dirty(reinterpret_cast<HeapWord*>(field));\n+  }\n+}\n+\n@@ -67,0 +93,1 @@\n+  card_mark_barrier(field, value);\n@@ -72,0 +99,1 @@\n+  card_mark_barrier(field, value);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahReferenceProcessor.cpp","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"}]}