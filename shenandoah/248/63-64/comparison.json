{"files":[{"patch":"@@ -331,3 +331,6 @@\n-\/\/ Return conservative estimate of how much memory can be allocated before we need to start GC\n-size_t ShenandoahAdaptiveHeuristics::evac_slack(size_t young_regions_to_be_reclaimed) {\n-  assert(_generation->is_young(), \"evac_slack is only meaningful for young-gen heuristic\");\n+\/\/ Return a conservative estimate of how much memory can be allocated before we need to start GC. The estimate is based\n+\/\/ on memory that is currently available within young generation plus all of the memory that will be added to the young\n+\/\/ generation at the end of the current cycle (as represented by young_regions_to_be_reclaimed) and on the anticipated\n+\/\/ amount of time required to perform a GC.\n+size_t ShenandoahAdaptiveHeuristics::bytes_of_allocation_runway_before_gc_trigger(size_t young_regions_to_be_reclaimed) {\n+  assert(_generation->is_young(), \"Only meaningful for young-gen heuristic\");\n@@ -364,1 +367,1 @@\n-  \/\/ thus, avg_evac_slack is MIN2(0,  available - avg_cycle_time * avg_alloc_rate + penalties + spike_headroom)\n+  \/\/ thus, evac_slack_avg is MIN2(0,  available - avg_cycle_time * avg_alloc_rate + penalties + spike_headroom)\n@@ -366,2 +369,2 @@\n-  \/\/ similarly, spike_evac_slack is MIN2(0, available - avg_cycle_time * rate + penalties + spike_headroom)\n-  \/\/ but spike_evac_slack is only relevant if is_spiking, as defined below.\n+  \/\/ similarly, evac_slack_spiking is MIN2(0, available - avg_cycle_time * rate + penalties + spike_headroom)\n+  \/\/ but evac_slack_spiking is only relevant if is_spiking, as defined below.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.cpp","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-  virtual size_t evac_slack(size_t young_regions_to_be_recycled);\n+  virtual size_t bytes_of_allocation_runway_before_gc_trigger(size_t young_regions_to_be_recycled);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -103,0 +103,22 @@\n+\/\/ Preselect for inclusion into the collection set regions whose age is at or above tenure age which contain more than\n+\/\/ ShenandoahOldGarbageThreshold amounts of garbage.  We identify these regions by setting the appropriate entry of\n+\/\/ candidate_regions_for_promotion_by_copy[] to true.  All entries are initialized to false before calling this\n+\/\/ function.\n+\/\/\n+\/\/ During the subsequent selection of the collection set, we give priority to these promotion set candidates.\n+\/\/ Without this prioritization, we found that the aged regions tend to be ignored because they typically have\n+\/\/ much less garbage and much more live data than the recently allocated \"eden\" regions.  When aged regions are\n+\/\/ repeatedly excluded from the collection set, the amount of live memory within the young generation tends to\n+\/\/ accumulate and this has the undesirable side effect of causing young-generation collections to require much more\n+\/\/ CPU and wall-clock time.\n+\/\/\n+\/\/ A second benefit of treating aged regions differently than other regions during collection set selection is\n+\/\/ that this allows us to more accurately budget memory to hold the results of evacuation.  Memory for evacuation\n+\/\/ of aged regions must be reserved in the old generations.  Memory for evacuation of all other regions must be\n+\/\/ reserved in the young generation.\n+\/\/\n+\/\/ A side effect performed by this function is to tally up the number of regions and the number of live bytes\n+\/\/ that we plan to promote-in-place during the current GC cycle.  This information, which is stored with\n+\/\/ an invocation of heap->set_promotion_in_place_potential(), feeds into subsequent decisions about when to\n+\/\/ trigger the next GC and may identify special work to be done during this GC cycle if we choose to abbreviate it.\n+\/\/\n@@ -104,1 +126,2 @@\n-size_t ShenandoahHeuristics::select_aged_regions(size_t old_available, size_t num_regions, bool preselected_regions[]) {\n+size_t ShenandoahHeuristics::select_aged_regions(size_t old_available, size_t num_regions,\n+                                                 bool candidate_regions_for_promotion_by_copy[]) {\n@@ -211,1 +234,1 @@\n-        preselected_regions[region->index()] = true;\n+        candidate_regions_for_promotion_by_copy[region->index()] = true;\n@@ -346,1 +369,0 @@\n-\n@@ -539,2 +561,2 @@\n-size_t ShenandoahHeuristics::evac_slack(size_t young_regions_to_be_recycled) {\n-  assert(false, \"evac_slack() only implemented for young Adaptive Heuristics\");\n+size_t ShenandoahHeuristics::bytes_of_allocation_runway_before_gc_trigger(size_t young_regions_to_be_recycled) {\n+  assert(false, \"Only implemented for young Adaptive Heuristics\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.cpp","additions":27,"deletions":5,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -170,1 +170,1 @@\n-  virtual size_t select_aged_regions(size_t old_available, size_t num_regions, bool* preselected_regions);\n+  virtual size_t select_aged_regions(size_t old_available, size_t num_regions, bool candidate_regions_for_promotion_by_copy[]);\n@@ -183,1 +183,1 @@\n-  virtual size_t evac_slack(size_t region_to_be_recycled);\n+  virtual size_t bytes_of_allocation_runway_before_gc_trigger(size_t region_to_be_recycled);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -73,1 +73,1 @@\n-  size_t unfragmented_available = heap->old_generation()->free_unaffiliated_regions() * ShenandoahHeapRegion::region_size_bytes();\n+  size_t unfragmented_available = _old_generation->free_unaffiliated_regions() * ShenandoahHeapRegion::region_size_bytes();\n@@ -82,2 +82,2 @@\n-    assert(heap->old_generation()->available() > old_evacuation_budget, \"Cannot budget more than is available\");\n-    fragmented_available = heap->old_generation()->available() - unfragmented_available;\n+    assert(_old_generation->available() > old_evacuation_budget, \"Cannot budget more than is available\");\n+    fragmented_available = _old_generation->available() - unfragmented_available;\n@@ -348,1 +348,1 @@\n-  ((ShenandoahOldGeneration*) (heap->old_generation()))->set_live_bytes_after_last_mark(live_data);\n+  _old_generation->set_live_bytes_after_last_mark(live_data);\n@@ -512,2 +512,1 @@\n-    ShenandoahOldGeneration* old_gen = heap->old_generation();\n-    size_t old_gen_capacity = old_gen->max_capacity();\n+    size_t old_gen_capacity = _old_generation->max_capacity();\n@@ -523,4 +522,3 @@\n-    ShenandoahOldGeneration* old_gen = heap->old_generation();\n-    size_t used = old_gen->used();\n-    size_t used_regions_size = old_gen->used_regions_size();\n-    size_t used_regions = old_gen->used_regions();\n+    size_t used = _old_generation->used();\n+    size_t used_regions_size = _old_generation->used_regions_size();\n+    size_t used_regions = _old_generation->used_regions();\n@@ -540,3 +538,2 @@\n-    ShenandoahOldGeneration* old_gen = heap->old_generation();\n-    size_t current_usage = old_gen->used();\n-    size_t trigger_threshold = old_gen->usage_trigger_threshold();\n+    size_t current_usage = _old_generation->used();\n+    size_t trigger_threshold = _old_generation->usage_trigger_threshold();\n@@ -544,1 +541,1 @@\n-      size_t live_at_previous_old = old_gen->get_live_bytes_after_last_mark();\n+      size_t live_at_previous_old = _old_generation->get_live_bytes_after_last_mark();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.cpp","additions":11,"deletions":14,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -131,0 +131,6 @@\n+\/\/ This may be called by mutator threads.  We declare _success_full_gcs volatile to force the value not to be cached\n+\/\/ in a local register or variable by a mutator thread that is checking this value in a loop.\n+size_t ShenandoahCollectorPolicy::get_fullgc_count() const {\n+  return _success_full_gcs;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCollectorPolicy.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-  size_t _success_full_gcs;\n+  volatile size_t _success_full_gcs;\n@@ -91,0 +91,2 @@\n+  size_t get_fullgc_count() const;\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCollectorPolicy.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -370,2 +370,0 @@\n-\n-  heap->finish_fullgc();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1317,1 +1317,1 @@\n-    size_t original_fullgc_count = fullgc_count();\n+    size_t original_fullgc_count = shenandoah_policy()->get_fullgc_count();\n@@ -1323,1 +1323,2 @@\n-    while (result == nullptr && ((fullgc_count() == original_fullgc_count) || (tries <= ShenandoahOOMGCRetries))) {\n+    while (result == nullptr &&\n+           ((shenandoah_policy()->get_fullgc_count() == original_fullgc_count) || (tries <= ShenandoahOOMGCRetries))) {\n@@ -3068,4 +3069,4 @@\n-    \/\/ The computation of evac_slack is quite conservative so consider all of this available for transfer to old.\n-    \/\/ Note that transfer of humongous regions does not impact available.\n-    size_t evac_slack = young_generation()->heuristics()->evac_slack(young_cset_regions);\n-    adjust_generation_sizes_for_next_cycle(evac_slack, young_cset_regions, old_cset_regions);\n+    \/\/ The computation of bytes_of_allocation_runway_before_gc_trigger is quite conservative so consider all of this\n+    \/\/ available for transfer to old. Note that transfer of humongous regions does not impact available.\n+    size_t allocation_runway = young_generation()->heuristics()->bytes_of_allocation_runway_before_gc_trigger(young_cset_regions);\n+    adjust_generation_sizes_for_next_cycle(allocation_runway, young_cset_regions, old_cset_regions);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -395,9 +395,0 @@\n-\n-  void finish_fullgc() {\n-    Atomic::add(&_completed_fullgc_cycles, (size_t) 1);\n-  };\n-\n-  size_t fullgc_count() {\n-    return Atomic::load(&_completed_fullgc_cycles);\n-  };\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1055,0 +1055,2 @@\n+  \/\/ TODO: use an existing coalesce-and-fill function rather than\n+  \/\/ replicating the code here.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -152,2 +152,2 @@\n-  size_t evac_slack = heap->young_generation()->heuristics()->evac_slack(0);\n-  heap->adjust_generation_sizes_for_next_cycle(evac_slack, 0, 0);\n+  size_t allocation_runway = heap->young_generation()->heuristics()->bytes_of_allocation_runway_before_gc_trigger(0);\n+  heap->adjust_generation_sizes_for_next_cycle(allocation_runway, 0, 0);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGC.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}