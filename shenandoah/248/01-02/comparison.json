{"files":[{"patch":"@@ -204,1 +204,1 @@\n-        \/\/ they are to be promted in place.\n+        \/\/ they are to be promoted in place.\n@@ -246,2 +246,3 @@\n-  log_info(gc, ergo)(\"Chosen CSet evacuates old: \" SIZE_FORMAT \"%s, promoted: \" SIZE_FORMAT \"%s, young: \" SIZE_FORMAT \"%s\",\n-                     byte_size_in_proper_unit(collected_old),      proper_unit_for_byte_size(collected_old),\n+  log_info(gc, ergo)(\"Chosen CSet evacuates young: \" SIZE_FORMAT \"%s (of which at least: \" SIZE_FORMAT \"%s are to be promoted), \"\n+                     \"old: \" SIZE_FORMAT \"%s\",\n+                     byte_size_in_proper_unit(collected_young),    proper_unit_for_byte_size(collected_young),\n@@ -249,1 +250,1 @@\n-                     byte_size_in_proper_unit(collected_young),    proper_unit_for_byte_size(collected_young));\n+                     byte_size_in_proper_unit(collected_old),      proper_unit_for_byte_size(collected_old));\n@@ -368,12 +369,7 @@\n-  \/\/ TODO: There are other adjustments made in should_start_gc() to avg_cycle_time depending on degenerated cycles\n-  \/\/ and expansion of the live-memory set.  To be totally in sync with behavior of GC trigger, the estimate of\n-  \/\/ evacuation slack may want to incorporate the same adjustments.\n-\n-\n-  \/\/ TODO: Consider making conservative adjustments to avg_cycle_time, as in:\n-  \/\/   avg_cycle_time *= 2;\n-  \/\/ The observation is that GC time is approximately doubled when we perform promotions and\/or mixed evacuations.\n-  \/\/ If the caller takes action based on the value returned from evac_slack, the action will be to trigger promotion\n-  \/\/ and\/or mixed evacuation so double our understanding of cycle time.  Kelvin has experimented with this option.\n-  \/\/ While it reduces the likelihood of TLAB allocation failures, it also causes excessively conservative transfer\n-  \/\/ of memory to OLD, which ultimately prevents timely promotion of memory.\n+  \/\/ TODO: Consider making conservative adjustments to avg_cycle_time, such as: (avg_cycle_time *= 2) in cases where\n+  \/\/ we expect a longer-than-normal GC duration.  This includes mixed evacuations, evacuation that perform promotion\n+  \/\/ including promotion in place, and OLD GC bootstrap cycles.  It has been observed that these cycles sometimes\n+  \/\/ require twice or more the duration of \"normal\" GC cycles.  We have experimented with this approach.  While it\n+  \/\/ does appear to reduce the frequency of degenerated cycles due to late triggers, it also has the effect of reducing\n+  \/\/ evacuation slack so that there is less memory available to be transferred to OLD.  The result is that we\n+  \/\/ throttle promotion and it takes too long to move old objects out of the young generation.\n@@ -437,0 +433,22 @@\n+    if (available < min_threshold) {\n+      log_info(gc)(\"Trigger (%s): Free (\" SIZE_FORMAT \"%s) is below minimum threshold (\" SIZE_FORMAT \"%s)\",\n+                   _generation->name(),\n+                   byte_size_in_proper_unit(available), proper_unit_for_byte_size(available),\n+                   byte_size_in_proper_unit(min_threshold),       proper_unit_for_byte_size(min_threshold));\n+      return true;\n+    }\n+\n+    \/\/ Check if we need to learn a bit about the application\n+    const size_t max_learn = ShenandoahLearningSteps;\n+    if (_gc_times_learned < max_learn) {\n+      size_t init_threshold = capacity \/ 100 * ShenandoahInitFreeThreshold;\n+      if (available < init_threshold) {\n+        log_info(gc)(\"Trigger (%s): Learning \" SIZE_FORMAT \" of \" SIZE_FORMAT \". Free (\"\n+                     SIZE_FORMAT \"%s) is below initial threshold (\" SIZE_FORMAT \"%s)\",\n+                     _generation->name(), _gc_times_learned + 1, max_learn,\n+                     byte_size_in_proper_unit(available), proper_unit_for_byte_size(available),\n+                     byte_size_in_proper_unit(init_threshold),      proper_unit_for_byte_size(init_threshold));\n+        return true;\n+      }\n+    }\n+\n@@ -467,0 +485,3 @@\n+\n+\n+\n@@ -516,40 +537,0 @@\n-    if (available < min_threshold) {\n-      log_info(gc)(\"Trigger (%s): Free (\" SIZE_FORMAT \"%s) is below minimum threshold (\" SIZE_FORMAT \"%s)\",\n-                   _generation->name(),\n-                   byte_size_in_proper_unit(available), proper_unit_for_byte_size(available),\n-                   byte_size_in_proper_unit(min_threshold),       proper_unit_for_byte_size(min_threshold));\n-      return true;\n-    }\n-\n-    \/\/ Check if we need to learn a bit about the application\n-    const size_t max_learn = ShenandoahLearningSteps;\n-    if (_gc_times_learned < max_learn) {\n-      size_t init_threshold = capacity \/ 100 * ShenandoahInitFreeThreshold;\n-      if (available < init_threshold) {\n-        log_info(gc)(\"Trigger (%s): Learning \" SIZE_FORMAT \" of \" SIZE_FORMAT \". Free (\"\n-                     SIZE_FORMAT \"%s) is below initial threshold (\" SIZE_FORMAT \"%s)\",\n-                     _generation->name(), _gc_times_learned + 1, max_learn,\n-                     byte_size_in_proper_unit(available), proper_unit_for_byte_size(available),\n-                     byte_size_in_proper_unit(init_threshold),      proper_unit_for_byte_size(init_threshold));\n-        return true;\n-      }\n-    }\n-\n-    \/\/ TODO: Account for inherent delays in responding to GC triggers\n-    \/\/  1. It has been observed that delays of 200 ms or greater are common between the moment we return true from\n-    \/\/     should_start_gc() and the moment at which we begin execution of the concurrent reset phase.  Add this time into\n-    \/\/     the calculation of avg_cycle_time below.  (What is \"this time\"?  Perhaps we should remember recent history of\n-    \/\/     this delay for the running workload and use the maximum delay recently seen for \"this time\".)  These obervations\n-    \/\/     of long delays for this transition were from early in the development of generational mode.  They may have\n-    \/\/     resuilted from errors in the implementation which were subsequently fixed.  More recently, these long delays\n-    \/\/     have not been observed.\n-    \/\/  2. The frequency of inquiries to should_start_gc() is adaptive, ranging between ShenandoahControlIntervalMin and\n-    \/\/     ShenandoahControlIntervalMax.  The current control interval (or the max control interval) should also be added into\n-    \/\/     the calculation of avg_cycle_time below.\n-\n-    \/\/ Get through promotions and mixed evacuations as quickly as possible.  These cycles sometimes require significantly\n-    \/\/ more time than traditional young-generation cycles so start them up as soon as possible.  This is a \"mitigation\"\n-    \/\/ for the reality that old-gen and young-gen activities are not truly \"concurrent\".  If there is old-gen work to\n-    \/\/ be done, we start up the young-gen GC threads so they can do some of this old-gen work.  As implemented, promotion\n-    \/\/ gets priority over old-gen marking.\n-\n@@ -558,0 +539,6 @@\n+      \/\/ Get through promotions and mixed evacuations as quickly as possible.  These cycles sometimes require significantly\n+      \/\/ more time than traditional young-generation cycles so start them up as soon as possible.  This is a \"mitigation\"\n+      \/\/ for the reality that old-gen and young-gen activities are not truly \"concurrent\".  If there is old-gen work to\n+      \/\/ be done, we start up the young-gen GC threads so they can do some of this old-gen work.  As implemented, promotion\n+      \/\/ gets priority over old-gen marking.\n+\n@@ -653,1 +640,0 @@\n-  double sd = _rate.sd();\n@@ -655,0 +641,1 @@\n+  double sd = _rate.sd();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.cpp","additions":44,"deletions":57,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -96,1 +96,1 @@\n-    _young_available_bytes_collected += (r->end() - r->top()) * HeapWordSize;\n+    _young_available_bytes_collected += r->free();\n@@ -104,1 +104,1 @@\n-    _old_available_bytes_collected += (r->end() - r->top()) * HeapWordSize;\n+    _old_available_bytes_collected += r->free();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCollectionSet.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}