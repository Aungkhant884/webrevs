{"files":[{"patch":"@@ -516,26 +516,0 @@\n-  const char* msg;\n-  if (heap->mode()->is_generational()) {\n-    if (heap->cancelled_gc()) {\n-      msg = (generation == YOUNG) ? \"At end of Interrupted Concurrent Young GC\" :\n-                                    \"At end of Interrupted Concurrent Bootstrap GC\";\n-    } else {\n-      msg = (generation == YOUNG) ? \"At end of Concurrent Young GC\" :\n-                                    \"At end of Concurrent Bootstrap GC\";\n-      \/\/ We only record GC results if GC was successful\n-      ShenandoahMmuTracker* mmu_tracker = heap->mmu_tracker();\n-      if (generation == YOUNG) {\n-        if (heap->collection_set()->has_old_regions()) {\n-          bool mixed_is_done = (heap->old_heuristics()->unprocessed_old_collection_candidates() == 0);\n-          mmu_tracker->record_mixed(the_generation, GCId::current(), mixed_is_done);\n-        } else {\n-          mmu_tracker->record_young(the_generation, GCId::current());\n-        }\n-      } else {\n-        mmu_tracker->record_bootstrap(the_generation, GCId::current(), heap->collection_set()->has_old_regions());\n-      }\n-    }\n-  } else {\n-    msg = heap->cancelled_gc() ? \"At end of cancelled GC\" :\n-                                 \"At end of GC\";\n-  }\n-  heap->log_heap_status(msg);\n@@ -600,1 +574,1 @@\n-      service_concurrent_cycle(heap,young_generation, cause, true);\n+      service_concurrent_cycle(heap, young_generation, cause, true);\n@@ -739,1 +713,1 @@\n-void ShenandoahControlThread::service_concurrent_cycle(const ShenandoahHeap* heap,\n+void ShenandoahControlThread::service_concurrent_cycle(ShenandoahHeap* heap,\n@@ -755,0 +729,26 @@\n+  const char* msg;\n+  if (heap->mode()->is_generational()) {\n+    if (heap->cancelled_gc()) {\n+      msg = (generation->is_young()) ? \"At end of Interrupted Concurrent Young GC\" :\n+                                       \"At end of Interrupted Concurrent Bootstrap GC\";\n+    } else {\n+      msg = (generation->is_young()) ? \"At end of Concurrent Young GC\" :\n+                                       \"At end of Concurrent Bootstrap GC\";\n+      \/\/ We only record GC results if GC was successful\n+      ShenandoahMmuTracker* mmu_tracker = heap->mmu_tracker();\n+      if (generation->is_young()) {\n+        if (heap->collection_set()->has_old_regions()) {\n+          bool mixed_is_done = (heap->old_heuristics()->unprocessed_old_collection_candidates() == 0);\n+          mmu_tracker->record_mixed(generation, get_gc_id(), mixed_is_done);\n+        } else {\n+          mmu_tracker->record_young(generation, get_gc_id());\n+        }\n+      } else {\n+        mmu_tracker->record_bootstrap(generation, get_gc_id(), heap->collection_set()->has_old_regions());\n+      }\n+    }\n+  } else {\n+    msg = heap->cancelled_gc() ? \"At end of cancelled GC\" :\n+                                 \"At end of GC\";\n+  }\n+  heap->log_heap_status(msg);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":28,"deletions":28,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -91,0 +91,1 @@\n+  ShenandoahSharedFlag _humongous_alloc_failure_gc;\n@@ -194,1 +195,1 @@\n-  void service_concurrent_cycle(const ShenandoahHeap* heap,\n+  void service_concurrent_cycle(ShenandoahHeap* heap,\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -86,10 +86,1 @@\n-double ShenandoahMmuTracker::process_time_seconds() {\n-  double process_real_time(0.0), process_user_time(0.0), process_system_time(0.0);\n-  bool valid = os::getTimesSecs(&process_real_time, &process_user_time, &process_system_time);\n-  if (valid) {\n-    return process_user_time + process_system_time;\n-  }\n-  return 0.0;\n-}\n-\n-void ShenandoahMmuTracker::help_record_concurrent(ShenandoahGeneration* generation, uint gcid, const char *msg) {\n+void ShenandoahMmuTracker::update_utilization(ShenandoahGeneration* generation, uint gcid, const char *msg) {\n@@ -105,1 +96,1 @@\n-    double gc_cycle_duration = current - _most_recent_timestamp;\n+    double gc_cycle_period = current - _most_recent_timestamp;\n@@ -112,1 +103,1 @@\n-    _most_recent_gcu = gc_time \/ (_active_processors * gc_cycle_duration);\n+    _most_recent_gcu = gc_time \/ (_active_processors * gc_cycle_period);\n@@ -115,3 +106,3 @@\n-    _most_recent_mu = mutator_time \/ (_active_processors * gc_cycle_duration);\n-    log_info(gc, ergo)(\"At end of %s: GCU: %.1f%%, MU: %.1f%% for duration %.3fs\",\n-                       msg, _most_recent_gcu * 100, _most_recent_mu * 100, gc_cycle_duration);\n+    _most_recent_mu = mutator_time \/ (_active_processors * gc_cycle_period);\n+    log_info(gc, ergo)(\"At end of %s: GCU: %.1f%%, MU: %.1f%% during period of %.3fs\",\n+                       msg, _most_recent_gcu * 100, _most_recent_mu * 100, gc_cycle_period);\n@@ -122,1 +113,1 @@\n-  help_record_concurrent(generation, gcid, \"Concurrent Young GC\");\n+  update_utilization(generation, gcid, \"Concurrent Young GC\");\n@@ -127,5 +118,1 @@\n-  help_record_concurrent(generation, gcid, \"Bootstrap Old GC\");\n-  if (candidates_for_mixed) {\n-    _doing_mixed_evacuations = true;\n-  }\n-  \/\/ Else, there are no candidates for mixed evacuations, so we are not going to do mixed evacuations.\n+  update_utilization(generation, gcid, \"Bootstrap Old GC\");\n@@ -137,1 +124,3 @@\n-  double duration = os::elapsedTime() - _most_recent_timestamp;\n+  double now = os::elapsedTime();\n+  double duration = now - _most_recent_timestamp;\n+\n@@ -142,4 +131,1 @@\n-  if (has_old_candidates) {\n-    _doing_mixed_evacuations = true;\n-  }\n-  log_info(gc, ergo)(\"At end of %s: GC Utilization: %.1f%% for duration %.3fs (which is subsumed in next concurrent gc report)\",\n+  log_info(gc, ergo)(\"At end of %s: GCU: %.1f%%, MU: %.1f%% for duration %.3fs (totals to be subsumed in next gc report)\",\n@@ -147,1 +133,1 @@\n-                     _most_recent_gcu * 100, duration);\n+                     gcu * 100, mu * 100, duration);\n@@ -151,1 +137,1 @@\n-  help_record_concurrent(generation, gcid, \"Mixed Concurrent GC\");\n+  update_utilization(generation, gcid, \"Mixed Concurrent GC\");\n@@ -158,0 +144,1 @@\n+    \/\/ TODO: avoid making the call to record_degenerated() in the case that this degenerated upgraded to full gc.\n@@ -159,4 +146,1 @@\n-    help_record_concurrent(generation, gcid, \"Degenerated Bootstrap Old GC\");\n-    if (!is_mixed_done) {\n-      _doing_mixed_evacuations = true;\n-    }\n+    update_utilization(generation, gcid, \"Degenerated Bootstrap Old GC\");\n@@ -164,1 +148,1 @@\n-    help_record_concurrent(generation, gcid, \"Degenerated Young GC\");\n+    update_utilization(generation, gcid, \"Degenerated Young GC\");\n@@ -169,1 +153,1 @@\n-  help_record_concurrent(generation, gcid, \"Full GC\");\n+  update_utilization(generation, gcid, \"Full GC\");\n@@ -171,1 +155,0 @@\n-  _doing_mixed_evacuations = false;\n@@ -191,1 +174,1 @@\n-  log_info(gc)(\"Periodic Sample: Average GCU = %.3f%%, Average MU = %.3f%%\", gcu * 100, mu * 100);\n+  log_info(gc)(\"Periodic Sample: GCU = %.3f%%, MU = %.3f%% during most recent %.1fs\", gcu * 100, mu * 100, time_delta);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMmuTracker.cpp","additions":19,"deletions":36,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -54,1 +54,2 @@\n-  \/\/ For reporting utilization during most recent GC cycle\n+  \/\/ These variables hold recent snapshots of cumulative quantities that are used for calculating\n+  \/\/ CPU time consumed by GC and mutator threads during each GC cycle.\n@@ -61,1 +62,2 @@\n-  \/\/ For periodic MU\/GCU reports\n+  \/\/ These variables hold recent snapshots of cumulative quantities that are used for reporting\n+  \/\/ periodic consumption of CPU time by GC and mutator threads.\n@@ -70,1 +72,0 @@\n-  bool _doing_mixed_evacuations;\n@@ -75,2 +76,1 @@\n-  void help_record_concurrent(ShenandoahGeneration* generation, uint gcid, const char* msg);\n-  static double process_time_seconds();\n+  void update_utilization(ShenandoahGeneration* generation, uint gcid, const char* msg);\n@@ -87,1 +87,2 @@\n-  \/\/ GC utilization during this cycle.\n+  \/\/ GC utilization during this cycle.  Incremental efforts spent in an interrupted GC cycle will be accumulated into\n+  \/\/ the CPU time reports for the subsequent completed [degenerated or full] GC cycle.\n@@ -89,2 +90,3 @@\n-  \/\/ We may redundantly record degen and full, in which case the gcid will repeat.  We log these as FULL.\n-  \/\/ Full gets reported first.\n+  \/\/ We may redundantly record degen and full in the case that a degen upgrades to full.  When this happens, we will invoke\n+  \/\/ both record_full() and record_degenerated() with the same value of gcid.  record_full() is called first and the log\n+  \/\/ reports such a cycle as a FULL cycle.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMmuTracker.hpp","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"}]}