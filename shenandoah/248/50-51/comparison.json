{"files":[{"patch":"@@ -960,0 +960,12 @@\n+#undef KELVIN_TLAB\n+#ifdef KELVIN_TLAB\n+void kelvin_breakpoint(ShenandoahAllocRequest req) {\n+  if (req.type() == ShenandoahAllocRequest::_alloc_tlab) {\n+    ShenandoahHeapLocker locker(ShenandoahHeap::heap()->lock());\n+    ShenandoahHeap::heap()->log_heap_status(\"At TLAB allocation failure\");\n+    ShenandoahHeap::heap()->free_set()->log_status();\n+  }\n+}\n+#endif\n+\n+\n@@ -970,0 +982,3 @@\n+#ifdef KELVIN_TLAB\n+    kelvin_breakpoint(req);\n+#endif\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1086,1 +1086,2 @@\n-void ShenandoahFreeSet::rebuild() {\n+void ShenandoahFreeSet::rebuild(size_t young_cset_regions, size_t old_cset_regions) {\n+  shenandoah_assert_heaplocked();\n@@ -1088,0 +1089,54 @@\n+  size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n+\n+  size_t old_capacity = _heap->old_generation()->max_capacity();\n+  size_t old_available = _heap->old_generation()->available();\n+  size_t old_unaffiliated_regions = _heap->old_generation()->free_unaffiliated_regions();\n+  size_t young_capacity = _heap->young_generation()->max_capacity();\n+  size_t young_available = _heap->young_generation()->available();\n+  size_t young_unaffiliated_regions = _heap->old_generation()->free_unaffiliated_regions();\n+\n+#undef KELVIN_REBUILD\n+#ifdef KELVIN_REBUILD\n+  log_info(gc, free)(\"Rebuild free_set with old available: \" SIZE_FORMAT \" out of capacity: \" SIZE_FORMAT\n+                     \", young available: \" SIZE_FORMAT \" out of capacity: \" SIZE_FORMAT,\n+                     old_available, old_capacity, young_available, young_capacity);\n+  log_info(gc, free)(\"  young_unaffiliated: \" SIZE_FORMAT \", young_cset: \" SIZE_FORMAT \n+                     \", old_unaffiliated: \" SIZE_FORMAT \", old_cset: \" SIZE_FORMAT,\n+                     young_unaffiliated_regions, young_cset_regions, old_unaffiliated_regions, old_cset_regions);\n+#endif\n+\n+\n+  old_unaffiliated_regions += old_cset_regions;\n+  old_available += old_cset_regions * region_size_bytes;\n+  young_unaffiliated_regions += young_cset_regions;\n+  young_available += young_cset_regions * region_size_bytes;\n+\n+  \/\/ Consult old-region surplus and deficit to make adjustments to current generation capacities and availability.\n+  \/\/ The generation region transfers take place after we rebuild.\n+  size_t old_region_surplus = _heap->get_old_region_surplus();\n+  size_t old_region_deficit = _heap->get_old_region_deficit();\n+\n+#ifdef KELVIN_REBUILD\n+  log_info(gc, free)(\"old_region_surplus: \" SIZE_FORMAT \", old_region_deficit: \" SIZE_FORMAT,\n+                     old_region_surplus, old_region_deficit);\n+#endif\n+\n+  if (old_region_surplus > 0) {\n+    size_t xfer_bytes = old_region_surplus * region_size_bytes;\n+    assert(old_region_surplus <= old_unaffiliated_regions, \"Cannot transfer regions that are affiliated\");\n+    old_capacity -= xfer_bytes;\n+    old_available -= xfer_bytes;\n+    old_unaffiliated_regions -= old_region_surplus;\n+    young_capacity += xfer_bytes;\n+    young_available += xfer_bytes;\n+    young_unaffiliated_regions += old_region_surplus;\n+  } else if (old_region_deficit > 0) {\n+    size_t xfer_bytes = old_region_deficit * region_size_bytes;\n+    assert(old_region_deficit <= young_unaffiliated_regions, \"Cannot transfer regions that are affiliated\");\n+    old_capacity += xfer_bytes;\n+    old_available += xfer_bytes;\n+    old_unaffiliated_regions += old_region_deficit;\n+    young_capacity -= xfer_bytes;;\n+    young_available -= xfer_bytes;\n+    young_unaffiliated_regions -= old_region_deficit;\n+  }\n@@ -1089,1 +1144,0 @@\n-  shenandoah_assert_heaplocked();\n@@ -1104,0 +1158,10 @@\n+\n+#ifdef KELVIN_REBUILD\n+      log_info(gc, free)(\" ... has evacuation reserves: young_reserve \" SIZE_FORMAT \", promoted_reserve: \" SIZE_FORMAT\n+                         \", old evac reserve: \" SIZE_FORMAT, young_reserve, _heap->get_promoted_reserve(),\n+                         _heap->get_old_evac_reserve());\n+#endif\n+\n+      assert(old_reserve <= old_available,\n+             \"Cannot reserve (\" SIZE_FORMAT \" + \" SIZE_FORMAT\") more OLD than is available: \" SIZE_FORMAT,\n+             _heap->get_promoted_reserve(), _heap->get_old_evac_reserve(), old_available);\n@@ -1106,1 +1170,1 @@\n-      young_reserve = (_heap->young_generation()->max_capacity() * ShenandoahEvacReserve) \/ 100;\n+      young_reserve = (young_capacity * ShenandoahEvacReserve) \/ 100;\n@@ -1110,1 +1174,1 @@\n-      old_reserve = _heap->old_generation()->available();\n+      old_reserve = old_available;\n@@ -1113,1 +1177,12 @@\n-  reserve_regions(young_reserve, old_reserve);\n+  if (old_reserve > _free_sets.capacity_of(OldCollector)) {\n+    \/\/ Old available regions that have less than PLAB::min_size() of available memory are not placed into the OldCollector\n+    \/\/ free set.  Because of this, old_available may not have enough memory to represent the intended reserve.  Adjust\n+    \/\/ the reserve downward to account for this possibility. This loss is part of the reason why the original budget\n+    \/\/ was adjusted with ShenandoahOldEvacWaste and ShenandoahOldPromoWaste multipliers.\n+    if (old_reserve > _free_sets.capacity_of(OldCollector) + old_unaffiliated_regions * region_size_bytes) {\n+      old_reserve = _free_sets.capacity_of(OldCollector) + old_unaffiliated_regions * region_size_bytes;\n+    }\n+  }\n+  if (young_reserve > young_unaffiliated_regions * region_size_bytes) {\n+    young_reserve = young_unaffiliated_regions * region_size_bytes;\n+  }\n@@ -1115,0 +1190,1 @@\n+  reserve_regions(young_reserve, old_reserve);\n@@ -1126,1 +1202,25 @@\n-  for (size_t idx = _heap->num_regions() - 1; idx > 0; idx--) {\n+\n+#undef KELVIN_RESERVE\n+#ifdef KELVIN_RESERVE\n+  size_t old_unaffiliated = ShenandoahHeap::heap()->old_generation()->free_unaffiliated_regions();\n+  log_info(gc, free)(\"FreeSet reserve regions(young: \" SIZE_FORMAT \", old: \" SIZE_FORMAT \"), OldCollector capacity: \" SIZE_FORMAT\n+                     \", old unaffiliated regions: \" SIZE_FORMAT, to_reserve, to_reserve_old,\n+                     _free_sets.capacity_of(OldCollector), old_unaffiliated);\n+  if (to_reserve_old > _free_sets.capacity_of(OldCollector)) {\n+    size_t more_old_required = to_reserve_old - _free_sets.capacity_of(OldCollector);\n+    if (more_old_required > old_unaffiliated * ShenandoahHeapRegion::region_size_bytes()) {\n+      log_info(gc, free)(\" old is in deficit by \" SIZE_FORMAT,\n+                         more_old_required - old_unaffiliated * ShenandoahHeapRegion::region_size_bytes());\n+    } else {\n+      log_info(gc, free)(\" old has sufficient by \" SIZE_FORMAT,\n+                         old_unaffiliated * ShenandoahHeapRegion::region_size_bytes() - more_old_required);\n+    }\n+  } else {\n+    log_info(gc, free)(\" old has excess \" SIZE_FORMAT,\n+                       old_unaffiliated * ShenandoahHeapRegion::region_size_bytes() + \n+                       (_free_sets.capacity_of(OldCollector) - to_reserve_old));\n+  }\n+#endif\n+\n+  for (size_t i = _heap->num_regions(); i > 0; i--) {\n+    size_t idx = i - 1;\n@@ -1164,0 +1264,11 @@\n+    size_t retired_young_waste = 0;\n+    size_t retired_old_waste = 0;\n+    size_t consumed_collector = 0;\n+    size_t consumed_old_collector = 0;\n+    size_t consumed_mutator = 0;\n+    size_t available_old = 0;\n+    size_t available_young = 0;\n+    size_t available_mutator = 0;\n+    size_t available_collector = 0;\n+    size_t available_old_collector = 0;\n+\n@@ -1187,1 +1298,4 @@\n-        buffer[idx] = (alloc_capacity(r) == region_size_bytes)? 'M': 'm';\n+        size_t capacity = alloc_capacity(r);\n+        available_mutator += capacity;\n+        consumed_mutator += region_size_bytes - capacity;\n+        buffer[idx] = (capacity == region_size_bytes)? 'M': 'm';\n@@ -1190,1 +1304,4 @@\n-        buffer[idx] = (alloc_capacity(r) == region_size_bytes)? 'C': 'c';\n+        size_t capacity = alloc_capacity(r);\n+        available_collector += capacity;\n+        consumed_collector += region_size_bytes - capacity;\n+        buffer[idx] = (capacity == region_size_bytes)? 'C': 'c';\n@@ -1192,1 +1309,4 @@\n-        buffer[idx] = (alloc_capacity(r) == region_size_bytes)? 'O': 'o';\n+        size_t capacity = alloc_capacity(r);\n+        available_old_collector += capacity;\n+        consumed_old_collector += region_size_bytes - capacity;\n+        buffer[idx] = (capacity == region_size_bytes)? 'O': 'o';\n@@ -1204,0 +1324,1 @@\n+          retired_old_waste += alloc_capacity(r);\n@@ -1207,0 +1328,1 @@\n+          retired_young_waste += alloc_capacity(r);\n@@ -1220,2 +1342,5 @@\n-    log_info(gc, free)(\"Retired young: \" SIZE_FORMAT \"%s (including humongous: \" SIZE_FORMAT \"%s), old: \" SIZE_FORMAT\n-                       \"%s (including humongous: \" SIZE_FORMAT \"%s)\",\n+#define KELVIN_LOG_STATUS\n+#ifdef KELVIN_LOG_STATUS\n+    log_info(gc, free)(\"Retired young: \" SIZE_FORMAT \"%s (including regular waste: \"\n+                       SIZE_FORMAT \"%s and humongous: \" SIZE_FORMAT \"%s); Retired old: \" SIZE_FORMAT\n+                       \"%s (including regular waste: \" SIZE_FORMAT \"%s and humongous: \" SIZE_FORMAT \"%s)\",\n@@ -1223,0 +1348,1 @@\n+                       byte_size_in_proper_unit(retired_young_waste),     proper_unit_for_byte_size(retired_young_waste),\n@@ -1225,0 +1351,1 @@\n+                       byte_size_in_proper_unit(retired_old_waste),       proper_unit_for_byte_size(retired_old_waste),\n@@ -1226,0 +1353,12 @@\n+    log_info(gc, free)(\"Free set young is mutator available: \" SIZE_FORMAT \" + mutator consumed: \" SIZE_FORMAT\n+                       \" + collector available: \" SIZE_FORMAT \" + collector consumed: \" SIZE_FORMAT\n+                       \" + regular retired: \" SIZE_FORMAT \" + humongous (with waste): \" SIZE_FORMAT \" = \" SIZE_FORMAT,\n+                       available_mutator, consumed_mutator, available_collector, consumed_collector,\n+                       retired_young, retired_young_humongous, \n+                       (available_mutator + consumed_mutator + available_collector + consumed_collector +\n+                        retired_young + retired_young_humongous));\n+    log_info(gc, free)(\"Free set OLD is old_collector available: \" SIZE_FORMAT \" + old_collector consumed: \" SIZE_FORMAT\n+                       \" + regular retired: \" SIZE_FORMAT \" + humongous (with waste): \" SIZE_FORMAT \" = \" SIZE_FORMAT,\n+                       available_old_collector, consumed_old_collector, retired_old, retired_old_humongous, \n+                       (available_old_collector + consumed_old_collector + retired_old + retired_old_humongous));\n+#endif\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":150,"deletions":11,"binary":false,"changes":161,"status":"modified"},{"patch":"@@ -200,1 +200,1 @@\n-  void rebuild();\n+  void rebuild(size_t young_cset_regions, size_t old_cset_regions);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1524,2 +1524,0 @@\n-    \/\/ We do not separately promote humongous after Full GC.  These have been handled by separate mechanism.\n-\n@@ -1542,1 +1540,1 @@\n-    heap->free_set()->rebuild();\n+    heap->free_set()->rebuild(young_cset_regions, old_cset_regions);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -510,1 +510,1 @@\n-    heap->free_set()->rebuild();\n+    heap->free_set()->rebuild(young_cset_regions, old_cset_regions);\n@@ -714,2 +714,8 @@\n-  size_t soft_capacity = max_capacity();\n-  return in_use > soft_capacity ? 0 : soft_capacity - in_use;\n+  size_t capacity = max_capacity();\n+  size_t result = in_use > capacity ? 0 : capacity - in_use;\n+#undef KELVIN_AVAILABLE\n+#ifdef KELVIN_AVAILABLE\n+  log_info(gc, free)(\"%s::available() returning \" SIZE_FORMAT \" as capacity: \" SIZE_FORMAT \" minus used: \" SIZE_FORMAT,\n+                     name(), result, capacity, in_use);\n+#endif\n+  return result;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -386,1 +386,1 @@\n-    _free_set->rebuild();\n+    _free_set->rebuild(young_cset_regions, old_cset_regions);\n@@ -591,0 +591,2 @@\n+  _old_regions_surplus(0),\n+  _old_regions_deficit(0),\n@@ -3090,1 +3092,1 @@\n-  _free_set->rebuild();\n+  _free_set->rebuild(young_cset_regions, old_cset_regions);\n@@ -3097,7 +3099,2 @@\n-    if (old_available >= old_unaffiliated_available) {\n-      old_fragmented_available = old_available - old_unaffiliated_available;\n-    } else {\n-      \/\/ WE SHOULD NOT NEED THIS CONDITIONAL CODE, BUT KELVIN HAS NOT\n-      \/\/ YET FIGURED OUT HOW THIS CONDITION IS VIOLATED.\n-      old_fragmented_available = 0;\n-    }\n+    old_fragmented_available = old_available - old_unaffiliated_available;\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -348,1 +348,1 @@\n-    heap->free_set()->rebuild();\n+    heap->free_set()->rebuild(cset_young_regions, cset_old_regions);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}