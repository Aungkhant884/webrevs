{"files":[{"patch":"@@ -258,1 +258,0 @@\n-      heap->set_alloc_supplement_reserve(0);\n@@ -769,3 +768,0 @@\n-    \/\/\n-    \/\/ heap->get_alloc_supplement_reserve() represents the amount of old-gen memory that can be allocated during evacuation\n-    \/\/ and update-refs phases of gc.  The young evacuation reserve has already been removed from this quantity.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -300,2 +300,0 @@\n-\n-    heap->set_alloc_supplement_reserve(0);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahDegeneratedGC.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -194,2 +194,2 @@\n-        \/\/ Note: unsigned result from adjusted_unaffiliated_regions() will never be less than zero, but it may equal zero.\n-        if (_heap->old_generation()->adjusted_unaffiliated_regions() <= 0) {\n+        \/\/ Note: unsigned result from free_unaffiliated_regions() will never be less than zero, but it may equal zero.\n+        if (_heap->old_generation()->free_unaffiliated_regions() <= 0) {\n@@ -201,2 +201,2 @@\n-        \/\/ Note: unsigned result from adjusted_unaffiliated_regions() will never be less than zero, but it may equal zero.\n-        if (_heap->young_generation()->adjusted_unaffiliated_regions() <= 0) {\n+        \/\/ Note: unsigned result from free_unaffiliated_regions() will never be less than zero, but it may equal zero.\n+        if (_heap->young_generation()->free_unaffiliated_regions() <= 0) {\n@@ -600,1 +600,1 @@\n-    size_t avail_young_regions = generation->adjusted_unaffiliated_regions();\n+    size_t avail_young_regions = generation->free_unaffiliated_regions();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -183,1 +183,1 @@\n-    assert(heap->old_generation()->used_regions_size() <= heap->old_generation()->adjusted_capacity(),\n+    assert(heap->old_generation()->used_regions_size() <= heap->old_generation()->soft_max_capacity(),\n@@ -185,1 +185,1 @@\n-    assert(heap->young_generation()->used_regions_size() <= heap->young_generation()->adjusted_capacity(),\n+    assert(heap->young_generation()->used_regions_size() <= heap->young_generation()->soft_max_capacity(),\n@@ -209,3 +209,0 @@\n-    \/\/ Defer unadjust_available() invocations until after Full GC finishes its efforts because Full GC makes use\n-    \/\/ of young-gen memory that may have been loaned from old-gen.\n-\n@@ -213,1 +210,0 @@\n-    heap->set_alloc_supplement_reserve(0);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -570,1 +570,1 @@\n-  _adjusted_capacity(soft_max_capacity), _heuristics(nullptr) {\n+  _heuristics(nullptr) {\n@@ -712,1 +712,1 @@\n-    result = 0;                 \/\/ If old-gen is loaning regions to young-gen, affiliated regions may exceed capacity temporarily.\n+    result = 0;\n@@ -729,35 +729,0 @@\n-size_t ShenandoahGeneration::adjust_available(intptr_t adjustment) {\n-  \/\/ TODO: ysr: remove this check & warning\n-  if (adjustment % ShenandoahHeapRegion::region_size_bytes() != 0) {\n-    log_warning(gc)(\"Adjustment (\" INTPTR_FORMAT \") should be a multiple of region size (\" SIZE_FORMAT \")\",\n-                    adjustment, ShenandoahHeapRegion::region_size_bytes());\n-  }\n-  assert(adjustment % ShenandoahHeapRegion::region_size_bytes() == 0,\n-         \"Adjustment to generation size must be multiple of region size\");\n-  _adjusted_capacity = soft_max_capacity() + adjustment;\n-  return _adjusted_capacity;\n-}\n-\n-size_t ShenandoahGeneration::unadjust_available() {\n-  _adjusted_capacity = soft_max_capacity();\n-  return _adjusted_capacity;\n-}\n-\n-size_t ShenandoahGeneration::adjusted_available() const {\n-  size_t in_use = used() + get_humongous_waste();\n-  size_t capacity = _adjusted_capacity;\n-  return in_use > capacity ? 0 : capacity - in_use;\n-}\n-\n-size_t ShenandoahGeneration::adjusted_capacity() const {\n-  return _adjusted_capacity;\n-}\n-\n-size_t ShenandoahGeneration::adjusted_unaffiliated_regions() const {\n-  assert(adjusted_capacity() >= used_regions_size(), \"adjusted_unaffiliated_regions() cannot return negative\");\n-  assert((adjusted_capacity() - used_regions_size()) % ShenandoahHeapRegion::region_size_bytes() == 0,\n-         \"adjusted capacity (\" SIZE_FORMAT \") and used regions size (\" SIZE_FORMAT \") should be multiples of region_size_bytes\",\n-         adjusted_capacity(), used_regions_size());\n-  return (adjusted_capacity() - used_regions_size()) \/ ShenandoahHeapRegion::region_size_bytes();\n-}\n-\n@@ -774,1 +739,0 @@\n-  _adjusted_capacity += increment;\n@@ -794,1 +758,0 @@\n-  _adjusted_capacity -= decrement;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":2,"deletions":39,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -61,2 +61,0 @@\n-  size_t _adjusted_capacity;\n-\n@@ -100,16 +98,0 @@\n-  \/\/ During evacuation and update-refs, some memory may be shifted between generations.  In particular, memory\n-  \/\/ may be loaned by old-gen to young-gen based on the promise the loan will be promptly repaid from the memory reclaimed\n-  \/\/ when the current collection set is recycled.  The capacity adjustment also takes into consideration memory that is\n-  \/\/ set aside within each generation to hold the results of evacuation, but not promotion, into that region.  Promotions\n-  \/\/ into old-gen are bounded by adjusted_available() whereas evacuations into old-gen are pre-committed.\n-  virtual size_t adjusted_available() const;\n-  virtual size_t adjusted_capacity() const;\n-\n-  \/\/ This is the number of FREE regions that are eligible to be affiliated with this generation according to the current\n-  \/\/ adjusted capacity.\n-  virtual size_t adjusted_unaffiliated_regions() const;\n-\n-  \/\/ Both of following return new value of available\n-  virtual size_t adjust_available(intptr_t adjustment);\n-  virtual size_t unadjust_available();\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.hpp","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -556,1 +556,0 @@\n-  _alloc_supplement_reserve(0),\n@@ -1341,1 +1340,1 @@\n-          size_t young_words_available = young_generation()->adjusted_available() \/ HeapWordSize;\n+          size_t young_words_available = young_generation()->available() \/ HeapWordSize;\n@@ -1881,1 +1880,1 @@\n-      return MIN2(ShenandoahHeapRegion::max_tlab_size_bytes(), young_generation()->adjusted_available());\n+      return MIN2(ShenandoahHeapRegion::max_tlab_size_bytes(), young_generation()->available());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -358,24 +358,1 @@\n-  \/\/ _alloc_supplement_reserve is a supplemental budget for new_memory allocations.  During evacuation and update-references,\n-  \/\/ mutator allocation requests are \"authorized\" iff young_gen->available() plus _alloc_supplement_reserve minus\n-  \/\/ _young_evac_reserve is greater than request size.  The values of _alloc_supplement_reserve and _young_evac_reserve\n-  \/\/ are zero except during evacuation and update-reference phases of GC.  Both of these values are established at\n-  \/\/ the start of evacuation, and they remain constant throughout the duration of these two phases of GC.  Since these\n-  \/\/ two values are constant throughout each GC phases, we introduce a new service into ShenandoahGeneration.  This service\n-  \/\/ provides adjusted_available() based on an adjusted capacity.  At the start of evacuation, we adjust young capacity by\n-  \/\/ adding the amount to be borrowed from old-gen and subtracting the _young_evac_reserve, we adjust old capacity by\n-  \/\/ subtracting the amount to be loaned to young-gen.\n-  \/\/\n-  \/\/ We always use adjusted capacities to determine permission to allocate within young and to promote into old.  Note\n-  \/\/ that adjusted capacities equal traditional capacities except during evacuation and update refs.\n-  \/\/\n-  \/\/ During evacuation, we assure that _old_evac_expended does not exceed _old_evac_reserve.\n-  \/\/\n-  \/\/ At the end of update references, we perform the following bookkeeping activities:\n-  \/\/\n-  \/\/ 1. Unadjust the capacity within young-gen and old-gen to undo the effects of borrowing memory from old-gen.  Note that\n-  \/\/    the entirety of the collection set is now available, so allocation capacity naturally increase at this time.\n-  \/\/ 2. Clear (reset to zero) _alloc_supplement_reserve, _young_evac_reserve, _old_evac_reserve, and _promoted_reserve\n-  \/\/\n-  \/\/ _young_evac_reserve and _old_evac_reserve are only non-zero during evacuation and update-references.\n-  \/\/\n-  \/\/ Allocation of old GCLABs assures that _old_evac_expended + request-size < _old_evac_reserved.  If the allocation\n+  \/\/ Allocation of old GCLABs (aka PLABs) assures that _old_evac_expended + request-size < _old_evac_reserved.  If the allocation\n@@ -384,0 +361,2 @@\n+  \/\/ TODO: The following comment is not entirely accurate, I believe.  Maybe it is not at all accurate.\n+  \/\/\n@@ -390,1 +369,0 @@\n-  intptr_t _alloc_supplement_reserve;  \/\/ Bytes reserved for young allocations during evac and update refs\n@@ -493,5 +471,0 @@\n-  \/\/ Returns previous value.  This is a signed value because it is the amount borrowed minus the amount reserved for\n-  \/\/ young-gen evacuation.  In case we cannot borrow much, this value might be negative.\n-  inline intptr_t set_alloc_supplement_reserve(intptr_t new_val);\n-  inline intptr_t get_alloc_supplement_reserve() const;\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":3,"deletions":30,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -804,10 +804,0 @@\n-inline intptr_t ShenandoahHeap::set_alloc_supplement_reserve(intptr_t new_val) {\n-  intptr_t orig = _alloc_supplement_reserve;\n-  _alloc_supplement_reserve = new_val;\n-  return orig;\n-}\n-\n-inline intptr_t ShenandoahHeap::get_alloc_supplement_reserve() const {\n-  return _alloc_supplement_reserve;\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.inline.hpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1010,1 +1010,1 @@\n-               (regions * ShenandoahHeapRegion::region_size_bytes() <= heap->young_generation()->adjusted_capacity()),\n+               (regions * ShenandoahHeapRegion::region_size_bytes() <= heap->young_generation()->soft_max_capacity()),\n@@ -1018,1 +1018,1 @@\n-               (regions * ShenandoahHeapRegion::region_size_bytes() <= heap->old_generation()->adjusted_capacity()),\n+               (regions * ShenandoahHeapRegion::region_size_bytes() <= heap->old_generation()->soft_max_capacity()),\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -438,1 +438,1 @@\n-    size_t generation_capacity = generation->adjusted_capacity();\n+    size_t generation_capacity = generation->soft_max_capacity();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVerifier.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}