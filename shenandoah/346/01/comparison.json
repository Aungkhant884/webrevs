{"files":[{"patch":"@@ -58,1 +58,1 @@\n-    runs-on: macos-11\n+    runs-on: macos-13\n","filename":".github\/workflows\/build-macos.yml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -149,2 +149,2 @@\n-      apt-extra-packages: 'libfreetype-dev:i386 libtiff-dev:i386 libcupsimage2-dev:i386 libc6-i386 libgcc-s1:i386 libstdc++6:i386'\n-      extra-conf-options: '--with-target-bits=32'\n+      apt-extra-packages: 'libfreetype-dev:i386 libtiff-dev:i386 libcupsimage2-dev:i386 libc6-i386 libgcc-s1:i386 libstdc++6:i386 libffi-dev:i386'\n+      extra-conf-options: '--with-target-bits=32 --enable-fallback-linker --enable-libffi-bundling'\n@@ -230,1 +230,1 @@\n-      xcode-toolset-version: '12.5.1'\n+      xcode-toolset-version: '14.3.1'\n@@ -241,1 +241,1 @@\n-      xcode-toolset-version: '12.5.1'\n+      xcode-toolset-version: '14.3.1'\n@@ -321,1 +321,1 @@\n-      runs-on: macos-11\n+      runs-on: macos-13\n","filename":".github\/workflows\/main.yml","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -135,1 +135,1 @@\n-          sudo xcode-select --switch \/Applications\/Xcode_11.7.app\/Contents\/Developer\n+          sudo xcode-select --switch \/Applications\/Xcode_14.3.1.app\/Contents\/Developer\n","filename":".github\/workflows\/test.yml","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -131,1 +131,1 @@\n-    # MACOSX_VERSION_MIN specifies the lowest version of Macosx that the built\n+    # MACOSX_VERSION_MIN specifies the lowest version of macOS that the built\n@@ -136,5 +136,1 @@\n-    if test \"x$OPENJDK_TARGET_CPU_ARCH\" = xaarch64; then\n-      MACOSX_VERSION_MIN=11.00.00\n-    else\n-      MACOSX_VERSION_MIN=10.12.0\n-    fi\n+    MACOSX_VERSION_MIN=11.00.00\n","filename":"make\/autoconf\/flags.m4","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -429,3 +429,8 @@\n-            dependencies: [\"devkit\", \"gtest\"],\n-            configure_args: concat(common.configure_args_32bit,\n-                \"--with-jvm-variants=minimal,server\", \"--with-zlib=system\"),\n+            dependencies: [\"devkit\", \"gtest\", \"libffi\"],\n+            configure_args: concat(common.configure_args_32bit, [\n+                \"--with-jvm-variants=minimal,server\",\n+                \"--with-zlib=system\",\n+                \"--with-libffi=\" + input.get(\"libffi\", \"home_path\"),\n+                \"--enable-libffi-bundling\",\n+                \"--enable-fallback-linker\"\n+            ])\n@@ -439,1 +444,1 @@\n-                \"--with-macosx-version-max=10.12.00\",\n+                \"--with-macosx-version-max=11.00.00\",\n","filename":"make\/conf\/jib-profiles.js","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -136,0 +136,15 @@\n+  # Set ASSERT, NDEBUG and PRODUCT flags just like in JvmFlags.gmk\n+  ifeq ($(DEBUG_LEVEL), release)\n+    # release builds disable uses of assert macro from <assert.h>.\n+    ADLCFLAGS += -DNDEBUG\n+    # For hotspot, release builds differ internally between \"optimized\" and \"product\"\n+    # in that \"optimize\" does not define PRODUCT.\n+    ifneq ($(HOTSPOT_DEBUG_LEVEL), optimized)\n+      ADLCFLAGS += -DPRODUCT\n+    endif\n+  else ifeq ($(DEBUG_LEVEL), fastdebug)\n+    ADLCFLAGS += -DASSERT\n+  else ifeq ($(DEBUG_LEVEL), slowdebug)\n+    ADLCFLAGS += -DASSERT\n+  endif\n+\n","filename":"make\/hotspot\/gensrc\/GensrcAdlc.gmk","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -230,1 +230,1 @@\n-                  $(call SET_SHARED_LIBRARY_ORIGIN), \\\n+                 $(call SET_SHARED_LIBRARY_ORIGIN), \\\n","filename":"make\/modules\/java.base\/Lib.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -922,13 +922,0 @@\n-# MACOSX_METAL_VERSION_MIN specifies the lowest version of Macosx\n-# that should be used to compile Metal shaders. We support Metal\n-# pipeline only on Macosx >=10.14. For Macosx versions <10.14 even if\n-# we enable Metal pipeline using -Dsun.java2d.metal=true, at\n-# runtime we force it to use OpenGL pipeline. And MACOSX_VERSION_MIN\n-# for aarch64 has always been >10.14 so we use continue to use\n-# MACOSX_VERSION_MIN for aarch64.\n-ifeq ($(OPENJDK_TARGET_CPU_ARCH), xaarch64)\n-    MACOSX_METAL_VERSION_MIN=$(MACOSX_VERSION_MIN)\n-else\n-    MACOSX_METAL_VERSION_MIN=10.14.0\n-endif\n-\n@@ -947,1 +934,1 @@\n-          -mmacosx-version-min=$(MACOSX_METAL_VERSION_MIN) \\\n+          -mmacosx-version-min=$(MACOSX_VERSION_MIN) \\\n","filename":"make\/modules\/java.desktop\/lib\/Awt2dLibraries.gmk","additions":1,"deletions":14,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -87,1 +87,3 @@\n-# sun.security.util is required to compile Cache benchmark\n+# sun.security.util is required to compile Cache benchmark.\n+# jmh uses annotation processors to generate the benchmark jar and thus\n+# requires the use of -processor option during benchmark compilation.\n@@ -109,1 +111,3 @@\n-        --enable-preview, \\\n+        --add-exports java.base\/jdk.internal.foreign=ALL-UNNAMED \\\n+        --enable-preview \\\n+        -processor org.openjdk.jmh.generators.BenchmarkProcessor, \\\n","filename":"make\/test\/BuildMicrobenchmark.gmk","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -168,1 +168,1 @@\n-  frame(intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, address pc, CodeBlob* cb);\n+  frame(intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, address pc, CodeBlob* cb, bool allow_cb_null = false);\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -94,1 +94,1 @@\n-inline frame::frame(intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, address pc, CodeBlob* cb) {\n+inline frame::frame(intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, address pc, CodeBlob* cb, bool allow_cb_null) {\n@@ -105,1 +105,1 @@\n-  assert(_cb != nullptr, \"pc: \" INTPTR_FORMAT, p2i(pc));\n+  assert(_cb != nullptr || allow_cb_null, \"pc: \" INTPTR_FORMAT, p2i(pc));\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"oops\/resolvedFieldEntry.hpp\"\n@@ -315,0 +316,30 @@\n+void InterpreterMacroAssembler::load_field_entry(Register cache, Register index, int bcp_offset) {\n+  \/\/ Get index out of bytecode pointer\n+  assert_different_registers(cache, index);\n+\n+  get_index_at_bcp(index, bcp_offset, cache \/*as tmp*\/, sizeof(u2));\n+\n+  \/\/ Scale the index to be the entry index * sizeof(ResolvedFieldEntry)\n+  \/\/ sizeof(ResolvedFieldEntry) is 16 on Arm, so using shift\n+  if (is_power_of_2(sizeof(ResolvedFieldEntry))) {\n+    \/\/ load constant pool cache pointer\n+    ldr(cache, Address(FP, frame::interpreter_frame_cache_offset * wordSize));\n+    \/\/ Get address of field entries array\n+    ldr(cache, Address(cache, in_bytes(ConstantPoolCache::field_entries_offset())));\n+\n+    add(cache, cache, Array<ResolvedFieldEntry>::base_offset_in_bytes());\n+    add(cache, cache, AsmOperand(index, lsl, log2i_exact(sizeof(ResolvedFieldEntry))));\n+  }\n+  else {\n+    mov(cache, sizeof(ResolvedFieldEntry));\n+    mul(index, index, cache);\n+    \/\/ load constant pool cache pointer\n+    ldr(cache, Address(FP, frame::interpreter_frame_cache_offset * wordSize));\n+\n+    \/\/ Get address of field entries array\n+    ldr(cache, Address(cache, in_bytes(ConstantPoolCache::field_entries_offset())));\n+    add(cache, cache, Array<ResolvedFieldEntry>::base_offset_in_bytes());\n+    add(cache, cache, index);\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/arm\/interp_masm_arm.cpp","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -105,0 +105,1 @@\n+  void load_field_entry(Register cache, Register index, int bcp_offset = 1);\n","filename":"src\/hotspot\/cpu\/arm\/interp_masm_arm.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+#include \"oops\/resolvedFieldEntry.hpp\"\n@@ -230,1 +231,10 @@\n-      __ get_cache_and_index_and_bytecode_at_bcp(bc_reg, temp_reg, temp_reg, byte_no, 1, sizeof(u2));\n+      __ load_field_entry(temp_reg, bc_reg);\n+      if (byte_no == f1_byte) {\n+        __ add(temp_reg, temp_reg, in_bytes(ResolvedFieldEntry::get_code_offset()));\n+      } else {\n+        __ add(temp_reg, temp_reg, in_bytes(ResolvedFieldEntry::put_code_offset()));\n+      }\n+      \/\/ Load-acquire the bytecode to match store-release in ResolvedFieldEntry::fill_in()\n+      __ ldrb(temp_reg, temp_reg);\n+      __ membar(MacroAssembler::Membar_mask_bits(MacroAssembler::LoadLoad | MacroAssembler::LoadStore), noreg, true);\n+\n@@ -2569,0 +2579,22 @@\n+  Bytecodes::Code code = bytecode();\n+  assert(byte_no == f1_byte || byte_no == f2_byte, \"byte_no out of range\");\n+  __ get_cache_and_index_and_bytecode_at_bcp(Rcache, Rindex, Rtemp, byte_no, 1, index_size);\n+  __ cmp(Rtemp, code);  \/\/ have we resolved this bytecode?\n+  __ b(resolved, eq);\n+\n+  \/\/ resolve first time through\n+  address entry = CAST_FROM_FN_PTR(address, InterpreterRuntime::resolve_from_cache);\n+  __ mov(R1, code);\n+  __ call_VM(noreg, entry, R1);\n+  \/\/ Update registers with resolved info\n+  __ get_cache_and_index_at_bcp(Rcache, Rindex, 1, index_size);\n+  __ bind(resolved);\n+}\n+\n+void TemplateTable::resolve_cache_and_index_for_field(int byte_no,\n+                                                      Register Rcache,\n+                                                      Register Rindex) {\n+  assert_different_registers(Rcache, Rindex, Rtemp);\n+\n+  Label resolved;\n+\n@@ -2577,1 +2609,11 @@\n-  __ get_cache_and_index_and_bytecode_at_bcp(Rcache, Rindex, Rtemp, byte_no, 1, index_size);\n+  __ load_field_entry(Rcache, Rindex);\n+  if (byte_no == f1_byte) {\n+    __ add(Rtemp, Rcache, in_bytes(ResolvedFieldEntry::get_code_offset()));\n+  } else {\n+    __ add(Rtemp, Rcache, in_bytes(ResolvedFieldEntry::put_code_offset()));\n+  }\n+\n+  \/\/ Load-acquire the bytecode to match store-release in ResolvedFieldEntry::fill_in()\n+  __ ldrb(Rtemp, Rtemp);\n+  __ membar(MacroAssembler::Membar_mask_bits(MacroAssembler::LoadLoad | MacroAssembler::LoadStore), noreg, true);\n+\n@@ -2586,1 +2628,1 @@\n-  __ get_cache_and_index_at_bcp(Rcache, Rindex, 1, index_size);\n+  __ load_field_entry(Rcache, Rindex);\n@@ -2590,0 +2632,25 @@\n+void TemplateTable::load_resolved_field_entry(Register obj,\n+                                              Register cache,\n+                                              Register tos_state,\n+                                              Register offset,\n+                                              Register flags,\n+                                              bool is_static = false) {\n+  assert_different_registers(cache, tos_state, flags, offset);\n+\n+  \/\/ Field offset\n+  __ ldr(offset, Address(cache, in_bytes(ResolvedFieldEntry::field_offset_offset())));\n+\n+  \/\/ Flags\n+  __ ldrb(flags, Address(cache, in_bytes(ResolvedFieldEntry::flags_offset())));\n+\n+  \/\/ TOS state\n+  __ ldrb(tos_state, Address(cache, in_bytes(ResolvedFieldEntry::type_offset())));\n+\n+  \/\/ Klass overwrite register\n+  if (is_static) {\n+    __ ldr(obj, Address(cache, ResolvedFieldEntry::field_holder_offset()));\n+    const int mirror_offset = in_bytes(Klass::java_mirror_offset());\n+    __ ldr(obj, Address(obj, mirror_offset));\n+    __ resolve_oop_handle(obj);\n+  }\n+}\n@@ -2745,2 +2812,2 @@\n-    __ add(R2, Rcache, AsmOperand(Rindex, lsl, LogBytesPerWord));\n-    __ add(R2, R2, in_bytes(ConstantPoolCache::base_offset()));\n+    __ load_field_entry(R2, Rindex);\n+\n@@ -2759,1 +2826,1 @@\n-    __ get_cache_and_index_at_bcp(Rcache, Rindex, 1);\n+    __ load_field_entry(Rcache, Rindex);\n@@ -2776,6 +2843,7 @@\n-  const Register Roffset  = R2_tmp;\n-  const Register Robj     = R3_tmp;\n-  const Register Rcache   = R4_tmp;\n-  const Register Rflagsav = Rtmp_save0;  \/\/ R4\/R19\n-  const Register Rindex   = R5_tmp;\n-  const Register Rflags   = R5_tmp;\n+  const Register Rcache = R4_tmp;\n+  const Register Rindex = R3_tmp;\n+\n+  const Register Roffset = R2_tmp;\n+  const Register Rtos_state = R3_tmp;\n+  const Register Robj = R4_tmp; \/\/ Rcache is free at the time of loading Robj\n+  const Register Rflags = R5_tmp;\n@@ -2783,1 +2851,1 @@\n-  resolve_cache_and_index(byte_no, Rcache, Rindex, sizeof(u2));\n+  resolve_cache_and_index_for_field(byte_no, Rcache, Rindex);\n@@ -2785,3 +2853,1 @@\n-  load_field_cp_cache_entry(Rcache, Rindex, Roffset, Rflags, Robj, is_static);\n-\n-  __ mov(Rflagsav, Rflags);\n+  load_resolved_field_entry(Robj, Rcache, Rtos_state, Roffset, Rflags, is_static);\n@@ -2789,1 +2855,3 @@\n-  if (!is_static) pop_and_check_object(Robj);\n+  if (!is_static) {\n+    pop_and_check_object(Robj);\n+  }\n@@ -2794,5 +2862,0 @@\n-  \/\/ compute type\n-  __ logical_shift_right(Rflags, Rflags, ConstantPoolCacheEntry::tos_state_shift);\n-  \/\/ Make sure we don't need to mask flags after the above shift\n-  ConstantPoolCacheEntry::verify_tos_state_shift();\n-\n@@ -2821,1 +2884,1 @@\n-  __ cmp(Rflags, itos);\n+  __ cmp(Rtos_state, itos);\n@@ -2823,1 +2886,1 @@\n-    __ cmp(Rflags, atos, ne);\n+    __ cmp(Rtos_state, atos, ne);\n@@ -2828,1 +2891,1 @@\n-    __ add(PC, PC, AsmOperand(Rflags, lsl, log_max_block_size + Assembler::LogInstructionSize), ne);\n+    __ add(PC, PC, AsmOperand(Rtos_state, lsl, log_max_block_size + Assembler::LogInstructionSize), ne);\n@@ -2830,1 +2893,1 @@\n-    __ ldr(PC, Address(PC, Rflags, lsl, LogBytesPerWord), ne);\n+    __ ldr(PC, Address(PC, Rtos_state, lsl, LogBytesPerWord), ne);\n@@ -2871,1 +2934,1 @@\n-    assert(ztos == seq++, \"btos has unexpected value\");\n+    assert(ztos == seq++, \"ztos has unexpected value\");\n@@ -2995,7 +3058,7 @@\n-  \/\/ Check for volatile field\n-  Label notVolatile;\n-  __ tbz(Rflagsav, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);\n-\n-  volatile_barrier(MacroAssembler::Membar_mask_bits(MacroAssembler::LoadLoad | MacroAssembler::LoadStore), Rtemp);\n-\n-  __ bind(notVolatile);\n+  {\n+    \/\/ Check for volatile field\n+    Label notVolatile;\n+    __ tbz(Rflags, ResolvedFieldEntry::is_volatile_shift, notVolatile);\n+    __ membar(MacroAssembler::Membar_mask_bits(MacroAssembler::LoadLoad | MacroAssembler::LoadStore), Rtemp);\n+    __ bind(notVolatile);\n+  }\n@@ -3032,0 +3095,2 @@\n+    __ mov(R2, Rcache);\n+\n@@ -3040,0 +3105,1 @@\n+      __ ldrb(R3, Address(Rcache, in_bytes(ResolvedFieldEntry::type_offset())));\n@@ -3041,9 +3107,2 @@\n-      __ add(Rtemp, Rcache, AsmOperand(Rindex, lsl, LogBytesPerWord));\n-      __ ldr_u32(Rtemp, Address(Rtemp, cp_base_offset + ConstantPoolCacheEntry::flags_offset()));\n-\n-      __ logical_shift_right(Rtemp, Rtemp, ConstantPoolCacheEntry::tos_state_shift);\n-      \/\/ Make sure we don't need to mask Rtemp after the above shift\n-      ConstantPoolCacheEntry::verify_tos_state_shift();\n-\n-      __ cmp(Rtemp, ltos);\n-      __ cond_cmp(Rtemp, dtos, ne);\n+      __ cmp(R3, ltos);\n+      __ cond_cmp(R3, dtos, ne);\n@@ -3057,4 +3116,0 @@\n-    \/\/ cache entry pointer\n-    __ add(R2, Rcache, AsmOperand(Rindex, lsl, LogBytesPerWord));\n-    __ add(R2, R2, in_bytes(cp_base_offset));\n-\n@@ -3069,1 +3124,1 @@\n-    __ get_cache_and_index_at_bcp(Rcache, Rindex, 1);\n+    __ load_field_entry(Rcache, Rindex);\n@@ -3079,6 +3134,7 @@\n-  const Register Roffset  = R2_tmp;\n-  const Register Robj     = R3_tmp;\n-  const Register Rcache   = R4_tmp;\n-  const Register Rflagsav = Rtmp_save0;  \/\/ R4\/R19\n-  const Register Rindex   = R5_tmp;\n-  const Register Rflags   = R5_tmp;\n+  const Register Rcache = R4_tmp;\n+  const Register Rindex = R3_tmp;\n+\n+  const Register Roffset = R2_tmp;\n+  const Register Rtos_state = R3_tmp;\n+  const Register Robj = R4_tmp; \/\/ Rcache is free at the time of loading Robj\n+  const Register Rflags = R5_tmp;\n@@ -3086,1 +3142,1 @@\n-  resolve_cache_and_index(byte_no, Rcache, Rindex, sizeof(u2));\n+  resolve_cache_and_index_for_field(byte_no, Rcache, Rindex);\n@@ -3088,1 +3144,1 @@\n-  load_field_cp_cache_entry(Rcache, Rindex, Roffset, Rflags, Robj, is_static);\n+  load_resolved_field_entry(Robj, Rcache, Rtos_state, Roffset, Rflags, is_static);\n@@ -3091,7 +3147,6 @@\n-  Label notVolatile;\n-  __ mov(Rflagsav, Rflags);\n-  __ tbz(Rflagsav, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);\n-\n-  volatile_barrier(MacroAssembler::Membar_mask_bits(MacroAssembler::StoreStore | MacroAssembler::LoadStore), Rtemp);\n-\n-  __ bind(notVolatile);\n+  {\n+    Label notVolatile;\n+    __ tbz(Rflags, ResolvedFieldEntry::is_volatile_shift, notVolatile);\n+    __ membar(MacroAssembler::Membar_mask_bits(MacroAssembler::StoreStore | MacroAssembler::LoadStore), Rtemp);\n+    __ bind(notVolatile);\n+  }\n@@ -3102,5 +3157,0 @@\n-  \/\/ compute type\n-  __ logical_shift_right(Rflags, Rflags, ConstantPoolCacheEntry::tos_state_shift);\n-  \/\/ Make sure we don't need to mask flags after the above shift\n-  ConstantPoolCacheEntry::verify_tos_state_shift();\n-\n@@ -3127,1 +3177,1 @@\n-  __ cmp(Rflags, itos);\n+  __ cmp(Rtos_state, itos);\n@@ -3131,1 +3181,1 @@\n-    __ add(PC, PC, AsmOperand(Rflags, lsl, log_max_block_size + Assembler::LogInstructionSize), ne);\n+    __ add(PC, PC, AsmOperand(Rtos_state, lsl, log_max_block_size + Assembler::LogInstructionSize), ne);\n@@ -3133,1 +3183,1 @@\n-    __ ldr(PC, Address(PC, Rflags, lsl, LogBytesPerWord), ne);\n+    __ ldr(PC, Address(PC, Rtos_state, lsl, LogBytesPerWord), ne);\n@@ -3270,1 +3320,1 @@\n-    assert(atos == seq++, \"dtos has unexpected value\");\n+    assert(atos == seq++, \"atos has unexpected value\");\n@@ -3296,26 +3346,5 @@\n-  Label notVolatile2;\n-  if (is_static) {\n-    \/\/ Just check for volatile. Memory barrier for static final field\n-    \/\/ is handled by class initialization.\n-    __ tbz(Rflagsav, ConstantPoolCacheEntry::is_volatile_shift, notVolatile2);\n-    volatile_barrier(MacroAssembler::StoreLoad, Rtemp);\n-    __ bind(notVolatile2);\n-  } else {\n-    \/\/ Check for volatile field and final field\n-    Label skipMembar;\n-\n-    __ tst(Rflagsav, 1 << ConstantPoolCacheEntry::is_volatile_shift |\n-           1 << ConstantPoolCacheEntry::is_final_shift);\n-    __ b(skipMembar, eq);\n-\n-    __ tbz(Rflagsav, ConstantPoolCacheEntry::is_volatile_shift, notVolatile2);\n-\n-    \/\/ StoreLoad barrier after volatile field write\n-    volatile_barrier(MacroAssembler::StoreLoad, Rtemp);\n-    __ b(skipMembar);\n-\n-    \/\/ StoreStore barrier after final field write\n-    __ bind(notVolatile2);\n-    volatile_barrier(MacroAssembler::StoreStore, Rtemp);\n-\n-    __ bind(skipMembar);\n+  {\n+    Label notVolatile;\n+    __ tbz(Rflags, ResolvedFieldEntry::is_volatile_shift, notVolatile);\n+    __ membar(MacroAssembler::Membar_mask_bits(MacroAssembler::StoreStore | MacroAssembler::LoadStore), Rtemp);\n+    __ bind(notVolatile);\n@@ -3361,1 +3390,1 @@\n-    __ get_cache_entry_pointer_at_bcp(R2, R1, 1);\n+    __ load_field_entry(R2, R1);\n@@ -3386,5 +3415,2 @@\n-  const Register Rcache  = R2_tmp;\n-  const Register Rindex  = R3_tmp;\n-  const Register Roffset = R3_tmp;\n-  const Register Rflags  = Rtmp_save0; \/\/ R4\/R19\n-  const Register Robj    = R5_tmp;\n+  const Register Rcache = R4_tmp;\n+  const Register Rindex = R3_tmp;\n@@ -3392,2 +3418,4 @@\n-  \/\/ access constant pool cache\n-  __ get_cache_and_index_at_bcp(Rcache, Rindex, 1);\n+  const Register Roffset = R2_tmp;\n+  const Register Rtos_state = R3_tmp;\n+  const Register Robj = R4_tmp;  \/\/ Rcache is free at the time of loading Robj\n+  const Register Rflags = R5_tmp;\n@@ -3395,1 +3423,3 @@\n-  __ add(Rcache, Rcache, AsmOperand(Rindex, lsl, LogBytesPerWord));\n+  \/\/ access constant pool cache\n+  __ load_field_entry(Rcache, Rindex);\n+  load_resolved_field_entry(Robj, Rcache, Rtos_state, Roffset, Rflags);\n@@ -3398,12 +3428,7 @@\n-  __ ldr_u32(Rflags, Address(Rcache, base + ConstantPoolCacheEntry::flags_offset()));\n-\n-  \/\/ replace index with field offset from cache entry\n-  __ ldr(Roffset, Address(Rcache, base + ConstantPoolCacheEntry::f2_offset()));\n-\n-  \/\/ Check for volatile store\n-  Label notVolatile;\n-  __ tbz(Rflags, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);\n-\n-  volatile_barrier(MacroAssembler::Membar_mask_bits(MacroAssembler::StoreStore | MacroAssembler::LoadStore), Rtemp);\n-\n-  __ bind(notVolatile);\n+  {\n+    \/\/ Check for volatile store\n+    Label notVolatile;\n+    __ tbz(Rflags, ResolvedFieldEntry::is_volatile_shift, notVolatile);\n+    __ membar(MacroAssembler::Membar_mask_bits(MacroAssembler::StoreStore | MacroAssembler::LoadStore), Rtemp);\n+    __ bind(notVolatile);\n+  }\n@@ -3449,15 +3474,7 @@\n-  Label notVolatile2;\n-  Label skipMembar;\n-  __ tst(Rflags, 1 << ConstantPoolCacheEntry::is_volatile_shift |\n-         1 << ConstantPoolCacheEntry::is_final_shift);\n-  __ b(skipMembar, eq);\n-\n-  __ tbz(Rflags, ConstantPoolCacheEntry::is_volatile_shift, notVolatile2);\n-\n-  \/\/ StoreLoad barrier after volatile field write\n-  volatile_barrier(MacroAssembler::StoreLoad, Rtemp);\n-  __ b(skipMembar);\n-\n-  \/\/ StoreStore barrier after final field write\n-  __ bind(notVolatile2);\n-  volatile_barrier(MacroAssembler::StoreStore, Rtemp);\n+  {\n+    \/\/ Check for volatile store\n+    Label notVolatile;\n+    __ tbz(Rflags, ResolvedFieldEntry::is_volatile_shift, notVolatile);\n+    __ membar(MacroAssembler::Membar_mask_bits(MacroAssembler::StoreStore | MacroAssembler::LoadStore), Rtemp);\n+    __ bind(notVolatile);\n+  }\n@@ -3465,1 +3482,0 @@\n-  __ bind(skipMembar);\n@@ -3479,1 +3495,1 @@\n-    __ get_cache_entry_pointer_at_bcp(R2, R1, 1);\n+    __ load_field_entry(R2, R1);\n@@ -3498,1 +3514,1 @@\n-  __ get_cache_and_index_at_bcp(Rcache, Rindex, 1);\n+  __ load_field_entry(Rcache, Rindex);\n@@ -3500,2 +3516,1 @@\n-  __ add(Rtemp, Rcache, AsmOperand(Rindex, lsl, LogBytesPerWord));\n-  __ ldr(Roffset, Address(Rtemp, ConstantPoolCache::base_offset() + ConstantPoolCacheEntry::f2_offset()));\n+  __ ldr(Roffset, Address(Rcache, ResolvedFieldEntry::field_offset_offset()));\n@@ -3504,1 +3519,1 @@\n-  __ ldr_u32(Rflags, Address(Rtemp, ConstantPoolCache::base_offset() + ConstantPoolCacheEntry::flags_offset()));\n+  __ ldrb(Rflags, Address(Rcache, ResolvedFieldEntry::flags_offset()));\n@@ -3507,1 +3522,1 @@\n-  __ null_check(Robj, Rtemp);\n+  __ null_check(Robj);\n@@ -3541,7 +3556,7 @@\n-  \/\/ Check for volatile load\n-  Label notVolatile;\n-  __ tbz(Rflags, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);\n-\n-  volatile_barrier(MacroAssembler::Membar_mask_bits(MacroAssembler::LoadLoad | MacroAssembler::LoadStore), Rtemp);\n-\n-  __ bind(notVolatile);\n+  {\n+    \/\/ Check for volatile load\n+    Label notVolatile;\n+    __ tbz(Rflags, ResolvedFieldEntry::is_volatile_shift, notVolatile);\n+    __ membar(MacroAssembler::Membar_mask_bits(MacroAssembler::LoadLoad | MacroAssembler::LoadStore), Rtemp);\n+    __ bind(notVolatile);\n+  }\n@@ -3565,3 +3580,2 @@\n-  __ get_cache_and_index_at_bcp(Rcache, Rindex, 2);\n-  __ add(Rtemp, Rcache, AsmOperand(Rindex, lsl, LogBytesPerWord));\n-  __ ldr(Roffset, Address(Rtemp, ConstantPoolCache::base_offset() + ConstantPoolCacheEntry::f2_offset()));\n+  __ load_field_entry(Rcache, Rindex, 2);\n+  __ ldr(Roffset, Address(Rcache, ResolvedFieldEntry::field_offset_offset()));\n@@ -3570,1 +3584,1 @@\n-  __ ldr_u32(Rflags, Address(Rtemp, ConstantPoolCache::base_offset() + ConstantPoolCacheEntry::flags_offset()));\n+  __ ldrb(Rflags, Address(Rcache, ResolvedFieldEntry::flags_offset()));\n@@ -3593,7 +3607,7 @@\n-  \/\/ Check for volatile load\n-  Label notVolatile;\n-  __ tbz(Rflags, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);\n-\n-  volatile_barrier(MacroAssembler::Membar_mask_bits(MacroAssembler::LoadLoad | MacroAssembler::LoadStore), Rtemp);\n-\n-  __ bind(notVolatile);\n+  {\n+    \/\/ Check for volatile load\n+    Label notVolatile;\n+    __ tbz(Rflags, ResolvedFieldEntry::is_volatile_shift, notVolatile);\n+    __ membar(MacroAssembler::Membar_mask_bits(MacroAssembler::LoadLoad | MacroAssembler::LoadStore), Rtemp);\n+    __ bind(notVolatile);\n+  }\n","filename":"src\/hotspot\/cpu\/arm\/templateTable_arm.cpp","additions":173,"deletions":159,"binary":false,"changes":332,"status":"modified"},{"patch":"@@ -1793,0 +1793,5 @@\n+  INSN(vsse8_v,  0b0100111, 0b000, 0b10, 0b0);\n+  INSN(vsse16_v, 0b0100111, 0b101, 0b10, 0b0);\n+  INSN(vsse32_v, 0b0100111, 0b110, 0b10, 0b0);\n+  INSN(vsse64_v, 0b0100111, 0b111, 0b10, 0b0);\n+\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1292,0 +1292,7 @@\n+  \/\/ rotate vector register left with shift bits, 32-bit version\n+  inline void vrole32_vi(VectorRegister vd, uint32_t shift, VectorRegister tmp_vr) {\n+    vsrl_vi(tmp_vr, vd, 32 - shift);\n+    vsll_vi(vd, vd, shift);\n+    vor_vv(vd, vd, tmp_vr);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -4280,0 +4280,136 @@\n+  \/**\n+   * Perform the quarter round calculations on values contained within four vector registers.\n+   *\n+   * @param aVec the SIMD register containing only the \"a\" values\n+   * @param bVec the SIMD register containing only the \"b\" values\n+   * @param cVec the SIMD register containing only the \"c\" values\n+   * @param dVec the SIMD register containing only the \"d\" values\n+   * @param tmp_vr temporary vector register holds intermedia values.\n+   *\/\n+  void chacha20_quarter_round(VectorRegister aVec, VectorRegister bVec,\n+                          VectorRegister cVec, VectorRegister dVec, VectorRegister tmp_vr) {\n+    \/\/ a += b, d ^= a, d <<<= 16\n+    __ vadd_vv(aVec, aVec, bVec);\n+    __ vxor_vv(dVec, dVec, aVec);\n+    __ vrole32_vi(dVec, 16, tmp_vr);\n+\n+    \/\/ c += d, b ^= c, b <<<= 12\n+    __ vadd_vv(cVec, cVec, dVec);\n+    __ vxor_vv(bVec, bVec, cVec);\n+    __ vrole32_vi(bVec, 12, tmp_vr);\n+\n+    \/\/ a += b, d ^= a, d <<<= 8\n+    __ vadd_vv(aVec, aVec, bVec);\n+    __ vxor_vv(dVec, dVec, aVec);\n+    __ vrole32_vi(dVec, 8, tmp_vr);\n+\n+    \/\/ c += d, b ^= c, b <<<= 7\n+    __ vadd_vv(cVec, cVec, dVec);\n+    __ vxor_vv(bVec, bVec, cVec);\n+    __ vrole32_vi(bVec, 7, tmp_vr);\n+  }\n+\n+  \/**\n+   * int com.sun.crypto.provider.ChaCha20Cipher.implChaCha20Block(int[] initState, byte[] result)\n+   *\n+   *  Input arguments:\n+   *  c_rarg0   - state, the starting state\n+   *  c_rarg1   - key_stream, the array that will hold the result of the ChaCha20 block function\n+   *\n+   *  Implementation Note:\n+   *   Parallelization is achieved by loading individual state elements into vectors for N blocks.\n+   *   N depends on single vector register length.\n+   *\/\n+  address generate_chacha20Block() {\n+    Label L_Rounds;\n+\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, \"StubRoutines\", \"chacha20Block\");\n+    address start = __ pc();\n+    __ enter();\n+\n+    const int states_len = 16;\n+    const int step = 4;\n+    const Register state = c_rarg0;\n+    const Register key_stream = c_rarg1;\n+    const Register tmp_addr = t0;\n+    const Register length = t1;\n+\n+    \/\/ Organize vector registers in an array that facilitates\n+    \/\/ putting repetitive opcodes into loop structures below.\n+    const VectorRegister work_vrs[16] = {\n+      v0, v1, v2,  v3,  v4,  v5,  v6,  v7,\n+      v8, v9, v10, v11, v12, v13, v14, v15\n+    };\n+    const VectorRegister tmp_vr = v16;\n+    const VectorRegister counter_vr = v17;\n+\n+    {\n+      \/\/ Put 16 here, as com.sun.crypto.providerChaCha20Cipher.KS_MAX_LEN is 1024\n+      \/\/ in java level.\n+      __ vsetivli(length, 16, Assembler::e32, Assembler::m1);\n+    }\n+\n+    \/\/ Load from source state.\n+    \/\/ Every element in source state is duplicated to all elements in the corresponding vector.\n+    __ mv(tmp_addr, state);\n+    for (int i = 0; i < states_len; i += 1) {\n+      __ vlse32_v(work_vrs[i], tmp_addr, zr);\n+      __ addi(tmp_addr, tmp_addr, step);\n+    }\n+    \/\/ Adjust counter for every individual block.\n+    __ vid_v(counter_vr);\n+    __ vadd_vv(work_vrs[12], work_vrs[12], counter_vr);\n+\n+    \/\/ Perform 10 iterations of the 8 quarter round set\n+    {\n+      const Register loop = t2; \/\/ share t2 with other non-overlapping usages.\n+      __ mv(loop, 10);\n+      __ BIND(L_Rounds);\n+\n+      chacha20_quarter_round(work_vrs[0], work_vrs[4], work_vrs[8],  work_vrs[12], tmp_vr);\n+      chacha20_quarter_round(work_vrs[1], work_vrs[5], work_vrs[9],  work_vrs[13], tmp_vr);\n+      chacha20_quarter_round(work_vrs[2], work_vrs[6], work_vrs[10], work_vrs[14], tmp_vr);\n+      chacha20_quarter_round(work_vrs[3], work_vrs[7], work_vrs[11], work_vrs[15], tmp_vr);\n+\n+      chacha20_quarter_round(work_vrs[0], work_vrs[5], work_vrs[10], work_vrs[15], tmp_vr);\n+      chacha20_quarter_round(work_vrs[1], work_vrs[6], work_vrs[11], work_vrs[12], tmp_vr);\n+      chacha20_quarter_round(work_vrs[2], work_vrs[7], work_vrs[8],  work_vrs[13], tmp_vr);\n+      chacha20_quarter_round(work_vrs[3], work_vrs[4], work_vrs[9],  work_vrs[14], tmp_vr);\n+\n+      __ sub(loop, loop, 1);\n+      __ bnez(loop, L_Rounds);\n+    }\n+\n+    \/\/ Add the original state into the end working state.\n+    \/\/ We do this by first duplicating every element in source state array to the corresponding\n+    \/\/ vector, then adding it to the post-loop working state.\n+    __ mv(tmp_addr, state);\n+    for (int i = 0; i < states_len; i += 1) {\n+      __ vlse32_v(tmp_vr, tmp_addr, zr);\n+      __ addi(tmp_addr, tmp_addr, step);\n+      __ vadd_vv(work_vrs[i], work_vrs[i], tmp_vr);\n+    }\n+    \/\/ Add the counter overlay onto work_vrs[12] at the end.\n+    __ vadd_vv(work_vrs[12], work_vrs[12], counter_vr);\n+\n+    \/\/ Store result to key stream.\n+    {\n+      const Register stride = t2; \/\/ share t2 with other non-overlapping usages.\n+      \/\/ Every block occupies 64 bytes, so we use 64 as stride of the vector store.\n+      __ mv(stride, 64);\n+      for (int i = 0; i < states_len; i += 1) {\n+        __ vsse32_v(work_vrs[i], key_stream, stride);\n+        __ addi(key_stream, key_stream, step);\n+      }\n+    }\n+\n+    \/\/ Return length of output key_stream\n+    __ slli(c_rarg0, length, 6);\n+\n+    __ leave();\n+    __ ret();\n+\n+    return (address) start;\n+  }\n+\n@@ -4499,0 +4635,5 @@\n+\n+    if (UseChaCha20Intrinsics) {\n+      StubRoutines::_chacha20Block = generate_chacha20Block();\n+    }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":141,"deletions":0,"binary":false,"changes":141,"status":"modified"},{"patch":"@@ -256,0 +256,10 @@\n+  if (UseRVV) {\n+    if (FLAG_IS_DEFAULT(UseChaCha20Intrinsics)) {\n+      FLAG_SET_DEFAULT(UseChaCha20Intrinsics, true);\n+    }\n+  } else if (UseChaCha20Intrinsics) {\n+    if (!FLAG_IS_DEFAULT(UseChaCha20Intrinsics)) {\n+      warning(\"Chacha20 intrinsic requires RVV instructions (not available on this CPU)\");\n+    }\n+    FLAG_SET_DEFAULT(UseChaCha20Intrinsics, false);\n+  }\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -143,1 +143,2 @@\n-      guarantee(is_in_range_of_RelAddr(target, pc, shortForm), \"target not within reach\");\n+      guarantee(is_in_range_of_RelAddr(target, pc, shortForm),\n+                \"target not within reach at \" INTPTR_FORMAT \", distance = \" INTX_FORMAT, p2i(pc), (target - pc) );\n","filename":"src\/hotspot\/cpu\/s390\/assembler_s390.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -104,1 +104,1 @@\n-    z_btrue(slow_case);\n+    branch_optimized(Assembler::bcondAllOne, slow_case);\n@@ -173,1 +173,1 @@\n-    z_brnz(slow_case);\n+    branch_optimized(Assembler::bcondNotZero, slow_case);\n","filename":"src\/hotspot\/cpu\/s390\/c1_MacroAssembler_s390.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"oops\/resolvedFieldEntry.hpp\"\n@@ -352,1 +353,1 @@\n-  \/\/ Get index out of bytecode pointer, get_cache_entry_pointer_at_bcp\n+  \/\/ Get index out of bytecode pointer.\n@@ -354,1 +355,2 @@\n-  \/\/ Get address of invokedynamic array\n+\n+  \/\/ Get the address of the ResolvedIndyEntry array\n@@ -357,2 +359,10 @@\n-  \/\/ Scale the index to be the entry index * sizeof(ResolvedInvokeDynamicInfo)\n-  z_sllg(index, index, exact_log2(sizeof(ResolvedIndyEntry)));\n+\n+  \/\/ Scale the index to form a byte offset into the ResolvedIndyEntry array\n+  size_t entry_size = sizeof(ResolvedIndyEntry);\n+  if (is_power_of_2(entry_size)) {\n+    z_sllg(index, index, exact_log2(entry_size));\n+  } else {\n+    z_mghi(index, entry_size);\n+  }\n+\n+  \/\/ Calculate the final field address.\n@@ -362,0 +372,20 @@\n+void InterpreterMacroAssembler::load_field_entry(Register cache, Register index, int bcp_offset) {\n+  \/\/ Get field index out of bytecode pointer.\n+  get_cache_index_at_bcp(index, bcp_offset, sizeof(u2));\n+\n+  \/\/ Get the address of the ResolvedFieldEntry array.\n+  get_constant_pool_cache(cache);\n+  z_lg(cache, Address(cache, in_bytes(ConstantPoolCache::field_entries_offset())));\n+\n+  \/\/ Scale the index to form a byte offset into the ResolvedFieldEntry array\n+  size_t entry_size = sizeof(ResolvedFieldEntry);\n+  if (is_power_of_2(entry_size)) {\n+    z_sllg(index, index, exact_log2(entry_size));\n+  } else {\n+    z_mghi(index, entry_size);\n+  }\n+\n+  \/\/ Calculate the final field address.\n+  z_la(cache, Array<ResolvedFieldEntry>::base_offset_in_bytes(), index, cache);\n+}\n+\n","filename":"src\/hotspot\/cpu\/s390\/interp_masm_s390.cpp","additions":34,"deletions":4,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -116,0 +116,1 @@\n+  void load_field_entry(Register cache, Register index, int bcp_offset = 1);\n","filename":"src\/hotspot\/cpu\/s390\/interp_masm_s390.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"oops\/resolvedFieldEntry.hpp\"\n@@ -79,4 +80,3 @@\n-    __ z_larl(Z_R0, (int64_t)0);     \/* Check current address alignment. *\/    \\\n-    __ z_slgr(Z_R0, br_tab);         \/* Current Address must be equal    *\/    \\\n-    __ z_slgr(Z_R0, flags);          \/* to calculated branch target.     *\/    \\\n-    __ z_brc(Assembler::bcondLogZero, 3); \/* skip trap if ok. *\/               \\\n+    __ z_larl(br_tab_temp, (int64_t)0);  \/* Check current address alignment. *\/\\\n+    __ z_slgr(br_tab_temp, br_tab);      \/* Current Address must be equal    *\/\\\n+    __ z_brc(Assembler::bcondLogZero, 3);\/* skip trap if ok. *\/                \\\n@@ -254,2 +254,6 @@\n-        __ get_cache_and_index_and_bytecode_at_bcp(Z_R1_scratch, bc_reg,\n-                                                   temp_reg, byte_no, 1);\n+\n+        \/\/ Both registers are block-local temp regs. Their contents before and after is not used.\n+        Register index = bc_reg;\n+        Register cache = temp_reg;\n+\n+        __ load_field_entry(cache, index);\n@@ -257,2 +261,7 @@\n-        __ compareU32_and_branch(temp_reg, (intptr_t)0,\n-                                 Assembler::bcondZero, L_patch_done);\n+\n+        if (byte_no == f1_byte) {\n+          __ z_cli(Address(cache, in_bytes(ResolvedFieldEntry::get_code_offset())), 0);\n+        } else {\n+          __ z_cli(Address(cache, in_bytes(ResolvedFieldEntry::put_code_offset())), 0);\n+        }\n+        __ z_bre(L_patch_done);\n@@ -263,1 +272,1 @@\n-      \/\/ The pair bytecodes have already done the load.\n+      \/\/ The bytecode pair may have already performed the load.\n@@ -271,2 +280,1 @@\n-\n-    Label   L_fast_patch;\n+    NearLabel L_fast_patch;\n@@ -277,0 +285,1 @@\n+\n@@ -281,1 +290,1 @@\n-                      temp_reg, Z_R13, bc_reg);\n+                      temp_reg, Z_bcp, bc_reg);\n@@ -2345,1 +2354,1 @@\n-\/\/ NOTE: Cpe_offset is already computed as byte offset, so we must not\n+\/\/ NOTE: index is already computed as byte offset, so we must not\n@@ -2349,1 +2358,1 @@\n-                                            Register cpe_offset,\n+                                            Register index,\n@@ -2351,5 +2360,0 @@\n-  BLOCK_COMMENT(\"resolve_cache_and_index {\");\n-  NearLabel      resolved, clinit_barrier_slow;\n-  const Register bytecode_in_cpcache = Z_R1_scratch;\n-  const int      total_f1_offset = in_bytes(ConstantPoolCache::base_offset() + ConstantPoolCacheEntry::f1_offset());\n-  assert_different_registers(cache, cpe_offset, bytecode_in_cpcache);\n@@ -2357,0 +2361,5 @@\n+  assert_different_registers(cache, index, Z_R1_scratch);\n+  assert(byte_no == f1_byte || byte_no == f2_byte, \"byte_no out of range\");\n+\n+  const Register  bytecode_in_cpcache = Z_R1_scratch;\n+  NearLabel       resolved, clinit_barrier_slow;\n@@ -2358,6 +2367,0 @@\n-  switch (code) {\n-    case Bytecodes::_nofast_getfield: code = Bytecodes::_getfield; break;\n-    case Bytecodes::_nofast_putfield: code = Bytecodes::_putfield; break;\n-    default:\n-      break;\n-  }\n@@ -2365,6 +2368,5 @@\n-  {\n-    assert(byte_no == f1_byte || byte_no == f2_byte, \"byte_no out of range\");\n-    __ get_cache_and_index_and_bytecode_at_bcp(cache, cpe_offset, bytecode_in_cpcache, byte_no, 1, index_size);\n-    \/\/ Have we resolved this bytecode?\n-    __ compare32_and_branch(bytecode_in_cpcache, (int)code, Assembler::bcondEqual, resolved);\n-  }\n+  BLOCK_COMMENT(\"resolve_cache_and_index {\");\n+\n+  __ get_cache_and_index_and_bytecode_at_bcp(cache, index, bytecode_in_cpcache, byte_no, 1, index_size);\n+  \/\/ Have we resolved this bytecode?\n+  __ compare32_and_branch(bytecode_in_cpcache, (int)code, Assembler::bcondEqual, resolved);\n@@ -2372,1 +2374,1 @@\n-  \/\/ Resolve first time through.\n+  \/\/ Resolve first time through via runtime call.\n@@ -2376,1 +2378,1 @@\n-  __ load_const_optimized(Z_ARG2, (int) code);\n+  __ load_const_optimized(Z_ARG2, (int)code);\n@@ -2378,1 +2380,0 @@\n-\n@@ -2380,1 +2381,2 @@\n-  __ get_cache_and_index_at_bcp(cache, cpe_offset, 1, index_size);\n+  __ get_cache_and_index_at_bcp(cache, index, 1, index_size);\n+\n@@ -2388,1 +2390,1 @@\n-    __ load_resolved_method_at_index(byte_no, cache, cpe_offset, method);\n+    __ load_resolved_method_at_index(byte_no, cache, index, method);\n@@ -2396,0 +2398,63 @@\n+void TemplateTable::resolve_cache_and_index_for_field(int byte_no,\n+                                                      Register cache,\n+                                                      Register index) {\n+\n+  assert_different_registers(cache, index);\n+  assert(byte_no == f1_byte || byte_no == f2_byte, \"byte_no out of range\");\n+\n+  NearLabel resolved;\n+\n+  Bytecodes::Code code = bytecode();\n+  switch (code) {\n+    case Bytecodes::_nofast_getfield: code = Bytecodes::_getfield; break;\n+    case Bytecodes::_nofast_putfield: code = Bytecodes::_putfield; break;\n+    default: break;\n+  }\n+\n+  __ load_field_entry(cache, index);\n+  if (byte_no == f1_byte) {\n+    __ z_cli(Address(cache, in_bytes(ResolvedFieldEntry::get_code_offset())), code);\n+  } else {\n+    __ z_cli(Address(cache, in_bytes(ResolvedFieldEntry::put_code_offset())), code);\n+  }\n+  __ z_bre(resolved);\n+\n+  \/\/ resolve first time through\n+  address entry = CAST_FROM_FN_PTR(address, InterpreterRuntime::resolve_from_cache);\n+  __ load_const_optimized(Z_ARG2, (int)code);\n+  __ call_VM(noreg, entry, Z_ARG2);\n+\n+  \/\/ Update registers with resolved info.\n+  __ load_field_entry(cache, index);\n+\n+  __ bind(resolved);\n+}\n+\n+\/\/ The cache register (the only input reg) must be set before call.\n+void TemplateTable::load_resolved_field_entry(Register obj,\n+                                              Register cache,\n+                                              Register tos_state,\n+                                              Register offset,\n+                                              Register flags,\n+                                              bool is_static = false) {\n+  assert_different_registers(cache, tos_state, flags, offset);\n+\n+  \/\/ Field offset\n+  __ load_sized_value(offset, Address(cache, in_bytes(ResolvedFieldEntry::field_offset_offset())), sizeof(int), true \/*is_signed*\/);\n+\n+  \/\/ Flags\n+  __ load_sized_value(flags, Address(cache, in_bytes(ResolvedFieldEntry::flags_offset())), sizeof(u1), false);\n+\n+  \/\/ TOS state\n+  if (tos_state != noreg) {\n+    __ load_sized_value(tos_state, Address(cache, in_bytes(ResolvedFieldEntry::type_offset())), sizeof(u1), false);\n+  }\n+\n+  \/\/ Klass overwrite register\n+  if (is_static) {\n+    __ load_sized_value(obj, Address(cache, ResolvedFieldEntry::field_holder_offset()), sizeof(void*), false);\n+    __ load_sized_value(obj, Address(obj, in_bytes(Klass::java_mirror_offset())), sizeof(void*), false);\n+    __ resolve_oop_handle(obj);\n+  }\n+}\n+\n@@ -2523,2 +2588,4 @@\n-\/\/ The registers cache and index expected to be set before call.\n-\/\/ Correct values of the cache and index registers are preserved.\n+\/\/ The registers cache and index are set up if needed.\n+\/\/ However, the field entry must have been resolved before.\n+\/\/ If no jvmti post operation is performed, their contents remains unchanged.\n+\/\/ After a jvmti post operation, the registers are re-calculated by load_field_entry().\n@@ -2537,1 +2604,1 @@\n-  Label exit;\n+  Label dontPost;\n@@ -2540,5 +2607,2 @@\n-  __ load_and_test_int(Z_R0, Address(Z_tos));\n-  __ z_brz(exit);\n-\n-  \/\/ Index is returned as byte offset, do not shift!\n-  __ get_cache_and_index_at_bcp(Z_ARG3, Z_R1_scratch, 1);\n+  __ z_chsi(0, Z_tos, 0); \/\/ avoid loading data into a scratch register\n+  __ z_bre(dontPost);\n@@ -2547,3 +2611,1 @@\n-  __ add2reg_with_index(Z_ARG3,\n-                        in_bytes(ConstantPoolCache::base_offset()),\n-                        Z_ARG3, Z_R1_scratch);\n+  \/\/ __ load_field_entry(cache, index); \/\/ not required as already set by resolve_cache_and_index_for_field()\n@@ -2554,1 +2616,1 @@\n-    __ mem2reg_opt(Z_ARG2, at_tos());  \/\/ Get object pointer without popping it.\n+    __ load_ptr(0, Z_ARG2);  \/\/ Get object pointer without popping it.\n@@ -2557,0 +2619,1 @@\n+\n@@ -2558,1 +2621,1 @@\n-  \/\/ Z_ARG3: cache entry pointer\n+  \/\/ cache:  cache entry pointer\n@@ -2561,2 +2624,1 @@\n-             Z_ARG2, Z_ARG3);\n-  __ get_cache_and_index_at_bcp(cache, index, 1);\n+             Z_ARG2, cache);\n@@ -2564,1 +2626,4 @@\n-  __ bind(exit);\n+  \/\/ restore registers after runtime call.\n+  __ load_field_entry(cache, index);\n+\n+  __ bind(dontPost);\n@@ -2576,6 +2641,14 @@\n-  const Register cache = Z_tmp_1;\n-  const Register index = Z_tmp_2;\n-  const Register obj   = Z_tmp_1;\n-  const Register off   = Z_ARG2;\n-  const Register flags = Z_ARG1;\n-  const Register bc    = Z_tmp_1;  \/\/ Uses same reg as obj, so don't mix them.\n+  const Register obj           = Z_tmp_1;\n+  const Register off           = Z_tmp_2;\n+  const Register cache         = Z_tmp_1;\n+  const Register index         = Z_tmp_2;\n+  const Register flags         = Z_R1_scratch; \/\/ flags are not used in getfield\n+  const Register br_tab        = Z_R1_scratch;\n+  const Register tos_state     = Z_ARG4;\n+  const Register bc_reg        = Z_tmp_1;\n+  const Register patch_tmp     = Z_ARG4;\n+  const Register oopLoad_tmp1  = Z_R1_scratch;\n+  const Register oopLoad_tmp2  = Z_ARG5;\n+#ifdef ASSERT\n+  const Register br_tab_temp   = Z_R0_scratch;  \/\/ for branch table verification code only\n+#endif\n@@ -2583,1 +2656,12 @@\n-  resolve_cache_and_index(byte_no, cache, index, sizeof(u2));\n+\n+  \/\/ Register usage and life range\n+  \/\/\n+  \/\/  cache, index          : short-lived. Their life ends after load_resolved_field_entry.\n+  \/\/  obj (overwrites cache): long-lived. Used in branch table entries.\n+  \/\/  off (overwrites index): long-lived. Used in branch table entries.\n+  \/\/  flags                 : unused in getfield.\n+  \/\/  br_tab                : short-lived. Only used to address branch table, and for verification in BTB_BEGIN macro.\n+  \/\/  tos_state             : short-lived. Only used to index the branch table entry.\n+  \/\/  bc_reg                : short-lived. Used as work register in patch_bytecode.\n+  \/\/\n+  resolve_cache_and_index_for_field(byte_no, cache, index);\n@@ -2585,1 +2669,1 @@\n-  load_field_cp_cache_entry(obj, cache, index, off, flags, is_static);\n+  load_resolved_field_entry(obj, cache, tos_state, off, flags, is_static);\n@@ -2592,1 +2676,1 @@\n-  \/\/ Displacement is 0, so any store instruction will be fine on any CPU.\n+  \/\/ Displacement is 0. No need to care about limited displacement range.\n@@ -2595,1 +2679,1 @@\n-  Label    is_Byte, is_Bool, is_Int, is_Short, is_Char,\n+  Label    is_Byte, is_Bool,  is_Int,    is_Short, is_Char,\n@@ -2597,3 +2681,2 @@\n-  Label    is_badState8, is_badState9, is_badStateA, is_badStateB,\n-           is_badStateC, is_badStateD, is_badStateE, is_badStateF,\n-           is_badState;\n+  Label    is_badState,  is_badState9, is_badStateA, is_badStateB,\n+           is_badStateC, is_badStateD, is_badStateE, is_badStateF;\n@@ -2601,1 +2684,0 @@\n-  Register br_tab       = Z_R1_scratch;\n@@ -2606,1 +2688,1 @@\n-  assert(btos == 0, \"change code, btos != 0\");\n+  assert((btos == 0) && (atos == 8), \"change branch table! ByteCodes may have changed\");\n@@ -2612,0 +2694,1 @@\n+  \/\/ Calculate branch table size.\n@@ -2618,3 +2701,0 @@\n-    const int r_bitpos  = 63 - bit_shift;\n-    const int l_bitpos  = r_bitpos - ConstantPoolCacheEntry::tos_state_bits + 1;\n-    const int n_rotate  = (bit_shift-ConstantPoolCacheEntry::tos_state_shift);\n@@ -2622,1 +2702,4 @@\n-    __ rotate_then_insert(flags, flags, l_bitpos, r_bitpos, n_rotate, true);\n+    __ z_sllg(tos_state, tos_state, bit_shift);\n+    assert(tos_state != Z_R0_scratch, \"shouldn't be\");\n+    __ z_agr(br_tab, tos_state);\n+    __ z_bcr(Assembler::bcondAlways, br_tab);\n@@ -2624,1 +2707,0 @@\n-  __ z_bc(Assembler::bcondAlways, 0, flags, br_tab);\n@@ -2635,1 +2717,1 @@\n-    patch_bytecode(Bytecodes::_fast_bgetfield, bc, Z_ARG5);\n+    patch_bytecode(Bytecodes::_fast_bgetfield, bc_reg, patch_tmp);\n@@ -2647,1 +2729,1 @@\n-    patch_bytecode(Bytecodes::_fast_bgetfield, bc, Z_ARG5);\n+    patch_bytecode(Bytecodes::_fast_bgetfield, bc_reg, patch_tmp);\n@@ -2659,1 +2741,1 @@\n-    patch_bytecode(Bytecodes::_fast_cgetfield, bc, Z_ARG5);\n+    patch_bytecode(Bytecodes::_fast_cgetfield, bc_reg, patch_tmp);\n@@ -2670,1 +2752,1 @@\n-    patch_bytecode(Bytecodes::_fast_sgetfield, bc, Z_ARG5);\n+    patch_bytecode(Bytecodes::_fast_sgetfield, bc_reg, patch_tmp);\n@@ -2681,1 +2763,1 @@\n-    patch_bytecode(Bytecodes::_fast_igetfield, bc, Z_ARG5);\n+    patch_bytecode(Bytecodes::_fast_igetfield, bc_reg, patch_tmp);\n@@ -2692,1 +2774,1 @@\n-    patch_bytecode(Bytecodes::_fast_lgetfield, bc, Z_ARG5);\n+    patch_bytecode(Bytecodes::_fast_lgetfield, bc_reg, patch_tmp);\n@@ -2703,1 +2785,1 @@\n-    patch_bytecode(Bytecodes::_fast_fgetfield, bc, Z_ARG5);\n+    patch_bytecode(Bytecodes::_fast_fgetfield, bc_reg, patch_tmp);\n@@ -2714,1 +2796,1 @@\n-    patch_bytecode(Bytecodes::_fast_dgetfield, bc, Z_ARG5);\n+    patch_bytecode(Bytecodes::_fast_dgetfield, bc_reg, patch_tmp);\n@@ -2725,4 +2807,0 @@\n-  BTB_BEGIN(is_badState8, bsize, \"getfield_or_static:is_badState8\");\n-  __ z_illtrap();\n-  __ z_bru(is_badState);\n-  BTB_END( is_badState8, bsize, \"getfield_or_static:is_badState8\");\n@@ -2732,1 +2810,1 @@\n-  BTB_END( is_badState9, bsize, \"getfield_or_static:is_badState9\");\n+  BTB_END(is_badState9, bsize, \"getfield_or_static:is_badState9\");\n@@ -2736,1 +2814,1 @@\n-  BTB_END( is_badStateA, bsize, \"getfield_or_static:is_badStateA\");\n+  BTB_END(is_badStateA, bsize, \"getfield_or_static:is_badStateA\");\n@@ -2740,1 +2818,1 @@\n-  BTB_END( is_badStateB, bsize, \"getfield_or_static:is_badStateB\");\n+  BTB_END(is_badStateB, bsize, \"getfield_or_static:is_badStateB\");\n@@ -2744,1 +2822,1 @@\n-  BTB_END( is_badStateC, bsize, \"getfield_or_static:is_badStateC\");\n+  BTB_END(is_badStateC, bsize, \"getfield_or_static:is_badStateC\");\n@@ -2748,1 +2826,1 @@\n-  BTB_END( is_badStateD, bsize, \"getfield_or_static:is_badStateD\");\n+  BTB_END(is_badStateD, bsize, \"getfield_or_static:is_badStateD\");\n@@ -2752,1 +2830,1 @@\n-  BTB_END( is_badStateE, bsize, \"getfield_or_static:is_badStateE\");\n+  BTB_END(is_badStateE, bsize, \"getfield_or_static:is_badStateE\");\n@@ -2756,1 +2834,1 @@\n-  BTB_END( is_badStateF, bsize, \"getfield_or_static:is_badStateF\");\n+  BTB_END(is_badStateF, bsize, \"getfield_or_static:is_badStateF\");\n@@ -2778,1 +2856,1 @@\n-    do_oop_load(_masm, field, Z_tos, Z_tmp_2, Z_tmp_3, IN_HEAP);\n+    do_oop_load(_masm, field, Z_tos, oopLoad_tmp1, oopLoad_tmp2, IN_HEAP);\n@@ -2782,1 +2860,1 @@\n-      patch_bytecode(Bytecodes::_fast_agetfield, bc, Z_ARG5);\n+      patch_bytecode(Bytecodes::_fast_agetfield, bc_reg, patch_tmp);\n@@ -2806,3 +2884,3 @@\n-\/\/ The registers cache and index expected to be set before call.  The\n-\/\/ function may destroy various registers, just not the cache and\n-\/\/ index registers.\n+\/\/ Register cache is expected to be set before the call.\n+\/\/ This function may destroy various registers.\n+\/\/ Only the contents of register cache is preserved\/restored.\n@@ -2819,6 +2897,4 @@\n-  \/\/ Check to see if a field modification watch has been set before\n-  \/\/ we take the time to call into the VM.\n-  Label    L1;\n-  ByteSize cp_base_offset = ConstantPoolCache::base_offset();\n-  assert_different_registers(cache, index, Z_tos);\n-\n+  \/\/ Check to see if a field modification watch has been set\n+  \/\/ before we take the time to call into the VM.\n+  Label    dontPost;\n+  assert_different_registers(cache, index, Z_tos, Z_ARG2, Z_ARG3, Z_ARG4);\n@@ -2826,2 +2902,6 @@\n-  __ load_and_test_int(Z_R0, Address(Z_tos));\n-  __ z_brz(L1);\n+  __ z_chsi(0, Z_tos, 0); \/\/ avoid loading data into a scratch register\n+  __ z_bre(dontPost);\n+\n+  Register obj        = Z_ARG2;\n+  Register fieldEntry = Z_ARG3;\n+  Register value      = Z_ARG4;\n@@ -2829,2 +2909,2 @@\n-  \/\/ Index is returned as byte offset, do not shift!\n-  __ get_cache_and_index_at_bcp(Z_ARG3, Z_R1_scratch, 1);\n+  \/\/ Take a copy of cache entry pointer\n+  __ z_lgr(fieldEntry, cache);\n@@ -2833,2 +2913,2 @@\n-    \/\/ Life is simple. Null out the object pointer.\n-    __ clear_reg(Z_ARG2, true, false);   \/\/ Don't set CC.\n+    \/\/ Life is simple. NULL the object pointer.\n+    __ clear_reg(obj, true, false); \/\/ Don't set CC.\n@@ -2840,9 +2920,1 @@\n-    __ mem2reg_opt(Z_ARG4,\n-                   Address(Z_ARG3, Z_R1_scratch,\n-                           in_bytes(cp_base_offset + ConstantPoolCacheEntry::flags_offset()) +\n-                           (BytesPerLong - BytesPerInt)),\n-                   false);\n-    __ z_srl(Z_ARG4, ConstantPoolCacheEntry::tos_state_shift);\n-    \/\/ Make sure we don't need to mask Z_ARG4 for tos_state after the above shift.\n-    ConstantPoolCacheEntry::verify_tos_state_shift();\n-    __ mem2reg_opt(Z_ARG2, at_tos(1));  \/\/ Initially assume a one word jvalue.\n+    __ load_sized_value(value, Address(fieldEntry, in_bytes(ResolvedFieldEntry::type_offset())), sizeof(u1), false);\n@@ -2850,1 +2922,1 @@\n-    NearLabel   load_dtos, cont;\n+    __ mem2reg_opt(obj, at_tos(1)); \/\/ Initially assume a one word jvalue.\n@@ -2852,4 +2924,7 @@\n-    __ compareU32_and_branch(Z_ARG4, (intptr_t) ltos,\n-                              Assembler::bcondNotEqual, load_dtos);\n-    __ mem2reg_opt(Z_ARG2, at_tos(2)); \/\/ ltos (two word jvalue)\n-    __ z_bru(cont);\n+    if (VM_Version::has_LoadStoreConditional()) {\n+      __ z_chi(value, ltos);\n+      __ z_locg(obj, at_tos(2), Assembler::bcondEqual);\n+      __ z_chi(value, dtos);\n+      __ z_locg(obj, at_tos(2), Assembler::bcondEqual);\n+    } else {\n+      NearLabel load_dtos, cont;\n@@ -2857,3 +2932,4 @@\n-    __ bind(load_dtos);\n-    __ compareU32_and_branch(Z_ARG4, (intptr_t)dtos, Assembler::bcondNotEqual, cont);\n-    __ mem2reg_opt(Z_ARG2, at_tos(2)); \/\/ dtos (two word jvalue)\n+      __ z_chi(value, ltos);\n+      __ z_brne(load_dtos);\n+      __ mem2reg_opt(obj, at_tos(2)); \/\/ ltos (two word jvalue)\n+      __ z_bru(cont);\n@@ -2861,3 +2937,4 @@\n-    __ bind(cont);\n-  }\n-  \/\/ cache entry pointer\n+      __ bind(load_dtos);\n+      __ z_chi(value, dtos);\n+      __ z_brne(cont);\n+      __ mem2reg_opt(obj, at_tos(2)); \/\/ dtos (two word jvalue)\n@@ -2865,1 +2942,3 @@\n-  __ add2reg_with_index(Z_ARG3, in_bytes(cp_base_offset), Z_ARG3, Z_R1_scratch);\n+      __ bind(cont);\n+    }\n+  }\n@@ -2868,4 +2947,4 @@\n-  __ load_address(Z_ARG4, Address(Z_esp, Interpreter::stackElementSize));\n-  \/\/ Z_ARG2: object pointer set up above (null if static)\n-  \/\/ Z_ARG3: cache entry pointer\n-  \/\/ Z_ARG4: jvalue object on the stack\n+  __ load_address(value, Address(Z_esp, Interpreter::expr_offset_in_bytes(0)));\n+  \/\/ obj:        object pointer set up above (null if static)\n+  \/\/ fieldEntry: field entry pointer\n+  \/\/ value:      jvalue object on the stack\n@@ -2874,2 +2953,1 @@\n-             Z_ARG2, Z_ARG3, Z_ARG4);\n-  __ get_cache_and_index_at_bcp(cache, index, 1);\n+             obj, fieldEntry, value);\n@@ -2877,1 +2955,4 @@\n-  __ bind(L1);\n+  \/\/ Reload field entry\n+  __ load_field_entry(cache, index);\n+\n+  __ bind(dontPost);\n@@ -2885,3 +2966,1 @@\n-  const Register cache         = Z_tmp_1;\n-  const Register index         = Z_ARG5;\n-  const Register obj           = Z_tmp_1;\n+  const Register obj           = Z_ARG5;\n@@ -2889,3 +2968,8 @@\n-  const Register flags         = Z_R1_scratch;\n-  const Register br_tab        = Z_ARG5;\n-  const Register bc            = Z_tmp_1;\n+  const Register cache         = Z_ARG5;\n+  const Register index         = Z_tmp_2;\n+  const Register fieldAddr     = Z_tmp_2;      \/\/ contains obj and off combined. Could be any address register.\n+  const Register flags         = Z_tmp_1;      \/\/ preserves flag value till the end, for volatility check\n+  const Register br_tab        = Z_R1_scratch;\n+  const Register tos_state     = Z_ARG4;\n+  const Register bc_reg        = Z_tmp_2;\n+  const Register patch_tmp     = Z_ARG4;\n@@ -2893,1 +2977,1 @@\n-  const Register oopStore_tmp2 = Z_ARG5;\n+  const Register oopStore_tmp2 = Z_ARG5;       \/\/ tmp2 must be non-volatile reg\n@@ -2895,0 +2979,3 @@\n+#ifdef ASSERT\n+  const Register br_tab_temp   = Z_R0_scratch; \/\/ for branch table verification code only\n+#endif\n@@ -2896,1 +2983,12 @@\n-  resolve_cache_and_index(byte_no, cache, index, sizeof(u2));\n+\/*\n+ *  Register usage and life range\n+ *\n+ *  cache, index          : short-lived. Their life ends after load_resolved_field_entry.\n+ *  obj (overwrites cache): very short-lived, Combined with off immediately.\n+ *  off (overwrites index): long-lived, Used in branch table entries.\n+ *  flags                 : long-lived, Has to survive until the end to determine volatility.\n+ *  br_tab                : short-lived, Only used to address branch table, and for verification in BTB_BEGIN macro.\n+ *  tos_state             : short-live, Only used to index the branch table entry.\n+ *  bc_reg                : short-lived, Used as work register in patch_bytecode.\n+*\/\n+  resolve_cache_and_index_for_field(byte_no, cache, index);\n@@ -2898,6 +2996,16 @@\n-  load_field_cp_cache_entry(obj, cache, index, off, flags, is_static);\n-  \/\/ begin of life for:\n-  \/\/   obj, off   long life range\n-  \/\/   flags      short life range, up to branch into branch table\n-  \/\/ end of life for:\n-  \/\/   cache, index\n+  load_resolved_field_entry(obj, cache, tos_state, off, flags, is_static);\n+\n+  const Address field(fieldAddr);\n+  __ lgr_if_needed(fieldAddr, off);\n+\n+  \/*\n+   * In the static case, we can calculate the final field address easily.\n+   * Do so to occupy only one non-volatile register\n+   * ---------------------\n+   * In the non-static case, we preset fieldAddr with the field offset.\n+   * The object address is available only later. It is popped from stack.\n+   * see pop_and_check_object(obj);\n+   *\/\n+  if (is_static) {\n+    __ z_agr(fieldAddr, obj);\n+  }\n@@ -2905,2 +3013,1 @@\n-  const Address field(obj, off);\n-  Label is_Byte, is_Bool, is_Int, is_Short, is_Char,\n+  Label is_Byte, is_Bool,  is_Int,    is_Short, is_Char,\n@@ -2908,3 +3015,2 @@\n-  Label is_badState8, is_badState9, is_badStateA, is_badStateB,\n-        is_badStateC, is_badStateD, is_badStateE, is_badStateF,\n-        is_badState;\n+  Label is_badState,  is_badState9, is_badStateA, is_badStateB,\n+        is_badStateC, is_badStateD, is_badStateE, is_badStateF;\n@@ -2916,2 +3022,1 @@\n-\n-  assert(btos == 0, \"change code, btos != 0\");\n+  assert((btos == 0) && (atos == 8), \"change branch table! ByteCodes may have changed\");\n@@ -2920,1 +3025,1 @@\n-  const unsigned int bsize = is_static ? BTB_MINSIZE*1 : BTB_MINSIZE*4;\n+  const unsigned int bsize = is_static ? BTB_MINSIZE*1 : BTB_MINSIZE*8;\n@@ -2928,3 +3033,0 @@\n-    const int r_bitpos  = 63 - bit_shift;\n-    const int l_bitpos  = r_bitpos - ConstantPoolCacheEntry::tos_state_bits + 1;\n-    const int n_rotate  = (bit_shift-ConstantPoolCacheEntry::tos_state_shift);\n@@ -2932,2 +3034,4 @@\n-    __ rotate_then_insert(flags, flags, l_bitpos, r_bitpos, n_rotate, true);\n-    __ z_bc(Assembler::bcondAlways, 0, flags, br_tab);\n+    __ z_sllg(tos_state, tos_state, bit_shift);\n+    assert(tos_state != Z_R0_scratch, \"shouldn't be\");\n+    __ z_agr(br_tab, tos_state);\n+    __ z_bcr(Assembler::bcondAlways, br_tab);\n@@ -2935,2 +3039,0 @@\n-  \/\/ end of life for:\n-  \/\/   flags, br_tab\n@@ -2946,0 +3048,1 @@\n+    __ z_agr(fieldAddr, obj);\n@@ -2949,1 +3052,1 @@\n-    patch_bytecode(Bytecodes::_fast_bputfield, bc, Z_ARG5, true, byte_no);\n+    patch_bytecode(Bytecodes::_fast_bputfield, bc_reg, patch_tmp, true, byte_no);\n@@ -2952,1 +3055,1 @@\n-  BTB_END( is_Byte, bsize, \"putfield_or_static:is_Byte\");\n+  BTB_END(is_Byte, bsize, \"putfield_or_static:is_Byte\");\n@@ -2959,0 +3062,1 @@\n+    __ z_agr(fieldAddr, obj);\n@@ -2963,1 +3067,1 @@\n-    patch_bytecode(Bytecodes::_fast_zputfield, bc, Z_ARG5, true, byte_no);\n+    patch_bytecode(Bytecodes::_fast_zputfield, bc_reg, patch_tmp, true, byte_no);\n@@ -2973,0 +3077,1 @@\n+    __ z_agr(fieldAddr, obj);\n@@ -2976,1 +3081,1 @@\n-    patch_bytecode(Bytecodes::_fast_cputfield, bc, Z_ARG5, true, byte_no);\n+    patch_bytecode(Bytecodes::_fast_cputfield, bc_reg, patch_tmp, true, byte_no);\n@@ -2979,1 +3084,1 @@\n-  BTB_END( is_Char, bsize, \"putfield_or_static:is_Char\");\n+  BTB_END(is_Char, bsize, \"putfield_or_static:is_Char\");\n@@ -2986,0 +3091,1 @@\n+    __ z_agr(fieldAddr, obj);\n@@ -2989,1 +3095,1 @@\n-    patch_bytecode(Bytecodes::_fast_sputfield, bc, Z_ARG5, true, byte_no);\n+    patch_bytecode(Bytecodes::_fast_sputfield, bc_reg, patch_tmp, true, byte_no);\n@@ -2992,1 +3098,1 @@\n-  BTB_END( is_Short, bsize, \"putfield_or_static:is_Short\");\n+  BTB_END(is_Short, bsize, \"putfield_or_static:is_Short\");\n@@ -2999,0 +3105,1 @@\n+    __ z_agr(fieldAddr, obj);\n@@ -3002,1 +3109,1 @@\n-    patch_bytecode(Bytecodes::_fast_iputfield, bc, Z_ARG5, true, byte_no);\n+    patch_bytecode(Bytecodes::_fast_iputfield, bc_reg, patch_tmp, true, byte_no);\n@@ -3005,1 +3112,1 @@\n-  BTB_END( is_Int, bsize, \"putfield_or_static:is_Int\");\n+  BTB_END(is_Int, bsize, \"putfield_or_static:is_Int\");\n@@ -3012,0 +3119,1 @@\n+    __ z_agr(fieldAddr, obj);\n@@ -3015,1 +3123,1 @@\n-    patch_bytecode(Bytecodes::_fast_lputfield, bc, Z_ARG5, true, byte_no);\n+    patch_bytecode(Bytecodes::_fast_lputfield, bc_reg, patch_tmp, true, byte_no);\n@@ -3018,1 +3126,1 @@\n-  BTB_END( is_Long, bsize, \"putfield_or_static:is_Long\");\n+  BTB_END(is_Long, bsize, \"putfield_or_static:is_Long\");\n@@ -3025,0 +3133,1 @@\n+    __ z_agr(fieldAddr, obj);\n@@ -3028,1 +3137,1 @@\n-    patch_bytecode(Bytecodes::_fast_fputfield, bc, Z_ARG5, true, byte_no);\n+    patch_bytecode(Bytecodes::_fast_fputfield, bc_reg, patch_tmp, true, byte_no);\n@@ -3031,1 +3140,1 @@\n-  BTB_END( is_Float, bsize, \"putfield_or_static:is_Float\");\n+  BTB_END(is_Float, bsize, \"putfield_or_static:is_Float\");\n@@ -3038,0 +3147,1 @@\n+    __ z_agr(fieldAddr, obj);\n@@ -3041,1 +3151,1 @@\n-    patch_bytecode(Bytecodes::_fast_dputfield, bc, Z_ARG5, true, byte_no);\n+    patch_bytecode(Bytecodes::_fast_dputfield, bc_reg, patch_tmp, true, byte_no);\n@@ -3044,1 +3154,1 @@\n-  BTB_END( is_Double, bsize, \"putfield_or_static:is_Double\");\n+  BTB_END(is_Double, bsize, \"putfield_or_static:is_Double\");\n@@ -3049,1 +3159,1 @@\n-  BTB_END( is_Object, bsize, \"putfield_or_static:is_Object\");\n+  BTB_END(is_Object, bsize, \"putfield_or_static:is_Object\");\n@@ -3052,4 +3162,0 @@\n-  BTB_BEGIN(is_badState8, bsize, \"putfield_or_static:is_badState8\");\n-  __ z_illtrap();\n-  __ z_bru(is_badState);\n-  BTB_END( is_badState8, bsize, \"putfield_or_static:is_badState8\");\n@@ -3059,1 +3165,1 @@\n-  BTB_END( is_badState9, bsize, \"putfield_or_static:is_badState9\");\n+  BTB_END(is_badState9, bsize, \"putfield_or_static:is_badState9\");\n@@ -3063,1 +3169,1 @@\n-  BTB_END( is_badStateA, bsize, \"putfield_or_static:is_badStateA\");\n+  BTB_END(is_badStateA, bsize, \"putfield_or_static:is_badStateA\");\n@@ -3067,1 +3173,1 @@\n-  BTB_END( is_badStateB, bsize, \"putfield_or_static:is_badStateB\");\n+  BTB_END(is_badStateB, bsize, \"putfield_or_static:is_badStateB\");\n@@ -3071,1 +3177,1 @@\n-  BTB_END( is_badStateC, bsize, \"putfield_or_static:is_badStateC\");\n+  BTB_END(is_badStateC, bsize, \"putfield_or_static:is_badStateC\");\n@@ -3075,1 +3181,1 @@\n-  BTB_END( is_badStateD, bsize, \"putfield_or_static:is_badStateD\");\n+  BTB_END(is_badStateD, bsize, \"putfield_or_static:is_badStateD\");\n@@ -3079,1 +3185,1 @@\n-  BTB_END( is_badStateE, bsize, \"putfield_or_static:is_badStateE\");\n+  BTB_END(is_badStateE, bsize, \"putfield_or_static:is_badStateE\");\n@@ -3083,1 +3189,1 @@\n-  BTB_END( is_badStateF, bsize, \"putfield_or_static:is_badStateF\");\n+  BTB_END(is_badStateF, bsize, \"putfield_or_static:is_badStateF\");\n@@ -3090,1 +3196,1 @@\n-    else            __ stop_static(\"Bad state in putfield\");\n+    else           __ stop_static(\"Bad state in putfield\");\n@@ -3105,0 +3211,1 @@\n+      __ z_agr(fieldAddr, obj);\n@@ -3107,1 +3214,1 @@\n-    do_oop_store(_masm, Address(obj, off), Z_tos,\n+    do_oop_store(_masm, field, Z_tos,\n@@ -3110,1 +3217,1 @@\n-      patch_bytecode(Bytecodes::_fast_aputfield, bc, Z_ARG5, true, byte_no);\n+      patch_bytecode(Bytecodes::_fast_aputfield, bc_reg, patch_tmp, true, byte_no);\n@@ -3119,1 +3226,2 @@\n-  Label notVolatile;\n+  \/\/ only if flags register is non-volatile\n+  NearLabel notVolatile;\n@@ -3121,1 +3229,2 @@\n-  __ testbit(Z_ARG4, ConstantPoolCacheEntry::is_volatile_shift);\n+  assert(flags.is_nonvolatile(), \"flags register needs to be non-volatile\");\n+  __ testbit(flags, ResolvedFieldEntry::is_volatile_shift);\n@@ -3123,0 +3232,1 @@\n+\n@@ -3152,4 +3262,0 @@\n-  \/\/ Check to see if a field modification watch has been set before\n-  \/\/ we take the time to call into the VM.\n-  Label   exit;\n-\n@@ -3158,4 +3264,6 @@\n-  __ load_absolute_address(Z_R1_scratch,\n-                           (address) JvmtiExport::get_field_modification_count_addr());\n-  __ load_and_test_int(Z_R0_scratch, Address(Z_R1_scratch));\n-  __ z_brz(exit);\n+  \/\/ Check to see if a field modification watch has been set\n+  \/\/ before we take the time to call into the VM.\n+  Label dontPost;\n+  __ load_absolute_address(Z_R1_scratch, (address)JvmtiExport::get_field_modification_count_addr());\n+  __ z_chsi(0, Z_R1_scratch, 0); \/\/ avoid loading data into a scratch register\n+  __ z_bre(dontPost);\n@@ -3163,1 +3271,3 @@\n-  Register obj = Z_tmp_1;\n+  Register obj        = Z_ARG2;\n+  Register fieldEntry = Z_ARG3;\n+  Register value      = Z_ARG4;\n@@ -3165,3 +3275,2 @@\n-  __ pop_ptr(obj);                  \/\/ Copy the object pointer from tos.\n-  __ verify_oop(obj);\n-  __ push_ptr(obj);                 \/\/ Put the object pointer back on tos.\n+  __ load_ptr(0, obj);              \/\/ Copy the object pointer from tos.\n+  __ verify_oop(obj);               \/\/ and verify it\n@@ -3198,1 +3307,1 @@\n-  __ load_address(Z_ARG4, Address(Z_esp, Interpreter::stackElementSize));\n+  __ load_address(value, Address(Z_esp, Interpreter::expr_offset_in_bytes(0)));\n@@ -3200,1 +3309,1 @@\n-  __ get_cache_entry_pointer_at_bcp(Z_ARG3, Z_tos, 1);\n+  __ load_field_entry(fieldEntry, Z_tos, 1);\n@@ -3203,3 +3312,3 @@\n-  \/\/ obj   : object pointer copied above\n-  \/\/ Z_ARG3: cache entry pointer\n-  \/\/ Z_ARG4: jvalue object on the stack\n+  \/\/ obj        : object pointer copied above\n+  \/\/ fieldEntry : cache entry pointer\n+  \/\/ value      : jvalue object on the stack\n@@ -3208,1 +3317,1 @@\n-             obj, Z_ARG3, Z_ARG4);\n+             obj, fieldEntry, value);\n@@ -3234,1 +3343,1 @@\n-  __ bind(exit);\n+  __ bind(dontPost);\n@@ -3241,1 +3350,0 @@\n-  ByteSize base = ConstantPoolCache::base_offset();\n@@ -3245,3 +3353,5 @@\n-  Register cache = Z_tmp_1;\n-  Register index = Z_tmp_2;\n-  Register flags = Z_ARG5;\n+  Register obj       = Z_tmp_1;\n+  Register cache     = Z_tmp_1;\n+  Register index     = Z_tmp_2;\n+  Register off       = Z_tmp_2;\n+  Register flags     = Z_ARG5;\n@@ -3250,9 +3360,3 @@\n-  __ get_cache_and_index_at_bcp(cache, index, 1);\n-\n-  \/\/ Test for volatile.\n-  assert(!flags->is_volatile(), \"do_oop_store could perform leaf RT call\");\n-  __ z_lg(flags, Address(cache, index, base + ConstantPoolCacheEntry::flags_offset()));\n-\n-  \/\/ Replace index with field offset from cache entry.\n-  Register field_offset = index;\n-  __ z_lg(field_offset, Address(cache, index, base + ConstantPoolCacheEntry::f2_offset()));\n+  __ load_field_entry(cache, index);\n+  \/\/ this call is for nonstatic. obj remains unchanged.\n+  load_resolved_field_entry(obj, cache, noreg, off, flags, false);\n@@ -3261,2 +3365,0 @@\n-  Register   obj = cache;\n-\n@@ -3266,1 +3368,1 @@\n-  const Address   field(obj, field_offset);\n+  const Address field(obj, off);\n@@ -3271,1 +3373,1 @@\n-      do_oop_store(_masm, Address(obj, field_offset), Z_tos,\n+      do_oop_store(_masm, field, Z_tos,\n@@ -3304,1 +3406,1 @@\n-  __ testbit(flags, ConstantPoolCacheEntry::is_volatile_shift);\n+  __ testbit(flags, ResolvedFieldEntry::is_volatile_shift);\n@@ -3314,1 +3416,1 @@\n-  Register obj = Z_tos;\n+  Register obj = Z_tos;  \/\/ Object ptr is in TOS\n@@ -3316,1 +3418,1 @@\n-  \/\/ Do the JVMTI work here to avoid disturbing the register state below\n+  \/\/ Do the JVMTI work here. There is no specific jvmti_post_fast_access() emitter.\n@@ -3318,3 +3420,6 @@\n-    \/\/ Check to see if a field access watch has been set before we\n-    \/\/ take the time to call into the VM.\n-    Label cont;\n+    \/\/ Check to see if a field modification watch has been set\n+    \/\/ before we take the time to call into the VM.\n+    BLOCK_COMMENT(\"jvmti_post_fast_field_access {\");\n+    Label    dontPost;\n+    Register cache = Z_ARG3;\n+    Register index = Z_tmp_2;\n@@ -3322,4 +3427,3 @@\n-    __ load_absolute_address(Z_R1_scratch,\n-                             (address)JvmtiExport::get_field_access_count_addr());\n-    __ load_and_test_int(Z_R0_scratch, Address(Z_R1_scratch));\n-    __ z_brz(cont);\n+    __ load_absolute_address(Z_R1_scratch, (address)JvmtiExport::get_field_access_count_addr());\n+    __ z_chsi(0, Z_R1_scratch, 0); \/\/ avoid loading data into a scratch register\n+    __ z_bre(dontPost);\n@@ -3328,0 +3432,1 @@\n+    __ load_field_entry(cache, index);\n@@ -3329,1 +3434,0 @@\n-    __ get_cache_entry_pointer_at_bcp(Z_ARG3, Z_tmp_1, 1);\n@@ -3335,1 +3439,1 @@\n-    \/\/ Z_ARG3: cache entry pointer\n+    \/\/ cache: cache entry pointer\n@@ -3338,1 +3442,1 @@\n-               Z_ARG2, Z_ARG3);\n+               Z_ARG2, cache);\n@@ -3341,1 +3445,2 @@\n-    __ bind(cont);\n+    __ bind(dontPost);\n+    BLOCK_COMMENT(\"} jvmti_post_fast_field_access\");\n@@ -3345,2 +3450,3 @@\n-  Register   cache = Z_tmp_1;\n-  Register   index = Z_tmp_2;\n+  Register cache = Z_tmp_1;\n+  Register index = Z_tmp_2;\n+  Register off   = Z_tmp_2;\n@@ -3349,1 +3455,1 @@\n-  __ get_cache_and_index_at_bcp(cache, index, 1);\n+  __ load_field_entry(cache, index);\n@@ -3351,3 +3457,1 @@\n-  __ mem2reg_opt(index,\n-                 Address(cache, index,\n-                         ConstantPoolCache::base_offset() + ConstantPoolCacheEntry::f2_offset()));\n+  __ load_sized_value(off, Address(cache, in_bytes(ResolvedFieldEntry::field_offset_offset())), sizeof(jint), true);\n@@ -3358,1 +3462,1 @@\n-  Address field(obj, index);\n+  Address field(obj, off);\n@@ -3402,0 +3506,1 @@\n+  Register off   = Z_tmp_2;\n@@ -3404,1 +3509,1 @@\n-  __ get_cache_and_index_at_bcp(cache, index, 2);\n+  __ load_field_entry(cache, index, 2);\n@@ -3406,3 +3511,1 @@\n-  __ mem2reg_opt(index,\n-                 Address(cache, index,\n-                         ConstantPoolCache::base_offset() + ConstantPoolCacheEntry::f2_offset()));\n+  __ load_sized_value(off, Address(cache, in_bytes(ResolvedFieldEntry::field_offset_offset())), sizeof(jint), true);\n@@ -3414,0 +3517,3 @@\n+\n+  Address field(receiver, off);\n+\n@@ -3416,1 +3522,1 @@\n-      __ mem2reg_opt(Z_tos, Address(receiver, index), false);\n+      __ mem2reg_opt(Z_tos, field, false);\n@@ -3419,1 +3525,1 @@\n-      do_oop_load(_masm, Address(receiver, index), Z_tos, Z_tmp_1, Z_tmp_2, IN_HEAP);\n+      do_oop_load(_masm, field, Z_tos, Z_tmp_1, Z_tmp_2, IN_HEAP);\n@@ -3423,1 +3529,1 @@\n-      __ mem2freg_opt(Z_ftos, Address(receiver, index));\n+      __ mem2freg_opt(Z_ftos, field);\n","filename":"src\/hotspot\/cpu\/s390\/templateTable_s390.cpp","additions":367,"deletions":261,"binary":false,"changes":628,"status":"modified"},{"patch":"@@ -4176,1 +4176,1 @@\n-  if (UseAVX > 2 && VM_Version::supports_avx512dq()) {\n+  if (VM_Version::is_intel() && VM_Version::supports_avx512dq()) {\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -772,1 +772,2 @@\n-  pthread_attr_init(&attr);\n+  int rslt = pthread_attr_init(&attr);\n+  guarantee(rslt == 0, \"pthread_attr_init has to return 0\");\n@@ -806,0 +807,1 @@\n+    pthread_attr_destroy(&attr);\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -914,1 +914,6 @@\n-  pthread_attr_init(&attr);\n+  int rslt = pthread_attr_init(&attr);\n+  if (rslt != 0) {\n+    thread->set_osthread(nullptr);\n+    delete osthread;\n+    return false;\n+  }\n@@ -963,0 +968,1 @@\n+    pthread_attr_destroy(&attr);\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -180,1 +180,1 @@\n-  return frame(fr->link(), fr->link(), fr->sender_pc());\n+  return frame(fr->sender_sp(), fr->link(), fr->sender_pc());\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/os_bsd_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -155,0 +155,10 @@\n+\/\/ The \"Procedure Call Standard for the Arm 64-bit Architecture\" doesn't\n+\/\/ specify a location for the frame record within a stack frame (6.4.6).\n+\/\/ GCC currently chooses to save it at the top of the frame (lowest address).\n+\/\/ This means that using fr->sender_sp() to set the caller's frame _unextended_sp,\n+\/\/ as we do in x86, is wrong. Using fr->link() instead only makes sense for\n+\/\/ native frames. Setting a correct value for _unextended_sp is important\n+\/\/ if this value is later used to get that frame's caller. This will happen\n+\/\/ if we end up calling frame::sender_for_compiled_frame(), which will be the\n+\/\/ case if the _pc is associated with a CodeBlob that has a _frame_size > 0\n+\/\/ (nmethod, runtime stub, safepoint stub, etc).\n@@ -156,1 +166,6 @@\n-  return frame(fr->link(), fr->link(), fr->sender_pc());\n+  address pc = fr->sender_pc();\n+  CodeBlob* cb = CodeCache::find_blob(pc);\n+  bool use_codeblob = cb != nullptr && cb->frame_size() > 0;\n+  assert(!use_codeblob || !Interpreter::contains(pc), \"should not be an interpreter frame\");\n+  intptr_t* sender_sp = use_codeblob ? (fr->link() + frame::metadata_words - cb->frame_size()) : fr->link();\n+  return frame(sender_sp, sender_sp, fr->link(), pc, cb, true \/* allow_cb_null *\/);\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/os_linux_aarch64.cpp","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+#include \"compiler\/compilationMemoryStatistic.hpp\"\n+#include \"compiler\/compilerDirectives.hpp\"\n@@ -37,0 +39,1 @@\n+#include \"compiler\/compileTask.hpp\"\n@@ -445,0 +448,3 @@\n+\n+  CompilationMemoryStatisticMark cmsm(env()->task()->directive());\n+\n","filename":"src\/hotspot\/share\/c1\/c1_Compilation.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -49,5 +49,3 @@\n-  {\n-    PerfClassTraceTime vmtimer(ClassLoader::perf_sys_class_lookup_time(),\n-                               THREAD->get_thread_stat()->perf_timers_addr(),\n-                               PerfClassTraceTime::CLASS_LOAD);\n-  }\n+  PerfClassTraceTime vmtimer(ClassLoader::perf_app_classload_time(),\n+                             THREAD->get_thread_stat()->perf_timers_addr(),\n+                             PerfClassTraceTime::CLASS_LOAD);\n","filename":"src\/hotspot\/share\/cds\/unregisteredClasses.cpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -126,1 +126,0 @@\n-PerfCounter*    ClassLoader::_perf_sys_class_lookup_time = nullptr;\n@@ -1380,1 +1379,0 @@\n-    NEWPERFTICKCOUNTER(_perf_sys_class_lookup_time, SUN_CLS, \"lookupSysClassTime\");\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -171,1 +171,0 @@\n-  static PerfCounter* _perf_sys_class_lookup_time;\n@@ -292,1 +291,0 @@\n-  static PerfCounter* perf_sys_class_lookup_time()    { return _perf_sys_class_lookup_time; }\n","filename":"src\/hotspot\/share\/classfile\/classLoader.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -222,1 +222,1 @@\n-    _arena = new (mtSymbol) Arena(mtSymbol, symbol_alloc_arena_size);\n+    _arena = new (mtSymbol) Arena(mtSymbol, Arena::Tag::tag_other, symbol_alloc_arena_size);\n","filename":"src\/hotspot\/share\/classfile\/symbolTable.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1254,0 +1254,48 @@\n+#ifndef PRODUCT\n+\/\/ Check if any of live methods dependencies have been invalidated.\n+\/\/ (this is expensive!)\n+static void check_live_nmethods_dependencies(DepChange& changes) {\n+  \/\/ Checked dependencies are allocated into this ResourceMark\n+  ResourceMark rm;\n+\n+  \/\/ Turn off dependency tracing while actually testing dependencies.\n+  FlagSetting fs(Dependencies::_verify_in_progress, true);\n+\n+  typedef ResourceHashtable<DependencySignature, int, 11027,\n+                            AnyObj::RESOURCE_AREA, mtInternal,\n+                            &DependencySignature::hash,\n+                            &DependencySignature::equals> DepTable;\n+\n+  DepTable* table = new DepTable();\n+\n+  \/\/ Iterate over live nmethods and check dependencies of all nmethods that are not\n+  \/\/ marked for deoptimization. A particular dependency is only checked once.\n+  NMethodIterator iter(NMethodIterator::only_not_unloading);\n+  while(iter.next()) {\n+    nmethod* nm = iter.method();\n+    \/\/ Only notify for live nmethods\n+    if (!nm->is_marked_for_deoptimization()) {\n+      for (Dependencies::DepStream deps(nm); deps.next(); ) {\n+        \/\/ Construct abstraction of a dependency.\n+        DependencySignature* current_sig = new DependencySignature(deps);\n+\n+        \/\/ Determine if dependency is already checked. table->put(...) returns\n+        \/\/ 'true' if the dependency is added (i.e., was not in the hashtable).\n+        if (table->put(*current_sig, 1)) {\n+          if (deps.check_dependency() != nullptr) {\n+            \/\/ Dependency checking failed. Print out information about the failed\n+            \/\/ dependency and finally fail with an assert. We can fail here, since\n+            \/\/ dependency checking is never done in a product build.\n+            tty->print_cr(\"Failed dependency:\");\n+            changes.print();\n+            nm->print();\n+            nm->print_dependencies_on(tty);\n+            assert(false, \"Should have been marked for deoptimization\");\n+          }\n+        }\n+      }\n+    }\n+  }\n+}\n+#endif\n+\n@@ -1275,1 +1323,1 @@\n-    nmethod::check_all_dependencies(changes);\n+    check_live_nmethods_dependencies(changes);\n","filename":"src\/hotspot\/share\/code\/codeCache.cpp","additions":49,"deletions":1,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -562,2 +562,2 @@\n-  if (cb != nullptr && cb->is_adapter_blob()) {\n-    return true;\n+  if (cb == nullptr) {\n+    return false;\n@@ -565,4 +565,4 @@\n-  \/\/ itable stubs also use CompiledICHolder\n-  if (cb != nullptr && cb->is_vtable_blob()) {\n-    VtableStub* s = VtableStubs::entry_point(entry);\n-    return (s != nullptr) && s->is_itable_stub();\n+  if (cb->is_adapter_blob()) {\n+    return true;\n+  } else if (cb->is_vtable_blob()) {\n+    return VtableStubs::is_icholder_entry(entry);\n@@ -570,1 +570,0 @@\n-\n","filename":"src\/hotspot\/share\/code\/compiledIC.cpp","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"runtime\/atomic.hpp\"\n@@ -47,2 +48,2 @@\n-CompiledICHolder* InlineCacheBuffer::_pending_released = nullptr;\n-int InlineCacheBuffer::_pending_count = 0;\n+CompiledICHolder* volatile InlineCacheBuffer::_pending_released = nullptr;\n+volatile int InlineCacheBuffer::_pending_count = 0;\n@@ -250,1 +251,1 @@\n-  CompiledICHolder* holder = _pending_released;\n+  CompiledICHolder* holder = Atomic::load(&_pending_released);\n@@ -252,0 +253,1 @@\n+  int count = 0;\n@@ -256,1 +258,1 @@\n-    _pending_count--;\n+    count++;\n@@ -258,1 +260,2 @@\n-  assert(_pending_count == 0, \"wrong count\");\n+  assert(pending_icholder_count() == count, \"wrong count\");\n+  Atomic::store(&_pending_count, 0);\n@@ -262,1 +265,1 @@\n-\/\/ not safe to free them until them since they might be visible to\n+\/\/ not safe to free them until then since they might be visible to\n@@ -265,4 +268,14 @@\n-  MutexLocker mex(InlineCacheBuffer_lock, Mutex::_no_safepoint_check_flag);\n-  icholder->set_next(_pending_released);\n-  _pending_released = icholder;\n-  _pending_count++;\n+  assert(icholder->next() == nullptr, \"multiple enqueue?\");\n+\n+  CompiledICHolder* old = Atomic::load(&_pending_released);\n+  for (;;) {\n+    icholder->set_next(old);\n+    \/\/ The only reader runs at a safepoint serially so there is no need for a more strict atomic.\n+    CompiledICHolder* cur = Atomic::cmpxchg(&_pending_released, old, icholder, memory_order_relaxed);\n+    if (cur == old) {\n+      break;\n+    }\n+    old = cur;\n+  }\n+  Atomic::inc(&_pending_count, memory_order_relaxed);\n+\n@@ -273,0 +286,4 @@\n+\n+int InlineCacheBuffer::pending_icholder_count() {\n+  return Atomic::load(&_pending_count);\n+}\n","filename":"src\/hotspot\/share\/code\/icBuffer.cpp","additions":27,"deletions":10,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -149,2 +149,2 @@\n-  static CompiledICHolder* _pending_released;\n-  static int _pending_count;\n+  static CompiledICHolder* volatile _pending_released;\n+  static volatile int _pending_count;\n@@ -179,1 +179,1 @@\n-  static int pending_icholder_count() { return _pending_count; }\n+  static int pending_icholder_count();\n","filename":"src\/hotspot\/share\/code\/icBuffer.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2151,45 +2151,0 @@\n-\n-void nmethod::check_all_dependencies(DepChange& changes) {\n-  \/\/ Checked dependencies are allocated into this ResourceMark\n-  ResourceMark rm;\n-\n-  \/\/ Turn off dependency tracing while actually testing dependencies.\n-  NOT_PRODUCT( FlagSetting fs(Dependencies::_verify_in_progress, true));\n-\n-  typedef ResourceHashtable<DependencySignature, int, 11027,\n-                            AnyObj::RESOURCE_AREA, mtInternal,\n-                            &DependencySignature::hash,\n-                            &DependencySignature::equals> DepTable;\n-\n-  DepTable* table = new DepTable();\n-\n-  \/\/ Iterate over live nmethods and check dependencies of all nmethods that are not\n-  \/\/ marked for deoptimization. A particular dependency is only checked once.\n-  NMethodIterator iter(NMethodIterator::only_not_unloading);\n-  while(iter.next()) {\n-    nmethod* nm = iter.method();\n-    \/\/ Only notify for live nmethods\n-    if (!nm->is_marked_for_deoptimization()) {\n-      for (Dependencies::DepStream deps(nm); deps.next(); ) {\n-        \/\/ Construct abstraction of a dependency.\n-        DependencySignature* current_sig = new DependencySignature(deps);\n-\n-        \/\/ Determine if dependency is already checked. table->put(...) returns\n-        \/\/ 'true' if the dependency is added (i.e., was not in the hashtable).\n-        if (table->put(*current_sig, 1)) {\n-          if (deps.check_dependency() != nullptr) {\n-            \/\/ Dependency checking failed. Print out information about the failed\n-            \/\/ dependency and finally fail with an assert. We can fail here, since\n-            \/\/ dependency checking is never done in a product build.\n-            tty->print_cr(\"Failed dependency:\");\n-            changes.print();\n-            nm->print();\n-            nm->print_dependencies_on(tty);\n-            assert(false, \"Should have been marked for deoptimization\");\n-          }\n-        }\n-      }\n-    }\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":0,"deletions":45,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -680,4 +680,0 @@\n-  \/\/ tells if any of this method's dependencies have been invalidated\n-  \/\/ (this is expensive!)\n-  static void check_all_dependencies(DepChange& changes);\n-\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -98,2 +98,1 @@\n-VtableStub* VtableStubs::_table[VtableStubs::N];\n-int VtableStubs::_number_of_vtable_stubs = 0;\n+VtableStub* volatile VtableStubs::_table[VtableStubs::N];\n@@ -129,0 +128,2 @@\n+  assert(VtableStub::_receiver_location == VMRegImpl::Bad(), \"initialized multiple times?\");\n+\n@@ -132,2 +133,0 @@\n-    assert(_number_of_vtable_stubs == 0, \"potential performance bug: VtableStubs initialized more than once\");\n-    assert(is_power_of_2(int(N)), \"N must be a power of 2\");\n@@ -135,1 +134,1 @@\n-      _table[i] = nullptr;\n+      Atomic::store(&_table[i], (VtableStub*)nullptr);\n@@ -262,1 +261,1 @@\n-  VtableStub* s = _table[hash];\n+  VtableStub* s = Atomic::load(&_table[hash]);\n@@ -272,4 +271,4 @@\n-  \/\/ enter s at the beginning of the corresponding list\n-  s->set_next(_table[h]);\n-  _table[h] = s;\n-  _number_of_vtable_stubs++;\n+  \/\/ Insert s at the beginning of the corresponding list.\n+  s->set_next(Atomic::load(&_table[h]));\n+  \/\/ Make sure that concurrent readers not taking the mutex observe the writing of \"next\".\n+  Atomic::release_store(&_table[h], s);\n@@ -283,1 +282,1 @@\n-  for (s = _table[hash]; s != nullptr && s != stub; s = s->next()) {}\n+  for (s = Atomic::load(&_table[hash]); s != nullptr && s != stub; s = s->next()) {}\n@@ -287,0 +286,7 @@\n+bool VtableStubs::is_icholder_entry(address pc) {\n+  assert(contains(pc), \"must contain all vtable blobs\");\n+  VtableStub* stub = (VtableStub*)(pc - VtableStub::entry_offset());\n+  \/\/ itable stubs use CompiledICHolder.\n+  return stub->is_itable_stub();\n+}\n+\n@@ -295,3 +301,0 @@\n-  \/\/ Note: No locking needed since any change to the data structure\n-  \/\/       happens with an atomic store into it (we don't care about\n-  \/\/       consistency with the _number_of_vtable_stubs counter).\n@@ -299,1 +302,1 @@\n-    for (VtableStub* s = _table[i]; s != nullptr; s = s->next()) {\n+    for (VtableStub* s = Atomic::load_acquire(&_table[i]); s != nullptr; s = s->next()) {\n@@ -311,4 +314,3 @@\n-    for (int i = 0; i < N; i++) {\n-        for (VtableStub* s = _table[i]; s != nullptr; s = s->next()) {\n-            f(s);\n-        }\n+  for (int i = 0; i < N; i++) {\n+    for (VtableStub* s = Atomic::load_acquire(&_table[i]); s != nullptr; s = s->next()) {\n+      f(s);\n@@ -316,0 +318,1 @@\n+  }\n","filename":"src\/hotspot\/share\/code\/vtableStubs.cpp","additions":22,"deletions":19,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -83,0 +83,2 @@\n+  static_assert(is_power_of_2((int)N), \"N must be a power of 2\");\n+\n@@ -85,2 +87,1 @@\n-  static VtableStub* _table[N];                  \/\/ table of existing stubs\n-  static int         _number_of_vtable_stubs;    \/\/ number of stubs created so far (for statistics)\n+  static VtableStub* volatile _table[N];                  \/\/ table of existing stubs\n@@ -109,0 +110,1 @@\n+  static bool        is_icholder_entry(address pc);                  \/\/ is the blob containing pc (which must be a vtable blob) an icholder?\n@@ -111,1 +113,0 @@\n-  static int         number_of_vtable_stubs() { return _number_of_vtable_stubs; }\n","filename":"src\/hotspot\/share\/code\/vtableStubs.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,451 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Red Hat, Inc. and\/or its affiliates.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"logging\/logStream.hpp\"\n+#include \"compiler\/abstractCompiler.hpp\"\n+#include \"compiler\/compilationMemoryStatistic.hpp\"\n+#include \"compiler\/compilerDirectives.hpp\"\n+#include \"compiler\/compileTask.hpp\"\n+#include \"compiler\/compilerDefinitions.hpp\"\n+#include \"compiler\/compilerThread.hpp\"\n+#include \"memory\/arena.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"oops\/symbol.hpp\"\n+#ifdef COMPILER2\n+#include \"opto\/node.hpp\" \/\/ compile.hpp is not self-contained\n+#include \"opto\/compile.hpp\"\n+#endif\n+#include \"services\/nmtCommon.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+#include \"utilities\/quickSort.hpp\"\n+#include \"utilities\/resourceHash.hpp\"\n+\n+\n+ArenaStatCounter::ArenaStatCounter() :\n+  _current(0), _start(0), _peak(0),\n+  _na(0), _ra(0),\n+  _na_at_peak(0), _ra_at_peak(0), _live_nodes_at_peak(0)\n+{}\n+\n+size_t ArenaStatCounter::peak_since_start() const {\n+  return _peak > _start ? _peak - _start : 0;\n+}\n+\n+void ArenaStatCounter::start() {\n+  _peak = _start = _current;\n+}\n+\n+void ArenaStatCounter::update_c2_node_count() {\n+#ifdef COMPILER2\n+  CompilerThread* const th = Thread::current()->as_Compiler_thread();\n+  const CompileTask* const task = th->task();\n+  if (task != nullptr &&\n+      th->task()->compiler() != nullptr &&\n+      th->task()->compiler()->type() == compiler_c2) {\n+    const Compile* const comp = Compile::current();\n+    if (comp != nullptr) {\n+      _live_nodes_at_peak = comp->live_nodes();\n+    }\n+  }\n+#endif\n+}\n+\n+\/\/ Account an arena allocation or de-allocation.\n+bool ArenaStatCounter::account(ssize_t delta, int tag) {\n+  bool rc = false;\n+#ifdef ASSERT\n+  \/\/ Note: if this fires, we free more arena memory under the scope of the\n+  \/\/ CompilationMemoryHistoryMark than we allocate. This cannot be since we\n+  \/\/ assume arena allocations in CompilerThread to be stack bound and symmetric.\n+  assert(delta >= 0 || ((ssize_t)_current + delta) >= 0,\n+         \"Negative overflow (d=%zd %zu %zu %zu)\", delta, _current, _start, _peak);\n+#endif\n+  \/\/ Update totals\n+  _current += delta;\n+  \/\/ Update detail counter\n+  switch ((Arena::Tag)tag) {\n+    case Arena::Tag::tag_ra: _ra += delta; break;\n+    case Arena::Tag::tag_node: _na += delta; break;\n+    default: \/\/ ignore\n+      break;\n+  };\n+  \/\/ Did we reach a peak?\n+  if (_current > _peak) {\n+    _peak = _current;\n+    assert(delta > 0, \"Sanity (%zu %zu %zu)\", _current, _start, _peak);\n+    _na_at_peak = _na;\n+    _ra_at_peak = _ra;\n+    update_c2_node_count();\n+    rc = true;\n+  }\n+  return rc;\n+}\n+\n+void ArenaStatCounter::print_on(outputStream* st) const {\n+  st->print(\"%zu [na %zu ra %zu]\", peak_since_start(), _na_at_peak, _ra_at_peak);\n+#ifdef ASSERT\n+  st->print(\" (%zu->%zu->%zu)\", _start, _peak, _current);\n+#endif\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/ Backend\n+\n+class FullMethodName {\n+  Symbol* const _k;\n+  Symbol* const _m;\n+  Symbol* const _s;\n+\n+public:\n+\n+  FullMethodName(Symbol* k, Symbol* m, Symbol* s) : _k(k), _m(m), _s(s) {}\n+  FullMethodName(const FullMethodName& o) : _k(o._k), _m(o._m), _s(o._s) {}\n+\n+  void make_permanent() {\n+    _k->make_permanent();\n+    _m->make_permanent();\n+    _s->make_permanent();\n+  }\n+\n+  static unsigned compute_hash(const FullMethodName& n) {\n+    return Symbol::compute_hash(n._k) ^\n+        Symbol::compute_hash(n._m) ^\n+        Symbol::compute_hash(n._s);\n+  }\n+\n+  char* as_C_string(char* buf, size_t len) const {\n+    stringStream ss(buf, len);\n+    ResourceMark rm;\n+    ss.print_raw(_k->as_C_string());\n+    ss.print_raw(\"::\");\n+    ss.print_raw(_m->as_C_string());\n+    ss.put('(');\n+    ss.print_raw(_s->as_C_string());\n+    ss.put(')');\n+    return buf;\n+  }\n+\n+  bool equals(const FullMethodName& b) const {\n+    return _k == b._k && _m == b._m && _s == b._s;\n+  }\n+\n+  bool operator== (const FullMethodName& other) const { return equals(other); }\n+};\n+\n+\/\/ Note: not mtCompiler since we don't want to change what we measure\n+class MemStatEntry : public CHeapObj<mtInternal> {\n+  const FullMethodName _method;\n+  CompilerType _comptype;\n+  double _time;\n+  \/\/ How often this has been recompiled.\n+  int _num_recomp;\n+  \/\/ Compiling thread. Only for diagnostic purposes. Thread may not be alive anymore.\n+  const Thread* _thread;\n+\n+  size_t _total;\n+  size_t _na_at_peak;\n+  size_t _ra_at_peak;\n+  unsigned _live_nodes_at_peak;\n+\n+public:\n+\n+  MemStatEntry(FullMethodName method)\n+    : _method(method), _comptype(compiler_c1),\n+      _time(0), _num_recomp(0), _thread(nullptr),\n+      _total(0), _na_at_peak(0), _ra_at_peak(0), _live_nodes_at_peak(0) {\n+  }\n+\n+  void set_comptype(CompilerType comptype) { _comptype = comptype; }\n+  void set_current_time() { _time = os::elapsedTime(); }\n+  void set_current_thread() { _thread = Thread::current(); }\n+  void inc_recompilation() { _num_recomp++; }\n+\n+  void set_total(size_t n) { _total = n; }\n+  void set_na_at_peak(size_t n) { _na_at_peak = n; }\n+  void set_ra_at_peak(size_t n) { _ra_at_peak = n; }\n+  void set_live_nodes_at_peak(unsigned n) { _live_nodes_at_peak = n; }\n+\n+  size_t total() const { return _total; }\n+\n+  static void print_legend(outputStream* st) {\n+    st->print_cr(\"Legend:\");\n+    st->print_cr(\"  total  : memory allocated via arenas while compiling\");\n+    st->print_cr(\"  NA     : ...how much in node arenas (if c2)\");\n+    st->print_cr(\"  RA     : ...how much in resource areas\");\n+    st->print_cr(\"  #nodes : ...how many nodes (if c2)\");\n+    st->print_cr(\"  time   : time of last compilation (sec)\");\n+    st->print_cr(\"  type   : compiler type\");\n+    st->print_cr(\"  #rc    : how often recompiled\");\n+    st->print_cr(\"  thread : compiler thread\");\n+  }\n+\n+  static void print_header(outputStream* st) {\n+    st->print_cr(\"total     NA        RA        #nodes  time    type  #rc thread              method\");\n+  }\n+\n+  void print_on(outputStream* st, bool human_readable) const {\n+    int col = 0;\n+\n+    \/\/ Total\n+    if (human_readable) {\n+      st->print(PROPERFMT \" \", PROPERFMTARGS(_total));\n+    } else {\n+      st->print(\"%zu \", _total);\n+    }\n+    col += 10; st->fill_to(col);\n+\n+    \/\/ NA\n+    if (human_readable) {\n+      st->print(PROPERFMT \" \", PROPERFMTARGS(_na_at_peak));\n+    } else {\n+      st->print(\"%zu \", _na_at_peak);\n+    }\n+    col += 10; st->fill_to(col);\n+\n+    \/\/ RA\n+    if (human_readable) {\n+      st->print(PROPERFMT \" \", PROPERFMTARGS(_ra_at_peak));\n+    } else {\n+      st->print(\"%zu \", _ra_at_peak);\n+    }\n+    col += 10; st->fill_to(col);\n+\n+    \/\/ Number of Nodes when memory peaked\n+    st->print(\"%u \", _live_nodes_at_peak);\n+    col += 8; st->fill_to(col);\n+\n+    \/\/ TimeStamp\n+    st->print(\"%.3f \", _time);\n+    col += 8; st->fill_to(col);\n+\n+    \/\/ Type\n+    st->print(\"%s \", compilertype2name(_comptype));\n+    col += 6; st->fill_to(col);\n+\n+    \/\/ Recomp\n+    st->print(\"%u \", _num_recomp);\n+    col += 4; st->fill_to(col);\n+\n+    \/\/ Thread\n+    st->print(PTR_FORMAT \"  \", p2i(_thread));\n+\n+    \/\/ MethodName\n+    char buf[1024];\n+    st->print(\"%s \", _method.as_C_string(buf, sizeof(buf)));\n+    st->cr();\n+  }\n+\n+  int compare_by_size(const MemStatEntry* b) const {\n+    const size_t x1 = b->_total;\n+    const size_t x2 = _total;\n+    return x1 < x2 ? -1 : x1 == x2 ? 0 : 1;\n+  }\n+\n+  bool equals(const FullMethodName& b) const {\n+    return _method.equals(b);\n+  }\n+};\n+\n+class MemStatTable :\n+    public ResourceHashtable<FullMethodName, MemStatEntry*, 7919, AnyObj::C_HEAP,\n+                             mtInternal, FullMethodName::compute_hash>\n+{\n+public:\n+\n+  void add(const FullMethodName& fmn, CompilerType comptype,\n+           size_t total, size_t na_at_peak, size_t ra_at_peak,\n+           unsigned live_nodes_at_peak) {\n+    assert_lock_strong(NMTCompilationCostHistory_lock);\n+\n+    MemStatEntry** pe = get(fmn);\n+    MemStatEntry* e = nullptr;\n+    if (pe == nullptr) {\n+      e = new MemStatEntry(fmn);\n+      put(fmn, e);\n+    } else {\n+      \/\/ Update existing entry\n+      e = *pe;\n+      assert(e != nullptr, \"Sanity\");\n+    }\n+    e->set_current_time();\n+    e->set_current_thread();\n+    e->set_comptype(comptype);\n+    e->inc_recompilation();\n+    e->set_total(total);\n+    e->set_na_at_peak(na_at_peak);\n+    e->set_ra_at_peak(ra_at_peak);\n+    e->set_live_nodes_at_peak(live_nodes_at_peak);\n+  }\n+\n+  \/\/ Returns a C-heap-allocated SortMe array containing all entries from the table,\n+  \/\/ optionally filtered by entry size\n+  MemStatEntry** calc_flat_array(int& num, size_t min_size) {\n+    assert_lock_strong(NMTCompilationCostHistory_lock);\n+\n+    const int num_all = number_of_entries();\n+    MemStatEntry** flat = NEW_C_HEAP_ARRAY(MemStatEntry*, num_all, mtInternal);\n+    int i = 0;\n+    auto do_f = [&] (const FullMethodName& ignored, MemStatEntry* e) {\n+      if (e->total() >= min_size) {\n+        flat[i] = e;\n+        assert(i < num_all, \"Sanity\");\n+        i ++;\n+      }\n+    };\n+    iterate_all(do_f);\n+    if (min_size == 0) {\n+      assert(i == num_all, \"Sanity\");\n+    } else {\n+      assert(i <= num_all, \"Sanity\");\n+    }\n+    num = i;\n+    return flat;\n+  }\n+};\n+\n+bool CompilationMemoryStatistic::_enabled = false;\n+\n+static MemStatTable* _the_table = nullptr;\n+\n+void CompilationMemoryStatistic::initialize() {\n+  assert(_enabled == false && _the_table == nullptr, \"Only once\");\n+  _the_table = new (mtCompiler) MemStatTable;\n+  _enabled = true;\n+  log_info(compilation, alloc)(\"Compilation memory statistic enabled\");\n+}\n+\n+void CompilationMemoryStatistic::on_start_compilation() {\n+  assert(enabled(), \"Not enabled?\");\n+  Thread::current()->as_Compiler_thread()->arena_stat()->start();\n+}\n+\n+void CompilationMemoryStatistic::on_end_compilation() {\n+  assert(enabled(), \"Not enabled?\");\n+  ResourceMark rm;\n+  CompilerThread* const th = Thread::current()->as_Compiler_thread();\n+  const ArenaStatCounter* const arena_stat = th->arena_stat();\n+  const CompilerType ct = th->task()->compiler()->type();\n+\n+  const Method* const m = th->task()->method();\n+  FullMethodName fmn(m->klass_name(), m->name(), m->signature());\n+  fmn.make_permanent();\n+\n+  const DirectiveSet* directive = th->task()->directive();\n+  assert(directive->should_collect_memstat(), \"Only call if memstat is enabled\");\n+  const bool print = directive->should_print_memstat();\n+\n+  if (print) {\n+    char buf[1024];\n+    fmn.as_C_string(buf, sizeof(buf));\n+    tty->print(\"%s Arena usage %s: \", compilertype2name(ct), buf);\n+    arena_stat->print_on(tty);\n+    tty->cr();\n+  }\n+  {\n+    MutexLocker ml(NMTCompilationCostHistory_lock, Mutex::_no_safepoint_check_flag);\n+    assert(_the_table != nullptr, \"not initialized\");\n+\n+    _the_table->add(fmn, ct,\n+                    arena_stat->peak_since_start(), \/\/ total\n+                    arena_stat->na_at_peak(),\n+                    arena_stat->ra_at_peak(),\n+                    arena_stat->live_nodes_at_peak());\n+  }\n+}\n+\n+void CompilationMemoryStatistic::on_arena_change(ssize_t diff, const Arena* arena) {\n+  assert(enabled(), \"Not enabled?\");\n+  CompilerThread* const th = Thread::current()->as_Compiler_thread();\n+  th->arena_stat()->account(diff, (int)arena->get_tag());\n+}\n+\n+static inline ssize_t diff_entries_by_size(const MemStatEntry* e1, const MemStatEntry* e2) {\n+  return e1->compare_by_size(e2);\n+}\n+\n+void CompilationMemoryStatistic::print_all_by_size(outputStream* st, bool human_readable, size_t min_size) {\n+  st->print_cr(\"Compilation memory statistics\");\n+\n+  if (!enabled()) {\n+    st->print_cr(\"(unavailable)\");\n+    return;\n+  }\n+\n+  st->cr();\n+\n+  MemStatEntry::print_legend(st);\n+  st->cr();\n+\n+  if (min_size > 0) {\n+    st->print_cr(\" (cutoff: %zu bytes)\", min_size);\n+  }\n+  st->cr();\n+\n+  MemStatEntry::print_header(st);\n+\n+  MemStatEntry** filtered = nullptr;\n+  {\n+    MutexLocker ml(NMTCompilationCostHistory_lock, Mutex::_no_safepoint_check_flag);\n+\n+    if (_the_table != nullptr) {\n+      \/\/ We sort with quicksort\n+      int num = 0;\n+      filtered = _the_table->calc_flat_array(num, min_size);\n+      if (min_size > 0) {\n+        st->print_cr(\"(%d\/%d)\", num, _the_table->number_of_entries());\n+      }\n+      if (num > 0) {\n+        QuickSort::sort(filtered, num, diff_entries_by_size, false);\n+        \/\/ Now print. Has to happen under lock protection too, since entries may be changed.\n+        for (int i = 0; i < num; i ++) {\n+          filtered[i]->print_on(st, human_readable);\n+        }\n+      } else {\n+        st->print_cr(\"No entries.\");\n+      }\n+    } else {\n+      st->print_cr(\"Not initialized.\");\n+    }\n+  } \/\/ locked\n+\n+  FREE_C_HEAP_ARRAY(Entry, filtered);\n+}\n+\n+CompilationMemoryStatisticMark::CompilationMemoryStatisticMark(const DirectiveSet* directive)\n+  : _active(directive->should_collect_memstat()) {\n+  if (_active) {\n+    CompilationMemoryStatistic::on_start_compilation();\n+  }\n+}\n+CompilationMemoryStatisticMark::~CompilationMemoryStatisticMark() {\n+  if (_active) {\n+    CompilationMemoryStatistic::on_end_compilation();\n+  }\n+}\n","filename":"src\/hotspot\/share\/compiler\/compilationMemoryStatistic.cpp","additions":451,"deletions":0,"binary":false,"changes":451,"status":"added"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Red Hat, Inc. and\/or its affiliates.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_COMPILER_COMPILATIONMEMORYSTATISTIC_HPP\n+#define SHARE_COMPILER_COMPILATIONMEMORYSTATISTIC_HPP\n+\n+#include \"compiler\/compilerDefinitions.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"memory\/allStatic.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+class outputStream;\n+class Symbol;\n+class DirectiveSet;\n+\n+\/\/ Counters for allocations from one arena\n+class ArenaStatCounter : public CHeapObj<mtCompiler> {\n+  \/\/ Current bytes, total\n+  size_t _current;\n+  \/\/ bytes when compilation started\n+  size_t _start;\n+  \/\/ bytes at last peak, total\n+  size_t _peak;\n+  \/\/ Current bytes used for node arenas, total\n+  size_t _na;\n+  \/\/ Current bytes used for resource areas\n+  size_t _ra;\n+\n+  \/\/ Peak composition:\n+  \/\/ Size of node arena when total peaked (c2 only)\n+  size_t _na_at_peak;\n+  \/\/ Size of resource area when total peaked\n+  size_t _ra_at_peak;\n+  \/\/ Number of live nodes when total peaked (c2 only)\n+  unsigned _live_nodes_at_peak;\n+\n+  void update_c2_node_count();\n+\n+public:\n+  ArenaStatCounter();\n+\n+  \/\/ Size of peak since last compilation\n+  size_t peak_since_start() const;\n+\n+  \/\/ Peak details\n+  size_t na_at_peak() const { return _na_at_peak; }\n+  size_t ra_at_peak() const { return _ra_at_peak; }\n+  unsigned live_nodes_at_peak() const { return _live_nodes_at_peak; }\n+\n+  \/\/ Mark the start of a compilation.\n+  void start();\n+\n+  \/\/ Account an arena allocation or de-allocation.\n+  \/\/ Returns true if new peak reached\n+  bool account(ssize_t delta, int tag);\n+\n+  void set_live_nodes_at_peak(unsigned i) { _live_nodes_at_peak = i; }\n+  void print_on(outputStream* st) const;\n+};\n+\n+class CompilationMemoryStatistic : public AllStatic {\n+  static bool _enabled;\n+public:\n+  static void initialize();\n+  \/\/ true if CollectMemStat or PrintMemStat has been enabled for any method\n+  static bool enabled() { return _enabled; }\n+  static void on_start_compilation();\n+  static void on_end_compilation();\n+  static void on_arena_change(ssize_t diff, const Arena* arena);\n+  static void print_all_by_size(outputStream* st, bool human_readable, size_t minsize);\n+};\n+\n+\/\/ RAII object to wrap one compilation\n+class CompilationMemoryStatisticMark {\n+  const bool _active;\n+public:\n+  CompilationMemoryStatisticMark(const DirectiveSet* directive);\n+  ~CompilationMemoryStatisticMark();\n+};\n+\n+#endif \/\/ SHARE_COMPILER_COMPILATIONMEMORYSTATISTIC_HPP\n","filename":"src\/hotspot\/share\/compiler\/compilationMemoryStatistic.hpp","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"compiler\/compilationMemoryStatistic.hpp\"\n@@ -653,0 +654,4 @@\n+  if (CompilerOracle::should_collect_memstat()) {\n+    CompilationMemoryStatistic::initialize();\n+  }\n+\n@@ -1698,1 +1703,1 @@\n-  if (comp->is_jvmci() && !task->should_wait_for_compilation()) {\n+  if (!UseJVMCINativeLibrary && comp->is_jvmci() && !task->should_wait_for_compilation()) {\n@@ -1700,0 +1705,3 @@\n+    \/\/ Note that libjvmci should not pre-emptively unblock\n+    \/\/ a thread waiting for a compilation as it does not call\n+    \/\/ Java code and so is not deadlock prone like jarjvmci.\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-inline const char* compilertype2name(CompilerType t) { return (uint)t < compiler_number_of_types ? compilertype2name_tab[t] : nullptr; }\n+inline const char* compilertype2name(CompilerType t) { return (uint)t < compiler_number_of_types ? compilertype2name_tab[t] : \"invalid\"; }\n","filename":"src\/hotspot\/share\/compiler\/compilerDefinitions.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -205,0 +205,8 @@\n+bool DirectiveSet::should_collect_memstat() const {\n+  return MemStatOption > 0;\n+}\n+\n+bool DirectiveSet::should_print_memstat() const {\n+  return MemStatOption == (uintx)MemStatAction::print;\n+}\n+\n","filename":"src\/hotspot\/share\/compiler\/compilerDirectives.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+    cflags(MemStat,                 uintx, 0, MemStat) \\\n@@ -134,0 +135,2 @@\n+  bool should_collect_memstat() const;\n+  bool should_print_memstat() const;\n","filename":"src\/hotspot\/share\/compiler\/compilerDirectives.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -104,0 +104,1 @@\n+static bool print_final_memstat_report = false;\n@@ -328,0 +329,1 @@\n+\n@@ -458,0 +460,9 @@\n+\/\/ Tells whether there are any methods to collect memory statistics for\n+bool CompilerOracle::should_collect_memstat() {\n+  return has_command(CompileCommand::MemStat);\n+}\n+\n+bool CompilerOracle::should_print_final_memstat_report() {\n+  return print_final_memstat_report;\n+}\n+\n@@ -626,0 +637,16 @@\n+static bool parseEnumValueAsUintx(enum CompileCommand option, const char* line, uintx& value, int& bytes_read, char* errorbuf, const int buf_size) {\n+  if (option == CompileCommand::MemStat) {\n+    if (strncasecmp(line, \"collect\", 7) == 0) {\n+      value = (uintx)MemStatAction::collect;\n+    } else if (strncasecmp(line, \"print\", 5) == 0) {\n+      value = (uintx)MemStatAction::print;\n+      print_final_memstat_report = true;\n+    } else {\n+      jio_snprintf(errorbuf, buf_size, \"MemStat: invalid value expected 'collect' or 'print' (omitting value means 'collect')\");\n+    }\n+    return true; \/\/ handled\n+  }\n+  return false;\n+#undef HANDLE_VALUE\n+}\n+\n@@ -645,1 +672,7 @@\n-    if (sscanf(line, \"\" UINTX_FORMAT \"%n\", &value, &bytes_read) == 1) {\n+    \/\/ Is it a named enum?\n+    bool success = parseEnumValueAsUintx(option, line, value, bytes_read, errorbuf, buf_size);\n+    if (!success) {\n+      \/\/ Is it a raw number?\n+      success = (sscanf(line, \"\" UINTX_FORMAT \"%n\", &value, &bytes_read) == 1);\n+    }\n+    if (success) {\n@@ -917,1 +950,0 @@\n-      \/\/ if this is a bool option this implies true\n@@ -919,0 +951,1 @@\n+        \/\/ if this is a bool option this implies true\n@@ -921,0 +954,4 @@\n+      } else if (option == CompileCommand::MemStat) {\n+        \/\/ MemStat default action is to collect data but to not print\n+        register_command(matcher, option, (uintx)MemStatAction::collect);\n+        return true;\n","filename":"src\/hotspot\/share\/compiler\/compilerOracle.cpp","additions":39,"deletions":2,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+  option(MemStat, \"MemStat\", Uintx) \\\n@@ -116,0 +117,4 @@\n+enum class MemStatAction {\n+  collect = 1, print = 2\n+};\n+\n@@ -154,0 +159,4 @@\n+  \/\/ Tells whether there are any methods to (collect|collect+print) memory statistics for\n+  static bool should_collect_memstat();\n+  static bool should_print_final_memstat_report();\n+\n","filename":"src\/hotspot\/share\/compiler\/compilerOracle.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"compiler\/compilationMemoryStatistic.hpp\"\n@@ -42,0 +43,1 @@\n+  _arena_stat = CompilationMemoryStatistic::enabled() ? new ArenaStatCounter : nullptr;\n@@ -54,0 +56,1 @@\n+  delete _arena_stat;\n","filename":"src\/hotspot\/share\/compiler\/compilerThread.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-class BufferBlob;\n@@ -32,0 +31,2 @@\n+class ArenaStatCounter;\n+class BufferBlob;\n@@ -57,0 +58,2 @@\n+  ArenaStatCounter*     _arena_stat;\n+\n@@ -84,0 +87,1 @@\n+  ArenaStatCounter* arena_stat() const           { return _arena_stat; }\n","filename":"src\/hotspot\/share\/compiler\/compilerThread.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -194,1 +194,4 @@\n-  if (hr == nullptr) {\n+\n+  if (hr == nullptr || hr->free() < MinTLABSize) {\n+    \/\/ The next TLAB allocation will most probably happen in a new region,\n+    \/\/ therefore we can attempt to allocate the maximum allowed TLAB size.\n@@ -196,2 +199,0 @@\n-  } else {\n-    return clamp(hr->free(), MinTLABSize, max_tlab);\n@@ -199,0 +200,2 @@\n+\n+  return MIN2(hr->free(), max_tlab);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Allocator.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -254,8 +254,0 @@\n-  \/\/ Check whether a given young length (young_length) fits into the\n-  \/\/ given target pause time and whether the prediction for the amount\n-  \/\/ of objects to be copied for the given length will fit into the\n-  \/\/ given free space (expressed by base_free_regions).  It is used by\n-  \/\/ calculate_young_list_target_length().\n-  bool predict_will_fit(uint young_length, double base_time_ms,\n-                        uint base_free_regions, double target_pause_time_ms) const;\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/serial\/generation.hpp\"\n@@ -29,1 +30,0 @@\n-#include \"gc\/shared\/generation.hpp\"\n","filename":"src\/hotspot\/share\/gc\/serial\/cardTableRS.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/serial\/generation.hpp\"\n@@ -32,1 +33,0 @@\n-#include \"gc\/shared\/generation.hpp\"\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"gc\/serial\/generation.hpp\"\n@@ -45,1 +46,0 @@\n-#include \"gc\/shared\/generation.hpp\"\n","filename":"src\/hotspot\/share\/gc\/serial\/genMarkSweep.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+#include \"gc\/serial\/generation.hpp\"\n+#include \"gc\/serial\/serialHeap.hpp\"\n@@ -32,2 +34,0 @@\n-#include \"gc\/shared\/genCollectedHeap.hpp\"\n-#include \"gc\/shared\/generation.hpp\"\n@@ -61,3 +61,3 @@\n-  GenCollectedHeap* gch = GenCollectedHeap::heap();\n-  if (gch->is_young_gen(this)) {\n-    return gch->young_gen_spec()->init_size();\n+  SerialHeap* serial_heap = SerialHeap::heap();\n+  if (serial_heap->is_young_gen(this)) {\n+    return serial_heap->young_gen_spec()->init_size();\n@@ -65,1 +65,1 @@\n-  return gch->old_gen_spec()->init_size();\n+  return serial_heap->old_gen_spec()->init_size();\n@@ -89,1 +89,1 @@\n-               GenCollectedHeap::heap()->is_young_gen(this) ? \"young\" : \"old\" ,\n+               SerialHeap::heap()->is_young_gen(this) ? \"young\" : \"old\" ,\n@@ -97,12 +97,0 @@\n-class GenerationIsInReservedClosure : public SpaceClosure {\n- public:\n-  const void* _p;\n-  Space* sp;\n-  virtual void do_space(Space* s) {\n-    if (sp == nullptr) {\n-      if (s->is_in_reserved(_p)) sp = s;\n-    }\n-  }\n-  GenerationIsInReservedClosure(const void* p) : _p(p), sp(nullptr) {}\n-};\n-\n@@ -131,2 +119,2 @@\n-  if (GenCollectedHeap::heap()->is_young_gen(this)) {\n-    old_avail = GenCollectedHeap::heap()->old_gen()->contiguous_available();\n+  if (SerialHeap::heap()->is_young_gen(this)) {\n+    old_avail = SerialHeap::heap()->old_gen()->contiguous_available();\n@@ -150,1 +138,1 @@\n-  if (GenCollectedHeap::heap()->promotion_should_fail()) {\n+  if (SerialHeap::heap()->promotion_should_fail()) {\n@@ -251,2 +239,0 @@\n-#if INCLUDE_SERIALGC\n-\n@@ -283,2 +269,0 @@\n-\n-#endif \/\/ INCLUDE_SERIALGC\n","filename":"src\/hotspot\/share\/gc\/serial\/generation.cpp","additions":10,"deletions":26,"binary":false,"changes":36,"previous_filename":"src\/hotspot\/share\/gc\/shared\/generation.cpp","status":"renamed"},{"patch":"@@ -57,1 +57,0 @@\n-class GenCollectedHeap;\n@@ -293,1 +292,0 @@\n-#if INCLUDE_SERIALGC\n@@ -300,1 +298,0 @@\n-#endif\n@@ -380,1 +377,1 @@\n-#endif \/\/ SHARE_GC_SHARED_GENERATION_HPP\n+#endif \/\/ SHARE_GC_SERIAL_GENERATION_HPP\n","filename":"src\/hotspot\/share\/gc\/serial\/generation.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"previous_filename":"src\/hotspot\/share\/gc\/shared\/generation.hpp","status":"renamed"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"gc\/shared\/generation.hpp\"\n+#include \"gc\/serial\/generation.hpp\"\n","filename":"src\/hotspot\/share\/gc\/serial\/tenuredGeneration.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"gc\/serial\/generation.hpp\"\n@@ -28,1 +29,0 @@\n-#include \"gc\/shared\/generation.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/genArguments.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/serial\/generation.hpp\"\n@@ -29,1 +30,0 @@\n-#include \"gc\/shared\/generation.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/genCollectedHeap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-#include \"gc\/shared\/generation.hpp\"\n+#include \"gc\/serial\/generation.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/genMemoryPools.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"gc\/shared\/generation.hpp\"\n+#include \"gc\/serial\/generation.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/generationSpec.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -89,1 +89,1 @@\n-  virtual HeapWord* saved_mark_word() const  { return _saved_mark_word; }\n+  HeapWord* saved_mark_word() const  { return _saved_mark_word; }\n@@ -95,1 +95,1 @@\n-  virtual bool obj_allocated_since_save_marks(const oop obj) const {\n+  bool obj_allocated_since_save_marks(const oop obj) const {\n@@ -181,1 +181,1 @@\n-  virtual HeapWord* block_start(const void* p);\n+  HeapWord* block_start(const void* p);\n@@ -194,1 +194,1 @@\n-  virtual bool obj_is_alive(const HeapWord* addr) const;\n+  bool obj_is_alive(const HeapWord* addr) const;\n@@ -209,1 +209,1 @@\n-  virtual void print() const;\n+  void print() const;\n@@ -211,2 +211,2 @@\n-  virtual void print_short() const;\n-  virtual void print_short_on(outputStream* st) const;\n+  void print_short() const;\n+  void print_short_on(outputStream* st) const;\n","filename":"src\/hotspot\/share\/gc\/shared\/space.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"gc\/serial\/generation.hpp\"\n@@ -31,1 +32,0 @@\n-#include \"gc\/shared\/generation.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/space.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"gc\/shared\/generation.hpp\"\n@@ -47,0 +46,1 @@\n+#include \"gc\/serial\/generation.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/vmStructs_gc.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -630,1 +630,1 @@\n-    return BarrierSetC2::load_at_resolved(access, val_type);;\n+    return BarrierSetC2::load_at_resolved(access, val_type);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahBarrierSetC2.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -67,0 +67,1 @@\n+      if (C->failing()) return false;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -224,1 +224,1 @@\n-#endif \/\/ SHARE_GC_SHENANDOAH_SHENANDOAHCLOSURES_HPP\n+#endif \/\/ SHARE_GC_SHENANDOAH_SHENANDOAHCLOSURES_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahClosures.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,64 +39,0 @@\n-ShenandoahParallelCodeCacheIterator::ShenandoahParallelCodeCacheIterator(const GrowableArray<CodeHeap*>* heaps) {\n-  _length = heaps->length();\n-  _iters = NEW_C_HEAP_ARRAY(ShenandoahParallelCodeHeapIterator, _length, mtGC);\n-  for (int h = 0; h < _length; h++) {\n-    _iters[h] = ShenandoahParallelCodeHeapIterator(heaps->at(h));\n-  }\n-}\n-\n-ShenandoahParallelCodeCacheIterator::~ShenandoahParallelCodeCacheIterator() {\n-  FREE_C_HEAP_ARRAY(ParallelCodeHeapIterator, _iters);\n-}\n-\n-void ShenandoahParallelCodeCacheIterator::parallel_blobs_do(CodeBlobClosure* f) {\n-  for (int c = 0; c < _length; c++) {\n-    _iters[c].parallel_blobs_do(f);\n-  }\n-}\n-\n-ShenandoahParallelCodeHeapIterator::ShenandoahParallelCodeHeapIterator(CodeHeap* heap) :\n-        _heap(heap), _claimed_idx(0), _finished(false) {\n-}\n-\n-void ShenandoahParallelCodeHeapIterator::parallel_blobs_do(CodeBlobClosure* f) {\n-  assert(SafepointSynchronize::is_at_safepoint(), \"Must be at safepoint\");\n-\n-  \/*\n-   * Parallel code heap walk.\n-   *\n-   * This code makes all threads scan all code heaps, but only one thread would execute the\n-   * closure on given blob. This is achieved by recording the \"claimed\" blocks: if a thread\n-   * had claimed the block, it can process all blobs in it. Others have to fast-forward to\n-   * next attempt without processing.\n-   *\n-   * Late threads would return immediately if iterator is finished.\n-   *\/\n-\n-  if (_finished) {\n-    return;\n-  }\n-\n-  int stride = 256; \/\/ educated guess\n-  int stride_mask = stride - 1;\n-  assert (is_power_of_2(stride), \"sanity\");\n-\n-  int count = 0;\n-  bool process_block = true;\n-\n-  for (CodeBlob *cb = CodeCache::first_blob(_heap); cb != nullptr; cb = CodeCache::next_blob(_heap, cb)) {\n-    int current = count++;\n-    if ((current & stride_mask) == 0) {\n-      process_block = (current >= _claimed_idx) &&\n-                      (Atomic::cmpxchg(&_claimed_idx, current, current + stride, memory_order_relaxed) == current);\n-    }\n-    if (process_block) {\n-      f->do_code_blob(cb);\n-#ifdef ASSERT\n-      if (cb->is_nmethod())\n-        Universe::heap()->verify_nmethod((nmethod*)cb);\n-#endif\n-    }\n-  }\n-\n-  _finished = true;\n-}\n@@ -306,1 +242,0 @@\n-        _par_iterator(CodeCache::heaps()),\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCodeRoots.cpp","additions":0,"deletions":65,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -42,27 +42,0 @@\n-class ShenandoahParallelCodeHeapIterator {\n-  friend class CodeCache;\n-private:\n-  CodeHeap*     _heap;\n-  shenandoah_padding(0);\n-  volatile int  _claimed_idx;\n-  volatile bool _finished;\n-  shenandoah_padding(1);\n-public:\n-  ShenandoahParallelCodeHeapIterator(CodeHeap* heap);\n-  void parallel_blobs_do(CodeBlobClosure* f);\n-};\n-\n-class ShenandoahParallelCodeCacheIterator {\n-  friend class CodeCache;\n-private:\n-  ShenandoahParallelCodeHeapIterator* _iters;\n-  int                       _length;\n-\n-  NONCOPYABLE(ShenandoahParallelCodeCacheIterator);\n-\n-public:\n-  ShenandoahParallelCodeCacheIterator(const GrowableArray<CodeHeap*>* heaps);\n-  ~ShenandoahParallelCodeCacheIterator();\n-  void parallel_blobs_do(CodeBlobClosure* f);\n-};\n-\n@@ -72,2 +45,0 @@\n-  ShenandoahParallelCodeCacheIterator _par_iterator;\n-  ShenandoahSharedFlag _seq_claimed;\n@@ -91,1 +62,0 @@\n-  static void flush_nmethod(nmethod* nm);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCodeRoots.hpp","additions":0,"deletions":30,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -71,1 +71,0 @@\n-    ShenandoahHeap* heap = ShenandoahHeap::heap();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGC.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2633,4 +2633,0 @@\n-address ShenandoahHeap::gc_state_addr() {\n-  return (address) ShenandoahHeap::heap()->_gc_state.addr_of();\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -395,1 +395,0 @@\n-  static address gc_state_addr();\n@@ -423,1 +422,1 @@\n-  inline bool is_gc_in_progress_mask(uint mask) const;\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -709,4 +709,0 @@\n-inline bool ShenandoahHeap::is_gc_in_progress_mask(uint mask) const {\n-  return _gc_state.is_set(mask);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.inline.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-#endif \/\/ SHARE_VM_GC_SHENANDOAH_SHENANDOAHJFRSUPPORT_HPP\n+#endif \/\/ SHARE_GC_SHENANDOAH_SHENANDOAHJFRSUPPORT_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahJfrSupport.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMark.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -55,33 +55,0 @@\n-class ShenandoahHasCSetOopClosure : public OopClosure {\n-private:\n-  ShenandoahHeap* const _heap;\n-  bool                  _has_cset_oops;\n-\n-public:\n-  ShenandoahHasCSetOopClosure(ShenandoahHeap *heap) :\n-    _heap(heap),\n-    _has_cset_oops(false) {\n-  }\n-\n-  bool has_cset_oops() const {\n-    return _has_cset_oops;\n-  }\n-\n-  void do_oop(oop* p) {\n-    oop value = RawAccess<>::oop_load(p);\n-    if (!_has_cset_oops && _heap->in_collection_set(value)) {\n-      _has_cset_oops = true;\n-    }\n-  }\n-\n-  void do_oop(narrowOop* p) {\n-    ShouldNotReachHere();\n-  }\n-};\n-\n-bool ShenandoahNMethod::has_cset_oops(ShenandoahHeap *heap) {\n-  ShenandoahHasCSetOopClosure cl(heap);\n-  oops_do(&cl);\n-  return cl.has_cset_oops();\n-}\n-\n@@ -212,4 +179,0 @@\n-\n-  bool has_oops() {\n-    return !_oops.is_empty();\n-  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahNMethod.cpp","additions":0,"deletions":37,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -58,6 +58,0 @@\n-  bool has_cset_oops(ShenandoahHeap* heap);\n-\n-  inline int oop_count() const;\n-  inline bool has_oops() const;\n-\n-  inline void mark_unregistered();\n@@ -80,1 +74,0 @@\n-  bool has_non_immed_oops() const { return _has_non_immed_oops; }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahNMethod.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -42,12 +42,0 @@\n-int ShenandoahNMethod::oop_count() const {\n-  return _oops_count + static_cast<int>(nm()->oops_end() - nm()->oops_begin());\n-}\n-\n-bool ShenandoahNMethod::has_oops() const {\n-  return oop_count() > 0;\n-}\n-\n-void ShenandoahNMethod::mark_unregistered() {\n-  _unregistered = true;\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahNMethod.inline.hpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -92,1 +92,0 @@\n-  _phase(phase),\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRootProcessor.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -137,1 +137,0 @@\n-  const ShenandoahPhaseTimings::Phase _phase;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRootProcessor.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2439,0 +2439,10 @@\n+C2V_VMENTRY(void, clearOopHandle, (JNIEnv* env, jobject, jlong oop_handle))\n+  if (oop_handle == 0L) {\n+    JVMCI_THROW(NullPointerException);\n+  }\n+  \/\/ Assert before nulling out, for better debugging.\n+  assert(JVMCIRuntime::is_oop_handle(oop_handle), \"precondition\");\n+  oop* oop_ptr = (oop*) oop_handle;\n+  NativeAccess<>::oop_store(oop_ptr, (oop) nullptr);\n+C2V_END\n+\n@@ -3263,0 +3273,1 @@\n+  {CC \"clearOopHandle\",                               CC \"(J)V\",                                                                            FN_PTR(clearOopHandle)},\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -890,0 +890,7 @@\n+#ifdef ASSERT\n+bool JVMCIRuntime::is_oop_handle(jlong handle) {\n+  const oop* ptr = (oop*) handle;\n+  return object_handles()->allocation_status(ptr) == OopStorage::ALLOCATED_ENTRY;\n+}\n+#endif\n+\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -320,0 +320,3 @@\n+#ifdef ASSERT\n+  static bool is_oop_handle(jlong handle);\n+#endif\n@@ -323,2 +326,0 @@\n-  \/\/ The method also resets _last_found_oop_handle_index to -1\n-  \/\/ and _null_oop_handles to 0.\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +52,2 @@\n-  const size_t sz = Message::calc_size(strlen(msg));\n+  const size_t len = strlen(msg);\n+  const size_t sz = Message::calc_size(len);\n@@ -57,1 +59,1 @@\n-    new(_buf + _pos) Message(output, decorations, msg);\n+    new(_buf + _pos) Message(output, decorations, msg, len);\n@@ -117,23 +119,1 @@\n-void AsyncLogWriter::write() {\n-  ResourceMark rm;\n-  AsyncLogMap<AnyObj::RESOURCE_AREA> snapshot;\n-\n-  \/\/ lock protection. This guarantees I\/O jobs don't block logsites.\n-  {\n-    AsyncLogLocker locker;\n-\n-    _buffer_staging->reset();\n-    swap(_buffer, _buffer_staging);\n-\n-    \/\/ move counters to snapshot and reset them.\n-    _stats.iterate([&] (LogFileStreamOutput* output, uint32_t& counter) {\n-      if (counter > 0) {\n-        bool created = snapshot.put(output, counter);\n-        assert(created == true, \"sanity check\");\n-        counter = 0;\n-      }\n-      return true;\n-    });\n-    _data_available = false;\n-  }\n-\n+void AsyncLogWriter::write(AsyncLogMap<AnyObj::RESOURCE_AREA>& snapshot) {\n@@ -160,1 +140,1 @@\n-      output->write_blocking(decorations, ss.as_string(false));\n+      output->write_blocking(decorations, ss.freeze());\n@@ -173,0 +153,2 @@\n+    ResourceMark rm;\n+    AsyncLogMap<AnyObj::RESOURCE_AREA> snapshot;\n@@ -179,0 +161,15 @@\n+      \/\/ Only doing a swap and statistics under the lock to\n+      \/\/ guarantee that I\/O jobs don't block logsites.\n+      _buffer_staging->reset();\n+      swap(_buffer, _buffer_staging);\n+\n+      \/\/ move counters to snapshot and reset them.\n+      _stats.iterate([&] (LogFileStreamOutput* output, uint32_t& counter) {\n+        if (counter > 0) {\n+          bool created = snapshot.put(output, counter);\n+          assert(created == true, \"sanity check\");\n+          counter = 0;\n+        }\n+        return true;\n+      });\n+      _data_available = false;\n@@ -180,2 +177,1 @@\n-\n-    write();\n+    write(snapshot);\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.cpp","additions":24,"deletions":28,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,1 +70,1 @@\n-  \/\/ Messsage is the envelop of a log line and its associative data.\n+  \/\/ Messsage is the envelope of a log line and its associative data.\n@@ -75,1 +76,1 @@\n-  \/\/ |_output|_decorations|\"a log line\", |pad| <- pointer aligned.\n+  \/\/ |_output|_decorations|\"a log line\", |pad| <- Message aligned.\n@@ -87,1 +88,2 @@\n-    Message(LogFileStreamOutput* output, const LogDecorations& decorations, const char* msg)\n+    \/\/ msglen excludes NUL-byte\n+    Message(LogFileStreamOutput* output, const LogDecorations& decorations, const char* msg, const size_t msglen)\n@@ -90,2 +92,1 @@\n-      PRAGMA_STRINGOP_OVERFLOW_IGNORED\n-      strcpy(reinterpret_cast<char* >(this+1), msg);\n+      memcpy(reinterpret_cast<char* >(this+1), msg, msglen + 1);\n@@ -96,1 +97,1 @@\n-      return align_up(sizeof(Message) + message_len + 1, sizeof(void*));\n+      return align_up(sizeof(Message) + message_len + 1, alignof(Message));\n@@ -117,0 +118,2 @@\n+      \/\/ Ensure _pos is Message-aligned\n+      _pos = align_up(_buf, alignof(Message)) - _buf;\n@@ -127,1 +130,4 @@\n-    void reset() { _pos = 0; }\n+    void reset() {\n+      \/\/ Ensure _pos is Message-aligned\n+      _pos = align_up(_buf, alignof(Message)) - _buf;\n+    }\n@@ -169,1 +175,1 @@\n-  void write();\n+  void write(AsyncLogMap<AnyObj::RESOURCE_AREA>& snapshot);\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.hpp","additions":14,"deletions":8,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"compiler\/compilationMemoryStatistic.hpp\"\n@@ -212,1 +213,1 @@\n-Arena::Arena(MEMFLAGS flag, size_t init_size) : _flags(flag), _size_in_bytes(0)  {\n+Arena::Arena(MEMFLAGS flag, Tag tag, size_t init_size) : _flags(flag), _tag(tag), _size_in_bytes(0)  {\n@@ -222,1 +223,1 @@\n-Arena::Arena(MEMFLAGS flag) : _flags(flag), _size_in_bytes(0) {\n+Arena::Arena(MEMFLAGS flag, Tag tag) : _flags(flag), _tag(tag), _size_in_bytes(0) {\n@@ -254,0 +255,6 @@\n+    if (CompilationMemoryStatistic::enabled() && _flags == mtCompiler) {\n+      Thread* const t = Thread::current();\n+      if (t != nullptr && t->is_Compiler_thread()) {\n+        CompilationMemoryStatistic::on_arena_change(delta, this);\n+      }\n+    }\n","filename":"src\/hotspot\/share\/memory\/arena.cpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -89,0 +89,9 @@\n+public:\n+\n+  enum class Tag {\n+    tag_other = 0,\n+    tag_ra,   \/\/ resource area\n+    tag_ha,   \/\/ handle area\n+    tag_node  \/\/ C2 Node arena\n+  };\n+\n@@ -95,1 +104,1 @@\n-\n+  const Tag _tag;\n@@ -118,3 +127,2 @@\n-\n-  Arena(MEMFLAGS memflag);\n-  Arena(MEMFLAGS memflag, size_t init_size);\n+  Arena(MEMFLAGS memflag, Tag tag = Tag::tag_other);\n+  Arena(MEMFLAGS memflag, Tag tag, size_t init_size);\n@@ -174,0 +182,2 @@\n+  Tag get_tag() const { return _tag; }\n+\n","filename":"src\/hotspot\/share\/memory\/arena.hpp","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"memory\/arena.hpp\"\n@@ -54,1 +55,1 @@\n-    Arena(flags) DEBUG_ONLY(COMMA _nesting(0)) {}\n+    Arena(flags, Arena::Tag::tag_ra) DEBUG_ONLY(COMMA _nesting(0)) {}\n@@ -57,1 +58,2 @@\n-    Arena(flags, init_size) DEBUG_ONLY(COMMA _nesting(0)) {}\n+    Arena(flags, Arena::Tag::tag_ra, init_size) DEBUG_ONLY(COMMA _nesting(0)) {\n+  }\n","filename":"src\/hotspot\/share\/memory\/resourceArea.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-  : _holder_metadata(metadata), _holder_klass(klass), _is_metadata_method(is_method) {\n+  : _holder_metadata(metadata), _holder_klass(klass), _next(nullptr), _is_metadata_method(is_method) {\n","filename":"src\/hotspot\/share\/oops\/compiledICHolder.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"compiler\/compilationMemoryStatistic.hpp\"\n@@ -112,0 +113,2 @@\n+  CompilationMemoryStatisticMark cmsm(directive);\n+\n@@ -121,0 +124,1 @@\n+    ResourceMark rm;\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -100,0 +100,2 @@\n+  if (C->failing()) return nullptr;\n+\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1886,0 +1886,11 @@\n+\/\/ Returns the BasicType of a given convert node and a type, with special handling to ensure that conversions to\n+\/\/ and from half float will return the SHORT basic type, as that wouldn't be returned typically from TypeInt.\n+static BasicType get_convert_type(Node* convert, const Type* type) {\n+  int convert_op = convert->Opcode();\n+  if (type->isa_int() && (convert_op == Op_ConvHF2F || convert_op == Op_ConvF2HF)) {\n+    return T_SHORT;\n+  }\n+\n+  return type->basic_type();\n+}\n+\n@@ -2560,0 +2571,35 @@\n+  \/\/ Try to convert a Phi with two duplicated convert nodes into a phi of the pre-conversion type and the convert node\n+  \/\/ proceeding the phi, to de-duplicate the convert node and compact the IR.\n+  if (can_reshape && progress == nullptr) {\n+    ConvertNode* convert = in(1)->isa_Convert();\n+    if (convert != nullptr) {\n+      int conv_op = convert->Opcode();\n+      bool ok = true;\n+\n+      \/\/ Check the rest of the inputs\n+      for (uint i = 2; i < req(); i++) {\n+        \/\/ Make sure that all inputs are of the same type of convert node\n+        if (in(i)->Opcode() != conv_op) {\n+          ok = false;\n+          break;\n+        }\n+      }\n+\n+      if (ok) {\n+        \/\/ Find the local bottom type to set as the type of the phi\n+        const Type* source_type = Type::get_const_basic_type(convert->in_type()->basic_type());\n+        const Type* dest_type = convert->bottom_type();\n+\n+        PhiNode* newphi = new PhiNode(in(0), source_type, nullptr);\n+        \/\/ Set inputs to the new phi be the inputs of the convert\n+        for (uint i = 1; i < req(); i++) {\n+          newphi->init_req(i, in(i)->in(1));\n+        }\n+\n+        phase->is_IterGVN()->register_new_node_with_optimizer(newphi, this);\n+\n+        return ConvertNode::create_convert(get_convert_type(convert, source_type), get_convert_type(convert, dest_type), newphi);\n+      }\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":46,"deletions":0,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -649,2 +649,2 @@\n-                  _node_arena_one(mtCompiler),\n-                  _node_arena_two(mtCompiler),\n+                  _node_arena_one(mtCompiler, Arena::Tag::tag_node),\n+                  _node_arena_two(mtCompiler, Arena::Tag::tag_node),\n@@ -2248,0 +2248,2 @@\n+  if (failing())  return;\n+\n@@ -2258,0 +2260,2 @@\n+    if (failing())  return;\n+\n@@ -2273,0 +2277,2 @@\n+  if (failing())  return;\n+\n@@ -2277,0 +2283,2 @@\n+  if (failing())  return;\n+\n@@ -2282,1 +2290,1 @@\n-\n+    if (failing())  return;\n@@ -2302,0 +2310,2 @@\n+  if (failing())  return;\n+\n@@ -2414,0 +2424,2 @@\n+  if (failing())  return;\n+\n@@ -2452,0 +2464,1 @@\n+    if (failing())  return;\n@@ -4012,2 +4025,0 @@\n-        DEBUG_ONLY( n->dump_bfs(1, 0, \"-\"); );\n-        assert(false, \"malformed control flow\");\n@@ -4930,0 +4941,1 @@\n+      if (failing())  return;\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":17,"deletions":5,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -91,0 +91,48 @@\n+uint ConvertNode::ideal_reg() const {\n+  return _type->ideal_reg();\n+}\n+\n+Node* ConvertNode::create_convert(BasicType source, BasicType target, Node* input) {\n+  if (source == T_INT) {\n+    if (target == T_LONG) {\n+      return new ConvI2LNode(input);\n+    } else if (target == T_FLOAT) {\n+      return new ConvI2FNode(input);\n+    } else if (target == T_DOUBLE) {\n+      return new ConvI2DNode(input);\n+    }\n+  } else if (source == T_LONG) {\n+    if (target == T_INT) {\n+      return new ConvL2INode(input);\n+    } else if (target == T_FLOAT) {\n+      return new ConvL2FNode(input);\n+    } else if (target == T_DOUBLE) {\n+      return new ConvL2DNode(input);\n+    }\n+  } else if (source == T_FLOAT) {\n+    if (target == T_INT) {\n+      return new ConvF2INode(input);\n+    } else if (target == T_LONG) {\n+      return new ConvF2LNode(input);\n+    } else if (target == T_DOUBLE) {\n+      return new ConvF2DNode(input);\n+    } else if (target == T_SHORT) {\n+      return new ConvF2HFNode(input);\n+    }\n+  } else if (source == T_DOUBLE) {\n+    if (target == T_INT) {\n+      return new ConvD2INode(input);\n+    } else if (target == T_LONG) {\n+      return new ConvD2LNode(input);\n+    } else if (target == T_FLOAT) {\n+      return new ConvD2FNode(input);\n+    }\n+  } else if (source == T_SHORT) {\n+    if (target == T_FLOAT) {\n+      return new ConvHF2FNode(input);\n+    }\n+  }\n+\n+  assert(false, \"Couldn't create conversion for type %s to %s\", type2name(source), type2name(target));\n+  return nullptr;\n+}\n@@ -196,2 +244,3 @@\n-  if (t == Type::FLOAT) return TypeInt::SHORT;\n-  if (StubRoutines::f2hf_adr() == nullptr) return bottom_type();\n+  if (t == Type::FLOAT || StubRoutines::f2hf_adr() == nullptr) {\n+    return TypeInt::SHORT;\n+  }\n@@ -266,2 +315,3 @@\n-  if (t == TypeInt::SHORT) return Type::FLOAT;\n-  if (StubRoutines::hf2f_adr() == nullptr) return bottom_type();\n+  if (t == TypeInt::SHORT || StubRoutines::hf2f_adr() == nullptr) {\n+    return Type::FLOAT;\n+  }\n@@ -273,1 +323,1 @@\n-  return bottom_type();\n+  return Type::FLOAT;\n@@ -283,1 +333,1 @@\n-  return bottom_type();\n+  return Type::DOUBLE;\n@@ -293,1 +343,1 @@\n-  return bottom_type();\n+  return Type::FLOAT;\n@@ -713,1 +763,1 @@\n-  return bottom_type();\n+  return Type::DOUBLE;\n@@ -723,1 +773,1 @@\n-  return bottom_type();\n+  return Type::FLOAT;\n","filename":"src\/hotspot\/share\/opto\/convertnode.cpp","additions":59,"deletions":9,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -45,0 +45,15 @@\n+class ConvertNode : public TypeNode {\n+protected:\n+  ConvertNode(const Type* t, Node* input) : TypeNode(t, 2) {\n+    init_class_id(Class_Convert);\n+    init_req(1, input);\n+  }\n+public:\n+  virtual const Type* in_type() const = 0;\n+  virtual uint ideal_reg() const;\n+\n+  \/\/ Create a convert node for a given input and output type.\n+  \/\/ Conversions to and from half float are specified via T_SHORT.\n+  static Node* create_convert(BasicType source, BasicType target, Node* input);\n+};\n+\n@@ -48,1 +63,1 @@\n-class ConvD2FNode : public Node {\n+class ConvD2FNode : public ConvertNode {\n@@ -50,1 +65,1 @@\n-  ConvD2FNode( Node *in1 ) : Node(0,in1) {}\n+  ConvD2FNode(Node* in1) : ConvertNode(Type::FLOAT,in1) {}\n@@ -52,1 +67,1 @@\n-  virtual const Type *bottom_type() const { return Type::FLOAT; }\n+  virtual const Type* in_type() const { return Type::DOUBLE; }\n@@ -55,2 +70,1 @@\n-  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n-  virtual uint  ideal_reg() const { return Op_RegF; }\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n@@ -61,1 +75,1 @@\n-class ConvD2INode : public Node {\n+class ConvD2INode : public ConvertNode {\n@@ -63,1 +77,1 @@\n-  ConvD2INode( Node *in1 ) : Node(0,in1) {}\n+  ConvD2INode(Node* in1) : ConvertNode(TypeInt::INT,in1) {}\n@@ -65,1 +79,1 @@\n-  virtual const Type *bottom_type() const { return TypeInt::INT; }\n+  virtual const Type* in_type() const { return Type::DOUBLE; }\n@@ -68,2 +82,1 @@\n-  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n-  virtual uint  ideal_reg() const { return Op_RegI; }\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n@@ -74,1 +87,1 @@\n-class ConvD2LNode : public Node {\n+class ConvD2LNode : public ConvertNode {\n@@ -76,1 +89,1 @@\n-  ConvD2LNode( Node *dbl ) : Node(0,dbl) {}\n+  ConvD2LNode(Node* in1) : ConvertNode(TypeLong::LONG, in1) {}\n@@ -78,1 +91,1 @@\n-  virtual const Type *bottom_type() const { return TypeLong::LONG; }\n+  virtual const Type* in_type() const { return Type::DOUBLE; }\n@@ -81,10 +94,1 @@\n-  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n-  virtual uint ideal_reg() const { return Op_RegL; }\n-};\n-\n-class RoundDNode : public Node {\n-  public:\n-  RoundDNode( Node *dbl ) : Node(0,dbl) {}\n-  virtual int Opcode() const;\n-  virtual const Type *bottom_type() const { return TypeLong::LONG; }\n-  virtual uint ideal_reg() const { return Op_RegL; }\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n@@ -95,1 +99,1 @@\n-class ConvF2DNode : public Node {\n+class ConvF2DNode : public ConvertNode {\n@@ -97,1 +101,1 @@\n-  ConvF2DNode( Node *in1 ) : Node(0,in1) {}\n+  ConvF2DNode(Node* in1) : ConvertNode(Type::DOUBLE,in1) {}\n@@ -99,1 +103,1 @@\n-  virtual const Type *bottom_type() const { return Type::DOUBLE; }\n+  virtual const Type* in_type() const { return Type::FLOAT; }\n@@ -101,1 +105,0 @@\n-  virtual uint  ideal_reg() const { return Op_RegD; }\n@@ -106,1 +109,1 @@\n-class ConvF2HFNode : public Node {\n+class ConvF2HFNode : public ConvertNode {\n@@ -108,1 +111,1 @@\n-  ConvF2HFNode( Node *in1 ) : Node(0,in1) {}\n+  ConvF2HFNode(Node* in1) : ConvertNode(TypeInt::SHORT, in1) {}\n@@ -110,1 +113,1 @@\n-  virtual const Type *bottom_type() const { return TypeInt::SHORT; }\n+  virtual const Type* in_type() const { return TypeInt::FLOAT; }\n@@ -112,1 +115,0 @@\n-  virtual uint  ideal_reg() const { return Op_RegI; }\n@@ -117,3 +119,3 @@\n-class ConvF2INode : public Node {\n-  public:\n-  ConvF2INode( Node *in1 ) : Node(0,in1) {}\n+class ConvF2INode : public ConvertNode {\n+public:\n+  ConvF2INode(Node* in1) : ConvertNode(TypeInt::INT, in1) {}\n@@ -121,1 +123,1 @@\n-  virtual const Type *bottom_type() const { return TypeInt::INT; }\n+  virtual const Type* in_type() const { return TypeInt::FLOAT; }\n@@ -124,2 +126,1 @@\n-  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n-  virtual uint  ideal_reg() const { return Op_RegI; }\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n@@ -128,1 +129,0 @@\n-\n@@ -131,3 +131,3 @@\n-class ConvF2LNode : public Node {\n-  public:\n-  ConvF2LNode( Node *in1 ) : Node(0,in1) {}\n+class ConvF2LNode : public ConvertNode {\n+public:\n+  ConvF2LNode(Node* in1) : ConvertNode(TypeLong::LONG, in1) {}\n@@ -135,1 +135,1 @@\n-  virtual const Type *bottom_type() const { return TypeLong::LONG; }\n+  virtual const Type* in_type() const { return TypeInt::FLOAT; }\n@@ -138,2 +138,1 @@\n-  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n-  virtual uint  ideal_reg() const { return Op_RegL; }\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n@@ -144,3 +143,3 @@\n-class ConvHF2FNode : public Node {\n-  public:\n-  ConvHF2FNode( Node *in1 ) : Node(0,in1) {}\n+class ConvHF2FNode : public ConvertNode {\n+public:\n+  ConvHF2FNode(Node* in1) : ConvertNode(Type::FLOAT, in1) {}\n@@ -148,1 +147,1 @@\n-  virtual const Type *bottom_type() const { return Type::FLOAT; }\n+  virtual const Type* in_type() const { return TypeInt::SHORT; }\n@@ -150,1 +149,0 @@\n-  virtual uint  ideal_reg() const { return Op_RegF; }\n@@ -155,3 +153,3 @@\n-class ConvI2DNode : public Node {\n-  public:\n-  ConvI2DNode( Node *in1 ) : Node(0,in1) {}\n+class ConvI2DNode : public ConvertNode {\n+public:\n+  ConvI2DNode(Node* in1) : ConvertNode(Type::DOUBLE, in1) {}\n@@ -159,1 +157,1 @@\n-  virtual const Type *bottom_type() const { return Type::DOUBLE; }\n+  virtual const Type* in_type() const { return TypeInt::INT; }\n@@ -161,1 +159,0 @@\n-  virtual uint  ideal_reg() const { return Op_RegD; }\n@@ -166,3 +163,3 @@\n-class ConvI2FNode : public Node {\n-  public:\n-  ConvI2FNode( Node *in1 ) : Node(0,in1) {}\n+class ConvI2FNode : public ConvertNode {\n+public:\n+  ConvI2FNode(Node* in1) : ConvertNode(Type::FLOAT, in1) {}\n@@ -170,1 +167,1 @@\n-  virtual const Type *bottom_type() const { return Type::FLOAT; }\n+  virtual const Type* in_type() const { return TypeInt::INT; }\n@@ -173,9 +170,0 @@\n-  virtual uint  ideal_reg() const { return Op_RegF; }\n-};\n-\n-class RoundFNode : public Node {\n-  public:\n-  RoundFNode( Node *in1 ) : Node(0,in1) {}\n-  virtual int Opcode() const;\n-  virtual const Type *bottom_type() const { return TypeInt::INT; }\n-  virtual uint  ideal_reg() const { return Op_RegI; }\n@@ -186,1 +174,1 @@\n-class ConvI2LNode : public TypeNode {\n+class ConvI2LNode : public ConvertNode {\n@@ -188,3 +176,1 @@\n-  ConvI2LNode(Node *in1, const TypeLong* t = TypeLong::INT)\n-  : TypeNode(t, 2)\n-  { init_req(1, in1); }\n+  ConvI2LNode(Node* in1, const TypeLong* t = TypeLong::INT) : ConvertNode(t, in1) {}\n@@ -192,0 +178,1 @@\n+  virtual const Type* in_type() const { return TypeInt::INT; }\n@@ -193,1 +180,1 @@\n-  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n@@ -195,1 +182,0 @@\n-  virtual uint  ideal_reg() const { return Op_RegL; }\n@@ -200,3 +186,3 @@\n-class ConvL2DNode : public Node {\n-  public:\n-  ConvL2DNode( Node *in1 ) : Node(0,in1) {}\n+class ConvL2DNode : public ConvertNode {\n+public:\n+  ConvL2DNode(Node* in1) : ConvertNode(Type::DOUBLE, in1) {}\n@@ -204,1 +190,1 @@\n-  virtual const Type *bottom_type() const { return Type::DOUBLE; }\n+  virtual const Type* in_type() const { return TypeLong::LONG; }\n@@ -206,1 +192,0 @@\n-  virtual uint ideal_reg() const { return Op_RegD; }\n@@ -211,3 +196,3 @@\n-class ConvL2FNode : public Node {\n-  public:\n-  ConvL2FNode( Node *in1 ) : Node(0,in1) {}\n+class ConvL2FNode : public ConvertNode {\n+public:\n+  ConvL2FNode(Node* in1) : ConvertNode(Type::FLOAT, in1) {}\n@@ -215,1 +200,1 @@\n-  virtual const Type *bottom_type() const { return Type::FLOAT; }\n+  virtual const Type* in_type() const { return TypeLong::LONG; }\n@@ -217,1 +202,0 @@\n-  virtual uint  ideal_reg() const { return Op_RegF; }\n@@ -222,1 +206,1 @@\n-class ConvL2INode : public TypeNode {\n+class ConvL2INode : public ConvertNode {\n@@ -224,4 +208,1 @@\n-  ConvL2INode(Node *in1, const TypeInt* t = TypeInt::INT)\n-  : TypeNode(t, 2) {\n-    init_req(1, in1);\n-  }\n+  ConvL2INode(Node* in1, const TypeInt* t = TypeInt::INT) : ConvertNode(t, in1) {}\n@@ -229,0 +210,1 @@\n+  virtual const Type* in_type() const { return TypeLong::LONG; }\n@@ -231,1 +213,16 @@\n-  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n+};\n+\n+class RoundDNode : public Node {\n+public:\n+  RoundDNode(Node* in1) : Node(nullptr, in1) {}\n+  virtual int Opcode() const;\n+  virtual const Type* bottom_type() const { return TypeLong::LONG; }\n+  virtual uint ideal_reg() const { return Op_RegL; }\n+};\n+\n+class RoundFNode : public Node {\n+public:\n+  RoundFNode(Node* in1) : Node(nullptr, in1) {}\n+  virtual int Opcode() const;\n+  virtual const Type* bottom_type() const { return TypeInt::INT; }\n","filename":"src\/hotspot\/share\/opto\/convertnode.hpp","additions":86,"deletions":89,"binary":false,"changes":175,"status":"modified"},{"patch":"@@ -85,1 +85,2 @@\n-    assert(!has_exceptions(), \"user must call transfer_exceptions_into_jvms\");\n+    assert(failing() || !has_exceptions(),\n+           \"unless compilation failed, user must call transfer_exceptions_into_jvms\");\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -4695,0 +4695,1 @@\n+  if (C->failing()) return;\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1197,1 +1197,1 @@\n-\n+      if (C->failing()) { return; }\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -359,1 +359,3 @@\n-  C->set_cached_top_node(xform( C->top(), live_nodes ));\n+  Node* const n = xform(C->top(), live_nodes);\n+  if (C->failing()) return;\n+  C->set_cached_top_node(n);\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -73,0 +73,1 @@\n+class ConvertNode;\n@@ -734,0 +735,1 @@\n+      DEFINE_CLASS_ID(Convert, Type, 10)\n@@ -892,0 +894,1 @@\n+  DEFINE_CLASS_QUERY(Convert)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1578,0 +1578,1 @@\n+    if (failing()) return;\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -731,1 +731,1 @@\n-  Arena* arena =  new (mtTest) Arena(mtTest, size_t(init_size));\n+  Arena* arena =  new (mtTest) Arena(mtTest, Arena::Tag::tag_other, size_t(init_size));\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -69,13 +69,16 @@\n-  if (displaced_header().is_neutral()) {\n-    \/\/ The object is locked and the resulting ObjectMonitor* will also be\n-    \/\/ locked so it can't be async deflated until ownership is dropped.\n-    ObjectSynchronizer::inflate_helper(obj);\n-    \/\/ WARNING: We cannot put a check here, because the inflation\n-    \/\/ will not update the displaced header. Once BasicLock is inflated,\n-    \/\/ no one should ever look at its content.\n-  } else {\n-    \/\/ Typically the displaced header will be 0 (recursive stack lock) or\n-    \/\/ unused_mark.  Naively we'd like to assert that the displaced mark\n-    \/\/ value is either 0, neutral, or 3.  But with the advent of the\n-    \/\/ store-before-CAS avoidance in fast_lock\/compiler_lock_object\n-    \/\/ we can find any flavor mark in the displaced mark.\n+  if (LockingMode == LM_LEGACY) {\n+    if (displaced_header().is_neutral()) {\n+      \/\/ The object is locked and the resulting ObjectMonitor* will also be\n+      \/\/ locked so it can't be async deflated until ownership is dropped.\n+      ObjectSynchronizer::inflate_helper(obj);\n+      \/\/ WARNING: We cannot put a check here, because the inflation\n+      \/\/ will not update the displaced header. Once BasicLock is inflated,\n+      \/\/ no one should ever look at its content.\n+    } else {\n+      \/\/ Typically the displaced header will be 0 (recursive stack lock) or\n+      \/\/ unused_mark.  Naively we'd like to assert that the displaced mark\n+      \/\/ value is either 0, neutral, or 3.  But with the advent of the\n+      \/\/ store-before-CAS avoidance in fast_lock\/compiler_lock_object\n+      \/\/ we can find any flavor mark in the displaced mark.\n+    }\n+    dest->set_displaced_header(displaced_header());\n@@ -83,1 +86,5 @@\n-  dest->set_displaced_header(displaced_header());\n+#ifdef ASSERT\n+  else {\n+    dest->set_displaced_header(markWord(badDispHeaderDeopt));\n+  }\n+#endif\n","filename":"src\/hotspot\/share\/runtime\/basicLock.cpp","additions":21,"deletions":14,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -190,1 +190,1 @@\n-  HandleArea(HandleArea* prev) : Arena(mtThread, Chunk::tiny_size) {\n+  HandleArea(HandleArea* prev) : Arena(mtThread, Tag::tag_ha, Chunk::tiny_size) {\n","filename":"src\/hotspot\/share\/runtime\/handles.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"compiler\/compilationMemoryStatistic.hpp\"\n@@ -228,0 +229,7 @@\n+#else\n+\n+void print_method_invocation_histogram() {}\n+void print_bytecode_count() {}\n+\n+#endif \/\/ PRODUCT\n+\n@@ -337,46 +345,2 @@\n-  ThreadsSMRSupport::log_statistics();\n-}\n-\n-#else \/\/ PRODUCT MODE STATISTICS\n-\n-void print_statistics() {\n-\n-  if (PrintMethodData) {\n-    print_method_profiling_data();\n-  }\n-\n-  if (CITime) {\n-    CompileBroker::print_times();\n-  }\n-\n-#ifdef COMPILER2_OR_JVMCI\n-  if ((LogVMOutput || LogCompilation) && UseCompiler) {\n-    \/\/ Only print the statistics to the log file\n-    FlagSetting fs(DisplayVMOutput, false);\n-    Deoptimization::print_statistics();\n-  }\n-#endif \/* COMPILER2 || INCLUDE_JVMCI *\/\n-\n-  if (PrintCodeCache) {\n-    MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n-    CodeCache::print();\n-  }\n-\n-  \/\/ CodeHeap State Analytics.\n-  if (PrintCodeHeapAnalytics) {\n-    CompileBroker::print_heapinfo(nullptr, \"all\", 4096); \/\/ details\n-  }\n-\n-#ifdef COMPILER2\n-  if (PrintPreciseRTMLockingStatistics) {\n-    OptoRuntime::print_named_counters();\n-  }\n-#endif\n-\n-  \/\/ Native memory tracking data\n-  if (PrintNMTStatistics) {\n-    MemTracker::final_report(tty);\n-  }\n-\n-  if (PrintMetaspaceStatisticsAtExit) {\n-    MetaspaceUtils::print_basic_report(tty, 0);\n+  if (CompilerOracle::should_print_final_memstat_report()) {\n+    CompilationMemoryStatistic::print_all_by_size(tty, false, 0);\n@@ -388,2 +352,0 @@\n-#endif\n-\n","filename":"src\/hotspot\/share\/runtime\/java.cpp","additions":10,"deletions":48,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -50,4 +50,8 @@\n-  JavaThread* thread = JavaThread::current();\n-  bool is_owning = &thread->lock_stack() == this;\n-  assert(is_owning == (get_thread() == thread), \"is_owning sanity\");\n-  return is_owning;\n+  Thread* current = Thread::current();\n+  if (current->is_Java_thread()) {\n+    JavaThread* thread = JavaThread::cast(current);\n+    bool is_owning = &thread->lock_stack() == this;\n+    assert(is_owning == (get_thread() == thread), \"is_owning sanity\");\n+    return is_owning;\n+  }\n+  return false;\n","filename":"src\/hotspot\/share\/runtime\/lockStack.inline.hpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -142,0 +142,1 @@\n+Mutex*   NMTCompilationCostHistory_lock = nullptr;\n@@ -312,0 +313,1 @@\n+  MUTEX_DEFN(NMTCompilationCostHistory_lock  , PaddedMutex  , nosafepoint);\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -120,0 +120,1 @@\n+extern Mutex*   NMTCompilationCostHistory_lock;  \/\/ guards NMT compilation cost history\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3260,6 +3260,11 @@\n-      \/\/ Inflate so the object's header no longer refers to the BasicLock.\n-      if (lock->displaced_header().is_unlocked()) {\n-        \/\/ The object is locked and the resulting ObjectMonitor* will also be\n-        \/\/ locked so it can't be async deflated until ownership is dropped.\n-        \/\/ See the big comment in basicLock.cpp: BasicLock::move_to().\n-        ObjectSynchronizer::inflate_helper(kptr2->obj());\n+      if (LockingMode == LM_LEGACY) {\n+        \/\/ Inflate so the object's header no longer refers to the BasicLock.\n+        if (lock->displaced_header().is_unlocked()) {\n+          \/\/ The object is locked and the resulting ObjectMonitor* will also be\n+          \/\/ locked so it can't be async deflated until ownership is dropped.\n+          \/\/ See the big comment in basicLock.cpp: BasicLock::move_to().\n+          ObjectSynchronizer::inflate_helper(kptr2->obj());\n+        }\n+        \/\/ Now the displaced header is free to move because the\n+        \/\/ object's header no longer refers to it.\n+        buf[i] = (intptr_t)lock->displaced_header().value();\n@@ -3267,3 +3272,6 @@\n-      \/\/ Now the displaced header is free to move because the\n-      \/\/ object's header no longer refers to it.\n-      buf[i++] = (intptr_t)lock->displaced_header().value();\n+#ifdef ASSERT\n+      else {\n+        buf[i] = badDispHeaderOSR;\n+      }\n+#endif\n+      i++;\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":17,"deletions":9,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -578,1 +578,0 @@\n-  static void print_statistics();\n@@ -582,0 +581,2 @@\n+\n+  static void print_statistics() PRODUCT_RETURN;\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+class CompilerThread;\n@@ -327,0 +328,6 @@\n+  \/\/ Convenience cast functions\n+  CompilerThread* as_Compiler_thread() const {\n+    assert(is_Compiler_thread(), \"Must be compiler thread\");\n+    return (CompilerThread*)this;\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1496,0 +1496,1 @@\n+  declare_c2_type(ConvertNode, TypeNode)                                  \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+#include \"compiler\/compilationMemoryStatistic.hpp\"\n+#include \"compiler\/compiler_globals.hpp\"\n@@ -141,0 +143,1 @@\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<CompilationMemoryStatisticDCmd>(full_export, true, false));\n@@ -1137,0 +1140,14 @@\n+\n+CompilationMemoryStatisticDCmd::CompilationMemoryStatisticDCmd(outputStream* output, bool heap) :\n+    DCmdWithParser(output, heap),\n+  _human_readable(\"-H\", \"Human readable format\", \"BOOLEAN\", false, \"false\"),\n+  _minsize(\"-s\", \"Minimum memory size\", \"MEMORY SIZE\", false, \"0\") {\n+  _dcmdparser.add_dcmd_option(&_human_readable);\n+  _dcmdparser.add_dcmd_option(&_minsize);\n+}\n+\n+void CompilationMemoryStatisticDCmd::execute(DCmdSource source, TRAPS) {\n+  const bool human_readable = _human_readable.value();\n+  const size_t minsize = _minsize.has_value() ? _minsize.value()._size : 0;\n+  CompilationMemoryStatistic::print_all_by_size(output(), human_readable, minsize);\n+}\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -957,0 +957,24 @@\n+class CompilationMemoryStatisticDCmd: public DCmdWithParser {\n+protected:\n+  DCmdArgument<bool> _human_readable;\n+  DCmdArgument<MemorySizeArgument> _minsize;\n+public:\n+  static int num_arguments() { return 2; }\n+  CompilationMemoryStatisticDCmd(outputStream* output, bool heap);\n+  static const char* name() {\n+    return \"Compiler.memory\";\n+  }\n+  static const char* description() {\n+    return \"Print compilation footprint\";\n+  }\n+  static const char* impact() {\n+    return \"Medium: Pause time depends on number of compiled methods\";\n+  }\n+  static const JavaPermission permission() {\n+    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n+                        \"monitor\", nullptr};\n+    return p;\n+  }\n+  virtual void execute(DCmdSource source, TRAPS);\n+};\n+\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+#include \"runtime\/continuationWrapper.inline.hpp\"\n@@ -1388,1 +1389,0 @@\n-\n@@ -1454,0 +1454,304 @@\n+\/\/ Support class used to generate HPROF_GC_ROOT_JAVA_FRAME records.\n+\n+class JavaStackRefDumper : public StackObj {\n+private:\n+  AbstractDumpWriter* _writer;\n+  u4 _thread_serial_num;\n+  int _frame_num;\n+  AbstractDumpWriter* writer() const { return _writer; }\n+public:\n+  JavaStackRefDumper(AbstractDumpWriter* writer, u4 thread_serial_num)\n+      : _writer(writer), _thread_serial_num(thread_serial_num), _frame_num(-1) \/\/ default - empty stack\n+  {\n+  }\n+\n+  void set_frame_number(int n) { _frame_num = n; }\n+\n+  void dump_java_stack_refs(StackValueCollection* values);\n+};\n+\n+void JavaStackRefDumper::dump_java_stack_refs(StackValueCollection* values) {\n+  for (int index = 0; index < values->size(); index++) {\n+    if (values->at(index)->type() == T_OBJECT) {\n+      oop o = values->obj_at(index)();\n+      if (o != nullptr) {\n+        u4 size = 1 + sizeof(address) + 4 + 4;\n+        writer()->start_sub_record(HPROF_GC_ROOT_JAVA_FRAME, size);\n+        writer()->write_objectID(o);\n+        writer()->write_u4(_thread_serial_num);\n+        writer()->write_u4((u4)_frame_num);\n+        writer()->end_sub_record();\n+      }\n+    }\n+  }\n+}\n+\n+\/\/ Class to collect, store and dump thread-related data:\n+\/\/ - HPROF_TRACE and HPROF_FRAME records;\n+\/\/ - HPROF_GC_ROOT_THREAD_OBJ\/HPROF_GC_ROOT_JAVA_FRAME\/HPROF_GC_ROOT_JNI_LOCAL subrecords.\n+class ThreadDumper : public CHeapObj<mtInternal> {\n+public:\n+  enum class ThreadType { Platform, MountedVirtual, UnmountedVirtual };\n+\n+private:\n+  ThreadType _thread_type;\n+  JavaThread* _java_thread;\n+  oop _thread_oop;\n+\n+  GrowableArray<StackFrameInfo*>* _frames;\n+  \/\/ non-null if the thread is OOM thread\n+  Method* _oome_constructor;\n+  int _thread_serial_num;\n+  int _start_frame_serial_num;\n+\n+  vframe* get_top_frame() const;\n+\n+public:\n+  static bool should_dump_pthread(JavaThread* thread) {\n+    return thread->threadObj() != nullptr && !thread->is_exiting() && !thread->is_hidden_from_external_view();\n+  }\n+\n+  static bool should_dump_vthread(oop vt) {\n+    return java_lang_VirtualThread::state(vt) != java_lang_VirtualThread::NEW\n+        && java_lang_VirtualThread::state(vt) != java_lang_VirtualThread::TERMINATED;\n+  }\n+\n+  ThreadDumper(ThreadType thread_type, JavaThread* java_thread, oop thread_oop);\n+\n+  \/\/ affects frame_count\n+  void add_oom_frame(Method* oome_constructor) {\n+    assert(_start_frame_serial_num == 0, \"add_oom_frame cannot be called after init_serial_nums\");\n+    _oome_constructor = oome_constructor;\n+  }\n+\n+  void init_serial_nums(volatile int* thread_counter, volatile int* frame_counter) {\n+    assert(_start_frame_serial_num == 0, \"already initialized\");\n+    _thread_serial_num = Atomic::fetch_then_add(thread_counter, 1);\n+    _start_frame_serial_num = Atomic::fetch_then_add(frame_counter, frame_count());\n+  }\n+\n+  bool oom_thread() const {\n+    return _oome_constructor != nullptr;\n+  }\n+\n+  int frame_count() const {\n+    return _frames->length() + (oom_thread() ? 1 : 0);\n+  }\n+\n+  u4 thread_serial_num() const {\n+    return (u4)_thread_serial_num;\n+  }\n+\n+  u4 stack_trace_serial_num() const {\n+    return (u4)(_thread_serial_num + STACK_TRACE_ID);\n+  }\n+\n+  \/\/ writes HPROF_TRACE and HPROF_FRAME records\n+  \/\/ returns number of dumped frames\n+  void dump_stack_traces(AbstractDumpWriter* writer, GrowableArray<Klass*>* klass_map);\n+\n+  \/\/ writes HPROF_GC_ROOT_THREAD_OBJ subrecord\n+  void dump_thread_obj(AbstractDumpWriter* writer);\n+\n+  \/\/ Walk the stack of the thread.\n+  \/\/ Dumps a HPROF_GC_ROOT_JAVA_FRAME subrecord for each local\n+  \/\/ Dumps a HPROF_GC_ROOT_JNI_LOCAL subrecord for each JNI local\n+  void dump_stack_refs(AbstractDumpWriter* writer);\n+\n+};\n+\n+ThreadDumper::ThreadDumper(ThreadType thread_type, JavaThread* java_thread, oop thread_oop)\n+    : _thread_type(thread_type), _java_thread(java_thread), _thread_oop(thread_oop),\n+      _oome_constructor(nullptr),\n+      _thread_serial_num(0), _start_frame_serial_num(0)\n+{\n+  \/\/ sanity checks\n+  if (_thread_type == ThreadType::UnmountedVirtual) {\n+    assert(_java_thread == nullptr, \"sanity\");\n+    assert(_thread_oop != nullptr, \"sanity\");\n+  } else {\n+    assert(_java_thread != nullptr, \"sanity\");\n+    assert(_thread_oop != nullptr, \"sanity\");\n+  }\n+\n+  _frames = new (mtServiceability) GrowableArray<StackFrameInfo*>(10, mtServiceability);\n+  bool stop_at_vthread_entry = _thread_type == ThreadType::MountedVirtual;\n+\n+  \/\/ vframes are resource allocated\n+  Thread* current_thread = Thread::current();\n+  ResourceMark rm(current_thread);\n+  HandleMark hm(current_thread);\n+\n+  for (vframe* vf = get_top_frame(); vf != nullptr; vf = vf->sender()) {\n+    if (stop_at_vthread_entry && vf->is_vthread_entry()) {\n+      break;\n+    }\n+    if (vf->is_java_frame()) {\n+      javaVFrame* jvf = javaVFrame::cast(vf);\n+      _frames->append(new StackFrameInfo(jvf, false));\n+    } else {\n+      \/\/ ignore non-Java frames\n+    }\n+  }\n+}\n+\n+void ThreadDumper::dump_stack_traces(AbstractDumpWriter* writer, GrowableArray<Klass*>* klass_map) {\n+  assert(_thread_serial_num != 0 && _start_frame_serial_num != 0, \"serial_nums are not initialized\");\n+\n+  \/\/ write HPROF_FRAME records for this thread's stack trace\n+  int depth = _frames->length();\n+  int frame_serial_num = _start_frame_serial_num;\n+\n+  if (oom_thread()) {\n+    \/\/ OOM thread\n+    \/\/ write fake frame that makes it look like the thread, which caused OOME,\n+    \/\/ is in the OutOfMemoryError zero-parameter constructor\n+    int oome_serial_num = klass_map->find(_oome_constructor->method_holder());\n+    \/\/ the class serial number starts from 1\n+    assert(oome_serial_num > 0, \"OutOfMemoryError class not found\");\n+    DumperSupport::dump_stack_frame(writer, ++frame_serial_num, oome_serial_num, _oome_constructor, 0);\n+    depth++;\n+  }\n+\n+  for (int j = 0; j < _frames->length(); j++) {\n+    StackFrameInfo* frame = _frames->at(j);\n+    Method* m = frame->method();\n+    int class_serial_num = klass_map->find(m->method_holder());\n+    \/\/ the class serial number starts from 1\n+    assert(class_serial_num > 0, \"class not found\");\n+    DumperSupport::dump_stack_frame(writer, ++frame_serial_num, class_serial_num, m, frame->bci());\n+  }\n+\n+  \/\/ write HPROF_TRACE record for the thread\n+  DumperSupport::write_header(writer, HPROF_TRACE, checked_cast<u4>(3 * sizeof(u4) + depth * oopSize));\n+  writer->write_u4(stack_trace_serial_num());   \/\/ stack trace serial number\n+  writer->write_u4(thread_serial_num());        \/\/ thread serial number\n+  writer->write_u4((u4)depth);                  \/\/ frame count (including oom frame)\n+  for (int j = 1; j <= depth; j++) {\n+    writer->write_id(_start_frame_serial_num + j);\n+  }\n+}\n+\n+void ThreadDumper::dump_thread_obj(AbstractDumpWriter * writer) {\n+  assert(_thread_serial_num != 0 && _start_frame_serial_num != 0, \"serial_num is not initialized\");\n+\n+  u4 size = 1 + sizeof(address) + 4 + 4;\n+  writer->start_sub_record(HPROF_GC_ROOT_THREAD_OBJ, size);\n+  writer->write_objectID(_thread_oop);\n+  writer->write_u4(thread_serial_num());      \/\/ thread serial number\n+  writer->write_u4(stack_trace_serial_num()); \/\/ stack trace serial number\n+  writer->end_sub_record();\n+}\n+\n+void ThreadDumper::dump_stack_refs(AbstractDumpWriter * writer) {\n+  assert(_thread_serial_num != 0 && _start_frame_serial_num != 0, \"serial_num is not initialized\");\n+\n+  JNILocalsDumper blk(writer, thread_serial_num());\n+  if (_thread_type == ThreadType::Platform) {\n+    if (!_java_thread->has_last_Java_frame()) {\n+      \/\/ no last java frame but there may be JNI locals\n+      _java_thread->active_handles()->oops_do(&blk);\n+      return;\n+    }\n+  }\n+\n+  JavaStackRefDumper java_ref_dumper(writer, thread_serial_num());\n+\n+  \/\/ vframes are resource allocated\n+  Thread* current_thread = Thread::current();\n+  ResourceMark rm(current_thread);\n+  HandleMark hm(current_thread);\n+\n+  bool stopAtVthreadEntry = _thread_type == ThreadType::MountedVirtual;\n+  frame* last_entry_frame = nullptr;\n+  bool is_top_frame = true;\n+  int depth = 0;\n+  if (oom_thread()) {\n+    depth++;\n+  }\n+\n+  for (vframe* vf = get_top_frame(); vf != nullptr; vf = vf->sender()) {\n+    if (stopAtVthreadEntry && vf->is_vthread_entry()) {\n+      break;\n+    }\n+\n+    if (vf->is_java_frame()) {\n+      javaVFrame* jvf = javaVFrame::cast(vf);\n+      if (!(jvf->method()->is_native())) {\n+        java_ref_dumper.set_frame_number(depth);\n+        java_ref_dumper.dump_java_stack_refs(jvf->locals());\n+        java_ref_dumper.dump_java_stack_refs(jvf->expressions());\n+      } else {\n+        \/\/ native frame\n+        blk.set_frame_number(depth);\n+        if (is_top_frame) {\n+          \/\/ JNI locals for the top frame.\n+          assert(_java_thread != nullptr, \"impossible for unmounted vthread\");\n+          _java_thread->active_handles()->oops_do(&blk);\n+        } else {\n+          if (last_entry_frame != nullptr) {\n+            \/\/ JNI locals for the entry frame\n+            assert(last_entry_frame->is_entry_frame(), \"checking\");\n+            last_entry_frame->entry_frame_call_wrapper()->handles()->oops_do(&blk);\n+          }\n+        }\n+      }\n+      last_entry_frame = nullptr;\n+      \/\/ increment only for Java frames\n+      depth++;\n+    } else {\n+      \/\/ externalVFrame - for an entry frame then we report the JNI locals\n+      \/\/ when we find the corresponding javaVFrame\n+      frame* fr = vf->frame_pointer();\n+      assert(fr != nullptr, \"sanity check\");\n+      if (fr->is_entry_frame()) {\n+        last_entry_frame = fr;\n+      }\n+    }\n+  is_top_frame = false;\n+  }\n+  assert(depth == frame_count(), \"total number of Java frames not matched\");\n+}\n+\n+vframe* ThreadDumper::get_top_frame() const {\n+  if (_thread_type == ThreadType::UnmountedVirtual) {\n+    ContinuationWrapper cont(java_lang_VirtualThread::continuation(_thread_oop));\n+    if (cont.is_empty()) {\n+      return nullptr;\n+    }\n+    assert(!cont.is_mounted(), \"sanity check\");\n+    stackChunkOop chunk = cont.last_nonempty_chunk();\n+    if (chunk == nullptr || chunk->is_empty()) {\n+      return nullptr;\n+    }\n+\n+    RegisterMap reg_map(cont.continuation(), RegisterMap::UpdateMap::include);\n+    frame fr = chunk->top_frame(&reg_map);\n+    vframe* vf = vframe::new_vframe(&fr, &reg_map, nullptr); \/\/ don't need JavaThread\n+    return vf;\n+  }\n+\n+  RegisterMap reg_map(_java_thread,\n+      RegisterMap::UpdateMap::include,\n+      RegisterMap::ProcessFrames::include,\n+      RegisterMap::WalkContinuation::skip);\n+  switch (_thread_type) {\n+  case ThreadType::Platform:\n+    if (!_java_thread->has_last_Java_frame()) {\n+      return nullptr;\n+    }\n+    return _java_thread->is_vthread_mounted()\n+        ? _java_thread->carrier_last_java_vframe(&reg_map)\n+        : _java_thread->platform_thread_last_java_vframe(&reg_map);\n+\n+  case ThreadType::MountedVirtual:\n+    return _java_thread->last_java_vframe(&reg_map);\n+\n+  default: \/\/ make compilers happy\n+      break;\n+  }\n+  ShouldNotReachHere();\n+  return nullptr;\n+}\n+\n+\n@@ -1686,2 +1990,6 @@\n-  ThreadStackTrace**      _stack_traces;\n-  int                     _num_threads;\n+\n+  ThreadDumper**          _thread_dumpers; \/\/ platform, carrier and mounted virtual threads\n+  int                     _thread_dumpers_count;\n+  volatile int            _thread_serial_num;\n+  volatile int            _frame_serial_num;\n+\n@@ -1724,3 +2032,2 @@\n-  \/\/ HPROF_GC_ROOT_THREAD_OBJ records\n-  int do_thread(JavaThread* thread, u4 thread_serial_num);\n-  void do_threads();\n+  \/\/ HPROF_GC_ROOT_THREAD_OBJ records for platform and mounted virtual threads\n+  void dump_threads();\n@@ -1732,1 +2039,5 @@\n-  \/\/ HPROF_TRACE and HPROF_FRAME records\n+  bool is_oom_thread(JavaThread* thread) const {\n+    return thread == _oome_thread && _oome_constructor != nullptr;\n+  }\n+\n+  \/\/ HPROF_TRACE and HPROF_FRAME records for platform and mounted virtual threads\n@@ -1745,2 +2056,6 @@\n-    _stack_traces = nullptr;\n-    _num_threads = 0;\n+\n+    _thread_dumpers = nullptr;\n+    _thread_dumpers_count = 0;\n+    _thread_serial_num = 1;\n+    _frame_serial_num = 1;\n+\n@@ -1766,3 +2081,3 @@\n-    if (_stack_traces != nullptr) {\n-      for (int i=0; i < _num_threads; i++) {\n-        delete _stack_traces[i];\n+    if (_thread_dumpers != nullptr) {\n+      for (int i = 0; i < _thread_dumpers_count; i++) {\n+        delete _thread_dumpers[i];\n@@ -1770,1 +2085,1 @@\n-      FREE_C_HEAP_ARRAY(ThreadStackTrace*, _stack_traces);\n+      FREE_C_HEAP_ARRAY(ThreadDumper*, _thread_dumpers);\n@@ -1772,0 +2087,1 @@\n+\n@@ -1838,94 +2154,6 @@\n-\/\/ Walk the stack of the given thread.\n-\/\/ Dumps a HPROF_GC_ROOT_JAVA_FRAME record for each local\n-\/\/ Dumps a HPROF_GC_ROOT_JNI_LOCAL record for each JNI local\n-\/\/\n-\/\/ It returns the number of Java frames in this thread stack\n-int VM_HeapDumper::do_thread(JavaThread* java_thread, u4 thread_serial_num) {\n-  JNILocalsDumper blk(writer(), thread_serial_num);\n-\n-  oop threadObj = java_thread->threadObj();\n-  assert(threadObj != nullptr, \"sanity check\");\n-\n-  int stack_depth = 0;\n-  if (java_thread->has_last_Java_frame()) {\n-\n-    \/\/ vframes are resource allocated\n-    Thread* current_thread = Thread::current();\n-    ResourceMark rm(current_thread);\n-    HandleMark hm(current_thread);\n-\n-    RegisterMap reg_map(java_thread,\n-                        RegisterMap::UpdateMap::include,\n-                        RegisterMap::ProcessFrames::include,\n-                        RegisterMap::WalkContinuation::skip);\n-    frame f = java_thread->last_frame();\n-    vframe* vf = vframe::new_vframe(&f, &reg_map, java_thread);\n-    frame* last_entry_frame = nullptr;\n-    int extra_frames = 0;\n-\n-    if (java_thread == _oome_thread && _oome_constructor != nullptr) {\n-      extra_frames++;\n-    }\n-    while (vf != nullptr) {\n-      blk.set_frame_number(stack_depth);\n-      if (vf->is_java_frame()) {\n-\n-        \/\/ java frame (interpreted, compiled, ...)\n-        javaVFrame *jvf = javaVFrame::cast(vf);\n-        if (!(jvf->method()->is_native())) {\n-          StackValueCollection* locals = jvf->locals();\n-          for (int slot=0; slot<locals->size(); slot++) {\n-            if (locals->at(slot)->type() == T_OBJECT) {\n-              oop o = locals->obj_at(slot)();\n-\n-              if (o != nullptr) {\n-                u4 size = 1 + sizeof(address) + 4 + 4;\n-                writer()->start_sub_record(HPROF_GC_ROOT_JAVA_FRAME, size);\n-                writer()->write_objectID(o);\n-                writer()->write_u4(thread_serial_num);\n-                writer()->write_u4((u4) (stack_depth + extra_frames));\n-                writer()->end_sub_record();\n-              }\n-            }\n-          }\n-          StackValueCollection *exprs = jvf->expressions();\n-          for(int index = 0; index < exprs->size(); index++) {\n-            if (exprs->at(index)->type() == T_OBJECT) {\n-               oop o = exprs->obj_at(index)();\n-               if (o != nullptr) {\n-                 u4 size = 1 + sizeof(address) + 4 + 4;\n-                 writer()->start_sub_record(HPROF_GC_ROOT_JAVA_FRAME, size);\n-                 writer()->write_objectID(o);\n-                 writer()->write_u4(thread_serial_num);\n-                 writer()->write_u4((u4) (stack_depth + extra_frames));\n-                 writer()->end_sub_record();\n-               }\n-             }\n-          }\n-        } else {\n-          \/\/ native frame\n-          if (stack_depth == 0) {\n-            \/\/ JNI locals for the top frame.\n-            java_thread->active_handles()->oops_do(&blk);\n-          } else {\n-            if (last_entry_frame != nullptr) {\n-              \/\/ JNI locals for the entry frame\n-              assert(last_entry_frame->is_entry_frame(), \"checking\");\n-              last_entry_frame->entry_frame_call_wrapper()->handles()->oops_do(&blk);\n-            }\n-          }\n-        }\n-        \/\/ increment only for Java frames\n-        stack_depth++;\n-        last_entry_frame = nullptr;\n-\n-      } else {\n-        \/\/ externalVFrame - if it's an entry frame then report any JNI locals\n-        \/\/ as roots when we find the corresponding native javaVFrame\n-        frame* fr = vf->frame_pointer();\n-        assert(fr != nullptr, \"sanity check\");\n-        if (fr->is_entry_frame()) {\n-          last_entry_frame = fr;\n-        }\n-      }\n-      vf = vf->sender();\n+\/\/ Write a HPROF_GC_ROOT_THREAD_OBJ record for platform\/carrier and mounted virtual threads.\n+\/\/ Then walk the stack so that locals and JNI locals are dumped.\n+void VM_HeapDumper::dump_threads() {\n+    for (int i = 0; i < _thread_dumpers_count; i++) {\n+        _thread_dumpers[i]->dump_thread_obj(writer());\n+        _thread_dumpers[i]->dump_stack_refs(writer());\n@@ -1933,26 +2161,0 @@\n-  } else {\n-    \/\/ no last java frame but there may be JNI locals\n-    java_thread->active_handles()->oops_do(&blk);\n-  }\n-  return stack_depth;\n-}\n-\n-\n-\/\/ write a HPROF_GC_ROOT_THREAD_OBJ record for each java thread. Then walk\n-\/\/ the stack so that locals and JNI locals are dumped.\n-void VM_HeapDumper::do_threads() {\n-  for (int i=0; i < _num_threads; i++) {\n-    JavaThread* thread = _stack_traces[i]->thread();\n-    oop threadObj = thread->threadObj();\n-    u4 thread_serial_num = i+1;\n-    u4 stack_serial_num = thread_serial_num + STACK_TRACE_ID;\n-    u4 size = 1 + sizeof(address) + 4 + 4;\n-    writer()->start_sub_record(HPROF_GC_ROOT_THREAD_OBJ, size);\n-    writer()->write_objectID(threadObj);\n-    writer()->write_u4(thread_serial_num);  \/\/ thread number\n-    writer()->write_u4(stack_serial_num);   \/\/ stack trace serial number\n-    writer()->end_sub_record();\n-    int num_frames = do_thread(thread, thread_serial_num);\n-    assert(num_frames == _stack_traces[i]->get_stack_depth(),\n-           \"total number of Java frames not matched\");\n-  }\n@@ -2103,0 +2305,2 @@\n+    \/\/ HPROF_HEAP_DUMP\/HPROF_HEAP_DUMP_SEGMENT starts here\n+\n@@ -2110,1 +2314,1 @@\n-    do_threads();\n+    dump_threads();\n@@ -2166,2 +2370,2 @@\n-  DumperSupport::write_header(writer(), HPROF_TRACE, 3*sizeof(u4));\n-  writer()->write_u4((u4) STACK_TRACE_ID);\n+  DumperSupport::write_header(writer(), HPROF_TRACE, 3 * sizeof(u4));\n+  writer()->write_u4((u4)STACK_TRACE_ID);\n@@ -2171,27 +2375,10 @@\n-  _stack_traces = NEW_C_HEAP_ARRAY(ThreadStackTrace*, Threads::number_of_threads(), mtInternal);\n-  int frame_serial_num = 0;\n-  for (JavaThreadIteratorWithHandle jtiwh; JavaThread *thread = jtiwh.next(); ) {\n-    oop threadObj = thread->threadObj();\n-    if (threadObj != nullptr && !thread->is_exiting() && !thread->is_hidden_from_external_view()) {\n-      \/\/ dump thread stack trace\n-      Thread* current_thread = Thread::current();\n-      ResourceMark rm(current_thread);\n-      HandleMark hm(current_thread);\n-\n-      ThreadStackTrace* stack_trace = new ThreadStackTrace(thread, false);\n-      stack_trace->dump_stack_at_safepoint(-1, \/* ObjectMonitorsHashtable is not needed here *\/ nullptr, true);\n-      _stack_traces[_num_threads++] = stack_trace;\n-\n-      \/\/ write HPROF_FRAME records for this thread's stack trace\n-      int depth = stack_trace->get_stack_depth();\n-      int thread_frame_start = frame_serial_num;\n-      int extra_frames = 0;\n-      \/\/ write fake frame that makes it look like the thread, which caused OOME,\n-      \/\/ is in the OutOfMemoryError zero-parameter constructor\n-      if (thread == _oome_thread && _oome_constructor != nullptr) {\n-        int oome_serial_num = _klass_map->find(_oome_constructor->method_holder());\n-        \/\/ the class serial number starts from 1\n-        assert(oome_serial_num > 0, \"OutOfMemoryError class not found\");\n-        DumperSupport::dump_stack_frame(writer(), ++frame_serial_num, oome_serial_num,\n-                                        _oome_constructor, 0);\n-        extra_frames++;\n+  \/\/ max number if every platform thread is carrier with mounted virtual thread\n+  _thread_dumpers = NEW_C_HEAP_ARRAY(ThreadDumper*, Threads::number_of_threads() * 2, mtInternal);\n+\n+  for (JavaThreadIteratorWithHandle jtiwh; JavaThread * thread = jtiwh.next(); ) {\n+    if (ThreadDumper::should_dump_pthread(thread)) {\n+      bool add_oom_frame = is_oom_thread(thread);\n+\n+      oop mounted_vt = thread->is_vthread_mounted() ? thread->vthread() : nullptr;\n+      if (mounted_vt != nullptr && !ThreadDumper::should_dump_vthread(mounted_vt)) {\n+        mounted_vt = nullptr;\n@@ -2199,7 +2386,12 @@\n-      for (int j=0; j < depth; j++) {\n-        StackFrameInfo* frame = stack_trace->stack_frame_at(j);\n-        Method* m = frame->method();\n-        int class_serial_num = _klass_map->find(m->method_holder());\n-        \/\/ the class serial number starts from 1\n-        assert(class_serial_num > 0, \"class not found\");\n-        DumperSupport::dump_stack_frame(writer(), ++frame_serial_num, class_serial_num, m, frame->bci());\n+\n+      \/\/ mounted vthread (if any)\n+      if (mounted_vt != nullptr) {\n+        ThreadDumper* thread_dumper = new ThreadDumper(ThreadDumper::ThreadType::MountedVirtual, thread, mounted_vt);\n+        _thread_dumpers[_thread_dumpers_count++] = thread_dumper;\n+        if (add_oom_frame) {\n+          thread_dumper->add_oom_frame(_oome_constructor);\n+          \/\/ we add oom frame to the VT stack, don't add it to the carrier thread stack\n+          add_oom_frame = false;\n+        }\n+        thread_dumper->init_serial_nums(&_thread_serial_num, &_frame_serial_num);\n+        thread_dumper->dump_stack_traces(writer(), _klass_map);\n@@ -2207,10 +2399,6 @@\n-      depth += extra_frames;\n-\n-      \/\/ write HPROF_TRACE record for one thread\n-      DumperSupport::write_header(writer(), HPROF_TRACE, checked_cast<u4>(3*sizeof(u4) + depth*oopSize));\n-      int stack_serial_num = _num_threads + STACK_TRACE_ID;\n-      writer()->write_u4(stack_serial_num);      \/\/ stack trace serial number\n-      writer()->write_u4((u4) _num_threads);     \/\/ thread serial number\n-      writer()->write_u4(depth);                 \/\/ frame count\n-      for (int j=1; j <= depth; j++) {\n-        writer()->write_id(thread_frame_start + j);\n+\n+      \/\/ platform or carrier thread\n+      ThreadDumper* thread_dumper = new ThreadDumper(ThreadDumper::ThreadType::Platform, thread, thread->threadObj());\n+      _thread_dumpers[_thread_dumpers_count++] = thread_dumper;\n+      if (add_oom_frame) {\n+        thread_dumper->add_oom_frame(_oome_constructor);\n@@ -2218,0 +2406,2 @@\n+      thread_dumper->init_serial_nums(&_thread_serial_num, &_frame_serial_num);\n+      thread_dumper->dump_stack_traces(writer(), _klass_map);\n","filename":"src\/hotspot\/share\/services\/heapDumper.cpp","additions":370,"deletions":180,"binary":false,"changes":550,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n-#ifdef ASSERT\n@@ -62,1 +61,0 @@\n-#endif \/\/ ASSERT\n","filename":"src\/hotspot\/share\/services\/mallocTracker.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n-#ifdef ASSERT\n@@ -55,1 +54,0 @@\n-#endif \/\/ ASSERT\n@@ -58,4 +56,1 @@\n-  MemoryCounter() : _count(0), _size(0) {\n-    DEBUG_ONLY(_peak_count = 0;)\n-    DEBUG_ONLY(_peak_size  = 0;)\n-  }\n+  MemoryCounter() : _count(0), _size(0), _peak_count(0), _peak_size(0) {}\n@@ -67,1 +62,1 @@\n-      DEBUG_ONLY(update_peak(sum, cnt);)\n+      update_peak(sum, cnt);\n@@ -84,1 +79,1 @@\n-      DEBUG_ONLY(update_peak(sum, _count);)\n+      update_peak(sum, _count);\n@@ -92,1 +87,1 @@\n-    return DEBUG_ONLY(Atomic::load(&_peak_count)) NOT_DEBUG(0);\n+    return Atomic::load(&_peak_count);\n@@ -96,1 +91,1 @@\n-    return DEBUG_ONLY(Atomic::load(&_peak_size)) NOT_DEBUG(0);\n+    return Atomic::load(&_peak_size);\n@@ -184,5 +179,0 @@\n-  inline size_t thread_count() const {\n-    MallocMemorySnapshot* s = const_cast<MallocMemorySnapshot*>(this);\n-    return s->by_type(mtThreadStack)->malloc_count();\n-  }\n-\n","filename":"src\/hotspot\/share\/services\/mallocTracker.hpp","additions":5,"deletions":15,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -193,0 +193,1 @@\n+  _thread_count = ThreadStackTracker::thread_count();\n","filename":"src\/hotspot\/share\/services\/memBaseline.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -67,0 +67,1 @@\n+  size_t                 _thread_count;\n@@ -87,1 +88,1 @@\n-    _instance_class_count(0), _array_class_count(0),\n+    _instance_class_count(0), _array_class_count(0), _thread_count(0),\n@@ -174,1 +175,1 @@\n-    return _malloc_memory_snapshot.thread_count();\n+    return _thread_count;\n@@ -183,0 +184,1 @@\n+    _thread_count = 0;\n","filename":"src\/hotspot\/share\/services\/memBaseline.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -249,1 +249,1 @@\n-        DEBUG_ONLY(|| amount_in_current_scale(malloc_memory->malloc_peak_size()) > 0)) {\n+        || amount_in_current_scale(malloc_memory->malloc_peak_size()) > 0) {\n","filename":"src\/hotspot\/share\/services\/memReporter.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+  ThreadCritical tc;\n@@ -53,1 +54,0 @@\n-    ThreadCritical tc;\n@@ -55,1 +55,0 @@\n-    _thread_count ++;\n@@ -60,1 +59,0 @@\n-      ThreadCritical tc;\n@@ -66,0 +64,1 @@\n+  _thread_count++;\n@@ -71,0 +70,1 @@\n+  ThreadCritical tc;\n@@ -72,1 +72,0 @@\n-    ThreadCritical tc;\n@@ -74,1 +73,0 @@\n-    _thread_count--;\n@@ -79,1 +77,0 @@\n-      ThreadCritical tc;\n@@ -86,0 +83,1 @@\n+  _thread_count--;\n","filename":"src\/hotspot\/share\/services\/threadStackTracker.cpp","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1039,1 +1039,2 @@\n-\n+const intptr_t badDispHeaderDeopt = 0xDE0BD000;             \/\/ value to fill unused displaced header during deoptimization\n+const intptr_t badDispHeaderOSR   = 0xDEAD05A0;             \/\/ value to fill unused displaced header during OSR\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -434,1 +434,1 @@\n-    if (fr.is_java_frame() || fr.is_native_frame() || fr.is_runtime_frame()) {\n+    if (fr.is_interpreted_frame() || (fr.cb() != nullptr && fr.cb()->frame_size() > 0)) {\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+#include \"jni_util.h\"\n@@ -31,0 +32,1 @@\n+#include <procinfo.h>\n@@ -39,0 +41,18 @@\n+\/*\n+ * Return pids of active processes, and optionally parent pids and\n+ * start times for each process.\n+ * For a specific non-zero pid, only the direct children are returned.\n+ * If the pid is zero, all active processes are returned.\n+ * Use getprocs64 to accumulate any process following the rules above.\n+ * The resulting pids are stored into an array of longs named jarray.\n+ * The number of pids is returned if they all fit.\n+ * If the parentArray is non-null, store also the parent pid.\n+ * In this case the parentArray must have the same length as the result pid array.\n+ * Of course in the case of a given non-zero pid all entries in the parentArray\n+ * will contain this pid, so this array does only make sense in the case of a given\n+ * zero pid.\n+ * If the jstimesArray is non-null, store also the start time of the pid.\n+ * In this case the jstimesArray must have the same length as the result pid array.\n+ * If the array(s) (is|are) too short, excess pids are not stored and\n+ * the desired length is returned.\n+ *\/\n@@ -41,1 +61,101 @@\n-    return unix_getChildren(env, jpid, jarray, jparentArray, jstimesArray);\n+    pid_t pid = (pid_t) jpid;\n+    jlong* pids = NULL;\n+    jlong* ppids = NULL;\n+    jlong* stimes = NULL;\n+    jsize parentArraySize = 0;\n+    jsize arraySize = 0;\n+    jsize stimesSize = 0;\n+    jsize count = 0;\n+\n+    arraySize = (*env)->GetArrayLength(env, jarray);\n+    JNU_CHECK_EXCEPTION_RETURN(env, -1);\n+    if (jparentArray != NULL) {\n+        parentArraySize = (*env)->GetArrayLength(env, jparentArray);\n+        JNU_CHECK_EXCEPTION_RETURN(env, -1);\n+\n+        if (arraySize != parentArraySize) {\n+            JNU_ThrowIllegalArgumentException(env, \"array sizes not equal\");\n+            return 0;\n+        }\n+    }\n+    if (jstimesArray != NULL) {\n+        stimesSize = (*env)->GetArrayLength(env, jstimesArray);\n+        JNU_CHECK_EXCEPTION_RETURN(env, -1);\n+\n+        if (arraySize != stimesSize) {\n+            JNU_ThrowIllegalArgumentException(env, \"array sizes not equal\");\n+            return 0;\n+        }\n+    }\n+\n+    const int chunk = 100;\n+    struct procentry64 ProcessBuffer[chunk];\n+    pid_t idxptr = 0;\n+    int i, num = 0;\n+\n+    do { \/\/ Block to break out of on Exception\n+        pids = (*env)->GetLongArrayElements(env, jarray, NULL);\n+        if (pids == NULL) {\n+            break;\n+        }\n+        if (jparentArray != NULL) {\n+            ppids  = (*env)->GetLongArrayElements(env, jparentArray, NULL);\n+            if (ppids == NULL) {\n+                break;\n+            }\n+        }\n+        if (jstimesArray != NULL) {\n+            stimes  = (*env)->GetLongArrayElements(env, jstimesArray, NULL);\n+            if (stimes == NULL) {\n+                break;\n+            }\n+        }\n+\n+        while ((num = getprocs64(ProcessBuffer, sizeof(struct procentry64), NULL,\n+                                 sizeof(struct fdsinfo64), &idxptr, chunk)) != -1) {\n+            for (i = 0; i < num; i++) {\n+                pid_t childpid = (pid_t) ProcessBuffer[i].pi_pid;\n+                pid_t ppid = (pid_t) ProcessBuffer[i].pi_ppid;\n+\n+                \/\/ Get the parent pid, and start time\n+                if (pid == 0 || ppid == pid) {\n+                    if (count < arraySize) {\n+                        \/\/ Only store if it fits\n+                        pids[count] = (jlong) childpid;\n+\n+                        if (ppids != NULL) {\n+                            \/\/ Store the parentPid\n+                            ppids[count] = (jlong) ppid;\n+                        }\n+                        if (stimes != NULL) {\n+                            \/\/ Store the process start time\n+                            stimes[count] = ((jlong) ProcessBuffer[i].pi_start) * 1000;;\n+                        }\n+                    }\n+                    count++; \/\/ Count to tabulate size needed\n+                }\n+            }\n+            if (num < chunk) {\n+                break;\n+            }\n+        }\n+    } while (0);\n+\n+    if (pids != NULL) {\n+        (*env)->ReleaseLongArrayElements(env, jarray, pids, 0);\n+    }\n+    if (ppids != NULL) {\n+        (*env)->ReleaseLongArrayElements(env, jparentArray, ppids, 0);\n+    }\n+    if (stimes != NULL) {\n+        (*env)->ReleaseLongArrayElements(env, jstimesArray, stimes, 0);\n+    }\n+\n+    if (num == -1) {\n+        JNU_ThrowByNameWithLastError(env,\n+            \"java\/lang\/RuntimeException\", \"Unable to retrieve Process info\");\n+        return -1;\n+    }\n+\n+    \/\/ If more pids than array had size for; count will be greater than array size\n+    return count;\n","filename":"src\/java.base\/aix\/native\/libjava\/ProcessHandleImpl_aix.c","additions":122,"deletions":2,"binary":false,"changes":124,"status":"modified"},{"patch":"@@ -161,0 +161,5 @@\n+        if (fname == NULL) {\n+            JNU_ThrowOutOfMemoryError(env, NULL);\n+            return;\n+        }\n+\n@@ -173,0 +178,5 @@\n+        if (map_entry == NULL) {\n+            JNU_ThrowOutOfMemoryError(env, NULL);\n+            fclose(proc_file);\n+            return;\n+        }\n","filename":"src\/java.base\/aix\/native\/libnio\/MappedMemoryUtils.c","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2008, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2013, 2019 SAP SE. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023 SAP SE. All rights reserved.\n@@ -108,0 +108,4 @@\n+        if (buffer == NULL) {\n+            throwUnixException(env, errno);\n+            return NULL;\n+        }\n","filename":"src\/java.base\/aix\/native\/libnio\/fs\/AixNativeDispatcher.c","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -145,1 +145,1 @@\n-        \/\/ POSIX attributes not supported on FAT\n+        \/\/ POSIX attributes not supported on FAT32\n","filename":"src\/java.base\/linux\/classes\/sun\/nio\/fs\/LinuxFileStore.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-#include <immintrin.h>\n@@ -63,0 +62,10 @@\n+\/*\n+Workaround for the bug in GCC12 (that was fixed in GCC 12.3.1).\n+More details are available at: https:\/\/gcc.gnu.org\/bugzilla\/show_bug.cgi?id=105593\n+*\/\n+#pragma GCC diagnostic push\n+#pragma GCC diagnostic ignored \"-Wmaybe-uninitialized\"\n+#pragma GCC diagnostic ignored \"-Wuninitialized\"\n+#include <immintrin.h>\n+#pragma GCC diagnostic pop\n+\n","filename":"src\/java.base\/linux\/native\/libsimdsort\/avx512-common-qsort.h","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.io.IOException;\n@@ -29,0 +30,1 @@\n+import java.nio.file.attribute.PosixFileAttributeView;\n@@ -30,1 +32,0 @@\n-import java.io.IOException;\n@@ -103,0 +104,4 @@\n+        \/\/ POSIX attributes not supported on FAT32\n+        if (type == PosixFileAttributeView.class &&\n+            entry().fstype().equals(\"msdos\"))\n+            return false;\n@@ -110,0 +115,3 @@\n+        \/\/ UNIX attributes not supported on FAT32\n+        if (name.equals(\"unix\") && entry().fstype().equals(\"msdos\"))\n+            return false;\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/fs\/BsdFileStore.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,1 @@\n-    private BlockCipherParamsCore core;\n+    private final BlockCipherParamsCore core;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/AESParameters.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n-    private int block_size = 0;\n+    private final int block_size;\n@@ -52,1 +52,1 @@\n-    private int[] moreSizes = null;\n+    private final int[] moreSizes;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/BlockCipherParamsCore.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,0 @@\n-import sun.security.util.*;\n@@ -34,1 +33,0 @@\n-import javax.crypto.spec.*;\n@@ -60,1 +58,1 @@\n-    private CipherCore core = null;\n+    private final CipherCore core;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/BlowfishCipher.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,1 @@\n-    private BlockCipherParamsCore core;\n+    private final BlockCipherParamsCore core;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/BlowfishParameters.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-import java.util.Objects;\n@@ -58,1 +57,1 @@\n-    private byte[] k;\n+    private final byte[] k;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/CipherBlockChaining.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,1 @@\n-    private byte[] buffer = null;\n+    private final byte[] buffer;\n@@ -65,1 +65,1 @@\n-    private int blockSize = 0;\n+    private final int blockSize;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/CipherCore.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,1 @@\n-    private int numBytes;\n+    private final int numBytes;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/CipherFeedback.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,0 @@\n-import javax.crypto.spec.*;\n@@ -55,1 +54,1 @@\n-    private CipherCore core = null;\n+    private final CipherCore core;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DESCipher.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import java.io.IOException;\n+import java.io.InvalidObjectException;\n@@ -48,1 +50,1 @@\n-    static final long serialVersionUID = 7724971015953279128L;\n+    private static final long serialVersionUID = 7724971015953279128L;\n@@ -146,2 +148,5 @@\n-     * readObject is called to restore the state of this key from\n-     * a stream.\n+     * Restores the state of this object from the stream.\n+     *\n+     * @param  s the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n@@ -151,1 +156,1 @@\n-         throws java.io.IOException, ClassNotFoundException\n+         throws IOException, ClassNotFoundException\n@@ -154,0 +159,3 @@\n+        if ((key == null) || (key.length != DESKeySpec.DES_KEY_LEN)) {\n+            throw new InvalidObjectException(\"Wrong key size\");\n+        }\n@@ -157,0 +165,3 @@\n+\n+        DESKeyGenerator.setParityBit(key, 0);\n+\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DESKey.java","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,1 @@\n-    private BlockCipherParamsCore core;\n+    private final BlockCipherParamsCore core;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DESParameters.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,0 @@\n-import javax.crypto.spec.*;\n@@ -53,1 +52,1 @@\n-    private CipherCore core = null;\n+    private final CipherCore core;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DESedeCipher.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2007, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,2 @@\n-    private byte[] buf1, buf2;\n+    private final byte[] buf1;\n+    private final byte[] buf2;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DESedeCrypt.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import java.io.IOException;\n+import java.io.InvalidObjectException;\n@@ -48,1 +50,1 @@\n-    static final long serialVersionUID = 2463986565756745178L;\n+    private static final long serialVersionUID = 2463986565756745178L;\n@@ -147,2 +149,5 @@\n-     * readObject is called to restore the state of this key from\n-     * a stream.\n+     * Restores the state of this object from the stream.\n+     *\n+     * @param  s the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n@@ -152,1 +157,1 @@\n-         throws java.io.IOException, ClassNotFoundException\n+         throws IOException, ClassNotFoundException\n@@ -155,0 +160,3 @@\n+        if ((key == null) || (key.length != DESedeKeySpec.DES_EDE_KEY_LEN)) {\n+            throw new InvalidObjectException(\"Wrong key size\");\n+        }\n@@ -158,0 +166,5 @@\n+\n+        DESKeyGenerator.setParityBit(key, 0);\n+        DESKeyGenerator.setParityBit(key, 8);\n+        DESKeyGenerator.setParityBit(key, 16);\n+\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DESedeKey.java","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-    private BlockCipherParamsCore core;\n+    private final BlockCipherParamsCore core;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DESedeParameters.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,1 @@\n-    private FeedbackCipher cipher;\n+    private final FeedbackCipher cipher;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DESedeWrapCipher.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -356,1 +356,1 @@\n-            if (ns.getName().equals(\"X25519\")) {\n+            if (ns.getName().equalsIgnoreCase(\"X25519\")) {\n@@ -358,1 +358,1 @@\n-            } else if (ns.getName().equals(\"X448\")) {\n+            } else if (ns.getName().equalsIgnoreCase(\"X448\")) {\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DHKEM.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -43,2 +43,0 @@\n- *\n- *\n@@ -52,1 +50,1 @@\n-    static final long serialVersionUID = 7565477590005668886L;\n+    private static final long serialVersionUID = 7565477590005668886L;\n@@ -58,1 +56,1 @@\n-    private BigInteger x;\n+    private final BigInteger x;\n@@ -67,1 +65,1 @@\n-    private BigInteger p;\n+    private final BigInteger p;\n@@ -70,1 +68,1 @@\n-    private BigInteger g;\n+    private final BigInteger g;\n@@ -73,1 +71,1 @@\n-    private int l;\n+    private final int l;\n@@ -166,0 +164,2 @@\n+            } else {\n+                this.l = 0;\n@@ -175,1 +175,3 @@\n-            parseKeyBits();\n+\n+            DerInputStream in = new DerInputStream(this.key);\n+            this.x = in.getBigInteger();\n@@ -276,10 +278,0 @@\n-    private void parseKeyBits() throws InvalidKeyException {\n-        try {\n-            DerInputStream in = new DerInputStream(this.key);\n-            this.x = in.getBigInteger();\n-        } catch (IOException e) {\n-            throw new InvalidKeyException(\n-                \"Error parsing key encoding: \" + e.getMessage(), e);\n-        }\n-    }\n-\n@@ -324,0 +316,24 @@\n+\n+    \/**\n+     * Restores the state of this object from the stream.\n+     * <p>\n+     * JDK 1.5+ objects use <code>KeyRep<\/code>s instead.\n+     *\n+     * @param  stream the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n+     *\/\n+    @java.io.Serial\n+    private void readObject(ObjectInputStream stream)\n+            throws IOException, ClassNotFoundException {\n+        stream.defaultReadObject();\n+        if ((key == null) || (key.length == 0)) {\n+            throw new InvalidObjectException(\"key not deserializable\");\n+        }\n+        this.key = key.clone();\n+        if ((encodedKey == null) || (encodedKey.length == 0)) {\n+            throw new InvalidObjectException(\n+                    \"encoded key not deserializable\");\n+        }\n+        this.encodedKey = encodedKey.clone();\n+    }\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DHPrivateKey.java","additions":34,"deletions":18,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -42,2 +42,0 @@\n- *\n- *\n@@ -51,1 +49,1 @@\n-    static final long serialVersionUID = 7647557958927458271L;\n+    private static final long serialVersionUID = 7647557958927458271L;\n@@ -54,1 +52,1 @@\n-    private BigInteger y;\n+    private final BigInteger y;\n@@ -63,1 +61,1 @@\n-    private BigInteger p;\n+    private final BigInteger p;\n@@ -66,1 +64,1 @@\n-    private BigInteger g;\n+    private final BigInteger g;\n@@ -69,1 +67,1 @@\n-    private int l;\n+    private final int l;\n@@ -72,1 +70,1 @@\n-    static ObjectIdentifier DH_OID =\n+    static final ObjectIdentifier DH_OID =\n@@ -158,0 +156,2 @@\n+            } else {\n+                this.l = 0;\n@@ -167,1 +167,4 @@\n-            parseKeyBits();\n+\n+            DerInputStream in = new DerInputStream(this.key);\n+            this.y = in.getBigInteger();\n+\n@@ -268,10 +271,0 @@\n-    private void parseKeyBits() throws InvalidKeyException {\n-        try {\n-            DerInputStream in = new DerInputStream(this.key);\n-            this.y = in.getBigInteger();\n-        } catch (IOException e) {\n-            throw new InvalidKeyException(\n-                \"Error parsing key encoding: \" + e.toString());\n-        }\n-    }\n-\n@@ -316,0 +309,24 @@\n+\n+    \/**\n+     * Restores the state of this object from the stream.\n+     * <p>\n+     * JDK 1.5+ objects use <code>KeyRep<\/code>s instead.\n+     *\n+     * @param  stream the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n+     *\/\n+    @java.io.Serial\n+    private void readObject(ObjectInputStream stream)\n+            throws IOException, ClassNotFoundException {\n+        stream.defaultReadObject();\n+        if ((key == null) || (key.length == 0)) {\n+            throw new InvalidObjectException(\"key not deserializable\");\n+        }\n+        this.key = key.clone();\n+        if ((encodedKey == null) || (encodedKey.length == 0)) {\n+            throw new InvalidObjectException(\n+                    \"encoded key not deserializable\");\n+        }\n+        this.encodedKey = encodedKey.clone();\n+    }\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DHPublicKey.java","additions":36,"deletions":19,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,1 @@\n-    private AlgorithmId algid;\n+    private final AlgorithmId algid;\n@@ -50,1 +50,1 @@\n-    private byte[] encryptedData;\n+    private final byte[] encryptedData;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/EncryptedPrivateKeyInfo.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -127,1 +127,1 @@\n-    private long[] subkeyHtbl;\n+    private final long[] subkeyHtbl;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/GHASH.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,2 +77,2 @@\n-    static int DEFAULT_IV_LEN = 12; \/\/ in bytes\n-    static int DEFAULT_TAG_LEN = 16; \/\/ in bytes\n+    private static final int DEFAULT_IV_LEN = 12; \/\/ in bytes\n+    private static final int DEFAULT_TAG_LEN = 16; \/\/ in bytes\n@@ -101,1 +101,1 @@\n-    SymmetricCipher blockCipher;\n+    final SymmetricCipher blockCipher;\n@@ -109,1 +109,1 @@\n-    int keySize;\n+    private final int keySize;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/GaloisCounterMode.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-    private int blockSize;\n+    private final int blockSize;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/ISO10126Padding.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -102,1 +102,1 @@\n-    private Hashtable<String, Object> entries = new Hashtable<String, Object>();\n+    private final Hashtable<String, Object> entries = new Hashtable<>();\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/JceKeyStore.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-    private char[] password;\n+    private final char[] password;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/KeyProtector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,1 @@\n-    private static ObjectIdentifier OID_MGF1 =\n+    private static final ObjectIdentifier OID_MGF1 =\n@@ -61,1 +61,1 @@\n-    private static ObjectIdentifier OID_PSpecified =\n+    private static final ObjectIdentifier OID_PSpecified =\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/OAEPParameters.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,1 @@\n-    private byte[] k = null;\n+    private final byte[] k;\n@@ -53,1 +53,1 @@\n-    private byte[] register = null;\n+    private final byte[] register;\n@@ -59,1 +59,1 @@\n-    private int numBytes;\n+    private final int numBytes;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/OutputFeedback.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import java.io.IOException;\n+import java.io.InvalidObjectException;\n@@ -49,1 +51,1 @@\n-    static final long serialVersionUID = -2234768909660948176L;\n+    private static final long serialVersionUID = -2234768909660948176L;\n@@ -53,1 +55,1 @@\n-    private String type;\n+    private final String type;\n@@ -165,2 +167,5 @@\n-     * readObject is called to restore the state of this key from\n-     * a stream.\n+     * Restores the state of this object from the stream.\n+     *\n+     * @param  s the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n@@ -170,1 +175,1 @@\n-         throws java.io.IOException, ClassNotFoundException\n+         throws IOException, ClassNotFoundException\n@@ -173,0 +178,4 @@\n+        if (key == null) {\n+            throw new InvalidObjectException(\n+                    \"PBEKey couldn't be deserialized\");\n+        }\n@@ -176,0 +185,11 @@\n+\n+        \/\/ Accept \"\\0\" to signify \"zero-length password with no terminator\".\n+        if (!(key.length == 1 && key[0] == 0)) {\n+            for (int i = 0; i < key.length; i++) {\n+                if ((key[i] < '\\u0020') || (key[i] > '\\u007E')) {\n+                    throw new InvalidObjectException(\n+                            \"PBEKey had non-ASCII chars\");\n+                }\n+            }\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PBEKey.java","additions":25,"deletions":5,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-    private String type;\n+    private final String type;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PBEKeyFactory.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,4 +46,3 @@\n-    private CipherCore cipher;\n-    private MessageDigest md;\n-    private int blkSize;\n-    private String algo = null;\n+    private final CipherCore cipher;\n+    private final MessageDigest md;\n+    private final String algo;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PBES1Core.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -95,1 +95,1 @@\n-    private static ObjectIdentifier pkcs5PBKDF2_OID =\n+    private static final ObjectIdentifier pkcs5PBKDF2_OID =\n@@ -97,1 +97,1 @@\n-    private static ObjectIdentifier pkcs5PBES2_OID =\n+    private static final ObjectIdentifier pkcs5PBES2_OID =\n@@ -99,1 +99,1 @@\n-    private static ObjectIdentifier aes128CBC_OID =\n+    private static final ObjectIdentifier aes128CBC_OID =\n@@ -101,1 +101,1 @@\n-    private static ObjectIdentifier aes192CBC_OID =\n+    private static final ObjectIdentifier aes192CBC_OID =\n@@ -103,1 +103,1 @@\n-    private static ObjectIdentifier aes256CBC_OID =\n+    private static final ObjectIdentifier aes256CBC_OID =\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PBES2Parameters.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-    private PBES1Core core;\n+    private final PBES1Core core;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PBEWithMD5AndDESCipher.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,1 +56,1 @@\n-    private PBES1Core core;\n+    private final PBES1Core core;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PBEWithMD5AndTripleDESCipher.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import java.io.ObjectStreamException;\n+import java.io.*;\n@@ -61,1 +61,1 @@\n-    static final long serialVersionUID = -2234868909660948157L;\n+    private static final long serialVersionUID = -2234868909660948157L;\n@@ -63,4 +63,4 @@\n-    private char[] passwd;\n-    private byte[] salt;\n-    private int iterCount;\n-    private byte[] key;\n+    private final char[] passwd;\n+    private final byte[] salt;\n+    private final int iterCount;\n+    private final byte[] key;\n@@ -69,2 +69,2 @@\n-    private transient Mac prf;\n-    private transient Cleaner.Cleanable cleaner;\n+    private final transient Mac prf;\n+    private final transient Cleaner.Cleanable cleaner;\n@@ -96,0 +96,1 @@\n+        byte[] key = null;\n@@ -114,1 +115,1 @@\n-            this.key = deriveKey(prf, passwdBytes, salt, iterCount, keyLength);\n+            key = deriveKey(prf, passwdBytes, salt, iterCount, keyLength);\n@@ -125,1 +126,1 @@\n-        final byte[] k = this.key;\n+        final byte[] k = this.key = key;\n@@ -144,0 +145,1 @@\n+            String algName = prf.getAlgorithm();\n@@ -150,1 +152,1 @@\n-                    return prf.getAlgorithm();\n+                    return algName;\n@@ -163,1 +165,1 @@\n-                      prf.getAlgorithm().toLowerCase(Locale.ENGLISH).hashCode();\n+                      algName.toLowerCase(Locale.ENGLISH).hashCode();\n@@ -170,1 +172,1 @@\n-                    return prf.getAlgorithm().equalsIgnoreCase(\n+                    return algName.equalsIgnoreCase(\n@@ -174,0 +176,8 @@\n+                \/\/ This derived key can't be deserialized.\n+                @java.io.Serial\n+                private void readObject(ObjectInputStream stream)\n+                        throws IOException, ClassNotFoundException {\n+                    throw new InvalidObjectException(\n+                            \"PBKDF2KeyImpl SecretKeys are not \" +\n+                            \"directly deserializable\");\n+                }\n@@ -175,0 +185,1 @@\n+\n@@ -306,0 +317,16 @@\n+\n+    \/**\n+     * Restores the state of this object from the stream.\n+     * <p>\n+     * Deserialization of this class is not supported.\n+     *\n+     * @param  stream the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n+     *\/\n+    @java.io.Serial\n+    private void readObject(ObjectInputStream stream)\n+            throws IOException, ClassNotFoundException {\n+        throw new InvalidObjectException(\n+                \"PBKDF2KeyImpl keys are not directly deserializable\");\n+    }\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PBKDF2KeyImpl.java","additions":40,"deletions":13,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-    private int blockSize;\n+    private final int blockSize;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PKCS5Padding.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,1 +56,1 @@\n-    private AlgorithmId algid;\n+    private final AlgorithmId algid;\n@@ -59,1 +59,1 @@\n-    private byte[] privkey;\n+    private final byte[] privkey;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PrivateKeyInfo.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import java.io.IOException;\n+import java.io.InvalidObjectException;\n+import java.io.ObjectInputStream;\n@@ -65,1 +68,1 @@\n-        if (params instanceof TlsMasterSecretParameterSpec == false) {\n+        if (!(params instanceof TlsMasterSecretParameterSpec)) {\n@@ -69,1 +72,1 @@\n-        if (\"RAW\".equals(spec.getPremasterSecret().getFormat()) == false) {\n+        if (!\"RAW\".equals(spec.getPremasterSecret().getFormat())) {\n@@ -194,1 +197,17 @@\n-    }\n+       \/**\n+        * Restores the state of this object from the stream.\n+        *\n+        * @param  stream the {@code ObjectInputStream} from which data is read\n+        * @throws IOException if an I\/O error occurs\n+        * @throws ClassNotFoundException if a serialized class cannot be loaded\n+        *\/\n+       @java.io.Serial\n+       private void readObject(ObjectInputStream stream)\n+               throws IOException, ClassNotFoundException {\n+           stream.defaultReadObject();\n+           if ((key == null) || (key.length == 0)) {\n+               throw new InvalidObjectException(\"TlsMasterSecretKey is null\");\n+           }\n+           key = key.clone();\n+       }\n+   }\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/TlsMasterSecretGenerator.java","additions":23,"deletions":4,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -86,0 +86,1 @@\n+import jdk.internal.vm.annotation.Stable;\n@@ -1063,0 +1064,1 @@\n+    @Stable\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -275,1 +275,1 @@\n-     * @since 20\n+     * @since 22\n@@ -277,1 +277,0 @@\n-    @PreviewFeature(feature = PreviewFeature.Feature.FOREIGN)\n@@ -312,1 +311,1 @@\n-    void ensureNativeAccess(Class<?> owner, String methodName) {\n+    void ensureNativeAccess(Class<?> owner, String methodName, Class<?> currentClass) {\n@@ -323,1 +322,1 @@\n-                String mod = isNamed() ? \"module \" + getName() : \"the unnamed module\";\n+                String mod = isNamed() ? \"module \" + getName() : \"an unnamed module\";\n@@ -325,0 +324,1 @@\n+                String caller = currentClass != null ? currentClass.getName() : \"code\";\n@@ -327,3 +327,4 @@\n-                        WARNING: %s has been called by %s\n-                        WARNING: Use --enable-native-access=%s to avoid a warning for this module\n-                        %n\"\"\", cls, mtd, mod, modflag);\n+                        WARNING: %s has been called by %s in %s\n+                        WARNING: Use --enable-native-access=%s to avoid a warning for callers in this module\n+                        WARNING: Restricted methods will be blocked in a future release unless native access is enabled\n+                        %n\"\"\", cls, mtd, caller, mod, modflag);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Module.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -310,3 +310,1 @@\n-         * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain\n-         * from depending on restricted methods, and use safe and supported functionalities,\n-         * where possible.\n+         * the JVM or, worse, silently result in memory corruption.\n@@ -325,1 +323,1 @@\n-         * @since 20\n+         * @since 22\n@@ -327,1 +325,0 @@\n-        @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ModuleLayer.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n@@ -1839,0 +1841,15 @@\n+    boolean bytesCompatible(Charset charset) {\n+        if (isLatin1()) {\n+            if (charset == ISO_8859_1.INSTANCE) {\n+                return true; \/\/ ok, same encoding\n+            } else if (charset == UTF_8.INSTANCE || charset == US_ASCII.INSTANCE) {\n+                return !StringCoding.hasNegatives(value, 0, value.length); \/\/ ok, if ASCII-compatible\n+            }\n+        }\n+        return false;\n+    }\n+\n+    void copyToSegmentRaw(MemorySegment segment, long offset) {\n+        MemorySegment.copy(value, 0, segment, ValueLayout.JAVA_BYTE, offset, value.length);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/String.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -598,0 +598,1 @@\n+         * @sealedGraph\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringTemplate.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import java.lang.foreign.MemorySegment;\n@@ -91,1 +92,0 @@\n-import jdk.internal.vm.annotation.ForceInline;\n@@ -2457,2 +2457,2 @@\n-            public void ensureNativeAccess(Module m, Class<?> owner, String methodName) {\n-                m.ensureNativeAccess(owner, methodName);\n+            public void ensureNativeAccess(Module m, Class<?> owner, String methodName, Class<?> currentClass) {\n+                m.ensureNativeAccess(owner, methodName, currentClass);\n@@ -2672,0 +2672,10 @@\n+\n+            @Override\n+            public void copyToSegmentRaw(String string, MemorySegment segment, long offset) {\n+                string.copyToSegmentRaw(segment, offset);\n+            }\n+\n+            @Override\n+            public boolean bytesCompatible(String string, Charset charset) {\n+                return string.bytesCompatible(charset);\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":13,"deletions":3,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.internal.javac.PreviewFeature;\n@@ -54,0 +53,3 @@\n+ * @implSpec\n+ * Implementations of this interface are immutable, thread-safe and <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>.\n+ *\n@@ -56,1 +58,1 @@\n- * @since 19\n+ * @since 22\n@@ -58,1 +60,0 @@\n-@PreviewFeature(feature = PreviewFeature.Feature.FOREIGN)\n@@ -98,1 +99,1 @@\n-     *         MemoryLayout.sequenceLayout(ValueLayout.JAVA_BYTE));\n+     *         MemoryLayout.sequenceLayout(Long.MAX_VALUE, ValueLayout.JAVA_BYTE));\n@@ -103,2 +104,1 @@\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n+     * the JVM or, worse, silently result in memory corruption.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/AddressLayout.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.internal.javac.PreviewFeature;\n@@ -187,1 +186,1 @@\n- *         MemorySegment s = slicingArena.allocateArray(JAVA_INT, 1, 2, 3, 4, 5);\n+ *         MemorySegment s = slicingArena.allocateFrom(JAVA_INT, 1, 2, 3, 4, 5);\n@@ -198,1 +197,1 @@\n- * @since 20\n+ * @since 22\n@@ -200,1 +199,0 @@\n-@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n@@ -272,3 +270,1 @@\n-    default MemorySegment allocate(long byteSize, long byteAlignment) {\n-        return ((MemorySessionImpl)scope()).allocate(byteSize, byteAlignment);\n-    }\n+    MemorySegment allocate(long byteSize, long byteAlignment);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Arena.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import jdk.internal.javac.PreviewFeature;\n@@ -47,1 +46,1 @@\n- * @since 19\n+ * @since 22\n@@ -49,1 +48,0 @@\n-@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/FunctionDescriptor.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.internal.javac.PreviewFeature;\n@@ -41,1 +40,1 @@\n- * @since 19\n+ * @since 22\n@@ -43,1 +42,0 @@\n-@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/GroupLayout.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import jdk.internal.javac.PreviewFeature;\n@@ -35,1 +34,0 @@\n-import jdk.internal.reflect.Reflection;\n@@ -38,1 +36,1 @@\n-import java.nio.ByteOrder;\n+import java.util.Map;\n@@ -40,1 +38,0 @@\n-import java.util.Optional;\n@@ -63,0 +60,6 @@\n+ * A linker provides a way to look up the <em>canonical layouts<\/em> associated with the data types used by the ABI.\n+ * For example, a linker implementing the C ABI might choose to provide a canonical layout for the C {@code size_t}\n+ * type. On 64-bit platforms, this canonical layout might be equal to {@link ValueLayout#JAVA_LONG}. The canonical\n+ * layouts supported by a linker are exposed via the {@link #canonicalLayouts()} method, which returns a map from\n+ * type names to canonical layouts.\n+ * <p>\n@@ -96,1 +99,1 @@\n- *     MemorySegment str = arena.allocateUtf8String(\"Hello\");\n+ *     MemorySegment str = arena.allocateFrom(\"Hello\");\n@@ -99,1 +102,1 @@\n- * }\n+ *}\n@@ -107,5 +110,2 @@\n- * of a suitable carrier. The mapping between a scalar type and its corresponding layout is dependent on the ABI\n- * implemented by the native linker. For instance, the C type {@code long} maps to the layout constant\n- * {@link ValueLayout#JAVA_LONG} on Linux\/x64, but maps to the layout constant {@link ValueLayout#JAVA_INT} on\n- * Windows\/x64. Similarly, the C type {@code size_t} maps to the layout constant {@link ValueLayout#JAVA_LONG}\n- * on 64-bit platforms, but maps to the layout constant {@link ValueLayout#JAVA_INT} on 32-bit platforms.\n+ * of a suitable carrier. The {@linkplain #canonicalLayouts() mapping} between a scalar type and its corresponding\n+ * canonical layout is dependent on the ABI implemented by the native linker (see below).\n@@ -126,1 +126,27 @@\n- * The following table shows some examples of how C types are modelled in Linux\/x64:\n+ * All native linker implementations are guaranteed to provide canonical layouts for the following set of types:\n+ * <ul>\n+ *     <li>{@code bool}<\/li>\n+ *     <li>{@code char}<\/li>\n+ *     <li>{@code short}<\/li>\n+ *     <li>{@code int}<\/li>\n+ *     <li>{@code long}<\/li>\n+ *     <li>{@code long long}<\/li>\n+ *     <li>{@code float}<\/li>\n+ *     <li>{@code double}<\/li>\n+ *     <li>{@code size_t}<\/li>\n+ *     <li>{@code wchar_t}<\/li>\n+ *     <li>{@code void*}<\/li>\n+ * <\/ul>\n+ * As noted above, the specific canonical layout associated with each type can vary, depending on the data model\n+ * supported by a given ABI. For instance, the C type {@code long} maps to the layout constant {@link ValueLayout#JAVA_LONG}\n+ * on Linux\/x64, but maps to the layout constant {@link ValueLayout#JAVA_INT} on Windows\/x64. Similarly, the C type\n+ * {@code size_t} maps to the layout constant {@link ValueLayout#JAVA_LONG} on 64-bit platforms, but maps to the layout\n+ * constant {@link ValueLayout#JAVA_INT} on 32-bit platforms.\n+ * <p>\n+ * A native linker typically does not provide canonical layouts for C's unsigned integral types. Instead, they are\n+ * modelled using the canonical layouts associated with their corresponding signed integral types. For instance,\n+ * the C type {@code unsigned long} maps to the layout constant {@link ValueLayout#JAVA_LONG} on Linux\/x64, but maps to\n+ * the layout constant {@link ValueLayout#JAVA_INT} on Windows\/x64.\n+ * <p>\n+ * The following table shows some examples of how C types are modelled in Linux\/x64 according to the\n+ * \"System V Application Binary Interface\" (all the examples provided here will assume these platform-dependent mappings):\n@@ -141,1 +167,1 @@\n- * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code char}<\/th>\n+ * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code char} <br> {@code unsigned char}<\/th>\n@@ -144,1 +170,1 @@\n- * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code short}<\/th>\n+ * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code short} <br> {@code unsigned short}<\/th>\n@@ -147,1 +173,1 @@\n- * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code int}<\/th>\n+ * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code int} <br> {@code unsigned int}<\/th>\n@@ -150,1 +176,1 @@\n- * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code long}<\/th>\n+ * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code long} <br> {@code unsigned long}<\/th>\n@@ -153,1 +179,1 @@\n- * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code long long}<\/th>\n+ * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code long long} <br> {@code unsigned long long}<\/th>\n@@ -204,14 +230,1 @@\n- * <li>{@code L} is a value layout {@code V} and {@code V.withoutName()} is {@linkplain MemoryLayout#equals(Object) equal}\n- * to one of the following layout constants:\n- * <ul>\n- * <li>{@link ValueLayout#JAVA_BOOLEAN}<\/li>\n- * <li>{@link ValueLayout#JAVA_BYTE}<\/li>\n- * <li>{@link ValueLayout#JAVA_CHAR}<\/li>\n- * <li>{@link ValueLayout#JAVA_SHORT}<\/li>\n- * <li>{@link ValueLayout#JAVA_INT}<\/li>\n- * <li>{@link ValueLayout#JAVA_LONG}<\/li>\n- * <li>{@link ValueLayout#JAVA_FLOAT}<\/li>\n- * <li>{@link ValueLayout#JAVA_DOUBLE}<\/li>\n- * <\/ul><\/li>\n- * <li>{@code L} is an address layout {@code A} and {@code A.withoutTargetLayout().withoutName()} is\n- * {@linkplain MemoryLayout#equals(Object) equal} to {@link ValueLayout#ADDRESS}<\/li>\n+ * <li>{@code L} is a value layout {@code V} and {@code V.withoutName()} is a canonical layout<\/li>\n@@ -297,1 +310,1 @@\n- *     MemorySegment array = arena.allocateArray(JAVA_INT, 0, 9, 3, 4, 6, 5, 1, 8, 2, 7);\n+ *     MemorySegment array = arena.allocateFrom(JAVA_INT, 0, 9, 3, 4, 6, 5, 1, 8, 2, 7);\n@@ -394,9 +407,5 @@\n- * Variadic functions are C functions which can accept a variable number and type of arguments. They are declared:\n- * <ol>\n- * <li>With a trailing ellipsis ({@code ...}) at the end of the formal parameter list, such as: {@code void foo(int x, ...);}<\/li>\n- * <li>With an empty formal parameter list, called a prototype-less function, such as: {@code void foo();}<\/li>\n- * <\/ol>\n- * The arguments passed in place of the ellipsis, or the arguments passed to a prototype-less function are called\n- * <em>variadic arguments<\/em>. Variadic functions are, essentially, templates that can be <em>specialized<\/em> into multiple\n- * non-variadic functions by replacing the {@code ...} or empty formal parameter list with a list of <em>variadic parameters<\/em>\n- * of a fixed number and type.\n+ * Variadic functions are C functions which can accept a variable number and type of arguments. They are declared with a\n+ * trailing ellipsis ({@code ...}) at the end of the formal parameter list, such as: {@code void foo(int x, ...);}\n+ * The arguments passed in place of the ellipsis are called <em>variadic arguments<\/em>. Variadic functions are,\n+ * essentially, templates that can be <em>specialized<\/em> into multiple non-variadic functions by replacing the\n+ * {@code ...} with a list of <em>variadic parameters<\/em> of a fixed number and type.\n@@ -414,2 +423,2 @@\n- * specialized form of a variadic function, as the variadic parameters of the specialized form will always have a promoted\n- * type.\n+ * types that can be used to replace the {@code ...}, as the variadic parameters of the specialized form of a variadic\n+ * function will always have a promoted type.\n@@ -421,2 +430,1 @@\n- * function descriptor, are called <em>variadic argument layouts<\/em>. For a prototype-less function, the index passed to\n- * {@link Linker.Option#firstVariadicArg(int)} should always be {@code 0}.\n+ * function descriptor, are called <em>variadic argument layouts<\/em>.\n@@ -424,5 +432,7 @@\n- * The native linker will reject an attempt to link a specialized function descriptor with any variadic argument layouts\n- * corresponding to a C type that would be subject to default argument promotion (as described above). Exactly which layouts\n- * will be rejected is platform specific, but as an example: on Linux\/x64 the layouts {@link ValueLayout#JAVA_BOOLEAN},\n- * {@link ValueLayout#JAVA_BYTE}, {@link ValueLayout#JAVA_CHAR}, {@link ValueLayout#JAVA_SHORT}, and\n- * {@link ValueLayout#JAVA_FLOAT} will be rejected.\n+ * The native linker does not automatically perform default argument promotions. However, since passing an argument of a\n+ * non-promoted type as a variadic argument is not supported in C, the native linker will reject an attempt to link a\n+ * specialized function descriptor with any variadic argument value layouts corresponding to a non-promoted C type.\n+ * Since the size of the C {@code int} type is platform-specific, exactly which layouts will be rejected is\n+ * platform-specific as well. As an example: on Linux\/x64 the layouts corresponding to the C types {@code _Bool},\n+ * {@code (unsigned) char}, {@code (unsigned) short}, and {@code float} (among others), will be rejected by the linker.\n+ * The {@link #canonicalLayouts()} method can be used to find which layout corresponds to a particular C type.\n@@ -464,2 +474,1 @@\n- *     int res = (int)printf.invokeExact(arena.allocateUtf8String(\"%d plus %d equals %d\"), 2, 2, 4); \/\/prints \"2 plus 2 equals 4\"\n- * }\n+ *     int res = (int)printf.invokeExact(arena.allocateFrom(\"%d plus %d equals %d\"), 2, 2, 4); \/\/prints \"2 plus 2 equals 4\"\n@@ -467,0 +476,1 @@\n+ *}\n@@ -486,1 +496,1 @@\n- * @since 19\n+ * @since 22\n@@ -488,1 +498,0 @@\n-@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n@@ -496,0 +505,2 @@\n+     * @implSpec A native linker implementation is guaranteed to provide canonical layouts for\n+     * <a href=\"#describing-c-sigs\">basic C types<\/a>.\n@@ -499,2 +510,0 @@\n-     *\n-     * @throws UnsupportedOperationException if the underlying native platform is not supported.\n@@ -516,2 +525,1 @@\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n+     * the JVM or, worse, silently result in memory corruption.\n@@ -563,2 +571,7 @@\n-     * representing the target address of the foreign function is the {@link MemorySegment#NULL} address.\n-     * The returned method handle will additionally throw {@link NullPointerException} if any argument passed to it is {@code null}.\n+     * representing the target address of the foreign function is the {@link MemorySegment#NULL} address. If an argument\n+     * is a {@link MemorySegment}, whose corresponding layout is a {@linkplain GroupLayout group layout}, the linker\n+     * might attempt to access the contents of the segment. As such, one of the exceptions specified by the\n+     * {@link MemorySegment#get(ValueLayout.OfByte, long)} or the\n+     * {@link MemorySegment#copy(MemorySegment, long, MemorySegment, long, long)} methods may be thrown.\n+     * The returned method handle will additionally throw {@link NullPointerException} if any argument\n+     * passed to it is {@code null}.\n@@ -568,2 +581,1 @@\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n+     * the JVM or, worse, silently result in memory corruption.\n@@ -606,2 +618,1 @@\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n+     * the JVM or, worse, silently result in memory corruption.\n@@ -642,0 +653,16 @@\n+    \/**\n+     * {@return an unmodifiable mapping between the names of data types used by the ABI implemented by this linker and their\n+     * <em>canonical layouts<\/em>}\n+     * <p>\n+     * Each {@link Linker} is responsible for choosing the data types that are widely recognized as useful on the OS\n+     * and processor combination supported by the {@link Linker}. Accordingly, the precise set of data type names\n+     * and canonical layouts exposed by the linker is unspecified; it varies from one {@link Linker} to another.\n+     * @implNote It is strongly recommended that the result of {@link #canonicalLayouts()} exposes a set of symbols that is stable over time.\n+     * Clients of {@link #canonicalLayouts()} are likely to fail if a data type that was previously exposed by the linker\n+     * is no longer exposed, or if its canonical layout is updated.\n+     * <p>If an implementer provides {@link Linker} implementations for multiple OS and processor combinations, then it is strongly\n+     * recommended that the result of {@link #canonicalLayouts()} exposes, as much as possible, a consistent set of symbols\n+     * across all the OS and processor combinations.\n+     *\/\n+    Map<String, MemoryLayout> canonicalLayouts();\n+\n@@ -644,1 +671,1 @@\n-     * @since 20\n+     * @since 22\n@@ -646,1 +673,0 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n@@ -710,0 +736,2 @@\n+         * <p>\n+         * This linker option can not be combined with {@link #critical}.\n@@ -753,1 +781,1 @@\n-         * {@return a linker option used to mark a foreign function as <em>trivial<\/em>}\n+         * {@return a linker option used to mark a foreign function as <em>critical<\/em>}\n@@ -755,2 +783,2 @@\n-         * A trivial function is a function that has an extremely short running time\n-         * in all cases (similar to calling an empty function), and does not call back into Java (e.g. using an upcall stub).\n+         * A critical function is a function that has an extremely short running time in all cases\n+         * (similar to calling an empty function), and does not call back into Java (e.g. using an upcall stub).\n@@ -759,1 +787,1 @@\n-         * optimizations that are only valid for trivial functions.\n+         * optimizations that are only valid for critical functions.\n@@ -761,1 +789,1 @@\n-         * Using this linker option when linking non trivial functions is likely to have adverse effects,\n+         * Using this linker option when linking non-critical functions is likely to have adverse effects,\n@@ -764,2 +792,2 @@\n-        static Option isTrivial() {\n-            return LinkerOptions.IsTrivial.INSTANCE;\n+        static Option critical() {\n+            return LinkerOptions.Critical.INSTANCE;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":101,"deletions":73,"binary":false,"changes":174,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.lang.invoke.MethodType;\n@@ -46,1 +47,1 @@\n-import jdk.internal.javac.PreviewFeature;\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -51,1 +52,1 @@\n- * There are two leaves in the layout hierarchy, {@linkplain ValueLayout value layouts}, which are used to represent values of given size and kind (see\n+ * There are two leaves in the layout hierarchy, {@linkplain ValueLayout value layouts}, which are used to represent values of given size and kind\n@@ -79,1 +80,1 @@\n- * SequenceLayout taggedValues = MemoryLayout.sequenceLayout(5,\n+ * SequenceLayout TAGGED_VALUES = MemoryLayout.sequenceLayout(5,\n@@ -134,1 +135,1 @@\n- * long valueOffset = taggedValues.byteOffset(PathElement.sequenceElement(0),\n+ * long valueOffset = TAGGED_VALUES.byteOffset(PathElement.sequenceElement(0),\n@@ -140,1 +141,1 @@\n- * MemoryLayout value = taggedValues.select(PathElement.sequenceElement(),\n+ * MemoryLayout value = TAGGED_VALUES.select(PathElement.sequenceElement(),\n@@ -153,1 +154,1 @@\n- * VarHandle valueHandle = taggedValues.varHandle(PathElement.sequenceElement(),\n+ * VarHandle valueHandle = TAGGED_VALUES.varHandle(PathElement.sequenceElement(),\n@@ -155,2 +156,5 @@\n- * MemorySegment valuesSegment = ...\n- * int val = (int) valueHandle.get(valuesSegment, 2); \/\/ reads the \"value\" field of the third struct in the array\n+ * MemorySegment taggedValues = ...\n+ * \/\/ reads the \"value\" field of the third struct in the array (taggedValues[2].value)\n+ * int val = (int) valueHandle.get(taggedValues,\n+ *         0L,  \/\/ base offset\n+ *         2L); \/\/ sequence index\n@@ -166,1 +170,1 @@\n- * MethodHandle offsetHandle = taggedValues.byteOffsetHandle(PathElement.sequenceElement(),\n+ * MethodHandle offsetHandle = TAGGED_VALUES.byteOffsetHandle(PathElement.sequenceElement(),\n@@ -168,2 +172,2 @@\n- * long offset1 = (long) offsetHandle.invokeExact(1L); \/\/ 8\n- * long offset2 = (long) offsetHandle.invokeExact(2L); \/\/ 16\n+ * long offset1 = (long) offsetHandle.invokeExact(0L, 1L); \/\/ 0 + (1 * 8) = 8\n+ * long offset2 = (long) offsetHandle.invokeExact(0L, 2L); \/\/ 0 + (2 * 8) = 16\n@@ -207,1 +211,4 @@\n- * int rect_y_4 = (int) rectPointYs.get(rect, 2); \/\/ rect.points[2]->y\n+ * \/\/ dereferences the third point struct in the \"points\" array, and reads its \"y\" coordinate (rect.points[2]->y)\n+ * int rect_y_2 = (int) rectPointYs.get(rect,\n+ *     0L,  \/\/ base offset\n+ *     2L); \/\/ sequence index\n@@ -234,0 +241,98 @@\n+ * <h2 id=\"access-mode-restrictions\">Access mode restrictions<\/h2>\n+ *\n+ * A var handle returned by {@link #varHandle(PathElement...)} or {@link ValueLayout#varHandle()} features certain\n+ * access characteristics, which are derived from the selected layout {@code L}:\n+ * <ul>\n+ * <li>A carrier type {@code T}, derived from {@code L.carrier()}<\/li>\n+ * <li>An alignment constraint {@code A}, derived from {@code L.byteAlignment()}<\/li>\n+ * <li>An access size {@code S}, derived from {@code L.byteSize()}<\/li>\n+ * <\/ul>\n+ * Depending on the above characteristics, the returned var handle might feature certain <i>access mode restrictions<\/i>.\n+ * We say that a var handle is <em>aligned<\/em> if its alignment constraint {@code A} is compatible with the access size\n+ * {@code S}, that is if {@code A >= S}. An aligned var handle is guaranteed to support the following access modes:\n+ * <ul>\n+ * <li>read write access modes for all {@code T}. On 32-bit platforms, access modes\n+ *     {@code get} and {@code set} for {@code long}, {@code double} and {@code MemorySegment}\n+ *     are supported but might lead to word tearing, as described in Section {@jls 17.7}.\n+ *     of <cite>The Java Language Specification<\/cite>.\n+ * <li>atomic update access modes for {@code int}, {@code long},\n+ *     {@code float}, {@code double} and {@link MemorySegment}.\n+ *     (Future major platform releases of the JDK may support additional\n+ *     types for certain currently unsupported access modes.)\n+ * <li>numeric atomic update access modes for {@code int}, {@code long} and {@link MemorySegment}.\n+ *     (Future major platform releases of the JDK may support additional\n+ *     numeric types for certain currently unsupported access modes.)\n+ * <li>bitwise atomic update access modes for {@code int}, {@code long} and {@link MemorySegment}.\n+ *     (Future major platform releases of the JDK may support additional\n+ *     numeric types for certain currently unsupported access modes.)\n+ * <\/ul>\n+ * If {@code T} is {@code float}, {@code double} or {@link MemorySegment} then atomic update access modes compare\n+ * values using their bitwise representation (see {@link Float#floatToRawIntBits}, {@link Double#doubleToRawLongBits}\n+ * and {@link MemorySegment#address()}, respectively).\n+ * <p>\n+ * Alternatively, a var handle is <em>unaligned<\/em> if its alignment constraint {@code A} is incompatible with the\n+ * access size {@code S}, that is, if {@code A < S}. An unaligned var handle only supports the {@code get} and {@code set}\n+ * access modes. All other access modes will result in {@link UnsupportedOperationException} being thrown. Moreover,\n+ * while supported, access modes {@code get} and {@code set} might lead to word tearing.\n+ *\n+ * <h2 id=\"variable-length\">Working with variable-length structs<\/h2>\n+ *\n+ * Memory layouts allow clients to describe the contents of a region of memory whose size is known <em>statically<\/em>.\n+ * There are, however, cases, where the size of a region of memory is only known <em>dynamically<\/em>, as it depends\n+ * on the value of one or more struct fields. Consider the following struct declaration in C:\n+ *\n+ * {@snippet lang=c :\n+ * typedef struct {\n+ *     int size;\n+ *     struct {\n+ *         int x;\n+ *         int y;\n+ *     } points[];\n+ * } Polygon;\n+ * }\n+ *\n+ * In the above code, a polygon is modelled as a size (the number of edges in the polygon) and an array of points\n+ * (one for each vertex in the polygon). The number of vertices depends on the number of edges in the polygon. As such,\n+ * the size of the {@code points} array is left <em>unspecified<\/em> in the C declaration, using a <em>Flexible Array Member<\/em>\n+ * (a feature standardized in C99).\n+ * <p>\n+ * Memory layouts do not support sequence layouts whose size is unknown. As such, it is not possible to model\n+ * the above struct directly. That said, clients can still enjoy structured access provided by memory layouts, as\n+ * demonstrated below:\n+ *\n+ * {@snippet lang=java :\n+ * StructLayout POINT = MemoryLayout.structLayout(\n+ *             ValueLayout.JAVA_INT.withName(\"x\"),\n+ *             ValueLayout.JAVA_INT.withName(\"y\")\n+ * );\n+ *\n+ * StructLayout POLYGON = MemoryLayout.structLayout(\n+ *             ValueLayout.JAVA_INT.withName(\"size\"),\n+ *             MemoryLayout.sequenceLayout(0, POINT).withName(\"points\")\n+ * );\n+ *\n+ * VarHandle POLYGON_SIZE = POLYGON.varHandle(0, PathElement.groupElement(\"size\"));\n+ * VarHandle POINT_X = POINT.varHandle(PathElement.groupElement(\"x\"));\n+ * long POINTS_OFFSET = POLYGON.byteOffset(PathElement.groupElement(\"points\"));\n+ * }\n+ *\n+ * Note how we have split the polygon struct in two. The {@code POLYGON} layout contains a sequence layout\n+ * of size <em>zero<\/em>. The element layout of the sequence layout is the {@code POINT} layout, which defines\n+ * the {@code x} and {@code y} coordinates, accordingly. The first layout is used to obtain a var handle\n+ * that provides access to the polygon size; the second layout is used to obtain a var handle that provides\n+ * access to the {@code x} coordinate of a point struct. Finally, an offset to the start of the variable-length\n+ * {@code points} array is also obtained.\n+ * <p>\n+ * The {@code x} coordinates of all the points in a polygon can then be accessed as follows:\n+ * {@snippet lang=java :\n+ * MemorySegment polygon = ...\n+ * int size = POLYGON_SIZE.get(polygon, 0L);\n+ * for (int i = 0 ; i < size ; i++) {\n+ *     int x = POINT_X.get(polygon, POINT.scaleOffset(POINTS_OFFSET, i));\n+ * }\n+ *  }\n+ * Here, we first obtain the polygon size, using the {@code POLYGON_SIZE} var handle. Then, in a loop, we read\n+ * the {@code x} coordinates of all the points in the polygon. This is done by providing a custom base offset to\n+ * the {@code POINT_X} var handle. The custom offset is computed as {@code POINTS_OFFSET + (i * POINT.byteSize())}, where\n+ * {@code i} is the loop induction variable.\n+ *\n@@ -238,1 +343,1 @@\n- * @since 19\n+ * @since 22\n@@ -240,1 +345,0 @@\n-@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n@@ -295,0 +399,38 @@\n+    \/**\n+     * {@return {@code offset + (byteSize() * index)}}\n+     *\n+     * @param offset the base offset\n+     * @param index the index to be scaled by the byte size of this layout\n+     * @throws IllegalArgumentException if {@code offset} or {@code index} is negative\n+     * @throws ArithmeticException if either the addition or multiplication overflows\n+     *\/\n+    @ForceInline\n+    default long scale(long offset, long index) {\n+        if (offset < 0) {\n+            throw new IllegalArgumentException(\"Negative offset: \" + offset);\n+        }\n+        if (index < 0) {\n+            throw new IllegalArgumentException(\"Negative index: \" + index);\n+        }\n+\n+        return Math.addExact(offset, Math.multiplyExact(byteSize(), index));\n+    }\n+\n+    \/**\n+     *{@return a method handle that can be used to invoke {@link #scale(long, long)} on this layout}\n+     *\/\n+    default MethodHandle scaleHandle() {\n+        class Holder {\n+            static final MethodHandle MH_SCALE;\n+            static {\n+                try {\n+                    MH_SCALE = MethodHandles.lookup().findVirtual(MemoryLayout.class, \"scale\",\n+                            MethodType.methodType(long.class, long.class, long.class));\n+                } catch (ReflectiveOperationException e) {\n+                    throw new ExceptionInInitializerError(e);\n+                }\n+            }\n+        }\n+        return Holder.MH_SCALE.bindTo(this);\n+    }\n+\n@@ -317,1 +459,2 @@\n-     *     <li>it has as zero or more parameters of type {@code long}, one for each <a href=#open-path-elements>open path element<\/a>\n+     *     <li>it has one leading {@code long} parameter representing the base offset;<\/li>\n+     *     <li>it has as zero or more trailing parameters of type {@code long}, one for each <a href=#open-path-elements>open path element<\/a>\n@@ -325,1 +468,1 @@\n-     * offset = c_1 + c_2 + ... + c_m + (x_1 * s_1) + (x_2 * s_2) + ... + (x_n * s_n)\n+     * offset = b + c_1 + c_2 + ... + c_m + (x_1 * s_1) + (x_2 * s_2) + ... + (x_n * s_n)\n@@ -328,4 +471,5 @@\n-     * where {@code x_1}, {@code x_2}, ... {@code x_n} are <em>dynamic<\/em> values provided as {@code long}\n-     * arguments, whereas {@code c_1}, {@code c_2}, ... {@code c_m} are <em>static<\/em> offset constants\n-     * and {@code s_0}, {@code s_1}, ... {@code s_n} are <em>static<\/em> stride constants which are derived from\n-     * the layout path.\n+     * where {@code b} represents the base offset provided as a <em>dynamic<\/em> {@code long} argument, {@code x_1}, {@code x_2},\n+     * ... {@code x_n} represent indices into sequences provided as <em>dynamic<\/em> {@code long} arguments, whereas\n+     * {@code s_1}, {@code s_2}, ... {@code s_n} are <em>static<\/em> stride constants derived from the size of the element\n+     * layout of a sequence, and {@code c_1}, {@code c_2}, ... {@code c_m} are other <em>static<\/em> offset constants\n+     * (such as field offsets) which are derived from the layout path.\n@@ -354,4 +498,6 @@\n-     *     <li>it has as zero or more access coordinates of type {@code long}, one for each\n-     *     <a href=#open-path-elements>open path element<\/a> in the provided layout path. The order of these access\n-     *     coordinates corresponds to the order in which the open path elements occur in the provided\n-     *     layout path.\n+     *     <li>it has a leading parameter of type {@code MemorySegment} representing the accessed segment<\/li>\n+     *     <li>a following {@code long} parameter, corresponding to the base offset, denoted as {@code B};<\/li>\n+     *     <li>it has zero or more trailing access coordinates of type {@code long}, one for each\n+     *     <a href=#open-path-elements>open path element<\/a> in the provided layout path, denoted as\n+     *     {@code I1, I2, ... In}, respectively. The order of these access coordinates corresponds to the order\n+     *     in which the open path elements occur in the provided layout path.\n@@ -360,14 +506,2 @@\n-     * The final address accessed by the returned var handle can be computed as follows:\n-     *\n-     * <blockquote><pre>{@code\n-     * address = base(segment) + offset\n-     * }<\/pre><\/blockquote>\n-     *\n-     * Where {@code base(segment)} denotes a function that returns the physical base address of the accessed\n-     * memory segment. For native segments, this function just returns the native segment's\n-     * {@linkplain MemorySegment#address() address}. For heap segments, this function is more complex, as the address\n-     * of heap segments is virtualized. The {@code offset} value can be expressed in the following form:\n-     *\n-     * <blockquote><pre>{@code\n-     * offset = c_1 + c_2 + ... + c_m + (x_1 * s_1) + (x_2 * s_2) + ... + (x_n * s_n)\n-     * }<\/pre><\/blockquote>\n+     * If the provided layout path {@code P} contains no dereference elements, then the offset {@code O} of the access\n+     * operation is computed as follows:\n@@ -375,4 +509,3 @@\n-     * where {@code x_1}, {@code x_2}, ... {@code x_n} are <em>dynamic<\/em> values provided as {@code long}\n-     * arguments, whereas {@code c_1}, {@code c_2}, ... {@code c_m} are <em>static<\/em> offset constants\n-     * and {@code s_1}, {@code s_2}, ... {@code s_n} are <em>static<\/em> stride constants which are derived from\n-     * the layout path.\n+     * {@snippet lang = \"java\":\n+     * O = this.offsetHandle(P).invokeExact(B, I1, I2, ... In);\n+     * }\n@@ -380,2 +513,15 @@\n-     * Additionally, the provided dynamic values must conform to bounds which are derived from the layout path, that is,\n-     * {@code 0 <= x_i < b_i}, where {@code 1 <= i <= n}, or {@link IndexOutOfBoundsException} is thrown.\n+     * Accessing a memory segment using the var handle returned by this method is subject to the following checks:\n+     * <ul>\n+     *     <li>The physical address of the accessed memory segment must be <a href=\"MemorySegment.html#segment-alignment\">aligned<\/a>\n+     * according to the {@linkplain #byteAlignment() alignment constraint} of the root layout (this layout), or\n+     * an {@link IllegalArgumentException} will be issued. Note that the alignment constraint of the root layout\n+     * can be more strict (but not less) than the alignment constraint of the selected value layout.<\/li>\n+     *     <li>The offset of the access operation (computed as above) must fall inside the spatial bounds of the\n+     * accessed memory segment, or an {@link IndexOutOfBoundsException} is thrown. This is the case when {@code O + A <= S},\n+     * where {@code O} is the accessed offset (computed as above), {@code A} is the size of the selected layout and {@code S}\n+     * is the size of the accessed memory segment.<\/li>\n+     *     <li>The accessed memory segment must be {@link MemorySegment#isAccessibleBy(Thread) accessible} from the\n+     * thread performing the access operation, or a {@link WrongThreadException} is thrown.<\/li>\n+     *     <li>The {@linkplain MemorySegment#scope() scope} associated with the accessed segment must be\n+     * {@linkplain MemorySegment.Scope#isAlive() alive}, or an {@link IllegalStateException} is thrown.<\/li>\n+     * <\/ul>\n@@ -383,3 +529,13 @@\n-     * The base address must be <a href=\"MemorySegment.html#segment-alignment\">aligned<\/a> according to the {@linkplain\n-     * #byteAlignment() alignment constraint} of the root layout (this layout). Note that this can be more strict\n-     * (but not less) than the alignment constraint of the selected value layout.\n+     * If the selected layout is an {@linkplain AddressLayout address layout}, calling {@link VarHandle#get(Object...)}\n+     * on the returned var handle will return a new memory segment. The segment is associated with a fresh scope that is\n+     * always alive. Moreover, the size of the segment depends on whether the address layout has a\n+     * {@linkplain AddressLayout#targetLayout() target layout}. More specifically:\n+     * <ul>\n+     *     <li>If the address layout has a target layout {@code T}, then the size of the returned segment\n+     *     is {@code T.byteSize()};<\/li>\n+     *     <li>Otherwise, the address layout has no target layout, and the size of the returned segment\n+     *     is <a href=\"MemorySegment.html#wrapping-addresses\">zero<\/a>.<\/li>\n+     * <\/ul>\n+     * Moreover, if the selected layout is an {@linkplain AddressLayout address layout}, calling {@link VarHandle#set(Object...)}\n+     * can throw {@link IllegalArgumentException} if the memory segment representing the address to be written is not a\n+     * {@linkplain MemorySegment#isNative() native} memory segment.\n@@ -387,5 +543,4 @@\n-     * Multiple paths can be chained, with <a href=#deref-path-elements>dereference path elements<\/a>.\n-     * A dereference path element constructs a fresh native memory segment whose base address is the address value\n-     * read obtained by accessing a memory segment at the offset determined by the layout path elements immediately preceding\n-     * the dereference path element. In other words, if a layout path contains one or more dereference path elements,\n-     * the final address accessed by the returned var handle can be computed as follows:\n+     * If the provided layout path has size {@code m} and contains a dereference path element in position {@code k}\n+     * (where {@code k <= m}) then two layout paths {@code P} and {@code P'} are derived, where P contains all the path\n+     * elements from 0 to {@code k - 1} and {@code P'} contains all the path elements from {@code k + 1} to\n+     * {@code m} (if any). Then, the returned var handle is computed as follows:\n@@ -393,6 +548,8 @@\n-     * <blockquote><pre>{@code\n-     * address_1 = base(segment) + offset_1\n-     * address_2 = base(segment_1) + offset_2\n-     * ...\n-     * address_k = base(segment_k-1) + offset_k\n-     * }<\/pre><\/blockquote>\n+     * {@snippet lang = \"java\":\n+     * VarHandle baseHandle = this.varHandle(P);\n+     * MemoryLayout target = ((AddressLayout)this.select(P)).targetLayout().get();\n+     * VarHandle targetHandle = target.varHandle(P');\n+     * targetHandle = MethodHandles.insertCoordinates(targetHandle, 1, 0L); \/\/ always access nested targets at offset 0\n+     * targetHandle = MethodHandles.collectCoordinates(targetHandle, 0,\n+     *         baseHandle.toMethodHandle(VarHandle.AccessMode.GET));\n+     * }\n@@ -400,8 +557,14 @@\n-     * where {@code k} is the number of dereference path elements in a layout path, {@code segment} is the input segment,\n-     * {@code segment_1}, ...  {@code segment_k-1} are the segments obtained by dereferencing the address associated with\n-     * a given dereference path element (e.g. {@code segment_1} is a native segment whose base address is {@code address_1}),\n-     * and {@code offset_1}, {@code offset_2}, ... {@code offset_k} are the offsets computed by evaluating\n-     * the path elements after a given dereference operation (these offsets are obtained using the computation described\n-     * above). In these more complex access operations, all memory accesses immediately preceding a dereference operation\n-     * (e.g. those at addresses {@code address_1}, {@code address_2}, ...,  {@code address_k-1} are performed using the\n-     * {@link VarHandle.AccessMode#GET} access mode.\n+     * (The above can be trivially generalized to cases where the provided layout path contains more than one dereference\n+     * path elements).\n+     * <p>\n+     * As an example, consider the memory layout expressed by a {@link GroupLayout} instance constructed as follows:\n+     * {@snippet lang = \"java\":\n+     *     GroupLayout grp = java.lang.foreign.MemoryLayout.structLayout(\n+     *             MemoryLayout.paddingLayout(4),\n+     *             ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN).withName(\"value\")\n+     *     );\n+     * }\n+     * To access the member layout named {@code value}, we can construct a var handle as follows:\n+     * {@snippet lang = \"java\":\n+     *     VarHandle handle = grp.varHandle(PathElement.groupElement(\"value\")); \/\/(MemorySegment, long) -> int\n+     * }\n@@ -409,2 +572,2 @@\n-     * @apiNote The resulting var handle features certain <em>access mode restrictions<\/em>, which are common to all\n-     * {@linkplain MethodHandles#memorySegmentViewVarHandle(ValueLayout) memory segment view handles}.\n+     * @apiNote The resulting var handle features certain <a href=\"#access-mode-restrictions\"><em>access mode restrictions<\/em><\/a>,\n+     * which are common to all var handles derived from memory layouts.\n@@ -416,1 +579,0 @@\n-     * @see MethodHandles#memorySegmentViewVarHandle(ValueLayout)\n@@ -419,0 +581,4 @@\n+        Objects.requireNonNull(elements);\n+        if (this instanceof ValueLayout vl && elements.length == 0) {\n+            return vl.varHandle(); \/\/ fast path\n+        }\n@@ -430,3 +596,3 @@\n-     *     <li>it has a leading parameter of type {@code MemorySegment}, corresponding to the memory segment\n-     *     to be sliced;<\/li>\n-     *     <li>it has as zero or more parameters of type {@code long}, one for each <a href=#open-path-elements>open path element<\/a>\n+     *     <li>it has a leading parameter of type {@code MemorySegment} corresponding to the memory segment to be sliced<\/li>\n+     *     <li>a following {@code long} parameter, corresponding to the base offset<\/li>\n+     *     <li>it has as zero or more trailing parameters of type {@code long}, one for each <a href=#open-path-elements>open path element<\/a>\n@@ -437,6 +603,2 @@\n-     * The offset of the returned segment is computed as follows:\n-     * {@snippet lang=java :\n-     * long offset = byteOffset(elements);\n-     * long size = select(elements).byteSize();\n-     * MemorySegment slice = segment.asSlice(offset, size);\n-     * }\n+     * The offset {@code O} of the returned segment is computed as if by a call to a\n+     * {@linkplain #byteOffsetHandle(PathElement...) byte offset handle} constructed using the given path elements.\n@@ -444,3 +606,11 @@\n-     * The segment to be sliced must be <a href=\"MemorySegment.html#segment-alignment\">aligned<\/a> according to the\n-     * {@linkplain #byteAlignment() alignment constraint} of the root layout (this layout). Note that this can be more\n-     * strict (but not less) than the alignment constraint of the selected value layout.\n+     * Computing a slice of a memory segment using the method handle returned by this method is subject to the following checks:\n+     * <ul>\n+     *     <li>The physical address of the accessed memory segment must be <a href=\"MemorySegment.html#segment-alignment\">aligned<\/a>\n+     * according to the {@linkplain #byteAlignment() alignment constraint} of the root layout (this layout), or\n+     * an {@link IllegalArgumentException} will be issued. Note that the alignment constraint of the root layout\n+     * can be more strict (but not less) than the alignment constraint of the selected layout.<\/li>\n+     *     <li>The start offset of the slicing operation (computed as above) must fall fall inside the spatial bounds of the\n+     * accessed memory segment, or an {@link IndexOutOfBoundsException} is thrown. This is the case when {@code O + A <= S},\n+     * where {@code O} is the start offset of the slicing operation (computed as above), {@code A} is the size of the\n+     * selected layout and {@code S} is the size of the accessed memory segment.<\/li>\n+     * <\/ul>\n@@ -504,1 +674,1 @@\n-     * @since 19\n+     * @since 22\n@@ -506,1 +676,0 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n@@ -672,18 +841,0 @@\n-    \/**\n-     * Creates a sequence layout with the given element layout and the maximum element\n-     * count such that it does not overflow a {@code long}.\n-     *\n-     * This is equivalent to the following code:\n-     * {@snippet lang = java:\n-     * sequenceLayout(Long.MAX_VALUE \/ elementLayout.byteSize(), elementLayout);\n-     * }\n-     *\n-     * @param elementLayout the sequence element layout.\n-     * @return a new sequence layout with the given element layout and maximum element count.\n-     * @throws IllegalArgumentException if {@code elementLayout.byteSize() % elementLayout.byteAlignment() != 0}.\n-     *\/\n-    static SequenceLayout sequenceLayout(MemoryLayout elementLayout) {\n-        Objects.requireNonNull(elementLayout);\n-        return sequenceLayout(Long.MAX_VALUE \/ elementLayout.byteSize(), elementLayout);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryLayout.java","additions":252,"deletions":101,"binary":false,"changes":353,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import java.lang.foreign.Linker.Option;\n+import java.lang.foreign.ValueLayout.OfInt;\n@@ -31,1 +31,1 @@\n-import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n@@ -37,1 +37,2 @@\n-import java.nio.channels.FileChannel.*;\n+import java.nio.channels.FileChannel.MapMode;\n+import java.nio.charset.Charset;\n@@ -46,1 +47,0 @@\n-import jdk.internal.foreign.HeapMemorySegmentImpl;\n@@ -48,1 +48,2 @@\n-import jdk.internal.foreign.NativeMemorySegmentImpl;\n+import jdk.internal.foreign.SegmentFactories;\n+import jdk.internal.foreign.StringSupport;\n@@ -50,3 +51,0 @@\n-import jdk.internal.foreign.abi.SharedUtils;\n-import jdk.internal.foreign.layout.ValueLayouts;\n-import jdk.internal.javac.PreviewFeature;\n@@ -127,1 +125,0 @@\n- * MemorySegment segment = ...\n@@ -131,5 +128,3 @@\n- * For more complex access operations (e.g. structured memory access), clients can obtain a\n- * {@linkplain MethodHandles#memorySegmentViewVarHandle(ValueLayout) var handle}\n- * that accepts a segment and a {@code long} offset. More complex var handles\n- * can be obtained by adapting a segment var handle view using the var handle combinator functions defined in the\n- * {@link java.lang.invoke.MethodHandles} class:\n+ * Access operations on memory segments are implemented using var handles. The {@link ValueLayout#varHandle()}\n+ * method can be used to obtain a var handle that can be used to get\/set values represented by the given value layout\n+ * on a memory segment at the given offset:\n@@ -137,9 +132,3 @@\n- * {@snippet lang=java :\n- * MemorySegment segment = ...\n- * VarHandle intHandle = MethodHandles.memorySegmentViewVarHandle(ValueLayout.JAVA_INT);\n- * MethodHandle multiplyExact = MethodHandles.lookup()\n- *                                           .findStatic(Math.class, \"multiplyExact\",\n- *                                                                   MethodType.methodType(long.class, long.class, long.class));\n- * intHandle = MethodHandles.filterCoordinates(intHandle, 1,\n- *                                             MethodHandles.insertArguments(multiplyExact, 0, ValueLayout.JAVA_INT.byteSize()));\n- * int value = (int) intHandle.get(segment, 3L); \/\/ get int element at offset 3 * 4 = 12\n+ * {@snippet lang=java:\n+ * VarHandle intAtOffsetHandle = ValueLayout.JAVA_INT.varHandle(); \/\/ (MemorySegment, long)\n+ * int value = (int) intAtOffsetHandle.get(segment, 10L);          \/\/ segment.get(ValueLayout.JAVA_INT, 10L)\n@@ -148,3 +137,4 @@\n- * Alternatively, complex var handles can can be obtained\n- * from {@linkplain MemoryLayout#varHandle(MemoryLayout.PathElement...) memory layouts}\n- * by providing a so called <a href=\"MemoryLayout.html#layout-paths\"><em>layout path<\/em><\/a>:\n+ * The var handle returned by {@link ValueLayout#varHandle()} features a <em>base offset<\/em> parameter. This parameter\n+ * allows clients to express complex access operations, by injecting additional offset computation into the var handle.\n+ * For instance, a var handle that can be used to access an element of an {@code int} array at a given logical\n+ * index can be created as follows:\n@@ -152,4 +142,5 @@\n- * {@snippet lang=java :\n- * MemorySegment segment = ...\n- * VarHandle intHandle = ValueLayout.JAVA_INT.arrayElementVarHandle();\n- * int value = (int) intHandle.get(segment, 3L); \/\/ get int element at offset 3 * 4 = 12\n+ * {@snippet lang=java:\n+ * MethodHandle scale = ValueLayout.JAVA_INT.scaleHandle();              \/\/ (long, long)long\n+ * VarHandle intAtOffsetAndIndexHandle =\n+ *         MethodHandles.collectCoordinates(intAtOffsetHandle, 1, scale); \/\/ (MemorySegment, long, long)\n+ * int value = (int) intAtOffsetAndIndexHandle.get(segment, 2L, 3L);     \/\/ segment.get(ValueLayout.JAVA_INT, 2L + (3L * 4L))\n@@ -158,0 +149,13 @@\n+ * <p>\n+ * Clients can also drop the base offset parameter, in order to make the access expression simpler. This can be used to\n+ * implement access operation such as {@link #getAtIndex(OfInt, long)}:\n+ *\n+ * {@snippet lang=java:\n+ * VarHandle intAtIndexHandle =\n+ *         MethodHandles.insertCoordinates(intAtOffsetAndIndexHandle, 1, 0L); \/\/ (MemorySegment, long)\n+ * int value = (int) intAtIndexHandle.get(segment, 3L);                       \/\/ segment.getAtIndex(ValueLayout.JAVA_INT, 3L);\n+ * }\n+ *\n+ * Var handles for more complex access expressions (e.g. struct field access, pointer dereference) can be created directly\n+ * from memory layouts, using <a href=\"MemoryLayout.html#layout-paths\"><em>layout paths<\/em><\/a>.\n+ *\n@@ -437,1 +441,1 @@\n- * @since 19\n+ * @since 22\n@@ -439,1 +443,0 @@\n-@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n@@ -600,2 +603,1 @@\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n+     * the JVM or, worse, silently result in memory corruption.\n@@ -634,2 +636,1 @@\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n+     * the JVM or, worse, silently result in memory corruption.\n@@ -674,2 +675,1 @@\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n+     * the JVM or, worse, silently result in memory corruption.\n@@ -742,24 +742,0 @@\n-    \/**\n-     * Returns the offset, in bytes, of the provided segment, relative to this\n-     * segment.\n-     *\n-     * <p>The offset is relative to the address of this segment and can be\n-     * a negative or positive value. For instance, if both segments are native\n-     * segments, or heap segments backed by the same array, the resulting offset\n-     * can be computed as follows:\n-     *\n-     * {@snippet lang=java :\n-     * other.address() - address()\n-     * }\n-     *\n-     * If the segments share the same address, {@code 0} is returned. If\n-     * {@code other} is a slice of this segment, the offset is always\n-     * {@code 0 <= x < this.byteSize()}.\n-     *\n-     * @param other the segment to retrieve an offset to.\n-     * @throws UnsupportedOperationException if the two segments cannot be compared, e.g. because they are of\n-     * different kinds, or because they are backed by different Java arrays.\n-     * @return the relative offset, in bytes, of the provided segment.\n-     *\/\n-    long segmentOffset(MemorySegment other);\n-\n@@ -774,1 +750,1 @@\n-     *     byteHandle.set(ValueLayout.JAVA_BYTE, offset, value);\n+     *     segment.set(ValueLayout.JAVA_BYTE, offset, value);\n@@ -1075,1 +1051,2 @@\n-     * Reads a UTF-8 encoded, null-terminated string from this segment at the given offset.\n+     * Reads a null-terminated string from this segment at the given offset, using the\n+     * {@linkplain StandardCharsets#UTF_8 UTF-8} charset.\n@@ -1077,4 +1054,5 @@\n-     * This method always replaces malformed-input and unmappable-character\n-     * sequences with this charset's default replacement string.  The {@link\n-     * java.nio.charset.CharsetDecoder} class should be used when more control\n-     * over the decoding process is required.\n+     * Calling this method is equivalent to the following code:\n+     * {@snippet lang = java:\n+     * getString(offset, StandardCharsets.UTF_8);\n+     *}\n+     *\n@@ -1084,3 +1062,4 @@\n-     * @throws IllegalArgumentException if the size of the UTF-8 string is greater than the largest string supported by the platform.\n-     * @throws IndexOutOfBoundsException if {@code offset < 0} or {@code offset > byteSize() - S}, where {@code S} is the size of the UTF-8\n-     * string (including the terminator character).\n+     * @throws IllegalArgumentException if the size of the string is greater than the largest string supported by the platform.\n+     * @throws IndexOutOfBoundsException     if {@code offset < 0}.\n+     * @throws IndexOutOfBoundsException     if {@code offset > byteSize() - (B + 1)}, where {@code B} is the size,\n+     * in bytes, of the string encoded using UTF-8 charset {@code str.getBytes(StandardCharsets.UTF_8).length}).\n@@ -1092,2 +1071,2 @@\n-    default String getUtf8String(long offset) {\n-        return SharedUtils.toJavaStringInternal(this, offset);\n+    default String getString(long offset) {\n+        return getString(offset, sun.nio.cs.UTF_8.INSTANCE);\n@@ -1097,1 +1076,1 @@\n-     * Writes the given string into this segment at the given offset, converting it to a null-terminated byte sequence using UTF-8 encoding.\n+     * Reads a null-terminated string from this segment at the given offset, using the provided charset.\n@@ -1103,0 +1082,28 @@\n+     *\n+     * @param offset  offset in bytes (relative to this segment address) at which this access operation will occur.\n+     * @param charset the charset used to {@linkplain Charset#newDecoder() decode} the string bytes.\n+     * @return a Java string constructed from the bytes read from the given starting address up to (but not including)\n+     * the first {@code '\\0'} terminator character (assuming one is found).\n+     * @throws IllegalArgumentException      if the size of the string is greater than the largest string supported by the platform.\n+     * @throws IndexOutOfBoundsException     if {@code offset < 0}.\n+     * @throws IndexOutOfBoundsException     if {@code offset > byteSize() - (B + N)}, where:\n+     * <ul>\n+     *     <li>{@code B} is the size, in bytes, of the string encoded using the provided charset\n+     *     (e.g. {@code str.getBytes(charset).length});<\/li>\n+     *     <li>{@code N} is the size (in bytes) of the terminator char according to the provided charset. For instance,\n+     *     this is 1 for {@link StandardCharsets#US_ASCII} and 2 for {@link StandardCharsets#UTF_16}.<\/li>\n+     * <\/ul>\n+     * @throws IllegalStateException    if the {@linkplain #scope() scope} associated with this segment is not\n+     *                                  {@linkplain Scope#isAlive() alive}.\n+     * @throws WrongThreadException     if this method is called from a thread {@code T},\n+     *                                  such that {@code isAccessibleBy(T) == false}.\n+     * @throws IllegalArgumentException if {@code charset} is not a {@linkplain StandardCharsets standard charset}.\n+     *\/\n+    default String getString(long offset, Charset charset) {\n+        Objects.requireNonNull(charset);\n+        return StringSupport.read(this, offset, charset);\n+    }\n+\n+    \/**\n+     * Writes the given string into this segment at the given offset, converting it to a null-terminated byte sequence\n+     * using the {@linkplain StandardCharsets#UTF_8 UTF-8} charset.\n@@ -1104,4 +1111,4 @@\n-     * If the given string contains any {@code '\\0'} characters, they will be\n-     * copied as well. This means that, depending on the method used to read\n-     * the string, such as {@link MemorySegment#getUtf8String(long)}, the string\n-     * will appear truncated when read again.\n+     * Calling this method is equivalent to the following code:\n+     * {@snippet lang = java:\n+     * setString(offset, str, StandardCharsets.UTF_8);\n+     *}\n@@ -1111,1 +1118,3 @@\n-     * @throws IndexOutOfBoundsException if {@code offset < 0} or {@code offset > byteSize() - str.getBytes().length() + 1}.\n+     * @throws IndexOutOfBoundsException     if {@code offset < 0}.\n+     * @throws IndexOutOfBoundsException     if {@code offset > byteSize() - (B + 1)}, where {@code B} is the size,\n+     * in bytes, of the string encoded using UTF-8 charset {@code str.getBytes(StandardCharsets.UTF_8).length}).\n@@ -1117,2 +1126,3 @@\n-    default void setUtf8String(long offset, String str) {\n-        Utils.toCString(str.getBytes(StandardCharsets.UTF_8), SegmentAllocator.prefixAllocator(asSlice(offset)));\n+    default void setString(long offset, String str) {\n+        Objects.requireNonNull(str);\n+        setString(offset, str, sun.nio.cs.UTF_8.INSTANCE);\n@@ -1121,0 +1131,37 @@\n+    \/**\n+     * Writes the given string into this segment at the given offset, converting it to a null-terminated byte sequence\n+     * using the provided charset.\n+     * <p>\n+     * This method always replaces malformed-input and unmappable-character\n+     * sequences with this charset's default replacement string.  The {@link\n+     * java.nio.charset.CharsetDecoder} class should be used when more control\n+     * over the decoding process is required.\n+     * <p>\n+     * If the given string contains any {@code '\\0'} characters, they will be\n+     * copied as well. This means that, depending on the method used to read\n+     * the string, such as {@link MemorySegment#getString(long)}, the string\n+     * will appear truncated when read again.\n+     *\n+     * @param offset  offset in bytes (relative to this segment address) at which this access operation will occur.\n+     *                the final address of this write operation can be expressed as {@code address() + offset}.\n+     * @param str     the Java string to be written into this segment.\n+     * @param charset the charset used to {@linkplain Charset#newEncoder() encode} the string bytes.\n+     * @throws IndexOutOfBoundsException     if {@code offset < 0}.\n+     * @throws IndexOutOfBoundsException     if {@code offset > byteSize() - (B + N)}, where:\n+     * <ul>\n+     *     <li>{@code B} is the size, in bytes, of the string encoded using the provided charset\n+     *     (e.g. {@code str.getBytes(charset).length});<\/li>\n+     *     <li>{@code N} is the size (in bytes) of the terminator char according to the provided charset. For instance,\n+     *     this is 1 for {@link StandardCharsets#US_ASCII} and 2 for {@link StandardCharsets#UTF_16}.<\/li>\n+     * <\/ul>\n+     * @throws IllegalStateException    if the {@linkplain #scope() scope} associated with this segment is not\n+     *                                  {@linkplain Scope#isAlive() alive}.\n+     * @throws WrongThreadException     if this method is called from a thread {@code T},\n+     *                                  such that {@code isAccessibleBy(T) == false}.\n+     * @throws IllegalArgumentException if {@code charset} is not a {@linkplain StandardCharsets standard charset}.\n+     *\/\n+    default void setString(long offset, String str, Charset charset) {\n+        Objects.requireNonNull(charset);\n+        Objects.requireNonNull(str);\n+        StringSupport.write(this, offset, charset, str);\n+    }\n@@ -1158,1 +1205,1 @@\n-        return HeapMemorySegmentImpl.OfByte.fromArray(byteArray);\n+        return SegmentFactories.fromArray(byteArray);\n@@ -1170,1 +1217,1 @@\n-        return HeapMemorySegmentImpl.OfChar.fromArray(charArray);\n+        return SegmentFactories.fromArray(charArray);\n@@ -1182,1 +1229,1 @@\n-        return HeapMemorySegmentImpl.OfShort.fromArray(shortArray);\n+        return SegmentFactories.fromArray(shortArray);\n@@ -1194,1 +1241,1 @@\n-        return HeapMemorySegmentImpl.OfInt.fromArray(intArray);\n+        return SegmentFactories.fromArray(intArray);\n@@ -1206,1 +1253,1 @@\n-        return HeapMemorySegmentImpl.OfFloat.fromArray(floatArray);\n+        return SegmentFactories.fromArray(floatArray);\n@@ -1218,1 +1265,1 @@\n-        return HeapMemorySegmentImpl.OfLong.fromArray(longArray);\n+        return SegmentFactories.fromArray(longArray);\n@@ -1230,1 +1277,1 @@\n-        return HeapMemorySegmentImpl.OfDouble.fromArray(doubleArray);\n+        return SegmentFactories.fromArray(doubleArray);\n@@ -1234,1 +1281,1 @@\n-     * A zero-length native segment modelling the {@code NULL} address.\n+     * A zero-length native segment modelling the {@code NULL} address. Equivalent to {@code MemorySegment.ofAddress(0L)}.\n@@ -1236,1 +1283,1 @@\n-    MemorySegment NULL = new NativeMemorySegmentImpl();\n+    MemorySegment NULL = MemorySegment.ofAddress(0L);\n@@ -1250,1 +1297,1 @@\n-        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(address, 0);\n+        return SegmentFactories.makeNativeSegmentUnchecked(address, 0);\n@@ -1284,2 +1331,3 @@\n-     * @throws IndexOutOfBoundsException if {@code srcOffset > srcSegment.byteSize() - bytes} or if\n-     * {@code dstOffset > dstSegment.byteSize() - bytes}, or if either {@code srcOffset}, {@code dstOffset}\n+     * @throws IndexOutOfBoundsException if {@code srcOffset > srcSegment.byteSize() - bytes}.\n+     * @throws IndexOutOfBoundsException if {@code dstOffset > dstSegment.byteSize() - bytes}.\n+     * @throws IndexOutOfBoundsException if either {@code srcOffset}, {@code dstOffset}\n@@ -1323,1 +1371,3 @@\n-     * (resp. destination) element layout, or if the source (resp. destination) element layout alignment is greater than its size.\n+     * (resp. destination) element layout.\n+     * @throws IllegalArgumentException if {@code srcElementLayout.byteAlignment() > srcElementLayout.byteSize()}.\n+     * @throws IllegalArgumentException if {@code dstElementLayout.byteAlignment() > dstElementLayout.byteSize()}.\n@@ -1327,1 +1377,1 @@\n-     * such that {@code srcSegment().isAccessibleBy(T) == false}.\n+     * such that {@code srcSegment.isAccessibleBy(T) == false}.\n@@ -1331,1 +1381,1 @@\n-     * such that {@code dstSegment().isAccessibleBy(T) == false}.\n+     * such that {@code dstSegment.isAccessibleBy(T) == false}.\n@@ -1333,1 +1383,3 @@\n-     * @throws IndexOutOfBoundsException if {@code elementCount * srcLayout.byteSize()} or {@code elementCount * dtsLayout.byteSize()} overflows.\n+     * @throws IndexOutOfBoundsException if {@code elementCount * srcLayout.byteSize()} overflows.\n+     * @throws IndexOutOfBoundsException if {@code elementCount * dtsLayout.byteSize()} overflows.\n+     * @throws IndexOutOfBoundsException if {@code srcOffset > srcSegment.byteSize() - (elementCount * srcLayout.byteSize())}.\n@@ -1364,1 +1416,1 @@\n-        return (byte) ((ValueLayouts.OfByteImpl) layout).accessHandle().get(this, offset);\n+        return (byte) layout.varHandle().get(this, offset);\n@@ -1384,1 +1436,1 @@\n-        ((ValueLayouts.OfByteImpl) layout).accessHandle().set(this, offset, value);\n+        layout.varHandle().set(this, offset, value);\n@@ -1403,1 +1455,1 @@\n-        return (boolean) ((ValueLayouts.OfBooleanImpl) layout).accessHandle().get(this, offset);\n+        return (boolean) layout.varHandle().get(this, offset);\n@@ -1423,1 +1475,1 @@\n-        ((ValueLayouts.OfBooleanImpl) layout).accessHandle().set(this, offset, value);\n+        layout.varHandle().set(this, offset, value);\n@@ -1442,1 +1494,1 @@\n-        return (char) ((ValueLayouts.OfCharImpl) layout).accessHandle().get(this, offset);\n+        return (char) layout.varHandle().get(this, offset);\n@@ -1462,1 +1514,1 @@\n-        ((ValueLayouts.OfCharImpl) layout).accessHandle().set(this, offset, value);\n+        layout.varHandle().set(this, offset, value);\n@@ -1481,1 +1533,1 @@\n-        return (short) ((ValueLayouts.OfShortImpl) layout).accessHandle().get(this, offset);\n+        return (short) layout.varHandle().get(this, offset);\n@@ -1501,1 +1553,1 @@\n-        ((ValueLayouts.OfShortImpl) layout).accessHandle().set(this, offset, value);\n+        layout.varHandle().set(this, offset, value);\n@@ -1520,1 +1572,1 @@\n-        return (int) ((ValueLayouts.OfIntImpl) layout).accessHandle().get(this, offset);\n+        return (int) layout.varHandle().get(this, offset);\n@@ -1540,1 +1592,1 @@\n-        ((ValueLayouts.OfIntImpl) layout).accessHandle().set(this, offset, value);\n+        layout.varHandle().set(this, offset, value);\n@@ -1559,1 +1611,1 @@\n-        return (float)((ValueLayouts.OfFloatImpl) layout).accessHandle().get(this, offset);\n+        return (float)layout.varHandle().get(this, offset);\n@@ -1579,1 +1631,1 @@\n-        ((ValueLayouts.OfFloatImpl) layout).accessHandle().set(this, offset, value);\n+        layout.varHandle().set(this, offset, value);\n@@ -1598,1 +1650,1 @@\n-        return (long) ((ValueLayouts.OfLongImpl) layout).accessHandle().get(this, offset);\n+        return (long) layout.varHandle().get(this, offset);\n@@ -1618,1 +1670,1 @@\n-        ((ValueLayouts.OfLongImpl) layout).accessHandle().set(this, offset, value);\n+        layout.varHandle().set(this, offset, value);\n@@ -1637,1 +1689,1 @@\n-        return (double) ((ValueLayouts.OfDoubleImpl) layout).accessHandle().get(this, offset);\n+        return (double) layout.varHandle().get(this, offset);\n@@ -1657,1 +1709,1 @@\n-        ((ValueLayouts.OfDoubleImpl) layout).accessHandle().set(this, offset, value);\n+        layout.varHandle().set(this, offset, value);\n@@ -1682,1 +1734,1 @@\n-        return (MemorySegment) ((ValueLayouts.OfAddressImpl) layout).accessHandle().get(this, offset);\n+        return (MemorySegment) layout.varHandle().get(this, offset);\n@@ -1703,1 +1755,1 @@\n-        ((ValueLayouts.OfAddressImpl) layout).accessHandle().set(this, offset, value);\n+        layout.varHandle().set(this, offset, value);\n@@ -1718,2 +1770,2 @@\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IllegalArgumentException if {@code layout.byteAlignment() > layout.byteSize()}.\n@@ -1727,1 +1779,1 @@\n-        return (byte) ((ValueLayouts.OfByteImpl) layout).accessHandle().get(this, index * layout.byteSize());\n+        return (byte) layout.varHandle().get(this, index * layout.byteSize());\n@@ -1742,2 +1794,2 @@\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IllegalArgumentException if {@code layout.byteAlignment() > layout.byteSize()}.\n@@ -1751,1 +1803,1 @@\n-        return (boolean) ((ValueLayouts.OfBooleanImpl) layout).accessHandle().get(this, index * layout.byteSize());\n+        return (boolean) layout.varHandle().get(this, index * layout.byteSize());\n@@ -1766,2 +1818,2 @@\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IllegalArgumentException if {@code layout.byteAlignment() > layout.byteSize()}.\n@@ -1775,1 +1827,1 @@\n-        return (char) ((ValueLayouts.OfCharImpl) layout).accessHandle().get(this, index * layout.byteSize());\n+        return (char) layout.varHandle().get(this, index * layout.byteSize());\n@@ -1790,2 +1842,2 @@\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IllegalArgumentException if {@code layout.byteAlignment() > layout.byteSize()}.\n@@ -1800,1 +1852,1 @@\n-        ((ValueLayouts.OfCharImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n+        layout.varHandle().set(this, index * layout.byteSize(), value);\n@@ -1815,2 +1867,2 @@\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IllegalArgumentException if {@code layout.byteAlignment() > layout.byteSize()}.\n@@ -1824,1 +1876,1 @@\n-        return (short) ((ValueLayouts.OfShortImpl) layout).accessHandle().get(this, index * layout.byteSize());\n+        return (short) layout.varHandle().get(this, index * layout.byteSize());\n@@ -1839,2 +1891,2 @@\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IllegalArgumentException if {@code layout.byteAlignment() > layout.byteSize()}.\n@@ -1849,1 +1901,1 @@\n-        ((ValueLayouts.OfByteImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n+        layout.varHandle().set(this, index * layout.byteSize(), value);\n@@ -1865,2 +1917,2 @@\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IllegalArgumentException if {@code layout.byteAlignment() > layout.byteSize()}.\n@@ -1875,1 +1927,1 @@\n-        ((ValueLayouts.OfBooleanImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n+        layout.varHandle().set(this, index * layout.byteSize(), value);\n@@ -1890,2 +1942,2 @@\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IllegalArgumentException if {@code layout.byteAlignment() > layout.byteSize()}.\n@@ -1900,1 +1952,1 @@\n-        ((ValueLayouts.OfShortImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n+        layout.varHandle().set(this, index * layout.byteSize(), value);\n@@ -1915,2 +1967,2 @@\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IllegalArgumentException if {@code layout.byteAlignment() > layout.byteSize()}.\n@@ -1924,1 +1976,1 @@\n-        return (int) ((ValueLayouts.OfIntImpl) layout).accessHandle().get(this, index * layout.byteSize());\n+        return (int) layout.varHandle().get(this, index * layout.byteSize());\n@@ -1939,2 +1991,2 @@\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IllegalArgumentException if {@code layout.byteAlignment() > layout.byteSize()}.\n@@ -1949,1 +2001,1 @@\n-        ((ValueLayouts.OfIntImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n+        layout.varHandle().set(this, index * layout.byteSize(), value);\n@@ -1964,2 +2016,2 @@\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IllegalArgumentException if {@code layout.byteAlignment() > layout.byteSize()}.\n@@ -1973,1 +2025,1 @@\n-        return (float) ((ValueLayouts.OfFloatImpl) layout).accessHandle().get(this, index * layout.byteSize());\n+        return (float) layout.varHandle().get(this, index * layout.byteSize());\n@@ -1988,2 +2040,2 @@\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IllegalArgumentException if {@code layout.byteAlignment() > layout.byteSize()}.\n@@ -1998,1 +2050,1 @@\n-        ((ValueLayouts.OfFloatImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n+        layout.varHandle().set(this, index * layout.byteSize(), value);\n@@ -2013,2 +2065,2 @@\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IllegalArgumentException if {@code layout.byteAlignment() > layout.byteSize()}.\n@@ -2022,1 +2074,1 @@\n-        return (long) ((ValueLayouts.OfLongImpl) layout).accessHandle().get(this, index * layout.byteSize());\n+        return (long) layout.varHandle().get(this, index * layout.byteSize());\n@@ -2037,2 +2089,2 @@\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IllegalArgumentException if {@code layout.byteAlignment() > layout.byteSize()}.\n@@ -2047,1 +2099,1 @@\n-        ((ValueLayouts.OfLongImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n+        layout.varHandle().set(this, index * layout.byteSize(), value);\n@@ -2062,2 +2114,2 @@\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IllegalArgumentException if {@code layout.byteAlignment() > layout.byteSize()}.\n@@ -2071,1 +2123,1 @@\n-        return (double) ((ValueLayouts.OfDoubleImpl) layout).accessHandle().get(this, index * layout.byteSize());\n+        return (double) layout.varHandle().get(this, index * layout.byteSize());\n@@ -2086,2 +2138,2 @@\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IllegalArgumentException if {@code layout.byteAlignment() > layout.byteSize()}.\n@@ -2096,1 +2148,1 @@\n-        ((ValueLayouts.OfDoubleImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n+        layout.varHandle().set(this, index * layout.byteSize(), value);\n@@ -2114,2 +2166,2 @@\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IllegalArgumentException if {@code layout.byteAlignment() > layout.byteSize()}.\n@@ -2126,1 +2178,1 @@\n-        return (MemorySegment) ((ValueLayouts.OfAddressImpl) layout).accessHandle().get(this, index * layout.byteSize());\n+        return (MemorySegment) layout.varHandle().get(this, index * layout.byteSize());\n@@ -2141,2 +2193,2 @@\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IllegalArgumentException if {@code layout.byteAlignment() > layout.byteSize()}.\n@@ -2152,1 +2204,1 @@\n-        ((ValueLayouts.OfAddressImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n+        layout.varHandle().set(this, index * layout.byteSize(), value);\n@@ -2201,1 +2253,1 @@\n-     * such that {@code srcSegment().isAccessibleBy(T) == false}.\n+     * such that {@code srcSegment.isAccessibleBy(T) == false}.\n@@ -2240,1 +2292,1 @@\n-     * such that {@code dstSegment().isAccessibleBy(T) == false}.\n+     * such that {@code dstSegment.isAccessibleBy(T) == false}.\n@@ -2315,1 +2367,0 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":223,"deletions":172,"binary":false,"changes":395,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.internal.javac.PreviewFeature;\n@@ -38,1 +37,1 @@\n- * @since 20\n+ * @since 22\n@@ -40,1 +39,0 @@\n-@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/PaddingLayout.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,3 +28,1 @@\n-import java.lang.invoke.VarHandle;\n-import java.lang.reflect.Array;\n-import java.nio.ByteOrder;\n+import java.nio.charset.Charset;\n@@ -33,1 +31,1 @@\n-import java.util.function.Function;\n+\n@@ -35,0 +33,1 @@\n+import jdk.internal.foreign.ArenaImpl;\n@@ -36,2 +35,2 @@\n-import jdk.internal.foreign.Utils;\n-import jdk.internal.javac.PreviewFeature;\n+import jdk.internal.foreign.StringSupport;\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -73,1 +72,1 @@\n- * @since 19\n+ * @since 22\n@@ -76,1 +75,0 @@\n-@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n@@ -80,1 +78,20 @@\n-     * {@return a new memory segment with a Java string converted into a UTF-8 encoded, null-terminated C string}\n+     * Converts a Java string into a null-terminated C string using the {@linkplain StandardCharsets#UTF_8 UTF-8} charset,\n+     * storing the result into a memory segment.\n+     * <p>\n+     * Calling this method is equivalent to the following code:\n+     * {@snippet lang = java:\n+     * allocateFrom(str, StandardCharsets.UTF_8);\n+     *}\n+     *\n+     * @param str the Java string to be converted into a C string.\n+     * @return a new native segment containing the converted C string.\n+     *\/\n+    @ForceInline\n+    default MemorySegment allocateFrom(String str) {\n+        Objects.requireNonNull(str);\n+        return allocateFrom(str, sun.nio.cs.UTF_8.INSTANCE);\n+    }\n+\n+    \/**\n+     * Converts a Java string into a null-terminated C string using the provided charset,\n+     * and storing the result into a memory segment.\n@@ -89,1 +106,1 @@\n-     * the string, such as {@link MemorySegment#getUtf8String(long)}, the string\n+     * the string, such as {@link MemorySegment#getString(long)}, the string\n@@ -92,0 +109,4 @@\n+     * @param str     the Java string to be converted into a C string.\n+     * @param charset the charset used to {@linkplain Charset#newEncoder() encode} the string bytes.\n+     * @return a new native segment containing the converted C string.\n+     * @throws IllegalArgumentException if {@code charset} is not a {@linkplain StandardCharsets standard charset}.\n@@ -93,2 +114,7 @@\n-     * into a new memory segment obtained by calling {@code this.allocate(str.length() + 1)}.\n-     * @param str the Java string to be converted into a C string.\n+     * into a new memory segment obtained by calling {@code this.allocate(B + N)}, where:\n+     * <ul>\n+     *     <li>{@code B} is the size, in bytes, of the string encoded using the provided charset\n+     *     (e.g. {@code str.getBytes(charset).length});<\/li>\n+     *     <li>{@code N} is the size (in bytes) of the terminator char according to the provided charset. For instance,\n+     *     this is 1 for {@link StandardCharsets#US_ASCII} and 2 for {@link StandardCharsets#UTF_16}.<\/li>\n+     * <\/ul>\n@@ -96,1 +122,3 @@\n-    default MemorySegment allocateUtf8String(String str) {\n+    @ForceInline\n+    default MemorySegment allocateFrom(String str, Charset charset) {\n+        Objects.requireNonNull(charset);\n@@ -98,1 +126,17 @@\n-        return Utils.toCString(str.getBytes(StandardCharsets.UTF_8), this);\n+        int termCharSize = StringSupport.CharsetKind.of(charset).terminatorCharSize();\n+        MemorySegment segment;\n+        int length;\n+        if (StringSupport.bytesCompatible(str, charset)) {\n+            length = str.length();\n+            segment = allocateNoInit((long) length + termCharSize);\n+            StringSupport.copyToSegmentRaw(str, segment, 0);\n+        } else {\n+            byte[] bytes = str.getBytes(charset);\n+            length = bytes.length;\n+            segment = allocateNoInit((long) bytes.length + termCharSize);\n+            MemorySegment.copy(bytes, 0, segment, ValueLayout.JAVA_BYTE, 0, bytes.length);\n+        }\n+        for (int i = 0 ; i < termCharSize ; i++) {\n+            segment.set(ValueLayout.JAVA_BYTE, length + i, (byte)0);\n+        }\n+        return segment;\n@@ -102,2 +146,5 @@\n-     * {@return a new memory segment initialized with the provided {@code byte} {@code value} as\n-     * specified by the provided {@code layout} (i.e. byte ordering, alignment and size)}\n+     * {@return a new memory segment initialized with the provided byte value.}\n+     * <p>\n+     * The size of the allocated memory segment is the {@linkplain MemoryLayout#byteSize() size} of the given layout.\n+     * The given value is written into the segment according to the byte order and alignment constraint of the\n+     * given layout.\n@@ -115,1 +162,1 @@\n-    default MemorySegment allocate(ValueLayout.OfByte layout, byte value) {\n+    default MemorySegment allocateFrom(ValueLayout.OfByte layout, byte value) {\n@@ -117,3 +164,2 @@\n-        VarHandle handle = layout.varHandle();\n-        MemorySegment seg = allocate(layout);\n-        handle.set(seg, value);\n+        MemorySegment seg = allocateNoInit(layout);\n+        seg.set(layout, 0, value);\n@@ -124,2 +170,5 @@\n-     * {@return a new memory segment initialized with the provided {@code char} {@code value} as\n-     * specified by the provided {@code layout} (i.e. byte ordering, alignment and size)}\n+     * {@return a new memory segment initialized with the provided char value.}\n+     * <p>\n+     * The size of the allocated memory segment is the {@linkplain MemoryLayout#byteSize() size} of the given layout.\n+     * The given value is written into the segment according to the byte order and alignment constraint of the\n+     * given layout.\n@@ -137,1 +186,1 @@\n-    default MemorySegment allocate(ValueLayout.OfChar layout, char value) {\n+    default MemorySegment allocateFrom(ValueLayout.OfChar layout, char value) {\n@@ -139,3 +188,2 @@\n-        VarHandle handle = layout.varHandle();\n-        MemorySegment seg = allocate(layout);\n-        handle.set(seg, value);\n+        MemorySegment seg = allocateNoInit(layout);\n+        seg.set(layout, 0, value);\n@@ -146,2 +194,5 @@\n-     * {@return a new memory segment initialized with the provided {@code short} {@code value} as\n-     * specified by the provided {@code layout} (i.e. byte ordering, alignment and size)}\n+     * {@return a new memory segment initialized with the provided short value.}\n+     * <p>\n+     * The size of the allocated memory segment is the {@linkplain MemoryLayout#byteSize() size} of the given layout.\n+     * The given value is written into the segment according to the byte order and alignment constraint of the\n+     * given layout.\n@@ -159,1 +210,1 @@\n-    default MemorySegment allocate(ValueLayout.OfShort layout, short value) {\n+    default MemorySegment allocateFrom(ValueLayout.OfShort layout, short value) {\n@@ -161,3 +212,2 @@\n-        VarHandle handle = layout.varHandle();\n-        MemorySegment seg = allocate(layout);\n-        handle.set(seg, value);\n+        MemorySegment seg = allocateNoInit(layout);\n+        seg.set(layout, 0, value);\n@@ -168,2 +218,5 @@\n-     * {@return a new memory segment initialized with the provided {@code int} {@code value} as\n-     * specified by the provided {@code layout} (i.e. byte ordering, alignment and size)}\n+     * {@return a new memory segment initialized with the provided int value.}\n+     * <p>\n+     * The size of the allocated memory segment is the {@linkplain MemoryLayout#byteSize() size} of the given layout.\n+     * The given value is written into the segment according to the byte order and alignment constraint of the\n+     * given layout.\n@@ -181,1 +234,1 @@\n-    default MemorySegment allocate(ValueLayout.OfInt layout, int value) {\n+    default MemorySegment allocateFrom(ValueLayout.OfInt layout, int value) {\n@@ -183,3 +236,2 @@\n-        VarHandle handle = layout.varHandle();\n-        MemorySegment seg = allocate(layout);\n-        handle.set(seg, value);\n+        MemorySegment seg = allocateNoInit(layout);\n+        seg.set(layout, 0, value);\n@@ -190,2 +242,5 @@\n-     * {@return a new memory segment initialized with the provided {@code float} {@code value} as\n-     * specified by the provided {@code layout} (i.e. byte ordering, alignment and size)}\n+     * {@return a new memory segment initialized with the provided float value.}\n+     * <p>\n+     * The size of the allocated memory segment is the {@linkplain MemoryLayout#byteSize() size} of the given layout.\n+     * The given value is written into the segment according to the byte order and alignment constraint of the\n+     * given layout.\n@@ -203,1 +258,1 @@\n-    default MemorySegment allocate(ValueLayout.OfFloat layout, float value) {\n+    default MemorySegment allocateFrom(ValueLayout.OfFloat layout, float value) {\n@@ -205,3 +260,2 @@\n-        VarHandle handle = layout.varHandle();\n-        MemorySegment seg = allocate(layout);\n-        handle.set(seg, value);\n+        MemorySegment seg = allocateNoInit(layout);\n+        seg.set(layout, 0, value);\n@@ -212,2 +266,5 @@\n-     * {@return a new memory segment initialized with the provided {@code long} {@code value} as\n-     * specified by the provided {@code layout} (i.e. byte ordering, alignment and size)}\n+     * {@return a new memory segment initialized with the provided long value.}\n+     * <p>\n+     * The size of the allocated memory segment is the {@linkplain MemoryLayout#byteSize() size} of the given layout.\n+     * The given value is written into the segment according to the byte order and alignment constraint of the\n+     * given layout.\n@@ -225,1 +282,1 @@\n-    default MemorySegment allocate(ValueLayout.OfLong layout, long value) {\n+    default MemorySegment allocateFrom(ValueLayout.OfLong layout, long value) {\n@@ -227,3 +284,2 @@\n-        VarHandle handle = layout.varHandle();\n-        MemorySegment seg = allocate(layout);\n-        handle.set(seg, value);\n+        MemorySegment seg = allocateNoInit(layout);\n+        seg.set(layout, 0, value);\n@@ -234,2 +290,5 @@\n-     * {@return a new memory segment initialized with the provided {@code double} {@code value} as\n-     * specified by the provided {@code layout} (i.e. byte ordering, alignment and size)}\n+     * {@return a new memory segment initialized with the provided double value.}\n+     * <p>\n+     * The size of the allocated memory segment is the {@linkplain MemoryLayout#byteSize() size} of the given layout.\n+     * The given value is written into the segment according to the byte order and alignment constraint of the\n+     * given layout.\n@@ -247,1 +306,1 @@\n-    default MemorySegment allocate(ValueLayout.OfDouble layout, double value) {\n+    default MemorySegment allocateFrom(ValueLayout.OfDouble layout, double value) {\n@@ -249,3 +308,2 @@\n-        VarHandle handle = layout.varHandle();\n-        MemorySegment seg = allocate(layout);\n-        handle.set(seg, value);\n+        MemorySegment seg = allocateNoInit(layout);\n+        seg.set(layout, 0, value);\n@@ -256,2 +314,1 @@\n-     * {@return a new memory segment initialized with the address of the provided {@code value} as\n-     * specified by the provided {@code layout} (i.e. byte ordering, alignment and size)}\n+     * {@return a new memory segment initialized with the {@linkplain MemorySegment#address() address} of the provided memory segment.}\n@@ -260,0 +317,4 @@\n+     * <p>\n+     * The size of the allocated memory segment is the {@linkplain MemoryLayout#byteSize() size} of the given layout.\n+     * The given value is written into the segment according to the byte order and alignment constraint of the\n+     * given layout.\n@@ -271,0 +332,1 @@\n+     * @throws UnsupportedOperationException if {@code value} is not a {@linkplain MemorySegment#isNative() native} segment.\n@@ -272,1 +334,1 @@\n-    default MemorySegment allocate(AddressLayout layout, MemorySegment value) {\n+    default MemorySegment allocateFrom(AddressLayout layout, MemorySegment value) {\n@@ -275,3 +337,3 @@\n-        MemorySegment seg = allocate(layout);\n-        layout.varHandle().set(seg, value);\n-        return seg;\n+        MemorySegment segment = allocateNoInit(layout);\n+        segment.set(layout, 0, value);\n+        return segment;\n@@ -281,10 +343,11 @@\n-     * {@return a new memory segment with a {@linkplain MemorySegment#byteSize() byteSize()} of\n-     * {@code E*layout.byteSize()} initialized with the provided {@code E} {@code byte} {@code elements} as\n-     * specified by the provided {@code layout} (i.e. byte ordering, alignment and size)}\n-     *\n-     * @implSpec The default implementation is equivalent to:\n-     * {@snippet lang=java :\n-     *  int size = Objects.requireNonNull(elements).length;\n-     *  MemorySegment seg = allocateArray(Objects.requireNonNull(elementLayout), size);\n-     *  MemorySegment.copy(elements, 0, seg, elementLayout, 0, size);\n-     *  return seg;\n+     * {@return a new memory segment initialized with the contents of the provided segment.}\n+     * <p>\n+     * The size of the allocated memory segment is the {@code elementLayout.byteSize() * elementCount}.\n+     * The contents of the source segment is copied into the result segment element by element, according to the byte\n+     * order and alignment constraint of the given element layout.\n+     *\n+     * @implSpec the default implementation for this method is equivalent to the following code:\n+     * {@snippet lang = java:\n+     * MemorySegment dest = this.allocate(elementLayout, elementCount);\n+     * MemorySegment.copy(source, sourceElementLayout, sourceOffset, dest, elementLayout, 0, elementCount);\n+     * return dest;\n@@ -292,3 +355,17 @@\n-     *\n-     * @param elementLayout the element layout of the array to be allocated.\n-     * @param elements      the short elements to be copied to the newly allocated memory block.\n+     * @param elementLayout the element layout of the allocated array.\n+     * @param source the source segment.\n+     * @param sourceElementLayout the element layout of the source segment.\n+     * @param sourceOffset the starting offset, in bytes, of the source segment.\n+     * @param elementCount the number of elements in the source segment to be copied.\n+     * @throws IllegalArgumentException if {@code elementLayout.byteSize() != sourceElementLayout.byteSize()}.\n+     * @throws IllegalArgumentException if the source segment\/offset are <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a>\n+     * in the source element layout.\n+     * @throws IllegalArgumentException if {@code elementLayout.byteAlignment() > elementLayout.byteSize()}.\n+     * @throws IllegalArgumentException if {@code sourceElementLayout.byteAlignment() > sourceElementLayout.byteSize()}.\n+     * @throws IllegalStateException if the {@linkplain MemorySegment#scope() scope} associated with {@code source} is not\n+     * {@linkplain MemorySegment.Scope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code source.isAccessibleBy(T) == false}.\n+     * @throws IndexOutOfBoundsException if {@code elementCount * sourceElementLayout.byteSize()} overflows.\n+     * @throws IndexOutOfBoundsException if {@code sourceOffset > source.byteSize() - (elementCount * sourceElementLayout.byteSize())}.\n+     * @throws IndexOutOfBoundsException if either {@code sourceOffset} or {@code elementCount} are {@code < 0}.\n@@ -296,2 +373,9 @@\n-    default MemorySegment allocateArray(ValueLayout.OfByte elementLayout, byte... elements) {\n-        return copyArrayWithSwapIfNeeded(elements, elementLayout, MemorySegment::ofArray);\n+    @ForceInline\n+    default MemorySegment allocateFrom(ValueLayout elementLayout, MemorySegment source,\n+                                       ValueLayout sourceElementLayout, long sourceOffset, long elementCount) {\n+        Objects.requireNonNull(source);\n+        Objects.requireNonNull(sourceElementLayout);\n+        Objects.requireNonNull(elementLayout);\n+        MemorySegment dest = allocateNoInit(elementLayout, elementCount);\n+        MemorySegment.copy(source, sourceElementLayout, sourceOffset, dest, elementLayout, 0, elementCount);\n+        return dest;\n@@ -301,12 +385,11 @@\n-     * {@return a new memory segment with a {@linkplain MemorySegment#byteSize() byteSize()} of\n-     * {@code E*layout.byteSize()} initialized with the provided {@code E} {@code short} {@code elements} as\n-     * specified by the provided {@code layout} (i.e. byte ordering, alignment and size)}\n-     *\n-     * @implSpec The default implementation is equivalent to:\n-     * {@snippet lang=java :\n-     *  int size = Objects.requireNonNull(elements).length;\n-     *  MemorySegment seg = allocateArray(Objects.requireNonNull(elementLayout), size);\n-     *  MemorySegment.copy(elements, 0, seg, elementLayout, 0, size);\n-     *  return seg;\n-     * }\n-     *\n+     * {@return a new memory segment initialized with the elements in the provided byte array.}\n+     * <p>\n+     * The size of the allocated memory segment is {@code elementLayout.byteSize() * elements.length}.\n+     * The contents of the source array is copied into the result segment element by element, according to the byte\n+     * order and alignment constraint of the given element layout.\n+     *\n+     * @implSpec the default implementation for this method is equivalent to the following code:\n+     * {@snippet lang = java:\n+     * this.allocateFrom(layout, MemorySegment.ofArray(array),\n+     *                   ValueLayout.JAVA_BYTE, 0, array.length)\n+     *}\n@@ -314,1 +397,2 @@\n-     * @param elements      the short elements to be copied to the newly allocated memory block.\n+     * @param elements      the byte elements to be copied to the newly allocated memory block.\n+     * @throws IllegalArgumentException if {@code elementLayout.byteAlignment() > elementLayout.byteSize()}.\n@@ -316,2 +400,4 @@\n-    default MemorySegment allocateArray(ValueLayout.OfShort elementLayout, short... elements) {\n-        return copyArrayWithSwapIfNeeded(elements, elementLayout, MemorySegment::ofArray);\n+    @ForceInline\n+    default MemorySegment allocateFrom(ValueLayout.OfByte elementLayout, byte... elements) {\n+        return allocateFrom(elementLayout, MemorySegment.ofArray(elements),\n+                ValueLayout.JAVA_BYTE, 0, elements.length);\n@@ -321,12 +407,11 @@\n-     * {@return a new memory segment with a {@linkplain MemorySegment#byteSize() byteSize()} of\n-     * {@code E*layout.byteSize()} initialized with the provided {@code E} {@code char} {@code elements} as\n-     * specified by the provided {@code layout} (i.e. byte ordering, alignment and size)}\n-     *\n-     * @implSpec The default implementation is equivalent to:\n-     * {@snippet lang=java :\n-     *  int size = Objects.requireNonNull(elements).length;\n-     *  MemorySegment seg = allocateArray(Objects.requireNonNull(elementLayout), size);\n-     *  MemorySegment.copy(elements, 0, seg, elementLayout, 0, size);\n-     *  return seg;\n-     * }\n-     *\n+     * {@return a new memory segment initialized with the elements in the provided short array.}\n+     * <p>\n+     * The size of the allocated memory segment is {@code elementLayout.byteSize() * elements.length}.\n+     * The contents of the source array is copied into the result segment element by element, according to the byte\n+     * order and alignment constraint of the given element layout.\n+     *\n+     * @implSpec the default implementation for this method is equivalent to the following code:\n+     * {@snippet lang = java:\n+     * this.allocateFrom(layout, MemorySegment.ofArray(array),\n+     *                   ValueLayout.JAVA_SHORT, 0, array.length)\n+     *}\n@@ -335,0 +420,1 @@\n+     * @throws IllegalArgumentException if {@code elementLayout.byteAlignment() > elementLayout.byteSize()}.\n@@ -336,2 +422,4 @@\n-    default MemorySegment allocateArray(ValueLayout.OfChar elementLayout, char... elements) {\n-        return copyArrayWithSwapIfNeeded(elements, elementLayout, MemorySegment::ofArray);\n+    @ForceInline\n+    default MemorySegment allocateFrom(ValueLayout.OfShort elementLayout, short... elements) {\n+        return allocateFrom(elementLayout, MemorySegment.ofArray(elements),\n+                ValueLayout.JAVA_SHORT, 0, elements.length);\n@@ -341,12 +429,11 @@\n-     * {@return a new memory segment with a {@linkplain MemorySegment#byteSize() byteSize()} of\n-     * {@code E*layout.byteSize()} initialized with the provided {@code E} {@code int} {@code elements} as\n-     * specified by the provided {@code layout} (i.e. byte ordering, alignment and size)}\n-     *\n-     * @implSpec The default implementation is equivalent to:\n-     * {@snippet lang=java :\n-     *  int size = Objects.requireNonNull(elements).length;\n-     *  MemorySegment seg = allocateArray(Objects.requireNonNull(elementLayout), size);\n-     *  MemorySegment.copy(elements, 0, seg, elementLayout, 0, size);\n-     *  return seg;\n-     * }\n-     *\n+     * {@return a new memory segment initialized with the elements in the provided char array.}\n+     * <p>\n+     * The size of the allocated memory segment is {@code elementLayout.byteSize() * elements.length}.\n+     * The contents of the source array is copied into the result segment element by element, according to the byte\n+     * order and alignment constraint of the given element layout.\n+     *\n+     * @implSpec the default implementation for this method is equivalent to the following code:\n+     * {@snippet lang = java:\n+     * this.allocateFrom(layout, MemorySegment.ofArray(array),\n+     *                   ValueLayout.JAVA_CHAR, 0, array.length)\n+     *}\n@@ -354,1 +441,2 @@\n-     * @param elements      the short elements to be copied to the newly allocated memory block.\n+     * @param elements      the char elements to be copied to the newly allocated memory block.\n+     * @throws IllegalArgumentException if {@code elementLayout.byteAlignment() > elementLayout.byteSize()}.\n@@ -356,2 +444,4 @@\n-    default MemorySegment allocateArray(ValueLayout.OfInt elementLayout, int... elements) {\n-        return copyArrayWithSwapIfNeeded(elements, elementLayout, MemorySegment::ofArray);\n+    @ForceInline\n+    default MemorySegment allocateFrom(ValueLayout.OfChar elementLayout, char... elements) {\n+        return allocateFrom(elementLayout, MemorySegment.ofArray(elements),\n+                ValueLayout.JAVA_CHAR, 0, elements.length);\n@@ -361,12 +451,11 @@\n-     * {@return a new memory segment with a {@linkplain MemorySegment#byteSize() byteSize()} of\n-     * {@code E*layout.byteSize()} initialized with the provided {@code E} {@code float} {@code elements} as\n-     * specified by the provided {@code layout} (i.e. byte ordering, alignment and size)}\n-     *\n-     * @implSpec The default implementation is equivalent to:\n-     * {@snippet lang=java :\n-     *  int size = Objects.requireNonNull(elements).length;\n-     *  MemorySegment seg = allocateArray(Objects.requireNonNull(elementLayout), size);\n-     *  MemorySegment.copy(elements, 0, seg, elementLayout, 0, size);\n-     *  return seg;\n-     * }\n-     *\n+     * {@return a new memory segment initialized with the elements in the provided int array.}\n+     * <p>\n+     * The size of the allocated memory segment is {@code elementLayout.byteSize() * elements.length}.\n+     * The contents of the source array is copied into the result segment element by element, according to the byte\n+     * order and alignment constraint of the given element layout.\n+     *\n+     * @implSpec the default implementation for this method is equivalent to the following code:\n+     * {@snippet lang = java:\n+     * this.allocateFrom(layout, MemorySegment.ofArray(array),\n+     *                   ValueLayout.JAVA_INT, 0, array.length)\n+     *}\n@@ -374,1 +463,2 @@\n-     * @param elements      the short elements to be copied to the newly allocated memory block.\n+     * @param elements      the int elements to be copied to the newly allocated memory block.\n+     * @throws IllegalArgumentException if {@code elementLayout.byteAlignment() > elementLayout.byteSize()}.\n@@ -376,2 +466,4 @@\n-    default MemorySegment allocateArray(ValueLayout.OfFloat elementLayout, float... elements) {\n-        return copyArrayWithSwapIfNeeded(elements, elementLayout, MemorySegment::ofArray);\n+    @ForceInline\n+    default MemorySegment allocateFrom(ValueLayout.OfInt elementLayout, int... elements) {\n+        return allocateFrom(elementLayout, MemorySegment.ofArray(elements),\n+                ValueLayout.JAVA_INT, 0, elements.length);\n@@ -381,12 +473,11 @@\n-     * {@return a new memory segment with a {@linkplain MemorySegment#byteSize() byteSize()} of\n-     * {@code E*layout.byteSize()} initialized with the provided {@code E} {@code long} {@code elements} as\n-     * specified by the provided {@code layout} (i.e. byte ordering, alignment and size)}\n-     *\n-     * @implSpec The default implementation is equivalent to:\n-     * {@snippet lang=java :\n-     *  int size = Objects.requireNonNull(elements).length;\n-     *  MemorySegment seg = allocateArray(Objects.requireNonNull(elementLayout), size);\n-     *  MemorySegment.copy(elements, 0, seg, elementLayout, 0, size);\n-     *  return seg;\n-     * }\n-     *\n+     * {@return a new memory segment initialized with the elements in the provided float array.}\n+     * <p>\n+     * The size of the allocated memory segment is {@code elementLayout.byteSize() * elements.length}.\n+     * The contents of the source array is copied into the result segment element by element, according to the byte\n+     * order and alignment constraint of the given element layout.\n+     *\n+     * @implSpec the default implementation for this method is equivalent to the following code:\n+     * {@snippet lang = java:\n+     * this.allocateFrom(layout, MemorySegment.ofArray(array),\n+     *                   ValueLayout.JAVA_FLOAT, 0, array.length)\n+     *}\n@@ -394,1 +485,2 @@\n-     * @param elements      the short elements to be copied to the newly allocated memory block.\n+     * @param elements the float elements to be copied to the newly allocated memory block.\n+     * @throws IllegalArgumentException if {@code elementLayout.byteAlignment() > elementLayout.byteSize()}.\n@@ -396,2 +488,4 @@\n-    default MemorySegment allocateArray(ValueLayout.OfLong elementLayout, long... elements) {\n-        return copyArrayWithSwapIfNeeded(elements, elementLayout, MemorySegment::ofArray);\n+    @ForceInline\n+    default MemorySegment allocateFrom(ValueLayout.OfFloat elementLayout, float... elements) {\n+        return allocateFrom(elementLayout, MemorySegment.ofArray(elements),\n+                ValueLayout.JAVA_FLOAT, 0, elements.length);\n@@ -401,12 +495,11 @@\n-     * {@return a new memory segment with a {@linkplain MemorySegment#byteSize() byteSize()} of\n-     * {@code E*layout.byteSize()} initialized with the provided {@code E} {@code double} {@code elements} as\n-     * specified by the provided {@code layout} (i.e. byte ordering, alignment and size)}\n-     *\n-     * @implSpec The default implementation is equivalent to:\n-     * {@snippet lang=java :\n-     *  int size = Objects.requireNonNull(elements).length;\n-     *  MemorySegment seg = allocateArray(Objects.requireNonNull(elementLayout), size);\n-     *  MemorySegment.copy(elements, 0, seg, elementLayout, 0, size);\n-     *  return seg;\n-     * }\n-     *\n+     * {@return a new memory segment initialized with the elements in the provided long array.}\n+     * <p>\n+     * The size of the allocated memory segment is {@code elementLayout.byteSize() * elements.length}.\n+     * The contents of the source array is copied into the result segment element by element, according to the byte\n+     * order and alignment constraint of the given element layout.\n+     *\n+     * @implSpec the default implementation for this method is equivalent to the following code:\n+     * {@snippet lang = java:\n+     * this.allocateFrom(layout, MemorySegment.ofArray(array),\n+     *                   ValueLayout.JAVA_LONG, 0, array.length)\n+     *}\n@@ -414,1 +507,2 @@\n-     * @param elements      the short elements to be copied to the newly allocated memory block.\n+     * @param elements the long elements to be copied to the newly allocated memory block.\n+     * @throws IllegalArgumentException if {@code elementLayout.byteAlignment() > elementLayout.byteSize()}.\n@@ -416,2 +510,4 @@\n-    default MemorySegment allocateArray(ValueLayout.OfDouble elementLayout, double... elements) {\n-        return copyArrayWithSwapIfNeeded(elements, elementLayout, MemorySegment::ofArray);\n+    @ForceInline\n+    default MemorySegment allocateFrom(ValueLayout.OfLong elementLayout, long... elements) {\n+        return allocateFrom(elementLayout, MemorySegment.ofArray(elements),\n+                ValueLayout.JAVA_LONG, 0, elements.length);\n@@ -420,9 +516,20 @@\n-    private <Z> MemorySegment copyArrayWithSwapIfNeeded(Z array, ValueLayout elementLayout,\n-                                                        Function<Z, MemorySegment> heapSegmentFactory) {\n-        int size = Array.getLength(Objects.requireNonNull(array));\n-        MemorySegment seg = allocateArray(Objects.requireNonNull(elementLayout), size);\n-        if (size > 0) {\n-            MemorySegment.copy(heapSegmentFactory.apply(array), elementLayout, 0,\n-                    seg, elementLayout.withOrder(ByteOrder.nativeOrder()), 0, size);\n-        }\n-        return seg;\n+    \/**\n+     * {@return a new memory segment initialized with the elements in the provided double array.}\n+     * <p>\n+     * The size of the allocated memory segment is {@code elementLayout.byteSize() * elements.length}.\n+     * The contents of the source array is copied into the result segment element by element, according to the byte\n+     * order and alignment constraint of the given element layout.\n+     *\n+     * @implSpec the default implementation for this method is equivalent to the following code:\n+     * {@snippet lang = java:\n+     * this.allocateFrom(layout, MemorySegment.ofArray(array),\n+     *                   ValueLayout.JAVA_DOUBLE, 0, array.length)\n+     *}\n+     * @param elementLayout the element layout of the array to be allocated.\n+     * @param elements      the double elements to be copied to the newly allocated memory block.\n+     * @throws IllegalArgumentException if {@code elementLayout.byteAlignment() > elementLayout.byteSize()}.\n+     *\/\n+    @ForceInline\n+    default MemorySegment allocateFrom(ValueLayout.OfDouble elementLayout, double... elements) {\n+        return allocateFrom(elementLayout, MemorySegment.ofArray(elements),\n+                ValueLayout.JAVA_DOUBLE, 0, elements.length);\n@@ -455,1 +562,1 @@\n-    default MemorySegment allocateArray(MemoryLayout elementLayout, long count) {\n+    default MemorySegment allocate(MemoryLayout elementLayout, long count) {\n@@ -528,0 +635,21 @@\n+\n+    @ForceInline\n+    private MemorySegment allocateNoInit(long byteSize) {\n+        return this instanceof ArenaImpl arenaImpl ?\n+                arenaImpl.allocateNoInit(byteSize, 1) :\n+                allocate(byteSize);\n+    }\n+\n+    @ForceInline\n+    private MemorySegment allocateNoInit(MemoryLayout layout) {\n+        return this instanceof ArenaImpl arenaImpl ?\n+                arenaImpl.allocateNoInit(layout.byteSize(), layout.byteAlignment()) :\n+                allocate(layout);\n+    }\n+\n+    @ForceInline\n+    private MemorySegment allocateNoInit(MemoryLayout layout, long size) {\n+        return this instanceof ArenaImpl arenaImpl ?\n+                arenaImpl.allocateNoInit(layout.byteSize() * size, layout.byteAlignment()) :\n+                allocate(layout, size);\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SegmentAllocator.java","additions":304,"deletions":176,"binary":false,"changes":480,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.internal.javac.PreviewFeature;\n@@ -53,1 +52,1 @@\n- * @since 19\n+ * @since 22\n@@ -55,1 +54,0 @@\n-@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SequenceLayout.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.internal.javac.PreviewFeature;\n@@ -37,1 +36,1 @@\n- * @since 20\n+ * @since 22\n@@ -39,1 +38,0 @@\n-@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/StructLayout.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import jdk.internal.javac.PreviewFeature;\n@@ -123,1 +122,1 @@\n- * @since 19\n+ * @since 22\n@@ -125,1 +124,0 @@\n-@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n@@ -219,2 +217,1 @@\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n+     * the JVM or, worse, silently result in memory corruption.\n@@ -254,2 +251,1 @@\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n+     * the JVM or, worse, silently result in memory corruption.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SymbolLookup.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.internal.javac.PreviewFeature;\n@@ -37,1 +36,1 @@\n- * @since 20\n+ * @since 22\n@@ -39,1 +38,0 @@\n-@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/UnionLayout.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.lang.invoke.MethodHandles;\n@@ -31,1 +30,0 @@\n-\n@@ -33,1 +31,0 @@\n-import jdk.internal.javac.PreviewFeature;\n@@ -54,1 +51,1 @@\n- * @since 19\n+ * @since 22\n@@ -56,1 +53,0 @@\n-@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n@@ -79,60 +75,0 @@\n-    \/**\n-     * Creates a <em>strided<\/em> var handle that can be used to access a memory segment as multi-dimensional\n-     * array. This array has a notional sequence layout featuring {@code shape.length} nested sequence layouts. The element\n-     * layout of the innermost sequence layout in the notional sequence layout is this value layout. The resulting var handle\n-     * is obtained as if calling the {@link #varHandle(PathElement...)} method on the notional layout, with a layout\n-     * path containing exactly {@code shape.length + 1} {@linkplain PathElement#sequenceElement() open sequence layout path elements}.\n-     * <p>\n-     * For instance, the following method call:\n-     *\n-     * {@snippet lang=java :\n-     * VarHandle arrayHandle = ValueLayout.JAVA_INT.arrayElementVarHandle(10, 20);\n-     * }\n-     *\n-     * Is equivalent to the following code:\n-     *\n-     * {@snippet lang = java:\n-     * SequenceLayout notionalLayout = MemoryLayout.sequenceLayout(\n- *                                         MemoryLayout.sequenceLayout(10, MemoryLayout.sequenceLayout(20, ValueLayout.JAVA_INT)));\n-     * VarHandle arrayHandle = notionalLayout.varHandle(PathElement.sequenceElement(),\n-     *                                                  PathElement.sequenceElement(),\n-     *                                                  PathElement.sequenceElement());\n-     *}\n-     *\n-     * The resulting var handle {@code arrayHandle} will feature 3 coordinates of type {@code long}; each coordinate\n-     * is interpreted as an index into the corresponding sequence layout. If we refer to the var handle coordinates, from left\n-     * to right, as {@code x}, {@code y} and {@code z} respectively, the final offset accessed by the var handle can be\n-     * computed with the following formula:\n-     *\n-     * <blockquote><pre>{@code\n-     * offset = (10 * 20 * 4 * x) + (20 * 4 * y) + (4 * z)\n-     * }<\/pre><\/blockquote>\n-     *\n-     * Additionally, the values of {@code x}, {@code y} and {@code z} are constrained as follows:\n-     * <ul>\n-     *     <li>{@code 0 <= x < notionalLayout.elementCount() }<\/li>\n-     *     <li>{@code 0 <= y < 10 }<\/li>\n-     *     <li>{@code 0 <= z < 20 }<\/li>\n-     * <\/ul>\n-     * <p>\n-     * Consider the following access expressions:\n-     * {@snippet lang=java :\n-     * int value1 = (int) arrayHandle.get(10, 2, 4); \/\/ ok, accessed offset = 8176\n-     * int value2 = (int) arrayHandle.get(0, 0, 30); \/\/ out of bounds value for z\n-     * }\n-     * In the first case, access is well-formed, as the values for {@code x}, {@code y} and {@code z} conform to\n-     * the bounds specified above. In the second case, access fails with {@link IndexOutOfBoundsException},\n-     * as the value for {@code z} is outside its specified bounds.\n-     *\n-     * @param shape the size of each nested array dimension.\n-     * @return a var handle which can be used to access a memory segment as a multi-dimensional array,\n-     * featuring {@code shape.length + 1}\n-     * {@code long} coordinates.\n-     * @throws IllegalArgumentException if {@code shape[i] < 0}, for at least one index {@code i}.\n-     * @throws UnsupportedOperationException if {@code byteAlignment() > byteSize()}.\n-     * @see MethodHandles#memorySegmentViewVarHandle\n-     * @see MemoryLayout#varHandle(PathElement...)\n-     * @see SequenceLayout\n-     *\/\n-    VarHandle arrayElementVarHandle(int... shape);\n-\n@@ -152,0 +88,1 @@\n+     *\n@@ -157,0 +94,21 @@\n+    \/**\n+     * {@return a var handle which can be used to access values described by this value layout, in a given memory segment.}\n+     * <p>\n+     * The returned var handle's {@linkplain VarHandle#varType() var type} is the {@linkplain ValueLayout#carrier() carrier type} of\n+     * this value layout, and the list of coordinate types is {@code (MemorySegment, long)}, where the memory segment coordinate\n+     * corresponds to the memory segment to be accessed, and the {@code long} coordinate corresponds to the byte offset\n+     * into the accessed memory segment at which the access occurs.\n+     * <p>\n+     * The returned var handle checks that accesses are aligned according to this value layout's\n+     * {@linkplain MemoryLayout#byteAlignment() alignment constraint}.\n+     *\n+     * @apiNote This method is similar, but more efficient, than calling {@code MemoryLayout#varHandle(PathElement...)}\n+     * with an empty path element array, as it avoids the creation of the var args array.\n+     *\n+     * @apiNote The returned var handle features certain <a href=\"MemoryLayout.html#access-mode-restrictions\">access mode\n+     * restrictions<\/a> common to all memory access var handles derived from memory layouts.\n+     *\n+     * @see MemoryLayout#varHandle(PathElement...)\n+     *\/\n+    VarHandle varHandle();\n+\n@@ -161,1 +119,1 @@\n-     * @since 19\n+     * @since 22\n@@ -163,2 +121,1 @@\n-    @PreviewFeature(feature = PreviewFeature.Feature.FOREIGN)\n-    sealed interface OfBoolean extends ValueLayout permits ValueLayouts.OfBooleanImpl {\n+        sealed interface OfBoolean extends ValueLayout permits ValueLayouts.OfBooleanImpl {\n@@ -197,1 +154,1 @@\n-     * @since 19\n+     * @since 22\n@@ -199,2 +156,1 @@\n-    @PreviewFeature(feature = PreviewFeature.Feature.FOREIGN)\n-    sealed interface OfByte extends ValueLayout permits ValueLayouts.OfByteImpl {\n+        sealed interface OfByte extends ValueLayout permits ValueLayouts.OfByteImpl {\n@@ -234,1 +190,1 @@\n-     * @since 19\n+     * @since 22\n@@ -236,2 +192,1 @@\n-    @PreviewFeature(feature = PreviewFeature.Feature.FOREIGN)\n-    sealed interface OfChar extends ValueLayout permits ValueLayouts.OfCharImpl {\n+        sealed interface OfChar extends ValueLayout permits ValueLayouts.OfCharImpl {\n@@ -271,1 +226,1 @@\n-     * @since 19\n+     * @since 22\n@@ -273,2 +228,1 @@\n-    @PreviewFeature(feature = PreviewFeature.Feature.FOREIGN)\n-    sealed interface OfShort extends ValueLayout permits ValueLayouts.OfShortImpl {\n+        sealed interface OfShort extends ValueLayout permits ValueLayouts.OfShortImpl {\n@@ -308,1 +262,1 @@\n-     * @since 19\n+     * @since 22\n@@ -310,2 +264,1 @@\n-    @PreviewFeature(feature = PreviewFeature.Feature.FOREIGN)\n-    sealed interface OfInt extends ValueLayout permits ValueLayouts.OfIntImpl {\n+        sealed interface OfInt extends ValueLayout permits ValueLayouts.OfIntImpl {\n@@ -345,1 +298,1 @@\n-     * @since 19\n+     * @since 22\n@@ -347,2 +300,1 @@\n-    @PreviewFeature(feature = PreviewFeature.Feature.FOREIGN)\n-    sealed interface OfFloat extends ValueLayout permits ValueLayouts.OfFloatImpl {\n+        sealed interface OfFloat extends ValueLayout permits ValueLayouts.OfFloatImpl {\n@@ -381,1 +333,1 @@\n-     * @since 19\n+     * @since 22\n@@ -383,2 +335,1 @@\n-    @PreviewFeature(feature = PreviewFeature.Feature.FOREIGN)\n-    sealed interface OfLong extends ValueLayout permits ValueLayouts.OfLongImpl {\n+        sealed interface OfLong extends ValueLayout permits ValueLayouts.OfLongImpl {\n@@ -418,1 +369,1 @@\n-     * @since 19\n+     * @since 22\n@@ -420,2 +371,1 @@\n-    @PreviewFeature(feature = PreviewFeature.Feature.FOREIGN)\n-    sealed interface OfDouble extends ValueLayout permits ValueLayouts.OfDoubleImpl {\n+        sealed interface OfDouble extends ValueLayout permits ValueLayouts.OfDoubleImpl {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/ValueLayout.java","additions":39,"deletions":89,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -96,1 +96,1 @@\n- *     MemorySegment cString = arena.allocateUtf8String(\"Hello\");\n+ *     MemorySegment cString = arena.allocateFrom(\"Hello\");\n@@ -112,1 +112,1 @@\n- * {@linkplain java.lang.foreign.SegmentAllocator#allocateUtf8String(java.lang.String) converting} Java strings into\n+ * {@linkplain java.lang.foreign.SegmentAllocator#allocateFrom(java.lang.String) converting} Java strings into\n@@ -138,2 +138,2 @@\n- * @apiNote Usual memory model guarantees, for example stated in {@jls 6.6} and {@jls 10.4}, do not apply\n- * when accessing native memory segments as these segments are backed by off-heap regions of memory.\n+ * @apiNote Usual memory model guarantees (see {@jls 17.4}) do not apply when accessing native memory segments as\n+ * these segments are backed by off-heap regions of memory.\n@@ -150,1 +150,1 @@\n- * @since 19\n+ * @since 22\n@@ -152,1 +152,0 @@\n-@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n@@ -155,1 +154,0 @@\n-import jdk.internal.javac.PreviewFeature;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/package-info.java","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -125,1 +125,1 @@\n-                    MemorySegment s = slicingArena.allocateArray(JAVA_INT, 1, 2, 3, 4, 5);\n+                    MemorySegment s = slicingArena.allocateFrom(JAVA_INT, 1, 2, 3, 4, 5);\n@@ -151,1 +151,1 @@\n-                    sequenceLayout(ValueLayout.JAVA_BYTE));\n+                    sequenceLayout(Long.MAX_VALUE, ValueLayout.JAVA_BYTE));\n@@ -171,1 +171,1 @@\n-                MemorySegment str = arena.allocateUtf8String(\"Hello\");\n+                MemorySegment str = arena.allocateFrom(\"Hello\");\n@@ -200,1 +200,1 @@\n-                MemorySegment array = arena.allocateArray(JAVA_INT, 0, 9, 3, 4, 6, 5, 1, 8, 2, 7);\n+                MemorySegment array = arena.allocateFrom(JAVA_INT, 0, 9, 3, 4, 6, 5, 1, 8, 2, 7);\n@@ -291,1 +291,1 @@\n-                int res = (int) printf.invokeExact(arena.allocateUtf8String(\"%d plus %d equals %d\"), 2, 2, 4); \/\/prints \"2 plus 2 equals 4\"\n+                int res = (int) printf.invokeExact(arena.allocateFrom(\"%d plus %d equals %d\"), 2, 2, 4); \/\/prints \"2 plus 2 equals 4\"\n@@ -316,1 +316,1 @@\n-                int errno = (int) errnoHandle.get(capturedState);\n+                int errno = (int) errnoHandle.get(capturedState, 0L);\n@@ -354,2 +354,2 @@\n-            long offset1 = (long) offsetHandle.invokeExact(1L); \/\/ 8\n-            long offset2 = (long) offsetHandle.invokeExact(2L); \/\/ 16\n+            long offset1 = (long) offsetHandle.invokeExact(0L, 1L); \/\/ 8\n+            long offset2 = (long) offsetHandle.invokeExact(0L, 2L); \/\/ 16\n@@ -399,1 +399,1 @@\n-                VarHandle intHandle = MethodHandles.memorySegmentViewVarHandle(ValueLayout.JAVA_INT);\n+                VarHandle intHandle = ValueLayout.JAVA_INT.varHandle();\n@@ -411,2 +411,7 @@\n-                VarHandle intHandle = ValueLayout.JAVA_INT.arrayElementVarHandle();\n-                int value = (int) intHandle.get(segment, 3L); \/\/ get int element at offset 3 * 4 = 12\n+                MemoryLayout segmentLayout = MemoryLayout.structLayout(\n+                    ValueLayout.JAVA_INT.withName(\"size\"),\n+                    MemoryLayout.sequenceLayout(4, ValueLayout.JAVA_INT).withName(\"data\") \/\/ array of 4 elements\n+                );\n+                VarHandle intHandle = segmentLayout.varHandle(MemoryLayout.PathElement.groupElement(\"data\"),\n+                                                              MemoryLayout.PathElement.sequenceElement());\n+                int value = (int) intHandle.get(segment, 0L, 3L); \/\/ get int element at offset 0 + offsetof(data) + 3 * 4 = 12\n@@ -527,2 +532,0 @@\n-            var byteHandle = MemoryLayout.sequenceLayout(ValueLayout.JAVA_BYTE)\n-                    .varHandle(MemoryLayout.PathElement.sequenceElement());\n@@ -530,1 +533,1 @@\n-                byteHandle.set(segment.address(), l, value);\n+                segment.set(JAVA_BYTE, l, value);\n@@ -573,1 +576,1 @@\n-                MemorySegment cString = arena.allocateUtf8String(\"Hello\");\n+                MemorySegment cString = arena.allocateFrom(\"Hello\");\n@@ -657,11 +660,0 @@\n-        void arrayElementVarHandle() {\n-            VarHandle arrayHandle = ValueLayout.JAVA_INT.arrayElementVarHandle(10, 20);\n-\n-            SequenceLayout arrayLayout = MemoryLayout.sequenceLayout(\n-                    MemoryLayout.sequenceLayout(10,\n-                            MemoryLayout.sequenceLayout(20, ValueLayout.JAVA_INT)));\n-\n-            int value1 = (int) arrayHandle.get(10, 2, 4); \/\/ ok, accessed offset = 8176\n-            int value2 = (int) arrayHandle.get(0, 0, 30); \/\/ out of bounds value for z\n-        }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/snippet-files\/Snippets.java","additions":18,"deletions":26,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -29,2 +29,0 @@\n-import jdk.internal.foreign.Utils;\n-import jdk.internal.javac.PreviewFeature;\n@@ -48,4 +46,0 @@\n-import java.lang.foreign.GroupLayout;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.ValueLayout;\n@@ -7981,79 +7975,0 @@\n-    \/**\n-     * Creates a var handle object, which can be used to dereference a {@linkplain java.lang.foreign.MemorySegment memory segment}\n-     * at a given byte offset, using the provided value layout.\n-     *\n-     * <p>The provided layout specifies the {@linkplain ValueLayout#carrier() carrier type},\n-     * the {@linkplain ValueLayout#byteSize() byte size},\n-     * the {@linkplain ValueLayout#byteAlignment() byte alignment} and the {@linkplain ValueLayout#order() byte order}\n-     * associated with the returned var handle.\n-     *\n-     * <p>The list of coordinate types associated with the returned var handle is {@code (MemorySegment, long)},\n-     * where the {@code long} coordinate type corresponds to byte offset into the given memory segment coordinate.\n-     * Thus, the returned var handle accesses bytes at an offset in a given memory segment, composing bytes to or from\n-     * a value of the var handle type. Moreover, the access operation will honor the endianness and the\n-     * alignment constraints expressed in the provided layout.\n-     *\n-     * <p>As an example, consider the memory layout expressed by a {@link GroupLayout} instance constructed as follows:\n-     * {@snippet lang=\"java\" :\n-     *     GroupLayout seq = java.lang.foreign.MemoryLayout.structLayout(\n-     *             MemoryLayout.paddingLayout(4),\n-     *             ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN).withName(\"value\")\n-     *     );\n-     * }\n-     * To access the member layout named {@code value}, we can construct a memory segment view var handle as follows:\n-     * {@snippet lang=\"java\" :\n-     *     VarHandle handle = MethodHandles.memorySegmentViewVarHandle(ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN)); \/\/(MemorySegment, long) -> int\n-     *     handle = MethodHandles.insertCoordinates(handle, 1, 4); \/\/(MemorySegment) -> int\n-     * }\n-     *\n-     * @apiNote The resulting var handle features certain <i>access mode restrictions<\/i>,\n-     * which are common to all memory segment view var handles. A memory segment view var handle is associated\n-     * with an access size {@code S} and an alignment constraint {@code B}\n-     * (both expressed in bytes). We say that a memory access operation is <em>fully aligned<\/em> if it occurs\n-     * at a memory address {@code A} which is compatible with both alignment constraints {@code S} and {@code B}.\n-     * If access is fully aligned then following access modes are supported and are\n-     * guaranteed to support atomic access:\n-     * <ul>\n-     * <li>read write access modes for all {@code T}, with the exception of\n-     *     access modes {@code get} and {@code set} for {@code long} and\n-     *     {@code double} on 32-bit platforms.\n-     * <li>atomic update access modes for {@code int}, {@code long},\n-     *     {@code float}, {@code double} or {@link MemorySegment}.\n-     *     (Future major platform releases of the JDK may support additional\n-     *     types for certain currently unsupported access modes.)\n-     * <li>numeric atomic update access modes for {@code int}, {@code long} and {@link MemorySegment}.\n-     *     (Future major platform releases of the JDK may support additional\n-     *     numeric types for certain currently unsupported access modes.)\n-     * <li>bitwise atomic update access modes for {@code int}, {@code long} and {@link MemorySegment}.\n-     *     (Future major platform releases of the JDK may support additional\n-     *     numeric types for certain currently unsupported access modes.)\n-     * <\/ul>\n-     *\n-     * If {@code T} is {@code float}, {@code double} or {@link MemorySegment} then atomic\n-     * update access modes compare values using their bitwise representation\n-     * (see {@link Float#floatToRawIntBits},\n-     * {@link Double#doubleToRawLongBits} and {@link MemorySegment#address()}, respectively).\n-     * <p>\n-     * Alternatively, a memory access operation is <em>partially aligned<\/em> if it occurs at a memory address {@code A}\n-     * which is only compatible with the alignment constraint {@code B}; in such cases, access for anything other than the\n-     * {@code get} and {@code set} access modes will result in an {@code IllegalStateException}. If access is partially aligned,\n-     * atomic access is only guaranteed with respect to the largest power of two that divides the GCD of {@code A} and {@code S}.\n-     * <p>\n-     * In all other cases, we say that a memory access operation is <em>misaligned<\/em>; in such cases an\n-     * {@code IllegalStateException} is thrown, irrespective of the access mode being used.\n-     * <p>\n-     * Finally, if {@code T} is {@code MemorySegment} all write access modes throw {@link IllegalArgumentException}\n-     * unless the value to be written is a {@linkplain MemorySegment#isNative() native} memory segment.\n-     *\n-     * @param layout the value layout for which a memory access handle is to be obtained.\n-     * @return the new memory segment view var handle.\n-     * @throws NullPointerException if {@code layout} is {@code null}.\n-     * @see MemoryLayout#varHandle(MemoryLayout.PathElement...)\n-     * @since 19\n-     *\/\n-    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n-    public static VarHandle memorySegmentViewVarHandle(ValueLayout layout) {\n-        Objects.requireNonNull(layout);\n-        return Utils.makeSegmentViewVarHandle(layout);\n-    }\n-\n@@ -8090,1 +8005,1 @@\n-     * @since 19\n+     * @since 22\n@@ -8092,1 +8007,0 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n@@ -8126,1 +8040,1 @@\n-     * @since 19\n+     * @since 22\n@@ -8128,1 +8042,0 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n@@ -8158,1 +8071,1 @@\n-     * @since 19\n+     * @since 22\n@@ -8160,1 +8073,0 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n@@ -8201,1 +8113,1 @@\n-     * @since 19\n+     * @since 22\n@@ -8203,1 +8115,0 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n@@ -8245,1 +8156,1 @@\n-     * @since 19\n+     * @since 22\n@@ -8247,1 +8158,0 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n@@ -8271,1 +8181,1 @@\n-     * @since 19\n+     * @since 22\n@@ -8273,1 +8183,0 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":6,"deletions":97,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import jdk.internal.foreign.Utils;\n+\n@@ -57,1 +59,5 @@\n-        return new IllegalArgumentException(\"Misaligned access at address: \" + address);\n+        return new IllegalArgumentException(\"Misaligned access at address: \" + Utils.toHexString(address));\n+    }\n+\n+    static UnsupportedOperationException newUnsupportedAccessModeForAlignment(long alignment) {\n+        return new UnsupportedOperationException(\"Unsupported access mode for alignment: \" + alignment);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandleSegmentViewBase.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-    static final int VM_ALIGN = $BoxType$.BYTES - 1;\n+    static final int NON_PLAIN_ACCESS_MIN_ALIGN_MASK = $BoxType$.BYTES - 1;\n@@ -107,4 +107,3 @@\n-    static long offset(AbstractMemorySegmentImpl bb, long offset, long alignmentMask) {\n-        long address = offsetNoVMAlignCheck(bb, offset, alignmentMask);\n-        if ((address & VM_ALIGN) != 0) {\n-            throw VarHandleSegmentViewBase.newIllegalArgumentExceptionForMisalignedAccess(address);\n+    static long offsetNonPlain(AbstractMemorySegmentImpl bb, long offset, long alignmentMask) {\n+        if ((alignmentMask & NON_PLAIN_ACCESS_MIN_ALIGN_MASK) != NON_PLAIN_ACCESS_MIN_ALIGN_MASK) {\n+            throw VarHandleSegmentViewBase.newUnsupportedAccessModeForAlignment(alignmentMask + 1);\n@@ -112,1 +111,1 @@\n-        return address;\n+        return offsetPlain(bb, offset, alignmentMask);\n@@ -116,1 +115,1 @@\n-    static long offsetNoVMAlignCheck(AbstractMemorySegmentImpl bb, long offset, long alignmentMask) {\n+    static long offsetPlain(AbstractMemorySegmentImpl bb, long offset, long alignmentMask) {\n@@ -133,1 +132,1 @@\n-                offsetNoVMAlignCheck(bb, base, handle.alignmentMask),\n+                offsetPlain(bb, base, handle.alignmentMask),\n@@ -140,1 +139,1 @@\n-                offsetNoVMAlignCheck(bb, base, handle.alignmentMask));\n+                offsetPlain(bb, base, handle.alignmentMask));\n@@ -144,1 +143,1 @@\n-                offsetNoVMAlignCheck(bb, base, handle.alignmentMask),\n+                offsetPlain(bb, base, handle.alignmentMask),\n@@ -157,1 +156,1 @@\n-                offsetNoVMAlignCheck(bb, base, handle.alignmentMask),\n+                offsetPlain(bb, base, handle.alignmentMask),\n@@ -164,1 +163,1 @@\n-                offsetNoVMAlignCheck(bb, base, handle.alignmentMask),\n+                offsetPlain(bb, base, handle.alignmentMask),\n@@ -169,1 +168,1 @@\n-                offsetNoVMAlignCheck(bb, base, handle.alignmentMask),\n+                offsetPlain(bb, base, handle.alignmentMask),\n@@ -183,1 +182,1 @@\n-                                  offset(bb, base, handle.alignmentMask)));\n+                                  offsetNonPlain(bb, base, handle.alignmentMask)));\n@@ -192,1 +191,1 @@\n-                offset(bb, base, handle.alignmentMask),\n+                offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -203,1 +202,1 @@\n-                                  offset(bb, base, handle.alignmentMask)));\n+                                  offsetNonPlain(bb, base, handle.alignmentMask)));\n@@ -212,1 +211,1 @@\n-                offset(bb, base, handle.alignmentMask),\n+                offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -223,1 +222,1 @@\n-                                  offset(bb, base, handle.alignmentMask)));\n+                                  offsetNonPlain(bb, base, handle.alignmentMask)));\n@@ -232,1 +231,1 @@\n-                offset(bb, base, handle.alignmentMask),\n+                offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -243,1 +242,1 @@\n-                offset(bb, base, handle.alignmentMask),\n+                offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -254,1 +253,1 @@\n-                                  offset(bb, base, handle.alignmentMask),\n+                                  offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -265,1 +264,1 @@\n-                                  offset(bb, base, handle.alignmentMask),\n+                                  offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -276,1 +275,1 @@\n-                                  offset(bb, base, handle.alignmentMask),\n+                                  offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -286,1 +285,1 @@\n-                offset(bb, base, handle.alignmentMask),\n+                offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -296,1 +295,1 @@\n-                offset(bb, base, handle.alignmentMask),\n+                offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -306,1 +305,1 @@\n-                offset(bb, base, handle.alignmentMask),\n+                offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -316,1 +315,1 @@\n-                offset(bb, base, handle.alignmentMask),\n+                offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -327,1 +326,1 @@\n-                                  offset(bb, base, handle.alignmentMask),\n+                                  offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -338,1 +337,1 @@\n-                                  offset(bb, base, handle.alignmentMask),\n+                                  offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -349,1 +348,1 @@\n-                                  offset(bb, base, handle.alignmentMask),\n+                                  offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -362,1 +361,1 @@\n-                    offset(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -365,1 +364,1 @@\n-            return getAndAddConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), delta);\n+            return getAndAddConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), delta);\n@@ -376,1 +375,1 @@\n-                    offset(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -379,1 +378,1 @@\n-            return getAndAddConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), delta);\n+            return getAndAddConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), delta);\n@@ -390,1 +389,1 @@\n-                    offset(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -393,1 +392,1 @@\n-            return getAndAddConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), delta);\n+            return getAndAddConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), delta);\n@@ -418,1 +417,1 @@\n-                    offset(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -421,1 +420,1 @@\n-            return getAndBitwiseOrConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseOrConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), value);\n@@ -432,1 +431,1 @@\n-                    offset(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -435,1 +434,1 @@\n-            return getAndBitwiseOrConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseOrConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), value);\n@@ -446,1 +445,1 @@\n-                    offset(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -449,1 +448,1 @@\n-            return getAndBitwiseOrConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseOrConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), value);\n@@ -472,1 +471,1 @@\n-                    offset(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -475,1 +474,1 @@\n-            return getAndBitwiseAndConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseAndConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), value);\n@@ -486,1 +485,1 @@\n-                    offset(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -489,1 +488,1 @@\n-            return getAndBitwiseAndConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseAndConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), value);\n@@ -500,1 +499,1 @@\n-                    offset(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -503,1 +502,1 @@\n-            return getAndBitwiseAndConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseAndConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), value);\n@@ -527,1 +526,1 @@\n-                    offset(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -530,1 +529,1 @@\n-            return getAndBitwiseXorConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseXorConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), value);\n@@ -541,1 +540,1 @@\n-                    offset(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -544,1 +543,1 @@\n-            return getAndBitwiseXorConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseXorConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), value);\n@@ -555,1 +554,1 @@\n-                    offset(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -558,1 +557,1 @@\n-            return getAndBitwiseXorConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseXorConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), value);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/X-VarHandleSegmentView.java.template","additions":54,"deletions":55,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -1099,1 +1099,4 @@\n-            SocketReadEvent.offer(start, nbytes, parent.getRemoteSocketAddress(), getSoTimeout());\n+            long duration = SocketReadEvent.timestamp() - start;\n+            if (SocketReadEvent.shouldCommit(duration)) {\n+                SocketReadEvent.emit(start, duration, nbytes, parent.getRemoteSocketAddress(), getSoTimeout());\n+            }\n@@ -1212,1 +1215,4 @@\n-            SocketWriteEvent.offer(start, len, parent.getRemoteSocketAddress());\n+            long duration = SocketWriteEvent.timestamp() - start;\n+            if (SocketWriteEvent.shouldCommit(duration)) {\n+                SocketWriteEvent.emit(start, duration, len, parent.getRemoteSocketAddress());\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/net\/Socket.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -282,0 +282,3 @@\n+#if[byte]\n+ * @sealedGraph\n+#end[byte]\n","filename":"src\/java.base\/share\/classes\/java\/nio\/X-Buffer.java.template","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1091,1 +1091,1 @@\n-     * @since   19\n+     * @since   22\n@@ -1093,1 +1093,0 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/FileChannel.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -145,1 +145,1 @@\n-        sb.append(\"Signer: \" + signerCertPath.getCertificates().get(0));\n+        sb.append(\"Signer: \").append(signerCertPath.getCertificates().get(0));\n@@ -147,1 +147,1 @@\n-            sb.append(\"timestamp: \" + timestamp);\n+            sb.append(\"timestamp: \").append(timestamp);\n@@ -163,3 +163,6 @@\n-        throws IOException, ClassNotFoundException {\n-     ois.defaultReadObject();\n-     myhash = -1;\n+            throws IOException, ClassNotFoundException {\n+        ois.defaultReadObject();\n+        if (signerCertPath == null) {\n+            throw new InvalidObjectException(\"signerCertPath is null\");\n+        }\n+        myhash = -1;\n","filename":"src\/java.base\/share\/classes\/java\/security\/CodeSigner.java","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-import java.util.*;\n+import java.util.Date;\n@@ -32,2 +32,0 @@\n-import sun.security.x509.GeneralNameInterface;\n-\n@@ -58,5 +56,0 @@\n-    protected void implSetPathToNames(X509CertSelector sel,\n-            Set<GeneralNameInterface> names) {\n-        sel.setPathToNamesInternal(names);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/security\/cert\/CertPathHelperImpl.java","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -90,4 +90,0 @@\n-    static {\n-        CertPathHelperImpl.initialize();\n-    }\n-\n@@ -1130,8 +1126,0 @@\n-    \/\/ called from CertPathHelper\n-    void setPathToNamesInternal(Set<GeneralNameInterface> names) {\n-        \/\/ set names to non-null dummy value\n-        \/\/ this breaks getPathToNames()\n-        pathToNames = Collections.<List<?>>emptySet();\n-        pathToGeneralNames = names;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/security\/cert\/X509CertSelector.java","additions":1,"deletions":13,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -353,1 +353,1 @@\n-            ks = new AbstractSet<K>() {\n+            ks = new AbstractSet<>() {\n@@ -355,15 +355,1 @@\n-                    return new Iterator<K>() {\n-                        private Iterator<Entry<K,V>> i = entrySet().iterator();\n-\n-                        public boolean hasNext() {\n-                            return i.hasNext();\n-                        }\n-\n-                        public K next() {\n-                            return i.next().getKey();\n-                        }\n-\n-                        public void remove() {\n-                            i.remove();\n-                        }\n-                    };\n+                    return new KeyIterator();\n@@ -412,1 +398,1 @@\n-            vals = new AbstractCollection<V>() {\n+            vals = new AbstractCollection<>() {\n@@ -414,15 +400,1 @@\n-                    return new Iterator<V>() {\n-                        private Iterator<Entry<K,V>> i = entrySet().iterator();\n-\n-                        public boolean hasNext() {\n-                            return i.hasNext();\n-                        }\n-\n-                        public V next() {\n-                            return i.next().getValue();\n-                        }\n-\n-                        public void remove() {\n-                            i.remove();\n-                        }\n-                    };\n+                    return new ValueIterator();\n@@ -927,0 +899,16 @@\n+\n+    \/\/ Iterator implementations.\n+\n+    final class KeyIterator implements Iterator<K> {\n+        private final Iterator<Entry<K,V>> i = entrySet().iterator();\n+        public boolean hasNext() { return i.hasNext(); }\n+        public void remove() { i.remove(); }\n+        public K next() { return i.next().getKey(); }\n+    }\n+\n+    final class ValueIterator implements Iterator<V> {\n+        private final Iterator<Entry<K,V>> i = entrySet().iterator();\n+        public boolean hasNext() { return i.hasNext(); }\n+        public void remove() { i.remove(); }\n+        public V next() { return i.next().getValue(); }\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/util\/AbstractMap.java","additions":20,"deletions":32,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -625,3 +625,3 @@\n-     * operations generally delegate to the appropriate method with the opposite\n-     * orientation. For example, calling {@code getFirst} on the view results in\n-     * a call to {@code getLast} on this Deque.\n+     * operations generally behave as if they delegate to the appropriate method\n+     * with the opposite orientation. For example, calling {@code getFirst} on\n+     * the view might result in a call to {@code getLast} on this Deque.\n","filename":"src\/java.base\/share\/classes\/java\/util\/Deque.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -169,3 +169,3 @@\n-         * @param a the array to be sorted\n-         * @param low the index of the first element, inclusive, to be sorted\n-         * @param high the index of the last element, exclusive, to be sorted\n+         * @param a the array to be partitioned\n+         * @param low the index of the first element, inclusive, to be partitioned\n+         * @param high the index of the last element, exclusive, to be partitioned\n@@ -181,2 +181,2 @@\n-     * @param elemType the class of the array to be sorted\n-     * @param array the array to be sorted\n+     * @param elemType the class of the array to be partitioned\n+     * @param array the array to be partitioned\n@@ -186,2 +186,2 @@\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n+     * @param low the index of the first element, inclusive, to be partitioned\n+     * @param high the index of the last element, exclusive, to be partitioned\n","filename":"src\/java.base\/share\/classes\/java\/util\/DualPivotQuicksort.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.util.HexDigits;\n@@ -153,9 +154,1 @@\n-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1\n@@ -406,6 +399,3 @@\n-                out.append(prefix);\n-                toHexDigits(out, bytes[fromIndex]);\n-                if (suffix.isEmpty() && delimiter.isEmpty() && prefix.isEmpty()) {\n-                    for (int i = 1; i < length; i++) {\n-                        toHexDigits(out, bytes[fromIndex + i]);\n-                    }\n+                String s = formatOptDelimiter(bytes, fromIndex, toIndex);\n+                if (s != null) {\n+                    out.append(s);\n@@ -413,0 +403,2 @@\n+                    out.append(prefix);\n+                    toHexDigits(out, bytes[fromIndex]);\n@@ -419,0 +411,1 @@\n+                    out.append(suffix);\n@@ -420,1 +413,0 @@\n-                out.append(suffix);\n@@ -441,0 +433,1 @@\n+        char sep;\n@@ -445,0 +438,2 @@\n+\n+        boolean ucase = digitCase == Case.UPPERCASE;\n@@ -450,2 +445,4 @@\n-                rep[i * 2] = (byte)toHighHexDigit(bytes[fromIndex + i]);\n-                rep[i * 2 + 1] = (byte)toLowHexDigit(bytes[fromIndex + i]);\n+                short pair = HexDigits.digitPair(bytes[fromIndex + i], ucase);\n+                int pos = i * 2;\n+                rep[pos] = (byte)pair;\n+                rep[pos + 1] = (byte)(pair >>> 8);\n@@ -453,1 +450,1 @@\n-        } else if (delimiter.length() == 1 && delimiter.charAt(0) < 256) {\n+        } else if (delimiter.length() == 1 && (sep = delimiter.charAt(0)) < 256) {\n@@ -456,1 +453,0 @@\n-            char sep = delimiter.charAt(0);\n@@ -458,2 +454,3 @@\n-            rep[0] = (byte) toHighHexDigit(bytes[fromIndex]);\n-            rep[1] = (byte) toLowHexDigit(bytes[fromIndex]);\n+            short pair = HexDigits.digitPair(bytes[fromIndex], ucase);\n+            rep[0] = (byte)pair;\n+            rep[1] = (byte)(pair >>> 8);\n@@ -461,3 +458,5 @@\n-                rep[i * 3 - 1] = (byte) sep;\n-                rep[i * 3    ] = (byte) toHighHexDigit(bytes[fromIndex + i]);\n-                rep[i * 3 + 1] = (byte) toLowHexDigit(bytes[fromIndex + i]);\n+                int pos = i * 3;\n+                pair = HexDigits.digitPair(bytes[fromIndex + i], ucase);\n+                rep[pos - 1] = (byte) sep;\n+                rep[pos] = (byte)pair;\n+                rep[pos + 1] = (byte)(pair >>> 8);\n@@ -890,1 +889,1 @@\n-        return ((ch >>> 8) == 0 && DIGITS[ch] >= 0);\n+        return ((ch >>> 7) == 0 && DIGITS[ch] >= 0);\n@@ -908,1 +907,1 @@\n-        if ((ch >>> 8) == 0 && (value = DIGITS[ch]) >= 0) {\n+        if ((ch >>> 7) == 0 && (value = DIGITS[ch]) >= 0) {\n","filename":"src\/java.base\/share\/classes\/java\/util\/HexFormat.java","additions":26,"deletions":27,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+ * @sealedGraph\n","filename":"src\/java.base\/share\/classes\/java\/util\/IllegalFormatException.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -894,3 +894,3 @@\n-     * operations generally delegate to the appropriate method with the opposite\n-     * orientation. For example, calling {@code getFirst} on the view results in\n-     * a call to {@code getLast} on this List.\n+     * operations generally behave as if they delegate to the appropriate method\n+     * with the opposite orientation. For example, calling {@code getFirst} on\n+     * the view might result in a call to {@code getLast} on this List.\n","filename":"src\/java.base\/share\/classes\/java\/util\/List.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -324,3 +324,3 @@\n-     * operations generally delegate to the appropriate method with the opposite\n-     * orientation. For example, calling {@code firstEntry} on the view results in\n-     * a call to {@code lastEntry} on this SortedMap.\n+     * operations generally behave as if they delegate to the appropriate method\n+     * with the opposite orientation. For example, calling {@code firstEntry} on\n+     * the view might result in a call to {@code lastEntry} on this SortedMap.\n","filename":"src\/java.base\/share\/classes\/java\/util\/SortedMap.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -368,3 +368,3 @@\n-     * operations generally delegate to the appropriate method with the opposite\n-     * orientation. For example, calling {@code getFirst} on the view results in\n-     * a call to {@code getLast} on this SortedSet.\n+     * operations generally behave as if they delegate to the appropriate method\n+     * with the opposite orientation. For example, calling {@code getFirst} on the\n+     * view might result in a call to {@code getLast} on this SortedSet.\n","filename":"src\/java.base\/share\/classes\/java\/util\/SortedSet.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -718,1 +718,1 @@\n-                \/\/ JDK internal attributes\n+                \/\/ JDK specific attributes\n@@ -721,0 +721,1 @@\n+                addName(names, new Name(\"Enable-Native-Access\"));\n","filename":"src\/java.base\/share\/classes\/java\/util\/jar\/Attributes.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -31,0 +31,3 @@\n+import java.io.IOException;\n+import java.io.InvalidObjectException;\n+import java.io.ObjectInputStream;\n@@ -63,1 +66,1 @@\n-    private final byte[] key;\n+    private byte[] key;\n@@ -254,0 +257,22 @@\n+\n+    \/**\n+     * Restores the state of this object from the stream.\n+     *\n+     * @param  stream the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n+     *\/\n+    @java.io.Serial\n+    private void readObject(ObjectInputStream stream)\n+            throws IOException, ClassNotFoundException {\n+        stream.defaultReadObject();\n+\n+        if (key == null || algorithm == null) {\n+            throw new InvalidObjectException(\"Missing argument\");\n+        }\n+\n+        this.key = key.clone();\n+        if (key.length == 0) {\n+            throw new InvalidObjectException(\"Invalid key length\");\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/spec\/SecretKeySpec.java","additions":26,"deletions":1,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,4 @@\n+import java.io.IOException;\n+import java.io.InvalidObjectException;\n+import java.io.ObjectInputStream;\n+\n@@ -51,1 +55,1 @@\n-    private final String[] choices;\n+    private String[] choices;\n@@ -75,1 +79,0 @@\n-     *\n@@ -107,0 +110,5 @@\n+        this.prompt = prompt;\n+        this.defaultChoice = defaultChoice;\n+        this.multipleSelectionsAllowed = multipleSelectionsAllowed;\n+\n+        this.choices = choices.clone();\n@@ -111,5 +119,0 @@\n-\n-        this.prompt = prompt;\n-        this.choices = choices.clone();\n-        this.defaultChoice = defaultChoice;\n-        this.multipleSelectionsAllowed = multipleSelectionsAllowed;\n@@ -199,0 +202,34 @@\n+\n+    \/**\n+     * Restores the state of this object from the stream.\n+     *\n+     * @param  stream the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n+     *\/\n+    @java.io.Serial\n+    private void readObject(ObjectInputStream stream)\n+            throws IOException, ClassNotFoundException {\n+        stream.defaultReadObject();\n+\n+        if ((prompt == null) || prompt.isEmpty() ||\n+                (choices == null) || (choices.length == 0) ||\n+                (defaultChoice < 0) || (defaultChoice >= choices.length)) {\n+            throw new InvalidObjectException(\n+                    \"Missing\/invalid prompt\/choices\");\n+        }\n+\n+        choices = choices.clone();\n+        for (int i = 0; i < choices.length; i++) {\n+            if ((choices[i] == null) || choices[i].isEmpty())\n+                throw new InvalidObjectException(\"Null\/empty choices\");\n+        }\n+\n+        if (selections != null) {\n+            selections = selections.clone();\n+            if (!multipleSelectionsAllowed && (selections.length != 1)) {\n+                throw new InvalidObjectException(\n+                        \"Multiple selections not allowed\");\n+            }\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/javax\/security\/auth\/callback\/ChoiceCallback.java","additions":45,"deletions":8,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+\n@@ -150,1 +153,1 @@\n-    private final String[] options;\n+    private String[] options;\n@@ -255,5 +258,0 @@\n-        for (int i = 0; i < options.length; i++) {\n-            if (options[i] == null || options[i].isEmpty())\n-                throw new IllegalArgumentException();\n-        }\n-\n@@ -263,1 +261,0 @@\n-        this.options = options.clone();\n@@ -265,0 +262,6 @@\n+\n+        this.options = options.clone();\n+        for (int i = 0; i < options.length; i++) {\n+            if (options[i] == null || options[i].isEmpty())\n+                throw new IllegalArgumentException();\n+        }\n@@ -375,5 +378,0 @@\n-        for (int i = 0; i < options.length; i++) {\n-            if (options[i] == null || options[i].isEmpty())\n-                throw new IllegalArgumentException();\n-        }\n-\n@@ -383,1 +381,0 @@\n-        this.options = options.clone();\n@@ -385,0 +382,6 @@\n+\n+        this.options = options.clone();\n+        for (int i = 0; i < options.length; i++) {\n+            if (options[i] == null || options[i].isEmpty())\n+                throw new IllegalArgumentException();\n+        }\n@@ -490,0 +493,16 @@\n+\n+    \/**\n+     * Restores the state of this object from the stream.\n+     *\n+     * @param  stream the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n+     *\/\n+    @java.io.Serial\n+    private void readObject(ObjectInputStream stream)\n+            throws IOException, ClassNotFoundException {\n+        stream.defaultReadObject();\n+        if (options != null) {\n+            options = options.clone();\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/javax\/security\/auth\/callback\/ConfirmationCallback.java","additions":33,"deletions":14,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import java.io.IOException;\n+import java.io.InvalidObjectException;\n+import java.io.ObjectInputStream;\n@@ -160,0 +163,23 @@\n+\n+    \/**\n+     * Restores the state of this object from the stream.\n+     *\n+     * @param  stream the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n+     *\/\n+    @java.io.Serial\n+    private void readObject(ObjectInputStream stream)\n+            throws IOException, ClassNotFoundException {\n+        stream.defaultReadObject();\n+\n+        if (prompt == null || prompt.isEmpty()) {\n+            throw new InvalidObjectException(\"Missing prompt\");\n+        }\n+\n+        if (inputPassword != null) {\n+            inputPassword = inputPassword.clone();\n+            cleanable = CleanerFactory.cleaner().register(\n+                    this, cleanerFor(inputPassword));\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/javax\/security\/auth\/callback\/PasswordCallback.java","additions":27,"deletions":1,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.lang.foreign.MemorySegment;\n@@ -276,1 +277,1 @@\n-    void ensureNativeAccess(Module m, Class<?> owner, String methodName);\n+    void ensureNativeAccess(Module m, Class<?> owner, String methodName, Class<?> currentClass);\n@@ -577,0 +578,10 @@\n+\n+    \/**\n+     * Copy the string bytes to an existing segment, avoiding intermediate copies.\n+     *\/\n+    void copyToSegmentRaw(String string, MemorySegment segment, long offset);\n+\n+    \/**\n+     * Are the string bytes compatible with the given charset?\n+     *\/\n+    boolean bytesCompatible(String string, Charset charset);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -116,0 +116,1 @@\n+     * @param duration the duration\n@@ -120,11 +121,8 @@\n-    public static void offer(long start, long nbytes, SocketAddress remote, long timeout) {\n-        long duration = timestamp() - start;\n-        if (shouldCommit(duration)) {\n-            boolean eof = nbytes < 0 ? true : false;\n-            nbytes = nbytes < 0 ? 0 : nbytes;\n-            if (remote instanceof InetSocketAddress isa) {\n-                commit(start, duration, isa.getHostString(), isa.getAddress().getHostAddress(), isa.getPort(), timeout, nbytes, eof);\n-            } else if (remote instanceof UnixDomainSocketAddress udsa) {\n-                String path = \"[\" + udsa.getPath().toString() + \"]\";\n-                commit(start, duration, \"Unix domain socket\", path, 0, timeout, nbytes, eof);\n-            }\n+    public static void emit(long start, long duration, long nbytes, SocketAddress remote, long timeout) {\n+        boolean eof = nbytes < 0 ? true : false;\n+        nbytes = nbytes < 0 ? 0 : nbytes;\n+        if (remote instanceof InetSocketAddress isa) {\n+            commit(start, duration, isa.getHostString(), isa.getAddress().getHostAddress(), isa.getPort(), timeout, nbytes, eof);\n+        } else if (remote instanceof UnixDomainSocketAddress udsa) {\n+            String path = \"[\" + udsa.getPath().toString() + \"]\";\n+            commit(start, duration, \"Unix domain socket\", path, 0, timeout, nbytes, eof);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/event\/SocketReadEvent.java","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -111,0 +111,1 @@\n+     * @param duration the duration\n@@ -114,10 +115,7 @@\n-    public static void offer(long start, long bytesWritten, SocketAddress remote) {\n-        long duration = timestamp() - start;\n-        if (shouldCommit(duration)) {\n-            long bytes = bytesWritten < 0 ? 0 : bytesWritten;\n-            if (remote instanceof InetSocketAddress isa) {\n-                commit(start, duration, isa.getHostString(), isa.getAddress().getHostAddress(), isa.getPort(), bytes);\n-            } else if (remote instanceof UnixDomainSocketAddress udsa) {\n-                String path = \"[\" + udsa.getPath().toString() + \"]\";\n-                commit(start, duration, \"Unix domain socket\", path, 0, bytes);\n-            }\n+    public static void emit(long start, long duration, long bytesWritten, SocketAddress remote) {\n+        long bytes = bytesWritten < 0 ? 0 : bytesWritten;\n+        if (remote instanceof InetSocketAddress isa) {\n+            commit(start, duration, isa.getHostString(), isa.getAddress().getHostAddress(), isa.getPort(), bytes);\n+        } else if (remote instanceof UnixDomainSocketAddress udsa) {\n+            String path = \"[\" + udsa.getPath().toString() + \"]\";\n+            commit(start, duration, \"Unix domain socket\", path, 0, bytes);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/event\/SocketWriteEvent.java","additions":8,"deletions":10,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -154,1 +154,1 @@\n-                () -> cleanup.accept(NativeMemorySegmentImpl.makeNativeSegmentUnchecked(address(), newSize)) :\n+                () -> cleanup.accept(SegmentFactories.makeNativeSegmentUnchecked(address(), newSize)) :\n@@ -156,1 +156,1 @@\n-        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(address(), newSize,\n+        return SegmentFactories.makeNativeSegmentUnchecked(address(), newSize,\n@@ -267,1 +267,1 @@\n-                long offsetToThat = this.segmentOffset(that);\n+                long offsetToThat = that.address() - this.address();\n@@ -275,9 +275,0 @@\n-    @Override\n-    public final long segmentOffset(MemorySegment other) {\n-        AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl) Objects.requireNonNull(other);\n-        if (unsafeGetBase() == that.unsafeGetBase()) {\n-            return that.unsafeGetOffset() - this.unsafeGetOffset();\n-        }\n-        throw new UnsupportedOperationException(\"Cannot compute offset from native to heap (or vice versa).\");\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":3,"deletions":12,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.foreign;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.MemorySegment.Scope;\n+import java.util.Objects;\n+\n+public final class ArenaImpl implements Arena {\n+\n+    private final MemorySessionImpl session;\n+    private final boolean shouldReserveMemory;\n+    ArenaImpl(MemorySessionImpl session) {\n+        this.session = session;\n+        shouldReserveMemory = session instanceof ImplicitSession;\n+    }\n+\n+    @Override\n+    public Scope scope() {\n+        return session;\n+    }\n+\n+    @Override\n+    public void close() {\n+        session.close();\n+    }\n+\n+    public MemorySegment allocateNoInit(long byteSize, long byteAlignment) {\n+        Utils.checkAllocationSizeAndAlign(byteSize, byteAlignment);\n+        return SegmentFactories.allocateSegment(byteSize, byteAlignment, session, shouldReserveMemory);\n+    }\n+\n+    @Override\n+    public MemorySegment allocate(long byteSize, long byteAlignment) {\n+        MemorySegment segment = allocateNoInit(byteSize, byteAlignment);\n+        return segment.fill((byte)0);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/ArenaImpl.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -29,1 +29,0 @@\n-import java.lang.foreign.MemorySegment;\n@@ -51,1 +50,1 @@\n-public abstract sealed class HeapMemorySegmentImpl extends AbstractMemorySegmentImpl {\n+abstract sealed class HeapMemorySegmentImpl extends AbstractMemorySegmentImpl {\n@@ -113,7 +112,0 @@\n-        public static MemorySegment fromArray(byte[] arr) {\n-            Objects.requireNonNull(arr);\n-            long byteSize = (long)arr.length * Unsafe.ARRAY_BYTE_INDEX_SCALE;\n-            return new OfByte(Unsafe.ARRAY_BYTE_BASE_OFFSET, arr, byteSize, false,\n-                    MemorySessionImpl.heapSession(arr));\n-        }\n-\n@@ -147,7 +139,0 @@\n-        public static MemorySegment fromArray(char[] arr) {\n-            Objects.requireNonNull(arr);\n-            long byteSize = (long)arr.length * Unsafe.ARRAY_CHAR_INDEX_SCALE;\n-            return new OfChar(Unsafe.ARRAY_CHAR_BASE_OFFSET, arr, byteSize, false,\n-                    MemorySessionImpl.heapSession(arr));\n-        }\n-\n@@ -181,7 +166,0 @@\n-        public static MemorySegment fromArray(short[] arr) {\n-            Objects.requireNonNull(arr);\n-            long byteSize = (long)arr.length * Unsafe.ARRAY_SHORT_INDEX_SCALE;\n-            return new OfShort(Unsafe.ARRAY_SHORT_BASE_OFFSET, arr, byteSize, false,\n-                    MemorySessionImpl.heapSession(arr));\n-        }\n-\n@@ -215,7 +193,0 @@\n-        public static MemorySegment fromArray(int[] arr) {\n-            Objects.requireNonNull(arr);\n-            long byteSize = (long)arr.length * Unsafe.ARRAY_INT_INDEX_SCALE;\n-            return new OfInt(Unsafe.ARRAY_INT_BASE_OFFSET, arr, byteSize, false,\n-                    MemorySessionImpl.heapSession(arr));\n-        }\n-\n@@ -249,7 +220,0 @@\n-        public static MemorySegment fromArray(long[] arr) {\n-            Objects.requireNonNull(arr);\n-            long byteSize = (long)arr.length * Unsafe.ARRAY_LONG_INDEX_SCALE;\n-            return new OfLong(Unsafe.ARRAY_LONG_BASE_OFFSET, arr, byteSize, false,\n-                    MemorySessionImpl.heapSession(arr));\n-        }\n-\n@@ -283,7 +247,0 @@\n-        public static MemorySegment fromArray(float[] arr) {\n-            Objects.requireNonNull(arr);\n-            long byteSize = (long)arr.length * Unsafe.ARRAY_FLOAT_INDEX_SCALE;\n-            return new OfFloat(Unsafe.ARRAY_FLOAT_BASE_OFFSET, arr, byteSize, false,\n-                    MemorySessionImpl.heapSession(arr));\n-        }\n-\n@@ -317,7 +274,0 @@\n-        public static MemorySegment fromArray(double[] arr) {\n-            Objects.requireNonNull(arr);\n-            long byteSize = (long)arr.length * Unsafe.ARRAY_DOUBLE_INDEX_SCALE;\n-            return new OfDouble(Unsafe.ARRAY_DOUBLE_BASE_OFFSET, arr, byteSize, false,\n-                    MemorySessionImpl.heapSession(arr));\n-        }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/HeapMemorySegmentImpl.java","additions":1,"deletions":51,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.vm.annotation.Stable;\n@@ -42,0 +43,2 @@\n+import java.util.List;\n+import java.util.Locale;\n@@ -44,0 +47,4 @@\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import static java.util.stream.Collectors.joining;\n@@ -64,0 +71,1 @@\n+    private static final MethodHandle MH_ADD;\n@@ -75,1 +83,1 @@\n-                    MethodType.methodType(MemorySegment.class, MemorySegment.class, MemoryLayout.class));\n+                    MethodType.methodType(void.class, MemorySegment.class, long.class, MemoryLayout.class));\n@@ -78,0 +86,2 @@\n+            MH_ADD = lookup.findStatic(Long.class, \"sum\",\n+                    MethodType.methodType(long.class, long.class, long.class));\n@@ -87,1 +97,0 @@\n-\n@@ -103,2 +112,1 @@\n-        check(SequenceLayout.class, \"attempting to select a sequence element from a non-sequence layout\");\n-        SequenceLayout seq = (SequenceLayout)layout;\n+        SequenceLayout seq = requireSequenceLayout();\n@@ -110,2 +118,1 @@\n-        check(SequenceLayout.class, \"attempting to select a sequence element from a non-sequence layout\");\n-        SequenceLayout seq = (SequenceLayout)layout;\n+        SequenceLayout seq = requireSequenceLayout();\n@@ -120,1 +127,1 @@\n-                                     addStride(elemSize * step), addBound(maxIndex), derefAdapters, this);\n+                addStride(elemSize * step), addBound(maxIndex), derefAdapters, this);\n@@ -124,2 +131,1 @@\n-        check(SequenceLayout.class, \"attempting to select a sequence element from a non-sequence layout\");\n-        SequenceLayout seq = (SequenceLayout)layout;\n+        SequenceLayout seq = requireSequenceLayout();\n@@ -129,1 +135,1 @@\n-        return LayoutPath.nestedPath(seq.elementLayout(), offset + elemOffset, strides, bounds, derefAdapters,this);\n+        return LayoutPath.nestedPath(seq.elementLayout(), offset + elemOffset, strides, bounds, derefAdapters, this);\n@@ -133,2 +139,1 @@\n-        check(GroupLayout.class, \"attempting to select a group element from a non-group layout\");\n-        GroupLayout g = (GroupLayout)layout;\n+        GroupLayout g = requireGroupLayout();\n@@ -148,1 +153,2 @@\n-            throw badLayoutPath(\"cannot resolve '\" + name + \"' in layout \" + layout);\n+            throw badLayoutPath(\n+                    String.format(\"cannot resolve '%s' in layout %s\", name, breadcrumbs()));\n@@ -154,2 +160,1 @@\n-        check(GroupLayout.class, \"attempting to select a group element from a non-group layout\");\n-        GroupLayout g = (GroupLayout)layout;\n+        GroupLayout g = requireGroupLayout();\n@@ -161,1 +166,2 @@\n-                throw badLayoutPath(\"cannot resolve element \" + index + \" in layout \" + layout);\n+                throw badLayoutPath(\n+                        String.format(\"cannot resolve element %d in layout: %s\", index, breadcrumbs()));\n@@ -174,1 +180,2 @@\n-            throw badLayoutPath(\"Cannot dereference layout: \" + layout);\n+            throw badLayoutPath(\n+                    String.format(\"Cannot dereference layout: %s\", breadcrumbs()));\n@@ -199,1 +206,2 @@\n-            throw new IllegalArgumentException(\"Path does not select a value layout\");\n+            throw new IllegalArgumentException(\n+                    String.format(\"Path does not select a value layout: %s\", breadcrumbs()));\n@@ -205,1 +213,1 @@\n-        VarHandle handle = Utils.makeSegmentViewVarHandle(accessedLayout);\n+        VarHandle handle = accessedLayout.varHandle();\n@@ -212,2 +220,6 @@\n-            MethodHandle checkHandle = MethodHandles.insertArguments(MH_CHECK_ALIGN, 1, rootLayout());\n-            handle = MethodHandles.filterCoordinates(handle, 0, checkHandle);\n+            \/\/ insert align check for the root layout on the initial MS + offset\n+            List<Class<?>> coordinateTypes = handle.coordinateTypes();\n+            MethodHandle alignCheck = MethodHandles.insertArguments(MH_CHECK_ALIGN, 2, rootLayout());\n+            handle = MethodHandles.collectCoordinates(handle, 0, alignCheck);\n+            int[] reorder = IntStream.concat(IntStream.of(0, 1), IntStream.range(0, coordinateTypes.size())).toArray();\n+            handle = MethodHandles.permuteCoordinates(handle, coordinateTypes, reorder);\n@@ -217,0 +229,4 @@\n+            if (derefAdapters.length > 0) {\n+                \/\/ plug up the base offset if we have at least 1 enclosing dereference\n+                handle = MethodHandles.insertCoordinates(handle, 1, 0);\n+            }\n@@ -218,1 +234,7 @@\n-                handle = MethodHandles.collectCoordinates(handle, 0, derefAdapters[i - 1]);\n+                MethodHandle adapter = derefAdapters[i - 1];\n+                \/\/ the first\/outermost adapter will have a base offset coordinate, the rest are constant 0\n+                if (i > 1) {\n+                    \/\/ plug in a constant 0 base offset for all but the outermost access in a deref chain\n+                    adapter = MethodHandles.insertArguments(adapter, 1, 0);\n+                }\n+                handle = MethodHandles.collectCoordinates(handle, 0, adapter);\n@@ -231,2 +253,2 @@\n-        MethodHandle mh = MethodHandles.identity(long.class);\n-        for (int i = strides.length - 1; i >=0; i--) {\n+        MethodHandle mh = MethodHandles.insertArguments(MH_ADD, 0, offset);\n+        for (int i = strides.length - 1; i >= 0; i--) {\n@@ -238,1 +260,1 @@\n-        mh = MethodHandles.insertArguments(mh, 0, offset);\n+\n@@ -256,1 +278,1 @@\n-        sliceHandle = MethodHandles.collectArguments(sliceHandle, 1, offsetHandle()); \/\/ (MS, ...) -> MS\n+        sliceHandle = MethodHandles.collectArguments(sliceHandle, 1, offsetHandle()); \/\/ (MS, long, ...) -> MS\n@@ -259,2 +281,6 @@\n-            MethodHandle checkHandle = MethodHandles.insertArguments(MH_CHECK_ALIGN, 1, rootLayout());\n-            sliceHandle = MethodHandles.filterArguments(sliceHandle, 0, checkHandle);\n+            \/\/ insert align check for the root layout on the initial MS + offset\n+            MethodType oldType = sliceHandle.type();\n+            MethodHandle alignCheck = MethodHandles.insertArguments(MH_CHECK_ALIGN, 2, rootLayout());\n+            sliceHandle = MethodHandles.collectArguments(sliceHandle, 0, alignCheck); \/\/ (MS, long, MS, long) -> MS\n+            int[] reorder = IntStream.concat(IntStream.of(0, 1), IntStream.range(0, oldType.parameterCount())).toArray();\n+            sliceHandle = MethodHandles.permuteArguments(sliceHandle, oldType, reorder); \/\/ (MS, long, ...) -> MS\n@@ -266,3 +292,5 @@\n-    private static MemorySegment checkAlign(MemorySegment segment, MemoryLayout constraint) {\n-        if (!((AbstractMemorySegmentImpl) segment).isAlignedForElement(0, constraint)) {\n-            throw new IllegalArgumentException(\"Target offset incompatible with alignment constraints: \" + constraint.byteAlignment());\n+    private static void checkAlign(MemorySegment segment, long offset, MemoryLayout constraint) {\n+        if (!((AbstractMemorySegmentImpl) segment).isAlignedForElement(offset, constraint)) {\n+            throw new IllegalArgumentException(String.format(\n+                    \"Target offset %d is incompatible with alignment constraint %d (of %s) for segment %s\"\n+                    , offset, constraint.byteAlignment(), constraint, segment));\n@@ -270,1 +298,0 @@\n-        return segment;\n@@ -295,1 +322,9 @@\n-    private void check(Class<?> layoutClass, String msg) {\n+    private SequenceLayout requireSequenceLayout() {\n+        return requireLayoutType(SequenceLayout.class, \"sequence\");\n+    }\n+\n+    private GroupLayout requireGroupLayout() {\n+        return requireLayoutType(GroupLayout.class, \"group\");\n+    }\n+\n+    private <T extends MemoryLayout> T requireLayoutType(Class<T> layoutClass, String name) {\n@@ -297,1 +332,3 @@\n-            throw badLayoutPath(msg);\n+            throw badLayoutPath(\n+                    String.format(\"attempting to select a %s element from a non-%s layout: %s\",\n+                            name, name, breadcrumbs()));\n@@ -299,0 +336,1 @@\n+        return layoutClass.cast(layout);\n@@ -303,1 +341,2 @@\n-            throw badLayoutPath(String.format(\"Sequence index out of bound; found: %d, size: %d\", index, seq.elementCount()));\n+            throw badLayoutPath(String.format(\"sequence index out of bounds; index: %d, elementCount is %d for layout %s\",\n+                    index, seq.elementCount(), breadcrumbs()));\n@@ -323,0 +362,7 @@\n+    private String breadcrumbs() {\n+        return Stream.iterate(this, Objects::nonNull, lp -> lp.enclosing)\n+                .map(LayoutPath::layout)\n+                .map(Object::toString)\n+                .collect(joining(\", selected from: \"));\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/LayoutPath.java","additions":81,"deletions":35,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-public final class MappedMemorySegmentImpl extends NativeMemorySegmentImpl {\n+final class MappedMemorySegmentImpl extends NativeMemorySegmentImpl {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MappedMemorySegmentImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -80,11 +80,1 @@\n-        return new Arena() {\n-            @Override\n-            public Scope scope() {\n-                return MemorySessionImpl.this;\n-            }\n-\n-            @Override\n-            public void close() {\n-                MemorySessionImpl.this.close();\n-            }\n-        };\n+        return new ArenaImpl(this);\n@@ -156,5 +146,0 @@\n-    public MemorySegment allocate(long byteSize, long byteAlignment) {\n-        Utils.checkAllocationSizeAndAlign(byteSize, byteAlignment);\n-        return NativeMemorySegmentImpl.makeNativeSegment(byteSize, byteAlignment, this);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MemorySessionImpl.java","additions":1,"deletions":16,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import jdk.internal.misc.VM;\n@@ -36,1 +35,0 @@\n-import sun.security.action.GetBooleanAction;\n@@ -42,8 +40,1 @@\n-public sealed class NativeMemorySegmentImpl extends AbstractMemorySegmentImpl permits MappedMemorySegmentImpl {\n-\n-    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n-\n-    \/\/ The maximum alignment supported by malloc - typically 16 bytes on\n-    \/\/ 64-bit platforms and 8 bytes on 32-bit platforms.\n-    private static final long MAX_MALLOC_ALIGN = Unsafe.ADDRESS_SIZE == 4 ? 8 : 16;\n-    private static final boolean SKIP_ZERO_MEMORY = GetBooleanAction.privilegedGetProperty(\"jdk.internal.foreign.skipZeroMemory\");\n+sealed class NativeMemorySegmentImpl extends AbstractMemorySegmentImpl permits MappedMemorySegmentImpl {\n@@ -63,11 +54,0 @@\n-    \/**\n-     * This constructor should only be used when initializing {@link MemorySegment#NULL}. Note: because of the memory\n-     * segment class hierarchy, it is possible to end up in a situation where this constructor is called\n-     * when the static fields in this class are not yet initialized.\n-     *\/\n-    @ForceInline\n-    public NativeMemorySegmentImpl() {\n-        super(0L, false, new GlobalSession(null));\n-        this.min = 0L;\n-    }\n-\n@@ -115,58 +95,0 @@\n-\n-    \/\/ factories\n-\n-    public static MemorySegment makeNativeSegment(long byteSize, long byteAlignment, MemorySessionImpl sessionImpl) {\n-        sessionImpl.checkValidState();\n-        if (VM.isDirectMemoryPageAligned()) {\n-            byteAlignment = Math.max(byteAlignment, NIO_ACCESS.pageSize());\n-        }\n-        long alignedSize = Math.max(1L, byteAlignment > MAX_MALLOC_ALIGN ?\n-                byteSize + (byteAlignment - 1) :\n-                byteSize);\n-\n-        NIO_ACCESS.reserveMemory(alignedSize, byteSize);\n-\n-        long buf = UNSAFE.allocateMemory(alignedSize);\n-        if (!SKIP_ZERO_MEMORY) {\n-            UNSAFE.setMemory(buf, alignedSize, (byte)0);\n-        }\n-        long alignedBuf = Utils.alignUp(buf, byteAlignment);\n-        AbstractMemorySegmentImpl segment = new NativeMemorySegmentImpl(buf, alignedSize,\n-                false, sessionImpl);\n-        sessionImpl.addOrCleanupIfFail(new MemorySessionImpl.ResourceList.ResourceCleanup() {\n-            @Override\n-            public void cleanup() {\n-                UNSAFE.freeMemory(buf);\n-                NIO_ACCESS.unreserveMemory(alignedSize, byteSize);\n-            }\n-        });\n-        if (alignedSize != byteSize) {\n-            long delta = alignedBuf - buf;\n-            segment = segment.asSlice(delta, byteSize);\n-        }\n-        return segment;\n-    }\n-\n-    \/\/ Unsafe native segment factories. These are used by the implementation code, to skip the sanity checks\n-    \/\/ associated with MemorySegment::ofAddress.\n-\n-    @ForceInline\n-    public static MemorySegment makeNativeSegmentUnchecked(long min, long byteSize, MemorySessionImpl sessionImpl, Runnable action) {\n-        if (action == null) {\n-            sessionImpl.checkValidState();\n-        } else {\n-            sessionImpl.addCloseAction(action);\n-        }\n-        return new NativeMemorySegmentImpl(min, byteSize, false, sessionImpl);\n-    }\n-\n-    @ForceInline\n-    public static MemorySegment makeNativeSegmentUnchecked(long min, long byteSize, MemorySessionImpl sessionImpl) {\n-        sessionImpl.checkValidState();\n-        return new NativeMemorySegmentImpl(min, byteSize, false, sessionImpl);\n-    }\n-\n-    @ForceInline\n-    public static MemorySegment makeNativeSegmentUnchecked(long min, long byteSize) {\n-        return new NativeMemorySegmentImpl(min, byteSize, false, new GlobalSession(null));\n-    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/NativeMemorySegmentImpl.java","additions":1,"deletions":79,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -0,0 +1,211 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.foreign;\n+\n+import jdk.internal.access.foreign.UnmapperProxy;\n+import jdk.internal.foreign.HeapMemorySegmentImpl.OfByte;\n+import jdk.internal.foreign.HeapMemorySegmentImpl.OfChar;\n+import jdk.internal.foreign.HeapMemorySegmentImpl.OfDouble;\n+import jdk.internal.foreign.HeapMemorySegmentImpl.OfFloat;\n+import jdk.internal.foreign.HeapMemorySegmentImpl.OfInt;\n+import jdk.internal.foreign.HeapMemorySegmentImpl.OfLong;\n+import jdk.internal.foreign.HeapMemorySegmentImpl.OfShort;\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.misc.VM;\n+import jdk.internal.vm.annotation.ForceInline;\n+\n+import java.lang.foreign.MemorySegment;\n+import java.util.Objects;\n+\n+\/**\n+ * This class is used to retrieve concrete memory segment implementations, while making sure that classes\n+ * are initialized in the right order (that is, that {@code MemorySegment} is always initialized first).\n+ * See {@link SegmentFactories#ensureInitialized()}.\n+ *\/\n+public class SegmentFactories {\n+\n+    \/\/ The maximum alignment supported by malloc - typically 16 bytes on\n+    \/\/ 64-bit platforms and 8 bytes on 32-bit platforms.\n+    private static final long MAX_MALLOC_ALIGN = Unsafe.ADDRESS_SIZE == 4 ? 8 : 16;\n+\n+    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+\n+    \/\/ Unsafe native segment factories. These are used by the implementation code, to skip the sanity checks\n+    \/\/ associated with MemorySegment::ofAddress.\n+\n+    @ForceInline\n+    public static MemorySegment makeNativeSegmentUnchecked(long min, long byteSize, MemorySessionImpl sessionImpl, Runnable action) {\n+        ensureInitialized();\n+        if (action == null) {\n+            sessionImpl.checkValidState();\n+        } else {\n+            sessionImpl.addCloseAction(action);\n+        }\n+        return new NativeMemorySegmentImpl(min, byteSize, false, sessionImpl);\n+    }\n+\n+    @ForceInline\n+    public static MemorySegment makeNativeSegmentUnchecked(long min, long byteSize, MemorySessionImpl sessionImpl) {\n+        ensureInitialized();\n+        sessionImpl.checkValidState();\n+        return new NativeMemorySegmentImpl(min, byteSize, false, sessionImpl);\n+    }\n+\n+    @ForceInline\n+    public static MemorySegment makeNativeSegmentUnchecked(long min, long byteSize) {\n+        ensureInitialized();\n+        return new NativeMemorySegmentImpl(min, byteSize, false, new GlobalSession(null));\n+    }\n+\n+    public static MemorySegment fromArray(byte[] arr) {\n+        ensureInitialized();\n+        Objects.requireNonNull(arr);\n+        long byteSize = (long)arr.length * Unsafe.ARRAY_BYTE_INDEX_SCALE;\n+        return new OfByte(Unsafe.ARRAY_BYTE_BASE_OFFSET, arr, byteSize, false,\n+                MemorySessionImpl.heapSession(arr));\n+    }\n+\n+    public static MemorySegment fromArray(short[] arr) {\n+        ensureInitialized();\n+        Objects.requireNonNull(arr);\n+        long byteSize = (long)arr.length * Unsafe.ARRAY_SHORT_INDEX_SCALE;\n+        return new OfShort(Unsafe.ARRAY_SHORT_BASE_OFFSET, arr, byteSize, false,\n+                MemorySessionImpl.heapSession(arr));\n+    }\n+\n+    public static MemorySegment fromArray(int[] arr) {\n+        ensureInitialized();\n+        Objects.requireNonNull(arr);\n+        long byteSize = (long)arr.length * Unsafe.ARRAY_INT_INDEX_SCALE;\n+        return new OfInt(Unsafe.ARRAY_INT_BASE_OFFSET, arr, byteSize, false,\n+                MemorySessionImpl.heapSession(arr));\n+    }\n+\n+    public static MemorySegment fromArray(char[] arr) {\n+        ensureInitialized();\n+        Objects.requireNonNull(arr);\n+        long byteSize = (long)arr.length * Unsafe.ARRAY_CHAR_INDEX_SCALE;\n+        return new OfChar(Unsafe.ARRAY_CHAR_BASE_OFFSET, arr, byteSize, false,\n+                MemorySessionImpl.heapSession(arr));\n+    }\n+\n+    public static MemorySegment fromArray(float[] arr) {\n+        ensureInitialized();\n+        Objects.requireNonNull(arr);\n+        long byteSize = (long)arr.length * Unsafe.ARRAY_FLOAT_INDEX_SCALE;\n+        return new OfFloat(Unsafe.ARRAY_FLOAT_BASE_OFFSET, arr, byteSize, false,\n+                MemorySessionImpl.heapSession(arr));\n+    }\n+\n+    public static MemorySegment fromArray(double[] arr) {\n+        ensureInitialized();\n+        Objects.requireNonNull(arr);\n+        long byteSize = (long)arr.length * Unsafe.ARRAY_DOUBLE_INDEX_SCALE;\n+        return new OfDouble(Unsafe.ARRAY_DOUBLE_BASE_OFFSET, arr, byteSize, false,\n+                MemorySessionImpl.heapSession(arr));\n+    }\n+\n+    public static MemorySegment fromArray(long[] arr) {\n+        ensureInitialized();\n+        Objects.requireNonNull(arr);\n+        long byteSize = (long)arr.length * Unsafe.ARRAY_LONG_INDEX_SCALE;\n+        return new OfLong(Unsafe.ARRAY_LONG_BASE_OFFSET, arr, byteSize, false,\n+                MemorySessionImpl.heapSession(arr));\n+    }\n+\n+    public static MemorySegment allocateSegment(long byteSize, long byteAlignment, MemorySessionImpl sessionImpl,\n+                                                  boolean shouldReserve) {\n+        ensureInitialized();\n+        sessionImpl.checkValidState();\n+        if (VM.isDirectMemoryPageAligned()) {\n+            byteAlignment = Math.max(byteAlignment, AbstractMemorySegmentImpl.NIO_ACCESS.pageSize());\n+        }\n+        long alignedSize = Math.max(1L, byteAlignment > MAX_MALLOC_ALIGN ?\n+                byteSize + (byteAlignment - 1) :\n+                byteSize);\n+\n+        if (shouldReserve) {\n+            AbstractMemorySegmentImpl.NIO_ACCESS.reserveMemory(alignedSize, byteSize);\n+        }\n+\n+        long buf = allocateMemoryWrapper(alignedSize);\n+        long alignedBuf = Utils.alignUp(buf, byteAlignment);\n+        AbstractMemorySegmentImpl segment = new NativeMemorySegmentImpl(buf, alignedSize,\n+                false, sessionImpl);\n+        sessionImpl.addOrCleanupIfFail(new MemorySessionImpl.ResourceList.ResourceCleanup() {\n+            @Override\n+            public void cleanup() {\n+                UNSAFE.freeMemory(buf);\n+                if (shouldReserve) {\n+                    AbstractMemorySegmentImpl.NIO_ACCESS.unreserveMemory(alignedSize, byteSize);\n+                }\n+            }\n+        });\n+        if (alignedSize != byteSize) {\n+            long delta = alignedBuf - buf;\n+            segment = segment.asSlice(delta, byteSize);\n+        }\n+        return segment;\n+    }\n+\n+    private static long allocateMemoryWrapper(long size) {\n+        try {\n+            return UNSAFE.allocateMemory(size);\n+        } catch (IllegalArgumentException ex) {\n+            throw new OutOfMemoryError();\n+        }\n+    }\n+\n+    public static MemorySegment mapSegment(long size, UnmapperProxy unmapper, boolean readOnly, MemorySessionImpl sessionImpl) {\n+        ensureInitialized();\n+        if (unmapper != null) {\n+            AbstractMemorySegmentImpl segment =\n+                    new MappedMemorySegmentImpl(unmapper.address(), unmapper, size,\n+                            readOnly, sessionImpl);\n+            MemorySessionImpl.ResourceList.ResourceCleanup resource =\n+                    new MemorySessionImpl.ResourceList.ResourceCleanup() {\n+                        @Override\n+                        public void cleanup() {\n+                            unmapper.unmap();\n+                        }\n+                    };\n+            sessionImpl.addOrCleanupIfFail(resource);\n+            return segment;\n+        } else {\n+            return new MappedMemorySegmentImpl(0, null, 0, readOnly, sessionImpl);\n+        }\n+    }\n+\n+    \/\/ The method below needs to be called before any concrete subclass of MemorySegment\n+    \/\/ is instantiated. This is to make sure that we cannot have an initialization deadlock\n+    \/\/ where one thread attempts to initialize e.g. MemorySegment (and then NativeMemorySegmentImpl, via\n+    \/\/ the MemorySegment.NULL field) while another thread is attempting to initialize\n+    \/\/ NativeMemorySegmentImpl (and then MemorySegment, the super-interface).\n+    @ForceInline\n+    private static void ensureInitialized() {\n+        MemorySegment segment = MemorySegment.NULL;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SegmentFactories.java","additions":211,"deletions":0,"binary":false,"changes":211,"status":"added"},{"patch":"@@ -34,1 +34,0 @@\n-    private final long maxAlign;\n@@ -40,1 +39,0 @@\n-        this.maxAlign = ((AbstractMemorySegmentImpl)segment).maxAlignMask();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SlicingAllocator.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,332 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.foreign;\n+\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.foreign.abi.SharedUtils;\n+import jdk.internal.util.ArraysSupport;\n+import sun.security.action.GetPropertyAction;\n+\n+import java.lang.foreign.MemorySegment;\n+import java.nio.charset.Charset;\n+\n+import static java.lang.foreign.ValueLayout.*;\n+\n+\/**\n+ * Miscellaneous functions to read and write strings, in various charsets.\n+ *\/\n+public class StringSupport {\n+\n+    static final JavaLangAccess JAVA_LANG_ACCESS = SharedSecrets.getJavaLangAccess();\n+\n+    private StringSupport() {}\n+\n+    public static String read(MemorySegment segment, long offset, Charset charset) {\n+        return switch (CharsetKind.of(charset)) {\n+            case SINGLE_BYTE -> readByte(segment, offset, charset);\n+            case DOUBLE_BYTE -> readShort(segment, offset, charset);\n+            case QUAD_BYTE -> readInt(segment, offset, charset);\n+        };\n+    }\n+\n+    public static void write(MemorySegment segment, long offset, Charset charset, String string) {\n+        switch (CharsetKind.of(charset)) {\n+            case SINGLE_BYTE -> writeByte(segment, offset, charset, string);\n+            case DOUBLE_BYTE -> writeShort(segment, offset, charset, string);\n+            case QUAD_BYTE -> writeInt(segment, offset, charset, string);\n+        }\n+    }\n+\n+    private static String readByte(MemorySegment segment, long offset, Charset charset) {\n+        long len = chunkedStrlenByte(segment, offset);\n+        byte[] bytes = new byte[(int)len];\n+        MemorySegment.copy(segment, JAVA_BYTE, offset, bytes, 0, (int)len);\n+        return new String(bytes, charset);\n+    }\n+\n+    private static void writeByte(MemorySegment segment, long offset, Charset charset, String string) {\n+        int bytes = copyBytes(string, segment, charset, offset);\n+        segment.set(JAVA_BYTE, offset + bytes, (byte)0);\n+    }\n+\n+    private static String readShort(MemorySegment segment, long offset, Charset charset) {\n+        long len = chunkedStrlenShort(segment, offset);\n+        byte[] bytes = new byte[(int)len];\n+        MemorySegment.copy(segment, JAVA_BYTE, offset, bytes, 0, (int)len);\n+        return new String(bytes, charset);\n+    }\n+\n+    private static void writeShort(MemorySegment segment, long offset, Charset charset, String string) {\n+        int bytes = copyBytes(string, segment, charset, offset);\n+        segment.set(JAVA_SHORT, offset + bytes, (short)0);\n+    }\n+\n+    private static String readInt(MemorySegment segment, long offset, Charset charset) {\n+        long len = strlenInt(segment, offset);\n+        byte[] bytes = new byte[(int)len];\n+        MemorySegment.copy(segment, JAVA_BYTE, offset, bytes, 0, (int)len);\n+        return new String(bytes, charset);\n+    }\n+\n+    private static void writeInt(MemorySegment segment, long offset, Charset charset, String string) {\n+        int bytes = copyBytes(string, segment, charset, offset);\n+        segment.set(JAVA_INT, offset + bytes, 0);\n+    }\n+\n+    \/**\n+     * {@return the shortest distance beginning at the provided {@code start}\n+     *  to the encountering of a zero byte in the provided {@code segment}}\n+     * <p>\n+     * The method divides the region of interest into three distinct regions:\n+     * <ul>\n+     *     <li>head (access made on a byte-by-byte basis) (if any)<\/li>\n+     *     <li>body (access made with eight bytes at a time at physically 64-bit-aligned memory) (if any)<\/li>\n+     *     <li>tail (access made on a byte-by-byte basis) (if any)<\/li>\n+     * <\/ul>\n+     * <p>\n+     * The body is using a heuristic method to determine if a long word\n+     * contains a zero byte. The method might have false positives but\n+     * never false negatives.\n+     * <p>\n+     * This method is inspired by the `glibc\/string\/strlen.c` implementation\n+     *\n+     * @param segment to examine\n+     * @param start   from where examination shall begin\n+     * @throws IllegalArgumentException if the examined region contains no zero bytes\n+     *                                  within a length that can be accepted by a String\n+     *\/\n+    public static int chunkedStrlenByte(MemorySegment segment, long start) {\n+\n+        \/\/ Handle the first unaligned \"head\" bytes separately\n+        int headCount = (int)SharedUtils.remainsToAlignment(segment.address() + start, Long.BYTES);\n+\n+        int offset = 0;\n+        for (; offset < headCount; offset++) {\n+            byte curr = segment.get(JAVA_BYTE, start + offset);\n+            if (curr == 0) {\n+                return offset;\n+            }\n+        }\n+\n+        \/\/ We are now on a long-aligned boundary so this is the \"body\"\n+        int bodyCount = bodyCount(segment.byteSize() - start - headCount);\n+\n+        for (; offset < bodyCount; offset += Long.BYTES) {\n+            \/\/ We know we are `long` aligned so, we can save on alignment checking here\n+            long curr = segment.get(JAVA_LONG_UNALIGNED, start + offset);\n+            \/\/ Is this a candidate?\n+            if (mightContainZeroByte(curr)) {\n+                for (int j = 0; j < 8; j++) {\n+                    if (segment.get(JAVA_BYTE, start + offset + j) == 0) {\n+                        return offset + j;\n+                    }\n+                }\n+            }\n+        }\n+\n+        \/\/ Handle the \"tail\"\n+        return requireWithinArraySize((long) offset + strlenByte(segment, start + offset));\n+    }\n+\n+    \/* Bits 63 and N * 8 (N = 1..7) of this number are zero.  Call these bits\n+       the \"holes\".  Note that there is a hole just to the left of\n+       each byte, with an extra at the end:\n+\n+       bits:  01111110 11111110 11111110 11111110 11111110 11111110 11111110 11111111\n+       bytes: AAAAAAAA BBBBBBBB CCCCCCCC DDDDDDDD EEEEEEEE FFFFFFFF GGGGGGGG HHHHHHHH\n+\n+       The 1-bits make sure that carries propagate to the next 0-bit.\n+       The 0-bits provide holes for carries to fall into.\n+    *\/\n+    private static final long HIMAGIC_FOR_BYTES = 0x8080_8080_8080_8080L;\n+    private static final long LOMAGIC_FOR_BYTES = 0x0101_0101_0101_0101L;\n+\n+    static boolean mightContainZeroByte(long l) {\n+        return ((l - LOMAGIC_FOR_BYTES) & (~l) & HIMAGIC_FOR_BYTES) != 0;\n+    }\n+\n+    private static final long HIMAGIC_FOR_SHORTS = 0x8000_8000_8000_8000L;\n+    private static final long LOMAGIC_FOR_SHORTS = 0x0001_0001_0001_0001L;\n+\n+    static boolean mightContainZeroShort(long l) {\n+        return ((l - LOMAGIC_FOR_SHORTS) & (~l) & HIMAGIC_FOR_SHORTS) != 0;\n+    }\n+\n+    static int requireWithinArraySize(long size) {\n+        if (size > ArraysSupport.SOFT_MAX_ARRAY_LENGTH) {\n+            throw newIaeStringTooLarge();\n+        }\n+        return (int) size;\n+    }\n+\n+    static int bodyCount(long remaining) {\n+        return (int) Math.min(\n+                \/\/ Make sure we do not wrap around\n+                Integer.MAX_VALUE - Long.BYTES,\n+                \/\/ Remaining bytes to consider\n+                remaining)\n+                & -Long.BYTES; \/\/ Mask 0xFFFFFFF8\n+    }\n+\n+    private static int strlenByte(MemorySegment segment, long start) {\n+        for (int offset = 0; offset < ArraysSupport.SOFT_MAX_ARRAY_LENGTH; offset += 1) {\n+            byte curr = segment.get(JAVA_BYTE, start + offset);\n+            if (curr == 0) {\n+                return offset;\n+            }\n+        }\n+        throw newIaeStringTooLarge();\n+    }\n+\n+    \/**\n+     * {@return the shortest distance beginning at the provided {@code start}\n+     *  to the encountering of a zero short in the provided {@code segment}}\n+     * <p>\n+     * Note: The inspected region must be short aligned.\n+     *\n+     * @see #chunkedStrlenByte(MemorySegment, long) for more information\n+     *\n+     * @param segment to examine\n+     * @param start   from where examination shall begin\n+     * @throws IllegalArgumentException if the examined region contains no zero shorts\n+     *                                  within a length that can be accepted by a String\n+     *\/\n+    public static int chunkedStrlenShort(MemorySegment segment, long start) {\n+\n+        \/\/ Handle the first unaligned \"head\" bytes separately\n+        int headCount = (int)SharedUtils.remainsToAlignment(segment.address() + start, Long.BYTES);\n+\n+        int offset = 0;\n+        for (; offset < headCount; offset += Short.BYTES) {\n+            short curr = segment.get(JAVA_SHORT, start + offset);\n+            if (curr == 0) {\n+                return offset;\n+            }\n+        }\n+\n+        \/\/ We are now on a long-aligned boundary so this is the \"body\"\n+        int bodyCount = bodyCount(segment.byteSize() - start - headCount);\n+\n+        for (; offset < bodyCount; offset += Long.BYTES) {\n+            \/\/ We know we are `long` aligned so, we can save on alignment checking here\n+            long curr = segment.get(JAVA_LONG_UNALIGNED, start + offset);\n+            \/\/ Is this a candidate?\n+            if (mightContainZeroShort(curr)) {\n+                for (int j = 0; j < Long.BYTES; j += Short.BYTES) {\n+                    if (segment.get(JAVA_SHORT_UNALIGNED, start + offset + j) == 0) {\n+                        return offset + j;\n+                    }\n+                }\n+            }\n+        }\n+\n+        \/\/ Handle the \"tail\"\n+        return requireWithinArraySize((long) offset + strlenShort(segment, start + offset));\n+    }\n+\n+    private static int strlenShort(MemorySegment segment, long start) {\n+        for (int offset = 0; offset < ArraysSupport.SOFT_MAX_ARRAY_LENGTH; offset += Short.BYTES) {\n+            short curr = segment.get(JAVA_SHORT_UNALIGNED, start + offset);\n+            if (curr == (short)0) {\n+                return offset;\n+            }\n+        }\n+        throw newIaeStringTooLarge();\n+    }\n+\n+    \/\/ The gain of using `long` wide operations for `int` is lower than for the two other `byte` and `short` variants\n+    \/\/ so, there is only one method for ints.\n+    public static int strlenInt(MemorySegment segment, long start) {\n+        for (int offset = 0; offset < ArraysSupport.SOFT_MAX_ARRAY_LENGTH; offset += Integer.BYTES) {\n+            \/\/ We are guaranteed to be aligned here so, we can use unaligned access.\n+            int curr = segment.get(JAVA_INT_UNALIGNED, start + offset);\n+            if (curr == 0) {\n+                return offset;\n+            }\n+        }\n+        throw newIaeStringTooLarge();\n+    }\n+\n+    public enum CharsetKind {\n+        SINGLE_BYTE(1),\n+        DOUBLE_BYTE(2),\n+        QUAD_BYTE(4);\n+\n+        final int terminatorCharSize;\n+\n+        CharsetKind(int terminatorCharSize) {\n+            this.terminatorCharSize = terminatorCharSize;\n+        }\n+\n+        public int terminatorCharSize() {\n+            return terminatorCharSize;\n+        }\n+\n+        public static CharsetKind of(Charset charset) {\n+            \/\/ Comparing the charset to specific internal implementations avoids loading the class `StandardCharsets`\n+            if        (charset == sun.nio.cs.UTF_8.INSTANCE ||\n+                       charset == sun.nio.cs.ISO_8859_1.INSTANCE ||\n+                       charset == sun.nio.cs.US_ASCII.INSTANCE) {\n+                return SINGLE_BYTE;\n+            } else if (charset instanceof sun.nio.cs.UTF_16LE ||\n+                       charset instanceof sun.nio.cs.UTF_16BE ||\n+                       charset instanceof sun.nio.cs.UTF_16) {\n+                return DOUBLE_BYTE;\n+            } else if (charset instanceof sun.nio.cs.UTF_32LE ||\n+                       charset instanceof sun.nio.cs.UTF_32BE ||\n+                       charset instanceof sun.nio.cs.UTF_32) {\n+                return QUAD_BYTE;\n+            } else {\n+                throw new IllegalArgumentException(\"Unsupported charset: \" + charset);\n+            }\n+        }\n+    }\n+\n+    public static boolean bytesCompatible(String string, Charset charset) {\n+        return JAVA_LANG_ACCESS.bytesCompatible(string, charset);\n+    }\n+\n+    public static int copyBytes(String string, MemorySegment segment, Charset charset, long offset) {\n+        if (bytesCompatible(string, charset)) {\n+            copyToSegmentRaw(string, segment, offset);\n+            return string.length();\n+        } else {\n+            byte[] bytes = string.getBytes(charset);\n+            MemorySegment.copy(bytes, 0, segment, JAVA_BYTE, offset, bytes.length);\n+            return bytes.length;\n+        }\n+    }\n+\n+    public static void copyToSegmentRaw(String string, MemorySegment segment, long offset) {\n+        JAVA_LANG_ACCESS.copyToSegmentRaw(string, segment, offset);\n+    }\n+\n+    private static IllegalArgumentException newIaeStringTooLarge() {\n+        return new IllegalArgumentException(\"String too large\");\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/StringSupport.java","additions":332,"deletions":0,"binary":false,"changes":332,"status":"added"},{"patch":"@@ -32,1 +32,0 @@\n-import java.lang.foreign.SegmentAllocator;\n@@ -50,1 +49,0 @@\n-import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n@@ -101,0 +99,4 @@\n+\n+            static VarHandle get(ValueLayout layout) {\n+                return HANDLE_MAP.get(layout);\n+            }\n@@ -102,0 +104,8 @@\n+        layout = layout.withoutName(); \/\/ name doesn't matter\n+        \/\/ keep the addressee layout as it's used below\n+\n+        VarHandle handle = VarHandleCache.get(layout);\n+        if (handle != null) {\n+            return handle;\n+        }\n+\n@@ -113,1 +123,1 @@\n-        VarHandle handle = SharedSecrets.getJavaLangInvokeAccess().memorySegmentViewHandle(baseCarrier,\n+        handle = SharedSecrets.getJavaLangInvokeAccess().memorySegmentViewHandle(baseCarrier,\n@@ -139,1 +149,1 @@\n-            throw new IllegalArgumentException(\"Invalid alignment constraint for address: \" + addr);\n+            throw new IllegalArgumentException(\"Invalid alignment constraint for address: \" + toHexString(addr));\n@@ -141,1 +151,1 @@\n-        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(addr, size);\n+        return SegmentFactories.makeNativeSegmentUnchecked(addr, size);\n@@ -147,1 +157,1 @@\n-            throw new IllegalArgumentException(\"Invalid alignment constraint for address: \" + addr);\n+            throw new IllegalArgumentException(\"Invalid alignment constraint for address: \" + toHexString(addr));\n@@ -149,13 +159,1 @@\n-        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(addr, size, scope);\n-    }\n-\n-    public static void copy(MemorySegment addr, byte[] bytes) {\n-        var heapSegment = MemorySegment.ofArray(bytes);\n-        addr.copyFrom(heapSegment);\n-        addr.set(JAVA_BYTE, bytes.length, (byte)0);\n-    }\n-\n-    public static MemorySegment toCString(byte[] bytes, SegmentAllocator allocator) {\n-        MemorySegment addr = allocator.allocate(bytes.length + 1);\n-        copy(addr, bytes);\n-        return addr;\n+        return SegmentFactories.makeNativeSegmentUnchecked(addr, size, scope);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/Utils.java","additions":17,"deletions":19,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+import java.util.HashSet;\n@@ -76,0 +77,1 @@\n+    private final Set<MemoryLayout> CANONICAL_LAYOUTS_CACHE = new HashSet<>(canonicalLayouts().values());\n@@ -216,1 +218,1 @@\n-    private static void checkGroupSize(GroupLayout gl, long maxUnpaddedOffset) {\n+    private void checkGroupSize(GroupLayout gl, long maxUnpaddedOffset) {\n@@ -226,1 +228,1 @@\n-    private static void checkMemberOffset(StructLayout parent, MemoryLayout memberLayout,\n+    private void checkMemberOffset(StructLayout parent, MemoryLayout memberLayout,\n@@ -235,1 +237,1 @@\n-    private static void checkSupported(ValueLayout valueLayout) {\n+    private void checkSupported(ValueLayout valueLayout) {\n@@ -240,1 +242,1 @@\n-        if (!SUPPORTED_LAYOUTS.contains(valueLayout.withoutName())) {\n+        if (!CANONICAL_LAYOUTS_CACHE.contains(valueLayout.withoutName())) {\n@@ -245,1 +247,1 @@\n-    private static void checkHasNaturalAlignment(MemoryLayout layout) {\n+    private void checkHasNaturalAlignment(MemoryLayout layout) {\n@@ -276,12 +278,0 @@\n-\n-    private static final Set<MemoryLayout> SUPPORTED_LAYOUTS = Set.of(\n-            ValueLayout.JAVA_BOOLEAN,\n-            ValueLayout.JAVA_BYTE,\n-            ValueLayout.JAVA_CHAR,\n-            ValueLayout.JAVA_SHORT,\n-            ValueLayout.JAVA_INT,\n-            ValueLayout.JAVA_FLOAT,\n-            ValueLayout.JAVA_LONG,\n-            ValueLayout.JAVA_DOUBLE,\n-            ValueLayout.ADDRESS\n-    );\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/AbstractLinker.java","additions":7,"deletions":17,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -467,1 +467,1 @@\n-            storeFunc.store(storage(), type(), stack.pop());\n+            storeFunc.store(storage(), stack.pop());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/Binding.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,2 +52,2 @@\n-    interface StoreFunc {\n-        void store(VMStorage storage, Class<?> type, Object o);\n+    public interface StoreFunc {\n+        void store(VMStorage storage, Object o);\n@@ -57,1 +57,1 @@\n-    interface LoadFunc {\n+    public interface LoadFunc {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/BindingInterpreter.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -195,1 +195,1 @@\n-        return !linkerOptions.isTrivial();\n+        return !linkerOptions.isCritical();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/CallingSequence.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.lang.foreign.AddressLayout;\n@@ -37,0 +38,1 @@\n+import java.util.ArrayList;\n@@ -38,0 +40,1 @@\n+import java.util.List;\n@@ -41,0 +44,3 @@\n+import jdk.internal.foreign.AbstractMemorySegmentImpl;\n+import jdk.internal.foreign.MemorySessionImpl;\n+\n@@ -96,1 +102,0 @@\n-            Map<VMStorage, Integer> retIndexMap = SharedUtils.indexMap(retMoves);\n@@ -98,1 +103,1 @@\n-            InvocationData invData = new InvocationData(handle, argIndexMap, retIndexMap);\n+            InvocationData invData = new InvocationData(handle, callingSequence, argIndexMap);\n@@ -149,1 +154,1 @@\n-    private record InvocationData(MethodHandle leaf, Map<VMStorage, Integer> argIndexMap, Map<VMStorage, Integer> retIndexMap) {}\n+    private record InvocationData(MethodHandle leaf, CallingSequence callingSequence, Map<VMStorage, Integer> argIndexMap) {}\n@@ -155,0 +160,1 @@\n+        List<MemorySessionImpl> acquiredScopes = new ArrayList<>();\n@@ -159,1 +165,0 @@\n-            Object[] leafArgs = new Object[invData.leaf.type().parameterCount()];\n@@ -168,0 +173,2 @@\n+\n+            Object[] leafArgs = new Object[invData.leaf.type().parameterCount()];\n@@ -170,0 +177,9 @@\n+                if (callingSequence.functionDesc().argumentLayouts().get(i) instanceof AddressLayout) {\n+                    MemorySessionImpl sessionImpl = ((AbstractMemorySegmentImpl) arg).sessionImpl();\n+                    if (!(callingSequence.needsReturnBuffer() && i == 0)) { \/\/ don't acquire unboxArena's scope\n+                        sessionImpl.acquire0();\n+                        \/\/ add this scope _after_ we acquire, so we only release scopes we actually acquired\n+                        \/\/ in case an exception occurs\n+                        acquiredScopes.add(sessionImpl);\n+                    }\n+                }\n@@ -171,1 +187,1 @@\n-                        (storage, type, value) -> leafArgs[invData.argIndexMap.get(storage)] = value, unboxArena);\n+                    (storage, value) -> leafArgs[invData.argIndexMap.get(storage)] = value, unboxArena);\n@@ -197,0 +213,4 @@\n+        } finally {\n+            for (MemorySessionImpl sessionImpl : acquiredScopes) {\n+                sessionImpl.release0();\n+            }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/DowncallLinker.java","additions":25,"deletions":5,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -66,1 +66,5 @@\n-        return new LinkerOptions(optionMap);\n+        LinkerOptions linkerOptions = new LinkerOptions(optionMap);\n+        if (linkerOptions.hasCapturedCallState() && linkerOptions.isCritical()) {\n+            throw new IllegalArgumentException(\"Incompatible linker options: captureCallState, critical\");\n+        }\n+        return linkerOptions;\n@@ -100,3 +104,3 @@\n-    public boolean isTrivial() {\n-        IsTrivial it = getOption(IsTrivial.class);\n-        return it != null;\n+    public boolean isCritical() {\n+        Critical c = getOption(Critical.class);\n+        return c != null;\n@@ -118,1 +122,1 @@\n-            permits CaptureCallState, FirstVariadicArg, IsTrivial {\n+            permits CaptureCallState, FirstVariadicArg, Critical {\n@@ -144,2 +148,2 @@\n-    public record IsTrivial() implements LinkerOptionImpl {\n-        public static IsTrivial INSTANCE = new IsTrivial();\n+    public record Critical() implements LinkerOptionImpl {\n+        public static Critical INSTANCE = new Critical();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/LinkerOptions.java","additions":11,"deletions":7,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -57,1 +57,0 @@\n-import java.lang.invoke.VarHandle;\n@@ -60,1 +59,0 @@\n-import java.nio.charset.StandardCharsets;\n@@ -86,1 +84,1 @@\n-            .withTargetLayout(MemoryLayout.sequenceLayout(JAVA_BYTE));\n+            .withTargetLayout(MemoryLayout.sequenceLayout(Long.MAX_VALUE, JAVA_BYTE));\n@@ -95,1 +93,1 @@\n-        public MemorySegment allocate(long byteSize) {\n+        public MemorySegment allocate(long byteSize, long byteAlignment) {\n@@ -132,0 +130,4 @@\n+    public static long remainsToAlignment(long addr, long alignment) {\n+        return alignUp(addr, alignment) - addr;\n+    }\n+\n@@ -254,18 +256,0 @@\n-    public static String toJavaStringInternal(MemorySegment segment, long start) {\n-        int len = strlen(segment, start);\n-        byte[] bytes = new byte[len];\n-        MemorySegment.copy(segment, JAVA_BYTE, start, bytes, 0, len);\n-        return new String(bytes, StandardCharsets.UTF_8);\n-    }\n-\n-    private static int strlen(MemorySegment segment, long start) {\n-        \/\/ iterate until overflow (String can only hold a byte[], whose length can be expressed as an int)\n-        for (int offset = 0; offset >= 0; offset++) {\n-            byte curr = segment.get(JAVA_BYTE, start + offset);\n-            if (curr == 0) {\n-                return offset;\n-            }\n-        }\n-        throw new IllegalArgumentException(\"String too large\");\n-    }\n-\n@@ -437,14 +421,0 @@\n-    public static final class SimpleVaArg {\n-        public final MemoryLayout layout;\n-        public final Object value;\n-\n-        public SimpleVaArg(MemoryLayout layout, Object value) {\n-            this.layout = layout;\n-            this.value = value;\n-        }\n-\n-        public VarHandle varHandle() {\n-            return layout.varHandle();\n-        }\n-    }\n-\n@@ -518,0 +488,31 @@\n+\n+    public static Map<String, MemoryLayout> canonicalLayouts(ValueLayout longLayout, ValueLayout sizetLayout, ValueLayout wchartLayout) {\n+        return Map.ofEntries(\n+                \/\/ specified canonical layouts\n+                Map.entry(\"bool\", ValueLayout.JAVA_BOOLEAN),\n+                Map.entry(\"char\", ValueLayout.JAVA_BYTE),\n+                Map.entry(\"short\", ValueLayout.JAVA_SHORT),\n+                Map.entry(\"int\", ValueLayout.JAVA_INT),\n+                Map.entry(\"float\", ValueLayout.JAVA_FLOAT),\n+                Map.entry(\"long\", longLayout),\n+                Map.entry(\"long long\", ValueLayout.JAVA_LONG),\n+                Map.entry(\"double\", ValueLayout.JAVA_DOUBLE),\n+                Map.entry(\"void*\", ValueLayout.ADDRESS),\n+                Map.entry(\"size_t\", sizetLayout),\n+                Map.entry(\"wchar_t\", wchartLayout),\n+                \/\/ unspecified size-dependent layouts\n+                Map.entry(\"int8_t\", ValueLayout.JAVA_BYTE),\n+                Map.entry(\"int16_t\", ValueLayout.JAVA_SHORT),\n+                Map.entry(\"int32_t\", ValueLayout.JAVA_INT),\n+                Map.entry(\"int64_t\", ValueLayout.JAVA_LONG),\n+                \/\/ unspecified JNI layouts\n+                Map.entry(\"jboolean\", ValueLayout.JAVA_BOOLEAN),\n+                Map.entry(\"jchar\", ValueLayout.JAVA_CHAR),\n+                Map.entry(\"jbyte\", ValueLayout.JAVA_BYTE),\n+                Map.entry(\"jshort\", ValueLayout.JAVA_SHORT),\n+                Map.entry(\"jint\", ValueLayout.JAVA_INT),\n+                Map.entry(\"jlong\", ValueLayout.JAVA_LONG),\n+                Map.entry(\"jfloat\", ValueLayout.JAVA_FLOAT),\n+                Map.entry(\"jdouble\", ValueLayout.JAVA_DOUBLE)\n+        );\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":37,"deletions":36,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -180,1 +180,1 @@\n-                        (storage, type, value) -> returnValues[invData.retIndexMap.get(storage)] = value, null);\n+                        (storage, value) -> returnValues[invData.retIndexMap.get(storage)] = value, null);\n@@ -190,6 +190,1 @@\n-                Binding.VMStore[] retMoves = invData.callingSequence.returnBindings().stream()\n-                        .filter(Binding.VMStore.class::isInstance)\n-                        .map(Binding.VMStore.class::cast)\n-                        .toArray(Binding.VMStore[]::new);\n-\n-                assert returnValues.length == retMoves.length;\n+                assert returnValues.length == invData.retMoves().length;\n@@ -197,2 +192,2 @@\n-                for (int i = 0; i < retMoves.length; i++) {\n-                    Binding.VMStore store = retMoves[i];\n+                for (int i = 0; i < invData.retMoves().length; i++) {\n+                    Binding.VMStore store = invData.retMoves()[i];\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/UpcallLinker.java","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import jdk.internal.foreign.Utils;\n@@ -39,1 +40,1 @@\n-            throw new IllegalStateException(\"Not a stub address: \" + stubAddress);\n+            throw new IllegalStateException(\"Not a stub address: \" + Utils.toHexString(stubAddress));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/UpcallStubs.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.foreign.abi.SharedUtils;\n@@ -33,0 +34,2 @@\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.ValueLayout;\n@@ -36,0 +39,1 @@\n+import java.util.Map;\n@@ -43,0 +47,3 @@\n+    static final Map<String, MemoryLayout> CANONICAL_LAYOUTS =\n+            SharedUtils.canonicalLayouts(ValueLayout.JAVA_LONG, ValueLayout.JAVA_LONG, ValueLayout.JAVA_INT);\n+\n@@ -69,0 +76,5 @@\n+\n+    @Override\n+    public Map<String, MemoryLayout> canonicalLayouts() {\n+        return CANONICAL_LAYOUTS;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64Linker.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.foreign.abi.SharedUtils;\n@@ -33,0 +34,2 @@\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.ValueLayout;\n@@ -36,0 +39,1 @@\n+import java.util.Map;\n@@ -43,0 +47,3 @@\n+    static final Map<String, MemoryLayout> CANONICAL_LAYOUTS =\n+            SharedUtils.canonicalLayouts(ValueLayout.JAVA_LONG, ValueLayout.JAVA_LONG, ValueLayout.JAVA_INT);\n+\n@@ -69,0 +76,5 @@\n+\n+    @Override\n+    public Map<String, MemoryLayout> canonicalLayouts() {\n+        return CANONICAL_LAYOUTS;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64Linker.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import jdk.internal.foreign.abi.SharedUtils;\n@@ -34,0 +35,2 @@\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.ValueLayout;\n@@ -37,0 +40,1 @@\n+import java.util.Map;\n@@ -43,0 +47,3 @@\n+\n+    static final Map<String, MemoryLayout> CANONICAL_LAYOUTS =\n+            SharedUtils.canonicalLayouts(ValueLayout.JAVA_INT, ValueLayout.JAVA_LONG, ValueLayout.JAVA_CHAR);\n@@ -66,0 +73,5 @@\n+\n+    @Override\n+    public Map<String, MemoryLayout> canonicalLayouts() {\n+        return CANONICAL_LAYOUTS;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/windows\/WindowsAArch64Linker.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-import java.util.Comparator;\n@@ -47,0 +46,1 @@\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n@@ -61,5 +61,1 @@\n-    private static final ValueLayout SIZE_T = switch ((int) ADDRESS.byteSize()) {\n-            case 8 -> JAVA_LONG;\n-            case 4 -> JAVA_INT;\n-            default -> throw new IllegalStateException(\"Address size not supported: \" + ADDRESS.byteSize());\n-        };\n+    static final ValueLayout SIZE_T = layoutFor((int)ADDRESS.byteSize());\n@@ -72,1 +68,1 @@\n-    private static final VarHandle VH_SIZE_T_ARRAY = SIZE_T.arrayElementVarHandle();\n+    private static final VarHandle VH_SIZE_T = SIZE_T.varHandle();\n@@ -86,2 +82,2 @@\n-        VH_TYPE.set(ffiType, LibFallback.structTag());\n-        VH_ELEMENTS.set(ffiType, elementsSeg);\n+        VH_TYPE.set(ffiType, 0L, LibFallback.structTag());\n+        VH_ELEMENTS.set(ffiType, 0L, elementsSeg);\n@@ -135,1 +131,1 @@\n-                    long ffiOffset = (long) VH_SIZE_T_ARRAY.get(offsetsOut, offsetIdx++);\n+                    long ffiOffset = sizeTAtIndex(offsetsOut, offsetIdx++);\n@@ -146,0 +142,19 @@\n+\n+    static ValueLayout layoutFor(int byteSize) {\n+        return switch (byteSize) {\n+            case 1 -> JAVA_BYTE;\n+            case 2 -> JAVA_SHORT;\n+            case 4 -> JAVA_INT;\n+            case 8 -> JAVA_LONG;\n+            default -> throw new IllegalStateException(\"Unsupported size: \" + byteSize);\n+        };\n+    }\n+\n+    private static long sizeTAtIndex(MemorySegment segment, int index) {\n+        long offset = SIZE_T.scale(0, index);\n+        if (VH_SIZE_T.varType() == long.class) {\n+            return (long) VH_SIZE_T.get(segment, offset);\n+        } else {\n+            return (int) VH_SIZE_T.get(segment, offset); \/\/ 'erase' to long\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/fallback\/FFIType.java","additions":25,"deletions":10,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+import java.util.Map;\n@@ -52,0 +53,8 @@\n+import static java.lang.foreign.ValueLayout.JAVA_BOOLEAN;\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n+import static java.lang.foreign.ValueLayout.JAVA_CHAR;\n+import static java.lang.foreign.ValueLayout.JAVA_DOUBLE;\n+import static java.lang.foreign.ValueLayout.JAVA_FLOAT;\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n+import static java.lang.foreign.ValueLayout.JAVA_LONG;\n+import static java.lang.foreign.ValueLayout.JAVA_SHORT;\n@@ -286,0 +295,43 @@\n+\n+    @Override\n+    public Map<String, MemoryLayout> canonicalLayouts() {\n+        \/\/ Avoid eager dependency on LibFallback, so we can safely check LibFallback.SUPPORTED\n+        class Holder {\n+            static final Map<String, MemoryLayout> CANONICAL_LAYOUTS;\n+\n+            static {\n+                int wchar_size = LibFallback.wcharSize();\n+                MemoryLayout wchartLayout = switch(wchar_size) {\n+                    case 2 -> JAVA_CHAR; \/\/ prefer JAVA_CHAR\n+                    default -> FFIType.layoutFor(wchar_size);\n+                };\n+\n+                CANONICAL_LAYOUTS = Map.ofEntries(\n+                    \/\/ specified canonical layouts\n+                    Map.entry(\"bool\", JAVA_BOOLEAN),\n+                    Map.entry(\"char\", JAVA_BYTE),\n+                    Map.entry(\"float\", JAVA_FLOAT),\n+                    Map.entry(\"long long\", JAVA_LONG),\n+                    Map.entry(\"double\", JAVA_DOUBLE),\n+                    Map.entry(\"void*\", ADDRESS),\n+                    \/\/ platform-dependent sizes\n+                    Map.entry(\"size_t\", FFIType.SIZE_T),\n+                    Map.entry(\"short\", FFIType.layoutFor(LibFallback.shortSize())),\n+                    Map.entry(\"int\", FFIType.layoutFor(LibFallback.intSize())),\n+                    Map.entry(\"long\", FFIType.layoutFor(LibFallback.longSize())),\n+                    Map.entry(\"wchar_t\", wchartLayout),\n+                    \/\/ JNI types\n+                    Map.entry(\"jboolean\", JAVA_BOOLEAN),\n+                    Map.entry(\"jchar\", JAVA_CHAR),\n+                    Map.entry(\"jbyte\", JAVA_BYTE),\n+                    Map.entry(\"jshort\", JAVA_SHORT),\n+                    Map.entry(\"jint\", JAVA_INT),\n+                    Map.entry(\"jlong\", JAVA_LONG),\n+                    Map.entry(\"jfloat\", JAVA_FLOAT),\n+                    Map.entry(\"jdouble\", JAVA_DOUBLE)\n+                );\n+            }\n+        }\n+\n+        return Holder.CANONICAL_LAYOUTS;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/fallback\/FallbackLinker.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -68,0 +68,6 @@\n+    \/\/ platform-dependent types\n+    static int shortSize() { return NativeConstants.SIZEOF_SHORT; }\n+    static int intSize() { return NativeConstants.SIZEOF_INT; }\n+    static int longSize() {return NativeConstants.SIZEOF_LONG; }\n+    static int wcharSize() {return NativeConstants.SIZEOF_WCHAR; }\n+\n@@ -225,0 +231,4 @@\n+    private static native int ffi_sizeof_short();\n+    private static native int ffi_sizeof_int();\n+    private static native int ffi_sizeof_long();\n+    private static native int ffi_sizeof_wchar();\n@@ -242,0 +252,5 @@\n+        static final int SIZEOF_SHORT = ffi_sizeof_short();\n+        static final int SIZEOF_INT = ffi_sizeof_int();\n+        static final int SIZEOF_LONG = ffi_sizeof_long();\n+        static final int SIZEOF_WCHAR = ffi_sizeof_wchar();\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/fallback\/LibFallback.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.foreign.abi.SharedUtils;\n@@ -33,0 +34,2 @@\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.ValueLayout;\n@@ -36,0 +39,1 @@\n+import java.util.Map;\n@@ -39,0 +43,3 @@\n+    static final Map<String, MemoryLayout> CANONICAL_LAYOUTS =\n+        SharedUtils.canonicalLayouts(ValueLayout.JAVA_LONG, ValueLayout.JAVA_LONG, ValueLayout.JAVA_INT);\n+\n@@ -65,0 +72,5 @@\n+\n+    @Override\n+    public Map<String, MemoryLayout> canonicalLayouts() {\n+        return CANONICAL_LAYOUTS;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/ppc64\/linux\/LinuxPPC64Linker.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.foreign.abi.SharedUtils;\n@@ -33,0 +34,2 @@\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.ValueLayout;\n@@ -36,0 +39,1 @@\n+import java.util.Map;\n@@ -39,0 +43,3 @@\n+    static final Map<String, MemoryLayout> CANONICAL_LAYOUTS =\n+            SharedUtils.canonicalLayouts(ValueLayout.JAVA_LONG, ValueLayout.JAVA_LONG, ValueLayout.JAVA_INT);\n+\n@@ -65,0 +72,5 @@\n+\n+    @Override\n+    public Map<String, MemoryLayout> canonicalLayouts() {\n+        return CANONICAL_LAYOUTS;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/ppc64\/linux\/LinuxPPC64leLinker.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import jdk.internal.foreign.abi.SharedUtils;\n@@ -35,0 +36,2 @@\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.ValueLayout;\n@@ -38,0 +41,1 @@\n+import java.util.Map;\n@@ -41,0 +45,3 @@\n+    static final Map<String, MemoryLayout> CANONICAL_LAYOUTS =\n+            SharedUtils.canonicalLayouts(ValueLayout.JAVA_LONG, ValueLayout.JAVA_LONG, ValueLayout.JAVA_INT);\n+\n@@ -67,0 +74,5 @@\n+\n+    @Override\n+    public Map<String, MemoryLayout> canonicalLayouts() {\n+        return CANONICAL_LAYOUTS;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/riscv64\/linux\/LinuxRISCV64Linker.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.foreign.abi.SharedUtils;\n@@ -32,0 +33,2 @@\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.ValueLayout;\n@@ -35,0 +38,1 @@\n+import java.util.Map;\n@@ -38,0 +42,3 @@\n+    private static final Map<String, MemoryLayout> CANONICAL_LAYOUTS =\n+            SharedUtils.canonicalLayouts(ValueLayout.JAVA_LONG, ValueLayout.JAVA_LONG, ValueLayout.JAVA_INT);\n+\n@@ -64,0 +71,5 @@\n+\n+    @Override\n+    public Map<String, MemoryLayout> canonicalLayouts() {\n+        return CANONICAL_LAYOUTS;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/s390\/linux\/LinuxS390Linker.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.foreign.abi.SharedUtils;\n@@ -32,0 +33,2 @@\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.ValueLayout;\n@@ -35,0 +38,1 @@\n+import java.util.Map;\n@@ -41,0 +45,3 @@\n+    static final Map<String, MemoryLayout> CANONICAL_LAYOUTS =\n+            SharedUtils.canonicalLayouts(ValueLayout.JAVA_LONG, ValueLayout.JAVA_LONG, ValueLayout.JAVA_INT);\n+\n@@ -67,0 +74,5 @@\n+\n+    @Override\n+    public Map<String, MemoryLayout> canonicalLayouts() {\n+        return CANONICAL_LAYOUTS;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVx64Linker.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.foreign.abi.SharedUtils;\n@@ -31,0 +32,2 @@\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.ValueLayout;\n@@ -34,0 +37,1 @@\n+import java.util.Map;\n@@ -40,0 +44,3 @@\n+    static final Map<String, MemoryLayout> CANONICAL_LAYOUTS =\n+            SharedUtils.canonicalLayouts(ValueLayout.JAVA_INT, ValueLayout.JAVA_LONG, ValueLayout.JAVA_CHAR);\n+\n@@ -66,0 +73,5 @@\n+\n+    @Override\n+    public Map<String, MemoryLayout> canonicalLayouts() {\n+        return CANONICAL_LAYOUTS;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/Windowsx64Linker.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -42,2 +42,0 @@\n- *\n- * @since 19\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/AbstractGroupLayout.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+    @SuppressWarnings(\"unchecked\")\n@@ -57,1 +58,1 @@\n-        return dup(byteAlignment(), Optional.empty());\n+        return name.isPresent() ? dup(byteAlignment(), Optional.empty()) : (L) this;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/AbstractLayout.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import sun.invoke.util.Wrapper;\n@@ -36,0 +35,1 @@\n+import java.lang.foreign.AddressLayout;\n@@ -38,1 +38,0 @@\n-import java.lang.foreign.AddressLayout;\n@@ -42,2 +41,0 @@\n-import java.util.ArrayList;\n-import java.util.List;\n@@ -118,18 +115,0 @@\n-        public final VarHandle arrayElementVarHandle(int... shape) {\n-            Objects.requireNonNull(shape);\n-            if (!Utils.isElementAligned((ValueLayout) this)) {\n-                throw new UnsupportedOperationException(\"Layout alignment greater than its size\");\n-            }\n-            MemoryLayout layout = self();\n-            List<MemoryLayout.PathElement> path = new ArrayList<>();\n-            for (int i = shape.length; i > 0; i--) {\n-                int size = shape[i - 1];\n-                if (size < 0) throw new IllegalArgumentException(\"Invalid shape size: \" + size);\n-                layout = MemoryLayout.sequenceLayout(size, layout);\n-                path.add(MemoryLayout.PathElement.sequenceElement());\n-            }\n-            layout = MemoryLayout.sequenceLayout(layout);\n-            path.add(MemoryLayout.PathElement.sequenceElement());\n-            return layout.varHandle(path.toArray(new MemoryLayout.PathElement[0]));\n-        }\n-\n@@ -180,1 +159,1 @@\n-        public final VarHandle accessHandle() {\n+        public final VarHandle varHandle() {\n@@ -396,1 +375,1 @@\n-     *     <li>{@link ValueLayout.OfAddress}, for {@code MemorySegment.class}<\/li>\n+     *     <li>{@link AddressLayout}, for {@code MemorySegment.class}<\/li>\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/ValueLayouts.java","additions":3,"deletions":24,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -4598,1 +4598,1 @@\n-        if (0 > count || objects.length < (objectStart+count)) {\n+        if (0 > count || objects.length - count < objectStart) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/icu\/text\/BidiBase.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-        \/\/ not used\n+        \/\/ not used, but required for interim javac to not warn.\n@@ -69,1 +69,0 @@\n-        @JEP(number=442, title=\"Foreign Function & Memory API\", status=\"Third Preview\")\n@@ -71,0 +70,1 @@\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/javac\/PreviewFeature.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -151,0 +151,1 @@\n+    @Stable\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/VM.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -137,0 +137,7 @@\n+    \/**\n+     * Adds native access to all unnamed modules.\n+     *\/\n+    public static void addEnableNativeAccessToAllUnnamed() {\n+        JLA.addEnableNativeAccessToAllUnnamed();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/Modules.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+import jdk.internal.access.JavaLangAccess;\n@@ -118,1 +119,4 @@\n-        SharedSecrets.getJavaLangAccess().ensureNativeAccess(module, owner, methodName);\n+        class Holder {\n+            static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n+        }\n+        Holder.JLA.ensureNativeAccess(module, owner, methodName, currentClass);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/Reflection.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -117,1 +117,1 @@\n-    private static Architecture CURRENT_ARCH = initArch(PlatformProps.CURRENT_ARCH_STRING);\n+    private static final Architecture CURRENT_ARCH = initArch(PlatformProps.CURRENT_ARCH_STRING);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/Architecture.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -94,0 +94,24 @@\n+    \/**\n+     * For values from 0 to 255 return a short encoding a pair of hex ASCII-encoded digit characters in little-endian\n+     * @param i value to convert\n+     * @param ucase true uppper case, false lower case\n+     * @return a short encoding a pair of hex ASCII-encoded digit characters\n+     *\/\n+    public static short digitPair(int i, boolean ucase) {\n+        \/*\n+         * 0b0100_0000_0100_0000 is a selector that selects letters (1 << 6),\n+         * uppercase or not, and shifting it right by 1 bit incidentally\n+         * becomes a bit offset between cases (1 << 5).\n+         *\n+         *  ([0-9] & 0b100_0000) >> 1 => 0\n+         *  ([a-f] & 0b100_0000) >> 1 => 32\n+         *\n+         *  [0-9] -  0 => [0-9]\n+         *  [a-f] - 32 => [A-F]\n+         *\/\n+        short v = DIGITS[i & 0xff];\n+        return ucase\n+                ? (short) (v - ((v & 0b0100_0000_0100_0000) >> 1))\n+                : v;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/HexDigits.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -51,0 +51,4 @@\n+    \/**\n+     * @param bitIndex the bit index to test\n+     * @return true if the bit is in the range of the BitSet and the bit is set, otherwise false\n+     *\/\n@@ -53,2 +57,3 @@\n-        if (bitIndex < 0)\n-            throw new IndexOutOfBoundsException(\"bitIndex < 0: \" + bitIndex);\n+        if (bitIndex < 0) {\n+            return false;\n+        }\n@@ -56,1 +61,1 @@\n-        int wordIndex = wordIndex(bitIndex);\n+        int wordIndex = bitIndex >> 6;\n@@ -61,7 +66,0 @@\n-    \/**\n-     * Given a bit index, return word index containing it.\n-     *\/\n-    private static int wordIndex(int bitIndex) {\n-        return bitIndex >> 6;\n-    }\n-\n@@ -82,0 +80,6 @@\n+        if (original.size() <= 128) {\n+            long[] array = original.toLongArray();\n+            return new SmallImmutableBitSetPredicate(\n+                    array.length > 0 ? array[0] : 0L,\n+                    array.length > 1 ? array[1] : 0L);\n+        }\n@@ -85,0 +89,25 @@\n+    \/**\n+     * Specialization for small sets of 128 bits or less\n+     * @param first - bits index 0 through 63, inclusive\n+     * @param second - bits index 64 through 127, inclusive\n+     *\/\n+    public record SmallImmutableBitSetPredicate(long first, long second) implements IntPredicate {\n+\n+        \/**\n+         * @param bitIndex the bit index to test\n+         * @return true if the bit is in the range of the BitSet and the bit is set, otherwise false\n+         *\/\n+        @Override\n+        public boolean test(int bitIndex) {\n+            if (bitIndex < 0) {\n+                return false;\n+            }\n+\n+            int wordIndex = bitIndex >> 6;\n+            if (wordIndex > 1) {\n+                return false;\n+            }\n+            long bits = wordIndex == 0 ? first : second;\n+            return (bits & (1L << bitIndex)) != 0;\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/ImmutableBitSetPredicate.java","additions":39,"deletions":10,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -152,1 +152,1 @@\n-        jdk.incubator.vector, \/\/ participates in preview features\n+        jdk.incubator.vector,\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -105,0 +105,1 @@\n+    private static final String ENABLE_NATIVE_ACCESS = \"Enable-Native-Access\";\n@@ -635,0 +636,7 @@\n+            String enableNativeAccess = mainAttrs.getValue(ENABLE_NATIVE_ACCESS);\n+            if (enableNativeAccess != null) {\n+                if (!enableNativeAccess.equals(\"ALL-UNNAMED\")) {\n+                    abort(null, \"java.launcher.jar.error.illegal.ena.value\", enableNativeAccess);\n+                }\n+                Modules.addEnableNativeAccessToAllUnnamed();\n+            }\n","filename":"src\/java.base\/share\/classes\/sun\/launcher\/LauncherHelper.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -66,2 +66,2 @@\n-\\                  modules that are permitted to perform restricted native operations.\\n\\\n-\\                  <module name> can also be ALL-UNNAMED.\\n\\\n+\\                  allow code in modules to access code and data outside the Java runtime.\\n\\\n+\\                  <module name> can also be ALL-UNNAMED to indicate code on the class path.\\n\\\n@@ -271,0 +271,2 @@\n+java.launcher.jar.error.illegal.ena.value=\\\n+    Error: illegal value \\\"{0}\\\" for Enable-Native-Access manifest attribute. Only 'ALL-UNNAMED' is allowed\n","filename":"src\/java.base\/share\/classes\/sun\/launcher\/resources\/launcher.properties","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -53,2 +53,0 @@\n-import jdk.internal.foreign.AbstractMemorySegmentImpl;\n-import jdk.internal.foreign.MappedMemorySegmentImpl;\n@@ -56,0 +54,1 @@\n+import jdk.internal.foreign.SegmentFactories;\n@@ -1338,16 +1337,1 @@\n-        if (unmapper != null) {\n-            AbstractMemorySegmentImpl segment =\n-                new MappedMemorySegmentImpl(unmapper.address(), unmapper, size,\n-                                            readOnly, sessionImpl);\n-            MemorySessionImpl.ResourceList.ResourceCleanup resource =\n-                new MemorySessionImpl.ResourceList.ResourceCleanup() {\n-                    @Override\n-                    public void cleanup() {\n-                        unmapper.unmap();\n-                    }\n-                };\n-            sessionImpl.addOrCleanupIfFail(resource);\n-            return segment;\n-        } else {\n-            return new MappedMemorySegmentImpl(0, null, 0, readOnly, sessionImpl);\n-        }\n+        return SegmentFactories.mapSegment(size, unmapper, readOnly, sessionImpl);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/FileChannelImpl.java","additions":2,"deletions":18,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,6 +73,2 @@\n-    private static final ThreadLocal<GroupAndInvokeCount> myGroupAndInvokeCount =\n-        new ThreadLocal<GroupAndInvokeCount>() {\n-            @Override protected GroupAndInvokeCount initialValue() {\n-                return null;\n-            }\n-        };\n+    private static final ThreadLocal<GroupAndInvokeCount> myGroupAndInvokeCount\n+        = new ThreadLocal<GroupAndInvokeCount>();\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/Invoker.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -497,1 +497,4 @@\n-        SocketReadEvent.offer(start, nbytes, remoteAddress(), 0);\n+        long duration = SocketReadEvent.timestamp() - start;\n+        if (SocketReadEvent.shouldCommit(duration)) {\n+            SocketReadEvent.emit(start, duration, nbytes, remoteAddress(), 0);\n+        }\n@@ -511,1 +514,4 @@\n-        SocketReadEvent.offer(start, nbytes, remoteAddress(), 0);\n+        long duration = SocketReadEvent.timestamp() - start;\n+        if (SocketReadEvent.shouldCommit(duration)) {\n+            SocketReadEvent.emit(start, duration, nbytes, remoteAddress(), 0);\n+        }\n@@ -622,1 +628,4 @@\n-        SocketWriteEvent.offer(start, nbytes, remoteAddress());\n+        long duration = SocketWriteEvent.timestamp() - start;\n+        if (SocketWriteEvent.shouldCommit(duration)) {\n+            SocketWriteEvent.emit(start, duration, nbytes, remoteAddress());\n+        }\n@@ -635,1 +644,4 @@\n-        SocketWriteEvent.offer(start, nbytes, remoteAddress());\n+        long duration = SocketWriteEvent.timestamp() - start;\n+        if (SocketWriteEvent.shouldCommit(duration)) {\n+            SocketWriteEvent.emit(start, duration, nbytes, remoteAddress());\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/SocketChannelImpl.java","additions":16,"deletions":4,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import java.io.InvalidObjectException;\n+import java.io.ObjectInputStream;\n@@ -44,1 +46,1 @@\n- *\n+ * <p>\n@@ -67,0 +69,1 @@\n+    @java.io.Serial\n@@ -221,0 +224,16 @@\n+\n+    \/**\n+     * Restores the state of this object from the stream.\n+     * <p>\n+     * Deserialization of this object is not supported.\n+     *\n+     * @param  stream the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n+     *\/\n+    @java.io.Serial\n+    private void readObject(ObjectInputStream stream)\n+            throws IOException, ClassNotFoundException {\n+        throw new InvalidObjectException(\n+                \"ECPrivateKeyImpl keys are not directly deserializable\");\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/ECPrivateKeyImpl.java","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,2 @@\n+import java.io.InvalidObjectException;\n+import java.io.ObjectInputStream;\n@@ -47,0 +49,1 @@\n+    @java.io.Serial\n@@ -126,1 +129,2 @@\n-    protected Object writeReplace() throws java.io.ObjectStreamException {\n+    @java.io.Serial\n+    private Object writeReplace() throws java.io.ObjectStreamException {\n@@ -132,1 +136,17 @@\n-}\n+\n+    \/**\n+     * Restores the state of this object from the stream.\n+     * <p>\n+     * Deserialization of this object is not supported.\n+     *\n+     * @param  stream the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n+     *\/\n+    @java.io.Serial\n+    private void readObject(ObjectInputStream stream)\n+            throws IOException, ClassNotFoundException {\n+        throw new InvalidObjectException(\n+                \"ECPublicKeyImpl keys are not directly deserializable\");\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/ECPublicKeyImpl.java","additions":23,"deletions":3,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+    @java.io.Serial\n@@ -106,1 +107,1 @@\n-        XECParameters params = paramSpec.getName().equals(\"X25519\")\n+        XECParameters params = paramSpec.getName().equalsIgnoreCase(\"X25519\")\n@@ -117,1 +118,0 @@\n-}\n@@ -119,0 +119,16 @@\n+    \/**\n+     * Restores the state of this object from the stream.\n+     * <p>\n+     * Deserialization of this object is not supported.\n+     *\n+     * @param  stream the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n+     *\/\n+    @java.io.Serial\n+    private void readObject(ObjectInputStream stream)\n+            throws IOException, ClassNotFoundException {\n+        throw new InvalidObjectException(\n+                \"XDHPrivateKeyImpl keys are not directly deserializable\");\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/XDHPrivateKeyImpl.java","additions":18,"deletions":2,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import java.io.IOException;\n+import java.io.InvalidObjectException;\n+import java.io.ObjectInputStream;\n@@ -42,0 +45,1 @@\n+    @java.io.Serial\n@@ -110,1 +114,2 @@\n-    protected Object writeReplace() throws java.io.ObjectStreamException {\n+    @java.io.Serial\n+    private Object writeReplace() throws java.io.ObjectStreamException {\n@@ -133,0 +138,16 @@\n+\n+    \/**\n+     * Restores the state of this object from the stream.\n+     * <p>\n+     * Deserialization of this object is not supported.\n+     *\n+     * @param  stream the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n+     *\/\n+    @java.io.Serial\n+    private void readObject(ObjectInputStream stream)\n+            throws IOException, ClassNotFoundException {\n+        throw new InvalidObjectException(\n+                \"XDHPublicKeyImpl keys are not directly deserializable\");\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/XDHPublicKeyImpl.java","additions":23,"deletions":2,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,2 @@\n+import java.io.InvalidObjectException;\n+import java.io.ObjectInputStream;\n@@ -41,0 +43,1 @@\n+    @java.io.Serial\n@@ -105,0 +108,16 @@\n+\n+    \/**\n+     * Restores the state of this object from the stream.\n+     * <p>\n+     * Deserialization of this object is not supported.\n+     *\n+     * @param  stream the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n+     *\/\n+    @java.io.Serial\n+    private void readObject(ObjectInputStream stream)\n+            throws IOException, ClassNotFoundException {\n+        throw new InvalidObjectException(\n+                \"EdDSAPrivateKeyImpl keys are not directly deserializable\");\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/ed\/EdDSAPrivateKeyImpl.java","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import java.io.IOException;\n+import java.io.InvalidObjectException;\n+import java.io.ObjectInputStream;\n@@ -42,0 +45,1 @@\n+    @java.io.Serial\n@@ -111,1 +115,2 @@\n-    protected Object writeReplace() throws java.io.ObjectStreamException {\n+    @java.io.Serial\n+    private Object writeReplace() throws java.io.ObjectStreamException {\n@@ -132,0 +137,16 @@\n+\n+    \/**\n+     * Restores the state of this object from the stream.\n+     * <p>\n+     * Deserialization of this object is not supported.\n+     *\n+     * @param  stream the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n+     *\/\n+    @java.io.Serial\n+    private void readObject(ObjectInputStream stream)\n+            throws IOException, ClassNotFoundException {\n+        throw new InvalidObjectException(\n+                \"EdDSAPublicKeyImpl keys are not directly deserializable\");\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/ed\/EdDSAPublicKeyImpl.java","additions":23,"deletions":2,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import java.io.IOException;\n+import java.io.InvalidObjectException;\n+import java.io.ObjectInputStream;\n@@ -34,1 +37,1 @@\n- *\n+ * <p>\n@@ -38,1 +41,1 @@\n- *\n+ * <p>\n@@ -75,1 +78,1 @@\n-    protected Object writeReplace() throws java.io.ObjectStreamException {\n+    private Object writeReplace() throws java.io.ObjectStreamException {\n@@ -81,0 +84,16 @@\n+\n+    \/**\n+     * Restores the state of this object from the stream.\n+     * <p>\n+     * Deserialization of this object is not supported.\n+     *\n+     * @param  stream the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n+     *\/\n+    @java.io.Serial\n+    private void readObject(ObjectInputStream stream)\n+            throws IOException, ClassNotFoundException {\n+        throw new InvalidObjectException(\n+                \"DSAPublicKeyImpl keys are not directly deserializable\");\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/DSAPublicKeyImpl.java","additions":23,"deletions":4,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2101,1 +2101,9 @@\n-            if (this.certs.length != that.certs.length)\n+            if ((this.certs == null) && (that.certs == null)) {\n+                return true;\n+            }\n+\n+            if ((this.certs == null) || (that.certs == null)) {\n+                return false;\n+            }\n+\n+            if (this.certs.length != that.certs.length) {\n@@ -2103,0 +2111,1 @@\n+            }\n@@ -2166,1 +2175,1 @@\n-            return certs;\n+            return (certs == null ? null : certs.clone());\n@@ -2179,0 +2188,16 @@\n+\n+        \/**\n+         * Restores the state of this object from the stream.\n+         *\n+         * @param  stream the {@code ObjectInputStream} from which data is read\n+         * @throws IOException if an I\/O error occurs\n+         * @throws ClassNotFoundException if a serialized class cannot be loaded\n+         *\/\n+        @java.io.Serial\n+        private void readObject(ObjectInputStream stream)\n+                throws IOException, ClassNotFoundException {\n+            stream.defaultReadObject();\n+            if (certs != null) {\n+                this.certs = certs.clone();\n+            }\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/PolicyFile.java","additions":27,"deletions":2,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.io.InvalidObjectException;\n@@ -195,1 +196,1 @@\n-     *\n+     * <p>\n@@ -268,2 +269,4 @@\n-     * readObject is called to restore the state of the random object from\n-     * a stream.  We have to create a new instance of MessageDigest, because\n+     * This method is called to restore the state of the random object from\n+     * a stream.\n+     * <p>\n+     * We have to create a new instance of {@code MessageDigest}, because\n@@ -271,3 +274,3 @@\n-     *\n-     * Note that the engineNextBytes() method invoked on the restored random\n-     * object will yield the exact same (random) bytes as the original.\n+     * <p>\n+     * Note that the {@code engineNextBytes()} method invoked on the restored\n+     * random object will yield the exact same (random) bytes as the original.\n@@ -275,1 +278,5 @@\n-     * random object, using engineSetSeed().\n+     * random object, using {@code engineSetSeed()}.\n+     *\n+     * @param  s the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n@@ -279,1 +286,1 @@\n-        throws IOException, ClassNotFoundException {\n+            throws IOException, ClassNotFoundException {\n@@ -298,0 +305,29 @@\n+\n+        \/\/ Various consistency checks\n+        if ((remainder == null) && (remCount > 0)) {\n+            throw new InvalidObjectException(\n+                    \"Remainder indicated, but no data available\");\n+        }\n+\n+        \/\/ Not yet allocated state\n+        if (state == null) {\n+            if (remainder == null) {\n+                return;\n+            } else {\n+                throw new InvalidObjectException(\n+                        \"Inconsistent buffer allocations\");\n+            }\n+        }\n+\n+        \/\/ Sanity check on sizes\/pointer\n+        if ((state.length != DIGEST_SIZE) ||\n+                ((remainder != null) && (remainder.length != DIGEST_SIZE)) ||\n+                (remCount < 0 ) || (remCount >= DIGEST_SIZE)) {\n+            throw new InvalidObjectException(\n+                    \"Inconsistent buffer sizes\/state\");\n+        }\n+\n+        state = state.clone();\n+        if (remainder != null) {\n+            remainder = remainder.clone();\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/SecureRandom.java","additions":45,"deletions":9,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-import java.util.Set;\n@@ -32,1 +31,0 @@\n-import java.security.cert.X509CertSelector;\n@@ -35,2 +33,0 @@\n-import sun.security.x509.GeneralNameInterface;\n-\n@@ -58,3 +54,0 @@\n-    protected abstract void implSetPathToNames(X509CertSelector sel,\n-            Set<GeneralNameInterface> names);\n-\n@@ -65,5 +58,0 @@\n-    static void setPathToNames(X509CertSelector sel,\n-            Set<GeneralNameInterface> names) {\n-        instance.implSetPathToNames(sel, names);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/certpath\/CertPathHelper.java","additions":1,"deletions":13,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -50,1 +50,0 @@\n-import sun.security.x509.SubjectAlternativeNameExtension;\n@@ -260,8 +259,0 @@\n-            \/*\n-             * Match on subjectNamesTraversed (both DNs and AltNames)\n-             * (checks that current cert's name constraints permit it\n-             * to certify all the DNs and AltNames that have been traversed)\n-             *\/\n-            CertPathHelper.setPathToNames\n-                (caSelector, currentState.subjectNamesTraversed);\n-\n@@ -700,13 +691,0 @@\n-        \/*\n-         * Abort if we encounter the same certificate or a certificate with\n-         * the same public key, subject DN, and subjectAltNames as a cert\n-         * that is already in path.\n-         *\/\n-        for (X509Certificate cpListCert : certPathList) {\n-            if (repeated(cpListCert, cert)) {\n-                throw new CertPathValidatorException(\n-                    \"cert with repeated subject, public key, and \" +\n-                    \"subjectAltNames detected\");\n-            }\n-        }\n-\n@@ -790,43 +768,0 @@\n-    \/**\n-     * Return true if two certificates are equal or have the same subject,\n-     * public key, and subject alternative names.\n-     *\/\n-    private static boolean repeated(\n-            X509Certificate currCert, X509Certificate nextCert) {\n-        if (currCert.equals(nextCert)) {\n-            return true;\n-        }\n-        return (currCert.getSubjectX500Principal().equals(\n-            nextCert.getSubjectX500Principal()) &&\n-            currCert.getPublicKey().equals(nextCert.getPublicKey()) &&\n-            altNamesEqual(currCert, nextCert));\n-    }\n-\n-    \/**\n-     * Return true if two certificates have the same subject alternative names.\n-     *\/\n-    private static boolean altNamesEqual(\n-            X509Certificate currCert, X509Certificate nextCert) {\n-        X509CertImpl curr, next;\n-        try {\n-            curr = X509CertImpl.toImpl(currCert);\n-            next = X509CertImpl.toImpl(nextCert);\n-        } catch (CertificateException ce) {\n-            return false;\n-        }\n-\n-        SubjectAlternativeNameExtension currAltNameExt =\n-            curr.getSubjectAlternativeNameExtension();\n-        SubjectAlternativeNameExtension nextAltNameExt =\n-            next.getSubjectAlternativeNameExtension();\n-        if (currAltNameExt != null) {\n-            if (nextAltNameExt == null) {\n-                return false;\n-            }\n-            return Arrays.equals(currAltNameExt.getExtensionValue(),\n-                nextAltNameExt.getExtensionValue());\n-        } else {\n-            return (nextAltNameExt == null);\n-        }\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/certpath\/ForwardBuilder.java","additions":0,"deletions":65,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import java.util.HashSet;\n@@ -40,5 +39,0 @@\n-import sun.security.x509.SubjectAlternativeNameExtension;\n-import sun.security.x509.GeneralNames;\n-import sun.security.x509.GeneralName;\n-import sun.security.x509.GeneralNameInterface;\n-import sun.security.x509.X500Name;\n@@ -64,3 +58,0 @@\n-    \/* The set of subjectDNs and subjectAltNames of all certs in the path *\/\n-    HashSet<GeneralNameInterface> subjectNamesTraversed;\n-\n@@ -76,1 +67,0 @@\n-\n@@ -106,2 +96,0 @@\n-                \"\\n  subjectNamesTraversed: \\n\" +\n-                subjectNamesTraversed +\n@@ -120,1 +108,0 @@\n-        subjectNamesTraversed = new HashSet<>();\n@@ -170,16 +157,0 @@\n-        \/* update subjectNamesTraversed only if this is the EE cert or if\n-           this cert is not self-issued *\/\n-        if (init || !selfIssued) {\n-            X500Principal subjName = cert.getSubjectX500Principal();\n-            subjectNamesTraversed.add(X500Name.asX500Name(subjName));\n-\n-            SubjectAlternativeNameExtension subjAltNameExt\n-                    = icert.getSubjectAlternativeNameExtension();\n-            if (subjAltNameExt != null) {\n-                GeneralNames gNames = subjAltNameExt.getNames();\n-                for (GeneralName gName : gNames.names()) {\n-                    subjectNamesTraversed.add(gName.getName());\n-                }\n-            }\n-        }\n-\n@@ -193,4 +164,0 @@\n-     *\n-     * Note that this is a SMART clone. Not all fields are fully copied,\n-     * because some of them will\n-     * not have their contents modified by subsequent calls to updateState.\n@@ -216,7 +183,0 @@\n-            \/*\n-             * Shallow copy traversed names. There is no need to\n-             * deep copy contents, since the elements of the Set\n-             * are never modified by subsequent calls to updateState().\n-             *\/\n-            clonedState.subjectNamesTraversed\n-                = (HashSet<GeneralNameInterface>)subjectNamesTraversed.clone();\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/certpath\/ForwardState.java","additions":0,"deletions":40,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.util.Arrays;\n@@ -45,0 +46,1 @@\n+import sun.security.x509.SubjectAlternativeNameExtension;\n@@ -268,1 +270,1 @@\n-        List<Vertex> vertices = addVertices(certs, adjList);\n+        List<Vertex> vertices = addVertices(certs, adjList, cpList);\n@@ -328,0 +330,1 @@\n+                PublicKey rootKey = cert.getPublicKey();\n@@ -330,0 +333,6 @@\n+                    rootKey = builder.trustAnchor.getCAPublicKey();\n+                    if (debug != null)\n+                        debug.println(\n+                            \"SunCertPathBuilder.depthFirstSearchForward \" +\n+                            \"using buildParams public key: \" +\n+                            rootKey.toString());\n@@ -331,0 +340,2 @@\n+                TrustAnchor anchor = new TrustAnchor\n+                    (cert.getSubjectX500Principal(), rootKey, null);\n@@ -332,0 +343,7 @@\n+                \/\/ add the basic checker\n+                List<PKIXCertPathChecker> checkers = new ArrayList<>();\n+                BasicChecker basicChecker = new BasicChecker(anchor,\n+                                                    buildParams.date(),\n+                                                    buildParams.sigProvider(),\n+                                                    true);\n+                checkers.add(basicChecker);\n@@ -338,1 +356,0 @@\n-                List<PKIXCertPathChecker> checkers = new ArrayList<>();\n@@ -349,0 +366,3 @@\n+                \/\/ add the constraints checker\n+                checkers.add(new ConstraintsChecker(appendedCerts.size()));\n+\n@@ -353,18 +373,0 @@\n-                PublicKey rootKey = cert.getPublicKey();\n-                if (builder.trustAnchor.getTrustedCert() == null) {\n-                    rootKey = builder.trustAnchor.getCAPublicKey();\n-                    if (debug != null)\n-                        debug.println(\n-                            \"SunCertPathBuilder.depthFirstSearchForward \" +\n-                            \"using buildParams public key: \" +\n-                            rootKey.toString());\n-                }\n-                TrustAnchor anchor = new TrustAnchor\n-                    (cert.getSubjectX500Principal(), rootKey, null);\n-\n-                \/\/ add the basic checker\n-                BasicChecker basicChecker = new BasicChecker(anchor,\n-                                                    buildParams.date(),\n-                                                    buildParams.sigProvider(),\n-                                                    true);\n-                checkers.add(basicChecker);\n@@ -566,1 +568,2 @@\n-                                            List<List<Vertex>> adjList)\n+                                            List<List<Vertex>> adjList,\n+                                            List<X509Certificate> cpList)\n@@ -571,2 +574,19 @@\n-            Vertex v = new Vertex(cert);\n-            l.add(v);\n+            boolean repeated = false;\n+            for (X509Certificate cpListCert : cpList) {\n+                \/*\n+                 * Ignore if we encounter the same certificate or a\n+                 * certificate with the same public key, subject DN, and\n+                 * subjectAltNames as a cert that is already in path.\n+                 *\/\n+                if (repeated(cpListCert, cert)) {\n+                    if (debug != null) {\n+                        debug.println(\"cert with repeated subject, \" +\n+                            \"public key, and subjectAltNames detected\");\n+                    }\n+                    repeated = true;\n+                    break;\n+                }\n+            }\n+            if (!repeated) {\n+                l.add(new Vertex(cert));\n+            }\n@@ -578,0 +598,43 @@\n+    \/**\n+     * Return true if two certificates are equal or have the same subject,\n+     * public key, and subject alternative names.\n+     *\/\n+    private static boolean repeated(\n+            X509Certificate currCert, X509Certificate nextCert) {\n+        if (currCert.equals(nextCert)) {\n+            return true;\n+        }\n+        return (currCert.getSubjectX500Principal().equals(\n+            nextCert.getSubjectX500Principal()) &&\n+            currCert.getPublicKey().equals(nextCert.getPublicKey()) &&\n+            altNamesEqual(currCert, nextCert));\n+    }\n+\n+    \/**\n+     * Return true if two certificates have the same subject alternative names.\n+     *\/\n+    private static boolean altNamesEqual(\n+            X509Certificate currCert, X509Certificate nextCert) {\n+        X509CertImpl curr, next;\n+        try {\n+            curr = X509CertImpl.toImpl(currCert);\n+            next = X509CertImpl.toImpl(nextCert);\n+        } catch (CertificateException ce) {\n+            return false;\n+        }\n+\n+        SubjectAlternativeNameExtension currAltNameExt =\n+            curr.getSubjectAlternativeNameExtension();\n+        SubjectAlternativeNameExtension nextAltNameExt =\n+            next.getSubjectAlternativeNameExtension();\n+        if (currAltNameExt != null) {\n+            if (nextAltNameExt == null) {\n+                return false;\n+            }\n+            return Arrays.equals(currAltNameExt.getExtensionValue(),\n+                nextAltNameExt.getExtensionValue());\n+        } else {\n+            return (nextAltNameExt == null);\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/certpath\/SunCertPathBuilder.java","additions":86,"deletions":23,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,1 @@\n-import java.io.ByteArrayInputStream;\n-import java.io.IOException;\n-import java.io.InputStream;\n+import java.io.*;\n@@ -382,0 +380,16 @@\n+\n+    \/**\n+     * Restores the state of this object from the stream.\n+     * <p>\n+     * Deserialization of this object is not supported.\n+     *\n+     * @param  stream the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n+     *\/\n+    @java.io.Serial\n+    private void readObject(ObjectInputStream stream)\n+            throws IOException, ClassNotFoundException {\n+        throw new InvalidObjectException(\n+                \"X509CertPaths are not directly deserializable\");\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/certpath\/X509CertPath.java","additions":18,"deletions":4,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,2 @@\n+import java.io.InvalidObjectException;\n+import java.io.ObjectInputStream;\n@@ -46,1 +48,1 @@\n- *\n+ * <p>\n@@ -359,0 +361,16 @@\n+\n+    \/**\n+     * Restores the state of this object from the stream.\n+     * <p>\n+     * Deserialization of this object is not supported.\n+     *\n+     * @param  stream the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n+     *\/\n+    @java.io.Serial\n+    private void readObject(ObjectInputStream stream)\n+            throws IOException, ClassNotFoundException {\n+        throw new InvalidObjectException(\n+                \"RSAPrivateCrtKeyImpl keys are not directly deserializable\");\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/rsa\/RSAPrivateCrtKeyImpl.java","additions":20,"deletions":2,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import java.io.IOException;\n+import java.io.InvalidObjectException;\n+import java.io.ObjectInputStream;\n@@ -42,4 +45,5 @@\n- * form (modulus, private exponent only). For CRT private keys, see\n- * RSAPrivateCrtKeyImpl. We need separate classes to ensure correct behavior\n- * in instanceof checks, etc.\n- *\n+ * form (modulus, private exponent only).\n+ * <p>\n+ * For CRT private keys, see RSAPrivateCrtKeyImpl. We need separate classes\n+ * to ensure correct behavior in instanceof checks, etc.\n+ * <p>\n@@ -144,0 +148,16 @@\n+\n+    \/**\n+     * Restores the state of this object from the stream.\n+     * <p>\n+     * Deserialization of this object is not supported.\n+     *\n+     * @param  stream the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n+     *\/\n+    @java.io.Serial\n+    private void readObject(ObjectInputStream stream)\n+            throws IOException, ClassNotFoundException {\n+        throw new InvalidObjectException(\n+                \"RSAPrivateKeyImpl keys are not directly deserializable\");\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/rsa\/RSAPrivateKeyImpl.java","additions":25,"deletions":5,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,2 @@\n+import java.io.InvalidObjectException;\n+import java.io.ObjectInputStream;\n@@ -42,1 +44,1 @@\n- *\n+ * <p>\n@@ -236,1 +238,1 @@\n-    protected Object writeReplace() throws java.io.ObjectStreamException {\n+    private Object writeReplace() throws java.io.ObjectStreamException {\n@@ -242,0 +244,16 @@\n+\n+    \/**\n+     * Restores the state of this object from the stream.\n+     * <p>\n+     * Deserialization of this object is not supported.\n+     *\n+     * @param  stream the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n+     *\/\n+    @java.io.Serial\n+    private void readObject(ObjectInputStream stream)\n+            throws IOException, ClassNotFoundException {\n+        throw new InvalidObjectException(\n+                \"RSAPublicKeyImpl keys are not directly deserializable\");\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/rsa\/RSAPublicKeyImpl.java","additions":21,"deletions":3,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -539,1 +539,1 @@\n-     *\n+     * <p>\n@@ -1221,1 +1221,1 @@\n-            nameEntry.add(Integer.valueOf(name.getType()));\n+            nameEntry.add(name.getType());\n@@ -1634,0 +1634,16 @@\n+\n+    \/**\n+     * Restores the state of this object from the stream.\n+     * <p>\n+     * Deserialization of this object is not supported.\n+     *\n+     * @param  stream the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n+     *\/\n+    @java.io.Serial\n+    private void readObject(ObjectInputStream stream)\n+            throws IOException, ClassNotFoundException {\n+        throw new InvalidObjectException(\n+                \"X509CertImpls are not directly deserializable\");\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/X509CertImpl.java","additions":19,"deletions":3,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -533,4 +533,5 @@\n-Specifies where to find application modules with a list of path elements.\n-The elements of a module path can be a file path to a module or a directory\n-containing modules. Each module is either a modular JAR or an\n-exploded-module directory.\n+Specifies where to find application modules with a list of path\n+elements.\n+The elements of a module path can be a file path to a module or a\n+directory containing modules.\n+Each module is either a modular JAR or an exploded-module directory.\n@@ -539,2 +540,2 @@\n-On Windows, semicolons (\\f[V];\\f[R]) separate path elements in this list;\n-on other platforms it is a colon (\\f[V]:\\f[R]).\n+On Windows, semicolons (\\f[V];\\f[R]) separate path elements in this\n+list; on other platforms it is a colon (\\f[V]:\\f[R]).\n@@ -544,5 +545,5 @@\n-Specifies where to find module replacements of upgradeable modules in the\n-runtime image with a list of path elements.\n-The elements of a module path can be a file path to a module or a directory\n-containing modules. Each module is either a modular JAR or an\n-exploded-module directory.\n+Specifies where to find module replacements of upgradeable modules in\n+the runtime image with a list of path elements.\n+The elements of a module path can be a file path to a module or a\n+directory containing modules.\n+Each module is either a modular JAR or an exploded-module directory.\n@@ -551,2 +552,2 @@\n-On Windows, semicolons (\\f[V];\\f[R]) separate path elements in this list;\n-on other platforms it is a colon (\\f[V]:\\f[R]).\n+On Windows, semicolons (\\f[V];\\f[R]) separate path elements in this\n+list; on other platforms it is a colon (\\f[V]:\\f[R]).\n@@ -1307,0 +1308,1 @@\n+Multiple parameters can be specified by separating them with a comma.\n@@ -1372,3 +1374,0 @@\n-.PP\n-You can specify values for multiple parameters by separating them with a\n-comma.\n@@ -1661,0 +1660,3 @@\n+.PP\n+If %p and\/or %t is specified in the filename, it expands to the\n+JVM\\[aq]s PID and the current timestamp, respectively.\n@@ -1815,13 +1817,0 @@\n-\\f[V]-XX:+UseHugeTLBFS\\f[R]\n-\\f[B]Linux only:\\f[R] This option is the equivalent of specifying\n-\\f[V]-XX:+UseLargePages\\f[R].\n-This option is disabled by default.\n-This option pre-allocates all large pages up-front, when memory is\n-reserved; consequently the JVM can\\[aq]t dynamically grow or shrink\n-large pages memory areas; see \\f[V]-XX:UseTransparentHugePages\\f[R] if\n-you want this behavior.\n-.RS\n-.PP\n-See \\f[B]Large Pages\\f[R].\n-.RE\n-.TP\n@@ -2175,6 +2164,0 @@\n-Specify each method with the full class name (including the packages and\n-subpackages).\n-For example, to compile only the \\f[V]length()\\f[R] method of the\n-\\f[V]String\\f[R] class and the \\f[V]size()\\f[R] method of the\n-\\f[V]List\\f[R] class, use the following:\n-.RS\n@@ -2183,17 +2166,1 @@\n-\\f[V]-XX:CompileOnly=java\/lang\/String.length,java\/util\/List.size\\f[R]\n-.RE\n-.PP\n-Note that the full class name is specified, including all packages and\n-subpackages separated by a slash (\\f[V]\/\\f[R]).\n-For easier cut and paste operations, it\\[aq]s also possible to use the\n-method name format produced by the \\f[V]-XX:+PrintCompilation\\f[R] and\n-\\f[V]-XX:+LogCompilation\\f[R] options:\n-.RS\n-.PP\n-\\f[V]-XX:CompileOnly=java.lang.String::length,java.util.List::size\\f[R]\n-.RE\n-.PP\n-Although wildcards aren\\[aq]t supported, you can specify only the class\n-or package name to compile all methods in that class or package, as well\n-as specify just the method to compile methods with this name in any\n-class:\n+\\f[V]-XX:CompileOnly=method1,method2,...,methodN\\f[R] is an alias for:\n@@ -2203,3 +2170,4 @@\n--XX:CompileOnly=java\/lang\/String\n--XX:CompileOnly=java\/lang\n--XX:CompileOnly=.length\n+-XX:CompileCommand=compileonly,method1\n+-XX:CompileCommand=compileonly,method2\n+\\&...\n+-XX:CompileCommand=compileonly,methodN\n@@ -3658,8 +3626,0 @@\n-\\f[V]-XX:+UseSHM\\f[R]\n-\\f[B]Linux only:\\f[R] Enables the JVM to use shared memory to set up\n-large pages.\n-.RS\n-.PP\n-See \\f[B]Large Pages\\f[R] for setting up large pages.\n-.RE\n-.TP\n@@ -3818,0 +3778,13 @@\n+.TP\n+\\f[V]-XX:+UseHugeTLBFS\\f[R]\n+\\f[B]Linux only:\\f[R] This option is the equivalent of specifying\n+\\f[V]-XX:+UseLargePages\\f[R].\n+This option is disabled by default.\n+This option pre-allocates all large pages up-front, when memory is\n+reserved; consequently the JVM can\\[aq]t dynamically grow or shrink\n+large pages memory areas; see \\f[V]-XX:UseTransparentHugePages\\f[R] if\n+you want this behavior.\n+.TP\n+\\f[V]-XX:+UseSHM\\f[R]\n+\\f[B]Linux only:\\f[R] Enables the JVM to use shared memory to set up\n+large pages.\n@@ -4918,14 +4891,0 @@\n-.PP\n-When using the option \\f[V]-XX:+UseSHM\\f[R] to enable large pages you\n-also need to make sure the \\f[V]SHMMAX\\f[R] parameter is configured to\n-allow large enough shared memory segments to be allocated.\n-To allow a maximum shared segment of 8 GB, login as \\f[V]root\\f[R] and\n-run:\n-.RS\n-.PP\n-\\f[V]# echo 8589934592 > \/proc\/sys\/kernel\/shmmax\\f[R]\n-.RE\n-.PP\n-In some environments this is not needed since the default value is large\n-enough, but it is important to make sure the value is large enough to\n-fit the amount of memory intended to be backed by large pages.\n","filename":"src\/java.base\/share\/man\/java.1","additions":36,"deletions":77,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include <wchar.h>\n@@ -209,0 +210,20 @@\n+\n+JNIEXPORT jint JNICALL\n+Java_jdk_internal_foreign_abi_fallback_LibFallback_ffi_1sizeof_1short(JNIEnv* env, jclass cls) {\n+  return sizeof(short);\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_jdk_internal_foreign_abi_fallback_LibFallback_ffi_1sizeof_1int(JNIEnv* env, jclass cls) {\n+  return sizeof(int);\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_jdk_internal_foreign_abi_fallback_LibFallback_ffi_1sizeof_1long(JNIEnv* env, jclass cls) {\n+  return sizeof(long);\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_jdk_internal_foreign_abi_fallback_LibFallback_ffi_1sizeof_1wchar(JNIEnv* env, jclass cls) {\n+  return sizeof(wchar_t);\n+}\n","filename":"src\/java.base\/share\/native\/libfallbackLinker\/fallbackLinker.c","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -164,3 +164,0 @@\n-JNIEXPORT int JNICALL\n-NET_SocketAvailable(int fd, int *pbytes);\n-\n@@ -176,6 +173,0 @@\n-JNIEXPORT int JNICALL\n-NET_MapSocketOption(jint cmd, int *level, int *optname);\n-\n-JNIEXPORT int JNICALL\n-NET_MapSocketOptionV6(jint cmd, int *level, int *optname);\n-\n","filename":"src\/java.base\/share\/native\/libnet\/net_util.h","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,6 @@\n-import java.nio.file.attribute.*;\n-import java.util.concurrent.TimeUnit;\n-import java.util.Set;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.FileTime;\n+import java.nio.file.attribute.GroupPrincipal;\n+import java.nio.file.attribute.PosixFileAttributes;\n+import java.nio.file.attribute.PosixFilePermission;\n+import java.nio.file.attribute.UserPrincipal;\n@@ -32,0 +35,2 @@\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n@@ -55,0 +60,1 @@\n+    private long    st_birthtime_nsec;\n@@ -161,1 +167,1 @@\n-            return FileTime.from(st_birthtime_sec, TimeUnit.SECONDS);\n+            return toFileTime(st_birthtime_sec, st_birthtime_nsec);\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixFileAttributes.java","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -491,1 +491,1 @@\n-#if defined (__linux__) || defined(_AIX)\n+#if defined (__linux__)\n@@ -494,4 +494,6 @@\n- * Returns the children of the requested pid and optionally each parent and\n- * start time.\n- * Reads \/proc and accumulates any process who parent pid matches.\n- * The resulting pids are stored into the array of longs.\n+ * Return pids of active processes, and optionally parent pids and\n+ * start times for each process.\n+ * For a specific non-zero pid, only the direct children are returned.\n+ * If the pid is zero, all active processes are returned.\n+ * Reads \/proc and accumulates any process following the rules above.\n+ * The resulting pids are stored into an array of longs named jarray.\n@@ -499,1 +501,9 @@\n- * If the array is too short, the negative of the desired length is returned.\n+ * If the parentArray is non-null, store also the parent pid.\n+ * In this case the parentArray must have the same length as the result pid array.\n+ * Of course in the case of a given non-zero pid all entries in the parentArray\n+ * will contain this pid, so this array does only make sense in the case of a given\n+ * zero pid.\n+ * If the jstimesArray is non-null, store also the start time of the pid.\n+ * In this case the jstimesArray must have the same length as the result pid array.\n+ * If the array(s) (is|are) too short, excess pids are not stored and\n+ * the desired length is returned.\n@@ -610,1 +620,1 @@\n-#endif \/\/ defined (__linux__) || defined(_AIX)\n+#endif \/\/ defined (__linux__)\n","filename":"src\/java.base\/unix\/native\/libjava\/ProcessHandleImpl_unix.c","additions":17,"deletions":7,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -241,0 +241,5 @@\n+            if (*std_language == NULL) {\n+                free(encoding_variant);\n+                JNU_ThrowOutOfMemoryError(env, NULL);\n+                return 0;\n+            }\n@@ -249,0 +254,5 @@\n+            if (*std_country == NULL) {\n+                free(encoding_variant);\n+                JNU_ThrowOutOfMemoryError(env, NULL);\n+                return 0;\n+            }\n","filename":"src\/java.base\/unix\/native\/libjava\/java_props_md.c","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -94,7 +94,7 @@\n-typedef GProxyResolver* g_proxy_resolver_get_default_func();\n-typedef char** g_proxy_resolver_lookup_func();\n-typedef GSocketConnectable* g_network_address_parse_uri_func();\n-typedef const char* g_network_address_get_hostname_func();\n-typedef unsigned short g_network_address_get_port_func();\n-typedef void g_strfreev_func();\n-typedef void g_clear_error_func();\n+typedef GProxyResolver* g_proxy_resolver_get_default_func(void);\n+typedef char** g_proxy_resolver_lookup_func(GProxyResolver* resolver, char* uri, void *null, GError **error_p);\n+typedef GSocketConnectable* g_network_address_parse_uri_func(char* proxy, unsigned short default_port, GError **error_p);\n+typedef const char* g_network_address_get_hostname_func(GSocketConnectable* conn);\n+typedef unsigned short g_network_address_get_port_func(GSocketConnectable* conn);\n+typedef void g_strfreev_func(char** proxies);\n+typedef void g_clear_error_func(GError **error_p);\n","filename":"src\/java.base\/unix\/native\/libnet\/DefaultProxySelector.c","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include <sys\/ioctl.h>\n@@ -54,12 +53,0 @@\n-#define RESTARTABLE(_cmd, _result) do { \\\n-    do { \\\n-        _result = _cmd; \\\n-    } while((_result == -1) && (errno == EINTR)); \\\n-} while(0)\n-\n-int NET_SocketAvailable(int s, int *pbytes) {\n-    int result;\n-    RESTARTABLE(ioctl(s, FIONREAD, pbytes), result);\n-    return result;\n-}\n-\n@@ -330,66 +317,0 @@\n-\/*\n- * Map the Java level socket option to the platform specific\n- * level and option name.\n- *\/\n-int\n-NET_MapSocketOption(jint cmd, int *level, int *optname) {\n-    static struct {\n-        jint cmd;\n-        int level;\n-        int optname;\n-    } const opts[] = {\n-        { java_net_SocketOptions_TCP_NODELAY,           IPPROTO_TCP,    TCP_NODELAY },\n-        { java_net_SocketOptions_SO_OOBINLINE,          SOL_SOCKET,     SO_OOBINLINE },\n-        { java_net_SocketOptions_SO_LINGER,             SOL_SOCKET,     SO_LINGER },\n-        { java_net_SocketOptions_SO_SNDBUF,             SOL_SOCKET,     SO_SNDBUF },\n-        { java_net_SocketOptions_SO_RCVBUF,             SOL_SOCKET,     SO_RCVBUF },\n-        { java_net_SocketOptions_SO_KEEPALIVE,          SOL_SOCKET,     SO_KEEPALIVE },\n-        { java_net_SocketOptions_SO_REUSEADDR,          SOL_SOCKET,     SO_REUSEADDR },\n-        { java_net_SocketOptions_SO_REUSEPORT,          SOL_SOCKET,     SO_REUSEPORT },\n-        { java_net_SocketOptions_SO_BROADCAST,          SOL_SOCKET,     SO_BROADCAST },\n-        { java_net_SocketOptions_IP_TOS,                IPPROTO_IP,     IP_TOS },\n-        { java_net_SocketOptions_IP_MULTICAST_IF,       IPPROTO_IP,     IP_MULTICAST_IF },\n-        { java_net_SocketOptions_IP_MULTICAST_IF2,      IPPROTO_IP,     IP_MULTICAST_IF },\n-        { java_net_SocketOptions_IP_MULTICAST_LOOP,     IPPROTO_IP,     IP_MULTICAST_LOOP },\n-    };\n-\n-    int i;\n-\n-    if (ipv6_available()) {\n-        switch (cmd) {\n-            \/\/ Different multicast options if IPv6 is enabled\n-            case java_net_SocketOptions_IP_MULTICAST_IF:\n-            case java_net_SocketOptions_IP_MULTICAST_IF2:\n-                *level = IPPROTO_IPV6;\n-                *optname = IPV6_MULTICAST_IF;\n-                return 0;\n-\n-            case java_net_SocketOptions_IP_MULTICAST_LOOP:\n-                *level = IPPROTO_IPV6;\n-                *optname = IPV6_MULTICAST_LOOP;\n-                return 0;\n-#if defined(MACOSX)\n-            \/\/ Map IP_TOS request to IPV6_TCLASS\n-            case java_net_SocketOptions_IP_TOS:\n-                *level = IPPROTO_IPV6;\n-                *optname = IPV6_TCLASS;\n-                return 0;\n-#endif\n-        }\n-    }\n-\n-    \/*\n-     * Map the Java level option to the native level\n-     *\/\n-    for (i=0; i<(int)(sizeof(opts) \/ sizeof(opts[0])); i++) {\n-        if (cmd == opts[i].cmd) {\n-            *level = opts[i].level;\n-            *optname = opts[i].optname;\n-            return 0;\n-        }\n-    }\n-\n-    \/* not found *\/\n-    return -1;\n-}\n-\n","filename":"src\/java.base\/unix\/native\/libnet\/net_util_md.c","additions":0,"deletions":79,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include <sys\/ioctl.h>\n@@ -857,1 +858,4 @@\n-    if (NET_SocketAvailable(fdval(env, fdo), &count) != 0) {\n+    int result;\n+    RESTARTABLE(ioctl(fdval(env, fdo), FIONREAD, &count), result);\n+\n+    if (result != 0) {\n","filename":"src\/java.base\/unix\/native\/libnio\/ch\/Net.c","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+#include <sys\/sysmacros.h> \/\/ makedev macros\n@@ -74,0 +75,92 @@\n+#if defined(__linux__)\n+\/\/ Account for the case where we compile on a system without statx\n+\/\/ support. We still want to ensure we can call statx at runtime\n+\/\/ if the runtime glibc version supports it (>= 2.28). We do this\n+\/\/ by defining binary compatible statx structs in this file and\n+\/\/ not relying on included headers.\n+\n+#ifndef __GLIBC__\n+\/\/ Alpine doesn't know these types, define them\n+typedef unsigned int       __uint32_t;\n+typedef unsigned short     __uint16_t;\n+typedef unsigned long int  __uint64_t;\n+#endif\n+\n+\/*\n+ * Timestamp structure for the timestamps in struct statx.\n+ *\/\n+struct my_statx_timestamp {\n+        int64_t   tv_sec;\n+        __uint32_t  tv_nsec;\n+        int32_t   __reserved;\n+};\n+\n+\/*\n+ * struct statx used by statx system call on >= glibc 2.28\n+ * systems\n+ *\/\n+struct my_statx\n+{\n+  __uint32_t stx_mask;\n+  __uint32_t stx_blksize;\n+  __uint64_t stx_attributes;\n+  __uint32_t stx_nlink;\n+  __uint32_t stx_uid;\n+  __uint32_t stx_gid;\n+  __uint16_t stx_mode;\n+  __uint16_t __statx_pad1[1];\n+  __uint64_t stx_ino;\n+  __uint64_t stx_size;\n+  __uint64_t stx_blocks;\n+  __uint64_t stx_attributes_mask;\n+  struct my_statx_timestamp stx_atime;\n+  struct my_statx_timestamp stx_btime;\n+  struct my_statx_timestamp stx_ctime;\n+  struct my_statx_timestamp stx_mtime;\n+  __uint32_t stx_rdev_major;\n+  __uint32_t stx_rdev_minor;\n+  __uint32_t stx_dev_major;\n+  __uint32_t stx_dev_minor;\n+  __uint64_t __statx_pad2[14];\n+};\n+\n+\/\/ statx masks, flags, constants\n+\n+#ifndef AT_SYMLINK_NOFOLLOW\n+#define AT_SYMLINK_NOFOLLOW 0x100\n+#endif\n+\n+#ifndef AT_STATX_SYNC_AS_STAT\n+#define AT_STATX_SYNC_AS_STAT 0x0000\n+#endif\n+\n+#ifndef AT_EMPTY_PATH\n+#define AT_EMPTY_PATH 0x1000\n+#endif\n+\n+#ifndef STATX_BASIC_STATS\n+#define STATX_BASIC_STATS 0x000007ffU\n+#endif\n+\n+#ifndef STATX_BTIME\n+#define STATX_BTIME 0x00000800U\n+#endif\n+\n+#ifndef STATX_ALL\n+#define STATX_ALL (STATX_BTIME | STATX_BASIC_STATS)\n+#endif\n+\n+#ifndef AT_FDCWD\n+#define AT_FDCWD -100\n+#endif\n+\n+#ifndef RTLD_DEFAULT\n+#define RTLD_DEFAULT RTLD_LOCAL\n+#endif\n+\n+#define NO_FOLLOW_SYMLINK 1\n+#define FOLLOW_SYMLINK 0\n+\n+#endif \/\/ __linux__\n+\n+\n@@ -120,1 +213,1 @@\n-#ifdef _DARWIN_FEATURE_64_BIT_INODE\n+#if defined(_DARWIN_FEATURE_64_BIT_INODE) || defined(__linux__)\n@@ -123,0 +216,3 @@\n+#if defined(__linux__) \/\/ Linux has nsec granularity if supported\n+static jfieldID attrs_st_birthtime_nsec;\n+#endif\n@@ -146,0 +242,4 @@\n+#if defined(__linux__)\n+typedef int statx_func(int dirfd, const char *restrict pathname, int flags,\n+                       unsigned int mask, struct my_statx *restrict statxbuf);\n+#endif\n@@ -155,0 +255,3 @@\n+#if defined(__linux__)\n+static statx_func* my_statx_func = NULL;\n+#endif\n@@ -180,0 +283,7 @@\n+#if defined(__linux__)\n+static int statx_wrapper(int dirfd, const char *restrict pathname, int flags,\n+                         unsigned int mask, struct my_statx *restrict statxbuf) {\n+    return (*my_statx_func)(dirfd, pathname, flags, mask, statxbuf);\n+}\n+#endif\n+\n@@ -232,1 +342,1 @@\n-#ifdef _DARWIN_FEATURE_64_BIT_INODE\n+#if defined(_DARWIN_FEATURE_64_BIT_INODE) || defined(__linux__)\n@@ -236,0 +346,4 @@\n+#if defined (__linux__) \/\/ Linux has nsec granularity\n+    attrs_st_birthtime_nsec = (*env)->GetFieldID(env, clazz, \"st_birthtime_nsec\", \"J\");\n+    CHECK_NULL_RETURN(attrs_st_birthtime_nsec, 0);\n+#endif\n@@ -317,0 +431,6 @@\n+#if defined(__linux__)\n+    my_statx_func = (statx_func*) dlsym(RTLD_DEFAULT, \"statx\");\n+    if (my_statx_func != NULL) {\n+        capabilities |= sun_nio_fs_UnixNativeDispatcher_SUPPORTS_BIRTHTIME;\n+    }\n+#endif\n@@ -493,0 +613,27 @@\n+#if defined(__linux__)\n+\/**\n+ * Copy statx members into sun.nio.fs.UnixFileAttributes\n+ *\/\n+static void copy_statx_attributes(JNIEnv* env, struct my_statx* buf, jobject attrs) {\n+    (*env)->SetIntField(env, attrs, attrs_st_mode, (jint)buf->stx_mode);\n+    (*env)->SetLongField(env, attrs, attrs_st_ino, (jlong)buf->stx_ino);\n+    (*env)->SetIntField(env, attrs, attrs_st_nlink, (jint)buf->stx_nlink);\n+    (*env)->SetIntField(env, attrs, attrs_st_uid, (jint)buf->stx_uid);\n+    (*env)->SetIntField(env, attrs, attrs_st_gid, (jint)buf->stx_gid);\n+    (*env)->SetLongField(env, attrs, attrs_st_size, (jlong)buf->stx_size);\n+    (*env)->SetLongField(env, attrs, attrs_st_atime_sec, (jlong)buf->stx_atime.tv_sec);\n+    (*env)->SetLongField(env, attrs, attrs_st_mtime_sec, (jlong)buf->stx_mtime.tv_sec);\n+    (*env)->SetLongField(env, attrs, attrs_st_ctime_sec, (jlong)buf->stx_ctime.tv_sec);\n+    (*env)->SetLongField(env, attrs, attrs_st_birthtime_sec, (jlong)buf->stx_btime.tv_sec);\n+    (*env)->SetLongField(env, attrs, attrs_st_birthtime_nsec, (jlong)buf->stx_btime.tv_nsec);\n+    (*env)->SetLongField(env, attrs, attrs_st_atime_nsec, (jlong)buf->stx_atime.tv_nsec);\n+    (*env)->SetLongField(env, attrs, attrs_st_mtime_nsec, (jlong)buf->stx_mtime.tv_nsec);\n+    (*env)->SetLongField(env, attrs, attrs_st_ctime_nsec, (jlong)buf->stx_ctime.tv_nsec);\n+    \/\/ convert statx major:minor to dev_t using makedev\n+    dev_t dev = makedev(buf->stx_dev_major, buf->stx_dev_minor);\n+    dev_t rdev = makedev(buf->stx_rdev_major, buf->stx_rdev_minor);\n+    (*env)->SetLongField(env, attrs, attrs_st_dev, (jlong)dev);\n+    (*env)->SetLongField(env, attrs, attrs_st_rdev, (jlong)rdev);\n+}\n+#endif\n+\n@@ -496,1 +643,1 @@\n-static void prepAttributes(JNIEnv* env, struct stat64* buf, jobject attrs) {\n+static void copy_stat64_attributes(JNIEnv* env, struct stat64* buf, jobject attrs) {\n@@ -511,0 +658,1 @@\n+    \/\/ rely on default value of 0 for st_birthtime_nsec field on Darwin\n@@ -531,1 +679,16 @@\n-\n+#if defined(__linux__)\n+    struct my_statx statx_buf;\n+    int flags = AT_STATX_SYNC_AS_STAT;\n+    unsigned int mask = STATX_ALL;\n+\n+    if (my_statx_func != NULL) {\n+        \/\/ Prefer statx over stat64 on Linux if it's available\n+        RESTARTABLE(statx_wrapper(AT_FDCWD, path, flags, mask, &statx_buf), err);\n+        if (err == 0) {\n+            copy_statx_attributes(env, &statx_buf, attrs);\n+            return 0;\n+        } else {\n+            return errno;\n+        }\n+    }\n+#endif\n@@ -534,1 +697,1 @@\n-        prepAttributes(env, &buf, attrs);\n+        copy_stat64_attributes(env, &buf, attrs);\n@@ -548,1 +711,17 @@\n-\n+#if defined(__linux__)\n+    struct my_statx statx_buf;\n+    int flags = AT_STATX_SYNC_AS_STAT | AT_SYMLINK_NOFOLLOW;\n+    unsigned int mask = STATX_ALL;\n+\n+    if (my_statx_func != NULL) {\n+        \/\/ Prefer statx over stat64 on Linux if it's available\n+        RESTARTABLE(statx_wrapper(AT_FDCWD, path, flags, mask, &statx_buf), err);\n+        if (err == 0) {\n+            copy_statx_attributes(env, &statx_buf, attrs);\n+        } else {\n+            throwUnixException(env, errno);\n+        }\n+        \/\/ statx was available, so return now\n+        return;\n+    }\n+#endif\n@@ -553,1 +732,1 @@\n-        prepAttributes(env, &buf, attrs);\n+        copy_stat64_attributes(env, &buf, attrs);\n@@ -563,1 +742,18 @@\n-\n+#if defined(__linux__)\n+    struct my_statx statx_buf;\n+    int flags = AT_EMPTY_PATH | AT_STATX_SYNC_AS_STAT;\n+    unsigned int mask = STATX_ALL;\n+\n+    if (my_statx_func != NULL) {\n+        \/\/ statx supports FD use via dirfd iff pathname is an empty string and the\n+        \/\/ AT_EMPTY_PATH flag is specified in flags\n+        RESTARTABLE(statx_wrapper((int)fd, \"\", flags, mask, &statx_buf), err);\n+        if (err == 0) {\n+            copy_statx_attributes(env, &statx_buf, attrs);\n+        } else {\n+            throwUnixException(env, errno);\n+        }\n+        \/\/ statx was available, so return now\n+        return;\n+    }\n+#endif\n@@ -568,1 +764,1 @@\n-        prepAttributes(env, &buf, attrs);\n+        copy_stat64_attributes(env, &buf, attrs);\n@@ -579,0 +775,20 @@\n+#if defined(__linux__)\n+    struct my_statx statx_buf;\n+    int flags = AT_STATX_SYNC_AS_STAT;\n+    unsigned int mask = STATX_ALL;\n+\n+    if (my_statx_func != NULL) {\n+        \/\/ Prefer statx over stat64 on Linux if it's available\n+        if (((int)flag & AT_SYMLINK_NOFOLLOW) > 0) { \/\/ flag set in java code\n+            flags |= AT_SYMLINK_NOFOLLOW;\n+        }\n+        RESTARTABLE(statx_wrapper((int)dfd, path, flags, mask, &statx_buf), err);\n+        if (err == 0) {\n+            copy_statx_attributes(env, &statx_buf, attrs);\n+        } else {\n+            throwUnixException(env, errno);\n+        }\n+        \/\/ statx was available, so return now\n+        return;\n+    }\n+#endif\n@@ -588,1 +804,1 @@\n-        prepAttributes(env, &buf, attrs);\n+        copy_stat64_attributes(env, &buf, attrs);\n","filename":"src\/java.base\/unix\/native\/libnio\/fs\/UnixNativeDispatcher.c","additions":226,"deletions":10,"binary":false,"changes":236,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -327,0 +327,4 @@\n+        if (cptr == NULL) {\n+            printf(\"*** cannot allocate memory\\n\");\n+            doabort();\n+        }\n","filename":"src\/java.base\/windows\/native\/libjli\/cmdtoargs.c","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -242,1 +242,1 @@\n-        _snwprintf(url, sizeof(url) - 1, L\"%s:\/\/%s\", lpProto, lpHost);\n+        swprintf(url, MAX_STR_LEN, L\"%s:\/\/%s\", lpProto, lpHost);\n","filename":"src\/java.base\/windows\/native\/libnet\/DefaultProxySelector.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -228,69 +228,0 @@\n-\/* call NET_MapSocketOptionV6 for the IPv6 fd only\n- * and NET_MapSocketOption for the IPv4 fd\n- *\/\n-JNIEXPORT int JNICALL\n-NET_MapSocketOptionV6(jint cmd, int *level, int *optname) {\n-\n-    switch (cmd) {\n-        case java_net_SocketOptions_IP_MULTICAST_IF:\n-        case java_net_SocketOptions_IP_MULTICAST_IF2:\n-            *level = IPPROTO_IPV6;\n-            *optname = IPV6_MULTICAST_IF;\n-            return 0;\n-\n-        case java_net_SocketOptions_IP_MULTICAST_LOOP:\n-            *level = IPPROTO_IPV6;\n-            *optname = IPV6_MULTICAST_LOOP;\n-            return 0;\n-    }\n-    return NET_MapSocketOption (cmd, level, optname);\n-}\n-\n-\/*\n- * Map the Java level socket option to the platform specific\n- * level and option name.\n- *\/\n-\n-JNIEXPORT int JNICALL\n-NET_MapSocketOption(jint cmd, int *level, int *optname) {\n-\n-    typedef struct {\n-        jint cmd;\n-        int level;\n-        int optname;\n-    } sockopts;\n-\n-    static sockopts opts[] = {\n-        { java_net_SocketOptions_TCP_NODELAY,   IPPROTO_TCP,    TCP_NODELAY },\n-        { java_net_SocketOptions_SO_OOBINLINE,  SOL_SOCKET,     SO_OOBINLINE },\n-        { java_net_SocketOptions_SO_LINGER,     SOL_SOCKET,     SO_LINGER },\n-        { java_net_SocketOptions_SO_SNDBUF,     SOL_SOCKET,     SO_SNDBUF },\n-        { java_net_SocketOptions_SO_RCVBUF,     SOL_SOCKET,     SO_RCVBUF },\n-        { java_net_SocketOptions_SO_KEEPALIVE,  SOL_SOCKET,     SO_KEEPALIVE },\n-        { java_net_SocketOptions_SO_REUSEADDR,  SOL_SOCKET,     SO_REUSEADDR },\n-        { java_net_SocketOptions_SO_BROADCAST,  SOL_SOCKET,     SO_BROADCAST },\n-        { java_net_SocketOptions_IP_MULTICAST_IF,   IPPROTO_IP, IP_MULTICAST_IF },\n-        { java_net_SocketOptions_IP_MULTICAST_LOOP, IPPROTO_IP, IP_MULTICAST_LOOP },\n-        { java_net_SocketOptions_IP_TOS,            IPPROTO_IP, IP_TOS },\n-\n-    };\n-\n-\n-    int i;\n-\n-    \/*\n-     * Map the Java level option to the native level\n-     *\/\n-    for (i=0; i<(int)(sizeof(opts) \/ sizeof(opts[0])); i++) {\n-        if (cmd == opts[i].cmd) {\n-            *level = opts[i].level;\n-            *optname = opts[i].optname;\n-            return 0;\n-        }\n-    }\n-\n-    \/* not found *\/\n-    return -1;\n-}\n-\n-\n@@ -395,11 +326,0 @@\n-JNIEXPORT int JNICALL\n-NET_SocketAvailable(int s, int *pbytes) {\n-    u_long arg;\n-    if (ioctlsocket((SOCKET)s, FIONREAD, &arg) == SOCKET_ERROR) {\n-        return -1;\n-    } else {\n-        *pbytes = (int) arg;\n-        return 0;\n-    }\n-}\n-\n@@ -407,1 +327,1 @@\n- * Sets SO_ECLUSIVEADDRUSE if SO_REUSEADDR is not already set.\n+ * Sets SO_EXCLUSIVEADDRUSE if SO_REUSEADDR is not already set.\n","filename":"src\/java.base\/windows\/native\/libnet\/net_util_md.c","additions":1,"deletions":81,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -92,1 +92,1 @@\n-        handleSocketError(env, WSAGetLastError());\n+        NET_ThrowNew(env, WSAGetLastError(), \"connect\");\n@@ -139,1 +139,4 @@\n-            } else return handleSocketError(env, theErr);\n+            } else {\n+                NET_ThrowNew(env, theErr, \"recvfrom\");\n+                return IOS_THROWN;\n+            }\n@@ -163,1 +166,2 @@\n-        return handleSocketError(env, (jint)WSAGetLastError());\n+        NET_ThrowNew(env, (jint)WSAGetLastError(), \"sendto\");\n+        return IOS_THROWN;\n","filename":"src\/java.base\/windows\/native\/libnio\/ch\/DatagramChannelImpl.c","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -152,2 +152,1 @@\n-        int error = WSAGetLastError();\n-        handleSocketError(env, (jint)error);\n+        NET_ThrowNew(env, WSAGetLastError(), \"ioctlsocket\");\n","filename":"src\/java.base\/windows\/native\/libnio\/ch\/IOUtil.c","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -80,6 +80,0 @@\n-jint handleSocketError(JNIEnv *env, int errorValue)\n-{\n-    NET_ThrowNew(env, errorValue, NULL);\n-    return IOS_THROWN;\n-}\n-\n@@ -395,1 +389,1 @@\n-        handleSocketError(env, WSAGetLastError());\n+        NET_ThrowNew(env, WSAGetLastError(), \"getsockopt\");\n@@ -439,1 +433,1 @@\n-        handleSocketError(env, WSAGetLastError());\n+        NET_ThrowNew(env, WSAGetLastError(), \"setsocketopt\");\n@@ -470,1 +464,1 @@\n-        handleSocketError(env, WSAGetLastError());\n+        NET_ThrowNew(env, WSAGetLastError(), \"setsocketopt\");\n@@ -492,1 +486,1 @@\n-        handleSocketError(env, WSAGetLastError());\n+        NET_ThrowNew(env, WSAGetLastError(), \"setsockopt\");\n@@ -545,1 +539,1 @@\n-        handleSocketError(env, WSAGetLastError());\n+        NET_ThrowNew(env, WSAGetLastError(), \"setsockopt\");\n@@ -557,1 +551,1 @@\n-        handleSocketError(env, WSAGetLastError());\n+        NET_ThrowNew(env, WSAGetLastError(), \"setsocketopt to block or unblock source\");\n@@ -574,1 +568,1 @@\n-        handleSocketError(env, WSAGetLastError());\n+        NET_ThrowNew(env, WSAGetLastError(), \"setsockopt\");\n@@ -587,1 +581,1 @@\n-        handleSocketError(env, WSAGetLastError());\n+        NET_ThrowNew(env, WSAGetLastError(), \"getsockopt\");\n@@ -603,1 +597,1 @@\n-        handleSocketError(env, WSAGetLastError());\n+        NET_ThrowNew(env, WSAGetLastError(), \"setsockopt\");\n@@ -616,1 +610,1 @@\n-        handleSocketError(env, WSAGetLastError());\n+        NET_ThrowNew(env, WSAGetLastError(), \"getsockopt\");\n@@ -634,3 +628,3 @@\n-    int count = 0;\n-    if (NET_SocketAvailable(fdval(env, fdo), &count) != 0) {\n-        handleSocketError(env, WSAGetLastError());\n+    u_long arg;\n+    if (ioctlsocket((SOCKET) fdval(env, fdo), FIONREAD, &arg) == SOCKET_ERROR) {\n+        NET_ThrowNew(env, WSAGetLastError(), \"ioctlsocket\");\n@@ -639,1 +633,1 @@\n-    return (jint) count;\n+    return (jint) arg;\n@@ -670,1 +664,1 @@\n-        handleSocketError(env, WSAGetLastError());\n+        NET_ThrowNew(env, WSAGetLastError(), \"select\");\n@@ -710,1 +704,1 @@\n-        handleSocketError(env, WSAGetLastError());\n+        NET_ThrowNew(env, WSAGetLastError(), \"select\");\n@@ -730,1 +724,1 @@\n-            handleSocketError(env, optError);\n+            NET_ThrowNew(env, optError, \"getsockopt\");\n","filename":"src\/java.base\/windows\/native\/libnio\/ch\/Net.c","additions":17,"deletions":23,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -121,0 +121,3 @@\n+            if (infoPtr == NULL) {\n+                return JNI_FALSE;\n+            }\n@@ -161,1 +164,2 @@\n-        return handleSocketError(env, WSAGetLastError());\n+        NET_ThrowNew(env, WSAGetLastError(), \"WSASocketW\");\n+        return IOS_THROWN;\n","filename":"src\/java.base\/windows\/native\/libnio\/ch\/UnixDomainSockets.c","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,0 @@\n-jint handleSocketError(JNIEnv *env, int errorValue);\n","filename":"src\/java.base\/windows\/native\/libnio\/ch\/nio_util.h","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,1 @@\n+static NSInteger architecture = -1;\n@@ -61,1 +62,11 @@\n-static BOOL isValidDisplayMode(CGDisplayModeRef mode){\n+static BOOL isValidDisplayMode(CGDisplayModeRef mode) {\n+    \/\/ Workaround for apple bug FB13261205, since it only affects arm based macs\n+    \/\/ and arm support started with macOS 11 ignore the workaround for previous versions\n+    if (@available(macOS 11, *)) {\n+        if (architecture == -1) {\n+            architecture = [[NSRunningApplication currentApplication] executableArchitecture];\n+        }\n+        if (architecture == NSBundleExecutableArchitectureARM64) {\n+            return (CGDisplayModeGetPixelWidth(mode) >= 800);\n+        }\n+    }\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/CGraphicsDevice.m","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -299,0 +299,5 @@\n+    if (mtlsdo == NULL) {\n+        JNU_ThrowOutOfMemoryError(env, \"Initialization of SurfaceData failed.\");\n+        return;\n+    }\n+\n@@ -306,6 +311,1 @@\n-        JNU_ThrowOutOfMemoryError(env, \"Initialization of SurfaceData failed.\");\n-        return;\n-    }\n-\n-    if (mtlsdo == NULL) {\n-        (*env)->DeleteGlobalRef(env, gc);\n+        free(mtlsdo);\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLSurfaceData.m","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -276,1 +276,2 @@\n-    pthread_attr_init(&attr);\n+    int rslt = pthread_attr_init(&attr);\n+    if (rslt != 0) return;\n@@ -278,0 +279,1 @@\n+    pthread_attr_destroy(&attr);\n","filename":"src\/java.desktop\/macosx\/native\/libsplashscreen\/splashscreen_sys.m","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n- Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,1 +61,0 @@\n-            class=\"centered\"\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/doc-files\/FocusCycle.svg","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -937,1 +937,1 @@\n-     * the popup menu menu is to be displayed.\n+     * the popup menu is to be displayed.\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JPopupMenu.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -373,7 +373,0 @@\n-        contentPane.add(component);\n-        if (\"true\".equals(AccessController.\n-            doPrivileged(new GetPropertyAction(\"swing.jlf.contentPaneTransparent\", \"false\"))))\n-        {\n-            contentPane.setOpaque(false);\n-        }\n-        setContentPane(contentPane);\n@@ -399,0 +392,9 @@\n+        contentPane.add(component);\n+        contentPane.revalidate();\n+        contentPane.repaint();\n+        if (\"true\".equals(AccessController.\n+            doPrivileged(new GetPropertyAction(\"swing.jlf.contentPaneTransparent\", \"false\"))))\n+        {\n+            contentPane.setOpaque(false);\n+        }\n+        setContentPane(contentPane);\n","filename":"src\/java.desktop\/share\/classes\/sun\/swing\/JLightweightFrame.java","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import sun.java2d.pipe.Region;\n@@ -31,0 +32,1 @@\n+import java.awt.GraphicsConfiguration;\n@@ -34,0 +36,1 @@\n+import java.awt.geom.AffineTransform;\n@@ -112,3 +115,14 @@\n-                .map(graphicsDevice ->\n-                        graphicsDevice.getDefaultConfiguration().getBounds()\n-                ).toList();\n+                .map(graphicsDevice -> {\n+                    GraphicsConfiguration gc =\n+                            graphicsDevice.getDefaultConfiguration();\n+                    Rectangle screen = gc.getBounds();\n+                    AffineTransform tx = gc.getDefaultTransform();\n+\n+                    return new Rectangle(\n+                            Region.clipRound(screen.x * tx.getScaleX()),\n+                            Region.clipRound(screen.y * tx.getScaleY()),\n+                            Region.clipRound(screen.width * tx.getScaleX()),\n+                            Region.clipRound(screen.height * tx.getScaleY())\n+                    );\n+                })\n+                .toList();\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/screencast\/ScreencastHelper.java","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -372,0 +372,11 @@\n+        \/\/ 3. add tokens with the same or greater number of screens\n+        \/\/ This is useful if we once received a token with one screen resolution\n+        \/\/ and the same screen was later scaled in the system.\n+        \/\/ In that case, the token is still valid.\n+\n+        allTokenItems\n+                .stream()\n+                .filter(t ->\n+                        t.allowedScreensBounds.size() >= affectedScreenBounds.size())\n+                .forEach(result::add);\n+\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/screencast\/TokenStorage.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -53,2 +53,0 @@\n-extern int XShmQueryExtension();\n-\n","filename":"src\/java.desktop\/unix\/native\/common\/awt\/awt_GraphicsEnv.h","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1468,1 +1468,1 @@\n-                    (*fp_gtk_notebook_new)(NULL);\n+                    (*fp_gtk_notebook_new)();\n@@ -1476,1 +1476,1 @@\n-                    (*fp_gtk_toggle_button_new)(NULL);\n+                    (*fp_gtk_toggle_button_new)();\n@@ -1485,1 +1485,1 @@\n-                    (*fp_gtk_toolbar_new)(NULL);\n+                    (*fp_gtk_toolbar_new)();\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/awt\/gtk2_interface.c","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -322,0 +322,4 @@\n+        fp_gdk_pixbuf_new_from_data = dl_symbol(\"gdk_pixbuf_new_from_data\");\n+        fp_gdk_pixbuf_scale_simple = dl_symbol(\"gdk_pixbuf_scale_simple\");\n+        fp_gdk_pixbuf_copy_area = dl_symbol(\"gdk_pixbuf_copy_area\");\n+\n@@ -1255,1 +1259,1 @@\n-                    (*fp_gtk_notebook_new)(NULL);\n+                    (*fp_gtk_notebook_new)();\n@@ -1263,1 +1267,1 @@\n-                    (*fp_gtk_toggle_button_new)(NULL);\n+                    (*fp_gtk_toggle_button_new)();\n@@ -1272,1 +1276,1 @@\n-                    (*fp_gtk_toolbar_new)(NULL);\n+                    (*fp_gtk_toolbar_new)();\n@@ -3126,0 +3130,6 @@\n+\n+    gtk->gdk_pixbuf_new = fp_gdk_pixbuf_new;\n+    gtk->gdk_pixbuf_new_from_data = fp_gdk_pixbuf_new_from_data;\n+    gtk->gdk_pixbuf_scale_simple = fp_gdk_pixbuf_scale_simple;\n+    gtk->gdk_pixbuf_get_pixels = fp_gdk_pixbuf_get_pixels;\n+    gtk->gdk_pixbuf_copy_area = fp_gdk_pixbuf_copy_area;\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/awt\/gtk3_interface.c","additions":13,"deletions":3,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -531,0 +531,24 @@\n+\n+static GdkPixbuf *(*fp_gdk_pixbuf_new_from_data)(\n+        const guchar *data,\n+        GdkColorspace colorspace,\n+        gboolean has_alpha,\n+        int bits_per_sample,\n+        int width,\n+        int height,\n+        int rowstride,\n+        GdkPixbufDestroyNotify destroy_fn,\n+        gpointer destroy_fn_data\n+);\n+\n+static void (*fp_gdk_pixbuf_copy_area) (\n+        const GdkPixbuf* src_pixbuf,\n+        int src_x,\n+        int src_y,\n+        int width,\n+        int height,\n+        GdkPixbuf* dest_pixbuf,\n+        int dest_x,\n+        int dest_y\n+);\n+\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/awt\/gtk3_interface.h","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -535,0 +535,2 @@\n+typedef void GdkPixbuf;\n+typedef void (* GdkPixbufDestroyNotify) (guchar *pixels, gpointer data);\n@@ -800,0 +802,40 @@\n+    GdkPixbuf *(*gdk_pixbuf_new)(GdkColorspace colorspace,\n+                                 gboolean has_alpha,\n+                                 int bits_per_sample,\n+                                 int width,\n+                                 int height);\n+\n+\n+    GdkPixbuf *(*gdk_pixbuf_new_from_data)(\n+            const guchar *data,\n+            GdkColorspace colorspace,\n+            gboolean has_alpha,\n+            int bits_per_sample,\n+            int width,\n+            int height,\n+            int rowstride,\n+            GdkPixbufDestroyNotify destroy_fn,\n+            gpointer destroy_fn_data\n+    );\n+\n+\n+    GdkPixbuf *(*gdk_pixbuf_scale_simple)(GdkPixbuf *src,\n+                                          int dest_width,\n+                                          int dest_heigh,\n+                                          GdkInterpType interp_type\n+    );\n+\n+    guchar* (*gdk_pixbuf_get_pixels) (const GdkPixbuf* pixbuf);\n+\n+\n+    void (*gdk_pixbuf_copy_area) (\n+            const GdkPixbuf* src_pixbuf,\n+            int src_x,\n+            int src_y,\n+            int width,\n+            int height,\n+            GdkPixbuf* dest_pixbuf,\n+            int dest_x,\n+            int dest_y\n+    );\n+\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/awt\/gtk_interface.h","additions":42,"deletions":0,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -178,43 +178,0 @@\n-static inline void convertRGBxToBGRx(int* in) {\n-    char* o = (char*) in;\n-    char tmp = o[0];\n-    o[0] = o[2];\n-    o[2] = tmp;\n-}\n-\n-static gchar * cropTo(\n-        struct spa_data data,\n-        struct spa_video_info_raw raw,\n-        guint32 x,\n-        guint32 y,\n-        guint32 width,\n-        guint32 height\n-) {\n-    int srcW = raw.size.width;\n-    if (data.chunk->stride \/ 4 != srcW) {\n-        fprintf(stderr, \"%s:%i Unexpected stride \/ 4: %i srcW: %i\\n\",\n-                __func__, __LINE__, data.chunk->stride \/ 4, srcW);\n-    }\n-\n-    int* d = data.data;\n-\n-    int *outData = calloc(width * height, sizeof(int));\n-    if (!outData) {\n-        ERR(\"failed to allocate memory\\n\");\n-        return NULL;\n-    }\n-\n-    gboolean needConversion = raw.format != SPA_VIDEO_FORMAT_BGRx;\n-    for (guint32 j = y; j < y + height; ++j) {\n-        for (guint32 i = x; i < x + width; ++i) {\n-            int color = *(d + (j * srcW) + i);\n-            if (needConversion) {\n-                convertRGBxToBGRx(&color);\n-            }\n-            *(outData + ((j - y) * width) + (i - x)) = color;\n-        }\n-    }\n-\n-    return (gchar*) outData;\n-}\n-\n@@ -304,0 +261,3 @@\n+    gint streamWidth = data->rawFormat.size.width;\n+    gint streamHeight = data->rawFormat.size.height;\n+\n@@ -307,1 +267,1 @@\n-                        \"flags %d FD %li captureDataReady %i\\n\",\n+                        \"flags %d FD %li captureDataReady %i of stream %dx%d\\n\",\n@@ -313,1 +273,3 @@\n-                        screen->captureDataReady\n+                        screen->captureDataReady,\n+                        streamWidth,\n+                        streamHeight\n@@ -316,6 +278,58 @@\n-    data->screenProps->captureData = cropTo(\n-            spaData,\n-            data->rawFormat,\n-            screen->captureArea.x, screen->captureArea.y,\n-            screen->captureArea.width, screen->captureArea.height\n-    );\n+    GdkRectangle captureArea = screen->captureArea;\n+    GdkRectangle screenBounds = screen->bounds;\n+\n+    GdkPixbuf *pixbuf = gtk->gdk_pixbuf_new_from_data(spaData.data,\n+                                                      GDK_COLORSPACE_RGB,\n+                                                      TRUE,\n+                                                      8,\n+                                                      streamWidth,\n+                                                      streamHeight,\n+                                                      spaData.chunk->stride,\n+                                                      NULL,\n+                                                      NULL);\n+\n+    if (screen->bounds.width != streamWidth\n+        || screen->bounds.height != streamHeight) {\n+\n+        DEBUG_SCREEN_PREFIX(screen, \"scaling stream data %dx%d -> %dx%d\\n\",\n+                         streamWidth, streamHeight,\n+                         screen->bounds.width, screen->bounds.height\n+        );\n+\n+        GdkPixbuf *scaled = gtk->gdk_pixbuf_scale_simple(pixbuf,\n+                                                         screen->bounds.width,\n+                                                         screen->bounds.height,\n+                                                         GDK_INTERP_BILINEAR);\n+\n+        gtk->g_object_unref(pixbuf);\n+        pixbuf = scaled;\n+    }\n+\n+    GdkPixbuf *cropped = NULL;\n+    if (captureArea.width != screenBounds.width\n+        || captureArea.height != screenBounds.height) {\n+\n+        cropped = gtk->gdk_pixbuf_new(GDK_COLORSPACE_RGB,\n+                                      TRUE,\n+                                      8,\n+                                      captureArea.width,\n+                                      captureArea.height);\n+        if (cropped) {\n+            gtk->gdk_pixbuf_copy_area(pixbuf,\n+                                      captureArea.x,\n+                                      captureArea.y,\n+                                      captureArea.width,\n+                                      captureArea.height,\n+                                      cropped,\n+                                      0, 0);\n+        } else {\n+            ERR(\"Cannot create a new pixbuf.\\n\");\n+        }\n+\n+        gtk->g_object_unref(pixbuf);\n+        pixbuf = NULL;\n+\n+        data->screenProps->captureDataPixbuf = cropped;\n+    } else {\n+        data->screenProps->captureDataPixbuf = pixbuf;\n+    }\n@@ -369,5 +383,1 @@\n-            SPA_POD_CHOICE_ENUM_Id(\n-                    2,\n-                    SPA_VIDEO_FORMAT_RGBx,\n-                    SPA_VIDEO_FORMAT_BGRx\n-            ),\n+            SPA_POD_Id(SPA_VIDEO_FORMAT_BGRx),\n@@ -913,1 +923,1 @@\n-                                i, screenProps->captureData,\n+                                i, screenProps->captureDataPixbuf,\n@@ -927,1 +937,1 @@\n-            if (screenProps->captureData) {\n+            if (screenProps->captureDataPixbuf) {\n@@ -942,2 +952,4 @@\n-                            ((jint *) screenProps->captureData)\n-                                + (captureArea.width * y)\n+                            ((jint *) gtk->gdk_pixbuf_get_pixels(\n+                                    screenProps->captureDataPixbuf\n+                            ))\n+                            + (captureArea.width * y)\n@@ -948,2 +960,4 @@\n-            free(screenProps->captureData);\n-            screenProps->captureData = NULL;\n+            if (screenProps->captureDataPixbuf) {\n+                gtk->g_object_unref(screenProps->captureDataPixbuf);\n+                screenProps->captureDataPixbuf = NULL;\n+            }\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/awt\/screencast_pipewire.c","additions":76,"deletions":62,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-    gchar *captureData;\n+    GdkPixbuf *captureDataPixbuf;\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/awt\/screencast_pipewire.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -776,1 +776,2 @@\n-    pthread_attr_init(&attr);\n+    int rslt = pthread_attr_init(&attr);\n+    if (rslt != 0) return;\n@@ -778,0 +779,1 @@\n+    pthread_attr_destroy(&attr);\n","filename":"src\/java.desktop\/unix\/native\/libsplashscreen\/splashscreen_sys.c","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -581,0 +581,1 @@\n+                        return true;\n@@ -582,1 +583,1 @@\n-                    return true;\n+                    return false;\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/HttpClientImpl.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -186,1 +186,1 @@\n-            while (!inputQ.isEmpty()) {\n+            while (!inputQ.isEmpty() && errorRef.get() == null) {\n@@ -420,0 +420,4 @@\n+        \/\/ ensure that the body subscriber will be subscribed and onError() is\n+        \/\/ invoked\n+        pendingResponseSubscriber = bodySubscriber;\n+\n@@ -430,3 +434,0 @@\n-        \/\/ ensure that the body subscriber will be subscribed and onError() is\n-        \/\/ invoked\n-        pendingResponseSubscriber = bodySubscriber;\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Stream.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -4653,1 +4653,1 @@\n-                    hasBindings(patternLabel.pat)) {\n+                    (hasBindings(patternLabel.pat) || hasBindings(c.guard))) {\n@@ -4657,1 +4657,1 @@\n-                           hasBindings(patternLabel.pat) &&\n+                           (hasBindings(patternLabel.pat) || hasBindings(c.guard)) &&\n@@ -4666,1 +4666,1 @@\n-    boolean hasBindings(JCPattern p) {\n+    boolean hasBindings(JCTree p) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -170,1 +170,1 @@\n-    private final Set<Pair<JCTree, RefSet<Ref>>> invocations = new HashSet<>();\n+    private final Set<Pair<JCMethodDecl, RefSet<Ref>>> invocations = new HashSet<>();\n@@ -593,1 +593,1 @@\n-            Pair<JCTree, RefSet<Ref>> invocation = Pair.of(site, refs.clone());\n+            Pair<JCMethodDecl, RefSet<Ref>> invocation = Pair.of(methodInfo.declaration, refs.clone());\n@@ -681,1 +681,5 @@\n-        visitLooped(tree, super::visitForeachLoop);\n+        visitLooped(tree, foreach -> {\n+            scan(foreach.expr);\n+            refs.discardExprs(depth);       \/\/ we don't handle iterator() yet\n+            scan(foreach.body);\n+        });\n@@ -732,1 +736,4 @@\n-        visitDeferred(() -> visitScoped(false, () -> super.visitLambda(lambda)));\n+        visitDeferred(() -> visitScoped(false, () -> {\n+            scan(lambda.body);\n+            refs.discardExprs(depth);       \/\/ needed in case body is a JCExpression\n+        }));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ThisEscapeAnalyzer.java","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -912,0 +912,1 @@\n+                checkNoMods(pos, mods.flags & Flags.FINAL);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1653,1 +1653,1 @@\n-                    node.body.stats.nonEmpty() && TreeInfo.isSuperCall(node.body.stats.head) &&\n+                    node.body != null && node.body.stats.nonEmpty() && TreeInfo.isSuperCall(node.body.stats.head) &&\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/processing\/JavacProcessingEnvironment.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -431,0 +431,1 @@\n+    @java.io.Serial\n@@ -433,1 +434,1 @@\n-            throw new NotSerializableException(\"Token has been removed\");\n+            throw new InvalidObjectException(\"Token has been removed\");\n@@ -438,0 +439,16 @@\n+    \/**\n+     * Restores the state of this object from the stream.\n+     * <p>\n+     * Deserialization of this object is not supported.\n+     *\n+     * @param  stream the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n+     *\/\n+    @java.io.Serial\n+    private void readObject(ObjectInputStream stream)\n+            throws IOException, ClassNotFoundException {\n+        throw new InvalidObjectException(\n+                \"Tokens are not directly deserializable\");\n+    }\n+\n@@ -452,0 +469,1 @@\n+        @java.io.Serial\n@@ -461,1 +479,1 @@\n-            throw new NotSerializableException(\"Could not find token\");\n+            throw new InvalidObjectException(\"Could not find token\");\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/Token.java","additions":21,"deletions":3,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import java.io.IOException;\n+import java.io.InvalidObjectException;\n+import java.io.ObjectInputStream;\n@@ -38,0 +41,1 @@\n+    @java.io.Serial\n@@ -75,0 +79,1 @@\n+    @java.io.Serial\n@@ -77,1 +82,18 @@\n-        throw new java.io.NotSerializableException();\n+        throw new java.io.InvalidObjectException(\n+                \"CPrivateKeys are not serializable\");\n+    }\n+\n+    \/**\n+     * Restores the state of this object from the stream.\n+     * <p>\n+     * Deserialization of this object is not supported.\n+     *\n+     * @param  stream the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n+     *\/\n+    @java.io.Serial\n+    private void readObject(ObjectInputStream stream)\n+            throws IOException, ClassNotFoundException {\n+        throw new InvalidObjectException(\n+                \"CPrivateKeys are not deserializable\");\n","filename":"src\/jdk.crypto.mscapi\/windows\/classes\/sun\/security\/mscapi\/CPrivateKey.java","additions":24,"deletions":2,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -28,0 +28,3 @@\n+import java.io.IOException;\n+import java.io.InvalidObjectException;\n+import java.io.ObjectInputStream;\n@@ -53,0 +56,1 @@\n+    @java.io.Serial\n@@ -61,0 +65,2 @@\n+\n+        @java.io.Serial\n@@ -112,1 +118,1 @@\n-            sb.append(algorithm + \"PublicKey [size=\").append(keyLength)\n+            sb.append(algorithm).append(\"PublicKey [size=\").append(keyLength)\n@@ -123,0 +129,2 @@\n+\n+        @java.io.Serial\n@@ -131,1 +139,1 @@\n-            sb.append(algorithm + \"PublicKey [size=\").append(keyLength)\n+            sb.append(algorithm).append(\"PublicKey [size=\").append(keyLength)\n@@ -218,0 +226,1 @@\n+    @java.io.Serial\n@@ -225,0 +234,16 @@\n+    \/**\n+     * Restores the state of this object from the stream.\n+     * <p>\n+     * Deserialization of this object is not supported.\n+     *\n+     * @param  stream the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n+     *\/\n+    @java.io.Serial\n+    private void readObject(ObjectInputStream stream)\n+            throws IOException, ClassNotFoundException {\n+        throw new InvalidObjectException(\n+                \"CPublicKeys are not deserializable\");\n+    }\n+\n","filename":"src\/jdk.crypto.mscapi\/windows\/classes\/sun\/security\/mscapi\/CPublicKey.java","additions":27,"deletions":2,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n-import jdk.internal.javac.ParticipatesInPreview;\n-\n@@ -36,1 +34,0 @@\n-@ParticipatesInPreview\n","filename":"src\/jdk.incubator.vector\/share\/classes\/module-info.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1303,0 +1303,5 @@\n+    \/**\n+     * Clears the oop handle in {@code handle}.\n+     *\/\n+    native void clearOopHandle(long handle);\n+\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/CompilerToVM.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -158,1 +158,2 @@\n-     * {@link CompilerToVM#releaseClearedOopHandles}.\n+     * {@link CompilerToVM#releaseClearedOopHandles}. This must be done with a VM call so\n+     * that the JNI handle is cleared at a safepoint.\n@@ -161,1 +162,1 @@\n-        UNSAFE.putLong(handle, 0);\n+        runtime().compilerToVm.clearOopHandle(handle);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/IndirectHotSpotObjectConstantImpl.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -102,1 +102,1 @@\n-        return new RISCV64HotSpotRegisterConfig(target, config.useCompressedOops, config.linuxOs);\n+        return new RISCV64HotSpotRegisterConfig(target, config.useCompressedOops, target.linuxOs);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/riscv64\/RISCV64HotSpotJVMCIBackendFactory.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n-import jdk.vm.ci.services.Services;\n-import jdk.internal.util.OperatingSystem;\n@@ -41,2 +39,0 @@\n-    final boolean linuxOs = OperatingSystem.isLinux();\n-\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/riscv64\/RISCV64HotSpotVMConfig.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -540,0 +540,10 @@\n+    \/**\n+     * Add the restricted information for the given method.\n+     *\n+     * @param method the method being documented.\n+     * @param content the content to which the preview information will be added.\n+     *\/\n+    protected void addRestrictedInfo(ExecutableElement method, Content content) {\n+        writer.addRestrictedInfo(method, content);\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/AbstractMemberWriter.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -97,3 +97,3 @@\n-\n-                buildAnnotationTypeMemberChildren(annotationContent);\n-\n+                Content div = HtmlTree.DIV(HtmlStyle.horizontalScroll);\n+                buildAnnotationTypeMemberChildren(div);\n+                annotationContent.add(div);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/AnnotationTypeMemberWriter.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -161,1 +161,1 @@\n-        Content c = new ContentBuilder();\n+        Content c = HtmlTree.DIV(HtmlStyle.horizontalScroll);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/ClassWriter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -109,7 +109,7 @@\n-\n-                buildSignature(constructorContent);\n-                buildDeprecationInfo(constructorContent);\n-                buildPreviewInfo(constructorContent);\n-                buildConstructorComments(constructorContent);\n-                buildTagInfo(constructorContent);\n-\n+                Content div = HtmlTree.DIV(HtmlStyle.horizontalScroll);\n+                buildSignature(div);\n+                buildDeprecationInfo(div);\n+                buildPreviewInfo(div);\n+                buildConstructorComments(div);\n+                buildTagInfo(div);\n+                constructorContent.add(div);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/ConstructorWriter.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -160,0 +160,3 @@\n+    public final Content restrictedMark;\n+    public final Content restrictedMethods;\n+    public final Content restrictedPhrase;\n@@ -306,0 +309,3 @@\n+        restrictedMark = getContent(\"doclet.Restricted_Mark\");\n+        restrictedMethods = getContent(\"doclet.Restricted_Methods\");\n+        restrictedPhrase = getContent(\"doclet.Restricted\");\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/Contents.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -76,7 +76,7 @@\n-\n-                buildSignature(enumConstantContent);\n-                buildDeprecationInfo(enumConstantContent);\n-                buildPreviewInfo(enumConstantContent);\n-                buildEnumConstantComments(enumConstantContent);\n-                buildTagInfo(enumConstantContent);\n-\n+                Content div = HtmlTree.DIV(HtmlStyle.horizontalScroll);\n+                buildSignature(div);\n+                buildDeprecationInfo(div);\n+                buildPreviewInfo(div);\n+                buildEnumConstantComments(div);\n+                buildTagInfo(div);\n+                enumConstantContent.add(div);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/EnumConstantWriter.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -86,7 +86,7 @@\n-\n-                buildSignature(fieldContent);\n-                buildDeprecationInfo(fieldContent);\n-                buildPreviewInfo(fieldContent);\n-                buildFieldComments(fieldContent);\n-                buildTagInfo(fieldContent);\n-\n+                Content div = HtmlTree.DIV(HtmlStyle.horizontalScroll);\n+                buildSignature(div);\n+                buildDeprecationInfo(div);\n+                buildPreviewInfo(div);\n+                buildFieldComments(div);\n+                buildTagInfo(div);\n+                fieldContent.add(div);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/FieldWriter.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -345,0 +345,9 @@\n+        \/\/ Restricted\n+        if (configuration.conditionalPages.contains(HtmlConfiguration.ConditionalPage.RESTRICTED)) {\n+            section = newHelpSection(contents.restrictedMethods, PageMode.RESTRICTED, subTOC);\n+            Content restrictedBody = getContent(\"doclet.help.restricted.body\",\n+                    links.createLink(DocPaths.RESTRICTED_LIST, resources.getText(\"doclet.Restricted_Methods\")));\n+            section.add(HtmlTree.P(restrictedBody));\n+            pageKindsSection.add(section);\n+        }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HelpWriter.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -71,0 +71,1 @@\n+import jdk.javadoc.internal.doclets.toolkit.util.RestrictedAPIListBuilder;\n@@ -142,0 +143,8 @@\n+    \/**\n+     * The collection of restricted methods, if any, to be displayed on the\n+     * restricted-list page, or null if the page should not be generated.\n+     * The page will not be generated if there are no restricted methods to be\n+     * documented.\n+     *\/\n+    protected RestrictedAPIListBuilder restrictedAPIListBuilder;\n+\n@@ -165,1 +174,2 @@\n-        CONSTANT_VALUES, DEPRECATED, EXTERNAL_SPECS, PREVIEW, SERIALIZED_FORM, SYSTEM_PROPERTIES, NEW\n+        CONSTANT_VALUES, DEPRECATED, EXTERNAL_SPECS, PREVIEW, RESTRICTED,\n+        SERIALIZED_FORM, SYSTEM_PROPERTIES, NEW\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlConfiguration.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+import jdk.javadoc.internal.doclets.toolkit.util.RestrictedAPIListBuilder;\n@@ -198,0 +199,5 @@\n+        RestrictedAPIListBuilder restrictedBuilder = new RestrictedAPIListBuilder(configuration);\n+        if (!restrictedBuilder.isEmpty()) {\n+            configuration.restrictedAPIListBuilder = restrictedBuilder;\n+            configuration.conditionalPages.add(HtmlConfiguration.ConditionalPage.RESTRICTED);\n+        }\n@@ -250,0 +256,1 @@\n+                HtmlConfiguration.ConditionalPage.RESTRICTED,\n@@ -256,0 +263,1 @@\n+                    case RESTRICTED -> writerFactory.newRestrictedListWriter();\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlDoclet.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -507,1 +507,1 @@\n-    protected HtmlTree getHeader(Navigation.PageMode pageMode) {\n+    protected Content getHeader(Navigation.PageMode pageMode) {\n@@ -520,1 +520,1 @@\n-    protected HtmlTree getHeader(Navigation.PageMode pageMode, Element element) {\n+    protected Content getHeader(Navigation.PageMode pageMode, Element element) {\n@@ -522,2 +522,2 @@\n-                .add(RawHtml.of(replaceDocRootDir(options.top())))\n-                .add(getNavBar(pageMode, element).getContent());\n+                        .add(RawHtml.of(replaceDocRootDir(options.top())))\n+                        .add(getNavBar(pageMode, element).getContent());\n@@ -2056,0 +2056,8 @@\n+    public void addRestrictedSummary(Element forWhat, Content target) {\n+        if (utils.isRestrictedAPI(forWhat)) {\n+            var div = HtmlTree.DIV(HtmlStyle.block);\n+            div.add(HtmlTree.SPAN(HtmlStyle.restrictedLabel, contents.restrictedPhrase));\n+            target.add(div);\n+        }\n+    }\n+\n@@ -2206,0 +2214,20 @@\n+    public void addRestrictedInfo(ExecutableElement forWhat, Content target) {\n+        if (utils.isRestrictedAPI(forWhat)) {\n+            \/\/in Java platform:\n+            var restrictedDiv = HtmlTree.DIV(HtmlStyle.restrictedBlock);\n+            restrictedDiv.setId(htmlIds.forRestrictedSection(forWhat));\n+            String name = forWhat.getSimpleName().toString();\n+            var nameCode = HtmlTree.CODE(Text.of(name));\n+            String leadingNoteKey = \"doclet.RestrictedLeadingNote\";\n+            Content leadingNote =\n+                    contents.getContent(leadingNoteKey, nameCode);\n+            restrictedDiv.add(HtmlTree.SPAN(HtmlStyle.restrictedLabel,\n+                    leadingNote));\n+            Content note1 = contents.getContent(\"doclet.RestrictedTrailingNote1\", nameCode);\n+            restrictedDiv.add(HtmlTree.DIV(HtmlStyle.restrictedComment, note1));\n+            Content note2 = contents.getContent(\"doclet.RestrictedTrailingNote2\", nameCode);\n+            restrictedDiv.add(HtmlTree.DIV(HtmlStyle.restrictedComment, note2));\n+            target.add(restrictedDiv);\n+        }\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlDocletWriter.java","additions":32,"deletions":4,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -492,0 +492,11 @@\n+    \/**\n+     * Returns an id for the \"restricted\" section for an executable element.\n+     *\n+     * @param el the executable element\n+     *\n+     * @return the id\n+     *\/\n+    public HtmlId forRestrictedSection(ExecutableElement el) {\n+        return HtmlId.of(\"restricted-\" + forMember(el).name());\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlIds.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.util.function.Consumer;\n@@ -35,0 +36,1 @@\n+import javax.lang.model.element.ExecutableElement;\n@@ -45,0 +47,1 @@\n+import jdk.javadoc.internal.doclets.formats.html.markup.Entity;\n@@ -238,0 +241,1 @@\n+        ExecutableElement restrictedTarget;\n@@ -242,0 +246,1 @@\n+            restrictedTarget = null;\n@@ -244,0 +249,3 @@\n+            \/\/ We piggy back on whether to show preview info, for both preview AND\n+            \/\/ restricted methods superscripts. That's because when e.g. we are generating a\n+            \/\/ method summary we do not want either superscript.\n@@ -257,0 +265,5 @@\n+            if (flags.contains(ElementFlag.RESTRICTED)) {\n+                restrictedTarget = (ExecutableElement) linkInfo.getTargetMember();\n+            } else {\n+                restrictedTarget = null;\n+            }\n@@ -259,0 +272,1 @@\n+            restrictedTarget = null;\n@@ -272,0 +286,1 @@\n+                        Content spacer = Text.EMPTY;\n@@ -276,0 +291,7 @@\n+                            spacer = Entity.NO_BREAK_SPACE;\n+                        }\n+                        if (flags.contains(ElementFlag.RESTRICTED)) {\n+                            link.add(spacer);\n+                            link.add(HtmlTree.SUP(m_writer.links.createLink(\n+                                    filename.fragment(m_writer.htmlIds.forRestrictedSection(restrictedTarget).name()),\n+                                    m_writer.contents.restrictedMark)));\n@@ -286,0 +308,1 @@\n+                Content spacer = Text.EMPTY;\n@@ -292,0 +315,9 @@\n+                    spacer = Entity.NO_BREAK_SPACE;\n+                }\n+                if (flags.contains(ElementFlag.RESTRICTED)) {\n+                    link.add(spacer);\n+                    link.add(HtmlTree.SUP(m_writer.getCrossClassLink(\n+                            typeElement,\n+                            m_writer.htmlIds.forRestrictedSection(restrictedTarget).name(),\n+                            m_writer.contents.restrictedMark,\n+                            null, false)));\n@@ -298,0 +330,1 @@\n+        Content spacer = Text.EMPTY;\n@@ -300,0 +333,5 @@\n+            spacer = Entity.NO_BREAK_SPACE;\n+        }\n+        if (flags.contains(ElementFlag.RESTRICTED)) {\n+            link.add(spacer);\n+            link.add(HtmlTree.SUP(m_writer.contents.restrictedMark));\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlLinkFactory.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -108,7 +108,8 @@\n-\n-                buildSignature(methodContent);\n-                buildDeprecationInfo(methodContent);\n-                buildPreviewInfo(methodContent);\n-                buildMethodComments(methodContent);\n-                buildTagInfo(methodContent);\n-\n+                Content div = HtmlTree.DIV(HtmlStyle.horizontalScroll);\n+                buildSignature(div);\n+                buildDeprecationInfo(div);\n+                buildPreviewInfo(div);\n+                buildRestrictedInfo(div);\n+                buildMethodComments(div);\n+                buildTagInfo(div);\n+                methodContent.add(div);\n@@ -137,0 +138,9 @@\n+    \/**\n+     * Builds the restricted method info.\n+     *\n+     * @param target the content to which the documentation will be added\n+     *\/\n+    protected void buildRestrictedInfo(Content target) {\n+        addRestricted(currentMethod, target);\n+    }\n+\n@@ -218,0 +228,4 @@\n+    protected void addRestricted(ExecutableElement method, Content content) {\n+        addRestrictedInfo(method, content);\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/MethodWriter.java","additions":21,"deletions":7,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -194,3 +194,5 @@\n-\n-        addModuleSignature(moduleContent);\n-        buildModuleDescription(moduleContent);\n+        moduleContent.add(new HtmlTree(TagName.HR));\n+        Content div = HtmlTree.DIV(HtmlStyle.horizontalScroll);\n+        addModuleSignature(div);\n+        buildModuleDescription(div);\n+        moduleContent.add(div);\n@@ -885,1 +887,0 @@\n-        moduleContent.add(new HtmlTree(TagName.HR));\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/ModuleWriter.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -94,0 +94,1 @@\n+        RESTRICTED,\n@@ -319,0 +320,1 @@\n+            case RESTRICTED:\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/Navigation.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-    private final HtmlTree section = HtmlTree.SECTION(HtmlStyle.packageDescription, new ContentBuilder());\n+    private final HtmlTree section = HtmlTree.SECTION(HtmlStyle.packageDescription);\n@@ -131,4 +131,6 @@\n-\n-        addPackageSignature(packageContent);\n-        buildPackageDescription(packageContent);\n-        buildPackageTags(packageContent);\n+        packageContent.add(new HtmlTree(TagName.HR));\n+        Content div = HtmlTree.DIV(HtmlStyle.horizontalScroll);\n+        addPackageSignature(div);\n+        buildPackageDescription(div);\n+        buildPackageTags(div);\n+        packageContent.add(div);\n@@ -180,2 +182,2 @@\n-        if (options.noComment()) {\n-            return;\n+        if (!options.noComment()) {\n+            addPackageDescription(packageContent);\n@@ -183,1 +185,0 @@\n-        addPackageDescription(packageContent);\n@@ -192,2 +193,2 @@\n-        if (options.noComment()) {\n-            return;\n+        if (!options.noComment()) {\n+            addPackageTags(packageContent);\n@@ -195,1 +196,0 @@\n-        addPackageTags(packageContent);\n@@ -425,1 +425,0 @@\n-        packageContent.add(new HtmlTree(TagName.HR));\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/PackageWriter.java","additions":11,"deletions":12,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -81,7 +81,7 @@\n-\n-                buildSignature(propertyContent);\n-                buildDeprecationInfo(propertyContent);\n-                buildPreviewInfo(propertyContent);\n-                buildPropertyComments(propertyContent);\n-                buildTagInfo(propertyContent);\n-\n+                Content div = HtmlTree.DIV(HtmlStyle.horizontalScroll);\n+                buildSignature(div);\n+                buildDeprecationInfo(div);\n+                buildPreviewInfo(div);\n+                buildPropertyComments(div);\n+                buildTagInfo(div);\n+                propertyContent.add(div);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/PropertyWriter.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html;\n+\n+import javax.lang.model.element.Element;\n+\n+import jdk.javadoc.internal.doclets.formats.html.Navigation.PageMode;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocPaths;\n+import jdk.javadoc.internal.doclets.toolkit.util.IndexItem;\n+import jdk.javadoc.internal.doclets.toolkit.util.RestrictedAPIListBuilder;\n+\n+\/**\n+ * Generate File to list all the restricted methods with the\n+ * appropriate links.\n+ *\/\n+public class RestrictedListWriter extends SummaryListWriter<RestrictedAPIListBuilder> {\n+\n+    \/**\n+     * Constructor.\n+     *\n+     * @param configuration the configuration for this doclet\n+     *\/\n+    public RestrictedListWriter(HtmlConfiguration configuration) {\n+        super(configuration, DocPaths.RESTRICTED_LIST, configuration.restrictedAPIListBuilder);\n+        if (configuration.restrictedAPIListBuilder != null) {\n+            configuration.indexBuilder.add(IndexItem.of(IndexItem.Category.TAGS,\n+                    resources.getText(\"doclet.Restricted_Methods\"), path));\n+        }\n+    }\n+\n+    @Override\n+    protected PageMode getPageMode() {\n+        return PageMode.RESTRICTED;\n+    }\n+\n+    @Override\n+    protected String getDescription() {\n+        return \"restricted methods\";\n+    }\n+\n+    @Override\n+    protected boolean showContentsList() {\n+        \/\/ This list contains only methods, no need to show list of element kinds.\n+        return false;\n+    }\n+\n+    @Override\n+    protected Content getHeadContent() {\n+        return configuration.contents.restrictedMethods;\n+    }\n+\n+    @Override\n+    protected String getTitleKey() {\n+        return \"doclet.Window_Restricted_List\";\n+    }\n+\n+    @Override\n+    protected void addComments(Element e, Content desc) {\n+        addSummaryComment(e, desc);\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/RestrictedListWriter.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -116,0 +116,1 @@\n+        addRestrictedSummary(member, tdSummaryContent);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/SubWriterHolderWriter.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.util.Arrays;\n@@ -141,2 +142,4 @@\n-        content.add(HtmlTree.HEADING_TITLE(Headings.CONTENT_HEADING, contents.contentsHeading));\n-        content.add(getContentsList());\n+        if (showContentsList()) {\n+            content.add(HtmlTree.HEADING_TITLE(Headings.CONTENT_HEADING, contents.contentsHeading));\n+            content.add(getContentsList());\n+        }\n@@ -187,0 +190,7 @@\n+    \/**\n+     * {@return {@code true} if the contents list should be generated, {@code false} if not}\n+     *\/\n+    protected boolean showContentsList() {\n+        return true;\n+    }\n+\n@@ -307,2 +317,2 @@\n-     * Subclasses allow the user to show or hide parts of the content in the page.\n-     * This method should be used to add the UI to select the visible page content.\n+     * Allow Subclasses to add a content selector UI such as a row of radio buttons\n+     * near the top of the page. This method does not add anything.\n@@ -312,1 +322,1 @@\n-    protected abstract void addContentSelectors(Content target);\n+    protected void addContentSelectors(Content target) {}\n@@ -315,2 +325,2 @@\n-     * Some subclasses of this class display an extra column in their element tables.\n-     * This methods allows them to return the content to show for {@code element}.\n+     * Allow subclasses to add an extra table column for an element.\n+     * This methods does not add any content by returning {@code null}.\n@@ -321,1 +331,3 @@\n-    protected abstract Content getExtraContent(Element element);\n+    protected Content getExtraContent(Element element) {\n+        return null;\n+    }\n@@ -355,1 +367,2 @@\n-     * Allow subclasses to add extra tabs to the element tables.\n+     * Allow subclasses to add extra tabs to the element tables. This method does not\n+     * add any tabs.\n@@ -360,1 +373,1 @@\n-    protected abstract void addTableTabs(Table<Element> table, String headingKey);\n+    protected void addTableTabs(Table<Element> table, String headingKey) {}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/SummaryListWriter.java","additions":23,"deletions":10,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -173,0 +173,7 @@\n+    \/**\n+     * {@return a new writer for the list of restricted methods in this release}\n+     *\/\n+    public HtmlDocletWriter newRestrictedListWriter() {\n+        return new RestrictedListWriter(configuration);\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/WriterFactory.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -46,2 +46,2 @@\n-    private HtmlTree header = null;\n-    private HtmlTree footer = null;\n+    private Content header = null;\n+    private Content footer = null;\n@@ -54,1 +54,1 @@\n-    public BodyContents setHeader(HtmlTree header) {\n+    public BodyContents setHeader(Content header) {\n@@ -59,1 +59,1 @@\n-    public BodyContents setFooter(HtmlTree footer) {\n+    public BodyContents setFooter(Content footer) {\n@@ -90,3 +90,2 @@\n-        HtmlTree flexHeader = header.addStyle(HtmlStyle.flexHeader);\n-\n-        var flexContent = HtmlTree.DIV(HtmlStyle.flexContent)\n+        return new ContentBuilder()\n+                .add(header)\n@@ -95,4 +94,0 @@\n-\n-        return HtmlTree.DIV(HtmlStyle.flexBox)\n-                .add(flexHeader)\n-                .add(flexContent);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/markup\/BodyContents.java","additions":6,"deletions":11,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -385,0 +385,16 @@\n+    \/**\n+     * The class for a block describing the \"restricted\" status of a declaration.\n+     *\/\n+    restrictedBlock,\n+\n+    \/**\n+     * The class for the details in a block describing the \"restricted\" status of a declaration.\n+     *\/\n+    restrictedComment,\n+\n+    \/**\n+     * The class for the \"Restricted\" label in a block describing the \"restricted\" status\n+     * of a declaration.\n+     *\/\n+    restrictedLabel,\n+\n@@ -566,23 +582,0 @@\n-    \/\/<editor-fold desc=\"flex layout\">\n-    \/\/\n-    \/\/ The following constants are used for the components of the top-level structures for \"flex\" layout.\n-\n-    \/**\n-     * The class of the top-level {@code div} element used to arrange for \"flex\" layout in\n-     * a browser window. The element should contain two child elements: one with class\n-     * {@link #flexHeader flex-header} and one with class {@link #flexContent flex-content}.\n-     *\/\n-    flexBox,\n-\n-    \/**\n-     * The class of the {@code header} element within a {@link #flexBox flex-box} container.\n-     * The element is always displayed at the top of the viewport.\n-     *\/\n-    flexHeader,\n-\n-    \/**\n-     * The class of the {@code div} element within a {@link #flexBox flex-box} container\n-     * This element appears below the header and can be scrolled if too big for the available height.\n-     *\/\n-    flexContent,\n-    \/\/<\/editor-fold>\n@@ -819,0 +812,5 @@\n+    \/**\n+     * The class of the {@code body} element for the page listing restricted methods.\n+     *\/\n+    restrictedListPage,\n+\n@@ -967,0 +965,5 @@\n+    \/**\n+     * The class of a {@code div} element that allows its horizontal overflow to be scrolled.\n+     *\/\n+    horizontalScroll,\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/markup\/HtmlStyle.java","additions":27,"deletions":24,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -230,1 +230,1 @@\n-\/\/ Workaround for scroll position not being included in browser history (8249133)\n+\/\/ Dynamically set scroll margin to accomodate for draft header\n@@ -232,21 +232,4 @@\n-    var contentDiv = document.querySelector(\"div.flex-content\");\n-    window.addEventListener(\"popstate\", function(e) {\n-        if (e.state !== null) {\n-            contentDiv.scrollTop = e.state;\n-        }\n-    });\n-    window.addEventListener(\"hashchange\", function(e) {\n-        history.replaceState(contentDiv.scrollTop, document.title);\n-    });\n-    var timeoutId;\n-    contentDiv.addEventListener(\"scroll\", function(e) {\n-        if (timeoutId) {\n-            clearTimeout(timeoutId);\n-        }\n-        timeoutId = setTimeout(function() {\n-            history.replaceState(contentDiv.scrollTop, document.title);\n-        }, 100);\n-    });\n-    if (!location.hash) {\n-        history.replaceState(contentDiv.scrollTop, document.title);\n-    }\n+    document.querySelectorAll(':not(input)[id]').forEach(\n+        function(c) {\n+            c.style[\"scroll-margin-top\"] = Math.ceil(document.querySelector(\"header\").offsetHeight) + \"px\"\n+        });\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/script.js","additions":5,"deletions":22,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -88,0 +88,1 @@\n+doclet.Window_Restricted_List=Restricted Method List\n@@ -132,0 +133,2 @@\n+doclet.Restricted_Methods=Restricted Methods\n+doclet.Restricted_Mark=RESTRICTED\n@@ -306,0 +309,3 @@\n+doclet.help.restricted.body=\\\n+    The {0} page lists all restricted methods. Restricted methods are unsafe, and, if used \\\n+    incorrectly, might crash the JVM or result in memory corruption.\n@@ -413,0 +419,4 @@\n+doclet.RestrictedLeadingNote={0} is a restricted method of the Java platform.\n+doclet.RestrictedTrailingNote1=Programs can only use {0} when access to restricted methods is enabled.\n+doclet.RestrictedTrailingNote2=Restricted methods are unsafe, and, if used incorrectly, might crash \\\n+    the JVM or result in memory corruption.\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/standard.properties","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -87,0 +87,3 @@\n+:not(input)[id] {\n+    scroll-margin-top: 78px;\n+}\n@@ -175,13 +178,5 @@\n-    div.flex-box {\n-        position:fixed;\n-        display:flex;\n-        flex-direction:column;\n-        height: 100%;\n-        width: 100%;\n-    }\n-    header.flex-header {\n-        flex: 0 0 auto;\n-    }\n-    div.flex-content {\n-        flex: 1 1 auto;\n-        overflow-y: auto;\n+    header {\n+        position:sticky;\n+        top:0;\n+        z-index:1;\n+        background: var(--body-background-color);\n@@ -308,2 +303,1 @@\n-body.class-declaration-page .details h3,\n-body.class-declaration-page .summary .inherited-list h2 {\n+body.class-declaration-page .details h3 {\n@@ -314,0 +308,1 @@\n+    overflow-x:auto;\n@@ -323,0 +318,4 @@\n+section[id$=-description] :is(dl, ol, ul, p, div, blockquote, pre):last-child,\n+section[id$=-description] :is(dl, ol, ul):last-child > :is(li, dd):last-child {\n+    margin-bottom:4px;\n+}\n@@ -446,2 +445,2 @@\n-    padding:10px 0 0 1px;\n-    margin:10px 0 0 0;\n+    padding: 10px 0 0 1px;\n+    margin: 0;\n@@ -530,1 +529,1 @@\n-    overflow-x: auto;\n+    overflow: auto hidden;\n@@ -618,1 +617,1 @@\n-    margin:14px 0;\n+    margin:8px 0 14px 0;\n@@ -651,1 +650,1 @@\n-.package-hierarchy-label, .type-name-label, .type-name-link, .search-tag-link, .preview-label {\n+.package-hierarchy-label, .type-name-label, .type-name-link, .search-tag-link, .preview-label, .restricted-label {\n@@ -654,1 +653,1 @@\n-.deprecation-comment, .help-footnote, .preview-comment {\n+.deprecation-comment, .help-footnote, .preview-comment, .restricted-comment {\n@@ -657,12 +656,1 @@\n-.deprecation-block {\n-    font-size:1em;\n-    font-family:var(--block-font-family);\n-    border-style:solid;\n-    border-width:thin;\n-    border-radius:10px;\n-    padding:10px;\n-    margin-bottom:10px;\n-    margin-right:10px;\n-    display:inline-block;\n-}\n-.preview-block {\n+.deprecation-block, .preview-block, .restricted-block {\n@@ -701,0 +689,3 @@\n+nav {\n+    overflow:hidden;\n+}\n@@ -857,0 +848,3 @@\n+.horizontal-scroll {\n+    overflow: auto hidden;\n+}\n@@ -1101,1 +1095,1 @@\n-    header.flex-header {\n+    header {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/stylesheet.css","additions":28,"deletions":34,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -432,0 +432,5 @@\n+    public boolean isRestrictedAPI(Element el) {\n+        Symbol sym = (Symbol) el;\n+        return sym.kind == MTH && (sym.flags() & Flags.RESTRICTED) != 0;\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/WorkArounds.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -216,0 +216,1 @@\n+doclet.Restricted=Restricted.\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/resources\/doclets.properties","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -151,0 +151,3 @@\n+    \/** The name of the file for restricted methods. *\/\n+    public static final DocPath RESTRICTED_LIST = DocPath.create(\"restricted-list.html\");\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/DocPaths.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.toolkit.util;\n+\n+import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n+\n+import javax.lang.model.element.Element;\n+\n+\/**\n+ * Build list of all the restricted methods.\n+ *\/\n+public class RestrictedAPIListBuilder extends SummaryAPIListBuilder {\n+\n+\n+    \/**\n+     * Constructor.\n+     *\n+     * @param configuration the current configuration of the doclet\n+     *\/\n+    public RestrictedAPIListBuilder(BaseConfiguration configuration) {\n+        super(configuration, configuration.utils::isRestrictedAPI);\n+        buildSummaryAPIInfo();\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/RestrictedAPIListBuilder.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -2743,0 +2743,10 @@\n+    \/**\n+     * Checks whether the given ExecutableElement should be marked as a restricted API.\n+     *\n+     * @param el the element to check\n+     * @return true if and only if the given element should be marked as a restricted API\n+     *\/\n+    public boolean isRestrictedAPI(Element el) {\n+        return configuration.workArounds.isRestrictedAPI(el);\n+    }\n+\n@@ -2756,0 +2766,4 @@\n+        if (el.getKind() == ElementKind.METHOD && configuration.workArounds.isRestrictedAPI((ExecutableElement)el)) {\n+            flags.add(ElementFlag.RESTRICTED);\n+        }\n+\n@@ -2769,1 +2783,2 @@\n-        PREVIEW\n+        PREVIEW,\n+        RESTRICTED\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/Utils.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -456,0 +456,2 @@\n+If %p and\/or %t is specified in the filename, it expands to the\n+JVM\\[aq]s PID and the current timestamp, respectively.\n@@ -524,0 +526,2 @@\n+If %p and\/or %t is specified in the filename, it expands to the\n+JVM\\[aq]s PID and the current timestamp, respectively.\n@@ -615,0 +619,2 @@\n+If %p and\/or %t is specified in the filename, it expands to the\n+JVM\\[aq]s PID and the current timestamp, respectively.\n","filename":"src\/jdk.jcmd\/share\/man\/jcmd.1","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -247,4 +247,0 @@\n-\\f[V]-P\\f[R] or \\f[V]-profile\\f[R]\n-Shows the profile containing a package.\n-This option is deprecated and may be removed in a future release.\n-.TP\n","filename":"src\/jdk.jdeps\/share\/man\/jdeps.1","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -224,1 +224,1 @@\n-The parameter can be an event type name.\n+The <\\f[I]view\\f[R]> parameter can be an event type name.\n@@ -261,2 +261,3 @@\n-Use the form: <\\f[I]event-name>#=<value\\f[R]> To add a new event\n-setting, prefix the event name with \\[aq]+\\[aq].\n+Use the form:\n+<\\f[I]event-name\\f[R]>#<\\f[I]setting-name\\f[R]>=<\\f[I]value\\f[R]> To add\n+a new event setting, prefix the event name with \\[aq]+\\[aq].\n@@ -319,1 +320,1 @@\n-<\\f[I]filter\\f[R]>] <\\f[I]input-file\\f[R]> []\n+<\\f[I]filter\\f[R]>] <\\f[I]input-file\\f[R]> [<\\f[I]output-file\\f[R]>]\n@@ -338,2 +339,3 @@\n-.PP\n-<\\f[I]input-file\\f[R]> :The input file to read events from.\n+.TP\n+<\\f[I]input-file\\f[R]>\n+The input file to read events from.\n@@ -349,1 +351,1 @@\n-.SS jfr \\f[V]assemble\\f[R] subcommand\n+.SS \\f[V]jfr assemble\\f[R] subcommand\n","filename":"src\/jdk.jfr\/share\/man\/jfr.1","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -193,1 +193,1 @@\n-        UNDERSCORE(TokenKind.UNDERSCORE, XERRO),  \/\/  _\n+        UNDERSCORE(TokenKind.UNDERSCORE, XDECL1),  \/\/  _\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/CompletenessAnalyzer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import java.io.IOException;\n+import java.io.InvalidObjectException;\n+import java.io.ObjectInputStream;\n@@ -50,0 +53,1 @@\n+    @java.io.Serial\n@@ -138,0 +142,27 @@\n+\n+    \/**\n+     * Restores the state of this object from the stream.\n+     *\n+     * @param  stream the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n+     *\/\n+    @java.io.Serial\n+    private void readObject(ObjectInputStream stream)\n+            throws IOException, ClassNotFoundException {\n+        stream.defaultReadObject();\n+        if ((name == null) || (nameString == null)) {\n+            throw new InvalidObjectException(\n+                    \"null name\/nameString is illegal\");\n+        }\n+        try {\n+            if (!name.equals(getLdapName(nameString))) {\n+                throw new InvalidObjectException(\"Inconsistent names\");\n+            }\n+        } catch  (InvalidNameException e) {\n+            InvalidObjectException nse = new InvalidObjectException(\n+                    \"Invalid Name\");\n+            nse.initCause(e);\n+            throw nse;\n+        }\n+    }\n","filename":"src\/jdk.security.auth\/share\/classes\/com\/sun\/security\/auth\/LdapPrincipal.java","additions":32,"deletions":1,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import java.io.IOException;\n+import java.io.InvalidObjectException;\n+import java.io.ObjectInputStream;\n@@ -50,0 +53,1 @@\n+    @java.io.Serial\n@@ -123,3 +127,1 @@\n-            if (name.equals(that.getName()))\n-                return true;\n-            return false;\n+        return name.equals(that.getName());\n@@ -136,0 +138,20 @@\n+\n+    \/**\n+     * Restores the state of this object from the stream.\n+     *\n+     * @param  stream the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n+     *\/\n+    @java.io.Serial\n+    private void readObject(ObjectInputStream stream)\n+            throws IOException, ClassNotFoundException {\n+        stream.defaultReadObject();\n+        if (name == null) {\n+            java.text.MessageFormat form = new java.text.MessageFormat\n+                    (sun.security.util.ResourcesMgr.getAuthResourceString\n+                            (\"invalid.null.input.value\"));\n+            Object[] source = {\"name\"};\n+            throw new InvalidObjectException(form.format(source));\n+        }\n+    }\n","filename":"src\/jdk.security.auth\/share\/classes\/com\/sun\/security\/auth\/NTDomainPrincipal.java","additions":26,"deletions":4,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import java.io.IOException;\n+import java.io.InvalidObjectException;\n+import java.io.ObjectInputStream;\n@@ -52,0 +55,1 @@\n+    @java.io.Serial\n@@ -83,1 +87,1 @@\n-        sid = new String(stringSid);\n+        sid = stringSid;\n@@ -131,4 +135,1 @@\n-        if (sid.equals(that.sid)) {\n-            return true;\n-        }\n-        return false;\n+        return sid.equals(that.sid);\n@@ -145,0 +146,25 @@\n+\n+    \/**\n+     * Restores the state of this object from the stream.\n+     *\n+     * @param  stream the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n+     *\/\n+    @java.io.Serial\n+    private void readObject(ObjectInputStream stream)\n+            throws IOException, ClassNotFoundException {\n+        stream.defaultReadObject();\n+        if (sid == null) {\n+            java.text.MessageFormat form = new java.text.MessageFormat\n+                    (sun.security.util.ResourcesMgr.getAuthResourceString\n+                            (\"invalid.null.input.value\"));\n+            Object[] source = {\"stringSid\"};\n+            throw new InvalidObjectException(form.format(source));\n+        }\n+        if (sid.length() == 0) {\n+            throw new InvalidObjectException\n+                    (sun.security.util.ResourcesMgr.getAuthResourceString\n+                            (\"Invalid.NTSid.value\"));\n+        }\n+    }\n","filename":"src\/jdk.security.auth\/share\/classes\/com\/sun\/security\/auth\/NTSid.java","additions":32,"deletions":6,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import java.io.IOException;\n+import java.io.InvalidObjectException;\n+import java.io.ObjectInputStream;\n@@ -46,0 +49,1 @@\n+    @java.io.Serial\n@@ -117,3 +121,1 @@\n-            if (name.equals(that.getName()))\n-                return true;\n-            return false;\n+        return name.equals(that.getName());\n@@ -130,0 +132,21 @@\n+\n+\n+    \/**\n+     * Restores the state of this object from the stream.\n+     *\n+     * @param  stream the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n+     *\/\n+    @java.io.Serial\n+    private void readObject(ObjectInputStream stream)\n+            throws IOException, ClassNotFoundException {\n+        stream.defaultReadObject();\n+        if (name == null) {\n+            java.text.MessageFormat form = new java.text.MessageFormat\n+                    (sun.security.util.ResourcesMgr.getAuthResourceString\n+                            (\"invalid.null.input.value\"));\n+            Object[] source = {\"name\"};\n+            throw new InvalidObjectException(form.format(source));\n+        }\n+    }\n","filename":"src\/jdk.security.auth\/share\/classes\/com\/sun\/security\/auth\/NTUserPrincipal.java","additions":27,"deletions":4,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import java.io.IOException;\n+import java.io.InvalidObjectException;\n+import java.io.ObjectInputStream;\n@@ -49,0 +52,1 @@\n+    @java.io.Serial\n@@ -187,4 +191,2 @@\n-        if (this.getName().equals(that.getName()) &&\n-            this.isPrimaryGroup() == that.isPrimaryGroup())\n-            return true;\n-        return false;\n+        return this.getName().equals(that.getName()) &&\n+                this.isPrimaryGroup() == that.isPrimaryGroup();\n@@ -201,0 +203,20 @@\n+\n+    \/**\n+     * Restores the state of this object from the stream.\n+     *\n+     * @param  stream the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n+     *\/\n+    @java.io.Serial\n+    private void readObject(ObjectInputStream stream)\n+            throws IOException, ClassNotFoundException {\n+        stream.defaultReadObject();\n+        if (name == null) {\n+            java.text.MessageFormat form = new java.text.MessageFormat\n+                    (sun.security.util.ResourcesMgr.getAuthResourceString\n+                            (\"invalid.null.input.value\"));\n+            Object[] source = {\"name\"};\n+            throw new InvalidObjectException(form.format(source));\n+        }\n+    }\n","filename":"src\/jdk.security.auth\/share\/classes\/com\/sun\/security\/auth\/UnixNumericGroupPrincipal.java","additions":27,"deletions":5,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import java.io.IOException;\n+import java.io.InvalidObjectException;\n+import java.io.ObjectInputStream;\n@@ -47,0 +50,1 @@\n+    @java.io.Serial\n@@ -149,3 +153,1 @@\n-        if (this.getName().equals(that.getName()))\n-            return true;\n-        return false;\n+        return this.getName().equals(that.getName());\n@@ -162,0 +164,20 @@\n+\n+    \/**\n+     * Restores the state of this object from the stream.\n+     *\n+     * @param  stream the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n+     *\/\n+    @java.io.Serial\n+    private void readObject(ObjectInputStream stream)\n+            throws IOException, ClassNotFoundException {\n+        stream.defaultReadObject();\n+        if (name == null) {\n+            java.text.MessageFormat form = new java.text.MessageFormat\n+                    (sun.security.util.ResourcesMgr.getAuthResourceString\n+                            (\"invalid.null.input.value\"));\n+            Object[] source = {\"name\"};\n+            throw new InvalidObjectException(form.format(source));\n+        }\n+    }\n","filename":"src\/jdk.security.auth\/share\/classes\/com\/sun\/security\/auth\/UnixNumericUserPrincipal.java","additions":26,"deletions":4,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import java.io.IOException;\n+import java.io.InvalidObjectException;\n+import java.io.ObjectInputStream;\n@@ -46,0 +49,1 @@\n+    @java.io.Serial\n@@ -118,3 +122,1 @@\n-        if (this.getName().equals(that.getName()))\n-            return true;\n-        return false;\n+        return this.getName().equals(that.getName());\n@@ -131,0 +133,20 @@\n+\n+    \/**\n+     * Restores the state of this object from the stream.\n+     *\n+     * @param  stream the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n+     *\/\n+    @java.io.Serial\n+    private void readObject(ObjectInputStream stream)\n+            throws IOException, ClassNotFoundException {\n+        stream.defaultReadObject();\n+        if (name == null) {\n+            java.text.MessageFormat form = new java.text.MessageFormat\n+                    (sun.security.util.ResourcesMgr.getAuthResourceString\n+                            (\"invalid.null.input.value\"));\n+            Object[] source = {\"name\"};\n+            throw new InvalidObjectException(form.format(source));\n+        }\n+    }\n","filename":"src\/jdk.security.auth\/share\/classes\/com\/sun\/security\/auth\/UnixPrincipal.java","additions":26,"deletions":4,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import java.io.IOException;\n+import java.io.InvalidObjectException;\n+import java.io.ObjectInputStream;\n@@ -47,0 +50,1 @@\n+    @java.io.Serial\n@@ -112,0 +116,16 @@\n+\n+    \/**\n+     * Restores the state of this object from the stream.\n+     *\n+     * @param  stream the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n+     *\/\n+    @java.io.Serial\n+    private void readObject(ObjectInputStream stream)\n+            throws IOException, ClassNotFoundException {\n+        stream.defaultReadObject();\n+        if (name == null) {\n+            throw new InvalidObjectException(\"null name is illegal\");\n+        }\n+    }\n","filename":"src\/jdk.security.auth\/share\/classes\/com\/sun\/security\/auth\/UserPrincipal.java","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -332,1 +332,1 @@\n-  Arena ar(mtTest, 4097);\n+  Arena ar(mtTest, Arena::Tag::tag_other, 4097);\n@@ -345,1 +345,1 @@\n-  Arena ar(mtTest, 100); \/\/ first chunk is small\n+  Arena ar(mtTest, Arena::Tag::tag_other, 100); \/\/ first chunk is small\n@@ -375,8 +375,8 @@\n-    Arena ar0(mtTest, random_arena_chunk_size());\n-    Arena ar1(mtTest, random_arena_chunk_size());\n-    Arena ar2(mtTest, random_arena_chunk_size());\n-    Arena ar3(mtTest, random_arena_chunk_size());\n-    Arena ar4(mtTest, random_arena_chunk_size());\n-    Arena ar5(mtTest, random_arena_chunk_size());\n-    Arena ar6(mtTest, random_arena_chunk_size());\n-    Arena ar7(mtTest, random_arena_chunk_size());\n+    Arena ar0(mtTest, Arena::Tag::tag_other, random_arena_chunk_size());\n+    Arena ar1(mtTest, Arena::Tag::tag_other, random_arena_chunk_size());\n+    Arena ar2(mtTest, Arena::Tag::tag_other, random_arena_chunk_size());\n+    Arena ar3(mtTest, Arena::Tag::tag_other, random_arena_chunk_size());\n+    Arena ar4(mtTest, Arena::Tag::tag_other, random_arena_chunk_size());\n+    Arena ar5(mtTest, Arena::Tag::tag_other, random_arena_chunk_size());\n+    Arena ar6(mtTest, Arena::Tag::tag_other, random_arena_chunk_size());\n+    Arena ar7(mtTest, Arena::Tag::tag_other, random_arena_chunk_size());\n","filename":"test\/hotspot\/gtest\/memory\/test_arena.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -94,1 +94,1 @@\n-runtime\/jni\/terminatedThread\/TestTerminatedThread.java 8219652 aix-ppc64\n+runtime\/jni\/terminatedThread\/TestTerminatedThread.java 8317789 aix-ppc64\n@@ -113,0 +113,2 @@\n+runtime\/CompressedOops\/CompressedClassPointers.java 8317610 linux-x64,windows-x64\n+\n@@ -176,0 +178,2 @@\n+\n+vmTestbase\/nsk\/monitoring\/ThreadMXBean\/findMonitorDeadlockedThreads\/find006\/TestDescription.java 8310144 macosx-aarch64\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -35,1 +35,2 @@\n-keys=stress headful intermittent randomness cgroups\n+# flag-sensitive:       test is sensitive to certain flags and might fail when flags are passed using -vmoptions and -javaoptions\n+keys=stress headful intermittent randomness cgroups flag-sensitive\n","filename":"test\/hotspot\/jtreg\/TEST.ROOT","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,155 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n+\/*\n+ * @test\n+ * @summary Test that patterns involving duplicated conversion nodes behind phi are properly optimized.\n+ * @bug 8316918\n+ * @library \/test\/lib \/\n+ * @requires vm.compiler2.enabled\n+ * @run driver compiler.c2.irTests.TestPhiDuplicatedConversion\n+ *\/\n+public class TestPhiDuplicatedConversion {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CONV, \"1\"})\n+    public static float int2Float(boolean c, int a, int b) {\n+        return c ? a : b;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CONV, \"1\"})\n+    public static double int2Double(boolean c, int a, int b) {\n+        return c ? a : b;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CONV, \"1\"})\n+    public static long int2Long(boolean c, int a, int b) {\n+        return c ? a : b;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CONV, \"1\"})\n+    public static int float2Int(boolean c, float a, float b) {\n+        return c ? (int)a : (int)b;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CONV, \"1\"})\n+    public static double float2Double(boolean c, float a, float b) {\n+        return c ? (double)a : (double)b;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CONV, \"1\"})\n+    public static long float2Long(boolean c, float a, float b) {\n+        return c ? (long)a : (long)b;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CONV, \"1\"})\n+    public static int double2Int(boolean c, double a, double b) {\n+        return c ? (int)a : (int)b;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CONV, \"1\"})\n+    public static float double2Float(boolean c, double a, double b) {\n+        return c ? (float)a : (float)b;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CONV, \"1\"})\n+    public static long double2Long(boolean c, double a, double b) {\n+        return c ? (long)a : (long)b;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CONV, \"1\"})\n+    public static float long2Float(boolean c, long a, long b) {\n+        return c ? a : b;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CONV, \"1\"})\n+    public static double long2Double(boolean c, long a, long b) {\n+        return c ? a : b;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CONV, \"1\"})\n+    public static int long2Int(boolean c, long a, long b) {\n+        return c ? (int)a : (int)b;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CONV, \"1\"}, applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    public static short float2HalfFloat(boolean c, float a, float b) {\n+        return c ? Float.floatToFloat16(a) : Float.floatToFloat16(b);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CONV, \"1\"}, applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    public static float halfFloat2Float(boolean c, short a, short b) {\n+        return c ? Float.float16ToFloat(a) : Float.float16ToFloat(b);\n+    }\n+\n+    @Run(test = {\"int2Float\", \"int2Double\", \"int2Long\",\n+                 \"float2Int\", \"float2Double\", \"float2Long\",\n+                 \"double2Int\", \"double2Float\", \"double2Long\",\n+                 \"long2Float\", \"long2Double\", \"long2Int\",\n+                 \"float2HalfFloat\", \"halfFloat2Float\"})\n+    public void runTests() {\n+        assertResults(true, 10, 20, 3.14f, -1.6f, 3.1415, -1.618, 30L, 400L, Float.floatToFloat16(10.5f), Float.floatToFloat16(20.5f));\n+        assertResults(false, 10, 20, 3.14f, -1.6f, 3.1415, -1.618, 30L, 400L, Float.floatToFloat16(10.5f), Float.floatToFloat16(20.5f));\n+    }\n+\n+    @DontCompile\n+    public void assertResults(boolean c, int intA, int intB, float floatA, float floatB, double doubleA, double doubleB, long longA, long longB, short halfFloatA, short halfFloatB) {\n+        Asserts.assertEQ(c ? (float)intA : (float)intB, int2Float(c, intA, intB));\n+        Asserts.assertEQ(c ? (double)intA : (double)intB, int2Double(c, intA, intB));\n+        Asserts.assertEQ(c ? (long)intA : (long)intB, int2Long(c, intA, intB));\n+        Asserts.assertEQ(c ? (int)floatA : (int)floatB, float2Int(c, floatA, floatB));\n+        Asserts.assertEQ(c ? (double)floatA : (double)floatB, float2Double(c, floatA, floatB));\n+        Asserts.assertEQ(c ? (long)floatA : (long)floatB, float2Long(c, floatA, floatB));\n+        Asserts.assertEQ(c ? (int)doubleA : (int)doubleB, double2Int(c, doubleA, doubleB));\n+        Asserts.assertEQ(c ? (float)doubleA : (float)doubleB, double2Float(c, doubleA, doubleB));\n+        Asserts.assertEQ(c ? (long)doubleA : (long)doubleB, double2Long(c, doubleA, doubleB));\n+        Asserts.assertEQ(c ? (float)longA : (float)longB, long2Float(c, longA, longB));\n+        Asserts.assertEQ(c ? (double)longA : (double)longB, long2Double(c, longA, longB));\n+        Asserts.assertEQ(c ? (int)longA : (int)longB, long2Int(c, longA, longB));\n+        Asserts.assertEQ(c ? Float.floatToFloat16(floatA) : Float.floatToFloat16(floatB), float2HalfFloat(c, floatA, floatB));\n+        Asserts.assertEQ(c ? Float.float16ToFloat(halfFloatA) : Float.float16ToFloat(halfFloatB), halfFloat2Float(c, halfFloatA, halfFloatB));\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestPhiDuplicatedConversion.java","additions":155,"deletions":0,"binary":false,"changes":155,"status":"added"},{"patch":"@@ -70,1 +70,1 @@\n-        if (oa.getExitValue() != 0 && !oa.getOutput().contains(\"Out of space in CodeCache for adapters\")) {\n+        if (oa.getExitValue() != 0 && !oa.getOutput().contains(\"Out of space in CodeCache\")) {\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/CodeCacheFullCountTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -445,0 +445,5 @@\n+    public static final String CONV = PREFIX + \"CONV\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CONV, \"Conv\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,102 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Checks that -XX:CompileCommand=PrintMemStat,... works\n+ * @library \/test\/lib\n+ * @run driver compiler.print.CompileCommandPrintMemStat\n+ *\/\n+\n+package compiler.print;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class CompileCommandPrintMemStat {\n+\n+    final static String METHOD1 = \"method1\";\n+    final static String METHOD2 = \"method2\";\n+\n+    public static void main(String[] args) throws Exception {\n+        test(METHOD1, METHOD2);\n+        test(METHOD2, METHOD1);\n+    }\n+\n+    private static void test(String include, String exclude) throws Exception {\n+        List<String> options = new ArrayList<String>();\n+        options.add(\"-Xcomp\");\n+        options.add(\"-XX:-Inline\");\n+        options.add(\"-XX:CompileCommand=compileonly,\" + getTestClass() + \"::*\");\n+        options.add(\"-XX:CompileCommand=MemStat,\" + getTestMethod(include) + \",print\");\n+        options.add(getTestClass());\n+\n+        OutputAnalyzer oa = ProcessTools.executeTestJvm(options);\n+\n+        \/\/ We expect two printouts for \"PrintMemStat\". A line at compilation time, and a line in a summary report\n+        \/\/ that is printed when we exit. Both use the typical <class>::name format but use \/ as separator and also\n+        \/\/ print the signature.\n+        String expectedNameIncl = getTestMethod(include)\n+                .replace('.', '\/')\n+                .replace(\"$\", \"\\\\$\");\n+        String expectedNameExcl = getTestMethod(exclude)\n+                .replace('.', '\/')\n+                .replace(\"$\", \"\\\\$\");\n+\n+        \/\/ Should see trace output when methods are compiled\n+        oa.shouldHaveExitValue(0)\n+          .shouldMatch(\".*\" + expectedNameIncl + \".*\")\n+          .shouldNotMatch(\".*\" + expectedNameExcl + \".*\");\n+\n+        \/\/ Should see final report\n+        \/\/ Looks like this:\n+        \/\/ total     NA        RA        #nodes  time    type  #rc thread              method\n+        \/\/ 621832    0         589104    0       0,025   c1    1   0x00007f5ccc1951a0  java\/util\/zip\/ZipFile$Source::checkAndAddEntry((II)I)\n+        oa.shouldMatch(\"total.*method\");\n+        oa.shouldMatch(\"\\\\d+ +\\\\d+ +\\\\d+ +\\\\d+.*\" + expectedNameIncl + \".*\");\n+        oa.shouldNotMatch(\"\\\\d+ +\\\\d+ +\\\\d+ +\\\\d+.*\" + expectedNameExcl + \".*\");\n+    }\n+\n+    \/\/ Test class that is invoked by the sub process\n+    public static String getTestClass() {\n+        return TestMain.class.getName();\n+    }\n+\n+    public static String getTestMethod(String method) {\n+        return getTestClass() + \"::\" + method;\n+    }\n+\n+    public static class TestMain {\n+        public static void main(String[] args) {\n+            method1();\n+            method2();\n+        }\n+\n+        static void method1() {}\n+        static void method2() {}\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/print\/CompileCommandPrintMemStat.java","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"},{"patch":"@@ -31,2 +31,1 @@\n- * @compile --enable-preview -source ${jdk.version} TestRangeCheckHoistingScaledIV.java\n- * @run main\/othervm --enable-preview compiler.rangechecks.TestRangeCheckHoistingScaledIV\n+ * @run main\/othervm compiler.rangechecks.TestRangeCheckHoistingScaledIV\n@@ -86,1 +85,1 @@\n-                \"--enable-preview\", \"--add-modules\", \"jdk.incubator.vector\",\n+                \"--add-modules\", \"jdk.incubator.vector\",\n","filename":"test\/hotspot\/jtreg\/compiler\/rangechecks\/TestRangeCheckHoistingScaledIV.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n- * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestIntrinsicBailOut.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-                                    \"-XX:+EnableVectorReboxing\", \"-Xlog:compilation\", \"-version\", \"--enable-preview\")\n+                                    \"-XX:+EnableVectorReboxing\", \"-Xlog:compilation\", \"-version\")\n@@ -46,1 +46,1 @@\n-                                    \"-XX:+EnableVectorAggressiveReboxing\", \"-Xlog:compilation\", \"-version\", \"--enable-preview\")\n+                                    \"-XX:+EnableVectorAggressiveReboxing\", \"-Xlog:compilation\", \"-version\")\n@@ -51,1 +51,1 @@\n-                                    \"-XX:-EnableVectorReboxing\", \"-Xlog:compilation\", \"-version\", \"--enable-preview\")\n+                                    \"-XX:-EnableVectorReboxing\", \"-Xlog:compilation\", \"-version\")\n@@ -57,1 +57,1 @@\n-                                    \"-XX:-EnableVectorAggressiveReboxing\", \"-Xlog:compilation\", \"-version\", \"--enable-preview\")\n+                                    \"-XX:-EnableVectorAggressiveReboxing\", \"-Xlog:compilation\", \"-version\")\n@@ -62,1 +62,1 @@\n-                                    \"-XX:-EnableVectorSupport\", \"-Xlog:compilation\", \"-version\", \"--enable-preview\")\n+                                    \"-XX:-EnableVectorSupport\", \"-Xlog:compilation\", \"-version\")\n@@ -69,1 +69,1 @@\n-                                    \"-XX:-EnableVectorSupport\", \"-XX:+EnableVectorReboxing\", \"-Xlog:compilation\", \"-version\", \"--enable-preview\")\n+                                    \"-XX:-EnableVectorSupport\", \"-XX:+EnableVectorReboxing\", \"-Xlog:compilation\", \"-version\")\n@@ -76,1 +76,1 @@\n-                                    \"-XX:-EnableVectorSupport\", \"-XX:+EnableVectorAggressiveReboxing\", \"-Xlog:compilation\", \"-version\", \"--enable-preview\")\n+                                    \"-XX:-EnableVectorSupport\", \"-XX:+EnableVectorAggressiveReboxing\", \"-Xlog:compilation\", \"-version\")\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestVectorErgonomics.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n- * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorMemoryAlias.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,0 @@\n- * @enablePreview\n@@ -51,1 +50,0 @@\n- * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorRebracket128Test.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n- * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/TestVectorCastAVX1.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n- * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/TestVectorCastAVX2.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n- * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/TestVectorCastAVX512.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n- * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/TestVectorCastAVX512BW.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n- * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/TestVectorCastAVX512DQ.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n- * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/TestVectorCastNeon.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n- * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/TestVectorCastSVE.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,0 @@\n- * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/TestVectorReinterpret.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -80,1 +80,1 @@\n-        test.addFlags(\"--add-modules=jdk.incubator.vector\", \"--add-exports=java.base\/jdk.internal.misc=ALL-UNNAMED\", \"--enable-preview\");\n+        test.addFlags(\"--add-modules=jdk.incubator.vector\", \"--add-exports=java.base\/jdk.internal.misc=ALL-UNNAMED\");\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/utils\/VectorReshapeHelper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,1 @@\n+ * @requires vm.opt.CompressedClassSpaceSize == null & vm.opt.UseCompressedClassPointers == null\n@@ -53,1 +54,1 @@\n-        ProcessBuilder pb = GCArguments.createJavaProcessBuilder(args);\n+        ProcessBuilder pb = GCArguments.createTestJvm(args);\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestCompressedClassFlags.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,7 +43,7 @@\n-        ProcessBuilder pb = GCArguments.createJavaProcessBuilder(\"-XX:-UseSerialGC\",\n-                                                                 \"-XX:-UseParallelGC\",\n-                                                                 \"-XX:-UseG1GC\",\n-                                                                 \"-XX:-UseZGC\",\n-                                                                 \"-XX:+UnlockExperimentalVMOptions\",\n-                                                                 \"-XX:-UseShenandoahGC\",\n-                                                                 \"-version\");\n+        ProcessBuilder pb = GCArguments.createTestJvm(\"-XX:-UseSerialGC\",\n+                                                      \"-XX:-UseParallelGC\",\n+                                                      \"-XX:-UseG1GC\",\n+                                                      \"-XX:-UseZGC\",\n+                                                      \"-XX:+UnlockExperimentalVMOptions\",\n+                                                      \"-XX:-UseShenandoahGC\",\n+                                                      \"-version\");\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestDisableDefaultGC.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @requires vm.gc.G1\n+ * @requires vm.gc.G1 & vm.opt.G1ConcMarkStepDurationMillis == null\n@@ -81,1 +81,1 @@\n-    ProcessBuilder pb = GCArguments.createJavaProcessBuilder(vmOpts);\n+    ProcessBuilder pb = GCArguments.createTestJvm(vmOpts);\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestG1ConcMarkStepDurationMillis.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @requires vm.gc.G1\n+ * @requires vm.gc.G1 & vm.opt.G1ConcRefinementThreads == null\n@@ -72,1 +72,1 @@\n-    ProcessBuilder pb = GCArguments.createJavaProcessBuilder(vmOpts);\n+    ProcessBuilder pb = GCArguments.createTestJvm(vmOpts);\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestG1ConcRefinementThreads.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @requires vm.gc.G1\n+ * @requires vm.gc.G1 & vm.opt.G1HeapRegionSize == null\n@@ -56,1 +56,1 @@\n-    ProcessBuilder pb = GCArguments.createJavaProcessBuilder(flagList);\n+    ProcessBuilder pb = GCArguments.createTestJvm(flagList);\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestG1HeapRegionSize.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n- * @requires vm.gc.G1\n@@ -31,0 +30,2 @@\n+ * @key flag-sensitive\n+ * @requires vm.gc.G1 & vm.opt.x.Xmx == null & vm.opt.x.Xms == null & vm.opt.MinHeapSize == null & vm.opt.MaxHeapSize == null & vm.opt.InitialHeapSize == null\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestG1HeapSizeFlags.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @requires vm.gc.G1\n+ * @requires vm.gc.G1 & vm.opt.G1ConfidencePercent == null\n@@ -66,2 +66,1 @@\n-        ProcessBuilder pb = GCArguments.createJavaProcessBuilder(\n-                \"-XX:+UseG1GC\", flag, \"-version\");\n+        ProcessBuilder pb = GCArguments.createTestJvm(\"-XX:+UseG1GC\", flag, \"-version\");\n@@ -76,2 +75,1 @@\n-    private static\n-    void check(String name, String value, boolean is_valid) throws Exception {\n+    private static void check(String name, String value, boolean is_valid) throws Exception {\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestG1PercentageOptions.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @requires vm.gc.G1\n+ * @requires vm.gc.G1 & vm.opt.UnlockExperimentalVMOptions == null & vm.opt.G1RemSetHowlNumBuckets == null & vm.opt.G1RemSetHowlMaxNumBuckets == null\n@@ -51,1 +51,1 @@\n-    ProcessBuilder pb = GCArguments.createJavaProcessBuilder(flagList);\n+    ProcessBuilder pb = GCArguments.createTestJvm(flagList);\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestG1RemSetFlags.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+ * @requires vm.opt.x.Xminf == null & vm.opt.x.Xmaxf == null & vm.opt.MinHeapFreeRatio == null & vm.opt.MaxHeapFreeRatio == null\n@@ -50,1 +51,1 @@\n-    ProcessBuilder pb = GCArguments.createJavaProcessBuilder(\n+    ProcessBuilder pb = GCArguments.createTestJvm(\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestHeapFreeRatio.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @requires vm.gc.Parallel\n+ * @requires vm.gc.Parallel & vm.opt.InitialTenuringThreshold == null & vm.opt.MaxTenuringThreshold == null\n@@ -44,1 +44,1 @@\n-    ProcessBuilder pb = GCArguments.createJavaProcessBuilder(\n+    ProcessBuilder pb = GCArguments.createTestJvm(\n@@ -61,1 +61,1 @@\n-    ProcessBuilder pb = GCArguments.createJavaProcessBuilder(\n+    ProcessBuilder pb = GCArguments.createTestJvm(\n@@ -63,0 +63,1 @@\n+      \"-XX:+UseParallelGC\",\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestInitialTenuringThreshold.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,0 @@\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n@@ -30,0 +28,2 @@\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n@@ -118,1 +118,1 @@\n-    ProcessBuilder pb = GCArguments.createJavaProcessBuilder(gcflag,\n+    ProcessBuilder pb = GCArguments.createTestJvm(gcflag,\n@@ -211,1 +211,1 @@\n-    ProcessBuilder pb = GCArguments.createJavaProcessBuilder(finalargs.toArray(String[]::new));\n+    ProcessBuilder pb = GCArguments.createTestJvm(finalargs.toArray(String[]::new));\n@@ -311,1 +311,1 @@\n-    ProcessBuilder pb = GCArguments.createJavaProcessBuilder(flags);\n+    ProcessBuilder pb = GCArguments.createTestJvm(flags);\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestMaxHeapSizeTools.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,2 @@\n- * @requires vm.gc.Parallel\n+ * @key flag-sensitive\n+ * @requires vm.gc.Parallel & vm.opt.x.Xmx == null & vm.opt.x.Xms == null & vm.opt.MinHeapSize == null & vm.opt.MaxHeapSize == null & vm.opt.InitialHeapSize == null\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestParallelHeapSizeFlags.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,2 @@\n+ * @key flag-sensitive\n+ * @requires vm.gc.Serial & vm.opt.x.Xmx == null & vm.opt.x.Xms == null & vm.opt.MinHeapSize == null & vm.opt.MaxHeapSize == null & vm.opt.InitialHeapSize == null\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestSerialHeapSizeFlags.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/compiler\/TestLinkToNativeRBP.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n-    private static final Class<?> PREVIEW_API = java.lang.foreign.MemorySegment.class;\n+    private static final Class<?> PREVIEW_API = java.lang.ScopedValue.class;\n","filename":"test\/hotspot\/jtreg\/runtime\/ClassFile\/ClassFileVersionTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,134 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.Utils;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+\/*\n+ * @test StackWalkNativeToJava\n+ * @bug 8316309\n+ * @summary Check that walking the stack works fine when going from C++ frame to Java frame.\n+ * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\"\n+ * @requires os.family != \"windows\"\n+ * @requires vm.flagless\n+ * @library \/test\/lib\n+ * @run driver StackWalkNativeToJava\n+ *\/\n+\n+public class StackWalkNativeToJava {\n+\n+    public static void main(String[] args) throws Exception {\n+        \/\/ Check stack walking works fine when sender of C++ frame\n+        \/\/ is a Java native method.\n+        testStackWalkNativeToJavaNative(\"-Xint\");\n+        testStackWalkNativeToJavaNative(\"-Xcomp\", \"-XX:CompileCommand=dontinline,StackWalkNativeToJava$TestNativeToJavaNative::*\");\n+\n+        \/\/ Check stack walking works fine when sender of C++ frame\n+        \/\/ is a runtime stub or interpreted Java method (VM call from Java).\n+        testStackWalkNativeToJava(\"-Xint\");\n+        testStackWalkNativeToJava(\"-Xcomp\", \"-XX:TieredStopAtLevel=3\",\n+                                  \"-XX:CompileCommand=dontinline,StackWalkNativeToJava$TestNativeToJava::*\");\n+    }\n+\n+    public static void testStackWalkNativeToJavaNative(String... extraFlags) throws Exception {\n+        List<String> commands = new ArrayList<>();\n+        commands.add(\"-Xbootclasspath\/a:.\");\n+        commands.add(\"-XX:-CreateCoredumpOnCrash\");\n+        commands.add(\"-XX:+UnlockDiagnosticVMOptions\");\n+        commands.add(\"-XX:AbortVMOnException=java.lang.IllegalMonitorStateException\");\n+        commands.add(\"-XX:+ErrorFileToStdout\");\n+        commands.addAll(Arrays.asList(extraFlags));\n+        commands.add(\"StackWalkNativeToJava$TestNativeToJavaNative\");\n+\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(commands);\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldNotContain(\"java.lang.RuntimeException: Reached statement after obj.wait()\");\n+        output.shouldNotContain(\"[error occurred during error reporting (printing native stack\");\n+        String[] res = output.getOutput().split(\"StackWalkNativeToJava\\\\$TestNativeToJavaNative\\\\.callNativeMethod\\\\(\\\\)V\");\n+        assertTrue(res.length - 1 == 2, res.length - 1);\n+        output.shouldNotHaveExitValue(0);\n+    }\n+\n+    public static class TestNativeToJavaNative {\n+        public static void main(String[] args) throws Exception {\n+            TestNativeToJavaNative test = new TestNativeToJavaNative();\n+            test.callNativeMethod();\n+        }\n+\n+        public void callNativeMethod() throws Exception {\n+            Object obj = new Object();\n+            \/\/ Trigger a fatal exit due to IllegalMonitorStateException during\n+            \/\/ a call to the VM from a Java native method.\n+            obj.wait();\n+            throw new RuntimeException(\"Reached statement after obj.wait()\");\n+        }\n+    }\n+\n+    public static void testStackWalkNativeToJava(String... extraFlags) throws Exception {\n+        List<String> commands = new ArrayList<>();\n+        commands.add(\"-Xbootclasspath\/a:.\");\n+        commands.add(\"-XX:-CreateCoredumpOnCrash\");\n+        commands.add(\"-XX:+UnlockDiagnosticVMOptions\");\n+        commands.add(\"-XX:DiagnoseSyncOnValueBasedClasses=1\");\n+        commands.add(\"-XX:+ErrorFileToStdout\");\n+        commands.addAll(Arrays.asList(extraFlags));\n+        commands.add(\"StackWalkNativeToJava$TestNativeToJava\");\n+\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(commands);\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldNotContain(\"java.lang.RuntimeException: Reached statement after synchronized\");\n+        output.shouldNotContain(\"[error occurred during error reporting (printing native stack\");\n+        String[] res = output.getOutput().split(\"StackWalkNativeToJava\\\\$TestNativeToJava\\\\.callVMMethod\\\\(\\\\)V\");\n+        assertTrue(res.length - 1 == 2, res.length - 1);\n+        output.shouldNotHaveExitValue(0);\n+    }\n+\n+    public static class TestNativeToJava {\n+        static Integer counter = 0;\n+\n+        public static void main(String[] args) throws Exception {\n+            TestNativeToJava test = new TestNativeToJava();\n+            test.callVMMethod();\n+        }\n+\n+        public void callVMMethod() throws Exception {\n+            \/\/ Trigger a fatal exit for trying to synchronize on a value based class\n+            \/\/ during a call to the VM from a Java method.\n+            synchronized (counter) {\n+                counter++;\n+            }\n+            throw new RuntimeException(\"Reached statement after synchronized\");\n+        }\n+    }\n+\n+    private static void assertTrue(boolean condition, int count) {\n+        if (!condition) {\n+            throw new RuntimeException(\"Count error: count was \" + count);\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/StackWalkNativeToJava.java","additions":134,"deletions":0,"binary":false,"changes":134,"status":"added"},{"patch":"@@ -38,0 +38,1 @@\n+    private static int classesBeforeGC = 0;\n@@ -99,0 +100,8 @@\n+        \/\/ Every N-th classes, force a GC to kick out the loaded classes from previous tests.\n+        \/\/ Different tests come in with different number of classes, so testNum is not reliable.\n+        classesBeforeGC -= classes.size();\n+        if (classesBeforeGC <= 0) {\n+            System.gc();\n+            classesBeforeGC = 3000;\n+        }\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/InvocationTests\/shared\/AbstractGenerator.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary run NMT baseline, create threads and verify output from summary.diff\n+ * @author Evgeny Ignatenko\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:NativeMemoryTracking=summary SummaryDiffThreadCount\n+ *\/\n+\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.JDKToolFinder;\n+\n+public class SummaryDiffThreadCount {\n+    public static void main(String args[]) throws Exception {\n+        ProcessBuilder pb = new ProcessBuilder();\n+        OutputAnalyzer output;\n+        \/\/ Grab my own PID.\n+        String pid = Long.toString(ProcessTools.getProcessId());\n+\n+        pb.command(new String[] { JDKToolFinder.getJDKTool(\"jcmd\"), pid, \"VM.native_memory\", \"baseline=true\"});\n+        pb.start().waitFor();\n+\n+        output = new OutputAnalyzer(pb.start());\n+        output.shouldContain(\"Baseline taken\");\n+\n+        \/\/ Creating 10 threads.\n+        for (int i = 0; i < 10; i++) {\n+            new Thread(()-> {\n+                while (true) { continue; }\n+            }).start();\n+        }\n+\n+        \/\/ Running \"jcmd <pid> VM.native_memory summary.diff\" and checking for five new threads reported.\n+        pb.command(new String[] { JDKToolFinder.getJDKTool(\"jcmd\"), pid, \"VM.native_memory\", \"summary.diff\"});\n+        output = new OutputAnalyzer(pb.start());\n+\n+        \/\/ Trailing '+' is needed to check that NMT now reports that now we have more threads than it\n+        \/\/ was during the baseline.\n+        output.shouldMatch(\"threads #\\\\d+ \\\\+\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/SummaryDiffThreadCount.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,2 @@\n+ * @comment CDS archive heap mapping is not supported with large pages\n+ * @requires vm.opt.UseLargePages == null | !vm.opt.UseLargePages\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/sharedStrings\/InternSharedString.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8317262\n+ * @library \/testlibrary \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+HandshakeALot -XX:GuaranteedSafepointInterval=1 TestStackWalk\n+ *\/\n+\n+import jvmti.JVMTIUtils;\n+import jdk.test.lib.Asserts;\n+import jdk.test.whitebox.WhiteBox;\n+import java.util.concurrent.CountDownLatch;\n+\n+public class TestStackWalk {\n+    static Thread worker1;\n+    static Thread worker2;\n+    static volatile boolean done;\n+    static volatile int counter = 0;\n+    static Object lock = new Object();\n+\n+    public static void main(String... args) throws Exception {\n+        worker1 = new Thread(() -> syncedWorker());\n+        worker1.start();\n+        worker2 = new Thread(() -> syncedWorker());\n+        worker2.start();\n+        Thread worker3 = new Thread(() -> stackWalker());\n+        worker3.start();\n+\n+        worker1.join();\n+        worker2.join();\n+        worker3.join();\n+    }\n+\n+    public static void syncedWorker() {\n+        synchronized (lock) {\n+            while (!done) {\n+                counter++;\n+            }\n+        }\n+    }\n+\n+    public static void stackWalker() {\n+        \/\/ Suspend workers so the one looping waiting for \"done\"\n+        \/\/ doesn't execute the handshake below, increasing the\n+        \/\/ chances the VMThread will do it.\n+        suspendWorkers();\n+\n+        WhiteBox wb = WhiteBox.getWhiteBox();\n+        long end = System.currentTimeMillis() + 20000;\n+        while (end > System.currentTimeMillis()) {\n+            wb.handshakeWalkStack(worker1, false \/* all_threads *\/);\n+            wb.handshakeWalkStack(worker2, false \/* all_threads *\/);\n+        }\n+\n+        resumeWorkers();\n+        done = true;\n+    }\n+\n+    static void suspendWorkers() {\n+        JVMTIUtils.suspendThread(worker1);\n+        JVMTIUtils.suspendThread(worker2);\n+    }\n+\n+    static void resumeWorkers() {\n+        JVMTIUtils.resumeThread(worker1);\n+        JVMTIUtils.resumeThread(worker2);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/lockStack\/TestStackWalk.java","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test id=int\n+ * @summary Check that monitorenter A; monitorenter B; monitorexit A; monitorexit B; works\n+ * @compile TestUnstructuredLocking.jasm\n+ * @run main\/othervm -Xint TestUnstructuredLocking\n+ *\/\n+\/*\n+ * @test id=comp\n+ * @summary Check that monitorenter A; monitorenter B; monitorexit A; monitorexit B; works, with -Xcomp\n+ * @compile TestUnstructuredLocking.jasm\n+ * @run main\/othervm -Xcomp TestUnstructuredLocking\n+ *\/\n+\n+super public class TestUnstructuredLocking version 64:0 {\n+\n+    public static Method main:\"([Ljava\/lang\/String;)V\" stack 2 locals 4 {\n+        new class java\/lang\/Object;\n+        dup;\n+        invokespecial Method java\/lang\/Object.\"<init>\":\"()V\";\n+        astore_1;\n+        new class java\/lang\/Object;\n+        dup;\n+        invokespecial Method java\/lang\/Object.\"<init>\":\"()V\";\n+        astore_2;\n+        aload_1;\n+        monitorenter;\n+        aload_2;\n+        monitorenter;\n+        aload_1;\n+        monitorexit;\n+        aload_2;\n+        monitorexit;\n+        return;\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/locking\/TestUnstructuredLocking.jasm","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Red Hat, Inc. and\/or its affiliates.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.dcmd.PidJcmdExecutor;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+import java.util.Iterator;\n+\n+\/*\n+ * @test CompilerMemoryStatisticTest\n+ * @summary Test Compiler.memory\n+ * @requires vm.compiler1.enabled\n+ * @requires vm.compiler2.enabled\n+ *\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @run main\/othervm -XX:CompileCommand=memstat,*.* CompilerMemoryStatisticTest\n+ *\/\n+\n+\/*\n+ * @test CompilerMemoryStatisticTest\n+ * @summary Test Compiler.memory\n+ * @requires vm.compiler1.enabled\n+ * @requires vm.compiler2.enabled\n+ *\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @run main\/othervm -XX:CompileCommand=memstat,*.*,collect CompilerMemoryStatisticTest\n+ *\/\n+\n+public class CompilerMemoryStatisticTest {\n+\n+    public static void main(String args[]) throws Exception {\n+        PidJcmdExecutor executor = new PidJcmdExecutor();\n+        OutputAnalyzer out = executor.execute(\"Compiler.memory\");\n+        out.shouldHaveExitValue(0);\n+\n+        \/\/ Looks like this:\n+        \/\/ total     NA        RA        #nodes  time    type  #rc thread              method\n+        \/\/ 621832    0         589104    0       0,025   c1    1   0x00007f5ccc1951a0  java\/util\/zip\/ZipFile$Source.checkAndAddEntry((II)I)\n+        out.shouldMatch(\"total.*method\");\n+        out.shouldMatch(\"\\\\d+ +\\\\d+ +\\\\d+ +\\\\d+.*java.*\\\\(.*\\\\)\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/compiler\/CompilerMemoryStatisticTest.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -0,0 +1,300 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.File;\n+import java.lang.ref.Reference;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.JDKToolLauncher;\n+import jdk.test.lib.apps.LingeredApp;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import jdk.test.lib.hprof.model.JavaClass;\n+import jdk.test.lib.hprof.model.JavaHeapObject;\n+import jdk.test.lib.hprof.model.Root;\n+import jdk.test.lib.hprof.model.Snapshot;\n+import jdk.test.lib.hprof.model.StackFrame;\n+import jdk.test.lib.hprof.model.StackTrace;\n+import jdk.test.lib.hprof.model.ThreadObject;\n+import jdk.test.lib.hprof.parser.Reader;\n+\n+\/**\n+ * @test id=default\n+ * @requires vm.jvmti\n+ * @requires vm.continuations\n+ * @library \/test\/lib\n+ * @run main VThreadInHeapDump\n+ *\/\n+\n+\/**\n+ * @test id=no-vmcontinuations\n+ * @requires vm.jvmti\n+ * @library \/test\/lib\n+ * @comment pass extra VM arguments as the test arguments\n+ * @run main VThreadInHeapDump\n+ *           -XX:+UnlockExperimentalVMOptions -XX:-VMContinuations\n+ *\/\n+\n+class VThreadInHeapDumpTarg extends LingeredApp {\n+\n+    public static class VThreadUnmountedReferenced {\n+    }\n+    public static class VThreadMountedReferenced {\n+    }\n+    public static class PThreadReferenced {\n+    }\n+\n+    public class ThreadBase {\n+        private volatile boolean threadReady = false;\n+\n+        protected void ready() {\n+            threadReady = true;\n+        }\n+\n+        public void waitReady() {\n+            while (!threadReady) {\n+                try {\n+                    Thread.sleep(10);\n+                } catch (InterruptedException e) {\n+                }\n+            }\n+        }\n+    }\n+\n+    public class VthreadUnmounted extends ThreadBase implements Runnable {\n+        public void run() {\n+            Object referenced = new VThreadUnmountedReferenced();\n+            ready();\n+            \/\/ The thread will be unmounted in awaitToStop().\n+            awaitToStop();\n+            Reference.reachabilityFence(referenced);\n+        }\n+    }\n+\n+    public class VthreadMounted extends ThreadBase implements Runnable {\n+        int dummy = -1;\n+\n+        public void run() {\n+            Object referenced = new VThreadMountedReferenced();\n+            ready();\n+            \/\/ Don't give a chance for the thread to unmount.\n+            while (!timeToStop) {\n+                if (++dummy == 10000) {\n+                    dummy = 0;\n+                }\n+            }\n+            Reference.reachabilityFence(referenced);\n+        }\n+    }\n+\n+    public class Pthread extends ThreadBase implements Runnable {\n+        public void run() {\n+            Object referenced = new PThreadReferenced();\n+            ready();\n+            awaitToStop();\n+            Reference.reachabilityFence(referenced);\n+        }\n+    }\n+\n+    CountDownLatch timeToStopLatch = new CountDownLatch(1);\n+    volatile boolean timeToStop = false;\n+\n+    void awaitToStop() {\n+        try {\n+            timeToStopLatch.await();\n+        } catch (InterruptedException e) {\n+        }\n+    }\n+\n+    private void runTest(String[] args) {\n+        try {\n+            \/\/ Unmounted virtual thread.\n+            VthreadUnmounted vthreadUnmounted = new VthreadUnmounted();\n+            Thread.ofVirtual().start(vthreadUnmounted);\n+            vthreadUnmounted.waitReady();\n+\n+            \/\/ Mounted virtual thread.\n+            VthreadMounted vthreadMounted = new VthreadMounted();\n+            Thread.ofVirtual().start(vthreadMounted);\n+            vthreadMounted.waitReady();\n+\n+            \/\/ Platform thread.\n+            Pthread pthread = new Pthread();\n+            Thread.ofPlatform().start(pthread);\n+            pthread.waitReady();\n+\n+            \/\/ We are ready.\n+            LingeredApp.main(args);\n+\n+        } finally {\n+            \/\/ Signal all threads to finish.\n+            timeToStop = true;\n+            timeToStopLatch.countDown();\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        VThreadInHeapDumpTarg test = new VThreadInHeapDumpTarg();\n+        test.runTest(args);\n+    }\n+\n+}\n+\n+\n+public class VThreadInHeapDump {\n+\n+    \/\/ test arguments are extra VM options for target process\n+    public static void main(String[] args) throws Exception {\n+        File dumpFile = new File(\"Myheapdump.hprof\");\n+        createDump(dumpFile, args);\n+        verifyDump(dumpFile);\n+    }\n+\n+    private static void createDump(File dumpFile, String[] extraOptions) throws Exception {\n+        LingeredApp theApp = null;\n+        try {\n+            theApp = new VThreadInHeapDumpTarg();\n+\n+            List<String> extraVMArgs = new ArrayList<>();\n+            extraVMArgs.add(\"-Djdk.virtualThreadScheduler.parallelism=1\");\n+            extraVMArgs.addAll(Arrays.asList(extraOptions));\n+            LingeredApp.startApp(theApp, extraVMArgs.toArray(new String[0]));\n+\n+            \/\/jcmd <pid> GC.heap_dump <file_path>\n+            JDKToolLauncher launcher = JDKToolLauncher\n+                    .createUsingTestJDK(\"jcmd\")\n+                    .addToolArg(Long.toString(theApp.getPid()))\n+                    .addToolArg(\"GC.heap_dump\")\n+                    .addToolArg(dumpFile.getAbsolutePath());\n+            Process p = ProcessTools.startProcess(\"jcmd\", new ProcessBuilder(launcher.getCommand()));\n+            \/\/ If something goes wrong with heap dumping most likely we'll get crash of the target VM.\n+            while (!p.waitFor(5, TimeUnit.SECONDS)) {\n+                if (!theApp.getProcess().isAlive()) {\n+                    log(\"ERROR: target VM died, killing jcmd...\");\n+                    p.destroyForcibly();\n+                    throw new Exception(\"Target VM died\");\n+                }\n+            }\n+\n+            if (p.exitValue() != 0) {\n+                throw new Exception(\"Jcmd exited with code \" + p.exitValue());\n+            }\n+        } finally {\n+            LingeredApp.stopApp(theApp);\n+        }\n+    }\n+\n+    private static void verifyDump(File dumpFile) throws Exception {\n+        Asserts.assertTrue(dumpFile.exists(), \"Heap dump file not found.\");\n+\n+        log(\"Reading \" + dumpFile + \"...\");\n+        try (Snapshot snapshot = Reader.readFile(dumpFile.getPath(), true, 0)) {\n+            log(\"Resolving snapshot...\");\n+            snapshot.resolve(true);\n+            log(\"Snapshot resolved.\");\n+\n+            \/\/ Log all threads with stack traces and stack references.\n+            List<ThreadObject> threads = snapshot.getThreads();\n+            List<Root> roots = Collections.list(snapshot.getRoots());\n+            log(\"Threads:\");\n+            for (ThreadObject thread: threads) {\n+                StackTrace st = thread.getStackTrace();\n+                StackFrame[] frames = st.getFrames();\n+                log(\"thread \" + thread.getIdString() + \", \" + frames.length + \" frames\");\n+\n+                List<Root> stackRoots = findStackRoot(roots, thread);\n+                for (int i = 0; i < frames.length; i++) {\n+                    log(\"  - [\" + i + \"] \"\n+                        + frames[i].getClassName() + \".\" + frames[i].getMethodName()\n+                        + frames[i].getMethodSignature()\n+                        + \" (\" + frames[i].getSourceFileName()\n+                        + \":\" + frames[i].getLineNumber() + \")\");\n+\n+                    for (Root r: stackRoots) {\n+                        StackFrame[] rootFrames = r.getStackTrace().getFrames();\n+                        \/\/ the frame this local belongs to\n+                        StackFrame frame = rootFrames[rootFrames.length - 1];\n+                        if (frame == frames[i]) {\n+                            JavaHeapObject obj = snapshot.findThing(r.getId());\n+                            JavaClass objClass = obj.getClazz();\n+                            log(\"      \" + r.getDescription() + \": \" + objClass.getName());\n+                        }\n+                    }\n+                }\n+            }\n+\n+            \/\/ Verify objects from thread stacks are dumped.\n+            test(snapshot, VThreadInHeapDumpTarg.VThreadMountedReferenced.class);\n+            test(snapshot, VThreadInHeapDumpTarg.PThreadReferenced.class);\n+            \/\/ Dumping of unmounted vthreads is not implemented yet\n+            \/\/test(snapshot, VThreadInHeapDumpTarg.VThreadUnmountedReferenced.class);\n+        }\n+\n+    }\n+\n+    private static List<Root> findStackRoot(List<Root> roots, ThreadObject thread) {\n+        List<Root> result = new ArrayList<>();\n+        for (Root root: roots) {\n+            if (root.getReferrerId() == thread.getId()) {\n+                result.add(root);\n+            }\n+        }\n+        return result;\n+    }\n+\n+    private static void test(Snapshot snapshot, String className) {\n+        log(\"Testing \" + className + \"...\");\n+        JavaClass jClass = snapshot.findClass(className);\n+        if (jClass == null) {\n+            throw new RuntimeException(\"'\" + className + \"' not found\");\n+        }\n+        int instanceCount = jClass.getInstancesCount(false);\n+        if (instanceCount != 1) {\n+            throw new RuntimeException(\"Expected 1 instance, \" + instanceCount + \" instances found\");\n+        }\n+        \/\/ There is the only instance.\n+        JavaHeapObject heapObj = jClass.getInstances(false).nextElement();\n+\n+        Root root = heapObj.getRoot();\n+        if (root == null) {\n+            throw new RuntimeException(\"No root for \" + className + \" instance\");\n+        }\n+        log(\"  root: \" + root.getDescription());\n+        JavaHeapObject referrer = root.getReferrer();\n+        log(\"  referrer: \" + referrer);\n+    }\n+\n+    private static void test(Snapshot snapshot, Class cls) {\n+        test(snapshot, cls.getName());\n+    }\n+\n+    private static void log(Object s) {\n+        System.out.println(s);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/HeapDump\/VThreadInHeapDump.java","additions":300,"deletions":0,"binary":false,"changes":300,"status":"added"},{"patch":"@@ -42,0 +42,1 @@\n+java\/nio\/channels\/vthread\/BlockingChannelOps.java#direct-register 8315544 windows-x64\n","filename":"test\/jdk\/ProblemList-generational-zgc.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -381,1 +381,1 @@\n-java\/awt\/Mouse\/MouseModifiersUnitTest\/MouseModifiersUnitTest_Standard.java 7124407 macosx-all\n+java\/awt\/Mouse\/MouseModifiersUnitTest\/MouseModifiersUnitTest_Standard.java 7124407,8302787  macosx-all,windows-all\n@@ -459,0 +459,2 @@\n+java\/awt\/KeyboardFocusmanager\/ConsumeNextMnemonicKeyTypedTest\/ConsumeForModalDialogTest\/ConsumeForModalDialogTest.java 8302787 windows-all\n+java\/awt\/KeyboardFocusmanager\/TypeAhead\/MenuItemActivatedTest\/MenuItemActivatedTest.java 8302787 windows-all\n@@ -463,1 +465,0 @@\n-java\/awt\/GraphicsDevice\/CheckDisplayModes.java 8266242 macosx-aarch64\n@@ -557,0 +558,2 @@\n+java\/net\/Socket\/asyncClose\/Race.java                            8317801 aix-ppc64\n+\n@@ -563,0 +566,2 @@\n+java\/nio\/channels\/Channels\/SocketChannelStreams.java            8317838 aix-ppc64\n+\n@@ -620,6 +625,6 @@\n-sun\/security\/tools\/keytool\/NssTest.java                         8295343 linux-all\n-sun\/security\/pkcs11\/Signature\/TestRSAKeyLength.java             8295343 linux-all\n-sun\/security\/pkcs11\/rsa\/TestSignatures.java                     8295343 linux-all\n-sun\/security\/pkcs11\/rsa\/TestKeyPairGenerator.java               8295343 linux-all\n-sun\/security\/pkcs11\/rsa\/TestKeyFactory.java                     8295343 linux-all\n-sun\/security\/pkcs11\/KeyStore\/Basic.java                         8295343 linux-all\n+sun\/security\/tools\/keytool\/NssTest.java                         8295343 generic-all\n+sun\/security\/pkcs11\/Signature\/TestRSAKeyLength.java             8295343 generic-all\n+sun\/security\/pkcs11\/rsa\/TestSignatures.java                     8295343 generic-all\n+sun\/security\/pkcs11\/rsa\/TestKeyPairGenerator.java               8295343 generic-all\n+sun\/security\/pkcs11\/rsa\/TestKeyFactory.java                     8295343 generic-all\n+sun\/security\/pkcs11\/KeyStore\/Basic.java                         8295343 generic-all\n@@ -758,1 +763,1 @@\n-jdk\/jfr\/api\/consumer\/recordingstream\/TestOnEvent.java           8255404 linux-x64\n+jdk\/jfr\/api\/consumer\/recordingstream\/TestOnEvent.java           8255404 linux-x64,linux-aarch64\n","filename":"test\/jdk\/ProblemList.txt","additions":14,"deletions":9,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8318328\n+ * @summary DHKEM should check XDH name in case-insensitive mode\n+ * @library \/test\/lib\n+ * @modules java.base\/com.sun.crypto.provider\n+ *\/\n+import javax.crypto.KEM;\n+import java.math.BigInteger;\n+import java.security.KeyPairGenerator;\n+import java.security.interfaces.XECPublicKey;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.NamedParameterSpec;\n+\n+public class NameSensitiveness {\n+    public static void main(String[] args) throws Exception {\n+        var g = KeyPairGenerator.getInstance(\"XDH\");\n+        g.initialize(NamedParameterSpec.X25519);\n+        var pk1 = (XECPublicKey) g.generateKeyPair().getPublic();\n+        var pk2 = new XECPublicKey() {\n+            public BigInteger getU() {\n+                return pk1.getU();\n+            }\n+            public AlgorithmParameterSpec getParams() {\n+                return new NamedParameterSpec(\"x25519\"); \/\/ lowercase!!!\n+            }\n+            public String getAlgorithm() {\n+                return pk1.getAlgorithm();\n+            }\n+            public String getFormat() {\n+                return pk1.getFormat();\n+            }\n+            public byte[] getEncoded() {\n+                return pk1.getEncoded();\n+            }\n+        };\n+        var kem = KEM.getInstance(\"DHKEM\");\n+        kem.newEncapsulator(pk2);\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/DHKEM\/NameSensitiveness.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -53,0 +53,1 @@\n+                .screenCapture()\n","filename":"test\/jdk\/java\/awt\/Frame\/DefaultSizeTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n-import javax.swing.UIManager;\n@@ -57,0 +56,6 @@\n+        if (\"2\".equals(System.getProperty(\"jdk.gtk.version\"))\n+                && System.getenv(\"WAYLAND_DISPLAY\") != null) {\n+            \/\/ screen capture is not supported with gtk2 on Wayland\n+            return;\n+        }\n+\n","filename":"test\/jdk\/java\/awt\/Robot\/HiDPIScreenCapture\/ScreenCaptureGtkTest.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-  @run main RejectDragDropActionTest\n+  @run main\/timeout=300 RejectDragDropActionTest\n@@ -33,1 +33,0 @@\n-import java.awt.AWTException;\n@@ -49,1 +48,0 @@\n-import java.lang.reflect.InvocationTargetException;\n@@ -56,1 +54,1 @@\n-    private static final int FRAME_ACTIVATION_TIMEOUT = 3000;\n+    private static final int DELAY_TIME = 500;\n@@ -77,2 +75,1 @@\n-    public static void main(String[] args) throws InterruptedException,\n-            InvocationTargetException, AWTException {\n+    public static void main(String[] args) throws Exception {\n@@ -83,2 +80,4 @@\n-            dgr = ds.createDefaultDragGestureRecognizer(frame, DnDConstants.ACTION_COPY, dgl);\n-            frame.setBounds(100, 100, 200, 200);\n+            dgr = ds.createDefaultDragGestureRecognizer(frame,\n+                    DnDConstants.ACTION_COPY, dgl);\n+            frame.setSize(200, 200);\n+            frame.setLocationRelativeTo(null);\n@@ -90,0 +89,1 @@\n+            robot.setAutoWaitForIdle(true);\n@@ -91,1 +91,1 @@\n-            robot.delay(FRAME_ACTIVATION_TIMEOUT);\n+            robot.delay(DELAY_TIME);\n@@ -100,1 +100,2 @@\n-            for (Point p = new Point(startPoint); !p.equals(endPoint);\n+            for (Point p = new Point(startPoint);\n+                 !p.equals(endPoint) && !incorrectActionDetected;\n@@ -102,1 +103,1 @@\n-                         sign(endPoint.y - p.y))) {\n+                             sign(endPoint.y - p.y))) {\n@@ -104,1 +105,0 @@\n-                robot.delay(50);\n","filename":"test\/jdk\/java\/awt\/dnd\/RejectDragDropActionTest.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,132 @@\n+\/*\n+ * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.List;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.TextArea;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+import java.awt.event.MouseListener;\n+\n+\/*\n+ * @test\n+ * @key headful\n+ * @bug 4454304\n+ * @summary On Solaris, TextArea triggers MouseEntered when the mouse is inside the component\n+ * @run main MouseEnterExitTest\n+ *\/\n+public class MouseEnterExitTest {\n+\n+    private static Frame frame;\n+\n+    private volatile static boolean entered = false;\n+    private volatile static boolean exited = false;\n+    private volatile static boolean passed = true;\n+\n+    private volatile static Point compAt;\n+    private volatile static Dimension compSize;\n+\n+    private static final MouseListener mouseListener = new MouseAdapter() {\n+        @Override\n+        public void mouseEntered(MouseEvent e) {\n+            System.out.println(\n+                \"MouseEntered component \" + e.getSource().getClass().getName());\n+            if (entered) {\n+                passed = false;\n+            }\n+            entered = true;\n+            exited = false;\n+        }\n+\n+        @Override\n+        public void mouseExited(MouseEvent e) {\n+            System.out.println(\n+                \"MouseExited component \" + e.getSource().getClass().getName());\n+            if (exited) {\n+                passed = false;\n+            }\n+            entered = false;\n+            exited = true;\n+        }\n+    };\n+\n+    private static void initializeGUI() {\n+        frame = new Frame(\"MouseEnterExitTest\");\n+        frame.setLayout(new FlowLayout());\n+        List list = new List(4);\n+        for (int i = 0; i < 10; i++) {\n+            list.add(\"item \" + i);\n+        }\n+        list.addMouseListener(mouseListener);\n+        frame.add(list);\n+\n+        TextArea textArea = new TextArea(\"TextArea\", 10, 20);\n+        textArea.addMouseListener(mouseListener);\n+        frame.add(textArea);\n+\n+        frame.pack();\n+        frame.setLocationRelativeTo(null);\n+        frame.setVisible(true);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        try {\n+            Robot robot = new Robot();\n+            robot.setAutoDelay(100);\n+            robot.setAutoWaitForIdle(true);\n+\n+            EventQueue.invokeAndWait(MouseEnterExitTest::initializeGUI);\n+            robot.waitForIdle();\n+\n+            EventQueue.invokeAndWait(() -> {\n+                compAt = frame.getLocationOnScreen();\n+                compSize = frame.getSize();\n+            });\n+            compAt.y += compSize.getHeight() \/ 2;\n+            int xr = compAt.x + compSize.width + 1;\n+            for (int i = compAt.x - 5; (i < xr) && passed; i++) {\n+                robot.mouseMove(i, compAt.y);\n+            }\n+\n+            if (!passed || entered || !exited) {\n+                throw new RuntimeException(\n+                    \"MouseEnterExitTest FAILED. MouseEntered\/MouseExited \"\n+                        + \"not properly triggered. Please see the log\");\n+            }\n+            System.out.println(\"Test PASSED\");\n+        } finally {\n+            EventQueue.invokeAndWait(MouseEnterExitTest::disposeFrame);\n+        }\n+    }\n+\n+    private static void disposeFrame() {\n+        if (frame != null) {\n+            frame.dispose();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/event\/MouseEvent\/MouseEnterExitTest.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-   @author Anton Nashatyrev\n@@ -32,3 +31,9 @@\n-import javax.swing.*;\n-import java.awt.*;\n-import java.awt.event.*;\n+import java.awt.AWTEvent;\n+import java.awt.Dimension;\n+import java.awt.FlowLayout;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.Toolkit;\n+import java.awt.event.AWTEventListener;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n@@ -37,0 +42,4 @@\n+import javax.swing.JButton;\n+import javax.swing.JFrame;\n+import javax.swing.SwingUtilities;\n+\n@@ -47,0 +56,3 @@\n+    private volatile Point sLoc;\n+    private volatile Dimension bSize;\n+\n@@ -101,2 +113,5 @@\n-        Point sLoc = fb.getLocationOnScreen();\n-        Dimension bSize = fb.getSize();\n+        SwingUtilities.invokeAndWait(() -> {\n+            sLoc = fb.getLocationOnScreen();\n+            bSize = fb.getSize();\n+        });\n+\n@@ -104,1 +119,1 @@\n-        r.mousePress(MouseEvent.BUTTON1_MASK);\n+        r.mousePress(MouseEvent.BUTTON1_DOWN_MASK);\n@@ -122,1 +137,1 @@\n-        r.mouseRelease(MouseEvent.BUTTON1_MASK);\n+        r.mouseRelease(MouseEvent.BUTTON1_DOWN_MASK);\n","filename":"test\/jdk\/java\/awt\/event\/MouseWheelEvent\/WheelModifier\/WheelModifier.java","additions":24,"deletions":9,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/CompositeLookupTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -37,4 +37,13 @@\n- * @test\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n- * @run testng\/othervm --enable-native-access=ALL-UNNAMED LibraryLookupTest\n+ * @test id=specialized\n+ * @run testng\/othervm\n+ *  -Djdk.internal.foreign.DowncallLinker.USE_SPEC=true\n+ *  --enable-native-access=ALL-UNNAMED\n+ *  LibraryLookupTest\n+ *\/\n+\n+\/*\n+ * @test id=interpreted\n+ * @run testng\/othervm\n+ *   -Djdk.internal.foreign.DowncallLinker.USE_SPEC=false\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   LibraryLookupTest\n","filename":"test\/jdk\/java\/foreign\/LibraryLookupTest.java","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/MemoryLayoutPrincipalTotalityTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/MemoryLayoutTypeRetentionTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -89,0 +89,2 @@\n+    public static final Linker LINKER = Linker.nativeLinker();\n+\n@@ -94,1 +96,1 @@\n-    public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;\n+    public static final ValueLayout.OfBoolean C_BOOL = (ValueLayout.OfBoolean) LINKER.canonicalLayouts().get(\"bool\");\n@@ -98,1 +100,1 @@\n-    public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;\n+    public static final ValueLayout.OfByte C_CHAR = (ValueLayout.OfByte) LINKER.canonicalLayouts().get(\"char\");\n@@ -102,1 +104,1 @@\n-    public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT;\n+    public static final ValueLayout.OfShort C_SHORT = (ValueLayout.OfShort) LINKER.canonicalLayouts().get(\"short\");\n@@ -106,1 +108,1 @@\n-    public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT;\n+    public static final ValueLayout.OfInt C_INT = (ValueLayout.OfInt) LINKER.canonicalLayouts().get(\"int\");\n@@ -111,1 +113,1 @@\n-    public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG;\n+    public static final ValueLayout.OfLong C_LONG_LONG = (ValueLayout.OfLong) LINKER.canonicalLayouts().get(\"long long\");\n@@ -115,1 +117,1 @@\n-    public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT;\n+    public static final ValueLayout.OfFloat C_FLOAT = (ValueLayout.OfFloat) LINKER.canonicalLayouts().get(\"float\");\n@@ -119,1 +121,1 @@\n-    public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE;\n+    public static final ValueLayout.OfDouble C_DOUBLE = (ValueLayout.OfDouble) LINKER.canonicalLayouts().get(\"double\");\n@@ -123,4 +125,21 @@\n-    public static final AddressLayout C_POINTER = ValueLayout.ADDRESS\n-            .withTargetLayout(MemoryLayout.sequenceLayout(C_CHAR));\n-\n-    public static final Linker LINKER = Linker.nativeLinker();\n+    public static final AddressLayout C_POINTER = ((AddressLayout) LINKER.canonicalLayouts().get(\"void*\"))\n+            .withTargetLayout(MemoryLayout.sequenceLayout(Long.MAX_VALUE, C_CHAR));\n+    \/**\n+     * The layout for the {@code size_t} C type\n+     *\/\n+    public static final ValueLayout C_SIZE_T = (ValueLayout) LINKER.canonicalLayouts().get(\"size_t\");\n+\n+    \/\/ Common layout shared by some tests\n+    \/\/ struct S_PDI { void* p0; double p1; int p2; };\n+    public static final MemoryLayout S_PDI_LAYOUT = switch ((int) ValueLayout.ADDRESS.byteSize()) {\n+        case 8 -> MemoryLayout.structLayout(\n+            C_POINTER.withName(\"p0\"),\n+            C_DOUBLE.withName(\"p1\"),\n+            C_INT.withName(\"p2\"),\n+            MemoryLayout.paddingLayout(4));\n+        case 4 -> MemoryLayout.structLayout(\n+            C_POINTER.withName(\"p0\"),\n+            C_DOUBLE.withName(\"p1\"),\n+            C_INT.withName(\"p2\"));\n+        default -> throw new UnsupportedOperationException(\"Unsupported address size\");\n+    };\n@@ -251,2 +270,2 @@\n-            accessor.set(container, fieldValue.value());\n-            return actual -> fieldCheck.accept(accessor.get((MemorySegment) actual));\n+            accessor.set(container, 0L, fieldValue.value());\n+            return actual -> fieldCheck.accept(accessor.get((MemorySegment) actual, 0L));\n@@ -260,1 +279,1 @@\n-                return (MemorySegment) slicer.invokeExact(container);\n+                return (MemorySegment) slicer.invokeExact(container, 0L);\n","filename":"test\/jdk\/java\/foreign\/NativeTestHelper.java","additions":33,"deletions":14,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -25,4 +25,13 @@\n- * @test\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n- * @run testng\/othervm --enable-native-access=ALL-UNNAMED SafeFunctionAccessTest\n+ * @test id=specialized\n+ * @run testng\/othervm\n+ *  -Djdk.internal.foreign.DowncallLinker.USE_SPEC=true\n+ *  --enable-native-access=ALL-UNNAMED\n+ *  SafeFunctionAccessTest\n+ *\/\n+\n+\/*\n+ * @test id=interpreted\n+ * @run testng\/othervm\n+ *   -Djdk.internal.foreign.DowncallLinker.USE_SPEC=false\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   SafeFunctionAccessTest\n","filename":"test\/jdk\/java\/foreign\/SafeFunctionAccessTest.java","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -54,1 +52,0 @@\n-@Test\n@@ -124,2 +121,5 @@\n-        String formatArgs = args.stream()\n-                .map(a -> a.format)\n+        String javaFormatArgs = args.stream()\n+                .map(a -> a.javaFormat)\n+                .collect(Collectors.joining(\",\"));\n+        String nativeFormatArgs = args.stream()\n+                .map(a -> a.nativeFormat)\n@@ -128,1 +128,2 @@\n-        String formatString = \"hello(\" + formatArgs + \")\\n\";\n+        String javaFormatString = \"hello(\" + javaFormatArgs + \")\\n\";\n+        String nativeFormatString = \"hello(\" + nativeFormatArgs + \")\\n\";\n@@ -130,1 +131,1 @@\n-        String expected = String.format(formatString, args.stream()\n+        String expected = String.format(javaFormatString, args.stream()\n@@ -133,1 +134,1 @@\n-        int found = stdLibHelper.printf(formatString, args);\n+        int found = stdLibHelper.printf(nativeFormatString, args);\n@@ -159,0 +160,1 @@\n+        \/\/ void qsort( void *ptr, size_t count, size_t size, int (*comp)(const void *, const void *) );\n@@ -160,1 +162,1 @@\n-                FunctionDescriptor.ofVoid(C_POINTER, C_LONG_LONG, C_LONG_LONG, C_POINTER));\n+                FunctionDescriptor.ofVoid(C_POINTER, C_SIZE_T, C_SIZE_T, C_POINTER));\n@@ -190,3 +192,3 @@\n-                buf.setUtf8String(0, s1);\n-                MemorySegment other = arena.allocateUtf8String(s2);\n-                return ((MemorySegment)strcat.invokeExact(buf, other)).getUtf8String(0);\n+                buf.setString(0, s1);\n+                MemorySegment other = arena.allocateFrom(s2);\n+                return ((MemorySegment)strcat.invokeExact(buf, other)).getString(0);\n@@ -198,2 +200,2 @@\n-                MemorySegment ns1 = arena.allocateUtf8String(s1);\n-                MemorySegment ns2 = arena.allocateUtf8String(s2);\n+                MemorySegment ns1 = arena.allocateFrom(s1);\n+                MemorySegment ns2 = arena.allocateFrom(s2);\n@@ -206,1 +208,1 @@\n-                MemorySegment s = arena.allocateUtf8String(msg);\n+                MemorySegment s = arena.allocateFrom(msg);\n@@ -213,1 +215,1 @@\n-                MemorySegment s = arena.allocateUtf8String(msg);\n+                MemorySegment s = arena.allocateFrom(msg);\n@@ -280,1 +282,1 @@\n-                MemorySegment nativeArr = arena.allocateArray(C_INT, arr);\n+                MemorySegment nativeArr = arena.allocateFrom(C_INT, arr);\n@@ -285,1 +287,5 @@\n-                qsort.invokeExact(nativeArr, (long)arr.length, C_INT.byteSize(), qsortUpcallStub);\n+                \/\/ both of these fit in an int\n+                \/\/ automatically widen them to long on x64\n+                int count = arr.length;\n+                int size = (int) C_INT.byteSize();\n+                qsort.invoke(nativeArr, count, size, qsortUpcallStub);\n@@ -303,1 +309,1 @@\n-                MemorySegment formatStr = arena.allocateUtf8String(format);\n+                MemorySegment formatStr = arena.allocateFrom(format);\n@@ -381,4 +387,4 @@\n-        INT(int.class, C_INT, \"%d\", arena -> 42, 42),\n-        LONG(long.class, C_LONG_LONG, \"%d\", arena -> 84L, 84L),\n-        DOUBLE(double.class, C_DOUBLE, \"%.4f\", arena -> 1.2345d, 1.2345d),\n-        STRING(MemorySegment.class, C_POINTER, \"%s\", arena -> arena.allocateUtf8String(\"str\"), \"str\");\n+        INT(int.class, C_INT, \"%d\", \"%d\", arena -> 42, 42),\n+        LONG(long.class, C_LONG_LONG, \"%lld\", \"%d\", arena -> 84L, 84L),\n+        DOUBLE(double.class, C_DOUBLE, \"%.4f\", \"%.4f\", arena -> 1.2345d, 1.2345d),\n+        STRING(MemorySegment.class, C_POINTER, \"%s\", \"%s\", arena -> arena.allocateFrom(\"str\"), \"str\");\n@@ -388,1 +394,2 @@\n-        final String format;\n+        final String nativeFormat;\n+        final String javaFormat;\n@@ -392,1 +399,2 @@\n-        <Z, L extends ValueLayout> PrintfArg(Class<?> carrier, L layout, String format, Function<Arena, Z> nativeValueFactory, Object javaValue) {\n+        <Z, L extends ValueLayout> PrintfArg(Class<?> carrier, L layout, String nativeFormat, String javaFormat,\n+                                             Function<Arena, Z> nativeValueFactory, Object javaValue) {\n@@ -395,1 +403,2 @@\n-            this.format = format;\n+            this.nativeFormat = nativeFormat;\n+            this.javaFormat = javaFormat;\n","filename":"test\/jdk\/java\/foreign\/StdLibTest.java","additions":35,"deletions":26,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -0,0 +1,179 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng\/othervm -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=true -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=false -Xverify:all TestAccessModes\n+ * @run testng\/othervm -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=true -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=true -Xverify:all TestAccessModes\n+ * @run testng\/othervm -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=false -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=false -Xverify:all TestAccessModes\n+ * @run testng\/othervm -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=false -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=true -Xverify:all TestAccessModes\n+ *\/\n+\n+import java.lang.foreign.AddressLayout;\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.invoke.VarHandle;\n+import java.lang.invoke.VarHandle.AccessMode;\n+import java.util.ArrayList;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.testng.annotations.*;\n+\n+import static org.testng.Assert.*;\n+public class TestAccessModes {\n+\n+    @Test(dataProvider = \"segmentsAndLayoutsAndModes\")\n+    public void testAccessModes(MemorySegment segment, ValueLayout layout, AccessMode mode) throws Throwable {\n+        VarHandle varHandle = layout.varHandle();\n+        MethodHandle methodHandle = varHandle.toMethodHandle(mode);\n+        boolean compatible = AccessModeKind.supportedModes(layout).contains(AccessModeKind.of(mode));\n+        try {\n+            Object o = methodHandle.invokeWithArguments(makeArgs(segment, varHandle.accessModeType(mode)));\n+            assertTrue(compatible);\n+        } catch (UnsupportedOperationException ex) {\n+            assertFalse(compatible);\n+        } catch (IllegalArgumentException ex) {\n+            \/\/ access is unaligned, but access mode is supported\n+            assertTrue(compatible);\n+        }\n+    }\n+\n+    Object[] makeArgs(MemorySegment segment, MethodType type) throws Throwable {\n+        List<Object> args = new ArrayList<>();\n+        args.add(segment);\n+        for (Class argType : type.dropParameterTypes(0, 1).parameterList()) {\n+            args.add(defaultValue(argType));\n+        }\n+        return args.toArray();\n+    }\n+\n+    Object defaultValue(Class<?> clazz) throws Throwable {\n+        if (clazz == MemorySegment.class) {\n+            return MemorySegment.NULL;\n+        } else if (clazz.isPrimitive()) {\n+            return MethodHandles.zero(clazz).invoke();\n+        } else {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+\n+    \/*\n+     * See the javadoc of MemoryLayout::varHandle.\n+     *\/\n+    enum AccessModeKind {\n+        PLAIN,\n+        READ_WRITE,\n+        ATOMIC_UPDATE,\n+        ATOMIC_NUMERIC_UPDATE,\n+        ATOMIC_BITWISE_UPDATE;\n+\n+        static AccessModeKind of(AccessMode mode) {\n+            return switch (mode) {\n+                case GET, SET -> PLAIN;\n+                case GET_ACQUIRE, GET_OPAQUE, GET_VOLATILE, SET_VOLATILE,\n+                        SET_OPAQUE, SET_RELEASE -> READ_WRITE;\n+                case GET_AND_SET, GET_AND_SET_ACQUIRE, GET_AND_SET_RELEASE,\n+                        WEAK_COMPARE_AND_SET, WEAK_COMPARE_AND_SET_RELEASE,\n+                        WEAK_COMPARE_AND_SET_ACQUIRE, WEAK_COMPARE_AND_SET_PLAIN,\n+                        COMPARE_AND_EXCHANGE, COMPARE_AND_EXCHANGE_ACQUIRE,\n+                        COMPARE_AND_EXCHANGE_RELEASE, COMPARE_AND_SET -> ATOMIC_UPDATE;\n+                case GET_AND_ADD, GET_AND_ADD_ACQUIRE, GET_AND_ADD_RELEASE -> ATOMIC_NUMERIC_UPDATE;\n+                default -> ATOMIC_BITWISE_UPDATE;\n+            };\n+        }\n+\n+        static Set<AccessModeKind> supportedModes(ValueLayout layout) {\n+            Set<AccessModeKind> supportedModes = EnumSet.noneOf(AccessModeKind.class);\n+            supportedModes.add(PLAIN);\n+            if (layout.byteAlignment() >= layout.byteSize()) {\n+                supportedModes.add(READ_WRITE);\n+                if (layout instanceof ValueLayout.OfInt || layout instanceof ValueLayout.OfLong ||\n+                        layout instanceof ValueLayout.OfFloat || layout instanceof ValueLayout.OfDouble ||\n+                        layout instanceof AddressLayout) {\n+                    supportedModes.add(ATOMIC_UPDATE);\n+                }\n+                if (layout instanceof ValueLayout.OfInt || layout instanceof ValueLayout.OfLong ||\n+                        layout instanceof AddressLayout) {\n+                    supportedModes.add(ATOMIC_NUMERIC_UPDATE);\n+                    supportedModes.add(ATOMIC_BITWISE_UPDATE);\n+                }\n+            }\n+            return supportedModes;\n+        }\n+    }\n+\n+    static MemoryLayout[] layouts() {\n+        MemoryLayout[] valueLayouts = {\n+                ValueLayout.JAVA_BOOLEAN,\n+                ValueLayout.JAVA_CHAR,\n+                ValueLayout.JAVA_BYTE,\n+                ValueLayout.JAVA_SHORT,\n+                ValueLayout.JAVA_INT,\n+                ValueLayout.JAVA_FLOAT,\n+                ValueLayout.JAVA_LONG,\n+                ValueLayout.JAVA_DOUBLE,\n+                ValueLayout.ADDRESS\n+        };\n+        List<MemoryLayout> layouts = new ArrayList<>();\n+        for (MemoryLayout layout : valueLayouts) {\n+            for (int align : new int[] { 1, 2, 4, 8 }) {\n+                layouts.add(layout.withByteAlignment(align));\n+            }\n+        }\n+        return layouts.toArray(new MemoryLayout[0]);\n+    }\n+\n+    static MemorySegment[] segments() {\n+        return new MemorySegment[]{\n+                Arena.ofAuto().allocate(8),\n+                MemorySegment.ofArray(new byte[8]),\n+                MemorySegment.ofArray(new char[4]),\n+                MemorySegment.ofArray(new short[4]),\n+                MemorySegment.ofArray(new int[2]),\n+                MemorySegment.ofArray(new float[2]),\n+                MemorySegment.ofArray(new long[1]),\n+                MemorySegment.ofArray(new double[1])\n+        };\n+    }\n+\n+    @DataProvider(name = \"segmentsAndLayoutsAndModes\")\n+    static Object[][] segmentsAndLayoutsAndModes() {\n+        List<Object[]> segmentsAndLayouts = new ArrayList<>();\n+        for (MemorySegment segment : segments()) {\n+            for (MemoryLayout layout : layouts()) {\n+                for (AccessMode mode : AccessMode.values()) {\n+                    segmentsAndLayouts.add(new Object[]{segment, layout, mode});\n+                }\n+            }\n+        }\n+        return segmentsAndLayouts.toArray(new Object[0][]);\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/foreign\/TestAccessModes.java","additions":179,"deletions":0,"binary":false,"changes":179,"status":"added"},{"patch":"@@ -27,1 +27,0 @@\n- * @enablePreview\n@@ -86,1 +85,2 @@\n-    static final VarHandle intHandleIndexed = ValueLayout.JAVA_INT.arrayElementVarHandle();\n+    static final VarHandle intHandleIndexed = MethodHandles.collectCoordinates(ValueLayout.JAVA_INT.varHandle(),\n+            1, MethodHandles.insertArguments(ValueLayout.JAVA_INT.scaleHandle(), 0, 0L));\n@@ -88,1 +88,1 @@\n-    static final VarHandle intHandle = ValueLayout.JAVA_INT.varHandle();\n+    static final VarHandle intHandle = MethodHandles.insertCoordinates(ValueLayout.JAVA_INT.varHandle(), 1, 0L);\n@@ -90,1 +90,1 @@\n-    static final VarHandle floatHandle = ValueLayout.JAVA_FLOAT.varHandle();\n+    static final VarHandle floatHandle = MethodHandles.insertCoordinates(ValueLayout.JAVA_FLOAT.varHandle(), 1, 0L);\n@@ -99,2 +99,2 @@\n-        i2SHandle.set(segment, \"1\");\n-        String oldValue = (String)i2SHandle.getAndAdd(segment, \"42\");\n+        i2SHandle.set(segment, 0L, \"1\");\n+        String oldValue = (String)i2SHandle.getAndAdd(segment, 0L, \"42\");\n@@ -102,1 +102,1 @@\n-        String value = (String)i2SHandle.get(segment);\n+        String value = (String)i2SHandle.get(segment, 0L);\n@@ -104,1 +104,1 @@\n-        boolean swapped = (boolean)i2SHandle.compareAndSet(segment, \"43\", \"12\");\n+        boolean swapped = (boolean)i2SHandle.compareAndSet(segment, 0L, \"43\", \"12\");\n@@ -106,1 +106,1 @@\n-        oldValue = (String)i2SHandle.compareAndExchange(segment, \"12\", \"42\");\n+        oldValue = (String)i2SHandle.compareAndExchange(segment, 0L, \"12\", \"42\");\n@@ -108,1 +108,1 @@\n-        value = (String)i2SHandle.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment);\n+        value = (String)i2SHandle.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment, 0L);\n@@ -120,3 +120,3 @@\n-        i2SHandle = MethodHandles.insertCoordinates(i2SHandle, 1, \"a\", \"b\");\n-        i2SHandle.set(segment, \"1\");\n-        String oldValue = (String)i2SHandle.getAndAdd(segment, \"42\");\n+        i2SHandle = MethodHandles.insertCoordinates(i2SHandle, 2, \"a\", \"b\");\n+        i2SHandle.set(segment, 0L, \"1\");\n+        String oldValue = (String)i2SHandle.getAndAdd(segment, 0L, \"42\");\n@@ -124,1 +124,1 @@\n-        String value = (String)i2SHandle.get(segment);\n+        String value = (String)i2SHandle.get(segment, 0L);\n@@ -126,1 +126,1 @@\n-        boolean swapped = (boolean)i2SHandle.compareAndSet(segment, \"43\", \"12\");\n+        boolean swapped = (boolean)i2SHandle.compareAndSet(segment, 0L, \"43\", \"12\");\n@@ -128,1 +128,1 @@\n-        oldValue = (String)i2SHandle.compareAndExchange(segment, \"12\", \"42\");\n+        oldValue = (String)i2SHandle.compareAndExchange(segment, 0L, \"12\", \"42\");\n@@ -130,1 +130,1 @@\n-        value = (String)i2SHandle.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment);\n+        value = (String)i2SHandle.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment, 0L);\n@@ -141,2 +141,2 @@\n-        i2SHandle.set(segment, \"1\");\n-        String oldValue = (String)i2SHandle.getAndAdd(segment, \"42\");\n+        i2SHandle.set(segment, 0L, \"1\");\n+        String oldValue = (String)i2SHandle.getAndAdd(segment, 0L, \"42\");\n@@ -144,1 +144,1 @@\n-        String value = (String)i2SHandle.get(segment);\n+        String value = (String)i2SHandle.get(segment, 0L);\n@@ -146,1 +146,1 @@\n-        boolean swapped = (boolean)i2SHandle.compareAndSet(segment, \"43\", \"12\");\n+        boolean swapped = (boolean)i2SHandle.compareAndSet(segment, 0L, \"43\", \"12\");\n@@ -148,1 +148,1 @@\n-        oldValue = (String)i2SHandle.compareAndExchange(segment, \"12\", \"42\");\n+        oldValue = (String)i2SHandle.compareAndExchange(segment, 0L, \"12\", \"42\");\n@@ -150,1 +150,1 @@\n-        value = (String)(Object)i2SHandle.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment);\n+        value = (String)(Object)i2SHandle.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment, 0L);\n@@ -197,2 +197,2 @@\n-            vh.set(seg, \"42\");\n-            String x = (String) vh.get(seg); \/\/ should throw\n+            vh.set(seg, 0L, \"42\");\n+            String x = (String) vh.get(seg, 0L); \/\/ should throw\n@@ -208,1 +208,1 @@\n-            vh.set(seg, \"42\"); \/\/ should throw\n+            vh.set(seg, 0L, \"42\"); \/\/ should throw\n","filename":"test\/jdk\/java\/foreign\/TestAdaptVarHandles.java","additions":26,"deletions":26,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n@@ -28,1 +27,0 @@\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -43,0 +41,2 @@\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n@@ -187,0 +187,2 @@\n+        private static final Pattern LAYOUT_PATTERN = Pattern.compile(\"^(?<align>\\\\d+%)?(?<char>[azcsifjdAZCSIFJD])\\\\d+$\");\n+\n@@ -188,11 +190,14 @@\n-            return switch (layoutString.charAt(0)) {\n-                case 'A','a' -> ADDRESS;\n-                case 'z','Z' -> BOOL;\n-                case 'c','C' -> CHAR;\n-                case 's','S' -> SHORT;\n-                case 'i','I' -> INT;\n-                case 'f','F' -> FLOAT;\n-                case 'j','J' -> LONG;\n-                case 'd','D' -> DOUBLE;\n-                default -> throw new AssertionError(\"Invalid layout string: \" + layoutString);\n-            };\n+            Matcher matcher = LAYOUT_PATTERN.matcher(layoutString);\n+            if (matcher.matches()) {\n+                switch (matcher.group(\"char\")) {\n+                    case \"A\",\"a\": return ADDRESS;\n+                    case \"z\",\"Z\": return BOOL;\n+                    case \"c\",\"C\": return CHAR;\n+                    case \"s\",\"S\": return SHORT;\n+                    case \"i\",\"I\": return INT;\n+                    case \"f\",\"F\": return FLOAT;\n+                    case \"j\",\"J\": return LONG;\n+                    case \"d\",\"D\": return DOUBLE;\n+                };\n+            }\n+            throw new AssertionError(\"Invalid layout string: \" + layoutString);\n","filename":"test\/jdk\/java\/foreign\/TestAddressDereference.java","additions":18,"deletions":13,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @enablePreview\n@@ -30,0 +29,1 @@\n+import java.lang.foreign.MemoryLayout;\n@@ -32,0 +32,3 @@\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n@@ -291,0 +294,5 @@\n+    private static VarHandle arrayVarHandle(ValueLayout layout) {\n+        return MethodHandles.collectCoordinates(layout.varHandle(),\n+                1, MethodHandles.insertArguments(layout.scaleHandle(), 0, 0L));\n+    }\n+\n@@ -292,2 +300,2 @@\n-        VarHandle indexedHandleNO = helper.elementLayout.withOrder(NATIVE_ORDER).arrayElementVarHandle();\n-        VarHandle indexedHandleNNO = helper.elementLayout.withOrder(NON_NATIVE_ORDER).arrayElementVarHandle();\n+        VarHandle indexedHandleNO = arrayVarHandle(helper.elementLayout.withOrder(NATIVE_ORDER));\n+        VarHandle indexedHandleNNO = arrayVarHandle(helper.elementLayout.withOrder(NON_NATIVE_ORDER));\n","filename":"test\/jdk\/java\/foreign\/TestArrayCopy.java","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @enablePreview\n@@ -34,0 +33,3 @@\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n@@ -147,1 +149,1 @@\n-                (base) -> initBytes(base, bytes, (addr, pos) -> byteHandle.set(addr, pos, (byte)(long)pos));\n+                (base) -> initBytes(base, bytes, (addr, pos) -> byteHandle.set(addr, 0L, pos, (byte)(long)pos));\n@@ -149,1 +151,1 @@\n-                (base) -> initBytes(base, chars, (addr, pos) -> charHandle.set(addr, pos, (char)(long)pos));\n+                (base) -> initBytes(base, chars, (addr, pos) -> charHandle.set(addr, 0L, pos, (char)(long)pos));\n@@ -151,1 +153,1 @@\n-                (base) -> initBytes(base, shorts, (addr, pos) -> shortHandle.set(addr, pos, (short)(long)pos));\n+                (base) -> initBytes(base, shorts, (addr, pos) -> shortHandle.set(addr, 0L, pos, (short)(long)pos));\n@@ -153,1 +155,1 @@\n-                (base) -> initBytes(base, ints, (addr, pos) -> intHandle.set(addr, pos, (int)(long)pos));\n+                (base) -> initBytes(base, ints, (addr, pos) -> intHandle.set(addr, 0L, pos, (int)(long)pos));\n@@ -155,1 +157,1 @@\n-                (base) -> initBytes(base, floats, (addr, pos) -> floatHandle.set(addr, pos, (float)(long)pos));\n+                (base) -> initBytes(base, floats, (addr, pos) -> floatHandle.set(addr, 0L, pos, (float)(long)pos));\n@@ -157,1 +159,1 @@\n-                (base) -> initBytes(base, longs, (addr, pos) -> longHandle.set(addr, pos, (long)pos));\n+                (base) -> initBytes(base, longs, (addr, pos) -> longHandle.set(addr, 0L, pos, (long)pos));\n@@ -159,1 +161,1 @@\n-                (base) -> initBytes(base, doubles, (addr, pos) -> doubleHandle.set(addr, pos, (double)(long)pos));\n+                (base) -> initBytes(base, doubles, (addr, pos) -> doubleHandle.set(addr, 0L, pos, (double)(long)pos));\n@@ -162,1 +164,1 @@\n-                (base) -> checkBytes(base, bytes, s -> s.toArray(JAVA_BYTE), (addr, pos) -> (byte)byteHandle.get(addr, pos));\n+                (base) -> checkBytes(base, bytes, s -> s.toArray(JAVA_BYTE), (addr, pos) -> (byte)byteHandle.get(addr, 0L, pos));\n@@ -164,1 +166,1 @@\n-                (base) -> checkBytes(base, shorts, s -> s.toArray(JAVA_SHORT), (addr, pos) -> (short)shortHandle.get(addr, pos));\n+                (base) -> checkBytes(base, shorts, s -> s.toArray(JAVA_SHORT), (addr, pos) -> (short)shortHandle.get(addr, 0L, pos));\n@@ -166,1 +168,1 @@\n-                (base) -> checkBytes(base, chars, s -> s.toArray(JAVA_CHAR), (addr, pos) -> (char)charHandle.get(addr, pos));\n+                (base) -> checkBytes(base, chars, s -> s.toArray(JAVA_CHAR), (addr, pos) -> (char)charHandle.get(addr, 0L, pos));\n@@ -168,1 +170,1 @@\n-                (base) -> checkBytes(base, ints, s -> s.toArray(JAVA_INT), (addr, pos) -> (int)intHandle.get(addr, pos));\n+                (base) -> checkBytes(base, ints, s -> s.toArray(JAVA_INT), (addr, pos) -> (int)intHandle.get(addr, 0L, pos));\n@@ -170,1 +172,1 @@\n-                (base) -> checkBytes(base, floats, s -> s.toArray(JAVA_FLOAT), (addr, pos) -> (float)floatHandle.get(addr, pos));\n+                (base) -> checkBytes(base, floats, s -> s.toArray(JAVA_FLOAT), (addr, pos) -> (float)floatHandle.get(addr, 0L, pos));\n@@ -172,1 +174,1 @@\n-                (base) -> checkBytes(base, longs, s -> s.toArray(JAVA_LONG), (addr, pos) -> (long)longHandle.get(addr, pos));\n+                (base) -> checkBytes(base, longs, s -> s.toArray(JAVA_LONG), (addr, pos) -> (long)longHandle.get(addr, 0L, pos));\n@@ -174,1 +176,1 @@\n-                (base) -> checkBytes(base, doubles, s -> s.toArray(JAVA_DOUBLE), (addr, pos) -> (double)doubleHandle.get(addr, pos));\n+                (base) -> checkBytes(base, doubles, s -> s.toArray(JAVA_DOUBLE), (addr, pos) -> (double)doubleHandle.get(addr, 0L, pos));\n","filename":"test\/jdk\/java\/foreign\/TestArrays.java","additions":17,"deletions":15,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n@@ -73,3 +72,0 @@\n-import jdk.internal.foreign.HeapMemorySegmentImpl;\n-import jdk.internal.foreign.MappedMemorySegmentImpl;\n-import jdk.internal.foreign.NativeMemorySegmentImpl;\n@@ -125,2 +121,2 @@\n-            indexHandle.set(base, i, (int)i);\n-            valueHandle.set(base, i, (float)(i \/ 500f));\n+            indexHandle.set(base, 0L, i, (int)i);\n+            valueHandle.set(base, 0L, i, (float)(i \/ 500f));\n@@ -134,2 +130,2 @@\n-            assertEquals(index = bb.getInt(), (int)indexHandle.get(base, i));\n-            assertEquals(value = bb.getFloat(), (float)valueHandle.get(base, i));\n+            assertEquals(index = bb.getInt(), (int)indexHandle.get(base, 0L, i));\n+            assertEquals(value = bb.getFloat(), (float)valueHandle.get(base, 0L, i));\n@@ -991,3 +987,3 @@\n-        Predicate<MemorySegment> heapTest = segment -> segment instanceof HeapMemorySegmentImpl;\n-        Predicate<MemorySegment> nativeTest = segment -> segment instanceof NativeMemorySegmentImpl;\n-        Predicate<MemorySegment> mappedTest = segment -> segment instanceof MappedMemorySegmentImpl;\n+        Predicate<MemorySegment> heapTest = segment -> !segment.isNative() && !segment.isMapped();\n+        Predicate<MemorySegment> nativeTest = segment -> segment.isNative() && !segment.isMapped();\n+        Predicate<MemorySegment> mappedTest = segment -> segment.isNative() && segment.isMapped();\n@@ -1005,1 +1001,1 @@\n-                            nativeTest \/* this seems to be an existing bug in the BB implementation *\/ }\n+                            mappedTest }\n","filename":"test\/jdk\/java\/foreign\/TestByteBuffer.java","additions":8,"deletions":12,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/TestClassLoaderFindNative.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,101 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=Arena_allocateFrom\n+ * @run main\/othervm\/timeout=5 --enable-native-access=ALL-UNNAMED -Xlog:class+init TestDeadlock Arena\n+ *\/\n+\n+\/*\n+ * @test id=FileChannel_map\n+ * @run main\/othervm\/timeout=5 --enable-native-access=ALL-UNNAMED -Xlog:class+init TestDeadlock FileChannel\n+ *\/\n+\n+import java.lang.foreign.*;\n+import java.io.IOException;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.concurrent.CountDownLatch;\n+\n+public class TestDeadlock {\n+    public static void main(String[] args) throws Throwable {\n+        CountDownLatch latch = new CountDownLatch(2);\n+\n+        Runnable tester = switch (args[0]) {\n+            case \"Arena\" -> () -> {\n+                Arena arena = Arena.global();\n+                arena.scope(); \/\/ init ArenaImpl\n+                ValueLayout.JAVA_INT.byteSize(); \/\/ init ValueLayout (and impls)\n+                latch.countDown();\n+                try {\n+                    latch.await();\n+                } catch(InterruptedException e) {\n+                    throw new RuntimeException(e);\n+                }\n+\n+                \/\/ Access ArenaImpl -> NativeMemorySegmentImpl -> MemorySegment\n+                arena.allocateFrom(ValueLayout.JAVA_INT, 42);\n+            };\n+            case \"FileChannel\" -> () -> {\n+                try {\n+                    Arena arena = Arena.global();\n+                    Path p = Files.createFile(Path.of(\"test.out\"));\n+\n+                    try (FileChannel channel = FileChannel.open(p, StandardOpenOption.READ, StandardOpenOption.WRITE)) {\n+                        channel.map(FileChannel.MapMode.READ_WRITE, 0, 4); \/\/ create MappedByteBuffer to initialize other things\n+                        latch.countDown();\n+                        latch.await();\n+\n+                        \/\/ Access MappedMemorySegmentImpl -> MemorySegment\n+                        channel.map(FileChannel.MapMode.READ_WRITE, 0, 4, arena);\n+                    }\n+                } catch(InterruptedException | IOException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            };\n+            default -> throw new IllegalArgumentException(\"Unknown test selection: \" + args[0]);\n+        };\n+\n+        Thread t1 = Thread.ofPlatform().start(tester);\n+        Thread t2 = Thread.ofPlatform().start(() -> {\n+            latch.countDown();\n+            try {\n+                latch.await();\n+            } catch(InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+\n+            \/\/ Access MemorySegment -> NativeMemorySegmentImpl\n+            MemorySegment.ofAddress(42);\n+        });\n+\n+        \/\/ wait for potential deadlock\n+\n+        t1.join();\n+        t2.join();\n+\n+        \/\/ all good\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/TestDeadlock.java","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"},{"patch":"@@ -27,1 +27,0 @@\n- * @enablePreview\n@@ -76,1 +75,1 @@\n-            int val = (int) abcx.get(a);\n+            int val = (int) abcx.get(a, 0L);\n@@ -101,2 +100,2 @@\n-            MemorySegment b = arena.allocateArray(B, 2);\n-            MemorySegment c = arena.allocateArray(C, 4);\n+            MemorySegment b = arena.allocate(B, 2);\n+            MemorySegment c = arena.allocate(C, 4);\n@@ -112,1 +111,1 @@\n-            int val00 = (int) abcx_multi.get(a, 0, 0); \/\/ a->b[0]->c[0] = 1\n+            int val00 = (int) abcx_multi.get(a, 0L, 0, 0); \/\/ a->b[0]->c[0] = 1\n@@ -114,1 +113,1 @@\n-            int val10 = (int) abcx_multi.get(a, 1, 0); \/\/ a->b[1]->c[0] = 3\n+            int val10 = (int) abcx_multi.get(a, 0L, 1, 0); \/\/ a->b[1]->c[0] = 3\n@@ -116,1 +115,1 @@\n-            int val01 = (int) abcx_multi.get(a, 0, 1); \/\/ a->b[0]->c[1] = 2\n+            int val01 = (int) abcx_multi.get(a, 0L, 0, 1); \/\/ a->b[0]->c[1] = 2\n@@ -118,1 +117,1 @@\n-            int val11 = (int) abcx_multi.get(a, 1, 1); \/\/ a->b[1]->c[1] = 4\n+            int val11 = (int) abcx_multi.get(a, 0L, 1, 1); \/\/ a->b[1]->c[1] = 4\n@@ -155,1 +154,1 @@\n-            vhX.set(segment, 42); \/\/ should throw\n+            vhX.set(segment, 0L, 42); \/\/ should throw\n","filename":"test\/jdk\/java\/foreign\/TestDereferencePath.java","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/TestDowncallScope.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/TestDowncallStack.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/TestFallbackLookup.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @enablePreview\n@@ -42,1 +41,1 @@\n-        assertEquals(str, addr.getUtf8String(0));\n+        assertEquals(str, addr.getString(0));\n","filename":"test\/jdk\/java\/foreign\/TestFree.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/TestFunctionDescriptor.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/TestHFA.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/TestHandshake.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -48,2 +46,2 @@\n-        assertAligned(align, layout, () -> layout.varHandle().get(segment));\n-        assertAligned(align, layout, () -> layout.varHandle().set(segment, val));\n+        assertAligned(align, layout, () -> layout.varHandle().get(segment, 0L));\n+        assertAligned(align, layout, () -> layout.varHandle().set(segment, 0L, val));\n@@ -51,2 +49,2 @@\n-        assertAligned(align, layout, () -> seq.varHandle(MemoryLayout.PathElement.sequenceElement()).get(segment, 0L));\n-        assertAligned(align, layout, () -> seq.varHandle(MemoryLayout.PathElement.sequenceElement()).set(segment, 0L, val));\n+        assertAligned(align, layout, () -> seq.varHandle(MemoryLayout.PathElement.sequenceElement()).get(segment, 0L, 0L));\n+        assertAligned(align, layout, () -> seq.varHandle(MemoryLayout.PathElement.sequenceElement()).set(segment, 0L, 0L, val));\n","filename":"test\/jdk\/java\/foreign\/TestHeapAlignment.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -50,0 +48,2 @@\n+import static java.lang.foreign.ValueLayout.*;\n+\n@@ -105,1 +105,1 @@\n-            { Linker.Option.isTrivial() },\n+            { Linker.Option.critical() },\n@@ -131,1 +131,1 @@\n-                    IS_LE ? \"Unsupported layout: 2%a8\" : \"Unsupported layout: 2%A8\"\n+                    (IS_LE ? \"Unsupported layout: 2%a\" : \"Unsupported layout: 2%A\")  + ADDRESS.byteSize()\n@@ -159,1 +159,1 @@\n-                            MemoryLayout.sequenceLayout(\n+                            MemoryLayout.sequenceLayout(1,\n@@ -184,1 +184,1 @@\n-                    FunctionDescriptor.of(MemoryLayout.structLayout(MemoryLayout.sequenceLayout(C_INT.withOrder(nonNativeOrder())))),\n+                    FunctionDescriptor.of(MemoryLayout.structLayout(MemoryLayout.sequenceLayout(1, C_INT.withOrder(nonNativeOrder())))),\n@@ -188,7 +188,0 @@\n-            {\n-                    FunctionDescriptor.ofVoid(MemoryLayout.structLayout(\n-                            ValueLayout.JAVA_LONG,\n-                            ValueLayout.JAVA_INT)), \/\/ missing trailing padding\n-                    NO_OPTIONS,\n-                    \"has unexpected size\"\n-            },\n@@ -202,0 +195,5 @@\n+            {\n+                    FunctionDescriptor.ofVoid(),\n+                    new Linker.Option[]{Linker.Option.critical(), Linker.Option.captureCallState(\"errno\")},\n+                    \"Incompatible linker options: captureCallState, critical\"\n+            },\n@@ -215,1 +213,1 @@\n-                            MemoryLayout.sequenceLayout(\n+                            MemoryLayout.sequenceLayout(Long.MAX_VALUE \/ C_INT.byteSize(),\n@@ -222,0 +220,9 @@\n+        if (ValueLayout.JAVA_LONG.byteAlignment() == 8) {\n+            cases.add(new Object[]{\n+                    FunctionDescriptor.ofVoid(MemoryLayout.structLayout(\n+                            ValueLayout.JAVA_LONG,\n+                            ValueLayout.JAVA_INT)), \/\/ missing trailing padding\n+                    NO_OPTIONS,\n+                    \"has unexpected size\"\n+            });\n+        }\n","filename":"test\/jdk\/java\/foreign\/TestIllegalLink.java","additions":21,"deletions":14,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/TestIntrinsics.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/TestLargeSegmentCopy.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @enablePreview\n@@ -38,0 +37,1 @@\n+import java.nio.ByteOrder;\n@@ -45,0 +45,1 @@\n+import static java.lang.foreign.ValueLayout.JAVA_LONG;\n@@ -139,1 +140,1 @@\n-    public void testBadAlignmentOfRoot() throws Throwable {\n+    public void testBadAlignmentOfRoot() {\n@@ -150,1 +151,1 @@\n-            String expectedMessage = \"Target offset incompatible with alignment constraints: \" + struct.byteAlignment();\n+            String expectedMessage = \"Target offset 0 is incompatible with alignment constraint \" + struct.byteAlignment() + \" (of [i4s2(x)]) for segment MemorySegment\";\n@@ -154,1 +155,1 @@\n-                vhX.set(seg, (short) 42);\n+                vhX.set(seg, 0L, (short) 42);\n@@ -156,1 +157,1 @@\n-            assertEquals(iae.getMessage(), expectedMessage);\n+            assertTrue(iae.getMessage().startsWith(expectedMessage));\n@@ -160,1 +161,1 @@\n-                MemorySegment slice = (MemorySegment) sliceX.invokeExact(seg);\n+                MemorySegment slice = (MemorySegment) sliceX.invokeExact(seg, 0L);\n@@ -162,1 +163,1 @@\n-            assertEquals(iae.getMessage(), expectedMessage);\n+            assertTrue(iae.getMessage().startsWith(expectedMessage));\n@@ -166,0 +167,36 @@\n+    @Test\n+    public void testWrongTypeRoot() {\n+        MemoryLayout struct = MemoryLayout.structLayout(\n+                JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN),\n+                JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN)\n+        );\n+\n+        var expectedMessage = \"Bad layout path: attempting to select a sequence element from a non-sequence layout: [i4i4]\";\n+\n+        IllegalArgumentException iae = expectThrows(IllegalArgumentException.class, () ->\n+                struct.select(PathElement.sequenceElement()));\n+        assertEquals(iae.getMessage(), expectedMessage);\n+    }\n+\n+    @Test\n+    public void testWrongTypeEnclosing() {\n+        MemoryLayout struct = MemoryLayout.structLayout(\n+                MemoryLayout.sequenceLayout(2, MemoryLayout.structLayout(\n+                                JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN).withName(\"3a\"),\n+                                JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN).withName(\"3b\")\n+                        ).withName(\"2\")\n+                ).withName(\"1\")\n+        ).withName(\"0\");\n+\n+        var expectedMessage = \"Bad layout path: attempting to select a sequence element from a non-sequence layout: \" +\n+                \"[i4(3a)i4(3b)](2), selected from: \" +\n+                \"[2:[i4(3a)i4(3b)](2)](1), selected from: \" +\n+                \"[[2:[i4(3a)i4(3b)](2)](1)](0)\";\n+\n+        IllegalArgumentException iae = expectThrows(IllegalArgumentException.class, () ->\n+                struct.select(PathElement.groupElement(\"1\"),\n+                        PathElement.sequenceElement(),\n+                        PathElement.sequenceElement()));\n+        assertEquals(iae.getMessage(), expectedMessage);\n+    }\n+\n@@ -274,1 +311,1 @@\n-        long actualByteOffset = (long) byteOffsetHandle.invokeExact(indexes);\n+        long actualByteOffset = (long) byteOffsetHandle.invokeExact(0L, indexes);\n@@ -363,1 +400,1 @@\n-            MemorySegment slice = (MemorySegment) sliceHandle.invokeExact(segment, indexes);\n+            MemorySegment slice = (MemorySegment) sliceHandle.invokeExact(segment, 0L, indexes);\n","filename":"test\/jdk\/java\/foreign\/TestLayoutPaths.java","additions":46,"deletions":9,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n@@ -101,1 +100,1 @@\n-                indexHandle.set(segment, (long)i, i);\n+                indexHandle.set(segment, 0L, (long)i, i);\n@@ -106,2 +105,2 @@\n-                int expected = (int)indexHandle.get(segment, (long)i);\n-                int found = (int)preindexHandle.get(segment);\n+                int expected = (int)indexHandle.get(segment, 0L, (long)i);\n+                int found = (int)preindexHandle.get(segment, 0L);\n@@ -204,6 +203,1 @@\n-    @Test(dataProvider = \"basicLayouts\")\n-    public void testSequenceInferredCount(MemoryLayout layout) {\n-        assertEquals(MemoryLayout.sequenceLayout(layout),\n-                     MemoryLayout.sequenceLayout(Long.MAX_VALUE \/ layout.byteSize(), layout));\n-    }\n-\n+    @Test\n@@ -303,1 +297,1 @@\n-        MemoryLayout.sequenceLayout(layout);\n+        MemoryLayout.sequenceLayout(1, layout);\n@@ -310,1 +304,1 @@\n-            MemoryLayout.sequenceLayout(layout);\n+            MemoryLayout.sequenceLayout(1, layout);\n@@ -341,8 +335,0 @@\n-    @Test(dataProvider=\"layoutsAndAlignments\")\n-    public void testArrayElementVarHandleBadAlignment(MemoryLayout layout, long byteAlign) {\n-        if (layout instanceof ValueLayout) {\n-            assertThrows(UnsupportedOperationException.class, () ->\n-                    ((ValueLayout) layout).withByteAlignment(byteAlign * 2).arrayElementVarHandle());\n-        }\n-    }\n-\n@@ -362,0 +348,31 @@\n+    @Test\n+    public void testVarHandleCaching() {\n+        assertSame(JAVA_INT.varHandle(), JAVA_INT.varHandle());\n+        assertSame(JAVA_INT.withName(\"foo\").varHandle(), JAVA_INT.varHandle());\n+\n+        assertNotSame(JAVA_INT_UNALIGNED.varHandle(), JAVA_INT.varHandle());\n+        assertNotSame(ADDRESS.withTargetLayout(JAVA_INT).varHandle(), ADDRESS.varHandle());\n+    }\n+\n+    @Test(expectedExceptions=IllegalArgumentException.class,\n+        expectedExceptionsMessageRegExp=\".*Negative offset.*\")\n+    public void testScaleNegativeOffset() {\n+        JAVA_INT.scale(-1, 0);\n+    }\n+\n+    @Test(expectedExceptions=IllegalArgumentException.class,\n+        expectedExceptionsMessageRegExp=\".*Negative index.*\")\n+    public void testScaleNegativeIndex() {\n+        JAVA_INT.scale(0, -1);\n+    }\n+\n+    @Test(expectedExceptions=ArithmeticException.class)\n+    public void testScaleAddOverflow() {\n+        JAVA_INT.scale(Long.MAX_VALUE, 1);\n+    }\n+\n+    @Test(expectedExceptions=ArithmeticException.class)\n+    public void testScaleMultiplyOverflow() {\n+        JAVA_INT.scale(0, Long.MAX_VALUE);\n+    }\n+\n@@ -499,1 +516,0 @@\n-                MemoryLayout.sequenceLayout(JAVA_INT),\n","filename":"test\/jdk\/java\/foreign\/TestLayouts.java","additions":37,"deletions":21,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -40,0 +38,2 @@\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.ValueLayout;\n@@ -48,0 +48,1 @@\n+import static org.testng.Assert.assertNotNull;\n@@ -50,0 +51,1 @@\n+import static org.testng.Assert.assertTrue;\n@@ -94,4 +96,0 @@\n-            { FunctionDescriptor.ofVoid(structLayout(C_INT, paddingLayout(4), C_LONG_LONG)),\n-                    FunctionDescriptor.ofVoid(structLayout(C_INT, paddingLayout(4), C_LONG_LONG.withName(\"x\"))) },\n-            { FunctionDescriptor.ofVoid(structLayout(C_INT, paddingLayout(4), C_LONG_LONG)),\n-                    FunctionDescriptor.ofVoid(structLayout(C_INT, paddingLayout(4).withName(\"x\"), C_LONG_LONG)) },\n@@ -116,0 +114,6 @@\n+        if (C_LONG_LONG.byteAlignment() == 8) {\n+            cases.add(new Object[]{ FunctionDescriptor.ofVoid(structLayout(C_INT, paddingLayout(4), C_LONG_LONG)),\n+                    FunctionDescriptor.ofVoid(structLayout(C_INT, paddingLayout(4), C_LONG_LONG.withName(\"x\"))) });\n+            cases.add(new Object[]{ FunctionDescriptor.ofVoid(structLayout(C_INT, paddingLayout(4), C_LONG_LONG)),\n+                    FunctionDescriptor.ofVoid(structLayout(C_INT, paddingLayout(4).withName(\"x\"), C_LONG_LONG)) });\n+        }\n@@ -143,0 +147,28 @@\n+    @Test(dataProvider = \"canonicalTypeNames\")\n+    public void testCanonicalLayouts(String typeName) {\n+        MemoryLayout layout = LINKER.canonicalLayouts().get(typeName);\n+        assertNotNull(layout);\n+        assertTrue(layout instanceof ValueLayout);\n+    }\n+\n+    @DataProvider\n+    public static Object[][] canonicalTypeNames() {\n+        return new Object[][]{\n+                { \"bool\" },\n+                { \"char\" },\n+                { \"short\" },\n+                { \"int\" },\n+                { \"long\" },\n+                { \"long long\" },\n+                { \"float\" },\n+                { \"double\" },\n+                { \"void*\" },\n+                { \"size_t\" },\n+                { \"wchar_t\" },\n+        };\n+    }\n+\n+    @Test(expectedExceptions=UnsupportedOperationException.class)\n+    public void testCanonicalLayoutsUnmodifiable() {\n+        LINKER.canonicalLayouts().put(\"asdf\", C_INT);\n+    }\n","filename":"test\/jdk\/java\/foreign\/TestLinker.java","additions":39,"deletions":7,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,2 +35,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -48,2 +46,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -61,2 +57,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -74,2 +68,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -87,2 +79,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -99,2 +89,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -111,2 +99,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -123,2 +109,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -135,2 +119,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -148,2 +130,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -161,2 +141,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -174,2 +152,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -187,2 +163,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -200,2 +174,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -213,2 +185,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -226,2 +196,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -239,2 +207,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -252,2 +218,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -265,2 +229,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -278,2 +240,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -292,2 +252,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/TestMatrix.java","additions":1,"deletions":43,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n@@ -69,6 +68,0 @@\n-    @Test(dataProvider = \"arrayElements\")\n-    public void testArrayAccessAlt(Function<MemorySegment, MemorySegment> viewFactory, ValueLayout elemLayout, ArrayChecker checker) {\n-        SequenceLayout seq = MemoryLayout.sequenceLayout(10, elemLayout.withName(\"elem\"));\n-        testArrayAccessInternal(viewFactory, seq, elemLayout.arrayElementVarHandle(), checker);\n-    }\n-\n@@ -161,7 +154,0 @@\n-    @Test(dataProvider = \"matrixElements\")\n-    public void testMatrixAccessAlt(Function<MemorySegment, MemorySegment> viewFactory, ValueLayout elemLayout, MatrixChecker checker) {\n-        SequenceLayout seq = MemoryLayout.sequenceLayout(20,\n-                MemoryLayout.sequenceLayout(10, elemLayout.withName(\"elem\")));\n-        testMatrixAccessInternal(viewFactory, seq, elemLayout.arrayElementVarHandle(10), checker);\n-    }\n-\n@@ -270,2 +256,2 @@\n-            handle.set(segment, (byte)42);\n-            assertEquals(42, (byte)handle.get(segment));\n+            handle.set(segment, 0L, (byte)42);\n+            assertEquals(42, (byte)handle.get(segment, 0L));\n@@ -275,2 +261,2 @@\n-            handle.set(segment, (short)42);\n-            assertEquals(42, (short)handle.get(segment));\n+            handle.set(segment, 0L, (short)42);\n+            assertEquals(42, (short)handle.get(segment, 0L));\n@@ -280,2 +266,2 @@\n-            handle.set(segment, (char)42);\n-            assertEquals(42, (char)handle.get(segment));\n+            handle.set(segment, 0L, (char)42);\n+            assertEquals(42, (char)handle.get(segment, 0L));\n@@ -285,2 +271,2 @@\n-            handle.set(segment, 42);\n-            assertEquals(42, (int)handle.get(segment));\n+            handle.set(segment, 0L, 42);\n+            assertEquals(42, (int)handle.get(segment, 0L));\n@@ -290,2 +276,2 @@\n-            handle.set(segment, (long)42);\n-            assertEquals(42, (long)handle.get(segment));\n+            handle.set(segment, 0L, (long)42);\n+            assertEquals(42, (long)handle.get(segment, 0L));\n@@ -295,2 +281,2 @@\n-            handle.set(segment, (float)42);\n-            assertEquals((float)42, (float)handle.get(segment));\n+            handle.set(segment, 0L, (float)42);\n+            assertEquals((float)42, (float)handle.get(segment, 0L));\n@@ -300,2 +286,2 @@\n-            handle.set(segment, (double)42);\n-            assertEquals((double)42, (double)handle.get(segment));\n+            handle.set(segment, 0L, (double)42);\n+            assertEquals((double)42, (double)handle.get(segment, 0L));\n@@ -347,2 +333,2 @@\n-            handle.set(segment, i, (byte)i);\n-            assertEquals(i, (byte)handle.get(segment, i));\n+            handle.set(segment, 0L, i, (byte)i);\n+            assertEquals(i, (byte)handle.get(segment, 0L, i));\n@@ -352,2 +338,2 @@\n-            handle.set(segment, i, (short)i);\n-            assertEquals(i, (short)handle.get(segment, i));\n+            handle.set(segment, 0L, i, (short)i);\n+            assertEquals(i, (short)handle.get(segment, 0L, i));\n@@ -357,2 +343,2 @@\n-            handle.set(segment, i, (char)i);\n-            assertEquals(i, (char)handle.get(segment, i));\n+            handle.set(segment, 0L, i, (char)i);\n+            assertEquals(i, (char)handle.get(segment, 0L, i));\n@@ -362,2 +348,2 @@\n-            handle.set(segment, i, (int)i);\n-            assertEquals(i, (int)handle.get(segment, i));\n+            handle.set(segment, 0L, i, (int)i);\n+            assertEquals(i, (int)handle.get(segment, 0L, i));\n@@ -367,2 +353,2 @@\n-            handle.set(segment, i, (long)i);\n-            assertEquals(i, (long)handle.get(segment, i));\n+            handle.set(segment, 0L, i, (long)i);\n+            assertEquals(i, (long)handle.get(segment, 0L, i));\n@@ -372,2 +358,2 @@\n-            handle.set(segment, i, (float)i);\n-            assertEquals((float)i, (float)handle.get(segment, i));\n+            handle.set(segment, 0L, i, (float)i);\n+            assertEquals((float)i, (float)handle.get(segment, 0L, i));\n@@ -377,2 +363,2 @@\n-            handle.set(segment, i, (double)i);\n-            assertEquals((double)i, (double)handle.get(segment, i));\n+            handle.set(segment, 0L, i, (double)i);\n+            assertEquals((double)i, (double)handle.get(segment, 0L, i));\n@@ -432,2 +418,2 @@\n-            handle.set(segment, r, c, (byte)(r + c));\n-            assertEquals(r + c, (byte)handle.get(segment, r, c));\n+            handle.set(segment, 0L, r, c, (byte)(r + c));\n+            assertEquals(r + c, (byte)handle.get(segment, 0L, r, c));\n@@ -437,2 +423,2 @@\n-            handle.set(segment, r, c, (r + c) != 0);\n-            assertEquals((r + c) != 0, (boolean)handle.get(segment, r, c));\n+            handle.set(segment, 0L, r, c, (r + c) != 0);\n+            assertEquals((r + c) != 0, (boolean)handle.get(segment, 0L, r, c));\n@@ -442,2 +428,2 @@\n-            handle.set(segment, r, c, (short)(r + c));\n-            assertEquals(r + c, (short)handle.get(segment, r, c));\n+            handle.set(segment, 0L, r, c, (short)(r + c));\n+            assertEquals(r + c, (short)handle.get(segment, 0L, r, c));\n@@ -447,2 +433,2 @@\n-            handle.set(segment, r, c, (char)(r + c));\n-            assertEquals(r + c, (char)handle.get(segment, r, c));\n+            handle.set(segment, 0L, r, c, (char)(r + c));\n+            assertEquals(r + c, (char)handle.get(segment, 0L, r, c));\n@@ -452,2 +438,2 @@\n-            handle.set(segment, r, c, (int)(r + c));\n-            assertEquals(r + c, (int)handle.get(segment, r, c));\n+            handle.set(segment, 0L, r, c, (int)(r + c));\n+            assertEquals(r + c, (int)handle.get(segment, 0L, r, c));\n@@ -457,2 +443,2 @@\n-            handle.set(segment, r, c, r + c);\n-            assertEquals(r + c, (long)handle.get(segment, r, c));\n+            handle.set(segment, 0L, r, c, r + c);\n+            assertEquals(r + c, (long)handle.get(segment, 0L, r, c));\n@@ -462,2 +448,2 @@\n-            handle.set(segment, r, c, MemorySegment.ofAddress(r + c));\n-            assertEquals(MemorySegment.ofAddress(r + c), (MemorySegment) handle.get(segment, r, c));\n+            handle.set(segment, 0L, r, c, MemorySegment.ofAddress(r + c));\n+            assertEquals(MemorySegment.ofAddress(r + c), (MemorySegment) handle.get(segment, 0L, r, c));\n@@ -467,2 +453,2 @@\n-            handle.set(segment, r, c, (float)(r + c));\n-            assertEquals((float)(r + c), (float)handle.get(segment, r, c));\n+            handle.set(segment, 0L, r, c, (float)(r + c));\n+            assertEquals((float)(r + c), (float)handle.get(segment, 0L, r, c));\n@@ -472,2 +458,2 @@\n-            handle.set(segment, r, c, (double)(r + c));\n-            assertEquals((double)(r + c), (double)handle.get(segment, r, c));\n+            handle.set(segment, 0L, r, c, (double)(r + c));\n+            assertEquals((double)(r + c), (double)handle.get(segment, 0L, r, c));\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAccess.java","additions":46,"deletions":60,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAccessInstance.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n@@ -51,2 +50,2 @@\n-            vh.set(segment, -42);\n-            int val = (int)vh.get(segment);\n+            vh.set(segment, 0L, -42);\n+            int val = (int)vh.get(segment, 0L);\n@@ -68,1 +67,1 @@\n-            vh.set(segment.asSlice(1L), -42);\n+            vh.set(segment.asSlice(1L), 0L, -42);\n@@ -96,1 +95,1 @@\n-                    vh.set(segment, i, -42);\n+                    vh.set(segment, 0L, i, -42);\n@@ -119,6 +118,6 @@\n-            vh_c.set(segment, Byte.MIN_VALUE);\n-            assertEquals(vh_c.get(segment), Byte.MIN_VALUE);\n-            vh_s.set(segment, Short.MIN_VALUE);\n-            assertEquals(vh_s.get(segment), Short.MIN_VALUE);\n-            vh_i.set(segment, Integer.MIN_VALUE);\n-            assertEquals(vh_i.get(segment), Integer.MIN_VALUE);\n+            vh_c.set(segment, 0L, Byte.MIN_VALUE);\n+            assertEquals(vh_c.get(segment, 0L), Byte.MIN_VALUE);\n+            vh_s.set(segment, 0L, Short.MIN_VALUE);\n+            assertEquals(vh_s.get(segment, 0L), Short.MIN_VALUE);\n+            vh_i.set(segment, 0L, Integer.MIN_VALUE);\n+            assertEquals(vh_i.get(segment, 0L), Integer.MIN_VALUE);\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAlignment.java","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/TestMemoryDereference.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/TestMemorySession.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/TestMismatch.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/TestNULLAddress.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -211,1 +209,1 @@\n-                (base) -> initBytes(base, bytes, (addr, pos) -> byteHandle.set(addr, pos, (byte)(long)pos));\n+                (base) -> initBytes(base, bytes, (addr, pos) -> byteHandle.set(addr, 0L, pos, (byte)(long)pos));\n@@ -213,1 +211,1 @@\n-                (base) -> initBytes(base, chars, (addr, pos) -> charHandle.set(addr, pos, (char)(long)pos));\n+                (base) -> initBytes(base, chars, (addr, pos) -> charHandle.set(addr, 0L, pos, (char)(long)pos));\n@@ -215,1 +213,1 @@\n-                (base) -> initBytes(base, shorts, (addr, pos) -> shortHandle.set(addr, pos, (short)(long)pos));\n+                (base) -> initBytes(base, shorts, (addr, pos) -> shortHandle.set(addr, 0L, pos, (short)(long)pos));\n@@ -217,1 +215,1 @@\n-                (base) -> initBytes(base, ints, (addr, pos) -> intHandle.set(addr, pos, (int)(long)pos));\n+                (base) -> initBytes(base, ints, (addr, pos) -> intHandle.set(addr, 0L, pos, (int)(long)pos));\n@@ -219,1 +217,1 @@\n-                (base) -> initBytes(base, floats, (addr, pos) -> floatHandle.set(addr, pos, (float)(long)pos));\n+                (base) -> initBytes(base, floats, (addr, pos) -> floatHandle.set(addr, 0L, pos, (float)(long)pos));\n@@ -221,1 +219,1 @@\n-                (base) -> initBytes(base, longs, (addr, pos) -> longHandle.set(addr, pos, (long)pos));\n+                (base) -> initBytes(base, longs, (addr, pos) -> longHandle.set(addr, 0L, pos, (long)pos));\n@@ -223,1 +221,1 @@\n-                (base) -> initBytes(base, doubles, (addr, pos) -> doubleHandle.set(addr, pos, (double)(long)pos));\n+                (base) -> initBytes(base, doubles, (addr, pos) -> doubleHandle.set(addr, 0L, pos, (double)(long)pos));\n@@ -226,1 +224,1 @@\n-                (base) -> checkBytes(base, bytes, byteHandle::get, bb -> bb, TestNative::getByteBuffer, TestNative::getByteRaw);\n+                (base) -> checkBytes(base, bytes, (addr, pos) -> byteHandle.get(addr, 0L, pos), bb -> bb, TestNative::getByteBuffer, TestNative::getByteRaw);\n@@ -228,1 +226,1 @@\n-                (base) -> checkBytes(base, chars, charHandle::get, ByteBuffer::asCharBuffer, TestNative::getCharBuffer, TestNative::getCharRaw);\n+                (base) -> checkBytes(base, chars, (addr, pos) -> charHandle.get(addr, 0L, pos), ByteBuffer::asCharBuffer, TestNative::getCharBuffer, TestNative::getCharRaw);\n@@ -230,1 +228,1 @@\n-                (base) -> checkBytes(base, shorts, shortHandle::get, ByteBuffer::asShortBuffer, TestNative::getShortBuffer, TestNative::getShortRaw);\n+                (base) -> checkBytes(base, shorts, (addr, pos) -> shortHandle.get(addr, 0L, pos), ByteBuffer::asShortBuffer, TestNative::getShortBuffer, TestNative::getShortRaw);\n@@ -232,1 +230,1 @@\n-                (base) -> checkBytes(base, ints, intHandle::get, ByteBuffer::asIntBuffer, TestNative::getIntBuffer, TestNative::getIntRaw);\n+                (base) -> checkBytes(base, ints, (addr, pos) -> intHandle.get(addr, 0L, pos), ByteBuffer::asIntBuffer, TestNative::getIntBuffer, TestNative::getIntRaw);\n@@ -234,1 +232,1 @@\n-                (base) -> checkBytes(base, floats, floatHandle::get, ByteBuffer::asFloatBuffer, TestNative::getFloatBuffer, TestNative::getFloatRaw);\n+                (base) -> checkBytes(base, floats, (addr, pos) -> floatHandle.get(addr, 0L, pos), ByteBuffer::asFloatBuffer, TestNative::getFloatBuffer, TestNative::getFloatRaw);\n@@ -236,1 +234,1 @@\n-                (base) -> checkBytes(base, longs, longHandle::get, ByteBuffer::asLongBuffer, TestNative::getLongBuffer, TestNative::getLongRaw);\n+                (base) -> checkBytes(base, longs, (addr, pos) -> longHandle.get(addr, 0L, pos), ByteBuffer::asLongBuffer, TestNative::getLongBuffer, TestNative::getLongRaw);\n@@ -238,1 +236,1 @@\n-                (base) -> checkBytes(base, doubles, doubleHandle::get, ByteBuffer::asDoubleBuffer, TestNative::getDoubleBuffer, TestNative::getDoubleRaw);\n+                (base) -> checkBytes(base, doubles, (addr, pos) -> doubleHandle.get(addr, 0L, pos), ByteBuffer::asDoubleBuffer, TestNative::getDoubleBuffer, TestNative::getDoubleRaw);\n","filename":"test\/jdk\/java\/foreign\/TestNative.java","additions":14,"deletions":16,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -147,1 +145,1 @@\n-        addDefaultMapping(VarHandle.class, MethodHandles.memorySegmentViewVarHandle(JAVA_INT));\n+        addDefaultMapping(VarHandle.class, JAVA_INT.varHandle());\n","filename":"test\/jdk\/java\/foreign\/TestNulls.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/TestOfBufferIssue.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/TestReshape.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/TestRestricted.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -125,15 +123,15 @@\n-        ScopedOperation.ofScope(a -> a.allocate(JAVA_BYTE, (byte) 0), \"Arena::allocate\/byte\");\n-        ScopedOperation.ofScope(a -> a.allocate(ValueLayout.JAVA_CHAR, (char) 0), \"Arena::allocate\/char\");\n-        ScopedOperation.ofScope(a -> a.allocate(ValueLayout.JAVA_SHORT, (short) 0), \"Arena::allocate\/short\");\n-        ScopedOperation.ofScope(a -> a.allocate(ValueLayout.JAVA_INT, 0), \"Arena::allocate\/int\");\n-        ScopedOperation.ofScope(a -> a.allocate(ValueLayout.JAVA_FLOAT, 0f), \"Arena::allocate\/float\");\n-        ScopedOperation.ofScope(a -> a.allocate(ValueLayout.JAVA_LONG, 0L), \"Arena::allocate\/long\");\n-        ScopedOperation.ofScope(a -> a.allocate(ValueLayout.JAVA_DOUBLE, 0d), \"Arena::allocate\/double\");\n-        ScopedOperation.ofScope(a -> a.allocateArray(JAVA_BYTE, 1L), \"Arena::allocateArray\/size\");\n-        ScopedOperation.ofScope(a -> a.allocateArray(JAVA_BYTE, new byte[]{0}), \"Arena::allocateArray\/byte\");\n-        ScopedOperation.ofScope(a -> a.allocateArray(ValueLayout.JAVA_CHAR, new char[]{0}), \"Arena::allocateArray\/char\");\n-        ScopedOperation.ofScope(a -> a.allocateArray(ValueLayout.JAVA_SHORT, new short[]{0}), \"Arena::allocateArray\/short\");\n-        ScopedOperation.ofScope(a -> a.allocateArray(ValueLayout.JAVA_INT, new int[]{0}), \"Arena::allocateArray\/int\");\n-        ScopedOperation.ofScope(a -> a.allocateArray(ValueLayout.JAVA_FLOAT, new float[]{0}), \"Arena::allocateArray\/float\");\n-        ScopedOperation.ofScope(a -> a.allocateArray(ValueLayout.JAVA_LONG, new long[]{0}), \"Arena::allocateArray\/long\");\n-        ScopedOperation.ofScope(a -> a.allocateArray(ValueLayout.JAVA_DOUBLE, new double[]{0}), \"Arena::allocateArray\/double\");\n+        ScopedOperation.ofScope(a -> a.allocateFrom(JAVA_BYTE, (byte) 0), \"Arena::allocate\/byte\");\n+        ScopedOperation.ofScope(a -> a.allocateFrom(ValueLayout.JAVA_CHAR, (char) 0), \"Arena::allocate\/char\");\n+        ScopedOperation.ofScope(a -> a.allocateFrom(ValueLayout.JAVA_SHORT, (short) 0), \"Arena::allocate\/short\");\n+        ScopedOperation.ofScope(a -> a.allocateFrom(ValueLayout.JAVA_INT, 0), \"Arena::allocate\/int\");\n+        ScopedOperation.ofScope(a -> a.allocateFrom(ValueLayout.JAVA_FLOAT, 0f), \"Arena::allocate\/float\");\n+        ScopedOperation.ofScope(a -> a.allocateFrom(ValueLayout.JAVA_LONG, 0L), \"Arena::allocate\/long\");\n+        ScopedOperation.ofScope(a -> a.allocateFrom(ValueLayout.JAVA_DOUBLE, 0d), \"Arena::allocate\/double\");\n+        ScopedOperation.ofScope(a -> a.allocate(JAVA_BYTE, 1L), \"Arena::allocate\/size\");\n+        ScopedOperation.ofScope(a -> a.allocateFrom(JAVA_BYTE, new byte[]{0}), \"Arena::allocateFrom\/byte\");\n+        ScopedOperation.ofScope(a -> a.allocateFrom(ValueLayout.JAVA_CHAR, new char[]{0}), \"Arena::allocateFrom\/char\");\n+        ScopedOperation.ofScope(a -> a.allocateFrom(ValueLayout.JAVA_SHORT, new short[]{0}), \"Arena::allocateFrom\/short\");\n+        ScopedOperation.ofScope(a -> a.allocateFrom(ValueLayout.JAVA_INT, new int[]{0}), \"Arena::allocateFrom\/int\");\n+        ScopedOperation.ofScope(a -> a.allocateFrom(ValueLayout.JAVA_FLOAT, new float[]{0}), \"Arena::allocateFrom\/float\");\n+        ScopedOperation.ofScope(a -> a.allocateFrom(ValueLayout.JAVA_LONG, new long[]{0}), \"Arena::allocateFrom\/long\");\n+        ScopedOperation.ofScope(a -> a.allocateFrom(ValueLayout.JAVA_DOUBLE, new double[]{0}), \"Arena::allocateFrom\/double\");\n","filename":"test\/jdk\/java\/foreign\/TestScopedOperations.java","additions":15,"deletions":17,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @enablePreview\n@@ -34,2 +33,0 @@\n-import jdk.internal.foreign.MappedMemorySegmentImpl;\n-import jdk.internal.foreign.NativeMemorySegmentImpl;\n@@ -85,1 +82,1 @@\n-                        assertEquals(value, handle.get(address));\n+                        assertEquals(value, handle.get(address, 0L));\n@@ -151,1 +148,1 @@\n-        allocator.allocateArray(ValueLayout.JAVA_BYTE, -1);\n+        allocator.allocate(ValueLayout.JAVA_BYTE, -1);\n@@ -156,1 +153,1 @@\n-        allocator.allocateArray(ValueLayout.JAVA_LONG,  Long.MAX_VALUE);\n+        allocator.allocate(ValueLayout.JAVA_LONG,  Long.MAX_VALUE);\n@@ -172,1 +169,1 @@\n-                return null;\n+                return MemorySegment.NULL;\n@@ -176,1 +173,1 @@\n-            public MemorySegment allocateArray(MemoryLayout elementLayout, long count) {\n+            public MemorySegment allocateFrom(ValueLayout elementLayout, MemorySegment source, ValueLayout sourceElementLayout, long sourceOffset, long elementCount) {\n@@ -178,2 +175,2 @@\n-                return null;\n-            };\n+                return MemorySegment.NULL;\n+            }\n@@ -181,7 +178,7 @@\n-        allocator.allocateArray(ValueLayout.JAVA_BYTE);\n-        allocator.allocateArray(ValueLayout.JAVA_SHORT);\n-        allocator.allocateArray(ValueLayout.JAVA_CHAR);\n-        allocator.allocateArray(ValueLayout.JAVA_INT);\n-        allocator.allocateArray(ValueLayout.JAVA_FLOAT);\n-        allocator.allocateArray(ValueLayout.JAVA_LONG);\n-        allocator.allocateArray(ValueLayout.JAVA_DOUBLE);\n+        allocator.allocateFrom(ValueLayout.JAVA_BYTE);\n+        allocator.allocateFrom(ValueLayout.JAVA_SHORT);\n+        allocator.allocateFrom(ValueLayout.JAVA_CHAR);\n+        allocator.allocateFrom(ValueLayout.JAVA_INT);\n+        allocator.allocateFrom(ValueLayout.JAVA_FLOAT);\n+        allocator.allocateFrom(ValueLayout.JAVA_LONG);\n+        allocator.allocateFrom(ValueLayout.JAVA_DOUBLE);\n@@ -196,1 +193,0 @@\n-\n@@ -207,1 +203,1 @@\n-        allocator.allocateUtf8String(\"Hello\");\n+        allocator.allocateFrom(\"Hello\");\n@@ -245,1 +241,1 @@\n-                assertEquals(segment.isNative(), segment instanceof NativeMemorySegmentImpl);\n+                assertTrue(segment.isNative());\n@@ -255,1 +251,1 @@\n-                    (AllocationFunction.OfByte) SegmentAllocator::allocate,\n+                    (AllocationFunction.OfByte) SegmentAllocator::allocateFrom,\n@@ -258,1 +254,1 @@\n-                    (AllocationFunction.OfShort) SegmentAllocator::allocate,\n+                    (AllocationFunction.OfShort) SegmentAllocator::allocateFrom,\n@@ -261,1 +257,1 @@\n-                    (AllocationFunction.OfChar) SegmentAllocator::allocate,\n+                    (AllocationFunction.OfChar) SegmentAllocator::allocateFrom,\n@@ -265,1 +261,1 @@\n-                    (AllocationFunction.OfInt) SegmentAllocator::allocate,\n+                    (AllocationFunction.OfInt) SegmentAllocator::allocateFrom,\n@@ -268,1 +264,1 @@\n-                    (AllocationFunction.OfFloat) SegmentAllocator::allocate,\n+                    (AllocationFunction.OfFloat) SegmentAllocator::allocateFrom,\n@@ -271,1 +267,1 @@\n-                    (AllocationFunction.OfLong) SegmentAllocator::allocate,\n+                    (AllocationFunction.OfLong) SegmentAllocator::allocateFrom,\n@@ -274,1 +270,1 @@\n-                    (AllocationFunction.OfDouble) SegmentAllocator::allocate,\n+                    (AllocationFunction.OfDouble) SegmentAllocator::allocateFrom,\n@@ -277,1 +273,1 @@\n-                    (AllocationFunction.OfAddress) SegmentAllocator::allocate,\n+                    (AllocationFunction.OfAddress) SegmentAllocator::allocateFrom,\n@@ -281,1 +277,1 @@\n-                    (AllocationFunction.OfShort) SegmentAllocator::allocate,\n+                    (AllocationFunction.OfShort) SegmentAllocator::allocateFrom,\n@@ -284,1 +280,1 @@\n-                    (AllocationFunction.OfChar) SegmentAllocator::allocate,\n+                    (AllocationFunction.OfChar) SegmentAllocator::allocateFrom,\n@@ -288,1 +284,1 @@\n-                    (AllocationFunction.OfInt) SegmentAllocator::allocate,\n+                    (AllocationFunction.OfInt) SegmentAllocator::allocateFrom,\n@@ -291,1 +287,1 @@\n-                    (AllocationFunction.OfFloat) SegmentAllocator::allocate,\n+                    (AllocationFunction.OfFloat) SegmentAllocator::allocateFrom,\n@@ -294,1 +290,1 @@\n-                    (AllocationFunction.OfLong) SegmentAllocator::allocate,\n+                    (AllocationFunction.OfLong) SegmentAllocator::allocateFrom,\n@@ -297,1 +293,1 @@\n-                    (AllocationFunction.OfDouble) SegmentAllocator::allocate,\n+                    (AllocationFunction.OfDouble) SegmentAllocator::allocateFrom,\n@@ -300,1 +296,1 @@\n-                    (AllocationFunction.OfAddress) SegmentAllocator::allocate,\n+                    (AllocationFunction.OfAddress) SegmentAllocator::allocateFrom,\n@@ -311,1 +307,1 @@\n-                    (AllocationFunction.OfByteArray) SegmentAllocator::allocateArray,\n+                    (AllocationFunction.OfByteArray) SegmentAllocator::allocateFrom,\n@@ -314,1 +310,1 @@\n-                    (AllocationFunction.OfCharArray) SegmentAllocator::allocateArray,\n+                    (AllocationFunction.OfCharArray) SegmentAllocator::allocateFrom,\n@@ -317,1 +313,1 @@\n-                    (AllocationFunction.OfShortArray) SegmentAllocator::allocateArray,\n+                    (AllocationFunction.OfShortArray) SegmentAllocator::allocateFrom,\n@@ -321,1 +317,1 @@\n-                    (AllocationFunction.OfIntArray) SegmentAllocator::allocateArray,\n+                    (AllocationFunction.OfIntArray) SegmentAllocator::allocateFrom,\n@@ -324,1 +320,1 @@\n-                    (AllocationFunction.OfFloatArray) SegmentAllocator::allocateArray,\n+                    (AllocationFunction.OfFloatArray) SegmentAllocator::allocateFrom,\n@@ -327,1 +323,1 @@\n-                    (AllocationFunction.OfLongArray) SegmentAllocator::allocateArray,\n+                    (AllocationFunction.OfLongArray) SegmentAllocator::allocateFrom,\n@@ -330,1 +326,1 @@\n-                    (AllocationFunction.OfDoubleArray) SegmentAllocator::allocateArray,\n+                    (AllocationFunction.OfDoubleArray) SegmentAllocator::allocateFrom,\n@@ -334,1 +330,1 @@\n-                    (AllocationFunction.OfCharArray) SegmentAllocator::allocateArray,\n+                    (AllocationFunction.OfCharArray) SegmentAllocator::allocateFrom,\n@@ -337,1 +333,1 @@\n-                    (AllocationFunction.OfShortArray) SegmentAllocator::allocateArray,\n+                    (AllocationFunction.OfShortArray) SegmentAllocator::allocateFrom,\n@@ -341,1 +337,1 @@\n-                    (AllocationFunction.OfIntArray) SegmentAllocator::allocateArray,\n+                    (AllocationFunction.OfIntArray) SegmentAllocator::allocateFrom,\n@@ -344,1 +340,1 @@\n-                    (AllocationFunction.OfFloatArray) SegmentAllocator::allocateArray,\n+                    (AllocationFunction.OfFloatArray) SegmentAllocator::allocateFrom,\n@@ -347,1 +343,1 @@\n-                    (AllocationFunction.OfLongArray) SegmentAllocator::allocateArray,\n+                    (AllocationFunction.OfLongArray) SegmentAllocator::allocateFrom,\n@@ -350,1 +346,1 @@\n-                    (AllocationFunction.OfDoubleArray) SegmentAllocator::allocateArray,\n+                    (AllocationFunction.OfDoubleArray) SegmentAllocator::allocateFrom,\n","filename":"test\/jdk\/java\/foreign\/TestSegmentAllocators.java","additions":44,"deletions":48,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @enablePreview\n@@ -174,1 +173,1 @@\n-            return MethodHandles.memorySegmentViewVarHandle(layout);\n+            return layout.varHandle();\n","filename":"test\/jdk\/java\/foreign\/TestSegmentCopy.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n@@ -33,0 +32,1 @@\n+import org.testng.SkipException;\n@@ -47,0 +47,3 @@\n+        if (s1.kind != s2.kind) {\n+            throw new SkipException(\"Slices of different segment kinds\");\n+        }\n@@ -49,1 +52,1 @@\n-            long offset = s1.segment.segmentOffset(s2.segment);\n+            long offset = s1.offset(s2);\n@@ -56,9 +59,0 @@\n-        } else if (s1.kind != s2.kind) {\n-            \/\/ check that offset from s1 to s2 fails\n-            try {\n-                long offset = s1.segment.segmentOffset(s2.segment);\n-                out.format(\"testOffset s1:%s, s2:%s, offset:%d\\n\", s1, s2, offset);\n-                fail(\"offset unexpectedly passed!\");\n-            } catch (UnsupportedOperationException ex) {\n-                assertTrue(ex.getMessage().contains(\"Cannot compute offset from native to heap (or vice versa).\"));\n-            }\n@@ -67,1 +61,1 @@\n-            long offset = s1.segment.segmentOffset(s2.segment);\n+            long offset = s1.offset(s2);\n@@ -119,0 +113,4 @@\n+\n+        long offset(SegmentSlice that) {\n+            return that.segment.address() - segment.address();\n+        }\n","filename":"test\/jdk\/java\/foreign\/TestSegmentOffset.java","additions":10,"deletions":12,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/TestSegmentOverlap.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,2 +26,1 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n+ * @requires vm.bits == 64\n@@ -87,1 +86,1 @@\n-        VarHandle byteHandle = ValueLayout.JAVA_BYTE.arrayElementVarHandle();\n+        VarHandle byteHandle = ValueLayout.JAVA_BYTE.varHandle();\n@@ -98,1 +97,1 @@\n-        VarHandle byteHandle = ValueLayout.JAVA_BYTE.arrayElementVarHandle();\n+        VarHandle byteHandle = ValueLayout.JAVA_BYTE.varHandle();\n@@ -266,1 +265,1 @@\n-        VarHandle byteHandle = ValueLayout.JAVA_BYTE.arrayElementVarHandle();\n+        VarHandle byteHandle = ValueLayout.JAVA_BYTE.varHandle();\n","filename":"test\/jdk\/java\/foreign\/TestSegments.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @enablePreview\n@@ -154,1 +153,1 @@\n-        return (int)intHandle.getVolatile(base);\n+        return (int)intHandle.getVolatile(base, 0L);\n@@ -158,1 +157,1 @@\n-        intHandle.setVolatile(base, value);\n+        intHandle.setVolatile(base, 0L, value);\n","filename":"test\/jdk\/java\/foreign\/TestSharedAccess.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n- * @enablePreview\n@@ -56,1 +55,1 @@\n-                    VH_ALL.set(segment, i, j, (int)j + 1 + ((int)i * 5));\n+                    VH_ALL.set(segment, 0L, i, j, (int)j + 1 + ((int)i * 5));\n@@ -68,2 +67,2 @@\n-            assertThrows(() -> handle.get(segment, lo, 0));\n-            assertThrows(() -> handle.get(segment, 0, hi));\n+            assertThrows(() -> handle.get(segment, 0L, lo, 0));\n+            assertThrows(() -> handle.get(segment, 0L, 0, hi));\n@@ -77,1 +76,1 @@\n-                int x = (int) handle.get(segment, i, j);\n+                int x = (int) handle.get(segment, 0L, i, j);\n","filename":"test\/jdk\/java\/foreign\/TestSlices.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n@@ -47,2 +46,0 @@\n-    static final VarHandle INT_HANDLE = ValueLayout.JAVA_INT.arrayElementVarHandle();\n-\n@@ -59,1 +56,1 @@\n-                INT_HANDLE.set(segment, (long) i, i);\n+                segment.setAtIndex(ValueLayout.JAVA_INT, i, i);\n@@ -86,1 +83,1 @@\n-            INT_HANDLE.set(segment, (long) i, i);\n+            segment.setAtIndex(ValueLayout.JAVA_INT, i, i);\n@@ -163,1 +160,1 @@\n-        return acc + (int)INT_HANDLE.get(segment, 0L);\n+        return acc + segment.getAtIndex(ValueLayout.JAVA_INT, 0);\n@@ -170,1 +167,1 @@\n-            sum += (int)INT_HANDLE.get(segment, (long)i);\n+            sum += segment.getAtIndex(ValueLayout.JAVA_INT, i);\n","filename":"test\/jdk\/java\/foreign\/TestSpliterator.java","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -25,0 +25,2 @@\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n@@ -26,0 +28,3 @@\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemoryLayout;\n@@ -27,0 +32,15 @@\n+import java.lang.foreign.SegmentAllocator;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.reflect.Field;\n+import java.nio.channels.FileChannel;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.function.Consumer;\n+import java.util.function.UnaryOperator;\n@@ -28,0 +48,1 @@\n+import jdk.internal.foreign.StringSupport;\n@@ -29,0 +50,2 @@\n+\n+import static java.lang.foreign.ValueLayout.*;\n@@ -33,2 +56,1 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n+ * @modules java.base\/jdk.internal.foreign\n@@ -41,3 +63,196 @@\n-    public void testStrings(String testString, int expectedByteLength) {\n-        try (Arena arena = Arena.ofConfined()) {\n-            MemorySegment text = arena.allocateUtf8String(testString);\n+    public void testStrings(String testString) {\n+        for (Charset charset : Charset.availableCharsets().values()) {\n+            if (isStandard(charset)) {\n+                for (Arena arena : arenas()) {\n+                    try (arena) {\n+                        MemorySegment text = arena.allocateFrom(testString, charset);\n+\n+                        int terminatorSize = \"\\0\".getBytes(charset).length;\n+                        if (charset == StandardCharsets.UTF_16) {\n+                            terminatorSize -= 2; \/\/ drop BOM\n+                        }\n+                        \/\/ Note that the JDK's UTF_32 encoder doesn't add a BOM.\n+                        \/\/ This is legal under the Unicode standard, and means the byte order is BE.\n+                        \/\/ See: https:\/\/unicode.org\/faq\/utf_bom.html#gen7\n+\n+                        int expectedByteLength =\n+                                testString.getBytes(charset).length +\n+                                        terminatorSize;\n+\n+                        assertEquals(text.byteSize(), expectedByteLength);\n+\n+                        String roundTrip = text.getString(0, charset);\n+                        if (charset.newEncoder().canEncode(testString)) {\n+                            assertEquals(roundTrip, testString);\n+                        }\n+                    }\n+                }\n+            } else {\n+                assertThrows(IllegalArgumentException.class, () -> Arena.global().allocateFrom(testString, charset));\n+            }\n+        }\n+    }\n+\n+\n+    @Test(dataProvider = \"strings\")\n+    public void testStringsHeap(String testString) {\n+        for (Charset charset : singleByteCharsets()) {\n+            for (var arena : arenas()) {\n+                try (arena) {\n+                    MemorySegment text = arena.allocateFrom(testString, charset);\n+                    text = toHeapSegment(text);\n+\n+                    int expectedByteLength =\n+                            testString.getBytes(charset).length + 1;\n+\n+                    assertEquals(text.byteSize(), expectedByteLength);\n+\n+                    String roundTrip = text.getString(0, charset);\n+                    if (charset.newEncoder().canEncode(testString)) {\n+                        assertEquals(roundTrip, testString);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    MemorySegment toHeapSegment(MemorySegment segment) {\n+        var heapArray = segment.toArray(JAVA_BYTE);\n+        return MemorySegment.ofArray(heapArray);\n+    }\n+\n+    @Test(dataProvider = \"strings\")\n+    public void unboundedSegment(String testString) {\n+        testModifyingSegment(testString,\n+                standardCharsets(),\n+                s -> s.reinterpret(Long.MAX_VALUE),\n+                UnaryOperator.identity());\n+    }\n+\n+    @Test(dataProvider = \"strings\")\n+    public void unalignedSegmentSingleByte(String testString) {\n+        testModifyingSegment(testString,\n+                singleByteCharsets(),\n+                s -> s.byteSize() > 1 ? s.asSlice(1) : s,\n+                s -> s.length() > 0 ? s.substring(1) : s);\n+    }\n+\n+    @Test(dataProvider = \"strings\")\n+    public void expandedSegment(String testString) {\n+        try (var arena = Arena.ofConfined()) {\n+            for (int i = 0; i < Long.BYTES; i++) {\n+                int extra = i;\n+                testModifyingSegment(testString,\n+                        \/\/ Single byte charsets\n+                        standardCharsets(),\n+                        s -> {\n+                            var s2 = arena.allocate(s.byteSize() + extra);\n+                            MemorySegment.copy(s, 0, s2, 0, s.byteSize());\n+                            return s2;\n+                        },\n+                        UnaryOperator.identity());\n+            }\n+        }\n+    }\n+\n+    public void testModifyingSegment(String testString,\n+                                     List<Charset> charsets,\n+                                     UnaryOperator<MemorySegment> segmentMapper,\n+                                     UnaryOperator<String> stringMapper) {\n+        for (var charset : charsets) {\n+            try (Arena arena = Arena.ofConfined()) {\n+                MemorySegment text = arena.allocateFrom(testString, charset);\n+                text = segmentMapper.apply(text);\n+                String roundTrip = text.getString(0, charset);\n+                String expected = stringMapper.apply(testString);\n+                if (charset.newEncoder().canEncode(testString)) {\n+                    assertEquals(roundTrip, expected);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test()\n+    public void testPeculiarContentSingleByte() {\n+        Random random = new Random(42);\n+        for (int len = 7; len < 71; len++) {\n+            for (var arena : arenas()) {\n+                try (arena) {\n+                    var segment = arena.allocate(len, 1);\n+                    var arr = new byte[len];\n+                    random.nextBytes(arr);\n+                    segment.copyFrom(MemorySegment.ofArray(arr));\n+                    int terminatorIndex = random.nextInt(len);\n+                    segment.set(ValueLayout.JAVA_BYTE, terminatorIndex, (byte) 0);\n+                    for (Charset charset : singleByteCharsets()) {\n+                        var s = segment.getString(0, charset);\n+                        var ref = referenceImpl(segment, 0, charset);\n+                        assertEquals(s, ref);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"strings\")\n+    public void testOffset(String testString) {\n+        if (testString.length() < 3 || !containsOnlyRegularCharacters(testString)) {\n+            return;\n+        }\n+        for (var charset : singleByteCharsets()) {\n+            for (var arena: arenas()) {\n+                try (arena) {\n+                    MemorySegment inSegment = arena.allocateFrom(testString, charset);\n+                    for (int i = 0; i < 3; i++) {\n+                        String actual = inSegment.getString(i, charset);\n+                        assertEquals(actual, testString.substring(i));\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static final MemoryLayout CHAR_POINTER = ADDRESS\n+            .withTargetLayout(MemoryLayout.sequenceLayout(Long.MAX_VALUE, JAVA_BYTE));\n+    private static final Linker LINKER = Linker.nativeLinker();\n+    private static final MethodHandle STRCAT = LINKER.downcallHandle(\n+            LINKER.defaultLookup().find(\"strcat\").orElseThrow(),\n+            FunctionDescriptor.of(CHAR_POINTER, CHAR_POINTER, CHAR_POINTER));\n+\n+    @Test(dataProvider = \"strings\")\n+    public void nativeSegFromNativeCall(String testString) {\n+        String addition = \"123\";\n+        try (var arena = Arena.ofConfined()) {\n+            try {\n+                var testStringSegment = arena.allocateFrom(testString);\n+                var additionSegment = arena.allocateFrom(addition);\n+                var destination = arena.allocate(testStringSegment.byteSize() + additionSegment.byteSize() - 1);\n+                destination.copyFrom(testStringSegment);\n+\n+                MemorySegment concatenation = (MemorySegment) STRCAT.invokeExact(destination, arena.allocateFrom(addition));\n+                var actual = concatenation.getString(0);\n+                assertEquals(actual, testString + addition);\n+            } catch (Throwable t) {\n+                throw new AssertionError(t);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void segmentationFault() {\n+        for (int i = 1; i < 18; i++) {\n+            var size = 1 << i;\n+            try (var arena = Arena.ofConfined()) {\n+                var seg = arena.allocate(size, size);\n+                seg.fill((byte) 1);\n+                try {\n+                    var s = seg.getString(0);\n+                    System.out.println(\"s.length() = \" + s.length());\n+                } catch (IndexOutOfBoundsException e) {\n+                    \/\/ we will end up here if strlen finds a zero outside the MS\n+                }\n+            }\n+        }\n+    }\n+\n+    private static final int TEST_LENGTH_MAX = 277;\n@@ -45,1 +260,51 @@\n-            assertEquals(text.byteSize(), expectedByteLength);\n+    private Random deterministicRandom() {\n+        return new Random(42);\n+    }\n+\n+    @Test\n+    public void chunked_strlen_byte() {\n+        Random random = deterministicRandom();\n+        for (int skew = 0; skew < Long.BYTES; skew++) {\n+            for (int len = 0; len < TEST_LENGTH_MAX; len++) {\n+                try (var arena = Arena.ofConfined()) {\n+                    var segment = arena.allocate(len + 1 + skew)\n+                            .asSlice(skew);\n+                    for (int i = 0; i < len; i++) {\n+                        byte value;\n+                        while ((value = (byte) random.nextInt()) == 0) {\n+                        }\n+                        segment.setAtIndex(JAVA_BYTE, i, value);\n+                    }\n+                    segment.setAtIndex(JAVA_BYTE, len, (byte) 0);\n+                    for (int j = 0; j < len; j++) {\n+                        int actual = StringSupport.chunkedStrlenByte(segment, j);\n+                        assertEquals(actual, len - j);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void chunked_strlen_short() {\n+        Random random = deterministicRandom();\n+        for (int skew = 0; skew < Long.BYTES; skew += Short.BYTES) {\n+            for (int len = 0; len < TEST_LENGTH_MAX; len++) {\n+                try (var arena = Arena.ofConfined()) {\n+                    var segment = arena.allocate((len + 1) * Short.BYTES + skew, JAVA_SHORT.byteAlignment())\n+                            .asSlice(skew);\n+                    for (int i = 0; i < len; i++) {\n+                        short value;\n+                        while ((value = (short) random.nextInt()) == 0) {\n+                        }\n+                        segment.setAtIndex(JAVA_SHORT, i, value);\n+                    }\n+                    segment.setAtIndex(JAVA_SHORT, len, (short) 0);\n+                    for (int j = 0; j < len; j++) {\n+                        int actual = StringSupport.chunkedStrlenShort(segment, j * Short.BYTES);\n+                        assertEquals(actual, (len - j) * Short.BYTES);\n+                    }\n+                }\n+            }\n+        }\n+    }\n@@ -47,2 +312,21 @@\n-            String roundTrip = text.getUtf8String(0);\n-            assertEquals(roundTrip, testString);\n+    @Test\n+    public void strlen_int() {\n+        Random random = deterministicRandom();\n+        for (int skew = 0; skew < Long.BYTES; skew += Integer.BYTES) {\n+            for (int len = 0; len < TEST_LENGTH_MAX; len++) {\n+                try (var arena = Arena.ofConfined()) {\n+                    var segment = arena.allocate((len + 1) * Integer.BYTES + skew, JAVA_INT.byteAlignment())\n+                            .asSlice(skew);\n+                    for (int i = 0; i < len; i++) {\n+                        int value;\n+                        while ((value = random.nextInt()) == 0) {\n+                        }\n+                        segment.setAtIndex(JAVA_INT, i, value);\n+                    }\n+                    segment.setAtIndex(JAVA_INT, len, 0);\n+                    for (int j = 0; j < len; j++) {\n+                        int actual = StringSupport.strlenInt(segment, j * Integer.BYTES);\n+                        assertEquals(actual, (len - j) * Integer.BYTES);\n+                    }\n+                }\n+            }\n@@ -54,8 +338,18 @@\n-        return new Object[][] {\n-            { \"testing\",               8 },\n-            { \"\",                      1 },\n-            { \"X\",                     2 },\n-            { \"12345\",                 6 },\n-            { \"yen \\u00A5\",            7 }, \/\/ in UTF-8 2 bytes: 0xC2 0xA5\n-            { \"snowman \\u26C4\",       12 }, \/\/ in UTF-8 three bytes: 0xE2 0x9B 0x84\n-            { \"rainbow \\uD83C\\uDF08\", 13 }  \/\/ in UTF-8 four bytes: 0xF0 0x9F 0x8C 0x88\n+        return new Object[][]{\n+                {\"testing\"},\n+                {\"\"},\n+                {\"X\"},\n+                {\"12345\"},\n+                {\"yen \\u00A5\"},\n+                {\"snowman \\u26C4\"},\n+                {\"rainbow \\uD83C\\uDF08\"},\n+                {\"0\"},\n+                {\"01\"},\n+                {\"012\"},\n+                {\"0123\"},\n+                {\"01234\"},\n+                {\"012345\"},\n+                {\"0123456\"},\n+                {\"01234567\"},\n+                {\"012345678\"},\n+                {\"0123456789\"}\n@@ -64,0 +358,101 @@\n+\n+    public static boolean containsOnlyRegularCharacters(String s) {\n+        return s.chars()\n+                .allMatch(c -> Character.isLetterOrDigit((char) c));\n+    }\n+\n+    boolean isStandard(Charset charset) {\n+        for (Field standardCharset : StandardCharsets.class.getDeclaredFields()) {\n+            try {\n+                if (standardCharset.get(null) == charset) {\n+                    return true;\n+                }\n+            } catch (ReflectiveOperationException e) {\n+                throw new AssertionError(e);\n+            }\n+        }\n+        return false;\n+    }\n+\n+    List<Charset> standardCharsets() {\n+        return Charset.availableCharsets().values().stream()\n+                .filter(this::isStandard)\n+                .toList();\n+    }\n+\n+    List<Charset> singleByteCharsets() {\n+        return Arrays.asList(StandardCharsets.UTF_8, StandardCharsets.ISO_8859_1, StandardCharsets.US_ASCII);\n+    }\n+\n+    static String referenceImpl(MemorySegment segment, long offset, Charset charset) {\n+        long len = strlen_byte(segment, offset);\n+        byte[] bytes = new byte[(int) len];\n+        MemorySegment.copy(segment, JAVA_BYTE, offset, bytes, 0, (int) len);\n+        return new String(bytes, charset);\n+    }\n+\n+    \/\/ Reference implementation\n+    private static int strlen_byte(MemorySegment segment, long start) {\n+        \/\/ iterate until overflow (String can only hold a byte[], whose length can be expressed as an int)\n+        for (int offset = 0; offset >= 0; offset++) {\n+            byte curr = segment.get(JAVA_BYTE, start + offset);\n+            if (curr == 0) {\n+                return offset;\n+            }\n+        }\n+        throw new IllegalArgumentException(\"String too large\");\n+    }\n+\n+    private static List<Arena> arenas() {\n+        return Arrays.asList(\n+                Arena.ofConfined(),          \/\/ Native memory\n+                new HeapArena(byte.class),   \/\/ Heap memory backed by a byte array\n+                new HeapArena(short.class),  \/\/ Heap memory backed by a short array\n+                new HeapArena(int.class),    \/\/ Heap memory backed by an int array\n+                new HeapArena(long.class));  \/\/ Heap memory backed by a long array\n+    }\n+\n+    private static final class HeapArena implements Arena {\n+\n+        private static final int ELEMENT_SIZE = 1_000;\n+\n+        private final MemorySegment backingSegment;\n+        private final SegmentAllocator allocator;\n+\n+        public HeapArena(Class<?> type) {\n+            backingSegment = switch (type) {\n+                case Class<?> c when byte.class.equals(c) -> MemorySegment.ofArray(new byte[ELEMENT_SIZE]);\n+                case Class<?> c when short.class.equals(c) ->\n+                        MemorySegment.ofArray(new short[ELEMENT_SIZE]);\n+                case Class<?> c when int.class.equals(c) ->\n+                        MemorySegment.ofArray(new int[ELEMENT_SIZE]);\n+                case Class<?> c when long.class.equals(c) ->\n+                        MemorySegment.ofArray(new long[ELEMENT_SIZE]);\n+                default -> throw new IllegalArgumentException(type.toString());\n+            };\n+            allocator = SegmentAllocator.slicingAllocator(backingSegment);\n+        }\n+\n+        @Override\n+        public MemorySegment allocate(long byteSize, long byteAlignment) {\n+            return allocator.allocate(byteSize, byteAlignment);\n+        }\n+\n+        @Override\n+        public MemorySegment.Scope scope() {\n+            return backingSegment.scope();\n+        }\n+\n+        @Override\n+        public void close() {\n+            \/\/ Do nothing\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"HeapArena{\" +\n+                    \"type=\" + backingSegment.heapBase().orElseThrow().getClass().getName() +\n+                    '}';\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestStringEncoding.java","additions":411,"deletions":16,"binary":false,"changes":427,"status":"modified"},{"patch":"@@ -0,0 +1,102 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.*;\n+\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.function.Consumer;\n+\n+import static java.lang.foreign.ValueLayout.*;\n+import static org.testng.Assert.*;\n+\n+\/*\n+ * @test\n+ * @modules java.base\/jdk.internal.foreign\n+ * @requires sun.arch.data.model == \"64\"\n+ * @requires vm.flavor != \"zero\"\n+ *\n+ * @run testng\/othervm -Xmx6G TestStringEncodingJumbo\n+ *\/\n+\n+public class TestStringEncodingJumbo {\n+\n+    @Test()\n+    public void testJumboSegment() {\n+        testWithJumboSegment(\"testJumboSegment\", segment -> {\n+            segment.fill((byte) 1);\n+            segment.set(JAVA_BYTE, Integer.MAX_VALUE + 10L, (byte) 0);\n+            String big = segment.getString(100);\n+            assertEquals(big.length(), Integer.MAX_VALUE - (100 - 10));\n+        });\n+    }\n+\n+    @Test()\n+    public void testStringLargerThanMaxInt() {\n+        testWithJumboSegment(\"testStringLargerThanMaxInt\", segment -> {\n+            segment.fill((byte) 1);\n+            segment.set(JAVA_BYTE, Integer.MAX_VALUE + 10L, (byte) 0);\n+            assertThrows(IllegalArgumentException.class, () -> {\n+                segment.getString(0);\n+            });\n+        });\n+    }\n+\n+    private static void testWithJumboSegment(String testName, Consumer<MemorySegment> tester) {\n+        Path path = Paths.get(\"mapped_file\");\n+        try {\n+            \/\/ Relly try to make sure the file is deleted after use\n+            path.toFile().deleteOnExit();\n+            deleteIfExistsOrThrow(path);\n+            try (RandomAccessFile raf = new RandomAccessFile(path.toFile(), \"rw\")) {\n+                FileChannel fc = raf.getChannel();\n+                try (Arena arena = Arena.ofConfined()) {\n+                    var segment = fc.map(FileChannel.MapMode.READ_WRITE, 0L, (long) Integer.MAX_VALUE + 100, arena);\n+                    tester.accept(segment);\n+                }\n+            }\n+        } catch (Exception e) {\n+            throw new AssertionError(e);\n+        } catch (OutOfMemoryError oome) {\n+            \/\/ Unfortunately, we run out of memory and cannot run this test in this configuration\n+            System.out.println(\"Skipping test because of insufficient memory: \" + testName);\n+        } finally {\n+            deleteIfExistsOrThrow(path);\n+        }\n+    }\n+\n+    private static void deleteIfExistsOrThrow(Path file) {\n+        try {\n+            Files.deleteIfExists(file);\n+        } catch (IOException ioe) {\n+            throw new AssertionError(\"Unable to delete mapped file: \" + file);\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/foreign\/TestStringEncodingJumbo.java","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"},{"patch":"@@ -27,1 +27,0 @@\n- * @enablePreview\n@@ -46,1 +45,1 @@\n-        int v = (int)INT_HANDLE.get(\"string\");\n+        int v = (int)INT_HANDLE.get(\"string\", 0L);\n@@ -57,2 +56,2 @@\n-            MemorySegment s = arena.allocate(8, 8);;\n-            String address = (String)ADDR_HANDLE.get(s);\n+            MemorySegment s = arena.allocate(8, 8);\n+            String address = (String)ADDR_HANDLE.get(s, 0L);\n@@ -66,1 +65,1 @@\n-            ADDR_HANDLE.set(s, \"string\");\n+            ADDR_HANDLE.set(s, 0L, \"string\");\n@@ -73,2 +72,2 @@\n-            MemorySegment s = arena.allocate(8, 8);;\n-            int address = (int)ADDR_HANDLE.get(s);\n+            MemorySegment s = arena.allocate(8, 8);\n+            int address = (int)ADDR_HANDLE.get(s, 0L);\n","filename":"test\/jdk\/java\/foreign\/TestTypeAccess.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @enablePreview\n- *\n- * @run testng\/othervm -Djdk.internal.foreign.CABI=UNSUPPORTED --enable-native-access=ALL-UNNAMED TestUnsupportedLinker\n- *\/\n-\n-import java.lang.foreign.Linker;\n-\n-import org.testng.annotations.Test;\n-\n-public class TestUnsupportedLinker {\n-\n-    @Test(expectedExceptions = UnsupportedOperationException.class)\n-    public void testLinker() {\n-        Linker.nativeLinker();\n-    }\n-}\n","filename":"test\/jdk\/java\/foreign\/TestUnsupportedLinker.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/TestUpcallAsync.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/TestUpcallException.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -51,9 +49,0 @@\n-    static final Linker LINKER = Linker.nativeLinker();\n-\n-    \/\/ struct S_PDI { void* p0; double p1; int p2; };\n-    static final MemoryLayout S_PDI_LAYOUT = MemoryLayout.structLayout(\n-        C_POINTER.withName(\"p0\"),\n-        C_DOUBLE.withName(\"p1\"),\n-        C_INT.withName(\"p2\"),\n-        MemoryLayout.paddingLayout(4)\n-    );\n","filename":"test\/jdk\/java\/foreign\/TestUpcallHighArity.java","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/TestUpcallScope.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/TestUpcallStack.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -54,1 +52,0 @@\n-    static final Linker LINKER = Linker.nativeLinker();\n@@ -57,8 +54,0 @@\n-    \/\/ struct S_PDI { void* p0; double p1; int p2; };\n-    static final MemoryLayout S_PDI_LAYOUT = MemoryLayout.structLayout(\n-        C_POINTER.withName(\"p0\"),\n-        C_DOUBLE.withName(\"p1\"),\n-        C_INT.withName(\"p2\"),\n-        MemoryLayout.paddingLayout(4)\n-    );\n-\n","filename":"test\/jdk\/java\/foreign\/TestUpcallStructScope.java","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/TestValueLayouts.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -43,0 +41,1 @@\n+import java.lang.foreign.ValueLayout;\n@@ -54,1 +53,0 @@\n-    static final VarHandle VH_IntArray = C_INT.arrayElementVarHandle();\n@@ -85,1 +83,1 @@\n-                VH_IntArray.set(argIDs, (long) i, args.get(i).id.ordinal());\n+                argIDs.setAtIndex(ValueLayout.JAVA_INT, i, args.get(i).id.ordinal());\n@@ -200,1 +198,1 @@\n-            VH_writeback.set(seg, addr);\n+            VH_writeback.set(seg, 0L, addr);\n@@ -203,1 +201,1 @@\n-            VH_argIDs.set(seg, addr);\n+            VH_argIDs.set(seg, 0L, addr);\n@@ -222,1 +220,3 @@\n-            return new Arg(id, layout, value, layout.varHandle().toMethodHandle(VarHandle.AccessMode.GET));\n+            MethodHandle getterHandle = layout.varHandle().toMethodHandle(VarHandle.AccessMode.GET);\n+            getterHandle = MethodHandles.insertArguments(getterHandle, 1, 0L); \/\/ align signature with getter for structs\n+            return new Arg(id, layout, value, getterHandle);\n","filename":"test\/jdk\/java\/foreign\/TestVarArgs.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @enablePreview\n@@ -47,1 +46,1 @@\n-        VarHandle vh = MethodHandles.memorySegmentViewVarHandle(ValueLayout.JAVA_BYTE);\n+        VarHandle vh = ValueLayout.JAVA_BYTE.varHandle();\n@@ -56,1 +55,1 @@\n-        VarHandle vh = MethodHandles.memorySegmentViewVarHandle(ValueLayout.JAVA_BYTE.withByteAlignment(4));\n+        VarHandle vh = ValueLayout.JAVA_BYTE.withByteAlignment(4).varHandle();\n@@ -66,1 +65,1 @@\n-        VarHandle vh = MethodHandles.memorySegmentViewVarHandle(ValueLayout.JAVA_BYTE.withByteAlignment(2));\n+        VarHandle vh = ValueLayout.JAVA_BYTE.withByteAlignment(2).varHandle();\n@@ -76,2 +75,1 @@\n-        VarHandle vh = MethodHandles.memorySegmentViewVarHandle(ValueLayout.JAVA_SHORT_UNALIGNED\n-                .withOrder(ByteOrder.LITTLE_ENDIAN));\n+        VarHandle vh = ValueLayout.JAVA_SHORT_UNALIGNED.withOrder(ByteOrder.LITTLE_ENDIAN).varHandle();\n@@ -87,2 +85,1 @@\n-        VarHandle vh = MethodHandles.memorySegmentViewVarHandle(ValueLayout.JAVA_SHORT_UNALIGNED\n-                .withOrder(ByteOrder.BIG_ENDIAN));\n+        VarHandle vh = ValueLayout.JAVA_SHORT_UNALIGNED.withOrder(ByteOrder.BIG_ENDIAN).varHandle();\n@@ -103,1 +100,1 @@\n-        VarHandle vh = MethodHandles.memorySegmentViewVarHandle(ValueLayout.JAVA_INT);\n+        VarHandle vh = ValueLayout.JAVA_INT.varHandle();\n","filename":"test\/jdk\/java\/foreign\/TestVarHandleCombinators.java","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-            \"--enable-preview\",\n","filename":"test\/jdk\/java\/foreign\/UpcallTestHelper.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n@@ -28,1 +27,0 @@\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -40,1 +38,0 @@\n- * @enablePreview\n@@ -42,1 +39,0 @@\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/arraystructs\/TestArrayStructs.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestLayoutEquality.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestLinuxAArch64CallArranger.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestMacOsAArch64CallArranger.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestRISCV64CallArranger.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestSysVCallArranger.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestWindowsAArch64CallArranger.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestWindowsCallArranger.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n@@ -28,1 +27,0 @@\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -66,1 +64,1 @@\n-    private record SaveValuesCase(String nativeTarget, FunctionDescriptor nativeDesc, boolean trivial, String threadLocalName, Consumer<Object> resultCheck) {}\n+    private record SaveValuesCase(String nativeTarget, FunctionDescriptor nativeDesc, String threadLocalName, Consumer<Object> resultCheck) {}\n@@ -70,6 +68,2 @@\n-        List<Linker.Option> options = new ArrayList<>();\n-        options.add(Linker.Option.captureCallState(testCase.threadLocalName()));\n-        if (testCase.trivial()) {\n-            options.add(Linker.Option.isTrivial());\n-        }\n-        MethodHandle handle = downcallHandle(testCase.nativeTarget(), testCase.nativeDesc(), options.toArray(Linker.Option[]::new));\n+        Linker.Option stl = Linker.Option.captureCallState(testCase.threadLocalName());\n+        MethodHandle handle = downcallHandle(testCase.nativeTarget(), testCase.nativeDesc(), stl);\n@@ -88,1 +82,1 @@\n-            int savedErrno = (int) errnoHandle.get(saveSeg);\n+            int savedErrno = (int) errnoHandle.get(saveSeg, 0L);\n@@ -108,4 +102,0 @@\n-    interface CaseAdder {\n-      void addCase(String nativeTarget, FunctionDescriptor nativeDesc, String threadLocalName, Consumer<Object> resultCheck);\n-    }\n-\n@@ -115,4 +105,0 @@\n-        CaseAdder adder = (nativeTarget, nativeDesc, threadLocalName, resultCheck) -> {\n-          cases.add(new SaveValuesCase(nativeTarget, nativeDesc, false, threadLocalName, resultCheck));\n-          cases.add(new SaveValuesCase(nativeTarget, nativeDesc, true, threadLocalName, resultCheck));\n-        };\n@@ -120,16 +106,16 @@\n-        adder.addCase(\"set_errno_V\", FunctionDescriptor.ofVoid(JAVA_INT), \"errno\", o -> {});\n-        adder.addCase(\"set_errno_I\", FunctionDescriptor.of(JAVA_INT, JAVA_INT), \"errno\", o -> assertEquals((int) o, 42));\n-        adder.addCase(\"set_errno_D\", FunctionDescriptor.of(JAVA_DOUBLE, JAVA_INT), \"errno\", o -> assertEquals((double) o, 42.0));\n-\n-        structCase(adder, \"SL\",  Map.of(JAVA_LONG.withName(\"x\"), 42L));\n-        structCase(adder, \"SLL\", Map.of(JAVA_LONG.withName(\"x\"), 42L,\n-                                         JAVA_LONG.withName(\"y\"), 42L));\n-        structCase(adder, \"SLLL\", Map.of(JAVA_LONG.withName(\"x\"), 42L,\n-                                         JAVA_LONG.withName(\"y\"), 42L,\n-                                         JAVA_LONG.withName(\"z\"), 42L));\n-        structCase(adder, \"SD\",  Map.of(JAVA_DOUBLE.withName(\"x\"), 42D));\n-        structCase(adder, \"SDD\", Map.of(JAVA_DOUBLE.withName(\"x\"), 42D,\n-                                         JAVA_DOUBLE.withName(\"y\"), 42D));\n-        structCase(adder, \"SDDD\", Map.of(JAVA_DOUBLE.withName(\"x\"), 42D,\n-                                         JAVA_DOUBLE.withName(\"y\"), 42D,\n-                                         JAVA_DOUBLE.withName(\"z\"), 42D));\n+        cases.add(new SaveValuesCase(\"set_errno_V\", FunctionDescriptor.ofVoid(JAVA_INT), \"errno\", o -> {}));\n+        cases.add(new SaveValuesCase(\"set_errno_I\", FunctionDescriptor.of(JAVA_INT, JAVA_INT), \"errno\", o -> assertEquals((int) o, 42)));\n+        cases.add(new SaveValuesCase(\"set_errno_D\", FunctionDescriptor.of(JAVA_DOUBLE, JAVA_INT), \"errno\", o -> assertEquals((double) o, 42.0)));\n+\n+        cases.add(structCase(\"SL\",  Map.of(JAVA_LONG.withName(\"x\"), 42L)));\n+        cases.add(structCase(\"SLL\", Map.of(JAVA_LONG.withName(\"x\"), 42L,\n+                                           JAVA_LONG.withName(\"y\"), 42L)));\n+        cases.add(structCase(\"SLLL\", Map.of(JAVA_LONG.withName(\"x\"), 42L,\n+                                            JAVA_LONG.withName(\"y\"), 42L,\n+                                            JAVA_LONG.withName(\"z\"), 42L)));\n+        cases.add(structCase(\"SD\",  Map.of(JAVA_DOUBLE.withName(\"x\"), 42D)));\n+        cases.add(structCase(\"SDD\", Map.of(JAVA_DOUBLE.withName(\"x\"), 42D,\n+                                           JAVA_DOUBLE.withName(\"y\"), 42D)));\n+        cases.add(structCase(\"SDDD\", Map.of(JAVA_DOUBLE.withName(\"x\"), 42D,\n+                                            JAVA_DOUBLE.withName(\"y\"), 42D,\n+                                            JAVA_DOUBLE.withName(\"z\"), 42D)));\n@@ -138,2 +124,2 @@\n-            adder.addCase(\"SetLastError\", FunctionDescriptor.ofVoid(JAVA_INT), \"GetLastError\", o -> {});\n-            adder.addCase(\"WSASetLastError\", FunctionDescriptor.ofVoid(JAVA_INT), \"WSAGetLastError\", o -> {});\n+            cases.add(new SaveValuesCase(\"SetLastError\", FunctionDescriptor.ofVoid(JAVA_INT), \"GetLastError\", o -> {}));\n+            cases.add(new SaveValuesCase(\"WSASetLastError\", FunctionDescriptor.ofVoid(JAVA_INT), \"WSAGetLastError\", o -> {}));\n@@ -145,1 +131,1 @@\n-    static void structCase(CaseAdder adder, String name, Map<MemoryLayout, Object> fields) {\n+    static SaveValuesCase structCase(String name, Map<MemoryLayout, Object> fields) {\n@@ -153,1 +139,1 @@\n-            check = check.andThen(o -> assertEquals(fieldHandle.get(o), value));\n+            check = check.andThen(o -> assertEquals(fieldHandle.get(o, 0L), value));\n@@ -156,1 +142,1 @@\n-        adder.addCase(\"set_errno_\" + name, FunctionDescriptor.of(layout, JAVA_INT), \"errno\", check);\n+        return new SaveValuesCase(\"set_errno_\" + name, FunctionDescriptor.of(layout, JAVA_INT), \"errno\", check);\n","filename":"test\/jdk\/java\/foreign\/capturecallstate\/TestCaptureCallState.java","additions":25,"deletions":39,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/channels\/TestAsyncSocketChannels.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/channels\/TestSocketChannels.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n@@ -29,1 +28,0 @@\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/dontrelease\/TestDontRelease.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -33,1 +31,1 @@\n- *        org.openjdk.foreigntest.PanamaMainUnnamedModule\n+ *        org.openjdk.foreigntest.unnamed.PanamaMainUnnamedModule\n@@ -38,1 +36,0 @@\n-import java.util.ArrayList;\n@@ -60,69 +57,1 @@\n-public class TestEnableNativeAccess {\n-\n-    static final String MODULE_PATH = System.getProperty(\"jdk.module.path\");\n-\n-    static final String PANAMA_MAIN = \"panama_module\/org.openjdk.foreigntest.PanamaMainDirect\";\n-    static final String PANAMA_REFLECTION = \"panama_module\/org.openjdk.foreigntest.PanamaMainReflection\";\n-    static final String PANAMA_INVOKE = \"panama_module\/org.openjdk.foreigntest.PanamaMainInvoke\";\n-    static final String PANAMA_JNI = \"panama_module\/org.openjdk.foreigntest.PanamaMainJNI\";\n-    static final String UNNAMED = \"org.openjdk.foreigntest.PanamaMainUnnamedModule\";\n-\n-    \/**\n-     * Represents the expected result of a test.\n-     *\/\n-    static final class Result {\n-        private final boolean success;\n-        private final List<String> expectedOutput = new ArrayList<>();\n-        private final List<String> notExpectedOutput = new ArrayList<>();\n-\n-        Result(boolean success) {\n-            this.success = success;\n-        }\n-\n-        Result expect(String msg) {\n-            expectedOutput.add(msg);\n-            return this;\n-        }\n-\n-        Result doNotExpect(String msg) {\n-            notExpectedOutput.add(msg);\n-            return this;\n-        }\n-\n-        boolean shouldSucceed() {\n-            return success;\n-        }\n-\n-        Stream<String> expectedOutput() {\n-            return expectedOutput.stream();\n-        }\n-\n-        Stream<String> notExpectedOutput() {\n-            return notExpectedOutput.stream();\n-        }\n-\n-        @Override\n-        public String toString() {\n-            String s = (success) ? \"success\" : \"failure\";\n-            for (String msg : expectedOutput) {\n-                s += \"\/\" + msg;\n-            }\n-            return s;\n-        }\n-    }\n-\n-    static Result success() {\n-        return new Result(true);\n-    }\n-\n-    static Result successNoWarning() {\n-        return success().doNotExpect(\"WARNING\");\n-    }\n-\n-    static Result successWithWarning(String moduleName) {\n-        return success().expect(\"WARNING\").expect(\"--enable-native-access=\" + moduleName);\n-    }\n-\n-    static Result failWithWarning(String expectedOutput) {\n-        return new Result(false).expect(expectedOutput).expect(\"WARNING\");\n-    }\n+public class TestEnableNativeAccess extends TestEnableNativeAccessBase {\n@@ -153,15 +82,0 @@\n-    \/**\n-     * Checks an expected result with the output captured by the given\n-     * OutputAnalyzer.\n-     *\/\n-    void checkResult(Result expectedResult, OutputAnalyzer outputAnalyzer) {\n-        expectedResult.expectedOutput().forEach(outputAnalyzer::shouldContain);\n-        expectedResult.notExpectedOutput().forEach(outputAnalyzer::shouldNotContain);\n-        int exitValue = outputAnalyzer.getExitValue();\n-        if (expectedResult.shouldSucceed()) {\n-            assertTrue(exitValue == 0);\n-        } else {\n-            assertTrue(exitValue != 0);\n-        }\n-    }\n-\n@@ -179,2 +93,2 @@\n-        Stream<String> s2 = cls.equals(UNNAMED) ? Stream.of(\"--enable-preview\", \"-p\", MODULE_PATH, cls, action)\n-                : Stream.of(\"--enable-preview\", \"-p\", MODULE_PATH, \"-m\", cls, action);\n+        Stream<String> s2 = cls.equals(UNNAMED) ? Stream.of(\"-p\", MODULE_PATH, cls, action)\n+                : Stream.of(\"-p\", MODULE_PATH, \"-m\", cls, action);\n@@ -202,1 +116,1 @@\n-        assertTrue(count(output1, \"WARNING\") == 3);  \/\/ 3 on first access, none on subsequent access\n+        assertTrue(count(output1, \"WARNING\") == 4);  \/\/ 4 on first access, none on subsequent access\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/TestEnableNativeAccess.java","additions":6,"deletions":92,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -0,0 +1,124 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.util.List;\n+import java.util.ArrayList;\n+import java.util.stream.Stream;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+import static org.testng.Assert.*;\n+\n+public class TestEnableNativeAccessBase {\n+    static final String MODULE_PATH = System.getProperty(\"jdk.module.path\");\n+\n+    static final String PANAMA_MAIN_CLS = \"org.openjdk.foreigntest.PanamaMainDirect\";\n+    static final String PANAMA_MAIN = \"panama_module\/\" + PANAMA_MAIN_CLS;\n+    static final String PANAMA_REFLECTION_CLS = \"org.openjdk.foreigntest.PanamaMainReflection\";\n+    static final String PANAMA_REFLECTION = \"panama_module\/\" + PANAMA_REFLECTION_CLS;\n+    static final String PANAMA_INVOKE_CLS = \"org.openjdk.foreigntest.PanamaMainInvoke\";\n+    static final String PANAMA_INVOKE = \"panama_module\/\" + PANAMA_INVOKE_CLS;\n+    static final String PANAMA_JNI_CLS = \"org.openjdk.foreigntest.PanamaMainJNI\";\n+    static final String PANAMA_JNI = \"panama_module\/\" + PANAMA_JNI_CLS;\n+    static final String UNNAMED = \"org.openjdk.foreigntest.unnamed.PanamaMainUnnamedModule\";\n+\n+    \/**\n+     * Represents the expected result of a test.\n+     *\/\n+    static final class Result {\n+        private final boolean success;\n+        private final List<String> expectedOutput = new ArrayList<>();\n+        private final List<String> notExpectedOutput = new ArrayList<>();\n+\n+        Result(boolean success) {\n+            this.success = success;\n+        }\n+\n+        Result expect(String msg) {\n+            expectedOutput.add(msg);\n+            return this;\n+        }\n+\n+        Result doNotExpect(String msg) {\n+            notExpectedOutput.add(msg);\n+            return this;\n+        }\n+\n+        boolean shouldSucceed() {\n+            return success;\n+        }\n+\n+        Stream<String> expectedOutput() {\n+            return expectedOutput.stream();\n+        }\n+\n+        Stream<String> notExpectedOutput() {\n+            return notExpectedOutput.stream();\n+        }\n+\n+        @Override\n+        public String toString() {\n+            String s = (success) ? \"success\" : \"failure\";\n+            for (String msg : expectedOutput) {\n+                s += \"\/\" + msg;\n+            }\n+            return s;\n+        }\n+\n+    }\n+\n+    static Result success() {\n+        return new Result(true);\n+    }\n+\n+    static Result successNoWarning() {\n+        return success().doNotExpect(\"WARNING\");\n+    }\n+\n+    static Result successWithWarning(String moduleName) {\n+        return success().expect(\"WARNING\").expect(\"--enable-native-access=\" + moduleName);\n+    }\n+\n+    static Result failWithWarning(String expectedOutput) {\n+        return new Result(false).expect(expectedOutput).expect(\"WARNING\");\n+    }\n+\n+    static Result failWithError(String expectedOutput) {\n+        return new Result(false).expect(expectedOutput);\n+    }\n+\n+    \/**\n+     * Checks an expected result with the output captured by the given\n+     * OutputAnalyzer.\n+     *\/\n+    void checkResult(Result expectedResult, OutputAnalyzer outputAnalyzer) {\n+        expectedResult.expectedOutput().forEach(outputAnalyzer::shouldContain);\n+        expectedResult.notExpectedOutput().forEach(outputAnalyzer::shouldNotContain);\n+        int exitValue = outputAnalyzer.getExitValue();\n+        if (expectedResult.shouldSucceed()) {\n+            assertTrue(exitValue == 0);\n+        } else {\n+            assertTrue(exitValue != 0);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/TestEnableNativeAccessBase.java","additions":124,"deletions":0,"binary":false,"changes":124,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -40,1 +38,0 @@\n-import java.util.stream.Stream;\n@@ -47,1 +44,0 @@\n-import static org.testng.Assert.*;\n@@ -50,64 +46,1 @@\n-public class TestEnableNativeAccessDynamic {\n-\n-    static final String MODULE_PATH = System.getProperty(\"jdk.module.path\");\n-\n-    static final String PANAMA_MAIN = \"panama_module\/org.openjdk.foreigntest.PanamaMainDirect\";\n-    static final String PANAMA_REFLECTION = \"panama_module\/org.openjdk.foreigntest.PanamaMainReflection\";\n-    static final String PANAMA_INVOKE = \"panama_module\/org.openjdk.foreigntest.PanamaMainInvoke\";\n-    static final String PANAMA_JNI = \"panama_module\/org.openjdk.foreigntest.PanamaMainJNI\";\n-\n-    \/**\n-     * Represents the expected result of a test.\n-     *\/\n-    static final class Result {\n-        private final boolean success;\n-        private final List<String> expectedOutput = new ArrayList<>();\n-        private final List<String> notExpectedOutput = new ArrayList<>();\n-\n-        Result(boolean success) {\n-            this.success = success;\n-        }\n-\n-        Result expect(String msg) {\n-            expectedOutput.add(msg);\n-            return this;\n-        }\n-\n-        Result doNotExpect(String msg) {\n-            notExpectedOutput.add(msg);\n-            return this;\n-        }\n-\n-        boolean shouldSucceed() {\n-            return success;\n-        }\n-\n-        Stream<String> expectedOutput() {\n-            return expectedOutput.stream();\n-        }\n-\n-        Stream<String> notExpectedOutput() {\n-            return notExpectedOutput.stream();\n-        }\n-\n-        @Override\n-        public String toString() {\n-            String s = (success) ? \"success\" : \"failure\";\n-            for (String msg : expectedOutput) {\n-                s += \"\/\" + msg;\n-            }\n-            return s;\n-        }\n-    }\n-\n-    static Result success() {\n-        return new Result(true);\n-    }\n-\n-    static Result successNoWarning() {\n-        return success().doNotExpect(\"WARNING\");\n-    }\n-\n-    static Result failWithError(String expectedOutput) {\n-        return new Result(false).expect(expectedOutput);\n-    }\n+public class TestEnableNativeAccessDynamic extends TestEnableNativeAccessBase {\n@@ -134,15 +67,0 @@\n-    \/**\n-     * Checks an expected result with the output captured by the given\n-     * OutputAnalyzer.\n-     *\/\n-    void checkResult(Result expectedResult, OutputAnalyzer outputAnalyzer) {\n-        expectedResult.expectedOutput().forEach(outputAnalyzer::shouldContain);\n-        expectedResult.notExpectedOutput().forEach(outputAnalyzer::shouldNotContain);\n-        int exitValue = outputAnalyzer.getExitValue();\n-        if (expectedResult.shouldSucceed()) {\n-            assertTrue(exitValue == 0);\n-        } else {\n-            assertTrue(exitValue != 0);\n-        }\n-    }\n-\n@@ -158,1 +76,0 @@\n-        list.add(\"--enable-preview\");\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/TestEnableNativeAccessDynamic.java","additions":2,"deletions":85,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -0,0 +1,141 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary Basic test for Enable-Native-Access attribute in the\n+ *          manifest of a main application JAR\n+ * @library \/test\/lib\n+ * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n+ * @requires !vm.musl\n+ *\n+ * @enablePreview\n+ * @build TestEnableNativeAccessJarManifest\n+ *        panama_module\/*\n+ *        org.openjdk.foreigntest.unnamed.PanamaMainUnnamedModule\n+ * @run testng TestEnableNativeAccessJarManifest\n+ *\/\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+import java.util.ArrayList;\n+import java.util.jar.Attributes;\n+import java.util.jar.Manifest;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.util.JarUtils;\n+\n+import org.testng.annotations.Test;\n+import org.testng.annotations.DataProvider;\n+\n+public class TestEnableNativeAccessJarManifest extends TestEnableNativeAccessBase {\n+\n+    private static final String REINVOKER = \"TestEnableNativeAccessJarManifest$Reinvoker\";\n+\n+    static record Attribute(String name, String value) {}\n+\n+    @Test(dataProvider = \"cases\")\n+    public void testEnableNativeAccessInJarManifest(String action, String cls, Result expectedResult,\n+                                                    List<Attribute> attributes, List<String> vmArgs, List<String> programArgs) throws Exception {\n+        Manifest man = new Manifest();\n+        Attributes attrs = man.getMainAttributes();\n+        attrs.put(Attributes.Name.MANIFEST_VERSION, \"1.0\");\n+        attrs.put(Attributes.Name.MAIN_CLASS, cls);\n+\n+        for (Attribute attrib : attributes) {\n+            attrs.put(new Attributes.Name(attrib.name()), attrib.value());\n+        }\n+\n+        \/\/ create the JAR file with Test1 and Test2\n+        Path jarfile = Paths.get(action + \".jar\");\n+        Files.deleteIfExists(jarfile);\n+\n+        Path classes = Paths.get(System.getProperty(\"test.classes\", \"\"));\n+        JarUtils.createJarFile(jarfile, man, classes, Paths.get(cls.replace('.', '\/') + \".class\"));\n+\n+        \/\/ java -jar test.jar\n+        List<String> command = new ArrayList<>(List.of(\n+            \"--enable-preview\",\n+            \"-Djava.library.path=\" + System.getProperty(\"java.library.path\")\n+        ));\n+        command.addAll(vmArgs);\n+        command.add(\"-jar\");\n+        command.add(jarfile.toString());\n+        command.addAll(programArgs);\n+        OutputAnalyzer outputAnalyzer = ProcessTools.executeTestJava(command.toArray(String[]::new))\n+                .outputTo(System.out)\n+                .errorTo(System.out);\n+        checkResult(expectedResult, outputAnalyzer);\n+    }\n+\n+    @DataProvider\n+    public Object[][] cases() {\n+        return new Object[][] {\n+            \/\/ simple cases where a jar contains a single main class with no dependencies\n+            { \"panama_no_unnamed_module_native_access\", UNNAMED, successWithWarning(\"ALL-UNNAMED\"),\n+                    List.of(), List.of(), List.of() },\n+            { \"panama_unnamed_module_native_access\", UNNAMED, successNoWarning(),\n+                    List.of(new Attribute(\"Enable-Native-Access\", \"ALL-UNNAMED\")), List.of(), List.of() },\n+            { \"panama_unnamed_module_native_access_invalid\", UNNAMED,\n+                    failWithError(\"Error: illegal value \\\"asdf\\\" for Enable-Native-Access manifest attribute. Only ALL-UNNAMED is allowed\"),\n+                    List.of(new Attribute(\"Enable-Native-Access\", \"asdf\")), List.of(), List.of() },\n+\n+            \/\/ more complex cases where a jar invokes a module on the module path that does native access\n+            { \"panama_enable_native_access_false\", REINVOKER, successWithWarning(\"panama_module\"),\n+                    List.of(new Attribute(\"Enable-Native-Access\", \"ALL-UNNAMED\")),\n+                    List.of(\"-p\", MODULE_PATH, \"--add-modules=panama_module\"),\n+                    List.of(PANAMA_MAIN_CLS) },\n+            { \"panama_enable_native_access_reflection_false\", REINVOKER, successWithWarning(\"panama_module\"),\n+                    List.of(new Attribute(\"Enable-Native-Access\", \"ALL-UNNAMED\")),\n+                    List.of(\"-p\", MODULE_PATH, \"--add-modules=panama_module\"),\n+                    List.of(PANAMA_REFLECTION_CLS) },\n+            { \"panama_enable_native_access_invoke_false\", REINVOKER, successWithWarning(\"panama_module\"),\n+                    List.of(new Attribute(\"Enable-Native-Access\", \"ALL-UNNAMED\")),\n+                    List.of(\"-p\", MODULE_PATH, \"--add-modules=panama_module\"),\n+                    List.of(PANAMA_INVOKE_CLS) },\n+\n+            { \"panama_enable_native_access_true\", REINVOKER, successNoWarning(),\n+                    List.of(new Attribute(\"Enable-Native-Access\", \"ALL-UNNAMED\")),\n+                    List.of(\"-p\", MODULE_PATH, \"--add-modules=panama_module\", \"--enable-native-access=panama_module\"),\n+                    List.of(PANAMA_MAIN_CLS) },\n+            { \"panama_enable_native_access_reflection_true\", REINVOKER, successNoWarning(),\n+                    List.of(new Attribute(\"Enable-Native-Access\", \"ALL-UNNAMED\")),\n+                    List.of(\"-p\", MODULE_PATH, \"--add-modules=panama_module\", \"--enable-native-access=panama_module\"),\n+                    List.of(PANAMA_REFLECTION_CLS) },\n+            { \"panama_enable_native_access_invoke_true\", REINVOKER, successNoWarning(),\n+                    List.of(new Attribute(\"Enable-Native-Access\", \"ALL-UNNAMED\")),\n+                    List.of(\"-p\", MODULE_PATH, \"--add-modules=panama_module\", \"--enable-native-access=panama_module\"),\n+                    List.of(PANAMA_INVOKE_CLS) }\n+        };\n+    }\n+\n+    public class Reinvoker {\n+        public static void main(String[] args) throws Throwable {\n+            Class<?> realMainClass = Class.forName(args[0]);\n+            realMainClass.getMethod(\"main\", String[].class).invoke(null, (Object) new String[0]);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/TestEnableNativeAccessJarManifest.java","additions":141,"deletions":0,"binary":false,"changes":141,"status":"added"},{"patch":"@@ -24,1 +24,1 @@\n-package org.openjdk.foreigntest;\n+package org.openjdk.foreigntest.unnamed;\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/org\/openjdk\/foreigntest\/unnamed\/PanamaMainUnnamedModule.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/org\/openjdk\/foreigntest\/PanamaMainUnnamedModule.java","status":"renamed"},{"patch":"@@ -39,1 +39,1 @@\n-    Java_org_openjdk_foreigntest_PanamaMainUnnamedModule_nativeLinker0(JNIEnv *env, jclass cls) {\n+    Java_org_openjdk_foreigntest_unnamed_PanamaMainUnnamedModule_nativeLinker0(JNIEnv *env, jclass cls) {\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/org\/openjdk\/foreigntest\/unnamed\/libLinkerInvokerUnnamed.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/org\/openjdk\/foreigntest\/libLinkerInvokerUnnamed.cpp","status":"renamed"},{"patch":"@@ -1,34 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.openjdk.foreigntest;\n-\n-import java.lang.foreign.*;\n-\n-public class PanamaMain {\n-   public static void main(String[] args) {\n-       System.out.println(\"Trying to obtain a downcall handle\");\n-       Linker.nativeLinker().downcallHandle(FunctionDescriptor.ofVoid());\n-       System.out.println(\"Got downcall handle\");\n-   }\n-}\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_module\/org\/openjdk\/foreigntest\/PanamaMain.java","additions":0,"deletions":34,"binary":false,"changes":34,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+   jthrowable exception;\n@@ -42,0 +43,2 @@\n+    context->exception = (jthrowable) env->NewGlobalRef(env->ExceptionOccurred());\n+    env->ExceptionClear();\n@@ -54,0 +57,3 @@\n+        if (context.exception != nullptr) {\n+            env->Throw(context.exception); \/\/ transfer exception to this thread\n+        }\n@@ -57,0 +63,1 @@\n+        env->DeleteGlobalRef(context.exception);\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_module\/org\/openjdk\/foreigntest\/libLinkerInvokerModule.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/handles\/Driver.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n@@ -28,1 +27,0 @@\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/largestub\/TestLargeStub.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/loaderLookup\/TestLoaderLookup.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,2 +32,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/loaderLookup\/TestLoaderLookupJNI.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n@@ -28,1 +27,0 @@\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/nested\/TestNested.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n@@ -28,1 +27,0 @@\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/normalize\/TestNormalize.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @enablePreview\n@@ -28,1 +27,0 @@\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/passheapsegment\/TestPassHeapSegment.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -45,2 +43,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -65,2 +61,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -85,2 +79,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/stackwalk\/TestAsyncStackWalk.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/stackwalk\/TestReentrantUpcalls.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -45,2 +43,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -65,2 +61,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -85,2 +79,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/stackwalk\/TestStackWalk.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @library ..\/ \/test\/lib\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestCritical\n+ *\/\n+\n+import org.testng.annotations.Test;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.SegmentAllocator;\n+import java.lang.foreign.StructLayout;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+\n+import static org.testng.Assert.assertEquals;\n+\n+public class TestCritical extends NativeTestHelper {\n+\n+    static {\n+        System.loadLibrary(\"Critical\");\n+    }\n+\n+    @Test\n+    public void testEmpty() throws Throwable {\n+        MethodHandle handle = downcallHandle(\"empty\", FunctionDescriptor.ofVoid(), Linker.Option.critical());\n+        handle.invokeExact();\n+    }\n+\n+    @Test\n+    public void testIdentity() throws Throwable {\n+        MethodHandle handle = downcallHandle(\"identity\", FunctionDescriptor.of(C_INT, C_INT), Linker.Option.critical());\n+        int result = (int) handle.invokeExact(42);\n+        assertEquals(result, 42);\n+    }\n+\n+    @Test\n+    public void testWithReturnBuffer() throws Throwable {\n+        StructLayout bigLayout = MemoryLayout.structLayout(\n+                C_LONG_LONG.withName(\"x\"),\n+                C_LONG_LONG.withName(\"y\"));\n+\n+        MethodHandle handle = downcallHandle(\"with_return_buffer\", FunctionDescriptor.of(bigLayout), Linker.Option.critical());\n+        VarHandle vhX = bigLayout.varHandle(MemoryLayout.PathElement.groupElement(\"x\"));\n+        VarHandle vhY = bigLayout.varHandle(MemoryLayout.PathElement.groupElement(\"y\"));\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment result = (MemorySegment) handle.invokeExact((SegmentAllocator) arena);\n+            long x = (long) vhX.get(result, 0L);\n+            assertEquals(x, 10);\n+            long y = (long) vhY.get(result, 0L);\n+            assertEquals(y, 11);\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/foreign\/trivial\/TestCritical.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @library ..\/ \/test\/lib\n+ * @requires jdk.foreign.linker != \"FALLBACK\"\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestCriticalUpcall\n+ *\/\n+\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.invoke.MethodHandle;\n+\n+import static org.testng.Assert.fail;\n+\n+public class TestCriticalUpcall extends UpcallTestHelper {\n+\n+    @Test\n+    public void testUpcallFailure() throws IOException, InterruptedException {\n+        \/\/ test to see if we catch a trivial downcall doing an upcall\n+        runInNewProcess(Runner.class, true).assertStdOutContains(\"wrong thread state for upcall\");\n+    }\n+\n+    public static class Runner extends NativeTestHelper {\n+        public static void main(String[] args) throws Throwable {\n+            System.loadLibrary(\"Critical\");\n+\n+            MethodHandle mh = downcallHandle(\"do_upcall\", FunctionDescriptor.ofVoid(C_POINTER), Linker.Option.critical());\n+            MemorySegment stub = upcallStub(Runner.class, \"target\", FunctionDescriptor.ofVoid());\n+            mh.invokeExact(stub);\n+        }\n+\n+        public static void target() {\n+            fail(\"Should not get here\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/trivial\/TestCriticalUpcall.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -1,98 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @enablePreview\n- * @library ..\/ \/test\/lib\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n- * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestTrivial\n- *\/\n-\n-import org.testng.annotations.Test;\n-\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.Linker;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.SegmentAllocator;\n-import java.lang.foreign.StructLayout;\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.VarHandle;\n-\n-import static org.testng.Assert.assertEquals;\n-\n-public class TestTrivial extends NativeTestHelper {\n-\n-    static {\n-        System.loadLibrary(\"Trivial\");\n-    }\n-\n-    @Test\n-    public void testEmpty() throws Throwable {\n-        MethodHandle handle = downcallHandle(\"empty\", FunctionDescriptor.ofVoid(), Linker.Option.isTrivial());\n-        handle.invokeExact();\n-    }\n-\n-    @Test\n-    public void testIdentity() throws Throwable {\n-        MethodHandle handle = downcallHandle(\"identity\", FunctionDescriptor.of(C_INT, C_INT), Linker.Option.isTrivial());\n-        int result = (int) handle.invokeExact(42);\n-        assertEquals(result, 42);\n-    }\n-\n-    @Test\n-    public void testWithReturnBuffer() throws Throwable {\n-        StructLayout bigLayout = MemoryLayout.structLayout(\n-                C_LONG_LONG.withName(\"x\"),\n-                C_LONG_LONG.withName(\"y\"));\n-\n-        MethodHandle handle = downcallHandle(\"with_return_buffer\", FunctionDescriptor.of(bigLayout), Linker.Option.isTrivial());\n-        VarHandle vhX = bigLayout.varHandle(MemoryLayout.PathElement.groupElement(\"x\"));\n-        VarHandle vhY = bigLayout.varHandle(MemoryLayout.PathElement.groupElement(\"y\"));\n-        try (Arena arena = Arena.ofConfined()) {\n-            MemorySegment result = (MemorySegment) handle.invokeExact((SegmentAllocator) arena);\n-            long x = (long) vhX.get(result);\n-            assertEquals(x, 10);\n-            long y = (long) vhY.get(result);\n-            assertEquals(y, 11);\n-        }\n-    }\n-\n-    @Test\n-    public void testCaptureErrno() throws Throwable {\n-        Linker.Option ccs = Linker.Option.captureCallState(\"errno\");\n-        MethodHandle handle = downcallHandle(\"capture_errno\", FunctionDescriptor.ofVoid(C_INT), Linker.Option.isTrivial(), ccs);\n-        StructLayout capturedStateLayout = Linker.Option.captureStateLayout();\n-        VarHandle errnoHandle = capturedStateLayout.varHandle(MemoryLayout.PathElement.groupElement(\"errno\"));\n-        try (Arena arena = Arena.ofConfined()) {\n-            MemorySegment captureSeg = arena.allocate(capturedStateLayout);\n-            handle.invokeExact(captureSeg, 42);\n-            int capturedErrno = (int) errnoHandle.get(captureSeg);\n-            assertEquals(capturedErrno, 42);\n-        }\n-    }\n-\n-\n-}\n","filename":"test\/jdk\/java\/foreign\/trivial\/TestTrivial.java","additions":0,"deletions":98,"binary":false,"changes":98,"status":"deleted"},{"patch":"@@ -1,64 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @enablePreview\n- * @library ..\/ \/test\/lib\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n- * @requires jdk.foreign.linker != \"FALLBACK\"\n- * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestTrivialUpcall\n- *\/\n-\n-import org.testng.annotations.Test;\n-\n-import java.io.IOException;\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.Linker;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.invoke.MethodHandle;\n-\n-import static org.testng.Assert.fail;\n-\n-public class TestTrivialUpcall extends UpcallTestHelper {\n-\n-    @Test\n-    public void testUpcallFailure() throws IOException, InterruptedException {\n-        \/\/ test to see if we catch a trivial downcall doing an upcall\n-        runInNewProcess(Runner.class, true).assertStdOutContains(\"wrong thread state for upcall\");\n-    }\n-\n-    public static class Runner extends NativeTestHelper {\n-        public static void main(String[] args) throws Throwable {\n-            System.loadLibrary(\"Trivial\");\n-\n-            MethodHandle mh = downcallHandle(\"do_upcall\", FunctionDescriptor.ofVoid(C_POINTER), Linker.Option.isTrivial());\n-            MemorySegment stub = upcallStub(Runner.class, \"target\", FunctionDescriptor.ofVoid());\n-            mh.invokeExact(stub);\n-        }\n-\n-        public static void target() {\n-            fail(\"Should not get here\");\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/foreign\/trivial\/TestTrivialUpcall.java","additions":0,"deletions":64,"binary":false,"changes":64,"status":"deleted"},{"patch":"@@ -51,4 +51,0 @@\n-EXPORT void capture_errno(int value) {\n-    errno = value;\n-}\n-\n","filename":"test\/jdk\/java\/foreign\/trivial\/libCritical.c","additions":0,"deletions":4,"binary":false,"changes":4,"previous_filename":"test\/jdk\/java\/foreign\/trivial\/libTrivial.c","status":"renamed"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n@@ -28,1 +27,0 @@\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/upcalldeopt\/TestUpcallDeopt.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/virtual\/TestVirtualCalls.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,4 +41,4 @@\n- * @compile --enable-preview -source ${jdk.version} ImplicitAttach.java\n- * @run main AttachTest --enable-preview --enable-native-access=ALL-UNNAMED ImplicitAttach 1\n- * @run main AttachTest --enable-preview --enable-native-access=ALL-UNNAMED ImplicitAttach 2\n- * @run main AttachTest --enable-preview --enable-native-access=ALL-UNNAMED ImplicitAttach 4\n+ * @compile ImplicitAttach.java\n+ * @run main AttachTest --enable-native-access=ALL-UNNAMED ImplicitAttach 1\n+ * @run main AttachTest --enable-native-access=ALL-UNNAMED ImplicitAttach 2\n+ * @run main AttachTest --enable-native-access=ALL-UNNAMED ImplicitAttach 4\n","filename":"test\/jdk\/java\/lang\/Thread\/jni\/AttachCurrentThread\/AttachTest.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @requires vm.flagless\n","filename":"test\/jdk\/java\/lang\/instrument\/modules\/AppendToClassPathModuleTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/IndirectVarHandleTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n@@ -174,1 +173,1 @@\n-        VarHandle vh = MethodHandles.memorySegmentViewVarHandle(ValueLayouts.valueLayout(carrier, ByteOrder.nativeOrder()));\n+        VarHandle vh = ValueLayouts.valueLayout(carrier, ByteOrder.nativeOrder()).varHandle();\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestExact.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -477,0 +477,1 @@\n+            var tracker = TRACKER.getTracker(client);\n@@ -485,1 +486,0 @@\n-                var tracker = TRACKER.getTracker(client);\n@@ -494,0 +494,8 @@\n+            } else {\n+                System.out.println(now() + \"waiting for operation to finish: \" + tracker.getName());\n+                System.err.println(now() + \"waiting for operation to finish: \" + tracker.getName());\n+                var error = TRACKER.checkFinished(tracker, 10000);\n+                if (error != null) throw error;\n+                System.out.println(now() + \"operation finished normally: \" + tracker.getName());\n+                System.err.println(now() + \"operation finished normally: \" + tracker.getName());\n+\n@@ -803,1 +811,1 @@\n-        AssertionError fail = TRACKER.check(500);\n+        AssertionError fail = TRACKER.check(5000);\n","filename":"test\/jdk\/java\/net\/httpclient\/AbstractThrowingSubscribers.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -118,0 +118,8 @@\n+    public AssertionError checkFinished(Tracker tracker, long graceDelayMs) {\n+        Predicate<Tracker> hasOperations = (t) -> t.getOutstandingOperations() > 0;\n+        Predicate<Tracker> hasSubscribers = (t) -> t.getOutstandingSubscribers() > 0;\n+        return check(tracker, graceDelayMs,\n+                hasOperations.or(hasSubscribers),\n+                \"outstanding operations or unreleased resources\", false);\n+    }\n+\n","filename":"test\/jdk\/java\/net\/httpclient\/ReferenceTracker.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/nio\/channels\/FileChannel\/LargeMapTest.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/nio\/channels\/FileChannel\/MapToMemorySegmentTest.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -48,0 +48,12 @@\n+    private static final String FAT32_TYPE;\n+    static {\n+        if (Platform.isLinux())\n+            FAT32_TYPE = \"vfat\";\n+        else if (Platform.isOSX())\n+            FAT32_TYPE = \"msdos\";\n+        else if (Platform.isWindows())\n+            FAT32_TYPE = \"FAT32\";\n+        else\n+            FAT32_TYPE = \"unknown\";\n+    }\n+\n@@ -51,0 +63,1 @@\n+    private static boolean targetVolumeIsFAT32 = false;\n@@ -68,0 +81,2 @@\n+            targetVolumeIsFAT32 = fileStore2.type().equals(FAT32_TYPE);\n+\n@@ -101,0 +116,1 @@\n+            targetVolumeIsFAT32 = false;\n@@ -134,4 +150,9 @@\n-\n-            if (time1 != time2) {\n-                System.err.format(\"File time for %s is %s\\n\", attrs1.fileKey(), attrs1.lastModifiedTime());\n-                System.err.format(\"File time for %s is %s\\n\", attrs2.fileKey(), attrs2.lastModifiedTime());\n+            long delta = Math.abs(Math.subtractExact(time1, time2));\n+\n+            \/\/ FAT32 volumes have a time stamp resolution of 2 seconds for\n+            \/\/ last modified time (write time)\n+            if ((delta != 0 && !targetVolumeIsFAT32) || delta > 2) {\n+                System.err.format(\"File time for %s is %s\\n\",\n+                                  attrs1.fileKey(), attrs1.lastModifiedTime());\n+                System.err.format(\"File time for %s is %s\\n\",\n+                                  attrs2.fileKey(), attrs2.lastModifiedTime());\n","filename":"test\/jdk\/java\/nio\/file\/Files\/CopyAndMove.java","additions":25,"deletions":4,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n- * @bug 8011536 8151430\n+ * @bug 8011536 8151430 8316304\n@@ -33,0 +33,1 @@\n+import java.lang.foreign.Linker;\n@@ -91,0 +92,5 @@\n+        } else if (Platform.isLinux()) {\n+            \/\/ Creation time read depends on statx system call support\n+            supportsCreationTimeRead = Linker.nativeLinker().defaultLookup().find(\"statx\").isPresent();\n+            \/\/ Creation time updates are not supported on Linux\n+            supportsCreationTimeWrite = false;\n@@ -92,0 +98,1 @@\n+        System.out.println(\"supportsCreationTimeRead == \" + supportsCreationTimeRead);\n","filename":"test\/jdk\/java\/nio\/file\/attribute\/BasicFileAttributeView\/CreationTime.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"filename":"test\/jdk\/java\/security\/KeyRep\/RSA.pre.1.5.key","binary":true,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2005, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 4532506\n+ * @bug 4532506 8301126\n@@ -33,1 +33,0 @@\n-import java.security.*;\n@@ -43,1 +42,7 @@\n-        \/\/ verify pre-tiger keys still deserialize in our VM\n+        \/\/ verify pre-tiger keys still deserialize in our VM.\n+\n+        \/\/ There used to be a RSA test here, but the serialized file contained\n+        \/\/ classes introduced in JDK 5.0 (sun.security.rsa.RSA*).  The older\n+        \/\/ RSA keys from JDK 1.4.2 were of class JSA_* which were removed when\n+        \/\/ sun.security.rsa was introduced.  (See JDK-8301126 for more\n+        \/\/ details.)  The test\/data has been removed.\n@@ -46,1 +51,0 @@\n-        deserializeKey(\"RSA\");\n","filename":"test\/jdk\/java\/security\/KeyRep\/SerialOld.java","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,5 @@\n- * @summary Confirm that DecimalFormat.parse() parses BigDecimal and BigInteger as expected.\n+ * @summary Confirm that DecimalFormat.parse() parses BigDecimal and BigInteger\n+ *          string values as expected. Specifically, ensure a ParseException is\n+ *          not thrown as well as the parsed value being numerically correct.\n+ *          Tests large String values with combinations of multipliers and exponents.\n+ * @run junit BigDecimalCompatibilityTest\n@@ -30,3 +34,15 @@\n-import java.math.*;\n-import java.text.*;\n-import java.util.*;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.text.DecimalFormat;\n+import java.util.ArrayList;\n+import java.util.Locale;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n@@ -36,1 +52,3 @@\n-    static boolean err = false;\n+    private static DecimalFormat df = new DecimalFormat();\n+    \/\/ Save JVM default Locale\n+    private static final Locale savedLocale = Locale.getDefault();\n@@ -38,10 +56,1 @@\n-    static final String[] input_data = {\n-        \"0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\",\n-        \"1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890\"\n-    };\n-    static final String[] exponents = {\n-        \"E-100\", \"E100\", \"E-900\", \"E900\", \"\"\n-    };\n-    static final int[] multipliers = {\n-        -1, 1, -100, 100, -9999, 9999\n-    };\n+    \/\/ ---- Used for the test data (start) ----\n@@ -49,3 +58,3 @@\n-    public static void main(String[] args) throws Exception {\n-        Locale loc = Locale.getDefault();\n-        Locale.setDefault(Locale.US);\n+    \/\/ Both ArrayList composed of Arguments(String longString, int multiplier)\n+    private static final ArrayList<Arguments> bigIntegers = new ArrayList<Arguments>();\n+    private static final ArrayList<Arguments> bigDecimals = new ArrayList<Arguments>();\n@@ -53,2 +62,4 @@\n-        testBigDecimal();\n-        testBigInteger();\n+    \/\/ Long string data to generate combinations of test values\n+    private static final String[] inputData = {\n+            \"0\".repeat(400),\n+            \"1234567890\".repeat(40)};\n@@ -56,1 +67,4 @@\n-        Locale.setDefault(loc);\n+    \/\/ Variety of exponents to test parse() against\n+    private static final String[] exponents = {\n+            \"E-100\", \"E100\", \"E-900\", \"E900\", \"\"\n+    };\n@@ -58,4 +72,5 @@\n-        if (err) {\n-            throw new RuntimeException(\"Error: Unexpected value\");\n-        }\n-    }\n+    \/\/ Variety of multipliers that DecimalFormat can apply\n+    private static final int[] multipliers = {\n+            -1, 1, -100, 100, -9999, 9999\n+    };\n+    \/\/ ---- Used for the test data (end) ----\n@@ -63,4 +78,6 @@\n-    static private void testBigDecimal() {\n-        DecimalFormat df = new DecimalFormat();\n-        df.setParseBigDecimal(true);\n-        df.setMaximumFractionDigits(Integer.MAX_VALUE);\n+    \/\/ Set JVM default Locale to US and populate the test arrayLists\n+    @BeforeAll\n+    static void initAll() {\n+        Locale.setDefault(Locale.US);\n+        buildTestData();\n+    }\n@@ -68,11 +85,21 @@\n-        for (int i = 0; i < input_data.length; i++) {\n-            for (int j = 0; j < input_data.length; j++) {\n-                for (int k = 0; k < input_data.length; k++) {\n-                    for (int l = 0; l < input_data.length; l++) {\n-                        for (int m = 0; m < exponents.length; m++) {\n-                            String s = input_data[i] + input_data[j] + '.' +\n-                                       input_data[k] + input_data[l] +\n-                                       exponents[m];\n-                            for (int n = 0; n < multipliers.length; n++) {\n-                                test(df, s, multipliers[n]);\n-                                test(df, '-'+s, multipliers[n]);\n+    \/*\n+     * Uses inputData and exponents to build long string\n+     * decimal and integer values and populate bigDecimals and bigIntegers\n+     * accordingly. Attaches a multiplier value as well to the test data.\n+     *\/\n+    private static void buildTestData() {\n+        for (String longString1 : inputData) {\n+            for (String longString2 : inputData) {\n+                String bigInteger = longString1 + longString2;\n+                for (int multiplier : multipliers) {\n+                    bigIntegers.add(Arguments.of(bigInteger, multiplier));\n+                    bigIntegers.add(Arguments.of('-' + bigInteger, multiplier));\n+                }\n+                for (String longString3 : inputData) {\n+                    for (String longString4 : inputData) {\n+                        for (String exponent : exponents) {\n+                            String bigDecimal = longString1 + longString2 + '.'\n+                                    + longString3 + longString4 + exponent;\n+                            for (int multiplier : multipliers) {\n+                                bigDecimals.add(Arguments.of(bigDecimal, multiplier));\n+                                bigDecimals.add(Arguments.of('-' + bigDecimal, multiplier));\n@@ -87,4 +114,5 @@\n-    static private void testBigInteger() {\n-        DecimalFormat df = new DecimalFormat();\n-        df.setParseBigDecimal(true);\n-        df.setMaximumFractionDigits(Integer.MAX_VALUE);\n+    \/\/ Restore JVM default Locale\n+    @AfterAll\n+    static void tearDownAll() {\n+        Locale.setDefault(savedLocale);\n+    }\n@@ -92,9 +120,24 @@\n-        for (int i = 0; i < input_data.length; i++) {\n-            for (int j = 0; j < input_data.length; j++) {\n-                String s = input_data[i] + input_data[j];\n-                for (int k = 0; k < multipliers.length; k++) {\n-                    test(df, s, multipliers[k]);\n-                    test(df, '-'+s, multipliers[k]);\n-                }\n-            }\n-        }\n+    \/\/ Tests strings with length 1600+. See test() for specific details.\n+    @ParameterizedTest\n+    @MethodSource(\"bigDecimalProvider\")\n+    public void bigDecimalParseTest(String longString, int multiplier) {\n+        test(longString, multiplier);\n+    }\n+\n+    \/\/ Returns 960 arrangements of bigDecimal string values and multipliers\n+    \/\/ In the form of (String, int).\n+    private static Stream<Arguments> bigDecimalProvider() {\n+        return bigDecimals.stream();\n+    }\n+\n+    \/\/ Tests strings with length 800+. See test() for specific details.\n+    @ParameterizedTest\n+    @MethodSource(\"bigIntegerProvider\")\n+    public void bigIntegerParseTest(String longString, int multiplier) {\n+        test(longString, multiplier);\n+    }\n+\n+    \/\/ Returns 48 arrangements of bigInteger string values and multipliers\n+    \/\/ In the form of (String, int).\n+    private static Stream<Arguments> bigIntegerProvider() {\n+        return bigIntegers.stream();\n@@ -103,1 +146,12 @@\n-    static void test(DecimalFormat df, String s, int multiplier) {\n+    \/*\n+     * Tests that parsing a large BigDecimal\/BigInteger string value\n+     * will not throw a ParseException with setParseBigDecimal as true.\n+     * Parses with a variety of multiplier values. Then ensures that the parsed\n+     * value is the expected number.\n+     *\/\n+    private static void test(String longString, int multiplier) {\n+        \/\/ Reset DecimalFormat for a clean test\n+        df = new DecimalFormat();\n+        df.setParseBigDecimal(true);\n+        \/\/ wide enough to support the long string test data\n+        df.setMaximumFractionDigits(Integer.MAX_VALUE);\n@@ -106,9 +160,7 @@\n-        Number num = null;\n-        try {\n-            num = df.parse(s);\n-        }\n-        catch (ParseException e) {\n-            err = true;\n-            System.err.println(\"Failed: Exception occurred: \" + e.getMessage());\n-            return;\n-        }\n+        \/\/ Check parse and returned value. This was originally intended to ensure\n+        \/\/ a ParseException is not thrown\n+        Number parsedValue = assertDoesNotThrow(()-> df.parse(longString),\n+                \"Should not throw an Exception\");\n+        BigDecimal expectedValue = getExpected(longString, multiplier);\n+        assertEquals(expectedValue, parsedValue, \"With multiplier: \" + multiplier);\n+    }\n@@ -116,1 +168,4 @@\n-        BigDecimal bd = new BigDecimal(s);\n+    \/\/ Utility to get a numerically correct value of a long string.\n+    \/\/ Dependent on BigDecimal implementation\n+    private static BigDecimal getExpected(String longString, int multiplier) {\n+        BigDecimal expected = new BigDecimal(longString);\n@@ -118,1 +173,1 @@\n-           bd = bd.divide(new BigDecimal(multiplier));\n+            expected = expected.divide(new BigDecimal(multiplier));\n@@ -121,11 +176,1 @@\n-           bd = bd.divide(new BigDecimal(multiplier), RoundingMode.HALF_EVEN);\n-        }\n-        check(num, bd, multiplier);\n-    }\n-\n-    static void check(Number got, BigDecimal expected, int multiplier) {\n-        if (!got.equals(expected)) {\n-            err = true;\n-            System.err.println(\"Failed: got:\" + got +\n-                               \", expected: \" + expected +\n-                               \", multiplier=\" + multiplier);\n+            expected = expected.divide(new BigDecimal(multiplier), RoundingMode.HALF_EVEN);\n@@ -133,0 +178,1 @@\n+        return expected;\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/BigDecimalCompatibilityTest.java","additions":123,"deletions":77,"binary":false,"changes":200,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,3 @@\n- * @summary Confirm that the decimal separator is shown when explicitly requested.\n+ * @summary Confirm that the decimal separator is shown when explicitly requested\n+ *          (or not shown if not requested). Tests against double, long, BigDecimal,\n+ *          and BigInteger with a combination of different patterns.\n@@ -28,0 +30,1 @@\n+ * @run junit Bug4208135\n@@ -30,3 +33,5 @@\n-import java.math.*;\n-import java.text.*;\n-import java.util.*;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.text.DecimalFormat;\n+import java.util.Locale;\n+import java.util.stream.Stream;\n@@ -34,1 +39,5 @@\n-public class Bug4208135 {\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n@@ -36,1 +45,1 @@\n-    static DecimalFormat df;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n@@ -38,1 +47,1 @@\n-    static boolean err = false;\n+public class Bug4208135 {\n@@ -40,1 +49,3 @@\n-    static public void main(String[] args){\n+    private static DecimalFormat df;\n+    \/\/ Save JVM default Locale\n+    private static final Locale savedLocale = Locale.getDefault();\n@@ -42,1 +53,3 @@\n-        Locale defaultLoc = Locale.getDefault();\n+    \/\/ Set JVM default locale to US\n+    @BeforeAll\n+    static void init() {\n@@ -44,0 +57,1 @@\n+    }\n@@ -45,1 +59,41 @@\n-        df = new DecimalFormat();\n+    \/\/ Restore JVM default locale\n+    @AfterAll\n+    static void tearDown() {\n+        Locale.setDefault(savedLocale);\n+    }\n+\n+    \/\/ Confirm that decimal separator shown when formatting a number\n+    @ParameterizedTest\n+    @MethodSource(\"fractionalDigitsWithSeparatorProvider\")\n+    public void fractionalDigitsWithSeparatorTest(Number num, String expected) {\n+        df = getDF(\"0.#E0\", true);\n+        String actualFormatted = df.format(num);\n+        assertEquals(expected, actualFormatted, getErrMsg(\"0.#E0\", true));\n+    }\n+\n+    \/\/ Combination of numbers and a fractional exponent pattern with a separator\n+    private static Stream<Arguments> fractionalDigitsWithSeparatorProvider() {\n+        return Stream.of(\n+                Arguments.of(0.0, \"0.E0\"),\n+                Arguments.of(10.0, \"1.E1\"),\n+                Arguments.of(1000.0, \"1.E3\"),\n+                Arguments.of(0L, \"0.E0\"),\n+                Arguments.of(10L, \"1.E1\"),\n+                Arguments.of(1000L, \"1.E3\"),\n+                Arguments.of(new BigDecimal(\"0.0\"), \"0.E0\"),\n+                Arguments.of(new BigDecimal(\"10.0\"), \"1.E1\"),\n+                Arguments.of(new BigDecimal(\"1000.0\"), \"1.E3\"),\n+                Arguments.of(new BigInteger(\"00\"), \"0.E0\"),\n+                Arguments.of(new BigInteger(\"10\"), \"1.E1\"),\n+                Arguments.of(new BigInteger(\"1000\"), \"1.E3\")\n+        );\n+    }\n+\n+    \/\/ Confirm that decimal separator not shown when formatting a number\n+    @ParameterizedTest\n+    @MethodSource(\"fractionalDigitsNoSeparatorProvider\")\n+    public void fractionalDigitsNoSeparatorTest(Number num, String expected) {\n+        df = getDF(\"0.#E0\", false);\n+        String actualFormatted = df.format(num);\n+        assertEquals(expected, actualFormatted, getErrMsg(\"0.#E0\", false));\n+    }\n@@ -47,65 +101,78 @@\n-        df.applyPattern(\"0.#E0\");\n-\n-        df.setDecimalSeparatorAlwaysShown(true);\n-        checkFormat(0.0, \"0.E0\");\n-        checkFormat(10.0, \"1.E1\");\n-        checkFormat(1000.0, \"1.E3\");\n-        checkFormat(0L, \"0.E0\");\n-        checkFormat(10L, \"1.E1\");\n-        checkFormat(1000L, \"1.E3\");\n-        checkFormat(new BigDecimal(\"0.0\"), \"0.E0\");\n-        checkFormat(new BigDecimal(\"10.0\"), \"1.E1\");\n-        checkFormat(new BigDecimal(\"1000.0\"), \"1.E3\");\n-        checkFormat(new BigInteger(\"00\"), \"0.E0\");\n-        checkFormat(new BigInteger(\"10\"), \"1.E1\");\n-        checkFormat(new BigInteger(\"1000\"), \"1.E3\");\n-\n-        df.setDecimalSeparatorAlwaysShown(false);\n-        checkFormat(0.0, \"0E0\");\n-        checkFormat(10.0, \"1E1\");\n-        checkFormat(1000.0, \"1E3\");\n-        checkFormat(0L, \"0E0\");\n-        checkFormat(10L, \"1E1\");\n-        checkFormat(1000L, \"1E3\");\n-        checkFormat(new BigDecimal(\"0.0\"), \"0E0\");\n-        checkFormat(new BigDecimal(\"10.0\"), \"1E1\");\n-        checkFormat(new BigDecimal(\"1000.0\"), \"1E3\");\n-        checkFormat(new BigInteger(\"0\"), \"0E0\");\n-        checkFormat(new BigInteger(\"10\"), \"1E1\");\n-        checkFormat(new BigInteger(\"1000\"), \"1E3\");\n-\n-        df.applyPattern(\"0.###\");\n-\n-        df.setDecimalSeparatorAlwaysShown(true);\n-        checkFormat(0.0, \"0.\");\n-        checkFormat(10.0, \"10.\");\n-        checkFormat(1000.0, \"1000.\");\n-        checkFormat(0L, \"0.\");\n-        checkFormat(10L, \"10.\");\n-        checkFormat(1000L, \"1000.\");\n-        checkFormat(new BigDecimal(\"0.0\"), \"0.\");\n-        checkFormat(new BigDecimal(\"10.0\"), \"10.\");\n-        checkFormat(new BigDecimal(\"1000.0\"), \"1000.\");\n-        checkFormat(new BigInteger(\"0\"), \"0.\");\n-        checkFormat(new BigInteger(\"10\"), \"10.\");\n-        checkFormat(new BigInteger(\"1000\"), \"1000.\");\n-\n-        df.setDecimalSeparatorAlwaysShown(false);\n-        checkFormat(0.0, \"0\");\n-        checkFormat(10.0, \"10\");\n-        checkFormat(1000.0, \"1000\");\n-        checkFormat(0L, \"0\");\n-        checkFormat(10L, \"10\");\n-        checkFormat(1000L, \"1000\");\n-        checkFormat(new BigDecimal(\"0.0\"), \"0\");\n-        checkFormat(new BigDecimal(\"10.0\"), \"10\");\n-        checkFormat(new BigDecimal(\"1000.0\"), \"1000\");\n-        checkFormat(new BigInteger(\"0\"), \"0\");\n-        checkFormat(new BigInteger(\"10\"), \"10\");\n-        checkFormat(new BigInteger(\"1000\"), \"1000\");\n-\n-        Locale.setDefault(defaultLoc);\n-\n-        if (err) {\n-            throw new RuntimeException(\"Wrong format\/parse with DecimalFormat\");\n-        }\n+    \/\/ Combination of numbers and a fractional exponent pattern with no separator\n+    private static Stream<Arguments> fractionalDigitsNoSeparatorProvider() {\n+        return Stream.of(\n+                Arguments.of(0.0, \"0E0\"),\n+                Arguments.of(10.0, \"1E1\"),\n+                Arguments.of(1000.0, \"1E3\"),\n+                Arguments.of(0L, \"0E0\"),\n+                Arguments.of(10L, \"1E1\"),\n+                Arguments.of(1000L, \"1E3\"),\n+                Arguments.of(new BigDecimal(\"0.0\"), \"0E0\"),\n+                Arguments.of(new BigDecimal(\"10.0\"), \"1E1\"),\n+                Arguments.of(new BigDecimal(\"1000.0\"), \"1E3\"),\n+                Arguments.of(new BigInteger(\"00\"), \"0E0\"),\n+                Arguments.of(new BigInteger(\"10\"), \"1E1\"),\n+                Arguments.of(new BigInteger(\"1000\"), \"1E3\")\n+        );\n+    }\n+\n+    \/\/ Confirm that decimal separator shown when formatting a number\n+    @ParameterizedTest\n+    @MethodSource(\"noFractionalDigitsWithSeparatorProvider\")\n+    public void noFractionalDigitsWithSeparatorTest(Number num, String expected) {\n+        df = getDF(\"0.###\", true);\n+        String actualFormatted = df.format(num);\n+        assertEquals(expected, actualFormatted, getErrMsg(\"0.###\", true));\n+    }\n+\n+    \/\/ Combination of numbers and a non-fractional exponent pattern with a separator\n+    private static Stream<Arguments> noFractionalDigitsWithSeparatorProvider() {\n+        return Stream.of(\n+                Arguments.of(0.0, \"0.\"),\n+                Arguments.of(10.0, \"10.\"),\n+                Arguments.of(1000.0, \"1000.\"),\n+                Arguments.of(0L, \"0.\"),\n+                Arguments.of(10L, \"10.\"),\n+                Arguments.of(1000L, \"1000.\"),\n+                Arguments.of(new BigDecimal(\"0.0\"), \"0.\"),\n+                Arguments.of(new BigDecimal(\"10.0\"), \"10.\"),\n+                Arguments.of(new BigDecimal(\"1000.0\"), \"1000.\"),\n+                Arguments.of(new BigInteger(\"00\"), \"0.\"),\n+                Arguments.of(new BigInteger(\"10\"), \"10.\"),\n+                Arguments.of(new BigInteger(\"1000\"), \"1000.\")\n+        );\n+    }\n+\n+    \/\/ Confirm that decimal separator not shown when formatting a number\n+    @ParameterizedTest\n+    @MethodSource(\"noFractionalDigitsNoSeparatorProvider\")\n+    public void noFractionalDigitsNoSeparatorTest(Number num, String expected) {\n+        df = getDF(\"0.###\", false);\n+        String actualFormatted = df.format(num);\n+        assertEquals(expected, actualFormatted, getErrMsg(\"0.###\", false));\n+    }\n+\n+    \/\/ Combination of numbers and a non-fractional exponent pattern with no separator\n+    private static Stream<Arguments> noFractionalDigitsNoSeparatorProvider() {\n+        return Stream.of(\n+                Arguments.of(0.0, \"0\"),\n+                Arguments.of(10.0, \"10\"),\n+                Arguments.of(1000.0, \"1000\"),\n+                Arguments.of(0L, \"0\"),\n+                Arguments.of(10L, \"10\"),\n+                Arguments.of(1000L, \"1000\"),\n+                Arguments.of(new BigDecimal(\"0.0\"), \"0\"),\n+                Arguments.of(new BigDecimal(\"10.0\"), \"10\"),\n+                Arguments.of(new BigDecimal(\"1000.0\"), \"1000\"),\n+                Arguments.of(new BigInteger(\"00\"), \"0\"),\n+                Arguments.of(new BigInteger(\"10\"), \"10\"),\n+                Arguments.of(new BigInteger(\"1000\"), \"1000\")\n+        );\n+    }\n+\n+    \/\/ Creates clean DF and sets the pattern and separatorShown value\n+    private static DecimalFormat getDF(String pattern, boolean separatorShown) {\n+        df = new DecimalFormat();\n+        df.applyPattern(pattern);\n+        df.setDecimalSeparatorAlwaysShown(separatorShown);\n+        return df;\n@@ -114,12 +181,4 @@\n-    static void checkFormat(Number num, String expected) {\n-        String got = df.format(num);\n-        if (!got.equals(expected)) {\n-            err = true;\n-            System.err.println(\"    DecimalFormat format(\" +\n-                               num.getClass().getName() +\n-                               \") error:\" +\n-                               \"\\n\\tnumber:           \" + num +\n-                               \"\\n\\tSeparatorShown? : \" + df.isDecimalSeparatorAlwaysShown() +\n-                               \"\\n\\tgot:              \" + got +\n-                               \"\\n\\texpected:         \" + expected);\n-        }\n+    \/\/ Utility to get a helpful error message when values are not as expected\n+    private static String getErrMsg(String pattern, boolean separatorShown) {\n+        return String.format(\"Fails with pattern= %s, with separatorShown = %s\",\n+                pattern, separatorShown);\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/Bug4208135.java","additions":147,"deletions":88,"binary":false,"changes":235,"status":"modified"},{"patch":"@@ -27,1 +27,3 @@\n- * @summary Confirm that DecimalFormat can format a number with negative exponent number correctly.\n+ * @summary Confirm that DecimalFormat can format a number with a negative\n+ *          exponent number correctly. Tests also involve using a DecimalFormat\n+ *          with a custom pattern or a custom minus sign.\n@@ -31,3 +33,6 @@\n-import java.math.*;\n-import java.util.*;\n-import java.text.*;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.text.DecimalFormat;\n+import java.text.DecimalFormatSymbols;\n+import java.util.Locale;\n+import java.util.stream.Stream;\n@@ -35,1 +40,5 @@\n-import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n@@ -37,0 +46,1 @@\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n@@ -39,0 +49,10 @@\n+\/*\n+ * This bug is about exponential formatting. But I added test cases for:\n+ *   - Double and BigDecimal numbers which don't have exponent parts.\n+ *   - Long and BigInteger numbers which don't support exponential\n+ *     notation.\n+ * because there are few test cases for suffix and prefix.\n+ * And also, I added test cases to guarantee further formatting and\n+ * parsing using the same DecimalFormat instance will not change the\n+ * Number's value anymore.\n+ *\/\n@@ -41,3 +61,2 @@\n-    static DecimalFormat df;\n-    static DecimalFormatSymbols dfs;\n-    static boolean err = false;\n+    \/\/ Save JVM default Locale\n+    private static final Locale savedLocale = Locale.getDefault();\n@@ -45,2 +64,3 @@\n-    static public void main(String[] args) {\n-        Locale defaultLoc = Locale.getDefault();\n+    \/\/ Set JVM default Locale to US\n+    @BeforeAll\n+    static void init() {\n@@ -48,22 +68,0 @@\n-\n-        \/**\n-         * This bug is about exponential formatting. But I added test cases for:\n-         *   - Double and BigDecimal numbers which don't have exponent parts.\n-         *   - Long and BigInteger numbers which don't support exponential\n-         *     notation.\n-         * because there are few test cases for suffix and prefix.\n-         * And also, I added test cases to guarantee further formatting and\n-         * parsing using the same DecimalFormat instance will not change the\n-         * Number's value anymore.\n-         *\/\n-\n-        test_double();\n-        test_long();\n-        test_BigDecimal();\n-        test_BigInteger();\n-\n-        Locale.setDefault(defaultLoc);\n-\n-        if (err) {\n-            throw new RuntimeException(\"Wrong format with DecimalFormat\");\n-        }\n@@ -72,46 +70,4 @@\n-    static void test_double() {\n-        df = new DecimalFormat();\n-        dfs = df.getDecimalFormatSymbols();\n-\n-        \/* Test with default pattern *\/\n-        test(1234D,    \"1,234\");\n-        test(0.1234,  \"0.123\");     \/\/ rounded\n-        test(-1234D,   \"-1,234\");\n-        test(-0.1234, \"-0.123\");    \/\/ rounded\n-\n-        test(Double.POSITIVE_INFINITY, \"\\u221e\");\n-        test(Double.NEGATIVE_INFINITY, \"-\\u221e\");\n-        test(Double.NaN, \"\\ufffd\"); \/\/ without prefix and suffix\n-        test(0.0,  \"0\");\n-        test(-0.0, \"-0\");   \/\/ with the minus sign\n-\n-        \/* Specify a pattern and the minus sign. *\/\n-        prepareFormatter(\"<P>#.###E00<S>\", 'm');\n-        test(1234D,    \"<P>1.234E03<S>\");\n-        test(0.1234,  \"<P>1.234Em01<S>\");\n-        test(-1234D,   \"m<P>1.234E03<S>\");\n-        test(-0.1234, \"m<P>1.234Em01<S>\");\n-\n-        prepareFormatter(\"<P>#.###E00<S>;#.###E00\", 'm');\n-        test(1234D,    \"<P>1.234E03<S>\");\n-        test(0.1234,  \"<P>1.234Em01<S>\");\n-        test(-1234D,   \"1.234E03\");\n-        test(-0.1234, \"1.234Em01\");\n-\n-        prepareFormatter(\"#.###E00;<P>#.###E00<S>\", 'm');\n-        test(1234D,    \"1.234E03\");\n-        test(0.1234,  \"1.234Em01\");\n-        test(-1234D,   \"<P>1.234E03<S>\");\n-        test(-0.1234, \"<P>1.234Em01<S>\");\n-\n-        prepareFormatter(\"<P>#.###E00<S>;<p>-#.###E00<s>\", 'm');\n-        test(1234D,    \"<P>1.234E03<S>\");\n-        test(0.1234,  \"<P>1.234Em01<S>\");\n-        test(-1234D,   \"<p>m1.234E03<s>\");\n-        test(-0.1234, \"<p>m1.234Em01<s>\");\n-\n-        test(Double.POSITIVE_INFINITY, \"<P>\\u221e<S>\");\n-        test(Double.NEGATIVE_INFINITY, \"<p>m\\u221e<s>\");\n-        test(Double.NaN, \"\\ufffd\"); \/\/ without prefix and suffix\n-        test(0.0,  \"<P>0E00<S>\");\n-        test(-0.0, \"<p>m0E00<s>\");  \/\/ with the minus sign\n+    \/\/ Restore the original JVM default locale\n+    @AfterAll\n+    static void tearDown() {\n+        Locale.setDefault(savedLocale);\n@@ -120,30 +76,5 @@\n-    static void test_BigDecimal() {\n-        df = new DecimalFormat();\n-        dfs = df.getDecimalFormatSymbols();\n-\n-        \/* Test with default pattern *\/\n-        test(new BigDecimal(\"123456789012345678901234567890\"),\n-             \"123,456,789,012,345,678,901,234,567,890\");\n-        test(new BigDecimal(\"0.000000000123456789012345678901234567890\"),\n-             \"0\");\n-        test(new BigDecimal(\"-123456789012345678901234567890\"),\n-             \"-123,456,789,012,345,678,901,234,567,890\");\n-        test(new BigDecimal(\"-0.000000000123456789012345678901234567890\"),\n-              \"-0\");\n-\n-        test(new BigDecimal(\"0\"), \"0\");\n-        test(new BigDecimal(\"-0\"), \"0\");\n-\n-        \/* Specify a pattern and the minus sign. *\/\n-        prepareFormatter(\"<P>#.####################E00<S>;<p>-#.####################E00<s>\", 'm');\n-        test(new BigDecimal(\"123456789012345678901234567890\"),\n-             \"<P>1.23456789012345678901E29<S>\");\n-        test(new BigDecimal(\"0.000000000123456789012345678901234567890\"),\n-             \"<P>1.23456789012345678901Em10<S>\");\n-        test(new BigDecimal(\"-123456789012345678901234567890\"),\n-             \"<p>m1.23456789012345678901E29<s>\");\n-        test(new BigDecimal(\"-0.000000000123456789012345678901234567890\"),\n-              \"<p>m1.23456789012345678901Em10<s>\");\n-\n-        test(new BigDecimal(\"0\"), \"<P>0E00<S>\");\n-        test(new BigDecimal(\"-0\"), \"<P>0E00<S>\");\n+    \/\/ Check that negative exponent number recognized for doubles\n+    @ParameterizedTest\n+    @MethodSource(\"doubles\")\n+    public void doubleTest(Number num, String str, DecimalFormat df) {\n+        test(num, str, df);\n@@ -152,18 +83,43 @@\n-    static void test_long() {\n-        df = new DecimalFormat();\n-        dfs = df.getDecimalFormatSymbols();\n-\n-        \/* Test with default pattern *\/\n-        test(123456789L,  \"123,456,789\");\n-        test(-123456789L, \"-123,456,789\");\n-\n-        test(0L, \"0\");\n-        test(-0L, \"0\");\n-\n-        \/* Specify a pattern and the minus sign. *\/\n-        prepareFormatter(\"<P>#,###<S>;<p>-#,###<s>\", 'm');\n-        test(123456789L,  \"<P>123,456,789<S>\");\n-        test(-123456789L, \"<p>m123,456,789<s>\");\n-\n-        test(0L, \"<P>0<S>\");\n-        test(-0L, \"<P>0<S>\");\n+    \/\/ Provides a double to be formatted, which is compared to the expected String.\n+    \/\/ Additionally, provides a DecimalFormat to do the formatting (can have a custom\n+    \/\/ pattern and minus sign). Given in the form (double, String, DecimalFormat).\n+    private static Stream<Arguments> doubles() {\n+        DecimalFormat defaultDf = new DecimalFormat();\n+        DecimalFormat customDf1 = getDecimalFormat(\"<P>#.###E00<S>\", 'm');\n+        DecimalFormat customDf2 = getDecimalFormat(\"<P>#.###E00<S>;#.###E00\", 'm');\n+        DecimalFormat customDf3 = getDecimalFormat(\"#.###E00;<P>#.###E00<S>\", 'm');\n+        DecimalFormat customDf4 = getDecimalFormat(\"<P>#.###E00<S>;<p>-#.###E00<s>\", 'm');\n+        return Stream.of(\n+                \/\/ Test with default pattern\n+                Arguments.of(1234D,    \"1,234\", defaultDf),\n+                Arguments.of(0.1234,  \"0.123\", defaultDf),    \/\/ rounded\n+                Arguments.of(-1234D,   \"-1,234\", defaultDf),\n+                Arguments.of(-0.1234, \"-0.123\", defaultDf),    \/\/ rounded\n+                Arguments.of(Double.POSITIVE_INFINITY, \"\\u221e\", defaultDf),\n+                Arguments.of(Double.NEGATIVE_INFINITY, \"-\\u221e\", defaultDf),\n+                Arguments.of(Double.NaN, \"\\ufffd\", defaultDf), \/\/ without prefix and suffix\n+                Arguments.of(0.0,  \"0\", defaultDf),\n+                Arguments.of(-0.0, \"-0\", defaultDf),   \/\/ with the minus sign\n+                \/\/ Test with a pattern and the minus sign\n+                Arguments.of(1234D,    \"<P>1.234E03<S>\", customDf1),\n+                Arguments.of(0.1234,  \"<P>1.234Em01<S>\", customDf1),\n+                Arguments.of(-1234D,   \"m<P>1.234E03<S>\", customDf1),\n+                Arguments.of(-0.1234, \"m<P>1.234Em01<S>\", customDf1),\n+                Arguments.of(1234D,    \"<P>1.234E03<S>\", customDf2),\n+                Arguments.of(0.1234,  \"<P>1.234Em01<S>\", customDf2),\n+                Arguments.of(-1234D,   \"1.234E03\", customDf2),\n+                Arguments.of(-0.1234, \"1.234Em01\", customDf2),\n+                Arguments.of(1234D,    \"1.234E03\", customDf3),\n+                Arguments.of(0.1234,  \"1.234Em01\", customDf3),\n+                Arguments.of(-1234D,   \"<P>1.234E03<S>\", customDf3),\n+                Arguments.of(-0.1234, \"<P>1.234Em01<S>\", customDf3),\n+                Arguments.of(1234D,    \"<P>1.234E03<S>\", customDf4),\n+                Arguments.of(0.1234,  \"<P>1.234Em01<S>\", customDf4),\n+                Arguments.of(-1234D,   \"<p>m1.234E03<s>\", customDf4),\n+                Arguments.of(-0.1234, \"<p>m1.234Em01<s>\", customDf4),\n+                Arguments.of(Double.POSITIVE_INFINITY, \"<P>\\u221e<S>\", customDf4),\n+                Arguments.of(Double.NEGATIVE_INFINITY, \"<p>m\\u221e<s>\", customDf4),\n+                Arguments.of(Double.NaN, \"\\ufffd\", customDf4), \/\/ without prefix and suffix\n+                Arguments.of(0.0,  \"<P>0E00<S>\", customDf4),\n+                Arguments.of(-0.0, \"<p>m0E00<s>\", customDf4) \/\/ with the minus sign\n+        );\n@@ -172,3 +128,6 @@\n-    static void test_BigInteger() {\n-        df = new DecimalFormat();\n-        dfs = df.getDecimalFormatSymbols();\n+    \/\/ Check that negative exponent number recognized for longs\n+    @ParameterizedTest\n+    @MethodSource(\"longs\")\n+    public void longTest(Number num, String str, DecimalFormat df) {\n+        test(num, str, df);\n+    }\n@@ -176,5 +135,19 @@\n-        \/* Test with default pattern *\/\n-        test(new BigInteger(\"123456789012345678901234567890\"),\n-             \"123,456,789,012,345,678,901,234,567,890\");\n-        test(new BigInteger(\"-123456789012345678901234567890\"),\n-             \"-123,456,789,012,345,678,901,234,567,890\");\n+    \/\/ Same as doubles() data provider, but with long values\n+    \/\/ Given in the form (long, String, DecimalFormat).\n+    private static Stream<Arguments> longs() {\n+        DecimalFormat defaultDf = new DecimalFormat();\n+        DecimalFormat customDf = getDecimalFormat(\n+                \"<P>#,###<S>;<p>-#,###<s>\", 'm');\n+        return Stream.of(\n+                \/\/ Test with default pattern\n+                Arguments.of(123456789L,  \"123,456,789\", defaultDf),\n+                Arguments.of(-123456789L, \"-123,456,789\", defaultDf),\n+                Arguments.of(0L, \"0\", defaultDf),\n+                Arguments.of(-0L, \"0\", defaultDf),\n+                \/\/ Test with a pattern and the minus sign\n+                Arguments.of(123456789L,  \"<P>123,456,789<S>\", customDf),\n+                Arguments.of(-123456789L, \"<p>m123,456,789<s>\", customDf),\n+                Arguments.of(0L, \"<P>0<S>\", customDf),\n+                Arguments.of(-0L, \"<P>0<S>\", customDf)\n+        );\n+    }\n@@ -182,2 +155,6 @@\n-        test(new BigInteger(\"0\"), \"0\");\n-        test(new BigInteger(\"-0\"), \"0\");\n+    \/\/ Check that negative exponent number recognized for bigDecimals\n+    @ParameterizedTest\n+    @MethodSource(\"bigDecimals\")\n+    public void bigDecimalTest(Number num, String str, DecimalFormat df) {\n+        test(num, str, df);\n+    }\n@@ -185,6 +162,31 @@\n-        \/* Specify a pattern and the minus sign. *\/\n-        prepareFormatter(\"<P>#,###<S>;<p>-#,###<s>\", 'm');\n-        test(new BigInteger(\"123456789012345678901234567890\"),\n-             \"<P>123,456,789,012,345,678,901,234,567,890<S>\");\n-        test(new BigInteger(\"-123456789012345678901234567890\"),\n-             \"<p>m123,456,789,012,345,678,901,234,567,890<s>\");\n+    \/\/ Same as doubles() data provider, but with BigDecimal values\n+    \/\/ Given in the form (BigDecimal, String, DecimalFormat).\n+    private static Stream<Arguments> bigDecimals() {\n+        DecimalFormat defaultDf = new DecimalFormat();\n+        DecimalFormat customDf = getDecimalFormat(\n+                \"<P>#.####################E00<S>;<p>-#.####################E00<s>\", 'm');\n+        return Stream.of(\n+                \/\/ Test with default pattern\n+                Arguments.of(new BigDecimal(\"123456789012345678901234567890\"),\n+                        \"123,456,789,012,345,678,901,234,567,890\", defaultDf),\n+                Arguments.of(new BigDecimal(\"0.000000000123456789012345678901234567890\"),\n+                        \"0\", defaultDf),\n+                Arguments.of(new BigDecimal(\"-123456789012345678901234567890\"),\n+                        \"-123,456,789,012,345,678,901,234,567,890\", defaultDf),\n+                Arguments.of(new BigDecimal(\"-0.000000000123456789012345678901234567890\"),\n+                        \"-0\", defaultDf),\n+                Arguments.of(new BigDecimal(\"0\"), \"0\", defaultDf),\n+                Arguments.of(new BigDecimal(\"-0\"), \"0\", defaultDf),\n+                \/\/ Test with a pattern and the minus sign\n+                Arguments.of(new BigDecimal(\"123456789012345678901234567890\"),\n+                        \"<P>1.23456789012345678901E29<S>\", customDf),\n+                Arguments.of(new BigDecimal(\"0.000000000123456789012345678901234567890\"),\n+                        \"<P>1.23456789012345678901Em10<S>\", customDf),\n+                Arguments.of(new BigDecimal(\"-123456789012345678901234567890\"),\n+                        \"<p>m1.23456789012345678901E29<s>\", customDf),\n+                Arguments.of(new BigDecimal(\"-0.000000000123456789012345678901234567890\"),\n+                        \"<p>m1.23456789012345678901Em10<s>\", customDf),\n+                Arguments.of(new BigDecimal(\"0\"), \"<P>0E00<S>\", customDf),\n+                Arguments.of(new BigDecimal(\"-0\"), \"<P>0E00<S>\", customDf)\n+        );\n+    }\n@@ -192,2 +194,5 @@\n-        test(new BigInteger(\"0\"), \"<P>0<S>\");\n-        test(new BigInteger(\"-0\"), \"<P>0<S>\");\n+    \/\/ Check that negative exponent number recognized for bigIntegers\n+    @ParameterizedTest\n+    @MethodSource(\"bigIntegers\")\n+    public void bigIntegerTest(Number num, String str, DecimalFormat df) {\n+        test(num, str, df);\n@@ -196,5 +201,22 @@\n-    static void prepareFormatter(String pattern, char minusSign) {\n-        dfs = df.getDecimalFormatSymbols();\n-        df.applyPattern(pattern);\n-        dfs.setMinusSign(minusSign);\n-        df.setDecimalFormatSymbols(dfs);\n+    \/\/ Same as doubles() data provider, but with BigInteger values\n+    \/\/ Given in the form (BigInteger, String, DecimalFormat).\n+    private static Stream<Arguments> bigIntegers() {\n+        DecimalFormat defaultDf = new DecimalFormat();\n+        DecimalFormat customDf = getDecimalFormat(\n+                \"<P>#,###<S>;<p>-#,###<s>\", 'm');\n+        return Stream.of(\n+                \/\/ Test with default pattern\n+                Arguments.of(new BigInteger(\"123456789012345678901234567890\"),\n+                        \"123,456,789,012,345,678,901,234,567,890\", defaultDf),\n+                Arguments.of(new BigInteger(\"-123456789012345678901234567890\"),\n+                        \"-123,456,789,012,345,678,901,234,567,890\", defaultDf),\n+                Arguments.of(new BigInteger(\"0\"), \"0\", defaultDf),\n+                Arguments.of(new BigInteger(\"-0\"), \"0\", defaultDf),\n+                \/\/ Test with a pattern and the minus sign\n+                Arguments.of(new BigInteger(\"123456789012345678901234567890\"),\n+                        \"<P>123,456,789,012,345,678,901,234,567,890<S>\", customDf),\n+                Arguments.of(new BigInteger(\"-123456789012345678901234567890\"),\n+                        \"<p>m123,456,789,012,345,678,901,234,567,890<s>\", customDf),\n+                Arguments.of(new BigInteger(\"0\"), \"<P>0<S>\", customDf),\n+                Arguments.of(new BigInteger(\"-0\"), \"<P>0<S>\", customDf)\n+        );\n@@ -203,1 +225,3 @@\n-    static void test(Number num, String str) {\n+    \/\/ Check that the formatted value is correct and also check that\n+    \/\/ it can be round-tripped via parse() and format()\n+    private static void test(Number num, String str, DecimalFormat df) {\n@@ -205,10 +229,2 @@\n-        if (!formatted.equals(str)) {\n-            err = true;\n-            System.err.println(\"    DecimalFormat format(\" +\n-                               num.getClass().getName() +\n-                               \") error: \\n\\tnumber: \" + num +\n-                               \"\\n\\tminus sign: \" + dfs.getMinusSign() +\n-                               \"\\n\\tgot:        \" + formatted +\n-                               \"\\n\\texpected:   \" + str);\n-            return;\n-        }\n+        assertEquals(str, formatted, String.format(\"DecimalFormat format(%s) \" +\n+                \"Error: number: %s, minus sign: %s\", num.getClass().getName(), num, df.getDecimalFormatSymbols().getMinusSign()));\n@@ -219,0 +235,6 @@\n+        testRoundTrip(formatted, str, num, df);\n+    }\n+\n+    \/\/ Test that a parsed value can be round-tripped via format() and parse()\n+    private static void testRoundTrip(String formatted, String str,\n+                                      Number num, DecimalFormat df) {\n@@ -224,12 +246,11 @@\n-            if (!parsed1.equals(parsed2)) {\n-                err = true;\n-                System.err.println(\"    DecimalFormat roundtrip parse(\" +\n-                                   num.getClass().getName() +\n-                                   \") error: \\n\\toriginal number:  \" + str +\n-                                   \"\\n\\tparsed number:    \" + parsed1 +\n-                                   \"  (\" + parsed1.getClass().getName() + \")\" +\n-                                   \"\\n\\tformatted number: \" + formatted +\n-                                   \"\\n\\tre-parsed number: \" + parsed2 +\n-                                   \"  (\" + parsed2.getClass().getName() + \")\" +\n-                                   \"\\n\\tminus sign: \" + dfs.getMinusSign());\n-            }\n+            assertEquals(parsed2, parsed1, \"\"\"\n+                            DecimalFormat round trip parse(%s) error:\n+                                original number: %s\n+                                parsed number: %s\n+                                (%s)\n+                                formatted number: %s\n+                                re-parsed number: %s\n+                                (%s)\n+                                minus sign: %s\n+                            \"\"\".formatted(num.getClass().getName(), str, parsed1, parsed1.getClass().getName(),\n+                                    formatted, parsed2, parsed2.getClass().getName(), df.getDecimalFormatSymbols().getMinusSign()));\n@@ -238,11 +259,11 @@\n-            err = true;\n-            System.err.println(\"    DecimalFormat parse(\" +\n-                               num.getClass().getName() +\n-                               \") threw an Exception:  \" + e.getMessage() +\n-                               \"\\n\\toriginal number:  \" + str +\n-                               \"\\n\\tparsed number   : \" + parsed1 +\n-                               \"  (\" + parsed1.getClass().getName() + \")\" +\n-                               \"\\n\\tformatted number: \" + formatted +\n-                               \"\\n\\tre-parsed number: \" + parsed2 +\n-                               \"  (\" + parsed2.getClass().getName() + \")\" +\n-                               \"\\n\\tminus sign: \" + dfs.getMinusSign());\n+            fail(\"\"\"\n+                    DecimalFormat parse(%s) threw an Exception: %s\n+                        original number: %s\n+                        parsed number: %s\n+                        (%s)\n+                        formatted number: %s\n+                        re-parsed number: %s\n+                        (%s)\n+                        minus sign: %s\n+                    \"\"\".formatted(num.getClass().getName(), e.getMessage(), str, parsed1, parsed1.getClass().getName(),\n+                            formatted, parsed2, parsed2.getClass().getName(), df.getDecimalFormatSymbols().getMinusSign()));\n@@ -251,0 +272,10 @@\n+\n+    \/\/ Set up custom DecimalFormat with DecimalFormatSymbols\n+    private static DecimalFormat getDecimalFormat(String pattern, char minusSign) {\n+        DecimalFormat df = new DecimalFormat();\n+        DecimalFormatSymbols dfs = df.getDecimalFormatSymbols();\n+        df.applyPattern(pattern);\n+        dfs.setMinusSign(minusSign);\n+        df.setDecimalFormatSymbols(dfs);\n+        return df;\n+    }\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/Bug4838107.java","additions":214,"deletions":183,"binary":false,"changes":397,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,3 @@\n- * and which are between Long.MIN_VALUE and Long.MAX_VALUE are returned as Long(not double).\n+ *          and which are between Long.MIN_VALUE and Long.MAX_VALUE are returned\n+ *          as Long(not double).\n+ * @run junit Bug4944439\n@@ -31,2 +33,0 @@\n-import java.math.BigDecimal;\n-import java.math.BigInteger;\n@@ -34,0 +34,1 @@\n+import java.util.ArrayList;\n@@ -35,0 +36,1 @@\n+import java.util.stream.Stream;\n@@ -36,4 +38,5 @@\n-public class Bug4944439 {\n-\n-    static boolean err = false;\n-    static DecimalFormat df;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n@@ -41,4 +44,3 @@\n-    public static void main(String[] args) throws Exception {\n-\n-        Locale defaultLoc = Locale.getDefault();\n-        Locale.setDefault(Locale.US);\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertInstanceOf;\n@@ -46,3 +48,1 @@\n-        df = new DecimalFormat();\n-        String s = \"-9223372036854775809\";      \/\/ Long.MIN_VALUE-1\n-        check_Double(s);\n+public class Bug4944439 {\n@@ -50,3 +50,3 @@\n-        test(Long.MIN_VALUE, Long.MIN_VALUE+10);\n-        test(-10, 10);\n-        test(Long.MAX_VALUE-10, Long.MAX_VALUE-1);\n+    \/\/ Save JVM default locale\n+    private static final Locale savedLocale = Locale.getDefault();\n+    private static final DecimalFormat df = new DecimalFormat();\n@@ -54,4 +54,5 @@\n-        s = \"9223372036854775807.00\";   \/\/ Long.MAX_VALUE\n-        check_Long(s);\n-        s = \"9223372036854775808\";      \/\/ Long.MAX_VALUE+1\n-        check_Double(s);\n+    \/\/ Set JVM default locale to US for testing\n+    @BeforeAll\n+    static void initAll() {\n+        Locale.setDefault(Locale.US);\n+    }\n@@ -59,4 +60,5 @@\n-        s = \"-0.0\";\n-        check_Double(s);\n-        s = \"0.0\";\n-        check_Long(s);\n+    \/\/ Restore JVM default locale\n+    @AfterAll\n+    static void tearDownAll() {\n+        Locale.setDefault(savedLocale);\n+    }\n@@ -64,1 +66,14 @@\n-        Locale.setDefault(defaultLoc);\n+    \/\/ Check return type and value returned by DecimalFormat.parse() for longs\n+    @ParameterizedTest\n+    @MethodSource(\"longs\")\n+    public void parseLongTest(String s) {\n+        \/\/ This was originally intended to ensure a ParseException is not thrown\n+        Number parsedNumber = assertDoesNotThrow(() -> df.parse(s),\n+                \"DecimalFormat.parse(\\\"%s\\\") should not throw an Exception\");\n+        assertInstanceOf(Long.class, parsedNumber,\n+                \"DecimalFormat.parse(\\\"%s\\\") did not return Long\");\n+        \/\/ Grab integer portion of value\n+        Long expectedVal = Long.valueOf(s.substring(0, s.indexOf('.')));\n+        assertEquals(parsedNumber, expectedVal,\n+                \"DecimalFormat.parse(\\\"%s\\\") returned numerically incorrect value\");\n+    }\n@@ -66,3 +81,9 @@\n-        if (err) {\n-            throw new RuntimeException(\"Wrong parsing with DecimalFormat\");\n-        }\n+    \/\/ Test some values between Long.MIN_VALUE and Long.MAX_VALUE\n+    private static Stream<String> longs() {\n+        ArrayList<String> longs = new ArrayList<>();\n+        addLongData(Long.MIN_VALUE, Long.MIN_VALUE+10, longs);\n+        addLongData(-10, 10, longs);\n+        addLongData(Long.MAX_VALUE-10, Long.MAX_VALUE-1, longs);\n+        longs.add(\"9223372036854775807.00\");\n+        longs.add(\"0.0\");\n+        return longs.stream();\n@@ -71,1 +92,2 @@\n-    private static void test(long from, long to) throws Exception {\n+    \/\/ Utility to add values between parameters(long, to) to testLongs ArrayList\n+    private static void addLongData(long from, long to, ArrayList<String> testLongs){\n@@ -73,1 +95,1 @@\n-            check_Long(Long.toString(l) + \".00\");\n+            testLongs.add(l + \".00\");\n@@ -77,16 +99,12 @@\n-    private static void check_Long(String s) throws Exception {\n-        Number number = df.parse(s);\n-        if (!(number instanceof Long)) {\n-            err = true;\n-            System.err.println(\"Failed: DecimalFormat.parse(\\\"\" + s +\n-                \"\\\") should return a Long, but returned a \" +\n-                number.getClass().getName());\n-        }\n-\n-        int index = s.indexOf('.');\n-        Long l = Long.valueOf(s.substring(0, index));\n-        if (!l.equals(number)) {\n-            err = true;\n-            System.err.println(\"Failed: DecimalFormat.parse(\" + s +\n-                \") should return a Long(\" + l + \"), but returned \" + number);\n-        }\n+    \/\/ Check return type and value returned by DecimalFormat.parse() for doubles\n+    @ParameterizedTest\n+    @MethodSource(\"doubles\")\n+    public void parseDoubleTest(String s) {\n+        \/\/ This was originally intended to ensure a ParseException is not thrown\n+        Number parsedNumber = assertDoesNotThrow(() -> df.parse(s),\n+                \"DecimalFormat.parse(\\\"%s\\\") should not throw an Exception\");\n+        assertInstanceOf(Double.class, parsedNumber,\n+                \"DecimalFormat.parse(\\\"%s\\\") did not return Double\");\n+        Double expectedVal = Double.valueOf(s);\n+        assertEquals(parsedNumber, expectedVal,\n+                \"DecimalFormat.parse(\\\"%s\\\") returned numerically incorrect value\");\n@@ -95,15 +113,7 @@\n-    private static void check_Double(String s) throws Exception {\n-        Number number = df.parse(s);\n-        if (!(number instanceof Double)) {\n-            err = true;\n-            System.err.println(\"Failed: DecimalFormat.parse(\\\"\" + s +\n-                \"\\\") should return a Double, but returned a \" +\n-                number.getClass().getName());\n-        }\n-\n-        Double d = Double.valueOf(s);\n-        if (!d.equals(number)) {\n-            err = true;\n-            System.err.println(\"Failed: DecimalFormat.parse(\" + s +\n-                \") should return a Double(\" + d + \"), but returned \" + number);\n-        }\n+    \/\/ Check values not between Long.MIN_VALUE and Long.MAX_VALUE\n+    private static Stream<String> doubles() {\n+        return Stream.of(\n+                \"-9223372036854775809\", \/\/ Long.MIN_VALUE-1\n+                \"9223372036854775808\", \/\/ Long.MAX_VALUE+1\n+                \"-0.0\"\n+        );\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/Bug4944439.java","additions":73,"deletions":63,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,1 @@\n-\/**\n+\/*\n@@ -27,1 +27,3 @@\n- * @summary Make sure that any subclass of Number can be formatted using DecimalFormat.format().\n+ * @summary Make sure that any subclass of Number can be formatted using\n+ *          DecimalFormat.format() without throwing an exception.\n+ * @run junit Bug4990596\n@@ -32,0 +34,4 @@\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+\n@@ -34,2 +40,6 @@\n-    public static void main(String[] args) {\n-        new DecimalFormat().format(new MutableInteger(0));\n+    \/\/ Test that a custom subclass of Number can be formatted by\n+    \/\/ DecimalFormat without throwing an IllegalArgumentException\n+    @Test\n+    public void formatSubclassedNumberTest() {\n+        assertDoesNotThrow(() -> new DecimalFormat().format(new MutableInteger(0)),\n+                \"DecimalFormat.format() should support subclasses of Number\");\n@@ -38,0 +48,2 @@\n+    \/\/ A custom subclass of Number. Prior to this fix, if an instance of this\n+    \/\/ class was formatted by DecimalFormat, an exception would be thrown.\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/Bug4990596.java","additions":17,"deletions":5,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,2 @@\n+ *          That is, make sure they are not treated as a double when formatted\n+ *          anymore (which can result in the loss of precision).\n@@ -28,0 +30,1 @@\n+ * @run junit Bug6278616\n@@ -34,1 +37,5 @@\n-import java.util.Locale;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n@@ -38,3 +45,1 @@\n-    static final int[] ints = {\n-        Integer.MIN_VALUE, -1, 0, 1, Integer.MAX_VALUE\n-    };\n+    private static final NumberFormat nf = NumberFormat.getInstance();\n@@ -42,3 +47,10 @@\n-    static final long[] longs = {\n-        Long.MIN_VALUE, -1, 0, 1, Long.MAX_VALUE\n-    };\n+    \/\/ Test that NumberFormat formats numerically equivalent int\n+    \/\/ and AtomicInteger values the same\n+    @ParameterizedTest\n+    @MethodSource(\"ints\")\n+    public void formattedAtomicIntTest(int testInt) {\n+        String formattedInt = nf.format(testInt);\n+        String formattedAtomicInt = nf.format(new AtomicInteger(testInt));\n+        assertEquals(formattedAtomicInt, formattedInt, \"Formatting numerically\" +\n+                \" equivalent AtomicInteger and int should produce the same String value\");\n+    }\n@@ -46,2 +58,4 @@\n-    public static void main(String[] args) {\n-        NumberFormat nf = NumberFormat.getInstance();\n+    \/\/ Various int values\n+    private static int[] ints() {\n+        return new int[] { Integer.MIN_VALUE, -1, 0, 1, Integer.MAX_VALUE};\n+    }\n@@ -49,9 +63,10 @@\n-        for (int j = 0; j < ints.length; j++) {\n-            String s_i = nf.format(ints[j]);\n-            String s_ai = nf.format(new AtomicInteger(ints[j]));\n-            if (!s_i.equals(s_ai)) {\n-                throw new RuntimeException(\"format(AtomicInteger \" + s_ai +\n-                                           \") doesn't equal format(Integer \" +\n-                                           s_i + \")\");\n-            }\n-        }\n+    \/\/ Test that NumberFormat formats numerically equivalent long\n+    \/\/ and AtomicLong values the same\n+    @ParameterizedTest\n+    @MethodSource(\"longs\")\n+    public void formattedAtomicLongTest(long testLong) {\n+        String formattedLong = nf.format(testLong);\n+        String formattedAtomicLong = nf.format(new AtomicLong(testLong));\n+        assertEquals(formattedAtomicLong, formattedLong, \"Formatting numerically\" +\n+                \" equivalent AtomicLong and long should produce the same String value\");\n+    }\n@@ -59,9 +74,3 @@\n-        for (int j = 0; j < longs.length; j++) {\n-            String s_l = nf.format(longs[j]);\n-            String s_al = nf.format(new AtomicLong(longs[j]));\n-            if (!s_l.equals(s_al)) {\n-                throw new RuntimeException(\"format(AtomicLong \" + s_al +\n-                                           \") doesn't equal format(Long \" +\n-                                           s_l + \")\");\n-            }\n-        }\n+    \/\/ Various long values\n+    private static long[] longs() {\n+        return new long[] { Long.MIN_VALUE, -1, 0, 1, Long.MAX_VALUE};\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/Bug6278616.java","additions":37,"deletions":28,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+ * @run junit Bug8132125\n@@ -31,2 +32,6 @@\n-import java.text.*;\n-import java.util.*;\n+import java.text.NumberFormat;\n+import java.util.Locale;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n@@ -35,1 +40,4 @@\n-    public static void main(String[] args) {\n+\n+    \/\/ Ensure the CLDRConverter does not omit the Swiss number elements\n+    @Test\n+    public void swissNumElementsTest() {\n@@ -39,1 +47,2 @@\n-        String expected = \"54\\u2019839\\u2019483.142\"; \/\/ i.e. \"\\u2019\" as decimal separator, \"\\u2019\" as grouping separator\n+        \/\/ \"\\u002E\" as decimal separator, \"\\u2019\" as grouping separator\n+        String expected = \"54\\u2019839\\u2019483.142\";\n@@ -41,3 +50,1 @@\n-        if (!actual.equals(expected)) {\n-            throw new RuntimeException(\"incorrect for de_CH: \" + expected + \" vs. actual \" + actual);\n-        }\n+        assertEquals(expected, actual, \"incorrect number elements for de_CH\");\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/Bug8132125.java","additions":15,"deletions":8,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ *          Tests both COMPAT and CLDR data.\n@@ -29,2 +30,2 @@\n- * @run main\/othervm -Djava.locale.providers=COMPAT CurrencyFormat COMPAT\n- * @run main\/othervm -Djava.locale.providers=CLDR CurrencyFormat CLDR\n+ * @run junit\/othervm -Djava.locale.providers=COMPAT CurrencyFormat\n+ * @run junit\/othervm -Djava.locale.providers=CLDR CurrencyFormat\n@@ -35,0 +36,1 @@\n+import java.io.IOException;\n@@ -37,0 +39,2 @@\n+import java.text.ParseException;\n+import java.util.ArrayList;\n@@ -45,0 +49,7 @@\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n@@ -48,1 +59,4 @@\n-    private static boolean isCompat;\n+    \/\/ Expected data is switched depending on COMPAT or CLDR\n+    \/\/ currencySymbolsTest() is only ran for COMPAT\n+    private static final boolean isCompat =\n+            \"COMPAT\".equals(System.getProperty(\"java.locale.providers\"));\n@@ -50,4 +64,15 @@\n-    public static void main(String[] args) throws Exception {\n-        isCompat = \"COMPAT\".equals(args[0]);\n-        testFormatting();\n-        testSymbols();\n+    \/\/ Tests the formatting of data for COMPAT + CLDR under various currencies\n+    \/\/ Using a NumberFormat generated by getCurrencyInstance()\n+    @ParameterizedTest\n+    @MethodSource(\"currencyFormatDataProvider\")\n+    public void currencyFormatTest(String expected, Currency currency,\n+                                   NumberFormat format, Locale locale) {\n+        if (currency != null) {\n+            format.setCurrency(currency);\n+            int digits = currency.getDefaultFractionDigits();\n+            format.setMinimumFractionDigits(digits);\n+            format.setMaximumFractionDigits(digits);\n+        }\n+        String result = format.format(1234.56);\n+        assertEquals(expected, result, String.format(\"Failed with locale: %s%s\",\n+                locale, (currency == null ? \", default currency\" : (\", currency: \" + currency))));\n@@ -56,2 +81,4 @@\n-    static void testFormatting() {\n-        boolean failed = false;\n+    \/\/ Generate a combination of expected data for 1234.56 formatted\n+    \/\/ under various currencies\/locale provider\/locale\n+    private static Stream<Arguments> currencyFormatDataProvider() {\n+        ArrayList<Arguments> data = new ArrayList<Arguments>();\n@@ -59,7 +86,7 @@\n-            Locale.US,\n-            Locale.JAPAN,\n-            Locale.GERMANY,\n-            Locale.ITALY,\n-            Locale.of(\"it\", \"IT\", \"EURO\"),\n-            Locale.forLanguageTag(\"de-AT\"),\n-            Locale.forLanguageTag(\"fr-CH\"),\n+                Locale.US,\n+                Locale.JAPAN,\n+                Locale.GERMANY,\n+                Locale.ITALY,\n+                Locale.of(\"it\", \"IT\", \"EURO\"),\n+                Locale.forLanguageTag(\"de-AT\"),\n+                Locale.forLanguageTag(\"fr-CH\"),\n@@ -68,5 +95,5 @@\n-            null,\n-            Currency.getInstance(\"USD\"),\n-            Currency.getInstance(\"JPY\"),\n-            Currency.getInstance(\"DEM\"),\n-            Currency.getInstance(\"EUR\"),\n+                null,\n+                Currency.getInstance(\"USD\"),\n+                Currency.getInstance(\"JPY\"),\n+                Currency.getInstance(\"DEM\"),\n+                Currency.getInstance(\"EUR\"),\n@@ -74,8 +101,8 @@\n-        String[][] expecteds = {\n-            {\"$1,234.56\", \"$1,234.56\", \"JPY1,235\", \"DEM1,234.56\", \"EUR1,234.56\"},\n-            {\"\\uFFE51,235\", \"USD1,234.56\", \"\\uFFE51,235\", \"DEM1,234.56\", \"EUR1,234.56\"},\n-            {\"1.234,56 \\u20AC\", \"1.234,56 USD\", \"1.235 JPY\", \"1.234,56 DM\", \"1.234,56 \\u20AC\"},\n-            {\"\\u20AC 1.234,56\", \"USD 1.234,56\", \"JPY 1.235\", \"DEM 1.234,56\", \"\\u20AC 1.234,56\"},\n-            {\"\\u20AC 1.234,56\", \"USD 1.234,56\", \"JPY 1.235\", \"DEM 1.234,56\", \"\\u20AC 1.234,56\"},\n-            {\"\\u20AC 1.234,56\", \"USD 1.234,56\", \"JPY 1.235\", \"DEM 1.234,56\", \"\\u20AC 1.234,56\"},\n-            {\"SFr. 1'234.56\", \"USD 1'234.56\", \"JPY 1'235\", \"DEM 1'234.56\", \"EUR 1'234.56\"},\n+        String[][] expectedCOMPATData = {\n+                {\"$1,234.56\", \"$1,234.56\", \"JPY1,235\", \"DEM1,234.56\", \"EUR1,234.56\"},\n+                {\"\\uFFE51,235\", \"USD1,234.56\", \"\\uFFE51,235\", \"DEM1,234.56\", \"EUR1,234.56\"},\n+                {\"1.234,56 \\u20AC\", \"1.234,56 USD\", \"1.235 JPY\", \"1.234,56 DM\", \"1.234,56 \\u20AC\"},\n+                {\"\\u20AC 1.234,56\", \"USD 1.234,56\", \"JPY 1.235\", \"DEM 1.234,56\", \"\\u20AC 1.234,56\"},\n+                {\"\\u20AC 1.234,56\", \"USD 1.234,56\", \"JPY 1.235\", \"DEM 1.234,56\", \"\\u20AC 1.234,56\"},\n+                {\"\\u20AC 1.234,56\", \"USD 1.234,56\", \"JPY 1.235\", \"DEM 1.234,56\", \"\\u20AC 1.234,56\"},\n+                {\"SFr. 1'234.56\", \"USD 1'234.56\", \"JPY 1'235\", \"DEM 1'234.56\", \"EUR 1'234.56\"},\n@@ -83,8 +110,8 @@\n-        String[][] expecteds_cldr = {\n-            {\"$1,234.56\", \"$1,234.56\", \"\\u00a51,235\", \"DEM1,234.56\", \"\\u20ac1,234.56\"},\n-            {\"\\uFFE51,235\", \"$1,234.56\", \"\\uFFE51,235\", \"DEM1,234.56\", \"\\u20ac1,234.56\"},\n-            {\"1.234,56\\u00a0\\u20ac\", \"1.234,56\\u00a0$\", \"1.235\\u00a0\\u00a5\", \"1.234,56\\u00a0DM\", \"1.234,56\\u00a0\\u20ac\"},\n-            {\"1.234,56\\u00a0\\u20ac\", \"1.234,56\\u00a0USD\", \"1.235\\u00a0JPY\", \"1.234,56\\u00a0DEM\", \"1.234,56\\u00a0\\u20ac\"},\n-            {\"1.234,56\\u00a0\\u20ac\", \"1.234,56\\u00a0USD\", \"1.235\\u00a0JPY\", \"1.234,56\\u00a0DEM\", \"1.234,56\\u00a0\\u20ac\"},\n-            {\"\\u20ac\\u00a01.234,56\", \"$\\u00a01.234,56\", \"\\u00a5\\u00a01.235\", \"DM\\u00a01.234,56\", \"\\u20ac\\u00a01.234,56\"},\n-            {\"1\\u202f234.56\\u00a0CHF\", \"1\\u202f234.56\\u00a0$US\", \"1\\u202f235\\u00a0JPY\", \"1\\u202f234.56\\u00a0DEM\", \"1\\u202f234.56\\u00a0\\u20ac\"},\n+        String[][] expectedCLDRData = {\n+                {\"$1,234.56\", \"$1,234.56\", \"\\u00a51,235\", \"DEM1,234.56\", \"\\u20ac1,234.56\"},\n+                {\"\\uFFE51,235\", \"$1,234.56\", \"\\uFFE51,235\", \"DEM1,234.56\", \"\\u20ac1,234.56\"},\n+                {\"1.234,56\\u00a0\\u20ac\", \"1.234,56\\u00a0$\", \"1.235\\u00a0\\u00a5\", \"1.234,56\\u00a0DM\", \"1.234,56\\u00a0\\u20ac\"},\n+                {\"1.234,56\\u00a0\\u20ac\", \"1.234,56\\u00a0USD\", \"1.235\\u00a0JPY\", \"1.234,56\\u00a0DEM\", \"1.234,56\\u00a0\\u20ac\"},\n+                {\"1.234,56\\u00a0\\u20ac\", \"1.234,56\\u00a0USD\", \"1.235\\u00a0JPY\", \"1.234,56\\u00a0DEM\", \"1.234,56\\u00a0\\u20ac\"},\n+                {\"\\u20ac\\u00a01.234,56\", \"$\\u00a01.234,56\", \"\\u00a5\\u00a01.235\", \"DM\\u00a01.234,56\", \"\\u20ac\\u00a01.234,56\"},\n+                {\"1\\u202f234.56\\u00a0CHF\", \"1\\u202f234.56\\u00a0$US\", \"1\\u202f235\\u00a0JPY\", \"1\\u202f234.56\\u00a0DEM\", \"1\\u202f234.56\\u00a0\\u20ac\"},\n@@ -92,1 +119,0 @@\n-\n@@ -98,15 +124,2 @@\n-                String expected = isCompat ? expecteds[i][j] : expecteds_cldr[i][j];\n-                if (currency != null) {\n-                    format.setCurrency(currency);\n-                    int digits = currency.getDefaultFractionDigits();\n-                    format.setMinimumFractionDigits(digits);\n-                    format.setMaximumFractionDigits(digits);\n-                }\n-                String result = format.format(1234.56);\n-                if (!result.equals(expected)) {\n-                    failed = true;\n-                    System.out.println(\"FAIL: Locale \" + locale\n-                        + (currency == null ? \", default currency\" : (\", currency: \" + currency))\n-                        + \", expected: \" + expected\n-                        + \", actual: \" + result);\n-                }\n+                String expected = isCompat ? expectedCOMPATData[i][j] : expectedCLDRData[i][j];\n+                data.add(Arguments.of(expected, currency, format, locale));\n@@ -115,4 +128,1 @@\n-\n-        if (failed) {\n-            throw new RuntimeException();\n-        }\n+        return data.stream();\n@@ -121,1 +131,5 @@\n-    static void testSymbols() throws Exception {\n+    \/\/ Compares the expected currency symbol of a locale to the value returned by\n+    \/\/ DecimalFormatSymbols.getCurrencySymbol().\n+    @ParameterizedTest\n+    @MethodSource(\"currencySymbolsDataProvider\")\n+    public void currencySymbolsTest(String expected, Locale locale) throws ParseException {\n@@ -123,2 +137,1 @@\n-            \/\/ For COMPAT only.\n-            return;\n+            return; \/\/ For COMPAT only.\n@@ -126,0 +139,13 @@\n+        if (expected == null) {\n+            System.out.println(\"Warning: No expected currency symbol defined for locale \" + locale);\n+        } else {\n+            \/\/ Reserved for when a currency will change its symbol at a given time in the future\n+            if (expected.contains(\";\")) {\n+                expected = getFutureSymbol(expected);\n+            }\n+            DecimalFormatSymbols symbols = DecimalFormatSymbols.getInstance(locale);\n+            String result = symbols.getCurrencySymbol();\n+            assertEquals(expected, result, \"Wrong currency symbol for locale \" +\n+                        locale + \", expected: \" + expected + \", got: \" + result);\n+        }\n+    }\n@@ -127,1 +153,6 @@\n-        FileInputStream stream = new FileInputStream(new File(System.getProperty(\"test.src\", \".\"), \"CurrencySymbols.properties\"));\n+    \/\/ Grabs the custom CurrencySymbols.properties and loads the file into a Properties\n+    \/\/ instance. Building the data set, which consists of the currency symbol for the locale.\n+    private static Stream<Arguments> currencySymbolsDataProvider() throws IOException {\n+        ArrayList<Arguments> data = new ArrayList<Arguments>();\n+        FileInputStream stream = new FileInputStream(new File(\n+                System.getProperty(\"test.src\", \".\"), \"CurrencySymbols.properties\"));\n@@ -131,2 +162,0 @@\n-        SimpleDateFormat format = null;\n-\n@@ -134,4 +163,1 @@\n-        for (int i = 0; i < locales.length; i++) {\n-            Locale locale = locales[i];\n-            DecimalFormatSymbols symbols = DecimalFormatSymbols.getInstance(locale);\n-            String result = symbols.getCurrencySymbol();\n+        for (Locale locale : locales) {\n@@ -139,0 +165,4 @@\n+            data.add(Arguments.of(expected, locale));\n+        }\n+        return data.stream();\n+    }\n@@ -140,25 +170,11 @@\n-            if (expected == null) {\n-                System.out.println(\"Warning: No expected currency symbol defined for locale \" + locale);\n-            } else {\n-                    if (expected.contains(\";\")) {\n-                        StringTokenizer tokens = new StringTokenizer(expected, \";\");\n-                        int tokensCount = tokens.countTokens();\n-\n-                        if (tokensCount == 3) {\n-                            expected = tokens.nextToken();\n-                            if (format == null) {\n-                                format = new SimpleDateFormat(\"yyyy-MM-dd-HH-mm-ss\", Locale.US);\n-                                format.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n-                                format.setLenient(false);\n-                            }\n-\n-                            if (format.parse(tokens.nextToken()).getTime() < System.currentTimeMillis()) {\n-                                expected = tokens.nextToken();\n-                            }\n-                        }\n-                    }\n-\n-                    if (!expected.equals(result)) {\n-                        throw new RuntimeException(\"Wrong currency symbol for locale \" +\n-                            locale + \", expected: \" + expected + \", got: \" + result);\n-                    }\n+    \/\/ Utility to grab the future symbol if in the right format and date cut-over allows\n+    private static String getFutureSymbol(String expected) throws ParseException {\n+        StringTokenizer tokens = new StringTokenizer(expected, \";\");\n+        int tokensCount = tokens.countTokens();\n+        if (tokensCount == 3) {\n+            expected = tokens.nextToken();\n+            SimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd-HH-mm-ss\", Locale.US);\n+            format.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n+            format.setLenient(false);\n+            if (format.parse(tokens.nextToken()).getTime() < System.currentTimeMillis()) {\n+                expected = tokens.nextToken();\n@@ -167,0 +183,1 @@\n+        return expected;\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/CurrencyFormat.java","additions":109,"deletions":92,"binary":false,"changes":201,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,1 @@\n-\/**\n+\/*\n@@ -27,1 +27,0 @@\n- * @summary Currency decimal marker incorrect for Peru.\n@@ -29,1 +28,2 @@\n- * @run main\/othervm -Djava.locale.providers=JRE TestPeruCurrencyFormat\n+ * @summary Currency decimal marker incorrect for Peru (COMPAT).\n+ * @run junit\/othervm -Djava.locale.providers=COMPAT TestPeruCurrencyFormat\n@@ -35,0 +35,4 @@\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n@@ -37,1 +41,3 @@\n-    public static void main(String[] args) {\n+    \/\/ Confirm correct decimal marker for Peru locale on COMPAT\n+    @Test\n+    public void peruDecimalMarketCOMPAT() {\n@@ -42,4 +48,2 @@\n-\n-        if (!s.equals(expected)) {\n-            throw new RuntimeException(\"Currency format for Peru failed, expected \" + expected + \", got \" + s);\n-        }\n+        assertEquals(expected, s,\n+                \"Currency format for Peru failed, expected \" + expected + \", got \" + s);\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/TestPeruCurrencyFormat.java","additions":13,"deletions":9,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import java.util.stream.IntStream;\n@@ -51,5 +52,6 @@\n-        BitSet bs = new BitSet();\n-        IntPredicate ibs = ImmutableBitSetPredicate.of(bs);\n-        assertThrows(IndexOutOfBoundsException.class, () -> {\n-            ibs.test(-1);\n-        });\n+        IntStream.of(0, 127, 128, 129, 143, 4711).forEach(k -> {\n+                    BitSet bs = new BitSet(k);\n+                    IntPredicate ibs = ImmutableBitSetPredicate.of(bs);\n+                    assertFalse(ibs.test(-1));\n+                    assertFalse(ibs.test(Integer.MIN_VALUE));\n+                });\n@@ -60,1 +62,5 @@\n-        BitSet bs = createReference(147);\n+        IntStream.of(0, 16, 127, 128, 129, 143, 4711).forEach(k -> basic(k));\n+    }\n+\n+    void basic(int length) {\n+        BitSet bs = createReference(length);\n@@ -67,4 +73,8 @@\n-        for (int i = Long.BYTES - 1; i < Long.BYTES + 2; i++) {\n-            BitSet bs = createReference(i);\n-            for (int j = bs.length() - 1; j > Long.BYTES - 1; j++) {\n-                bs.clear(j);\n+        IntStream.of(0, 16, 127, 128, 129, 143, 4711).forEach(k -> {\n+            for (int i = Long.BYTES - 1; i < Long.BYTES + 2; i++) {\n+                BitSet bs = createReference(k + i);\n+                for (int j = bs.length() - 1; j > Long.BYTES - 1; j--) {\n+                    bs.clear(j);\n+                }\n+                IntPredicate ibs = ImmutableBitSetPredicate.of(bs);\n+                test(bs, ibs);\n@@ -72,3 +82,1 @@\n-            IntPredicate ibs = ImmutableBitSetPredicate.of(bs);\n-            test(bs, ibs);\n-        }\n+        });\n@@ -84,1 +92,1 @@\n-        BitSet result = new BitSet();\n+        BitSet result = new BitSet(length);\n","filename":"test\/jdk\/java\/util\/BitSet\/ImmutableBitSet.java","additions":22,"deletions":14,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -9,3 +9,0 @@\n-\n-# To compile and run tests that use the foreign memory access API\n-enablePreview=true\n","filename":"test\/jdk\/java\/util\/stream\/test\/TEST.properties","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- * @ignore This test has brittle dependencies on an external working python.\n+ * @ignore 8303920 This test has brittle dependencies on an external working python.\n","filename":"test\/jdk\/java\/util\/zip\/DataDescriptorSignatureMissing.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -137,1 +137,1 @@\n-            = System.getProperty(\"test.security.protocol\", \"TLS\");\n+            = System.getProperty(\"test.security.protocol\");\n@@ -741,1 +741,3 @@\n-                    case \"DTLSv1.1\":\n+                    case \"DTLS\":\n+                    case \"DTLSv1.2\":\n+                    case \"TLS\":\n@@ -748,0 +750,3 @@\n+                    default:\n+                        throw new Error(\"Test error: Unsupported test \" +\n+                                \"security protocol: \" + TESTED_SECURITY_PROTOCOL);\n","filename":"test\/jdk\/javax\/net\/ssl\/TLSCommon\/SSLEngineTestCase.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorLoadStoreTests.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorLoadStoreTests.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorLoadStoreTests.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorLoadStoreTests.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorLoadStoreTests.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorLoadStoreTests.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorLoadStoreTests.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorLoadStoreTests.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorLoadStoreTests.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorLoadStoreTests.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorLoadStoreTests.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorLoadStoreTests.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorLoadStoreTests.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorLoadStoreTests.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/FloatMaxVectorLoadStoreTests.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorLoadStoreTests.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorLoadStoreTests.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorLoadStoreTests.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorLoadStoreTests.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorLoadStoreTests.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorLoadStoreTests.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorLoadStoreTests.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorLoadStoreTests.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorLoadStoreTests.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorLoadStoreTests.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorLoadStoreTests.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorLoadStoreTests.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorLoadStoreTests.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorLoadStoreTests.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorLoadStoreTests.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/VectorReshapeTests.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/X-LoadStoreTest.java.template","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -355,0 +355,40 @@\n+\/*\n+ * @test id=affirmtrustcommercialca\n+ * @bug 8040012\n+ * @summary Interoperability tests with AffirmTrust Commercial CA\n+ * @library \/test\/lib\n+ * @build jtreg.SkippedException ValidatePathWithURL CAInterop\n+ * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop affirmtrustcommercialca OCSP\n+ * @run main\/othervm -Djava.security.debug=certpath CAInterop affirmtrustcommercialca CRL\n+ *\/\n+\n+\/*\n+ * @test id=affirmtrustnetworkingca\n+ * @bug 8040012\n+ * @summary Interoperability tests with AffirmTrust Networking CA\n+ * @library \/test\/lib\n+ * @build jtreg.SkippedException ValidatePathWithURL CAInterop\n+ * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop affirmtrustnetworkingca OCSP\n+ * @run main\/othervm -Djava.security.debug=certpath CAInterop affirmtrustnetworkingca CRL\n+ *\/\n+\n+\/*\n+ * @test id=affirmtrustpremiumca\n+ * @bug 8040012\n+ * @summary Interoperability tests with AffirmTrust Premium CA\n+ * @library \/test\/lib\n+ * @build jtreg.SkippedException ValidatePathWithURL CAInterop\n+ * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop affirmtrustpremiumca OCSP\n+ * @run main\/othervm -Djava.security.debug=certpath CAInterop affirmtrustpremiumca CRL\n+ *\/\n+\n+\/*\n+ * @test id=affirmtrustpremiumeccca\n+ * @bug 8040012\n+ * @summary Interoperability tests with AffirmTrust Premium ECC CA\n+ * @library \/test\/lib\n+ * @build jtreg.SkippedException ValidatePathWithURL CAInterop\n+ * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop affirmtrustpremiumeccca OCSP\n+ * @run main\/othervm -Djava.security.debug=certpath CAInterop affirmtrustpremiumeccca CRL\n+ *\/\n+\n@@ -482,0 +522,14 @@\n+            \/\/ These are listed at https:\/\/www.affirmtrust.com\/resources\/\n+            case \"affirmtrustcommercialca\" ->\n+                    new CATestURLs(\"https:\/\/validcommercial.affirmtrust.com\",\n+                            \"https:\/\/revokedcommercial.affirmtrust.com\");\n+            case \"affirmtrustnetworkingca\" ->\n+                    new CATestURLs(\"https:\/\/validnetworking.affirmtrust.com\",\n+                            \"https:\/\/revokednetworking.affirmtrust.com\");\n+            case \"affirmtrustpremiumca\" ->\n+                    new CATestURLs(\"https:\/\/validpremium.affirmtrust.com\",\n+                            \"https:\/\/revokedpremium.affirmtrust.com\");\n+            case \"affirmtrustpremiumeccca\" ->\n+                    new CATestURLs(\"https:\/\/validpremiumecc.affirmtrust.com\",\n+                            \"https:\/\/revokedpremiumecc.affirmtrust.com\");\n+\n","filename":"test\/jdk\/security\/infra\/java\/security\/cert\/CertPathValidator\/certification\/CAInterop.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -311,2 +311,1 @@\n-            String classPath = System.getProperty(\"test.classes\");\n-            ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n+            ProcessBuilder pb = ProcessTools.createTestJvm(\n@@ -314,1 +313,1 @@\n-                \"-cp\", classPath, className, mainArgsIdentifier);\n+                className, mainArgsIdentifier);\n","filename":"test\/jdk\/sun\/jvmstat\/monitor\/MonitoredVm\/MonitorVmStartTerminate.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -392,0 +392,4 @@\n+                    \/\/ if the exception is thrown before connecting to the\n+                    \/\/ server, the test will time out and the exception will\n+                    \/\/ be lost\/hidden.\n+                    e.printStackTrace(System.err);\n","filename":"test\/jdk\/sun\/security\/pkcs11\/KeyStore\/ClientAuth.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -82,0 +82,5 @@\n+    \/\/ Version of the NSS artifact. This coincides with the version of\n+    \/\/ the NSS version\n+    private static final String NSS_BUNDLE_VERSION = \"3.91\";\n+    private static final String NSSLIB = \"jpg.tests.jdk.nsslib\";\n+\n@@ -810,3 +815,0 @@\n-            case \"Windows-x86-32\":\n-                return fetchNssLib(WINDOWS_X86.class);\n-\n@@ -819,0 +821,3 @@\n+            case \"MacOSX-aarch64-64\":\n+                return fetchNssLib(MACOSX_AARCH64.class);\n+\n@@ -822,0 +827,3 @@\n+            case \"Linux-aarch64-64\":\n+                return fetchNssLib(LINUX_AARCH64.class);\n+\n@@ -831,2 +839,2 @@\n-                    .findAny().get().getValue() + File.separator + \"nsslib\"\n-                    + File.separator;\n+                    .findAny().get().getValue() + File.separator + \"nss\"\n+                    + File.separator + \"lib\" + File.separator;\n@@ -934,1 +942,1 @@\n-            organization = \"jpg.tests.jdk.nsslib\",\n+            organization = NSSLIB,\n@@ -936,1 +944,1 @@\n-            revision = \"3.46-VS2017\",\n+            revision = NSS_BUNDLE_VERSION,\n@@ -942,3 +950,3 @@\n-            organization = \"jpg.tests.jdk.nsslib\",\n-            name = \"nsslib-windows_x86\",\n-            revision = \"3.46-VS2017\",\n+            organization = NSSLIB,\n+            name = \"nsslib-macosx_x64\",\n+            revision = NSS_BUNDLE_VERSION,\n@@ -946,1 +954,1 @@\n-    private static class WINDOWS_X86 {\n+    private static class MACOSX_X64 {\n@@ -950,3 +958,3 @@\n-            organization = \"jpg.tests.jdk.nsslib\",\n-            name = \"nsslib-macosx_x64\",\n-            revision = \"3.46\",\n+            organization = NSSLIB,\n+            name = \"nsslib-macosx_aarch64\",\n+            revision = NSS_BUNDLE_VERSION,\n@@ -954,1 +962,1 @@\n-    private static class MACOSX_X64 {\n+    private static class MACOSX_AARCH64 {\n@@ -958,1 +966,1 @@\n-            organization = \"jpg.tests.jdk.nsslib\",\n+            organization = NSSLIB,\n@@ -960,1 +968,1 @@\n-            revision = \"3.46\",\n+            revision = NSS_BUNDLE_VERSION,\n@@ -964,0 +972,9 @@\n+\n+    @Artifact(\n+            organization = NSSLIB,\n+            name = \"nsslib-linux_aarch64\",\n+            revision = NSS_BUNDLE_VERSION,\n+            extension = \"zip\"\n+    )\n+    private static class LINUX_AARCH64{\n+    }\n","filename":"test\/jdk\/sun\/security\/pkcs11\/PKCS11Test.java","additions":34,"deletions":17,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n- * and checks that sun.tools.ProcessHelper.getMainClass(pid) method returns a correct main class.                                                                                                                               return a .\n+ * and checks that sun.tools.ProcessHelper.getMainClass(pid) method returns a correct main class.\n@@ -55,0 +55,1 @@\n+ * @requires vm.flagless\n","filename":"test\/jdk\/sun\/tools\/jcmd\/TestProcessHelper.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,3 +63,2 @@\n-            String[] params = new String[0];;\n-            LingeredApp.startAppExactJvmOpts(app1, params);\n-            LingeredApp.startAppExactJvmOpts(app2, params);\n+            LingeredApp.startApp(app1);\n+            LingeredApp.startApp(app2);\n@@ -92,3 +91,2 @@\n-            String[] params = new String[0];\n-            LingeredApp.startAppExactJvmOpts(app1, params);\n-            LingeredApp.startAppExactJvmOpts(app2, params);\n+            LingeredApp.startApp(app1);\n+            LingeredApp.startApp(app2);\n","filename":"test\/jdk\/sun\/tools\/jinfo\/JInfoTest.java","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+ * @requires vm.flagless\n@@ -63,3 +64,1 @@\n-        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n-            \"-cp\",\n-            System.getProperty(\"test.class.path\"),\n+        ProcessBuilder pb = ProcessTools.createTestJvm(\n","filename":"test\/jdk\/sun\/tools\/jstat\/JStatInterval.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -50,0 +50,2 @@\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n@@ -52,1 +54,0 @@\n-\n@@ -86,0 +87,4 @@\n+\n+        public void putAll(Map<String, String> map) {\n+            map.entrySet().forEach(e -> put(e.getKey(), () -> e.getValue()));\n+        }\n@@ -138,0 +143,1 @@\n+        map.putAll(xOptFlags()); \/\/ -Xmx4g -> @requires vm.opt.x.Xmx == \"4g\" )\n@@ -605,3 +611,4 @@\n-        ProcessBuilder pb = new ProcessBuilder(Container.ENGINE_COMMAND, \"ps\");\n-        Map<String, String> logFileNames = redirectOutputToLogFile(\"checkDockerSupport(): <container> ps\",\n-                                                      pb, \"container-ps\");\n+        ProcessBuilder pb = new ProcessBuilder(\"which\", Container.ENGINE_COMMAND);\n+        Map<String, String> logFileNames =\n+            redirectOutputToLogFile(\"checkDockerSupport(): which <container-engine>\",\n+                                                      pb, \"which-container\");\n@@ -664,3 +671,1 @@\n-        List<String> allFlags = new ArrayList<String>();\n-        Collections.addAll(allFlags, System.getProperty(\"test.vm.opts\", \"\").trim().split(\"\\\\s+\"));\n-        Collections.addAll(allFlags, System.getProperty(\"test.java.opts\", \"\").trim().split(\"\\\\s+\"));\n+        List<String> allFlags = allFlags().toList();\n@@ -713,0 +718,25 @@\n+    private Stream<String> allFlags() {\n+        return Stream.of((System.getProperty(\"test.vm.opts\", \"\") + \" \" + System.getProperty(\"test.java.opts\", \"\")).trim().split(\"\\\\s+\"));\n+    }\n+\n+    \/**\n+     * Parses extra options, options that start with -X excluding the\n+     * bare -X option (as it is not considered an extra option).\n+     * Ignores extra options not starting with -X\n+     *\n+     * This could be improved to handle extra options not starting\n+     * with -X as well as \"standard\" options.\n+     *\/\n+    private Map<String, String> xOptFlags() {\n+        return allFlags()\n+            .filter(s -> s.startsWith(\"-X\") && !s.startsWith(\"-XX:\") && !s.equals(\"-X\"))\n+            .map(s -> s.replaceFirst(\"-\", \"\"))\n+            .map(flag -> flag.splitWithDelimiters(\"[:0123456789]\", 2))\n+            .collect(Collectors.toMap(a -> \"vm.opt.x.\" + a[0],\n+                                      a -> (a.length == 1)\n+                                      ? \"true\" \/\/ -Xnoclassgc\n+                                      : (a[1].equals(\":\")\n+                                         ? a[2]            \/\/ [\"-XshowSettings\", \":\", \"system\"]\n+                                         : a[1] + a[2]))); \/\/ [\"-Xmx\", \"4\", \"g\"]\n+    }\n+\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":37,"deletions":7,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -69,0 +69,1 @@\n+                    <div class=\"horizontal-scroll\">\n@@ -135,0 +136,1 @@\n+                    <div class=\"horizontal-scroll\">\n@@ -136,0 +138,1 @@\n+                    <\/div>\n@@ -141,0 +144,1 @@\n+                    <div class=\"horizontal-scroll\">\n@@ -146,0 +150,1 @@\n+                    <\/div>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testAnnotationTypes\/TestAnnotationTypes.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -196,1 +196,1 @@\n-        checkOutput(\"pkg\/TestClass.html\", false,\n+        checkOutput(\"pkg\/TestClass.html\", true,\n@@ -208,1 +208,1 @@\n-                    <div class=\"deprecation-comment\">class_test4 passes. This is the second sentence\\\n+                    <div class=\"deprecation-comment\">class_test5 passes. This is the second sentence\\\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testDeprecatedDocs\/TestDeprecatedDocs.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -280,0 +280,1 @@\n+                <div class=\"horizontal-scroll\">\n@@ -339,0 +340,1 @@\n+                <div class=\"horizontal-scroll\">\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testDirectedInheritance\/TestDirectedInheritance.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -389,0 +389,1 @@\n+                    <\/div>\n@@ -395,0 +396,1 @@\n+                    <\/div>\n@@ -404,0 +406,1 @@\n+                    <\/div>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testHtmlDefinitionListTag\/TestHtmlDefinitionListTag.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,1 +79,1 @@\n-                    <header role=\"banner\" class=\"flex-header\">\n+                    <header role=\"banner\">\n@@ -109,1 +109,1 @@\n-                    <header role=\"banner\" class=\"flex-header\">\n+                    <header role=\"banner\">\n@@ -147,1 +147,1 @@\n-                    <header role=\"banner\" class=\"flex-header\">\n+                    <header role=\"banner\">\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testHtmlLandmarkRegions\/TestHtmlLandmarkRegions.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-                    <header role=\"banner\" class=\"flex-header\">\n+                    <header role=\"banner\">\n@@ -102,1 +102,1 @@\n-                    <header role=\"banner\" class=\"flex-header\">\n+                    <header role=\"banner\">\n@@ -134,1 +134,1 @@\n-                    <header role=\"banner\" class=\"flex-header\">\n+                    <header role=\"banner\">\n@@ -167,1 +167,1 @@\n-                    <header role=\"banner\" class=\"flex-header\">\n+                    <header role=\"banner\">\n@@ -188,1 +188,1 @@\n-                    <header role=\"banner\" class=\"flex-header\">\n+                    <header role=\"banner\">\n@@ -217,1 +217,1 @@\n-                    <header role=\"banner\" class=\"flex-header\">\n+                    <header role=\"banner\">\n@@ -236,1 +236,1 @@\n-                    <header role=\"banner\" class=\"flex-header\">\n+                    <header role=\"banner\">\n@@ -260,1 +260,1 @@\n-                    <header role=\"banner\" class=\"flex-header\">\n+                    <header role=\"banner\">\n@@ -295,1 +295,1 @@\n-                    <header role=\"banner\" class=\"flex-header\">\n+                    <header role=\"banner\">\n@@ -300,1 +300,0 @@\n-                    <div class=\"flex-content\">\n@@ -322,1 +321,1 @@\n-                    <header role=\"banner\" class=\"flex-header\">\n+                    <header role=\"banner\">\n@@ -353,1 +352,1 @@\n-                    <header role=\"banner\" class=\"flex-header\">\n+                    <header role=\"banner\">\n@@ -403,1 +402,1 @@\n-                    <header role=\"banner\" class=\"flex-header\">\n+                    <header role=\"banner\">\n@@ -444,1 +443,1 @@\n-                    <header role=\"banner\" class=\"flex-header\">\n+                    <header role=\"banner\">\n@@ -476,1 +475,1 @@\n-                    <header role=\"banner\" class=\"flex-header\">\n+                    <header role=\"banner\">\n@@ -503,1 +502,1 @@\n-                    <header role=\"banner\" class=\"flex-header\">\n+                    <header role=\"banner\">\n@@ -530,1 +529,1 @@\n-                    <header role=\"banner\" class=\"flex-header\">\n+                    <header role=\"banner\">\n@@ -568,1 +567,1 @@\n-                    <header role=\"banner\" class=\"flex-header\">\n+                    <header role=\"banner\">\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testHtmlVersion\/TestHtmlVersion.java","additions":17,"deletions":18,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -131,0 +131,1 @@\n+                    <div class=\"horizontal-scroll\">\n@@ -150,0 +151,1 @@\n+                    <div class=\"horizontal-scroll\">\n@@ -160,0 +162,1 @@\n+                    <div class=\"horizontal-scroll\">\n@@ -314,0 +317,1 @@\n+                <div class=\"horizontal-scroll\">\n@@ -320,0 +324,1 @@\n+                <\/div>\n@@ -325,0 +330,1 @@\n+                <div class=\"horizontal-scroll\">\n@@ -332,0 +338,1 @@\n+                <\/div>\n@@ -337,0 +344,1 @@\n+                <div class=\"horizontal-scroll\">\n@@ -343,0 +351,1 @@\n+                <\/div>\n@@ -348,0 +357,1 @@\n+                <div class=\"horizontal-scroll\">\n@@ -350,0 +360,1 @@\n+                <\/div>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testInterface\/TestInterface.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -110,0 +110,1 @@\n+                    <div class=\"horizontal-scroll\">\n@@ -117,0 +118,1 @@\n+                    <div class=\"horizontal-scroll\">\n@@ -124,0 +126,1 @@\n+                    <div class=\"horizontal-scroll\">\n@@ -136,0 +139,1 @@\n+                    <div class=\"horizontal-scroll\">\n@@ -148,0 +152,1 @@\n+                    <div class=\"horizontal-scroll\">\n@@ -156,0 +161,1 @@\n+                    <div class=\"horizontal-scroll\">\n@@ -173,0 +179,1 @@\n+                    <div class=\"horizontal-scroll\">\n@@ -265,0 +272,1 @@\n+                        <div class=\"horizontal-scroll\">\n@@ -276,0 +284,1 @@\n+                        <\/div>\n@@ -281,0 +290,1 @@\n+                        <div class=\"horizontal-scroll\">\n@@ -292,0 +302,1 @@\n+                        <\/div>\n@@ -297,0 +308,1 @@\n+                        <div class=\"horizontal-scroll\">\n@@ -308,0 +320,1 @@\n+                        <\/div>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testJavaFX\/TestJavaFX.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -157,0 +157,1 @@\n+                                <div class=\"horizontal-scroll\">\n@@ -166,0 +167,1 @@\n+                                <\/div>\n@@ -179,0 +181,1 @@\n+                                <div class=\"horizontal-scroll\">\n@@ -185,0 +188,1 @@\n+                                <\/div>\n@@ -202,0 +206,1 @@\n+                                <div class=\"horizontal-scroll\">\n@@ -211,0 +216,1 @@\n+                                <\/div>\n@@ -223,0 +229,1 @@\n+                                <div class=\"horizontal-scroll\">\n@@ -229,0 +236,1 @@\n+                                <\/div>\n@@ -245,0 +253,1 @@\n+                                <div class=\"horizontal-scroll\">\n@@ -252,0 +261,1 @@\n+                                <\/div>\n@@ -265,0 +275,1 @@\n+                                <div class=\"horizontal-scroll\">\n@@ -272,0 +283,1 @@\n+                                <\/div>\n@@ -423,1 +435,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testJavaFX\/TestJavaFXCombo.java","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -92,0 +92,1 @@\n+                    <div class=\"horizontal-scroll\">\n@@ -108,0 +109,1 @@\n+                    <\/div>\n@@ -156,0 +158,1 @@\n+                    <div class=\"horizontal-scroll\">\n@@ -172,0 +175,1 @@\n+                    <\/div>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testJavaFX\/TestJavaFXMissingPropComments.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -123,0 +123,1 @@\n+                    <div class=\"horizontal-scroll\">\n@@ -127,0 +128,1 @@\n+                    <\/div>\n@@ -145,0 +147,1 @@\n+                    <div class=\"horizontal-scroll\">\n@@ -172,0 +175,1 @@\n+                    <div class=\"horizontal-scroll\">\n@@ -176,0 +180,1 @@\n+                    <\/div>\n@@ -188,0 +193,1 @@\n+                    <div class=\"horizontal-scroll\">\n@@ -191,0 +197,1 @@\n+                    <\/div>\n@@ -234,0 +241,1 @@\n+                    <div class=\"horizontal-scroll\">\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testMemberInheritance\/TestMemberInheritance.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -524,1 +524,0 @@\n-                    <div class=\"flex-content\">\n@@ -549,0 +548,1 @@\n+                    <div class=\"horizontal-scroll\">\n@@ -551,0 +551,1 @@\n+                    <\/div>\n@@ -562,0 +563,1 @@\n+                    <div class=\"horizontal-scroll\">\n@@ -568,0 +570,1 @@\n+                    <\/div>\n@@ -710,1 +713,0 @@\n-                    <div class=\"flex-content\">\n@@ -1132,0 +1134,1 @@\n+                    <div class=\"horizontal-scroll\">\n@@ -1145,0 +1148,1 @@\n+                    <div class=\"horizontal-scroll\">\n@@ -1357,0 +1361,1 @@\n+                    <div class=\"horizontal-scroll\">\n@@ -1362,0 +1367,1 @@\n+                    <\/div>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testModules\/TestModules.java","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -94,1 +94,0 @@\n-                    <div class=\"flex-content\">\n@@ -103,1 +102,0 @@\n-                    <div class=\"flex-content\">\n@@ -123,1 +121,0 @@\n-                    <div class=\"flex-content\">\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testNavigation\/TestNavigation.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -235,0 +235,1 @@\n+                    <div class=\"horizontal-scroll\">\n@@ -242,0 +243,1 @@\n+                    <div class=\"horizontal-scroll\">\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testOptions\/TestOptions.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,0 +58,1 @@\n+                    <div class=\"horizontal-scroll\">\n@@ -94,0 +95,1 @@\n+                    <div class=\"horizontal-scroll\">\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testPackageAnnotation\/TestPackageAnnotation.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,175 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8316972\n+ * @summary Add javadoc support for restricted methods\n+ * @library \/tools\/lib ..\/..\/lib\n+ * @modules jdk.javadoc\/jdk.javadoc.internal.tool\n+ * @build toolbox.ToolBox javadoc.tester.*\n+ * @run main TestRestricted\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+\n+import javadoc.tester.JavadocTester;\n+import toolbox.ToolBox;\n+\n+public class TestRestricted extends JavadocTester {\n+\n+    public final ToolBox tb;\n+    public static void main(String... args) throws Exception {\n+        var tester = new TestRestricted();\n+        tester.runTests();\n+    }\n+\n+    public TestRestricted() {\n+        tb = new ToolBox();\n+    }\n+\n+    @Test\n+    public void testRestricted(Path base) throws IOException {\n+        var src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                   package pkg;\n+\n+                   import jdk.internal.javac.PreviewFeature;\n+                   import jdk.internal.javac.PreviewFeature.Feature;\n+                   import jdk.internal.javac.Restricted;\n+\n+                   \/**\n+                    * Interface containing restricted methods.\n+                    * @see #restrictedMethod()\n+                    * @see #restrictedPreviewMethod()\n+                    *\/\n+                   public interface I {\n+\n+                       \/**\n+                        * Restricted method.\n+                        *\/\n+                       @Restricted\n+                       public void restrictedMethod();\n+\n+                       \/**\n+                        * Restricted preview method.\n+                        *\/\n+                       @PreviewFeature(feature=Feature.TEST)\n+                       @Restricted\n+                       public int restrictedPreviewMethod();\n+                   }\n+                   \"\"\");\n+\n+        javadoc(\"--enable-preview\", \"-source\", System.getProperty(\"java.specification.version\"),\n+                \"--add-exports\", \"java.base\/jdk.internal.javac=ALL-UNNAMED\",\n+                \"-d\", base.resolve(\"api\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                \"pkg\");\n+        checkExit(Exit.OK);\n+\n+        \/\/ Test restricted method note in class documentation\n+        checkOutput(\"pkg\/I.html\", true,\n+                \"\"\"\n+                <ul class=\"tag-list-long\">\n+                <li><a href=\"#restrictedMethod()\"><code>restrictedMethod()<\/code><\/a><sup><a href=\"\\\n+                #restricted-restrictedMethod()\">RESTRICTED<\/a><\/sup><\/li>\n+                <li><a href=\"#restrictedPreviewMethod()\"><code>restrictedPreviewMethod()<\/code><\/a>\\\n+                <sup><a href=\"#preview-restrictedPreviewMethod()\">PREVIEW<\/a><\/sup>&nbsp;<sup><a hr\\\n+                ef=\"#restricted-restrictedPreviewMethod()\">RESTRICTED<\/a><\/sup><\/li>\"\"\",\n+                        \"\"\"\n+                <div class=\"block\"><span class=\"restricted-label\">Restricted.<\/span><\/div>\n+                <div class=\"block\">Restricted method.<\/div>\"\"\",\n+                        \"\"\"\n+                <div class=\"block\"><span class=\"preview-label\">Preview.<\/span><\/div>\n+                <div class=\"block\"><span class=\"restricted-label\">Restricted.<\/span><\/div>\n+                <div class=\"block\">Restricted preview method.<\/div>\"\"\",\n+                        \"\"\"\n+                <h3>restrictedMethod<\/h3>\n+                <div class=\"horizontal-scroll\">\n+                <div class=\"member-signature\"><span class=\"modifiers\">sealed<\/span>&nbsp;<span clas\\\n+                s=\"return-type\">void<\/span>&nbsp;<span class=\"element-name\">restrictedMethod<\/span>\\\n+                ()<\/div>\n+                <div class=\"restricted-block\" id=\"restricted-restrictedMethod()\"><span class=\"restr\\\n+                icted-label\"><code>restrictedMethod<\/code> is a restricted method of the Java platf\\\n+                orm.<\/span>\n+                <div class=\"restricted-comment\">Programs can only use <code>restrictedMethod<\/code>\\\n+                 when access to restricted methods is enabled.<\/div>\n+                <div class=\"restricted-comment\">Restricted methods are unsafe, and, if used incorre\\\n+                ctly, might crash the JVM or result in memory corruption.<\/div>\n+                <\/div>\"\"\",\n+                        \"\"\"\n+                <h3>restrictedPreviewMethod<\/h3>\n+                <div class=\"horizontal-scroll\">\n+                <div class=\"member-signature\"><span class=\"modifiers\">sealed<\/span>&nbsp;<span clas\\\n+                s=\"return-type\">int<\/span>&nbsp;<span class=\"element-name\">restrictedPreviewMethod<\\\n+                \/span>()<\/div>\n+                <div class=\"preview-block\" id=\"preview-restrictedPreviewMethod()\"><span class=\"prev\\\n+                iew-label\"><code>restrictedPreviewMethod<\/code> is a preview API of the Java platfo\\\n+                rm.<\/span>\n+                <div class=\"preview-comment\">Programs can only use <code>restrictedPreviewMethod<\/c\\\n+                ode> when preview features are enabled.<\/div>\n+                <div class=\"preview-comment\">Preview features may be removed in a future release, o\\\n+                r upgraded to permanent features of the Java platform.<\/div>\n+                <\/div>\n+                <div class=\"restricted-block\" id=\"restricted-restrictedPreviewMethod()\"><span class\\\n+                =\"restricted-label\"><code>restrictedPreviewMethod<\/code> is a restricted method of \\\n+                the Java platform.<\/span>\n+                <div class=\"restricted-comment\">Programs can only use <code>restrictedPreviewMethod\\\n+                <\/code> when access to restricted methods is enabled.<\/div>\n+                <div class=\"restricted-comment\">Restricted methods are unsafe, and, if used incorre\\\n+                ctly, might crash the JVM or result in memory corruption.<\/div>\n+                <\/div>\"\"\");\n+\n+        \/\/ Test link on index page\n+        checkOutput(\"index-all.html\", true,\n+                        \"\"\"\n+                <a href=\"restricted-list.html\">Restricted&nbsp;Methods<\/a>\"\"\");\n+\n+        \/\/ Test restricted methods list\n+        checkOutput(\"restricted-list.html\", true,\n+                \"\"\"\n+                <h1 title=\"Restricted Methods\" class=\"title\">Restricted Methods<\/h1>\n+                <\/div>\n+                <ul class=\"block-list\">\n+                <li>\n+                <div id=\"method\">\n+                <div class=\"caption\"><span>Methods<\/span><\/div>\n+                <div class=\"summary-table two-column-summary\">\n+                <div class=\"table-header col-first\">Method<\/div>\n+                <div class=\"table-header col-last\">Description<\/div>\n+                <div class=\"col-summary-item-name even-row-color\"><a href=\"pkg\/I.html#restrictedMet\\\n+                hod()\">pkg.I.restrictedMethod()<\/a><sup><a href=\"pkg\/I.html#restricted-restrictedMe\\\n+                thod()\">RESTRICTED<\/a><\/sup><\/div>\n+                <div class=\"col-last even-row-color\">\n+                <div class=\"block\">Restricted method.<\/div>\n+                <\/div>\n+                <div class=\"col-summary-item-name odd-row-color\"><a href=\"pkg\/I.html#restrictedPrev\\\n+                iewMethod()\">pkg.I.restrictedPreviewMethod()<\/a><sup><a href=\"pkg\/I.html#preview-re\\\n+                strictedPreviewMethod()\">PREVIEW<\/a><\/sup>&nbsp;<sup><a href=\"pkg\/I.html#restricted\\\n+                -restrictedPreviewMethod()\">RESTRICTED<\/a><\/sup><\/div>\n+                <div class=\"col-last odd-row-color\">\n+                <div class=\"block\">Restricted preview method.<\/div>\n+                <\/div>\"\"\");\n+    }\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testRestricted\/TestRestricted.java","additions":175,"deletions":0,"binary":false,"changes":175,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -295,0 +295,1 @@\n+                    <\/div>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testReturnTag\/TestReturnTag.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -437,2 +437,0 @@\n-        checkOutput(fileName, true,\n-                \"<div class=\\\"flex-box\\\">\");\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSearch\/TestSearch.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -141,1 +141,1 @@\n-                        overflow-x: auto;\n+                        overflow: auto hidden;\n@@ -164,1 +164,1 @@\n-                    .deprecation-block {\n+                    .deprecation-block, .preview-block, .restricted-block {\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testStylesheet\/TestStylesheet.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -95,0 +95,1 @@\n+                 <div class=\"horizontal-scroll\">\n@@ -98,0 +99,1 @@\n+                 <\/div>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSummaryTag\/TestSummaryTag.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,2 +70,1 @@\n-                    <div class=\"flex-box\">\n-                    <header role=\"banner\" class=\"flex-header\">\"\"\",\n+                    <header role=\"banner\">\"\"\",\n@@ -74,1 +73,0 @@\n-                    <div class=\"flex-content\">\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSystemPropertyPage\/TestSystemPropertyPage.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -683,0 +683,1 @@\n+                <\/div>\n@@ -738,0 +739,1 @@\n+                <\/div>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testThrowsInheritanceMultiple\/TestOneToMany.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -110,0 +110,1 @@\n+                    <div class=\"horizontal-scroll\">\n@@ -118,0 +119,1 @@\n+                    <\/div>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testUnicode\/TestUnicode.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -83,0 +83,1 @@\n+                    <div class=\"horizontal-scroll\">\n@@ -88,0 +89,1 @@\n+                    <div class=\"horizontal-scroll\">\n@@ -116,0 +118,1 @@\n+                    <div class=\"horizontal-scroll\">\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testValueTag\/TestValueFormats.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -427,0 +427,1 @@\n+        boolean haveSourcePath = false;\n@@ -433,0 +434,1 @@\n+                case \"-sourcepath\", \"--source-path\", \"--module-source-path\" -> haveSourcePath = true;\n@@ -454,0 +456,10 @@\n+        \/\/ explicitly set the source path if none specified\n+        \/\/ to override the javadoc tool default to use the classpath\n+        if (!haveSourcePath) {\n+            var newArgs = new String[args.length + 2];\n+            newArgs[0] = \"-sourcepath\";\n+            newArgs[1] = testSrc;\n+            System.arraycopy(args, 0, newArgs, 2, args.length);\n+            args = newArgs;\n+        }\n+\n","filename":"test\/langtools\/jdk\/javadoc\/lib\/javadoc\/tester\/JavadocTester.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 9999999\n+ * @bug 8315851 8315588\n@@ -37,0 +37,2 @@\n+\n+import jdk.jshell.SourceCodeAnalysis;\n@@ -43,0 +45,3 @@\n+import static jdk.jshell.SourceCodeAnalysis.Completeness.COMPLETE;\n+import static jdk.jshell.SourceCodeAnalysis.Completeness.DEFINITELY_INCOMPLETE;\n+\n@@ -53,0 +58,73 @@\n+    static final String[] definitely_incomplete = new String[]{\n+            \"int _ = \",\n+            \"int m(String v, int r) {\\n\" +\n+                    \"    try {\\n\" +\n+                    \"        return Integer.parseInt(v, r);\\n\" +\n+                    \"    } catch (NumberFormatException _) {\",\n+            \"try (final Lock _ = \",\n+            \"try (Lock _ = null) {\\n\" +\n+                \"            try (Lock _ = null) {\",\n+            \"for (var _ : strs\",\n+            \"TwoParams p1 = (_, _) ->\",\n+            \"for (int _ = 0, _ = 1, x = 1;\",\n+            \"if (r instanceof R(_\"\n+    };\n+\n+    static final String[] complete = new String[]{\n+            \"int _ = 42;\",\n+            \"int m(String v, int r) {\\n\" +\n+                    \"    try {\\n\" +\n+                    \"        return Integer.parseInt(v, r);\\n\" +\n+                    \"    } catch (NumberFormatException _) { } }\",\n+            \"try (final Lock _ = TEST) {}\",\n+            \"try (Lock _ = null) {\\n\" +\n+                    \"            try (Lock _ = null) { } }\",\n+            \"for (var _ : strs) { }\",\n+            \"TwoParams p1 = (_, _) -> {};\",\n+            \"for (int _ = 0, _ = 1, x = 1; x <= 1 ; x++) {}\",\n+            \"if (r instanceof R(_)) { }\"\n+    };\n+\n+    private void assertStatus(String input, SourceCodeAnalysis.Completeness status, String source) {\n+        String augSrc;\n+        switch (status) {\n+            case COMPLETE_WITH_SEMI:\n+                augSrc = source + \";\";\n+                break;\n+\n+            case DEFINITELY_INCOMPLETE:\n+                augSrc = null;\n+                break;\n+\n+            case CONSIDERED_INCOMPLETE:\n+                augSrc = source + \";\";\n+                break;\n+\n+            case EMPTY:\n+            case COMPLETE:\n+            case UNKNOWN:\n+                augSrc = source;\n+                break;\n+\n+            default:\n+                throw new AssertionError();\n+        }\n+        assertAnalyze(input, status, augSrc);\n+    }\n+\n+    private void assertStatus(String[] ins, SourceCodeAnalysis.Completeness status) {\n+        for (String input : ins) {\n+            assertStatus(input, status, input);\n+        }\n+    }\n+\n+    @Test\n+    public void test_definitely_incomplete() {\n+        assertStatus(definitely_incomplete, DEFINITELY_INCOMPLETE);\n+    }\n+\n+    @Test\n+    public void test_definitely_complete() {\n+        assertStatus(complete, COMPLETE);\n+    }\n+\n","filename":"test\/langtools\/jdk\/jshell\/UnnamedTest.java","additions":79,"deletions":1,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# This file identifies root(s) of the test-ng hierarchy.\n+# This file identifies root(s) of the JUnit hierarchy.\n@@ -3,1 +3,1 @@\n-TestNG.dirs = .\n+JUnit.dirs = .\n","filename":"test\/langtools\/lib\/combo\/TEST.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,31 @@\n+package tools.javac.combo;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.junit.jupiter.api.extension.AfterAllCallback;\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.api.extension.TestWatcher;\n+\n+public class ComboWatcher implements TestWatcher, AfterAllCallback {\n+    private final Set<String> errors = Collections.synchronizedSet(new HashSet<>());\n+\n+    @Override\n+    public void testFailed(ExtensionContext context, Throwable cause) {\n+        if (context.getRequiredTestInstance() instanceof JavacTemplateTestBase instance) {\n+            errors.addAll(instance.diags.errorKeys());\n+            if (instance instanceof CompilationTestCase) {\n+                \/\/ Make sure offending template ends up in log file on failure\n+                System.err.printf(\"Diagnostics: %s%nTemplate: %s%n\", instance.diags.errorKeys(),\n+                        instance.sourceFiles.stream().map(SourceFile::template).toList());\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void afterAll(ExtensionContext extensionContext) {\n+        if (errors.isEmpty()) return;\n+        System.err.println(\"Errors found in tests: \" + errors);\n+    }\n+}\n","filename":"test\/langtools\/lib\/combo\/tools\/javac\/combo\/ComboWatcher.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,6 +34,0 @@\n-import org.testng.ITestResult;\n-import org.testng.annotations.AfterMethod;\n-import org.testng.annotations.Test;\n-\n-import static java.util.stream.Collectors.toList;\n-\n@@ -43,1 +37,0 @@\n-@Test\n@@ -45,1 +38,1 @@\n-    private String[] compileOptions = new String[] { };\n+    private String[] compileOptions = new String[]{};\n@@ -49,9 +42,0 @@\n-    @AfterMethod\n-    public void dumpTemplateIfError(ITestResult result) {\n-        \/\/ Make sure offending template ends up in log file on failure\n-        if (!result.isSuccess()) {\n-            System.err.printf(\"Diagnostics: %s%nTemplate: %s%n\", diags.errorKeys(),\n-                              sourceFiles.stream().map(p -> p.snd).collect(toList()));\n-        }\n-    }\n-\n@@ -84,1 +68,1 @@\n-            compileOptions = new String[] {};\n+            compileOptions = new String[]{};\n@@ -108,2 +92,1 @@\n-        }\n-        catch (IOException e) {\n+        } catch (IOException e) {\n","filename":"test\/langtools\/lib\/combo\/tools\/javac\/combo\/CompilationTestCase.java","additions":4,"deletions":21,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,0 @@\n-import java.util.HashSet;\n@@ -39,1 +38,0 @@\n-import java.util.Set;\n@@ -51,6 +49,2 @@\n-import com.sun.tools.javac.util.Pair;\n-import org.testng.ITestResult;\n-import org.testng.annotations.AfterMethod;\n-import org.testng.annotations.AfterSuite;\n-import org.testng.annotations.BeforeMethod;\n-import org.testng.annotations.Test;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.extension.ExtendWith;\n@@ -58,1 +52,1 @@\n-import static org.testng.Assert.fail;\n+import static org.junit.jupiter.api.Assertions.fail;\n@@ -61,1 +55,1 @@\n- * Base class for template-driven TestNG javac tests that support on-the-fly\n+ * Base class for template-driven JUnit javac tests that support on-the-fly\n@@ -73,1 +67,1 @@\n-@Test\n+@ExtendWith(ComboWatcher.class)\n@@ -75,1 +69,0 @@\n-    private static final Set<String> suiteErrors = Collections.synchronizedSet(new HashSet<>());\n@@ -82,1 +75,1 @@\n-    protected final List<Pair<String, String>> sourceFiles = new ArrayList<>();\n+    protected final List<SourceFile> sourceFiles = new ArrayList<>();\n@@ -98,1 +91,1 @@\n-        sourceFiles.add(new Pair<>(name, template));\n+        sourceFiles.add(new SourceFile(name, template));\n@@ -133,1 +126,1 @@\n-    @BeforeMethod\n+    @BeforeEach\n@@ -142,32 +135,0 @@\n-    \/\/ After each test method, if the test failed, capture source files and diagnostics and put them in the log\n-    @AfterMethod\n-    public void copyErrors(ITestResult result) {\n-        if (!result.isSuccess()) {\n-            suiteErrors.addAll(diags.errorKeys());\n-\n-            List<Object> list = new ArrayList<>();\n-            Collections.addAll(list, result.getParameters());\n-            list.add(\"Test case: \" + getTestCaseDescription());\n-            for (Pair<String, String> e : sourceFiles)\n-                list.add(\"Source file \" + e.fst + \": \" + e.snd);\n-            if (diags.errorsFound())\n-                list.add(\"Compile diagnostics: \" + diags.toString());\n-            result.setParameters(list.toArray(new Object[list.size()]));\n-        }\n-    }\n-\n-    @AfterSuite\n-    \/\/ After the suite is done, dump any errors to output\n-    public void dumpErrors() {\n-        if (!suiteErrors.isEmpty())\n-            System.err.println(\"Errors found in test suite: \" + suiteErrors);\n-    }\n-\n-    \/**\n-     * Get a description of this test case; since test cases may be combinatorially\n-     * generated, this should include all information needed to describe the test case\n-     *\/\n-    protected String getTestCaseDescription() {\n-        return this.toString();\n-    }\n-\n@@ -261,3 +222,1 @@\n-        List<JavaFileObject> files = new ArrayList<>();\n-        for (Pair<String, String> e : sourceFiles)\n-            files.add(new FileAdapter(e.fst, e.snd));\n+        var files = sourceFiles.stream().map(FileAdapter::new).toList();\n@@ -271,3 +230,1 @@\n-        List<JavaFileObject> files = new ArrayList<>();\n-        for (Pair<String, String> e : sourceFiles)\n-            files.add(new FileAdapter(e.fst, e.snd));\n+        var files = sourceFiles.stream().map(FileAdapter::new).toList();\n@@ -277,1 +234,1 @@\n-    private File compile(List<File> classpaths, List<JavaFileObject> files, boolean generate) throws IOException {\n+    private File compile(List<File> classpaths, List<? extends JavaFileObject> files, boolean generate) throws IOException {\n@@ -330,3 +287,3 @@\n-        FileAdapter(String filename, String templateString) {\n-            super(URI.create(\"myfo:\/\" + filename), Kind.SOURCE);\n-            this.templateString = templateString;\n+        FileAdapter(SourceFile file) {\n+            super(URI.create(\"myfo:\/\" + file.name()), Kind.SOURCE);\n+            this.templateString = file.template();\n","filename":"test\/langtools\/lib\/combo\/tools\/javac\/combo\/JavacTemplateTestBase.java","additions":15,"deletions":58,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -0,0 +1,26 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package tools.javac.combo;\n+\n+public record SourceFile(String name, String template) {}\n","filename":"test\/langtools\/lib\/combo\/tools\/javac\/combo\/SourceFile.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,4 @@\n-import org.testng.annotations.BeforeTest;\n-import org.testng.annotations.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.BeforeEach;\n@@ -32,2 +34,0 @@\n-import static org.testng.Assert.assertEquals;\n-\n@@ -37,3 +37,2 @@\n-@Test\n-public class TemplateTest {\n-    Map<String, Template> vars = new HashMap<>();\n+class TemplateTest {\n+    final Map<String, Template> vars = new HashMap<>();\n@@ -41,1 +40,1 @@\n-    @BeforeTest\n+    @BeforeEach\n@@ -46,1 +45,1 @@\n-        assertEquals(result, expected, \"for \" + template);\n+        assertEquals(expected, result, \"for \" + template);\n@@ -53,1 +52,2 @@\n-    public void testTemplateExpansion() {\n+    @Test\n+    void testTemplateExpansion() {\n@@ -75,1 +75,2 @@\n-    public void testIndexedTemplate() {\n+    @Test\n+    void testIndexedTemplate() {\n@@ -85,1 +86,2 @@\n-    public void testAngleBrackets() {\n+    @Test\n+    void testAngleBrackets() {\n@@ -90,3 +92,3 @@\n-    @Test(expectedExceptions = IllegalStateException.class )\n-    public void testUnknownKey() {\n-        assertTemplate(\"#{Q}\", \"#{Q}\");\n+    @Test\n+    void testUnknownKey() {\n+        assertThrows(IllegalStateException.class, () -> assertTemplate(\"#{Q}\", \"#{Q}\"));\n","filename":"test\/langtools\/lib\/combo\/tools\/javac\/combo\/TemplateTest.java","additions":18,"deletions":16,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -5,2 +5,2 @@\n- * @compile\/fail\/ref=RestrictedMethods.out -Xlint:restricted -Werror -XDrawDiagnostics --enable-preview --source ${jdk.version} RestrictedMethods.java\n- * @compile -Werror --enable-preview --source ${jdk.version} RestrictedMethods.java\n+ * @compile\/fail\/ref=RestrictedMethods.out -Xlint:restricted -Werror -XDrawDiagnostics RestrictedMethods.java\n+ * @compile -Werror RestrictedMethods.java\n","filename":"test\/langtools\/tools\/javac\/RestrictedMethods.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -6,2 +6,0 @@\n-- compiler.note.preview.filename: RestrictedMethods.java, DEFAULT\n-- compiler.note.preview.recompile\n","filename":"test\/langtools\/tools\/javac\/RestrictedMethods.out","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,131 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8305971\n+ * @summary NPE in JavacProcessingEnvironment for missing enum constructor body\n+ * @library \/tools\/lib \/tools\/javac\/lib\n+ * @modules\n+ *      jdk.compiler\/com.sun.tools.javac.api\n+ *      jdk.compiler\/com.sun.tools.javac.main\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @run main CrashEmptyEnumConstructorTest\n+ *\/\n+\n+import java.io.IOException;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+import java.util.List;\n+import java.util.Set;\n+import javax.annotation.processing.AbstractProcessor;\n+import javax.annotation.processing.RoundEnvironment;\n+import javax.annotation.processing.SupportedAnnotationTypes;\n+import javax.lang.model.SourceVersion;\n+import javax.lang.model.element.TypeElement;\n+\n+import toolbox.JavacTask;\n+import toolbox.Task;\n+import toolbox.Task.Mode;\n+import toolbox.Task.OutputKind;\n+import toolbox.TestRunner;\n+import toolbox.ToolBox;\n+\n+public class CrashEmptyEnumConstructorTest extends TestRunner {\n+    protected ToolBox tb;\n+\n+    CrashEmptyEnumConstructorTest() {\n+        super(System.err);\n+        tb = new ToolBox();\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        new CrashEmptyEnumConstructorTest().runTests();\n+    }\n+\n+    protected void runTests() throws Exception {\n+        runTests(m -> new Object[]{Paths.get(m.getName())});\n+    }\n+\n+    Path[] findJavaFiles(Path... paths) throws IOException {\n+        return tb.findJavaFiles(paths);\n+    }\n+\n+    @Test\n+    public void testEmptyEnumConstructor(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        Path r = src.resolve(\"E\");\n+\n+        Path classes = base.resolve(\"classes\");\n+\n+        Files.createDirectories(classes);\n+\n+        tb.writeJavaFiles(r,\n+                \"\"\"\n+                enum E {\n+                    ONE(\"\");\n+                    E(String one);\n+                }\n+                \"\"\");\n+\n+        List<String> expected = List.of(\n+            \"E.java:3: error: missing method body, or declare abstract\",\n+            \"    E(String one);\",\n+            \"    ^\",\n+            \"1 error\");\n+\n+        List<String> log = new JavacTask(tb)\n+                .options(\"-processor\", SimpleProcessor.class.getName())\n+                .files(findJavaFiles(src))\n+                .outdir(classes)\n+                .run(Task.Expect.FAIL)\n+                .writeAll()\n+                .getOutputLines(Task.OutputKind.DIRECT);\n+\n+        if (log.size() != expected.size()) {\n+            throw new AssertionError(\"Unexpected output: \" + log);\n+        } else {\n+            for (int i = 0; i < expected.size(); i++) {\n+                if (!log.get(i).contains(expected.get(i))) {\n+                    throw new AssertionError(\"Unexpected output: \" + log);\n+                }\n+            }\n+        }\n+    }\n+\n+    @SupportedAnnotationTypes(\"*\")\n+    public static final class SimpleProcessor extends AbstractProcessor {\n+        @Override\n+        public SourceVersion getSupportedSourceVersion() {\n+            return SourceVersion.latestSupported();\n+        }\n+\n+        @Override\n+        public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n+            return false;\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/annotations\/crash_empty_enum_const\/CrashEmptyEnumConstructorTest.java","additions":131,"deletions":0,"binary":false,"changes":131,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,0 @@\n-import java.io.IOException;\n@@ -27,3 +26,1 @@\n-import org.testng.ITestResult;\n-import org.testng.annotations.AfterMethod;\n-import org.testng.annotations.Test;\n+import org.junit.jupiter.api.Test;\n@@ -31,1 +28,0 @@\n-import tools.javac.combo.JavacTemplateTestBase;\n@@ -33,4 +29,1 @@\n-import static java.util.stream.Collectors.toList;\n-\n-@Test\n-public class ExpSwitchNestingTest extends CompilationTestCase {\n+class ExpSwitchNestingTest extends CompilationTestCase {\n@@ -80,1 +73,2 @@\n-    public void testReallySimpleCases() {\n+    @Test\n+    void testReallySimpleCases() {\n@@ -87,1 +81,2 @@\n-    public void testLambda() {\n+    @Test\n+    void testLambda() {\n@@ -109,1 +104,2 @@\n-    public void testEswitch() {\n+    @Test\n+    void testEswitch() {\n@@ -154,1 +150,2 @@\n-    public void testNestedInExpSwitch() {\n+    @Test\n+    void testNestedInExpSwitch() {\n@@ -187,1 +184,2 @@\n-    public void testBreakExpressionLabelDisambiguation() {\n+    @Test\n+    void testBreakExpressionLabelDisambiguation() {\n@@ -197,1 +195,2 @@\n-    public void testFunReturningSwitchExp() {\n+    @Test\n+    void testFunReturningSwitchExp() {\n@@ -201,1 +200,2 @@\n-    public void testContinueLoops() {\n+    @Test\n+    void testContinueLoops() {\n","filename":"test\/langtools\/tools\/javac\/expswitch\/ExpSwitchNestingTest.java","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-TestNG.dirs = .\n+JUnit.dirs = .\n","filename":"test\/langtools\/tools\/javac\/expswitch\/TEST.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,2 +34,2 @@\n-import org.testng.annotations.BeforeMethod;\n-import org.testng.annotations.Test;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n@@ -39,1 +39,1 @@\n-import static org.testng.Assert.fail;\n+import static org.junit.jupiter.api.Assertions.fail;\n@@ -59,1 +59,0 @@\n-@Test\n@@ -232,1 +231,1 @@\n-    @BeforeMethod\n+    @BeforeEach\n","filename":"test\/langtools\/tools\/javac\/lambda\/bridge\/template_tests\/BridgeMethodTestCase.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,2 +25,3 @@\n-\n-import org.testng.annotations.Test;\n+import tools.javac.combo.*;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n@@ -33,2 +34,1 @@\n-@Test\n-public class BridgeMethodsTemplateTest extends BridgeMethodTestCase {\n+class BridgeMethodsTemplateTest extends BridgeMethodTestCase {\n@@ -42,1 +42,2 @@\n-    public void test1() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test1() throws IOException, ReflectiveOperationException {\n@@ -55,1 +56,2 @@\n-    public void test2() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test2() throws IOException, ReflectiveOperationException {\n@@ -68,1 +70,2 @@\n-    public void test3() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test3() throws IOException, ReflectiveOperationException {\n@@ -81,1 +84,2 @@\n-    public void test4() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test4() throws IOException, ReflectiveOperationException {\n@@ -94,1 +98,2 @@\n-    public void test5() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test5() throws IOException, ReflectiveOperationException {\n@@ -107,1 +112,2 @@\n-    public void test6() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test6() throws IOException, ReflectiveOperationException {\n@@ -120,1 +126,2 @@\n-    public void test7() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test7() throws IOException, ReflectiveOperationException {\n@@ -133,1 +140,2 @@\n-    public void test8() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test8() throws IOException, ReflectiveOperationException {\n@@ -146,1 +154,2 @@\n-    public void test9() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test9() throws IOException, ReflectiveOperationException {\n@@ -159,1 +168,2 @@\n-    public void test10() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test10() throws IOException, ReflectiveOperationException {\n@@ -172,1 +182,2 @@\n-    public void test11() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test11() throws IOException, ReflectiveOperationException {\n@@ -186,1 +197,2 @@\n-    public void test12() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test12() throws IOException, ReflectiveOperationException {\n@@ -200,1 +212,2 @@\n-    public void test13() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test13() throws IOException, ReflectiveOperationException {\n@@ -214,1 +227,2 @@\n-    public void test14() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test14() throws IOException, ReflectiveOperationException {\n@@ -228,1 +242,2 @@\n-    public void test15() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test15() throws IOException, ReflectiveOperationException {\n@@ -242,1 +257,2 @@\n-    public void test16() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test16() throws IOException, ReflectiveOperationException {\n@@ -256,1 +272,2 @@\n-    public void test17() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test17() throws IOException, ReflectiveOperationException {\n@@ -270,1 +287,2 @@\n-    public void test18() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test18() throws IOException, ReflectiveOperationException {\n@@ -284,1 +302,2 @@\n-    public void test19() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test19() throws IOException, ReflectiveOperationException {\n@@ -298,1 +317,2 @@\n-    public void test20() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test20() throws IOException, ReflectiveOperationException {\n@@ -312,1 +332,2 @@\n-    public void test21() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test21() throws IOException, ReflectiveOperationException {\n@@ -326,1 +347,2 @@\n-    public void test22() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test22() throws IOException, ReflectiveOperationException {\n@@ -340,1 +362,2 @@\n-    public void test23() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test23() throws IOException, ReflectiveOperationException {\n@@ -354,1 +377,2 @@\n-    public void test24() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test24() throws IOException, ReflectiveOperationException {\n@@ -368,1 +392,2 @@\n-    public void test25() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test25() throws IOException, ReflectiveOperationException {\n@@ -382,1 +407,2 @@\n-    public void test26() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test26() throws IOException, ReflectiveOperationException {\n@@ -395,1 +421,2 @@\n-    public void test27() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test27() throws IOException, ReflectiveOperationException {\n@@ -408,1 +435,2 @@\n-    public void test28() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test28() throws IOException, ReflectiveOperationException {\n@@ -421,1 +449,2 @@\n-    public void test29() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test29() throws IOException, ReflectiveOperationException {\n@@ -435,1 +464,2 @@\n-    public void test30() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test30() throws IOException, ReflectiveOperationException {\n@@ -449,1 +479,2 @@\n-    public void test31() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test31() throws IOException, ReflectiveOperationException {\n@@ -463,1 +494,2 @@\n-    public void test32() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test32() throws IOException, ReflectiveOperationException {\n@@ -477,1 +509,2 @@\n-    public void test33() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test33() throws IOException, ReflectiveOperationException {\n@@ -491,1 +524,2 @@\n-    public void test34() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test34() throws IOException, ReflectiveOperationException {\n@@ -505,1 +539,2 @@\n-    public void test35() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test35() throws IOException, ReflectiveOperationException {\n@@ -519,1 +554,2 @@\n-    public void test36() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test36() throws IOException, ReflectiveOperationException {\n@@ -533,1 +569,2 @@\n-    public void test37() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test37() throws IOException, ReflectiveOperationException {\n@@ -547,1 +584,2 @@\n-    public void test38() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test38() throws IOException, ReflectiveOperationException {\n@@ -561,1 +599,2 @@\n-    public void test39() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test39() throws IOException, ReflectiveOperationException {\n@@ -576,1 +615,2 @@\n-    public void test40() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test40() throws IOException, ReflectiveOperationException {\n@@ -590,1 +630,2 @@\n-    public void test41() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test41() throws IOException, ReflectiveOperationException {\n@@ -604,1 +645,2 @@\n-    public void test42() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test42() throws IOException, ReflectiveOperationException {\n@@ -618,1 +660,2 @@\n-    public void test43() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test43() throws IOException, ReflectiveOperationException {\n@@ -633,1 +676,2 @@\n-    public void test44() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test44() throws IOException, ReflectiveOperationException {\n@@ -648,1 +692,2 @@\n-    public void test45() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test45() throws IOException, ReflectiveOperationException {\n@@ -662,1 +707,2 @@\n-    public void test46() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test46() throws IOException, ReflectiveOperationException {\n@@ -676,1 +722,2 @@\n-    public void test47() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test47() throws IOException, ReflectiveOperationException {\n@@ -690,1 +737,2 @@\n-    public void test48() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test48() throws IOException, ReflectiveOperationException {\n@@ -704,1 +752,2 @@\n-    public void test49() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test49() throws IOException, ReflectiveOperationException {\n@@ -720,1 +769,2 @@\n-    public void test50() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test50() throws IOException, ReflectiveOperationException {\n@@ -735,1 +785,2 @@\n-    public void test51() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test51() throws IOException, ReflectiveOperationException {\n@@ -749,1 +800,2 @@\n-    public void test52() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test52() throws IOException, ReflectiveOperationException {\n@@ -763,1 +815,2 @@\n-    public void test53() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test53() throws IOException, ReflectiveOperationException {\n@@ -778,1 +831,2 @@\n-    public void test54() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test54() throws IOException, ReflectiveOperationException {\n@@ -793,1 +847,2 @@\n-    public void test55() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test55() throws IOException, ReflectiveOperationException {\n@@ -808,1 +863,2 @@\n-    public void test56() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test56() throws IOException, ReflectiveOperationException {\n@@ -823,1 +879,2 @@\n-    public void test57() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test57() throws IOException, ReflectiveOperationException {\n@@ -838,1 +895,2 @@\n-    public void test58() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test58() throws IOException, ReflectiveOperationException {\n@@ -853,1 +911,2 @@\n-    public void test59() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test59() throws IOException, ReflectiveOperationException {\n@@ -868,1 +927,2 @@\n-    public void test60() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test60() throws IOException, ReflectiveOperationException {\n@@ -883,1 +943,2 @@\n-    public void test61() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test61() throws IOException, ReflectiveOperationException {\n@@ -898,1 +959,2 @@\n-    public void test62() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test62() throws IOException, ReflectiveOperationException {\n@@ -913,1 +975,2 @@\n-    public void test63() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test63() throws IOException, ReflectiveOperationException {\n@@ -928,1 +991,2 @@\n-    public void test64() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test64() throws IOException, ReflectiveOperationException {\n@@ -943,1 +1007,2 @@\n-    public void test65() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test65() throws IOException, ReflectiveOperationException {\n@@ -958,1 +1023,2 @@\n-    public void test66() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test66() throws IOException, ReflectiveOperationException {\n@@ -973,1 +1039,2 @@\n-    public void test67() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test67() throws IOException, ReflectiveOperationException {\n@@ -981,1 +1048,2 @@\n-    public void testA1() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void testA1() throws IOException, ReflectiveOperationException {\n@@ -986,1 +1054,2 @@\n-    public void testA2() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void testA2() throws IOException, ReflectiveOperationException {\n@@ -991,1 +1060,2 @@\n-    public void testA3() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void testA3() throws IOException, ReflectiveOperationException {\n@@ -996,1 +1066,2 @@\n-    public void testA4() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void testA4() throws IOException, ReflectiveOperationException {\n@@ -1002,1 +1073,2 @@\n-    public void testA5() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void testA5() throws IOException, ReflectiveOperationException {\n@@ -1007,1 +1079,2 @@\n-    public void testA6() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void testA6() throws IOException, ReflectiveOperationException {\n@@ -1013,1 +1086,2 @@\n-    public void testA7() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void testA7() throws IOException, ReflectiveOperationException {\n@@ -1018,1 +1092,2 @@\n-    public void testA8() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void testA8() throws IOException, ReflectiveOperationException {\n@@ -1022,1 +1097,2 @@\n-    public void testA9() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void testA9() throws IOException, ReflectiveOperationException {\n@@ -1027,1 +1103,2 @@\n-    public void testA10() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void testA10() throws IOException, ReflectiveOperationException {\n@@ -1031,1 +1108,2 @@\n-    public void testA11() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void testA11() throws IOException, ReflectiveOperationException {\n@@ -1039,1 +1117,2 @@\n-    public void testB1() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void testB1() throws IOException, ReflectiveOperationException {\n@@ -1046,1 +1125,2 @@\n-    public void testB2() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void testB2() throws IOException, ReflectiveOperationException {\n@@ -1059,1 +1139,2 @@\n-    public void testB5() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void testB5() throws IOException, ReflectiveOperationException {\n@@ -1064,1 +1145,2 @@\n-    public void testB6() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void testB6() throws IOException, ReflectiveOperationException {\n@@ -1069,1 +1151,2 @@\n-    public void testB7() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void testB7() throws IOException, ReflectiveOperationException {\n@@ -1074,1 +1157,2 @@\n-    public void testB8() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void testB8() throws IOException, ReflectiveOperationException {\n","filename":"test\/langtools\/tools\/javac\/lambda\/bridge\/template_tests\/BridgeMethodsTemplateTest.java","additions":173,"deletions":89,"binary":false,"changes":262,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# This file identifies root(s) of the test-ng hierarchy.\n+# This file identifies root(s) of the JUnit hierarchy.\n@@ -3,1 +3,1 @@\n-TestNG.dirs = .\n+JUnit.dirs = .\n","filename":"test\/langtools\/tools\/javac\/lambda\/bridge\/template_tests\/TEST.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n- * @run testng BoundUnboundSearchTest\n+ * @run junit BoundUnboundSearchTest\n@@ -43,1 +43,1 @@\n-import org.testng.annotations.Test;\n+import org.junit.jupiter.api.Test;\n@@ -46,4 +46,1 @@\n-import static org.testng.Assert.assertEquals;\n-\n-@Test\n-public class BoundUnboundSearchTest extends CompilationTestCase {\n+class BoundUnboundSearchTest extends CompilationTestCase {\n@@ -61,1 +58,1 @@\n-    public BoundUnboundSearchTest() {\n+    BoundUnboundSearchTest() {\n@@ -78,1 +75,2 @@\n-    public void test() {\n+    @Test\n+    void test() {\n","filename":"test\/langtools\/tools\/javac\/lambda\/methodReference\/BoundUnboundSearchTest.java","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,43 @@\n+\/**\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8314578\n+ * @enablePreview\n+ * @summary Parsing of erroneous patterns succeeds\n+ * @compile\/fail\/ref=T8314578.out -XDrawDiagnostics T8314578.java\n+ *\/\n+public class T8314578 {\n+    record R1() {}\n+    record R2() {}\n+\n+    static void test(Object o) {\n+        switch (o) {\n+            case R1() when o instanceof String s:\n+            case R2() when o instanceof Integer i:\n+                System.out.println(\"hello: \" + i);\n+                break;\n+            default:\n+                break;\n+        }\n+    }\n+\n+    static void test2(Object o) {\n+        switch (o) {\n+            case R1() when o instanceof String s:\n+                System.out.println(\"hello: \" + s);\n+            case R2() when o instanceof Integer i:\n+                System.out.println(\"hello: \" + i);\n+                break;\n+            default:\n+                break;\n+        }\n+    }\n+\n+    static int unnamedInGuardsOK(String s) {\n+        return switch (s) {\n+            case String _ when s instanceof String _ ->  \/\/ should be OK\n+                    1;\n+            default ->\n+                    -1;\n+        };\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/patterns\/T8314578.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,6 @@\n+T8314578.java:14:18: compiler.err.flows.through.from.pattern\n+T8314578.java:15:18: compiler.err.flows.through.to.pattern\n+T8314578.java:27:18: compiler.err.flows.through.to.pattern\n+- compiler.note.preview.filename: T8314578.java, DEFAULT\n+- compiler.note.preview.recompile\n+3 errors\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/patterns\/T8314578.out","additions":6,"deletions":0,"binary":false,"changes":6,"status":"added"},{"patch":"@@ -0,0 +1,24 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8317300\n+ * @summary javac erroneously allows \"final\" in front of a record pattern\n+ * @compile\/fail\/ref=T8317300.out -XDrawDiagnostics T8317300.java\n+ *\/\n+public class T8317300 {\n+    record Foo (int x) {}\n+    record Bar (Foo x) {}\n+\n+    void test1(Object obj) {\n+        switch (obj) {\n+            case final Foo(int x) -> {}\n+            default -> {}\n+        }\n+    }\n+\n+    void test2(Object obj) {\n+        switch (obj) {\n+            case Bar(final Foo(int x)) -> {}\n+            default -> {}\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/T8317300.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"added"},{"patch":"@@ -0,0 +1,5 @@\n+T8317300.java:13:18: compiler.err.mod.not.allowed.here: final\n+T8317300.java:20:22: compiler.err.illegal.start.of.expr\n+T8317300.java:20:31: compiler.err.expected: token.identifier\n+T8317300.java:20:37: compiler.err.expected: ';'\n+4 errors\n","filename":"test\/langtools\/tools\/javac\/patterns\/T8317300.out","additions":5,"deletions":0,"binary":false,"changes":5,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n-import java.util.List;\n@@ -28,4 +27,1 @@\n-\n-import org.testng.ITestResult;\n-import org.testng.annotations.AfterMethod;\n-import org.testng.annotations.Test;\n+import org.junit.jupiter.api.Test;\n@@ -34,4 +30,1 @@\n-import static java.util.stream.Collectors.toList;\n-\n-@Test\n-public class ScopeTest extends JavacTemplateTestBase {\n+class ScopeTest extends JavacTemplateTestBase {\n@@ -87,8 +80,0 @@\n-    @AfterMethod\n-    public void dumpTemplateIfError(ITestResult result) {\n-        \/\/ Make sure offending template ends up in log file on failure\n-        if (!result.isSuccess()) {\n-            System.err.printf(\"Diagnostics: %s%nTemplate: %s%n\", diags.errorKeys(), sourceFiles.stream().map(p -> p.snd).collect(toList()));\n-        }\n-    }\n-\n@@ -124,1 +109,2 @@\n-    public void testIf() {\n+    @Test\n+    void testIf() {\n@@ -131,1 +117,2 @@\n-    public void testWhile() {\n+    @Test\n+    void testWhile() {\n@@ -136,1 +123,2 @@\n-    public void testDoWhile() {\n+    @Test\n+    void testDoWhile() {\n@@ -141,1 +129,2 @@\n-    public void testFor() {\n+    @Test\n+    void testFor() {\n","filename":"test\/langtools\/tools\/javac\/patterns\/scope\/ScopeTest.java","additions":11,"deletions":22,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-TestNG.dirs = .\n+JUnit.dirs = .\n","filename":"test\/langtools\/tools\/javac\/patterns\/scope\/TEST.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n- * @run testng\/othervm LocalStaticDeclarations2\n+ * @run junit\/othervm LocalStaticDeclarations2\n@@ -35,1 +35,1 @@\n-import org.testng.annotations.Test;\n+import org.junit.jupiter.api.Test;\n@@ -38,5 +38,3 @@\n-import static org.testng.Assert.assertEquals;\n-\n-@Test\n-public class LocalStaticDeclarations2 extends CompilationTestCase {\n-    public void testLocalStatic() {\n+class LocalStaticDeclarations2 extends CompilationTestCase {\n+    @Test\n+    void testLocalStatic() {\n","filename":"test\/langtools\/tools\/javac\/records\/LocalStaticDeclarations2.java","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,2 +42,2 @@\n- * @run testng\/othervm -DuseAP=false RecordCompilationTests\n- * @run testng\/othervm -DuseAP=true RecordCompilationTests\n+ * @run junit\/othervm -DuseAP=false RecordCompilationTests\n+ * @run junit\/othervm -DuseAP=true RecordCompilationTests\n@@ -84,1 +84,0 @@\n-import org.testng.annotations.Test;\n@@ -86,0 +85,1 @@\n+import org.junit.jupiter.api.Test;\n@@ -88,1 +88,0 @@\n-import static org.testng.Assert.assertEquals;\n@@ -102,2 +101,1 @@\n-@Test\n-public class RecordCompilationTests extends CompilationTestCase {\n+class RecordCompilationTests extends CompilationTestCase {\n@@ -131,1 +129,2 @@\n-    public void testMalformedDeclarations() {\n+    @Test\n+    void testMalformedDeclarations() {\n@@ -153,1 +152,2 @@\n-    public void testGoodDeclarations() {\n+    @Test\n+    void testGoodDeclarations() {\n@@ -183,1 +183,2 @@\n-    public void testGoodMemberDeclarations() {\n+    @Test\n+    void testGoodMemberDeclarations() {\n@@ -194,1 +195,2 @@\n-    public void testBadComponentNames() {\n+    @Test\n+    void testBadComponentNames() {\n@@ -199,1 +201,2 @@\n-    public void testRestrictedIdentifiers() {\n+    @Test\n+    void testRestrictedIdentifiers() {\n@@ -218,1 +221,2 @@\n-    public void testValidMembers() {\n+    @Test\n+    void testValidMembers() {\n@@ -229,1 +233,2 @@\n-    public void testCyclic() {\n+    @Test\n+    void testCyclic() {\n@@ -234,1 +239,2 @@\n-    public void testBadExtends() {\n+    @Test\n+    void testBadExtends() {\n@@ -242,1 +248,2 @@\n-    public void testNoExtendRecord() {\n+    @Test\n+    void testNoExtendRecord() {\n@@ -254,1 +261,2 @@\n-    public void testFieldDeclarations() {\n+    @Test\n+    void testFieldDeclarations() {\n@@ -282,1 +290,2 @@\n-    public void testAccessorRedeclaration() {\n+    @Test\n+    void testAccessorRedeclaration() {\n@@ -338,1 +347,2 @@\n-    public void testConstructorRedeclaration() {\n+    @Test\n+    void testConstructorRedeclaration() {\n@@ -429,1 +439,2 @@\n-    public void testAnnotationCriteria() {\n+    @Test\n+    void testAnnotationCriteria() {\n@@ -438,1 +449,1 @@\n-        assertEquals(goodSet.size() + badSet.size(), values().length);\n+        Assert.check(goodSet.size() + badSet.size() == values().length);\n@@ -462,1 +473,2 @@\n-    public void testNestedRecords() {\n+    @Test\n+    void testNestedRecords() {\n@@ -480,1 +492,2 @@\n-    public void testDuplicatedMember() {\n+    @Test\n+    void testDuplicatedMember() {\n@@ -489,1 +502,2 @@\n-    public void testStaticLocals() {\n+    @Test\n+    void testStaticLocals() {\n@@ -579,1 +593,2 @@\n-    public void testStaticDefinitionsInInnerClasses() {\n+    @Test\n+    void testStaticDefinitionsInInnerClasses() {\n@@ -1045,1 +1060,2 @@\n-    public void testReturnInCanonical_Compact() {\n+    @Test\n+    void testReturnInCanonical_Compact() {\n@@ -1054,1 +1070,2 @@\n-    public void testArgumentsAreNotFinalInCompact() {\n+    @Test\n+    void testArgumentsAreNotFinalInCompact() {\n@@ -1065,1 +1082,2 @@\n-    public void testNoNativeMethods() {\n+    @Test\n+    void testNoNativeMethods() {\n@@ -1072,1 +1090,2 @@\n-    public void testRecordsInsideInner() {\n+    @Test\n+    void testRecordsInsideInner() {\n@@ -1113,1 +1132,2 @@\n-    public void testAnnoInsideLocalOrAnonymous() {\n+    @Test\n+    void testAnnoInsideLocalOrAnonymous() {\n@@ -1217,1 +1237,2 @@\n-    public void testReceiverParameter() {\n+    @Test\n+    void testReceiverParameter() {\n@@ -1245,1 +1266,2 @@\n-    public void testOnlyOneFieldRef() throws Exception {\n+    @Test\n+    void testOnlyOneFieldRef() throws Exception {\n@@ -1295,1 +1317,2 @@\n-    public void testCheckInitializationOrderInCompactConstructor() throws Exception {\n+    @Test\n+    void testCheckInitializationOrderInCompactConstructor() throws Exception {\n@@ -1334,1 +1357,2 @@\n-    public void testAcceptRecordId() {\n+    @Test\n+    void testAcceptRecordId() {\n@@ -1351,1 +1375,2 @@\n-    public void testMultipleAnnosInRecord() throws Exception {\n+    @Test\n+    void testMultipleAnnosInRecord() throws Exception {\n@@ -1392,1 +1417,2 @@\n-    public void testAnnos() throws Exception {\n+    @Test\n+    void testAnnos() throws Exception {\n@@ -1535,1 +1561,2 @@\n-    public void testOnlyTypeAnnotationsOnComponentField() throws Exception {\n+    @Test\n+    void testOnlyTypeAnnotationsOnComponentField() throws Exception {\n@@ -1758,1 +1785,2 @@\n-    public void testMethodsInheritedFromRecordArePublicAndFinal() throws Exception {\n+    @Test\n+    void testMethodsInheritedFromRecordArePublicAndFinal() throws Exception {\n@@ -1777,1 +1805,2 @@\n-    public void testCanonicalAccessibility() throws Exception {\n+    @Test\n+    void testCanonicalAccessibility() throws Exception {\n@@ -1826,1 +1855,2 @@\n-    public void testSameArity() {\n+    @Test\n+    void testSameArity() {\n@@ -1900,1 +1930,2 @@\n-    public void testSafeVararsAnno() {\n+    @Test\n+    void testSafeVararsAnno() {\n@@ -1962,1 +1993,2 @@\n-    public void testOverrideAtAccessor() {\n+    @Test\n+    void testOverrideAtAccessor() {\n@@ -2000,1 +2032,2 @@\n-    public void testNoAssigmentInsideCompactRecord() {\n+    @Test\n+    void testNoAssigmentInsideCompactRecord() {\n@@ -2021,1 +2054,2 @@\n-    public void testNoNPEStaticAnnotatedFields() {\n+    @Test\n+    void testNoNPEStaticAnnotatedFields() {\n@@ -2054,1 +2088,2 @@\n-    public void testDoNotAllowCStyleArraySyntaxForRecComponents() {\n+    @Test\n+    void testDoNotAllowCStyleArraySyntaxForRecComponents() {\n@@ -2072,1 +2107,2 @@\n-    public void testNoWarningForSerializableRecords() {\n+    @Test\n+    void testNoWarningForSerializableRecords() {\n@@ -2087,1 +2123,2 @@\n-    public void testAnnotationsOnVarargsRecComp() {\n+    @Test\n+    void testAnnotationsOnVarargsRecComp() {\n@@ -2122,1 +2159,2 @@\n-    public void testSaveVarargsAnno() {\n+    @Test\n+    void testSaveVarargsAnno() {\n","filename":"test\/langtools\/tools\/javac\/records\/RecordCompilationTests.java","additions":86,"deletions":48,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,2 +36,2 @@\n- * @run testng\/othervm -DuseAP=false SealedCompilationTests\n- * @run testng\/othervm -DuseAP=true SealedCompilationTests\n+ * @run junit\/othervm -DuseAP=false SealedCompilationTests\n+ * @run junit\/othervm -DuseAP=true SealedCompilationTests\n@@ -40,4 +40,0 @@\n-import java.lang.constant.ClassDesc;\n-\n-import java.io.File;\n-\n@@ -48,2 +44,0 @@\n-\n-import java.util.ArrayList;\n@@ -57,1 +51,0 @@\n-\n@@ -63,4 +56,1 @@\n-import static org.testng.Assert.assertEquals;\n-import static org.testng.Assert.assertTrue;\n-import static org.testng.Assert.fail;\n-import org.testng.annotations.Test;\n+import org.junit.jupiter.api.Test;\n@@ -74,2 +64,3 @@\n-@Test\n-public class SealedCompilationTests extends CompilationTestCase {\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+class SealedCompilationTests extends CompilationTestCase {\n@@ -97,1 +88,1 @@\n-    public SealedCompilationTests() {\n+    SealedCompilationTests() {\n@@ -119,1 +110,2 @@\n-    public void testSimpleExtension() {\n+    @Test\n+    void testSimpleExtension() {\n@@ -197,1 +189,2 @@\n-    public void testSealedAndRecords() {\n+    @Test\n+    void testSealedAndRecords() {\n@@ -213,1 +206,2 @@\n-    public void testBadExtension() {\n+    @Test\n+    void testBadExtension() {\n@@ -244,1 +238,2 @@\n-    public void testRestrictedKeyword() {\n+    @Test\n+    void testRestrictedKeyword() {\n@@ -292,1 +287,2 @@\n-    public void testRejectPermitsInNonSealedClass() {\n+    @Test\n+    void testRejectPermitsInNonSealedClass() {\n@@ -305,1 +301,2 @@\n-    public void testTypeInPermitsIsSameClassOrSuper() {\n+    @Test\n+    void testTypeInPermitsIsSameClassOrSuper() {\n@@ -329,1 +326,2 @@\n-    public void testBadModifiers() {\n+    @Test\n+    void testBadModifiers() {\n@@ -347,1 +345,2 @@\n-    public void testAnonymous_FunctionalExpr_and_Sealed() {\n+    @Test\n+    void testAnonymous_FunctionalExpr_and_Sealed() {\n@@ -406,1 +405,2 @@\n-    public void testNoLocalSealedClasses() {\n+    @Test\n+    void testNoLocalSealedClasses() {\n@@ -425,1 +425,2 @@\n-    public void testLocalCantExtendSealed() {\n+    @Test\n+    void testLocalCantExtendSealed() {\n@@ -457,1 +458,2 @@\n-    public void testSealedInterfaceAndAbstracClasses() {\n+    @Test\n+    void testSealedInterfaceAndAbstracClasses() {\n@@ -499,1 +501,2 @@\n-    public void testEnumsCantBeSealedOrNonSealed() {\n+    @Test\n+    void testEnumsCantBeSealedOrNonSealed() {\n@@ -514,1 +517,2 @@\n-    public void testEnumsCanImplementSealedInterfaces() {\n+    @Test\n+    void testEnumsCanImplementSealedInterfaces() {\n@@ -524,1 +528,2 @@\n-    public void testClassesCanExtendNonSealed() {\n+    @Test\n+    void testClassesCanExtendNonSealed() {\n@@ -537,1 +542,2 @@\n-    public void testEmptyPermits() {\n+    @Test\n+    void testEmptyPermits() {\n@@ -547,1 +553,2 @@\n-    public void testTypeVarInPermits() {\n+    @Test\n+    void testTypeVarInPermits() {\n@@ -558,1 +565,2 @@\n-    public void testRepeatedTypeInPermits() {\n+    @Test\n+    void testRepeatedTypeInPermits() {\n@@ -569,1 +577,2 @@\n-    public void testSubtypeDoesntExtendSealed() {\n+    @Test\n+    void testSubtypeDoesntExtendSealed() {\n@@ -593,1 +602,2 @@\n-    public void testAPIForPrimitiveAndArrayClasses() {\n+    @Test\n+    void testAPIForPrimitiveAndArrayClasses() {\n@@ -602,1 +612,2 @@\n-    public void testPrinting() throws Exception {\n+    @Test\n+    void testPrinting() throws Exception {\n@@ -718,1 +729,2 @@\n-    public void testNonSealedErroneousSuper() {\n+    @Test\n+    void testNonSealedErroneousSuper() {\n@@ -730,1 +742,2 @@\n-    public void testNonSealedErroneousSuperInterface() {\n+    @Test\n+    void testNonSealedErroneousSuperInterface() {\n@@ -742,1 +755,2 @@\n-    public void testIllFormedNonSealed() {\n+    @Test\n+    void testIllFormedNonSealed() {\n@@ -770,1 +784,2 @@\n-    public void testPermitsClause() {\n+    @Test\n+    void testPermitsClause() {\n@@ -832,1 +847,2 @@\n-    public void testSealedNonSealedWithOtherModifiers() {\n+    @Test\n+    void testSealedNonSealedWithOtherModifiers() {\n@@ -875,1 +891,2 @@\n-    public void testSubClassBeforeSealedClassInSameCU() {\n+    @Test\n+    void testSubClassBeforeSealedClassInSameCU() {\n@@ -954,1 +971,2 @@\n-    public void testDoNotAllowSealedAnnotation() {\n+    @Test\n+    void testDoNotAllowSealedAnnotation() {\n@@ -965,1 +983,2 @@\n-    public void testNarrowConversion() {\n+    @Test\n+    void testNarrowConversion() {\n@@ -1267,1 +1286,2 @@\n-    public void testIntersectionWithSealedClasses() {\n+    @Test\n+    void testIntersectionWithSealedClasses() {\n","filename":"test\/langtools\/tools\/javac\/sealed\/SealedCompilationTests.java","additions":66,"deletions":46,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -604,0 +604,46 @@\n+\n+    \/\/ Verify no assertion error occurs (JDK-8317336)\n+    public static class ThisEscapeAssertionError {\n+        public ThisEscapeAssertionError() {\n+            System.out.println((Supplier<Object>)() -> this);\n+        }\n+    }\n+\n+    \/\/ Verify no assertion error occurs (JDK-8317336)\n+    public static class ThisEscapeAssertionError2 {\n+        public ThisEscapeAssertionError2() {\n+            ThisEscapeAssertionError2[] array = new ThisEscapeAssertionError2[] { this };\n+            for (Object obj : array)\n+                ;\n+        }\n+    }\n+\n+    \/\/ Verify no infinite recursion loop occurs (JDK-8317818)\n+    public static class ThisEscapeRecursionExplosion {\n+        private Object obj;\n+        public ThisEscapeRecursionExplosion() {\n+            getObject();\n+        }\n+        private Object getObject() {\n+            if (this.obj == null) {\n+                this.obj = new Object();\n+                getObject().hashCode();\n+                getObject().hashCode();\n+                getObject().hashCode();\n+                getObject().hashCode();\n+                getObject().hashCode();\n+                getObject().hashCode();\n+                getObject().hashCode();\n+                getObject().hashCode();\n+                getObject().hashCode();\n+                getObject().hashCode();\n+                getObject().hashCode();\n+                getObject().hashCode();\n+                getObject().hashCode();\n+                getObject().hashCode();\n+                getObject().hashCode();\n+                getObject().hashCode();\n+            }\n+            return this.obj;\n+        }\n+    }\n","filename":"test\/langtools\/tools\/javac\/warnings\/ThisEscape.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,3 +56,3 @@\n-    \/\/ referers and referersLen go through two phases:  Building and\n-    \/\/ resolved.  When building, referers might have duplicates, but can\n-    \/\/ be appended to.  When resolved, referers has no duplicates or\n+    \/\/ referrers and referrersLen go through two phases:  Building and\n+    \/\/ resolved.  When building, referrers might have duplicates, but can\n+    \/\/ be appended to.  When resolved, referrers has no duplicates or\n@@ -61,2 +61,2 @@\n-    private JavaThing[] referers = null;\n-    private int referersLen = 0;        \/\/ -1 when resolved\n+    private JavaThing[] referrers = null;\n+    private int referrersLen = 0;        \/\/ -1 when resolved\n@@ -80,1 +80,1 @@\n-    \/\/  Eliminate duplicates from referers, and size the array exactly.\n+    \/\/ Eliminate duplicates from referrers, and size the array exactly.\n@@ -82,1 +82,1 @@\n-    \/\/ referers data member for details.\n+    \/\/ referrers data member for details.\n@@ -84,3 +84,3 @@\n-    void setupReferers() {\n-        if (referersLen > 1) {\n-            \/\/ Copy referers to map, screening out duplicates\n+    void setupReferrers() {\n+        if (referrersLen > 1) {\n+            \/\/ Copy referrers to map, screening out duplicates\n@@ -88,3 +88,3 @@\n-            for (int i = 0; i < referersLen; i++) {\n-                if (map.get(referers[i]) == null) {\n-                    map.put(referers[i], referers[i]);\n+            for (int i = 0; i < referrersLen; i++) {\n+                if (map.get(referrers[i]) == null) {\n+                    map.put(referrers[i], referrers[i]);\n@@ -95,2 +95,2 @@\n-            referers = new JavaThing[map.size()];\n-            map.keySet().toArray(referers);\n+            referrers = new JavaThing[map.size()];\n+            map.keySet().toArray(referrers);\n@@ -98,1 +98,1 @@\n-        referersLen = -1;\n+        referrersLen = -1;\n@@ -137,6 +137,6 @@\n-        if (referersLen == 0) {\n-            referers = new JavaThing[1];        \/\/ It was null\n-        } else if (referersLen == referers.length) {\n-            JavaThing[] copy = new JavaThing[(3 * (referersLen + 1)) \/ 2];\n-            System.arraycopy(referers, 0, copy, 0, referersLen);\n-            referers = copy;\n+        if (referrersLen == 0) {\n+            referrers = new JavaThing[1];        \/\/ It was null\n+        } else if (referrersLen == referrers.length) {\n+            JavaThing[] copy = new JavaThing[(3 * (referrersLen + 1)) \/ 2];\n+            System.arraycopy(referrers, 0, copy, 0, referrersLen);\n+            referrers = copy;\n@@ -144,2 +144,2 @@\n-        referers[referersLen++] = other;\n-        \/\/ We just append to referers here.  Measurements have shown that\n+        referrers[referrersLen++] = other;\n+        \/\/ We just append to referrers here.  Measurements have shown that\n@@ -167,2 +167,2 @@\n-    public Enumeration<JavaThing> getReferers() {\n-        if (referersLen != -1) {\n+    public Enumeration<JavaThing> getReferrers() {\n+        if (referrersLen != -1) {\n@@ -176,1 +176,1 @@\n-                return referers != null && num < referers.length;\n+                return referrers != null && num < referrers.length;\n@@ -180,1 +180,1 @@\n-                return referers[num++];\n+                return referrers[num++];\n@@ -186,1 +186,1 @@\n-     * Given other, which the caller promises is in referers, determines if\n+     * Given other, which the caller promises is in referrers, determines if\n","filename":"test\/lib\/jdk\/test\/lib\/hprof\/model\/JavaHeapObject.java","additions":30,"deletions":30,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,2 +49,2 @@\n-    private long refererId;     \/\/ Thread or Class responsible for this, or 0\n-    private int index = -1;             \/\/ Index in Snapshot.roots\n+    private long referrerId;    \/\/ Thread or Class responsible for this, or 0\n+    private int index = -1;     \/\/ Index in Snapshot.roots\n@@ -53,1 +53,1 @@\n-    private JavaHeapObject referer = null;\n+    private JavaHeapObject referrer = null;\n@@ -71,2 +71,2 @@\n-    public Root(long id, long refererId, int type, String description) {\n-        this(id, refererId, type, description, null);\n+    public Root(long id, long referrerId, int type, String description) {\n+        this(id, referrerId, type, description, null);\n@@ -76,1 +76,1 @@\n-    public Root(long id, long refererId, int type, String description,\n+    public Root(long id, long referrerId, int type, String description,\n@@ -79,1 +79,1 @@\n-        this.refererId = refererId;\n+        this.referrerId = referrerId;\n@@ -140,2 +140,6 @@\n-    public JavaHeapObject getReferer() {\n-        return referer;\n+    public JavaHeapObject getReferrer() {\n+        return referrer;\n+    }\n+\n+    public long getReferrerId() {\n+        return referrerId;\n@@ -160,2 +164,2 @@\n-        if (refererId != 0) {\n-            referer = ss.findThing(refererId);\n+        if (referrerId != 0) {\n+            referrer = ss.findThing(referrerId);\n","filename":"test\/lib\/jdk\/test\/lib\/hprof\/model\/Root.java","additions":16,"deletions":12,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,0 +85,3 @@\n+    \/\/ threads\n+    private ArrayList<ThreadObject> threads = new ArrayList<>();\n+\n@@ -178,0 +181,4 @@\n+    public void addThreadObject(ThreadObject thread) {\n+        threads.add(thread);\n+    }\n+\n@@ -296,1 +303,1 @@\n-            t.setupReferers();\n+            t.setupReferrers();\n@@ -436,0 +443,4 @@\n+    public List<ThreadObject> getThreads() {\n+        return Collections.unmodifiableList(threads);\n+    }\n+\n@@ -453,1 +464,1 @@\n-                \/\/ referers, because they might be more interesting.\n+                \/\/ referrers, because they might be more interesting.\n@@ -455,3 +466,3 @@\n-            Enumeration<JavaThing> referers = curr.getReferers();\n-            while (referers.hasMoreElements()) {\n-                JavaHeapObject t = (JavaHeapObject) referers.nextElement();\n+            Enumeration<JavaThing> referrers = curr.getReferrers();\n+            while (referrers.hasMoreElements()) {\n+                JavaHeapObject t = (JavaHeapObject)referrers.nextElement();\n","filename":"test\/lib\/jdk\/test\/lib\/hprof\/model\/Snapshot.java","additions":17,"deletions":6,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.hprof.model;\n+\n+import jdk.test.lib.hprof.util.Misc;\n+\n+public class ThreadObject {\n+\n+    private final long id;            \/\/ ID of the JavaThing we refer to\n+    private final StackTrace stackTrace;\n+\n+    public ThreadObject(long id, StackTrace stackTrace) {\n+        this.id = id;\n+        this.stackTrace = stackTrace;\n+    }\n+\n+    public long getId() {\n+        return id;\n+    }\n+\n+    public String getIdString() {\n+        return Misc.toHex(id);\n+    }\n+\n+    public StackTrace getStackTrace() {\n+        return stackTrace;\n+    }\n+\n+    void resolve(Snapshot ss) {\n+        if (stackTrace != null) {\n+            stackTrace.resolve(ss);\n+        }\n+    }\n+\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/hprof\/model\/ThreadObject.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -439,2 +439,4 @@\n-                    threadObjects.put(threadSeq,\n-                                      new ThreadObject(id, stackSeq));\n+                    StackTrace st = getStackTraceFromSerial(stackSeq);\n+                    ThreadObject threadObj = new ThreadObject(id, st);\n+                    threadObjects.put(threadSeq, threadObj);\n+                    snapshot.addThreadObject(threadObj);\n@@ -456,1 +458,1 @@\n-                    StackTrace st = getStackTraceFromSerial(to.stackSeq);\n+                    StackTrace st = to.getStackTrace();\n@@ -460,1 +462,1 @@\n-                    snapshot.addRoot(new Root(id, to.threadId,\n+                    snapshot.addRoot(new Root(id, to.getId(),\n@@ -470,1 +472,1 @@\n-                    StackTrace st = getStackTraceFromSerial(to.stackSeq);\n+                    StackTrace st = to.getStackTrace();;\n@@ -474,1 +476,1 @@\n-                    snapshot.addRoot(new Root(id, to.threadId,\n+                    snapshot.addRoot(new Root(id, to.getId(),\n@@ -483,2 +485,2 @@\n-                    StackTrace st = getStackTraceFromSerial(to.stackSeq);\n-                    snapshot.addRoot(new Root(id, to.threadId,\n+                    StackTrace st = to.getStackTrace();;\n+                    snapshot.addRoot(new Root(id, to.getId(),\n@@ -499,2 +501,2 @@\n-                    StackTrace st = getStackTraceFromSerial(to.stackSeq);\n-                    snapshot.addRoot(new Root(id, to.threadId,\n+                    StackTrace st = to.getStackTrace();\n+                    snapshot.addRoot(new Root(id, to.getId(),\n@@ -916,14 +918,0 @@\n-    \/\/\n-    \/\/ A trivial data-holder class for HPROF_GC_ROOT_THREAD_OBJ.\n-    \/\/\n-    private class ThreadObject {\n-\n-        long threadId;\n-        int stackSeq;\n-\n-        ThreadObject(long threadId, int stackSeq) {\n-            this.threadId = threadId;\n-            this.stackSeq = stackSeq;\n-        }\n-    }\n-\n","filename":"test\/lib\/jdk\/test\/lib\/hprof\/parser\/HprofReader.java","additions":13,"deletions":25,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\" })\n+public class AllocFromSliceTest extends CLayouts {\n+\n+    @Param({\"5\", \"20\", \"100\", \"500\", \"1000\"})\n+    public int size;\n+    public int start;\n+    public byte[] arr;\n+\n+    @Setup\n+    public void setup() {\n+        arr = new byte[1024];\n+        Random random = new Random(0);\n+        random.nextBytes(arr);\n+        start = random.nextInt(1024 - size);\n+    }\n+\n+    @Benchmark\n+    public MemorySegment alloc_confined() {\n+        Arena arena = Arena.ofConfined();\n+        MemorySegment segment = arena.allocate(size);\n+        MemorySegment.copy(arr, start, segment, C_CHAR, 0, size);\n+        arena.close();\n+        return segment;\n+    }\n+\n+    @Benchmark\n+    public MemorySegment alloc_confined_slice() {\n+        Arena arena = Arena.ofConfined();\n+        MemorySegment segment = arena.allocateFrom(C_CHAR, MemorySegment.ofArray(arr), C_CHAR, start, size);\n+        arena.close();\n+        return segment;\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/AllocFromSliceTest.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -0,0 +1,176 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.MemorySegment.Scope;\n+import java.lang.foreign.SegmentAllocator;\n+import java.lang.foreign.ValueLayout;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\" })\n+public class AllocFromTest extends CLayouts {\n+\n+    Arena arena = Arena.ofConfined();\n+\n+    SlicingPool pool = new SlicingPool();\n+\n+    @Param({\"5\", \"20\", \"100\", \"500\", \"1000\"})\n+    public int size;\n+    public byte[] arr;\n+\n+    @Setup\n+    public void setup() {\n+        arr = new byte[size];\n+        Random random = new Random(0);\n+        random.nextBytes(arr);\n+    }\n+\n+    @Benchmark\n+    public MemorySegment alloc_confined() {\n+        Arena arena = Arena.ofConfined();\n+        MemorySegment segment = arena.allocateFrom(ValueLayout.JAVA_BYTE, arr);\n+        arena.close();\n+        return segment;\n+    }\n+\n+    @Benchmark\n+    public MemorySegment alloc_malloc_arena() {\n+        MallocArena arena = new MallocArena();\n+        MemorySegment segment = arena.allocateFrom(ValueLayout.JAVA_BYTE, arr);\n+        arena.close();\n+        return segment;\n+    }\n+\n+    @Benchmark\n+    public MemorySegment alloc_unsafe_arena() {\n+        UnsafeArena arena = new UnsafeArena();\n+        MemorySegment segment = arena.allocateFrom(ValueLayout.JAVA_BYTE, arr);\n+        arena.close();\n+        return segment;\n+    }\n+\n+    @Benchmark\n+    public MemorySegment alloc_pool_arena() {\n+        Arena arena = pool.acquire();\n+        MemorySegment segment = arena.allocateFrom(ValueLayout.JAVA_BYTE, arr);\n+        arena.close();\n+        return segment;\n+    }\n+\n+    static class SlicingPool {\n+        final MemorySegment pool = Arena.ofAuto().allocate(1024);\n+        boolean isAcquired = false;\n+\n+        public Arena acquire() {\n+            if (isAcquired) {\n+                throw new IllegalStateException(\"An allocator is already in use\");\n+            }\n+            isAcquired = true;\n+            return new SlicingPoolAllocator();\n+        }\n+\n+        class SlicingPoolAllocator implements Arena {\n+\n+            final Arena arena = Arena.ofConfined();\n+            final SegmentAllocator slicing = SegmentAllocator.slicingAllocator(pool);\n+\n+            public MemorySegment allocate(long byteSize, long byteAlignment) {\n+                return slicing.allocate(byteSize, byteAlignment)\n+                        .reinterpret(arena, null);\n+            }\n+\n+            @Override\n+            public Scope scope() {\n+                return arena.scope();\n+            }\n+\n+            public void close() {\n+                isAcquired = false;\n+                arena.close();\n+            }\n+        }\n+    }\n+\n+    public static class MallocArena implements Arena {\n+\n+        final Arena arena = Arena.ofConfined();\n+\n+        @Override\n+        public Scope scope() {\n+            return arena.scope();\n+        }\n+\n+        @Override\n+        public void close() {\n+            arena.close();\n+        }\n+\n+        @Override\n+        public MemorySegment allocate(long byteSize, long byteAlignment) {\n+            return CLayouts.allocateMemory(byteSize)\n+                    .reinterpret(byteSize, arena, CLayouts::freeMemory);\n+        }\n+    }\n+\n+    public static class UnsafeArena implements Arena {\n+\n+        final Arena arena = Arena.ofConfined();\n+\n+        @Override\n+        public Scope scope() {\n+            return arena.scope();\n+        }\n+\n+        @Override\n+        public void close() {\n+            arena.close();\n+        }\n+\n+        @Override\n+        public MemorySegment allocate(long byteSize, long byteAlignment) {\n+            return MemorySegment.ofAddress(Utils.unsafe.allocateMemory(byteSize))\n+                    .reinterpret(byteSize, arena, ms -> Utils.unsafe.freeMemory(ms.address()));\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/AllocFromTest.java","additions":176,"deletions":0,"binary":false,"changes":176,"status":"added"},{"patch":"@@ -0,0 +1,145 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.MemorySegment.Scope;\n+import java.lang.foreign.SegmentAllocator;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.invoke.MethodHandle;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\" })\n+public class AllocTest extends CLayouts {\n+\n+    Arena arena = Arena.ofConfined();\n+\n+    @Param({\"5\", \"20\", \"100\", \"500\", \"1000\"})\n+    public int size;\n+\n+    @TearDown\n+    public void tearDown() {\n+        arena.close();\n+    }\n+\n+    @Benchmark\n+    public MemorySegment alloc_confined() {\n+        Arena arena = Arena.ofConfined();\n+        MemorySegment segment = arena.allocate(size);\n+        arena.close();\n+        return segment;\n+    }\n+\n+    @Benchmark\n+    public long alloc_calloc_arena() {\n+        CallocArena arena = new CallocArena();\n+        MemorySegment segment = arena.allocate(size);\n+        arena.close();\n+        return segment.address();\n+    }\n+\n+    @Benchmark\n+    public long alloc_unsafe_arena() {\n+        UnsafeArena arena = new UnsafeArena();\n+        MemorySegment segment = arena.allocate(size);\n+        arena.close();\n+        return segment.address();\n+    }\n+\n+    public static class CallocArena implements Arena {\n+\n+        static final MethodHandle CALLOC = Linker.nativeLinker()\n+                .downcallHandle(\n+                        Linker.nativeLinker().defaultLookup().find(\"calloc\").get(),\n+                        FunctionDescriptor.of(ValueLayout.ADDRESS, ValueLayout.JAVA_LONG, ValueLayout.JAVA_LONG));\n+\n+        static MemorySegment calloc(long size) {\n+            try {\n+                return (MemorySegment)CALLOC.invokeExact(size, 1L);\n+            } catch (Throwable ex) {\n+                throw new IllegalStateException(ex);\n+            }\n+        }\n+\n+        final Arena arena = Arena.ofConfined();\n+\n+        @Override\n+        public Scope scope() {\n+            return arena.scope();\n+        }\n+\n+        @Override\n+        public void close() {\n+            arena.close();\n+        }\n+\n+        @Override\n+        public MemorySegment allocate(long byteSize, long byteAlignment) {\n+            return calloc(byteSize)\n+                    .reinterpret(byteSize, arena, CLayouts::freeMemory);\n+        }\n+    }\n+\n+    public static class UnsafeArena implements Arena {\n+\n+        final Arena arena = Arena.ofConfined();\n+\n+        @Override\n+        public Scope scope() {\n+            return arena.scope();\n+        }\n+\n+        @Override\n+        public void close() {\n+            arena.close();\n+        }\n+\n+        @Override\n+        public MemorySegment allocate(long byteSize, long byteAlignment) {\n+            MemorySegment segment = MemorySegment.ofAddress(Utils.unsafe.allocateMemory(byteSize));\n+            Utils.unsafe.setMemory(segment.address(), byteSize, (byte)0);\n+            return segment.reinterpret(byteSize, arena, ms -> Utils.unsafe.freeMemory(segment.address()));\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/AllocTest.java","additions":145,"deletions":0,"binary":false,"changes":145,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,1 @@\n-@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n+@Fork(3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/BulkOps.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,1 +72,1 @@\n-            .withTargetLayout(MemoryLayout.sequenceLayout(C_CHAR));\n+            .withTargetLayout(MemoryLayout.sequenceLayout(Long.MAX_VALUE, C_CHAR));\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/CLayouts.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\", \"--enable-preview\" })\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\" })\n@@ -58,2 +58,2 @@\n-    public void panama_blank_trivial() throws Throwable {\n-        func_trivial.invokeExact();\n+    public void panama_blank_critical() throws Throwable {\n+        func_critical.invokeExact();\n@@ -73,2 +73,2 @@\n-    public int panama_identity_trivial() throws Throwable {\n-        return (int) identity_trivial.invokeExact(10);\n+    public int panama_identity_critical() throws Throwable {\n+        return (int) identity_critical.invokeExact(10);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/CallOverheadConstant.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-    static final MethodHandle func_trivial;\n+    static final MethodHandle func_critical;\n@@ -39,1 +39,1 @@\n-    static final MethodHandle func_trivial_v;\n+    static final MethodHandle func_critical_v;\n@@ -42,1 +42,1 @@\n-    static final MethodHandle identity_trivial;\n+    static final MethodHandle identity_critical;\n@@ -44,1 +44,1 @@\n-    static final MethodHandle identity_trivial_v;\n+    static final MethodHandle identity_critical_v;\n@@ -116,1 +116,1 @@\n-            func_trivial_v = abi.downcallHandle(fd, Linker.Option.isTrivial());\n+            func_critical_v = abi.downcallHandle(fd, Linker.Option.critical());\n@@ -118,1 +118,1 @@\n-            func_trivial = insertArguments(func_trivial_v, 0, func_addr);\n+            func_critical = insertArguments(func_critical_v, 0, func_addr);\n@@ -124,1 +124,1 @@\n-            identity_trivial_v = abi.downcallHandle(fd, Linker.Option.isTrivial());\n+            identity_critical_v = abi.downcallHandle(fd, Linker.Option.critical());\n@@ -126,1 +126,1 @@\n-            identity_trivial = insertArguments(identity_trivial_v, 0, identity_addr);\n+            identity_critical = insertArguments(identity_critical_v, 0, identity_addr);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/CallOverheadHelper.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\", \"--enable-preview\" })\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\" })\n@@ -58,2 +58,2 @@\n-    public void panama_blank_trivial() throws Throwable {\n-        func_trivial_v.invokeExact(func_addr);\n+    public void panama_blank_critical() throws Throwable {\n+        func_critical_v.invokeExact(func_addr);\n@@ -112,2 +112,2 @@\n-    public int panama_identity_trivial() throws Throwable {\n-        return (int) identity_trivial_v.invokeExact(identity_addr, 10);\n+    public int panama_identity_critical() throws Throwable {\n+        return (int) identity_critical_v.invokeExact(identity_addr, 10);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/CallOverheadVirtual.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,161 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import static java.lang.foreign.ValueLayout.*;\n+import static jdk.internal.foreign.StringSupport.*;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgsAppend = {\"--add-exports=java.base\/jdk.internal.foreign=ALL-UNNAMED\", \"--enable-native-access=ALL-UNNAMED\", \"--enable-preview\"})\n+public class InternalStrLen {\n+\n+    private MemorySegment singleByteSegment;\n+    private MemorySegment singleByteSegmentMisaligned;\n+    private MemorySegment doubleByteSegment;\n+    private MemorySegment quadByteSegment;\n+\n+    @Param({\"1\", \"4\", \"16\", \"251\", \"1024\"})\n+    int size;\n+\n+    @Setup\n+    public void setup() {\n+        var arena = Arena.ofAuto();\n+        singleByteSegment = arena.allocate((size + 1L) * Byte.BYTES);\n+        singleByteSegmentMisaligned = arena.allocate((size + 1L) * Byte.BYTES);\n+        doubleByteSegment = arena.allocate((size + 1L) * Short.BYTES);\n+        quadByteSegment = arena.allocate((size + 1L) * Integer.BYTES);\n+        Stream.of(singleByteSegment, doubleByteSegment, quadByteSegment)\n+                .forEach(s -> IntStream.range(0, (int) s.byteSize() - 1)\n+                        .forEach(i -> s.set(\n+                                ValueLayout.JAVA_BYTE,\n+                                i,\n+                                (byte) ThreadLocalRandom.current().nextInt(1, 254)\n+                        )));\n+        singleByteSegment.set(ValueLayout.JAVA_BYTE, singleByteSegment.byteSize() - Byte.BYTES, (byte) 0);\n+        doubleByteSegment.set(ValueLayout.JAVA_SHORT, doubleByteSegment.byteSize() - Short.BYTES, (short) 0);\n+        quadByteSegment.set(ValueLayout.JAVA_INT, quadByteSegment.byteSize() - Integer.BYTES, 0);\n+        singleByteSegmentMisaligned = arena.allocate(singleByteSegment.byteSize() + 1).\n+                asSlice(1);\n+        MemorySegment.copy(singleByteSegment, 0, singleByteSegmentMisaligned, 0, singleByteSegment.byteSize());\n+    }\n+\n+    @Benchmark\n+    public int elementSingle() {\n+        return legacy_strlen_byte(singleByteSegment, 0);\n+    }\n+\n+    @Benchmark\n+    public int elementByteMisaligned() {\n+        return legacy_strlen_byte(singleByteSegmentMisaligned, 0);\n+    }\n+\n+    @Benchmark\n+    public int elementDouble() {\n+        return legacy_strlen_short(doubleByteSegment, 0);\n+    }\n+\n+    @Benchmark\n+    public int elementQuad() {\n+        return legacy_strlen_int(quadByteSegment, 0);\n+    }\n+\n+    @Benchmark\n+    public int chunkedSingle() {\n+        return chunkedStrlenByte(singleByteSegment, 0);\n+    }\n+\n+    @Benchmark\n+    public int chunkedSingleMisaligned() {\n+        return chunkedStrlenByte(singleByteSegmentMisaligned, 0);\n+    }\n+\n+    @Benchmark\n+    public int chunkedDouble() {\n+        return chunkedStrlenShort(doubleByteSegment, 0);\n+    }\n+\n+    @Benchmark\n+    public int changedElementQuad() {\n+        return strlenInt(quadByteSegment, 0);\n+    }\n+\n+    \/\/ These are the legacy methods\n+\n+    private static int legacy_strlen_byte(MemorySegment segment, long start) {\n+        \/\/ iterate until overflow (String can only hold a byte[], whose length can be expressed as an int)\n+        for (int offset = 0; offset >= 0; offset++) {\n+            byte curr = segment.get(JAVA_BYTE, start + offset);\n+            if (curr == 0) {\n+                return offset;\n+            }\n+        }\n+        throw new IllegalArgumentException(\"String too large\");\n+    }\n+\n+    private static int legacy_strlen_short(MemorySegment segment, long start) {\n+        \/\/ iterate until overflow (String can only hold a byte[], whose length can be expressed as an int)\n+        for (int offset = 0; offset >= 0; offset += 2) {\n+            short curr = segment.get(JAVA_SHORT, start + offset);\n+            if (curr == 0) {\n+                return offset;\n+            }\n+        }\n+        throw new IllegalArgumentException(\"String too large\");\n+    }\n+\n+    private static int legacy_strlen_int(MemorySegment segment, long start) {\n+        \/\/ iterate until overflow (String can only hold a byte[], whose length can be expressed as an int)\n+        for (int offset = 0; offset >= 0; offset += 4) {\n+            int curr = segment.get(JAVA_INT, start + offset);\n+            if (curr == 0) {\n+                return offset;\n+            }\n+        }\n+        throw new IllegalArgumentException(\"String too large\");\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/InternalStrLen.java","additions":161,"deletions":0,"binary":false,"changes":161,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -29,1 +30,4 @@\n-import static java.lang.foreign.ValueLayout.*;\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n+import static java.lang.foreign.ValueLayout.JAVA_INT_UNALIGNED;\n+import static java.lang.foreign.ValueLayout.JAVA_LONG;\n+import static java.lang.foreign.ValueLayout.JAVA_LONG_UNALIGNED;\n@@ -32,1 +36,1 @@\n- * Some useful Java {@link ValueLayout} and associated {@link ValueLayout#arrayElementVarHandle(int...)} var handles.\n+ * Some useful Java {@link ValueLayout} and associated array var handles.\n@@ -36,1 +40,2 @@\n-    static final VarHandle VH_INT_UNALIGNED = JAVA_INT_UNALIGNED.arrayElementVarHandle();\n+    static final VarHandle VH_INT_UNALIGNED = arrayVarHandle(JAVA_INT_UNALIGNED);\n+    static final VarHandle VH_INT = arrayVarHandle(JAVA_INT);\n@@ -38,1 +43,7 @@\n-    static final VarHandle VH_INT = JAVA_INT.arrayElementVarHandle();\n+    static final VarHandle VH_LONG_UNALIGNED = arrayVarHandle(JAVA_LONG_UNALIGNED);\n+    static final VarHandle VH_LONG = arrayVarHandle(JAVA_LONG);\n+\n+    private static VarHandle arrayVarHandle(ValueLayout layout) {\n+        return MethodHandles.collectCoordinates(layout.varHandle(),\n+            1, MethodHandles.insertArguments(layout.scaleHandle(), 0, 0L));\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/JavaLayouts.java","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\", \"--enable-preview\" })\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\" })\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LinkUpcall.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,1 @@\n-@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n+@Fork(3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverConstant.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,1 @@\n-@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n+@Fork(3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNew.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,1 @@\n-@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n+@Fork(3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNewHeap.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--enable-preview\", \"--enable-native-access=ALL-UNNAMED\" })\n+@Fork(3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNonConstant.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,1 @@\n-@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n+@Fork(3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNonConstantFP.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,1 @@\n-@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n+@Fork(3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNonConstantHeap.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,1 @@\n-@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n+@Fork(3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNonConstantMapped.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,1 @@\n-@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n+@Fork(3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNonConstantShared.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n+@Fork(3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverOfAddress.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,1 @@\n-@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n+@Fork(3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverPollutedBuffer.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n-@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n+@Fork(3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverPollutedSegments.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--enable-preview\", \"--enable-native-access=ALL-UNNAMED\" })\n+@Fork(3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverSlice.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import sun.misc.Unsafe;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import static java.lang.foreign.ValueLayout.*;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgsAppend = {\"--enable-native-access=ALL-UNNAMED\"})\n+public class MemorySegmentCopyUnsafe {\n+\n+    static final Unsafe UNSAFE = Utils.unsafe;\n+\n+    long src;\n+    long dst;\n+\n+    @Setup\n+    public void setup() throws Throwable {\n+        src = Arena.global().allocate(JAVA_INT).address();\n+        dst = Arena.global().allocate(JAVA_INT).address();\n+    }\n+\n+    @Benchmark\n+    public void panama() {\n+        MemorySegment srcSeg = MemorySegment.ofAddress(src).reinterpret(JAVA_INT.byteSize());\n+        MemorySegment dstSeg = MemorySegment.ofAddress(dst).reinterpret(JAVA_INT.byteSize());\n+        dstSeg.copyFrom(srcSeg);\n+    }\n+\n+    @Benchmark\n+    public void unsafe() {\n+        UNSAFE.copyMemory(src, dst, JAVA_INT.byteSize());\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/MemorySegmentCopyUnsafe.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.invoke.VarHandle;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import sun.misc.Unsafe;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import static java.lang.foreign.ValueLayout.*;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgsAppend = {\"--enable-native-access=ALL-UNNAMED\"})\n+public class MemorySegmentGetUnsafe {\n+\n+    static final Unsafe UNSAFE = Utils.unsafe;\n+    static final MethodHandle OF_ADDRESS_UNSAFE;\n+\n+    static {\n+        try {\n+            OF_ADDRESS_UNSAFE = MethodHandles.lookup().findStatic(MemorySegmentGetUnsafe.class,\n+                    \"ofAddressUnsafe\", MethodType.methodType(MemorySegment.class, long.class));\n+        } catch (ReflectiveOperationException e) {\n+            throw new ExceptionInInitializerError(e);\n+        }\n+    }\n+\n+    static final VarHandle INT_HANDLE = adaptSegmentHandle(JAVA_INT.varHandle());\n+\n+    static VarHandle adaptSegmentHandle(VarHandle handle) {\n+        handle = MethodHandles.insertCoordinates(handle, 1, 0L);\n+        handle = MethodHandles.filterCoordinates(handle, 0, OF_ADDRESS_UNSAFE);\n+        return handle;\n+    }\n+\n+    static MemorySegment ofAddressUnsafe(long address) {\n+        return MemorySegment.ofAddress(address).reinterpret(JAVA_INT.byteSize());\n+    }\n+\n+    long addr;\n+\n+    @Setup\n+    public void setup() throws Throwable {\n+        addr = Arena.global().allocate(JAVA_INT).address();\n+    }\n+\n+    @Benchmark\n+    public int panama() {\n+        return (int) INT_HANDLE.get(addr);\n+    }\n+\n+    @Benchmark\n+    public int unsafe() {\n+        return UNSAFE.getInt(addr);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/MemorySegmentGetUnsafe.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,1 +61,1 @@\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-native-access=ALL-UNNAMED\", \"--enable-preview\"})\n+@Fork(3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/MemorySegmentVsBits.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n-@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n+@Fork(3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/MemorySessionClose.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,1 +55,1 @@\n-@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n+@Fork(3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/ParallelSum.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\", \"--enable-preview\" })\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\" })\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/PointerInvoke.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\", \"--enable-preview\" })\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\" })\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/QSort.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\", \"--enable-preview\" })\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\" })\n@@ -95,1 +95,1 @@\n-            MemorySegment segment = arena.allocateUtf8String(str);\n+            MemorySegment segment = arena.allocateFrom(str);\n@@ -102,1 +102,1 @@\n-        return (int)STRLEN.invokeExact(arenaAllocator.allocateUtf8String(str));\n+        return (int)STRLEN.invokeExact(arenaAllocator.allocateFrom(str));\n@@ -108,1 +108,1 @@\n-        int l = (int) STRLEN.invokeExact(arena.allocateUtf8String(str));\n+        int l = (int) STRLEN.invokeExact(arena.allocateFrom(str));\n@@ -115,1 +115,1 @@\n-        return (int)STRLEN.invokeExact(segmentAllocator.allocateUtf8String(str));\n+        return (int)STRLEN.invokeExact(segmentAllocator.allocateFrom(str));\n@@ -165,1 +165,1 @@\n-            long lastOffset = segment.segmentOffset(res) + res.byteSize();\n+            long lastOffset = res.address() - segment.address() + res.byteSize();\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/StrLenTest.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,1 @@\n-@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n+@Fork(3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/TestAdaptVarHandles.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,4 +51,1 @@\n-@Fork(value = 1, jvmArgsAppend = {\n-        \"-Dforeign.restricted=permit\",\n-        \"--enable-native-access\", \"ALL-UNNAMED\",\n-        \"--enable-preview\"})\n+@Fork(1)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/TestLoadBytes.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.MemorySegment.Scope;\n+import java.lang.foreign.SegmentAllocator;\n+import java.lang.invoke.MethodHandle;\n+import java.util.concurrent.TimeUnit;\n+\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\" })\n+public class ToCStringTest extends CLayouts {\n+\n+    @Param({\"5\", \"20\", \"100\", \"200\"})\n+    public int size;\n+    public String str;\n+\n+    static {\n+        System.loadLibrary(\"ToCString\");\n+    }\n+\n+    static final MethodHandle STRLEN;\n+\n+    static {\n+        Linker abi = Linker.nativeLinker();\n+        STRLEN = abi.downcallHandle(abi.defaultLookup().find(\"strlen\").get(),\n+                FunctionDescriptor.of(C_INT, C_POINTER));\n+    }\n+\n+    @Setup\n+    public void setup() {\n+        str = makeString(size);\n+    }\n+\n+    @Benchmark\n+    public long jni_writeString() throws Throwable {\n+        return writeString(str);\n+    }\n+\n+    @Benchmark\n+    public MemorySegment panama_writeString() throws Throwable {\n+        Arena arena = Arena.ofConfined();\n+        MemorySegment segment = arena.allocateFrom(str);\n+        arena.close();\n+        return segment;\n+    }\n+\n+    static native long writeString(String str);\n+\n+    static String makeString(int size) {\n+        String lorem = \"\"\"\n+                Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et\n+                 dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip\n+                 ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu\n+                 fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt\n+                 mollit anim id est laborum.\n+                \"\"\";\n+        return lorem.substring(0, size);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/ToCStringTest.java","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgsAppend = {\"--enable-native-access=ALL-UNNAMED\", \"--enable-preview\"})\n+public class ToJavaStringTest {\n+\n+    private MemorySegment strSegment;\n+\n+    @Param({\"5\", \"20\", \"100\", \"200\"})\n+    int size;\n+\n+    static {\n+        System.loadLibrary(\"ToJavaString\");\n+    }\n+\n+    @Setup\n+    public void setup() {\n+        var arena = Arena.ofAuto();\n+        strSegment = arena.allocateFrom(LOREM.substring(0, size));\n+    }\n+\n+    @Benchmark\n+    public String panama_readString() {\n+        return strSegment.getString(0);\n+    }\n+\n+    @Benchmark\n+    public String jni_readString() {\n+        return readString(strSegment.address());\n+    }\n+\n+    static native String readString(long addr);\n+\n+    static String LOREM = \"\"\"\n+                Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et\n+                 dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip\n+                 ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu\n+                 fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt\n+                 mollit anim id est laborum.\n+                \"\"\";\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/ToJavaStringTest.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--enable-preview\", \"--enable-native-access=ALL-UNNAMED\" })\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\" })\n@@ -48,4 +48,0 @@\n-    static final VarHandle VH_LONG_UNALIGNED = JAVA_LONG_UNALIGNED.arrayElementVarHandle();\n-\n-    static final VarHandle VH_LONG = JAVA_LONG.arrayElementVarHandle();\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/UnrolledAccess.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\", \"--enable-preview\" })\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\" })\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/Upcalls.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,1 @@\n-@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n+@Fork(3)\n@@ -57,1 +57,1 @@\n-        generic = MethodHandles.memorySegmentViewVarHandle(JAVA_INT);\n+        generic = JAVA_INT.varHandle();\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/VarHandleExact.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <jlong.h>\n+#include <jni.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+JNIEXPORT jlong JNICALL Java_org_openjdk_bench_java_lang_foreign_ToCStringTest_writeString(JNIEnv *const env, const jclass cls, const jstring text) {\n+    const char *str = (*env)->GetStringUTFChars(env, text, NULL);\n+    jlong addr = ptr_to_jlong(str);\n+    (*env)->ReleaseStringUTFChars(env, text, str);\n+    return addr;\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/libToCString.c","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <jlong.h>\n+#include <jni.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+JNIEXPORT jstring JNICALL Java_org_openjdk_bench_java_lang_foreign_ToJavaStringTest_readString(JNIEnv *const env, const jclass cls, jlong addr) {\n+    return (*env)->NewStringUTF(env, jlong_to_ptr(addr));\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/libToJavaString.c","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-            .withTargetLayout(MemoryLayout.sequenceLayout(ValueLayout.JAVA_BYTE));\n+            .withTargetLayout(MemoryLayout.sequenceLayout(Long.MAX_VALUE, ValueLayout.JAVA_BYTE));\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/pointers\/NativeType.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -81,1 +81,1 @@\n-        MemorySegment segment = allocator.allocateArray(type.layout(), size);\n+        MemorySegment segment = allocator.allocate(type.layout(), size);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/pointers\/Pointer.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n-@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n+@Fork(3)\n@@ -63,1 +63,1 @@\n-            .withTargetLayout(MemoryLayout.sequenceLayout(ValueLayout.JAVA_BYTE));\n+            .withTargetLayout(MemoryLayout.sequenceLayout(Long.MAX_VALUE, ValueLayout.JAVA_BYTE));\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/pointers\/PointerBench.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -71,1 +71,1 @@\n-        VH_x.set(segment, x);\n+        VH_x.set(segment, 0L, x);\n@@ -75,1 +75,1 @@\n-        return (int) VH_x.get(segment);\n+        return (int) VH_x.get(segment, 0L);\n@@ -79,1 +79,1 @@\n-        VH_y.set(segment, y);\n+        VH_y.set(segment, 0L, y);\n@@ -83,1 +83,1 @@\n-        return (int) VH_y.get(segment);\n+        return (int) VH_y.get(segment, 0L);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/points\/support\/PanamaPoint.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -140,1 +140,4 @@\n-                SocketWriteEvent.offer(start, nbytes, getRemoteAddress());\n+                long duration = start - SocketWriteEvent.timestamp();\n+                if (SocketWriteEvent.shouldCommit(duration)) {\n+                    SocketWriteEvent.emit(start, duration, nbytes, getRemoteAddress());\n+                }\n@@ -158,1 +161,4 @@\n-                SocketReadEvent.offer(start, nbytes, getRemoteAddress(), 0);\n+                long duration = start - SocketReadEvent.timestamp();\n+                if (SocketReadEvent.shouldCommit(duration)) {\n+                    SocketReadEvent.emit(start, duration, nbytes, getRemoteAddress(), 0);\n+                }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/net\/SocketEventOverhead.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -96,0 +96,19 @@\n+    @Benchmark\n+    public String formatLower() {\n+        return HexFormat.of().formatHex(bytes);\n+    }\n+\n+    @Benchmark\n+    public String formatUpper() {\n+        return HexFormat.of().withUpperCase().formatHex(bytes);\n+    }\n+\n+    @Benchmark\n+    public String formatLowerCached() {\n+        return LOWER_FORMATTER.formatHex(bytes);\n+    }\n+\n+    @Benchmark\n+    public String formatUpperCached() {\n+        return UPPER_FORMATTER.formatHex(bytes);\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/HexFormatBench.java","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,0 @@\n-    \"--enable-preview\",\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/MemorySegmentVectorAccess.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,0 @@\n-    \"--enable-preview\",\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/TestLoadStoreBytes.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,1 +55,0 @@\n-    \"--enable-preview\",\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/TestLoadStoreShorts.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,220 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Measurement(iterations = 4, time = 1000, timeUnit = TimeUnit.MILLISECONDS)\n+@Warmup(iterations = 3, time = 1000, timeUnit = TimeUnit.MILLISECONDS)\n+@Fork(3)\n+public class PhiDuplicatedConversion {\n+    public static final int SIZE = 300;\n+\n+    \/\/ Ints\n+\n+    @Benchmark\n+    public void testInt2Float(Blackhole blackhole, BenchState state) {\n+        for (int i = 0; i < SIZE; i++) {\n+            blackhole.consume(i2f(state.bools[i], state.ints[i], state.ints[SIZE - 1 - i]));\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testInt2Double(Blackhole blackhole, BenchState state) {\n+        for (int i = 0; i < SIZE; i++) {\n+            blackhole.consume(i2d(state.bools[i], state.ints[i], state.ints[SIZE - 1 - i]));\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testInt2Long(Blackhole blackhole, BenchState state) {\n+        for (int i = 0; i < SIZE; i++) {\n+            blackhole.consume(i2l(state.bools[i], state.ints[i], state.ints[SIZE - 1 - i]));\n+        }\n+    }\n+\n+    \/\/ Floats\n+\n+    @Benchmark\n+    public void testFloat2Int(Blackhole blackhole, BenchState state) {\n+        for (int i = 0; i < SIZE; i++) {\n+            blackhole.consume(f2i(state.bools[i], state.floats[i], state.floats[SIZE - 1 - i]));\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testFloat2Double(Blackhole blackhole, BenchState state) {\n+        for (int i = 0; i < SIZE; i++) {\n+            blackhole.consume(f2d(state.bools[i], state.floats[i], state.floats[SIZE - 1 - i]));\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testFloat2Long(Blackhole blackhole, BenchState state) {\n+        for (int i = 0; i < SIZE; i++) {\n+            blackhole.consume(f2l(state.bools[i], state.floats[i], state.floats[SIZE - 1 - i]));\n+        }\n+    }\n+\n+    \/\/ Doubles\n+\n+    @Benchmark\n+    public void testDouble2Int(Blackhole blackhole, BenchState state) {\n+        for (int i = 0; i < SIZE; i++) {\n+            blackhole.consume(d2i(state.bools[i], state.doubles[i], state.doubles[SIZE - 1 - i]));\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testDouble2Float(Blackhole blackhole, BenchState state) {\n+        for (int i = 0; i < SIZE; i++) {\n+            blackhole.consume(d2f(state.bools[i], state.doubles[i], state.doubles[SIZE - 1 - i]));\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testDouble2Long(Blackhole blackhole, BenchState state) {\n+        for (int i = 0; i < SIZE; i++) {\n+            blackhole.consume(d2l(state.bools[i], state.doubles[i], state.doubles[SIZE - 1 - i]));\n+        }\n+    }\n+\n+    \/\/ Longs\n+\n+    @Benchmark\n+    public void testLong2Float(Blackhole blackhole, BenchState state) {\n+        for (int i = 0; i < SIZE; i++) {\n+            blackhole.consume(l2f(state.bools[i], state.longs[i], state.longs[SIZE - 1 - i]));\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testLong2Double(Blackhole blackhole, BenchState state) {\n+        for (int i = 0; i < SIZE; i++) {\n+            blackhole.consume(l2d(state.bools[i], state.longs[i], state.longs[SIZE - 1 - i]));\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testLong2Int(Blackhole blackhole, BenchState state) {\n+        for (int i = 0; i < SIZE; i++) {\n+            blackhole.consume(l2i(state.bools[i], state.longs[i], state.longs[SIZE - 1 - i]));\n+        }\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public static float i2f(boolean c, int a, int b) {\n+        return c ? a : b;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public static double i2d(boolean c, int a, int b) {\n+        return c ? a : b;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public static long i2l(boolean c, int a, int b) {\n+        return c ? a : b;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public static int f2i(boolean c, float a, float b) {\n+        return c ? (int)a : (int)b;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public static double f2d(boolean c, float a, float b) {\n+        return c ? (double)a : (double)b;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public static long f2l(boolean c, float a, float b) {\n+        return c ? (long)a : (long)b;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public static int d2i(boolean c, double a, double b) {\n+        return c ? (int)a : (int)b;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public static float d2f(boolean c, double a, double b) {\n+        return c ? (float)a : (float)b;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public static long d2l(boolean c, double a, double b) {\n+        return c ? (long)a : (long)b;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public static float l2f(boolean c, long a, long b) {\n+        return c ? a : b;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public static double l2d(boolean c, long a, long b) {\n+        return c ? a : b;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public static int l2i(boolean c, long a, long b) {\n+        return c ? (int)a : (int)b;\n+    }\n+\n+    @State(Scope.Benchmark)\n+    public static class BenchState {\n+        public boolean[] bools;\n+        public int[] ints;\n+        public long[] longs;\n+        public float[] floats;\n+        public double[] doubles;\n+        public BenchState() {\n+\n+        }\n+\n+        @Setup(Level.Iteration)\n+        public void setup() {\n+            Random random = new Random(1000);\n+            bools = new boolean[SIZE];\n+            ints = new int[SIZE];\n+            longs = new long[SIZE];\n+            floats = new float[SIZE];\n+            doubles = new double[SIZE];\n+\n+            for (int i = 0; i < SIZE; i++) {\n+                bools[i] = random.nextBoolean();\n+                ints[i] = random.nextInt(100);\n+                longs[i] = random.nextLong(100);\n+                floats[i] = random.nextFloat(100);\n+                doubles[i] = random.nextDouble(100);\n+            }\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/PhiDuplicatedConversion.java","additions":220,"deletions":0,"binary":false,"changes":220,"status":"added"}]}