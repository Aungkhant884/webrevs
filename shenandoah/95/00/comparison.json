{"files":[{"patch":"@@ -201,0 +201,1 @@\n+  \/\/ req.size() is in words, free() is in bytes.\n@@ -202,3 +203,31 @@\n-    size_t free = align_down(r->free() >> LogHeapWordSize, MinObjAlignment);\n-    if (size > free) {\n-      size = free;\n+    if (req.type() == ShenandoahAllocRequest::_alloc_plab) {\n+      \/\/ Need to assure that plabs are aligned on multiple of card region.\n+      size_t free = r->free();\n+      size_t usable_free = (free \/ CardTable::card_size) << CardTable::card_shift;\n+      free \/= HeapWordSize;\n+      usable_free \/= HeapWordSize;\n+      if (size > usable_free) {\n+        size = usable_free;\n+      }\n+      if (size >= req.min_size()) {\n+        result = r->allocate_aligned(size, req, CardTable::card_size);\n+        assert (result != NULL, \"Allocation must succeed: free \" SIZE_FORMAT \", actual \" SIZE_FORMAT, usable_free, size);\n+        if (free > usable_free) {\n+          \/\/ Account for the alignment padding\n+          size_t padding = (free - usable_free) * HeapWordSize;\n+          increase_used(padding);\n+          assert(r->affiliation() == ShenandoahRegionAffiliation::OLD_GENERATION, \"All PLABs reside in old-gen\");\n+          _heap->old_generation()->increase_used(padding);\n+          \/\/ For verification consistency, we need to report this padding to _heap\n+          _heap->increase_used(padding);\n+        }\n+      }\n+    } else {\n+      size_t free = align_down(r->free() >> LogHeapWordSize, MinObjAlignment);\n+      if (size > free) {\n+        size = free;\n+      }\n+      if (size >= req.min_size()) {\n+        result = r->allocate(size, req);\n+        assert (result != NULL, \"Allocation must succeed: free \" SIZE_FORMAT \", actual \" SIZE_FORMAT, free, size);\n+      }\n@@ -206,3 +235,18 @@\n-    if (size >= req.min_size()) {\n-      result = r->allocate(size, req);\n-      assert (result != NULL, \"Allocation must succeed: free \" SIZE_FORMAT \", actual \" SIZE_FORMAT, free, size);\n+  } else if (req.is_lab_alloc() && req.type() == ShenandoahAllocRequest::_alloc_plab) {\n+    size_t free = r->free();\n+    size_t usable_free = (free \/ CardTable::card_size) << CardTable::card_shift;\n+    free \/= HeapWordSize;\n+    usable_free \/= HeapWordSize;\n+    if (size <= usable_free) {\n+      assert(size % CardTable::card_size_in_words == 0, \"PLAB size must be multiple of remembered set card size\");\n+\n+      result = r->allocate_aligned(size, req, CardTable::card_size);\n+      assert (result != NULL, \"Allocation must succeed: free \" SIZE_FORMAT \", actual \" SIZE_FORMAT, usable_free, size);\n+\n+      \/\/ Account for the alignment padding\n+      size_t padding = (free - usable_free) * HeapWordSize;\n+      increase_used(padding);\n+      assert(r->affiliation() == ShenandoahRegionAffiliation::OLD_GENERATION, \"All PLABs reside in old-gen\");\n+      _heap->old_generation()->increase_used(padding);\n+      \/\/ For verification consistency, we need to report this padding to _heap\n+      _heap->increase_used(padding);\n@@ -215,1 +259,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":50,"deletions":7,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -897,0 +897,5 @@\n+  size_t unalignment = new_size % CardTable::card_size_in_words;\n+  if (unalignment != 0) {\n+    new_size = new_size - unalignment + CardTable::card_size_in_words;\n+  }\n+\n@@ -899,1 +904,2 @@\n-  \/\/ heuristics should catch up with them.\n+  \/\/ heuristics should catch up with them.  Note that the requested new_size may\n+  \/\/ not be honored, but we remember that this is the preferred size.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -350,0 +350,3 @@\n+  \/\/ Allocation (return NULL if full)\n+  inline HeapWord* allocate_aligned(size_t word_size, ShenandoahAllocRequest req, size_t alignment_in_words);\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,0 +34,34 @@\n+\/\/ If next available memory is not aligned on address that is multiple of alignment, fill the empty space\n+\/\/ so that returned object is aligned on an address that is a multiple of alignment_in_words.  Requested\n+\/\/ size is in words.\n+HeapWord* ShenandoahHeapRegion::allocate_aligned(size_t size, ShenandoahAllocRequest req, size_t alignment_in_bytes) {\n+  shenandoah_assert_heaplocked_or_safepoint();\n+  assert(is_object_aligned(size), \"alloc size breaks alignment: \" SIZE_FORMAT, size);\n+\n+  HeapWord* obj = top();\n+  uintptr_t addr_as_int = (uintptr_t) obj;\n+\n+  size_t unalignment_bytes = addr_as_int % alignment_in_bytes;\n+  size_t unalignment_words = unalignment_bytes \/ HeapWordSize;\n+  if (pointer_delta(end(), obj + unalignment_words) >= size) {\n+    if (unalignment_words > 0) {\n+      size_t pad_words = (alignment_in_bytes \/ HeapWordSize) - unalignment_words;\n+      ShenandoahHeap::fill_with_object(obj, pad_words);\n+      ShenandoahHeap::heap()->card_scan()->register_object(obj);\n+      obj += pad_words;\n+    }\n+\n+    make_regular_allocation(req.affiliation());\n+    adjust_alloc_metadata(req.type(), size);\n+\n+    HeapWord* new_top = obj + size;\n+    set_top(new_top);\n+    assert(is_object_aligned(new_top), \"new top breaks alignment: \" PTR_FORMAT, p2i(new_top));\n+    assert(((uintptr_t) obj) % (alignment_in_bytes) == 0, \"obj is not aligned: \" PTR_FORMAT, p2i(obj));\n+\n+    return obj;\n+  } else {\n+    return NULL;\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.inline.hpp","additions":34,"deletions":0,"binary":false,"changes":34,"status":"modified"}]}