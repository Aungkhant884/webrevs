{"files":[{"patch":"@@ -59,0 +59,1 @@\n+  _degen_generation(NULL),\n@@ -127,1 +128,0 @@\n-      generation = GLOBAL;\n@@ -134,2 +134,11 @@\n-      if (ShenandoahDegeneratedGC && global_heuristics->should_degenerate_cycle()) {\n-        global_heuristics->record_allocation_failure_gc();\n+      if (degen_point == ShenandoahGC::_degenerated_outside_cycle) {\n+        _degen_generation = heap->global_generation();\n+      } else {\n+        assert(_degen_generation != NULL, \"Need to know which generation to resume.\");\n+      }\n+\n+      ShenandoahHeuristics* heuristics = _degen_generation->heuristics();\n+      generation = _degen_generation->generation_mode();\n+\n+      if (ShenandoahDegeneratedGC && heuristics->should_degenerate_cycle()) {\n+        heuristics->record_allocation_failure_gc();\n@@ -139,1 +148,1 @@\n-        global_heuristics->record_allocation_failure_gc();\n+        heuristics->record_allocation_failure_gc();\n@@ -143,1 +152,0 @@\n-\n@@ -366,21 +374,15 @@\n-\/\/                    +------------+                         +--------------+\n-\/\/                    |            |                         |              |\n-\/\/        +-----------+    Idle    +----------+              |   Bootstrap  |\n-\/\/        |           |            |          |              |              |\n-\/\/        |           +------+-----+          |              +------+-------+\n-\/\/        v                  |                v                     ^\n-\/\/ +--------------+          |         +-------------+              |\n-\/\/ |              |          |         |             |<-------------+\n-\/\/ |    Young     |          |         |     Old     |\n-\/\/ |              |          |         |             |<-------------+\n-\/\/ +------+-------+          |         +------+------+              |\n-\/\/        |                  |                |                     v\n-\/\/        |                  |                |             +-------+-------+\n-\/\/        |                  |                |             |               |\n-\/\/        |                  |                |             |  Young (Conc) |\n-\/\/        |                  v                |             |               |\n-\/\/        |           +------------+          |             +-------+-------+\n-\/\/        |           |            |<---------+                     |\n-\/\/        +---------->|   Global   |                                |\n-\/\/                    |            |<-------------------------------+\n-\/\/                    +------------+\n+\/\/              +-----------+  Idle  +-----------+\n+\/\/              |               +                |\n+\/\/              v               |                v\n+\/\/                              |\n+\/\/            Young             |               Old +------> Young\n+\/\/              +               v                +             +\n+\/\/              |                                |             |\n+\/\/              |             Global             |             |\n+\/\/              |               +                |             |\n+\/\/              |               |                |             |\n+\/\/              |               |                |             |\n+\/\/              v               v                |             v\n+\/\/                                               |\n+\/\/            Degen           Degen   <----------+           Degen\n+\/\/            Young           Global                         Young\n@@ -435,10 +437,0 @@\n-  \/\/ Reset the degenerated point. Normally this would happen at the top\n-  \/\/ of the control loop, but here we have just completed a young cycle\n-  \/\/ which has bootstrapped the old concurrent marking.\n-  _degen_point = ShenandoahGC::_degenerated_outside_cycle;\n-\n-  \/\/ Bit of a hack here to keep the phase timings happy as we transition\n-  \/\/ to concurrent old marking. We need to revisit this.\n-  heap->phase_timings()->flush_par_workers_to_cycle();\n-  heap->phase_timings()->flush_cycle_to_global();\n-\n@@ -449,6 +441,23 @@\n-  \/\/ From here we will 'resume' the old concurrent mark. This will skip reset\n-  \/\/ and init mark for the concurrent mark. All of that work will have been\n-  \/\/ done by the bootstrapping young cycle. In order to simplify the debugging\n-  \/\/ effort, the old cycle will ONLY complete the mark phase. No actual\n-  \/\/ collection of the old generation is happening here.\n-  resume_concurrent_old_cycle(old_generation, cause);\n+  if (heap->cancelled_gc()) {\n+    \/\/ Bootstrap cycle was cancelled. Now we expect to run a degenerated\n+    \/\/ young cycle. Clear anything out of old generation mark queues.\n+    old_generation->task_queues()->clear();\n+    old_generation->set_mark_incomplete();\n+  } else {\n+    \/\/ Reset the degenerated point. Normally this would happen at the top\n+    \/\/ of the control loop, but here we have just completed a young cycle\n+    \/\/ which has bootstrapped the old concurrent marking.\n+    _degen_point = ShenandoahGC::_degenerated_outside_cycle;\n+\n+    \/\/ Bit of a hack here to keep the phase timings happy as we transition\n+    \/\/ to concurrent old marking. We need to revisit this.\n+    heap->phase_timings()->flush_par_workers_to_cycle();\n+    heap->phase_timings()->flush_cycle_to_global();\n+\n+    \/\/ From here we will 'resume' the old concurrent mark. This will skip reset\n+    \/\/ and init mark for the concurrent mark. All of that work will have been\n+    \/\/ done by the bootstrapping young cycle. In order to simplify the debugging\n+    \/\/ effort, the old cycle will ONLY complete the mark phase. No actual\n+    \/\/ collection of the old generation is happening here.\n+    resume_concurrent_old_cycle(old_generation, cause);\n+  }\n@@ -495,0 +504,9 @@\n+    if (is_alloc_failure_gc()) {\n+      \/\/ Cancelled for degeneration, not just to run a young cycle.\n+      \/\/ We can't complete a global cycle with the partial marking\n+      \/\/ information in the old generation mark queues so we force\n+      \/\/ the degenerated cycle to be global and from outside the cycle.\n+      generation->task_queues()->clear();\n+      generation->set_mark_incomplete();\n+      _degen_point = ShenandoahGC::_degenerated_outside_cycle;\n+    }\n@@ -551,0 +569,1 @@\n+    _degen_generation = generation;\n@@ -568,9 +587,1 @@\n-    \/\/ Presently, young and old cycles degenerate to a global collection.\n-    \/\/ Since we cannot safely reclaim globally based on a partial old or\n-    \/\/ young marking we force the degenerated cycle to begin with a global\n-    \/\/ reset and mark.\n-    if (_requested_generation == YOUNG || _requested_generation == OLD) {\n-      _degen_point = ShenandoahGC::_degenerated_outside_cycle;\n-    } else {\n-      _degen_point = point;\n-    }\n+    _degen_point = point;\n@@ -634,1 +645,1 @@\n-  ShenandoahGCSession session(cause, heap->global_generation());\n+  ShenandoahGCSession session(cause, _degen_generation);\n@@ -636,1 +647,1 @@\n-  ShenandoahDegenGC gc(point);\n+  ShenandoahDegenGC gc(point, _degen_generation);\n@@ -639,1 +650,1 @@\n-  heap->global_generation()->heuristics()->record_success_degenerated();\n+  _degen_generation->heuristics()->record_success_degenerated();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":65,"deletions":54,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -92,0 +92,1 @@\n+  ShenandoahGeneration* _degen_generation;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-ShenandoahDegenGC::ShenandoahDegenGC(ShenandoahDegenPoint degen_point) :\n+ShenandoahDegenGC::ShenandoahDegenGC(ShenandoahDegenPoint degen_point, ShenandoahGeneration* generation) :\n@@ -48,1 +48,2 @@\n-  _degen_point(degen_point) {\n+  _degen_point(degen_point),\n+  _generation(generation) {\n@@ -85,0 +86,8 @@\n+  \/\/ We can't easily clear the old mark in progress flag because it must be done\n+  \/\/ on a safepoint (not sure if that is a hard requirement). At any rate, once\n+  \/\/ we are in a degenerated cycle, there should be no more old marking.\n+  assert(heap->old_generation()->task_queues()->is_empty(), \"Old gen task queues should be empty.\");\n+  if (heap->is_concurrent_old_mark_in_progress()) {\n+    heap->set_concurrent_old_mark_in_progress(false);\n+  }\n+\n@@ -108,1 +117,1 @@\n-      heap->set_unload_classes(heap->global_generation()->heuristics()->can_unload_classes());\n+      heap->set_unload_classes(_generation->heuristics()->can_unload_classes());\n@@ -216,1 +225,1 @@\n-  ShenandoahHeap::heap()->global_generation()->prepare_gc();\n+  _generation->prepare_gc();\n@@ -222,1 +231,1 @@\n-  ShenandoahSTWMark mark(false \/*full gc*\/);\n+  ShenandoahSTWMark mark(_generation, false \/*full gc*\/);\n@@ -227,1 +236,1 @@\n-  ShenandoahConcurrentMark mark(ShenandoahHeap::heap()->global_generation());\n+  ShenandoahConcurrentMark mark(_generation);\n@@ -239,0 +248,1 @@\n+\n@@ -240,1 +250,1 @@\n-  heap->global_generation()->prepare_regions_and_collection_set(false \/*concurrent*\/);\n+  _generation->prepare_regions_and_collection_set(false \/*concurrent*\/);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahDegeneratedGC.cpp","additions":17,"deletions":7,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+class ShenandoahGeneration;\n@@ -36,0 +37,1 @@\n+  ShenandoahGeneration* _generation;\n@@ -38,1 +40,1 @@\n-  ShenandoahDegenGC(ShenandoahDegenPoint degen_point);\n+  ShenandoahDegenGC(ShenandoahDegenPoint degen_point, ShenandoahGeneration* generation);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahDegeneratedGC.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -296,1 +296,1 @@\n-  ShenandoahSTWMark mark(true \/*full_gc*\/);\n+  ShenandoahSTWMark mark(heap->global_generation(), true \/*full_gc*\/);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -236,1 +236,1 @@\n-  uint nworkers = heap->safepoint_workers()->active_workers();\n+  uint nworkers = heap->workers()->active_workers();\n@@ -242,1 +242,1 @@\n-  heap->safepoint_workers()->run_task(&task);\n+  heap->workers()->run_task(&task);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1621,6 +1621,1 @@\n-  \/\/ Leave the SATB barriers alone if an old mark is in progress.\n-  if (is_concurrent_old_mark_in_progress()) {\n-    assert(ShenandoahBarrierSet::satb_mark_queue_set().is_active(), \"SATB barrier should still be active.\");\n-  } else {\n-    ShenandoahBarrierSet::satb_mark_queue_set().set_active_all_threads(in_progress, !in_progress);\n-  }\n+  manage_satb_barrier(in_progress);\n@@ -1636,4 +1631,10 @@\n-  \/\/ Assert the barriers are on if we are already in a concurrent old mark and\n-  \/\/ we are asked to turn them on. Otherwise, set the barrier state accordingly.\n-  if (in_progress) {\n-    assert(ShenandoahBarrierSet::satb_mark_queue_set().is_active(), \"SATB barrier should have been activated by bootstrapping young mark.\");\n+  manage_satb_barrier(in_progress);\n+}\n+\n+void ShenandoahHeap::manage_satb_barrier(bool active) {\n+  if (is_concurrent_mark_in_progress()) {\n+    \/\/ Ignore request to deactivate barrier while concurrent mark is in progress.\n+    \/\/ Do not attempt to re-activate the barrier if it is already active.\n+    if (active && !ShenandoahBarrierSet::satb_mark_queue_set().is_active()) {\n+      ShenandoahBarrierSet::satb_mark_queue_set().set_active_all_threads(active, !active);\n+    }\n@@ -1641,1 +1642,5 @@\n-    ShenandoahBarrierSet::satb_mark_queue_set().set_active_all_threads(in_progress, !in_progress);\n+    \/\/ No concurrent marking is in progress so honor request to deactivate,\n+    \/\/ but only if the barrier is already active.\n+    if (!active && ShenandoahBarrierSet::satb_mark_queue_set().is_active()) {\n+      ShenandoahBarrierSet::satb_mark_queue_set().set_active_all_threads(active, !active);\n+    }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":16,"deletions":11,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -351,0 +351,2 @@\n+  void manage_satb_barrier(bool active);\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -414,1 +414,0 @@\n-     oop obj = oop(bottom());\n@@ -827,1 +826,1 @@\n-    int index_limit = index() + ShenandoahHeapRegion::required_regions(obj->size() * HeapWordSize);\n+    size_t index_limit = index() + ShenandoahHeapRegion::required_regions(obj->size() * HeapWordSize);\n@@ -829,1 +828,1 @@\n-    for (int i = index(); i < index_limit; i++) {\n+    for (size_t i = index(); i < index_limit; i++) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -60,2 +60,2 @@\n-ShenandoahSTWMark::ShenandoahSTWMark(bool full_gc) :\n-  ShenandoahMark(ShenandoahHeap::heap()->global_generation()),\n+ShenandoahSTWMark::ShenandoahSTWMark(ShenandoahGeneration* generation, bool full_gc) :\n+  ShenandoahMark(generation),\n@@ -103,2 +103,15 @@\n-  ShenandoahInitMarkRootsClosure<GLOBAL> init_mark(task_queues()->queue(worker_id));\n-  _root_scanner.roots_do(&init_mark, worker_id);\n+  switch (_generation->generation_mode()) {\n+    case GLOBAL: {\n+      ShenandoahInitMarkRootsClosure<GLOBAL> init_mark(task_queues()->queue(worker_id));\n+      _root_scanner.roots_do(&init_mark, worker_id);\n+      break;\n+    }\n+    case YOUNG: {\n+      ShenandoahInitMarkRootsClosure<YOUNG> init_mark(task_queues()->queue(worker_id));\n+      _root_scanner.roots_do(&init_mark, worker_id);\n+      _generation->scan_remembered_set();\n+      break;\n+    }\n+    default:\n+      ShouldNotReachHere();\n+  }\n@@ -112,1 +125,2 @@\n-  mark_loop(GLOBAL, worker_id, &_terminator, rp,\n+  mark_loop(_generation->generation_mode(),\n+            worker_id, &_terminator, rp,\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahSTWMark.cpp","additions":19,"deletions":5,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+class ShenandoahGeneration;\n@@ -40,1 +41,1 @@\n- ShenandoahSTWMark(bool full_gc);\n+ ShenandoahSTWMark(ShenandoahGeneration* generation, bool full_gc);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahSTWMark.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-  _cluster_count = uint32_t(total_card_count \/ ShenandoahCardCluster<ShenandoahDirectCardMarkRememberedSet>::CardsPerCluster);\n+  _cluster_count = total_card_count \/ ShenandoahCardCluster<ShenandoahDirectCardMarkRememberedSet>::CardsPerCluster;\n@@ -61,1 +61,1 @@\n-void ShenandoahDirectCardMarkRememberedSet::initialize_overreach(uint32_t first_cluster, uint32_t count) {\n+void ShenandoahDirectCardMarkRememberedSet::initialize_overreach(size_t first_cluster, size_t count) {\n@@ -66,1 +66,1 @@\n-  uint32_t first_card_index = first_cluster * ShenandoahCardCluster<ShenandoahDirectCardMarkRememberedSet>::CardsPerCluster;\n+  size_t first_card_index = first_cluster * ShenandoahCardCluster<ShenandoahDirectCardMarkRememberedSet>::CardsPerCluster;\n@@ -73,1 +73,1 @@\n-void ShenandoahDirectCardMarkRememberedSet::merge_overreach(uint32_t first_cluster, uint32_t count) {\n+void ShenandoahDirectCardMarkRememberedSet::merge_overreach(size_t first_cluster, size_t count) {\n@@ -77,1 +77,1 @@\n-  uint32_t first_card_index = first_cluster * ShenandoahCardCluster<ShenandoahDirectCardMarkRememberedSet>::CardsPerCluster;\n+  size_t first_card_index = first_cluster * ShenandoahCardCluster<ShenandoahDirectCardMarkRememberedSet>::CardsPerCluster;\n@@ -111,1 +111,1 @@\n-      uint32_t start_cluster_no = rs->cluster_for_addr(start_of_range);\n+      size_t start_cluster_no = rs->cluster_for_addr(start_of_range);\n@@ -127,1 +127,1 @@\n-      uint32_t num_clusters = (uint32_t) ((num_heapwords - 1 + cluster_size) \/ cluster_size);\n+      size_t num_clusters = (size_t) ((num_heapwords - 1 + cluster_size) \/ cluster_size);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -239,1 +239,1 @@\n-  uint32_t _card_shift;\n+  size_t _card_shift;\n@@ -241,1 +241,1 @@\n-  uint32_t _cluster_count;\n+  size_t _cluster_count;\n@@ -256,8 +256,8 @@\n-  uint32_t card_index_for_addr(HeapWord *p);\n-  HeapWord *addr_for_card_index(uint32_t card_index);\n-  bool is_card_dirty(uint32_t card_index);\n-  void mark_card_as_dirty(uint32_t card_index);\n-  void mark_range_as_dirty(uint32_t card_index, uint32_t num_cards);\n-  void mark_card_as_clean(uint32_t card_index);\n-  void mark_range_as_clean(uint32_t card_index, uint32_t num_cards);\n-  void mark_overreach_card_as_dirty(uint32_t card_index);\n+  size_t card_index_for_addr(HeapWord *p);\n+  HeapWord *addr_for_card_index(size_t card_index);\n+  bool is_card_dirty(size_t card_index);\n+  void mark_card_as_dirty(size_t card_index);\n+  void mark_range_as_dirty(size_t card_index, size_t num_cards);\n+  void mark_card_as_clean(size_t card_index);\n+  void mark_range_as_clean(size_t card_index, size_t num_cards);\n+  void mark_overreach_card_as_dirty(size_t card_index);\n@@ -270,1 +270,1 @@\n-  uint32_t cluster_count();\n+  size_t cluster_count();\n@@ -274,1 +274,1 @@\n-  void initialize_overreach(uint32_t first_cluster, uint32_t count);\n+  void initialize_overreach(size_t first_cluster, size_t count);\n@@ -278,1 +278,1 @@\n-  void merge_overreach(uint32_t first_cluster, uint32_t count);\n+  void merge_overreach(size_t first_cluster, size_t count);\n@@ -472,1 +472,1 @@\n-  static const uint32_t CardsPerCluster = 64;\n+  static const size_t CardsPerCluster = 64;\n@@ -489,1 +489,1 @@\n-  inline void set_first_start(uint32_t card_index, uint8_t value) {\n+  inline void set_first_start(size_t card_index, uint8_t value) {\n@@ -494,1 +494,1 @@\n-  inline void set_last_start(uint32_t card_index, uint8_t value) {\n+  inline void set_last_start(size_t card_index, uint8_t value) {\n@@ -499,1 +499,1 @@\n-  inline void set_has_object_bit(uint32_t card_index) {\n+  inline void set_has_object_bit(size_t card_index) {\n@@ -503,1 +503,1 @@\n-  inline void clear_has_object_bit(uint32_t card_index) {\n+  inline void clear_has_object_bit(size_t card_index) {\n@@ -507,3 +507,3 @@\n-  inline void clear_objects_in_range(HeapWord *addr, uint32_t num_words) {\n-    uint32_t card_index = _rs->card_index_for_addr(addr);\n-    uint32_t last_card_index = _rs->card_index_for_addr(addr + num_words - 1);\n+  inline void clear_objects_in_range(HeapWord *addr, size_t num_words) {\n+    size_t card_index = _rs->card_index_for_addr(addr);\n+    size_t last_card_index = _rs->card_index_for_addr(addr + num_words - 1);\n@@ -615,2 +615,2 @@\n-  const uint32_t CardByteOffsetMultiplier = 8;\n-  const uint32_t CardWordOffsetMultiplier = 1;\n+  const size_t CardByteOffsetMultiplier = 8;\n+  const size_t CardWordOffsetMultiplier = 1;\n@@ -626,1 +626,1 @@\n-  inline void set_crossing_object_start(uint32_t card_index, uint16_t crossing_offset) {\n+  inline void set_crossing_object_start(size_t card_index, uint16_t crossing_offset) {\n@@ -772,1 +772,1 @@\n-  void coalesce_objects(HeapWord* address, uint32_t length_in_words);\n+  void coalesce_objects(HeapWord* address, size_t length_in_words);\n@@ -786,1 +786,1 @@\n-  bool has_object(uint32_t card_index);\n+  bool has_object(size_t card_index);\n@@ -791,1 +791,1 @@\n-  uint32_t get_first_start(uint32_t card_index);\n+  size_t get_first_start(size_t card_index);\n@@ -796,1 +796,1 @@\n-  uint32_t get_last_start(uint32_t card_index);\n+  size_t get_last_start(size_t card_index);\n@@ -873,8 +873,8 @@\n-  uint32_t card_index_for_addr(HeapWord *p);\n-  HeapWord *addr_for_card_index(uint32_t card_index);\n-  bool is_card_dirty(uint32_t card_index);\n-  void mark_card_as_dirty(uint32_t card_index);\n-  void mark_range_as_dirty(uint32_t card_index, uint32_t num_cards);\n-  void mark_card_as_clean(uint32_t card_index);\n-  void mark_range_as_clean(uint32_t card_index, uint32_t num_cards);\n-  void mark_overreach_card_as_dirty(uint32_t card_index);\n+  size_t card_index_for_addr(HeapWord *p);\n+  HeapWord *addr_for_card_index(size_t card_index);\n+  bool is_card_dirty(size_t card_index);\n+  void mark_card_as_dirty(size_t card_index);\n+  void mark_range_as_dirty(size_t card_index, size_t num_cards);\n+  void mark_card_as_clean(size_t card_index);\n+  void mark_range_as_clean(size_t card_index, size_t num_cards);\n+  void mark_overreach_card_as_dirty(size_t card_index);\n@@ -887,3 +887,3 @@\n-  uint32_t cluster_count();\n-  void initialize_overreach(uint32_t first_cluster, uint32_t count);\n-  void merge_overreach(uint32_t first_cluster, uint32_t count);\n+  size_t cluster_count();\n+  void initialize_overreach(size_t first_cluster, size_t count);\n+  void merge_overreach(size_t first_cluster, size_t count);\n@@ -891,1 +891,1 @@\n-  uint32_t cluster_for_addr(HeapWord *addr);\n+  size_t cluster_for_addr(HeapWord *addr);\n@@ -893,1 +893,1 @@\n-  void coalesce_objects(HeapWord *addr, uint32_t length_in_words);\n+  void coalesce_objects(HeapWord *addr, size_t length_in_words);\n@@ -896,1 +896,1 @@\n-  void mark_range_as_empty(HeapWord *addr, uint32_t length_in_words);\n+  void mark_range_as_empty(HeapWord *addr, size_t length_in_words);\n@@ -930,1 +930,1 @@\n-  inline void process_clusters(uint32_t first_cluster, uint32_t count, HeapWord *end_of_range, ClosureType *oops);\n+  inline void process_clusters(size_t first_cluster, size_t count, HeapWord *end_of_range, ClosureType *oops);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.hpp","additions":43,"deletions":43,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-inline uint32_t\n+inline size_t\n@@ -44,1 +44,1 @@\n-  return (uint32_t) _card_table->index_for(p);\n+  return _card_table->index_for(p);\n@@ -48,1 +48,1 @@\n-ShenandoahDirectCardMarkRememberedSet::addr_for_card_index(uint32_t card_index) {\n+ShenandoahDirectCardMarkRememberedSet::addr_for_card_index(size_t card_index) {\n@@ -53,1 +53,1 @@\n-ShenandoahDirectCardMarkRememberedSet::is_card_dirty(uint32_t card_index) {\n+ShenandoahDirectCardMarkRememberedSet::is_card_dirty(size_t card_index) {\n@@ -59,1 +59,1 @@\n-ShenandoahDirectCardMarkRememberedSet::mark_card_as_dirty(uint32_t card_index) {\n+ShenandoahDirectCardMarkRememberedSet::mark_card_as_dirty(size_t card_index) {\n@@ -65,1 +65,1 @@\n-ShenandoahDirectCardMarkRememberedSet::mark_range_as_dirty(uint32_t card_index, uint32_t num_cards) {\n+ShenandoahDirectCardMarkRememberedSet::mark_range_as_dirty(size_t card_index, size_t num_cards) {\n@@ -72,1 +72,1 @@\n-ShenandoahDirectCardMarkRememberedSet::mark_card_as_clean(uint32_t card_index) {\n+ShenandoahDirectCardMarkRememberedSet::mark_card_as_clean(size_t card_index) {\n@@ -78,1 +78,1 @@\n-ShenandoahDirectCardMarkRememberedSet::mark_range_as_clean(uint32_t card_index, uint32_t num_cards) {\n+ShenandoahDirectCardMarkRememberedSet::mark_range_as_clean(size_t card_index, size_t num_cards) {\n@@ -85,2 +85,1 @@\n-ShenandoahDirectCardMarkRememberedSet::mark_overreach_card_as_dirty(\n-    uint32_t card_index) {\n+ShenandoahDirectCardMarkRememberedSet::mark_overreach_card_as_dirty(size_t card_index) {\n@@ -131,1 +130,1 @@\n-inline uint32_t\n+inline size_t\n@@ -139,1 +138,1 @@\n-  uint32_t card_at_start = _rs->card_index_for_addr(address);\n+  size_t card_at_start = _rs->card_index_for_addr(address);\n@@ -157,1 +156,1 @@\n-ShenandoahCardCluster<RememberedSet>::coalesce_objects(HeapWord* address, uint32_t length_in_words) {\n+ShenandoahCardCluster<RememberedSet>::coalesce_objects(HeapWord* address, size_t length_in_words) {\n@@ -159,1 +158,1 @@\n-  uint32_t card_at_start = _rs->card_index_for_addr(address);\n+  size_t card_at_start = _rs->card_index_for_addr(address);\n@@ -161,1 +160,1 @@\n-  uint32_t card_at_end = card_at_start + ((address + length_in_words) - card_start_address) \/ CardTable::card_size_in_words;\n+  size_t card_at_end = card_at_start + ((address + length_in_words) - card_start_address) \/ CardTable::card_size_in_words;\n@@ -170,1 +169,1 @@\n-    uint32_t coalesced_offset = address - card_start_address;\n+    size_t coalesced_offset = address - card_start_address;\n@@ -178,1 +177,1 @@\n-    for (uint32_t i = card_at_start + 1; i < card_at_end; i++) {\n+    for (size_t i = card_at_start + 1; i < card_at_end; i++) {\n@@ -182,1 +181,1 @@\n-    uint32_t follow_offset = (address + length_in_words) - _rs->addr_for_card_index(card_at_end);\n+    size_t follow_offset = (address + length_in_words) - _rs->addr_for_card_index(card_at_end);\n@@ -207,4 +206,1 @@\n-ShenandoahCardCluster<RememberedSet>::has_object(uint32_t card_index) {\n-  ShenandoahHeap *heap = ShenandoahHeap::heap();\n-\n-\n+ShenandoahCardCluster<RememberedSet>::has_object(size_t card_index) {\n@@ -217,1 +213,1 @@\n-\n+  ShenandoahHeap *heap = ShenandoahHeap::heap();\n@@ -257,2 +253,2 @@\n-inline uint32_t\n-ShenandoahCardCluster<RememberedSet>::get_first_start(uint32_t card_index) {\n+inline size_t\n+ShenandoahCardCluster<RememberedSet>::get_first_start(size_t card_index) {\n@@ -286,2 +282,2 @@\n-inline uint32_t\n-ShenandoahCardCluster<RememberedSet>::get_last_start(uint32_t card_index) {\n+inline size_t\n+ShenandoahCardCluster<RememberedSet>::get_last_start(size_t card_index) {\n@@ -315,2 +311,2 @@\n-inline uint32_t\n-ShenandoahCardCluster<RememberedSet>::get_crossing_object_start(uint32_t card_index) {\n+inline size_t\n+ShenandoahCardCluster<RememberedSet>::get_crossing_object_start(size_t card_index) {\n@@ -318,1 +314,1 @@\n-  uint32_t cluster_no = card_index \/ ShenandoahCardCluster<RememberedSet>::CardsPerCluster;\n+  size_t cluster_no = card_index \/ ShenandoahCardCluster<RememberedSet>::CardsPerCluster;\n@@ -337,1 +333,1 @@\n-inline uint32_t\n+inline size_t\n@@ -342,1 +338,1 @@\n-ShenandoahScanRemembered<RememberedSet>::addr_for_card_index(uint32_t card_index) { return _rs->addr_for_card_index(card_index); }\n+ShenandoahScanRemembered<RememberedSet>::addr_for_card_index(size_t card_index) { return _rs->addr_for_card_index(card_index); }\n@@ -346,1 +342,1 @@\n-ShenandoahScanRemembered<RememberedSet>::is_card_dirty(uint32_t card_index) { return _rs->is_card_dirty(card_index); }\n+ShenandoahScanRemembered<RememberedSet>::is_card_dirty(size_t card_index) { return _rs->is_card_dirty(card_index); }\n@@ -350,1 +346,1 @@\n-ShenandoahScanRemembered<RememberedSet>::mark_card_as_dirty(uint32_t card_index) { _rs->mark_card_as_dirty(card_index); }\n+ShenandoahScanRemembered<RememberedSet>::mark_card_as_dirty(size_t card_index) { _rs->mark_card_as_dirty(card_index); }\n@@ -354,1 +350,1 @@\n-ShenandoahScanRemembered<RememberedSet>::mark_range_as_dirty(uint32_t card_index, uint32_t num_cards) { _rs->mark_range_as_dirty(card_index, num_cards); }\n+ShenandoahScanRemembered<RememberedSet>::mark_range_as_dirty(size_t card_index, size_t num_cards) { _rs->mark_range_as_dirty(card_index, num_cards); }\n@@ -358,1 +354,1 @@\n-ShenandoahScanRemembered<RememberedSet>::mark_card_as_clean(uint32_t card_index) { _rs->mark_card_as_clean(card_index); }\n+ShenandoahScanRemembered<RememberedSet>::mark_card_as_clean(size_t card_index) { _rs->mark_card_as_clean(card_index); }\n@@ -362,1 +358,1 @@\n-ShenandoahScanRemembered<RememberedSet>::mark_range_as_clean(uint32_t card_index, uint32_t num_cards) { _rs->mark_range_as_clean(card_index, num_cards); }\n+ShenandoahScanRemembered<RememberedSet>::mark_range_as_clean(size_t card_index, size_t num_cards) { _rs->mark_range_as_clean(card_index, num_cards); }\n@@ -366,1 +362,1 @@\n-ShenandoahScanRemembered<RememberedSet>:: mark_overreach_card_as_dirty(uint32_t card_index) { _rs->mark_overreach_card_as_dirty(card_index); }\n+ShenandoahScanRemembered<RememberedSet>:: mark_overreach_card_as_dirty(size_t card_index) { _rs->mark_overreach_card_as_dirty(card_index); }\n@@ -393,1 +389,1 @@\n-inline uint32_t\n+inline size_t\n@@ -398,1 +394,1 @@\n-ShenandoahScanRemembered<RememberedSet>::initialize_overreach(uint32_t first_cluster, uint32_t count) { _rs->initialize_overreach(first_cluster, count); }\n+ShenandoahScanRemembered<RememberedSet>::initialize_overreach(size_t first_cluster, size_t count) { _rs->initialize_overreach(first_cluster, count); }\n@@ -402,1 +398,1 @@\n-ShenandoahScanRemembered<RememberedSet>::merge_overreach(uint32_t first_cluster, uint32_t count) { _rs->merge_overreach(first_cluster, count); }\n+ShenandoahScanRemembered<RememberedSet>::merge_overreach(size_t first_cluster, size_t count) { _rs->merge_overreach(first_cluster, count); }\n@@ -413,1 +409,1 @@\n-ShenandoahScanRemembered<RememberedSet>::coalesce_objects(HeapWord *addr, uint32_t length_in_words) {\n+ShenandoahScanRemembered<RememberedSet>::coalesce_objects(HeapWord *addr, size_t length_in_words) {\n@@ -419,1 +415,1 @@\n-ShenandoahScanRemembered<RememberedSet>::mark_range_as_empty(HeapWord *addr, uint32_t length_in_words) {\n+ShenandoahScanRemembered<RememberedSet>::mark_range_as_empty(HeapWord *addr, size_t length_in_words) {\n@@ -427,1 +423,1 @@\n-ShenandoahScanRemembered<RememberedSet>::process_clusters(uint32_t first_cluster, uint32_t count, HeapWord *end_of_range,\n+ShenandoahScanRemembered<RememberedSet>::process_clusters(size_t first_cluster, size_t count, HeapWord *end_of_range,\n@@ -435,2 +431,2 @@\n-    uint32_t card_index = first_cluster * ShenandoahCardCluster<RememberedSet>::CardsPerCluster;\n-    uint32_t end_card_index = card_index + ShenandoahCardCluster<RememberedSet>::CardsPerCluster;\n+    size_t card_index = first_cluster * ShenandoahCardCluster<RememberedSet>::CardsPerCluster;\n+    size_t end_card_index = card_index + ShenandoahCardCluster<RememberedSet>::CardsPerCluster;\n@@ -448,1 +444,1 @@\n-          uint32_t start_offset = _scc->get_first_start(card_index);\n+          size_t start_offset = _scc->get_first_start(card_index);\n@@ -499,1 +495,1 @@\n-        uint32_t start_offset = _scc->get_last_start(card_index);\n+        size_t start_offset = _scc->get_last_start(card_index);\n@@ -507,1 +503,1 @@\n-        uint32_t last_card = card_index + (nextp - card_start) \/ CardTable::card_size_in_words;\n+        size_t last_card = card_index + (nextp - card_start) \/ CardTable::card_size_in_words;\n@@ -513,1 +509,1 @@\n-          uint32_t span_card;\n+          size_t span_card;\n@@ -546,1 +542,1 @@\n-inline uint32_t\n+inline size_t\n@@ -548,2 +544,2 @@\n-  uint32_t card_index = _rs->card_index_for_addr(addr);\n-  uint32_t result = card_index \/ ShenandoahCardCluster<RememberedSet>::CardsPerCluster;\n+  size_t card_index = _rs->card_index_for_addr(addr);\n+  size_t result = card_index \/ ShenandoahCardCluster<RememberedSet>::CardsPerCluster;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.inline.hpp","additions":49,"deletions":53,"binary":false,"changes":102,"status":"modified"}]}