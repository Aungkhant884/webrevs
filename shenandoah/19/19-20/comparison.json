{"files":[{"patch":"@@ -214,1 +214,2 @@\n-    log_info(gc)(\"Trigger: Free (\" SIZE_FORMAT \"%s) is below minimum threshold (\" SIZE_FORMAT \"%s)\",\n+    log_info(gc)(\"Trigger (%s): Free (\" SIZE_FORMAT \"%s) is below minimum threshold (\" SIZE_FORMAT \"%s)\",\n+                 _generation->name(),\n@@ -225,2 +226,2 @@\n-      log_info(gc)(\"Trigger: Learning \" SIZE_FORMAT \" of \" SIZE_FORMAT \". Free (\" SIZE_FORMAT \"%s) is below initial threshold (\" SIZE_FORMAT \"%s)\",\n-                   _gc_times_learned + 1, max_learn,\n+      log_info(gc)(\"Trigger (%s): Learning \" SIZE_FORMAT \" of \" SIZE_FORMAT \". Free (\" SIZE_FORMAT \"%s) is below initial threshold (\" SIZE_FORMAT \"%s)\",\n+                   _generation->name(), _gc_times_learned + 1, max_learn,\n@@ -247,2 +248,2 @@\n-    log_info(gc)(\"Trigger: Average GC time (%.2f ms) is above the time for average allocation rate (%.0f %sB\/s) to deplete free headroom (\" SIZE_FORMAT \"%s) (margin of error = %.2f)\",\n-                 avg_cycle_time * 1000,\n+    log_info(gc)(\"Trigger (%s): Average GC time (%.2f ms) is above the time for average allocation rate (%.0f %sB\/s) to deplete free headroom (\" SIZE_FORMAT \"%s) (margin of error = %.2f)\",\n+                 _generation->name(), avg_cycle_time * 1000,\n@@ -265,2 +266,2 @@\n-    log_info(gc)(\"Trigger: Average GC time (%.2f ms) is above the time for instantaneous allocation rate (%.0f %sB\/s) to deplete free headroom (\" SIZE_FORMAT \"%s) (spike threshold = %.2f)\",\n-                 avg_cycle_time * 1000,\n+    log_info(gc)(\"Trigger (%s): Average GC time (%.2f ms) is above the time for instantaneous allocation rate (%.0f %sB\/s) to deplete free headroom (\" SIZE_FORMAT \"%s) (spike threshold = %.2f)\",\n+                 _generation->name(), avg_cycle_time * 1000,\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.cpp","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -209,2 +209,2 @@\n-      log_info(gc)(\"Trigger: Time since last GC (%.0f ms) is larger than guaranteed interval (\" UINTX_FORMAT \" ms)\",\n-                   last_time_ms, ShenandoahGuaranteedGCInterval);\n+      log_info(gc)(\"Trigger (%s): Time since last GC (%.0f ms) is larger than guaranteed interval (\" UINTX_FORMAT \" ms)\",\n+                   _generation->name(), last_time_ms, ShenandoahGuaranteedGCInterval);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -60,1 +60,2 @@\n-  _allocs_seen(0) {\n+  _allocs_seen(0),\n+  _mode(none) {\n@@ -120,1 +121,1 @@\n-    GCMode mode = none;\n+    set_gc_mode(none);\n@@ -146,1 +147,1 @@\n-        mode = stw_degenerated;\n+        set_gc_mode(stw_degenerated);\n@@ -150,1 +151,1 @@\n-        mode = stw_full;\n+        set_gc_mode(stw_full);\n@@ -161,1 +162,1 @@\n-        mode = default_mode;\n+        set_gc_mode(default_mode);\n@@ -166,1 +167,1 @@\n-        mode = stw_full;\n+        set_gc_mode(stw_full);\n@@ -177,1 +178,1 @@\n-        mode = default_mode;\n+        set_gc_mode(default_mode);\n@@ -183,1 +184,1 @@\n-        mode = stw_full;\n+        set_gc_mode(stw_full);\n@@ -192,1 +193,1 @@\n-        mode = default_mode;\n+        set_gc_mode(default_mode);\n@@ -196,1 +197,1 @@\n-          mode = resume_old;\n+          set_gc_mode(marking_old);\n@@ -209,1 +210,1 @@\n-        mode = resume_old;\n+        set_gc_mode(marking_old);\n@@ -225,1 +226,1 @@\n-    bool gc_requested = (mode != none);\n+    bool gc_requested = (_mode != none);\n@@ -246,1 +247,1 @@\n-        switch (mode) {\n+        switch (_mode) {\n@@ -259,1 +260,1 @@\n-          case resume_old: {\n+          case marking_old: {\n@@ -483,0 +484,1 @@\n+    set_gc_mode(marking_old);\n@@ -510,2 +512,0 @@\n-  _allow_old_preemption.set();\n-\n@@ -519,1 +519,4 @@\n-  ShenandoahOldGC gc(generation);\n+  \/\/ We can only really tolerate being cancelled during concurrent\n+  \/\/ marking. This flag here (passed by reference) is used to control\n+  \/\/ precisely where the regulator is allowed to cancel a GC.\n+  ShenandoahOldGC gc(generation, _allow_old_preemption);\n@@ -524,3 +527,14 @@\n-  } else {\n-    assert(heap->cancelled_gc(), \"Old marking must be interrupted.\");\n-    check_cancellation_or_degen(gc.degen_point());\n+  }\n+\n+  if (heap->cancelled_gc()) {\n+    \/\/ It's possible the gc cycle was cancelled after the last time\n+    \/\/ the collection checked for cancellation. In which case, the\n+    \/\/ old gc cycle is still completed and we have to deal with this\n+    \/\/ cancellation. We set the degeneration point to be outside\n+    \/\/ the cycle because if this is an allocation failure, that is\n+    \/\/ what must be done (there is no degenerated old cycle). If the\n+    \/\/ cancellation was due to a heuristic wanting to start a young\n+    \/\/ cycle, then we are not actually going to a degenerated cycle,\n+    \/\/ so the degenerated point doesn't matter here.\n+    check_cancellation_or_degen(ShenandoahGC::_degenerated_outside_cycle);\n+\n@@ -534,1 +548,0 @@\n-      _degen_point = ShenandoahGC::_degenerated_outside_cycle;\n@@ -537,1 +550,0 @@\n-  _allow_old_preemption.unset();\n@@ -618,18 +630,7 @@\n-    if (point != ShenandoahGC::_degenerated_mark) {\n-      \/\/ Okay, cancel is set in the heap now whether we are in concurrent old marking\n-      \/\/ or not. Hopefully, we still are, but we can't guarantee when this thread\n-      \/\/ observes the cancellation. If this thread is still in concurrent marking,\n-      \/\/ then we can suspend without degeneration. Otherwise, we have to degenerate\n-      \/\/ the cycle - we can't just blithely ignore the cancellation because it\n-      \/\/ affects the machinery deeper than us. We could try to abandon the cycle\n-      \/\/ entirely, but that would be a new code path.\n-      \/\/ HEY! We don't actually handle this case in run_service!\n-      _degen_point = point;\n-    } else {\n-      \/\/ We were cancelled during the concurrent mark of old gen. Normally, the\n-      \/\/ degenerated or full cycle would clear the cancellation request, so we\n-      \/\/ need to clear it here so the cycle interrupting us will run. Note that\n-      \/\/ when this condition is met we will _not_ consume _degen_point and will\n-      \/\/ begin a concurrent young cycle.\n-      heap->clear_cancelled_gc(false \/* clear oom handler *\/);\n-    }\n+    \/\/ Old generation marking is only cancellable during concurrent marking.\n+    \/\/ Once final mark is complete, the code does not check again for cancellation.\n+    \/\/ If old generation was cancelled for an allocation failure, we wouldn't\n+    \/\/ make it to this case. The calling code is responsible for forcing a\n+    \/\/ cancellation due to allocation failure into a degenerated cycle.\n+    _degen_point = point;\n+    heap->clear_cancelled_gc(false \/* clear oom handler *\/);\n@@ -728,1 +729,1 @@\n-void ShenandoahControlThread::request_concurrent_gc(GenerationMode generation) {\n+bool ShenandoahControlThread::request_concurrent_gc(GenerationMode generation) {\n@@ -731,1 +732,1 @@\n-    return;\n+    return false;\n@@ -734,2 +735,5 @@\n-  _requested_gc_cause = GCCause::_shenandoah_concurrent_gc;\n-  _requested_generation = generation;\n+  if (_mode == none) {\n+    _requested_gc_cause = GCCause::_shenandoah_concurrent_gc;\n+    _requested_generation = generation;\n+    return true;\n+  }\n@@ -739,0 +743,2 @@\n+    _requested_gc_cause = GCCause::_shenandoah_concurrent_gc;\n+    _requested_generation = generation;\n@@ -740,0 +746,1 @@\n+    set_gc_mode(cancelling);\n@@ -741,0 +748,1 @@\n+    return true;\n@@ -742,0 +750,2 @@\n+\n+  return false;\n@@ -745,1 +755,1 @@\n-  return generation == YOUNG && _allow_old_preemption.try_unset();\n+  return generation == YOUNG && _allow_old_preemption.is_set();\n@@ -781,0 +791,1 @@\n+    set_gc_mode(cancelling);\n@@ -889,0 +900,19 @@\n+\n+const char* ShenandoahControlThread::gc_mode_name(ShenandoahControlThread::GCMode mode) {\n+  switch (mode) {\n+    case none:              return \"idle\";\n+    case concurrent_normal: return \"normal\";\n+    case stw_degenerated:   return \"degenerated\";\n+    case stw_full:          return \"full\";\n+    case marking_old:       return \"old mark\";\n+    case cancelling:        return \"cancelling\";\n+    default:                return \"unknown\";\n+  }\n+}\n+\n+void ShenandoahControlThread::set_gc_mode(ShenandoahControlThread::GCMode new_mode) {\n+  if (_mode != new_mode) {\n+    log_info(gc)(\"Transition from: %s to: %s\", gc_mode_name(_mode), gc_mode_name(new_mode));\n+    _mode = new_mode;\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":75,"deletions":45,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -60,8 +60,0 @@\n-  typedef enum {\n-    none,\n-    concurrent_normal,\n-    stw_degenerated,\n-    stw_full,\n-    resume_old\n-  } GCMode;\n-\n@@ -77,0 +69,9 @@\n+  typedef enum {\n+    none,\n+    concurrent_normal,\n+    stw_degenerated,\n+    stw_full,\n+    marking_old,\n+    cancelling\n+  } GCMode;\n+\n@@ -100,0 +101,2 @@\n+  volatile GCMode _mode;\n+  shenandoah_padding(3);\n@@ -142,1 +145,1 @@\n-  void request_concurrent_gc(GenerationMode generation);\n+  bool request_concurrent_gc(GenerationMode generation);\n@@ -168,0 +171,8 @@\n+\n+  void set_gc_mode(GCMode new_mode);\n+  GCMode gc_mode() {\n+    return _mode;\n+  }\n+\n+ private:\n+  static const char* gc_mode_name(GCMode mode);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.hpp","additions":20,"deletions":9,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -32,2 +32,2 @@\n-ShenandoahOldGC::ShenandoahOldGC(ShenandoahGeneration* generation) :\n-  ShenandoahConcurrentGC(generation) {}\n+ShenandoahOldGC::ShenandoahOldGC(ShenandoahGeneration* generation, ShenandoahSharedFlag& allow_preemption) :\n+  ShenandoahConcurrentGC(generation), _allow_preemption(allow_preemption) {}\n@@ -39,0 +39,1 @@\n+  _allow_preemption.set();\n@@ -40,0 +41,1 @@\n+  _allow_preemption.unset();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGC.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-  ShenandoahOldGC(ShenandoahGeneration* generation);\n+  ShenandoahOldGC(ShenandoahGeneration* generation, ShenandoahSharedFlag& allow_preemption);\n@@ -37,0 +37,2 @@\n+ private:\n+  ShenandoahSharedFlag& _allow_preemption;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGC.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-        ShenandoahMark::mark_through_ref<oop, OLD, STRING_DEDUP>(p, _queue, _queue, _mark_context, false);\n+        ShenandoahMark::mark_through_ref<oop, OLD, STRING_DEDUP>(p, _queue, NULL, _mark_context, false);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,3 +42,0 @@\n-  _last_young_cycle(0),\n-  _last_old_cycle(0),\n-  _last_cycle(0),\n@@ -75,8 +72,11 @@\n-    if (should_start_old_cycle()) {\n-      log_info(gc)(\"Heuristics requesting old collection.\");\n-      _last_old_cycle = _control_thread->get_gc_id();\n-      _control_thread->request_concurrent_gc(OLD);\n-    } else if (should_start_young_cycle()) {\n-      log_info(gc)(\"Heuristics requesting young collection.\");\n-      _last_young_cycle = _control_thread->get_gc_id();\n-      _control_thread->request_concurrent_gc(YOUNG);\n+    ShenandoahControlThread::GCMode mode = _control_thread->gc_mode();\n+    if (mode == ShenandoahControlThread::none) {\n+      if (start_old_cycle()) {\n+        log_info(gc)(\"Heuristics request for old collection accepted\");\n+      } else if (start_young_cycle()) {\n+        log_info(gc)(\"Heuristics request for young collection accepted\");\n+      }\n+    } else if (mode == ShenandoahControlThread::marking_old) {\n+      if (start_young_cycle()) {\n+        log_info(gc)(\"Heuristics request for young collection accepted\");\n+      }\n@@ -94,8 +94,4 @@\n-    if (should_start_cycle(_young_heuristics, _last_cycle)) {\n-      log_info(gc)(\"Heuristics requesting young collection.\");\n-      _last_cycle = _control_thread->get_gc_id();\n-      _control_thread->request_concurrent_gc(YOUNG);\n-    } else if (should_start_cycle(_global_heuristics, _last_cycle)) {\n-      log_info(gc)(\"Heuristics requesting global collection.\");\n-      _last_cycle = _control_thread->get_gc_id();\n-      _control_thread->request_concurrent_gc(GLOBAL);\n+    if (start_global_cycle()) {\n+      log_info(gc)(\"Heuristics request for global collection accepted.\");\n+    } else if (start_young_cycle()) {\n+      log_info(gc)(\"Heuristics request for young collection accepted.\");\n@@ -112,3 +108,2 @@\n-    if (should_start_cycle(_global_heuristics, _last_cycle)) {\n-      _last_cycle = _control_thread->get_gc_id();\n-      _control_thread->request_concurrent_gc(GLOBAL);\n+    if (start_global_cycle()) {\n+      log_info(gc)(\"Heuristics request for global collection accepted.\");\n@@ -137,3 +132,2 @@\n-bool ShenandoahRegulatorThread::should_start_young_cycle() {\n-  return ShenandoahHeap::heap()->mode()->is_generational()\n-      && should_start_cycle(_young_heuristics, _last_young_cycle);\n+bool ShenandoahRegulatorThread::start_old_cycle() {\n+  return _old_heuristics->should_start_gc() && _control_thread->request_concurrent_gc(OLD);\n@@ -142,2 +136,2 @@\n-bool ShenandoahRegulatorThread::should_start_old_cycle() {\n-  return should_start_cycle(_old_heuristics, _last_old_cycle);\n+bool ShenandoahRegulatorThread::start_young_cycle() {\n+  return _young_heuristics->should_start_gc() && _control_thread->request_concurrent_gc(YOUNG);\n@@ -146,7 +140,2 @@\n-bool ShenandoahRegulatorThread::should_start_cycle(ShenandoahHeuristics* heuristics, size_t last_cycle_started) {\n-  \/\/ We want to hold the last heuristic down so that it doesn't repeatedly try to start\n-  \/\/ a cycle. We might consider invoking 'should_start_gc' because in some cases it has\n-  \/\/ side effects (like sampling the allocation rate). On the other hand, the right thing™\n-  \/\/ to do is probably factor allocation rate sampling outside of heuristics evaluation.\n-  return (last_cycle_started == 0 || _control_thread->get_gc_id() > last_cycle_started)\n-      && heuristics->should_start_gc();\n+bool ShenandoahRegulatorThread::start_global_cycle() {\n+  return _global_heuristics->should_start_gc() && _control_thread->request_concurrent_gc(GLOBAL);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRegulatorThread.cpp","additions":23,"deletions":34,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -70,3 +70,3 @@\n-  bool should_start_young_cycle();\n-  bool should_start_old_cycle();\n-  bool should_start_cycle(ShenandoahHeuristics* heuristics, size_t last_cycle_started);\n+  bool start_old_cycle();\n+  bool start_young_cycle();\n+  bool start_global_cycle();\n@@ -80,4 +80,0 @@\n-  size_t _last_young_cycle;\n-  size_t _last_old_cycle;\n-  size_t _last_cycle;\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRegulatorThread.hpp","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"}]}