{"files":[{"patch":"@@ -186,10 +186,5 @@\n-      \/\/ We should only be here if the regulator requested a cycle.\n-      if (_requested_gc_cause == GCCause::_shenandoah_concurrent_gc) {\n-\n-        \/\/ Don't want to spin in this loop and start a cycle every time, so\n-        \/\/ clear requested gc cause. This creates a race with callers of the\n-        \/\/ blocking 'request_gc' method, but there it loops and resets the\n-        \/\/ '_requested_gc_cause' until a full cycle is completed.\n-        _requested_gc_cause = GCCause::_no_gc;\n-        _preemption_requested.unset();\n-\n+      \/\/ We should only be here if the regulator requested a cycle or if\n+      \/\/ there is an old generation mark in progress.\n+      if (_preemption_requested.try_unset() || _requested_gc_cause == GCCause::_shenandoah_concurrent_gc) {\n+        \/\/ preemption was requested or this is a regular cycle\n+        cause = GCCause::_shenandoah_concurrent_gc;\n@@ -197,1 +192,0 @@\n-        cause = default_cause;\n@@ -199,1 +193,0 @@\n-\n@@ -205,0 +198,4 @@\n+      } else if (heap->is_concurrent_old_mark_in_progress()) {\n+        cause = GCCause::_shenandoah_concurrent_gc;\n+        generation = OLD;\n+        mode = resume_old;\n@@ -206,0 +203,6 @@\n+\n+      \/\/ Don't want to spin in this loop and start a cycle every time, so\n+      \/\/ clear requested gc cause. This creates a race with callers of the\n+      \/\/ blocking 'request_gc' method, but there it loops and resets the\n+      \/\/ '_requested_gc_cause' until a full cycle is completed.\n+      _requested_gc_cause = GCCause::_no_gc;\n@@ -248,0 +251,5 @@\n+          case resume_old: {\n+            assert(generation == OLD, \"Expected old generation here\");\n+            resume_concurrent_old_cycle(heap->old_generation(), cause);\n+            break;\n+          }\n@@ -378,1 +386,1 @@\n-\/\/            Young             |               Old +------> Young\n+\/\/            Young             |               Old +------> Young (bootstrap)\n@@ -486,0 +494,1 @@\n+  assert(ShenandoahHeap::heap()->is_concurrent_old_mark_in_progress(), \"Old mark should be in progress\");\n@@ -714,1 +723,1 @@\n-    log_info(gc)(\"Preempting concurrent global mark to allow young GC.\");\n+    log_info(gc)(\"Preempting old generation mark to allow young GC.\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":23,"deletions":14,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -64,1 +64,2 @@\n-    stw_full\n+    stw_full,\n+    resume_old\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"gc\/shenandoah\/shenandoahBarrierSet.hpp\"\n@@ -31,2 +32,0 @@\n-#include \"gc\/shenandoah\/shenandoahYoungGeneration.hpp\"\n-#include \"gc\/shenandoah\/shenandoahBarrierSet.hpp\"\n@@ -34,0 +33,1 @@\n+#include \"gc\/shenandoah\/shenandoahYoungGeneration.hpp\"\n@@ -251,0 +251,2 @@\n+    } else if (r->affiliation() == ShenandoahRegionAffiliation::OLD_GENERATION) {\n+      _heap->old_generation()->increase_used(size * HeapWordSize);\n@@ -396,0 +398,2 @@\n+  } else if (req.affiliation() == ShenandoahRegionAffiliation::OLD_GENERATION) {\n+    _heap->old_generation()->increase_used(ShenandoahHeapRegion::region_size_bytes() * num);\n@@ -432,3 +436,0 @@\n-    if (r->affiliation() == ShenandoahRegionAffiliation::YOUNG_GENERATION) {\n-      _heap->young_generation()->decrease_used(r->used());\n-    }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -201,1 +201,4 @@\n-ShenandoahGeneration::ShenandoahGeneration(GenerationMode generation_mode, uint max_queues) :\n+ShenandoahGeneration::ShenandoahGeneration(GenerationMode generation_mode,\n+                                           uint max_queues,\n+                                           size_t max_capacity,\n+                                           size_t soft_max_capacity) :\n@@ -203,1 +206,3 @@\n-  _task_queues(new ShenandoahObjToScanQueueSet(max_queues)) {\n+  _task_queues(new ShenandoahObjToScanQueueSet(max_queues)),\n+  _affiliated_region_count(0), _used(0),\n+  _max_capacity(max_capacity), _soft_max_capacity(soft_max_capacity) {\n@@ -245,0 +250,28 @@\n+void ShenandoahGeneration::increment_affiliated_region_count() {\n+  _affiliated_region_count++;\n+}\n+\n+void ShenandoahGeneration::decrement_affiliated_region_count() {\n+  _affiliated_region_count--;\n+}\n+\n+void ShenandoahGeneration::increase_used(size_t bytes) {\n+  shenandoah_assert_heaplocked();\n+  _used += bytes;\n+}\n+\n+void ShenandoahGeneration::decrease_used(size_t bytes) {\n+  shenandoah_assert_heaplocked_or_safepoint();\n+  assert(_used >= bytes, \"cannot reduce bytes used by generation below zero\");\n+  _used -= bytes;\n+}\n+\n+size_t ShenandoahGeneration::used_regions_size() const {\n+  return _affiliated_region_count * ShenandoahHeapRegion::region_size_bytes();\n+}\n+\n+size_t ShenandoahGeneration::available() const {\n+  size_t in_use = used();\n+  size_t soft_capacity = soft_max_capacity();\n+  return in_use > soft_capacity ? 0 : soft_capacity - in_use;\n+}\n\\ No newline at end of file\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":35,"deletions":2,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/shenandoah\/heuristics\/shenandoahHeuristics.hpp\"\n@@ -39,2 +40,1 @@\n-  ShenandoahSharedFlag _is_marking_complete;\n-  \/\/ Marking task queues\n+  \/\/ Marking task queues and completeness\n@@ -42,0 +42,9 @@\n+  ShenandoahSharedFlag _is_marking_complete;\n+\n+protected:\n+  \/\/ Usage\n+  size_t _affiliated_region_count;\n+  size_t _used;\n+  size_t _max_capacity;\n+  size_t _soft_max_capacity;\n+\n@@ -43,1 +52,1 @@\n-  ShenandoahGeneration(GenerationMode generation_mode, uint max_queues);\n+  ShenandoahGeneration(GenerationMode generation_mode, uint max_queues, size_t max_capacity, size_t soft_max_capacity);\n@@ -54,5 +63,9 @@\n-  virtual size_t soft_max_capacity() const = 0;\n-  virtual size_t max_capacity() const = 0;\n-  virtual size_t used_regions_size() const = 0;\n-  virtual size_t used() const = 0;\n-  virtual size_t available() const = 0;\n+  virtual size_t soft_max_capacity() const { return _soft_max_capacity; }\n+  virtual size_t max_capacity() const      { return _max_capacity; }\n+  virtual size_t used_regions_size() const;\n+  virtual size_t used() const { return _used; }\n+  virtual size_t available() const;\n+\n+  void set_soft_max_capacity(size_t soft_max_capacity) {\n+    _soft_max_capacity = soft_max_capacity;\n+  }\n@@ -100,0 +113,6 @@\n+  void increment_affiliated_region_count();\n+  void decrement_affiliated_region_count();\n+\n+  void increase_used(size_t bytes);\n+  void decrease_used(size_t bytes);\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.hpp","additions":27,"deletions":8,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -33,1 +33,2 @@\n-  ShenandoahGlobalGeneration(uint max_queues) : ShenandoahGeneration(GLOBAL, max_queues) { }\n+  ShenandoahGlobalGeneration(uint max_queues)\n+  : ShenandoahGeneration(GLOBAL, max_queues, 0, 0) { }\n@@ -38,2 +39,1 @@\n-  size_t max_capacity() const;\n-\n+  virtual size_t max_capacity() const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGlobalGeneration.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -164,3 +164,0 @@\n-  \/\/ Now we know the number of regions, initialize the heuristics.\n-  initialize_heuristics();\n-\n@@ -182,0 +179,4 @@\n+  \/\/ Now we know the number of regions and heap sizes, initialize the heuristics.\n+  initialize_generations();\n+  initialize_heuristics();\n+\n@@ -442,0 +443,11 @@\n+void ShenandoahHeap::initialize_generations() {\n+  size_t max_capacity_new      = young_generation_capacity(max_capacity());\n+  size_t soft_max_capacity_new = young_generation_capacity(soft_max_capacity());\n+  size_t max_capacity_old      = max_capacity() - max_capacity_new;\n+  size_t soft_max_capacity_old = soft_max_capacity() - soft_max_capacity_new;\n+\n+  _young_generation = new ShenandoahYoungGeneration(_max_workers, max_capacity_new, soft_max_capacity_new);\n+  _old_generation = new ShenandoahOldGeneration(_max_workers, max_capacity_old, soft_max_capacity_old);\n+  _global_generation = new ShenandoahGlobalGeneration(_max_workers);\n+}\n+\n@@ -494,3 +506,3 @@\n-  _young_generation(new ShenandoahYoungGeneration(_max_workers)),\n-  _global_generation(new ShenandoahGlobalGeneration(_max_workers)),\n-  _old_generation(new ShenandoahOldGeneration(_max_workers)),\n+  _young_generation(NULL),\n+  _global_generation(NULL),\n+  _old_generation(NULL),\n@@ -613,0 +625,26 @@\n+\/\/ There are three JVM parameters for setting young gen capacity:\n+\/\/    NewSize, MaxNewSize, NewRatio.\n+\/\/\n+\/\/ If only NewSize is set, it assigns a fixed size and the other two parameters are ignored.\n+\/\/ Otherwise NewRatio applies.\n+\/\/\n+\/\/ If NewSize is set in any combination, it provides a lower bound.\n+\/\/\n+\/\/ If MaxNewSize is set it provides an upper bound.\n+\/\/ If this bound is smaller than NewSize, it supersedes,\n+\/\/ resulting in a fixed size given by MaxNewSize.\n+size_t ShenandoahHeap::young_generation_capacity(size_t capacity) {\n+  if (FLAG_IS_CMDLINE(NewSize) && !FLAG_IS_CMDLINE(MaxNewSize) && !FLAG_IS_CMDLINE(NewRatio)) {\n+    capacity = MIN2(NewSize, capacity);\n+  } else {\n+    capacity \/= NewRatio + 1;\n+    if (FLAG_IS_CMDLINE(NewSize)) {\n+      capacity = MAX2(NewSize, capacity);\n+    }\n+    if (FLAG_IS_CMDLINE(MaxNewSize)) {\n+      capacity = MIN2(MaxNewSize, capacity);\n+    }\n+  }\n+  return capacity;\n+}\n+\n@@ -684,0 +722,7 @@\n+\n+  if (mode()->is_generational()) {\n+    size_t soft_max_capacity_young = young_generation_capacity(_soft_max_size);\n+    size_t soft_max_capacity_old = _soft_max_size - soft_max_capacity_young;\n+    _young_generation->set_soft_max_capacity(soft_max_capacity_young);\n+    _old_generation->set_soft_max_capacity(soft_max_capacity_old);\n+  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":51,"deletions":6,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -184,0 +184,1 @@\n+  void initialize_generations();\n@@ -209,0 +210,2 @@\n+  static size_t young_generation_capacity(size_t total_capacity);\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+#include \"shenandoahGeneration.hpp\"\n@@ -503,0 +504,8 @@\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+\n+  if (affiliation() == YOUNG_GENERATION) {\n+    heap->young_generation()->decrease_used(used());\n+  } else if (affiliation() == OLD_GENERATION) {\n+    heap->old_generation()->decrease_used(used());\n+  }\n+\n@@ -508,1 +517,1 @@\n-  ShenandoahHeap::heap()->marking_context()->reset_top_at_mark_start(this);\n+  heap->marking_context()->reset_top_at_mark_start(this);\n@@ -764,1 +773,3 @@\n-      heap->young_generation()->decrement_affiliated_region_count();\n+    heap->young_generation()->decrement_affiliated_region_count();\n+  } else if (_affiliation == ShenandoahRegionAffiliation::OLD_GENERATION) {\n+    heap->old_generation()->decrement_affiliated_region_count();\n@@ -778,0 +789,1 @@\n+      heap->old_generation()->increment_affiliated_region_count();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.cpp","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -8,2 +8,2 @@\n-ShenandoahOldGeneration::ShenandoahOldGeneration(uint max_queues)\n-  : ShenandoahGeneration(OLD, max_queues) {}\n+ShenandoahOldGeneration::ShenandoahOldGeneration(uint max_queues, size_t max_capacity, size_t soft_max_capacity)\n+  : ShenandoahGeneration(OLD, max_queues, max_capacity, soft_max_capacity) {}\n@@ -15,20 +15,0 @@\n-size_t ShenandoahOldGeneration::soft_max_capacity() const {\n-  return 0;\n-}\n-\n-size_t ShenandoahOldGeneration::max_capacity() const {\n-  return 0;\n-}\n-\n-size_t ShenandoahOldGeneration::used_regions_size() const {\n-  return 0;\n-}\n-\n-size_t ShenandoahOldGeneration::used() const {\n-  return 0;\n-}\n-\n-size_t ShenandoahOldGeneration::available() const {\n-  return 0;\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.cpp","additions":2,"deletions":22,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -9,1 +9,1 @@\n-  ShenandoahOldGeneration(uint max_queues);\n+  ShenandoahOldGeneration(uint max_queues, size_t max_capacity, size_t soft_max_capacity);\n@@ -13,6 +13,0 @@\n-  size_t soft_max_capacity() const;\n-  size_t max_capacity() const;\n-  size_t used_regions_size() const;\n-  size_t used() const;\n-  size_t available() const;\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.hpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -169,1 +169,1 @@\n-    size_t coalesced_offset = address - card_start_address;\n+    uint8_t coalesced_offset = static_cast<uint8_t>(address - card_start_address);\n@@ -181,1 +181,1 @@\n-    size_t follow_offset = (address + length_in_words) - _rs->addr_for_card_index(card_at_end);\n+    uint8_t follow_offset = static_cast<uint8_t>((address + length_in_words) - _rs->addr_for_card_index(card_at_end));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,4 +36,2 @@\n-ShenandoahYoungGeneration::ShenandoahYoungGeneration(uint max_queues) :\n-  ShenandoahGeneration(YOUNG, max_queues),\n-  _affiliated_region_count(0),\n-  _used(0),\n+ShenandoahYoungGeneration::ShenandoahYoungGeneration(uint max_queues, size_t max_capacity, size_t soft_max_capacity) :\n+  ShenandoahGeneration(YOUNG, max_queues, max_capacity, soft_max_capacity),\n@@ -47,65 +45,0 @@\n-void ShenandoahYoungGeneration::increment_affiliated_region_count() {\n-  _affiliated_region_count++;\n-}\n-\n-void ShenandoahYoungGeneration::decrement_affiliated_region_count() {\n-  _affiliated_region_count--;\n-}\n-\n-void ShenandoahYoungGeneration::increase_used(size_t bytes) {\n-  shenandoah_assert_heaplocked();\n-  _used += bytes;\n-}\n-\n-void ShenandoahYoungGeneration::decrease_used(size_t bytes) {\n-  shenandoah_assert_heaplocked_or_safepoint();\n-  assert(used() >= bytes, \"cannot reduce bytes used by young generation below zero\");\n-  _used -= bytes;\n-}\n-\n-\/\/ There are three JVM parameters for setting young gen capacity:\n-\/\/    NewSize, MaxNewSize, NewRatio.\n-\/\/\n-\/\/ If only NewSize is set, it assigns a fixed size and the other two parameters are ignored.\n-\/\/ Otherwise NewRatio applies.\n-\/\/\n-\/\/ If NewSize is set in any combination, it provides a lower bound.\n-\/\/\n-\/\/ If MaxNewSize is set it provides an upper bound.\n-\/\/ If this bound is smaller than NewSize, it supersedes,\n-\/\/ resulting in a fixed size given by MaxNewSize.\n-size_t ShenandoahYoungGeneration::configured_capacity(size_t capacity) const {\n-  if (FLAG_IS_CMDLINE(NewSize) && !FLAG_IS_CMDLINE(MaxNewSize) && !FLAG_IS_CMDLINE(NewRatio)) {\n-    capacity = MIN2(NewSize, capacity);\n-  } else {\n-    capacity \/= NewRatio + 1;\n-    if (FLAG_IS_CMDLINE(NewSize)) {\n-      capacity = MAX2(NewSize, capacity);\n-    }\n-    if (FLAG_IS_CMDLINE(MaxNewSize)) {\n-      capacity = MIN2(MaxNewSize, capacity);\n-    }\n-  }\n-  return capacity;\n-}\n-\n-size_t ShenandoahYoungGeneration::soft_max_capacity() const {\n-  size_t capacity = ShenandoahHeap::heap()->soft_max_capacity();\n-  return configured_capacity(capacity);\n-}\n-\n-size_t ShenandoahYoungGeneration::max_capacity() const {\n-  size_t capacity = ShenandoahHeap::heap()->max_capacity();\n-  return configured_capacity(capacity);\n-}\n-\n-size_t ShenandoahYoungGeneration::used_regions_size() const {\n-  return _affiliated_region_count * ShenandoahHeapRegion::region_size_bytes();\n-}\n-\n-size_t ShenandoahYoungGeneration::available() const {\n-  size_t in_use = used();\n-  size_t soft_capacity = soft_max_capacity();\n-  return in_use > soft_capacity ? 0 : soft_capacity - in_use;\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahYoungGeneration.cpp","additions":2,"deletions":69,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -32,2 +32,0 @@\n-  size_t _affiliated_region_count;\n-  size_t _used;\n@@ -37,1 +35,1 @@\n-  ShenandoahYoungGeneration(uint max_queues);\n+  ShenandoahYoungGeneration(uint max_queues, size_t max_capacity, size_t max_soft_capacity);\n@@ -41,16 +39,0 @@\n-  void increment_affiliated_region_count();\n-  void decrement_affiliated_region_count();\n-\n-  void increase_used(size_t bytes);\n-  void decrease_used(size_t bytes);\n-\n-private:\n-  size_t configured_capacity(size_t capacity) const;\n-\n-public:\n-  virtual size_t max_capacity() const;\n-  virtual size_t soft_max_capacity() const;\n-  virtual size_t used_regions_size() const;\n-  virtual size_t used() const { return _used; }\n-  virtual size_t available() const;\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahYoungGeneration.hpp","additions":1,"deletions":19,"binary":false,"changes":20,"status":"modified"}]}