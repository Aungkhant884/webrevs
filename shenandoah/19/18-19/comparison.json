{"files":[{"patch":"@@ -491,6 +491,0 @@\n-  \/\/ Reference processing is disabled when old generation mark is in progress.\n-  \/\/ This is because we must leave the SATB barrier on to cover the old generation\n-  \/\/ snapshot. However, in some cases, the referent of a weak reference may be\n-  \/\/ NULL'd out after final mark. With the SATB barrier enabled, this reference\n-  \/\/ will be enqueued in the SATB buffer and will thereby poison the next cycle.\n-  rp->set_enabled(!heap->is_concurrent_old_mark_in_progress());\n@@ -962,0 +956,4 @@\n+  if (heap->is_concurrent_old_mark_in_progress()) {\n+    heap->purge_old_satb_buffers();\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -385,3 +385,2 @@\n-\/\/ by command line options). Old and young cycles always degenerate to a\n-\/\/ global cycle. Since the mark data for young and old cycles is partial,\n-\/\/ degeneration in these cycles must begin with a global (complete) marking.\n+\/\/ by command line options). Old cycles always degenerate to a global cycle.\n+\/\/ Young cycles are degenerated to complete the young cycle.\n@@ -390,15 +389,18 @@\n-\/\/              +-----------+  Idle  +-----------+\n-\/\/              |               +                |\n-\/\/              v               |                v\n-\/\/                              |\n-\/\/            Young             |               Old +------> Young (bootstrap)\n-\/\/              +               v                +             +\n-\/\/              |                                |             |\n-\/\/              |             Global             |             |\n-\/\/              |               +                |             |\n-\/\/              |               |                |             |\n-\/\/              |               |                |             |\n-\/\/              v               v                |             v\n-\/\/                                               |\n-\/\/            Degen           Degen   <----------+           Degen\n-\/\/            Young           Global                         Young\n+\/\/      +-------------+----------+  Idle  +--------------+\n+\/\/      |             |              +                   |\n+\/\/      |             |              |                   |\n+\/\/      |             |              |                   |\n+\/\/      |             |              |                   |\n+\/\/      |             v              v                   v\n+\/\/      |\n+\/\/      |           Young  <---+ Resume Old  <----+ Bootstrap Old\n+\/\/      |             +            +     +               +\n+\/\/      |             |            |     |               |\n+\/\/      |             v            |     |               v\n+\/\/      v        Young Degen       |     |           Young Degen\n+\/\/                                 |     |\n+\/\/   Global  <--------------------+      |\n+\/\/      +                                |\n+\/\/      |                                v\n+\/\/      |\n+\/\/      +--------------------->  Global Degen\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":20,"deletions":18,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -60,0 +60,9 @@\n+  if (in_progress && heap->is_concurrent_old_mark_in_progress()) {\n+    \/\/ Global collection has preempted an old generation mark. This is fine\n+    \/\/ because the global generation includes the old generation, but we\n+    \/\/ want the global collect to start from a clean slate and we don't want\n+    \/\/ any stale state in the old generation.\n+    heap->purge_old_satb_buffers();\n+    heap->old_generation()->cancel_marking();\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGlobalGeneration.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2365,0 +2365,4 @@\n+void ShenandoahHeap::purge_old_satb_buffers() {\n+  static_cast<ShenandoahOldGeneration*>(_old_generation)->purge_satb_buffers();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -690,0 +690,1 @@\n+  void purge_old_satb_buffers();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+#include \"gc\/shared\/strongRootsScope.hpp\"\n+#include \"gc\/shenandoah\/shenandoahAsserts.hpp\"\n@@ -30,0 +32,1 @@\n+#include \"gc\/shenandoah\/shenandoahMark.inline.hpp\"\n@@ -31,0 +34,88 @@\n+#include \"gc\/shenandoah\/shenandoahOopClosures.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahStringDedup.hpp\"\n+#include \"gc\/shenandoah\/shenandoahUtils.hpp\"\n+\n+class ShenandoahFlushAllSATB : public ThreadClosure {\n+ private:\n+  SATBMarkQueueSet& _satb_qset;\n+  uintx _claim_token;\n+\n+ public:\n+  explicit ShenandoahFlushAllSATB(SATBMarkQueueSet& satb_qset) :\n+    _satb_qset(satb_qset),\n+    _claim_token(Threads::thread_claim_token()) {}\n+\n+  void do_thread(Thread* thread) {\n+    if (thread->claim_threads_do(true, _claim_token)) {\n+      \/\/ Transfer any partial buffer to the qset for completed buffer processing.\n+      _satb_qset.flush_queue(ShenandoahThreadLocalData::satb_mark_queue(thread));\n+    }\n+  }\n+};\n+\n+class ShenandoahProcessOldSATB : public SATBBufferClosure {\n+ private:\n+  ShenandoahObjToScanQueue* _queue;\n+  ShenandoahHeap* _heap;\n+  ShenandoahMarkingContext* const _mark_context;\n+\n+ public:\n+  size_t _trashed_oops;\n+\n+  explicit ShenandoahProcessOldSATB(ShenandoahObjToScanQueue* q) :\n+    _queue(q),\n+    _heap(ShenandoahHeap::heap()),\n+    _mark_context(_heap->marking_context()),\n+    _trashed_oops(0) {}\n+\n+  void do_buffer(void **buffer, size_t size) {\n+    assert(size == 0 || !_heap->has_forwarded_objects() || _heap->is_concurrent_old_mark_in_progress(), \"Forwarded objects are not expected here\");\n+    if (ShenandoahStringDedup::is_enabled()) {\n+      do_buffer_impl<ENQUEUE_DEDUP>(buffer, size);\n+    } else {\n+      do_buffer_impl<NO_DEDUP>(buffer, size);\n+    }\n+  }\n+\n+  template<StringDedupMode STRING_DEDUP>\n+  void do_buffer_impl(void **buffer, size_t size) {\n+    for (size_t i = 0; i < size; ++i) {\n+      oop *p = (oop *) &buffer[i];\n+      ShenandoahHeapRegion* region = _heap->heap_region_containing(*p);\n+      if (!region->is_trash()) {\n+        ShenandoahMark::mark_through_ref<oop, OLD, STRING_DEDUP>(p, _queue, _queue, _mark_context, false);\n+      } else {\n+        ++_trashed_oops;\n+      }\n+    }\n+  }\n+};\n+\n+class ShenandoahPurgeSATBTask : public AbstractGangTask {\n+ private:\n+  ShenandoahObjToScanQueueSet* _mark_queues;\n+ public:\n+  size_t _trashed_oops;\n+\n+  explicit ShenandoahPurgeSATBTask(ShenandoahObjToScanQueueSet* queues) :\n+    AbstractGangTask(\"Purge SATB\"), _mark_queues(queues), _trashed_oops(0) {}\n+\n+  ~ShenandoahPurgeSATBTask() {\n+    if (_trashed_oops > 0) {\n+      log_info(gc)(\"Purged \" SIZE_FORMAT \" oops from old generation SATB buffers.\", _trashed_oops);\n+    }\n+  }\n+\n+  void work(uint worker_id) {\n+    ShenandoahParallelWorkerSession worker_session(worker_id);\n+    ShenandoahSATBMarkQueueSet &satb_queues = ShenandoahBarrierSet::satb_mark_queue_set();\n+    ShenandoahFlushAllSATB flusher(satb_queues);\n+    Threads::threads_do(&flusher);\n+\n+    ShenandoahObjToScanQueue* mark_queue = _mark_queues->queue(worker_id);\n+    ShenandoahProcessOldSATB processor(mark_queue);\n+    while (satb_queues.apply_closure_to_completed_buffer(&processor)) {}\n+\n+    Atomic::add(&_trashed_oops, processor._trashed_oops);\n+  }\n+};\n@@ -55,0 +146,12 @@\n+\n+void ShenandoahOldGeneration::purge_satb_buffers() {\n+  ShenandoahHeap *heap = ShenandoahHeap::heap();\n+\n+  shenandoah_assert_safepoint();\n+  assert(heap->is_concurrent_old_mark_in_progress(), \"Only necessary during old marking.\");\n+  uint nworkers = heap->workers()->active_workers();\n+  StrongRootsScope scope(nworkers);\n+\n+  ShenandoahPurgeSATBTask purge_satb_task(task_queues());\n+  heap->workers()->run_task(&purge_satb_task);\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.cpp","additions":103,"deletions":0,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -43,0 +43,19 @@\n+  \/\/ We leave the SATB barrier on for the entirety of the old generation\n+  \/\/ marking phase. In some cases, this can cause a write to a perfectly\n+  \/\/ reachable oop to enqueue a pointer that later becomes garbage (because\n+  \/\/ it points at an object in the collection set, for example). There are\n+  \/\/ also cases where the referent of a weak reference ends up in the SATB\n+  \/\/ and is later collected. In these cases the oop in the SATB buffer becomes\n+  \/\/ invalid and the _next_ cycle will crash during its marking phase. To\n+  \/\/ avoid this problem, we \"purge\" the SATB buffers during the final update\n+  \/\/ references phase if (and only if) an old generation mark is in progress.\n+  \/\/ At this stage we can safely determine if any of the oops in the SATB\n+  \/\/ buffer belong to trashed regions (before they are recycled). As it\n+  \/\/ happens, flushing a SATB queue also filters out oops which have already\n+  \/\/ been marked - which is the case for anything that is being evacuated\n+  \/\/ from the collection set.\n+  \/\/\n+  \/\/ Alternatively, we could inspect the state of the heap and the age of the\n+  \/\/ object at the barrier, but we reject this approach because it is likely\n+  \/\/ the performance impact would be too severe.\n+  void purge_satb_buffers();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.hpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -204,2 +204,1 @@\n-  _stats(),\n-  _enabled(true) {\n+  _stats() {\n@@ -370,1 +369,1 @@\n-  if (!RegisterReferences || !_enabled) {\n+  if (!RegisterReferences) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahReferenceProcessor.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -143,2 +143,0 @@\n-  bool _enabled;\n-\n@@ -193,4 +191,0 @@\n-\n-  void set_enabled(bool enabled) {\n-    _enabled = enabled;\n-  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahReferenceProcessor.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"}]}