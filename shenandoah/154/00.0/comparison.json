{"files":[{"patch":"@@ -4,1 +4,1 @@\n-version=19\n+version=20\n","filename":".jcheck\/conf","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2018, 2022, Red Hat, Inc. All rights reserved.\n@@ -37,0 +37,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -38,1 +39,0 @@\n-#include \"runtime\/thread.hpp\"\n@@ -170,1 +170,1 @@\n-  \/\/ intrinsified Reference.get() routine) then ebp might be pointing to\n+  \/\/ intrinsified Reference.get() routine) then rfp might be pointing to\n@@ -197,1 +197,1 @@\n-\/\/ IMPORTANT: This must preserve all registers, even rscratch1 and rscratch2, except those explicitely\n+\/\/ IMPORTANT: This must preserve all registers, even rscratch1 and rscratch2, except those explicitly\n@@ -248,1 +248,1 @@\n-  __ enter();\n+  __ enter(\/*strip_ret_addr*\/true);\n@@ -370,1 +370,1 @@\n-    __ enter();\n+    __ enter(\/*strip_ret_addr*\/true);\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shenandoah\/shenandoahBarrierSetAssembler_aarch64.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -69,0 +69,2 @@\n+  virtual NMethodPatchingType nmethod_patching_type() { return NMethodPatchingType::conc_data_patch; }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shenandoah\/shenandoahBarrierSetAssembler_aarch64.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -43,1 +44,0 @@\n-#include \"runtime\/thread.hpp\"\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shenandoah\/shenandoahBarrierSetAssembler_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -37,1 +38,0 @@\n-#include \"runtime\/thread.hpp\"\n@@ -693,1 +693,1 @@\n-                                             Address dst, Register val, Register tmp1, Register tmp2) {\n+              Address dst, Register val, Register tmp1, Register tmp2, Register tmp3) {\n@@ -701,1 +701,0 @@\n-    Register tmp3 = LP64_ONLY(r8) NOT_LP64(rsi);\n@@ -731,1 +730,1 @@\n-      BarrierSetAssembler::store_at(masm, decorators, type, Address(tmp1, 0), val, noreg, noreg);\n+      BarrierSetAssembler::store_at(masm, decorators, type, Address(tmp1, 0), val, noreg, noreg, noreg);\n@@ -734,1 +733,2 @@\n-      BarrierSetAssembler::store_at(masm, decorators, type, Address(tmp1, 0), val, noreg, noreg);\n+      \/\/ XXX: store_check missing from upstream\n+      BarrierSetAssembler::store_at(masm, decorators, type, Address(tmp1, 0), val, noreg, noreg, noreg);\n@@ -739,1 +739,1 @@\n-    BarrierSetAssembler::store_at(masm, decorators, type, dst, val, tmp1, tmp2);\n+    BarrierSetAssembler::store_at(masm, decorators, type, dst, val, tmp1, tmp2, tmp3);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shenandoah\/shenandoahBarrierSetAssembler_x86.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-                        Address dst, Register val, Register tmp1, Register tmp2);\n+                        Address dst, Register val, Register tmp1, Register tmp2, Register tmp3);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shenandoah\/shenandoahBarrierSetAssembler_x86.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -388,26 +388,0 @@\n-\/\/ Unlike several other card table methods, dirty_card_iterate()\n-\/\/ iterates over dirty cards ranges in increasing address order.\n-void CardTable::dirty_card_iterate(MemRegion mr, MemRegionClosure* cl) {\n-  for (int i = 0; i < _cur_covered_regions; i++) {\n-    MemRegion mri = mr.intersection(_covered[i]);\n-    if (!mri.is_empty()) {\n-      CardValue *cur_entry, *next_entry, *limit;\n-      for (cur_entry = byte_for(mri.start()), limit = byte_for(mri.last());\n-           cur_entry <= limit;\n-           cur_entry  = next_entry) {\n-        next_entry = cur_entry + 1;\n-        if (*cur_entry == dirty_card) {\n-          size_t dirty_cards;\n-          \/\/ Accumulate maximal dirty card range, starting at cur_entry\n-          for (dirty_cards = 1;\n-               next_entry <= limit && *next_entry == dirty_card;\n-               dirty_cards++, next_entry++);\n-          MemRegion cur_cards(addr_for(cur_entry),\n-                              dirty_cards*_card_size_in_words);\n-          cl->do_MemRegion(cur_cards);\n-        }\n-      }\n-    }\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTable.cpp","additions":0,"deletions":26,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -221,4 +221,0 @@\n-  \/\/ Apply closure \"cl\" to the dirty cards containing some part of\n-  \/\/ MemRegion \"mr\".\n-  void dirty_card_iterate(MemRegion mr, MemRegionClosure* cl);\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTable.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"gc\/shared\/collectedHeap.hpp\"\n@@ -49,1 +50,0 @@\n-  static size_t AlignmentReserve;\n@@ -72,0 +72,2 @@\n+  static void startup_initialization();\n+\n@@ -76,1 +78,1 @@\n-  static size_t size_required_for_allocation(size_t word_size) { return word_size + AlignmentReserve; }\n+  static size_t size_required_for_allocation(size_t word_size) { return word_size + CollectedHeap::lab_alignment_reserve(); }\n@@ -120,1 +122,1 @@\n-    assert(new_word_sz > AlignmentReserve, \"Too small\");\n+    assert(new_word_sz > CollectedHeap::lab_alignment_reserve(), \"Too small\");\n@@ -126,1 +128,1 @@\n-    _end      = _hard_end - AlignmentReserve;\n+    _end      = _hard_end - CollectedHeap::lab_alignment_reserve();\n","filename":"src\/hotspot\/share\/gc\/shared\/plab.hpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -393,2 +393,2 @@\n-      ciKlass* klass = itype->klass();\n-      if ( klass->is_loaded() &&\n+      ciKlass* klass = itype->instance_klass();\n+      if (klass->is_loaded() &&\n@@ -890,2 +890,2 @@\n-    ciInstanceKlass* ik = src_type->klass()->as_instance_klass();\n-    if ((src_type->klass_is_exact() || (!ik->is_interface() && !ik->has_subklass())) && !ik->has_injected_fields()) {\n+    ciInstanceKlass* ik = src_type->is_instptr()->instance_klass();\n+    if ((src_type->klass_is_exact() || !ik->has_subklass()) && !ik->has_injected_fields()) {\n@@ -903,2 +903,2 @@\n-    BasicType src_elem  = src_type->klass()->as_array_klass()->element_type()->basic_type();\n-    if (is_reference_type(src_elem)) {\n+    BasicType src_elem = src_type->isa_aryptr()->elem()->array_element_basic_type();\n+    if (is_reference_type(src_elem, true)) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahBarrierSetC2.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (C) 2022 THL A29 Limited, a Tencent company. All rights reserved.\n@@ -300,1 +301,1 @@\n-                   adr_type->is_instptr()->klass()->is_subtype_of(Compile::current()->env()->Reference_klass()) &&\n+                   adr_type->is_instptr()->instance_klass()->is_subtype_of(Compile::current()->env()->Reference_klass()) &&\n@@ -569,1 +570,1 @@\n-        Op_HasNegatives,\n+        Op_CountPositives,\n@@ -709,1 +710,1 @@\n-    assert(next->unique_ctrl_out() == c || c->is_Proj() || c->is_Region(), \"multiple control flow out but no proj or region?\");\n+    assert(next->unique_ctrl_out_or_null() == c || c->is_Proj() || c->is_Region(), \"multiple control flow out but no proj or region?\");\n@@ -1337,0 +1338,1 @@\n+    Node* raw_mem_for_ctrl = fixer.find_mem(ctrl, NULL);\n@@ -1363,1 +1365,1 @@\n-    \/\/ even for non-cset objects to prevent ressurrection of such objects.\n+    \/\/ even for non-cset objects to prevent resurrection of such objects.\n@@ -1438,0 +1440,1 @@\n+    fixer.record_new_ctrl(ctrl, region, raw_mem, raw_mem_for_ctrl);\n@@ -2673,0 +2676,7 @@\n+void MemoryGraphFixer::record_new_ctrl(Node* ctrl, Node* new_ctrl, Node* mem, Node* mem_for_ctrl) {\n+  if (mem_for_ctrl != mem && new_ctrl != ctrl) {\n+    _memory_nodes.map(ctrl->_idx, mem);\n+    _memory_nodes.map(new_ctrl->_idx, mem_for_ctrl);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.cpp","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2020, 2022, Red Hat, Inc. All rights reserved.\n@@ -51,0 +51,3 @@\n+  \/\/ Disable Loom\n+  SHENANDOAH_ERGO_DISABLE_FLAG(VMContinuations);\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/mode\/shenandoahIUMode.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2018, 2022, Red Hat, Inc. All rights reserved.\n@@ -38,1 +38,1 @@\n-#if !(defined AARCH64 || defined AMD64 || defined IA32 || defined PPC64)\n+#if !(defined AARCH64 || defined AMD64 || defined IA32 || defined PPC64 || defined RISCV64)\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahArguments.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2021, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2013, 2022, Red Hat, Inc. All rights reserved.\n@@ -26,1 +26,1 @@\n-#include \"gc\/shenandoah\/shenandoahBarrierSet.hpp\"\n+#include \"gc\/shared\/barrierSetNMethod.hpp\"\n@@ -106,1 +106,5 @@\n-    ShenandoahThreadLocalData::set_disarmed_value(thread, ShenandoahCodeRoots::disarmed_value());\n+\n+    BarrierSetNMethod* bs_nm = barrier_set_nmethod();\n+    if (bs_nm != NULL) {\n+      thread->set_nmethod_disarm_value(bs_nm->disarmed_value());\n+    }\n@@ -133,1 +137,1 @@\n-    \/\/ SATB protocol requires to keep alive reacheable oops from roots at the beginning of GC\n+    \/\/ SATB protocol requires to keep alive reachable oops from roots at the beginning of GC\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.cpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2015, 2022, Red Hat, Inc. All rights reserved.\n@@ -90,6 +90,1 @@\n-    \/\/ TODO: It should not be necessary to check evac-in-progress here.\n-    \/\/ We do it for mark-compact, which may have forwarded objects,\n-    \/\/ and objects in cset and gets here via runtime barriers.\n-    \/\/ We can probably fix this as soon as mark-compact has its own\n-    \/\/ marking phase.\n-       Thread* t = Thread::current();\n+      Thread* t = Thread::current();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.inline.hpp","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"gc\/shenandoah\/shenandoahMarkingContext.inline.hpp\"\n@@ -35,0 +36,1 @@\n+#include \"memory\/iterator.inline.hpp\"\n@@ -37,1 +39,1 @@\n-#include \"runtime\/thread.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n@@ -70,0 +72,4 @@\n+void ShenandoahOopClosureBase::do_nmethod(nmethod* nm) {\n+  nm->run_nmethod_entry_barrier();\n+}\n+\n@@ -71,1 +77,1 @@\n-  _bs(static_cast<ShenandoahBarrierSet*>(BarrierSet::barrier_set())) {\n+  _bs(ShenandoahBarrierSet::barrier_set()) {\n@@ -106,3 +112,3 @@\n-template <DecoratorSet MO>\n-ShenandoahEvacuateUpdateMetadataClosure<MO>::ShenandoahEvacuateUpdateMetadataClosure() :\n-  _heap(ShenandoahHeap::heap()), _thread(Thread::current()) {\n+template <bool concurrent, bool stable_thread>\n+ShenandoahEvacuateUpdateRootClosureBase<concurrent, stable_thread>::ShenandoahEvacuateUpdateRootClosureBase() :\n+  _heap(ShenandoahHeap::heap()), _thread(stable_thread ? Thread::current() : NULL) {\n@@ -111,20 +117,7 @@\n-template <DecoratorSet MO>\n-template <class T>\n-void ShenandoahEvacuateUpdateMetadataClosure<MO>::do_oop_work(T* p) {\n-  assert(_heap->is_concurrent_weak_root_in_progress() ||\n-         _heap->is_concurrent_strong_root_in_progress(),\n-         \"Only do this in root processing phase\");\n-  assert(_thread == Thread::current(), \"Wrong thread\");\n-\n-  T o = RawAccess<>::oop_load(p);\n-  if (! CompressedOops::is_null(o)) {\n-    oop obj = CompressedOops::decode_not_null(o);\n-    if (_heap->in_collection_set(obj)) {\n-      assert(_heap->is_evacuation_in_progress(), \"Only do this when evacuation is in progress\");\n-      shenandoah_assert_marked(p, obj);\n-      oop resolved = ShenandoahBarrierSet::resolve_forwarded_not_null(obj);\n-      if (resolved == obj) {\n-        resolved = _heap->evacuate_object(obj, _thread);\n-      }\n-      RawAccess<IS_NOT_NULL | MO>::oop_store(p, resolved);\n-    }\n+template <bool concurrent, bool stable_thread>\n+void ShenandoahEvacuateUpdateRootClosureBase<concurrent, stable_thread>::do_oop(oop* p) {\n+  if (concurrent) {\n+    ShenandoahEvacOOMScope scope;\n+    do_oop_work(p);\n+  } else {\n+    do_oop_work(p);\n@@ -133,11 +126,8 @@\n-template <DecoratorSet MO>\n-void ShenandoahEvacuateUpdateMetadataClosure<MO>::do_oop(oop* p) {\n-  do_oop_work(p);\n-}\n-\n-template <DecoratorSet MO>\n-void ShenandoahEvacuateUpdateMetadataClosure<MO>::do_oop(narrowOop* p) {\n-  do_oop_work(p);\n-}\n-ShenandoahEvacuateUpdateRootsClosure::ShenandoahEvacuateUpdateRootsClosure() :\n-  _heap(ShenandoahHeap::heap()) {\n+template <bool concurrent, bool stable_thread>\n+void ShenandoahEvacuateUpdateRootClosureBase<concurrent, stable_thread>::do_oop(narrowOop* p) {\n+  if (concurrent) {\n+    ShenandoahEvacOOMScope scope;\n+    do_oop_work(p);\n+  } else {\n+    do_oop_work(p);\n+  }\n@@ -147,2 +137,3 @@\n-template <typename T>\n-void ShenandoahEvacuateUpdateRootsClosure::do_oop_work(T* p, Thread* t) {\n+template <bool atomic, bool stable_thread>\n+template <class T>\n+void ShenandoahEvacuateUpdateRootClosureBase<atomic, stable_thread>::do_oop_work(T* p) {\n@@ -152,1 +143,0 @@\n-  assert(t == Thread::current(), \"Wrong thread\");\n@@ -162,1 +152,9 @@\n-        resolved = _heap->evacuate_object(obj, t);\n+        Thread* thr = stable_thread ? _thread : Thread::current();\n+        assert(thr == Thread::current(), \"Wrong thread\");\n+\n+        resolved = _heap->evacuate_object(obj, thr);\n+      }\n+      if (atomic) {\n+        ShenandoahHeap::atomic_update_oop(resolved, p, o);\n+      } else {\n+        RawAccess<IS_NOT_NULL | MO_UNORDERED>::oop_store(p, resolved);\n@@ -164,1 +162,0 @@\n-      ShenandoahHeap::atomic_update_oop(resolved, p, o);\n@@ -169,25 +166,0 @@\n-void ShenandoahEvacuateUpdateRootsClosure::do_oop(oop* p) {\n-  ShenandoahEvacOOMScope scope;\n-  do_oop_work(p, Thread::current());\n-}\n-\n-void ShenandoahEvacuateUpdateRootsClosure::do_oop(narrowOop* p) {\n-  ShenandoahEvacOOMScope scope;\n-  do_oop_work(p, Thread::current());\n-}\n-\n-ShenandoahContextEvacuateUpdateRootsClosure::ShenandoahContextEvacuateUpdateRootsClosure() :\n-  ShenandoahEvacuateUpdateRootsClosure(),\n-  _thread(Thread::current()) {\n-}\n-\n-void ShenandoahContextEvacuateUpdateRootsClosure::do_oop(oop* p) {\n-  ShenandoahEvacOOMScope scope;\n-  do_oop_work(p, _thread);\n-}\n-\n-void ShenandoahContextEvacuateUpdateRootsClosure::do_oop(narrowOop* p) {\n-  ShenandoahEvacOOMScope scope;\n-  do_oop_work(p, _thread);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahClosures.inline.hpp","additions":38,"deletions":66,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2021, 2022, Red Hat, Inc. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"gc\/shared\/continuationGCSupport.inline.hpp\"\n@@ -596,0 +597,4 @@\n+void ShenandoahConcurrentGC::start_mark() {\n+  _mark.start_mark();\n+}\n+\n@@ -636,0 +641,2 @@\n+  start_mark();\n+\n@@ -995,1 +1002,1 @@\n-  ShenandoahEvacuateUpdateMetadataClosure<> _cl;\n+  ShenandoahEvacuateUpdateMetadataClosure   _cl;\n@@ -1054,1 +1061,1 @@\n-        ShenandoahEvacuateUpdateMetadataClosure<> cl;\n+        ShenandoahEvacuateUpdateMetadataClosure cl;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -127,0 +127,2 @@\n+  void start_mark();\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,0 +46,2 @@\n+#include \"runtime\/continuation.hpp\"\n+#include \"runtime\/threads.hpp\"\n@@ -284,0 +286,2 @@\n+\n+  end_mark();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentMark.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (C) 2022 THL A29 Limited, a Tencent company. All rights reserved.\n@@ -739,0 +740,1 @@\n+         cause == GCCause::_codecache_GC_threshold ||\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/shared\/continuationGCSupport.hpp\"\n@@ -59,0 +60,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -60,1 +62,0 @@\n-#include \"runtime\/thread.hpp\"\n@@ -1104,0 +1105,2 @@\n+  void do_method(Method* m) {}\n+  void do_nmethod(nmethod* nm) {}\n@@ -1211,0 +1214,2 @@\n+\n+      ContinuationGCSupport::relativize_stack_chunk(new_obj);\n@@ -1336,0 +1341,1 @@\n+      ContinuationGCSupport::relativize_stack_chunk(cast_to_oop<HeapWord*>(heap->get_region(old_start)->bottom()));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2021, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2013, 2022, Red Hat, Inc. All rights reserved.\n@@ -43,0 +43,1 @@\n+#include \"gc\/shenandoah\/shenandoahMarkingContext.inline.hpp\"\n@@ -2964,0 +2965,18 @@\n+bool ShenandoahHeap::requires_barriers(stackChunkOop obj) const {\n+  if (is_idle()) return false;\n+\n+  \/\/ Objects allocated after marking start are implicitly alive, don't need any barriers during\n+  \/\/ marking phase.\n+  if (is_concurrent_mark_in_progress() &&\n+     !marking_context()->allocated_after_mark_start(obj)) {\n+    return true;\n+  }\n+\n+  \/\/ Can not guarantee obj is deeply good.\n+  if (has_forwarded_objects()) {\n+    return true;\n+  }\n+\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -619,0 +619,2 @@\n+  bool requires_barriers(stackChunkOop obj) const;\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"gc\/shared\/continuationGCSupport.inline.hpp\"\n@@ -51,0 +52,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -52,1 +54,0 @@\n-#include \"runtime\/thread.hpp\"\n@@ -527,0 +528,2 @@\n+  ContinuationGCSupport::relativize_stack_chunk(copy_val);\n+\n@@ -786,1 +789,1 @@\n-    \/\/ preceeds the object, we can skip over it. Once we cannot trust the bitmap,\n+    \/\/ precedes the object, we can skip over it. Once we cannot trust the bitmap,\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.inline.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2021, 2022, Red Hat, Inc. All rights reserved.\n@@ -37,0 +37,17 @@\n+#include \"runtime\/continuation.hpp\"\n+\n+void ShenandoahMark::start_mark() {\n+  \/\/ Tell the sweeper that we start a marking cycle.\n+  if (!Continuations::is_gc_marking_cycle_active()) {\n+    Continuations::on_gc_marking_cycle_start();\n+  }\n+}\n+\n+void ShenandoahMark::end_mark() {\n+  \/\/ Tell the sweeper that we finished a marking cycle.\n+  \/\/ Unlike other GCs, we do not arm the nmethods\n+  \/\/ when marking terminates.\n+  if (!ShenandoahHeap::heap()->is_concurrent_old_mark_in_progress()) {\n+    Continuations::on_gc_marking_cycle_finish();\n+  }\n+}\n@@ -62,10 +79,4 @@\n-  if (heap->unload_classes()) {\n-    if (update_refs) {\n-      using Closure = ShenandoahMarkUpdateRefsMetadataClosure<GENERATION>;\n-      Closure cl(q, rp, old);\n-      mark_loop_work<Closure, GENERATION, CANCELLABLE, STRING_DEDUP>(&cl, ld, w, t, req);\n-    } else {\n-      using Closure = ShenandoahMarkRefsMetadataClosure<GENERATION>;\n-      Closure cl(q, rp, old);\n-      mark_loop_work<Closure, GENERATION, CANCELLABLE, STRING_DEDUP>(&cl, ld, w, t, req);\n-    }\n+  if (update_refs) {\n+    using Closure = ShenandoahMarkUpdateRefsClosure<GENERATION>;\n+    Closure cl(q, rp, old);\n+    mark_loop_work<Closure, GENERATION, CANCELLABLE, STRING_DEDUP>(&cl, ld, w, t, req);\n@@ -73,9 +84,3 @@\n-    if (update_refs) {\n-      using Closure = ShenandoahMarkUpdateRefsClosure<GENERATION>;\n-      Closure cl(q, rp, old);\n-      mark_loop_work<Closure, GENERATION, CANCELLABLE, STRING_DEDUP>(&cl, ld, w, t, req);\n-    } else {\n-      using Closure = ShenandoahMarkRefsClosure<GENERATION>;\n-      Closure cl(q, rp, old);\n-      mark_loop_work<Closure, GENERATION, CANCELLABLE, STRING_DEDUP>(&cl, ld, w, t, req);\n-    }\n+    using Closure = ShenandoahMarkRefsClosure<GENERATION>;\n+    Closure cl(q, rp, old);\n+    mark_loop_work<Closure, GENERATION, CANCELLABLE, STRING_DEDUP>(&cl, ld, w, t, req);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMark.cpp","additions":25,"deletions":20,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2021, 2022, Red Hat, Inc. All rights reserved.\n@@ -50,0 +50,4 @@\n+  \/\/ Loom support\n+  void start_mark();\n+  void end_mark();\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMark.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2015, 2022, Red Hat, Inc. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"gc\/shared\/continuationGCSupport.inline.hpp\"\n@@ -41,0 +42,1 @@\n+#include \"utilities\/devirtualizer.inline.hpp\"\n@@ -76,0 +78,6 @@\n+      if (ContinuationGCSupport::relativize_stack_chunk(obj)) {\n+          \/\/ Loom doesn't support mixing of weak marking and strong marking of\n+          \/\/ stack chunks.\n+          cl->set_weak(false);\n+      }\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMark.inline.hpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2019, 2022, Red Hat, Inc. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"gc\/shenandoah\/shenandoahOopClosures.inline.hpp\"\n@@ -31,0 +32,1 @@\n+#include \"runtime\/continuation.hpp\"\n@@ -169,1 +171,1 @@\n-    assert(heap->cancelled_gc(), \"What else?\");\n+    assert(heap->cancelled_gc() || Continuations::enabled(), \"What else?\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahNMethod.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+#include \"runtime\/threads.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2015, 2022, Red Hat, Inc. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"gc\/shenandoah\/shenandoahClosures.inline.hpp\"\n@@ -33,1 +34,1 @@\n-#include \"runtime\/thread.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n@@ -62,0 +63,5 @@\n+\n+  virtual void do_nmethod(nmethod* nm) {\n+    assert(!is_weak(), \"Can't handle weak marking of nmethods\");\n+    nm->run_nmethod_entry_barrier();\n+  }\n@@ -91,16 +97,0 @@\n-  virtual bool do_metadata()        { return false; }\n-};\n-\n-template <GenerationMode GENERATION>\n-class ShenandoahMarkUpdateRefsMetadataClosure : public ShenandoahMarkUpdateRefsSuperClosure {\n-private:\n-  template <class T>\n-  inline void do_oop_work(T* p)     { work<T, GENERATION>(p); }\n-\n-public:\n-  ShenandoahMarkUpdateRefsMetadataClosure(ShenandoahObjToScanQueue* q, ShenandoahReferenceProcessor* rp, ShenandoahObjToScanQueue* old = NULL) :\n-    ShenandoahMarkUpdateRefsSuperClosure(q, rp, old) {}\n-\n-  virtual void do_oop(narrowOop* p) { do_oop_work(p); }\n-  virtual void do_oop(oop* p)       { do_oop_work(p); }\n-  virtual bool do_metadata()        { return true; }\n@@ -121,16 +111,0 @@\n-  virtual bool do_metadata()        { return false; }\n-};\n-\n-template <GenerationMode GENERATION>\n-class ShenandoahMarkRefsMetadataClosure : public ShenandoahMarkRefsSuperClosure {\n-private:\n-  template <class T>\n-  inline void do_oop_work(T* p)     { work<T, GENERATION>(p); }\n-\n-public:\n-  ShenandoahMarkRefsMetadataClosure(ShenandoahObjToScanQueue* q, ShenandoahReferenceProcessor* rp, ShenandoahObjToScanQueue* old = NULL) :\n-    ShenandoahMarkRefsSuperClosure(q, rp, old) {};\n-\n-  virtual void do_oop(narrowOop* p) { do_oop_work(p); }\n-  virtual void do_oop(oop* p)       { do_oop_work(p); }\n-  virtual bool do_metadata()        { return true; }\n@@ -139,1 +113,1 @@\n-class ShenandoahUpdateRefsSuperClosure : public BasicOopIterateClosure {\n+class ShenandoahUpdateRefsSuperClosure : public ShenandoahOopClosureBase {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOopClosures.hpp","additions":9,"deletions":35,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -41,1 +42,1 @@\n-#include \"runtime\/thread.hpp\"\n+#include \"runtime\/threads.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRootVerifier.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2021, 2022, Red Hat, Inc. All rights reserved.\n@@ -110,0 +110,2 @@\n+  start_mark();\n+\n@@ -130,0 +132,1 @@\n+  end_mark();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahSTWMark.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2018, 2022, Red Hat, Inc. All rights reserved.\n@@ -34,1 +34,1 @@\n-#include \"runtime\/thread.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n@@ -51,0 +51,1 @@\n+  double _paced_time;\n@@ -59,4 +60,0 @@\n-  uint  _worker_id;\n-  int  _disarmed_value;\n-  double _paced_time;\n-\n@@ -75,0 +72,1 @@\n+    _paced_time(0),\n@@ -77,2 +75,0 @@\n-    _disarmed_value(0),\n-    _paced_time(0),\n@@ -83,4 +79,0 @@\n-\n-    \/\/ At least on x86_64, nmethod entry barrier encodes _disarmed_value offset\n-    \/\/ in instruction as disp8 immed\n-    assert(in_bytes(disarmed_value_offset()) < 128, \"Offset range check\");\n@@ -238,4 +230,0 @@\n-  static void set_disarmed_value(Thread* thread, int value) {\n-    data(thread)->_disarmed_value = value;\n-  }\n-\n@@ -291,4 +279,0 @@\n-\n-  static ByteSize disarmed_value_offset() {\n-    return Thread::gc_data_offset() + byte_offset_of(ShenandoahThreadLocalData, _disarmed_value);\n-  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahThreadLocalData.hpp","additions":4,"deletions":20,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+#include \"runtime\/threads.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVerifier.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -87,0 +87,1 @@\n+  compiler\/c2\/irTests \\\n@@ -111,0 +112,16 @@\n+tier1_loom = \\\n+  :tier1_loom_runtime \\\n+  :tier1_loom_serviceability\n+\n+tier1_loom_runtime = \\\n+  runtime\/vthread \\\n+  runtime\/jni\/IsVirtualThread\n+\n+tier1_loom_serviceability = \\\n+  serviceability\/jvmti\/vthread \\\n+  serviceability\/jvmti\/events \\\n+  serviceability\/dcmd\/thread\n+\n+hotspot_loom = \\\n+  :tier1_loom\n+\n@@ -133,0 +150,1 @@\n+  resourcehogs\/compiler \\\n@@ -437,0 +455,1 @@\n+ -runtime\/cds\/appcds\/LambdaWithUseImplMethodHandle.java \\\n@@ -447,0 +466,1 @@\n+ -runtime\/cds\/appcds\/TestParallelGCWithCDS.java \\\n@@ -688,3 +708,0 @@\n-  vmTestbase\/gc\/gctests\/mallocWithGC1\/mallocWithGC1.java \\\n-  vmTestbase\/gc\/gctests\/mallocWithGC2\/mallocWithGC2.java \\\n-  vmTestbase\/gc\/gctests\/mallocWithGC3\/mallocWithGC3.java \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":21,"deletions":4,"binary":false,"changes":25,"status":"modified"}]}