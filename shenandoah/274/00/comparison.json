{"files":[{"patch":"@@ -460,1 +460,1 @@\n-void ShenandoahControlThread::service_concurrent_normal_cycle(const ShenandoahHeap* heap,\n+void ShenandoahControlThread::service_concurrent_normal_cycle(ShenandoahHeap* heap,\n@@ -464,0 +464,1 @@\n+  ShenandoahGeneration* the_generation = nullptr;\n@@ -472,1 +473,2 @@\n-      service_concurrent_cycle(heap->young_generation(), cause, false);\n+      the_generation = heap->young_generation();\n+      service_concurrent_cycle(the_generation, cause, false);\n@@ -477,0 +479,1 @@\n+      the_generation = heap->old_generation();\n@@ -482,1 +485,2 @@\n-      service_concurrent_cycle(heap->global_generation(), cause, false);\n+      the_generation = heap->global_generation();\n+      service_concurrent_cycle(the_generation, cause, false);\n@@ -487,1 +491,2 @@\n-      service_concurrent_cycle(heap->global_generation(), cause, false);\n+      the_generation = heap->global_generation();\n+      service_concurrent_cycle(the_generation, cause, false);\n@@ -497,1 +502,1 @@\n-            \"At end of Interrupted Concurrent Bootstrap GC\";\n+                                    \"At end of Interrupted Concurrent Bootstrap GC\";\n@@ -500,1 +505,13 @@\n-            \"At end of Concurrent Bootstrap GC\";\n+                                    \"At end of Concurrent Bootstrap GC\";\n+      \/\/ We only record GC results if GC was successful\n+      ShenandoahMmuTracker* mmu_tracker = heap->mmu_tracker();\n+      if (generation == YOUNG) {\n+        if (heap->collection_set()->has_old_regions()) {\n+          bool mixed_is_done = (heap->old_heuristics()->unprocessed_old_collection_candidates() == 0);\n+          mmu_tracker->record_mixed(the_generation, GCId::current(), mixed_is_done);\n+        } else {\n+          mmu_tracker->record_young(the_generation, GCId::current());\n+        }\n+      } else {\n+        mmu_tracker->record_bootstrap(the_generation, GCId::current(), heap->collection_set()->has_old_regions());\n+      }\n@@ -509,1 +526,1 @@\n-void ShenandoahControlThread::service_concurrent_old_cycle(const ShenandoahHeap* heap, GCCause::Cause &cause) {\n+void ShenandoahControlThread::service_concurrent_old_cycle(ShenandoahHeap* heap, GCCause::Cause &cause) {\n@@ -591,0 +608,2 @@\n+          heap->mmu_tracker()->record_old_marking_increment(old_generation, GCId::current(), true,\n+                                                            heap->collection_set()->has_old_regions());\n@@ -594,0 +613,2 @@\n+        heap->mmu_tracker()->record_old_marking_increment(old_generation, GCId::current(), false,\n+                                                          heap->collection_set()->has_old_regions());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":28,"deletions":7,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -176,1 +176,1 @@\n-  void service_concurrent_normal_cycle(const ShenandoahHeap* heap,\n+  void service_concurrent_normal_cycle(ShenandoahHeap* heap,\n@@ -180,1 +180,1 @@\n-  void service_concurrent_old_cycle(const ShenandoahHeap* heap,\n+  void service_concurrent_old_cycle(ShenandoahHeap* heap,\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -178,0 +178,1 @@\n+    heap->mmu_tracker()->record_full(heap->global_generation(), GCId::current());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1908,4 +1908,0 @@\n-\n-  \/\/ When a cycle starts, attribute any thread activity when the collector\n-  \/\/ is idle to the global generation.\n-  _mmu_tracker.record(global_generation());\n@@ -1916,1 +1912,0 @@\n-\n@@ -1923,3 +1918,0 @@\n-\n-  \/\/ When a cycle ends, the thread activity is attributed to the respective generation\n-  _mmu_tracker.record(generation);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -287,0 +287,2 @@\n+  inline ShenandoahMmuTracker* const mmu_tracker() { return &_mmu_tracker; };\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,1 +56,18 @@\n-double ShenandoahMmuTracker::gc_thread_time_seconds() {\n+ShenandoahMmuTracker::ShenandoahMmuTracker() :\n+    _most_recent_timestamp(0.0),\n+    _most_recent_gc_time(0.0),\n+    _most_recent_gcu(0.0),\n+    _most_recent_mutator_time(0.0),\n+    _most_recent_mu(0.0),\n+    _most_recent_periodic_time_stamp(0.0),\n+    _most_recent_periodic_gc_time(0.0),\n+    _most_recent_periodic_mutator_time(0.0),\n+    _mmu_periodic_task(new ShenandoahMmuTask(this)) {\n+}\n+\n+ShenandoahMmuTracker::~ShenandoahMmuTracker() {\n+  _mmu_periodic_task->disenroll();\n+  delete _mmu_periodic_task;\n+}\n+\n+void ShenandoahMmuTracker::fetch_cpu_times(double &gc_time, double &mutator_time) {\n@@ -61,1 +78,7 @@\n-  return double(cl.total_time) \/ NANOSECS_PER_SEC;\n+  double most_recent_gc_thread_time = double(cl.total_time) \/ NANOSECS_PER_SEC;\n+  gc_time = most_recent_gc_thread_time;\n+\n+  double process_real_time(0.0), process_user_time(0.0), process_system_time(0.0);\n+  bool valid = os::getTimesSecs(&process_real_time, &process_user_time, &process_system_time);\n+  assert(valid, \"don't know why this would not be valid\");\n+  mutator_time =(process_user_time + process_system_time) - most_recent_gc_thread_time;\n@@ -73,6 +96,24 @@\n-ShenandoahMmuTracker::ShenandoahMmuTracker() :\n-    _generational_reference_time_s(0.0),\n-    _process_reference_time_s(0.0),\n-    _collector_reference_time_s(0.0),\n-    _mmu_periodic_task(new ShenandoahMmuTask(this)),\n-    _mmu_average(10, ShenandoahAdaptiveDecayFactor) {\n+void ShenandoahMmuTracker::help_record_concurrent(ShenandoahGeneration* generation, uint gcid, const char *msg) {\n+  double current = os::elapsedTime();\n+  _most_recent_gcid = gcid;\n+  _most_recent_is_full = false;\n+\n+  if (gcid == 0) {\n+    fetch_cpu_times(_most_recent_gc_time, _most_recent_mutator_time);\n+\n+    _most_recent_timestamp = current;\n+  } else {\n+    double gc_cycle_duration = current - _most_recent_timestamp;\n+    _most_recent_timestamp = current;\n+\n+    double gc_thread_time, mutator_thread_time;\n+    fetch_cpu_times(gc_thread_time, mutator_thread_time);\n+    double gc_time = gc_thread_time - _most_recent_gc_time;\n+    _most_recent_gc_time = gc_thread_time;\n+    _most_recent_gcu = gc_time \/ (_active_processors * gc_cycle_duration);\n+    double mutator_time = mutator_thread_time - _most_recent_mutator_time;\n+    _most_recent_mutator_time = mutator_thread_time;\n+    _most_recent_mu = mutator_time \/ (_active_processors * gc_cycle_duration);\n+    log_info(gc, ergo)(\"At end of %s: GCU: %.1f%%, MU: %.1f%% for duration %.3fs\",\n+                       msg, _most_recent_gcu * 100, _most_recent_mu * 100, gc_cycle_duration);\n+  }\n@@ -81,3 +122,2 @@\n-ShenandoahMmuTracker::~ShenandoahMmuTracker() {\n-  _mmu_periodic_task->disenroll();\n-  delete _mmu_periodic_task;\n+void ShenandoahMmuTracker::record_young(ShenandoahGeneration* generation, uint gcid) {\n+  help_record_concurrent(generation, gcid, \"Concurrent Young GC\");\n@@ -86,6 +126,47 @@\n-void ShenandoahMmuTracker::record(ShenandoahGeneration* generation) {\n-  shenandoah_assert_control_or_vm_thread();\n-  double collector_time_s = gc_thread_time_seconds();\n-  double elapsed_gc_time_s = collector_time_s - _generational_reference_time_s;\n-  generation->add_collection_time(elapsed_gc_time_s);\n-  _generational_reference_time_s = collector_time_s;\n+void ShenandoahMmuTracker::record_bootstrap(ShenandoahGeneration* generation, uint gcid, bool candidates_for_mixed) {\n+  \/\/ Not likely that this will represent an \"ideal\" GCU, but doesn't hurt to try\n+  help_record_concurrent(generation, gcid, \"Bootstrap Old GC\");\n+  if (candidates_for_mixed) {\n+    _doing_mixed_evacuations = true;\n+  }\n+  \/\/ Else, there are no candidates for mixed evacuations, so we are not going to do mixed evacuations.\n+}\n+\n+void ShenandoahMmuTracker::record_old_marking_increment(ShenandoahGeneration* generation, uint gcid, bool old_marking_done,\n+                                                        bool has_old_candidates) {\n+  \/\/ No special processing for old marking\n+  double duration = os::elapsedTime() - _most_recent_timestamp;\n+  double gc_time, mutator_time;\n+  fetch_cpu_times(gc_time, mutator_time);\n+  double gcu = (gc_time - _most_recent_gc_time) \/ duration;\n+  double mu = (mutator_time - _most_recent_mutator_time) \/ duration;\n+  if (has_old_candidates) {\n+    _doing_mixed_evacuations = true;\n+  }\n+  log_info(gc, ergo)(\"At end of %s: GC Utilization: %.1f%% for duration %.3fs (which is subsumed in next concurrent gc report)\",\n+                     old_marking_done? \"last OLD marking increment\": \"OLD marking increment\",\n+                     _most_recent_gcu * 100, duration);\n+}\n+\n+void ShenandoahMmuTracker::record_mixed(ShenandoahGeneration* generation, uint gcid, bool is_mixed_done) {\n+  help_record_concurrent(generation, gcid, \"Mixed Concurrent GC\");\n+}\n+\n+void ShenandoahMmuTracker::record_degenerated(ShenandoahGeneration* generation,\n+                                              uint gcid, bool is_old_bootstrap, bool is_mixed_done) {\n+  if ((gcid == _most_recent_gcid) && _most_recent_is_full) {\n+    \/\/ Do nothing.  This is a redundant recording for the full gc that just completed.\n+  } else if (is_old_bootstrap) {\n+    help_record_concurrent(generation, gcid, \"Degenerated Bootstrap Old GC\");\n+    if (!is_mixed_done) {\n+      _doing_mixed_evacuations = true;\n+    }\n+  } else {\n+    help_record_concurrent(generation, gcid, \"Degenerated Young GC\");\n+  }\n+}\n+\n+void ShenandoahMmuTracker::record_full(ShenandoahGeneration* generation, uint gcid) {\n+  help_record_concurrent(generation, gcid, \"Full GC\");\n+  _most_recent_is_full = true;\n+  _doing_mixed_evacuations = false;\n@@ -96,6 +177,9 @@\n-  double process_time_s = process_time_seconds();\n-  double elapsed_process_time_s = process_time_s - _process_reference_time_s;\n-  if (elapsed_process_time_s <= 0.01) {\n-    \/\/ No cpu time for this interval?\n-    return;\n-  }\n+  double current = os::elapsedTime();\n+  double time_delta = current - _most_recent_periodic_time_stamp;\n+  _most_recent_periodic_time_stamp = current;\n+\n+  double gc_time, mutator_time;\n+  fetch_cpu_times(gc_time, mutator_time);\n+\n+  double gc_delta = gc_time - _most_recent_periodic_gc_time;\n+  _most_recent_periodic_gc_time = gc_time;\n@@ -103,7 +187,6 @@\n-  _process_reference_time_s = process_time_s;\n-  double collector_time_s = gc_thread_time_seconds();\n-  double elapsed_collector_time_s = collector_time_s - _collector_reference_time_s;\n-  _collector_reference_time_s = collector_time_s;\n-  double minimum_mutator_utilization = ((elapsed_process_time_s - elapsed_collector_time_s) \/ elapsed_process_time_s) * 100;\n-  _mmu_average.add(minimum_mutator_utilization);\n-  log_info(gc)(\"Average MMU = %.3f\", _mmu_average.davg());\n+  double mutator_delta = mutator_time - _most_recent_periodic_mutator_time;\n+  _most_recent_periodic_mutator_time = mutator_time;\n+\n+  double mu = mutator_delta \/ (_active_processors * time_delta);\n+  double gcu = gc_delta \/ (_active_processors * time_delta);\n+  log_info(gc)(\"Periodic Sample: Average GCU = %.3f%%, Average MU = %.3f%%\", gcu * 100, mu * 100);\n@@ -113,3 +196,5 @@\n-  _process_reference_time_s = process_time_seconds();\n-  _generational_reference_time_s = gc_thread_time_seconds();\n-  _collector_reference_time_s = _generational_reference_time_s;\n+  \/\/ initialize static data\n+  _active_processors = os::initial_active_processor_count();\n+\n+  double _most_recent_periodic_time_stamp = os::elapsedTime();\n+  fetch_cpu_times(_most_recent_periodic_gc_time, _most_recent_periodic_mutator_time);\n@@ -211,3 +296,4 @@\n-  if (_mmu_tracker->average() >= double(GCTimeRatio)) {\n-    return false;\n-  }\n+  \/\/ With simplified MU implementation, we no longer use _mmu_tracker->average to trigger resizing\n+  \/\/ if (_mmu_tracker->average() >= double(GCTimeRatio)) {\n+  \/\/   return false;\n+  \/\/ }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMmuTracker.cpp","additions":122,"deletions":36,"binary":false,"changes":158,"status":"modified"},{"patch":"@@ -53,0 +53,15 @@\n+private:\n+  \/\/ For reporting utilization during most recent GC cycle\n+  double _most_recent_timestamp;\n+  double _most_recent_gc_time;\n+  double _most_recent_gcu;\n+  double _most_recent_mutator_time;\n+  double _most_recent_mu;\n+\n+  \/\/ For periodic MU\/GCU reports\n+  double _most_recent_periodic_time_stamp;\n+  double _most_recent_periodic_gc_time;\n+  double _most_recent_periodic_mutator_time;\n+\n+  uint _most_recent_gcid;\n+  uint _active_processors;\n@@ -54,3 +69,2 @@\n-  double _generational_reference_time_s;\n-  double _process_reference_time_s;\n-  double _collector_reference_time_s;\n+  bool _most_recent_is_full;\n+  bool _doing_mixed_evacuations;\n@@ -61,1 +75,0 @@\n-  static double gc_thread_time_seconds();\n@@ -63,0 +76,3 @@\n+  static void fetch_cpu_times(double &gc_time, double &mutator_time);\n+\n+  void help_record_concurrent(ShenandoahGeneration* generation, uint gcid, const char* msg);\n@@ -71,6 +87,11 @@\n-  \/\/ This is called at the start and end of a GC cycle. The GC thread times\n-  \/\/ will be accumulated in this generation. Note that the bootstrap cycle\n-  \/\/ for an old collection should be counted against the old generation.\n-  \/\/ When the collector is idle, it still runs a regulator and a control.\n-  \/\/ The times for these threads are attributed to the global generation.\n-  void record(ShenandoahGeneration* generation);\n+  \/\/ At completion of each GC cycle (not including interrupted cycles), we invoke one of the following to record the\n+  \/\/ GC utilization during this cycle.\n+  \/\/\n+  \/\/ We may redundantly record degen and full, in which case the gcid will repeat.  We log these as FULL.\n+  \/\/ Full gets reported first.\n+  void record_young(ShenandoahGeneration* generation, uint gcid);\n+  void record_bootstrap(ShenandoahGeneration* generation, uint gcid, bool has_old_candidates);\n+  void record_old_marking_increment(ShenandoahGeneration* generation, uint gcid, bool old_marking_done, bool has_old_candidates);\n+  void record_mixed(ShenandoahGeneration* generation, uint gcid, bool is_mixed_done);\n+  void record_full(ShenandoahGeneration* generation, uint gcid);\n+  void record_degenerated(ShenandoahGeneration* generation, uint gcid, bool is_old_boostrap, bool is_mixed_done);\n@@ -81,1 +102,0 @@\n-  \/\/ This method also logs the average MMU.\n@@ -83,4 +103,0 @@\n-\n-  double average() {\n-    return _mmu_average.davg();\n-  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMmuTracker.hpp","additions":31,"deletions":15,"binary":false,"changes":46,"status":"modified"}]}