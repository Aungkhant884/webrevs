{"files":[{"patch":"@@ -363,1 +363,1 @@\n-    return true;\n+    return resize_and_evaluate();\n@@ -461,1 +461,1 @@\n-    return true;\n+    return resize_and_evaluate();\n@@ -473,1 +473,1 @@\n-    return true;\n+    return resize_and_evaluate();\n@@ -479,0 +479,22 @@\n+bool ShenandoahAdaptiveHeuristics::resize_and_evaluate() {\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  if (!heap->mode()->is_generational()) {\n+    \/\/ We only attempt to resize the generations in generational mode.\n+    return true;\n+  }\n+\n+  if (_gc_times_learned < ShenandoahLearningSteps) {\n+    \/\/ We aren't going to attempt to resize our generation until we have 'learned'\n+    \/\/ something about it. This provides a kind of cool down period after we've made\n+    \/\/ a change, to help prevent thrashing.\n+    return true;\n+  }\n+\n+  if (!heap->generation_sizer()->transfer_capacity(_generation)) {\n+    \/\/ We could not enlarge our generation, so we must start a gc cycle.\n+    return true;\n+  }\n+\n+  return should_start_gc();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.cpp","additions":25,"deletions":3,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -102,0 +102,2 @@\n+  bool resize_and_evaluate();\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -333,0 +333,4 @@\n+  reset_gc_learning();\n+}\n+\n+void ShenandoahHeuristics::reset_gc_learning() {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -158,0 +158,2 @@\n+  virtual void reset_gc_learning();\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -334,0 +334,6 @@\n+  if (!_promotion_failed) {\n+    if (ShenandoahHeap::heap()->generation_sizer()->transfer_capacity(_old_generation)) {\n+      log_info(gc)(\"Increased size of old generation due to promotion failure.\");\n+    }\n+    \/\/ TODO: Increase tenuring threshold to push back on promotions.\n+  }\n@@ -390,0 +396,4 @@\n+void ShenandoahOldHeuristics::reset_gc_learning() {\n+  _trigger_heuristic->reset_gc_learning();\n+}\n+\n@@ -422,0 +432,1 @@\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -152,0 +152,2 @@\n+  virtual void reset_gc_learning() override;\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -276,1 +276,1 @@\n-  \/\/ Compute the young evauation reserve: This is how much memory is available for evacuating young-gen objects.\n+  \/\/ Compute the young evacuation reserve: This is how much memory is available for evacuating young-gen objects.\n@@ -291,1 +291,1 @@\n-  \/\/  ShenandoahEvacReserve represents the configured taget size of the evacuation region.  We can only honor\n+  \/\/  ShenandoahEvacReserve represents the configured target size of the evacuation region.  We can only honor\n@@ -995,1 +995,0 @@\n-\n@@ -1001,0 +1000,2 @@\n+  _adjusted_capacity += increment;\n+  heuristics()->reset_gc_learning();\n@@ -1008,0 +1009,2 @@\n+  _adjusted_capacity -= decrement;\n+  heuristics()->reset_gc_learning();\n@@ -1021,0 +1024,1 @@\n+  shenandoah_assert_control_or_vm_thread();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -76,0 +76,4 @@\n+  bool is_young() const  { return _generation_mode == YOUNG; }\n+  bool is_old() const    { return _generation_mode == OLD; }\n+  bool is_global() const { return _generation_mode == GLOBAL; }\n+\n@@ -114,0 +118,3 @@\n+  \/\/ Changing the size of the generation will reset the times learned for the heuristic. The heuristic will need to\n+  \/\/ relearn collection performance metrics. This also has the effect of preventing further capacity changes from the\n+  \/\/ heuristics until at least ShenandoahLearningSteps(5) number of cycles has completed.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-  ShenandoahMmuTask(ShenandoahMmuTracker* mmu_tracker) :\n+  explicit ShenandoahMmuTask(ShenandoahMmuTracker* mmu_tracker) :\n@@ -42,1 +42,1 @@\n-  virtual void task() override {\n+  void task() override {\n@@ -51,1 +51,1 @@\n-  virtual void do_thread(Thread* thread) override {\n+  void do_thread(Thread* thread) override {\n@@ -76,0 +76,1 @@\n+    _collector_reference_time_s(0.0),\n@@ -123,1 +124,1 @@\n-    _resize_increment(YoungGenerationSizeIncrement \/ 100.0),\n+    _resize_increment(double(YoungGenerationSizeIncrement) \/ 100.0),\n@@ -204,1 +205,1 @@\n-bool ShenandoahGenerationSizer::adjust_generation_sizes() {\n+bool ShenandoahGenerationSizer::adjust_generation_sizes() const {\n@@ -241,1 +242,11 @@\n-bool ShenandoahGenerationSizer::transfer_capacity(ShenandoahGeneration* from, ShenandoahGeneration* to) {\n+bool ShenandoahGenerationSizer::transfer_capacity(ShenandoahGeneration* target) const {\n+  ShenandoahHeapLocker locker(ShenandoahHeap::heap()->lock());\n+  if (target->is_young()) {\n+    return transfer_capacity(ShenandoahHeap::heap()->old_generation(), target);\n+  } else {\n+    assert(target->is_old(), \"Expected old generation, if not young.\");\n+    return transfer_capacity(ShenandoahHeap::heap()->young_generation(), target);\n+  }\n+}\n+\n+bool ShenandoahGenerationSizer::transfer_capacity(ShenandoahGeneration* from, ShenandoahGeneration* to) const {\n@@ -273,4 +284,0 @@\n-size_t round_down_to_multiple_of_region_size(size_t bytes) {\n-  return (bytes \/ ShenandoahHeapRegion::region_size_bytes()) * ShenandoahHeapRegion::region_size_bytes();\n-}\n-\n@@ -286,1 +293,1 @@\n-    bytes_to_transfer = round_down_to_multiple_of_region_size(from->max_capacity() - minimum_size);\n+    bytes_to_transfer = align_down(from->max_capacity() - minimum_size, ShenandoahHeapRegion::region_size_bytes());\n@@ -300,1 +307,1 @@\n-    bytes_to_transfer = round_down_to_multiple_of_region_size(maximum_size - to->max_capacity());\n+    bytes_to_transfer = align_down(maximum_size - to->max_capacity(), ShenandoahHeapRegion::region_size_bytes());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMmuTracker.cpp","additions":19,"deletions":12,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -117,4 +117,0 @@\n-  \/\/ This will attempt to transfer capacity from one generation to the other. It\n-  \/\/ returns true if a transfer is made, false otherwise.\n-  bool transfer_capacity(ShenandoahGeneration* from, ShenandoahGeneration* to);\n-\n@@ -126,0 +122,3 @@\n+  \/\/ This will attempt to transfer capacity from one generation to the other. It\n+  \/\/ returns true if a transfer is made, false otherwise.\n+  bool transfer_capacity(ShenandoahGeneration* from, ShenandoahGeneration* to) const;\n@@ -127,1 +126,1 @@\n-  ShenandoahGenerationSizer(ShenandoahMmuTracker* mmu_tracker);\n+  explicit ShenandoahGenerationSizer(ShenandoahMmuTracker* mmu_tracker);\n@@ -152,1 +151,5 @@\n-  bool adjust_generation_sizes();\n+  bool adjust_generation_sizes() const;\n+\n+  \/\/ This may be invoked by a heuristic (from regulator thread) before it\n+  \/\/ decides to run a collection.\n+  bool transfer_capacity(ShenandoahGeneration* target) const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMmuTracker.hpp","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"}]}