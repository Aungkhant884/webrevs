{"files":[{"patch":"@@ -83,0 +83,1 @@\n+  size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n@@ -84,2 +85,2 @@\n-  size_t garbage_threshold = ShenandoahHeapRegion::region_size_bytes() * ShenandoahGarbageThreshold \/ 100;\n-  size_t ignore_threshold = ShenandoahHeapRegion::region_size_bytes() * ShenandoahIgnoreGarbageThreshold \/ 100;\n+  size_t garbage_threshold = region_size_bytes * ShenandoahGarbageThreshold \/ 100;\n+  size_t ignore_threshold = region_size_bytes * ShenandoahIgnoreGarbageThreshold \/ 100;\n@@ -92,0 +93,23 @@\n+\n+  \/\/ Figure out how many unaffiliated young regions are dedicated to mutator and to evacuator.  Allow the young\n+  \/\/ collector's unaffiliated regions to be transferred to old-gen if old-gen has more easily reclaimed garbage\n+  \/\/ than young-gen.  At the end of this cycle, any excess regions remaining in old-gen will be transferred back\n+  \/\/ to young.  Do not transfer the mutator's unaffiliated regions to transfer to old-gen.  Those most remain\n+  \/\/ available to the mutator as it needs to be able to consume this memory during the concurrent GC time.\n+\n+  size_t unaffiliated_young_regions = heap->young_generation()->free_unaffiliated_regions();\n+  size_t unaffiliated_young_memory = unaffiliated_young_regions * region_size_bytes;\n+\n+  if (unaffiliated_young_memory > max_young_cset) {\n+    size_t unaffiliated_mutator_memory = unaffiliated_young_memory - max_young_cset;\n+    unaffiliated_young_memory -= unaffiliated_mutator_memory;\n+    unaffiliated_young_regions = unaffiliated_young_memory \/ region_size_bytes; \/\/ round down\n+    unaffiliated_young_memory = unaffiliated_young_regions * region_size_bytes;\n+  }\n+\n+  \/\/ We'll affiliated these unaffiliated regions with either old or young, depending on need.\n+  max_young_cset -= unaffiliated_young_memory;\n+\n+  \/\/ Keep track of how many regions we plan to transfer from young to old.\n+  size_t regions_transferred_to_old = 0;\n+\n@@ -104,0 +128,1 @@\n+      assert(false, \"There should be no preselected regions during GLOBAL GC\");\n@@ -107,1 +132,1 @@\n-    if (r->is_old()) {\n+    if (r->is_old() || (r->age() >= tenuring_threshold)) {\n@@ -109,0 +134,7 @@\n+      if ((r->garbage() > garbage_threshold)) {\n+        while ((new_cset > max_old_cset) && (unaffiliated_young_regions > 0)) {\n+          unaffiliated_young_regions--;\n+          regions_transferred_to_old++;\n+          max_old_cset += region_size_bytes \/ ShenandoahOldEvacWaste;\n+        }\n+      }\n@@ -113,1 +145,2 @@\n-    } else if (r->age() < tenuring_threshold) {\n+    } else {\n+      \/\/ r->is_young() && (r->age() < tenuring_threshold)\n@@ -118,0 +151,7 @@\n+\n+      if (add_regardless || (r->garbage() > garbage_threshold)) {\n+        while ((new_cset > max_young_cset) && (unaffiliated_young_regions > 0)) {\n+          unaffiliated_young_regions--;\n+          max_young_cset += region_size_bytes \/ ShenandoahEvacWaste;\n+        }\n+      }\n@@ -124,3 +164,0 @@\n-    \/\/ Note that we do not add aged regions if they were not pre-selected.  The reason they were not preselected\n-    \/\/ is because there is not sufficient room in old-gen to hold their to-be-promoted live objects.\n-\n@@ -131,0 +168,6 @@\n+\n+  if (regions_transferred_to_old > 0) {\n+    heap->generation_sizer()->force_transfer_to_old(regions_transferred_to_old);\n+    heap->set_young_evac_reserve(heap->get_young_evac_reserve() - regions_transferred_to_old * region_size_bytes);\n+    heap->set_old_evac_reserve(heap->get_old_evac_reserve() + regions_transferred_to_old * region_size_bytes);\n+  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahGlobalHeuristics.cpp","additions":50,"deletions":7,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -301,1 +301,17 @@\n-  if (old_heuristics->unprocessed_old_collection_candidates() > 0) {\n+  if (is_global()) {\n+    \/\/ Global GC is typically triggered by user invocation of System.gc(), and typically indicates that there is lots\n+    \/\/ of garbage to be reclaimed because we are starting a new phase of execution.  Marking for global GC may take\n+    \/\/ significantly longer than typical young marking because we must mark through all old objects.  To expedite\n+    \/\/ evacuation and update-refs, we give emphasis to reclaiming garbage first, wherever that garbage is found.\n+    \/\/ Global GC will adjust generation sizes to accommodate the collection set it chooses.\n+\n+    \/\/ Set old_promo_reserve to enforce that no regions are preselected for promotion.  Such regions typically\n+    \/\/ have relatively high memory utilization.  We still call select_aged_regions() because this will prepare for\n+    \/\/ promotions in place, if relevant.\n+    old_promo_reserve = 0;\n+\n+    \/\/ Dedicate all available old memory to old_evacuation reserve.  This may be small, because old-gen is only\n+    \/\/ expanded based on an existing mixed evacuation workload at the end of the previous GC cycle.  We'll expand\n+    \/\/ the budget for evacuation of old during GLOBAL cset selection.\n+    old_evacuation_reserve = maximum_old_evacuation_reserve;\n+  } else if (old_heuristics->unprocessed_old_collection_candidates() > 0) {\n@@ -322,2 +338,4 @@\n-    \/\/ Let promo consume fragments of old-gen memory.\n-    old_promo_reserve += delta;\n+    \/\/ Let promo consume fragments of old-gen memory if not global\n+    if (!is_global()) {\n+      old_promo_reserve += delta;\n+    }\n@@ -328,4 +346,5 @@\n-  if (consumed_by_advance_promotion < old_promo_reserve) {\n-    \/\/ If we're in a global collection, this memory can be used for old evacuations\n-    old_evacuation_reserve += old_promo_reserve - consumed_by_advance_promotion;\n-  }\n+\n+  \/\/ Note that unused old_promo_reserve might not be entirely consumed_by_advance_promotion.  Do not transfer this\n+  \/\/ to old_evacuation_reserve because this memory is likely very fragmented, and we do not want to increase the likelihood\n+  \/\/ of old evacuatino failure.\n+\n@@ -336,1 +355,2 @@\n-  \/\/ There is no need to expand OLD because all memory used here was set aside at end of previous GC\n+  \/\/ There is no need to expand OLD because all memory used here was set aside at end of previous GC, except in the\n+  \/\/ case of a GLOBAL gc.  During choose_collection_set() of GLOBAL, old will be expanded on demand.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":28,"deletions":8,"binary":false,"changes":36,"status":"modified"}]}