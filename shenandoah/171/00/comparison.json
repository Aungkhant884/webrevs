{"files":[{"patch":"@@ -208,2 +208,2 @@\n-    size_t max_cset    = (size_t) (heap->get_young_evac_reserve() \/ ShenandoahEvacWaste);\n-    size_t cur_cset = 0;\n+    size_t capacity    = ShenandoahHeap::heap()->soft_max_capacity();\n+    size_t max_cset    = (size_t)((1.0 * capacity \/ 100 * ShenandoahEvacReserve) \/ ShenandoahEvacWaste);\n@@ -217,0 +217,3 @@\n+    size_t cur_cset = 0;\n+    size_t cur_garbage = 0;\n+\n@@ -221,1 +224,1 @@\n-      size_t new_garbage = cur_young_garbage + region_garbage;\n+      size_t new_garbage = cur_garbage + region_garbage;\n@@ -226,1 +229,1 @@\n-        cur_young_garbage = new_garbage;\n+        cur_garbage = new_garbage;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.cpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -219,0 +219,1 @@\n+  assert(heap->mode()->is_generational(), \"Only generational mode uses evacuation budgets.\");\n@@ -224,42 +225,0 @@\n-  if (heap->mode()->is_generational()) {\n-    ShenandoahGeneration* old_generation = heap->old_generation();\n-    ShenandoahYoungGeneration* young_generation = heap->young_generation();\n-    size_t avail_evac_reserve_for_loan_to_young_gen = 0;\n-    size_t old_evacuation_reserve = 0;\n-    size_t num_regions = heap->num_regions();\n-\n-    \/\/ During initialization and phase changes, it is more likely that fewer objects die young and old-gen\n-    \/\/ memory is not yet full (or is in the process of being replaced).  During these times especially, it\n-    \/\/ is beneficial to loan memory from old-gen to young-gen during the evacuation and update-refs phases\n-    \/\/ of execution.\n-\n-    \/\/ Calculate EvacuationReserve before PromotionReserve.  Evacuation is more critical than promotion.\n-    \/\/ If we cannot evacuate old-gen, we will not be able to reclaim old-gen memory.  Promotions are less\n-    \/\/ critical.  If we cannot promote, there may be degradation of young-gen memory because old objects\n-    \/\/ accumulate there until they can be promoted.  This increases the young-gen marking and evacuation work.\n-\n-    \/\/ Do not fill up old-gen memory with promotions.  Reserve some amount of memory for compaction purposes.\n-    ShenandoahOldHeuristics* old_heuristics = heap->old_heuristics();\n-    size_t young_evac_reserve_max = 0;\n-    if (old_heuristics->unprocessed_old_collection_candidates() > 0) {\n-      \/\/ Compute old_evacuation_reserve: how much memory are we reserving to hold the results of\n-      \/\/ evacuating old-gen heap regions?  In order to sustain a consistent pace of young-gen collections,\n-      \/\/ the goal is to maintain a consistent value for this parameter (when the candidate set is not\n-      \/\/ empty).  This value is the minimum of:\n-      \/\/   1. old_gen->available()\n-      \/\/   2. old-gen->capacity() * ShenandoahOldEvacReserve) \/ 100\n-      \/\/       (e.g. old evacuation should be no larger than 5% of old_gen capacity)\n-      \/\/   3. ((young_gen->capacity * ShenandoahEvacReserve \/ 100) * ShenandoahOldEvacRatioPercent) \/ 100\n-      \/\/       (e.g. old evacuation should be no larger than 12% of young-gen evacuation)\n-      old_evacuation_reserve = old_generation->available();\n-      assert(old_evacuation_reserve > minimum_evacuation_reserve, \"Old-gen available has not been preserved!\");\n-      size_t old_evac_reserve_max = old_generation->soft_max_capacity() * ShenandoahOldEvacReserve \/ 100;\n-      if (old_evac_reserve_max < old_evacuation_reserve) {\n-        old_evacuation_reserve = old_evac_reserve_max;\n-      }\n-      young_evac_reserve_max =\n-        (((young_generation->soft_max_capacity() * ShenandoahEvacReserve) \/ 100) * ShenandoahOldEvacRatioPercent) \/ 100;\n-      if (young_evac_reserve_max < old_evacuation_reserve) {\n-        old_evacuation_reserve = young_evac_reserve_max;\n-      }\n-    }\n@@ -267,5 +226,4 @@\n-    if (minimum_evacuation_reserve > old_generation->available()) {\n-      \/\/ Due to round-off errors during enforcement of minimum_evacuation_reserve during previous GC passes,\n-      \/\/ there can be slight discrepancies here.\n-      minimum_evacuation_reserve = old_generation->available();\n-    }\n+  ShenandoahGeneration* old_generation = heap->old_generation();\n+  ShenandoahYoungGeneration* young_generation = heap->young_generation();\n+  size_t old_evacuation_reserve = 0;\n+  size_t num_regions = heap->num_regions();\n@@ -273,91 +231,28 @@\n-    heap->set_old_evac_reserve(old_evacuation_reserve);\n-    heap->reset_old_evac_expended();\n-\n-    \/\/ Compute the young evauation reserve: This is how much memory is available for evacuating young-gen objects.\n-    \/\/ We ignore the possible effect of promotions, which reduce demand for young-gen evacuation memory.\n-    \/\/\n-    \/\/ TODO: We could give special treatment to the regions that have reached promotion age, because we know their\n-    \/\/ live data is entirely eligible for promotion.  This knowledge can feed both into calculations of young-gen\n-    \/\/ evacuation reserve and promotion reserve.\n-    \/\/\n-    \/\/  young_evacuation_reserve for young generation: how much memory are we reserving to hold the results\n-    \/\/  of evacuating young collection set regions?  This is typically smaller than the total amount\n-    \/\/  of available memory, and is also smaller than the total amount of marked live memory within\n-    \/\/  young-gen.  This value is the smaller of\n-    \/\/\n-    \/\/    1. (young_gen->capacity() * ShenandoahEvacReserve) \/ 100\n-    \/\/    2. (young_gen->available() + old_gen_memory_available_to_be_loaned\n-    \/\/\n-    \/\/  ShenandoahEvacReserve represents the configured taget size of the evacuation region.  We can only honor\n-    \/\/  this target if there is memory available to hold the evacuations.  Memory is available if it is already\n-    \/\/  free within young gen, or if it can be borrowed from old gen.  Since we have not yet chosen the collection\n-    \/\/  sets, we do not yet know the exact accounting of how many regions will be freed by this collection pass.\n-    \/\/  What we do know is that there will be at least one evacuated young-gen region for each old-gen region that\n-    \/\/  is loaned to the evacuation effort (because regions to be collected consume more memory than the compacted\n-    \/\/  regions that will replace them).  In summary, if there are old-gen regions that are available to hold the\n-    \/\/  results of young-gen evacuations, it is safe to loan them for this purpose.  At this point, we have not yet\n-    \/\/  established a promoted_reserve.  We'll do that after we choose the collection set and analyze its impact\n-    \/\/  on available memory.\n-    \/\/\n-    \/\/ We do not know the evacuation_supplement until after we have computed the collection set.  It is not always\n-    \/\/ the case that young-regions inserted into the collection set will result in net decrease of in-use regions\n-    \/\/ because ShenandoahEvacWaste times multiplied by memory within the region may be larger than the region size.\n-    \/\/ The problem is especially relevant to regions that have been inserted into the collection set because they have\n-    \/\/ reached tenure age.  These regions tend to have much higher utilization (e.g. 95%).  These regions also offer\n-    \/\/ a unique opportunity because we know that every live object contained within the region is elgible to be\n-    \/\/ promoted.  Thus, the following implementation treats these regions specially:\n-    \/\/\n-    \/\/  1. Before beginning collection set selection, we tally the total amount of live memory held within regions\n-    \/\/     that are known to have reached tenure age.  If this memory times ShenandoahEvacWaste is available within\n-    \/\/     old-gen memory, establish an advance promotion reserve to hold all or some percentage of these objects.\n-    \/\/     This advance promotion reserve is excluded from memory available for holding old-gen evacuations and cannot\n-    \/\/     be \"loaned\" to young gen.\n-    \/\/\n-    \/\/  2. Tenure-aged regions are included in the collection set iff their evacuation size * ShenandoahEvacWaste fits\n-    \/\/     within the advance promotion reserve.  It is counter productive to evacuate these regions if they cannot be\n-    \/\/     evacuated directly into old-gen memory.  So if there is not sufficient memory to hold copies of their\n-    \/\/     live data right now, we'll just let these regions remain in young for now, to be evacuated by a subsequent\n-    \/\/     evacuation pass.\n-    \/\/\n-    \/\/  3. Next, we calculate a young-gen evacuation budget, which is the smaller of the two quantities mentioned\n-    \/\/     above.  old_gen_memory_available_to_be_loaned is calculated as:\n-    \/\/       old_gen->available - (advance-promotion-reserve + old-gen_evacuation_reserve)\n-    \/\/\n-    \/\/  4. When choosing the collection set, special care is taken to assure that the amount of loaned memory required to\n-    \/\/     hold the results of evacuation is smaller than the total memory occupied by the regions added to the collection\n-    \/\/     set.  We need to take these precautions because we do not know how much memory will be reclaimed by evacuation\n-    \/\/     until after the collection set has been constructed.  The algorithm is as follows:\n-    \/\/\n-    \/\/     a. We feed into the algorithm (i) young available at the start of evacuation and (ii) the amount of memory\n-    \/\/        loaned from old-gen that is available to hold the results of evacuation.\n-    \/\/     b. As candidate regions are added into the young-gen collection set, we maintain accumulations of the amount\n-    \/\/        of memory spanned by the collection set regions and the amount of memory that must be reserved to hold\n-    \/\/        evacuation results (by multiplying live-data size by ShenandoahEvacWaste).  We process candidate regions\n-    \/\/        in order of decreasing amounts of garbage.  We skip over (and do not include into the collection set) any\n-    \/\/        regions that do not satisfy all of the following conditions:\n-    \/\/\n-    \/\/          i. The amount of live data within the region as scaled by ShenandoahEvacWaste must fit within the\n-    \/\/             relevant evacuation reserve (live data of old-gen regions must fit within the old-evac-reserve, live\n-    \/\/             data of young-gen tenure-aged regions must fit within the advance promotion reserve, live data within\n-    \/\/             other young-gen regions must fit within the youn-gen evacuation reserve).\n-    \/\/         ii. The accumulation of memory consumed by evacuation must not exceed the accumulation of memory reclaimed\n-    \/\/             through evacuation by more than young-gen available.\n-    \/\/        iii. Other conditions may be enforced as appropriate for specific heuristics.\n-    \/\/\n-    \/\/       Note that regions are considered for inclusion in the selection set in order of decreasing amounts of garbage.\n-    \/\/       It is possible that a region with a larger amount of garbage will be rejected because it also has a larger\n-    \/\/       amount of live data and some region that follows this region in candidate order is included in the collection\n-    \/\/       set (because it has less live data and thus can fit within the evacuation limits even though it has less\n-    \/\/       garbage).\n-\n-    size_t young_evacuation_reserve = (young_generation->max_capacity() * ShenandoahEvacReserve) \/ 100;\n-    \/\/ old evacuation can pack into existing partially used regions.  young evacuation and loans for young allocations\n-    \/\/ need to target regions that do not already hold any old-gen objects.  Round down.\n-    regions_available_to_loan = old_generation->free_unaffiliated_regions();\n-\n-    size_t required_evacuation_reserve;\n-    \/\/ Memory evacuated from old-gen on this pass will be available to hold old-gen evacuations in next pass.\n-    if (old_evacuation_reserve > minimum_evacuation_reserve) {\n-      required_evacuation_reserve = 0;\n-    } else {\n-      required_evacuation_reserve = minimum_evacuation_reserve - old_evacuation_reserve;\n+  \/\/ During initialization and phase changes, it is more likely that fewer objects die young and old-gen\n+  \/\/ memory is not yet full (or is in the process of being replaced).  During these times especially, it\n+  \/\/ is beneficial to loan memory from old-gen to young-gen during the evacuation and update-refs phases\n+  \/\/ of execution.\n+\n+  \/\/ Calculate EvacuationReserve before PromotionReserve.  Evacuation is more critical than promotion.\n+  \/\/ If we cannot evacuate old-gen, we will not be able to reclaim old-gen memory.  Promotions are less\n+  \/\/ critical.  If we cannot promote, there may be degradation of young-gen memory because old objects\n+  \/\/ accumulate there until they can be promoted.  This increases the young-gen marking and evacuation work.\n+\n+  \/\/ Do not fill up old-gen memory with promotions.  Reserve some amount of memory for compaction purposes.\n+  ShenandoahOldHeuristics* old_heuristics = heap->old_heuristics();\n+  size_t young_evac_reserve_max = 0;\n+  if (old_heuristics->unprocessed_old_collection_candidates() > 0) {\n+    \/\/ Compute old_evacuation_reserve: how much memory are we reserving to hold the results of\n+    \/\/ evacuating old-gen heap regions?  In order to sustain a consistent pace of young-gen collections,\n+    \/\/ the goal is to maintain a consistent value for this parameter (when the candidate set is not\n+    \/\/ empty).  This value is the minimum of:\n+    \/\/   1. old_gen->available()\n+    \/\/   2. old-gen->capacity() * ShenandoahOldEvacReserve) \/ 100\n+    \/\/       (e.g. old evacuation should be no larger than 5% of old_gen capacity)\n+    \/\/   3. ((young_gen->capacity * ShenandoahEvacReserve \/ 100) * ShenandoahOldEvacRatioPercent) \/ 100\n+    \/\/       (e.g. old evacuation should be no larger than 12% of young-gen evacuation)\n+    old_evacuation_reserve = old_generation->available();\n+    assert(old_evacuation_reserve > minimum_evacuation_reserve, \"Old-gen available has not been preserved!\");\n+    size_t old_evac_reserve_max = old_generation->soft_max_capacity() * ShenandoahOldEvacReserve \/ 100;\n+    if (old_evac_reserve_max < old_evacuation_reserve) {\n+      old_evacuation_reserve = old_evac_reserve_max;\n@@ -365,8 +260,4 @@\n-\n-    consumed_by_advance_promotion = _heuristics->select_aged_regions(\n-      old_generation->available() - old_evacuation_reserve - required_evacuation_reserve, num_regions, preselected_regions);\n-    size_t net_available_old_regions =\n-      (old_generation->available() - old_evacuation_reserve - consumed_by_advance_promotion) \/ region_size_bytes;\n-\n-   if (regions_available_to_loan > net_available_old_regions) {\n-      regions_available_to_loan = net_available_old_regions;\n+    young_evac_reserve_max =\n+      (((young_generation->soft_max_capacity() * ShenandoahEvacReserve) \/ 100) * ShenandoahOldEvacRatioPercent) \/ 100;\n+    if (young_evac_reserve_max < old_evacuation_reserve) {\n+      old_evacuation_reserve = young_evac_reserve_max;\n@@ -374,0 +265,1 @@\n+  }\n@@ -375,2 +267,5 @@\n-    \/\/ Otherwise, regions_available_to_loan is less than net_available_old_regions because available memory is\n-    \/\/ scattered between multiple partially used regions.\n+  if (minimum_evacuation_reserve > old_generation->available()) {\n+    \/\/ Due to round-off errors during enforcement of minimum_evacuation_reserve during previous GC passes,\n+    \/\/ there can be slight discrepancies here.\n+    minimum_evacuation_reserve = old_generation->available();\n+  }\n@@ -378,19 +273,89 @@\n-    if (young_evacuation_reserve > young_generation->available()) {\n-      size_t short_fall = young_evacuation_reserve - young_generation->available();\n-      if (regions_available_to_loan * region_size_bytes >= short_fall) {\n-        old_regions_loaned_for_young_evac = (short_fall + region_size_bytes - 1) \/ region_size_bytes;\n-        regions_available_to_loan -= old_regions_loaned_for_young_evac;\n-      } else {\n-        old_regions_loaned_for_young_evac = regions_available_to_loan;\n-        regions_available_to_loan = 0;\n-        young_evacuation_reserve = young_generation->available() + old_regions_loaned_for_young_evac * region_size_bytes;\n-        \/\/ In this case, there's no memory available for new allocations while evacuating and updating, unless we\n-        \/\/ find more old-gen memory to borrow below.\n-      }\n-    }\n-    \/\/ In generational mode, we may end up choosing a young collection set that contains so many promotable objects\n-    \/\/ that there is not sufficient space in old generation to hold the promoted objects.  That is ok because we have\n-    \/\/ assured there is sufficient space in young generation to hold the rejected promotion candidates.  These rejected\n-    \/\/ promotion candidates will presumably be promoted in a future evacuation cycle.\n-    heap->set_young_evac_reserve(young_evacuation_reserve);\n-    collection_set->establish_preselected(preselected_regions);\n+  heap->set_old_evac_reserve(old_evacuation_reserve);\n+  heap->reset_old_evac_expended();\n+\n+  \/\/ Compute the young evauation reserve: This is how much memory is available for evacuating young-gen objects.\n+  \/\/ We ignore the possible effect of promotions, which reduce demand for young-gen evacuation memory.\n+  \/\/\n+  \/\/ TODO: We could give special treatment to the regions that have reached promotion age, because we know their\n+  \/\/ live data is entirely eligible for promotion.  This knowledge can feed both into calculations of young-gen\n+  \/\/ evacuation reserve and promotion reserve.\n+  \/\/\n+  \/\/  young_evacuation_reserve for young generation: how much memory are we reserving to hold the results\n+  \/\/  of evacuating young collection set regions?  This is typically smaller than the total amount\n+  \/\/  of available memory, and is also smaller than the total amount of marked live memory within\n+  \/\/  young-gen.  This value is the smaller of\n+  \/\/\n+  \/\/    1. (young_gen->capacity() * ShenandoahEvacReserve) \/ 100\n+  \/\/    2. (young_gen->available() + old_gen_memory_available_to_be_loaned\n+  \/\/\n+  \/\/  ShenandoahEvacReserve represents the configured taget size of the evacuation region.  We can only honor\n+  \/\/  this target if there is memory available to hold the evacuations.  Memory is available if it is already\n+  \/\/  free within young gen, or if it can be borrowed from old gen.  Since we have not yet chosen the collection\n+  \/\/  sets, we do not yet know the exact accounting of how many regions will be freed by this collection pass.\n+  \/\/  What we do know is that there will be at least one evacuated young-gen region for each old-gen region that\n+  \/\/  is loaned to the evacuation effort (because regions to be collected consume more memory than the compacted\n+  \/\/  regions that will replace them).  In summary, if there are old-gen regions that are available to hold the\n+  \/\/  results of young-gen evacuations, it is safe to loan them for this purpose.  At this point, we have not yet\n+  \/\/  established a promoted_reserve.  We'll do that after we choose the collection set and analyze its impact\n+  \/\/  on available memory.\n+  \/\/\n+  \/\/ We do not know the evacuation_supplement until after we have computed the collection set.  It is not always\n+  \/\/ the case that young-regions inserted into the collection set will result in net decrease of in-use regions\n+  \/\/ because ShenandoahEvacWaste times multiplied by memory within the region may be larger than the region size.\n+  \/\/ The problem is especially relevant to regions that have been inserted into the collection set because they have\n+  \/\/ reached tenure age.  These regions tend to have much higher utilization (e.g. 95%).  These regions also offer\n+  \/\/ a unique opportunity because we know that every live object contained within the region is elgible to be\n+  \/\/ promoted.  Thus, the following implementation treats these regions specially:\n+  \/\/\n+  \/\/  1. Before beginning collection set selection, we tally the total amount of live memory held within regions\n+  \/\/     that are known to have reached tenure age.  If this memory times ShenandoahEvacWaste is available within\n+  \/\/     old-gen memory, establish an advance promotion reserve to hold all or some percentage of these objects.\n+  \/\/     This advance promotion reserve is excluded from memory available for holding old-gen evacuations and cannot\n+  \/\/     be \"loaned\" to young gen.\n+  \/\/\n+  \/\/  2. Tenure-aged regions are included in the collection set iff their evacuation size * ShenandoahEvacWaste fits\n+  \/\/     within the advance promotion reserve.  It is counter productive to evacuate these regions if they cannot be\n+  \/\/     evacuated directly into old-gen memory.  So if there is not sufficient memory to hold copies of their\n+  \/\/     live data right now, we'll just let these regions remain in young for now, to be evacuated by a subsequent\n+  \/\/     evacuation pass.\n+  \/\/\n+  \/\/  3. Next, we calculate a young-gen evacuation budget, which is the smaller of the two quantities mentioned\n+  \/\/     above.  old_gen_memory_available_to_be_loaned is calculated as:\n+  \/\/       old_gen->available - (advance-promotion-reserve + old-gen_evacuation_reserve)\n+  \/\/\n+  \/\/  4. When choosing the collection set, special care is taken to assure that the amount of loaned memory required to\n+  \/\/     hold the results of evacuation is smaller than the total memory occupied by the regions added to the collection\n+  \/\/     set.  We need to take these precautions because we do not know how much memory will be reclaimed by evacuation\n+  \/\/     until after the collection set has been constructed.  The algorithm is as follows:\n+  \/\/\n+  \/\/     a. We feed into the algorithm (i) young available at the start of evacuation and (ii) the amount of memory\n+  \/\/        loaned from old-gen that is available to hold the results of evacuation.\n+  \/\/     b. As candidate regions are added into the young-gen collection set, we maintain accumulations of the amount\n+  \/\/        of memory spanned by the collection set regions and the amount of memory that must be reserved to hold\n+  \/\/        evacuation results (by multiplying live-data size by ShenandoahEvacWaste).  We process candidate regions\n+  \/\/        in order of decreasing amounts of garbage.  We skip over (and do not include into the collection set) any\n+  \/\/        regions that do not satisfy all of the following conditions:\n+  \/\/\n+  \/\/          i. The amount of live data within the region as scaled by ShenandoahEvacWaste must fit within the\n+  \/\/             relevant evacuation reserve (live data of old-gen regions must fit within the old-evac-reserve, live\n+  \/\/             data of young-gen tenure-aged regions must fit within the advance promotion reserve, live data within\n+  \/\/             other young-gen regions must fit within the youn-gen evacuation reserve).\n+  \/\/         ii. The accumulation of memory consumed by evacuation must not exceed the accumulation of memory reclaimed\n+  \/\/             through evacuation by more than young-gen available.\n+  \/\/        iii. Other conditions may be enforced as appropriate for specific heuristics.\n+  \/\/\n+  \/\/       Note that regions are considered for inclusion in the selection set in order of decreasing amounts of garbage.\n+  \/\/       It is possible that a region with a larger amount of garbage will be rejected because it also has a larger\n+  \/\/       amount of live data and some region that follows this region in candidate order is included in the collection\n+  \/\/       set (because it has less live data and thus can fit within the evacuation limits even though it has less\n+  \/\/       garbage).\n+\n+  size_t young_evacuation_reserve = (young_generation->max_capacity() * ShenandoahEvacReserve) \/ 100;\n+  \/\/ old evacuation can pack into existing partially used regions.  young evacuation and loans for young allocations\n+  \/\/ need to target regions that do not already hold any old-gen objects.  Round down.\n+  regions_available_to_loan = old_generation->free_unaffiliated_regions();\n+\n+  size_t required_evacuation_reserve;\n+  \/\/ Memory evacuated from old-gen on this pass will be available to hold old-gen evacuations in next pass.\n+  if (old_evacuation_reserve > minimum_evacuation_reserve) {\n+    required_evacuation_reserve = 0;\n@@ -398,5 +363,26 @@\n-    \/\/ Not generational mode: limit young evac reserve by young available; no need to establish old_evac_reserve.\n-    ShenandoahYoungGeneration* young_generation = heap->young_generation();\n-    size_t young_evac_reserve = (young_generation->soft_max_capacity() * ShenandoahEvacReserve) \/ 100;\n-    if (young_evac_reserve > young_generation->available()) {\n-      young_evac_reserve = young_generation->available();\n+    required_evacuation_reserve = minimum_evacuation_reserve - old_evacuation_reserve;\n+  }\n+\n+  consumed_by_advance_promotion = _heuristics->select_aged_regions(\n+    old_generation->available() - old_evacuation_reserve - required_evacuation_reserve, num_regions, preselected_regions);\n+  size_t net_available_old_regions =\n+    (old_generation->available() - old_evacuation_reserve - consumed_by_advance_promotion) \/ region_size_bytes;\n+\n+ if (regions_available_to_loan > net_available_old_regions) {\n+    regions_available_to_loan = net_available_old_regions;\n+  }\n+\n+  \/\/ Otherwise, regions_available_to_loan is less than net_available_old_regions because available memory is\n+  \/\/ scattered between multiple partially used regions.\n+\n+  if (young_evacuation_reserve > young_generation->available()) {\n+    size_t short_fall = young_evacuation_reserve - young_generation->available();\n+    if (regions_available_to_loan * region_size_bytes >= short_fall) {\n+      old_regions_loaned_for_young_evac = (short_fall + region_size_bytes - 1) \/ region_size_bytes;\n+      regions_available_to_loan -= old_regions_loaned_for_young_evac;\n+    } else {\n+      old_regions_loaned_for_young_evac = regions_available_to_loan;\n+      regions_available_to_loan = 0;\n+      young_evacuation_reserve = young_generation->available() + old_regions_loaned_for_young_evac * region_size_bytes;\n+      \/\/ In this case, there's no memory available for new allocations while evacuating and updating, unless we\n+      \/\/ find more old-gen memory to borrow below.\n@@ -404,1 +390,0 @@\n-    heap->set_young_evac_reserve(young_evac_reserve);\n@@ -406,0 +391,6 @@\n+  \/\/ In generational mode, we may end up choosing a young collection set that contains so many promotable objects\n+  \/\/ that there is not sufficient space in old generation to hold the promoted objects.  That is ok because we have\n+  \/\/ assured there is sufficient space in young generation to hold the rejected promotion candidates.  These rejected\n+  \/\/ promotion candidates will presumably be promoted in a future evacuation cycle.\n+  heap->set_young_evac_reserve(young_evacuation_reserve);\n+  collection_set->establish_preselected(preselected_regions);\n@@ -428,38 +419,38 @@\n-  if (heap->mode()->is_generational()) {\n-    size_t old_regions_loaned_for_young_evac, regions_available_to_loan;\n-    size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n-    ShenandoahOldGeneration* old_generation = heap->old_generation();\n-    ShenandoahYoungGeneration* young_generation = heap->young_generation();\n-    size_t old_evacuated = collection_set->get_old_bytes_reserved_for_evacuation();\n-    size_t old_evacuated_committed = (size_t) (ShenandoahEvacWaste * old_evacuated);\n-    size_t old_evacuation_reserve = heap->get_old_evac_reserve();\n-    \/\/ Immediate garbage found during choose_collection_set() is all young\n-    size_t immediate_garbage = collection_set->get_immediate_trash();\n-    size_t old_available = old_generation->available();\n-    size_t young_available = young_generation->available() + immediate_garbage;\n-    size_t loaned_regions = 0;\n-    size_t available_loan_remnant = 0; \/\/ loaned memory that is not yet dedicated to any particular budget\n-\n-    assert(((consumed_by_advance_promotion * 33) \/ 32) >= collection_set->get_young_bytes_to_be_promoted() * ShenandoahEvacWaste,\n-           \"Advance promotion (\" SIZE_FORMAT \") should be at least young_bytes_to_be_promoted (\" SIZE_FORMAT\n-           \")* ShenandoahEvacWaste, totalling: \" SIZE_FORMAT \", within round-off errors of up to 3.125%%\",\n-           consumed_by_advance_promotion, collection_set->get_young_bytes_to_be_promoted(),\n-           (size_t) (collection_set->get_young_bytes_to_be_promoted() * ShenandoahEvacWaste));\n-\n-    assert(consumed_by_advance_promotion <= (collection_set->get_young_bytes_to_be_promoted() * ShenandoahEvacWaste * 33) \/ 32,\n-           \"Round-off errors should be less than 3.125%%, consumed by advance: \" SIZE_FORMAT \", promoted: \" SIZE_FORMAT,\n-           consumed_by_advance_promotion, (size_t) (collection_set->get_young_bytes_to_be_promoted() * ShenandoahEvacWaste));\n-\n-    collection_set->abandon_preselected();\n-\n-    if (old_evacuated_committed > old_evacuation_reserve) {\n-      \/\/ This should only happen due to round-off errors when enforcing ShenandoahEvacWaste\n-      assert(old_evacuated_committed <= (33 * old_evacuation_reserve) \/ 32,\n-             \"Round-off errors should be less than 3.125%%, committed: \" SIZE_FORMAT \", reserved: \" SIZE_FORMAT,\n-             old_evacuated_committed, old_evacuation_reserve);\n-      old_evacuated_committed = old_evacuation_reserve;\n-    } else if (old_evacuated_committed < old_evacuation_reserve) {\n-      \/\/ This may happen if the old-gen collection consumes less than full budget.\n-      old_evacuation_reserve = old_evacuated_committed;\n-      heap->set_old_evac_reserve(old_evacuation_reserve);\n-    }\n+  assert(heap->mode()->is_generational(), \"Only generational mode uses evacuation budgets.\");\n+  size_t old_regions_loaned_for_young_evac, regions_available_to_loan;\n+  size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n+  ShenandoahOldGeneration* old_generation = heap->old_generation();\n+  ShenandoahYoungGeneration* young_generation = heap->young_generation();\n+  size_t old_evacuated = collection_set->get_old_bytes_reserved_for_evacuation();\n+  size_t old_evacuated_committed = (size_t) (ShenandoahEvacWaste * old_evacuated);\n+  size_t old_evacuation_reserve = heap->get_old_evac_reserve();\n+  \/\/ Immediate garbage found during choose_collection_set() is all young\n+  size_t immediate_garbage = collection_set->get_immediate_trash();\n+  size_t old_available = old_generation->available();\n+  size_t young_available = young_generation->available() + immediate_garbage;\n+  size_t loaned_regions = 0;\n+  size_t available_loan_remnant = 0; \/\/ loaned memory that is not yet dedicated to any particular budget\n+\n+  assert(((consumed_by_advance_promotion * 33) \/ 32) >= collection_set->get_young_bytes_to_be_promoted() * ShenandoahEvacWaste,\n+         \"Advance promotion (\" SIZE_FORMAT \") should be at least young_bytes_to_be_promoted (\" SIZE_FORMAT\n+         \")* ShenandoahEvacWaste, totalling: \" SIZE_FORMAT \", within round-off errors of up to 3.125%%\",\n+         consumed_by_advance_promotion, collection_set->get_young_bytes_to_be_promoted(),\n+         (size_t) (collection_set->get_young_bytes_to_be_promoted() * ShenandoahEvacWaste));\n+\n+  assert(consumed_by_advance_promotion <= (collection_set->get_young_bytes_to_be_promoted() * ShenandoahEvacWaste * 33) \/ 32,\n+         \"Round-off errors should be less than 3.125%%, consumed by advance: \" SIZE_FORMAT \", promoted: \" SIZE_FORMAT,\n+         consumed_by_advance_promotion, (size_t) (collection_set->get_young_bytes_to_be_promoted() * ShenandoahEvacWaste));\n+\n+  collection_set->abandon_preselected();\n+\n+  if (old_evacuated_committed > old_evacuation_reserve) {\n+    \/\/ This should only happen due to round-off errors when enforcing ShenandoahEvacWaste\n+    assert(old_evacuated_committed <= (33 * old_evacuation_reserve) \/ 32,\n+           \"Round-off errors should be less than 3.125%%, committed: \" SIZE_FORMAT \", reserved: \" SIZE_FORMAT,\n+           old_evacuated_committed, old_evacuation_reserve);\n+    old_evacuated_committed = old_evacuation_reserve;\n+  } else if (old_evacuated_committed < old_evacuation_reserve) {\n+    \/\/ This may happen if the old-gen collection consumes less than full budget.\n+    old_evacuation_reserve = old_evacuated_committed;\n+    heap->set_old_evac_reserve(old_evacuation_reserve);\n+  }\n@@ -467,4 +458,5 @@\n-    \/\/ Recompute old_regions_loaned_for_young_evac because young-gen collection set may not need all the memory\n-    \/\/ originally reserved.\n-    size_t young_promoted = collection_set->get_young_bytes_to_be_promoted();\n-    size_t young_promoted_reserve_used = (size_t) (ShenandoahEvacWaste * young_promoted);\n+  \/\/ Recompute old_regions_loaned_for_young_evac because young-gen collection set may not need all the memory\n+  \/\/ originally reserved.\n+  size_t young_promoted = collection_set->get_young_bytes_to_be_promoted();\n+  size_t young_evacuated = collection_set->get_young_bytes_reserved_for_evacuation();\n+  size_t young_evacuated_reserve_used = (size_t) (ShenandoahEvacWaste * young_evacuated);\n@@ -472,2 +464,1 @@\n-    size_t young_evacuated = collection_set->get_young_bytes_reserved_for_evacuation();\n-    size_t young_evacuated_reserve_used = (size_t) (ShenandoahEvacWaste * young_evacuated);\n+  \/\/ We'll invoke heap->set_young_evac_reserve() further below, after we make additional adjustments to its value\n@@ -475,1 +466,3 @@\n-    \/\/ We'll invoke heap->set_young_evac_reserve() further below, after we make additional adjustments to its value\n+  \/\/ Adjust old_regions_loaned_for_young_evac to feed into calculations of promoted_reserve\n+  if (young_evacuated_reserve_used > young_available) {\n+    size_t short_fall = young_evacuated_reserve_used - young_available;\n@@ -477,3 +470,2 @@\n-    \/\/ Adjust old_regions_loaned_for_young_evac to feed into calculations of promoted_reserve\n-    if (young_evacuated_reserve_used > young_available) {\n-      size_t short_fall = young_evacuated_reserve_used - young_available;\n+    \/\/ region_size_bytes is a power of 2.  loan an integral number of regions.\n+    size_t revised_loan_for_young_evacuation = (short_fall + region_size_bytes - 1) \/ region_size_bytes;\n@@ -481,2 +473,4 @@\n-      \/\/ region_size_bytes is a power of 2.  loan an integral number of regions.\n-      size_t revised_loan_for_young_evacuation = (short_fall + region_size_bytes - 1) \/ region_size_bytes;\n+    \/\/ available_loan_remnant represents memory loaned from old-gen but not required for young evacuation.\n+    \/\/ This is the excess loaned memory that results from rounding the required loan up to an integral number\n+    \/\/ of heap regions.  This will be dedicated to alloc_supplement below.\n+    available_loan_remnant = (revised_loan_for_young_evacuation * region_size_bytes) - short_fall;\n@@ -484,4 +478,8 @@\n-      \/\/ available_loan_remnant represents memory loaned from old-gen but not required for young evacuation.\n-      \/\/ This is the excess loaned memory that results from rounding the required loan up to an integral number\n-      \/\/ of heap regions.  This will be dedicated to alloc_supplement below.\n-      available_loan_remnant = (revised_loan_for_young_evacuation * region_size_bytes) - short_fall;\n+    \/\/ We previously loaned more than was required by young-gen evacuation.  So claw some of this memory back.\n+    old_regions_loaned_for_young_evac = revised_loan_for_young_evacuation;\n+    loaned_regions = old_regions_loaned_for_young_evac;\n+  } else {\n+    \/\/ Undo the prevous loan, if any.\n+    old_regions_loaned_for_young_evac = 0;\n+    loaned_regions = 0;\n+  }\n@@ -489,8 +487,1 @@\n-      \/\/ We previously loaned more than was required by young-gen evacuation.  So claw some of this memory back.\n-      old_regions_loaned_for_young_evac = revised_loan_for_young_evacuation;\n-      loaned_regions = old_regions_loaned_for_young_evac;\n-    } else {\n-      \/\/ Undo the prevous loan, if any.\n-      old_regions_loaned_for_young_evac = 0;\n-      loaned_regions = 0;\n-    }\n+  size_t old_bytes_loaned_for_young_evac = old_regions_loaned_for_young_evac * region_size_bytes - available_loan_remnant;\n@@ -498,1 +489,2 @@\n-    size_t old_bytes_loaned_for_young_evac = old_regions_loaned_for_young_evac * region_size_bytes - available_loan_remnant;\n+  \/\/ Recompute regions_available_to_loan based on possible changes to old_regions_loaned_for_young_evac and\n+  \/\/ old_evacuation_reserve.\n@@ -500,2 +492,3 @@\n-    \/\/ Recompute regions_available_to_loan based on possible changes to old_regions_loaned_for_young_evac and\n-    \/\/ old_evacuation_reserve.\n+  \/\/ Any decrease in old_regions_loaned_for_young_evac are immediately available to be loaned\n+  \/\/ However, a change to old_evacuation_reserve() is not necessarily available to loan, because this memory may\n+  \/\/ reside within many fragments scattered throughout old-gen.\n@@ -503,3 +496,2 @@\n-    \/\/ Any decrease in old_regions_loaned_for_young_evac are immediately available to be loaned\n-    \/\/ However, a change to old_evacuation_reserve() is not necessarily available to loan, because this memory may\n-    \/\/ reside within many fragments scattered throughout old-gen.\n+  regions_available_to_loan = old_generation->free_unaffiliated_regions();\n+  size_t working_old_available = old_generation->available();\n@@ -507,2 +499,2 @@\n-    regions_available_to_loan = old_generation->free_unaffiliated_regions();\n-    size_t working_old_available = old_generation->available();\n+  assert(regions_available_to_loan * region_size_bytes <= working_old_available,\n+         \"Regions available to loan  must be less than available memory\");\n@@ -510,2 +502,3 @@\n-    assert(regions_available_to_loan * region_size_bytes <= working_old_available,\n-           \"Regions available to loan  must be less than available memory\");\n+  \/\/ fragmented_old_total is the amount of memory in old-gen beyond regions_available_to_loan that is otherwise not\n+  \/\/ yet dedicated to a particular budget.  This memory can be used for promotion_reserve.\n+  size_t fragmented_old_total = working_old_available - regions_available_to_loan * region_size_bytes;\n@@ -513,3 +506,3 @@\n-    \/\/ fragmented_old_total is the amount of memory in old-gen beyond regions_available_to_loan that is otherwise not\n-    \/\/ yet dedicated to a particular budget.  This memory can be used for promotion_reserve.\n-    size_t fragmented_old_total = working_old_available - regions_available_to_loan * region_size_bytes;\n+  \/\/ fragmented_old_usage is the memory that is dedicated to holding evacuated old-gen objects, which does not need\n+  \/\/ to be an integral number of regions.\n+  size_t fragmented_old_usage = old_evacuated_committed + consumed_by_advance_promotion;\n@@ -517,3 +510,0 @@\n-    \/\/ fragmented_old_usage is the memory that is dedicated to holding evacuated old-gen objects, which does not need\n-    \/\/ to be an integral number of regions.\n-    size_t fragmented_old_usage = old_evacuated_committed + consumed_by_advance_promotion;\n@@ -522,0 +512,9 @@\n+  if (fragmented_old_total >= fragmented_old_usage) {\n+    \/\/ Seems this will be rare.  In this case, all of the memory required for old-gen evacuations and promotions can be\n+    \/\/ taken from the existing fragments within old-gen.  Reduce this fragmented total by this amount.\n+    fragmented_old_total -= fragmented_old_usage;\n+    \/\/ And reduce regions_available_to_loan by the regions dedicated to young_evac.\n+    regions_available_to_loan -= old_regions_loaned_for_young_evac;\n+  } else {\n+    \/\/ In this case, we need to dedicate some of the regions_available_to_loan to hold the results of old-gen evacuations\n+    \/\/ and promotions.\n@@ -523,9 +522,3 @@\n-    if (fragmented_old_total >= fragmented_old_usage) {\n-      \/\/ Seems this will be rare.  In this case, all of the memory required for old-gen evacuations and promotions can be\n-      \/\/ taken from the existing fragments within old-gen.  Reduce this fragmented total by this amount.\n-      fragmented_old_total -= fragmented_old_usage;\n-      \/\/ And reduce regions_available_to_loan by the regions dedicated to young_evac.\n-      regions_available_to_loan -= old_regions_loaned_for_young_evac;\n-    } else {\n-      \/\/ In this case, we need to dedicate some of the regions_available_to_loan to hold the results of old-gen evacuations\n-      \/\/ and promotions.\n+    size_t unaffiliated_memory_required_for_old = fragmented_old_usage - fragmented_old_total;\n+    size_t unaffiliated_regions_used_by_old = (unaffiliated_memory_required_for_old + region_size_bytes - 1) \/ region_size_bytes;\n+    regions_available_to_loan -= (unaffiliated_regions_used_by_old + old_regions_loaned_for_young_evac);\n@@ -533,3 +526,5 @@\n-      size_t unaffiliated_memory_required_for_old = fragmented_old_usage - fragmented_old_total;\n-      size_t unaffiliated_regions_used_by_old = (unaffiliated_memory_required_for_old + region_size_bytes - 1) \/ region_size_bytes;\n-      regions_available_to_loan -= (unaffiliated_regions_used_by_old + old_regions_loaned_for_young_evac);\n+    size_t memory_for_promotions_and_old_evac = fragmented_old_total + unaffiliated_regions_used_by_old;\n+    size_t memory_required_for_promotions_and_old_evac = fragmented_old_usage;\n+    size_t excess_fragmented = memory_for_promotions_and_old_evac - memory_required_for_promotions_and_old_evac;\n+    fragmented_old_total = excess_fragmented;\n+  }\n@@ -537,4 +532,54 @@\n-      size_t memory_for_promotions_and_old_evac = fragmented_old_total + unaffiliated_regions_used_by_old;\n-      size_t memory_required_for_promotions_and_old_evac = fragmented_old_usage;\n-      size_t excess_fragmented = memory_for_promotions_and_old_evac - memory_required_for_promotions_and_old_evac;\n-      fragmented_old_total = excess_fragmented;\n+  \/\/ Subtract from working_old_available old_evacuated_committed and consumed_by_advance_promotion\n+  working_old_available -= fragmented_old_usage;\n+  \/\/ And also subtract out the regions loaned for young evacuation\n+  working_old_available -= old_regions_loaned_for_young_evac * region_size_bytes;\n+\n+  \/\/ Assure that old_evacuated_committed + old_bytes_loaned_for_young_evac >= the minimum evacuation reserve\n+  \/\/ in order to prevent promotion reserve from violating minimum evacuation reserve.\n+  size_t old_regions_reserved_for_alloc_supplement = 0;\n+  size_t old_bytes_reserved_for_alloc_supplement = 0;\n+  size_t reserved_bytes_for_future_old_evac = 0;\n+\n+  old_bytes_reserved_for_alloc_supplement = available_loan_remnant;\n+  available_loan_remnant = 0;\n+\n+  \/\/ Memory that has been loaned for young evacuations and old-gen regions in the current mixed-evacuation collection\n+  \/\/ set will be available to hold future old-gen evacuations.  If this memory is less than the desired amount of memory\n+  \/\/ set aside for old-gen compaction reserve, try to set aside additional memory so that it will be available during\n+  \/\/ the next mixed evacuation cycle.  Note that memory loaned to young-gen for allocation supplement is excluded from\n+  \/\/ the old-gen promotion reserve.\n+  size_t future_evac_reserve_regions = old_regions_loaned_for_young_evac + collection_set->get_old_region_count();\n+  size_t collected_regions = collection_set->get_young_region_count();\n+\n+  if (future_evac_reserve_regions < ShenandoahOldCompactionReserve) {\n+    \/\/ Require that we loan more memory for holding young evacuations to assure that we have adequate reserves to receive\n+    \/\/ old-gen evacuations during subsequent collections.  Loaning this memory for an allocation supplement does not\n+    \/\/ satisfy our needs because newly allocated objects are not necessarily counter-balanced by reclaimed collection\n+    \/\/ set regions.\n+\n+    \/\/ Put this memory into reserve by identifying it as old_regions_loaned_for_young_evac\n+    size_t additional_regions_to_loan = ShenandoahOldCompactionReserve - future_evac_reserve_regions;\n+\n+    \/\/ We can loan additional regions to be repaid from the anticipated recycling of young collection set regions\n+    \/\/ provided that these regions are currently available within old-gen memory.\n+    size_t collected_regions_to_loan;\n+    if (collected_regions >= additional_regions_to_loan) {\n+      collected_regions_to_loan = additional_regions_to_loan;\n+      additional_regions_to_loan = 0;\n+    } else if (collected_regions > 0) {\n+      collected_regions_to_loan = collected_regions;\n+      additional_regions_to_loan -= collected_regions_to_loan;\n+    } else {\n+      collected_regions_to_loan = 0;\n+    }\n+\n+    if (collected_regions_to_loan > 0) {\n+      \/\/ We're evacuating at least this many regions, it's ok to use these regions for allocation supplement since\n+      \/\/ we'll be able to repay the loan at end of this GC pass, assuming the regions are available.\n+      if (collected_regions_to_loan > regions_available_to_loan) {\n+        collected_regions_to_loan = regions_available_to_loan;\n+      }\n+      old_bytes_reserved_for_alloc_supplement += collected_regions_to_loan * region_size_bytes;\n+      regions_available_to_loan -= collected_regions_to_loan;\n+      loaned_regions += collected_regions_to_loan;\n+      working_old_available -= collected_regions_to_loan * region_size_bytes;\n@@ -543,40 +588,15 @@\n-    \/\/ Subtract from working_old_available old_evacuated_committed and consumed_by_advance_promotion\n-    working_old_available -= fragmented_old_usage;\n-    \/\/ And also subtract out the regions loaned for young evacuation\n-    working_old_available -= old_regions_loaned_for_young_evac * region_size_bytes;\n-\n-    \/\/ Assure that old_evacuated_committed + old_bytes_loaned_for_young_evac >= the minimum evacuation reserve\n-    \/\/ in order to prevent promotion reserve from violating minimum evacuation reserve.\n-    size_t old_regions_reserved_for_alloc_supplement = 0;\n-    size_t old_bytes_reserved_for_alloc_supplement = 0;\n-    size_t reserved_bytes_for_future_old_evac = 0;\n-\n-    old_bytes_reserved_for_alloc_supplement = available_loan_remnant;\n-    available_loan_remnant = 0;\n-\n-    \/\/ Memory that has been loaned for young evacuations and old-gen regions in the current mixed-evacuation collection\n-    \/\/ set will be available to hold future old-gen evacuations.  If this memory is less than the desired amount of memory\n-    \/\/ set aside for old-gen compaction reserve, try to set aside additional memory so that it will be available during\n-    \/\/ the next mixed evacuation cycle.  Note that memory loaned to young-gen for allocation supplement is excluded from\n-    \/\/ the old-gen promotion reserve.\n-    size_t future_evac_reserve_regions = old_regions_loaned_for_young_evac + collection_set->get_old_region_count();\n-    size_t collected_regions = collection_set->get_young_region_count();\n-\n-    if (future_evac_reserve_regions < ShenandoahOldCompactionReserve) {\n-      \/\/ Require that we loan more memory for holding young evacuations to assure that we have adequate reserves to receive\n-      \/\/ old-gen evacuations during subsequent collections.  Loaning this memory for an allocation supplement does not\n-      \/\/ satisfy our needs because newly allocated objects are not necessarily counter-balanced by reclaimed collection\n-      \/\/ set regions.\n-\n-      \/\/ Put this memory into reserve by identifying it as old_regions_loaned_for_young_evac\n-      size_t additional_regions_to_loan = ShenandoahOldCompactionReserve - future_evac_reserve_regions;\n-\n-      \/\/ We can loan additional regions to be repaid from the anticipated recycling of young collection set regions\n-      \/\/ provided that these regions are currently available within old-gen memory.\n-      size_t collected_regions_to_loan;\n-      if (collected_regions >= additional_regions_to_loan) {\n-        collected_regions_to_loan = additional_regions_to_loan;\n-        additional_regions_to_loan = 0;\n-      } else if (collected_regions > 0) {\n-        collected_regions_to_loan = collected_regions;\n-        additional_regions_to_loan -= collected_regions_to_loan;\n+    \/\/ If there's still memory that we want to exclude from the current promotion reserve, but we are unable to loan\n+    \/\/ this memory because fully empty old-gen regions are not available, decrement the working_old_available to make\n+    \/\/ sure that this memory is not used to hold the results of old-gen evacuation.\n+    if (additional_regions_to_loan > regions_available_to_loan) {\n+      size_t unloaned_regions = additional_regions_to_loan - regions_available_to_loan;\n+      size_t unloaned_bytes = unloaned_regions * region_size_bytes;\n+\n+      if (working_old_available < unloaned_bytes) {\n+        \/\/ We're in dire straits.  We won't be able to reserve all the memory that we want to make available for the\n+        \/\/ next old-gen evacuation.  We'll reserve as much of it as possible.  Setting working_old_available to zero\n+        \/\/ means there will be no promotion except for the advance promotion.  Note that if some advance promotion fails,\n+        \/\/ the object will be evacuated to young-gen so we should still end up reclaiming the entire advance promotion\n+        \/\/ collection set.\n+        reserved_bytes_for_future_old_evac = working_old_available;\n+        working_old_available = 0;\n@@ -584,1 +604,2 @@\n-        collected_regions_to_loan = 0;\n+        reserved_bytes_for_future_old_evac = unloaned_bytes;\n+        working_old_available -= unloaned_bytes;\n@@ -586,0 +607,2 @@\n+      size_t regions_reserved_for_future_old_evac =\n+        (reserved_bytes_for_future_old_evac + region_size_bytes - 1) \/ region_size_bytes;\n@@ -587,10 +610,4 @@\n-      if (collected_regions_to_loan > 0) {\n-        \/\/ We're evacuating at least this many regions, it's ok to use these regions for allocation supplement since\n-        \/\/ we'll be able to repay the loan at end of this GC pass, assuming the regions are available.\n-        if (collected_regions_to_loan > regions_available_to_loan) {\n-          collected_regions_to_loan = regions_available_to_loan;\n-        }\n-        old_bytes_reserved_for_alloc_supplement += collected_regions_to_loan * region_size_bytes;\n-        regions_available_to_loan -= collected_regions_to_loan;\n-        loaned_regions += collected_regions_to_loan;\n-        working_old_available -= collected_regions_to_loan * region_size_bytes;\n+      if (regions_reserved_for_future_old_evac < regions_available_to_loan) {\n+        regions_available_to_loan -= regions_reserved_for_future_old_evac;\n+      } else {\n+        regions_available_to_loan = 0;\n@@ -599,35 +616,5 @@\n-      \/\/ If there's still memory that we want to exclude from the current promotion reserve, but we are unable to loan\n-      \/\/ this memory because fully empty old-gen regions are not available, decrement the working_old_available to make\n-      \/\/ sure that this memory is not used to hold the results of old-gen evacuation.\n-      if (additional_regions_to_loan > regions_available_to_loan) {\n-        size_t unloaned_regions = additional_regions_to_loan - regions_available_to_loan;\n-        size_t unloaned_bytes = unloaned_regions * region_size_bytes;\n-\n-        if (working_old_available < unloaned_bytes) {\n-          \/\/ We're in dire straits.  We won't be able to reserve all the memory that we want to make available for the\n-          \/\/ next old-gen evacuation.  We'll reserve as much of it as possible.  Setting working_old_available to zero\n-          \/\/ means there will be no promotion except for the advance promotion.  Note that if some advance promotion fails,\n-          \/\/ the object will be evacuated to young-gen so we should still end up reclaiming the entire advance promotion\n-          \/\/ collection set.\n-          reserved_bytes_for_future_old_evac = working_old_available;\n-          working_old_available = 0;\n-        } else {\n-          reserved_bytes_for_future_old_evac = unloaned_bytes;\n-          working_old_available -= unloaned_bytes;\n-        }\n-        size_t regions_reserved_for_future_old_evac =\n-          (reserved_bytes_for_future_old_evac + region_size_bytes - 1) \/ region_size_bytes;\n-\n-        if (regions_reserved_for_future_old_evac < regions_available_to_loan) {\n-          regions_available_to_loan -= regions_reserved_for_future_old_evac;\n-        } else {\n-          regions_available_to_loan = 0;\n-        }\n-\n-        \/\/ Since we're in dire straits, zero out fragmented_old_total so this won't be used for promotion;\n-        if (working_old_available > fragmented_old_total) {\n-          working_old_available -= fragmented_old_total;\n-        } else {\n-          working_old_available = 0;\n-        }\n-        fragmented_old_total = 0;\n+      \/\/ Since we're in dire straits, zero out fragmented_old_total so this won't be used for promotion;\n+      if (working_old_available > fragmented_old_total) {\n+        working_old_available -= fragmented_old_total;\n+      } else {\n+        working_old_available = 0;\n@@ -635,0 +622,1 @@\n+      fragmented_old_total = 0;\n@@ -636,0 +624,1 @@\n+  }\n@@ -637,47 +626,47 @@\n-    \/\/ Establish young_evac_reserve so that this young-gen memory is not used for new allocations, allowing the memory\n-    \/\/ to be returned to old-gen as soon as the current collection set regions are reclaimed.\n-    heap->set_young_evac_reserve(young_evacuated_reserve_used);\n-\n-    \/\/ Limit promoted_reserve so that we can set aside memory to be loaned from old-gen to young-gen.  This\n-    \/\/ value is not \"critical\".  If we underestimate, certain promotions will simply be deferred.  If we put\n-    \/\/ \"all the rest\" of old-gen memory into the promotion reserve, we'll have nothing left to loan to young-gen\n-    \/\/ during the evac and update phases of GC.  So we \"limit\" the sizes of the promotion budget to be the smaller of:\n-    \/\/\n-    \/\/  1. old_available\n-    \/\/     (old_available is old_gen->available() -\n-    \/\/      (old_evacuated_committed + consumed_by_advance_promotion + loaned_for_young_evac + reserved_for_alloc_supplement))\n-    \/\/  2. young bytes reserved for evacuation (we can't promote more than young is evacuating)\n-    size_t promotion_reserve = working_old_available;\n-\n-    \/\/ We experimented with constraining promoted_reserve to be no larger than 4 times the size of previously_promoted,\n-    \/\/ but this constraint was too limiting, resulting in failure of legitimate promotions.  This was tried before we\n-    \/\/ had special handling in place for advance promotion.  We should retry now that advance promotion is handled\n-    \/\/ specially.\n-\n-    \/\/ We had also experimented with constraining promoted_reserve to be no more than young_evacuation_committed\n-    \/\/ divided by promotion_divisor, where:\n-    \/\/  size_t promotion_divisor = (0x02 << InitialTenuringThreshold) - 1;\n-    \/\/ This also was found to be too limiting, resulting in failure of legitimate promotions.\n-    \/\/\n-    \/\/ Both experiments were conducted in the presence of other bugs which could have been the root cause for\n-    \/\/ the failures identified above as being \"too limiting\".  TODO: conduct new experiments with the more limiting\n-    \/\/ values of young_evacuation_reserved_used.\n-\n-    \/\/ young_evacuation_reserve_used already excludes bytes known to be promoted, which equals consumed_by_advance_promotion\n-    if (young_evacuated_reserve_used < promotion_reserve) {\n-      \/\/ Shrink promotion_reserve if it is larger than the memory to be consumed by evacuating all young objects in\n-      \/\/ collection set, including anticipated waste.  There's no benefit in using a larger promotion_reserve.\n-      \/\/ young_evacuation_reserve_used does not include live memory within tenure-aged regions.\n-      promotion_reserve = young_evacuated_reserve_used;\n-    }\n-    assert(working_old_available >= promotion_reserve, \"Cannot reserve for promotion more than is available\");\n-    working_old_available -= promotion_reserve;\n-    \/\/ Having reserved this memory for promotion, the regions are no longer available to be loaned.\n-    size_t regions_consumed_by_promotion_reserve = (promotion_reserve + region_size_bytes - 1) \/ region_size_bytes;\n-    if (regions_consumed_by_promotion_reserve > regions_available_to_loan) {\n-      \/\/ This can happen if the promotion reserve makes use of memory that is fragmented between many partially available\n-      \/\/ old-gen regions.\n-      regions_available_to_loan = 0;\n-    } else {\n-      regions_available_to_loan -= regions_consumed_by_promotion_reserve;\n-    }\n+  \/\/ Establish young_evac_reserve so that this young-gen memory is not used for new allocations, allowing the memory\n+  \/\/ to be returned to old-gen as soon as the current collection set regions are reclaimed.\n+  heap->set_young_evac_reserve(young_evacuated_reserve_used);\n+\n+  \/\/ Limit promoted_reserve so that we can set aside memory to be loaned from old-gen to young-gen.  This\n+  \/\/ value is not \"critical\".  If we underestimate, certain promotions will simply be deferred.  If we put\n+  \/\/ \"all the rest\" of old-gen memory into the promotion reserve, we'll have nothing left to loan to young-gen\n+  \/\/ during the evac and update phases of GC.  So we \"limit\" the sizes of the promotion budget to be the smaller of:\n+  \/\/\n+  \/\/  1. old_available\n+  \/\/     (old_available is old_gen->available() -\n+  \/\/      (old_evacuated_committed + consumed_by_advance_promotion + loaned_for_young_evac + reserved_for_alloc_supplement))\n+  \/\/  2. young bytes reserved for evacuation (we can't promote more than young is evacuating)\n+  size_t promotion_reserve = working_old_available;\n+\n+  \/\/ We experimented with constraining promoted_reserve to be no larger than 4 times the size of previously_promoted,\n+  \/\/ but this constraint was too limiting, resulting in failure of legitimate promotions.  This was tried before we\n+  \/\/ had special handling in place for advance promotion.  We should retry now that advance promotion is handled\n+  \/\/ specially.\n+\n+  \/\/ We had also experimented with constraining promoted_reserve to be no more than young_evacuation_committed\n+  \/\/ divided by promotion_divisor, where:\n+  \/\/  size_t promotion_divisor = (0x02 << InitialTenuringThreshold) - 1;\n+  \/\/ This also was found to be too limiting, resulting in failure of legitimate promotions.\n+  \/\/\n+  \/\/ Both experiments were conducted in the presence of other bugs which could have been the root cause for\n+  \/\/ the failures identified above as being \"too limiting\".  TODO: conduct new experiments with the more limiting\n+  \/\/ values of young_evacuation_reserved_used.\n+\n+  \/\/ young_evacuation_reserve_used already excludes bytes known to be promoted, which equals consumed_by_advance_promotion\n+  if (young_evacuated_reserve_used < promotion_reserve) {\n+    \/\/ Shrink promotion_reserve if it is larger than the memory to be consumed by evacuating all young objects in\n+    \/\/ collection set, including anticipated waste.  There's no benefit in using a larger promotion_reserve.\n+    \/\/ young_evacuation_reserve_used does not include live memory within tenure-aged regions.\n+    promotion_reserve = young_evacuated_reserve_used;\n+  }\n+  assert(working_old_available >= promotion_reserve, \"Cannot reserve for promotion more than is available\");\n+  working_old_available -= promotion_reserve;\n+  \/\/ Having reserved this memory for promotion, the regions are no longer available to be loaned.\n+  size_t regions_consumed_by_promotion_reserve = (promotion_reserve + region_size_bytes - 1) \/ region_size_bytes;\n+  if (regions_consumed_by_promotion_reserve > regions_available_to_loan) {\n+    \/\/ This can happen if the promotion reserve makes use of memory that is fragmented between many partially available\n+    \/\/ old-gen regions.\n+    regions_available_to_loan = 0;\n+  } else {\n+    regions_available_to_loan -= regions_consumed_by_promotion_reserve;\n+  }\n@@ -685,5 +674,5 @@\n-    log_debug(gc)(\"old_gen->available(): \" SIZE_FORMAT \" divided between promotion reserve: \" SIZE_FORMAT\n-                  \", old evacuation reserve: \" SIZE_FORMAT \", advance promotion reserve supplement: \" SIZE_FORMAT\n-                  \", old loaned for young evacuation: \" SIZE_FORMAT \", old reserved for alloc supplement: \" SIZE_FORMAT,\n-                  old_generation->available(), promotion_reserve, old_evacuated_committed, consumed_by_advance_promotion,\n-                  old_regions_loaned_for_young_evac * region_size_bytes, old_bytes_reserved_for_alloc_supplement);\n+  log_debug(gc)(\"old_gen->available(): \" SIZE_FORMAT \" divided between promotion reserve: \" SIZE_FORMAT\n+                \", old evacuation reserve: \" SIZE_FORMAT \", advance promotion reserve supplement: \" SIZE_FORMAT\n+                \", old loaned for young evacuation: \" SIZE_FORMAT \", old reserved for alloc supplement: \" SIZE_FORMAT,\n+                old_generation->available(), promotion_reserve, old_evacuated_committed, consumed_by_advance_promotion,\n+                old_regions_loaned_for_young_evac * region_size_bytes, old_bytes_reserved_for_alloc_supplement);\n@@ -691,2 +680,2 @@\n-    promotion_reserve += consumed_by_advance_promotion;\n-    heap->set_promoted_reserve(promotion_reserve);\n+  promotion_reserve += consumed_by_advance_promotion;\n+  heap->set_promoted_reserve(promotion_reserve);\n@@ -694,5 +683,5 @@\n-    heap->reset_promoted_expended();\n-    if (collection_set->get_old_bytes_reserved_for_evacuation() == 0) {\n-      \/\/ Setting old evacuation reserve to zero denotes that there is no old-gen evacuation in this pass.\n-      heap->set_old_evac_reserve(0);\n-    }\n+  heap->reset_promoted_expended();\n+  if (collection_set->get_old_bytes_reserved_for_evacuation() == 0) {\n+    \/\/ Setting old evacuation reserve to zero denotes that there is no old-gen evacuation in this pass.\n+    heap->set_old_evac_reserve(0);\n+  }\n@@ -700,30 +689,26 @@\n-    size_t old_gen_usage_base = old_generation->used() - collection_set->get_old_garbage();\n-    heap->capture_old_usage(old_gen_usage_base);\n-\n-    \/\/ Compute additional evacuation supplement, which is extra memory borrowed from old-gen that can be allocated\n-    \/\/ by mutators while GC is working on evacuation and update-refs.  This memory can be temporarily borrowed\n-    \/\/ from old-gen allotment, then repaid at the end of update-refs from the recycled collection set.  After\n-    \/\/ we have computed the collection set based on the parameters established above, we can make additional\n-    \/\/ loans based on our knowledge of the collection set to determine how much allocation we can allow\n-    \/\/ during the evacuation and update-refs phases of execution.  The total available supplement is the result\n-    \/\/ of adding old_bytes_reserved_for_alloc_supplement to the smaller of:\n-    \/\/\n-    \/\/   1. regions_available_to_loan * region_size_bytes\n-    \/\/   2. The replenishment budget (number of regions in collection set - the number of regions already\n-    \/\/         under lien for the young_evacuation_reserve)\n-    \/\/\n-\n-    \/\/ Regardless of how many regions may be available to be loaned, we can loan no more regions than\n-    \/\/ the total number of young regions to be evacuated.  Call this the regions_for_runway.\n-\n-    if (regions_available_to_loan > 0 && (collected_regions > loaned_regions)) {\n-      assert(regions_available_to_loan * region_size_bytes <= working_old_available,\n-             \"regions_available_to_loan should not exceed working_old_available\");\n-\n-      size_t additional_regions_to_loan = collected_regions - loaned_regions;\n-      if (additional_regions_to_loan > regions_available_to_loan) {\n-        additional_regions_to_loan = regions_available_to_loan;\n-      }\n-      loaned_regions += additional_regions_to_loan;\n-      old_bytes_reserved_for_alloc_supplement += additional_regions_to_loan * region_size_bytes;\n-      working_old_available -= additional_regions_to_loan * region_size_bytes;\n+  size_t old_gen_usage_base = old_generation->used() - collection_set->get_old_garbage();\n+  heap->capture_old_usage(old_gen_usage_base);\n+\n+  \/\/ Compute additional evacuation supplement, which is extra memory borrowed from old-gen that can be allocated\n+  \/\/ by mutators while GC is working on evacuation and update-refs.  This memory can be temporarily borrowed\n+  \/\/ from old-gen allotment, then repaid at the end of update-refs from the recycled collection set.  After\n+  \/\/ we have computed the collection set based on the parameters established above, we can make additional\n+  \/\/ loans based on our knowledge of the collection set to determine how much allocation we can allow\n+  \/\/ during the evacuation and update-refs phases of execution.  The total available supplement is the result\n+  \/\/ of adding old_bytes_reserved_for_alloc_supplement to the smaller of:\n+  \/\/\n+  \/\/   1. regions_available_to_loan * region_size_bytes\n+  \/\/   2. The replenishment budget (number of regions in collection set - the number of regions already\n+  \/\/         under lien for the young_evacuation_reserve)\n+  \/\/\n+\n+  \/\/ Regardless of how many regions may be available to be loaned, we can loan no more regions than\n+  \/\/ the total number of young regions to be evacuated.  Call this the regions_for_runway.\n+\n+  if (regions_available_to_loan > 0 && (collected_regions > loaned_regions)) {\n+    assert(regions_available_to_loan * region_size_bytes <= working_old_available,\n+           \"regions_available_to_loan should not exceed working_old_available\");\n+\n+    size_t additional_regions_to_loan = collected_regions - loaned_regions;\n+    if (additional_regions_to_loan > regions_available_to_loan) {\n+      additional_regions_to_loan = regions_available_to_loan;\n@@ -731,38 +716,3 @@\n-    size_t allocation_supplement = old_bytes_reserved_for_alloc_supplement;\n-    heap->set_alloc_supplement_reserve(allocation_supplement);\n-\n-    \/\/ TODO: young_available, which feeds into alloc_budget_evac_and_update is lacking memory available within\n-    \/\/ existing young-gen regions that were not selected for the collection set.  Add this in and adjust the\n-    \/\/ log message (where it says \"empty-region allocation budget\").\n-\n-    log_debug(gc)(\"Memory reserved for young evacuation: \" SIZE_FORMAT \"%s for evacuating \" SIZE_FORMAT\n-                  \"%s out of young available: \" SIZE_FORMAT \"%s\",\n-                  byte_size_in_proper_unit(young_evacuated_reserve_used),\n-                  proper_unit_for_byte_size(young_evacuated_reserve_used),\n-                  byte_size_in_proper_unit(young_evacuated), proper_unit_for_byte_size(young_evacuated),\n-                  byte_size_in_proper_unit(young_available), proper_unit_for_byte_size(young_available));\n-\n-    log_debug(gc)(\"Memory reserved for old evacuation: \" SIZE_FORMAT \"%s for evacuating \" SIZE_FORMAT\n-                  \"%s out of old available: \" SIZE_FORMAT \"%s\",\n-                  byte_size_in_proper_unit(old_evacuated), proper_unit_for_byte_size(old_evacuated),\n-                  byte_size_in_proper_unit(old_evacuated), proper_unit_for_byte_size(old_evacuated),\n-                  byte_size_in_proper_unit(old_available), proper_unit_for_byte_size(old_available));\n-\n-    size_t regular_promotion = promotion_reserve - consumed_by_advance_promotion;\n-    size_t excess =\n-      old_available - (old_evacuation_reserve + promotion_reserve + old_bytes_loaned_for_young_evac + allocation_supplement);\n-    log_info(gc, ergo)(\"Old available: \" SIZE_FORMAT \"%s is partitioned into old evacuation budget: \" SIZE_FORMAT\n-                       \"%s, aged region promotion budget: \" SIZE_FORMAT\n-                       \"%s, regular region promotion budget: \" SIZE_FORMAT\n-                       \"%s, loaned for young evacuation: \" SIZE_FORMAT\n-                       \"%s, loaned for young allocations: \" SIZE_FORMAT\n-                       \"%s, excess: \" SIZE_FORMAT \"%s\",\n-                       byte_size_in_proper_unit(old_available), proper_unit_for_byte_size(old_available),\n-                       byte_size_in_proper_unit(old_evacuation_reserve), proper_unit_for_byte_size(old_evacuation_reserve),\n-                       byte_size_in_proper_unit(consumed_by_advance_promotion),\n-                       proper_unit_for_byte_size(consumed_by_advance_promotion),\n-                       byte_size_in_proper_unit(regular_promotion), proper_unit_for_byte_size(regular_promotion),\n-                       byte_size_in_proper_unit(old_bytes_loaned_for_young_evac),\n-                       proper_unit_for_byte_size(old_bytes_loaned_for_young_evac),\n-                       byte_size_in_proper_unit(allocation_supplement), proper_unit_for_byte_size(allocation_supplement),\n-                       byte_size_in_proper_unit(excess), proper_unit_for_byte_size(excess));\n+    loaned_regions += additional_regions_to_loan;\n+    old_bytes_reserved_for_alloc_supplement += additional_regions_to_loan * region_size_bytes;\n+    working_old_available -= additional_regions_to_loan * region_size_bytes;\n@@ -770,1 +720,38 @@\n-  \/\/ else, not generational: no evacuation budget adjustments required\n+  size_t allocation_supplement = old_bytes_reserved_for_alloc_supplement;\n+  heap->set_alloc_supplement_reserve(allocation_supplement);\n+\n+  \/\/ TODO: young_available, which feeds into alloc_budget_evac_and_update is lacking memory available within\n+  \/\/ existing young-gen regions that were not selected for the collection set.  Add this in and adjust the\n+  \/\/ log message (where it says \"empty-region allocation budget\").\n+\n+  log_debug(gc)(\"Memory reserved for young evacuation: \" SIZE_FORMAT \"%s for evacuating \" SIZE_FORMAT\n+                \"%s out of young available: \" SIZE_FORMAT \"%s\",\n+                byte_size_in_proper_unit(young_evacuated_reserve_used),\n+                proper_unit_for_byte_size(young_evacuated_reserve_used),\n+                byte_size_in_proper_unit(young_evacuated), proper_unit_for_byte_size(young_evacuated),\n+                byte_size_in_proper_unit(young_available), proper_unit_for_byte_size(young_available));\n+\n+  log_debug(gc)(\"Memory reserved for old evacuation: \" SIZE_FORMAT \"%s for evacuating \" SIZE_FORMAT\n+                \"%s out of old available: \" SIZE_FORMAT \"%s\",\n+                byte_size_in_proper_unit(old_evacuated), proper_unit_for_byte_size(old_evacuated),\n+                byte_size_in_proper_unit(old_evacuated), proper_unit_for_byte_size(old_evacuated),\n+                byte_size_in_proper_unit(old_available), proper_unit_for_byte_size(old_available));\n+\n+  size_t regular_promotion = promotion_reserve - consumed_by_advance_promotion;\n+  size_t excess =\n+    old_available - (old_evacuation_reserve + promotion_reserve + old_bytes_loaned_for_young_evac + allocation_supplement);\n+  log_info(gc, ergo)(\"Old available: \" SIZE_FORMAT \"%s is partitioned into old evacuation budget: \" SIZE_FORMAT\n+                     \"%s, aged region promotion budget: \" SIZE_FORMAT\n+                     \"%s, regular region promotion budget: \" SIZE_FORMAT\n+                     \"%s, loaned for young evacuation: \" SIZE_FORMAT\n+                     \"%s, loaned for young allocations: \" SIZE_FORMAT\n+                     \"%s, excess: \" SIZE_FORMAT \"%s\",\n+                     byte_size_in_proper_unit(old_available), proper_unit_for_byte_size(old_available),\n+                     byte_size_in_proper_unit(old_evacuation_reserve), proper_unit_for_byte_size(old_evacuation_reserve),\n+                     byte_size_in_proper_unit(consumed_by_advance_promotion),\n+                     proper_unit_for_byte_size(consumed_by_advance_promotion),\n+                     byte_size_in_proper_unit(regular_promotion), proper_unit_for_byte_size(regular_promotion),\n+                     byte_size_in_proper_unit(old_bytes_loaned_for_young_evac),\n+                     proper_unit_for_byte_size(old_bytes_loaned_for_young_evac),\n+                     byte_size_in_proper_unit(allocation_supplement), proper_unit_for_byte_size(allocation_supplement),\n+                     byte_size_in_proper_unit(excess), proper_unit_for_byte_size(excess));\n@@ -776,1 +763,0 @@\n-  size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n@@ -794,2 +780,0 @@\n-\n-    heap->assert_pinned_region_status();\n@@ -799,2 +783,5 @@\n-    size_t consumed_by_advance_promotion;\n-    bool* preselected_regions = nullptr;\n+    ShenandoahGCPhase phase(concurrent ? ShenandoahPhaseTimings::choose_cset :\n+                            ShenandoahPhaseTimings::degen_gc_choose_cset);\n+\n+    collection_set->clear();\n+    ShenandoahHeapLocker locker(heap->lock());\n@@ -802,1 +789,2 @@\n-      preselected_regions = (bool*) alloca(heap->num_regions() * sizeof(bool));\n+      size_t consumed_by_advance_promotion;\n+      bool* preselected_regions = (bool*) alloca(heap->num_regions() * sizeof(bool));\n@@ -806,4 +794,0 @@\n-    }\n-\n-    ShenandoahGCPhase phase(concurrent ? ShenandoahPhaseTimings::choose_cset :\n-                            ShenandoahPhaseTimings::degen_gc_choose_cset);\n@@ -811,15 +795,18 @@\n-    ShenandoahHeapLocker locker(heap->lock());\n-    collection_set->clear();\n-    \/\/ TODO: young_available can include available (between top() and end()) within each young region that is not\n-    \/\/ part of the collection set.  Making this memory available to the young_evacuation_reserve allows a larger\n-    \/\/ young collection set to be chosen when available memory is under extreme pressure.  Implementing this \"improvement\"\n-    \/\/ is tricky, because the incremental construction of the collection set actually changes the amount of memory\n-    \/\/ available to hold evacuated young-gen objects.  As currently implemented, the memory that is available within\n-    \/\/ non-empty regions that are not selected as part of the collection set can be allocated by the mutator while\n-    \/\/ GC is evacuating and updating references.\n-\n-    \/\/ Budgeting parameters to compute_evacuation_budgets are passed by reference.\n-    compute_evacuation_budgets(heap, preselected_regions, collection_set, consumed_by_advance_promotion);\n-    _heuristics->choose_collection_set(collection_set, heap->old_heuristics());\n-    if (!collection_set->is_empty()) {\n-      adjust_evacuation_budgets(heap, collection_set, consumed_by_advance_promotion);\n+      \/\/ TODO: young_available can include available (between top() and end()) within each young region that is not\n+      \/\/ part of the collection set.  Making this memory available to the young_evacuation_reserve allows a larger\n+      \/\/ young collection set to be chosen when available memory is under extreme pressure.  Implementing this \"improvement\"\n+      \/\/ is tricky, because the incremental construction of the collection set actually changes the amount of memory\n+      \/\/ available to hold evacuated young-gen objects.  As currently implemented, the memory that is available within\n+      \/\/ non-empty regions that are not selected as part of the collection set can be allocated by the mutator while\n+      \/\/ GC is evacuating and updating references.\n+\n+      \/\/ Budgeting parameters to compute_evacuation_budgets are passed by reference.\n+      compute_evacuation_budgets(heap, preselected_regions, collection_set, consumed_by_advance_promotion);\n+\n+      _heuristics->choose_collection_set(collection_set, heap->old_heuristics());\n+      if (!collection_set->is_empty()) {\n+        \/\/ only make use of evacuation budgets when we are evacuating\n+        adjust_evacuation_budgets(heap, collection_set, consumed_by_advance_promotion);\n+      }\n+    } else {\n+      _heuristics->choose_collection_set(collection_set, heap->old_heuristics());\n@@ -827,1 +814,0 @@\n-    \/\/ otherwise, this is an abbreviated cycle and we make no use of evacuation budgets.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":493,"deletions":507,"binary":false,"changes":1000,"status":"modified"}]}