{"files":[{"patch":"@@ -2,1 +2,1 @@\n-project=shenandoah\n+project=jdk\n@@ -7,1 +7,1 @@\n-error=author,committer,reviewers,executable,symlink,message,hg-tag,whitespace,problemlists\n+error=author,committer,reviewers,merge,issues,executable,symlink,message,hg-tag,whitespace,problemlists\n@@ -21,0 +21,3 @@\n+[checks \"merge\"]\n+message=Merge\n+\n@@ -22,1 +25,1 @@\n-committers=1\n+reviewers=1\n@@ -28,0 +31,3 @@\n+[checks \"issues\"]\n+pattern=^([124-8][0-9]{6}): (\\S.*)$\n+\n","filename":".jcheck\/conf","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1,9 +0,0 @@\n-## GenShen: the Generational Shenandoah project\n-\n-Gen Shen stands for Generational Shenandoah,\n-and it also means \"deep roots\" in Mandarin.\n-\n-Documents in this directory:\n-- [glossary.md](glossary.md): glossary of terms used in our documents,\n-- [workplan.summary.md](workplan.summary.md): summary of the plan of record that we strive to follow,\n-- [design.summary.md](design.summary.md): summary of design points that we rely upon as working hypotheses.\n","filename":"genshen-docs\/README.md","additions":0,"deletions":9,"binary":false,"changes":9,"status":"deleted"},{"patch":"@@ -1,329 +0,0 @@\n-## Design Points\n-\n-This section discusses design decisions, as guided by the following tenets.\n-\n-### Tenets\n-\n-1. Don’t punish the mutator: While mutator code must be added to \n-   implement generational collection, degradations of\n-   mutator throughput and responsiveness \n-   should be contained as much as possible.\n-   If in doubt between design choices, \n-   pick the one that promises to minimize mutator overhead.\n-2. Safeguard incremental progress with milestones that demonstrate key capabilities.\n-3. Minimize the overall development effort.  This includes containing\n-   efforts to prepare and present each milestone deliverable \n-   that do not directly contribute to the end product.\n-\n-### Design Decisions\n-\n-While it is probable that we may revisit some of the following design\n-decisions if we run into implementation difficulties or performance\n-problems, the following is the current plan of record.\n-\n-1. This document is maintained alongside the source code. \n-   1. It is organized hierarchically with sections\n-      dedicated to major design decisions.\n-      Further, more detailed decisions are organized in top-down fashion,\n-      with overarching design decisions preceding derivative design decisions.\n-      The topic numbers assigned to particular design decisions may evolve over time.\n-   2. There is a separate \"rationale\" document that explains more of the reasoning behind design decisions\n-      and links relevant portions between documents.\n-2. Genshen changes to the Shenandoah implementation will be\n-   compartmented.  See discussion [here](rationale.summary.md#compartmentalization\").\n-3. We will support concurrent collection of old gen and young gen,\n-   with the expectation that a single old collection will typically\n-   overlap with the execution of many young collections.\n-4. In order to minimize performance impact on the mutator, we will use\n-   a single Load-Reference-Barrier to implement both evacuation\n-   from young gen and from old gen.\n-   1. Tenuring will be implemented as part of young evacuation.\n-   2. All evacuation for both young and old gen regions\n-      happens under the control of the same GC threads and is\n-      supported by the same Load Reference Barrier (LRB) as in\n-      vanilla Shenandoah, with only small refinements to the\n-      implementation of slow-path code within the LRB.\n-   3. See discussion [here](rationale.summary.md#load-reference-barrier).\n-5. An old collection begins at the same time as a young gen\n-   collection, with both collections leveraging the\n-   results of a single shared root scan.\n-6. Old collection generally runs at lower priority (e.g., fewer\n-   numbers of parallel threads or greater “nice” values for\n-   concurrent threads) than young collection because\n-   replenishing the allocation pool to support ongoing allocation\n-   needs of mutator threads requires urgent completion of young GC.\n-   See discussion [here](rationale.summary.md#prioritization).\n-7. Although the planned future production release of GenShen will\n-   run young collection concurrently with old collection, support\n-   will also be implemented and maintained for alternating executions\n-   of young collections with global collections.  See\n-   discussion [here](rationale.summary.md#young-global-discussion).\n-   1. Since this is not a production release, efficiency of\n-      implementation is not a primary concern.\n-   2. Regression tests will exercise the implementation of this mode\n-      of operation.\n-8. A regression test suite will be developed and maintained to\n-   support all of the enhanced capabilities of GenShen, including\n-   capabilities that are enabled and disabled at build time for the\n-   JVM.\n-9. Though old collections start at the same time as young\n-   collections collections, they do not necessarily end at the same\n-   time.  Typically, many young-gen collections will be completed\n-   concurrently during the time that a single old-gen collection is\n-   running.  See discussion [here](rationale.summary.md#concurrency-of-young-and-old).\n-10. Root scanning will be performed during a JVM safe point.\n-11. Scanning of the remembered set will be performed by parallel\n-    young-gen GC threads during a JVM safe point.  A side\n-    effect of scanning is to mark as CLEAN any cards of the remembered\n-    set that are found by remembered set scanning to no longer be\n-    DIRTY. \n-12. The remembered set maintains a start-of-object representation to\n-    facilitate quick identification of where the first object\n-    pertaining to each DIRTY card region begins.  See discussion\n-    [here](rationale.summary.md#remembered-set-starting-offsets).\n-    This requires that:\n-    1. Newly promoted objects be registered with the remembered set\n-       and start-of-object support by post-processing the associated GCLAB block, and\n-    2. When entire regions are promoted out of young collections into\n-       old gen, the objects contained within those regions must be\n-       registered with the remembered set and the start-of-object support.\n-13. Young marking, including scanning of root pointers,\n-    will place discovered references to old gen into a thread-local SATB\n-    buffer so that they can be processed by an old-gen collection\n-    thread.  See discussion [here](rationale.summary.md#satb-keep-old-alive-entries). \n-    1. Possible optimization: refrain from logging old-gen pointers\n-       that refer to already marked old objects into the SATB buffer.\n-14. The default size of the SATB buffer will increase from 1024 to\n-    4096 words because we will be placing more information into the\n-    SATB buffer.\n-15. Whenever the SATB buffer is full, the slow path for adding to\n-    the SATB buffer will attempt to compress the buffer contents before\n-    communicating the buffer to GC threads.  If compression leaves a\n-    minimum of 256 slots available within the SATB buffer, the thread\n-    continues to add values to the existing buffer.  Compression\n-    consists of:\n-    1. For pointers to young gen:\n-       1. If concurrent marking of young gen is disabled, ignore the\n-          pointer.\n-       2. Otherwise, if the object referenced by this pointer has\n-          already been marked, ignore the pointer.\n-       3. If we choose to use SATB-based remembered set, ignore all\n-          overwritten address values that reside within young gen.\n-    2. For pointers to old gen:\n-       1. If concurrent marking of old gen is disabled, ignore the\n-          pointer.\n-       2. Otherwise, if the object referenced by this pointer\n-          has already been marked, ignore the pointer.\n-       3. If we choose to use an SATB-based remembered set:\n-          - If the card corresponding to an overwritten old gen\n-            address is already DIRTY, ignore this overwritten\n-            address.\n-          - Otherwise, fetch the pointer value held at the overwritten\n-            address.  If the fetched pointer value does not\n-            refer to young gen, ignore this overwritten address.\n-          - Otherwise, use a hash table (suggested size 127) to sift\n-            redundant DIRTY card references for the current batch of\n-            overwritten old-gen addresses.  Preserve only one address\n-            for each card entry that needs to be marked as DIRTY.\n-    3. SATB buffers will be processed by both a young GC\n-       thread and an old GC thread.\n-       1. The young GC thread will mark objects referenced\n-          by young pointers.\n-       2. The old GC thread will:\n-          1. Mark objects referenced by old-gen pointers, and\n-          2. If we choose to use SATB-based remembered set: mark as DIRTY\n-             the card entries corresponding to overwritten addresses.\n-16. GC uses a G1-style heuristic to choose collection sets for both\n-    young and old memory areas.  The collection set represents the\n-    heap regions that offer the greatest opportunity to quickly reclaim\n-    garbage, as with the existing Shenandoah implementation.  See\n-    discussion [here](rationale.summary.md#g1-heuristic).\n-17. Following an evacuation phase that evacuates\n-    both old and young heap regions, the update-references phase is\n-    required to update references throughout all \n-    old regions that were not selected as part of the old\n-    collection set in addition to updating references in young\n-    heap regions.\n-    1. If a particular young collection evacuation phase does not\n-       evacuate any old regions, then its update references phase can\n-       focus solely on young heap regions and the\n-       remembered set.\n-18. Tenuring is based on object age with the enhancements described\n-    below.  See discussion [here](rationale.summary.md#tenuring).\n-    1. The variable TenureCycle counts how many GC cycles correspond to\n-       each increment of an object’s age.  Object ages are not\n-       necessarily incremented each time a GC cycle is completed.  They\n-       are incremented each time TenureCycle GC cycles have been\n-       completed.\n-    2. The variable TenureAge represents the age at which an object\n-       becomes eligible for tenuring.\n-    3. During GC cycles that correspond to TenureCycle, the “age” of\n-       individual objects is incremented by 1 plus the size of the\n-       object’s original heap region age when the object is evacuated.\n-    4. During GC cycles that correspond to TenureCycle, the “age” of\n-       each heap region that has been fully allocated (i.e. no more\n-       available memory for allocation) and that is not in the\n-       collection set is incremented by 1 at the end of the evacuation\n-       phase.  If the resulting “age” equals TenureAge, then the entire\n-       region is reassigned to become part of old gen.\n-       1. The update-refs phase will process this heap region even\n-          though it is “now” considered to be part of old gen.\n-       2. Each of the objects contained within the promoted region\n-          shall be registered with the remembered set abstraction.\n-       3. Each of the objects contained within the promoted region\n-         be scanned to determine any references to young-gen\n-         memory that are contained therein.  For any such pointers, set\n-         the associated card table entry to DIRTY.\n-19. During evacuation, each running mutator thread has both a TLAB\n-    and a GCLAB.\n-    1. The TLAB is associated with a young heap region.\n-    2. The GCLAB is associated with an old heap region.\n-    3. When the mutator’s load reference barrier encounters a\n-       reference for which the associated object needs to be tenured, it\n-       allocates the copy memory from the GCLAB.\n-    4. When the mutator’s load reference barrier encounters a\n-       reference for which the associated object resides within the\n-       collection set of old gen, it allocates the copy memory from the\n-       GCLAB.\n-    5. When the mutator’s load reference barrier encounters a\n-       reference for which the associated object needs to be evacuated to\n-       young gen, it allocates the copy memory from the TLAB.\n-    6. We initially plan to use the same size for TLAB and GCLAB, but\n-       this decision may be revisited.\n-    7. If the size of the object to be evacuated is larger than half\n-       the size of the respective local allocation buffer, allocation\n-       of the replica memory is handled by alternative allocators, to be\n-       designed.  Call these \"odd\" objects.\n-20. During evacuation, each evacuating GC thread will maintain two\n-    GCLAB buffers:\n-    1. GCLAB-Young is associated with young gen.\n-    2. GCLAB-Old is associated with old gen.\n-    3. If the object to be evacuated currently resides in old gen or\n-      if it resides in young gen and it is to be tenured, allocate the\n-      copy memory from GCLAB-Old.\n-    4. Otherwise, allocate the copy memory from GCLAB-Young.\n-    5. At the end of the evacuation phase, consider repurposing any\n-       unspent GCLAB-Young as a TLAB if there is sufficient unallocated\n-       memory remaining within it.\n-    6. At the end of the evacuation phase, consider preserving the\n-       GCLAB-Old for use as a GCLAB for a mutator thread during the next\n-       young collections collection or as a GCLAB-Old during the next\n-       old-gen evacuation pass.\n-    7. See 19.7.\n-21. A certain budget of CPU time is provisioned to perform young-gen\n-    GC in order to support a particular planned workload.\n-    1. The resources dedicated to young-gen GC are limited in order\n-       to assure a certain amount of CPU time is available to mutator\n-       threads.\n-    2. Command line options allow user control over provisioning.  A\n-       TBD API may allow services to adjust provisioning dynamically.\n-    3. In the ideal, provisioning is adjusted automatically based on\n-       TBD heuristics.\n-    4. The provisioned CPU resources can support a range of service\n-       quality, reclaiming large numbers of heap regions with a low GC\n-       frequency or reclaiming small numbers of heap regions with a\n-       high GC frequency.  Given a particular frequency of GC cycles,\n-       the same CPU resources can evacuate a large number of sparsely\n-       populated heap regions or a small number of densely populated\n-       heap regions.  Tradeoffs between these configuration extremes\n-       may be adjusted under software control or by TBD\n-       heuristics.\n-    5. For each young-gen GC pass, a certain TBD percentage\n-       of CPU resources are reserved for old-gen evacuation and\n-       update-refs activities.\n-       1. The old-gen CPU resource budget represents the total amount\n-          of old-gen memory that can be relocated, and is quantified as\n-          a multiple N of the heap region size.\n-       2. The old-gen GC threads determine the composition of the\n-          old-gen collection set, up to but never exceeding the upper\n-          bound N on cumulative evacuation size.\n-       3. The old-gen GC thread may select for the collection set\n-          N heap regions which are known to have 100%\n-          utilization, 2N heap regions known to have 50% utilization,\n-          5N heap regions known to have 20% utilization, and so on.\n-       4. If the old-gen GC refrains from delegating N heap regions\n-          worth of evacuation work to the young-gen evacuation phase,\n-          then the young GC is free to use the excess CPU resources to\n-          more aggressively evacuate more of its own young heap regions,\n-          using a larger than normal young-gen collection set.\n-       5. The budget for updating old-gen references must be large\n-          enough to handle the total old-gen memory size - N.  In the\n-          case that old-gen GC configures a collection set that\n-          represents its full evacuation capacity of N heap regions, the\n-          number of old-gen heap regions that are not part of the\n-          old-gen collection set is never larger than this quantity.\n-          In the case that old-gen GC configures a smaller collection\n-          set, then for each fraction of a heap region that is not\n-          evacuated, this much more of a heap region might have to be\n-          processed during the update-refs phase of GC.  We estimate\n-          that the cost of evacuating M bytes of memory is similar to\n-          the cost of updating the references within M bytes of\n-          memory.\n-22. A smaller (generally) budget of CPU time is provisioned to\n-    perform old-gen GC in order to support a particular planned\n-    workload.\n-    1. The resources dedicated to young-gen GC are limited in order\n-       to assure a certain amount of CPU time is available to mutator\n-       threads.\n-    2. Command-line options allow user control over provisioning.  A\n-       TBD API may allow services to adjust provisioning dynamically.\n-    3. In the ideal, provisioning is adjusted automatically based on\n-       TBD heuristics.\n-    4. As with young-gen GC, the CPU resources provisioned for\n-       old-gen GC can support a range of service quality.\n-    5. The CPU resources dedicated to old-gen collection do not have\n-       responsibility for evacuating old regions as all evacuation\n-       is performed by young-gen GC threads.  Instead, the CPU\n-       resources dedicated to old-gen GC activities are used for\n-       activities such as the following:\n-       1. Processing the content of SATB buffers:\n-          - If old collection is in concurrent marking phase, mark\n-            objects referenced by any keep-alive pointers.\n-          - If we are using SATB-based remembered set, update the\n-            remembered set based on overwritten addresses reported in the\n-            SATB buffer.\n-       2. During concurrent marking, scan the contents of previously\n-          marked objects to complete the transitive closure of\n-          reachability.\n-       3. Perform heuristic computations:\n-          - Determine when to start the next old-gen GC cycle.\n-          - Determine which old regions to evacuate on this and future\n-            passes of young-gen GC.\n-          - Adjust young-gen efficiency parameters such as: How many\n-            heap regions should be dedicated to young gen?  What is\n-            optimal value of TenureCycle?  What is optimal value of\n-            TenureAge?  How much CPU time should be dedicated to\n-            young-gen GC?\n-          - Adjust old-gen efficiency parameters such as: How much CPU\n-            time should be dedicated to old-gen GC?  How many heap regions\n-            should be dedicated to old gen?  Should any heap regions be\n-            decommissioned and returned to the operating system in order\n-            to shrink the memory footprint of this service?\n-       4. Perform routine maintenance as time and schedule permits:\n-          - Potentially sweep up dead memory, accumulating ages at\n-            which dead objects were reclaimed within old regions.\n-          - Potentially, sweep through evacuated memory to accumulate\n-            ages at which dead objects were reclaimed.\n-          - Organize free lists for fast and efficient allocation of\n-            GCLAB and Odd object allocations.\n-          - Return emptied old regions to the free set.\n-          - Eventually, reference processing and string deduplication\n-            should be performed by lower priority old-gen threads\n-            rather than higher priority young-gen threads.\n-       5. Following completion of each old-gen concurrent mark pass,\n-          select regions to be included in the old-gen collection set:\n-          - No more than a total of N bytes of old gen is evacuated by\n-            each pass of the young-gen evacuator.\n-          - If old-gen GC threads desire to evacuate M, which is more\n-            than N bytes of old gen, it does so by piggy backing on\n-            multiple subsequent young-gen evacuation passes, selecting\n-            evacuating no more than the accumulation of N total heap\n-            regions in each of the following young-gen evacuation passes.\n-          - Since it is most efficient to evacuate all M > N regions\n-            of old-gen memory with a single young-gen evacuation pass,\n-            configure the old-gen collection set to include all M\n-            regions if there are sufficient free regions available to\n-            afford the young-gen allocator to continue allocating new\n-            objects during the longer delay that would be required to\n-            evacuate more than the traditionally budgeted N regions of\n-            old-gen memory.\n","filename":"genshen-docs\/design.summary.md","additions":0,"deletions":329,"binary":false,"changes":329,"status":"deleted"},{"patch":"@@ -1,44 +0,0 @@\n-## Glossary for the Generational Shenandoah (GenShen) Project\n-\n-Shen := Shenandoah := the Shenandoah garbage collector\n-\n-GenShen := Generational Shenandoah\n-\n-gen := generation\n-young gen := the young generation\n-old gen := the old generation\n-\n-collector := garbage collector\n-young collector := young gen collector\n-old collector := old gen collector\n-global collector := single-generation collector that works on the entire heap\n-\n-young\/old\/global collection := a complete cycle through the phases of the young\/old\/global collector\n-\n-cset := collection set\n-remset := remembered set\n-rset := remembered set\n-\n-parallel := same task, dealt with by multiple threads\n-concurrent := different tasks, operated upon simultaneously\n-conc := concurrent\n-\n-conc mark := concurrent marking\n-conc global GC := concurrent global GC, like vanilla Shen\n-evac := evacuation (phase)\n-UR := update references (phase)\n-\n-LRB := Load Reference Barrier\n-SATB := Snapshot At The Beginning\n-TLAB := Thread-Local Allocation Buffer for a mutator thread\n-GCLAB := like a TLAB, but for a GC thread\n-\n-young region := a heap region affiliated with young gen\n-old region := a heap region affiliated with old gen\n-free region := a region that is not affiliated with either generation and available for future reuse by allocators \n-\n-young object := an object in young gen\n-old object := an object in old gen\n-\n-block := an identifiable chunk of space in a region that is or was occupied by a Java object\n-block start := a pointer to the beginning of a block\n","filename":"genshen-docs\/glossary.md","additions":0,"deletions":44,"binary":false,"changes":44,"status":"deleted"},{"patch":"@@ -1,395 +0,0 @@\n-# Summary Plan of Record: GenShen Prototype (2020)\n-\n-## Planned Milestones\n-\n-### Overview of Initial Milestones\n-\n-1. Pure young collection. (Young gen size unlimited. Old gen untouched.)\n-2. Size-restricted young gen.\n-3. Tenuring and promotion.\n-4. Global collection after young collection.\n-5. Young collection after global collection, repeat alternations.\n-6. Concurrent old marking.\n-7. Concurrent old and young collections.\n-\n-Young collection reclaims garbage only from heap regions that are\n-identified as belonging to the young generation.\n-\n-Old collection reclaims garbage only from heap regions that are\n-identified as belonging to the old generation, which holds objects\n-that have been promoted from young generation.\n-\n-Global collection reclaims garbage from heap regions belonging to\n-either the young generation or the old generation.\n-\n-### Milestone 1: GC of Young Gen Only\n-\n-This demonstration proves successful implementation of:\n-\n-1. Separating out that certain heap regions comprise young gen and\n-   other heap regions are considered to represent old gen. \n-2. Confirming that card marking does not crash.  (Does not prove that\n-   card marking works because we have no objects in old gen.) \n-3. Confirming that remembered set scanning does not crash.  (Does not\n-   prove that remembered set scanning works because we have no objects in\n-   old gen.) \n-4. Demonstrating a simplified form of young collection.\n-\n-Tasks\n-\n-1. Integrate various completed code patches into a common branch\n-2. Test and debug existing code\n-\n-### Milestone 2: Restrict Size of Young Gen\n-\n-This milestone constrains the young generation to a certain number of\n-regions.  After that number is reached, allocation fails.  For now, the\n-number can be fixed, say 25% of all regions, and we can simply crash\n-thereafter. \n-\n-Tasks\n-\n-1. Establish a mechanism to specify and enforce a limit on the number\n-   of heap regions that may comprise young-gen memory.\n-2. Adjust the GC triggering mechanism so that the size of young gen\n-   does not have reason to exceed the young-gen size during young-gen\n-   GC, where the size of young-gen is affected by GC in the\n-   following ways:\n-   1. Certain free heap regions may be added to young gen in order to\n-      support allocation requests that are made by concurrent mutator\n-      threads while GC is being performed.\n-   2. At the end of GC, all heap regions that were part of the\n-      collection set are removed from young-gen memory and placed\n-      in the free pool.\n-\n-\n-### Milestone 3: Young Collection with Promotion of Tenured Objects\n-\n-Add to Milestone 2 the capability of promoting young gen objects.\n-Don’t worry about odd objects or humongous objects at this time.\n-Demonstrate: \n-\n-1. That we can promote objects into old gen.\n-2. That card-marking works.\n-3. That remembered set scanning works (correctly, but perhaps not with\n-   full desired efficiency). \n-\n-The following tasks must be implemented:\n-\n-1. The collection set is selected as a subset of all young collections\n-   heap regions using TBD heuristics. \n-2. During young collection, each time an object is evacuated to a\n-   young consolidation region, the object’s age is incremented. \n-    1. For simplicity, don’t try to implement the complete region\n-       aging or promotion at this time. \n-    2. Also for simplicity, don’t try to implement the TenureCycle\n-       optimization. \n-3. During young collection, each GC thread maintains both a young\n-   GCLAB and and old GCLAB.\n-    1. When evacuating an object whose incremented age is less than\n-       TenureAge, allocate memory for the object’s copy from within the\n-       young GCLAB. \n-    2. When evacuating an object whose incremented age is >=\n-       TenureAge, allocate memory for the object’s copy from within the\n-       old GCLAB. \n-    3. Don’t support Odd or Humongous objects for simplicity.\n-4. During young collection, each mutator thread maintains both a TLAB\n-   and a GCLAB.  The GCLAB is associated with old gen. \n-    1. When evacuating an object whose incremented age is less than\n-       TenureAge, allocate memory for the object’s copy from within the\n-       TLAB. \n-    2. When evacuating an object whose incremented age is >=\n-       TenureAge, allocate memory for the object’s copy from within the\n-       GCLAB. \n-5. Perform maintenance on the contents of each retired old GCLAB,\n-   where this maintenance consists of: \n-    1. Registering each object’s starting location and length with the\n-       remembered set abstraction so that remembered set scanning can\n-       quickly find the first object within each DIRTY card region, \n-    2. Updating the card table to reflect all references from this\n-       object into young gen,  \n-    3. Evacuating all objects directly referenced from this object\n-       which reside within a collection set and have not yet been\n-       evacuated, and \n-    4. Healing all pointers from within newly evacuated old objects\n-       that refer to objects residing within the collection set. \n-    5. The last two items listed above are already performed by\n-       traditional Shenandoah but can be merged with the implementation of\n-       the other maintenance activities in order to perform all this work\n-       in a consolidated pass. \n-\n-### Milestone 4: Sequential Execution of Multiple Young Collections Followed by Multiple Global Collections\n-\n-__Demonstrated Concurrency Between Young-Gen and Old-Gen Activities__\n-\n-   ✓ denotes that this combination of activities is allowed.\n-\n-   ✗ denotes that this combination of activities is disallowed.\n-\n-|                |  Old-Gen Mark  | Old-Gen Evac  | Old-Gen Idle |\n-|:--------------:|:--------------:|:-------------:|:------------:|\n-| Young Gen Mark |      ✓         |     ✗         |     ✓        |\n-| Young Gen Evac |      ✗         |     ✓         |     ✓        |\n-| Young Gen Idle |      ✗         |     ✗         |     ✓        |\n-\n-Add to Milestone 3 the ability to switch to global collection after a\n-series of young Collections.\n-\n-1. The switch is triggered by a simple TBD test, such as when the\n-   space available within old gen is less than the size of young gen. \n-2. The global collection continues to run with the card-marking\n-   barrier enabled though the card values will not be consulted further.\n-3. For this demonstration, the switch to global collections is\n-   one-way.  Following this switch, we can no longer perform young\n-   collections. \n-4. For this demonstration, the global collection does not distinguish\n-   between young regions and old regions. \n-    1. Evacuation of objects that resided in an old region is handled\n-    the same as evacuation of objects that resided in a young heap\n-    region. \n-5. This demonstrates that:\n-    1. Promotion of objects works.  The objects that have been promoted\n-    into old gen maintain whatever protocols and invariants are\n-    assumed by Shenandoah GC. \n-    2. That we can manage the transition from young GC to global GC.\n-    3. That global collection, insofar as we characterize it, works.\n-    4. That Young collections do not corrupt the heap.\n-\n-Tasks:\n-\n-1. Fix bugs in existing code enhancements.\n-2. Implement the transition from young collection to global collection\n-3. Implement global collection with write barrier for card-table marking\n-\n-### Milestone 5: Interleaved Execution of Young and Global Collections\n-\n-__Demonstrated Concurrency Between Young-Gen and Old-Gen Activities__\n-\n-   ✓ denotes that this combination of activities is allowed.\n-\n-   ✗ denotes that this combination of activities is disallowed.\n-\n-|                |  Old-Gen Mark  | Old-Gen Evac  | Old-Gen Idle |\n-|:--------------:|:--------------:|:-------------:|:------------:|\n-| Young Gen Mark |      ✓         |     ✗         |     ✓        |\n-| Young Gen Evac |      ✗         |     ✓         |     ✓        |\n-| Young Gen Idle |      ✗         |     ✗         |     ✓        |\n-\n-Add to Milestone 4 the ability to switch back to Young Collection upon\n-completion of a global collection. \n-\n-1. Assume that the global collection is successful in reclaiming\n-   necessary memory.  No heuristics to resize oldgen or young gen at\n-   this time. Specify sizes of each on command line. \n-2. The switch to old collection is triggered by exhaustion of old gen.\n-   At least one young collection is assumed to execute following\n-   completion of each global collection. \n-3. For this demonstration, the global collection does distinguish\n-   between young collections and old regions. \n-    1. Objects in the old collection set are evacuated to old\n-       consolidation regions. \n-    2. Objects in the young collection set are evacuated\n-       to young collections consolidation regions. \n-    3. There is no tenuring of objects during a global collection (for\n-       simplicity). \n-\n-This demonstrates that:\n-\n-1. Promotion of objects works.  The objects that have been promoted\n-   into old gen maintain whatever protocols and invariants are\n-   assumed by Shenandoah GC. \n-2. That we can manage the transition from young GC to global GC.\n-3. That we can manage the transition from global GC to young GC.\n-4. That the transition from global GC to young GC\n-   establishes all invariants required for correct operation of young\n-   GC. \n-\n-Tasks:\n-\n-1. Distinguish between “global collection” for purposes of\n-   maintaining support for non-generational GC and “global collection”\n-   for purposes of supporting sequential interleaving of young GC\n-   and global GC.\n-2. Implement the transition from global GC to young GC.\n-3. Initialize the remembered set for each consolidation heap region\n-   of old gen to all CLEAN before allocating any GCLAB buffers within\n-   the consolidation heap region.\n-4. At the start of global evacuation, select the collection set as\n-   some combination of existing young regions and\n-   old regions based on heuristics TBD.\n-5. During global collection, maintain old-gen GCLABs for all GC\n-   threads and mutator threads.\n-6. During global collection, distinguish evacuation behavior\n-   depending on whether an object to be evacuated resides within the\n-   young collection set or the old collection set since\n-   young objects are evacuated into young \n-   consolidation regions and old objects are evacuated into old\n-   consolidation regions;\n-7. Add minimal logging reports to describe behavior of young-gen and global\n-   GC.\n-8. During global collection, perform maintenance on the contents of\n-   each retired old GCLAB, where this maintenance consists of:\n-   1. Registering each object’s starting location and length with the\n-      remembered set abstraction so that remembered set scanning can\n-      quickly find the first object within each DIRTY card region,\n-   2. Updating the card table to reflect all references from this\n-      object into young gen,\n-   3. Evacuating all objects directly referenced from this object\n-      that reside within a collection set and that have not already been\n-      evacuated, and\n-   4. Healing all pointers from within new replica objects residing in old\n-      gen that refer to objects residing within the collection set.\n-   5. The last two items listed above are already performed by\n-      traditional Shenandoah but can be merged with the implementation of\n-      the other maintenance activities in order to perform all this work\n-      in a consolidated pass.\n-\n-### Milestone 6: GC of young collections with Concurrent Marking (but not Collecting) of Old Gen\n-\n-__Demonstrated Concurrency Between Young-Gen and Old-Gen Activities__\n-\n-   ✓ denotes that this combination of activities is allowed.\n-\n-   ✗ denotes that this combination of activities is disallowed.\n-\n-|                |  Old-Gen Mark  | Old-Gen Evac  | Old-Gen Idle |\n-|:--------------:|:--------------:|:-------------:|:------------:|\n-| Young Gen Mark |      ✓         |     NA         |     ✓        |\n-| Young Gen Evac |      ✓         |     NA         |     ✓        |\n-| Young Gen Idle |      ✓         |     NA         |     ✓        |\n-\n-This demonstration relies on GC log reports to show that marking of\n-old gen runs concurrently with marking of young gen.\n-Since the results of old-gen marking are not used to support old-gen\n-evacuation, this demonstration does not prove that old-gen marking\n-produces correct results.\n-\n-All pointers to old-gen memory that are discovered during scan of\n-young-gen memory are communicated to the old-gen concurrent mark\n-threads by inserting these pointer values into a SATB buffer as\n-keep-alive values.  Every SATB buffer is post-processed both by a\n-young-gen GC thread and by an old-gen GC thread.\n-\n-Pointers from old-gen memory to young-gen memory that are discovered\n-during the marking of old-gen are ignored.\n-\n-At the start of young-gen concurrent marking, the remembered set is\n-scanned to detect all inter-generational references.\n-\n-The SATB write barrier remains enabled as long as either young-gen or\n-old-gen concurrent marking is active.\n-\n-Tasks:\n-\n-1. Each young GC thread has a dedicated SATB buffer into which it places\n-   discovered references to old-gen memory.\n-2. SATB write barrier is left enabled as long as either young\n-   or old marking is active.\n-3. SATB buffer is enlarged to 4096 entries.\n-4. SATB buffer compression is enhanced to deal with the mix of old\n-   and young pointers.\n-5. SATB buffer processing is performed by both a young collection\n-   thread and an old collection thread.  Pointers to\n-   old gen within the SATB buffer are marked and added to the old-gen\n-   closure queues so that they can be subsequently scanned.\n-6. Certain GC threads (or work items) are dedicated to old GC\n-   and others are dedicated to young GC.\n-7. Old-gen GC threads process the closure of previously marked\n-   old-gen objects, scanning all references contained therein.\n-8. Old-gen GC threads add to the old-gen closures all old-gen objects\n-   referenced by SATB buffers if those objects were not previously marked.\n-\n-### Milestone 7: Concurrent Young and Old Collections\n-\n-\n-__Demonstrated Concurrency Between Young-Gen and Old-Gen Activities__\n-\n-   ✓ denotes that this combination of activities is allowed.\n-\n-   ✗ denotes that this combination of activities is disallowed.\n-\n-|                |  Old-Gen Mark  | Old-Gen Evac  | Old-Gen Idle |\n-|:--------------:|:--------------:|:-------------:|:------------:|\n-| Young Gen Mark |      ✓         |     ✗         |     ✓        |\n-| Young Gen Evac |      ✓         |     ✓         |     ✓        |\n-| Young Gen Idle |      ✓         |     ✗         |     ✓        |\n-\n-In this demonstration, old-gen concurrent marking runs concurrently with all\n-phases of young-gen GC.  Old-gen evacuation only runs while young-gen\n-evacuation is running.  In the case that old-gen needs to evacuate so\n-much memory that doing so in a single uninterruptible batch would\n-significantly extend the duration of the young-gen evacuation phase,\n-the total old-gen evacuation workload is divided into multiple smaller\n-batches of evacuation work, each batch being processed concurrently\n-with a different young-gen evacuation cycle. \n-\n-The demonstration:\n-\n-1. Uses logging reports to describe the results of young\n-   collection and old collection.\n-2. Shows for some “simple” workload (Heapothysis or\n-   Extremem?) that generational GC provides performance benefits over\n-   non-generational GC.\n-\n-Tasks\n-\n-1. Add minimal logging reports to describe behavior of old-gen\n-   GC.\n-2. Decide which old regions comprise the old collection set.\n-3. Divide the old collection set into multiple collection subsets.\n-4. For each of the collection subsets\n-   1. Communicate the subset to young GC tasks to process these\n-      evacuations when it begins its next evacuation cycle.\n-   2. Wait for young GC tasks to signal completion of the evacuation\n-      cycle.\n-\n-## Proposed Future Milestones Not Yet Fully Planned\n-\n-### Milestone 8: Performance Improvements\n-\n-1. Remembered Set scanning sets cards to CLEAN if they are no longer\n-   DIRTY.\n-2. Remembered Set scanning maintains and utilizes start-offset data\n-   structure to quickly find the first object to be scanned within each\n-   DIRTY card.\n-3. Remembered set scanning refrains from scanning the portions of\n-   large objects and arrays that overlap card regions that are not\n-   DIRTY.\n-\n-### Milestone 9: Fix Known Bugs\n-\n-We are aware of bugs in our existing card-marking implementation.\n-\n-### Milestone 10: Multiple Young-Gen Evacuations Process Old Collection Set\n-\n-### Milestone 11: Odd Objects (larger than 50% of TLAB\/GCLAB size)\n-\n-By default, the promotion of such objects is handled by a\n-slower-than-normal path.  Instead of allocating old gen from the\n-GCLAB, the mutator thread obtains memory for the copy by directly\n-accessing free lists. See existing code that does that already. \n-\n-### Micro Milestone 12: Collect and Report New Metrics\n-\n-### Micro Milestone 13: SATB-Based Remembered Set\n-\n-### Micro Milestone 14: Heuristic Pacing of Young Collection Frequency\n-\n-### Micro Milestone 15: Heuristic Pacing of Old Collection Frequency\n-\n-### Micro Milestone 16: Heuristic Sizing of Young and Old Sizes\n-\n-### Micro Milestone 17: Heuristic Adjustments of Tenuring Strategies\n-\n-### Micro Milestone 18: Overlap Evacuation of Cycle N with Marking of Cycle N+1\n-\n-### Micro Milestone 19: Humongous Objects\n-\n-### Micro Milestone 20: Reference Processing\n-\n-### Micro Milestone 21: String Dedup\n-\n-### Micro Milestone 22: Degenerated GC\n-\n-### Micro Milesones TBD: Various Performance Improvements\n-\n","filename":"genshen-docs\/workplan.summary.md","additions":0,"deletions":395,"binary":false,"changes":395,"status":"deleted"},{"patch":"@@ -3,2 +3,1 @@\n- * Copyright (c) 2012, 2021 SAP SE. All rights reserved.\n- * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * Copyright (c) 2012, 2022 SAP SE. All rights reserved.\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shenandoah\/c1\/shenandoahBarrierSetC1_ppc.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3,2 +3,1 @@\n- * Copyright (c) 2012, 2021 SAP SE. All rights reserved.\n- * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * Copyright (c) 2012, 2022 SAP SE. All rights reserved.\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shenandoah\/shenandoahBarrierSetAssembler_ppc.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -4,1 +4,0 @@\n- * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shenandoah\/shenandoahBarrierSetAssembler_ppc.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4,1 +4,0 @@\n- * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shenandoah\/c1\/shenandoahBarrierSetC1_riscv.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n- if (UseZGC) {\n+  if (UseZGC) {\n@@ -74,8 +74,0 @@\n-  if (UseZGC) {\n-    if (ZGenerational) {\n-      return ZMajor;\n-    } else {\n-      return Z;\n-    }\n-  }\n-\n@@ -91,0 +83,7 @@\n+  if (UseZGC) {\n+    if (ZGenerational) {\n+      return ZMajor;\n+    } else {\n+      return Z;\n+    }\n+  }\n","filename":"src\/hotspot\/share\/gc\/shared\/gcConfiguration.cpp","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -3,1 +3,0 @@\n- * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c1\/shenandoahBarrierSetC1.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3,1 +3,0 @@\n- * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahBarrierSetC2.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3,1 +3,0 @@\n- * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahCompactHeuristics.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -82,1 +82,1 @@\n-    assert(_old_generation->available() > old_evacuation_budget, \"Cannot budget more than is available\");\n+    assert(_old_generation->available() >= old_evacuation_budget, \"Cannot budget more than is available\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,0 @@\n- * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahPassiveHeuristics.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3,1 +3,0 @@\n- * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahPassiveHeuristics.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3,1 +3,0 @@\n- * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahStaticHeuristics.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -64,0 +64,4 @@\n+#if !(defined AARCH64 || defined AMD64 || defined IA32 || defined PPC64)\n+  vm_exit_during_initialization(\"Shenandoah Generational GC is not supported on this platform.\");\n+#endif\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/mode\/shenandoahGenerationalMode.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3,1 +3,0 @@\n- * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/mode\/shenandoahPassiveMode.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3,1 +3,0 @@\n- * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/mode\/shenandoahSATBMode.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3,1 +3,0 @@\n- * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSetClone.inline.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3,1 +3,0 @@\n- * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentMark.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3,1 +3,0 @@\n- * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahDegeneratedGC.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1487,1 +1487,0 @@\n-  _free_sets.assert_bounds();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3,1 +3,0 @@\n- * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3,1 +3,0 @@\n- * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGC.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3,1 +3,0 @@\n- * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGC.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -660,5 +660,0 @@\n-  \/\/ This detects arithmetic wraparound on _used.  Non-generational mode does not keep track of _affiliated_region_count\n-  \/\/ TODO: REMOVE IS_GLOBAL() QUALIFIER AFTER WE FIX GLOBAL AFFILIATED REGION ACCOUNTING\n-  assert(is_global() || ShenandoahHeap::heap()->is_full_gc_in_progress() ||\n-         (_used + _humongous_waste <= _affiliated_region_count * ShenandoahHeapRegion::region_size_bytes()),\n-         \"used cannot exceed regions\");\n@@ -686,6 +681,0 @@\n-\n-  \/\/ Non-generational mode does not maintain affiliated region counts\n-  \/\/ TODO: REMOVE IS_GLOBAL() QUALIFIER AFTER WE FIX GLOBAL AFFILIATED REGION ACCOUNTING\n-  assert(is_global() || ShenandoahHeap::heap()->is_full_gc_in_progress() ||\n-         (_affiliated_region_count * ShenandoahHeapRegion::region_size_bytes() >= _used),\n-         \"Affiliated regions must hold more than what is currently used\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1278,0 +1278,5 @@\n+  \/\/ Align requested sizes to card sized multiples\n+  size_t words_in_card = CardTable::card_size_in_words();\n+  size_t align_mask = ~(words_in_card - 1);\n+  min_size = (min_size + words_in_card - 1) & align_mask;\n+  word_size = (word_size + words_in_card - 1) & align_mask;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -160,7 +160,0 @@\n-#ifdef ASSERT\n-  size_t live_bytes = new_live_data * HeapWordSize;\n-  size_t used_bytes = used();\n-  assert(live_bytes <= used_bytes,\n-         \"%s Region \" SIZE_FORMAT \" can't have more live data than used: \" SIZE_FORMAT \", \" SIZE_FORMAT \" after adding \" SIZE_FORMAT,\n-         affiliation_name(), index(), live_bytes, used_bytes, s * HeapWordSize);\n-#endif\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.inline.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -3,1 +3,0 @@\n- * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahNMethod.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3,1 +3,0 @@\n- * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahNumberSeq.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3,1 +3,0 @@\n- * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahSTWMark.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3,1 +3,0 @@\n- * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahUnload.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3,1 +3,0 @@\n- * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVMOperations.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3,1 +3,0 @@\n- * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVMOperations.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3,1 +3,0 @@\n- * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahWorkerPolicy.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3,1 +3,0 @@\n- * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahWorkerPolicy.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -137,1 +137,1 @@\n- * @run main\/othervm -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ * @run main\/othervm\/timeout=300 -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestRetainObjects.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -147,1 +147,1 @@\n- * @run main\/othervm\/timeout=240 -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ * @run main\/othervm\/timeout=300 -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestSieveObjects.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -116,1 +116,1 @@\n- *      -Dprecise=false\n+ *      -Dprecise=false -Dmem.pool=Young\n@@ -144,10 +144,1 @@\n-    private static final String DEFAULT_POOL_NAME = \"Shenandoah\";\n-    private static final String YOUNG_GEN_POOL_NAME = \"Shenandoah Young Gen\";\n-\n-    private static MemoryUsage getUsage(Map<String, MemoryUsage> pools) {\n-        MemoryUsage usage = pools.get(DEFAULT_POOL_NAME);\n-        if (usage == null) {\n-            usage = pools.get(YOUNG_GEN_POOL_NAME);\n-        }\n-        return usage;\n-    }\n+    private static final String POOL_NAME = \"Young\".equals(System.getProperty(\"mem.pool\")) ? \"Shenandoah Young Gen\" : \"Shenandoah\";\n@@ -168,2 +159,2 @@\n-                    MemoryUsage before = getUsage(mapBefore);\n-                    MemoryUsage after = getUsage(mapAfter);\n+                    MemoryUsage before = mapBefore.get(POOL_NAME);\n+                    MemoryUsage after = mapAfter.get(POOL_NAME);\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/mxbeans\/TestChurnNotifications.java","additions":4,"deletions":13,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+\n@@ -63,1 +64,1 @@\n-    private static void allocate(String size) throws Exception {\n+    private static void allocate(String size, int multiplier) throws Exception {\n@@ -66,1 +67,1 @@\n-                work(1024 * 1024, 16);\n+                work(1024 * 1024, 16 * multiplier);\n@@ -69,1 +70,1 @@\n-                work(16 * 1024 * 1024, 1);\n+                work(16 * 1024 * 1024, multiplier);\n@@ -72,1 +73,1 @@\n-                work(1, 16 * 1024 * 1024);\n+                work(1, 16 * 1024 * 1024 * multiplier);\n@@ -80,2 +81,2 @@\n-        if (args.length > 1) {\n-            \/\/ Called from test, size is second argument\n+        if (args.length > 2) {\n+            \/\/ Called from test, size is second argument, heap requested is third\n@@ -83,1 +84,14 @@\n-            allocate(size);\n+            long spec_heap = Integer.parseInt(args[2]);\n+\n+            \/\/ The actual heap we get may be larger than the one we asked for\n+            \/\/ (particularly in the generational case)\n+            final long actual_heap = Runtime.getRuntime().maxMemory();\n+            int multiplier = 1;\n+            if (actual_heap > spec_heap) {\n+                \/\/ A suitable multiplier is used, so as to allocate an\n+                \/\/ amount appropriate to the larger actual heap size than what\n+                \/\/ was specified.\n+                multiplier = (int)((actual_heap + spec_heap - 1)\/spec_heap);\n+            }\n+\n+            allocate(size, multiplier);\n@@ -90,0 +104,1 @@\n+            int heap = 16*1024*1024;      \/\/ -Xmx16m\n@@ -94,1 +109,1 @@\n-                          \"test\", size);\n+                          \"test\", size, Integer.toString(heap));\n@@ -100,1 +115,1 @@\n-                          \"test\", size);\n+                          \"test\", size, Integer.toString(heap));\n@@ -104,0 +119,1 @@\n+            int heap = 1*1024*1024*1024;  \/\/ -Xmx1g\n@@ -108,1 +124,1 @@\n-                          \"test\", size);\n+                          \"test\", size, Integer.toString(heap));\n@@ -114,1 +130,1 @@\n-                          \"test\", size);\n+                          \"test\", size, Integer.toString(heap));\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/oom\/TestAllocOutOfMemory.java","additions":27,"deletions":11,"binary":false,"changes":38,"status":"modified"}]}