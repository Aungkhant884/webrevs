{"files":[{"patch":"@@ -75,0 +75,14 @@\n+class ShenandoahGlobalCoalesceAndFill : public ShenandoahHeapRegionClosure {\n+ public:\n+  virtual void heap_region_do(ShenandoahHeapRegion* region) override {\n+    \/\/ old region is not in the collection set and was not immediately trashed\n+    if (region->is_old() && region->is_active() && !region->is_humongous()) {\n+      region->oop_fill_and_coalesce();\n+    }\n+  }\n+\n+  virtual bool is_thread_safe() override {\n+    return true;\n+  }\n+};\n+\n@@ -153,0 +167,4 @@\n+  if (heap->mode()->is_generational() && _generation->generation_mode() == GLOBAL) {\n+    entry_global_coalesce_and_fill();\n+  }\n+\n@@ -242,1 +260,2 @@\n-  if (ShenandoahHeap::heap()->mode()->is_generational() && (_generation->generation_mode() == YOUNG)) {\n+  if (ShenandoahHeap::heap()->mode()->is_generational()\n+    && (_generation->generation_mode() == YOUNG || (_generation->generation_mode() == GLOBAL && ShenandoahVerify))) {\n@@ -244,1 +263,2 @@\n-    \/\/ to the read-card-table.\n+    \/\/ to the read-card-table. The remembered sets are also swapped for GLOBAL collections\n+    \/\/ so that the verifier works with the correct copy of the card table when verifying.\n@@ -482,0 +502,15 @@\n+void ShenandoahConcurrentGC::entry_global_coalesce_and_fill() {\n+  ShenandoahHeap* const heap = ShenandoahHeap::heap();\n+\n+  const char* msg = \"Coalescing and filling old regions in global collect\";\n+  ShenandoahConcurrentPhase gc_phase(msg, ShenandoahPhaseTimings::coalesce_and_fill);\n+\n+  TraceCollectorStats tcs(heap->monitoring_support()->concurrent_collection_counters());\n+  EventMark em(\"%s\", msg);\n+  ShenandoahWorkerScope scope(heap->workers(),\n+                              ShenandoahWorkerPolicy::calc_workers_for_conc_marking(),\n+                              \"concurrent coalesce and fill\");\n+\n+  op_global_coalesce_and_fill();\n+}\n+\n@@ -1030,0 +1065,6 @@\n+void ShenandoahConcurrentGC::op_global_coalesce_and_fill() {\n+  ShenandoahHeap* const heap = ShenandoahHeap::heap();\n+  ShenandoahGlobalCoalesceAndFill coalesce;\n+  heap->parallel_heap_region_iterate(&coalesce);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":43,"deletions":2,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -104,0 +104,1 @@\n+  void entry_global_coalesce_and_fill();\n@@ -123,0 +124,1 @@\n+  void op_global_coalesce_and_fill();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2202,6 +2202,1 @@\n-            \/\/ This code is only relevant to GLOBAL GC.  With OLD GC, all coalescing and filling is done before any relevant\n-            \/\/ evacuations.\n-\n-            \/\/ This is an old region in a global cycle.  Make sure that the next cycle does not iterate over dead objects\n-            \/\/ which haven't had their references updated.  This is not a promotion.\n-            r->global_oop_iterate_and_fill_dead(&cl);\n+            _heap->marked_object_oop_iterate(r, &cl, update_watermark);\n@@ -2598,1 +2593,0 @@\n-  ShenandoahMarkingContext* mark_context = marking_context();\n@@ -2605,2 +2599,2 @@\n-  if (doing_mixed_evacuations()) {\n-    ctx = mark_context;\n+  if (doing_mixed_evacuations() || active_generation()->generation_mode() == GLOBAL) {\n+    ctx = complete_marking_context();\n@@ -2615,1 +2609,1 @@\n-    if (r->is_old()) {\n+    if (r->is_old() && r->is_active()) {\n@@ -2629,1 +2623,1 @@\n-        if (!scanner->verify_registration(obj_addr, obj->size())) {\n+        if (!scanner->verify_registration(obj_addr, ctx)) {\n@@ -2634,2 +2628,2 @@\n-        HeapWord* t = r->top();\n-        while (obj_addr < t) {\n+        HeapWord* top = r->top();\n+        while (obj_addr < top) {\n@@ -2637,1 +2631,1 @@\n-          \/\/ ctx->is_marked() returns true if mark bit set (TAMS not relevant here)\n+          \/\/ ctx->is_marked() returns true if mark bit set (TAMS not relevant during init mark)\n@@ -2645,1 +2639,1 @@\n-            if (!scanner->verify_registration(obj_addr, obj->size())) {\n+            if (!scanner->verify_registration(obj_addr, ctx)) {\n@@ -2650,5 +2644,0 @@\n-          } \/\/ Else, this object is not live so we don't verify dirty cards contained therein.\n-\n-          if (ctx) {\n-            \/\/ TAMS not relevant here\n-            obj_addr = ctx->get_next_marked_addr(obj_addr, t);\n@@ -2656,1 +2645,3 @@\n-            obj_addr += obj->size();\n+            \/\/ This object is not live so we don'top verify dirty cards contained therein\n+            assert(ctx->top_at_mark_start(r) == top, \"Expect tams == top at start of mark.\");\n+            obj_addr = ctx->get_next_marked_addr(obj_addr, top);\n@@ -2684,1 +2675,1 @@\n-    if ((obj_addr < registration_watermark) && !scanner->verify_registration(obj_addr, obj->size())) {\n+    if ((obj_addr < registration_watermark) && !scanner->verify_registration(obj_addr, ctx)) {\n@@ -2701,1 +2692,1 @@\n-        if ((obj_addr < registration_watermark) && !scanner->verify_registration(obj_addr, obj->size())) {\n+        if ((obj_addr < registration_watermark) && !scanner->verify_registration(obj_addr, ctx)) {\n@@ -2705,11 +2696,0 @@\n-      } \/\/ Else, this object is not live so we don't verify dirty cards contained therein.\n-\n-      if (ctx) {\n-        ShenandoahHeapRegion* r = heap_region_containing(obj_addr);\n-        HeapWord* tams = ctx->top_at_mark_start(r);\n-        if (obj_addr >= tams) {\n-          obj_addr += obj->size();\n-        } else {\n-          obj_addr = ctx->get_next_marked_addr(obj_addr, tams);\n-        }\n-      } else {\n@@ -2717,0 +2697,4 @@\n+      } else {\n+        \/\/ This object is not live so we don't verify dirty cards contained therein\n+        HeapWord* tams = ctx->top_at_mark_start(r);\n+        obj_addr = ctx->get_next_marked_addr(obj_addr, tams);\n@@ -2749,2 +2733,2 @@\n-  if (doing_mixed_evacuations()) {\n-    ctx = marking_context();\n+  if (doing_mixed_evacuations() || active_generation()->generation_mode() == GLOBAL) {\n+    ctx = complete_marking_context();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":20,"deletions":36,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -444,3 +444,1 @@\n-  \/\/ Expect this to be invoked only from within threads perfoming old-gen GC, and expect\n-  \/\/ old-gen marking to be completed before these threads invoke this service.\n-  assert(heap->active_generation()->generation_mode() == OLD, \"sanity\");\n+  \/\/ Expect marking to be completed before these threads invoke this service.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -275,0 +275,1 @@\n+    ShenandoahHeap* heap = ShenandoahHeap::heap();\n@@ -276,1 +277,1 @@\n-    shenandoah_assert_not_in_cset_except(p, obj, ShenandoahHeap::heap()->cancelled_gc());\n+    shenandoah_assert_not_in_cset_except(p, obj, heap->cancelled_gc());\n@@ -280,1 +281,1 @@\n-      if (ShenandoahHeap::heap()->mode()->is_generational()) {\n+      if (heap->mode()->is_generational()) {\n@@ -286,3 +287,1 @@\n-        \/\/\n-        if ((GENERATION == YOUNG) && ShenandoahHeap::heap()->is_in(p) && ShenandoahHeap::heap()->is_in_old(p)) {\n-          RememberedScanner* scanner = ShenandoahHeap::heap()->card_scan();\n+        if (GENERATION == YOUNG && heap->is_in_old(p)) {\n@@ -290,4 +289,2 @@\n-          ShenandoahHeap::heap()->mark_card_as_dirty((HeapWord*)p);\n-        } else if ((GENERATION == GLOBAL) && in_generation<YOUNG>(obj) &&\n-                   ShenandoahHeap::heap()->is_in(p) && ShenandoahHeap::heap()->is_in_old(p)) {\n-          RememberedScanner* scanner = ShenandoahHeap::heap()->card_scan();\n+          heap->mark_card_as_dirty((HeapWord*)p);\n+        } else if (GENERATION == GLOBAL && heap->is_in_old(p) && heap->is_in_young(obj)) {\n@@ -295,1 +292,1 @@\n-          ShenandoahHeap::heap()->mark_card_as_dirty((HeapWord*)p);\n+          heap->mark_card_as_dirty((HeapWord*)p);\n@@ -306,2 +303,2 @@\n-      assert(ShenandoahHeap::heap()->is_in_young(obj), \"Expected young object.\");\n-      ShenandoahHeap::heap()->mark_card_as_dirty(p);\n+      assert(heap->is_in_young(obj), \"Expected young object.\");\n+      heap->mark_card_as_dirty(p);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMark.inline.hpp","additions":9,"deletions":12,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -54,2 +54,0 @@\n-    ShenandoahHeap* heap = ShenandoahHeap::heap();\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGC.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -223,0 +223,1 @@\n+class ShenandoahMarkingContext;\n@@ -955,1 +956,1 @@\n-  bool verify_registration(HeapWord* address, size_t size_in_words);\n+  bool verify_registration(HeapWord* address, ShenandoahMarkingContext* ctx);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -472,1 +472,1 @@\n-ShenandoahScanRemembered<RememberedSet>::verify_registration(HeapWord* address, size_t size_in_words) {\n+ShenandoahScanRemembered<RememberedSet>::verify_registration(HeapWord* address, ShenandoahMarkingContext* ctx) {\n@@ -481,7 +481,0 @@\n-  ShenandoahMarkingContext* ctx;\n-\n-  if (heap->doing_mixed_evacuations()) {\n-    ctx = heap->marking_context();\n-  } else {\n-    ctx = nullptr;\n-  }\n@@ -496,1 +489,1 @@\n-      ShenandoahHeapRegion* r = heap->heap_region_containing(base_addr + offset);\n+      ShenandoahHeapRegion* r = heap->heap_region_containing(obj);\n@@ -498,5 +491,1 @@\n-      if (base_addr + offset >= tams) {\n-        offset += obj->size();\n-      } else {\n-        offset = ctx->get_next_marked_addr(base_addr + offset, tams) - base_addr;\n-      }\n+      offset = ctx->get_next_marked_addr(base_addr + offset, tams) - base_addr;\n@@ -524,1 +513,0 @@\n-      HeapWord* obj_addr = base_addr + offset;\n@@ -540,4 +528,6 @@\n-    \/\/ If there is a following object registered, it should begin where this object ends.\n-    if ((base_addr + offset < _rs->whole_heap_end()) && _scc->has_object(end_card_index) &&\n-        ((addr_for_card_index(end_card_index) + _scc->get_first_start(end_card_index)) != (base_addr + offset))) {\n-      return false;\n+    if (end_card_index > index) {\n+      \/\/ If there is a following object registered on the next card, it should begin where this object ends.\n+      if ((base_addr + offset < _rs->whole_heap_end()) && _scc->has_object(end_card_index) &&\n+          ((addr_for_card_index(end_card_index) + _scc->get_first_start(end_card_index)) != (base_addr + offset))) {\n+        return false;\n+      }\n@@ -553,2 +543,2 @@\n-    \/\/ This is a mixed evacuation: rely on mark bits to identify which objects need to be properly registered\n-\n+    \/\/ This is a mixed evacuation or a global collect: rely on mark bits to identify which objects need to be properly registered\n+    assert(!ShenandoahHeap::heap()->is_concurrent_old_mark_in_progress(), \"Cannot rely on mark context here.\");\n@@ -556,2 +546,3 @@\n-    \/\/ should represents this object.  Otherwise, last_offset is a don't care.\n-    HeapWord* end_of_interest = base_addr + max_offset;\n+    \/\/ should represent this object.  Otherwise, last_offset is a don't care.\n+    ShenandoahHeapRegion* region = heap->heap_region_containing(base_addr + offset);\n+    HeapWord* tams = ctx->top_at_mark_start(region);\n@@ -559,2 +550,0 @@\n-      HeapWord* obj_addr = base_addr + offset;\n-      oop obj = cast_to_oop(base_addr + offset);\n@@ -562,2 +551,8 @@\n-      offset = ctx->get_next_marked_addr(base_addr + offset, end_of_interest) - base_addr;\n-    } while (offset < max_offset);\n+      oop obj = cast_to_oop(base_addr + offset);\n+      if (ctx->is_marked(obj)) {\n+        offset += obj->size();\n+      } else {\n+        offset = ctx->get_next_marked_addr(base_addr + offset, tams) - base_addr;\n+        \/\/ offset will be zero if no objects are marked in this card.\n+      }\n+    } while (offset > 0 && offset < max_offset);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.inline.hpp","additions":22,"deletions":27,"binary":false,"changes":49,"status":"modified"}]}