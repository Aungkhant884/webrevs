{"files":[{"patch":"@@ -2617,1 +2617,1 @@\n-    if (r->is_old()) {\n+    if (r->is_old() && r->is_active()) {\n@@ -2636,4 +2636,5 @@\n-        HeapWord* t = r->top();\n-        while (obj_addr < t) {\n-          oop obj = oop(obj_addr);\n-          \/\/ ctx->is_marked() returns true if mark bit set or if obj above TAMS.\n+        HeapWord* top = r->top();\n+\n+        while (obj_addr < top) {\n+          oop obj = cast_to_oop(obj_addr);\n+          \/\/ ctx->is_marked() returns true if mark bit set (TAMS not relevant during init mark)\n@@ -2653,8 +2654,3 @@\n-            \/\/ This object is not live so we don't verify dirty cards contained therein\n-            ShenandoahHeapRegion* r = heap_region_containing(obj_addr);\n-            HeapWord* tams = ctx->top_at_mark_start(r);\n-            if (obj_addr >= tams) {\n-              obj_addr += obj->size();\n-            } else {\n-              obj_addr = ctx->get_next_marked_addr(obj_addr, tams);\n-            }\n+            \/\/ This object is not live so we don'top verify dirty cards contained therein\n+            assert(ctx->top_at_mark_start(r) == top, \"Expect tams == top at start of mark.\");\n+            obj_addr = ctx->get_next_marked_addr(obj_addr, top);\n@@ -2712,1 +2708,0 @@\n-        ShenandoahHeapRegion* r = heap_region_containing(obj_addr);\n@@ -2714,5 +2709,1 @@\n-        if (obj_addr >= tams) {\n-          obj_addr += obj->size();\n-        } else {\n-          obj_addr = ctx->get_next_marked_addr(obj_addr, tams);\n-        }\n+        obj_addr = ctx->get_next_marked_addr(obj_addr, tams);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":10,"deletions":19,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -484,1 +484,1 @@\n-    oop obj = oop(base_addr + offset);\n+    oop obj = cast_to_oop(base_addr + offset);\n@@ -489,1 +489,1 @@\n-      ShenandoahHeapRegion* r = heap->heap_region_containing(base_addr + offset);\n+      ShenandoahHeapRegion* r = heap->heap_region_containing(obj);\n@@ -491,5 +491,1 @@\n-      if (base_addr + offset >= tams) {\n-        offset += obj->size();\n-      } else {\n-        offset = ctx->get_next_marked_addr(base_addr + offset, tams) - base_addr;\n-      }\n+      offset = ctx->get_next_marked_addr(base_addr + offset, tams) - base_addr;\n@@ -547,2 +543,2 @@\n-    \/\/ This is a mixed evacuation: rely on mark bits to identify which objects need to be properly registered\n-\n+    \/\/ This is a mixed evacuation or a global collect: rely on mark bits to identify which objects need to be properly registered\n+    assert(!ShenandoahHeap::heap()->is_concurrent_old_mark_in_progress(), \"Cannot rely on mark context here.\");\n@@ -551,0 +547,2 @@\n+    ShenandoahHeapRegion* region = heap->heap_region_containing(base_addr + offset);\n+    HeapWord* tams = ctx->top_at_mark_start(region);\n@@ -554,2 +552,0 @@\n-      ShenandoahHeapRegion* region = heap->heap_region_containing(obj);\n-      HeapWord* tams = ctx->top_at_mark_start(region);\n@@ -560,4 +556,1 @@\n-        if (offset == 0) {\n-          \/\/  no objects marked in this card\n-          break;\n-        }\n+        \/\/ offset will be zero if no objects are marked in this card.\n@@ -565,1 +558,1 @@\n-    } while (offset < max_offset);\n+    } while (offset > 0 && offset < max_offset);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.inline.hpp","additions":9,"deletions":16,"binary":false,"changes":25,"status":"modified"}]}