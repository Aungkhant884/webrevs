{"files":[{"patch":"@@ -184,0 +184,1 @@\n+      region->reset_coalesce_and_fill_boundary();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -75,0 +75,15 @@\n+class ShenandoahGlobalCoalesceAndFill : public ShenandoahHeapRegionClosure {\n+ public:\n+  virtual void heap_region_do(ShenandoahHeapRegion* region) override {\n+    \/\/ old region is not in the collection set and was not immediately trashed\n+    if (region->is_old() && region->is_active() && !region->is_humongous()) {\n+      bool result = region->oop_fill_and_coalesce();\n+      assert(result = true, \"Do not preempt or cancel fill and coalesce during GLOBAL gc\");\n+    }\n+  }\n+\n+  virtual bool is_thread_safe() override {\n+    return true;\n+  }\n+};\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -211,3 +211,3 @@\n-      } else if (heap->is_concurrent_old_mark_in_progress()) {\n-        \/\/ Nobody asked us to do anything, but we have an old generation mark\n-        \/\/ in progress, so resume working on that.\n+      } else if (heap->is_concurrent_old_mark_in_progress() || heap->is_concurrent_prep_for_mixed_evacuation_in_progress()) {\n+        \/\/ Nobody asked us to do anything, but we have an old-generation mark or old-generation preparation for\n+        \/\/ mixed evacuation in progress, so resume working on that.\n@@ -510,1 +510,4 @@\n-  assert(ShenandoahHeap::heap()->is_concurrent_old_mark_in_progress(), \"Old mark should be in progress\");\n+\n+  assert(ShenandoahHeap::heap()->is_concurrent_old_mark_in_progress() ||\n+         ShenandoahHeap::heap()->is_concurrent_prep_for_mixed_evacuation_in_progress(),\n+         \"Old mark or mixed-evac prep should be in progress\");\n@@ -519,4 +522,3 @@\n-\n-  \/\/ We can only really tolerate being cancelled during concurrent\n-  \/\/ marking. This flag here (passed by reference) is used to control\n-  \/\/ precisely where the regulator is allowed to cancel a GC.\n+  \/\/ We can only tolerate being cancelled during concurrent marking or during preparation for mixed\n+  \/\/ evacuation. This flag here (passed by reference) is used to control precisely where the regulator\n+  \/\/ is allowed to cancel a GC.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -167,1 +167,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahDegeneratedGC.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -174,0 +174,4 @@\n+\n+    \/\/ Any OLD region allocated during concurrent coalesce-and-fill does not need to be coalesced and filled.\n+    \/\/ This code is only necessary if req.affiliation() is old, but harmless if not.\n+    r->finish_coalesce_and_fill();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -504,0 +504,1 @@\n+  _prep_for_mixed_evac_in_progress(false),\n@@ -1924,0 +1925,10 @@\n+void ShenandoahHeap::set_concurrent_prep_for_mixed_evacuation_in_progress(bool in_progress) {\n+  \/\/ Unlike other set-gc-state functions, this may happen outside safepoint.\n+  \/\/ Is only set and queried by control thread, so no coherence issues.\n+  _prep_for_mixed_evac_in_progress = in_progress;\n+}\n+\n+bool ShenandoahHeap::is_concurrent_prep_for_mixed_evacuation_in_progress() {\n+  return _prep_for_mixed_evac_in_progress;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -154,0 +154,1 @@\n+  bool _prep_for_mixed_evac_in_progress; \/\/ true iff we are concurrently coalescing and filling old-gen HeapRegions\n@@ -354,0 +355,1 @@\n+  void set_concurrent_prep_for_mixed_evacuation_in_progress(bool cond);\n@@ -371,0 +373,1 @@\n+  bool is_concurrent_prep_for_mixed_evacuation_in_progress();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -428,3 +428,5 @@\n-\/\/ oop_iterate without closure\n-void ShenandoahHeapRegion::oop_fill_and_coalesce() {\n-  HeapWord* obj_addr = bottom();\n+\/\/ oop_iterate without closure, return true if completed without cancellation\n+bool ShenandoahHeapRegion::oop_fill_and_coalesce() {\n+  HeapWord* obj_addr = resume_coalesce_and_fill();\n+  \/\/ Consider yielding to cancel\/preemption request after this many coalesce operations (skip marked, or coalesce free).\n+  const size_t preemption_stride = 128;\n@@ -433,1 +435,4 @@\n-  if (!is_active()) return;\n+  if (!is_active()) {\n+    finish_coalesce_and_fill();\n+    return true;\n+  }\n@@ -447,0 +452,1 @@\n+  size_t ops_before_preempt_check = preemption_stride;\n@@ -461,0 +467,7 @@\n+    if (!ops_before_preempt_check--) {\n+      if (heap->cancelled_gc()) {\n+        suspend_coalesce_and_fill(obj_addr);\n+        return false;\n+      }\n+      ops_before_preempt_check = preemption_stride;\n+    }\n@@ -462,0 +475,3 @@\n+  \/\/ Mark that this region has been coalesced and filled\n+  finish_coalesce_and_fill();\n+  return true;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.cpp","additions":20,"deletions":4,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -243,0 +243,1 @@\n+  HeapWord* _coalesce_and_fill_boundary; \/\/ for old regions not selected as collection set candidates.\n@@ -371,0 +372,20 @@\n+  inline void reset_coalesce_and_fill_boundary() {\n+    _coalesce_and_fill_boundary = _bottom;\n+  }\n+\n+  inline void finish_coalesce_and_fill() {\n+    _coalesce_and_fill_boundary = _end;\n+  }\n+\n+  inline void suspend_coalesce_and_fill(HeapWord* next_focus) {\n+    _coalesce_and_fill_boundary = next_focus;\n+  }\n+\n+  inline HeapWord* resume_coalesce_and_fill() {\n+    return _coalesce_and_fill_boundary;\n+  }\n+\n+  inline bool coalesce_and_fill_is_done() {\n+    return _coalesce_and_fill_boundary >= _top;\n+  }\n+\n@@ -372,2 +393,3 @@\n-  \/\/ This is used by old-gen GC following concurrent marking to make old-gen HeapRegions parseable.\n-  void oop_fill_and_coalesce();\n+  \/\/ This is used by old-gen GC following concurrent marking to make old-gen HeapRegions parseable.  Return true iff\n+  \/\/ region is completely coalesced and filled.  Returns false if cancelled before task is complete.\n+  bool oop_fill_and_coalesce();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.hpp","additions":24,"deletions":2,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -100,1 +100,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegionCounters.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -43,0 +43,2 @@\n+  ShenandoahConcurrentGC* _old_gc;\n+  volatile bool _is_preempted;\n@@ -45,2 +47,2 @@\n-  ShenandoahConcurrentCoalesceAndFillTask(uint nworkers,\n-                                          ShenandoahHeapRegion** coalesce_and_fill_region_array, uint region_count) :\n+  ShenandoahConcurrentCoalesceAndFillTask(uint nworkers, ShenandoahHeapRegion** coalesce_and_fill_region_array,\n+                                          uint region_count, ShenandoahConcurrentGC* old_gc) :\n@@ -50,1 +52,3 @@\n-    _coalesce_and_fill_region_count(region_count) {\n+    _coalesce_and_fill_region_count(region_count),\n+    _old_gc(old_gc),\n+    _is_preempted(false) {\n@@ -56,3 +60,7 @@\n-      if (!r->is_humongous())\n-        r->oop_fill_and_coalesce();\n-      else {\n+      if (!r->is_humongous()) {\n+        if (!r->oop_fill_and_coalesce()) {\n+          \/\/ Coalesce and fill has been preempted\n+          Atomic::store(&_is_preempted, true);\n+          return;\n+        }\n+      } else {\n@@ -63,0 +71,5 @@\n+\n+  \/\/ Value returned from is_completed() is only valid after all worker thread have terminated.\n+  bool is_completed() {\n+    return !Atomic::load(&_is_preempted);\n+  }\n@@ -118,8 +131,11 @@\n-  \/\/ Continue concurrent mark, do not reset regions, do not mark roots, do not collect $200.\n-  _allow_preemption.set();\n-  entry_mark();\n-  if (!_allow_preemption.try_unset()) {\n-    \/\/ The regulator thread has unset the preemption guard. That thread will shortly cancel\n-    \/\/ the gc, but the control thread is now racing it. Wait until this thread sees the cancellation.\n-    while (!heap->cancelled_gc()) {\n-      SpinPause();\n+  if (!heap->is_concurrent_prep_for_mixed_evacuation_in_progress()) {\n+    \/\/ Skip over the initial phases of old collect if we're resuming mixed evacuation preparation.\n+    \/\/ Continue concurrent mark, do not reset regions, do not mark roots, do not collect $200.\n+    _allow_preemption.set();\n+    entry_mark();\n+    if (!_allow_preemption.try_unset()) {\n+      \/\/ The regulator thread has unset the preemption guard. That thread will shortly cancel\n+      \/\/ the gc, but the control thread is now racing it. Wait until this thread sees the cancellation.\n+      while (!heap->cancelled_gc()) {\n+        SpinPause();\n+      }\n@@ -127,1 +143,0 @@\n-  }\n@@ -129,3 +144,3 @@\n-  if (check_cancellation_and_abort(ShenandoahDegenPoint::_degenerated_mark)) {\n-    return false;\n-  }\n+    if (check_cancellation_and_abort(ShenandoahDegenPoint::_degenerated_mark)) {\n+      return false;\n+    }\n@@ -133,2 +148,2 @@\n-  \/\/ Complete marking under STW\n-  vmop_entry_final_mark();\n+    \/\/ Complete marking under STW\n+    vmop_entry_final_mark();\n@@ -136,3 +151,3 @@\n-  \/\/ We aren't dealing with old generation evacuation yet. Our heuristic\n-  \/\/ should not have built a cset in final mark.\n-  assert(!heap->is_evacuation_in_progress(), \"Old gen evacuations are not supported\");\n+    \/\/ We aren't dealing with old generation evacuation yet. Our heuristic\n+    \/\/ should not have built a cset in final mark.\n+    assert(!heap->is_evacuation_in_progress(), \"Old gen evacuations are not supported\");\n@@ -140,5 +155,5 @@\n-  \/\/ Process weak roots that might still point to regions that would be broken by cleanup\n-  if (heap->is_concurrent_weak_root_in_progress()) {\n-    entry_weak_refs();\n-    entry_weak_roots();\n-  }\n+    \/\/ Process weak roots that might still point to regions that would be broken by cleanup\n+    if (heap->is_concurrent_weak_root_in_progress()) {\n+      entry_weak_refs();\n+      entry_weak_roots();\n+    }\n@@ -146,3 +161,3 @@\n-  \/\/ Final mark might have reclaimed some immediate garbage, kick cleanup to reclaim\n-  \/\/ the space. This would be the last action if there is nothing to evacuate.\n-  entry_cleanup_early();\n+    \/\/ Final mark might have reclaimed some immediate garbage, kick cleanup to reclaim\n+    \/\/ the space. This would be the last action if there is nothing to evacuate.\n+    entry_cleanup_early();\n@@ -150,4 +165,4 @@\n-  {\n-    ShenandoahHeapLocker locker(heap->lock());\n-    heap->free_set()->log_status();\n-  }\n+    {\n+      ShenandoahHeapLocker locker(heap->lock());\n+      heap->free_set()->log_status();\n+    }\n@@ -155,6 +170,10 @@\n-  \/\/ TODO: Old marking doesn't support class unloading yet\n-  \/\/ Perform concurrent class unloading\n-  \/\/ if (heap->unload_classes() &&\n-  \/\/     heap->is_concurrent_weak_root_in_progress()) {\n-  \/\/   entry_class_unloading();\n-  \/\/ }\n+\n+    \/\/ TODO: Old marking doesn't support class unloading yet\n+    \/\/ Perform concurrent class unloading\n+    \/\/ if (heap->unload_classes() &&\n+    \/\/     heap->is_concurrent_weak_root_in_progress()) {\n+    \/\/   entry_class_unloading();\n+    \/\/ }\n+\n+    heap->set_concurrent_prep_for_mixed_evacuation_in_progress(true);\n+  }\n@@ -168,1 +187,6 @@\n-  entry_coalesce_and_fill();\n+\n+  _allow_preemption.set();\n+\n+  if (check_cancellation_and_abort(ShenandoahDegenPoint::_degenerated_evac)) {\n+    return false;\n+  }\n@@ -176,0 +200,17 @@\n+\n+  if (heap->is_concurrent_prep_for_mixed_evacuation_in_progress()) {\n+    if (!entry_coalesce_and_fill()) {\n+      \/\/ If old-gen degenerates instead of resuming, we'll just start up an out-of-cycle degenerated GC.\n+      \/\/ This should be a rare event.  Normally, we'll resume the coalesce-and-fill effort after the\n+      \/\/ preempting young-gen GC finishes.\n+      check_cancellation_and_abort(ShenandoahDegenPoint::_degenerated_outside_cycle);\n+      return false;\n+    }\n+  }\n+  if (!_allow_preemption.try_unset()) {\n+    \/\/ The regulator thread has unset the preemption guard. That thread will shortly cancel\n+    \/\/ the gc, but the control thread is now racing it. Wait until this thread sees the cancellation.\n+    while (!heap->cancelled_gc()) {\n+      SpinPause();\n+    }\n+  }\n@@ -184,1 +225,1 @@\n-void ShenandoahOldGC::op_coalesce_and_fill() {\n+bool ShenandoahOldGC::op_coalesce_and_fill() {\n@@ -186,1 +227,1 @@\n-\n+  ShenandoahOldHeuristics* old_heuristics = heap->old_heuristics();\n@@ -191,2 +232,1 @@\n-\n-  ShenandoahOldHeuristics* old_heuristics = heap->old_heuristics();\n+  log_debug(gc)(\"Starting (or resuming) coalesce-and-fill of old heap regions\");\n@@ -196,7 +236,1 @@\n-  ShenandoahConcurrentCoalesceAndFillTask task(nworkers, _coalesce_and_fill_region_array, coalesce_and_fill_regions_count);\n-\n-\n-  \/\/ TODO:  We need to implement preemption of coalesce and fill.  If young-gen wants to run while we're working on this,\n-  \/\/ we should preempt this code and then resume it after young-gen has finished.  This requires that we \"remember\" the state\n-  \/\/ of each worker thread so it can be resumed where it left off.  Note that some worker threads may have processed more regions\n-  \/\/ than others at the time of preemption.\n+  ShenandoahConcurrentCoalesceAndFillTask task(nworkers, _coalesce_and_fill_region_array, coalesce_and_fill_regions_count, this);\n@@ -205,0 +239,9 @@\n+  if (task.is_completed()) {\n+    \/\/ Remember that we're done with coalesce-and-fill.\n+    heap->set_concurrent_prep_for_mixed_evacuation_in_progress(false);\n+    return true;\n+  } else {\n+    log_debug(gc)(\"Suspending coalesce-and-fill of old heap regions\");\n+    \/\/ Otherwise, we got preempted before the work was done.\n+    return false;\n+  }\n@@ -207,1 +250,1 @@\n-void ShenandoahOldGC::entry_coalesce_and_fill() {\n+bool ShenandoahOldGC::entry_coalesce_and_fill() {\n@@ -220,1 +263,1 @@\n-  op_coalesce_and_fill();\n+  return op_coalesce_and_fill();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGC.cpp","additions":98,"deletions":55,"binary":false,"changes":153,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-  void entry_coalesce_and_fill();\n+  bool entry_coalesce_and_fill();\n@@ -48,1 +48,1 @@\n-  void op_coalesce_and_fill();\n+  bool op_coalesce_and_fill();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGC.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-  if (_old_gen_task_queues != nullptr && in_progress) {\n+  if (_old_gen_task_queues != nullptr && in_progress && !heap->is_concurrent_prep_for_mixed_evacuation_in_progress()) {\n@@ -48,1 +48,3 @@\n-    \/\/ the old generation marking is still in progress.\n+    \/\/ the old generation marking is still in progress, unless it's not.\n+    \/\/ In the case that old-gen preparation for mixed evacuation has been\n+    \/\/ preempted, we do not want to set concurrent old mark to be in progress.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahYoungGeneration.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"}]}