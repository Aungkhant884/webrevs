{"files":[{"patch":"@@ -125,1 +125,1 @@\n-  inline void arraycopy_marking(T* src, T* dst, size_t count);\n+  inline void arraycopy_marking(T* src, T* dst, size_t count, bool is_old_marking);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -408,1 +408,1 @@\n-    arraycopy_marking(src, dst, count);\n+    arraycopy_marking(src, dst, count, false);\n@@ -425,1 +425,1 @@\n-      arraycopy_marking(src, dst, count);\n+      arraycopy_marking(src, dst, count, true);\n@@ -431,1 +431,1 @@\n-void ShenandoahBarrierSet::arraycopy_marking(T* src, T* dst, size_t count) {\n+void ShenandoahBarrierSet::arraycopy_marking(T* src, T* dst, size_t count, bool is_old_marking) {\n@@ -433,3 +433,46 @@\n-  T* array = ShenandoahSATBBarrier ? dst : src;\n-  if (!_heap->marking_context()->allocated_after_mark_start(reinterpret_cast<HeapWord*>(array))) {\n-    arraycopy_work<T, false, false, true>(array, count);\n+  \/*\n+   * Note that an old-gen object is considered live if it is live at the start of OLD marking or if it is promoted\n+   * following the start of OLD marking.\n+   *\n+   * 1. Every object promoted following the start of OLD marking will be above TAMS within its old-gen region\n+   * 2. Every object live at the start of OLD marking will be referenced from a \"root\" or it will be referenced from\n+   *    another live OLD-gen object.  With regards to old-gen, roots include stack locations and all of live young-gen.\n+   *    All root references to old-gen are identified during a bootstrap young collection.  All references from other\n+   *    old-gen objects will be marked during the traversal of all old objects, or will be marked by the SATB barrier.\n+   *\n+   * During old-gen marking (which is interleaved with young-gen collections), call arraycopy_work() if:\n+   *\n+   * 1. The overwritten array resides in old-gen and it is below TAMS within its old-gen region\n+   * 2. Do not call arraycopy_work for any array residing in young-gen because young-gen collection is idle at this time\n+   *\n+   * During young-gen marking, call arraycopy_work() if:\n+   *\n+   * 1. The overwritten array resides in young-gen and is below TAMS within its young-gen region\n+   * 2. Additionally, if array resides in old-gen, regardless of its relationship to TAMS because this old-gen array\n+   *    may hold references to young-gen\n+   *\/\n+  if (ShenandoahSATBBarrier) {\n+    T* array = dst;\n+    HeapWord* array_addr = reinterpret_cast<HeapWord*>(array);\n+    if (is_old_marking) {\n+      \/\/ Generational, old marking\n+      assert(_heap->mode()->is_generational(), \"Invariant\");\n+      ShenandoahHeapRegion* r = _heap->heap_region_containing(array_addr);\n+      if (r->is_old() && (array_addr < _heap->marking_context()->top_at_mark_start(r))) {\n+        arraycopy_work<T, false, false, true>(array, count);\n+      }\n+    } else if (_heap->mode()->is_generational()) {\n+      \/\/ Generational, young marking\n+      ShenandoahHeapRegion* r = _heap->heap_region_containing(array);\n+      if (r->is_old() || !_heap->marking_context()->allocated_after_mark_start(array_addr)) {\n+        arraycopy_work<T, false, false, true>(array, count);\n+      }\n+    } else if (!_heap->marking_context()->allocated_after_mark_start(array_addr)) {\n+      \/\/ Non-generational, marking\n+      arraycopy_work<T, false, false, true>(array, count);\n+    }\n+  } else {\n+    T* array = src;\n+    if (!_heap->marking_context()->allocated_after_mark_start(reinterpret_cast<HeapWord*>(array))) {\n+      arraycopy_work<T, false, false, true>(array, count);\n+    }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.inline.hpp","additions":49,"deletions":6,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -325,0 +325,2 @@\n+\n+    phase5_epilog();\n@@ -1449,0 +1451,58 @@\n+}\n+\n+static void account_for_region(ShenandoahHeapRegion* r, size_t &region_count, size_t &region_usage, size_t &humongous_waste) {\n+  region_count++;\n+  region_usage += r->used();\n+  if (r->is_humongous_start()) {\n+    \/\/ For each humongous object, we take this path once regardless of how many regions it spans.\n+    HeapWord* obj_addr = r->bottom();\n+    oop obj = cast_to_oop(obj_addr);\n+    size_t word_size = obj->size();\n+    size_t region_size_words = ShenandoahHeapRegion::region_size_words();\n+    size_t overreach = word_size % region_size_words;\n+    if (overreach != 0) {\n+      humongous_waste += (region_size_words - overreach) * HeapWordSize;\n+    }\n+    \/\/ else, this humongous object aligns exactly on region size, so no waste.\n+  }\n+}\n+\n+void ShenandoahFullGC::phase5_epilog() {\n+  GCTraceTime(Info, gc, phases) time(\"Phase 5: Full GC epilog\", _gc_timer);\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  size_t num_regions = heap->num_regions();\n+  size_t young_usage = 0;\n+  size_t young_regions = 0;\n+  size_t young_humongous_waste = 0;\n+  size_t old_usage = 0;\n+  size_t old_regions = 0;\n+  size_t old_humongous_waste = 0;\n+  ShenandoahHeapRegion* r;\n+\n+  if (heap->mode()->is_generational()) {\n+    \/\/ TODO: We may be able remove code that recomputes generation usage after we fix the incremental updates to generation\n+    \/\/ usage that are scattered throughout the existing Full GC implementation.  There's an error in there somewhere that\n+    \/\/ has not yet been figured out.  Or maybe it is easier to just not try to do the generation accounting on the fly, keep\n+    \/\/ this code, and remove all of the other attempts to increase\/decrease affiliated regions, used, and humongous_waste.\n+    {\n+      ShenandoahGCPhase phase(ShenandoahPhaseTimings::full_gc_recompute_generation_usage);\n+      for (size_t i = 0; i < num_regions; i++) {\n+        switch (heap->region_affiliation(i)) {\n+          case ShenandoahRegionAffiliation::FREE:\n+            break;\n+          case ShenandoahRegionAffiliation::YOUNG_GENERATION:\n+            r = heap->get_region(i);\n+            account_for_region(r, young_regions, young_usage, young_humongous_waste);\n+            break;\n+          case ShenandoahRegionAffiliation::OLD_GENERATION:\n+            r = heap->get_region(i);\n+            account_for_region(r, old_regions, old_usage, old_humongous_waste);\n+            break;\n+          default:\n+            assert(false, \"Should not reach\");\n+        }\n+      }\n+      heap->old_generation()->establish_usage(old_regions, old_usage, old_humongous_waste);\n+      heap->young_generation()->establish_usage(young_regions, young_usage, young_humongous_waste);\n+    }\n+  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":60,"deletions":0,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -84,0 +84,1 @@\n+  void phase5_epilog();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -946,0 +946,7 @@\n+void ShenandoahGeneration::establish_usage(size_t num_regions, size_t num_bytes, size_t humongous_waste) {\n+  assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), \"must be at a safepoint\");\n+  _affiliated_region_count = num_regions;\n+  _used = num_bytes;\n+  \/\/ future improvement: _humongous_waste = humongous_waste;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -186,0 +186,2 @@\n+  void establish_usage(size_t num_regions, size_t num_bytes, size_t humongous_waste);\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -181,0 +181,1 @@\n+  f(full_gc_recompute_generation_usage,             \"    Recompute generation usage\")  \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahPhaseTimings.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}