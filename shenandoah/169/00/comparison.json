{"files":[{"patch":"@@ -39,0 +39,1 @@\n+  SHENANDOAH_ERGO_OVERRIDE_DEFAULT(NewRatio, 1);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/mode\/shenandoahGenerationalMode.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -347,1 +347,1 @@\n-      target_gen == YOUNG_GENERATION && ShenandoahPromoteTenuredObjects) {\n+      target_gen == YOUNG_GENERATION) {\n@@ -397,23 +397,22 @@\n-           if (ShenandoahUsePLAB) {\n-             PLAB* plab = ShenandoahThreadLocalData::plab(thread);\n-             if (plab != nullptr) {\n-               has_plab = true;\n-             }\n-             copy = allocate_from_plab(thread, size, is_promotion);\n-             if ((copy == nullptr) && (size < ShenandoahThreadLocalData::plab_size(thread)) &&\n-                 ShenandoahThreadLocalData::plab_retries_enabled(thread)) {\n-               \/\/ PLAB allocation failed because we are bumping up against the limit on old evacuation reserve or because\n-               \/\/ the requested object does not fit within the current plab but the plab still has an \"abundance\" of memory,\n-               \/\/ where abundance is defined as >= PLAB::min_size().  In the former case, we try resetting the desired\n-               \/\/ PLAB size and retry PLAB allocation to avoid cascading of shared memory allocations.\n-\n-               \/\/ In this situation, PLAB memory is precious.  We'll try to preserve our existing PLAB by forcing\n-               \/\/ this particular allocation to be shared.\n-               if (plab->words_remaining() < PLAB::min_size()) {\n-                 ShenandoahThreadLocalData::set_plab_size(thread, PLAB::min_size());\n-                 copy = allocate_from_plab(thread, size, is_promotion);\n-                 \/\/ If we still get nullptr, we'll try a shared allocation below.\n-                 if (copy == nullptr) {\n-                   \/\/ If retry fails, don't continue to retry until we have success (probably in next GC pass)\n-                   ShenandoahThreadLocalData::disable_plab_retries(thread);\n-                 }\n+\n+           PLAB* plab = ShenandoahThreadLocalData::plab(thread);\n+           if (plab != nullptr) {\n+             has_plab = true;\n+           }\n+           copy = allocate_from_plab(thread, size, is_promotion);\n+           if ((copy == nullptr) && (size < ShenandoahThreadLocalData::plab_size(thread)) &&\n+               ShenandoahThreadLocalData::plab_retries_enabled(thread)) {\n+             \/\/ PLAB allocation failed because we are bumping up against the limit on old evacuation reserve or because\n+             \/\/ the requested object does not fit within the current plab but the plab still has an \"abundance\" of memory,\n+             \/\/ where abundance is defined as >= PLAB::min_size().  In the former case, we try resetting the desired\n+             \/\/ PLAB size and retry PLAB allocation to avoid cascading of shared memory allocations.\n+\n+             \/\/ In this situation, PLAB memory is precious.  We'll try to preserve our existing PLAB by forcing\n+             \/\/ this particular allocation to be shared.\n+             if (plab->words_remaining() < PLAB::min_size()) {\n+               ShenandoahThreadLocalData::set_plab_size(thread, PLAB::min_size());\n+               copy = allocate_from_plab(thread, size, is_promotion);\n+               \/\/ If we still get nullptr, we'll try a shared allocation below.\n+               if (copy == nullptr) {\n+                 \/\/ If retry fails, don't continue to retry until we have success (probably in next GC pass)\n+                 ShenandoahThreadLocalData::disable_plab_retries(thread);\n@@ -421,1 +420,0 @@\n-               \/\/ else, copy still equals nullptr.  this causes shared allocation below, preserving this plab for future needs.\n@@ -423,0 +421,1 @@\n+             \/\/ else, copy still equals nullptr.  this causes shared allocation below, preserving this plab for future needs.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.inline.hpp","additions":24,"deletions":25,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -99,1 +99,1 @@\n-  product(uintx, ShenandoahOldGarbageThreshold, 25, EXPERIMENTAL,           \\\n+  product(uintx, ShenandoahOldGarbageThreshold, 10, EXPERIMENTAL,           \\\n@@ -155,1 +155,1 @@\n-  product(uintx, ShenandoahImmediateThreshold, 90, EXPERIMENTAL,            \\\n+  product(uintx, ShenandoahImmediateThreshold, 70, EXPERIMENTAL,            \\\n@@ -284,4 +284,0 @@\n-  product(bool, ShenandoahUsePLAB, true, DIAGNOSTIC,                        \\\n-          \"Use PLABs for object promotions with Shenandoah, \"               \\\n-          \"if in generational mode and UseTLAB is also set.\")               \\\n-                                                                            \\\n@@ -529,4 +525,0 @@\n-  product(bool, ShenandoahPromoteTenuredObjects, true, DIAGNOSTIC,          \\\n-          \"Turn on\/off evacuating individual tenured young objects \"        \\\n-          \" to the old generation.\")                                        \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoah_globals.hpp","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"}]}