{"files":[{"patch":"@@ -44,0 +44,14 @@\n+inline void assert_no_in_place_promotions() {\n+#ifdef ASSERT\n+  class ShenandoahNoInPlacePromotions : public ShenandoahHeapRegionClosure {\n+  public:\n+    void heap_region_do(ShenandoahHeapRegion *r) override {\n+      assert(r->get_top_before_promote() == nullptr,\n+             \"Region \" SIZE_FORMAT \" should not be ready for in-place promotion\", r->index());\n+    }\n+  } cl;\n+  ShenandoahHeap::heap()->heap_region_iterate(&cl);\n+#endif\n+}\n+\n+\n@@ -128,0 +142,4 @@\n+\n+  \/\/ There should be no regions configured for subsequent in-place-promotions carried over from the previous cycle.\n+  assert_no_in_place_promotions();\n+\n@@ -156,1 +174,0 @@\n-      r->save_top_before_promote();\n@@ -161,3 +178,6 @@\n-          \/\/ Fill the remnant memory within this region to assure no allocations prior to promote in place.  Otherwise,\n-          \/\/ newly allocated objects will not be parseable when promote in place tries to register them.  Furthermore, any\n-          \/\/ new allocations would not necessarily be eligible for promotion.  This addresses both issues.\n+          \/\/ No allocations from this region have been made during concurrent mark. It meets all the criteria\n+          \/\/ for in-place-promotion. Though we only need the value of top when we fill the end of the region,\n+          \/\/ we use this field to indicate that this region should be promoted in place during the evacuation\n+          \/\/ phase.\n+          r->save_top_before_promote();\n+\n@@ -167,0 +187,3 @@\n+            \/\/ Fill the remnant memory within this region to assure no allocations prior to promote in place.  Otherwise,\n+            \/\/ newly allocated objects will not be parseable when promote in place tries to register them.  Furthermore, any\n+            \/\/ new allocations would not necessarily be eligible for promotion.  This addresses both issues.\n@@ -171,1 +194,1 @@\n-            \/\/ allocations occuring within this region before the region is promoted in place.\n+            \/\/ allocations occurring within this region before the region is promoted in place.\n@@ -322,1 +345,1 @@\n-          if (region->garbage_before_padded_for_promote() < old_garbage_threshold) {\n+          if (region->get_top_before_promote() != nullptr) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.cpp","additions":29,"deletions":6,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -1274,3 +1274,5 @@\n-  ShenandoahHeap* heap = ShenandoahHeap::heap();\n-  if (heap->is_aging_cycle()) {\n-    ShenandoahMarkingContext* ctx = heap->complete_marking_context();\n+  ShenandoahHeap *heap = ShenandoahHeap::heap();\n+  heap->set_concurrent_weak_root_in_progress(false);\n+\n+  if (heap->mode()->is_generational()) {\n+    ShenandoahMarkingContext *ctx = heap->complete_marking_context();\n@@ -1285,1 +1287,1 @@\n-        } else {\n+        } else if (heap->is_aging_cycle()) {\n@@ -1291,2 +1293,0 @@\n-\n-  ShenandoahHeap::heap()->set_concurrent_weak_root_in_progress(false);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1721,1 +1721,5 @@\n-        } else if (r->is_regular() && (r->garbage_before_padded_for_promote() < old_garbage_threshold) && (r->get_top_before_promote() == tams)) {\n+        } else if (r->is_regular() && (r->get_top_before_promote() != nullptr)) {\n+          assert(r->garbage_before_padded_for_promote() < old_garbage_threshold,\n+                 \"Region \" SIZE_FORMAT \" has too much garbage for promotion\", r->index());\n+          assert(r->get_top_before_promote() == tams,\n+                 \"Region \" SIZE_FORMAT \" has been used for allocations before promotion\", r->index());\n@@ -2999,1 +3003,1 @@\n-    if (_is_generational && r->is_young()) {\n+    if (_is_generational && r->is_young() && r->is_active()) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -74,0 +74,1 @@\n+  _top_before_promoted(nullptr),\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -188,1 +188,0 @@\n-  size_t used_before_promote = byte_size(bottom(), get_top_before_promote());\n@@ -190,0 +189,1 @@\n+  size_t used_before_promote = byte_size(bottom(), get_top_before_promote());\n@@ -254,1 +254,0 @@\n-#ifdef ASSERT\n@@ -256,1 +255,0 @@\n-#endif\n@@ -260,1 +258,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.inline.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"}]}