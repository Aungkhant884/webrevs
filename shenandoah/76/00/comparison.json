{"files":[{"patch":"@@ -204,1 +204,1 @@\n-  log_debug(gc)(\"should_start_gc? available: \" SIZE_FORMAT \", soft_max_capacity: \" SIZE_FORMAT\n+  log_debug(gc)(\"should_start_gc (%s)? available: \" SIZE_FORMAT \", soft_max_capacity: \" SIZE_FORMAT\n@@ -206,1 +206,1 @@\n-                available, capacity, max_capacity, allocated);\n+                _generation->name(), available, capacity, max_capacity, allocated);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,322 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2021, Red Hat, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-\n-#include \"gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.hpp\"\n-#include \"gc\/shenandoah\/heuristics\/shenandoahAdaptiveOldHeuristics.hpp\"\n-#include \"gc\/shenandoah\/shenandoahCollectionSet.hpp\"\n-#include \"gc\/shenandoah\/shenandoahFreeSet.hpp\"\n-#include \"gc\/shenandoah\/shenandoahGeneration.hpp\"\n-#include \"gc\/shenandoah\/shenandoahHeapRegion.inline.hpp\"\n-#include \"logging\/log.hpp\"\n-#include \"logging\/logTag.hpp\"\n-#include \"utilities\/quickSort.hpp\"\n-\n-\/\/ These constants are used to adjust the margin of error for the moving\n-\/\/ average of the allocation rate and cycle time. The units are standard\n-\/\/ deviations.\n-const double ShenandoahAdaptiveOldHeuristics::FULL_PENALTY_SD = 0.2;\n-const double ShenandoahAdaptiveOldHeuristics::DEGENERATE_PENALTY_SD = 0.1;\n-\n-\/\/ These are used to decide if we want to make any adjustments at all\n-\/\/ at the end of a successful concurrent cycle.\n-const double ShenandoahAdaptiveOldHeuristics::LOWEST_EXPECTED_AVAILABLE_AT_END = -0.5;\n-const double ShenandoahAdaptiveOldHeuristics::HIGHEST_EXPECTED_AVAILABLE_AT_END = 0.5;\n-\n-\/\/ These values are the confidence interval expressed as standard deviations.\n-\/\/ At the minimum confidence level, there is a 25% chance that the true value of\n-\/\/ the estimate (average cycle time or allocation rate) is not more than\n-\/\/ MINIMUM_CONFIDENCE standard deviations away from our estimate. Similarly, the\n-\/\/ MAXIMUM_CONFIDENCE interval here means there is a one in a thousand chance\n-\/\/ that the true value of our estimate is outside the interval. These are used\n-\/\/ as bounds on the adjustments applied at the outcome of a GC cycle.\n-const double ShenandoahAdaptiveOldHeuristics::MINIMUM_CONFIDENCE = 0.319; \/\/ 25%\n-const double ShenandoahAdaptiveOldHeuristics::MAXIMUM_CONFIDENCE = 3.291; \/\/ 99.9%\n-\n-ShenandoahAdaptiveOldHeuristics::ShenandoahAdaptiveOldHeuristics(ShenandoahGeneration* generation) :\n-  ShenandoahOldHeuristics(generation),\n-  _margin_of_error_sd(ShenandoahAdaptiveInitialConfidence),\n-  _spike_threshold_sd(ShenandoahAdaptiveInitialSpikeThreshold),\n-  _last_trigger(OTHER) { }\n-\n-ShenandoahAdaptiveOldHeuristics::~ShenandoahAdaptiveOldHeuristics() {}\n-\n-void ShenandoahAdaptiveOldHeuristics::choose_collection_set_from_regiondata(ShenandoahCollectionSet* cset,\n-                                                                            RegionData* data, size_t size,\n-                                                                            size_t actual_free) {\n-  size_t garbage_threshold = ShenandoahHeapRegion::region_size_bytes() * ShenandoahGarbageThreshold \/ 100;\n-\n-  \/\/ The logic for cset selection in adaptive is as follows:\n-  \/\/\n-  \/\/   1. We cannot get cset larger than available free space. Otherwise we guarantee OOME\n-  \/\/      during evacuation, and thus guarantee full GC. In practice, we also want to let\n-  \/\/      application to allocate something. This is why we limit CSet to some fraction of\n-  \/\/      available space. In non-overloaded heap, max_cset would contain all plausible candidates\n-  \/\/      over garbage threshold.\n-  \/\/\n-  \/\/   2. We should not get cset too low so that free threshold would not be met right\n-  \/\/      after the cycle. Otherwise we get back-to-back cycles for no reason if heap is\n-  \/\/      too fragmented. In non-overloaded non-fragmented heap min_garbage would be around zero.\n-  \/\/\n-  \/\/ Therefore, we start by sorting the regions by garbage. Then we unconditionally add the best candidates\n-  \/\/ before we meet min_garbage. Then we add all candidates that fit with a garbage threshold before\n-  \/\/ we hit max_cset. When max_cset is hit, we terminate the cset selection. Note that in this scheme,\n-  \/\/ ShenandoahGarbageThreshold is the soft threshold which would be ignored until min_garbage is hit.\n-\n-  size_t capacity    = _generation->soft_max_capacity();\n-  size_t max_cset    = (size_t)((1.0 * capacity \/ 100 * ShenandoahEvacReserve) \/ ShenandoahEvacWaste);\n-  size_t free_target = (capacity \/ 100 * ShenandoahMinFreeThreshold) + max_cset;\n-  size_t min_garbage = (free_target > actual_free ? (free_target - actual_free) : 0);\n-\n-  log_info(gc, ergo)(\"Adaptive CSet Selection. Target Free: \" SIZE_FORMAT \"%s, Actual Free: \"\n-                     SIZE_FORMAT \"%s, Max CSet: \" SIZE_FORMAT \"%s, Min Garbage: \" SIZE_FORMAT \"%s\",\n-                     byte_size_in_proper_unit(free_target), proper_unit_for_byte_size(free_target),\n-                     byte_size_in_proper_unit(actual_free), proper_unit_for_byte_size(actual_free),\n-                     byte_size_in_proper_unit(max_cset),    proper_unit_for_byte_size(max_cset),\n-                     byte_size_in_proper_unit(min_garbage), proper_unit_for_byte_size(min_garbage));\n-\n-\n-  \/\/ Better select garbage-first regions\n-  QuickSort::sort<RegionData>(data, (int)size, compare_by_garbage, false);\n-\n-  size_t cur_cset = 0;\n-  size_t cur_garbage = 0;\n-\n-  for (size_t idx = 0; idx < size; idx++) {\n-    ShenandoahHeapRegion* r = data[idx]._region;\n-\n-    size_t new_cset    = cur_cset + r->get_live_data_bytes();\n-    size_t new_garbage = cur_garbage + r->garbage();\n-\n-    if (new_cset > max_cset) {\n-      break;\n-    }\n-\n-    if ((new_garbage < min_garbage) || (r->garbage() > garbage_threshold)) {\n-      cset->add_region(r);\n-      cur_cset = new_cset;\n-      cur_garbage = new_garbage;\n-    }\n-  }\n-}\n-\n-void ShenandoahAdaptiveOldHeuristics::record_cycle_start() {\n-  ShenandoahHeuristics::record_cycle_start();\n-  _allocation_rate.allocation_counter_reset();\n-}\n-\n-void ShenandoahAdaptiveOldHeuristics::record_success_concurrent() {\n-  ShenandoahHeuristics::record_success_concurrent();\n-\n-  size_t available = ShenandoahHeap::heap()->free_set()->available();\n-\n-  _available.add(available);\n-  double z_score = 0.0;\n-  if (_available.sd() > 0) {\n-    z_score = (available - _available.avg()) \/ _available.sd();\n-  }\n-\n-  log_debug(gc, ergo)(\"Available: \" SIZE_FORMAT \" %sB, z-score=%.3f. Average available: %.1f %sB +\/- %.1f %sB.\",\n-                      byte_size_in_proper_unit(available), proper_unit_for_byte_size(available),\n-                      z_score,\n-                      byte_size_in_proper_unit(_available.avg()), proper_unit_for_byte_size(_available.avg()),\n-                      byte_size_in_proper_unit(_available.sd()), proper_unit_for_byte_size(_available.sd()));\n-\n-  \/\/ In the case when a concurrent GC cycle completes successfully but with an\n-  \/\/ unusually small amount of available memory we will adjust our trigger\n-  \/\/ parameters so that they are more likely to initiate a new cycle.\n-  \/\/ Conversely, when a GC cycle results in an above average amount of available\n-  \/\/ memory, we will adjust the trigger parameters to be less likely to initiate\n-  \/\/ a GC cycle.\n-  \/\/\n-  \/\/ The z-score we've computed is in no way statistically related to the\n-  \/\/ trigger parameters, but it has the nice property that worse z-scores for\n-  \/\/ available memory indicate making larger adjustments to the trigger\n-  \/\/ parameters. It also results in fewer adjustments as the application\n-  \/\/ stabilizes.\n-  \/\/\n-  \/\/ In order to avoid making endless and likely unnecessary adjustments to the\n-  \/\/ trigger parameters, the change in available memory (with respect to the\n-  \/\/ average) at the end of a cycle must be beyond these threshold values.\n-  if (z_score < LOWEST_EXPECTED_AVAILABLE_AT_END ||\n-      z_score > HIGHEST_EXPECTED_AVAILABLE_AT_END) {\n-    \/\/ The sign is flipped because a negative z-score indicates that the\n-    \/\/ available memory at the end of the cycle is below average. Positive\n-    \/\/ adjustments make the triggers more sensitive (i.e., more likely to fire).\n-    \/\/ The z-score also gives us a measure of just how far below normal. This\n-    \/\/ property allows us to adjust the trigger parameters proportionally.\n-    \/\/\n-    \/\/ The `100` here is used to attenuate the size of our adjustments. This\n-    \/\/ number was chosen empirically. It also means the adjustments at the end of\n-    \/\/ a concurrent cycle are an order of magnitude smaller than the adjustments\n-    \/\/ made for a degenerated or full GC cycle (which themselves were also\n-    \/\/ chosen empirically).\n-    adjust_last_trigger_parameters(z_score \/ -100);\n-  }\n-}\n-\n-void ShenandoahAdaptiveOldHeuristics::record_success_degenerated() {\n-  ShenandoahHeuristics::record_success_degenerated();\n-  \/\/ Adjust both trigger's parameters in the case of a degenerated GC because\n-  \/\/ either of them should have triggered earlier to avoid this case.\n-  adjust_margin_of_error(DEGENERATE_PENALTY_SD);\n-  adjust_spike_threshold(DEGENERATE_PENALTY_SD);\n-}\n-\n-void ShenandoahAdaptiveOldHeuristics::record_success_full() {\n-  ShenandoahHeuristics::record_success_full();\n-  \/\/ Adjust both trigger's parameters in the case of a full GC because\n-  \/\/ either of them should have triggered earlier to avoid this case.\n-  adjust_margin_of_error(FULL_PENALTY_SD);\n-  adjust_spike_threshold(FULL_PENALTY_SD);\n-}\n-\n-static double saturate(double value, double min, double max) {\n-  return MAX2(MIN2(value, max), min);\n-}\n-\n-bool ShenandoahAdaptiveOldHeuristics::should_start_gc() {\n-  size_t max_capacity = _generation->max_capacity();\n-  size_t capacity = _generation->soft_max_capacity();\n-  size_t available = _generation->available();\n-  \/\/ TODO: Fix implementation of old_generation->bytes_allocated_since_gc_start() to represent bytes promoted since\n-  \/\/ start of most recent OLD collection.\n-\n-  \/\/ Note further: available is the difference between soft_capacity and in_use.  So soft_tail has already been removed\n-  \/\/ from this total.  It is redundant to remove it again below.\n-\n-  size_t allocated = _generation->bytes_allocated_since_gc_start();\n-\n-  log_debug(gc)(\"should_start_old_gc? available: \" SIZE_FORMAT \", soft_max_capacity: \" SIZE_FORMAT \", max_capacity: \" SIZE_FORMAT,\n-                available, capacity, max_capacity);\n-  log_debug(gc)(\"  allocated: \" SIZE_FORMAT, allocated);\n-\n-  \/\/ Make sure the code below treats available without the soft tail.\n-  size_t soft_tail = max_capacity - capacity;\n-  available = (available > soft_tail) ? (available - soft_tail) : 0;\n-\n-  \/\/ Track allocation rate even if we decide to start a cycle for other reasons.\n-  double rate = _allocation_rate.sample(allocated);\n-  _last_trigger = OTHER;\n-\n-  size_t min_threshold = (capacity * ShenandoahMinFreeThreshold) \/ 100;\n-\n-  log_debug(gc)(\"  available adjusted to: \" SIZE_FORMAT \", min_threshold: \" SIZE_FORMAT \", ShenandoahMinFreeThreshold: \" SIZE_FORMAT,\n-                available, min_threshold, ShenandoahMinFreeThreshold);\n-\n-  if (available < min_threshold) {\n-    log_info(gc)(\"Trigger (%s): Free (\" SIZE_FORMAT \"%s) is below minimum threshold (\" SIZE_FORMAT \"%s)\",\n-                 _generation->name(),\n-                 byte_size_in_proper_unit(available),     proper_unit_for_byte_size(available),\n-                 byte_size_in_proper_unit(min_threshold), proper_unit_for_byte_size(min_threshold));\n-    return true;\n-  }\n-\n-  \/\/ Check if we need to learn a bit about the application\n-  const size_t max_learn = ShenandoahLearningSteps;\n-  if (_gc_times_learned < max_learn) {\n-    size_t init_threshold = capacity \/ 100 * ShenandoahInitFreeThreshold;\n-    if (available < init_threshold) {\n-      log_info(gc)(\"Trigger (%s): Learning \" SIZE_FORMAT \" of \" SIZE_FORMAT \". Free (\" SIZE_FORMAT \"%s) is below initial threshold (\" SIZE_FORMAT \"%s)\",\n-                   _generation->name(), _gc_times_learned + 1, max_learn,\n-                   byte_size_in_proper_unit(available),      proper_unit_for_byte_size(available),\n-                   byte_size_in_proper_unit(init_threshold), proper_unit_for_byte_size(init_threshold));\n-      return true;\n-    }\n-  }\n-\n-  \/\/ Check if allocation headroom is still okay. This also factors in:\n-  \/\/   1. Some space to absorb allocation spikes\n-  \/\/   2. Accumulated penalties from Degenerated and Full GC\n-  size_t allocation_headroom = available;\n-\n-  size_t spike_headroom = capacity \/ 100 * ShenandoahAllocSpikeFactor;\n-  size_t penalties      = capacity \/ 100 * _gc_time_penalties;\n-\n-  allocation_headroom -= MIN2(allocation_headroom, spike_headroom);\n-  allocation_headroom -= MIN2(allocation_headroom, penalties);\n-\n-  double avg_cycle_time = _gc_time_history->davg() + (_margin_of_error_sd * _gc_time_history->dsd());\n-  double avg_alloc_rate = _allocation_rate.upper_bound(_margin_of_error_sd);\n-  log_debug(gc)(\"%s: average GC time: %.2f ms, allocation rate: %.0f %s\/s\",\n-                _generation->name(), avg_cycle_time * 1000, byte_size_in_proper_unit(avg_alloc_rate), proper_unit_for_byte_size(avg_alloc_rate));\n-\n-  if (avg_cycle_time > allocation_headroom \/ avg_alloc_rate) {\n-    log_info(gc)(\"Trigger (%s): Average GC time (%.2f ms) is above the time for average allocation rate (%.0f %sB\/s) to deplete free headroom (\" SIZE_FORMAT \"%s) (margin of error = %.2f)\",\n-                 _generation->name(), avg_cycle_time * 1000,\n-                 byte_size_in_proper_unit(avg_alloc_rate), proper_unit_for_byte_size(avg_alloc_rate),\n-                 byte_size_in_proper_unit(allocation_headroom), proper_unit_for_byte_size(allocation_headroom),\n-                 _margin_of_error_sd);\n-\n-    log_info(gc, ergo)(\"Free headroom: \" SIZE_FORMAT \"%s (free) - \" SIZE_FORMAT \"%s (spike) - \" SIZE_FORMAT \"%s (penalties) = \" SIZE_FORMAT \"%s\",\n-                       byte_size_in_proper_unit(available),           proper_unit_for_byte_size(available),\n-                       byte_size_in_proper_unit(spike_headroom),      proper_unit_for_byte_size(spike_headroom),\n-                       byte_size_in_proper_unit(penalties),           proper_unit_for_byte_size(penalties),\n-                       byte_size_in_proper_unit(allocation_headroom), proper_unit_for_byte_size(allocation_headroom));\n-\n-    _last_trigger = RATE;\n-    return true;\n-  }\n-\n-  bool is_spiking = _allocation_rate.is_spiking(rate, _spike_threshold_sd);\n-  if (is_spiking && avg_cycle_time > allocation_headroom \/ rate) {\n-    log_info(gc)(\"Trigger (%s): Average GC time (%.2f ms) is above the time for instantaneous allocation rate (%.0f %sB\/s) to deplete free headroom (\" SIZE_FORMAT \"%s) (spike threshold = %.2f)\",\n-                 _generation->name(), avg_cycle_time * 1000,\n-                 byte_size_in_proper_unit(rate), proper_unit_for_byte_size(rate),\n-                 byte_size_in_proper_unit(allocation_headroom), proper_unit_for_byte_size(allocation_headroom),\n-                 _spike_threshold_sd);\n-    _last_trigger = SPIKE;\n-    return true;\n-  }\n-\n-  return ShenandoahHeuristics::should_start_gc();\n-}\n-\n-void ShenandoahAdaptiveOldHeuristics::adjust_last_trigger_parameters(double amount) {\n-  switch (_last_trigger) {\n-    case RATE:\n-      adjust_margin_of_error(amount);\n-      break;\n-    case SPIKE:\n-      adjust_spike_threshold(amount);\n-      break;\n-    case OTHER:\n-      \/\/ nothing to adjust here.\n-      break;\n-    default:\n-      ShouldNotReachHere();\n-  }\n-}\n-\n-void ShenandoahAdaptiveOldHeuristics::adjust_margin_of_error(double amount) {\n-  _margin_of_error_sd = saturate(_margin_of_error_sd + amount, MINIMUM_CONFIDENCE, MAXIMUM_CONFIDENCE);\n-  log_debug(gc, ergo)(\"Margin of error now %.2f\", _margin_of_error_sd);\n-}\n-\n-void ShenandoahAdaptiveOldHeuristics::adjust_spike_threshold(double amount) {\n-  _spike_threshold_sd = saturate(_spike_threshold_sd - amount, MINIMUM_CONFIDENCE, MAXIMUM_CONFIDENCE);\n-  log_debug(gc, ergo)(\"Spike threshold now: %.2f\", _spike_threshold_sd);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveOldHeuristics.cpp","additions":0,"deletions":322,"binary":false,"changes":322,"status":"deleted"},{"patch":"@@ -1,111 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2021, Red Hat, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_SHENANDOAH_HEURISTICS_SHENANDOAHADAPTIVEOLDHEURISTICS_HPP\n-#define SHARE_GC_SHENANDOAH_HEURISTICS_SHENANDOAHADAPTIVEOLDHEURISTICS_HPP\n-\n-#include \"gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.hpp\"\n-#include \"gc\/shenandoah\/shenandoahPhaseTimings.hpp\"\n-#include \"utilities\/numberSeq.hpp\"\n-\n-class ShenandoahAllocationRate;\n-\n-class ShenandoahAdaptiveOldHeuristics : public ShenandoahOldHeuristics {\n-public:\n-  ShenandoahAdaptiveOldHeuristics(ShenandoahGeneration* generation);\n-\n-  virtual ~ShenandoahAdaptiveOldHeuristics();\n-\n-  virtual void choose_collection_set_from_regiondata(ShenandoahCollectionSet* cset,\n-                                                     RegionData* data, size_t size,\n-                                                     size_t actual_free);\n-\n-  void record_cycle_start();\n-  void record_success_concurrent();\n-  void record_success_degenerated();\n-  void record_success_full();\n-\n-  virtual bool should_start_gc();\n-\n-  virtual const char* name()     { return \"AdaptiveOld\"; }\n-  virtual bool is_diagnostic()   { return false; }\n-  virtual bool is_experimental() { return false; }\n-\n- private:\n-  \/\/ These are used to adjust the margin of error and the spike threshold\n-  \/\/ in response to GC cycle outcomes. These values are shared, but the\n-  \/\/ margin of error and spike threshold trend in opposite directions.\n-  const static double FULL_PENALTY_SD;\n-  const static double DEGENERATE_PENALTY_SD;\n-\n-  const static double MINIMUM_CONFIDENCE;\n-  const static double MAXIMUM_CONFIDENCE;\n-\n-  const static double LOWEST_EXPECTED_AVAILABLE_AT_END;\n-  const static double HIGHEST_EXPECTED_AVAILABLE_AT_END;\n-\n-  friend class ShenandoahAllocationRate;\n-\n-  \/\/ Used to record the last trigger that signaled to start a GC.\n-  \/\/ This itself is used to decide whether or not to adjust the margin of\n-  \/\/ error for the average cycle time and allocation rate or the allocation\n-  \/\/ spike detection threshold.\n-  enum Trigger {\n-    SPIKE, RATE, OTHER\n-  };\n-\n-  void adjust_last_trigger_parameters(double amount);\n-  void adjust_margin_of_error(double amount);\n-  void adjust_spike_threshold(double amount);\n-\n-  ShenandoahAllocationRate _allocation_rate;\n-\n-  \/\/ The margin of error expressed in standard deviations to add to our\n-  \/\/ average cycle time and allocation rate. As this value increases we\n-  \/\/ tend to over estimate the rate at which mutators will deplete the\n-  \/\/ heap. In other words, erring on the side of caution will trigger more\n-  \/\/ concurrent GCs.\n-  double _margin_of_error_sd;\n-\n-  \/\/ The allocation spike threshold is expressed in standard deviations.\n-  \/\/ If the standard deviation of the most recent sample of the allocation\n-  \/\/ rate exceeds this threshold, a GC cycle is started. As this value\n-  \/\/ decreases the sensitivity to allocation spikes increases. In other\n-  \/\/ words, lowering the spike threshold will tend to increase the number\n-  \/\/ of concurrent GCs.\n-  double _spike_threshold_sd;\n-\n-  \/\/ Remember which trigger is responsible for the last GC cycle. When the\n-  \/\/ outcome of the cycle is evaluated we will adjust the parameters for the\n-  \/\/ corresponding triggers. Note that successful outcomes will raise\n-  \/\/ the spike threshold and lower the margin of error.\n-  Trigger _last_trigger;\n-\n-  \/\/ Keep track of the available memory at the end of a GC cycle. This\n-  \/\/ establishes what is 'normal' for the application and is used as a\n-  \/\/ source of feedback to adjust trigger parameters.\n-  TruncatedSeq _available;\n-};\n-\n-#endif \/\/ SHARE_GC_SHENANDOAH_HEURISTICS_SHENANDOAHADAPTIVEOLDHEURISTICS_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveOldHeuristics.hpp","additions":0,"deletions":111,"binary":false,"changes":111,"status":"deleted"},{"patch":"@@ -1,69 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2021, Red Hat, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-\n-#include \"gc\/shenandoah\/heuristics\/shenandoahAggressiveOldHeuristics.hpp\"\n-#include \"gc\/shenandoah\/shenandoahCollectionSet.hpp\"\n-#include \"gc\/shenandoah\/shenandoahHeapRegion.inline.hpp\"\n-#include \"logging\/log.hpp\"\n-#include \"logging\/logTag.hpp\"\n-#include \"runtime\/os.hpp\"\n-\n-ShenandoahAggressiveOldHeuristics::ShenandoahAggressiveOldHeuristics(ShenandoahGeneration* generation) : ShenandoahOldHeuristics(generation) {\n-  \/\/ Do not shortcut evacuation\n-  SHENANDOAH_ERGO_OVERRIDE_DEFAULT(ShenandoahImmediateThreshold, 100);\n-\n-  \/\/ Aggressive evacuates everything, so it needs as much evac space as it can get\n-  SHENANDOAH_ERGO_ENABLE_FLAG(ShenandoahEvacReserveOverflow);\n-\n-  \/\/ If class unloading is globally enabled, aggressive does unloading even with\n-  \/\/ concurrent cycles.\n-  if (ClassUnloading) {\n-    SHENANDOAH_ERGO_OVERRIDE_DEFAULT(ShenandoahUnloadClassesFrequency, 1);\n-  }\n-}\n-\n-void ShenandoahAggressiveOldHeuristics::choose_collection_set_from_regiondata(ShenandoahCollectionSet* cset,\n-                                                                             RegionData* data, size_t size,\n-                                                                             size_t free) {\n-  for (size_t idx = 0; idx < size; idx++) {\n-    ShenandoahHeapRegion* r = data[idx]._region;\n-    if (r->garbage() > 0) {\n-      cset->add_region(r);\n-    }\n-  }\n-}\n-\n-bool ShenandoahAggressiveOldHeuristics::should_start_gc() {\n-  log_info(gc)(\"Trigger: Start next cycle immediately\");\n-  return true;\n-}\n-\n-bool ShenandoahAggressiveOldHeuristics::should_unload_classes() {\n-  if (!can_unload_classes_normal()) return false;\n-  if (has_metaspace_oom()) return true;\n-  \/\/ Randomly unload classes with 50% chance.\n-  return (os::random() & 1) == 1;\n-}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAggressiveOldHeuristics.cpp","additions":0,"deletions":69,"binary":false,"changes":69,"status":"deleted"},{"patch":"@@ -1,47 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2021, Red Hat, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_SHENANDOAH_HEURISTICS_SHENANDOAHAGGRESSIVEOLDHEURISTICS_HPP\n-#define SHARE_GC_SHENANDOAH_HEURISTICS_SHENANDOAHAGGRESSIVEOLDHEURISTICS_HPP\n-\n-#include \"gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.hpp\"\n-\n-class ShenandoahAggressiveOldHeuristics : public ShenandoahOldHeuristics {\n-public:\n-  ShenandoahAggressiveOldHeuristics(ShenandoahGeneration* generation);\n-\n-  virtual void choose_collection_set_from_regiondata(ShenandoahCollectionSet* cset,\n-                                                     RegionData* data, size_t size,\n-                                                     size_t free);\n-\n-  virtual bool should_start_gc();\n-\n-  virtual bool should_unload_classes();\n-\n-  virtual const char* name()     { return \"AggressiveOld\"; }\n-  virtual bool is_diagnostic()   { return true; }\n-  virtual bool is_experimental() { return false; }\n-};\n-\n-#endif \/\/ SHARE_GC_SHENANDOAH_HEURISTICS_SHENANDOAHAGGRESSIVEOLDHEURISTICS_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAggressiveOldHeuristics.hpp","additions":0,"deletions":47,"binary":false,"changes":47,"status":"deleted"},{"patch":"@@ -1,99 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2021, Red Hat, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-\n-#include \"gc\/shenandoah\/shenandoahCollectionSet.hpp\"\n-#include \"gc\/shenandoah\/heuristics\/shenandoahCompactOldHeuristics.hpp\"\n-#include \"gc\/shenandoah\/shenandoahFreeSet.hpp\"\n-#include \"gc\/shenandoah\/shenandoahGeneration.hpp\"\n-#include \"gc\/shenandoah\/shenandoahHeapRegion.inline.hpp\"\n-#include \"logging\/log.hpp\"\n-#include \"logging\/logTag.hpp\"\n-\n-ShenandoahCompactOldHeuristics::ShenandoahCompactOldHeuristics(ShenandoahGeneration* generation) :\n-  ShenandoahOldHeuristics(generation) {\n-  SHENANDOAH_ERGO_ENABLE_FLAG(ExplicitGCInvokesConcurrent);\n-  SHENANDOAH_ERGO_ENABLE_FLAG(ShenandoahImplicitGCInvokesConcurrent);\n-  SHENANDOAH_ERGO_ENABLE_FLAG(ShenandoahUncommit);\n-  SHENANDOAH_ERGO_ENABLE_FLAG(ShenandoahAlwaysClearSoftRefs);\n-  SHENANDOAH_ERGO_OVERRIDE_DEFAULT(ShenandoahAllocationThreshold,  10);\n-  SHENANDOAH_ERGO_OVERRIDE_DEFAULT(ShenandoahImmediateThreshold,   100);\n-  SHENANDOAH_ERGO_OVERRIDE_DEFAULT(ShenandoahUncommitDelay,        1000);\n-  SHENANDOAH_ERGO_OVERRIDE_DEFAULT(ShenandoahGuaranteedGCInterval, 30000);\n-  SHENANDOAH_ERGO_OVERRIDE_DEFAULT(ShenandoahGarbageThreshold,     10);\n-}\n-\n-bool ShenandoahCompactOldHeuristics::should_start_gc() {\n-  size_t max_capacity = _generation->max_capacity();\n-  size_t capacity = _generation->soft_max_capacity();\n-  size_t available = _generation->available();\n-\n-  \/\/ Make sure the code below treats available without the soft tail.\n-  size_t soft_tail = max_capacity - capacity;\n-  available = (available > soft_tail) ? (available - soft_tail) : 0;\n-\n-  size_t threshold_bytes_allocated = capacity \/ 100 * ShenandoahAllocationThreshold;\n-  size_t min_threshold = capacity \/ 100 * ShenandoahMinFreeThreshold;\n-\n-  if (available < min_threshold) {\n-    log_info(gc)(\"Trigger: Free (\" SIZE_FORMAT \"%s) is below minimum threshold (\" SIZE_FORMAT \"%s)\",\n-                 byte_size_in_proper_unit(available),     proper_unit_for_byte_size(available),\n-                 byte_size_in_proper_unit(min_threshold), proper_unit_for_byte_size(min_threshold));\n-    return true;\n-  }\n-\n-  size_t bytes_allocated = _generation->bytes_allocated_since_gc_start();\n-  if (bytes_allocated > threshold_bytes_allocated) {\n-    log_info(gc)(\"Trigger: Allocated since last cycle (\" SIZE_FORMAT \"%s) is larger than allocation threshold (\" SIZE_FORMAT \"%s)\",\n-                 byte_size_in_proper_unit(bytes_allocated),           proper_unit_for_byte_size(bytes_allocated),\n-                 byte_size_in_proper_unit(threshold_bytes_allocated), proper_unit_for_byte_size(threshold_bytes_allocated));\n-    return true;\n-  }\n-\n-  return ShenandoahHeuristics::should_start_gc();\n-}\n-\n-void ShenandoahCompactOldHeuristics::choose_collection_set_from_regiondata(ShenandoahCollectionSet* cset,\n-                                                                           RegionData* data, size_t size,\n-                                                                           size_t actual_free) {\n-  \/\/ Do not select too large CSet that would overflow the available free space\n-  size_t max_cset = actual_free * 3 \/ 4;\n-\n-  log_info(gc, ergo)(\"CSet Selection. Actual Free: \" SIZE_FORMAT \"%s, Max CSet: \" SIZE_FORMAT \"%s\",\n-                     byte_size_in_proper_unit(actual_free), proper_unit_for_byte_size(actual_free),\n-                     byte_size_in_proper_unit(max_cset),    proper_unit_for_byte_size(max_cset));\n-\n-  size_t threshold = ShenandoahHeapRegion::region_size_bytes() * ShenandoahGarbageThreshold \/ 100;\n-\n-  size_t live_cset = 0;\n-  for (size_t idx = 0; idx < size; idx++) {\n-    ShenandoahHeapRegion* r = data[idx]._region;\n-    size_t new_cset = live_cset + r->get_live_data_bytes();\n-    if (new_cset < max_cset && r->garbage() > threshold) {\n-      live_cset = new_cset;\n-      cset->add_region(r);\n-    }\n-  }\n-}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahCompactOldHeuristics.cpp","additions":0,"deletions":99,"binary":false,"changes":99,"status":"deleted"},{"patch":"@@ -1,45 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2021, Red Hat, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_SHENANDOAH_HEURISTICS_SHENANDOAHCOMPACTOLDHEURISTICS_HPP\n-#define SHARE_GC_SHENANDOAH_HEURISTICS_SHENANDOAHCOMPACTOLDHEURISTICS_HPP\n-\n-#include \"gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.hpp\"\n-\n-class ShenandoahCompactOldHeuristics : public ShenandoahOldHeuristics {\n-public:\n-  ShenandoahCompactOldHeuristics(ShenandoahGeneration* generation);\n-\n-  virtual bool should_start_gc();\n-\n-  virtual void choose_collection_set_from_regiondata(ShenandoahCollectionSet* cset,\n-                                                     RegionData* data, size_t size,\n-                                                     size_t actual_free);\n-\n-  virtual const char* name()     { return \"CompactOld\"; }\n-  virtual bool is_diagnostic()   { return false; }\n-  virtual bool is_experimental() { return false; }\n-};\n-\n-#endif \/\/ SHARE_GC_SHENANDOAH_HEURISTICS_SHENANDOAHCOMPACTOLDHEURISTICS_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahCompactOldHeuristics.hpp","additions":0,"deletions":45,"binary":false,"changes":45,"status":"deleted"},{"patch":"@@ -53,0 +53,1 @@\n+  _guaranteed_gc_interval(0),\n@@ -217,1 +218,1 @@\n-  if (ShenandoahGuaranteedGCInterval > 0) {\n+  if (_guaranteed_gc_interval > 0) {\n@@ -219,1 +220,1 @@\n-    if (last_time_ms > ShenandoahGuaranteedGCInterval) {\n+    if (last_time_ms > _guaranteed_gc_interval) {\n@@ -221,1 +222,1 @@\n-                   _generation->name(), last_time_ms, ShenandoahGuaranteedGCInterval);\n+                   _generation->name(), last_time_ms, _guaranteed_gc_interval);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -93,0 +93,2 @@\n+  size_t _guaranteed_gc_interval;\n+\n@@ -125,0 +127,4 @@\n+  void set_guaranteed_gc_interval(size_t guaranteed_gc_interval) {\n+    _guaranteed_gc_interval = guaranteed_gc_interval;\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-ShenandoahOldHeuristics::ShenandoahOldHeuristics(ShenandoahGeneration* generation) :\n+ShenandoahOldHeuristics::ShenandoahOldHeuristics(ShenandoahGeneration* generation, ShenandoahHeuristics* trigger_heuristic) :\n@@ -37,1 +37,2 @@\n-    _first_coalesce_and_fill_candidate(0)\n+    _first_coalesce_and_fill_candidate(0),\n+    _trigger_heuristic(trigger_heuristic)\n@@ -42,0 +43,5 @@\n+  if (unprocessed_old_collection_candidates() == 0) {\n+    \/\/ no candidates for inclusion in collection set.\n+    return false;\n+  }\n+\n@@ -49,2 +55,1 @@\n-  \/\/ interrim, we may choose to offer command-line options to set the values of these configuration\n-  \/\/ parameters.\n+  \/\/ interim, we offer command-line options to set the values of these configuration parameters.\n@@ -54,1 +59,1 @@\n-  const size_t max_old_evacuation_bytes = (ShenandoahHeapRegion::region_size_bytes() * 8);\n+  const size_t max_old_evacuation_bytes = (size_t) ((double)_generation->soft_max_capacity() \/ 100 * ShenandoahOldEvacReserve);\n@@ -98,0 +103,4 @@\n+  log_info(gc)(\"Choose old regions for mixed collection: excess capacity: \" SIZE_FORMAT \"%s, evacuation budget: \" SIZE_FORMAT \"%s\",\n+                byte_size_in_proper_unit((size_t) excess_free_capacity), proper_unit_for_byte_size(excess_free_capacity),\n+                byte_size_in_proper_unit(old_evacuation_budget), proper_unit_for_byte_size(old_evacuation_budget));\n+\n@@ -140,3 +149,2 @@\n-    log_info(gc)(\"Old-gen piggyback evac (%llu regions, %llu bytes)\",\n-                 (unsigned long long) included_old_regions,\n-                 (unsigned long long) evacuated_old_bytes);\n+    log_info(gc)(\"Old-gen piggyback evac (\" UINT32_FORMAT \" regions, \" SIZE_FORMAT \" %s)\",\n+                 included_old_regions, byte_size_in_proper_unit(evacuated_old_bytes), proper_unit_for_byte_size(evacuated_old_bytes));\n@@ -158,1 +166,1 @@\n-  uint free_regions = 0;\n+\n@@ -162,0 +170,2 @@\n+  size_t immediate_garbage = 0;\n+  size_t immediate_regions = 0;\n@@ -176,0 +186,2 @@\n+        immediate_regions++;\n+        immediate_garbage += garbage;\n@@ -190,0 +202,4 @@\n+    } else if (region->is_trash()) {\n+      \/\/ Count humongous objects made into trash here.\n+      immediate_regions++;\n+      immediate_garbage += garbage;\n@@ -193,0 +209,4 @@\n+  \/\/ TODO: Consider not running mixed collects if we recovered some threshold percentage of memory from immediate garbage.\n+  \/\/ This would be similar to young and global collections shortcutting evacuation, though we'd probably want a separate\n+  \/\/ threshold for the old generation.\n+\n@@ -196,1 +216,1 @@\n-  \/\/ Any old-gen region that contains (ShenandoahGarbageThreshold (default value 25))% garbage or more is to\n+  \/\/ Any old-gen region that contains (ShenandoahOldGarbageThreshold (default value 25))% garbage or more is to\n@@ -199,6 +219,1 @@\n-  \/\/ TODO: it probably makes sense to define old-generation collection_threshold_garbage_percent differently\n-  \/\/ than the young-gen ShenandoahGarbageThreshold.  So a different command-line option might allow specification\n-  \/\/ distinct values for each.  Even better, allow collection_threshold_garbage_percent to be determined\n-  \/\/ adaptively, by heuristics.\n-\n-  const size_t collection_threshold_garbage_percent = ShenandoahGarbageThreshold;\n+  \/\/ TODO: allow ShenandoahOldGarbageThreshold to be determined adaptively, by heuristics.\n@@ -206,1 +221,2 @@\n-  size_t region_size = ShenandoahHeapRegion::region_size_bytes();\n+  const size_t garbage_threshold = ShenandoahHeapRegion::region_size_bytes() * ShenandoahOldGarbageThreshold \/ 100;\n+  size_t candidates_garbage = 0;\n@@ -208,4 +224,3 @@\n-    \/\/ Do approximate percent to avoid floating point math\n-    size_t percent_garbage = candidates[i]._garbage * 100 \/ region_size;\n-\n-    if (percent_garbage < collection_threshold_garbage_percent) {\n+    candidates_garbage += candidates[i]._garbage;\n+    if (candidates[i]._garbage < garbage_threshold) {\n+      \/\/ Candidates are sorted in decreasing order of garbage, so no regions after this will be above the threshold\n@@ -219,3 +234,2 @@\n-      log_info(gc)(\"Old-gen mark evac (%llu RR, %llu CF)\",\n-                   (unsigned long long) (_hidden_old_collection_candidates),\n-                   (unsigned long long) _old_coalesce_and_fill_candidates);\n+      log_info(gc)(\"Old-gen mark evac (\" UINT32_FORMAT \" RR, \" UINT32_FORMAT \" CF)\",\n+                   _hidden_old_collection_candidates, _old_coalesce_and_fill_candidates);\n@@ -234,3 +248,7 @@\n-  log_info(gc)(\"Old-gen mark evac (%llu RR, %llu CF)\",\n-               (unsigned long long) (_hidden_old_collection_candidates),\n-               (unsigned long long) _old_coalesce_and_fill_candidates);\n+  size_t collectable_garbage = immediate_garbage + candidates_garbage;\n+  log_info(gc)(\"Old-gen mark evac (\" UINT32_FORMAT \" RR, \" UINT32_FORMAT \" CF), \"\n+               \"Collectable Garbage: \" SIZE_FORMAT \"%s, \"\n+               \"Immediate Garbage: \" SIZE_FORMAT \"%s\",\n+               _hidden_old_collection_candidates, _old_coalesce_and_fill_candidates,\n+               byte_size_in_proper_unit(collectable_garbage), proper_unit_for_byte_size(collectable_garbage),\n+               byte_size_in_proper_unit(immediate_garbage), proper_unit_for_byte_size(immediate_garbage));\n@@ -245,1 +263,2 @@\n-  _hidden_old_collection_candidates = 0;}\n+  _hidden_old_collection_candidates = 0;\n+}\n@@ -283,1 +302,1 @@\n-    \/\/ For example, we could choose to abandon the prevoius old collection before it has completed evacuations,\n+    \/\/ For example, we could choose to abandon the previous old collection before it has completed evacuations,\n@@ -299,0 +318,71 @@\n+void ShenandoahOldHeuristics::record_cycle_start() {\n+  _trigger_heuristic->record_cycle_start();\n+}\n+\n+void ShenandoahOldHeuristics::record_cycle_end() {\n+  _trigger_heuristic->record_cycle_end();\n+}\n+\n+bool ShenandoahOldHeuristics::should_start_gc() {\n+  if (should_defer_gc()) {\n+    return false;\n+  }\n+  return _trigger_heuristic->should_start_gc();\n+}\n+\n+bool ShenandoahOldHeuristics::should_degenerate_cycle() {\n+  return _trigger_heuristic->should_degenerate_cycle();\n+}\n+\n+void ShenandoahOldHeuristics::record_success_concurrent() {\n+  _trigger_heuristic->record_success_concurrent();\n+}\n+\n+void ShenandoahOldHeuristics::record_success_degenerated() {\n+  _trigger_heuristic->record_success_degenerated();\n+}\n+\n+void ShenandoahOldHeuristics::record_success_full() {\n+  _trigger_heuristic->record_success_full();\n+}\n+\n+void ShenandoahOldHeuristics::record_allocation_failure_gc() {\n+  _trigger_heuristic->record_allocation_failure_gc();\n+}\n+\n+void ShenandoahOldHeuristics::record_requested_gc() {\n+  _trigger_heuristic->record_requested_gc();\n+}\n+\n+bool ShenandoahOldHeuristics::can_unload_classes() {\n+  return _trigger_heuristic->can_unload_classes();\n+}\n+\n+bool ShenandoahOldHeuristics::can_unload_classes_normal() {\n+  return _trigger_heuristic->can_unload_classes_normal();\n+}\n+\n+bool ShenandoahOldHeuristics::should_unload_classes() {\n+  return _trigger_heuristic->should_unload_classes();\n+}\n+\n+const char* ShenandoahOldHeuristics::name() {\n+  static char name[128];\n+  jio_snprintf(name, sizeof(name), \"%s (OLD)\", _trigger_heuristic->name());\n+  return name;\n+}\n+\n+bool ShenandoahOldHeuristics::is_diagnostic() {\n+  return false;\n+}\n+\n+bool ShenandoahOldHeuristics::is_experimental() {\n+  return true;\n+}\n+\n+void ShenandoahOldHeuristics::choose_collection_set_from_regiondata(ShenandoahCollectionSet* set,\n+                                                                    ShenandoahHeuristics::RegionData* data,\n+                                                                    size_t data_size, size_t free) {\n+  ShouldNotReachHere();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.cpp","additions":119,"deletions":29,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-protected:\n+private:\n@@ -66,0 +66,3 @@\n+  \/\/ This can be the 'static' or 'adaptive' heuristic.\n+  ShenandoahHeuristics* _trigger_heuristic;\n+\n@@ -69,0 +72,5 @@\n+\n+ protected:\n+  virtual void choose_collection_set_from_regiondata(ShenandoahCollectionSet* set, RegionData* data, size_t data_size,\n+                                                     size_t free) override;\n+\n@@ -70,1 +78,1 @@\n-  ShenandoahOldHeuristics(ShenandoahGeneration* generation);\n+  ShenandoahOldHeuristics(ShenandoahGeneration* generation, ShenandoahHeuristics* trigger_heuristic);\n@@ -109,0 +117,30 @@\n+  virtual void record_cycle_start() override;\n+\n+  virtual void record_cycle_end() override;\n+\n+  virtual bool should_start_gc() override;\n+\n+  virtual bool should_degenerate_cycle() override;\n+\n+  virtual void record_success_concurrent() override;\n+\n+  virtual void record_success_degenerated() override;\n+\n+  virtual void record_success_full() override;\n+\n+  virtual void record_allocation_failure_gc() override;\n+\n+  virtual void record_requested_gc() override;\n+\n+  virtual bool can_unload_classes() override;\n+\n+  virtual bool can_unload_classes_normal() override;\n+\n+  virtual bool should_unload_classes() override;\n+\n+  virtual const char* name() override;\n+\n+  virtual bool is_diagnostic() override;\n+\n+  virtual bool is_experimental() override;\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.hpp","additions":40,"deletions":2,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -1,75 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2021, Red Hat, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-\n-#include \"gc\/shenandoah\/heuristics\/shenandoahPassiveOldHeuristics.hpp\"\n-#include \"gc\/shenandoah\/shenandoahCollectionSet.hpp\"\n-#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n-#include \"gc\/shenandoah\/shenandoahHeapRegion.inline.hpp\"\n-#include \"logging\/log.hpp\"\n-#include \"logging\/logTag.hpp\"\n-\n-bool ShenandoahPassiveOldHeuristics::should_start_gc() {\n-  \/\/ Never do concurrent GCs.\n-  return false;\n-}\n-\n-bool ShenandoahPassiveOldHeuristics::should_unload_classes() {\n-  \/\/ Always unload classes, if we can.\n-  return can_unload_classes();\n-}\n-\n-bool ShenandoahPassiveOldHeuristics::should_degenerate_cycle() {\n-  \/\/ Always fail to Degenerated GC, if enabled\n-  return ShenandoahDegeneratedGC;\n-}\n-\n-void ShenandoahPassiveOldHeuristics::choose_collection_set_from_regiondata(ShenandoahCollectionSet* cset,\n-                                                                           RegionData* data, size_t size,\n-                                                                           size_t actual_free) {\n-  assert(ShenandoahDegeneratedGC, \"This path is only taken for Degenerated GC\");\n-\n-  \/\/ Do not select too large CSet that would overflow the available free space.\n-  \/\/ Take at least the entire evacuation reserve, and be free to overflow to free space.\n-  size_t max_capacity = ShenandoahHeap::heap()->max_capacity();\n-  size_t available = MAX2(max_capacity \/ 100 * ShenandoahEvacReserve, actual_free);\n-  size_t max_cset  = (size_t)(available \/ ShenandoahEvacWaste);\n-\n-  log_info(gc, ergo)(\"CSet Selection. Actual Free: \" SIZE_FORMAT \"%s, Max CSet: \" SIZE_FORMAT \"%s\",\n-                     byte_size_in_proper_unit(actual_free), proper_unit_for_byte_size(actual_free),\n-                     byte_size_in_proper_unit(max_cset),    proper_unit_for_byte_size(max_cset));\n-\n-  size_t threshold = ShenandoahHeapRegion::region_size_bytes() * ShenandoahGarbageThreshold \/ 100;\n-\n-  size_t live_cset = 0;\n-  for (size_t idx = 0; idx < size; idx++) {\n-    ShenandoahHeapRegion* r = data[idx]._region;\n-    size_t new_cset = live_cset + r->get_live_data_bytes();\n-    if (new_cset < max_cset && r->garbage() > threshold) {\n-      live_cset = new_cset;\n-      cset->add_region(r);\n-    }\n-  }\n-}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahPassiveOldHeuristics.cpp","additions":0,"deletions":75,"binary":false,"changes":75,"status":"deleted"},{"patch":"@@ -1,50 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2021, Red Hat, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_SHENANDOAH_HEURISTICS_SHENANDOAHPASSIVEOLDHEURISTICS_HPP\n-#define SHARE_GC_SHENANDOAH_HEURISTICS_SHENANDOAHPASSIVEOLDHEURISTICS_HPP\n-\n-#include \"gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.hpp\"\n-\n-class ShenandoahPassiveOldHeuristics : public ShenandoahOldHeuristics {\n-public:\n-  ShenandoahPassiveOldHeuristics(ShenandoahGeneration* generation)\n-    : ShenandoahOldHeuristics(generation) {}\n-\n-  virtual bool should_start_gc();\n-\n-  virtual bool should_unload_classes();\n-\n-  virtual bool should_degenerate_cycle();\n-\n-  virtual void choose_collection_set_from_regiondata(ShenandoahCollectionSet* set,\n-                                                     RegionData* data, size_t data_size,\n-                                                     size_t free);\n-\n-  virtual const char* name()     { return \"PassiveOld\"; }\n-  virtual bool is_diagnostic()   { return true; }\n-  virtual bool is_experimental() { return false; }\n-};\n-\n-#endif \/\/ SHARE_GC_SHENANDOAH_HEURISTICS_SHENANDOAHPASSIVEOLDHEURISTICS_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahPassiveOldHeuristics.hpp","additions":0,"deletions":50,"binary":false,"changes":50,"status":"deleted"},{"patch":"@@ -1,74 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2021, Red Hat, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-\n-#include \"gc\/shenandoah\/heuristics\/shenandoahStaticOldHeuristics.hpp\"\n-#include \"gc\/shenandoah\/shenandoahCollectionSet.hpp\"\n-#include \"gc\/shenandoah\/shenandoahFreeSet.hpp\"\n-#include \"gc\/shenandoah\/shenandoahHeapRegion.inline.hpp\"\n-#include \"gc\/shenandoah\/shenandoahGeneration.hpp\"\n-#include \"logging\/log.hpp\"\n-#include \"logging\/logTag.hpp\"\n-\n-ShenandoahStaticOldHeuristics::ShenandoahStaticOldHeuristics(ShenandoahGeneration* generation) :\n-  ShenandoahOldHeuristics(generation) {\n-  SHENANDOAH_ERGO_ENABLE_FLAG(ExplicitGCInvokesConcurrent);\n-  SHENANDOAH_ERGO_ENABLE_FLAG(ShenandoahImplicitGCInvokesConcurrent);\n-}\n-\n-ShenandoahStaticOldHeuristics::~ShenandoahStaticOldHeuristics() {}\n-\n-bool ShenandoahStaticOldHeuristics::should_start_gc() {\n-  size_t max_capacity = _generation->max_capacity();\n-  size_t capacity = _generation->soft_max_capacity();\n-  size_t available = _generation->available();\n-\n-  \/\/ Make sure the code below treats available without the soft tail.\n-  size_t soft_tail = max_capacity - capacity;\n-  available = (available > soft_tail) ? (available - soft_tail) : 0;\n-\n-  size_t threshold_available = capacity \/ 100 * ShenandoahMinFreeThreshold;\n-\n-  if (available < threshold_available) {\n-    log_info(gc)(\"Trigger: Free (\" SIZE_FORMAT \"%s) is below minimum threshold (\" SIZE_FORMAT \"%s)\",\n-                 byte_size_in_proper_unit(available), proper_unit_for_byte_size(available),\n-                 byte_size_in_proper_unit(threshold_available), proper_unit_for_byte_size(threshold_available));\n-    return true;\n-  }\n-  return ShenandoahHeuristics::should_start_gc();\n-}\n-\n-void ShenandoahStaticOldHeuristics::choose_collection_set_from_regiondata(ShenandoahCollectionSet* cset,\n-                                                                          RegionData* data, size_t size,\n-                                                                          size_t free) {\n-  size_t threshold = ShenandoahHeapRegion::region_size_bytes() * ShenandoahGarbageThreshold \/ 100;\n-\n-  for (size_t idx = 0; idx < size; idx++) {\n-    ShenandoahHeapRegion* r = data[idx]._region;\n-    if (r->garbage() > threshold) {\n-      cset->add_region(r);\n-    }\n-  }\n-}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahStaticOldHeuristics.cpp","additions":0,"deletions":74,"binary":false,"changes":74,"status":"deleted"},{"patch":"@@ -1,47 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2021, Red Hat, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_SHENANDOAH_HEURISTICS_SHENANDOAHSTATICOLDHEURISTICS_HPP\n-#define SHARE_GC_SHENANDOAH_HEURISTICS_SHENANDOAHSTATICOLDHEURISTICS_HPP\n-\n-#include \"gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.hpp\"\n-\n-class ShenandoahStaticOldHeuristics : public ShenandoahOldHeuristics {\n-public:\n-  ShenandoahStaticOldHeuristics(ShenandoahGeneration* generation);\n-\n-  virtual ~ShenandoahStaticOldHeuristics();\n-\n-  virtual bool should_start_gc();\n-\n-  virtual void choose_collection_set_from_regiondata(ShenandoahCollectionSet* cset,\n-                                                     RegionData* data, size_t size,\n-                                                     size_t free);\n-\n-  virtual const char* name()     { return \"StaticOld\"; }\n-  virtual bool is_diagnostic()   { return false; }\n-  virtual bool is_experimental() { return false; }\n-};\n-\n-#endif \/\/ SHARE_GC_SHENANDOAH_HEURISTICS_SHENANDOAHSTATICOLDHEURISTICS_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahStaticOldHeuristics.hpp","additions":0,"deletions":47,"binary":false,"changes":47,"status":"deleted"},{"patch":"@@ -27,1 +27,0 @@\n-#include \"gc\/shenandoah\/heuristics\/shenandoahAdaptiveOldHeuristics.hpp\"\n@@ -29,1 +28,0 @@\n-#include \"gc\/shenandoah\/heuristics\/shenandoahAggressiveOldHeuristics.hpp\"\n@@ -31,1 +29,0 @@\n-#include \"gc\/shenandoah\/heuristics\/shenandoahCompactOldHeuristics.hpp\"\n@@ -33,1 +30,0 @@\n-#include \"gc\/shenandoah\/heuristics\/shenandoahStaticOldHeuristics.hpp\"\n@@ -56,17 +52,0 @@\n-ShenandoahOldHeuristics* ShenandoahMode::initialize_old_heuristics(ShenandoahGeneration* generation) const {\n-\n-  assert(ShenandoahGCHeuristics != NULL, \"ShenandoahGCHeuristics should not equal NULL\");\n-  if (strcmp(ShenandoahGCHeuristics, \"aggressive\") == 0) {\n-    return new ShenandoahAggressiveOldHeuristics(generation);\n-  } else if (strcmp(ShenandoahGCHeuristics, \"static\") == 0) {\n-    return new ShenandoahStaticOldHeuristics(generation);\n-  } else if (strcmp(ShenandoahGCHeuristics, \"adaptive\") == 0) {\n-    return new ShenandoahAdaptiveOldHeuristics(generation);\n-  } else if (strcmp(ShenandoahGCHeuristics, \"compact\") == 0) {\n-    return new ShenandoahCompactOldHeuristics(generation);\n-  } else {\n-    vm_exit_during_initialization(\"Unknown -XX:ShenandoahGCHeuristics option\");\n-    ShouldNotReachHere();\n-    return NULL;\n-  }\n-}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/mode\/shenandoahMode.cpp","additions":0,"deletions":21,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -56,1 +56,0 @@\n-  virtual ShenandoahOldHeuristics* initialize_old_heuristics(ShenandoahGeneration* generation) const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/mode\/shenandoahMode.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"gc\/shenandoah\/heuristics\/shenandoahPassiveOldHeuristics.hpp\"\n@@ -65,5 +64,0 @@\n-\n-ShenandoahOldHeuristics* ShenandoahPassiveMode::initialize_old_heuristics(ShenandoahGeneration* generation) const {\n-  assert(ShenandoahGCHeuristics != NULL, \"ShenandoahGCHeuristics should not equal NULL\");\n-  return new ShenandoahPassiveOldHeuristics(generation);\n-}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/mode\/shenandoahPassiveMode.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-  virtual ShenandoahOldHeuristics* initialize_old_heuristics(ShenandoahGeneration* generation) const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/mode\/shenandoahPassiveMode.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -106,7 +106,0 @@\n-ShenandoahOldHeuristics* ShenandoahGeneration::initialize_old_heuristics(ShenandoahMode* gc_mode) {\n-  ShenandoahOldHeuristics* old_heuristics = gc_mode->initialize_old_heuristics(this);\n-  _heuristics = old_heuristics;\n-  confirm_heuristics_mode();\n-  return old_heuristics;\n-}\n-\n@@ -115,0 +108,1 @@\n+  _heuristics->set_guaranteed_gc_interval(ShenandoahGuaranteedGCInterval);\n@@ -285,1 +279,2 @@\n-  _max_capacity(max_capacity), _soft_max_capacity(soft_max_capacity) {\n+  _max_capacity(max_capacity), _soft_max_capacity(soft_max_capacity),\n+  _heuristics(nullptr) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-  ShenandoahHeuristics* _heuristics;\n@@ -57,1 +56,2 @@\n-public:\n+  ShenandoahHeuristics* _heuristics;\n+ public:\n@@ -69,3 +69,1 @@\n-  ShenandoahHeuristics* initialize_heuristics(ShenandoahMode* gc_mode);\n-\n-  ShenandoahOldHeuristics* initialize_old_heuristics(ShenandoahMode* gc_mode);\n+  virtual ShenandoahHeuristics* initialize_heuristics(ShenandoahMode* gc_mode);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.hpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -488,1 +488,0 @@\n-  _old_heuristics = _old_generation->initialize_old_heuristics(_gc_mode);\n@@ -490,1 +489,4 @@\n-  _young_generation->initialize_heuristics(_gc_mode);\n+  if (mode()->is_generational()) {\n+    _young_generation->initialize_heuristics(_gc_mode);\n+    _old_generation->initialize_heuristics(_gc_mode);\n+  }\n@@ -501,1 +503,0 @@\n-  _old_heuristics(nullptr),\n@@ -628,0 +629,5 @@\n+\n+ShenandoahOldHeuristics* ShenandoahHeap::old_heuristics() {\n+  return (ShenandoahOldHeuristics*) _old_generation->heuristics();\n+}\n+\n@@ -629,1 +635,1 @@\n-  return (_old_heuristics->unprocessed_old_collection_candidates() > 0);\n+  return old_heuristics()->unprocessed_old_collection_candidates() > 0;\n@@ -943,1 +949,1 @@\n-  _old_heuristics->abandon_collection_candidates();\n+  old_heuristics()->abandon_collection_candidates();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -153,1 +153,0 @@\n-  ShenandoahOldHeuristics* _old_heuristics;\n@@ -174,3 +173,1 @@\n-  ShenandoahOldHeuristics* old_heuristics() {\n-    return _old_heuristics;\n-  }\n+  ShenandoahOldHeuristics* old_heuristics();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+\n@@ -28,0 +29,4 @@\n+#include \"gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.hpp\"\n+#include \"gc\/shenandoah\/heuristics\/shenandoahAggressiveHeuristics.hpp\"\n+#include \"gc\/shenandoah\/heuristics\/shenandoahCompactHeuristics.hpp\"\n+#include \"gc\/shenandoah\/heuristics\/shenandoahStaticHeuristics.hpp\"\n@@ -201,0 +206,19 @@\n+\n+ShenandoahHeuristics* ShenandoahOldGeneration::initialize_heuristics(ShenandoahMode* gc_mode) {\n+  assert(ShenandoahOldGCHeuristics != NULL, \"ShenandoahOldGCHeuristics should not equal NULL\");\n+  ShenandoahHeuristics* trigger;\n+  if (strcmp(ShenandoahOldGCHeuristics, \"static\") == 0) {\n+    trigger = new ShenandoahStaticHeuristics(this);\n+  } else if (strcmp(ShenandoahOldGCHeuristics, \"adaptive\") == 0) {\n+    trigger = new ShenandoahAdaptiveHeuristics(this);\n+  } else if (strcmp(ShenandoahOldGCHeuristics, \"compact\") == 0) {\n+    trigger = new ShenandoahCompactHeuristics(this);\n+  } else {\n+    vm_exit_during_initialization(\"Unknown -XX:ShenandoahOldGCHeuristics option (must be one of: static, adaptive, compact)\");\n+    ShouldNotReachHere();\n+    return NULL;\n+  }\n+  trigger->set_guaranteed_gc_interval(ShenandoahGuaranteedOldGCInterval);\n+  _heuristics = new ShenandoahOldHeuristics(this, trigger);\n+  return _heuristics;\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.cpp","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -51,0 +51,2 @@\n+  virtual ShenandoahHeuristics* initialize_heuristics(ShenandoahMode* gc_mode) override;\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-  _old_heuristics = heap->old_heuristics();\n+  _old_heuristics = get_heuristics(heap->old_generation());\n@@ -137,1 +137,1 @@\n-  return !_old_heuristics->should_defer_gc() && _old_heuristics->should_start_gc() && _control_thread->request_concurrent_gc(OLD);\n+  return _old_heuristics->should_start_gc() && _control_thread->request_concurrent_gc(OLD);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRegulatorThread.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,3 +29,1 @@\n-#include \"gc\/shenandoah\/heuristics\/shenandoahHeuristics.hpp\"\n-#include \"gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.hpp\"\n-#include \"gc\/shenandoah\/shenandoahHeap.hpp\"\n+#include \"gc\/shenandoah\/shenandoahSharedVariables.hpp\"\n@@ -34,0 +32,3 @@\n+class ShenandoahHeuristics;\n+class ShenandoahControlThread;\n+\n@@ -78,1 +79,1 @@\n-  ShenandoahOldHeuristics* _old_heuristics;\n+  ShenandoahHeuristics* _old_heuristics;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRegulatorThread.hpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -610,1 +610,0 @@\n-  ShenandoahOldHeuristics* old_heuristics = heap->old_heuristics();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.inline.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -80,0 +80,6 @@\n+  product(ccstr, ShenandoahOldGCHeuristics, \"adaptive\",                     \\\n+          \"Similar to ShenandoahGCHeuristics, but applied to the old \"      \\\n+          \"generation. This configuration is only used to trigger old \"     \\\n+          \"collections and does not change how regions are selected \"       \\\n+          \"for collection.\")                                                \\\n+                                                                            \\\n@@ -93,0 +99,5 @@\n+  product(uintx, ShenandoahOldGarbageThreshold, 25, EXPERIMENTAL,           \\\n+          \"How much garbage an old region has to contain before it would \"  \\\n+          \"be taken for collection.\")                                       \\\n+          range(0,100)                                                      \\\n+                                                                            \\\n@@ -167,0 +178,5 @@\n+  product(uintx, ShenandoahGuaranteedOldGCInterval, 10*60*1000,  EXPERIMENTAL,  \\\n+          \"Run a collection of the old generation at least this often. \"    \\\n+          \"Heuristics may trigger collections more frequently. Time is in \" \\\n+          \"milliseconds. Setting this to 0 disables the feature.\")          \\\n+                                                                            \\\n@@ -252,0 +268,6 @@\n+  product(double, ShenandoahOldEvacReserve, 5.0, EXPERIMENTAL,              \\\n+          \"How much of old generation to withhold from evacuations. \"       \\\n+           \"Larger values will result in fewer live objects being \"         \\\n+           \"evacuated in the old generation.\")                              \\\n+          range(1,100)                                                      \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoah_globals.hpp","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"}]}