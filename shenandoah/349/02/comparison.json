{"files":[{"patch":"@@ -58,1 +58,1 @@\n-    runs-on: macos-11\n+    runs-on: macos-13\n","filename":".github\/workflows\/build-macos.yml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -149,2 +149,2 @@\n-      apt-extra-packages: 'libfreetype-dev:i386 libtiff-dev:i386 libcupsimage2-dev:i386 libc6-i386 libgcc-s1:i386 libstdc++6:i386'\n-      extra-conf-options: '--with-target-bits=32'\n+      apt-extra-packages: 'libfreetype-dev:i386 libtiff-dev:i386 libcupsimage2-dev:i386 libc6-i386 libgcc-s1:i386 libstdc++6:i386 libffi-dev:i386'\n+      extra-conf-options: '--with-target-bits=32 --enable-fallback-linker --enable-libffi-bundling'\n@@ -230,1 +230,1 @@\n-      xcode-toolset-version: '12.5.1'\n+      xcode-toolset-version: '14.3.1'\n@@ -241,1 +241,1 @@\n-      xcode-toolset-version: '12.5.1'\n+      xcode-toolset-version: '14.3.1'\n@@ -321,1 +321,1 @@\n-      runs-on: macos-11\n+      runs-on: macos-13\n","filename":".github\/workflows\/main.yml","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -135,1 +135,1 @@\n-          sudo xcode-select --switch \/Applications\/Xcode_11.7.app\/Contents\/Developer\n+          sudo xcode-select --switch \/Applications\/Xcode_14.3.1.app\/Contents\/Developer\n","filename":".github\/workflows\/test.yml","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -822,2 +822,2 @@\n-<code>C:\\freetype-i586<\/code>:\n-<code>bash configure --with-freetype=\/cygdrive\/c\/freetype-i586 --with-target-bits=32<\/code><\/p><\/li>\n+<code>C:\\freetype-i586<\/code>:<\/p>\n+<pre><code>bash configure --with-freetype=\/cygdrive\/c\/freetype-i586 --with-target-bits=32<\/code><\/pre><\/li>\n@@ -825,2 +825,2 @@\n-enabled:\n-<code>bash configure --enable-debug --with-jvm-variants=server --enable-dtrace<\/code><\/p><\/li>\n+enabled:<\/p>\n+<pre><code>bash configure --enable-debug --with-jvm-variants=server --enable-dtrace<\/code><\/pre><\/li>\n@@ -1334,2 +1334,1 @@\n-instance:<\/p><\/li>\n-<\/ul>\n+instance:<\/p>\n@@ -1338,4 +1337,3 @@\n-dpkg-deb -x \/tmp\/libasound2-dev_1.0.25-4_armhf.deb .<\/code><\/pre>\n-<ul>\n-<li>If alsa is not properly detected by <code>configure<\/code>, you can\n-point it out by <code>--with-alsa<\/code>.<\/li>\n+dpkg-deb -x \/tmp\/libasound2-dev_1.0.25-4_armhf.deb .<\/code><\/pre><\/li>\n+<li><p>If alsa is not properly detected by <code>configure<\/code>, you\n+can point it out by <code>--with-alsa<\/code>.<\/p><\/li>\n@@ -1375,15 +1373,12 @@\n-<pre><code>    cd \/tools\/gcc-linaro-arm-linux-gnueabihf-raspbian-2012.09-20120921_linux\/arm-linux-gnueabihf\/libc\/usr\n-    mkdir X11R6\n-    cd X11R6\n-    for deb in \/tmp\/target-x11\/*.deb ; do dpkg-deb -x $deb . ; done\n-    mv usr\/* .\n-    cd lib\n-    cp arm-linux-gnueabihf\/* .\n-    ```\n-\n-You can ignore the following messages. These libraries are not needed to\n-successfully complete a full JDK build.<\/code><\/pre>\n-<p>cp: cannot stat\n-<code>arm-linux-gnueabihf\/libICE.so': No such file or directory cp: cannot stat<\/code>arm-linux-gnueabihf\/libSM.so':\n-No such file or directory cp: cannot stat\n-`arm-linux-gnueabihf\/libXt.so': No such file or directory ```<\/p><\/li>\n+<pre><code>cd \/tools\/gcc-linaro-arm-linux-gnueabihf-raspbian-2012.09-20120921_linux\/arm-linux-gnueabihf\/libc\/usr\n+mkdir X11R6\n+cd X11R6\n+for deb in \/tmp\/target-x11\/*.deb ; do dpkg-deb -x $deb . ; done\n+mv usr\/* .\n+cd lib\n+cp arm-linux-gnueabihf\/* .<\/code><\/pre>\n+<p>You can ignore the following messages. These libraries are not needed\n+to successfully complete a full JDK build.<\/p>\n+<pre><code>cp: cannot stat `arm-linux-gnueabihf\/libICE.so&#39;: No such file or directory\n+cp: cannot stat `arm-linux-gnueabihf\/libSM.so&#39;: No such file or directory\n+cp: cannot stat `arm-linux-gnueabihf\/libXt.so&#39;: No such file or directory<\/code><\/pre><\/li>\n@@ -1407,2 +1402,2 @@\n-<li><p>Install cross-compiler on the <em>build<\/em> system:\n-<code>apt install g++-aarch64-linux-gnu gcc-aarch64-linux-gnu<\/code><\/p><\/li>\n+<li><p>Install cross-compiler on the <em>build<\/em> system:<\/p>\n+<pre><code>apt install g++-aarch64-linux-gnu gcc-aarch64-linux-gnu<\/code><\/pre><\/li>\n@@ -1410,2 +1405,22 @@\n-<em>target<\/em> system:\n-<code>sudo debootstrap \\       --arch=arm64 \\       --verbose \\       --include=fakeroot,symlinks,build-essential,libx11-dev,libxext-dev,libxrender-dev,libxrandr-dev,libxtst-dev,libxt-dev,libcups2-dev,libfontconfig1-dev,libasound2-dev,libfreetype6-dev,libpng-dev,libffi-dev \\       --resolve-deps \\       buster \\       ~\/sysroot-arm64 \\       http:\/\/httpredir.debian.org\/debian\/     # If the target architecture is `riscv64`,     # the path should be `debian-ports` instead of `debian`.<\/code><\/p><\/li>\n+<em>target<\/em> system:<\/p>\n+<pre><code>sudo debootstrap \\\n+  --arch=arm64 \\\n+  --verbose \\\n+  --include=fakeroot,symlinks,build-essential,libx11-dev,libxext-dev,libxrender-dev,libxrandr-dev,libxtst-dev,libxt-dev,libcups2-dev,libfontconfig1-dev,libasound2-dev,libfreetype6-dev,libpng-dev,libffi-dev \\\n+  --resolve-deps \\\n+  buster \\\n+  ~\/sysroot-arm64 \\\n+  http:\/\/httpredir.debian.org\/debian\/\n+# If the target architecture is `riscv64`,\n+# the path should be `debian-ports` instead of `debian`.<\/code><\/pre><\/li>\n+<li><p>To create a Ubuntu-based chroot:<\/p>\n+<pre><code>sudo debootstrap \\\n+  --arch=arm64 \\\n+  --verbose \\\n+  --components=main,universe \\\n+  --include=fakeroot,symlinks,build-essential,libx11-dev,libxext-dev,libxrender-dev,libxrandr-dev,libxtst-dev,libxt-dev,libcups2-dev,libfontconfig1-dev,libasound2-dev,libfreetype6-dev,libpng-dev,libffi-dev \\\n+  --resolve-deps \\\n+  jammy \\\n+  ~\/sysroot-arm64 \\\n+  http:\/\/ports.ubuntu.com\/ubuntu-ports\/\n+# symlinks is in the universe repository<\/code><\/pre><\/li>\n@@ -1413,2 +1428,2 @@\n-proper locations:\n-<code>sudo chroot ~\/sysroot-arm64 symlinks -cr .<\/code><\/p><\/li>\n+proper locations:<\/p>\n+<pre><code>sudo chroot ~\/sysroot-arm64 symlinks -cr .<\/code><\/pre><\/li>\n@@ -1416,2 +1431,6 @@\n-sysroot\/toolchain-path:\n-<code>sh .\/configure \\       --openjdk-target=aarch64-linux-gnu \\       --with-sysroot=~\/sysroot-arm64     make images     ls build\/linux-aarch64-server-release\/<\/code><\/p><\/li>\n+sysroot\/toolchain-path:<\/p>\n+<pre><code>sh .\/configure \\\n+  --openjdk-target=aarch64-linux-gnu \\\n+  --with-sysroot=~\/sysroot-arm64\n+make images\n+ls build\/linux-aarch64-server-release\/<\/code><\/pre><\/li>\n@@ -1569,6 +1588,21 @@\n-<li><p>Install the RISC-V GNU compiler toolchain:\n-<code>git clone --recursive https:\/\/github.com\/riscv-collab\/riscv-gnu-toolchain     cd riscv-gnu-toolchain     .\/configure --prefix=&lt;toolchain-installed-path&gt;     make linux     export PATH=&lt;toolchain-installed-path&gt;\/bin:$PATH<\/code><\/p><\/li>\n-<li><p>Cross-compile all the required libraries:\n-<code># An example for libffi     git clone https:\/\/github.com\/libffi\/libffi     cd libffi     .\/configure --host=riscv64-unknown-linux-gnu --prefix=&lt;toolchain-installed-path&gt;\/sysroot\/usr     make     make install<\/code><\/p><\/li>\n-<li><p>Configure and build OpenJDK:\n-<code>bash configure \\       --with-boot-jdk=$BOOT_JDK \\       --openjdk-target=riscv64-linux-gnu \\       --with-sysroot=&lt;toolchain-installed-path&gt;\/sysroot \\       --with-toolchain-path=&lt;toolchain-installed-path&gt;\/bin \\       --with-extra-path=&lt;toolchain-installed-path&gt;\/bin     make images<\/code><\/p><\/li>\n+<li><p>Install the RISC-V GNU compiler toolchain:<\/p>\n+<pre><code>git clone --recursive https:\/\/github.com\/riscv-collab\/riscv-gnu-toolchain\n+cd riscv-gnu-toolchain\n+.\/configure --prefix=&lt;toolchain-installed-path&gt;\n+make linux\n+export PATH=&lt;toolchain-installed-path&gt;\/bin:$PATH<\/code><\/pre><\/li>\n+<li><p>Cross-compile all the required libraries:<\/p>\n+<pre><code># An example for libffi\n+git clone https:\/\/github.com\/libffi\/libffi\n+cd libffi\n+.\/configure --host=riscv64-unknown-linux-gnu --prefix=&lt;toolchain-installed-path&gt;\/sysroot\/usr\n+make\n+make install<\/code><\/pre><\/li>\n+<li><p>Configure and build OpenJDK:<\/p>\n+<pre><code>bash configure \\\n+  --with-boot-jdk=$BOOT_JDK \\\n+  --openjdk-target=riscv64-linux-gnu \\\n+  --with-sysroot=&lt;toolchain-installed-path&gt;\/sysroot \\\n+  --with-toolchain-path=&lt;toolchain-installed-path&gt;\/bin \\\n+  --with-extra-path=&lt;toolchain-installed-path&gt;\/bin\n+make images<\/code><\/pre><\/li>\n","filename":"doc\/building.html","additions":73,"deletions":39,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -629,0 +629,1 @@\n+\n@@ -634,0 +635,1 @@\n+\n@@ -1103,5 +1105,6 @@\n-```\n-cd \/tools\/gcc-linaro-arm-linux-gnueabihf-raspbian-2012.09-20120921_linux\/arm-linux-gnueabihf\/libc\n-dpkg-deb -x \/tmp\/libasound2_1.0.25-4_armhf.deb .\n-dpkg-deb -x \/tmp\/libasound2-dev_1.0.25-4_armhf.deb .\n-```\n+\n+    ```\n+    cd \/tools\/gcc-linaro-arm-linux-gnueabihf-raspbian-2012.09-20120921_linux\/arm-linux-gnueabihf\/libc\n+    dpkg-deb -x \/tmp\/libasound2_1.0.25-4_armhf.deb .\n+    dpkg-deb -x \/tmp\/libasound2-dev_1.0.25-4_armhf.deb .\n+    ```\n@@ -1143,0 +1146,1 @@\n+\n@@ -1176,0 +1180,1 @@\n+\n@@ -1181,0 +1186,1 @@\n+\n@@ -1194,0 +1200,15 @@\n+  * To create a Ubuntu-based chroot:\n+\n+    ```\n+    sudo debootstrap \\\n+      --arch=arm64 \\\n+      --verbose \\\n+      --components=main,universe \\\n+      --include=fakeroot,symlinks,build-essential,libx11-dev,libxext-dev,libxrender-dev,libxrandr-dev,libxtst-dev,libxt-dev,libcups2-dev,libfontconfig1-dev,libasound2-dev,libfreetype6-dev,libpng-dev,libffi-dev \\\n+      --resolve-deps \\\n+      jammy \\\n+      ~\/sysroot-arm64 \\\n+      http:\/\/ports.ubuntu.com\/ubuntu-ports\/\n+    # symlinks is in the universe repository\n+    ```\n+\n@@ -1195,0 +1216,1 @@\n+\n@@ -1200,0 +1222,1 @@\n+\n@@ -1258,0 +1281,1 @@\n+\n@@ -1267,0 +1291,1 @@\n+\n@@ -1277,0 +1302,1 @@\n+\n","filename":"doc\/building.md","additions":31,"deletions":5,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -84,2 +84,1 @@\n-    # For public debug symbols on Windows, we have to use stripped pdbs, rename them\n-    # and filter out a few launcher pdbs where there's a lib that goes by the same name\n+    # For public debug symbols on Windows, we have to use stripped pdbs and rename them\n@@ -89,2 +88,1 @@\n-        $(filter-out %jimage.stripped.pdb %jpackage.stripped.pdb %java.stripped.pdb, \\\n-            $(filter %.stripped.pdb, $(call FindFiles, $(CMDS_DIR))))\n+        $(filter %.stripped.pdb, $(call FindFiles, $(CMDS_DIR)))\n@@ -99,12 +97,0 @@\n-  else ifeq ($(call isTargetOs, windows)+$(SHIP_DEBUG_SYMBOLS), true+full)\n-    # For full debug symbols on Windows, we have to filter out a few launcher pdbs\n-    # where there's a lib that goes by the same name\n-    CMDS_DIR_FILTERED := $(subst modules_cmds,modules_cmds_filtered, $(CMDS_DIR))\n-    $(eval $(call SetupCopyFiles, COPY_FILTERED_CMDS, \\\n-        SRC := $(CMDS_DIR), \\\n-        DEST := $(CMDS_DIR_FILTERED), \\\n-        FILES := $(filter-out %jimage.pdb %jpackage.pdb %java.pdb, \\\n-            $(call FindFiles, $(CMDS_DIR))), \\\n-    ))\n-    DEPS += $(COPY_FILTERED_CMDS)\n-    JMOD_FLAGS += --cmds $(CMDS_DIR_FILTERED)\n","filename":"make\/CreateJmods.gmk","additions":3,"deletions":17,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -277,3 +277,0 @@\n-FILTERED_PDBS := %jimage.stripped.pdb %jpackage.stripped.pdb %java.stripped.pdb \\\n-    %jimage.pdb %jpackage.pdb %java.pdb %jimage.map %jpackage.map %java.map\n-\n@@ -293,2 +290,2 @@\n-          FILES := $(filter-out $(FILTERED_PDBS), $(call FindDebuginfoFiles, \\\n-              $(SUPPORT_OUTPUTDIR)\/modules_cmds\/$m)), \\\n+          FILES := $(call FindDebuginfoFiles, \\\n+              $(SUPPORT_OUTPUTDIR)\/modules_cmds\/$m), \\\n","filename":"make\/Images.gmk","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -360,1 +360,1 @@\n-    $(subst .sh,,$(subst .html,,$(subst .java,,$(suffix $(notdir $1)))))\n+    $(subst .jasm,,$(subst .sh,,$(subst .html,,$(subst .java,,$(suffix $(notdir $1))))))\n","filename":"make\/RunTests.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -125,1 +125,1 @@\n-$(eval $(call SetupVariable,JTREG_JAVA,$(BOOT_JDK)\/bin\/java))\n+$(eval $(call SetupVariable,JTREG_JDK,$(BOOT_JDK)))\n@@ -161,0 +161,4 @@\n+else ifeq ($(UNAME_OS), MINGW64)\n+  OPENJDK_TARGET_OS := windows\n+  OPENJDK_TARGET_OS_TYPE := windows\n+  OPENJDK_TARGET_OS_ENV := windows.msys2\n@@ -173,0 +177,3 @@\n+# Sanity check env detection\n+$(info Detected target OS, type and env: [$(OPENJDK_TARGET_OS)] [$(OPENJDK_TARGET_OS_TYPE)] [$(OPENJDK_TARGET_OS_ENV)])\n+\n@@ -252,1 +259,1 @@\n-    JTREG_JAVA := $(FIXPATH) $(JTREG_JAVA), \\\n+    JTREG_JDK := $(JTREG_JDK), \\\n","filename":"make\/RunTestsPrebuilt.gmk","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -127,0 +127,2 @@\n+JTREG_JAVA := $(FIXPATH) $(JTREG_JDK)\/bin\/java $(JAVA_FLAGS_BIG) $(JAVA_FLAGS)\n+\n","filename":"make\/RunTestsPrebuiltSpec.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -90,3 +90,3 @@\n-          modules_libs\/java.security.jgss\/w2k_lsa_auth.diz \\\n-          modules_libs\/java.security.jgss\/w2k_lsa_auth.map \\\n-          modules_libs\/java.security.jgss\/w2k_lsa_auth.pdb, \\\n+          modules_libs\/java.security.jgss\/w2k_lsa_auth.dll.diz \\\n+          modules_libs\/java.security.jgss\/w2k_lsa_auth.dll.map \\\n+          modules_libs\/java.security.jgss\/w2k_lsa_auth.dll.pdb, \\\n","filename":"make\/ZipSecurity.gmk","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -131,1 +131,1 @@\n-    # MACOSX_VERSION_MIN specifies the lowest version of Macosx that the built\n+    # MACOSX_VERSION_MIN specifies the lowest version of macOS that the built\n@@ -136,5 +136,1 @@\n-    if test \"x$OPENJDK_TARGET_CPU_ARCH\" = xaarch64; then\n-      MACOSX_VERSION_MIN=11.00.00\n-    else\n-      MACOSX_VERSION_MIN=10.12.0\n-    fi\n+    MACOSX_VERSION_MIN=11.00.00\n","filename":"make\/autoconf\/flags.m4","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -137,1 +137,2 @@\n-  BINUTILS_DIR=\"$CONFIGURESUPPORT_OUTPUTDIR\/binutils\"\n+  BINUTILS_BUILD_DIR=\"$CONFIGURESUPPORT_OUTPUTDIR\/binutils\"\n+  BINUTILS_INSTALL_DIR=\"$CONFIGURESUPPORT_OUTPUTDIR\/binutils-install\"\n@@ -146,2 +147,2 @@\n-  if ! test -d $BINUTILS_DIR; then\n-    $MKDIR -p $BINUTILS_DIR\n+  if ! test -d $BINUTILS_BUILD_DIR; then\n+    $MKDIR -p $BINUTILS_BUILD_DIR\n@@ -150,5 +151,5 @@\n-  if test -e $BINUTILS_DIR\/bfd\/libbfd.a && \\\n-      test -e $BINUTILS_DIR\/opcodes\/libopcodes.a && \\\n-      test -e $BINUTILS_DIR\/libiberty\/libiberty.a && \\\n-      test -e $BINUTILS_DIR\/zlib\/libz.a; then\n-    AC_MSG_NOTICE([Found binutils binaries in binutils source directory -- not building])\n+  # We don't know the version, not checking for libsframe.a\n+  if test -e $BINUTILS_INSTALL_DIR\/lib\/libbfd.a && \\\n+     test -e $BINUTILS_INSTALL_DIR\/lib\/libopcodes.a && \\\n+     test -e $BINUTILS_INSTALL_DIR\/lib\/libiberty.a; then\n+    AC_MSG_NOTICE([Found binutils binaries in binutils install directory -- not building])\n@@ -193,1 +194,1 @@\n-    AC_MSG_NOTICE([configure command line: cd $BINUTILS_DIR && $BINUTILS_SRC\/configure --disable-nls CFLAGS=\"$binutils_cflags\" CC=\"$binutils_cc\" AR=\"$AR\" $binutils_target])\n+    AC_MSG_NOTICE([configure command line: cd $BINUTILS_BUILD_DIR && $BINUTILS_SRC\/configure --disable-werror --prefix=$BINUTILS_INSTALL_DIR --enable-install-libiberty --with-system-zlib --without-zstd --disable-nls CFLAGS=\"$binutils_cflags\" CC=\"$binutils_cc\" AR=\"$AR\" $binutils_target])\n@@ -195,3 +196,3 @@\n-    cd \"$BINUTILS_DIR\"\n-    $BINUTILS_SRC\/configure --disable-nls CFLAGS=\"$binutils_cflags\" CC=\"$binutils_cc\" AR=\"$AR\" $binutils_target\n-    if test $? -ne 0 || ! test -e $BINUTILS_DIR\/Makefile; then\n+    cd \"$BINUTILS_BUILD_DIR\"\n+    $BINUTILS_SRC\/configure --disable-werror --prefix=$BINUTILS_INSTALL_DIR --enable-install-libiberty --with-system-zlib --without-zstd --disable-nls CFLAGS=\"$binutils_cflags\" CC=\"$binutils_cc\" AR=\"$AR\" $binutils_target\n+    if test $? -ne 0 || ! test -e $BINUTILS_BUILD_DIR\/Makefile; then\n@@ -202,1 +203,1 @@\n-    $MAKE all-opcodes\n+    $MAKE all-opcodes all-libiberty\n@@ -207,0 +208,6 @@\n+    AC_MSG_NOTICE([Running binutils make install])\n+    $MAKE install-opcodes install-libiberty\n+    if test $? -ne 0; then\n+      AC_MSG_NOTICE([Automatic building, install step, of binutils failed on make. Try building it manually])\n+      AC_MSG_ERROR([Cannot continue])\n+    fi\n@@ -226,1 +233,1 @@\n-    # Try building the source first. If it succeeds, it sets $BINUTILS_DIR.\n+    # Try building the source first. If it succeeds, it sets $BINUTILS_INSTALL_DIR.\n@@ -231,1 +238,1 @@\n-    BINUTILS_DIR=\"$with_binutils\"\n+    BINUTILS_INSTALL_DIR=\"$with_binutils\"\n@@ -235,0 +242,1 @@\n+  HSDIS_LDFLAGS=\"\"\n@@ -236,1 +244,3 @@\n-  if test \"x$BINUTILS_DIR\" = xsystem; then\n+  disasm_header=\"<dis-asm.h>\"\n+\n+  if test \"x$BINUTILS_INSTALL_DIR\" = xsystem; then\n@@ -239,1 +249,0 @@\n-    AC_CHECK_LIB(iberty, xmalloc, [ HSDIS_LIBS=\"$HSDIS_LIBS -liberty\" ], [ binutils_system_error=\"libiberty not found\" ])\n@@ -241,0 +250,3 @@\n+    # libiberty is not required on Ubuntu\n+    AC_CHECK_LIB(iberty, xmalloc, [ HSDIS_LIBS=\"$HSDIS_LIBS -liberty\" ])\n+    AC_CHECK_LIB(sframe, frame, [ HSDIS_LIBS=\"$HSDIS_LIBS -lsframe\" ], )\n@@ -242,10 +254,10 @@\n-  elif test \"x$BINUTILS_DIR\" != x; then\n-    if test -e $BINUTILS_DIR\/bfd\/libbfd.a && \\\n-        test -e $BINUTILS_DIR\/opcodes\/libopcodes.a && \\\n-        test -e $BINUTILS_DIR\/libiberty\/libiberty.a && \\\n-        test -e $BINUTILS_DIR\/zlib\/libz.a; then\n-      HSDIS_CFLAGS=\"-DLIBARCH_$OPENJDK_TARGET_CPU_LEGACY_LIB\"\n-      if test -n \"$BINUTILS_SRC\"; then\n-        HSDIS_CFLAGS=\"$HSDIS_CFLAGS -I$BINUTILS_SRC\/include -I$BINUTILS_DIR\/bfd\"\n-      else\n-        HSDIS_CFLAGS=\"$HSDIS_CFLAGS -I$BINUTILS_DIR\/include -I$BINUTILS_DIR\/bfd\"\n+  elif test \"x$BINUTILS_INSTALL_DIR\" != x; then\n+    disasm_header=\"\\\"$BINUTILS_INSTALL_DIR\/include\/dis-asm.h\\\"\"\n+    if test -e $BINUTILS_INSTALL_DIR\/lib\/libbfd.a && \\\n+       test -e $BINUTILS_INSTALL_DIR\/lib\/libopcodes.a && \\\n+       test -e $BINUTILS_INSTALL_DIR\/lib\/libiberty.a; then\n+      HSDIS_CFLAGS=\"-DLIBARCH_$OPENJDK_TARGET_CPU_LEGACY_LIB -I$BINUTILS_INSTALL_DIR\/include\"\n+      HSDIS_LIBS=\"$BINUTILS_INSTALL_DIR\/lib\/libbfd.a $BINUTILS_INSTALL_DIR\/lib\/libopcodes.a $BINUTILS_INSTALL_DIR\/lib\/libiberty.a\"\n+      # If we have libsframe add it.\n+      if test -e $BINUTILS_INSTALL_DIR\/lib\/libsframe.a; then\n+        HSDIS_LIBS=\"$HSDIS_LIBS $BINUTILS_INSTALL_DIR\/lib\/libsframe.a\"\n@@ -253,2 +265,3 @@\n-      HSDIS_LDFLAGS=\"\"\n-      HSDIS_LIBS=\"$BINUTILS_DIR\/bfd\/libbfd.a $BINUTILS_DIR\/opcodes\/libopcodes.a $BINUTILS_DIR\/libiberty\/libiberty.a $BINUTILS_DIR\/zlib\/libz.a\"\n+      AC_CHECK_LIB(z, deflate, [ HSDIS_LIBS=\"$HSDIS_LIBS -lz\" ], AC_MSG_ERROR([libz not found]))\n+    else\n+      AC_MSG_ERROR([\"$BINUTILS_INSTALL_DIR\/libs\/ must contain libbfd.a, libopcodes.a, libiberty.a\"])\n@@ -258,0 +271,11 @@\n+  AC_MSG_CHECKING([Checking binutils API])\n+  AC_COMPILE_IFELSE([AC_LANG_PROGRAM([#include $disasm_header],[[void foo() {init_disassemble_info(0, 0, 0, 0);}]])],\n+    [\n+      AC_MSG_RESULT([New API])\n+      HSDIS_CFLAGS=\"$HSDIS_CFLAGS -DBINUTILS_NEW_API\"\n+    ],\n+    [\n+      AC_MSG_RESULT([Old API])\n+    ]\n+  )\n+\n@@ -259,1 +283,1 @@\n-  case \"x$BINUTILS_DIR\" in\n+  case \"x$BINUTILS_INSTALL_DIR\" in\n@@ -282,1 +306,1 @@\n-        AC_MSG_RESULT([$BINUTILS_DIR])\n+        AC_MSG_RESULT([$BINUTILS_INSTALL_DIR])\n@@ -285,1 +309,1 @@\n-        AC_MSG_ERROR([$BINUTILS_DIR does not contain a proper binutils installation])\n+        AC_MSG_ERROR([$BINUTILS_INSTALL_DIR does not contain a proper binutils installation])\n","filename":"make\/autoconf\/lib-hsdis.m4","additions":57,"deletions":33,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -254,5 +254,4 @@\n-  JTREG_JAVA=\"$JTREG_JDK\/bin\/java\"\n-  UTIL_FIXUP_PATH(JTREG_JAVA)\n-  JTREG_JAVA=\"$FIXPATH $JTREG_JAVA\"\n-  AC_SUBST([JTREG_JAVA])\n-\n+  UTIL_FIXUP_PATH(JTREG_JDK)\n+  AC_SUBST([JTREG_JDK])\n+  # For use in the configure script\n+  JTREG_JAVA=\"$FIXPATH $JTREG_JDK\/bin\/java\"\n","filename":"make\/autoconf\/lib-tests.m4","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -669,2 +669,0 @@\n-JTREG_JAVA:=@JTREG_JAVA@\n-\n@@ -690,0 +688,3 @@\n+JTREG_JDK := @JTREG_JDK@\n+JTREG_JAVA = @FIXPATH@ $(JTREG_JDK)\/bin\/java $(JAVA_FLAGS_BIG) $(JAVA_FLAGS)\n+\n","filename":"make\/autoconf\/spec.gmk.in","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -65,2 +65,2 @@\n-  MODULES_FILTER += jdk.internal.vm.compiler\n-  MODULES_FILTER += jdk.internal.vm.compiler.management\n+  MODULES_FILTER += jdk.graal.compiler\n+  MODULES_FILTER += jdk.graal.compiler.management\n","filename":"make\/common\/Modules.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1076,2 +1076,2 @@\n-          $1_EXTRA_LDFLAGS += -debug \"-pdb:$$($1_SYMBOLS_DIR)\/$$($1_NOSUFFIX).pdb\" \\\n-              \"-map:$$($1_SYMBOLS_DIR)\/$$($1_NOSUFFIX).map\"\n+          $1_EXTRA_LDFLAGS += -debug \"-pdb:$$($1_SYMBOLS_DIR)\/$$($1_BASENAME).pdb\" \\\n+              \"-map:$$($1_SYMBOLS_DIR)\/$$($1_BASENAME).map\"\n@@ -1079,1 +1079,1 @@\n-            $1_EXTRA_LDFLAGS += \"-pdbstripped:$$($1_SYMBOLS_DIR)\/$$($1_NOSUFFIX).stripped.pdb\"\n+            $1_EXTRA_LDFLAGS += \"-pdbstripped:$$($1_SYMBOLS_DIR)\/$$($1_BASENAME).stripped.pdb\"\n@@ -1081,2 +1081,2 @@\n-          $1_DEBUGINFO_FILES := $$($1_SYMBOLS_DIR)\/$$($1_NOSUFFIX).pdb \\\n-              $$($1_SYMBOLS_DIR)\/$$($1_NOSUFFIX).map\n+          $1_DEBUGINFO_FILES := $$($1_SYMBOLS_DIR)\/$$($1_BASENAME).pdb \\\n+              $$($1_SYMBOLS_DIR)\/$$($1_BASENAME).map\n@@ -1130,1 +1130,5 @@\n-          $1_DEBUGINFO_ZIP := $$($1_SYMBOLS_DIR)\/$$($1_NOSUFFIX).diz\n+          ifeq ($(call isTargetOs, windows), true)\n+            $1_DEBUGINFO_ZIP := $$($1_SYMBOLS_DIR)\/$$($1_BASENAME).diz\n+          else\n+            $1_DEBUGINFO_ZIP := $$($1_SYMBOLS_DIR)\/$$($1_NOSUFFIX).diz\n+          endif\n","filename":"make\/common\/NativeCompilation.gmk","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -429,3 +429,8 @@\n-            dependencies: [\"devkit\", \"gtest\"],\n-            configure_args: concat(common.configure_args_32bit,\n-                \"--with-jvm-variants=minimal,server\", \"--with-zlib=system\"),\n+            dependencies: [\"devkit\", \"gtest\", \"libffi\"],\n+            configure_args: concat(common.configure_args_32bit, [\n+                \"--with-jvm-variants=minimal,server\",\n+                \"--with-zlib=system\",\n+                \"--with-libffi=\" + input.get(\"libffi\", \"home_path\"),\n+                \"--enable-libffi-bundling\",\n+                \"--enable-fallback-linker\"\n+            ])\n@@ -439,1 +444,1 @@\n-                \"--with-macosx-version-max=10.12.00\",\n+                \"--with-macosx-version-max=11.00.00\",\n","filename":"make\/conf\/jib-profiles.js","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -63,2 +63,2 @@\n-    jdk.internal.vm.compiler \\\n-    jdk.internal.vm.compiler.management \\\n+    jdk.graal.compiler \\\n+    jdk.graal.compiler.management \\\n","filename":"make\/conf\/module-loader-map.conf","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -136,0 +136,15 @@\n+  # Set ASSERT, NDEBUG and PRODUCT flags just like in JvmFlags.gmk\n+  ifeq ($(DEBUG_LEVEL), release)\n+    # release builds disable uses of assert macro from <assert.h>.\n+    ADLCFLAGS += -DNDEBUG\n+    # For hotspot, release builds differ internally between \"optimized\" and \"product\"\n+    # in that \"optimize\" does not define PRODUCT.\n+    ifneq ($(HOTSPOT_DEBUG_LEVEL), optimized)\n+      ADLCFLAGS += -DPRODUCT\n+    endif\n+  else ifeq ($(DEBUG_LEVEL), fastdebug)\n+    ADLCFLAGS += -DASSERT\n+  else ifeq ($(DEBUG_LEVEL), slowdebug)\n+    ADLCFLAGS += -DASSERT\n+  endif\n+\n","filename":"make\/hotspot\/gensrc\/GensrcAdlc.gmk","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-          FILES := jvm.pdb gtestLauncher.pdb, \\\n+          FILES := jvm.dll.pdb gtestLauncher.exe.pdb, \\\n","filename":"make\/hotspot\/test\/GtestImage.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -332,1 +332,1 @@\n-        addAttr(rv, \"ProgramDataBaseFileName\", outDir+Util.sep+\"jvm.pdb\");\n+        addAttr(rv, \"ProgramDataBaseFileName\", outDir+Util.sep+\"jvm.dll.pdb\");\n@@ -412,1 +412,1 @@\n-        addAttr(rv, \"ProgramDatabaseFile\", outDir+Util.sep+\"jvm.pdb\");\n+        addAttr(rv, \"ProgramDatabaseFile\", outDir+Util.sep+\"jvm.dll.pdb\");\n","filename":"make\/ide\/visualstudio\/hotspot\/src\/classes\/build\/tools\/projectcreator\/WinGammaPlatformVC10.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import java.text.MessageFormat;\n@@ -95,0 +94,6 @@\n+    \/\/ constants used for TZDB short names\n+    private static final String NBSP = \"\\u00A0\";\n+    private static final String STD = \"std\";\n+    private static final String DST = \"dst\";\n+    private static final String NO_SUBST = \"-\";\n+\n@@ -126,0 +131,4 @@\n+    \/\/ TZDB Short Names Map\n+    private static final Map<String, String> tzdbShortNamesMap = HashMap.newHashMap(512);\n+    private static final Map<String, String> tzdbSubstLetters = HashMap.newHashMap(512);\n+\n@@ -287,0 +296,3 @@\n+        \/\/ TZDB short names map\n+        generateTZDBShortNamesMap();\n+\n@@ -760,1 +772,1 @@\n-            if (data instanceof String[]) {\n+            if (data instanceof String[] tznames) {\n@@ -763,1 +775,1 @@\n-                    names.put(METAZONE_ID_PREFIX + META_ETCUTC_ZONE_NAME, data);\n+                    names.put(METAZONE_ID_PREFIX + META_ETCUTC_ZONE_NAME, tznames);\n@@ -767,1 +779,3 @@\n-                    names.put(tzid, data);\n+                    \/\/ TZDB short names\n+                    fillTZDBShortNames(tzid, tznames);\n+                    names.put(tzid, tznames);\n@@ -774,1 +788,3 @@\n-                    if (data instanceof String[]) {\n+                    if (data instanceof String[] tznames) {\n+                        \/\/ TZDB short names\n+                        fillTZDBShortNames(tzid, tznames);\n@@ -1249,0 +1265,119 @@\n+    \/*\n+     * Generates two maps from TZ database files, where they have usual abbreviation\n+     * of the time zone names as \"FORMAT\".\n+     *\n+     * `tzdbShortNamesMap` maps the time zone id, such as \"America\/Los_Angeles\" to\n+     * its FORMAT and Rule which determines the substitution. In \"America\/Los_Angeles\"\n+     * case, its FORMAT is \"P%sT\" and the Rule is \"US\". They are concatenated with\n+     * an NBSP, so the eventual mapping will be:\n+     *\n+     * \"America\/Los_Angeles\" -> \"P%sT<NBSP>US\"\n+     *\n+     * The other map, `tzdbSubstLetters` maps the Rule to its substitution letters.\n+     * The key of the map is the Rule name, appended with \"<NBSP>std\" or \"<NBSP>dst\"\n+     * depending on the savings, e.g.,\n+     *\n+     * \"US<NBSP>std\" -> \"S\"\n+     * \"US<NBSP>dst\" -> \"D\"\n+     *\n+     * These two mappings resolve the short names for time zones in each type,\n+     * such as:\n+     *\n+     * Standard short name for \"America\/Los_Angeles\" -> \"PST\"\n+     * DST short name for \"America\/Los_Angeles\" -> \"PDT\"\n+     * Generic short name for \"America\/Los_Angeles\" -> \"PT\"\n+     *\/\n+    private static void generateTZDBShortNamesMap() throws IOException {\n+        Files.walk(Path.of(tzDataDir), 1, FileVisitOption.FOLLOW_LINKS)\n+            .filter(p -> p.toFile().isFile())\n+            .forEach(p -> {\n+                try {\n+                    String zone = null;\n+                    String rule = null;\n+                    String format = null;\n+                    for (var line : Files.readAllLines(p)) {\n+                        if (line.contains(\"#STDOFF\")) continue;\n+                        line = line.replaceAll(\"[ \\t]*#.*\", \"\");\n+\n+                        \/\/ Zone line\n+                        if (line.startsWith(\"Zone\")) {\n+                            var zl = line.split(\"[ \\t]+\", -1);\n+                            zone = zl[1];\n+                            rule = zl[3];\n+                            format = zl[4];\n+                        } else {\n+                            if (zone != null) {\n+                                if (line.isBlank()) {\n+                                    tzdbShortNamesMap.put(zone, format + NBSP + rule);\n+                                    zone = null;\n+                                    rule = null;\n+                                    format = null;\n+                                } else {\n+                                    var s = line.split(\"[ \\t]+\", -1);\n+                                    rule = s[2];\n+                                    format = s[3];\n+                                }\n+                            }\n+                        }\n+\n+                        \/\/ Rule line\n+                        if (line.startsWith(\"Rule\")) {\n+                            var rl = line.split(\"[ \\t]+\", -1);\n+                            tzdbSubstLetters.put(rl[1] + NBSP + (rl[8].equals(\"0\") ? STD : DST),\n+                                    rl[9].replace(NO_SUBST, \"\"));\n+                        }\n+                    }\n+                } catch (IOException ioe) {\n+                    throw new UncheckedIOException(ioe);\n+                }\n+            });\n+    }\n+\n+    \/*\n+     * Fill the TZDB short names if there is no name provided by the CLDR\n+     *\/\n+    private static void fillTZDBShortNames(String tzid, String[] names) {\n+        var val = tzdbShortNamesMap.get(tzid);\n+        if (val != null) {\n+            var format = val.split(NBSP)[0];\n+            var rule = val.split(NBSP)[1];\n+            IntStream.of(1, 3, 5).forEach(i -> {\n+                if (names[i] == null) {\n+                    if (format.contains(\"%s\")) {\n+                        names[i] = switch (i) {\n+                            case 1 -> format.formatted(tzdbSubstLetters.get(rule + NBSP + STD));\n+                            case 3 -> format.formatted(tzdbSubstLetters.get(rule + NBSP + DST));\n+                            case 5 -> format.formatted(\"\");\n+                            default -> throw new InternalError();\n+                        };\n+                    } else if (format.contains(\"\/\")) { \/\/ such as \"+08\/+09\" or \"GMT\/BST\"\n+                        names[i] = switch (i) {\n+                            case 1, 5 -> convertGMTName(format.substring(0, format.indexOf(\"\/\")));\n+                            case 3 -> convertGMTName(format.substring(format.indexOf(\"\/\") + 1));\n+                            default -> throw new InternalError();\n+                        };\n+                    } else {\n+                        names[i] = convertGMTName(format);\n+                    }\n+                }\n+            });\n+        }\n+    }\n+\n+    \/*\n+     * Convert TZDB offsets to JDK's offsets, eg, \"-08\" to \"GMT-08:00\".\n+     * If it cannot recognize the pattern, return the argument as is.\n+     *\/\n+    private static String convertGMTName(String f) {\n+        try {\n+            \/\/ Should pre-fill GMT format once COMPAT is gone.\n+            \/\/ Till then, fall back to GMT format at runtime, after COMPAT short\n+            \/\/ names are populated\n+            ZoneOffset.of(f);\n+            return null;\n+        } catch (DateTimeException dte) {\n+            \/\/ textual representation. return as is\n+        }\n+        return f;\n+    }\n+\n","filename":"make\/jdk\/src\/classes\/build\/tools\/cldrconverter\/CLDRConverter.java","additions":140,"deletions":5,"binary":false,"changes":145,"status":"modified"},{"patch":"@@ -230,1 +230,1 @@\n-                  $(call SET_SHARED_LIBRARY_ORIGIN), \\\n+                 $(call SET_SHARED_LIBRARY_ORIGIN), \\\n","filename":"make\/modules\/java.base\/Lib.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -922,13 +922,0 @@\n-# MACOSX_METAL_VERSION_MIN specifies the lowest version of Macosx\n-# that should be used to compile Metal shaders. We support Metal\n-# pipeline only on Macosx >=10.14. For Macosx versions <10.14 even if\n-# we enable Metal pipeline using -Dsun.java2d.metal=true, at\n-# runtime we force it to use OpenGL pipeline. And MACOSX_VERSION_MIN\n-# for aarch64 has always been >10.14 so we use continue to use\n-# MACOSX_VERSION_MIN for aarch64.\n-ifeq ($(OPENJDK_TARGET_CPU_ARCH), xaarch64)\n-    MACOSX_METAL_VERSION_MIN=$(MACOSX_VERSION_MIN)\n-else\n-    MACOSX_METAL_VERSION_MIN=10.14.0\n-endif\n-\n@@ -947,1 +934,1 @@\n-          -mmacosx-version-min=$(MACOSX_METAL_VERSION_MIN) \\\n+          -mmacosx-version-min=$(MACOSX_VERSION_MIN) \\\n","filename":"make\/modules\/java.desktop\/lib\/Awt2dLibraries.gmk","additions":1,"deletions":14,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+TZ_DATA_DIR := $(TOPDIR)\/src\/java.base\/share\/data\/tzdata\n@@ -50,1 +51,2 @@\n-\t    -o $(GENSRC_DIR))\n+\t    -o $(GENSRC_DIR) \\\n+\t    -tzdatadir $(TZ_DATA_DIR))\n","filename":"make\/modules\/jdk.localedata\/Gensrc.gmk","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -52,2 +52,2 @@\n-      \/modules_libs\/java.security.jgss\/w2k_lsa_auth.pdb\n-      \/modules_libs\/java.security.jgss\/w2k_lsa_auth.map\n+      \/modules_libs\/java.security.jgss\/w2k_lsa_auth.dll.pdb\n+      \/modules_libs\/java.security.jgss\/w2k_lsa_auth.dll.map\n","filename":"make\/scripts\/compare_exceptions.sh.incl","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -87,1 +87,3 @@\n-# sun.security.util is required to compile Cache benchmark\n+# sun.security.util is required to compile Cache benchmark.\n+# jmh uses annotation processors to generate the benchmark jar and thus\n+# requires the use of -processor option during benchmark compilation.\n@@ -108,0 +110,1 @@\n+        --add-exports java.base\/jdk.internal.misc=ALL-UNNAMED \\\n@@ -109,1 +112,3 @@\n-        --enable-preview, \\\n+        --add-exports java.base\/jdk.internal.foreign=ALL-UNNAMED \\\n+        --enable-preview \\\n+        -processor org.openjdk.jmh.generators.BenchmarkProcessor, \\\n","filename":"make\/test\/BuildMicrobenchmark.gmk","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -120,1 +120,1 @@\n-          \/*release*\/ true, \/*weak*\/ false, rscratch1); \/\/ Sets flags for result\n+          \/*release*\/ true, \/*weak*\/ false, tmp3Reg); \/\/ Sets flags for result\n@@ -132,1 +132,1 @@\n-  cmp(rscratch1, rthread);\n+  cmp(tmp3Reg, rthread);\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -168,1 +168,1 @@\n-  frame(intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, address pc, CodeBlob* cb);\n+  frame(intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, address pc, CodeBlob* cb, bool allow_cb_null = false);\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -94,1 +94,1 @@\n-inline frame::frame(intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, address pc, CodeBlob* cb) {\n+inline frame::frame(intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, address pc, CodeBlob* cb, bool allow_cb_null) {\n@@ -105,1 +105,1 @@\n-  assert(_cb != nullptr, \"pc: \" INTPTR_FORMAT, p2i(pc));\n+  assert(_cb != nullptr || allow_cb_null, \"pc: \" INTPTR_FORMAT, p2i(pc));\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+#include \"prims\/upcallLinker.hpp\"\n@@ -7329,0 +7330,15 @@\n+  \/\/ exception handler for upcall stubs\n+  address generate_upcall_stub_exception_handler() {\n+    StubCodeMark mark(this, \"StubRoutines\", \"upcall stub exception handler\");\n+    address start = __ pc();\n+\n+    \/\/ Native caller has no idea how to handle exceptions,\n+    \/\/ so we just crash here. Up to callee to catch exceptions.\n+    __ verify_oop(r0);\n+    __ movptr(rscratch1, CAST_FROM_FN_PTR(uint64_t, UpcallLinker::handle_uncaught_exception));\n+    __ blr(rscratch1);\n+    __ should_not_reach_here();\n+\n+    return start;\n+  }\n+\n@@ -8380,0 +8396,2 @@\n+    StubRoutines::_upcall_stub_exception_handler = generate_upcall_stub_exception_handler();\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -220,0 +220,1 @@\n+  __ movptr(c_rarg1, (intptr_t)receiver);\n@@ -236,3 +237,1 @@\n-  __ movptr(shuffle_reg, (intptr_t)receiver);\n-  __ resolve_jobject(shuffle_reg, rscratch1, rscratch2);\n-  __ mov(j_rarg0, shuffle_reg);\n+  __ get_vm_result(j_rarg0, rthread);\n@@ -309,13 +308,0 @@\n-  __ block_comment(\"{ exception handler\");\n-\n-  intptr_t exception_handler_offset = __ pc() - start;\n-\n-  \/\/ Native caller has no idea how to handle exceptions,\n-  \/\/ so we just crash here. Up to callee to catch exceptions.\n-  __ verify_oop(r0);\n-  __ movptr(rscratch1, CAST_FROM_FN_PTR(uint64_t, UpcallLinker::handle_uncaught_exception));\n-  __ blr(rscratch1);\n-  __ should_not_reach_here();\n-\n-  __ block_comment(\"} exception handler\");\n-\n@@ -337,1 +323,0 @@\n-                         exception_handler_offset,\n","filename":"src\/hotspot\/cpu\/aarch64\/upcallLinker_aarch64.cpp","additions":2,"deletions":17,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"oops\/resolvedFieldEntry.hpp\"\n@@ -315,0 +316,30 @@\n+void InterpreterMacroAssembler::load_field_entry(Register cache, Register index, int bcp_offset) {\n+  \/\/ Get index out of bytecode pointer\n+  assert_different_registers(cache, index);\n+\n+  get_index_at_bcp(index, bcp_offset, cache \/*as tmp*\/, sizeof(u2));\n+\n+  \/\/ Scale the index to be the entry index * sizeof(ResolvedFieldEntry)\n+  \/\/ sizeof(ResolvedFieldEntry) is 16 on Arm, so using shift\n+  if (is_power_of_2(sizeof(ResolvedFieldEntry))) {\n+    \/\/ load constant pool cache pointer\n+    ldr(cache, Address(FP, frame::interpreter_frame_cache_offset * wordSize));\n+    \/\/ Get address of field entries array\n+    ldr(cache, Address(cache, in_bytes(ConstantPoolCache::field_entries_offset())));\n+\n+    add(cache, cache, Array<ResolvedFieldEntry>::base_offset_in_bytes());\n+    add(cache, cache, AsmOperand(index, lsl, log2i_exact(sizeof(ResolvedFieldEntry))));\n+  }\n+  else {\n+    mov(cache, sizeof(ResolvedFieldEntry));\n+    mul(index, index, cache);\n+    \/\/ load constant pool cache pointer\n+    ldr(cache, Address(FP, frame::interpreter_frame_cache_offset * wordSize));\n+\n+    \/\/ Get address of field entries array\n+    ldr(cache, Address(cache, in_bytes(ConstantPoolCache::field_entries_offset())));\n+    add(cache, cache, Array<ResolvedFieldEntry>::base_offset_in_bytes());\n+    add(cache, cache, index);\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/arm\/interp_masm_arm.cpp","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -105,0 +105,1 @@\n+  void load_field_entry(Register cache, Register index, int bcp_offset = 1);\n","filename":"src\/hotspot\/cpu\/arm\/interp_masm_arm.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+#include \"oops\/resolvedFieldEntry.hpp\"\n@@ -230,1 +231,10 @@\n-      __ get_cache_and_index_and_bytecode_at_bcp(bc_reg, temp_reg, temp_reg, byte_no, 1, sizeof(u2));\n+      __ load_field_entry(temp_reg, bc_reg);\n+      if (byte_no == f1_byte) {\n+        __ add(temp_reg, temp_reg, in_bytes(ResolvedFieldEntry::get_code_offset()));\n+      } else {\n+        __ add(temp_reg, temp_reg, in_bytes(ResolvedFieldEntry::put_code_offset()));\n+      }\n+      \/\/ Load-acquire the bytecode to match store-release in ResolvedFieldEntry::fill_in()\n+      __ ldrb(temp_reg, temp_reg);\n+      __ membar(MacroAssembler::Membar_mask_bits(MacroAssembler::LoadLoad | MacroAssembler::LoadStore), noreg, true);\n+\n@@ -2569,0 +2579,22 @@\n+  Bytecodes::Code code = bytecode();\n+  assert(byte_no == f1_byte || byte_no == f2_byte, \"byte_no out of range\");\n+  __ get_cache_and_index_and_bytecode_at_bcp(Rcache, Rindex, Rtemp, byte_no, 1, index_size);\n+  __ cmp(Rtemp, code);  \/\/ have we resolved this bytecode?\n+  __ b(resolved, eq);\n+\n+  \/\/ resolve first time through\n+  address entry = CAST_FROM_FN_PTR(address, InterpreterRuntime::resolve_from_cache);\n+  __ mov(R1, code);\n+  __ call_VM(noreg, entry, R1);\n+  \/\/ Update registers with resolved info\n+  __ get_cache_and_index_at_bcp(Rcache, Rindex, 1, index_size);\n+  __ bind(resolved);\n+}\n+\n+void TemplateTable::resolve_cache_and_index_for_field(int byte_no,\n+                                                      Register Rcache,\n+                                                      Register Rindex) {\n+  assert_different_registers(Rcache, Rindex, Rtemp);\n+\n+  Label resolved;\n+\n@@ -2577,1 +2609,11 @@\n-  __ get_cache_and_index_and_bytecode_at_bcp(Rcache, Rindex, Rtemp, byte_no, 1, index_size);\n+  __ load_field_entry(Rcache, Rindex);\n+  if (byte_no == f1_byte) {\n+    __ add(Rtemp, Rcache, in_bytes(ResolvedFieldEntry::get_code_offset()));\n+  } else {\n+    __ add(Rtemp, Rcache, in_bytes(ResolvedFieldEntry::put_code_offset()));\n+  }\n+\n+  \/\/ Load-acquire the bytecode to match store-release in ResolvedFieldEntry::fill_in()\n+  __ ldrb(Rtemp, Rtemp);\n+  __ membar(MacroAssembler::Membar_mask_bits(MacroAssembler::LoadLoad | MacroAssembler::LoadStore), noreg, true);\n+\n@@ -2586,1 +2628,1 @@\n-  __ get_cache_and_index_at_bcp(Rcache, Rindex, 1, index_size);\n+  __ load_field_entry(Rcache, Rindex);\n@@ -2590,0 +2632,25 @@\n+void TemplateTable::load_resolved_field_entry(Register obj,\n+                                              Register cache,\n+                                              Register tos_state,\n+                                              Register offset,\n+                                              Register flags,\n+                                              bool is_static = false) {\n+  assert_different_registers(cache, tos_state, flags, offset);\n+\n+  \/\/ Field offset\n+  __ ldr(offset, Address(cache, in_bytes(ResolvedFieldEntry::field_offset_offset())));\n+\n+  \/\/ Flags\n+  __ ldrb(flags, Address(cache, in_bytes(ResolvedFieldEntry::flags_offset())));\n+\n+  \/\/ TOS state\n+  __ ldrb(tos_state, Address(cache, in_bytes(ResolvedFieldEntry::type_offset())));\n+\n+  \/\/ Klass overwrite register\n+  if (is_static) {\n+    __ ldr(obj, Address(cache, ResolvedFieldEntry::field_holder_offset()));\n+    const int mirror_offset = in_bytes(Klass::java_mirror_offset());\n+    __ ldr(obj, Address(obj, mirror_offset));\n+    __ resolve_oop_handle(obj);\n+  }\n+}\n@@ -2745,2 +2812,2 @@\n-    __ add(R2, Rcache, AsmOperand(Rindex, lsl, LogBytesPerWord));\n-    __ add(R2, R2, in_bytes(ConstantPoolCache::base_offset()));\n+    __ load_field_entry(R2, Rindex);\n+\n@@ -2759,1 +2826,1 @@\n-    __ get_cache_and_index_at_bcp(Rcache, Rindex, 1);\n+    __ load_field_entry(Rcache, Rindex);\n@@ -2776,6 +2843,7 @@\n-  const Register Roffset  = R2_tmp;\n-  const Register Robj     = R3_tmp;\n-  const Register Rcache   = R4_tmp;\n-  const Register Rflagsav = Rtmp_save0;  \/\/ R4\/R19\n-  const Register Rindex   = R5_tmp;\n-  const Register Rflags   = R5_tmp;\n+  const Register Rcache = R4_tmp;\n+  const Register Rindex = R3_tmp;\n+\n+  const Register Roffset = R2_tmp;\n+  const Register Rtos_state = R3_tmp;\n+  const Register Robj = R4_tmp; \/\/ Rcache is free at the time of loading Robj\n+  const Register Rflags = R5_tmp;\n@@ -2783,1 +2851,1 @@\n-  resolve_cache_and_index(byte_no, Rcache, Rindex, sizeof(u2));\n+  resolve_cache_and_index_for_field(byte_no, Rcache, Rindex);\n@@ -2785,3 +2853,1 @@\n-  load_field_cp_cache_entry(Rcache, Rindex, Roffset, Rflags, Robj, is_static);\n-\n-  __ mov(Rflagsav, Rflags);\n+  load_resolved_field_entry(Robj, Rcache, Rtos_state, Roffset, Rflags, is_static);\n@@ -2789,1 +2855,3 @@\n-  if (!is_static) pop_and_check_object(Robj);\n+  if (!is_static) {\n+    pop_and_check_object(Robj);\n+  }\n@@ -2794,5 +2862,0 @@\n-  \/\/ compute type\n-  __ logical_shift_right(Rflags, Rflags, ConstantPoolCacheEntry::tos_state_shift);\n-  \/\/ Make sure we don't need to mask flags after the above shift\n-  ConstantPoolCacheEntry::verify_tos_state_shift();\n-\n@@ -2821,1 +2884,1 @@\n-  __ cmp(Rflags, itos);\n+  __ cmp(Rtos_state, itos);\n@@ -2823,1 +2886,1 @@\n-    __ cmp(Rflags, atos, ne);\n+    __ cmp(Rtos_state, atos, ne);\n@@ -2828,1 +2891,1 @@\n-    __ add(PC, PC, AsmOperand(Rflags, lsl, log_max_block_size + Assembler::LogInstructionSize), ne);\n+    __ add(PC, PC, AsmOperand(Rtos_state, lsl, log_max_block_size + Assembler::LogInstructionSize), ne);\n@@ -2830,1 +2893,1 @@\n-    __ ldr(PC, Address(PC, Rflags, lsl, LogBytesPerWord), ne);\n+    __ ldr(PC, Address(PC, Rtos_state, lsl, LogBytesPerWord), ne);\n@@ -2871,1 +2934,1 @@\n-    assert(ztos == seq++, \"btos has unexpected value\");\n+    assert(ztos == seq++, \"ztos has unexpected value\");\n@@ -2995,7 +3058,7 @@\n-  \/\/ Check for volatile field\n-  Label notVolatile;\n-  __ tbz(Rflagsav, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);\n-\n-  volatile_barrier(MacroAssembler::Membar_mask_bits(MacroAssembler::LoadLoad | MacroAssembler::LoadStore), Rtemp);\n-\n-  __ bind(notVolatile);\n+  {\n+    \/\/ Check for volatile field\n+    Label notVolatile;\n+    __ tbz(Rflags, ResolvedFieldEntry::is_volatile_shift, notVolatile);\n+    __ membar(MacroAssembler::Membar_mask_bits(MacroAssembler::LoadLoad | MacroAssembler::LoadStore), Rtemp);\n+    __ bind(notVolatile);\n+  }\n@@ -3032,0 +3095,2 @@\n+    __ mov(R2, Rcache);\n+\n@@ -3040,0 +3105,1 @@\n+      __ ldrb(R3, Address(Rcache, in_bytes(ResolvedFieldEntry::type_offset())));\n@@ -3041,9 +3107,2 @@\n-      __ add(Rtemp, Rcache, AsmOperand(Rindex, lsl, LogBytesPerWord));\n-      __ ldr_u32(Rtemp, Address(Rtemp, cp_base_offset + ConstantPoolCacheEntry::flags_offset()));\n-\n-      __ logical_shift_right(Rtemp, Rtemp, ConstantPoolCacheEntry::tos_state_shift);\n-      \/\/ Make sure we don't need to mask Rtemp after the above shift\n-      ConstantPoolCacheEntry::verify_tos_state_shift();\n-\n-      __ cmp(Rtemp, ltos);\n-      __ cond_cmp(Rtemp, dtos, ne);\n+      __ cmp(R3, ltos);\n+      __ cond_cmp(R3, dtos, ne);\n@@ -3057,4 +3116,0 @@\n-    \/\/ cache entry pointer\n-    __ add(R2, Rcache, AsmOperand(Rindex, lsl, LogBytesPerWord));\n-    __ add(R2, R2, in_bytes(cp_base_offset));\n-\n@@ -3069,1 +3124,1 @@\n-    __ get_cache_and_index_at_bcp(Rcache, Rindex, 1);\n+    __ load_field_entry(Rcache, Rindex);\n@@ -3079,6 +3134,7 @@\n-  const Register Roffset  = R2_tmp;\n-  const Register Robj     = R3_tmp;\n-  const Register Rcache   = R4_tmp;\n-  const Register Rflagsav = Rtmp_save0;  \/\/ R4\/R19\n-  const Register Rindex   = R5_tmp;\n-  const Register Rflags   = R5_tmp;\n+  const Register Rcache = R4_tmp;\n+  const Register Rindex = R3_tmp;\n+\n+  const Register Roffset = R2_tmp;\n+  const Register Rtos_state = R3_tmp;\n+  const Register Robj = R4_tmp; \/\/ Rcache is free at the time of loading Robj\n+  const Register Rflags = R5_tmp;\n@@ -3086,1 +3142,1 @@\n-  resolve_cache_and_index(byte_no, Rcache, Rindex, sizeof(u2));\n+  resolve_cache_and_index_for_field(byte_no, Rcache, Rindex);\n@@ -3088,1 +3144,1 @@\n-  load_field_cp_cache_entry(Rcache, Rindex, Roffset, Rflags, Robj, is_static);\n+  load_resolved_field_entry(Robj, Rcache, Rtos_state, Roffset, Rflags, is_static);\n@@ -3091,7 +3147,6 @@\n-  Label notVolatile;\n-  __ mov(Rflagsav, Rflags);\n-  __ tbz(Rflagsav, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);\n-\n-  volatile_barrier(MacroAssembler::Membar_mask_bits(MacroAssembler::StoreStore | MacroAssembler::LoadStore), Rtemp);\n-\n-  __ bind(notVolatile);\n+  {\n+    Label notVolatile;\n+    __ tbz(Rflags, ResolvedFieldEntry::is_volatile_shift, notVolatile);\n+    __ membar(MacroAssembler::Membar_mask_bits(MacroAssembler::StoreStore | MacroAssembler::LoadStore), Rtemp);\n+    __ bind(notVolatile);\n+  }\n@@ -3102,5 +3157,0 @@\n-  \/\/ compute type\n-  __ logical_shift_right(Rflags, Rflags, ConstantPoolCacheEntry::tos_state_shift);\n-  \/\/ Make sure we don't need to mask flags after the above shift\n-  ConstantPoolCacheEntry::verify_tos_state_shift();\n-\n@@ -3127,1 +3177,1 @@\n-  __ cmp(Rflags, itos);\n+  __ cmp(Rtos_state, itos);\n@@ -3131,1 +3181,1 @@\n-    __ add(PC, PC, AsmOperand(Rflags, lsl, log_max_block_size + Assembler::LogInstructionSize), ne);\n+    __ add(PC, PC, AsmOperand(Rtos_state, lsl, log_max_block_size + Assembler::LogInstructionSize), ne);\n@@ -3133,1 +3183,1 @@\n-    __ ldr(PC, Address(PC, Rflags, lsl, LogBytesPerWord), ne);\n+    __ ldr(PC, Address(PC, Rtos_state, lsl, LogBytesPerWord), ne);\n@@ -3270,1 +3320,1 @@\n-    assert(atos == seq++, \"dtos has unexpected value\");\n+    assert(atos == seq++, \"atos has unexpected value\");\n@@ -3296,26 +3346,5 @@\n-  Label notVolatile2;\n-  if (is_static) {\n-    \/\/ Just check for volatile. Memory barrier for static final field\n-    \/\/ is handled by class initialization.\n-    __ tbz(Rflagsav, ConstantPoolCacheEntry::is_volatile_shift, notVolatile2);\n-    volatile_barrier(MacroAssembler::StoreLoad, Rtemp);\n-    __ bind(notVolatile2);\n-  } else {\n-    \/\/ Check for volatile field and final field\n-    Label skipMembar;\n-\n-    __ tst(Rflagsav, 1 << ConstantPoolCacheEntry::is_volatile_shift |\n-           1 << ConstantPoolCacheEntry::is_final_shift);\n-    __ b(skipMembar, eq);\n-\n-    __ tbz(Rflagsav, ConstantPoolCacheEntry::is_volatile_shift, notVolatile2);\n-\n-    \/\/ StoreLoad barrier after volatile field write\n-    volatile_barrier(MacroAssembler::StoreLoad, Rtemp);\n-    __ b(skipMembar);\n-\n-    \/\/ StoreStore barrier after final field write\n-    __ bind(notVolatile2);\n-    volatile_barrier(MacroAssembler::StoreStore, Rtemp);\n-\n-    __ bind(skipMembar);\n+  {\n+    Label notVolatile;\n+    __ tbz(Rflags, ResolvedFieldEntry::is_volatile_shift, notVolatile);\n+    __ membar(MacroAssembler::Membar_mask_bits(MacroAssembler::StoreStore | MacroAssembler::LoadStore), Rtemp);\n+    __ bind(notVolatile);\n@@ -3361,1 +3390,1 @@\n-    __ get_cache_entry_pointer_at_bcp(R2, R1, 1);\n+    __ load_field_entry(R2, R1);\n@@ -3386,5 +3415,2 @@\n-  const Register Rcache  = R2_tmp;\n-  const Register Rindex  = R3_tmp;\n-  const Register Roffset = R3_tmp;\n-  const Register Rflags  = Rtmp_save0; \/\/ R4\/R19\n-  const Register Robj    = R5_tmp;\n+  const Register Rcache = R4_tmp;\n+  const Register Rindex = R3_tmp;\n@@ -3392,2 +3418,4 @@\n-  \/\/ access constant pool cache\n-  __ get_cache_and_index_at_bcp(Rcache, Rindex, 1);\n+  const Register Roffset = R2_tmp;\n+  const Register Rtos_state = R3_tmp;\n+  const Register Robj = R4_tmp;  \/\/ Rcache is free at the time of loading Robj\n+  const Register Rflags = R5_tmp;\n@@ -3395,1 +3423,3 @@\n-  __ add(Rcache, Rcache, AsmOperand(Rindex, lsl, LogBytesPerWord));\n+  \/\/ access constant pool cache\n+  __ load_field_entry(Rcache, Rindex);\n+  load_resolved_field_entry(Robj, Rcache, Rtos_state, Roffset, Rflags);\n@@ -3398,12 +3428,7 @@\n-  __ ldr_u32(Rflags, Address(Rcache, base + ConstantPoolCacheEntry::flags_offset()));\n-\n-  \/\/ replace index with field offset from cache entry\n-  __ ldr(Roffset, Address(Rcache, base + ConstantPoolCacheEntry::f2_offset()));\n-\n-  \/\/ Check for volatile store\n-  Label notVolatile;\n-  __ tbz(Rflags, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);\n-\n-  volatile_barrier(MacroAssembler::Membar_mask_bits(MacroAssembler::StoreStore | MacroAssembler::LoadStore), Rtemp);\n-\n-  __ bind(notVolatile);\n+  {\n+    \/\/ Check for volatile store\n+    Label notVolatile;\n+    __ tbz(Rflags, ResolvedFieldEntry::is_volatile_shift, notVolatile);\n+    __ membar(MacroAssembler::Membar_mask_bits(MacroAssembler::StoreStore | MacroAssembler::LoadStore), Rtemp);\n+    __ bind(notVolatile);\n+  }\n@@ -3449,15 +3474,7 @@\n-  Label notVolatile2;\n-  Label skipMembar;\n-  __ tst(Rflags, 1 << ConstantPoolCacheEntry::is_volatile_shift |\n-         1 << ConstantPoolCacheEntry::is_final_shift);\n-  __ b(skipMembar, eq);\n-\n-  __ tbz(Rflags, ConstantPoolCacheEntry::is_volatile_shift, notVolatile2);\n-\n-  \/\/ StoreLoad barrier after volatile field write\n-  volatile_barrier(MacroAssembler::StoreLoad, Rtemp);\n-  __ b(skipMembar);\n-\n-  \/\/ StoreStore barrier after final field write\n-  __ bind(notVolatile2);\n-  volatile_barrier(MacroAssembler::StoreStore, Rtemp);\n+  {\n+    \/\/ Check for volatile store\n+    Label notVolatile;\n+    __ tbz(Rflags, ResolvedFieldEntry::is_volatile_shift, notVolatile);\n+    __ membar(MacroAssembler::Membar_mask_bits(MacroAssembler::StoreStore | MacroAssembler::LoadStore), Rtemp);\n+    __ bind(notVolatile);\n+  }\n@@ -3465,1 +3482,0 @@\n-  __ bind(skipMembar);\n@@ -3479,1 +3495,1 @@\n-    __ get_cache_entry_pointer_at_bcp(R2, R1, 1);\n+    __ load_field_entry(R2, R1);\n@@ -3498,1 +3514,1 @@\n-  __ get_cache_and_index_at_bcp(Rcache, Rindex, 1);\n+  __ load_field_entry(Rcache, Rindex);\n@@ -3500,2 +3516,1 @@\n-  __ add(Rtemp, Rcache, AsmOperand(Rindex, lsl, LogBytesPerWord));\n-  __ ldr(Roffset, Address(Rtemp, ConstantPoolCache::base_offset() + ConstantPoolCacheEntry::f2_offset()));\n+  __ ldr(Roffset, Address(Rcache, ResolvedFieldEntry::field_offset_offset()));\n@@ -3504,1 +3519,1 @@\n-  __ ldr_u32(Rflags, Address(Rtemp, ConstantPoolCache::base_offset() + ConstantPoolCacheEntry::flags_offset()));\n+  __ ldrb(Rflags, Address(Rcache, ResolvedFieldEntry::flags_offset()));\n@@ -3507,1 +3522,1 @@\n-  __ null_check(Robj, Rtemp);\n+  __ null_check(Robj);\n@@ -3541,7 +3556,7 @@\n-  \/\/ Check for volatile load\n-  Label notVolatile;\n-  __ tbz(Rflags, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);\n-\n-  volatile_barrier(MacroAssembler::Membar_mask_bits(MacroAssembler::LoadLoad | MacroAssembler::LoadStore), Rtemp);\n-\n-  __ bind(notVolatile);\n+  {\n+    \/\/ Check for volatile load\n+    Label notVolatile;\n+    __ tbz(Rflags, ResolvedFieldEntry::is_volatile_shift, notVolatile);\n+    __ membar(MacroAssembler::Membar_mask_bits(MacroAssembler::LoadLoad | MacroAssembler::LoadStore), Rtemp);\n+    __ bind(notVolatile);\n+  }\n@@ -3565,3 +3580,2 @@\n-  __ get_cache_and_index_at_bcp(Rcache, Rindex, 2);\n-  __ add(Rtemp, Rcache, AsmOperand(Rindex, lsl, LogBytesPerWord));\n-  __ ldr(Roffset, Address(Rtemp, ConstantPoolCache::base_offset() + ConstantPoolCacheEntry::f2_offset()));\n+  __ load_field_entry(Rcache, Rindex, 2);\n+  __ ldr(Roffset, Address(Rcache, ResolvedFieldEntry::field_offset_offset()));\n@@ -3570,1 +3584,1 @@\n-  __ ldr_u32(Rflags, Address(Rtemp, ConstantPoolCache::base_offset() + ConstantPoolCacheEntry::flags_offset()));\n+  __ ldrb(Rflags, Address(Rcache, ResolvedFieldEntry::flags_offset()));\n@@ -3593,7 +3607,7 @@\n-  \/\/ Check for volatile load\n-  Label notVolatile;\n-  __ tbz(Rflags, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);\n-\n-  volatile_barrier(MacroAssembler::Membar_mask_bits(MacroAssembler::LoadLoad | MacroAssembler::LoadStore), Rtemp);\n-\n-  __ bind(notVolatile);\n+  {\n+    \/\/ Check for volatile load\n+    Label notVolatile;\n+    __ tbz(Rflags, ResolvedFieldEntry::is_volatile_shift, notVolatile);\n+    __ membar(MacroAssembler::Membar_mask_bits(MacroAssembler::LoadLoad | MacroAssembler::LoadStore), Rtemp);\n+    __ bind(notVolatile);\n+  }\n","filename":"src\/hotspot\/cpu\/arm\/templateTable_arm.cpp","additions":173,"deletions":159,"binary":false,"changes":332,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"prims\/upcallLinker.hpp\"\n@@ -4720,0 +4721,14 @@\n+  \/\/ exception handler for upcall stubs\n+  address generate_upcall_stub_exception_handler() {\n+    StubCodeMark mark(this, \"StubRoutines\", \"upcall stub exception handler\");\n+    address start = __ pc();\n+\n+    \/\/ Native caller has no idea how to handle exceptions,\n+    \/\/ so we just crash here. Up to callee to catch exceptions.\n+    __ verify_oop(R3_ARG1);\n+    __ load_const_optimized(R12_scratch2, CAST_FROM_FN_PTR(uint64_t, UpcallLinker::handle_uncaught_exception), R0);\n+    __ call_c(R12_scratch2);\n+    __ should_not_reach_here();\n+\n+    return start;\n+  }\n@@ -4799,0 +4814,2 @@\n+\n+    StubRoutines::_upcall_stub_exception_handler = generate_upcall_stub_exception_handler();\n","filename":"src\/hotspot\/cpu\/ppc\/stubGenerator_ppc.cpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -118,1 +118,1 @@\n-static const int upcall_stub_code_base_size = 1536; \/\/ depends on GC (resolve_jobject)\n+static const int upcall_stub_code_base_size = 1024;\n@@ -220,0 +220,1 @@\n+  __ load_const_optimized(R4_ARG2, (intptr_t)receiver, R0);\n@@ -235,2 +236,1 @@\n-  __ load_const_optimized(R3_ARG1, (intptr_t)receiver, R0);\n-  __ resolve_jobject(R3_ARG1, tmp, R31, MacroAssembler::PRESERVATION_FRAME_LR_GP_FP_REGS); \/\/ kills R31\n+  __ get_vm_result(R3_ARG1);\n@@ -317,13 +317,0 @@\n-  __ block_comment(\"{ exception handler\");\n-\n-  intptr_t exception_handler_offset = __ pc() - start;\n-\n-  \/\/ Native caller has no idea how to handle exceptions,\n-  \/\/ so we just crash here. Up to callee to catch exceptions.\n-  __ verify_oop(R3_ARG1);\n-  __ load_const_optimized(call_target_address, CAST_FROM_FN_PTR(uint64_t, UpcallLinker::handle_uncaught_exception), R0);\n-  __ call_c(call_target_address);\n-  __ should_not_reach_here();\n-\n-  __ block_comment(\"} exception handler\");\n-\n@@ -345,1 +332,0 @@\n-                         exception_handler_offset,\n","filename":"src\/hotspot\/cpu\/ppc\/upcallLinker_ppc.cpp","additions":3,"deletions":17,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1793,0 +1793,5 @@\n+  INSN(vsse8_v,  0b0100111, 0b000, 0b10, 0b0);\n+  INSN(vsse16_v, 0b0100111, 0b101, 0b10, 0b0);\n+  INSN(vsse32_v, 0b0100111, 0b110, 0b10, 0b0);\n+  INSN(vsse64_v, 0b0100111, 0b111, 0b10, 0b0);\n+\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1656,0 +1656,32 @@\n+\/\/ According to Java SE specification, for floating-point signum operations, if\n+\/\/ on input we have NaN or +\/-0.0 value we should return it,\n+\/\/ otherwise return +\/- 1.0 using sign of input.\n+\/\/ one - gives us a floating-point 1.0 (got from matching rule)\n+\/\/ bool is_double - specifies single or double precision operations will be used.\n+void C2_MacroAssembler::signum_fp(FloatRegister dst, FloatRegister src, FloatRegister one, bool is_double) {\n+  Register tmp1 = t0;\n+\n+  Label done;\n+\n+  is_double ? fclass_d(tmp1, src)\n+            : fclass_s(tmp1, src);\n+\n+  is_double ? fmv_d(dst, src)\n+            : fmv_s(dst, src);\n+\n+  \/\/bitmask 0b1100011000 specifies this bits:\n+  \/\/ 3 - src is -0\n+  \/\/ 4 - src is +0\n+  \/\/ 8 - src is signaling NaN\n+  \/\/ 9 - src is a quiet NaN\n+  andi(tmp1, tmp1, 0b1100011000);\n+\n+  bnez(tmp1, done);\n+\n+  \/\/ use floating-point 1.0 with a sign of input\n+  is_double ? fsgnj_d(dst, one, src)\n+            : fsgnj_s(dst, one, src);\n+\n+  bind(done);\n+}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -160,0 +160,3 @@\n+  void signum_fp(FloatRegister dst, FloatRegister src, FloatRegister one,\n+                 bool is_double);\n+\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -4407,2 +4407,2 @@\n-void MacroAssembler::cmp_l2i(Register dst, Register src1, Register src2, Register tmp)\n-{\n+void MacroAssembler::cmp_x2i(Register dst, Register src1, Register src2,\n+                             Register tmp, bool is_signed) {\n@@ -4427,1 +4427,5 @@\n-  slt(dst, right, left);\n+  if (is_signed) {\n+    slt(dst, right, left);\n+  } else {\n+    sltu(dst, right, left);\n+  }\n@@ -4429,1 +4433,5 @@\n-  slt(dst, left, right);\n+  if (is_signed) {\n+    slt(dst, left, right);\n+  } else {\n+    sltu(dst, left, right);\n+  }\n@@ -4435,0 +4443,13 @@\n+void MacroAssembler::cmp_l2i(Register dst, Register src1, Register src2, Register tmp)\n+{\n+  cmp_x2i(dst, src1, src2, tmp);\n+}\n+\n+void MacroAssembler::cmp_ul2i(Register dst, Register src1, Register src2, Register tmp) {\n+  cmp_x2i(dst, src1, src2, tmp, false);\n+}\n+\n+void MacroAssembler::cmp_uw2i(Register dst, Register src1, Register src2, Register tmp) {\n+  cmp_x2i(dst, src1, src2, tmp, false);\n+}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":25,"deletions":4,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -1292,0 +1292,7 @@\n+  \/\/ rotate vector register left with shift bits, 32-bit version\n+  inline void vrole32_vi(VectorRegister vd, uint32_t shift, VectorRegister tmp_vr) {\n+    vsrl_vi(tmp_vr, vd, 32 - shift);\n+    vsll_vi(vd, vd, shift);\n+    vor_vv(vd, vd, tmp_vr);\n+  }\n+\n@@ -1390,0 +1397,4 @@\n+private:\n+  void cmp_x2i(Register dst, Register src1, Register src2, Register tmp, bool is_signed = true);\n+\n+public:\n@@ -1395,0 +1406,2 @@\n+  void cmp_ul2i(Register dst, Register src1, Register src2, Register tmp = t0);\n+  void cmp_uw2i(Register dst, Register src1, Register src2, Register tmp = t0);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -7509,0 +7509,46 @@\n+\/\/ Copysign and signum intrinsics\n+\n+instruct copySignD_reg(fRegD dst, fRegD src1, fRegD src2, immD zero) %{\n+  match(Set dst (CopySignD src1 (Binary src2 zero)));\n+  format %{ \"CopySignD  $dst $src1 $src2\" %}\n+  ins_encode %{\n+    FloatRegister dst = as_FloatRegister($dst$$reg),\n+                  src1 = as_FloatRegister($src1$$reg),\n+                  src2 = as_FloatRegister($src2$$reg);\n+    __ fsgnj_d(dst, src1, src2);\n+  %}\n+  ins_pipe(fp_dop_reg_reg_d);\n+%}\n+\n+instruct copySignF_reg(fRegF dst, fRegF src1, fRegF src2) %{\n+  match(Set dst (CopySignF src1 src2));\n+  format %{ \"CopySignF  $dst $src1 $src2\" %}\n+  ins_encode %{\n+    FloatRegister dst = as_FloatRegister($dst$$reg),\n+                  src1 = as_FloatRegister($src1$$reg),\n+                  src2 = as_FloatRegister($src2$$reg);\n+    __ fsgnj_s(dst, src1, src2);\n+  %}\n+  ins_pipe(fp_dop_reg_reg_s);\n+%}\n+\n+instruct signumD_reg(fRegD dst, fRegD src, immD zero, fRegD one) %{\n+  match(Set dst (SignumD src (Binary zero one)));\n+  format %{ \"signumD  $dst, $src\" %}\n+  ins_encode %{\n+    __ signum_fp(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n+                 as_FloatRegister($one$$reg), true \/* is_double *\/);\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct signumF_reg(fRegF dst, fRegF src, immF zero, fRegF one) %{\n+  match(Set dst (SignumF src (Binary zero one)));\n+  format %{ \"signumF  $dst, $src\" %}\n+  ins_encode %{\n+    __ signum_fp(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n+                 as_FloatRegister($one$$reg), false \/* is_double *\/);\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n@@ -8593,0 +8639,36 @@\n+  %}\n+\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct cmpUL3_reg_reg(iRegINoSp dst, iRegL op1, iRegL op2)\n+%{\n+  match(Set dst (CmpUL3 op1 op2));\n+\n+  ins_cost(ALU_COST * 3 + BRANCH_COST);\n+  format %{ \"sltu  $dst, $op2, $op1\\t#@cmpUL3_reg_reg\\n\\t\"\n+            \"bnez  $dst, done\\n\\t\"\n+            \"sltu  $dst, $op1, $op2\\n\\t\"\n+            \"neg   $dst, $dst\\t#@cmpUL3_reg_reg\"\n+  %}\n+  ins_encode %{\n+    __ cmp_ul2i(t0, as_Register($op1$$reg), as_Register($op2$$reg));\n+    __ mv(as_Register($dst$$reg), t0);\n+  %}\n+\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct cmpU3_reg_reg(iRegINoSp dst, iRegI op1, iRegI op2)\n+%{\n+  match(Set dst (CmpU3 op1 op2));\n+\n+  ins_cost(ALU_COST * 3 + BRANCH_COST);\n+  format %{ \"sltu  $dst, $op2, $op1\\t#@cmpU3_reg_reg\\n\\t\"\n+            \"bnez  $dst, done\\n\\t\"\n+            \"sltu  $dst, $op1, $op2\\n\\t\"\n+            \"neg   $dst, $dst\\t#@cmpU3_reg_reg\"\n+  %}\n+  ins_encode %{\n+    __ cmp_uw2i(t0, as_Register($op1$$reg), as_Register($op2$$reg));\n+    __ mv(as_Register($dst$$reg), t0);\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":82,"deletions":0,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"prims\/upcallLinker.hpp\"\n@@ -4280,0 +4281,136 @@\n+  \/**\n+   * Perform the quarter round calculations on values contained within four vector registers.\n+   *\n+   * @param aVec the SIMD register containing only the \"a\" values\n+   * @param bVec the SIMD register containing only the \"b\" values\n+   * @param cVec the SIMD register containing only the \"c\" values\n+   * @param dVec the SIMD register containing only the \"d\" values\n+   * @param tmp_vr temporary vector register holds intermedia values.\n+   *\/\n+  void chacha20_quarter_round(VectorRegister aVec, VectorRegister bVec,\n+                          VectorRegister cVec, VectorRegister dVec, VectorRegister tmp_vr) {\n+    \/\/ a += b, d ^= a, d <<<= 16\n+    __ vadd_vv(aVec, aVec, bVec);\n+    __ vxor_vv(dVec, dVec, aVec);\n+    __ vrole32_vi(dVec, 16, tmp_vr);\n+\n+    \/\/ c += d, b ^= c, b <<<= 12\n+    __ vadd_vv(cVec, cVec, dVec);\n+    __ vxor_vv(bVec, bVec, cVec);\n+    __ vrole32_vi(bVec, 12, tmp_vr);\n+\n+    \/\/ a += b, d ^= a, d <<<= 8\n+    __ vadd_vv(aVec, aVec, bVec);\n+    __ vxor_vv(dVec, dVec, aVec);\n+    __ vrole32_vi(dVec, 8, tmp_vr);\n+\n+    \/\/ c += d, b ^= c, b <<<= 7\n+    __ vadd_vv(cVec, cVec, dVec);\n+    __ vxor_vv(bVec, bVec, cVec);\n+    __ vrole32_vi(bVec, 7, tmp_vr);\n+  }\n+\n+  \/**\n+   * int com.sun.crypto.provider.ChaCha20Cipher.implChaCha20Block(int[] initState, byte[] result)\n+   *\n+   *  Input arguments:\n+   *  c_rarg0   - state, the starting state\n+   *  c_rarg1   - key_stream, the array that will hold the result of the ChaCha20 block function\n+   *\n+   *  Implementation Note:\n+   *   Parallelization is achieved by loading individual state elements into vectors for N blocks.\n+   *   N depends on single vector register length.\n+   *\/\n+  address generate_chacha20Block() {\n+    Label L_Rounds;\n+\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, \"StubRoutines\", \"chacha20Block\");\n+    address start = __ pc();\n+    __ enter();\n+\n+    const int states_len = 16;\n+    const int step = 4;\n+    const Register state = c_rarg0;\n+    const Register key_stream = c_rarg1;\n+    const Register tmp_addr = t0;\n+    const Register length = t1;\n+\n+    \/\/ Organize vector registers in an array that facilitates\n+    \/\/ putting repetitive opcodes into loop structures below.\n+    const VectorRegister work_vrs[16] = {\n+      v0, v1, v2,  v3,  v4,  v5,  v6,  v7,\n+      v8, v9, v10, v11, v12, v13, v14, v15\n+    };\n+    const VectorRegister tmp_vr = v16;\n+    const VectorRegister counter_vr = v17;\n+\n+    {\n+      \/\/ Put 16 here, as com.sun.crypto.providerChaCha20Cipher.KS_MAX_LEN is 1024\n+      \/\/ in java level.\n+      __ vsetivli(length, 16, Assembler::e32, Assembler::m1);\n+    }\n+\n+    \/\/ Load from source state.\n+    \/\/ Every element in source state is duplicated to all elements in the corresponding vector.\n+    __ mv(tmp_addr, state);\n+    for (int i = 0; i < states_len; i += 1) {\n+      __ vlse32_v(work_vrs[i], tmp_addr, zr);\n+      __ addi(tmp_addr, tmp_addr, step);\n+    }\n+    \/\/ Adjust counter for every individual block.\n+    __ vid_v(counter_vr);\n+    __ vadd_vv(work_vrs[12], work_vrs[12], counter_vr);\n+\n+    \/\/ Perform 10 iterations of the 8 quarter round set\n+    {\n+      const Register loop = t2; \/\/ share t2 with other non-overlapping usages.\n+      __ mv(loop, 10);\n+      __ BIND(L_Rounds);\n+\n+      chacha20_quarter_round(work_vrs[0], work_vrs[4], work_vrs[8],  work_vrs[12], tmp_vr);\n+      chacha20_quarter_round(work_vrs[1], work_vrs[5], work_vrs[9],  work_vrs[13], tmp_vr);\n+      chacha20_quarter_round(work_vrs[2], work_vrs[6], work_vrs[10], work_vrs[14], tmp_vr);\n+      chacha20_quarter_round(work_vrs[3], work_vrs[7], work_vrs[11], work_vrs[15], tmp_vr);\n+\n+      chacha20_quarter_round(work_vrs[0], work_vrs[5], work_vrs[10], work_vrs[15], tmp_vr);\n+      chacha20_quarter_round(work_vrs[1], work_vrs[6], work_vrs[11], work_vrs[12], tmp_vr);\n+      chacha20_quarter_round(work_vrs[2], work_vrs[7], work_vrs[8],  work_vrs[13], tmp_vr);\n+      chacha20_quarter_round(work_vrs[3], work_vrs[4], work_vrs[9],  work_vrs[14], tmp_vr);\n+\n+      __ sub(loop, loop, 1);\n+      __ bnez(loop, L_Rounds);\n+    }\n+\n+    \/\/ Add the original state into the end working state.\n+    \/\/ We do this by first duplicating every element in source state array to the corresponding\n+    \/\/ vector, then adding it to the post-loop working state.\n+    __ mv(tmp_addr, state);\n+    for (int i = 0; i < states_len; i += 1) {\n+      __ vlse32_v(tmp_vr, tmp_addr, zr);\n+      __ addi(tmp_addr, tmp_addr, step);\n+      __ vadd_vv(work_vrs[i], work_vrs[i], tmp_vr);\n+    }\n+    \/\/ Add the counter overlay onto work_vrs[12] at the end.\n+    __ vadd_vv(work_vrs[12], work_vrs[12], counter_vr);\n+\n+    \/\/ Store result to key stream.\n+    {\n+      const Register stride = t2; \/\/ share t2 with other non-overlapping usages.\n+      \/\/ Every block occupies 64 bytes, so we use 64 as stride of the vector store.\n+      __ mv(stride, 64);\n+      for (int i = 0; i < states_len; i += 1) {\n+        __ vsse32_v(work_vrs[i], key_stream, stride);\n+        __ addi(key_stream, key_stream, step);\n+      }\n+    }\n+\n+    \/\/ Return length of output key_stream\n+    __ slli(c_rarg0, length, 6);\n+\n+    __ leave();\n+    __ ret();\n+\n+    return (address) start;\n+  }\n+\n@@ -4371,0 +4508,14 @@\n+  \/\/ exception handler for upcall stubs\n+  address generate_upcall_stub_exception_handler() {\n+    StubCodeMark mark(this, \"StubRoutines\", \"upcall stub exception handler\");\n+    address start = __ pc();\n+\n+    \/\/ Native caller has no idea how to handle exceptions,\n+    \/\/ so we just crash here. Up to callee to catch exceptions.\n+    __ verify_oop(x10); \/\/ return a exception oop in a0\n+    __ rt_call(CAST_FROM_FN_PTR(address, UpcallLinker::handle_uncaught_exception));\n+    __ should_not_reach_here();\n+\n+    return start;\n+  }\n+\n@@ -4455,0 +4606,2 @@\n+    StubRoutines::_upcall_stub_exception_handler = generate_upcall_stub_exception_handler();\n+\n@@ -4499,0 +4652,5 @@\n+\n+    if (UseChaCha20Intrinsics) {\n+      StubRoutines::_chacha20Block = generate_chacha20Block();\n+    }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":158,"deletions":0,"binary":false,"changes":158,"status":"modified"},{"patch":"@@ -117,1 +117,1 @@\n-static const int upcall_stub_code_base_size = 2048;\n+static const int upcall_stub_code_base_size = 1024;\n@@ -221,0 +221,1 @@\n+  __ movptr(c_rarg1, (intptr_t) receiver);\n@@ -258,3 +259,1 @@\n-  __ movptr(shuffle_reg, (intptr_t) receiver);\n-  __ resolve_jobject(shuffle_reg, t0, t1);\n-  __ mv(j_rarg0, shuffle_reg);\n+  __ get_vm_result(j_rarg0, xthread);\n@@ -329,11 +328,0 @@\n-  __ block_comment(\"{ exception handler\");\n-\n-  intptr_t exception_handler_offset = __ pc() - start;\n-\n-  \/\/ Native caller has no idea how to handle exceptions,\n-  \/\/ so we just crash here. Up to callee to catch exceptions.\n-  __ verify_oop(x10); \/\/ return a exception oop in a0\n-  __ rt_call(CAST_FROM_FN_PTR(address, UpcallLinker::handle_uncaught_exception));\n-  __ should_not_reach_here();\n-\n-  __ block_comment(\"} exception handler\");\n@@ -355,1 +343,0 @@\n-                         exception_handler_offset,\n","filename":"src\/hotspot\/cpu\/riscv\/upcallLinker_riscv.cpp","additions":3,"deletions":16,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -194,0 +194,8 @@\n+  if (FLAG_IS_DEFAULT(UseCopySignIntrinsic)) {\n+      FLAG_SET_DEFAULT(UseCopySignIntrinsic, true);\n+  }\n+\n+  if (FLAG_IS_DEFAULT(UseSignumIntrinsic)) {\n+      FLAG_SET_DEFAULT(UseSignumIntrinsic, true);\n+  }\n+\n@@ -256,0 +264,10 @@\n+  if (UseRVV) {\n+    if (FLAG_IS_DEFAULT(UseChaCha20Intrinsics)) {\n+      FLAG_SET_DEFAULT(UseChaCha20Intrinsics, true);\n+    }\n+  } else if (UseChaCha20Intrinsics) {\n+    if (!FLAG_IS_DEFAULT(UseChaCha20Intrinsics)) {\n+      warning(\"Chacha20 intrinsic requires RVV instructions (not available on this CPU)\");\n+    }\n+    FLAG_SET_DEFAULT(UseChaCha20Intrinsics, false);\n+  }\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.cpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -143,1 +143,2 @@\n-      guarantee(is_in_range_of_RelAddr(target, pc, shortForm), \"target not within reach\");\n+      guarantee(is_in_range_of_RelAddr(target, pc, shortForm),\n+                \"target not within reach at \" INTPTR_FORMAT \", distance = \" INTX_FORMAT, p2i(pc), (target - pc) );\n","filename":"src\/hotspot\/cpu\/s390\/assembler_s390.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -104,1 +104,1 @@\n-    z_btrue(slow_case);\n+    branch_optimized(Assembler::bcondAllOne, slow_case);\n@@ -173,1 +173,1 @@\n-    z_brnz(slow_case);\n+    branch_optimized(Assembler::bcondNotZero, slow_case);\n","filename":"src\/hotspot\/cpu\/s390\/c1_MacroAssembler_s390.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"oops\/resolvedFieldEntry.hpp\"\n@@ -352,1 +353,1 @@\n-  \/\/ Get index out of bytecode pointer, get_cache_entry_pointer_at_bcp\n+  \/\/ Get index out of bytecode pointer.\n@@ -354,1 +355,2 @@\n-  \/\/ Get address of invokedynamic array\n+\n+  \/\/ Get the address of the ResolvedIndyEntry array\n@@ -357,2 +359,10 @@\n-  \/\/ Scale the index to be the entry index * sizeof(ResolvedInvokeDynamicInfo)\n-  z_sllg(index, index, exact_log2(sizeof(ResolvedIndyEntry)));\n+\n+  \/\/ Scale the index to form a byte offset into the ResolvedIndyEntry array\n+  size_t entry_size = sizeof(ResolvedIndyEntry);\n+  if (is_power_of_2(entry_size)) {\n+    z_sllg(index, index, exact_log2(entry_size));\n+  } else {\n+    z_mghi(index, entry_size);\n+  }\n+\n+  \/\/ Calculate the final field address.\n@@ -362,0 +372,20 @@\n+void InterpreterMacroAssembler::load_field_entry(Register cache, Register index, int bcp_offset) {\n+  \/\/ Get field index out of bytecode pointer.\n+  get_cache_index_at_bcp(index, bcp_offset, sizeof(u2));\n+\n+  \/\/ Get the address of the ResolvedFieldEntry array.\n+  get_constant_pool_cache(cache);\n+  z_lg(cache, Address(cache, in_bytes(ConstantPoolCache::field_entries_offset())));\n+\n+  \/\/ Scale the index to form a byte offset into the ResolvedFieldEntry array\n+  size_t entry_size = sizeof(ResolvedFieldEntry);\n+  if (is_power_of_2(entry_size)) {\n+    z_sllg(index, index, exact_log2(entry_size));\n+  } else {\n+    z_mghi(index, entry_size);\n+  }\n+\n+  \/\/ Calculate the final field address.\n+  z_la(cache, Array<ResolvedFieldEntry>::base_offset_in_bytes(), index, cache);\n+}\n+\n","filename":"src\/hotspot\/cpu\/s390\/interp_masm_s390.cpp","additions":34,"deletions":4,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -116,0 +116,1 @@\n+  void load_field_entry(Register cache, Register index, int bcp_offset = 1);\n","filename":"src\/hotspot\/cpu\/s390\/interp_masm_s390.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"prims\/upcallLinker.hpp\"\n@@ -3097,0 +3098,15 @@\n+  \/\/ exception handler for upcall stubs\n+  address generate_upcall_stub_exception_handler() {\n+    StubCodeMark mark(this, \"StubRoutines\", \"upcall stub exception handler\");\n+    address start = __ pc();\n+\n+    \/\/ Native caller has no idea how to handle exceptions,\n+    \/\/ so we just crash here. Up to callee to catch exceptions.\n+    __ verify_oop(Z_ARG1);\n+    __ load_const_optimized(Z_R1_scratch, CAST_FROM_FN_PTR(uint64_t, UpcallLinker::handle_uncaught_exception));\n+    __ call_c(Z_R1_scratch);\n+    __ should_not_reach_here();\n+\n+    return start;\n+  }\n+\n@@ -3177,0 +3193,1 @@\n+    StubRoutines::_upcall_stub_exception_handler = generate_upcall_stub_exception_handler();\n","filename":"src\/hotspot\/cpu\/s390\/stubGenerator_s390.cpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"oops\/resolvedFieldEntry.hpp\"\n@@ -79,4 +80,3 @@\n-    __ z_larl(Z_R0, (int64_t)0);     \/* Check current address alignment. *\/    \\\n-    __ z_slgr(Z_R0, br_tab);         \/* Current Address must be equal    *\/    \\\n-    __ z_slgr(Z_R0, flags);          \/* to calculated branch target.     *\/    \\\n-    __ z_brc(Assembler::bcondLogZero, 3); \/* skip trap if ok. *\/               \\\n+    __ z_larl(br_tab_temp, (int64_t)0);  \/* Check current address alignment. *\/\\\n+    __ z_slgr(br_tab_temp, br_tab);      \/* Current Address must be equal    *\/\\\n+    __ z_brc(Assembler::bcondLogZero, 3);\/* skip trap if ok. *\/                \\\n@@ -254,2 +254,6 @@\n-        __ get_cache_and_index_and_bytecode_at_bcp(Z_R1_scratch, bc_reg,\n-                                                   temp_reg, byte_no, 1);\n+\n+        \/\/ Both registers are block-local temp regs. Their contents before and after is not used.\n+        Register index = bc_reg;\n+        Register cache = temp_reg;\n+\n+        __ load_field_entry(cache, index);\n@@ -257,2 +261,7 @@\n-        __ compareU32_and_branch(temp_reg, (intptr_t)0,\n-                                 Assembler::bcondZero, L_patch_done);\n+\n+        if (byte_no == f1_byte) {\n+          __ z_cli(Address(cache, in_bytes(ResolvedFieldEntry::get_code_offset())), 0);\n+        } else {\n+          __ z_cli(Address(cache, in_bytes(ResolvedFieldEntry::put_code_offset())), 0);\n+        }\n+        __ z_bre(L_patch_done);\n@@ -263,1 +272,1 @@\n-      \/\/ The pair bytecodes have already done the load.\n+      \/\/ The bytecode pair may have already performed the load.\n@@ -271,2 +280,1 @@\n-\n-    Label   L_fast_patch;\n+    NearLabel L_fast_patch;\n@@ -277,0 +285,1 @@\n+\n@@ -281,1 +290,1 @@\n-                      temp_reg, Z_R13, bc_reg);\n+                      temp_reg, Z_bcp, bc_reg);\n@@ -2345,1 +2354,1 @@\n-\/\/ NOTE: Cpe_offset is already computed as byte offset, so we must not\n+\/\/ NOTE: index is already computed as byte offset, so we must not\n@@ -2349,1 +2358,1 @@\n-                                            Register cpe_offset,\n+                                            Register index,\n@@ -2351,5 +2360,0 @@\n-  BLOCK_COMMENT(\"resolve_cache_and_index {\");\n-  NearLabel      resolved, clinit_barrier_slow;\n-  const Register bytecode_in_cpcache = Z_R1_scratch;\n-  const int      total_f1_offset = in_bytes(ConstantPoolCache::base_offset() + ConstantPoolCacheEntry::f1_offset());\n-  assert_different_registers(cache, cpe_offset, bytecode_in_cpcache);\n@@ -2357,0 +2361,5 @@\n+  assert_different_registers(cache, index, Z_R1_scratch);\n+  assert(byte_no == f1_byte || byte_no == f2_byte, \"byte_no out of range\");\n+\n+  const Register  bytecode_in_cpcache = Z_R1_scratch;\n+  NearLabel       resolved, clinit_barrier_slow;\n@@ -2358,6 +2367,0 @@\n-  switch (code) {\n-    case Bytecodes::_nofast_getfield: code = Bytecodes::_getfield; break;\n-    case Bytecodes::_nofast_putfield: code = Bytecodes::_putfield; break;\n-    default:\n-      break;\n-  }\n@@ -2365,6 +2368,5 @@\n-  {\n-    assert(byte_no == f1_byte || byte_no == f2_byte, \"byte_no out of range\");\n-    __ get_cache_and_index_and_bytecode_at_bcp(cache, cpe_offset, bytecode_in_cpcache, byte_no, 1, index_size);\n-    \/\/ Have we resolved this bytecode?\n-    __ compare32_and_branch(bytecode_in_cpcache, (int)code, Assembler::bcondEqual, resolved);\n-  }\n+  BLOCK_COMMENT(\"resolve_cache_and_index {\");\n+\n+  __ get_cache_and_index_and_bytecode_at_bcp(cache, index, bytecode_in_cpcache, byte_no, 1, index_size);\n+  \/\/ Have we resolved this bytecode?\n+  __ compare32_and_branch(bytecode_in_cpcache, (int)code, Assembler::bcondEqual, resolved);\n@@ -2372,1 +2374,1 @@\n-  \/\/ Resolve first time through.\n+  \/\/ Resolve first time through via runtime call.\n@@ -2376,1 +2378,1 @@\n-  __ load_const_optimized(Z_ARG2, (int) code);\n+  __ load_const_optimized(Z_ARG2, (int)code);\n@@ -2378,1 +2380,0 @@\n-\n@@ -2380,1 +2381,2 @@\n-  __ get_cache_and_index_at_bcp(cache, cpe_offset, 1, index_size);\n+  __ get_cache_and_index_at_bcp(cache, index, 1, index_size);\n+\n@@ -2388,1 +2390,1 @@\n-    __ load_resolved_method_at_index(byte_no, cache, cpe_offset, method);\n+    __ load_resolved_method_at_index(byte_no, cache, index, method);\n@@ -2396,0 +2398,63 @@\n+void TemplateTable::resolve_cache_and_index_for_field(int byte_no,\n+                                                      Register cache,\n+                                                      Register index) {\n+\n+  assert_different_registers(cache, index);\n+  assert(byte_no == f1_byte || byte_no == f2_byte, \"byte_no out of range\");\n+\n+  NearLabel resolved;\n+\n+  Bytecodes::Code code = bytecode();\n+  switch (code) {\n+    case Bytecodes::_nofast_getfield: code = Bytecodes::_getfield; break;\n+    case Bytecodes::_nofast_putfield: code = Bytecodes::_putfield; break;\n+    default: break;\n+  }\n+\n+  __ load_field_entry(cache, index);\n+  if (byte_no == f1_byte) {\n+    __ z_cli(Address(cache, in_bytes(ResolvedFieldEntry::get_code_offset())), code);\n+  } else {\n+    __ z_cli(Address(cache, in_bytes(ResolvedFieldEntry::put_code_offset())), code);\n+  }\n+  __ z_bre(resolved);\n+\n+  \/\/ resolve first time through\n+  address entry = CAST_FROM_FN_PTR(address, InterpreterRuntime::resolve_from_cache);\n+  __ load_const_optimized(Z_ARG2, (int)code);\n+  __ call_VM(noreg, entry, Z_ARG2);\n+\n+  \/\/ Update registers with resolved info.\n+  __ load_field_entry(cache, index);\n+\n+  __ bind(resolved);\n+}\n+\n+\/\/ The cache register (the only input reg) must be set before call.\n+void TemplateTable::load_resolved_field_entry(Register obj,\n+                                              Register cache,\n+                                              Register tos_state,\n+                                              Register offset,\n+                                              Register flags,\n+                                              bool is_static = false) {\n+  assert_different_registers(cache, tos_state, flags, offset);\n+\n+  \/\/ Field offset\n+  __ load_sized_value(offset, Address(cache, in_bytes(ResolvedFieldEntry::field_offset_offset())), sizeof(int), true \/*is_signed*\/);\n+\n+  \/\/ Flags\n+  __ load_sized_value(flags, Address(cache, in_bytes(ResolvedFieldEntry::flags_offset())), sizeof(u1), false);\n+\n+  \/\/ TOS state\n+  if (tos_state != noreg) {\n+    __ load_sized_value(tos_state, Address(cache, in_bytes(ResolvedFieldEntry::type_offset())), sizeof(u1), false);\n+  }\n+\n+  \/\/ Klass overwrite register\n+  if (is_static) {\n+    __ load_sized_value(obj, Address(cache, ResolvedFieldEntry::field_holder_offset()), sizeof(void*), false);\n+    __ load_sized_value(obj, Address(obj, in_bytes(Klass::java_mirror_offset())), sizeof(void*), false);\n+    __ resolve_oop_handle(obj);\n+  }\n+}\n+\n@@ -2523,2 +2588,4 @@\n-\/\/ The registers cache and index expected to be set before call.\n-\/\/ Correct values of the cache and index registers are preserved.\n+\/\/ The registers cache and index are set up if needed.\n+\/\/ However, the field entry must have been resolved before.\n+\/\/ If no jvmti post operation is performed, their contents remains unchanged.\n+\/\/ After a jvmti post operation, the registers are re-calculated by load_field_entry().\n@@ -2537,1 +2604,1 @@\n-  Label exit;\n+  Label dontPost;\n@@ -2540,5 +2607,2 @@\n-  __ load_and_test_int(Z_R0, Address(Z_tos));\n-  __ z_brz(exit);\n-\n-  \/\/ Index is returned as byte offset, do not shift!\n-  __ get_cache_and_index_at_bcp(Z_ARG3, Z_R1_scratch, 1);\n+  __ z_chsi(0, Z_tos, 0); \/\/ avoid loading data into a scratch register\n+  __ z_bre(dontPost);\n@@ -2547,3 +2611,1 @@\n-  __ add2reg_with_index(Z_ARG3,\n-                        in_bytes(ConstantPoolCache::base_offset()),\n-                        Z_ARG3, Z_R1_scratch);\n+  \/\/ __ load_field_entry(cache, index); \/\/ not required as already set by resolve_cache_and_index_for_field()\n@@ -2554,1 +2616,1 @@\n-    __ mem2reg_opt(Z_ARG2, at_tos());  \/\/ Get object pointer without popping it.\n+    __ load_ptr(0, Z_ARG2);  \/\/ Get object pointer without popping it.\n@@ -2557,0 +2619,1 @@\n+\n@@ -2558,1 +2621,1 @@\n-  \/\/ Z_ARG3: cache entry pointer\n+  \/\/ cache:  cache entry pointer\n@@ -2561,2 +2624,1 @@\n-             Z_ARG2, Z_ARG3);\n-  __ get_cache_and_index_at_bcp(cache, index, 1);\n+             Z_ARG2, cache);\n@@ -2564,1 +2626,4 @@\n-  __ bind(exit);\n+  \/\/ restore registers after runtime call.\n+  __ load_field_entry(cache, index);\n+\n+  __ bind(dontPost);\n@@ -2576,6 +2641,14 @@\n-  const Register cache = Z_tmp_1;\n-  const Register index = Z_tmp_2;\n-  const Register obj   = Z_tmp_1;\n-  const Register off   = Z_ARG2;\n-  const Register flags = Z_ARG1;\n-  const Register bc    = Z_tmp_1;  \/\/ Uses same reg as obj, so don't mix them.\n+  const Register obj           = Z_tmp_1;\n+  const Register off           = Z_tmp_2;\n+  const Register cache         = Z_tmp_1;\n+  const Register index         = Z_tmp_2;\n+  const Register flags         = Z_R1_scratch; \/\/ flags are not used in getfield\n+  const Register br_tab        = Z_R1_scratch;\n+  const Register tos_state     = Z_ARG4;\n+  const Register bc_reg        = Z_tmp_1;\n+  const Register patch_tmp     = Z_ARG4;\n+  const Register oopLoad_tmp1  = Z_R1_scratch;\n+  const Register oopLoad_tmp2  = Z_ARG5;\n+#ifdef ASSERT\n+  const Register br_tab_temp   = Z_R0_scratch;  \/\/ for branch table verification code only\n+#endif\n@@ -2583,1 +2656,12 @@\n-  resolve_cache_and_index(byte_no, cache, index, sizeof(u2));\n+\n+  \/\/ Register usage and life range\n+  \/\/\n+  \/\/  cache, index          : short-lived. Their life ends after load_resolved_field_entry.\n+  \/\/  obj (overwrites cache): long-lived. Used in branch table entries.\n+  \/\/  off (overwrites index): long-lived. Used in branch table entries.\n+  \/\/  flags                 : unused in getfield.\n+  \/\/  br_tab                : short-lived. Only used to address branch table, and for verification in BTB_BEGIN macro.\n+  \/\/  tos_state             : short-lived. Only used to index the branch table entry.\n+  \/\/  bc_reg                : short-lived. Used as work register in patch_bytecode.\n+  \/\/\n+  resolve_cache_and_index_for_field(byte_no, cache, index);\n@@ -2585,1 +2669,1 @@\n-  load_field_cp_cache_entry(obj, cache, index, off, flags, is_static);\n+  load_resolved_field_entry(obj, cache, tos_state, off, flags, is_static);\n@@ -2592,1 +2676,1 @@\n-  \/\/ Displacement is 0, so any store instruction will be fine on any CPU.\n+  \/\/ Displacement is 0. No need to care about limited displacement range.\n@@ -2595,1 +2679,1 @@\n-  Label    is_Byte, is_Bool, is_Int, is_Short, is_Char,\n+  Label    is_Byte, is_Bool,  is_Int,    is_Short, is_Char,\n@@ -2597,3 +2681,2 @@\n-  Label    is_badState8, is_badState9, is_badStateA, is_badStateB,\n-           is_badStateC, is_badStateD, is_badStateE, is_badStateF,\n-           is_badState;\n+  Label    is_badState,  is_badState9, is_badStateA, is_badStateB,\n+           is_badStateC, is_badStateD, is_badStateE, is_badStateF;\n@@ -2601,1 +2684,0 @@\n-  Register br_tab       = Z_R1_scratch;\n@@ -2606,1 +2688,1 @@\n-  assert(btos == 0, \"change code, btos != 0\");\n+  assert((btos == 0) && (atos == 8), \"change branch table! ByteCodes may have changed\");\n@@ -2612,0 +2694,1 @@\n+  \/\/ Calculate branch table size.\n@@ -2618,3 +2701,0 @@\n-    const int r_bitpos  = 63 - bit_shift;\n-    const int l_bitpos  = r_bitpos - ConstantPoolCacheEntry::tos_state_bits + 1;\n-    const int n_rotate  = (bit_shift-ConstantPoolCacheEntry::tos_state_shift);\n@@ -2622,1 +2702,4 @@\n-    __ rotate_then_insert(flags, flags, l_bitpos, r_bitpos, n_rotate, true);\n+    __ z_sllg(tos_state, tos_state, bit_shift);\n+    assert(tos_state != Z_R0_scratch, \"shouldn't be\");\n+    __ z_agr(br_tab, tos_state);\n+    __ z_bcr(Assembler::bcondAlways, br_tab);\n@@ -2624,1 +2707,0 @@\n-  __ z_bc(Assembler::bcondAlways, 0, flags, br_tab);\n@@ -2635,1 +2717,1 @@\n-    patch_bytecode(Bytecodes::_fast_bgetfield, bc, Z_ARG5);\n+    patch_bytecode(Bytecodes::_fast_bgetfield, bc_reg, patch_tmp);\n@@ -2647,1 +2729,1 @@\n-    patch_bytecode(Bytecodes::_fast_bgetfield, bc, Z_ARG5);\n+    patch_bytecode(Bytecodes::_fast_bgetfield, bc_reg, patch_tmp);\n@@ -2659,1 +2741,1 @@\n-    patch_bytecode(Bytecodes::_fast_cgetfield, bc, Z_ARG5);\n+    patch_bytecode(Bytecodes::_fast_cgetfield, bc_reg, patch_tmp);\n@@ -2670,1 +2752,1 @@\n-    patch_bytecode(Bytecodes::_fast_sgetfield, bc, Z_ARG5);\n+    patch_bytecode(Bytecodes::_fast_sgetfield, bc_reg, patch_tmp);\n@@ -2681,1 +2763,1 @@\n-    patch_bytecode(Bytecodes::_fast_igetfield, bc, Z_ARG5);\n+    patch_bytecode(Bytecodes::_fast_igetfield, bc_reg, patch_tmp);\n@@ -2692,1 +2774,1 @@\n-    patch_bytecode(Bytecodes::_fast_lgetfield, bc, Z_ARG5);\n+    patch_bytecode(Bytecodes::_fast_lgetfield, bc_reg, patch_tmp);\n@@ -2703,1 +2785,1 @@\n-    patch_bytecode(Bytecodes::_fast_fgetfield, bc, Z_ARG5);\n+    patch_bytecode(Bytecodes::_fast_fgetfield, bc_reg, patch_tmp);\n@@ -2714,1 +2796,1 @@\n-    patch_bytecode(Bytecodes::_fast_dgetfield, bc, Z_ARG5);\n+    patch_bytecode(Bytecodes::_fast_dgetfield, bc_reg, patch_tmp);\n@@ -2725,4 +2807,0 @@\n-  BTB_BEGIN(is_badState8, bsize, \"getfield_or_static:is_badState8\");\n-  __ z_illtrap();\n-  __ z_bru(is_badState);\n-  BTB_END( is_badState8, bsize, \"getfield_or_static:is_badState8\");\n@@ -2732,1 +2810,1 @@\n-  BTB_END( is_badState9, bsize, \"getfield_or_static:is_badState9\");\n+  BTB_END(is_badState9, bsize, \"getfield_or_static:is_badState9\");\n@@ -2736,1 +2814,1 @@\n-  BTB_END( is_badStateA, bsize, \"getfield_or_static:is_badStateA\");\n+  BTB_END(is_badStateA, bsize, \"getfield_or_static:is_badStateA\");\n@@ -2740,1 +2818,1 @@\n-  BTB_END( is_badStateB, bsize, \"getfield_or_static:is_badStateB\");\n+  BTB_END(is_badStateB, bsize, \"getfield_or_static:is_badStateB\");\n@@ -2744,1 +2822,1 @@\n-  BTB_END( is_badStateC, bsize, \"getfield_or_static:is_badStateC\");\n+  BTB_END(is_badStateC, bsize, \"getfield_or_static:is_badStateC\");\n@@ -2748,1 +2826,1 @@\n-  BTB_END( is_badStateD, bsize, \"getfield_or_static:is_badStateD\");\n+  BTB_END(is_badStateD, bsize, \"getfield_or_static:is_badStateD\");\n@@ -2752,1 +2830,1 @@\n-  BTB_END( is_badStateE, bsize, \"getfield_or_static:is_badStateE\");\n+  BTB_END(is_badStateE, bsize, \"getfield_or_static:is_badStateE\");\n@@ -2756,1 +2834,1 @@\n-  BTB_END( is_badStateF, bsize, \"getfield_or_static:is_badStateF\");\n+  BTB_END(is_badStateF, bsize, \"getfield_or_static:is_badStateF\");\n@@ -2778,1 +2856,1 @@\n-    do_oop_load(_masm, field, Z_tos, Z_tmp_2, Z_tmp_3, IN_HEAP);\n+    do_oop_load(_masm, field, Z_tos, oopLoad_tmp1, oopLoad_tmp2, IN_HEAP);\n@@ -2782,1 +2860,1 @@\n-      patch_bytecode(Bytecodes::_fast_agetfield, bc, Z_ARG5);\n+      patch_bytecode(Bytecodes::_fast_agetfield, bc_reg, patch_tmp);\n@@ -2806,3 +2884,3 @@\n-\/\/ The registers cache and index expected to be set before call.  The\n-\/\/ function may destroy various registers, just not the cache and\n-\/\/ index registers.\n+\/\/ Register cache is expected to be set before the call.\n+\/\/ This function may destroy various registers.\n+\/\/ Only the contents of register cache is preserved\/restored.\n@@ -2819,6 +2897,4 @@\n-  \/\/ Check to see if a field modification watch has been set before\n-  \/\/ we take the time to call into the VM.\n-  Label    L1;\n-  ByteSize cp_base_offset = ConstantPoolCache::base_offset();\n-  assert_different_registers(cache, index, Z_tos);\n-\n+  \/\/ Check to see if a field modification watch has been set\n+  \/\/ before we take the time to call into the VM.\n+  Label    dontPost;\n+  assert_different_registers(cache, index, Z_tos, Z_ARG2, Z_ARG3, Z_ARG4);\n@@ -2826,2 +2902,6 @@\n-  __ load_and_test_int(Z_R0, Address(Z_tos));\n-  __ z_brz(L1);\n+  __ z_chsi(0, Z_tos, 0); \/\/ avoid loading data into a scratch register\n+  __ z_bre(dontPost);\n+\n+  Register obj        = Z_ARG2;\n+  Register fieldEntry = Z_ARG3;\n+  Register value      = Z_ARG4;\n@@ -2829,2 +2909,2 @@\n-  \/\/ Index is returned as byte offset, do not shift!\n-  __ get_cache_and_index_at_bcp(Z_ARG3, Z_R1_scratch, 1);\n+  \/\/ Take a copy of cache entry pointer\n+  __ z_lgr(fieldEntry, cache);\n@@ -2833,2 +2913,2 @@\n-    \/\/ Life is simple. Null out the object pointer.\n-    __ clear_reg(Z_ARG2, true, false);   \/\/ Don't set CC.\n+    \/\/ Life is simple. NULL the object pointer.\n+    __ clear_reg(obj, true, false); \/\/ Don't set CC.\n@@ -2840,9 +2920,1 @@\n-    __ mem2reg_opt(Z_ARG4,\n-                   Address(Z_ARG3, Z_R1_scratch,\n-                           in_bytes(cp_base_offset + ConstantPoolCacheEntry::flags_offset()) +\n-                           (BytesPerLong - BytesPerInt)),\n-                   false);\n-    __ z_srl(Z_ARG4, ConstantPoolCacheEntry::tos_state_shift);\n-    \/\/ Make sure we don't need to mask Z_ARG4 for tos_state after the above shift.\n-    ConstantPoolCacheEntry::verify_tos_state_shift();\n-    __ mem2reg_opt(Z_ARG2, at_tos(1));  \/\/ Initially assume a one word jvalue.\n+    __ load_sized_value(value, Address(fieldEntry, in_bytes(ResolvedFieldEntry::type_offset())), sizeof(u1), false);\n@@ -2850,1 +2922,1 @@\n-    NearLabel   load_dtos, cont;\n+    __ mem2reg_opt(obj, at_tos(1)); \/\/ Initially assume a one word jvalue.\n@@ -2852,4 +2924,7 @@\n-    __ compareU32_and_branch(Z_ARG4, (intptr_t) ltos,\n-                              Assembler::bcondNotEqual, load_dtos);\n-    __ mem2reg_opt(Z_ARG2, at_tos(2)); \/\/ ltos (two word jvalue)\n-    __ z_bru(cont);\n+    if (VM_Version::has_LoadStoreConditional()) {\n+      __ z_chi(value, ltos);\n+      __ z_locg(obj, at_tos(2), Assembler::bcondEqual);\n+      __ z_chi(value, dtos);\n+      __ z_locg(obj, at_tos(2), Assembler::bcondEqual);\n+    } else {\n+      NearLabel load_dtos, cont;\n@@ -2857,3 +2932,4 @@\n-    __ bind(load_dtos);\n-    __ compareU32_and_branch(Z_ARG4, (intptr_t)dtos, Assembler::bcondNotEqual, cont);\n-    __ mem2reg_opt(Z_ARG2, at_tos(2)); \/\/ dtos (two word jvalue)\n+      __ z_chi(value, ltos);\n+      __ z_brne(load_dtos);\n+      __ mem2reg_opt(obj, at_tos(2)); \/\/ ltos (two word jvalue)\n+      __ z_bru(cont);\n@@ -2861,3 +2937,4 @@\n-    __ bind(cont);\n-  }\n-  \/\/ cache entry pointer\n+      __ bind(load_dtos);\n+      __ z_chi(value, dtos);\n+      __ z_brne(cont);\n+      __ mem2reg_opt(obj, at_tos(2)); \/\/ dtos (two word jvalue)\n@@ -2865,1 +2942,3 @@\n-  __ add2reg_with_index(Z_ARG3, in_bytes(cp_base_offset), Z_ARG3, Z_R1_scratch);\n+      __ bind(cont);\n+    }\n+  }\n@@ -2868,4 +2947,4 @@\n-  __ load_address(Z_ARG4, Address(Z_esp, Interpreter::stackElementSize));\n-  \/\/ Z_ARG2: object pointer set up above (null if static)\n-  \/\/ Z_ARG3: cache entry pointer\n-  \/\/ Z_ARG4: jvalue object on the stack\n+  __ load_address(value, Address(Z_esp, Interpreter::expr_offset_in_bytes(0)));\n+  \/\/ obj:        object pointer set up above (null if static)\n+  \/\/ fieldEntry: field entry pointer\n+  \/\/ value:      jvalue object on the stack\n@@ -2874,2 +2953,1 @@\n-             Z_ARG2, Z_ARG3, Z_ARG4);\n-  __ get_cache_and_index_at_bcp(cache, index, 1);\n+             obj, fieldEntry, value);\n@@ -2877,1 +2955,4 @@\n-  __ bind(L1);\n+  \/\/ Reload field entry\n+  __ load_field_entry(cache, index);\n+\n+  __ bind(dontPost);\n@@ -2885,3 +2966,1 @@\n-  const Register cache         = Z_tmp_1;\n-  const Register index         = Z_ARG5;\n-  const Register obj           = Z_tmp_1;\n+  const Register obj           = Z_ARG5;\n@@ -2889,3 +2968,8 @@\n-  const Register flags         = Z_R1_scratch;\n-  const Register br_tab        = Z_ARG5;\n-  const Register bc            = Z_tmp_1;\n+  const Register cache         = Z_ARG5;\n+  const Register index         = Z_tmp_2;\n+  const Register fieldAddr     = Z_tmp_2;      \/\/ contains obj and off combined. Could be any address register.\n+  const Register flags         = Z_tmp_1;      \/\/ preserves flag value till the end, for volatility check\n+  const Register br_tab        = Z_R1_scratch;\n+  const Register tos_state     = Z_ARG4;\n+  const Register bc_reg        = Z_tmp_2;\n+  const Register patch_tmp     = Z_ARG4;\n@@ -2893,1 +2977,1 @@\n-  const Register oopStore_tmp2 = Z_ARG5;\n+  const Register oopStore_tmp2 = Z_ARG5;       \/\/ tmp2 must be non-volatile reg\n@@ -2895,0 +2979,3 @@\n+#ifdef ASSERT\n+  const Register br_tab_temp   = Z_R0_scratch; \/\/ for branch table verification code only\n+#endif\n@@ -2896,1 +2983,12 @@\n-  resolve_cache_and_index(byte_no, cache, index, sizeof(u2));\n+\/*\n+ *  Register usage and life range\n+ *\n+ *  cache, index          : short-lived. Their life ends after load_resolved_field_entry.\n+ *  obj (overwrites cache): very short-lived, Combined with off immediately.\n+ *  off (overwrites index): long-lived, Used in branch table entries.\n+ *  flags                 : long-lived, Has to survive until the end to determine volatility.\n+ *  br_tab                : short-lived, Only used to address branch table, and for verification in BTB_BEGIN macro.\n+ *  tos_state             : short-live, Only used to index the branch table entry.\n+ *  bc_reg                : short-lived, Used as work register in patch_bytecode.\n+*\/\n+  resolve_cache_and_index_for_field(byte_no, cache, index);\n@@ -2898,6 +2996,16 @@\n-  load_field_cp_cache_entry(obj, cache, index, off, flags, is_static);\n-  \/\/ begin of life for:\n-  \/\/   obj, off   long life range\n-  \/\/   flags      short life range, up to branch into branch table\n-  \/\/ end of life for:\n-  \/\/   cache, index\n+  load_resolved_field_entry(obj, cache, tos_state, off, flags, is_static);\n+\n+  const Address field(fieldAddr);\n+  __ lgr_if_needed(fieldAddr, off);\n+\n+  \/*\n+   * In the static case, we can calculate the final field address easily.\n+   * Do so to occupy only one non-volatile register\n+   * ---------------------\n+   * In the non-static case, we preset fieldAddr with the field offset.\n+   * The object address is available only later. It is popped from stack.\n+   * see pop_and_check_object(obj);\n+   *\/\n+  if (is_static) {\n+    __ z_agr(fieldAddr, obj);\n+  }\n@@ -2905,2 +3013,1 @@\n-  const Address field(obj, off);\n-  Label is_Byte, is_Bool, is_Int, is_Short, is_Char,\n+  Label is_Byte, is_Bool,  is_Int,    is_Short, is_Char,\n@@ -2908,3 +3015,2 @@\n-  Label is_badState8, is_badState9, is_badStateA, is_badStateB,\n-        is_badStateC, is_badStateD, is_badStateE, is_badStateF,\n-        is_badState;\n+  Label is_badState,  is_badState9, is_badStateA, is_badStateB,\n+        is_badStateC, is_badStateD, is_badStateE, is_badStateF;\n@@ -2916,2 +3022,1 @@\n-\n-  assert(btos == 0, \"change code, btos != 0\");\n+  assert((btos == 0) && (atos == 8), \"change branch table! ByteCodes may have changed\");\n@@ -2920,1 +3025,1 @@\n-  const unsigned int bsize = is_static ? BTB_MINSIZE*1 : BTB_MINSIZE*4;\n+  const unsigned int bsize = is_static ? BTB_MINSIZE*1 : BTB_MINSIZE*8;\n@@ -2928,3 +3033,0 @@\n-    const int r_bitpos  = 63 - bit_shift;\n-    const int l_bitpos  = r_bitpos - ConstantPoolCacheEntry::tos_state_bits + 1;\n-    const int n_rotate  = (bit_shift-ConstantPoolCacheEntry::tos_state_shift);\n@@ -2932,2 +3034,4 @@\n-    __ rotate_then_insert(flags, flags, l_bitpos, r_bitpos, n_rotate, true);\n-    __ z_bc(Assembler::bcondAlways, 0, flags, br_tab);\n+    __ z_sllg(tos_state, tos_state, bit_shift);\n+    assert(tos_state != Z_R0_scratch, \"shouldn't be\");\n+    __ z_agr(br_tab, tos_state);\n+    __ z_bcr(Assembler::bcondAlways, br_tab);\n@@ -2935,2 +3039,0 @@\n-  \/\/ end of life for:\n-  \/\/   flags, br_tab\n@@ -2946,0 +3048,1 @@\n+    __ z_agr(fieldAddr, obj);\n@@ -2949,1 +3052,1 @@\n-    patch_bytecode(Bytecodes::_fast_bputfield, bc, Z_ARG5, true, byte_no);\n+    patch_bytecode(Bytecodes::_fast_bputfield, bc_reg, patch_tmp, true, byte_no);\n@@ -2952,1 +3055,1 @@\n-  BTB_END( is_Byte, bsize, \"putfield_or_static:is_Byte\");\n+  BTB_END(is_Byte, bsize, \"putfield_or_static:is_Byte\");\n@@ -2959,0 +3062,1 @@\n+    __ z_agr(fieldAddr, obj);\n@@ -2963,1 +3067,1 @@\n-    patch_bytecode(Bytecodes::_fast_zputfield, bc, Z_ARG5, true, byte_no);\n+    patch_bytecode(Bytecodes::_fast_zputfield, bc_reg, patch_tmp, true, byte_no);\n@@ -2973,0 +3077,1 @@\n+    __ z_agr(fieldAddr, obj);\n@@ -2976,1 +3081,1 @@\n-    patch_bytecode(Bytecodes::_fast_cputfield, bc, Z_ARG5, true, byte_no);\n+    patch_bytecode(Bytecodes::_fast_cputfield, bc_reg, patch_tmp, true, byte_no);\n@@ -2979,1 +3084,1 @@\n-  BTB_END( is_Char, bsize, \"putfield_or_static:is_Char\");\n+  BTB_END(is_Char, bsize, \"putfield_or_static:is_Char\");\n@@ -2986,0 +3091,1 @@\n+    __ z_agr(fieldAddr, obj);\n@@ -2989,1 +3095,1 @@\n-    patch_bytecode(Bytecodes::_fast_sputfield, bc, Z_ARG5, true, byte_no);\n+    patch_bytecode(Bytecodes::_fast_sputfield, bc_reg, patch_tmp, true, byte_no);\n@@ -2992,1 +3098,1 @@\n-  BTB_END( is_Short, bsize, \"putfield_or_static:is_Short\");\n+  BTB_END(is_Short, bsize, \"putfield_or_static:is_Short\");\n@@ -2999,0 +3105,1 @@\n+    __ z_agr(fieldAddr, obj);\n@@ -3002,1 +3109,1 @@\n-    patch_bytecode(Bytecodes::_fast_iputfield, bc, Z_ARG5, true, byte_no);\n+    patch_bytecode(Bytecodes::_fast_iputfield, bc_reg, patch_tmp, true, byte_no);\n@@ -3005,1 +3112,1 @@\n-  BTB_END( is_Int, bsize, \"putfield_or_static:is_Int\");\n+  BTB_END(is_Int, bsize, \"putfield_or_static:is_Int\");\n@@ -3012,0 +3119,1 @@\n+    __ z_agr(fieldAddr, obj);\n@@ -3015,1 +3123,1 @@\n-    patch_bytecode(Bytecodes::_fast_lputfield, bc, Z_ARG5, true, byte_no);\n+    patch_bytecode(Bytecodes::_fast_lputfield, bc_reg, patch_tmp, true, byte_no);\n@@ -3018,1 +3126,1 @@\n-  BTB_END( is_Long, bsize, \"putfield_or_static:is_Long\");\n+  BTB_END(is_Long, bsize, \"putfield_or_static:is_Long\");\n@@ -3025,0 +3133,1 @@\n+    __ z_agr(fieldAddr, obj);\n@@ -3028,1 +3137,1 @@\n-    patch_bytecode(Bytecodes::_fast_fputfield, bc, Z_ARG5, true, byte_no);\n+    patch_bytecode(Bytecodes::_fast_fputfield, bc_reg, patch_tmp, true, byte_no);\n@@ -3031,1 +3140,1 @@\n-  BTB_END( is_Float, bsize, \"putfield_or_static:is_Float\");\n+  BTB_END(is_Float, bsize, \"putfield_or_static:is_Float\");\n@@ -3038,0 +3147,1 @@\n+    __ z_agr(fieldAddr, obj);\n@@ -3041,1 +3151,1 @@\n-    patch_bytecode(Bytecodes::_fast_dputfield, bc, Z_ARG5, true, byte_no);\n+    patch_bytecode(Bytecodes::_fast_dputfield, bc_reg, patch_tmp, true, byte_no);\n@@ -3044,1 +3154,1 @@\n-  BTB_END( is_Double, bsize, \"putfield_or_static:is_Double\");\n+  BTB_END(is_Double, bsize, \"putfield_or_static:is_Double\");\n@@ -3049,1 +3159,1 @@\n-  BTB_END( is_Object, bsize, \"putfield_or_static:is_Object\");\n+  BTB_END(is_Object, bsize, \"putfield_or_static:is_Object\");\n@@ -3052,4 +3162,0 @@\n-  BTB_BEGIN(is_badState8, bsize, \"putfield_or_static:is_badState8\");\n-  __ z_illtrap();\n-  __ z_bru(is_badState);\n-  BTB_END( is_badState8, bsize, \"putfield_or_static:is_badState8\");\n@@ -3059,1 +3165,1 @@\n-  BTB_END( is_badState9, bsize, \"putfield_or_static:is_badState9\");\n+  BTB_END(is_badState9, bsize, \"putfield_or_static:is_badState9\");\n@@ -3063,1 +3169,1 @@\n-  BTB_END( is_badStateA, bsize, \"putfield_or_static:is_badStateA\");\n+  BTB_END(is_badStateA, bsize, \"putfield_or_static:is_badStateA\");\n@@ -3067,1 +3173,1 @@\n-  BTB_END( is_badStateB, bsize, \"putfield_or_static:is_badStateB\");\n+  BTB_END(is_badStateB, bsize, \"putfield_or_static:is_badStateB\");\n@@ -3071,1 +3177,1 @@\n-  BTB_END( is_badStateC, bsize, \"putfield_or_static:is_badStateC\");\n+  BTB_END(is_badStateC, bsize, \"putfield_or_static:is_badStateC\");\n@@ -3075,1 +3181,1 @@\n-  BTB_END( is_badStateD, bsize, \"putfield_or_static:is_badStateD\");\n+  BTB_END(is_badStateD, bsize, \"putfield_or_static:is_badStateD\");\n@@ -3079,1 +3185,1 @@\n-  BTB_END( is_badStateE, bsize, \"putfield_or_static:is_badStateE\");\n+  BTB_END(is_badStateE, bsize, \"putfield_or_static:is_badStateE\");\n@@ -3083,1 +3189,1 @@\n-  BTB_END( is_badStateF, bsize, \"putfield_or_static:is_badStateF\");\n+  BTB_END(is_badStateF, bsize, \"putfield_or_static:is_badStateF\");\n@@ -3090,1 +3196,1 @@\n-    else            __ stop_static(\"Bad state in putfield\");\n+    else           __ stop_static(\"Bad state in putfield\");\n@@ -3105,0 +3211,1 @@\n+      __ z_agr(fieldAddr, obj);\n@@ -3107,1 +3214,1 @@\n-    do_oop_store(_masm, Address(obj, off), Z_tos,\n+    do_oop_store(_masm, field, Z_tos,\n@@ -3110,1 +3217,1 @@\n-      patch_bytecode(Bytecodes::_fast_aputfield, bc, Z_ARG5, true, byte_no);\n+      patch_bytecode(Bytecodes::_fast_aputfield, bc_reg, patch_tmp, true, byte_no);\n@@ -3119,1 +3226,2 @@\n-  Label notVolatile;\n+  \/\/ only if flags register is non-volatile\n+  NearLabel notVolatile;\n@@ -3121,1 +3229,2 @@\n-  __ testbit(Z_ARG4, ConstantPoolCacheEntry::is_volatile_shift);\n+  assert(flags.is_nonvolatile(), \"flags register needs to be non-volatile\");\n+  __ testbit(flags, ResolvedFieldEntry::is_volatile_shift);\n@@ -3123,0 +3232,1 @@\n+\n@@ -3152,4 +3262,0 @@\n-  \/\/ Check to see if a field modification watch has been set before\n-  \/\/ we take the time to call into the VM.\n-  Label   exit;\n-\n@@ -3158,4 +3264,6 @@\n-  __ load_absolute_address(Z_R1_scratch,\n-                           (address) JvmtiExport::get_field_modification_count_addr());\n-  __ load_and_test_int(Z_R0_scratch, Address(Z_R1_scratch));\n-  __ z_brz(exit);\n+  \/\/ Check to see if a field modification watch has been set\n+  \/\/ before we take the time to call into the VM.\n+  Label dontPost;\n+  __ load_absolute_address(Z_R1_scratch, (address)JvmtiExport::get_field_modification_count_addr());\n+  __ z_chsi(0, Z_R1_scratch, 0); \/\/ avoid loading data into a scratch register\n+  __ z_bre(dontPost);\n@@ -3163,1 +3271,3 @@\n-  Register obj = Z_tmp_1;\n+  Register obj        = Z_ARG2;\n+  Register fieldEntry = Z_ARG3;\n+  Register value      = Z_ARG4;\n@@ -3165,3 +3275,2 @@\n-  __ pop_ptr(obj);                  \/\/ Copy the object pointer from tos.\n-  __ verify_oop(obj);\n-  __ push_ptr(obj);                 \/\/ Put the object pointer back on tos.\n+  __ load_ptr(0, obj);              \/\/ Copy the object pointer from tos.\n+  __ verify_oop(obj);               \/\/ and verify it\n@@ -3198,1 +3307,1 @@\n-  __ load_address(Z_ARG4, Address(Z_esp, Interpreter::stackElementSize));\n+  __ load_address(value, Address(Z_esp, Interpreter::expr_offset_in_bytes(0)));\n@@ -3200,1 +3309,1 @@\n-  __ get_cache_entry_pointer_at_bcp(Z_ARG3, Z_tos, 1);\n+  __ load_field_entry(fieldEntry, Z_tos, 1);\n@@ -3203,3 +3312,3 @@\n-  \/\/ obj   : object pointer copied above\n-  \/\/ Z_ARG3: cache entry pointer\n-  \/\/ Z_ARG4: jvalue object on the stack\n+  \/\/ obj        : object pointer copied above\n+  \/\/ fieldEntry : cache entry pointer\n+  \/\/ value      : jvalue object on the stack\n@@ -3208,1 +3317,1 @@\n-             obj, Z_ARG3, Z_ARG4);\n+             obj, fieldEntry, value);\n@@ -3234,1 +3343,1 @@\n-  __ bind(exit);\n+  __ bind(dontPost);\n@@ -3241,1 +3350,0 @@\n-  ByteSize base = ConstantPoolCache::base_offset();\n@@ -3245,3 +3353,5 @@\n-  Register cache = Z_tmp_1;\n-  Register index = Z_tmp_2;\n-  Register flags = Z_ARG5;\n+  Register obj       = Z_tmp_1;\n+  Register cache     = Z_tmp_1;\n+  Register index     = Z_tmp_2;\n+  Register off       = Z_tmp_2;\n+  Register flags     = Z_ARG5;\n@@ -3250,9 +3360,3 @@\n-  __ get_cache_and_index_at_bcp(cache, index, 1);\n-\n-  \/\/ Test for volatile.\n-  assert(!flags->is_volatile(), \"do_oop_store could perform leaf RT call\");\n-  __ z_lg(flags, Address(cache, index, base + ConstantPoolCacheEntry::flags_offset()));\n-\n-  \/\/ Replace index with field offset from cache entry.\n-  Register field_offset = index;\n-  __ z_lg(field_offset, Address(cache, index, base + ConstantPoolCacheEntry::f2_offset()));\n+  __ load_field_entry(cache, index);\n+  \/\/ this call is for nonstatic. obj remains unchanged.\n+  load_resolved_field_entry(obj, cache, noreg, off, flags, false);\n@@ -3261,2 +3365,0 @@\n-  Register   obj = cache;\n-\n@@ -3266,1 +3368,1 @@\n-  const Address   field(obj, field_offset);\n+  const Address field(obj, off);\n@@ -3271,1 +3373,1 @@\n-      do_oop_store(_masm, Address(obj, field_offset), Z_tos,\n+      do_oop_store(_masm, field, Z_tos,\n@@ -3304,1 +3406,1 @@\n-  __ testbit(flags, ConstantPoolCacheEntry::is_volatile_shift);\n+  __ testbit(flags, ResolvedFieldEntry::is_volatile_shift);\n@@ -3314,1 +3416,1 @@\n-  Register obj = Z_tos;\n+  Register obj = Z_tos;  \/\/ Object ptr is in TOS\n@@ -3316,1 +3418,1 @@\n-  \/\/ Do the JVMTI work here to avoid disturbing the register state below\n+  \/\/ Do the JVMTI work here. There is no specific jvmti_post_fast_access() emitter.\n@@ -3318,3 +3420,6 @@\n-    \/\/ Check to see if a field access watch has been set before we\n-    \/\/ take the time to call into the VM.\n-    Label cont;\n+    \/\/ Check to see if a field modification watch has been set\n+    \/\/ before we take the time to call into the VM.\n+    BLOCK_COMMENT(\"jvmti_post_fast_field_access {\");\n+    Label    dontPost;\n+    Register cache = Z_ARG3;\n+    Register index = Z_tmp_2;\n@@ -3322,4 +3427,3 @@\n-    __ load_absolute_address(Z_R1_scratch,\n-                             (address)JvmtiExport::get_field_access_count_addr());\n-    __ load_and_test_int(Z_R0_scratch, Address(Z_R1_scratch));\n-    __ z_brz(cont);\n+    __ load_absolute_address(Z_R1_scratch, (address)JvmtiExport::get_field_access_count_addr());\n+    __ z_chsi(0, Z_R1_scratch, 0); \/\/ avoid loading data into a scratch register\n+    __ z_bre(dontPost);\n@@ -3328,0 +3432,1 @@\n+    __ load_field_entry(cache, index);\n@@ -3329,1 +3434,0 @@\n-    __ get_cache_entry_pointer_at_bcp(Z_ARG3, Z_tmp_1, 1);\n@@ -3335,1 +3439,1 @@\n-    \/\/ Z_ARG3: cache entry pointer\n+    \/\/ cache: cache entry pointer\n@@ -3338,1 +3442,1 @@\n-               Z_ARG2, Z_ARG3);\n+               Z_ARG2, cache);\n@@ -3341,1 +3445,2 @@\n-    __ bind(cont);\n+    __ bind(dontPost);\n+    BLOCK_COMMENT(\"} jvmti_post_fast_field_access\");\n@@ -3345,2 +3450,3 @@\n-  Register   cache = Z_tmp_1;\n-  Register   index = Z_tmp_2;\n+  Register cache = Z_tmp_1;\n+  Register index = Z_tmp_2;\n+  Register off   = Z_tmp_2;\n@@ -3349,1 +3455,1 @@\n-  __ get_cache_and_index_at_bcp(cache, index, 1);\n+  __ load_field_entry(cache, index);\n@@ -3351,3 +3457,1 @@\n-  __ mem2reg_opt(index,\n-                 Address(cache, index,\n-                         ConstantPoolCache::base_offset() + ConstantPoolCacheEntry::f2_offset()));\n+  __ load_sized_value(off, Address(cache, in_bytes(ResolvedFieldEntry::field_offset_offset())), sizeof(jint), true);\n@@ -3358,1 +3462,1 @@\n-  Address field(obj, index);\n+  Address field(obj, off);\n@@ -3402,0 +3506,1 @@\n+  Register off   = Z_tmp_2;\n@@ -3404,1 +3509,1 @@\n-  __ get_cache_and_index_at_bcp(cache, index, 2);\n+  __ load_field_entry(cache, index, 2);\n@@ -3406,3 +3511,1 @@\n-  __ mem2reg_opt(index,\n-                 Address(cache, index,\n-                         ConstantPoolCache::base_offset() + ConstantPoolCacheEntry::f2_offset()));\n+  __ load_sized_value(off, Address(cache, in_bytes(ResolvedFieldEntry::field_offset_offset())), sizeof(jint), true);\n@@ -3414,0 +3517,3 @@\n+\n+  Address field(receiver, off);\n+\n@@ -3416,1 +3522,1 @@\n-      __ mem2reg_opt(Z_tos, Address(receiver, index), false);\n+      __ mem2reg_opt(Z_tos, field, false);\n@@ -3419,1 +3525,1 @@\n-      do_oop_load(_masm, Address(receiver, index), Z_tos, Z_tmp_1, Z_tmp_2, IN_HEAP);\n+      do_oop_load(_masm, field, Z_tos, Z_tmp_1, Z_tmp_2, IN_HEAP);\n@@ -3423,1 +3529,1 @@\n-      __ mem2freg_opt(Z_ftos, Address(receiver, index));\n+      __ mem2freg_opt(Z_ftos, field);\n","filename":"src\/hotspot\/cpu\/s390\/templateTable_s390.cpp","additions":367,"deletions":261,"binary":false,"changes":628,"status":"modified"},{"patch":"@@ -117,1 +117,1 @@\n-static const int upcall_stub_code_base_size = 1024; \/\/ depends on GC (resolve_jobject)\n+static const int upcall_stub_code_base_size = 1024;\n@@ -205,0 +205,1 @@\n+  __ load_const_optimized(Z_ARG2, (intptr_t)receiver);\n@@ -215,2 +216,1 @@\n-  __ load_const_optimized(Z_ARG1, (intptr_t)receiver);\n-  __ resolve_jobject(Z_ARG1, Z_tmp_1, Z_tmp_2);\n+  __ get_vm_result(Z_ARG1);\n@@ -269,13 +269,0 @@\n-  __ block_comment(\"{ exception handler\");\n-\n-  intptr_t exception_handler_offset = __ pc() - start;\n-\n-  \/\/ Native caller has no idea how to handle exceptions,\n-  \/\/ so we just crash here. Up to callee to catch exceptions.\n-  __ verify_oop(Z_ARG1);\n-  __ load_const_optimized(call_target_address, CAST_FROM_FN_PTR(uint64_t, UpcallLinker::handle_uncaught_exception));\n-  __ call_c(call_target_address);\n-  __ should_not_reach_here();\n-\n-  __ block_comment(\"} exception handler\");\n-\n@@ -296,1 +283,0 @@\n-                         exception_handler_offset,\n","filename":"src\/hotspot\/cpu\/s390\/upcallLinker_s390.cpp","additions":3,"deletions":17,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1335,0 +1335,5 @@\n+void Assembler::addb(Register dst, int imm8) {\n+  (void) prefix_and_encode(dst->encoding(), true);\n+  emit_arith_b(0x80, 0xC0, dst, imm8);\n+}\n+\n@@ -5322,0 +5327,12 @@\n+void Assembler::vpshufb(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {\n+  assert(vector_len == AVX_128bit ? VM_Version::supports_avx() :\n+         vector_len == AVX_256bit ? VM_Version::supports_avx2() :\n+         vector_len == AVX_512bit ? VM_Version::supports_avx512bw() : 0, \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n+  simd_prefix(dst, nds, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int8(0x00);\n+  emit_operand(dst, src, 0);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -989,0 +989,1 @@\n+  void addb(Register dst, int imm8);\n@@ -1955,0 +1956,1 @@\n+  void vpshufb(XMMRegister dst, XMMRegister nds, Address src, int vector_len);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3856,2 +3856,0 @@\n-    Register tmp3_aliased = len;\n-\n@@ -3861,2 +3859,2 @@\n-    andl(tmp1, 64 - 1);   \/\/ tail count (in chars) 0x3F\n-    andl(len, ~(64 - 1));    \/\/ vector count (in chars)\n+    andl(tmp1, 0x0000003f); \/\/ tail count (in chars) 0x3F\n+    andl(len,  0xffffffc0); \/\/ vector count (in chars)\n@@ -3882,0 +3880,2 @@\n+\n+    \/\/ check the tail for absense of negatives\n@@ -3884,4 +3884,7 @@\n-    mov64(tmp3_aliased, 0xFFFFFFFFFFFFFFFF);\n-    shlxq(tmp3_aliased, tmp3_aliased, tmp1);\n-    notq(tmp3_aliased);\n-    kmovql(mask2, tmp3_aliased);\n+    {\n+      Register tmp3_aliased = len;\n+      mov64(tmp3_aliased, 0xFFFFFFFFFFFFFFFF);\n+      shlxq(tmp3_aliased, tmp3_aliased, tmp1);\n+      notq(tmp3_aliased);\n+      kmovql(mask2, tmp3_aliased);\n+    }\n@@ -3919,0 +3922,5 @@\n+    \/\/ do a full check for negative registers in the tail\n+    movl(len, tmp1); \/\/ tmp1 holds low 6-bit from original len;\n+                     \/\/ ary1 already pointing to the right place\n+    jmpb(TAIL_START);\n+\n@@ -3920,1 +3928,1 @@\n-    \/\/ At least one byte in the last 64 bytes is negative.\n+    \/\/ At least one byte in the last 64 byte block was negative.\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":17,"deletions":9,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -9283,0 +9283,11 @@\n+void MacroAssembler::vpshufb(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n+  if (reachable(src)) {\n+    vpshufb(dst, nds, as_Address(src), vector_len);\n+  } else {\n+    lea(rscratch, src);\n+    vpshufb(dst, nds, Address(rscratch, 0), vector_len);\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1798,0 +1798,3 @@\n+  using Assembler::vpshufb;\n+  void vpshufb(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register rscratch = noreg);\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"prims\/upcallLinker.hpp\"\n@@ -3890,0 +3891,18 @@\n+\/\/ exception handler for upcall stubs\n+address StubGenerator::generate_upcall_stub_exception_handler() {\n+  StubCodeMark mark(this, \"StubRoutines\", \"upcall stub exception handler\");\n+  address start = __ pc();\n+\n+  \/\/ native caller has no idea how to handle exceptions\n+  \/\/ we just crash here. Up to callee to catch exceptions.\n+  __ verify_oop(rax);\n+  __ vzeroupper();\n+  __ mov(c_rarg0, rax);\n+  __ andptr(rsp, -StackAlignmentInBytes); \/\/ align stack as required by ABI\n+  __ subptr(rsp, frame::arg_reg_save_area_bytes); \/\/ windows\n+  __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, UpcallLinker::handle_uncaught_exception)));\n+  __ should_not_reach_here();\n+\n+  return start;\n+}\n+\n@@ -4042,0 +4061,2 @@\n+\n+  StubRoutines::_upcall_stub_exception_handler = generate_upcall_stub_exception_handler();\n@@ -4176,1 +4197,1 @@\n-  if (UseAVX > 2 && VM_Version::supports_avx512dq()) {\n+  if (VM_Version::is_intel() && VM_Version::supports_avx512dq()) {\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -330,0 +330,4 @@\n+  \/\/ AVX2 AES Galois Counter Mode implementation\n+  address generate_avx2_galoisCounterMode_AESCrypt();\n+  void aesgcm_avx2(Register in, Register len, Register ct, Register out, Register key,\n+                   Register state, Register subkeyHtbl, Register counter);\n@@ -356,0 +360,11 @@\n+  \/\/ AVX2 AES-GCM related functions\n+  void initial_blocks_avx2(XMMRegister ctr, Register rounds, Register key, Register len,\n+                           Register in, Register out, Register ct, XMMRegister aad_hashx, Register pos);\n+  void gfmul_avx2(XMMRegister GH, XMMRegister HK);\n+  void generateHtbl_8_block_avx2(Register htbl);\n+  void ghash8_encrypt8_parallel_avx2(Register key, Register subkeyHtbl, XMMRegister ctr_blockx, Register in,\n+                                     Register out, Register ct, Register pos, bool out_order, Register rounds,\n+                                     XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3, XMMRegister xmm4,\n+                                     XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7, XMMRegister xmm8);\n+  void ghash_last_8_avx2(Register subkeyHtbl);\n+\n@@ -553,0 +568,3 @@\n+  \/\/ shared exception handler for FFM upcall stubs\n+  address generate_upcall_stub_exception_handler();\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.hpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2019, 2021, Intel Corporation. All rights reserved.\n+* Copyright (c) 2019, 2023, Intel Corporation. All rights reserved.\n@@ -84,0 +84,24 @@\n+ATTRIBUTE_ALIGNED(16) uint64_t COUNTER_MASK_LINC1F[] = {\n+    0x0000000000000000UL, 0x0100000000000000UL,\n+};\n+\n+static address counter_mask_linc1f_addr() {\n+  return (address)COUNTER_MASK_LINC1F;\n+}\n+\n+ATTRIBUTE_ALIGNED(16) uint64_t COUNTER_MASK_LINC2[] = {\n+    0x0000000000000002UL, 0x0000000000000000UL,\n+};\n+\n+static address counter_mask_linc2_addr() {\n+  return (address)COUNTER_MASK_LINC2;\n+}\n+\n+ATTRIBUTE_ALIGNED(16) uint64_t COUNTER_MASK_LINC2F[] = {\n+    0x0000000000000000UL, 0x0200000000000000UL,\n+};\n+\n+static address counter_mask_linc2f_addr() {\n+  return (address)COUNTER_MASK_LINC2F;\n+}\n+\n@@ -166,0 +190,3 @@\n+      if (VM_Version::supports_avx2()) {\n+          StubRoutines::_galoisCounterMode_AESCrypt = generate_avx2_galoisCounterMode_AESCrypt();\n+      }\n@@ -267,0 +294,84 @@\n+\/\/ AVX2 Vector AES Galois Counter Mode implementation.\n+\/\/\n+\/\/ Inputs:           Windows    |   Linux\n+\/\/   in         = rcx (c_rarg0) | rsi (c_rarg0)\n+\/\/   len        = rdx (c_rarg1) | rdi (c_rarg1)\n+\/\/   ct         = r8  (c_rarg2) | rdx (c_rarg2)\n+\/\/   out        = r9  (c_rarg3) | rcx (c_rarg3)\n+\/\/   key        = rdi           | r8  (c_rarg4)\n+\/\/   state      = r13           | r9  (c_rarg5)\n+\/\/   subkeyHtbl = r11           | r11\n+\/\/   counter    = rsi           | r12\n+\/\/\n+\/\/ Output:\n+\/\/   rax - number of processed bytes\n+address StubGenerator::generate_avx2_galoisCounterMode_AESCrypt() {\n+  __ align(CodeEntryAlignment);\n+  StubCodeMark mark(this, \"StubRoutines\", \"galoisCounterMode_AESCrypt\");\n+  address start = __ pc();\n+\n+  const Register in = c_rarg0;\n+  const Register len = c_rarg1;\n+  const Register ct = c_rarg2;\n+  const Register out = c_rarg3;\n+  \/\/ and updated with the incremented counter in the end\n+ #ifndef _WIN64\n+  const Register key = c_rarg4;\n+  const Register state = c_rarg5;\n+  const Address subkeyH_mem(rbp, 2 * wordSize);\n+  const Register subkeyHtbl = r11;\n+  const Address counter_mem(rbp, 3 * wordSize);\n+  const Register counter = r12;\n+ #else\n+  const Address key_mem(rbp, 6 * wordSize);\n+  const Register key = rdi;\n+  const Address state_mem(rbp, 7 * wordSize);\n+  const Register state = r13;\n+  const Address subkeyH_mem(rbp, 8 * wordSize);\n+  const Register subkeyHtbl = r11;\n+  const Address counter_mem(rbp, 9 * wordSize);\n+  const Register counter = rsi;\n+ #endif\n+  __ enter();\n+  \/\/ Save state before entering routine\n+  __ push(r12);\n+  __ push(r13);\n+  __ push(r14);\n+  __ push(r15);\n+  __ push(rbx);\n+#ifdef _WIN64\n+  \/\/ on win64, fill len_reg from stack position\n+  __ push(rsi);\n+  __ push(rdi);\n+  __ movptr(key, key_mem);\n+  __ movptr(state, state_mem);\n+#endif\n+  __ movptr(subkeyHtbl, subkeyH_mem);\n+  __ movptr(counter, counter_mem);\n+\n+  \/\/ Save rsp\n+  __ movq(r14, rsp);\n+  \/\/ Align stack\n+  __ andq(rsp, -64);\n+  __ subptr(rsp, 16 * longSize); \/\/ Create space on the stack for saving AES entries\n+\n+  aesgcm_avx2(in, len, ct, out, key, state, subkeyHtbl, counter);\n+  __ vzeroupper();\n+  __ movq(rsp, r14);\n+  \/\/ Restore state before leaving routine\n+ #ifdef _WIN64\n+  __ pop(rdi);\n+  __ pop(rsi);\n+ #endif\n+  __ pop(rbx);\n+  __ pop(r15);\n+  __ pop(r14);\n+  __ pop(r13);\n+  __ pop(r12);\n+\n+  __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n+  __ ret(0);\n+\n+  return start;\n+}\n+\n@@ -3184,0 +3295,540 @@\n+\/\/Implements data * hashkey mod (128, 127, 126, 121, 0)\n+\/\/Inputs:\n+\/\/GH and HK - 128 bits each\n+\/\/Output:\n+\/\/GH = GH * Hashkey mod poly\n+\/\/Temp registers: xmm1, xmm2, xmm3, r15\n+void StubGenerator::gfmul_avx2(XMMRegister GH, XMMRegister HK) {\n+  const XMMRegister T1 = xmm1;\n+  const XMMRegister T2 = xmm2;\n+  const XMMRegister T3 = xmm3;\n+\n+  __ vpclmulqdq(T1, GH, HK, 0x11); \/\/ %%T1 = a1*b1\n+  __ vpclmulqdq(T2, GH, HK, 0x00); \/\/ %%T2 = a0*b0\n+  __ vpclmulqdq(T3, GH, HK, 0x01); \/\/ %%T3 = a1*b0\n+  __ vpclmulqdq(GH, GH, HK, 0x10); \/\/ %%GH = a0*b1\n+  __ vpxor(GH, GH, T3, Assembler::AVX_128bit);\n+\n+  __ vpsrldq(T3, GH, 8, Assembler::AVX_128bit); \/\/ shift-R %%GH 2 DWs\n+  __ vpslldq(GH, GH, 8, Assembler::AVX_128bit); \/\/ shift-L %%GH 2 DWs\n+\n+  __ vpxor(T1, T1, T3, Assembler::AVX_128bit);\n+  __ vpxor(GH, GH, T2, Assembler::AVX_128bit);\n+\n+  \/\/first phase of the reduction\n+  __ movdqu(T3, ExternalAddress(ghash_polynomial_reduction_addr()), r15 \/*rscratch*\/);\n+  __ vpclmulqdq(T2, T3, GH, 0x01);\n+  __ vpslldq(T2, T2, 8, Assembler::AVX_128bit); \/\/ shift-L %%T2 2 DWs\n+\n+  __ vpxor(GH, GH, T2, Assembler::AVX_128bit); \/\/ first phase of the reduction complete\n+  \/\/second phase of the reduction\n+  __ vpclmulqdq(T2, T3, GH, 0x00);\n+  __ vpsrldq(T2, T2, 4, Assembler::AVX_128bit); \/\/ shift-R %%T2 1 DW (Shift-R only 1-DW to obtain 2-DWs shift-R)\n+\n+  __ vpclmulqdq(GH, T3, GH, 0x10);\n+  __ vpslldq(GH, GH, 4, Assembler::AVX_128bit); \/\/ shift-L %%GH 1 DW (Shift-L 1-DW to obtain result with no shifts)\n+\n+  __ vpxor(GH, GH, T2, Assembler::AVX_128bit); \/\/ second phase of the reduction complete\n+  __ vpxor(GH, GH, T1, Assembler::AVX_128bit); \/\/ the result is in %%GH\n+}\n+\n+\/\/Generate 8 constants from the given subkeyH.\n+\/\/Input:\n+\/\/htbl - table containing the initial subkeyH\n+\/\/Output:\n+\/\/htbl - containing 8 H constants\n+\/\/Temp registers: xmm0, xmm1, xmm2, xmm3, xmm6, xmm11, xmm12, r15, rbx\n+void StubGenerator::generateHtbl_8_block_avx2(Register htbl) {\n+  const XMMRegister HK = xmm6;\n+\n+  __ movdqu(HK, Address(htbl, 0));\n+  __ movdqu(xmm1, ExternalAddress(ghash_long_swap_mask_addr()), rbx \/*rscratch*\/);\n+  __ vpshufb(HK, HK, xmm1, Assembler::AVX_128bit);\n+\n+  __ movdqu(xmm11, ExternalAddress(ghash_polynomial_addr()), rbx \/*rscratch*\/);\n+  __ movdqu(xmm12, ExternalAddress(ghash_polynomial_two_one_addr()), rbx \/*rscratch*\/);\n+  \/\/ Compute H ^ 2 from the input subkeyH\n+  __ vpsrlq(xmm1, xmm6, 63, Assembler::AVX_128bit);\n+  __ vpsllq(xmm6, xmm6, 1, Assembler::AVX_128bit);\n+  __ vpslldq(xmm2, xmm1, 8, Assembler::AVX_128bit);\n+  __ vpsrldq(xmm1, xmm1, 8, Assembler::AVX_128bit);\n+\n+  __ vpor(xmm6, xmm6, xmm2, Assembler::AVX_128bit);\n+\n+  __ vpshufd(xmm2, xmm1, 0x24, Assembler::AVX_128bit);\n+  __ vpcmpeqd(xmm2, xmm2, xmm12, Assembler::AVX_128bit);\n+  __ vpand(xmm2, xmm2, xmm11, Assembler::AVX_128bit);\n+  __ vpxor(xmm6, xmm6, xmm2, Assembler::AVX_128bit);\n+  __ movdqu(Address(htbl, 1 * 16), xmm6); \/\/ H * 2\n+  __ movdqu(xmm0, xmm6);\n+  for (int i = 2; i < 9; i++) {\n+    gfmul_avx2(xmm6, xmm0);\n+    __ movdqu(Address(htbl, i * 16), xmm6);\n+  }\n+}\n+\n+#define aesenc_step_avx2(t_key)\\\n+__ aesenc(xmm1, t_key);\\\n+__ aesenc(xmm2, t_key);\\\n+__ aesenc(xmm3, t_key);\\\n+__ aesenc(xmm4, t_key);\\\n+__ aesenc(xmm5, t_key);\\\n+__ aesenc(xmm6, t_key);\\\n+__ aesenc(xmm7, t_key);\\\n+__ aesenc(xmm8, t_key);\\\n+\n+#define ghash_step_avx2(ghdata, hkey) \\\n+__ vpclmulqdq(xmm11, ghdata, hkey, 0x11);\\\n+__ vpxor(xmm12, xmm12, xmm11, Assembler::AVX_128bit);\\\n+__ vpclmulqdq(xmm11, ghdata, hkey, 0x00);\\\n+__ vpxor(xmm15, xmm15, xmm11, Assembler::AVX_128bit);\\\n+__ vpclmulqdq(xmm11, ghdata, hkey, 0x01);\\\n+__ vpxor(xmm14, xmm14, xmm11, Assembler::AVX_128bit);\\\n+__ vpclmulqdq(xmm11, ghdata, hkey, 0x10);\\\n+__ vpxor(xmm14, xmm14, xmm11, Assembler::AVX_128bit);\\\n+\n+\/\/Encrypts and hashes 8 blocks in an interleaved fashion.\n+\/\/Inputs:\n+\/\/key - key for aes operations\n+\/\/subkeyHtbl - table containing H constants\n+\/\/ctr_blockx - counter for aes operations\n+\/\/in - input buffer\n+\/\/out - output buffer\n+\/\/ct - ciphertext buffer\n+\/\/pos - holds the length processed in this method\n+\/\/in_order - boolean that indicates if incrementing counter without shuffling is needed\n+\/\/rounds - number of aes rounds calculated based on key length\n+\/\/xmm1-xmm8 - holds encrypted counter values\n+\/\/Outputs:\n+\/\/xmm1-xmm8 - updated encrypted counter values\n+\/\/ctr_blockx - updated counter value\n+\/\/out - updated output buffer\n+\/\/Temp registers: xmm0, xmm10, xmm11, xmm12, xmm13, xmm14, xmm15, rbx\n+void StubGenerator::ghash8_encrypt8_parallel_avx2(Register key, Register subkeyHtbl, XMMRegister ctr_blockx, Register in,\n+                                                  Register out, Register ct, Register pos, bool in_order, Register rounds,\n+                                                  XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3, XMMRegister xmm4,\n+                                                  XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7, XMMRegister xmm8) {\n+  const XMMRegister t1 = xmm0;\n+  const XMMRegister t2 = xmm10;\n+  const XMMRegister t3 = xmm11;\n+  const XMMRegister t4 = xmm12;\n+  const XMMRegister t5 = xmm13;\n+  const XMMRegister t6 = xmm14;\n+  const XMMRegister t7 = xmm15;\n+  Label skip_reload, last_aes_rnd, aes_192, aes_256;\n+\n+  __ movdqu(t2, xmm1);\n+  for (int i = 0; i <= 6; i++) {\n+    __ movdqu(Address(rsp, 16 * i), as_XMMRegister(i + 2));\n+  }\n+\n+  if (in_order) {\n+    __ vpaddd(xmm1, ctr_blockx, ExternalAddress(counter_mask_linc1_addr()), Assembler::AVX_128bit, rbx \/*rscratch*\/); \/\/Increment counter by 1\n+    __ movdqu(t5, ExternalAddress(counter_mask_linc2_addr()), rbx \/*rscratch*\/);\n+    __ vpaddd(xmm2, ctr_blockx, t5, Assembler::AVX_128bit);\n+    for (int rnum = 1; rnum <= 6; rnum++) {\n+      __ vpaddd(as_XMMRegister(rnum + 2), as_XMMRegister(rnum), t5, Assembler::AVX_128bit);\n+    }\n+    __ movdqu(ctr_blockx, xmm8);\n+\n+    __ movdqu(t5, ExternalAddress(counter_shuffle_mask_addr()), rbx \/*rscratch*\/);\n+    for (int rnum = 1; rnum <= 8; rnum++) {\n+      __ vpshufb(as_XMMRegister(rnum), as_XMMRegister(rnum), t5, Assembler::AVX_128bit); \/\/perform a 16Byte swap\n+    }\n+  } else {\n+    __ vpaddd(xmm1, ctr_blockx, ExternalAddress(counter_mask_linc1f_addr()), Assembler::AVX_128bit, rbx \/*rscratch*\/); \/\/Increment counter by 1\n+    __ vmovdqu(t5, ExternalAddress(counter_mask_linc2f_addr()), Assembler::AVX_128bit, rbx \/*rscratch*\/);\n+    __ vpaddd(xmm2, ctr_blockx, t5, Assembler::AVX_128bit);\n+    for (int rnum = 1; rnum <= 6; rnum++) {\n+      __ vpaddd(as_XMMRegister(rnum + 2), as_XMMRegister(rnum), t5, Assembler::AVX_128bit);\n+    }\n+    __ movdqu(ctr_blockx, xmm8);\n+  }\n+\n+  load_key(t1, key, 16 * 0, rbx \/*rscratch*\/);\n+  for (int rnum = 1; rnum <= 8; rnum++) {\n+    __ vpxor(as_XMMRegister(rnum), as_XMMRegister(rnum), t1, Assembler::AVX_128bit);\n+  }\n+\n+  load_key(t1, key, 16 * 1, rbx \/*rscratch*\/);\n+  aesenc_step_avx2(t1);\n+\n+  load_key(t1, key, 16 * 2, rbx \/*rscratch*\/);\n+  aesenc_step_avx2(t1);\n+\n+  __ movdqu(t5, (Address(subkeyHtbl, 8 * 16)));\n+  __ vpclmulqdq(t4, t2, t5, 0x11); \/\/t4 = a1*b1\n+  __ vpclmulqdq(t7, t2, t5, 0x00); \/\/t7 = a0*b0\n+  __ vpclmulqdq(t6, t2, t5, 0x01); \/\/t6 = a1*b0\n+  __ vpclmulqdq(t5, t2, t5, 0x10); \/\/t5 = a0*b1\n+  __ vpxor(t6, t6, t5, Assembler::AVX_128bit);\n+\n+  for (int i = 3, j = 0; i <= 8; i++, j++) {\n+    load_key(t1, key, 16 * i, rbx \/*rscratch*\/);\n+    aesenc_step_avx2(t1);\n+    __ movdqu(t1, Address(rsp, 16 * j));\n+    __ movdqu(t5, (Address(subkeyHtbl, (7 - j) * 16)));\n+    ghash_step_avx2(t1, t5);\n+  }\n+\n+  load_key(t1, key, 16 * 9, rbx \/*rscratch*\/);\n+  aesenc_step_avx2(t1);\n+\n+  __ movdqu(t1, Address(rsp, 16 * 6));\n+  __ movdqu(t5, (Address(subkeyHtbl, 1 * 16)));\n+\n+  __ vpclmulqdq(t3, t1, t5, 0x00);\n+  __ vpxor(t7, t7, t3, Assembler::AVX_128bit);\n+\n+  __ vpclmulqdq(t3, t1, t5, 0x01);\n+  __ vpxor(t6, t6, t3, Assembler::AVX_128bit);\n+\n+  __ vpclmulqdq(t3, t1, t5, 0x10);\n+  __ vpxor(t6, t6, t3, Assembler::AVX_128bit);\n+\n+  __ vpclmulqdq(t3, t1, t5, 0x11);\n+  __ vpxor(t1, t4, t3, Assembler::AVX_128bit);\n+\n+  __ vpslldq(t3, t6, 8, Assembler::AVX_128bit); \/\/shift-L t3 2 DWs\n+  __ vpsrldq(t6, t6, 8, Assembler::AVX_128bit); \/\/shift-R t2 2 DWs\n+  __ vpxor(t7, t7, t3, Assembler::AVX_128bit);\n+  __ vpxor(t1, t1, t6, Assembler::AVX_128bit); \/\/ accumulate the results in t1:t7\n+\n+  load_key(t5, key, 16 * 10, rbx \/*rscratch*\/);\n+  __ cmpl(rounds, 52);\n+  __ jcc(Assembler::less, last_aes_rnd);\n+\n+  __ bind(aes_192);\n+  aesenc_step_avx2(t5);\n+  load_key(t5, key, 16 * 11, rbx \/*rscratch*\/);\n+  aesenc_step_avx2(t5);\n+  load_key(t5, key, 16 * 12, rbx \/*rscratch*\/);\n+  __ cmpl(rounds, 60);\n+  __ jcc(Assembler::less, last_aes_rnd);\n+\n+  __ bind(aes_256);\n+  aesenc_step_avx2(t5);\n+  load_key(t5, key, 16 * 13, rbx \/*rscratch*\/);\n+  aesenc_step_avx2(t5);\n+  load_key(t5, key, 16 * 14, rbx \/*rscratch*\/);\n+  __ bind(last_aes_rnd);\n+  for (int rnum = 1; rnum <= 8; rnum++) {\n+    __ aesenclast(as_XMMRegister(rnum), t5);\n+  }\n+\n+  for (int i = 0; i <= 7; i++) {\n+    __ movdqu(t2, Address(in, pos, Address::times_1, 16 * i));\n+    __ vpxor(as_XMMRegister(i + 1), as_XMMRegister(i + 1), t2, Assembler::AVX_128bit);\n+  }\n+\n+  \/\/first phase of the reduction\n+  __ vmovdqu(t3, ExternalAddress(ghash_polynomial_reduction_addr()), Assembler::AVX_128bit, rbx \/*rscratch*\/);\n+\n+  __ vpclmulqdq(t2, t3, t7, 0x01);\n+  __ vpslldq(t2, t2, 8, Assembler::AVX_128bit); \/\/shift-L xmm2 2 DWs\n+\n+  __ vpxor(t7, t7, t2, Assembler::AVX_128bit); \/\/first phase of the reduction complete\n+\n+  \/\/Write to the Ciphertext buffer\n+  for (int i = 0; i <= 7; i++) {\n+    __ movdqu(Address(out, pos, Address::times_1, 16 * i), as_XMMRegister(i + 1));\n+  }\n+\n+  __ cmpptr(ct, out);\n+  __ jcc(Assembler::equal, skip_reload);\n+  for (int i = 0; i <= 7; i++) {\n+    __ movdqu(as_XMMRegister(i + 1), Address(in, pos, Address::times_1, 16 * i));\n+  }\n+\n+  __ bind(skip_reload);\n+  \/\/second phase of the reduction\n+  __ vpclmulqdq(t2, t3, t7, 0x00);\n+  __ vpsrldq(t2, t2, 4, Assembler::AVX_128bit); \/\/shift-R t2 1 DW (Shift-R only 1-DW to obtain 2-DWs shift-R)\n+\n+  __ vpclmulqdq(t4, t3, t7, 0x10);\n+  __ vpslldq(t4, t4, 4, Assembler::AVX_128bit); \/\/shift-L t4 1 DW (Shift-L 1-DW to obtain result with no shifts)\n+  __ vpxor(t4, t4, t2, Assembler::AVX_128bit); \/\/second phase of the reduction complete\n+  __ vpxor(t1, t1, t4, Assembler::AVX_128bit); \/\/the result is in t1\n+\n+  \/\/perform a 16Byte swap\n+  __ movdqu(t7, ExternalAddress(counter_shuffle_mask_addr()), rbx \/*rscratch*\/);\n+  for (int rnum = 1; rnum <= 8; rnum++) {\n+    __ vpshufb(as_XMMRegister(rnum), as_XMMRegister(rnum), t7, Assembler::AVX_128bit);\n+  }\n+  __ vpxor(xmm1, xmm1, t1, Assembler::AVX_128bit);\n+}\n+\n+\/\/GHASH the last 8 ciphertext blocks.\n+\/\/Input:\n+\/\/subkeyHtbl - table containing H constants\n+\/\/Output:\n+\/\/xmm14 - calculated aad hash\n+\/\/Temp registers: xmm0, xmm10, xmm11, xmm12, xmm13, xmm15, rbx\n+void StubGenerator::ghash_last_8_avx2(Register subkeyHtbl) {\n+  const XMMRegister t1 = xmm0;\n+  const XMMRegister t2 = xmm10;\n+  const XMMRegister t3 = xmm11;\n+  const XMMRegister t4 = xmm12;\n+  const XMMRegister t5 = xmm13;\n+  const XMMRegister t6 = xmm14;\n+  const XMMRegister t7 = xmm15;\n+\n+  \/\/Karatsuba Method\n+  __ movdqu(t5, Address(subkeyHtbl, 8 * 16));\n+\n+  __ vpshufd(t2, xmm1, 78, Assembler::AVX_128bit);\n+  __ vpshufd(t3, t5, 78, Assembler::AVX_128bit);\n+  __ vpxor(t2, t2, xmm1, Assembler::AVX_128bit);\n+  __ vpxor(t3, t3, t5, Assembler::AVX_128bit);\n+\n+  __ vpclmulqdq(t6, xmm1, t5, 0x11);\n+  __ vpclmulqdq(t7, xmm1, t5, 0x00);\n+\n+  __ vpclmulqdq(xmm1, t2, t3, 0x00);\n+\n+  for (int i = 7, rnum = 2; rnum <= 8; i--, rnum++) {\n+    __ movdqu(t5, Address(subkeyHtbl, i * 16));\n+    __ vpshufd(t2, as_XMMRegister(rnum), 78, Assembler::AVX_128bit);\n+    __ vpshufd(t3, t5, 78, Assembler::AVX_128bit);\n+    __ vpxor(t2, t2, as_XMMRegister(rnum), Assembler::AVX_128bit);\n+    __ vpxor(t3, t3, t5, Assembler::AVX_128bit);\n+    __ vpclmulqdq(t4, as_XMMRegister(rnum), t5, 0x11);\n+    __ vpxor(t6, t6, t4, Assembler::AVX_128bit);\n+    __ vpclmulqdq(t4, as_XMMRegister(rnum), t5, 0x00);\n+    __ vpxor(t7, t7, t4, Assembler::AVX_128bit);\n+    __ vpclmulqdq(t2, t2, t3, 0x00);\n+    __ vpxor(xmm1, xmm1, t2, Assembler::AVX_128bit);\n+  }\n+\n+  __ vpxor(xmm1, xmm1, t6, Assembler::AVX_128bit);\n+  __ vpxor(t2, xmm1, t7, Assembler::AVX_128bit);\n+\n+  __ vpslldq(t4, t2, 8, Assembler::AVX_128bit);\n+  __ vpsrldq(t2, t2, 8, Assembler::AVX_128bit);\n+\n+  __ vpxor(t7, t7, t4, Assembler::AVX_128bit);\n+  __ vpxor(t6, t6, t2, Assembler::AVX_128bit); \/\/<t6:t7> holds the result of the accumulated carry-less multiplications\n+\n+  \/\/first phase of the reduction\n+  __ movdqu(t3, ExternalAddress(ghash_polynomial_reduction_addr()), rbx \/*rscratch*\/);\n+\n+  __ vpclmulqdq(t2, t3, t7, 0x01);\n+  __ vpslldq(t2, t2, 8, Assembler::AVX_128bit); \/\/ shift-L t2 2 DWs\n+\n+  __ vpxor(t7, t7, t2, Assembler::AVX_128bit);\/\/first phase of the reduction complete\n+\n+  \/\/second phase of the reduction\n+  __ vpclmulqdq(t2, t3, t7, 0x00);\n+  __ vpsrldq(t2, t2, 4, Assembler::AVX_128bit); \/\/shift-R t2 1 DW (Shift-R only 1-DW to obtain 2-DWs shift-R)\n+\n+  __ vpclmulqdq(t4, t3, t7, 0x10);\n+  __ vpslldq(t4, t4, 4, Assembler::AVX_128bit); \/\/shift-L t4 1 DW (Shift-L 1-DW to obtain result with no shifts)\n+  __ vpxor(t4, t4, t2, Assembler::AVX_128bit); \/\/second phase of the reduction complete\n+  __ vpxor(t6, t6, t4, Assembler::AVX_128bit); \/\/the result is in t6\n+}\n+\n+\/\/Encrypt initial number of 8 blocks\n+\/\/Inputs:\n+\/\/ctr - counter for aes operations\n+\/\/rounds - number of aes rounds calculated based on key length\n+\/\/key - key for aes operations\n+\/\/len - input length to be processed\n+\/\/in - input buffer\n+\/\/out - output buffer\n+\/\/ct - ciphertext buffer\n+\/\/aad_hashx - input aad hash\n+\/\/pos - holds the length processed in this method\n+\/\/Outputs:\n+\/\/xmm1-xmm8 - holds updated encrypted counter values\n+\/\/ctr - updated counter value\n+\/\/pos - updated position\n+\/\/len - updated length\n+\/\/out - updated output buffer\n+\/\/Temp registers: xmm0, xmm10, xmm11, xmm12, xmm13, xmm14, xmm15\n+void StubGenerator::initial_blocks_avx2(XMMRegister ctr, Register rounds, Register key, Register len, Register in,\n+                                        Register out, Register ct, XMMRegister aad_hashx, Register pos) {\n+  const XMMRegister t1 = xmm12;\n+  const XMMRegister t2 = xmm13;\n+  const XMMRegister t3 = xmm14;\n+  const XMMRegister t4 = xmm15;\n+  const XMMRegister t5 = xmm11;\n+  const XMMRegister t6 = xmm10;\n+  const XMMRegister t_key = xmm0;\n+\n+  Label skip_reload, last_aes_rnd, aes_192, aes_256;\n+  \/\/Move AAD_HASH to temp reg t3\n+  __ movdqu(t3, aad_hashx);\n+  \/\/Prepare 8 counter blocks and perform rounds of AES cipher on\n+  \/\/them, load plain\/cipher text and store cipher\/plain text.\n+  __ movdqu(xmm1, ctr);\n+  __ movdqu(t5, ExternalAddress(counter_mask_linc1_addr()), rbx \/*rscratch*\/);\n+  __ movdqu(t6, ExternalAddress(counter_mask_linc2_addr()), rbx \/*rscratch*\/ );\n+  __ vpaddd(xmm2, xmm1, t5, Assembler::AVX_128bit);\n+  for (int rnum = 1; rnum <= 6; rnum++) {\n+    __ vpaddd(as_XMMRegister(rnum + 2), as_XMMRegister(rnum), t6, Assembler::AVX_128bit);\n+  }\n+  __ movdqu(ctr, xmm8);\n+\n+  __ movdqu(t5, ExternalAddress(counter_shuffle_mask_addr()), rbx \/*rscratch*\/);\n+  for (int rnum = 1; rnum <= 8; rnum++) {\n+    __ vpshufb(as_XMMRegister(rnum), as_XMMRegister(rnum), t5, Assembler::AVX_128bit); \/\/perform a 16Byte swap\n+  }\n+\n+  load_key(t_key, key, 16 * 0, rbx \/*rscratch*\/);\n+  for (int rnum = 1; rnum <= 8; rnum++) {\n+    __ vpxor(as_XMMRegister(rnum), as_XMMRegister(rnum), t_key, Assembler::AVX_128bit);\n+  }\n+\n+  for (int i = 1; i <= 9; i++) {\n+    load_key(t_key, key, 16 * i, rbx \/*rscratch*\/);\n+    aesenc_step_avx2(t_key);\n+  }\n+\n+  load_key(t_key, key, 16 * 10, rbx \/*rscratch*\/);\n+  __ cmpl(rounds, 52);\n+  __ jcc(Assembler::less, last_aes_rnd);\n+\n+  __ bind(aes_192);\n+  aesenc_step_avx2(t_key);\n+  load_key(t_key, key, 16 * 11, rbx \/*rscratch*\/);\n+  aesenc_step_avx2(t_key);\n+  load_key(t_key, key, 16 * 12, rbx \/*rscratch*\/);\n+  __ cmpl(rounds, 60);\n+  __ jcc(Assembler::less, last_aes_rnd);\n+\n+  __ bind(aes_256);\n+  aesenc_step_avx2(t_key);\n+  load_key(t_key, key, 16 * 13, rbx \/*rscratch*\/);\n+  aesenc_step_avx2(t_key);\n+  load_key(t_key, key, 16 * 14, rbx \/*rscratch*\/);\n+\n+  __ bind(last_aes_rnd);\n+  for (int rnum = 1; rnum <= 8; rnum++) {\n+    __ aesenclast(as_XMMRegister(rnum), t_key);\n+  }\n+\n+  \/\/XOR and store data\n+  for (int i = 0; i <= 7; i++) {\n+    __ movdqu(t1, Address(in, pos, Address::times_1, 16 * i));\n+    __ vpxor(as_XMMRegister(i + 1), as_XMMRegister(i + 1), t1, Assembler::AVX_128bit);\n+    __ movdqu(Address(out, pos, Address::times_1, 16 * i), as_XMMRegister(i + 1));\n+  }\n+\n+  __ cmpptr(ct, out);\n+  __ jcc(Assembler::equal, skip_reload);\n+  for (int i = 0; i <= 7; i++) {\n+    __ movdqu(as_XMMRegister(i + 1), Address(in, pos, Address::times_1, 16 * i));\n+  }\n+\n+  __ bind(skip_reload);\n+  \/\/Update len with the number of blocks processed\n+  __ subl(len, 128);\n+  __ addl(pos, 128);\n+\n+  __ movdqu(t4, ExternalAddress(counter_shuffle_mask_addr()), rbx \/*rscratch*\/);\n+  for (int rnum = 1; rnum <= 8; rnum++) {\n+    __ vpshufb(as_XMMRegister(rnum), as_XMMRegister(rnum), t4, Assembler::AVX_128bit);\n+  }\n+  \/\/ Combine GHASHed value with the corresponding ciphertext\n+  __ vpxor(xmm1, xmm1, t3, Assembler::AVX_128bit);\n+}\n+\n+\/\/AES-GCM interleaved implementation\n+\/\/Inputs:\n+\/\/in - input buffer\n+\/\/len- message length to be processed\n+\/\/ct - cipher text buffer\n+\/\/out - output buffer\n+\/\/key - key for aes operations\n+\/\/state - address of aad hash for ghash computation\n+\/\/subkeyHtbl- table consisting of H constants\n+\/\/counter - address of counter for aes operations\n+\/\/Output:\n+\/\/(counter) - updated in memory counter value\n+\/\/(state) - updated in memory aad hash\n+\/\/rax - length processed\n+\/\/(out) - output buffer updated\n+\/\/len - updated length\n+\/\/Temp registers: xmm0-xmm15, r10, r15, rbx\n+void StubGenerator::aesgcm_avx2(Register in, Register len, Register ct, Register out, Register key,\n+                                Register state, Register subkeyHtbl, Register counter) {\n+  const Register pos = rax;\n+  const Register rounds = r10;\n+  const XMMRegister ctr_blockx = xmm9;\n+  const XMMRegister aad_hashx = xmm8;\n+  Label encrypt_done, encrypt_by_8_new, encrypt_by_8;\n+\n+  \/\/This routine should be called only for message sizes of 128 bytes or more.\n+  \/\/Macro flow:\n+  \/\/process 8 16 byte blocks in initial_num_blocks.\n+  \/\/process 8 16 byte blocks at a time until all are done 'encrypt_by_8_new  followed by ghash_last_8'\n+  __ xorl(pos, pos);\n+\n+  \/\/Generate 8 constants for htbl\n+  generateHtbl_8_block_avx2(subkeyHtbl);\n+\n+  \/\/Compute #rounds for AES based on the length of the key array\n+  __ movl(rounds, Address(key, arrayOopDesc::length_offset_in_bytes() - arrayOopDesc::base_offset_in_bytes(T_INT)));\n+\n+  \/\/Load and shuffle state and counter values\n+  __ movdqu(ctr_blockx, Address(counter, 0));\n+  __ movdqu(aad_hashx, Address(state, 0));\n+  __ vpshufb(ctr_blockx, ctr_blockx, ExternalAddress(counter_shuffle_mask_addr()), Assembler::AVX_128bit, rbx \/*rscratch*\/);\n+  __ vpshufb(aad_hashx, aad_hashx, ExternalAddress(ghash_long_swap_mask_addr()), Assembler::AVX_128bit, rbx \/*rscratch*\/);\n+\n+  initial_blocks_avx2(ctr_blockx, rounds, key, len, in, out, ct, aad_hashx, pos);\n+\n+  \/\/We need at least 128 bytes to proceed further.\n+  __ cmpl(len, 128);\n+  __ jcc(Assembler::less, encrypt_done);\n+\n+  \/\/in_order vs. out_order is an optimization to increment the counter without shuffling\n+  \/\/it back into little endian. r15d keeps track of when we need to increment in order so\n+  \/\/that the carry is handled correctly.\n+  __ movdl(r15, ctr_blockx);\n+  __ andl(r15, 255);\n+  __ vpshufb(ctr_blockx, ctr_blockx, ExternalAddress(counter_shuffle_mask_addr()), Assembler::AVX_128bit, rbx \/*rscratch*\/);\n+\n+  __ bind(encrypt_by_8_new);\n+  __ cmpl(r15, 255 - 8);\n+  __ jcc(Assembler::greater, encrypt_by_8);\n+\n+  __ addb(r15, 8);\n+  ghash8_encrypt8_parallel_avx2(key, subkeyHtbl, ctr_blockx, in, out, ct, pos, false, rounds,\n+                                xmm1, xmm2, xmm3, xmm4, xmm5, xmm6, xmm7, xmm8);\n+  __ addl(pos, 128);\n+  __ subl(len, 128);\n+  __ cmpl(len, 128);\n+  __ jcc(Assembler::greaterEqual, encrypt_by_8_new);\n+\n+  __ vpshufb(ctr_blockx, ctr_blockx, ExternalAddress(counter_shuffle_mask_addr()), Assembler::AVX_128bit, rbx \/*rscratch*\/);\n+  __ jmp(encrypt_done);\n+\n+  __ bind(encrypt_by_8);\n+  __ vpshufb(ctr_blockx, ctr_blockx, ExternalAddress(counter_shuffle_mask_addr()), Assembler::AVX_128bit, rbx \/*rscratch*\/);\n+\n+  __ addb(r15, 8);\n+  ghash8_encrypt8_parallel_avx2(key, subkeyHtbl, ctr_blockx, in, out, ct, pos, true, rounds,\n+                                xmm1, xmm2, xmm3, xmm4, xmm5, xmm6, xmm7, xmm8);\n+\n+  __ vpshufb(ctr_blockx, ctr_blockx, ExternalAddress(counter_shuffle_mask_addr()), Assembler::AVX_128bit, rbx \/*rscratch*\/);\n+  __ addl(pos, 128);\n+  __ subl(len, 128);\n+  __ cmpl(len, 128);\n+  __ jcc(Assembler::greaterEqual, encrypt_by_8_new);\n+  __ vpshufb(ctr_blockx, ctr_blockx, ExternalAddress(counter_shuffle_mask_addr()), Assembler::AVX_128bit, rbx \/*rscratch*\/);\n+\n+  __ bind(encrypt_done);\n+  ghash_last_8_avx2(subkeyHtbl);\n+\n+  __ vpaddd(ctr_blockx, ctr_blockx, ExternalAddress(counter_mask_linc1_addr()), Assembler::AVX_128bit, rbx \/*rscratch*\/);\n+  __ vpshufb(ctr_blockx, ctr_blockx, ExternalAddress(counter_shuffle_mask_addr()), Assembler::AVX_128bit, rbx \/*rscratch*\/);\n+  __ movdqu(Address(counter, 0), ctr_blockx); \/\/current_counter = xmm9\n+  __ vpshufb(xmm14, xmm14, ExternalAddress(ghash_long_swap_mask_addr()), Assembler::AVX_128bit, rbx \/*rscratch*\/);\n+  __ movdqu(Address(state, 0), xmm14); \/\/aad hash = xmm14\n+  \/\/Xor out round keys\n+  __ vpxor(xmm0, xmm0, xmm0, Assembler::AVX_128bit);\n+  __ vpxor(xmm13, xmm13, xmm13, Assembler::AVX_128bit);\n+\n+ }\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_aes.cpp","additions":652,"deletions":1,"binary":false,"changes":653,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-  _compiler_stubs_code_size     = 20000 LP64_ONLY(+30000) WINDOWS_ONLY(+2000),\n+  _compiler_stubs_code_size     = 20000 LP64_ONLY(+32000) WINDOWS_ONLY(+2000),\n","filename":"src\/hotspot\/cpu\/x86\/stubRoutines_x86.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -168,1 +168,1 @@\n-static const int upcall_stub_code_base_size = 2048;\n+static const int upcall_stub_code_base_size = 1024;\n@@ -275,0 +275,1 @@\n+  __ movptr(c_rarg1, (intptr_t)receiver);\n@@ -291,3 +292,1 @@\n-  __ movptr(rscratch1, (intptr_t)receiver);\n-  __ resolve_jobject(rscratch1, r15_thread, rscratch2);\n-  __ movptr(j_rarg0, rscratch1);\n+  __ get_vm_result(j_rarg0, r15_thread);\n@@ -364,18 +363,0 @@\n-  __ block_comment(\"{ exception handler\");\n-\n-  intptr_t exception_handler_offset = __ pc() - start;\n-\n-  \/\/ TODO: this is always the same, can we bypass and call handle_uncaught_exception directly?\n-\n-  \/\/ native caller has no idea how to handle exceptions\n-  \/\/ we just crash here. Up to callee to catch exceptions.\n-  __ verify_oop(rax);\n-  __ vzeroupper();\n-  __ mov(c_rarg0, rax);\n-  __ andptr(rsp, -StackAlignmentInBytes); \/\/ align stack as required by ABI\n-  __ subptr(rsp, frame::arg_reg_save_area_bytes); \/\/ windows (not really needed)\n-  __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, UpcallLinker::handle_uncaught_exception)));\n-  __ should_not_reach_here();\n-\n-  __ block_comment(\"} exception handler\");\n-\n@@ -384,1 +365,0 @@\n-\n@@ -398,1 +378,0 @@\n-                         exception_handler_offset,\n","filename":"src\/hotspot\/cpu\/x86\/upcallLinker_x86_64.cpp","additions":3,"deletions":24,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -228,0 +228,1 @@\n+      free(lm);\n@@ -249,0 +250,1 @@\n+        free(lm);\n","filename":"src\/hotspot\/os\/aix\/loadlib_aix.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -772,1 +772,2 @@\n-  pthread_attr_init(&attr);\n+  int rslt = pthread_attr_init(&attr);\n+  guarantee(rslt == 0, \"pthread_attr_init has to return 0\");\n@@ -806,0 +807,1 @@\n+    pthread_attr_destroy(&attr);\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -914,1 +914,6 @@\n-  pthread_attr_init(&attr);\n+  int rslt = pthread_attr_init(&attr);\n+  if (rslt != 0) {\n+    thread->set_osthread(nullptr);\n+    delete osthread;\n+    return false;\n+  }\n@@ -963,0 +968,1 @@\n+    pthread_attr_destroy(&attr);\n@@ -3772,0 +3778,2 @@\n+    \/\/ +UseTransparentHugePages implies +UseLargePages\n+    UseLargePages = true;\n@@ -5295,1 +5303,0 @@\n-    st->cr();\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -159,5 +159,1 @@\n-        fr.sender_pc() == nullptr || os::is_first_C_frame(&fr)) break;\n-\n-    if (fr.sender_pc() && !os::is_first_C_frame(&fr)) {\n-      fr = os::get_sender_for_C_frame(&fr);\n-    } else {\n+        fr.sender_pc() == nullptr || os::is_first_C_frame(&fr)) {\n@@ -166,0 +162,1 @@\n+    fr = os::get_sender_for_C_frame(&fr);\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -180,1 +180,1 @@\n-  return frame(fr->link(), fr->link(), fr->sender_pc());\n+  return frame(fr->sender_sp(), fr->link(), fr->sender_pc());\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/os_bsd_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -156,0 +156,8 @@\n+\/\/ No direct support for 8-byte xchg; emulate using cmpxchg.\n+template<>\n+struct Atomic::PlatformXchg<8> : Atomic::XchgUsingCmpxchg<8> {};\n+\n+\/\/ No direct support for 8-byte add; emulate using cmpxchg.\n+template<>\n+struct Atomic::PlatformAdd<8> : Atomic::AddUsingCmpxchg<8> {};\n+\n","filename":"src\/hotspot\/os_cpu\/bsd_x86\/atomic_bsd_x86.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -155,0 +155,10 @@\n+\/\/ The \"Procedure Call Standard for the Arm 64-bit Architecture\" doesn't\n+\/\/ specify a location for the frame record within a stack frame (6.4.6).\n+\/\/ GCC currently chooses to save it at the top of the frame (lowest address).\n+\/\/ This means that using fr->sender_sp() to set the caller's frame _unextended_sp,\n+\/\/ as we do in x86, is wrong. Using fr->link() instead only makes sense for\n+\/\/ native frames. Setting a correct value for _unextended_sp is important\n+\/\/ if this value is later used to get that frame's caller. This will happen\n+\/\/ if we end up calling frame::sender_for_compiled_frame(), which will be the\n+\/\/ case if the _pc is associated with a CodeBlob that has a _frame_size > 0\n+\/\/ (nmethod, runtime stub, safepoint stub, etc).\n@@ -156,1 +166,6 @@\n-  return frame(fr->link(), fr->link(), fr->sender_pc());\n+  address pc = fr->sender_pc();\n+  CodeBlob* cb = CodeCache::find_blob(pc);\n+  bool use_codeblob = cb != nullptr && cb->frame_size() > 0;\n+  assert(!use_codeblob || !Interpreter::contains(pc), \"should not be an interpreter frame\");\n+  intptr_t* sender_sp = use_codeblob ? (fr->link() + frame::metadata_words - cb->frame_size()) : fr->link();\n+  return frame(sender_sp, sender_sp, fr->link(), pc, cb, true \/* allow_cb_null *\/);\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/os_linux_aarch64.cpp","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -131,0 +131,7 @@\n+\/\/ No direct support for 8-byte xchg; emulate using cmpxchg.\n+template<>\n+struct Atomic::PlatformXchg<8> : Atomic::XchgUsingCmpxchg<8> {};\n+\n+\/\/ No direct support for 8-byte add; emulate using cmpxchg.\n+template<>\n+struct Atomic::PlatformAdd<8> : Atomic::AddUsingCmpxchg<8> {};\n","filename":"src\/hotspot\/os_cpu\/linux_arm\/atomic_linux_arm.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -156,0 +156,8 @@\n+\/\/ No direct support for 8-byte xchg; emulate using cmpxchg.\n+template<>\n+struct Atomic::PlatformXchg<8> : Atomic::XchgUsingCmpxchg<8> {};\n+\n+\/\/ No direct support for 8-byte add; emulate using cmpxchg.\n+template<>\n+struct Atomic::PlatformAdd<8> : Atomic::AddUsingCmpxchg<8> {};\n+\n","filename":"src\/hotspot\/os_cpu\/linux_x86\/atomic_linux_x86.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+#include \"compiler\/compilationMemoryStatistic.hpp\"\n+#include \"compiler\/compilerDirectives.hpp\"\n@@ -37,0 +39,1 @@\n+#include \"compiler\/compileTask.hpp\"\n@@ -445,0 +448,3 @@\n+\n+  CompilationMemoryStatisticMark cmsm(env()->task()->directive());\n+\n","filename":"src\/hotspot\/share\/c1\/c1_Compilation.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -141,1 +142,1 @@\n-  assert(DumpSharedSpaces, \"dump-time only\");\n+  assert(CDSConfig::is_dumping_heap(), \"dump-time only\");\n","filename":"src\/hotspot\/share\/cds\/archiveHeapWriter.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -176,1 +177,1 @@\n-  Arguments::assert_is_dumping_archive();\n+  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"cds\/cdsConfig.hpp\"\n+#include \"cds\/heapShared.hpp\"\n+\n+bool CDSConfig::is_dumping_archive() {\n+  return is_dumping_static_archive() || is_dumping_dynamic_archive();\n+}\n+\n+bool CDSConfig::is_dumping_static_archive() {\n+  return DumpSharedSpaces;\n+}\n+\n+bool CDSConfig::is_dumping_dynamic_archive() {\n+  return DynamicDumpSharedSpaces;\n+}\n+\n+#if INCLUDE_CDS_JAVA_HEAP\n+bool CDSConfig::is_dumping_heap() {\n+  \/\/ heap dump is not supported in dynamic dump\n+  return is_dumping_static_archive() && HeapShared::can_write();\n+}\n+#endif \/\/ INCLUDE_CDS_JAVA_HEAP\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_CDS_CDSCONFIG_HPP\n+#define SHARE_CDS_CDSCONFIG_HPP\n+\n+#include \"memory\/allStatic.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+class CDSConfig : public AllStatic {\n+public:\n+  \/\/ Basic CDS features\n+  static bool      is_dumping_archive()                      NOT_CDS_RETURN_(false);\n+  static bool      is_dumping_static_archive()               NOT_CDS_RETURN_(false);\n+  static bool      is_dumping_dynamic_archive()              NOT_CDS_RETURN_(false);\n+\n+  \/\/ CDS archived heap\n+  static bool      is_dumping_heap()                         NOT_CDS_JAVA_HEAP_RETURN_(false);\n+};\n+\n+#endif \/\/ SHARE_CDS_CDSCONFIG_HPP\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.hpp","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -243,1 +244,1 @@\n-  Arguments::assert_is_dumping_archive();\n+  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n","filename":"src\/hotspot\/share\/cds\/cppVtables.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -206,1 +207,1 @@\n-  if (DumpSharedSpaces && HeapShared::can_write()) {\n+  if (CDSConfig::is_dumping_heap()) {\n@@ -305,1 +306,1 @@\n-  Arguments::assert_is_dumping_archive();\n+  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n@@ -465,1 +466,1 @@\n-  Arguments::assert_is_dumping_archive();\n+  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n@@ -512,1 +513,1 @@\n-  Arguments::assert_is_dumping_archive();\n+  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n@@ -539,1 +540,1 @@\n-  Arguments::assert_is_dumping_archive();\n+  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n@@ -548,1 +549,1 @@\n-  Arguments::assert_is_dumping_archive();\n+  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n@@ -689,1 +690,1 @@\n-  Arguments::assert_is_dumping_archive();\n+  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n@@ -1511,1 +1512,1 @@\n-  Arguments::assert_is_dumping_archive();\n+  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -182,1 +183,1 @@\n-  assert(DumpSharedSpaces, \"dump-time only\");\n+  assert(CDSConfig::is_dumping_heap(), \"dump-time only\");\n@@ -209,1 +210,1 @@\n-  assert(DumpSharedSpaces, \"dump-time only\");\n+  assert(CDSConfig::is_dumping_heap(), \"dump-time only\");\n@@ -214,1 +215,1 @@\n-  assert(DumpSharedSpaces, \"dump-time only\");\n+  assert(CDSConfig::is_dumping_heap(), \"dump-time only\");\n@@ -227,1 +228,1 @@\n-  if (DumpSharedSpaces) {\n+  if (CDSConfig::is_dumping_heap()) {\n@@ -244,1 +245,1 @@\n-  assert(!DumpSharedSpaces && UseSharedSpaces, \"runtime only\");\n+  assert(!CDSConfig::is_dumping_heap() && UseSharedSpaces, \"runtime only\");\n@@ -266,1 +267,1 @@\n-  assert(DumpSharedSpaces, \"dump-time only\");\n+  assert(CDSConfig::is_dumping_heap(), \"dump-time only\");\n@@ -602,1 +603,1 @@\n-  assert(DumpSharedSpaces, \"dump time only\");\n+  assert(CDSConfig::is_dumping_heap(), \"dump time only\");\n@@ -613,1 +614,1 @@\n-  assert(DumpSharedSpaces, \"dump time only\");\n+  assert(CDSConfig::is_dumping_heap(), \"dump time only\");\n@@ -621,1 +622,1 @@\n-  assert(DumpSharedSpaces, \"dump time only\");\n+  assert(CDSConfig::is_dumping_heap(), \"dump time only\");\n@@ -633,1 +634,1 @@\n-  assert(DumpSharedSpaces, \"dump time only\");\n+  assert(CDSConfig::is_dumping_heap(), \"dump time only\");\n@@ -949,1 +950,1 @@\n-  assert(!DumpSharedSpaces, \"Should not be called with DumpSharedSpaces\");\n+  assert(!CDSConfig::is_dumping_heap(), \"Should not be called when dumping heap\");\n@@ -1246,1 +1247,1 @@\n-  assert(DumpSharedSpaces, \"dump time only\");\n+  assert(CDSConfig::is_dumping_heap(), \"dump time only\");\n@@ -1297,1 +1298,1 @@\n-  assert(DumpSharedSpaces, \"dump time only\");\n+  assert(CDSConfig::is_dumping_heap(), \"dump time only\");\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":14,"deletions":13,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -643,1 +644,1 @@\n-  Arguments::assert_is_dumping_archive();\n+  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n@@ -670,1 +671,1 @@\n-  if (!DumpSharedSpaces || UseCompressedOops) {\n+  if (!CDSConfig::is_dumping_heap() || UseCompressedOops) {\n@@ -777,4 +778,6 @@\n-  StringTable::allocate_shared_strings_array(CHECK);\n-  ArchiveHeapWriter::init();\n-  if (use_full_module_graph()) {\n-    HeapShared::reset_archived_object_states(CHECK);\n+  if (CDSConfig::is_dumping_heap()) {\n+    StringTable::allocate_shared_strings_array(CHECK);\n+    ArchiveHeapWriter::init();\n+    if (use_full_module_graph()) {\n+      HeapShared::reset_archived_object_states(CHECK);\n+    }\n@@ -792,1 +795,1 @@\n-  Arguments::assert_is_dumping_archive();\n+  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -49,5 +49,3 @@\n-  {\n-    PerfClassTraceTime vmtimer(ClassLoader::perf_sys_class_lookup_time(),\n-                               THREAD->get_thread_stat()->perf_timers_addr(),\n-                               PerfClassTraceTime::CLASS_LOAD);\n-  }\n+  PerfClassTraceTime vmtimer(ClassLoader::perf_app_classload_time(),\n+                             THREAD->get_thread_stat()->perf_timers_addr(),\n+                             PerfClassTraceTime::CLASS_LOAD);\n","filename":"src\/hotspot\/share\/cds\/unregisteredClasses.cpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -2855,1 +2856,1 @@\n-  if (JvmtiExport::can_maintain_original_method_order() || Arguments::is_dumping_archive()) {\n+  if (JvmtiExport::can_maintain_original_method_order() || CDSConfig::is_dumping_archive()) {\n@@ -2869,1 +2870,1 @@\n-  if (JvmtiExport::can_maintain_original_method_order() || Arguments::is_dumping_archive()) {\n+  if (JvmtiExport::can_maintain_original_method_order() || CDSConfig::is_dumping_archive()) {\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -126,1 +127,0 @@\n-PerfCounter*    ClassLoader::_perf_sys_class_lookup_time = nullptr;\n@@ -450,1 +450,1 @@\n-  Arguments::assert_is_dumping_archive();\n+  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n@@ -520,1 +520,1 @@\n-  Arguments::assert_is_dumping_archive();\n+  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n@@ -535,1 +535,1 @@\n-  Arguments::assert_is_dumping_archive();\n+  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n@@ -549,1 +549,1 @@\n-  Arguments::assert_is_dumping_archive();\n+  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n@@ -637,1 +637,1 @@\n-  if (Arguments::is_dumping_archive()) {\n+  if (CDSConfig::is_dumping_archive()) {\n@@ -1253,1 +1253,1 @@\n-  Arguments::assert_is_dumping_archive();\n+  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n@@ -1380,1 +1380,0 @@\n-    NEWPERFTICKCOUNTER(_perf_sys_class_lookup_time, SUN_CLS, \"lookupSysClassTime\");\n@@ -1448,1 +1447,1 @@\n-  if (Arguments::is_dumping_archive()) {\n+  if (CDSConfig::is_dumping_archive()) {\n@@ -1454,1 +1453,1 @@\n-  if (Arguments::is_dumping_archive()) {\n+  if (CDSConfig::is_dumping_archive()) {\n@@ -1463,1 +1462,1 @@\n-  Arguments::assert_is_dumping_archive();\n+  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -171,1 +171,0 @@\n-  static PerfCounter* _perf_sys_class_lookup_time;\n@@ -292,1 +291,0 @@\n-  static PerfCounter* perf_sys_class_lookup_time()    { return _perf_sys_class_lookup_time; }\n","filename":"src\/hotspot\/share\/classfile\/classLoader.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -31,1 +32,0 @@\n-#include \"runtime\/arguments.hpp\"\n@@ -73,1 +73,1 @@\n-  Arguments::assert_is_dumping_archive();\n+  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n@@ -95,1 +95,1 @@\n-  Arguments::assert_is_dumping_archive();\n+  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n","filename":"src\/hotspot\/share\/classfile\/classLoader.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -73,1 +74,1 @@\n-  Arguments::assert_is_dumping_archive();\n+  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n@@ -124,1 +125,1 @@\n-  Arguments::assert_is_dumping_archive();\n+  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n@@ -260,1 +261,1 @@\n-  Arguments::assert_is_dumping_archive();\n+  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n","filename":"src\/hotspot\/share\/classfile\/classLoaderExt.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -33,1 +34,0 @@\n-#include \"runtime\/arguments.hpp\"\n@@ -35,0 +35,1 @@\n+#include \"runtime\/java.hpp\"\n@@ -47,1 +48,1 @@\n-  Arguments::assert_is_dumping_archive();\n+  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n","filename":"src\/hotspot\/share\/classfile\/compactHashtable.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -39,1 +40,0 @@\n-#include \"runtime\/arguments.hpp\"\n@@ -1072,1 +1072,1 @@\n-  if (JvmtiExport::can_maintain_original_method_order() || Arguments::is_dumping_archive()) {\n+  if (JvmtiExport::can_maintain_original_method_order() || CDSConfig::is_dumping_archive()) {\n","filename":"src\/hotspot\/share\/classfile\/defaultMethods.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -42,1 +43,0 @@\n-#include \"runtime\/arguments.hpp\"\n@@ -214,1 +214,1 @@\n-  Arguments::assert_is_dumping_archive();\n+  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n","filename":"src\/hotspot\/share\/classfile\/dictionary.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -1067,1 +1068,1 @@\n-    if (DumpSharedSpaces) {\n+    if (CDSConfig::is_dumping_heap()) {\n@@ -1369,1 +1370,1 @@\n-  if (DumpSharedSpaces) {\n+  if (CDSConfig::is_dumping_heap()) {\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -37,1 +38,0 @@\n-#include \"runtime\/arguments.hpp\"\n@@ -215,1 +215,1 @@\n-  if (Arguments::is_dumping_archive()) {\n+  if (CDSConfig::is_dumping_archive()) {\n","filename":"src\/hotspot\/share\/classfile\/klassFactory.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -808,1 +809,1 @@\n-  assert(DumpSharedSpaces, \"must be\");\n+  assert(CDSConfig::is_dumping_heap(), \"must be\");\n","filename":"src\/hotspot\/share\/classfile\/stringTable.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -222,1 +222,1 @@\n-    _arena = new (mtSymbol) Arena(mtSymbol, symbol_alloc_arena_size);\n+    _arena = new (mtSymbol) Arena(mtSymbol, Arena::Tag::tag_other, symbol_alloc_arena_size);\n","filename":"src\/hotspot\/share\/classfile\/symbolTable.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -1785,1 +1786,1 @@\n-    if (Arguments::is_dumping_archive() && klass_being_linked != nullptr &&\n+    if (CDSConfig::is_dumping_archive() && klass_being_linked != nullptr &&\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -199,1 +200,1 @@\n-    assert(DynamicDumpSharedSpaces, \"must be\");\n+    assert(CDSConfig::is_dumping_dynamic_archive(), \"must be\");\n@@ -438,1 +439,1 @@\n-  assert(Arguments::is_dumping_archive() || ClassListWriter::is_enabled(), \"sanity\");\n+  assert(CDSConfig::is_dumping_archive() || ClassListWriter::is_enabled(), \"sanity\");\n@@ -492,1 +493,1 @@\n-  Arguments::assert_is_dumping_archive();\n+  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n@@ -500,1 +501,1 @@\n-  if (Arguments::is_dumping_archive()) {\n+  if (CDSConfig::is_dumping_archive()) {\n@@ -519,1 +520,1 @@\n-  if (Arguments::is_dumping_archive()) {\n+  if (CDSConfig::is_dumping_archive()) {\n@@ -523,1 +524,1 @@\n-  if (Arguments::is_dumping_archive() || ClassListWriter::is_enabled()) {\n+  if (CDSConfig::is_dumping_archive() || ClassListWriter::is_enabled()) {\n@@ -628,1 +629,1 @@\n-  if (DynamicDumpSharedSpaces) {\n+  if (CDSConfig::is_dumping_dynamic_archive()) {\n@@ -649,1 +650,1 @@\n-  Arguments::assert_is_dumping_archive();\n+  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n@@ -656,1 +657,1 @@\n-  Arguments::assert_is_dumping_archive();\n+  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n@@ -662,1 +663,1 @@\n-  Arguments::assert_is_dumping_archive();\n+  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n@@ -668,1 +669,1 @@\n-  Arguments::assert_is_dumping_archive();\n+  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n@@ -674,1 +675,1 @@\n-  Arguments::assert_is_dumping_archive();\n+  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n@@ -700,1 +701,1 @@\n-  Arguments::assert_is_dumping_archive();\n+  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n@@ -705,1 +706,1 @@\n-  if (DynamicDumpSharedSpaces) {\n+  if (CDSConfig::is_dumping_dynamic_archive()) {\n@@ -996,1 +997,1 @@\n-  Arguments::assert_is_dumping_archive();\n+  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":16,"deletions":15,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -35,1 +36,0 @@\n-#include \"runtime\/arguments.hpp\"\n@@ -112,1 +112,1 @@\n-    if (Arguments::is_dumping_archive()) {\n+    if (CDSConfig::is_dumping_archive()) {\n","filename":"src\/hotspot\/share\/classfile\/verificationType.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -741,3 +741,1 @@\n-UpcallStub::UpcallStub(const char* name, CodeBuffer* cb, int size,\n-                       intptr_t exception_handler_offset,\n-                       jobject receiver, ByteSize frame_data_offset) :\n+UpcallStub::UpcallStub(const char* name, CodeBuffer* cb, int size, jobject receiver, ByteSize frame_data_offset) :\n@@ -746,1 +744,0 @@\n-  _exception_handler_offset(exception_handler_offset),\n@@ -756,3 +753,1 @@\n-UpcallStub* UpcallStub::create(const char* name, CodeBuffer* cb,\n-                               intptr_t exception_handler_offset,\n-                               jobject receiver, ByteSize frame_data_offset) {\n+UpcallStub* UpcallStub::create(const char* name, CodeBuffer* cb, jobject receiver, ByteSize frame_data_offset) {\n@@ -765,2 +760,1 @@\n-    blob = new (size) UpcallStub(name, cb, size,\n-                                         exception_handler_offset, receiver, frame_data_offset);\n+    blob = new (size) UpcallStub(name, cb, size, receiver, frame_data_offset);\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -736,1 +736,0 @@\n-  intptr_t _exception_handler_offset;\n@@ -740,3 +739,1 @@\n-  UpcallStub(const char* name, CodeBuffer* cb, int size,\n-                     intptr_t exception_handler_offset,\n-                     jobject receiver, ByteSize frame_data_offset);\n+  UpcallStub(const char* name, CodeBuffer* cb, int size, jobject receiver, ByteSize frame_data_offset);\n@@ -757,3 +754,1 @@\n-  static UpcallStub* create(const char* name, CodeBuffer* cb,\n-                            intptr_t exception_handler_offset,\n-                            jobject receiver, ByteSize frame_data_offset);\n+  static UpcallStub* create(const char* name, CodeBuffer* cb, jobject receiver, ByteSize frame_data_offset);\n@@ -763,1 +758,0 @@\n-  address exception_handler() { return code_begin() + _exception_handler_offset; }\n","filename":"src\/hotspot\/share\/code\/codeBlob.hpp","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -705,8 +705,0 @@\n-int CodeCache::alignment_unit() {\n-  return (int)_heaps->first()->alignment_unit();\n-}\n-\n-int CodeCache::alignment_offset() {\n-  return (int)_heaps->first()->alignment_offset();\n-}\n-\n@@ -1027,1 +1019,1 @@\n-CodeCache::UnloadingScope::UnloadingScope(BoolObjectClosure* is_alive)\n+CodeCache::UnlinkingScope::UnlinkingScope(BoolObjectClosure* is_alive)\n@@ -1036,1 +1028,1 @@\n-CodeCache::UnloadingScope::~UnloadingScope() {\n+CodeCache::UnlinkingScope::~UnlinkingScope() {\n@@ -1039,1 +1031,0 @@\n-  CodeCache::flush_unlinked_nmethods();\n@@ -1254,0 +1245,48 @@\n+#ifndef PRODUCT\n+\/\/ Check if any of live methods dependencies have been invalidated.\n+\/\/ (this is expensive!)\n+static void check_live_nmethods_dependencies(DepChange& changes) {\n+  \/\/ Checked dependencies are allocated into this ResourceMark\n+  ResourceMark rm;\n+\n+  \/\/ Turn off dependency tracing while actually testing dependencies.\n+  FlagSetting fs(Dependencies::_verify_in_progress, true);\n+\n+  typedef ResourceHashtable<DependencySignature, int, 11027,\n+                            AnyObj::RESOURCE_AREA, mtInternal,\n+                            &DependencySignature::hash,\n+                            &DependencySignature::equals> DepTable;\n+\n+  DepTable* table = new DepTable();\n+\n+  \/\/ Iterate over live nmethods and check dependencies of all nmethods that are not\n+  \/\/ marked for deoptimization. A particular dependency is only checked once.\n+  NMethodIterator iter(NMethodIterator::only_not_unloading);\n+  while(iter.next()) {\n+    nmethod* nm = iter.method();\n+    \/\/ Only notify for live nmethods\n+    if (!nm->is_marked_for_deoptimization()) {\n+      for (Dependencies::DepStream deps(nm); deps.next(); ) {\n+        \/\/ Construct abstraction of a dependency.\n+        DependencySignature* current_sig = new DependencySignature(deps);\n+\n+        \/\/ Determine if dependency is already checked. table->put(...) returns\n+        \/\/ 'true' if the dependency is added (i.e., was not in the hashtable).\n+        if (table->put(*current_sig, 1)) {\n+          if (deps.check_dependency() != nullptr) {\n+            \/\/ Dependency checking failed. Print out information about the failed\n+            \/\/ dependency and finally fail with an assert. We can fail here, since\n+            \/\/ dependency checking is never done in a product build.\n+            tty->print_cr(\"Failed dependency:\");\n+            changes.print();\n+            nm->print();\n+            nm->print_dependencies_on(tty);\n+            assert(false, \"Should have been marked for deoptimization\");\n+          }\n+        }\n+      }\n+    }\n+  }\n+}\n+#endif\n+\n@@ -1275,1 +1314,1 @@\n-    nmethod::check_all_dependencies(changes);\n+    check_live_nmethods_dependencies(changes);\n","filename":"src\/hotspot\/share\/code\/codeCache.cpp","additions":51,"deletions":12,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -154,2 +154,0 @@\n-  static int  alignment_unit();                            \/\/ guaranteed alignment of all CodeBlobs\n-  static int  alignment_offset();                          \/\/ guaranteed offset of first CodeBlob byte within alignment unit (i.e., allocation header)\n@@ -182,5 +180,5 @@\n-  \/\/ If any oops are not marked this method unloads (i.e., breaks root links\n-  \/\/ to) any unmarked codeBlobs in the cache.  Sets \"marked_for_unloading\"\n-  \/\/ to \"true\" iff some code got unloaded.\n-  \/\/ \"unloading_occurred\" controls whether metadata should be cleaned because of class unloading.\n-  class UnloadingScope: StackObj {\n+\n+  \/\/ Helper scope object managing code cache unlinking behavior, i.e. sets and\n+  \/\/ restores the closure that determines which nmethods are going to be removed\n+  \/\/ during the unlinking part of code cache unloading.\n+  class UnlinkingScope : StackObj {\n@@ -191,2 +189,2 @@\n-    UnloadingScope(BoolObjectClosure* is_alive);\n-    ~UnloadingScope();\n+    UnlinkingScope(BoolObjectClosure* is_alive);\n+    ~UnlinkingScope();\n","filename":"src\/hotspot\/share\/code\/codeCache.hpp","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -562,2 +562,2 @@\n-  if (cb != nullptr && cb->is_adapter_blob()) {\n-    return true;\n+  if (cb == nullptr) {\n+    return false;\n@@ -565,4 +565,4 @@\n-  \/\/ itable stubs also use CompiledICHolder\n-  if (cb != nullptr && cb->is_vtable_blob()) {\n-    VtableStub* s = VtableStubs::entry_point(entry);\n-    return (s != nullptr) && s->is_itable_stub();\n+  if (cb->is_adapter_blob()) {\n+    return true;\n+  } else if (cb->is_vtable_blob()) {\n+    return VtableStubs::is_icholder_entry(entry);\n@@ -570,1 +570,0 @@\n-\n","filename":"src\/hotspot\/share\/code\/compiledIC.cpp","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"runtime\/atomic.hpp\"\n@@ -47,2 +48,2 @@\n-CompiledICHolder* InlineCacheBuffer::_pending_released = nullptr;\n-int InlineCacheBuffer::_pending_count = 0;\n+CompiledICHolder* volatile InlineCacheBuffer::_pending_released = nullptr;\n+volatile int InlineCacheBuffer::_pending_count = 0;\n@@ -250,1 +251,1 @@\n-  CompiledICHolder* holder = _pending_released;\n+  CompiledICHolder* holder = Atomic::load(&_pending_released);\n@@ -252,0 +253,1 @@\n+  int count = 0;\n@@ -256,1 +258,1 @@\n-    _pending_count--;\n+    count++;\n@@ -258,1 +260,2 @@\n-  assert(_pending_count == 0, \"wrong count\");\n+  assert(pending_icholder_count() == count, \"wrong count\");\n+  Atomic::store(&_pending_count, 0);\n@@ -262,1 +265,1 @@\n-\/\/ not safe to free them until them since they might be visible to\n+\/\/ not safe to free them until then since they might be visible to\n@@ -265,4 +268,14 @@\n-  MutexLocker mex(InlineCacheBuffer_lock, Mutex::_no_safepoint_check_flag);\n-  icholder->set_next(_pending_released);\n-  _pending_released = icholder;\n-  _pending_count++;\n+  assert(icholder->next() == nullptr, \"multiple enqueue?\");\n+\n+  CompiledICHolder* old = Atomic::load(&_pending_released);\n+  for (;;) {\n+    icholder->set_next(old);\n+    \/\/ The only reader runs at a safepoint serially so there is no need for a more strict atomic.\n+    CompiledICHolder* cur = Atomic::cmpxchg(&_pending_released, old, icholder, memory_order_relaxed);\n+    if (cur == old) {\n+      break;\n+    }\n+    old = cur;\n+  }\n+  Atomic::inc(&_pending_count, memory_order_relaxed);\n+\n@@ -273,0 +286,4 @@\n+\n+int InlineCacheBuffer::pending_icholder_count() {\n+  return Atomic::load(&_pending_count);\n+}\n","filename":"src\/hotspot\/share\/code\/icBuffer.cpp","additions":27,"deletions":10,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -149,2 +149,2 @@\n-  static CompiledICHolder* _pending_released;\n-  static int _pending_count;\n+  static CompiledICHolder* volatile _pending_released;\n+  static volatile int _pending_count;\n@@ -179,1 +179,1 @@\n-  static int pending_icholder_count() { return _pending_count; }\n+  static int pending_icholder_count();\n","filename":"src\/hotspot\/share\/code\/icBuffer.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2151,45 +2151,0 @@\n-\n-void nmethod::check_all_dependencies(DepChange& changes) {\n-  \/\/ Checked dependencies are allocated into this ResourceMark\n-  ResourceMark rm;\n-\n-  \/\/ Turn off dependency tracing while actually testing dependencies.\n-  NOT_PRODUCT( FlagSetting fs(Dependencies::_verify_in_progress, true));\n-\n-  typedef ResourceHashtable<DependencySignature, int, 11027,\n-                            AnyObj::RESOURCE_AREA, mtInternal,\n-                            &DependencySignature::hash,\n-                            &DependencySignature::equals> DepTable;\n-\n-  DepTable* table = new DepTable();\n-\n-  \/\/ Iterate over live nmethods and check dependencies of all nmethods that are not\n-  \/\/ marked for deoptimization. A particular dependency is only checked once.\n-  NMethodIterator iter(NMethodIterator::only_not_unloading);\n-  while(iter.next()) {\n-    nmethod* nm = iter.method();\n-    \/\/ Only notify for live nmethods\n-    if (!nm->is_marked_for_deoptimization()) {\n-      for (Dependencies::DepStream deps(nm); deps.next(); ) {\n-        \/\/ Construct abstraction of a dependency.\n-        DependencySignature* current_sig = new DependencySignature(deps);\n-\n-        \/\/ Determine if dependency is already checked. table->put(...) returns\n-        \/\/ 'true' if the dependency is added (i.e., was not in the hashtable).\n-        if (table->put(*current_sig, 1)) {\n-          if (deps.check_dependency() != nullptr) {\n-            \/\/ Dependency checking failed. Print out information about the failed\n-            \/\/ dependency and finally fail with an assert. We can fail here, since\n-            \/\/ dependency checking is never done in a product build.\n-            tty->print_cr(\"Failed dependency:\");\n-            changes.print();\n-            nm->print();\n-            nm->print_dependencies_on(tty);\n-            assert(false, \"Should have been marked for deoptimization\");\n-          }\n-        }\n-      }\n-    }\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":0,"deletions":45,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -680,4 +680,0 @@\n-  \/\/ tells if any of this method's dependencies have been invalidated\n-  \/\/ (this is expensive!)\n-  static void check_all_dependencies(DepChange& changes);\n-\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -98,2 +98,1 @@\n-VtableStub* VtableStubs::_table[VtableStubs::N];\n-int VtableStubs::_number_of_vtable_stubs = 0;\n+VtableStub* volatile VtableStubs::_table[VtableStubs::N];\n@@ -129,0 +128,2 @@\n+  assert(VtableStub::_receiver_location == VMRegImpl::Bad(), \"initialized multiple times?\");\n+\n@@ -132,2 +133,0 @@\n-    assert(_number_of_vtable_stubs == 0, \"potential performance bug: VtableStubs initialized more than once\");\n-    assert(is_power_of_2(int(N)), \"N must be a power of 2\");\n@@ -135,1 +134,1 @@\n-      _table[i] = nullptr;\n+      Atomic::store(&_table[i], (VtableStub*)nullptr);\n@@ -262,1 +261,1 @@\n-  VtableStub* s = _table[hash];\n+  VtableStub* s = Atomic::load(&_table[hash]);\n@@ -272,4 +271,4 @@\n-  \/\/ enter s at the beginning of the corresponding list\n-  s->set_next(_table[h]);\n-  _table[h] = s;\n-  _number_of_vtable_stubs++;\n+  \/\/ Insert s at the beginning of the corresponding list.\n+  s->set_next(Atomic::load(&_table[h]));\n+  \/\/ Make sure that concurrent readers not taking the mutex observe the writing of \"next\".\n+  Atomic::release_store(&_table[h], s);\n@@ -283,1 +282,1 @@\n-  for (s = _table[hash]; s != nullptr && s != stub; s = s->next()) {}\n+  for (s = Atomic::load(&_table[hash]); s != nullptr && s != stub; s = s->next()) {}\n@@ -287,0 +286,7 @@\n+bool VtableStubs::is_icholder_entry(address pc) {\n+  assert(contains(pc), \"must contain all vtable blobs\");\n+  VtableStub* stub = (VtableStub*)(pc - VtableStub::entry_offset());\n+  \/\/ itable stubs use CompiledICHolder.\n+  return stub->is_itable_stub();\n+}\n+\n@@ -295,3 +301,0 @@\n-  \/\/ Note: No locking needed since any change to the data structure\n-  \/\/       happens with an atomic store into it (we don't care about\n-  \/\/       consistency with the _number_of_vtable_stubs counter).\n@@ -299,1 +302,1 @@\n-    for (VtableStub* s = _table[i]; s != nullptr; s = s->next()) {\n+    for (VtableStub* s = Atomic::load_acquire(&_table[i]); s != nullptr; s = s->next()) {\n@@ -311,4 +314,3 @@\n-    for (int i = 0; i < N; i++) {\n-        for (VtableStub* s = _table[i]; s != nullptr; s = s->next()) {\n-            f(s);\n-        }\n+  for (int i = 0; i < N; i++) {\n+    for (VtableStub* s = Atomic::load_acquire(&_table[i]); s != nullptr; s = s->next()) {\n+      f(s);\n@@ -316,0 +318,1 @@\n+  }\n","filename":"src\/hotspot\/share\/code\/vtableStubs.cpp","additions":22,"deletions":19,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -83,0 +83,2 @@\n+  static_assert(is_power_of_2((int)N), \"N must be a power of 2\");\n+\n@@ -85,2 +87,1 @@\n-  static VtableStub* _table[N];                  \/\/ table of existing stubs\n-  static int         _number_of_vtable_stubs;    \/\/ number of stubs created so far (for statistics)\n+  static VtableStub* volatile _table[N];                  \/\/ table of existing stubs\n@@ -109,0 +110,1 @@\n+  static bool        is_icholder_entry(address pc);                  \/\/ is the blob containing pc (which must be a vtable blob) an icholder?\n@@ -111,1 +113,0 @@\n-  static int         number_of_vtable_stubs() { return _number_of_vtable_stubs; }\n","filename":"src\/hotspot\/share\/code\/vtableStubs.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,451 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Red Hat, Inc. and\/or its affiliates.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"logging\/logStream.hpp\"\n+#include \"compiler\/abstractCompiler.hpp\"\n+#include \"compiler\/compilationMemoryStatistic.hpp\"\n+#include \"compiler\/compilerDirectives.hpp\"\n+#include \"compiler\/compileTask.hpp\"\n+#include \"compiler\/compilerDefinitions.hpp\"\n+#include \"compiler\/compilerThread.hpp\"\n+#include \"memory\/arena.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"oops\/symbol.hpp\"\n+#ifdef COMPILER2\n+#include \"opto\/node.hpp\" \/\/ compile.hpp is not self-contained\n+#include \"opto\/compile.hpp\"\n+#endif\n+#include \"services\/nmtCommon.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+#include \"utilities\/quickSort.hpp\"\n+#include \"utilities\/resourceHash.hpp\"\n+\n+\n+ArenaStatCounter::ArenaStatCounter() :\n+  _current(0), _start(0), _peak(0),\n+  _na(0), _ra(0),\n+  _na_at_peak(0), _ra_at_peak(0), _live_nodes_at_peak(0)\n+{}\n+\n+size_t ArenaStatCounter::peak_since_start() const {\n+  return _peak > _start ? _peak - _start : 0;\n+}\n+\n+void ArenaStatCounter::start() {\n+  _peak = _start = _current;\n+}\n+\n+void ArenaStatCounter::update_c2_node_count() {\n+#ifdef COMPILER2\n+  CompilerThread* const th = Thread::current()->as_Compiler_thread();\n+  const CompileTask* const task = th->task();\n+  if (task != nullptr &&\n+      th->task()->compiler() != nullptr &&\n+      th->task()->compiler()->type() == compiler_c2) {\n+    const Compile* const comp = Compile::current();\n+    if (comp != nullptr) {\n+      _live_nodes_at_peak = comp->live_nodes();\n+    }\n+  }\n+#endif\n+}\n+\n+\/\/ Account an arena allocation or de-allocation.\n+bool ArenaStatCounter::account(ssize_t delta, int tag) {\n+  bool rc = false;\n+#ifdef ASSERT\n+  \/\/ Note: if this fires, we free more arena memory under the scope of the\n+  \/\/ CompilationMemoryHistoryMark than we allocate. This cannot be since we\n+  \/\/ assume arena allocations in CompilerThread to be stack bound and symmetric.\n+  assert(delta >= 0 || ((ssize_t)_current + delta) >= 0,\n+         \"Negative overflow (d=%zd %zu %zu %zu)\", delta, _current, _start, _peak);\n+#endif\n+  \/\/ Update totals\n+  _current += delta;\n+  \/\/ Update detail counter\n+  switch ((Arena::Tag)tag) {\n+    case Arena::Tag::tag_ra: _ra += delta; break;\n+    case Arena::Tag::tag_node: _na += delta; break;\n+    default: \/\/ ignore\n+      break;\n+  };\n+  \/\/ Did we reach a peak?\n+  if (_current > _peak) {\n+    _peak = _current;\n+    assert(delta > 0, \"Sanity (%zu %zu %zu)\", _current, _start, _peak);\n+    _na_at_peak = _na;\n+    _ra_at_peak = _ra;\n+    update_c2_node_count();\n+    rc = true;\n+  }\n+  return rc;\n+}\n+\n+void ArenaStatCounter::print_on(outputStream* st) const {\n+  st->print(\"%zu [na %zu ra %zu]\", peak_since_start(), _na_at_peak, _ra_at_peak);\n+#ifdef ASSERT\n+  st->print(\" (%zu->%zu->%zu)\", _start, _peak, _current);\n+#endif\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/ Backend\n+\n+class FullMethodName {\n+  Symbol* const _k;\n+  Symbol* const _m;\n+  Symbol* const _s;\n+\n+public:\n+\n+  FullMethodName(Symbol* k, Symbol* m, Symbol* s) : _k(k), _m(m), _s(s) {}\n+  FullMethodName(const FullMethodName& o) : _k(o._k), _m(o._m), _s(o._s) {}\n+\n+  void make_permanent() {\n+    _k->make_permanent();\n+    _m->make_permanent();\n+    _s->make_permanent();\n+  }\n+\n+  static unsigned compute_hash(const FullMethodName& n) {\n+    return Symbol::compute_hash(n._k) ^\n+        Symbol::compute_hash(n._m) ^\n+        Symbol::compute_hash(n._s);\n+  }\n+\n+  char* as_C_string(char* buf, size_t len) const {\n+    stringStream ss(buf, len);\n+    ResourceMark rm;\n+    ss.print_raw(_k->as_C_string());\n+    ss.print_raw(\"::\");\n+    ss.print_raw(_m->as_C_string());\n+    ss.put('(');\n+    ss.print_raw(_s->as_C_string());\n+    ss.put(')');\n+    return buf;\n+  }\n+\n+  bool equals(const FullMethodName& b) const {\n+    return _k == b._k && _m == b._m && _s == b._s;\n+  }\n+\n+  bool operator== (const FullMethodName& other) const { return equals(other); }\n+};\n+\n+\/\/ Note: not mtCompiler since we don't want to change what we measure\n+class MemStatEntry : public CHeapObj<mtInternal> {\n+  const FullMethodName _method;\n+  CompilerType _comptype;\n+  double _time;\n+  \/\/ How often this has been recompiled.\n+  int _num_recomp;\n+  \/\/ Compiling thread. Only for diagnostic purposes. Thread may not be alive anymore.\n+  const Thread* _thread;\n+\n+  size_t _total;\n+  size_t _na_at_peak;\n+  size_t _ra_at_peak;\n+  unsigned _live_nodes_at_peak;\n+\n+public:\n+\n+  MemStatEntry(FullMethodName method)\n+    : _method(method), _comptype(compiler_c1),\n+      _time(0), _num_recomp(0), _thread(nullptr),\n+      _total(0), _na_at_peak(0), _ra_at_peak(0), _live_nodes_at_peak(0) {\n+  }\n+\n+  void set_comptype(CompilerType comptype) { _comptype = comptype; }\n+  void set_current_time() { _time = os::elapsedTime(); }\n+  void set_current_thread() { _thread = Thread::current(); }\n+  void inc_recompilation() { _num_recomp++; }\n+\n+  void set_total(size_t n) { _total = n; }\n+  void set_na_at_peak(size_t n) { _na_at_peak = n; }\n+  void set_ra_at_peak(size_t n) { _ra_at_peak = n; }\n+  void set_live_nodes_at_peak(unsigned n) { _live_nodes_at_peak = n; }\n+\n+  size_t total() const { return _total; }\n+\n+  static void print_legend(outputStream* st) {\n+    st->print_cr(\"Legend:\");\n+    st->print_cr(\"  total  : memory allocated via arenas while compiling\");\n+    st->print_cr(\"  NA     : ...how much in node arenas (if c2)\");\n+    st->print_cr(\"  RA     : ...how much in resource areas\");\n+    st->print_cr(\"  #nodes : ...how many nodes (if c2)\");\n+    st->print_cr(\"  time   : time of last compilation (sec)\");\n+    st->print_cr(\"  type   : compiler type\");\n+    st->print_cr(\"  #rc    : how often recompiled\");\n+    st->print_cr(\"  thread : compiler thread\");\n+  }\n+\n+  static void print_header(outputStream* st) {\n+    st->print_cr(\"total     NA        RA        #nodes  time    type  #rc thread              method\");\n+  }\n+\n+  void print_on(outputStream* st, bool human_readable) const {\n+    int col = 0;\n+\n+    \/\/ Total\n+    if (human_readable) {\n+      st->print(PROPERFMT \" \", PROPERFMTARGS(_total));\n+    } else {\n+      st->print(\"%zu \", _total);\n+    }\n+    col += 10; st->fill_to(col);\n+\n+    \/\/ NA\n+    if (human_readable) {\n+      st->print(PROPERFMT \" \", PROPERFMTARGS(_na_at_peak));\n+    } else {\n+      st->print(\"%zu \", _na_at_peak);\n+    }\n+    col += 10; st->fill_to(col);\n+\n+    \/\/ RA\n+    if (human_readable) {\n+      st->print(PROPERFMT \" \", PROPERFMTARGS(_ra_at_peak));\n+    } else {\n+      st->print(\"%zu \", _ra_at_peak);\n+    }\n+    col += 10; st->fill_to(col);\n+\n+    \/\/ Number of Nodes when memory peaked\n+    st->print(\"%u \", _live_nodes_at_peak);\n+    col += 8; st->fill_to(col);\n+\n+    \/\/ TimeStamp\n+    st->print(\"%.3f \", _time);\n+    col += 8; st->fill_to(col);\n+\n+    \/\/ Type\n+    st->print(\"%s \", compilertype2name(_comptype));\n+    col += 6; st->fill_to(col);\n+\n+    \/\/ Recomp\n+    st->print(\"%u \", _num_recomp);\n+    col += 4; st->fill_to(col);\n+\n+    \/\/ Thread\n+    st->print(PTR_FORMAT \"  \", p2i(_thread));\n+\n+    \/\/ MethodName\n+    char buf[1024];\n+    st->print(\"%s \", _method.as_C_string(buf, sizeof(buf)));\n+    st->cr();\n+  }\n+\n+  int compare_by_size(const MemStatEntry* b) const {\n+    const size_t x1 = b->_total;\n+    const size_t x2 = _total;\n+    return x1 < x2 ? -1 : x1 == x2 ? 0 : 1;\n+  }\n+\n+  bool equals(const FullMethodName& b) const {\n+    return _method.equals(b);\n+  }\n+};\n+\n+class MemStatTable :\n+    public ResourceHashtable<FullMethodName, MemStatEntry*, 7919, AnyObj::C_HEAP,\n+                             mtInternal, FullMethodName::compute_hash>\n+{\n+public:\n+\n+  void add(const FullMethodName& fmn, CompilerType comptype,\n+           size_t total, size_t na_at_peak, size_t ra_at_peak,\n+           unsigned live_nodes_at_peak) {\n+    assert_lock_strong(NMTCompilationCostHistory_lock);\n+\n+    MemStatEntry** pe = get(fmn);\n+    MemStatEntry* e = nullptr;\n+    if (pe == nullptr) {\n+      e = new MemStatEntry(fmn);\n+      put(fmn, e);\n+    } else {\n+      \/\/ Update existing entry\n+      e = *pe;\n+      assert(e != nullptr, \"Sanity\");\n+    }\n+    e->set_current_time();\n+    e->set_current_thread();\n+    e->set_comptype(comptype);\n+    e->inc_recompilation();\n+    e->set_total(total);\n+    e->set_na_at_peak(na_at_peak);\n+    e->set_ra_at_peak(ra_at_peak);\n+    e->set_live_nodes_at_peak(live_nodes_at_peak);\n+  }\n+\n+  \/\/ Returns a C-heap-allocated SortMe array containing all entries from the table,\n+  \/\/ optionally filtered by entry size\n+  MemStatEntry** calc_flat_array(int& num, size_t min_size) {\n+    assert_lock_strong(NMTCompilationCostHistory_lock);\n+\n+    const int num_all = number_of_entries();\n+    MemStatEntry** flat = NEW_C_HEAP_ARRAY(MemStatEntry*, num_all, mtInternal);\n+    int i = 0;\n+    auto do_f = [&] (const FullMethodName& ignored, MemStatEntry* e) {\n+      if (e->total() >= min_size) {\n+        flat[i] = e;\n+        assert(i < num_all, \"Sanity\");\n+        i ++;\n+      }\n+    };\n+    iterate_all(do_f);\n+    if (min_size == 0) {\n+      assert(i == num_all, \"Sanity\");\n+    } else {\n+      assert(i <= num_all, \"Sanity\");\n+    }\n+    num = i;\n+    return flat;\n+  }\n+};\n+\n+bool CompilationMemoryStatistic::_enabled = false;\n+\n+static MemStatTable* _the_table = nullptr;\n+\n+void CompilationMemoryStatistic::initialize() {\n+  assert(_enabled == false && _the_table == nullptr, \"Only once\");\n+  _the_table = new (mtCompiler) MemStatTable;\n+  _enabled = true;\n+  log_info(compilation, alloc)(\"Compilation memory statistic enabled\");\n+}\n+\n+void CompilationMemoryStatistic::on_start_compilation() {\n+  assert(enabled(), \"Not enabled?\");\n+  Thread::current()->as_Compiler_thread()->arena_stat()->start();\n+}\n+\n+void CompilationMemoryStatistic::on_end_compilation() {\n+  assert(enabled(), \"Not enabled?\");\n+  ResourceMark rm;\n+  CompilerThread* const th = Thread::current()->as_Compiler_thread();\n+  const ArenaStatCounter* const arena_stat = th->arena_stat();\n+  const CompilerType ct = th->task()->compiler()->type();\n+\n+  const Method* const m = th->task()->method();\n+  FullMethodName fmn(m->klass_name(), m->name(), m->signature());\n+  fmn.make_permanent();\n+\n+  const DirectiveSet* directive = th->task()->directive();\n+  assert(directive->should_collect_memstat(), \"Only call if memstat is enabled\");\n+  const bool print = directive->should_print_memstat();\n+\n+  if (print) {\n+    char buf[1024];\n+    fmn.as_C_string(buf, sizeof(buf));\n+    tty->print(\"%s Arena usage %s: \", compilertype2name(ct), buf);\n+    arena_stat->print_on(tty);\n+    tty->cr();\n+  }\n+  {\n+    MutexLocker ml(NMTCompilationCostHistory_lock, Mutex::_no_safepoint_check_flag);\n+    assert(_the_table != nullptr, \"not initialized\");\n+\n+    _the_table->add(fmn, ct,\n+                    arena_stat->peak_since_start(), \/\/ total\n+                    arena_stat->na_at_peak(),\n+                    arena_stat->ra_at_peak(),\n+                    arena_stat->live_nodes_at_peak());\n+  }\n+}\n+\n+void CompilationMemoryStatistic::on_arena_change(ssize_t diff, const Arena* arena) {\n+  assert(enabled(), \"Not enabled?\");\n+  CompilerThread* const th = Thread::current()->as_Compiler_thread();\n+  th->arena_stat()->account(diff, (int)arena->get_tag());\n+}\n+\n+static inline ssize_t diff_entries_by_size(const MemStatEntry* e1, const MemStatEntry* e2) {\n+  return e1->compare_by_size(e2);\n+}\n+\n+void CompilationMemoryStatistic::print_all_by_size(outputStream* st, bool human_readable, size_t min_size) {\n+  st->print_cr(\"Compilation memory statistics\");\n+\n+  if (!enabled()) {\n+    st->print_cr(\"(unavailable)\");\n+    return;\n+  }\n+\n+  st->cr();\n+\n+  MemStatEntry::print_legend(st);\n+  st->cr();\n+\n+  if (min_size > 0) {\n+    st->print_cr(\" (cutoff: %zu bytes)\", min_size);\n+  }\n+  st->cr();\n+\n+  MemStatEntry::print_header(st);\n+\n+  MemStatEntry** filtered = nullptr;\n+  {\n+    MutexLocker ml(NMTCompilationCostHistory_lock, Mutex::_no_safepoint_check_flag);\n+\n+    if (_the_table != nullptr) {\n+      \/\/ We sort with quicksort\n+      int num = 0;\n+      filtered = _the_table->calc_flat_array(num, min_size);\n+      if (min_size > 0) {\n+        st->print_cr(\"(%d\/%d)\", num, _the_table->number_of_entries());\n+      }\n+      if (num > 0) {\n+        QuickSort::sort(filtered, num, diff_entries_by_size, false);\n+        \/\/ Now print. Has to happen under lock protection too, since entries may be changed.\n+        for (int i = 0; i < num; i ++) {\n+          filtered[i]->print_on(st, human_readable);\n+        }\n+      } else {\n+        st->print_cr(\"No entries.\");\n+      }\n+    } else {\n+      st->print_cr(\"Not initialized.\");\n+    }\n+  } \/\/ locked\n+\n+  FREE_C_HEAP_ARRAY(Entry, filtered);\n+}\n+\n+CompilationMemoryStatisticMark::CompilationMemoryStatisticMark(const DirectiveSet* directive)\n+  : _active(directive->should_collect_memstat()) {\n+  if (_active) {\n+    CompilationMemoryStatistic::on_start_compilation();\n+  }\n+}\n+CompilationMemoryStatisticMark::~CompilationMemoryStatisticMark() {\n+  if (_active) {\n+    CompilationMemoryStatistic::on_end_compilation();\n+  }\n+}\n","filename":"src\/hotspot\/share\/compiler\/compilationMemoryStatistic.cpp","additions":451,"deletions":0,"binary":false,"changes":451,"status":"added"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Red Hat, Inc. and\/or its affiliates.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_COMPILER_COMPILATIONMEMORYSTATISTIC_HPP\n+#define SHARE_COMPILER_COMPILATIONMEMORYSTATISTIC_HPP\n+\n+#include \"compiler\/compilerDefinitions.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"memory\/allStatic.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+class outputStream;\n+class Symbol;\n+class DirectiveSet;\n+\n+\/\/ Counters for allocations from one arena\n+class ArenaStatCounter : public CHeapObj<mtCompiler> {\n+  \/\/ Current bytes, total\n+  size_t _current;\n+  \/\/ bytes when compilation started\n+  size_t _start;\n+  \/\/ bytes at last peak, total\n+  size_t _peak;\n+  \/\/ Current bytes used for node arenas, total\n+  size_t _na;\n+  \/\/ Current bytes used for resource areas\n+  size_t _ra;\n+\n+  \/\/ Peak composition:\n+  \/\/ Size of node arena when total peaked (c2 only)\n+  size_t _na_at_peak;\n+  \/\/ Size of resource area when total peaked\n+  size_t _ra_at_peak;\n+  \/\/ Number of live nodes when total peaked (c2 only)\n+  unsigned _live_nodes_at_peak;\n+\n+  void update_c2_node_count();\n+\n+public:\n+  ArenaStatCounter();\n+\n+  \/\/ Size of peak since last compilation\n+  size_t peak_since_start() const;\n+\n+  \/\/ Peak details\n+  size_t na_at_peak() const { return _na_at_peak; }\n+  size_t ra_at_peak() const { return _ra_at_peak; }\n+  unsigned live_nodes_at_peak() const { return _live_nodes_at_peak; }\n+\n+  \/\/ Mark the start of a compilation.\n+  void start();\n+\n+  \/\/ Account an arena allocation or de-allocation.\n+  \/\/ Returns true if new peak reached\n+  bool account(ssize_t delta, int tag);\n+\n+  void set_live_nodes_at_peak(unsigned i) { _live_nodes_at_peak = i; }\n+  void print_on(outputStream* st) const;\n+};\n+\n+class CompilationMemoryStatistic : public AllStatic {\n+  static bool _enabled;\n+public:\n+  static void initialize();\n+  \/\/ true if CollectMemStat or PrintMemStat has been enabled for any method\n+  static bool enabled() { return _enabled; }\n+  static void on_start_compilation();\n+  static void on_end_compilation();\n+  static void on_arena_change(ssize_t diff, const Arena* arena);\n+  static void print_all_by_size(outputStream* st, bool human_readable, size_t minsize);\n+};\n+\n+\/\/ RAII object to wrap one compilation\n+class CompilationMemoryStatisticMark {\n+  const bool _active;\n+public:\n+  CompilationMemoryStatisticMark(const DirectiveSet* directive);\n+  ~CompilationMemoryStatisticMark();\n+};\n+\n+#endif \/\/ SHARE_COMPILER_COMPILATIONMEMORYSTATISTIC_HPP\n","filename":"src\/hotspot\/share\/compiler\/compilationMemoryStatistic.hpp","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"compiler\/compilationMemoryStatistic.hpp\"\n@@ -653,0 +654,4 @@\n+  if (CompilerOracle::should_collect_memstat()) {\n+    CompilationMemoryStatistic::initialize();\n+  }\n+\n@@ -1698,1 +1703,1 @@\n-  if (comp->is_jvmci() && !task->should_wait_for_compilation()) {\n+  if (!UseJVMCINativeLibrary && comp->is_jvmci() && !task->should_wait_for_compilation()) {\n@@ -1700,0 +1705,3 @@\n+    \/\/ Note that libjvmci should not pre-emptively unblock\n+    \/\/ a thread waiting for a compilation as it does not call\n+    \/\/ Java code and so is not deadlock prone like jarjvmci.\n@@ -2206,1 +2214,3 @@\n-        failure_reason = os::strdup(err_msg(\"Error attaching to libjvmci (err: %d)\", env.init_error()), mtJVMCI);\n+        const char* msg = env.init_error_msg();\n+        failure_reason = os::strdup(err_msg(\"Error attaching to libjvmci (err: %d, %s)\",\n+                                    env.init_error(), msg == nullptr ? \"unknown\" : msg), mtJVMCI);\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-inline const char* compilertype2name(CompilerType t) { return (uint)t < compiler_number_of_types ? compilertype2name_tab[t] : nullptr; }\n+inline const char* compilertype2name(CompilerType t) { return (uint)t < compiler_number_of_types ? compilertype2name_tab[t] : \"invalid\"; }\n","filename":"src\/hotspot\/share\/compiler\/compilerDefinitions.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -205,0 +205,8 @@\n+bool DirectiveSet::should_collect_memstat() const {\n+  return MemStatOption > 0;\n+}\n+\n+bool DirectiveSet::should_print_memstat() const {\n+  return MemStatOption == (uintx)MemStatAction::print;\n+}\n+\n@@ -282,1 +290,0 @@\n-#define init_defaults_definition(name, type, dvalue, compiler) this->name##Option = dvalue;\n@@ -284,0 +291,1 @@\n+#define init_defaults_definition(name, type, dvalue, compiler) this->name##Option = dvalue;\n@@ -287,0 +295,1 @@\n+#undef init_defaults_definition\n@@ -299,0 +308,6 @@\n+\n+#define free_string_flags(name, type, dvalue, cc_flag) if (_modified[name##Index]) os::free(const_cast<char*>(name##Option));\n+  compilerdirectives_common_string_flags(free_string_flags)\n+  compilerdirectives_c2_string_flags(free_string_flags)\n+  compilerdirectives_c1_string_flags(free_string_flags)\n+#undef free_string_flags\n@@ -402,0 +417,1 @@\n+#undef init_default_cc\n@@ -580,3 +596,15 @@\n-    compilerdirectives_common_flags(copy_members_definition)\n-    compilerdirectives_c2_flags(copy_members_definition)\n-    compilerdirectives_c1_flags(copy_members_definition)\n+    compilerdirectives_common_other_flags(copy_members_definition)\n+    compilerdirectives_c2_other_flags(copy_members_definition)\n+    compilerdirectives_c1_other_flags(copy_members_definition)\n+  #undef copy_members_definition\n+\n+#define copy_string_members_definition(name, type, dvalue, cc_flag)          \\\n+  if (src->_modified[name##Index]) {                                         \\\n+    set->name##Option = os::strdup_check_oom(src->name##Option, mtCompiler); \\\n+  } else {                                                                   \\\n+    set->name##Option = src->name##Option;                                   \\\n+  }\n+  compilerdirectives_common_string_flags(copy_string_members_definition)\n+  compilerdirectives_c2_string_flags(copy_string_members_definition)\n+  compilerdirectives_c1_string_flags(copy_string_members_definition)\n+#undef copy_string_members_definition\n","filename":"src\/hotspot\/share\/compiler\/compilerDirectives.cpp","additions":32,"deletions":4,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-  #define compilerdirectives_common_flags(cflags) \\\n+  #define compilerdirectives_common_other_flags(cflags) \\\n@@ -44,0 +44,1 @@\n+    cflags(MemStat,                 uintx, 0, MemStat) \\\n@@ -53,2 +54,0 @@\n-    cflags(DisableIntrinsic,        ccstrlist, DisableIntrinsic, DisableIntrinsic) \\\n-    cflags(ControlIntrinsic,        ccstrlist, ControlIntrinsic, ControlIntrinsic) \\\n@@ -56,0 +55,6 @@\n+#define compilerdirectives_common_string_flags(cflags)                           \\\n+  cflags(DisableIntrinsic,        ccstrlist, DisableIntrinsic, DisableIntrinsic) \\\n+  cflags(ControlIntrinsic,        ccstrlist, ControlIntrinsic, ControlIntrinsic)\n+#define compilerdirectives_common_flags(cflags) \\\n+  compilerdirectives_common_other_flags(cflags) \\\n+  compilerdirectives_common_string_flags(cflags)\n@@ -58,1 +63,2 @@\n-  #define compilerdirectives_c1_flags(cflags)\n+  #define compilerdirectives_c1_other_flags(cflags)\n+  #define compilerdirectives_c1_string_flags(cflags)\n@@ -60,1 +66,2 @@\n-  #define compilerdirectives_c1_flags(cflags)\n+  #define compilerdirectives_c1_other_flags(cflags)\n+  #define compilerdirectives_c1_string_flags(cflags)\n@@ -63,0 +70,4 @@\n+#define compilerdirectives_c1_flags(cflags) \\\n+  compilerdirectives_c1_other_flags(cflags) \\\n+  compilerdirectives_c1_string_flags(cflags)\n+\n@@ -64,1 +75,1 @@\n-  #define compilerdirectives_c2_flags(cflags) \\\n+  #define compilerdirectives_c2_other_flags(cflags) \\\n@@ -72,1 +83,0 @@\n-NOT_PRODUCT(cflags(PrintIdealPhase,     ccstrlist, \"\", PrintIdealPhase)) \\\n@@ -80,0 +90,2 @@\n+#define compilerdirectives_c2_string_flags(cflags) \\\n+NOT_PRODUCT(cflags(PrintIdealPhase,     ccstrlist, \"\", PrintIdealPhase))\n@@ -81,1 +93,2 @@\n-  #define compilerdirectives_c2_flags(cflags)\n+  #define compilerdirectives_c2_other_flags(cflags)\n+  #define compilerdirectives_c2_string_flags(cflags)\n@@ -84,0 +97,4 @@\n+#define compilerdirectives_c2_flags(cflags) \\\n+  compilerdirectives_c2_other_flags(cflags) \\\n+  compilerdirectives_c2_string_flags(cflags)\n+\n@@ -134,0 +151,2 @@\n+  bool should_collect_memstat() const;\n+  bool should_print_memstat() const;\n@@ -140,0 +159,1 @@\n+#undef enum_of_flags\n@@ -150,0 +170,1 @@\n+#undef flag_store_definition\n@@ -153,3 +174,22 @@\n-  compilerdirectives_common_flags(set_function_definition)\n-  compilerdirectives_c2_flags(set_function_definition)\n-  compilerdirectives_c1_flags(set_function_definition)\n+  compilerdirectives_common_other_flags(set_function_definition)\n+  compilerdirectives_c2_other_flags(set_function_definition)\n+  compilerdirectives_c1_other_flags(set_function_definition)\n+#undef set_function_definition\n+\n+\/\/ Casting to get the same function signature for all setters. Used from parser.\n+\/\/\n+\/\/ IMPORTANT: Takes ownership, will use os::free. Ensure the memory was dynamically allocated on the\n+\/\/            C heap.\n+#define set_string_function_definition(name, type, dvalue, cc_flag) \\\n+void set_##name(void* value) {                                      \\\n+  if (_modified[name##Index]) {                                     \\\n+    os::free(const_cast<char*>(name##Option));                      \\\n+  }                                                                 \\\n+  type val = *(type*)value;                                         \\\n+  name##Option = val;                                               \\\n+  _modified[name##Index] = true;                                    \\\n+}\n+  compilerdirectives_common_string_flags(set_string_function_definition)\n+  compilerdirectives_c2_string_flags(set_string_function_definition)\n+  compilerdirectives_c1_string_flags(set_string_function_definition)\n+#undef set_string_function_definition\n@@ -174,0 +214,1 @@\n+#undef print_function_definition\n","filename":"src\/hotspot\/share\/compiler\/compilerDirectives.hpp","additions":52,"deletions":11,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -104,0 +104,1 @@\n+static bool print_final_memstat_report = false;\n@@ -328,0 +329,1 @@\n+\n@@ -458,0 +460,9 @@\n+\/\/ Tells whether there are any methods to collect memory statistics for\n+bool CompilerOracle::should_collect_memstat() {\n+  return has_command(CompileCommand::MemStat);\n+}\n+\n+bool CompilerOracle::should_print_final_memstat_report() {\n+  return print_final_memstat_report;\n+}\n+\n@@ -626,0 +637,16 @@\n+static bool parseEnumValueAsUintx(enum CompileCommand option, const char* line, uintx& value, int& bytes_read, char* errorbuf, const int buf_size) {\n+  if (option == CompileCommand::MemStat) {\n+    if (strncasecmp(line, \"collect\", 7) == 0) {\n+      value = (uintx)MemStatAction::collect;\n+    } else if (strncasecmp(line, \"print\", 5) == 0) {\n+      value = (uintx)MemStatAction::print;\n+      print_final_memstat_report = true;\n+    } else {\n+      jio_snprintf(errorbuf, buf_size, \"MemStat: invalid value expected 'collect' or 'print' (omitting value means 'collect')\");\n+    }\n+    return true; \/\/ handled\n+  }\n+  return false;\n+#undef HANDLE_VALUE\n+}\n+\n@@ -645,1 +672,7 @@\n-    if (sscanf(line, \"\" UINTX_FORMAT \"%n\", &value, &bytes_read) == 1) {\n+    \/\/ Is it a named enum?\n+    bool success = parseEnumValueAsUintx(option, line, value, bytes_read, errorbuf, buf_size);\n+    if (!success) {\n+      \/\/ Is it a raw number?\n+      success = (sscanf(line, \"\" UINTX_FORMAT \"%n\", &value, &bytes_read) == 1);\n+    }\n+    if (success) {\n@@ -917,1 +950,0 @@\n-      \/\/ if this is a bool option this implies true\n@@ -919,0 +951,1 @@\n+        \/\/ if this is a bool option this implies true\n@@ -921,0 +954,4 @@\n+      } else if (option == CompileCommand::MemStat) {\n+        \/\/ MemStat default action is to collect data but to not print\n+        register_command(matcher, option, (uintx)MemStatAction::collect);\n+        return true;\n","filename":"src\/hotspot\/share\/compiler\/compilerOracle.cpp","additions":39,"deletions":2,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+  option(MemStat, \"MemStat\", Uintx) \\\n@@ -116,0 +117,4 @@\n+enum class MemStatAction {\n+  collect = 1, print = 2\n+};\n+\n@@ -154,0 +159,4 @@\n+  \/\/ Tells whether there are any methods to (collect|collect+print) memory statistics for\n+  static bool should_collect_memstat();\n+  static bool should_print_final_memstat_report();\n+\n","filename":"src\/hotspot\/share\/compiler\/compilerOracle.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"compiler\/compilationMemoryStatistic.hpp\"\n@@ -42,0 +43,1 @@\n+  _arena_stat = CompilationMemoryStatistic::enabled() ? new ArenaStatCounter : nullptr;\n@@ -54,0 +56,1 @@\n+  delete _arena_stat;\n","filename":"src\/hotspot\/share\/compiler\/compilerThread.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-class BufferBlob;\n@@ -32,0 +31,2 @@\n+class ArenaStatCounter;\n+class BufferBlob;\n@@ -57,0 +58,2 @@\n+  ArenaStatCounter*     _arena_stat;\n+\n@@ -84,0 +87,1 @@\n+  ArenaStatCounter* arena_stat() const           { return _arena_stat; }\n","filename":"src\/hotspot\/share\/compiler\/compilerThread.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -318,1 +318,1 @@\n-        char* s = NEW_C_HEAP_ARRAY(char, v->str.length+1,  mtCompiler);\n+        char* s = NEW_C_HEAP_ARRAY(char, v->str.length + 1, mtCompiler);\n@@ -321,1 +321,2 @@\n-        (set->*test)((void *)&s);\n+\n+        bool valid = true;\n@@ -326,1 +327,2 @@\n-          if (!validator.is_valid()) {\n+          valid = validator.is_valid();\n+          if (!valid) {\n@@ -328,1 +330,0 @@\n-            return false;\n@@ -333,1 +334,2 @@\n-          if (!validator.is_valid()) {\n+          valid = validator.is_valid();\n+          if (!valid) {\n@@ -335,1 +337,0 @@\n-            return false;\n@@ -341,1 +342,4 @@\n-          if (!validator.is_valid()) {\n+          valid = validator.is_valid();\n+          if (valid) {\n+            set->set_ideal_phase_mask(mask);\n+          } else {\n@@ -343,1 +347,0 @@\n-            return false;\n@@ -345,1 +348,0 @@\n-          set->set_ideal_phase_mask(mask);\n@@ -347,0 +349,6 @@\n+\n+        if (!valid) {\n+          FREE_C_HEAP_ARRAY(char, s);\n+          return false;\n+        }\n+        (set->*test)((void *)&s);  \/\/ Takes ownership.\n","filename":"src\/hotspot\/share\/compiler\/directivesParser.cpp","additions":17,"deletions":9,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -194,1 +194,4 @@\n-  if (hr == nullptr) {\n+\n+  if (hr == nullptr || hr->free() < MinTLABSize) {\n+    \/\/ The next TLAB allocation will most probably happen in a new region,\n+    \/\/ therefore we can attempt to allocate the maximum allowed TLAB size.\n@@ -196,2 +199,0 @@\n-  } else {\n-    return clamp(hr->free(), MinTLABSize, max_tlab);\n@@ -199,0 +200,2 @@\n+\n+  return MIN2(hr->free(), max_tlab);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Allocator.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1697,3 +1697,6 @@\n-    CodeCache::UnloadingScope scope(&g1_is_alive);\n-    bool purged_classes = SystemDictionary::do_unloading(_gc_timer_cm);\n-    _g1h->complete_cleaning(purged_classes);\n+    {\n+      CodeCache::UnlinkingScope scope(&g1_is_alive);\n+      bool unloading_occurred = SystemDictionary::do_unloading(_gc_timer_cm);\n+      _g1h->complete_cleaning(unloading_occurred);\n+    }\n+    CodeCache::flush_unlinked_nmethods();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -322,4 +322,7 @@\n-    CodeCache::UnloadingScope unloading_scope(&_is_alive);\n-    \/\/ Unload classes and purge the SystemDictionary.\n-    bool purged_class = SystemDictionary::do_unloading(scope()->timer());\n-    _heap->complete_cleaning(purged_class);\n+    {\n+      CodeCache::UnlinkingScope unloading_scope(&_is_alive);\n+      \/\/ Unload classes and purge the SystemDictionary.\n+      bool unloading_occurred = SystemDictionary::do_unloading(scope()->timer());\n+      _heap->complete_cleaning(unloading_occurred);\n+    }\n+    CodeCache::flush_unlinked_nmethods();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -146,1 +146,1 @@\n-        after._survivor_length, usage._survivor_region_count);\n+           after._survivor_length, usage._survivor_region_count);\n@@ -148,1 +148,1 @@\n-        after._old_length, usage._old_region_count);\n+           after._old_length, usage._old_region_count);\n@@ -150,1 +150,1 @@\n-        after._humongous_length, usage._humongous_region_count);\n+           after._humongous_length, usage._humongous_region_count);\n@@ -160,1 +160,1 @@\n-      usage._survivor_used \/ K, ((after._survivor_length * HeapRegion::GrainBytes) - usage._survivor_used) \/ K);\n+                      usage._survivor_used \/ K, ((after._survivor_length * HeapRegion::GrainBytes) - usage._survivor_used) \/ K);\n@@ -165,1 +165,1 @@\n-      usage._old_used \/ K, ((after._old_length * HeapRegion::GrainBytes) - usage._old_used) \/ K);\n+                      usage._old_used \/ K, ((after._old_length * HeapRegion::GrainBytes) - usage._old_used) \/ K);\n@@ -170,1 +170,1 @@\n-      usage._humongous_used \/ K, ((after._humongous_length * HeapRegion::GrainBytes) - usage._humongous_used) \/ K);\n+                      usage._humongous_used \/ K, ((after._humongous_length * HeapRegion::GrainBytes) - usage._humongous_used) \/ K);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapTransition.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1102,1 +1102,1 @@\n-  size_t const expected_bytes = _eden_surv_rate_group->accum_surv_rate_pred(count) * HeapRegion::GrainBytes;\n+  size_t const expected_bytes = _eden_surv_rate_group->accum_surv_rate_pred(count - 1) * HeapRegion::GrainBytes;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -254,8 +254,0 @@\n-  \/\/ Check whether a given young length (young_length) fits into the\n-  \/\/ given target pause time and whether the prediction for the amount\n-  \/\/ of objects to be copied for the given length will fit into the\n-  \/\/ given free space (expressed by base_free_regions).  It is used by\n-  \/\/ calculate_young_list_target_length().\n-  bool predict_will_fit(uint young_length, double base_time_ms,\n-                        uint base_free_regions, double target_pause_time_ms) const;\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1189,1 +1189,0 @@\n-\n@@ -1196,10 +1195,5 @@\n-      r->rem_set()->clear(true \/* only_cardset *\/);\n-      \/\/ Clear_locked() above sets the state to Empty. However we want to continue\n-      \/\/ collecting remembered set entries for humongous regions that were not\n-      \/\/ reclaimed.\n-      r->rem_set()->set_state_complete();\n-#ifdef ASSERT\n-      G1HeapRegionAttr region_attr = g1h->region_attr(region_index);\n-      assert(region_attr.remset_is_tracked(), \"must be\");\n-#endif\n-      assert(r->rem_set()->is_empty(), \"At this point any humongous candidate remembered set must be empty.\");\n+      \/\/ We want to continue collecting remembered set entries for humongous regions\n+      \/\/ that were not reclaimed.\n+      r->rem_set()->clear(true \/* only_cardset *\/, true \/* keep_tracked *\/);\n+\n+      assert(r->rem_set()->is_empty() && r->rem_set()->is_complete(), \"must be for eager reclaim candidates\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.cpp","additions":5,"deletions":11,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -152,1 +152,0 @@\n-  void add_code_root_locked(nmethod* nm);\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionRemSet.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"utilities\/spinYield.hpp\"\n@@ -126,7 +127,7 @@\n-\/\/ postcondition: ret is a dirty card or end_card\n-CardTable::CardValue* PSCardTable::find_first_dirty_card(CardValue* const start_card,\n-                                                         CardValue* const end_card) {\n-  for (CardValue* i_card = start_card; i_card < end_card; ++i_card) {\n-    if (*i_card != PSCardTable::clean_card_val()) {\n-      return i_card;\n-    }\n+void PSCardTable::scan_obj_with_limit(PSPromotionManager* pm,\n+                                      oop obj,\n+                                      HeapWord* start,\n+                                      HeapWord* end) {\n+  if (!obj->is_typeArray()) {\n+    prefetch_write(start);\n+    pm->push_contents_bounded(obj, start, end);\n@@ -134,1 +135,0 @@\n-  return end_card;\n@@ -137,24 +137,57 @@\n-\/\/ postcondition: ret is a clean card or end_card\n-\/\/ Note: if a part of an object is on a dirty card, all cards this object\n-\/\/ resides on are considered dirty.\n-CardTable::CardValue* PSCardTable::find_first_clean_card(ObjectStartArray* const start_array,\n-                                                         CardValue* const start_card,\n-                                                         CardValue* const end_card) {\n-  assert(start_card == end_card ||\n-         *start_card != PSCardTable::clean_card_val(), \"precondition\");\n-  \/\/ Skip the first dirty card.\n-  CardValue* i_card = start_card + 1;\n-  while (i_card < end_card) {\n-    if (*i_card != PSCardTable::clean_card_val()) {\n-      i_card++;\n-      continue;\n-    }\n-    assert(i_card - 1 >= start_card, \"inv\");\n-    assert(*(i_card - 1) != PSCardTable::clean_card_val(), \"prev card must be dirty\");\n-    \/\/ Find the final obj on the prev dirty card.\n-    HeapWord* obj_addr = start_array->object_start(addr_for(i_card)-1);\n-    HeapWord* obj_end_addr = obj_addr + cast_to_oop(obj_addr)->size();\n-    CardValue* final_card_by_obj = byte_for(obj_end_addr - 1);\n-    assert(final_card_by_obj < end_card, \"inv\");\n-    if (final_card_by_obj <= i_card) {\n-      return i_card;\n+void PSCardTable::pre_scavenge(HeapWord* old_gen_bottom, uint active_workers) {\n+  _preprocessing_active_workers = active_workers;\n+}\n+\n+\/\/ The \"shadow\" table is a copy of the card table entries of the current stripe.\n+\/\/ It is used to separate card reading, clearing and redirtying which reduces\n+\/\/ complexity significantly.\n+class PSStripeShadowCardTable {\n+  typedef CardTable::CardValue CardValue;\n+\n+  const uint _card_shift;\n+  const uint _card_size;\n+  CardValue _table[PSCardTable::num_cards_in_stripe];\n+  const CardValue* _table_base;\n+\n+public:\n+  PSStripeShadowCardTable(PSCardTable* pst, HeapWord* const start, HeapWord* const end) :\n+    _card_shift(CardTable::card_shift()),\n+    _card_size(CardTable::card_size()),\n+    _table_base(_table - (uintptr_t(start) >> _card_shift)) {\n+    size_t stripe_byte_size = pointer_delta(end, start) * HeapWordSize;\n+    size_t copy_length = align_up(stripe_byte_size, _card_size) >> _card_shift;\n+    \/\/ The end of the last stripe may not be card aligned as it is equal to old\n+    \/\/ gen top at scavenge start. We should not clear the card containing old gen\n+    \/\/ top if not card aligned because there can be promoted objects on that\n+    \/\/ same card. If it was marked dirty because of the promoted objects and we\n+    \/\/ cleared it, we would loose a card mark.\n+    size_t clear_length = align_down(stripe_byte_size, _card_size) >> _card_shift;\n+    CardValue* stripe_start_card = pst->byte_for(start);\n+    memcpy(_table, stripe_start_card, copy_length);\n+    memset(stripe_start_card, CardTable::clean_card_val(), clear_length);\n+  }\n+\n+  HeapWord* addr_for(const CardValue* const card) {\n+    assert(card >= _table && card <=  &_table[PSCardTable::num_cards_in_stripe], \"out of bounds\");\n+    return (HeapWord*) ((card - _table_base) << _card_shift);\n+  }\n+\n+  const CardValue* card_for(HeapWord* addr) {\n+    return &_table_base[uintptr_t(addr) >> _card_shift];\n+  }\n+\n+  bool is_dirty(const CardValue* const card) {\n+    return !is_clean(card);\n+  }\n+\n+  bool is_clean(const CardValue* const card) {\n+    assert(card >= _table && card <  &_table[PSCardTable::num_cards_in_stripe], \"out of bounds\");\n+    return *card == PSCardTable::clean_card_val();\n+  }\n+\n+  const CardValue* find_first_dirty_card(const CardValue* const start,\n+                                         const CardValue* const end) {\n+    for (const CardValue* i = start; i < end; ++i) {\n+      if (is_dirty(i)) {\n+        return i;\n+      }\n@@ -162,3 +195,9 @@\n-    \/\/ This final obj extends beyond i_card, check if this new card is dirty.\n-    if (*final_card_by_obj == PSCardTable::clean_card_val()) {\n-      return final_card_by_obj;\n+    return end;\n+  }\n+\n+  const CardValue* find_first_clean_card(const CardValue* const start,\n+                                         const CardValue* const end) {\n+    for (const CardValue* i = start; i < end; ++i) {\n+      if (is_clean(i)) {\n+        return i;\n+      }\n@@ -166,2 +205,1 @@\n-    \/\/ This new card is dirty, continuing the search...\n-    i_card = final_card_by_obj + 1;\n+    return end;\n@@ -169,2 +207,14 @@\n-  return end_card;\n-}\n+};\n+\n+template <typename Func>\n+void PSCardTable::process_range(Func&& object_start,\n+                                PSPromotionManager* pm,\n+                                HeapWord* const start,\n+                                HeapWord* const end) {\n+  assert(start < end, \"precondition\");\n+  assert(is_card_aligned(start), \"precondition\");\n+\n+  PSStripeShadowCardTable sct(this, start, end);\n+\n+  \/\/ end might not be card-aligned.\n+  const CardValue* end_card = sct.card_for(end - 1) + 1;\n@@ -172,3 +222,49 @@\n-void PSCardTable::clear_cards(CardValue* const start, CardValue* const end) {\n-  for (CardValue* i_card = start; i_card < end; ++i_card) {\n-    *i_card = clean_card;\n+  for (HeapWord* i_addr = start; i_addr < end; \/* empty *\/) {\n+    const CardValue* dirty_l = sct.find_first_dirty_card(sct.card_for(i_addr), end_card);\n+    const CardValue* dirty_r = sct.find_first_clean_card(dirty_l, end_card);\n+\n+    assert(dirty_l <= dirty_r, \"inv\");\n+\n+    if (dirty_l == dirty_r) {\n+      assert(dirty_r == end_card, \"inv\");\n+      break;\n+    }\n+\n+    \/\/ Located a non-empty dirty chunk [dirty_l, dirty_r).\n+    HeapWord* addr_l = sct.addr_for(dirty_l);\n+    HeapWord* addr_r = MIN2(sct.addr_for(dirty_r), end);\n+\n+    \/\/ Scan objects overlapping [addr_l, addr_r) limited to [start, end).\n+    HeapWord* obj_addr = object_start(addr_l);\n+\n+    while (true) {\n+      assert(obj_addr < addr_r, \"inv\");\n+\n+      oop obj = cast_to_oop(obj_addr);\n+      const bool is_obj_array = obj->is_objArray();\n+      HeapWord* const obj_end_addr = obj_addr + obj->size();\n+\n+      if (is_obj_array) {\n+        \/\/ Always scan obj arrays precisely (they are always marked precisely)\n+        \/\/ to avoid unnecessary work.\n+        scan_obj_with_limit(pm, obj, addr_l, addr_r);\n+      } else {\n+        if (obj_addr < i_addr && i_addr > start) {\n+          \/\/ Already scanned this object. Has been one that spans multiple dirty chunks.\n+          \/\/ The second condition makes sure objects reaching in the stripe are scanned once.\n+        } else {\n+          scan_obj_with_limit(pm, obj, addr_l, end);\n+        }\n+      }\n+\n+      if (obj_end_addr >= addr_r) {\n+        i_addr = is_obj_array ? addr_r : obj_end_addr;\n+        break;\n+      }\n+\n+      \/\/ Move to next obj inside this dirty chunk.\n+      obj_addr = obj_end_addr;\n+    }\n+\n+    \/\/ Finished a dirty chunk.\n+    pm->drain_stacks_cond_depth();\n@@ -178,10 +274,30 @@\n-void PSCardTable::scan_objects_in_range(PSPromotionManager* pm,\n-                                        HeapWord* start,\n-                                        HeapWord* end) {\n-  HeapWord* obj_addr = start;\n-  while (obj_addr < end) {\n-    oop obj = cast_to_oop(obj_addr);\n-    assert(oopDesc::is_oop(obj), \"inv\");\n-    prefetch_write(obj_addr);\n-    pm->push_contents(obj);\n-    obj_addr += obj->size();\n+template <typename Func>\n+void PSCardTable::preprocess_card_table_parallel(Func&& object_start,\n+                                                 HeapWord* old_gen_bottom,\n+                                                 HeapWord* old_gen_top,\n+                                                 uint stripe_index,\n+                                                 uint n_stripes) {\n+  const size_t num_cards_in_slice = num_cards_in_stripe * n_stripes;\n+  CardValue* cur_card = byte_for(old_gen_bottom) + stripe_index * num_cards_in_stripe;\n+  CardValue* const end_card = byte_for(old_gen_top - 1) + 1;\n+\n+  for (\/* empty *\/; cur_card < end_card; cur_card += num_cards_in_slice) {\n+    HeapWord* stripe_addr = addr_for(cur_card);\n+    if (is_dirty(cur_card)) {\n+      \/\/ The first card of this stripe is already dirty, no need to see if the\n+      \/\/ reaching-in object is a potentially imprecisely marked non-array\n+      \/\/ object.\n+      continue;\n+    }\n+    HeapWord* first_obj_addr = object_start(stripe_addr);\n+    if (first_obj_addr == stripe_addr) {\n+      \/\/ No object reaching into this stripe.\n+      continue;\n+    }\n+    oop first_obj = cast_to_oop(first_obj_addr);\n+    if (!first_obj->is_array() && is_dirty(byte_for(first_obj_addr))) {\n+      \/\/ Found a non-array object reaching into the stripe that has\n+      \/\/ potentially been marked imprecisely. Mark first card of the stripe\n+      \/\/ dirty so it will be processed later.\n+      *cur_card = dirty_card_val();\n+    }\n@@ -189,1 +305,0 @@\n-  pm->drain_stacks_cond_depth();\n@@ -230,0 +345,8 @@\n+\/\/ Scavenging and accesses to the card table are strictly limited to the stripe.\n+\/\/ In particular scavenging of an object crossing stripe boundaries is shared\n+\/\/ among the threads assigned to the stripes it resides on. This reduces\n+\/\/ complexity and enables shared scanning of large objects.\n+\/\/ It requires preprocessing of the card table though where imprecise card marks of\n+\/\/ objects crossing stripe boundaries are propagated to the first card of\n+\/\/ each stripe covered by the individual object.\n+\n@@ -231,2 +354,2 @@\n-                                             MutableSpace* sp,\n-                                             HeapWord* space_top,\n+                                             HeapWord* old_gen_bottom,\n+                                             HeapWord* old_gen_top,\n@@ -236,14 +359,11 @@\n-  const size_t num_cards_in_stripe = 128;\n-  const size_t stripe_size_in_words = num_cards_in_stripe * _card_size_in_words;\n-  const size_t slice_size_in_words = stripe_size_in_words * n_stripes;\n-\n-  HeapWord* cur_stripe_addr = sp->bottom() + stripe_index * stripe_size_in_words;\n-\n-  for (\/* empty *\/; cur_stripe_addr < space_top; cur_stripe_addr += slice_size_in_words) {\n-    \/\/ exclusive\n-    HeapWord* const cur_stripe_end_addr = MIN2(cur_stripe_addr + stripe_size_in_words,\n-                                               space_top);\n-\n-    \/\/ Process a stripe iff it contains any obj-start\n-    if (!start_array->object_starts_in_range(cur_stripe_addr, cur_stripe_end_addr)) {\n-      continue;\n+  \/\/ ObjectStartArray queries can be expensive for large objects. We cache known objects.\n+  struct {\n+    HeapWord* start_addr;\n+    HeapWord* end_addr;\n+  } cached_obj {nullptr, old_gen_bottom};\n+\n+  \/\/ Queries must be monotonic because we don't check addr >= cached_obj.start_addr.\n+  auto object_start = [&] (HeapWord* addr) {\n+    if (addr < cached_obj.end_addr) {\n+      assert(cached_obj.start_addr != nullptr, \"inv\");\n+      return cached_obj.start_addr;\n@@ -251,0 +371,1 @@\n+    HeapWord* result = start_array->object_start(addr);\n@@ -252,21 +373,2 @@\n-    \/\/ Constraints:\n-    \/\/ 1. range of cards checked for being dirty or clean: [iter_limit_l, iter_limit_r)\n-    \/\/ 2. range of cards can be cleared: [clear_limit_l, clear_limit_r)\n-    \/\/ 3. range of objs (obj-start) can be scanned: [first_obj_addr, cur_stripe_end_addr)\n-\n-    CardValue* iter_limit_l;\n-    CardValue* iter_limit_r;\n-    CardValue* clear_limit_l;\n-    CardValue* clear_limit_r;\n-\n-    \/\/ Identify left ends and the first obj-start inside this stripe.\n-    HeapWord* first_obj_addr = start_array->object_start(cur_stripe_addr);\n-    if (first_obj_addr < cur_stripe_addr) {\n-      \/\/ this obj belongs to previous stripe; can't clear any cards it occupies\n-      first_obj_addr += cast_to_oop(first_obj_addr)->size();\n-      clear_limit_l = byte_for(first_obj_addr - 1) + 1;\n-      iter_limit_l = byte_for(first_obj_addr);\n-    } else {\n-      assert(first_obj_addr == cur_stripe_addr, \"inv\");\n-      iter_limit_l = clear_limit_l = byte_for(cur_stripe_addr);\n-    }\n+    cached_obj.start_addr = result;\n+    cached_obj.end_addr = result + cast_to_oop(result)->size();\n@@ -274,2 +376,2 @@\n-    assert(cur_stripe_addr <= first_obj_addr, \"inside this stripe\");\n-    assert(first_obj_addr <= cur_stripe_end_addr, \"can be empty\");\n+    return result;\n+  };\n@@ -277,31 +379,2 @@\n-    {\n-      \/\/ Identify right ends.\n-      HeapWord* obj_addr = start_array->object_start(cur_stripe_end_addr - 1);\n-      HeapWord* obj_end_addr = obj_addr + cast_to_oop(obj_addr)->size();\n-      assert(obj_end_addr >= cur_stripe_end_addr, \"inv\");\n-      clear_limit_r = byte_for(obj_end_addr);\n-      iter_limit_r = byte_for(obj_end_addr - 1) + 1;\n-    }\n-\n-    assert(iter_limit_l <= clear_limit_l &&\n-           clear_limit_r <= iter_limit_r, \"clear cards only if we iterate over them\");\n-\n-    \/\/ Process dirty chunks, i.e. consecutive dirty cards [dirty_l, dirty_r),\n-    \/\/ chunk by chunk inside [iter_limit_l, iter_limit_r).\n-    CardValue* dirty_l;\n-    CardValue* dirty_r;\n-\n-    for (CardValue* cur_card = iter_limit_l; cur_card < iter_limit_r; cur_card = dirty_r + 1) {\n-      dirty_l = find_first_dirty_card(cur_card, iter_limit_r);\n-      dirty_r = find_first_clean_card(start_array, dirty_l, iter_limit_r);\n-      assert(dirty_l <= dirty_r, \"inv\");\n-\n-      \/\/ empty\n-      if (dirty_l == dirty_r) {\n-        assert(dirty_r == iter_limit_r, \"no more dirty cards in this stripe\");\n-        break;\n-      }\n-\n-      assert(*dirty_l != clean_card, \"inv\");\n-      assert(*dirty_r == clean_card || dirty_r >= clear_limit_r,\n-             \"clean card or belonging to next stripe\");\n+  \/\/ Prepare scavenge.\n+  preprocess_card_table_parallel(object_start, old_gen_bottom, old_gen_top, stripe_index, n_stripes);\n@@ -309,11 +382,6 @@\n-      \/\/ Process this non-empty dirty chunk in two steps:\n-      {\n-        \/\/ 1. Clear card in [dirty_l, dirty_r) subject to [clear_limit_l, clear_limit_r) constraint\n-        clear_cards(MAX2(dirty_l, clear_limit_l),\n-                    MIN2(dirty_r, clear_limit_r));\n-      }\n-\n-      {\n-        \/\/ 2. Scan objs in [dirty_l, dirty_r) subject to [first_obj_addr, cur_stripe_end_addr) constraint\n-        HeapWord* obj_l = MAX2(start_array->object_start(addr_for(dirty_l)),\n-                               first_obj_addr);\n+  \/\/ Sync with other workers.\n+  Atomic::dec(&_preprocessing_active_workers);\n+  SpinYield spin_yield;\n+  while (Atomic::load_acquire(&_preprocessing_active_workers) > 0) {\n+    spin_yield.wait();\n+  }\n@@ -321,2 +389,9 @@\n-        HeapWord* obj_r = MIN2(addr_for(dirty_r),\n-                               cur_stripe_end_addr);\n+  \/\/ Scavenge\n+  cached_obj = {nullptr, old_gen_bottom};\n+  const size_t stripe_size_in_words = num_cards_in_stripe * _card_size_in_words;\n+  const size_t slice_size_in_words = stripe_size_in_words * n_stripes;\n+  HeapWord* cur_addr = old_gen_bottom + stripe_index * stripe_size_in_words;\n+  for (\/* empty *\/; cur_addr < old_gen_top; cur_addr += slice_size_in_words) {\n+    HeapWord* const stripe_l = cur_addr;\n+    HeapWord* const stripe_r = MIN2(cur_addr + stripe_size_in_words,\n+                                    old_gen_top);\n@@ -324,3 +399,1 @@\n-        scan_objects_in_range(pm, obj_l, obj_r);\n-      }\n-    }\n+    process_range(object_start, pm, stripe_l, stripe_r);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCardTable.cpp","additions":212,"deletions":139,"binary":false,"changes":351,"status":"modified"},{"patch":"@@ -36,1 +36,29 @@\n- private:\n+  friend class PSStripeShadowCardTable;\n+  static constexpr size_t num_cards_in_stripe = 128;\n+  static_assert(num_cards_in_stripe >= 1, \"progress\");\n+\n+  volatile int _preprocessing_active_workers;\n+\n+  bool is_dirty(CardValue* card) {\n+    return !is_clean(card);\n+  }\n+\n+  bool is_clean(CardValue* card) {\n+    return *card == clean_card_val();\n+  }\n+\n+  \/\/ Iterate the stripes with the given index and copy imprecise card marks of\n+  \/\/ objects reaching into a stripe to its first card.\n+  template <typename Func>\n+  void preprocess_card_table_parallel(Func&& object_start,\n+                                      HeapWord* old_gen_bottom,\n+                                      HeapWord* old_gen_top,\n+                                      uint stripe_index,\n+                                      uint n_stripes);\n+\n+  \/\/ Scavenge contents on dirty cards of the given stripe [start, end).\n+  template <typename Func>\n+  void process_range(Func&& object_start,\n+                     PSPromotionManager* pm,\n+                     HeapWord* const start,\n+                     HeapWord* const end);\n@@ -45,12 +73,4 @@\n-  CardValue* find_first_dirty_card(CardValue* const start_card,\n-                                   CardValue* const end_card);\n-\n-  CardValue* find_first_clean_card(ObjectStartArray* start_array,\n-                                   CardValue* const start_card,\n-                                   CardValue* const end_card);\n-\n-  void clear_cards(CardValue* const start, CardValue* const end);\n-\n-  void scan_objects_in_range(PSPromotionManager* pm,\n-                             HeapWord* start,\n-                             HeapWord* end);\n+  void scan_obj_with_limit(PSPromotionManager* pm,\n+                           oop obj,\n+                           HeapWord* start,\n+                           HeapWord* end);\n@@ -59,1 +79,2 @@\n-  PSCardTable(MemRegion whole_heap) : CardTable(whole_heap) {}\n+  PSCardTable(MemRegion whole_heap) : CardTable(whole_heap),\n+                                      _preprocessing_active_workers(0) {}\n@@ -65,0 +86,2 @@\n+  void pre_scavenge(HeapWord* old_gen_bottom, uint active_workers);\n+  \/\/ Scavenge contents of stripes with the given index.\n@@ -66,2 +89,2 @@\n-                                  MutableSpace* sp,\n-                                  HeapWord* space_top,\n+                                  HeapWord* old_gen_bottom,\n+                                  HeapWord* old_gen_top,\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCardTable.hpp","additions":39,"deletions":16,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -2055,1 +2055,0 @@\n-    CodeCache::UnloadingScope scope(is_alive_closure());\n@@ -2057,2 +2056,10 @@\n-    \/\/ Follow system dictionary roots and unload classes.\n-    bool purged_class = SystemDictionary::do_unloading(&_gc_timer);\n+    bool unloading_occurred;\n+    {\n+      CodeCache::UnlinkingScope scope(is_alive_closure());\n+\n+      \/\/ Follow system dictionary roots and unload classes.\n+      unloading_occurred = SystemDictionary::do_unloading(&_gc_timer);\n+\n+      \/\/ Unload nmethods.\n+      CodeCache::do_unloading(unloading_occurred);\n+    }\n@@ -2060,2 +2067,2 @@\n-    \/\/ Unload nmethods.\n-    CodeCache::do_unloading(purged_class);\n+    \/\/ Release unloaded nmethods's memory.\n+    CodeCache::flush_unlinked_nmethods();\n@@ -2064,1 +2071,1 @@\n-    Klass::clean_weak_klass_links(purged_class);\n+    Klass::clean_weak_klass_links(unloading_occurred);\n@@ -2067,1 +2074,1 @@\n-    JVMCI_ONLY(JVMCI::do_unloading(purged_class));\n+    JVMCI_ONLY(JVMCI::do_unloading(unloading_occurred));\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":14,"deletions":7,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -180,0 +180,1 @@\n+  void push_contents_bounded(oop obj, HeapWord* left, HeapWord* right);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -134,0 +134,5 @@\n+inline void PSPromotionManager::push_contents_bounded(oop obj, HeapWord* left, HeapWord* right) {\n+  PSPushContentsClosure pcc(this);\n+  obj->oop_iterate(&pcc, MemRegion(left, right));\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.inline.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -90,1 +90,0 @@\n-  PSScavengeRootsClosure roots_closure(pm);\n@@ -304,0 +303,5 @@\n+\n+    if (!_is_old_gen_empty) {\n+      PSCardTable* card_table = ParallelScavengeHeap::heap()->card_table();\n+      card_table->pre_scavenge(_old_gen->object_space()->bottom(), active_workers);\n+    }\n@@ -317,0 +321,1 @@\n+        \/\/ The top of the old gen changes during scavenge when objects are promoted.\n@@ -318,1 +323,1 @@\n-                                               _old_gen->object_space(),\n+                                               _old_gen->object_space()->bottom(),\n","filename":"src\/hotspot\/share\/gc\/parallel\/psScavenge.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/serial\/generation.hpp\"\n@@ -29,1 +30,0 @@\n-#include \"gc\/shared\/generation.hpp\"\n@@ -109,2 +109,0 @@\n-      assert(_sp->block_size(top_obj) == cast_to_oop(top_obj)->size(),\n-             \"Block size and object size mismatch\");\n","filename":"src\/hotspot\/share\/gc\/serial\/cardTableRS.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/serial\/generation.hpp\"\n@@ -32,1 +33,0 @@\n-#include \"gc\/shared\/generation.hpp\"\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"gc\/serial\/generation.hpp\"\n@@ -45,1 +46,0 @@\n-#include \"gc\/shared\/generation.hpp\"\n@@ -202,1 +202,0 @@\n-    CodeCache::UnloadingScope scope(&is_alive);\n@@ -204,2 +203,3 @@\n-    \/\/ Unload classes and purge the SystemDictionary.\n-    bool purged_class = SystemDictionary::do_unloading(gc_timer());\n+    bool unloading_occurred;\n+    {\n+      CodeCache::UnlinkingScope scope(&is_alive);\n@@ -207,2 +207,9 @@\n-    \/\/ Unload nmethods.\n-    CodeCache::do_unloading(purged_class);\n+      \/\/ Unload classes and purge the SystemDictionary.\n+      unloading_occurred = SystemDictionary::do_unloading(gc_timer());\n+\n+      \/\/ Unload nmethods.\n+      CodeCache::do_unloading(unloading_occurred);\n+    }\n+\n+    \/\/ Release unloaded nmethod's memory.\n+    CodeCache::flush_unlinked_nmethods();\n@@ -211,1 +218,1 @@\n-    Klass::clean_weak_klass_links(purged_class);\n+    Klass::clean_weak_klass_links(unloading_occurred);\n@@ -214,1 +221,1 @@\n-    JVMCI_ONLY(JVMCI::do_unloading(purged_class));\n+    JVMCI_ONLY(JVMCI::do_unloading(unloading_occurred));\n","filename":"src\/hotspot\/share\/gc\/serial\/genMarkSweep.cpp","additions":15,"deletions":8,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -0,0 +1,260 @@\n+\/*\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/serial\/cardTableRS.hpp\"\n+#include \"gc\/serial\/generation.hpp\"\n+#include \"gc\/serial\/serialHeap.hpp\"\n+#include \"gc\/shared\/collectedHeap.inline.hpp\"\n+#include \"gc\/shared\/continuationGCSupport.inline.hpp\"\n+#include \"gc\/shared\/gcLocker.hpp\"\n+#include \"gc\/shared\/gcTimer.hpp\"\n+#include \"gc\/shared\/gcTrace.hpp\"\n+#include \"gc\/shared\/generationSpec.hpp\"\n+#include \"gc\/shared\/space.inline.hpp\"\n+#include \"gc\/shared\/spaceDecorator.inline.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"memory\/allocation.inline.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n+#include \"runtime\/java.hpp\"\n+#include \"utilities\/copy.hpp\"\n+#include \"utilities\/events.hpp\"\n+\n+Generation::Generation(ReservedSpace rs, size_t initial_size) :\n+  _gc_manager(nullptr) {\n+  if (!_virtual_space.initialize(rs, initial_size)) {\n+    vm_exit_during_initialization(\"Could not reserve enough space for \"\n+                    \"object heap\");\n+  }\n+  \/\/ Mangle all of the initial generation.\n+  if (ZapUnusedHeapArea) {\n+    MemRegion mangle_region((HeapWord*)_virtual_space.low(),\n+      (HeapWord*)_virtual_space.high());\n+    SpaceMangler::mangle_region(mangle_region);\n+  }\n+  _reserved = MemRegion((HeapWord*)_virtual_space.low_boundary(),\n+          (HeapWord*)_virtual_space.high_boundary());\n+}\n+\n+size_t Generation::initial_size() {\n+  SerialHeap* serial_heap = SerialHeap::heap();\n+  if (serial_heap->is_young_gen(this)) {\n+    return serial_heap->young_gen_spec()->init_size();\n+  }\n+  return serial_heap->old_gen_spec()->init_size();\n+}\n+\n+size_t Generation::max_capacity() const {\n+  return reserved().byte_size();\n+}\n+\n+void Generation::print() const { print_on(tty); }\n+\n+void Generation::print_on(outputStream* st)  const {\n+  st->print(\" %-20s\", name());\n+  st->print(\" total \" SIZE_FORMAT \"K, used \" SIZE_FORMAT \"K\",\n+             capacity()\/K, used()\/K);\n+  st->print_cr(\" [\" PTR_FORMAT \", \" PTR_FORMAT \", \" PTR_FORMAT \")\",\n+              p2i(_virtual_space.low_boundary()),\n+              p2i(_virtual_space.high()),\n+              p2i(_virtual_space.high_boundary()));\n+}\n+\n+void Generation::print_summary_info_on(outputStream* st) {\n+  StatRecord* sr = stat_record();\n+  double time = sr->accumulated_time.seconds();\n+  st->print_cr(\"Accumulated %s generation GC time %3.7f secs, \"\n+               \"%u GC's, avg GC time %3.7f\",\n+               SerialHeap::heap()->is_young_gen(this) ? \"young\" : \"old\" ,\n+               time,\n+               sr->invocations,\n+               sr->invocations > 0 ? time \/ sr->invocations : 0.0);\n+}\n+\n+\/\/ Utility iterator classes\n+\n+class GenerationIsInClosure : public SpaceClosure {\n+ public:\n+  const void* _p;\n+  Space* sp;\n+  virtual void do_space(Space* s) {\n+    if (sp == nullptr) {\n+      if (s->is_in(_p)) sp = s;\n+    }\n+  }\n+  GenerationIsInClosure(const void* p) : _p(p), sp(nullptr) {}\n+};\n+\n+bool Generation::is_in(const void* p) const {\n+  GenerationIsInClosure blk(p);\n+  ((Generation*)this)->space_iterate(&blk);\n+  return blk.sp != nullptr;\n+}\n+\n+size_t Generation::max_contiguous_available() const {\n+  \/\/ The largest number of contiguous free words in this or any higher generation.\n+  size_t avail = contiguous_available();\n+  size_t old_avail = 0;\n+  if (SerialHeap::heap()->is_young_gen(this)) {\n+    old_avail = SerialHeap::heap()->old_gen()->contiguous_available();\n+  }\n+  return MAX2(avail, old_avail);\n+}\n+\n+bool Generation::promotion_attempt_is_safe(size_t max_promotion_in_bytes) const {\n+  size_t available = max_contiguous_available();\n+  bool   res = (available >= max_promotion_in_bytes);\n+  log_trace(gc)(\"Generation: promo attempt is%s safe: available(\" SIZE_FORMAT \") %s max_promo(\" SIZE_FORMAT \")\",\n+                res? \"\":\" not\", available, res? \">=\":\"<\", max_promotion_in_bytes);\n+  return res;\n+}\n+\n+\/\/ Ignores \"ref\" and calls allocate().\n+oop Generation::promote(oop obj, size_t obj_size) {\n+  assert(obj_size == obj->size(), \"bad obj_size passed in\");\n+\n+#ifndef PRODUCT\n+  if (SerialHeap::heap()->promotion_should_fail()) {\n+    return nullptr;\n+  }\n+#endif  \/\/ #ifndef PRODUCT\n+\n+  \/\/ Allocate new object.\n+  HeapWord* result = allocate(obj_size, false);\n+  if (result == nullptr) {\n+    \/\/ Promotion of obj into gen failed.  Try to expand and allocate.\n+    result = expand_and_allocate(obj_size, false);\n+    if (result == nullptr) {\n+      return nullptr;\n+    }\n+  }\n+\n+  \/\/ Copy to new location.\n+  Copy::aligned_disjoint_words(cast_from_oop<HeapWord*>(obj), result, obj_size);\n+  oop new_obj = cast_to_oop<HeapWord*>(result);\n+\n+  \/\/ Transform object if it is a stack chunk.\n+  ContinuationGCSupport::transform_stack_chunk(new_obj);\n+\n+  return new_obj;\n+}\n+\n+\/\/ Some of these are mediocre general implementations.  Should be\n+\/\/ overridden to get better performance.\n+\n+class GenerationBlockStartClosure : public SpaceClosure {\n+ public:\n+  const void* _p;\n+  HeapWord* _start;\n+  virtual void do_space(Space* s) {\n+    if (_start == nullptr && s->is_in_reserved(_p)) {\n+      _start = s->block_start(_p);\n+    }\n+  }\n+  GenerationBlockStartClosure(const void* p) { _p = p; _start = nullptr; }\n+};\n+\n+HeapWord* Generation::block_start(const void* p) const {\n+  GenerationBlockStartClosure blk(p);\n+  \/\/ Cast away const\n+  ((Generation*)this)->space_iterate(&blk);\n+  return blk._start;\n+}\n+\n+class GenerationBlockSizeClosure : public SpaceClosure {\n+ public:\n+  const HeapWord* _p;\n+  size_t size;\n+  virtual void do_space(Space* s) {\n+    if (size == 0 && s->is_in_reserved(_p)) {\n+      size = s->block_size(_p);\n+    }\n+  }\n+  GenerationBlockSizeClosure(const HeapWord* p) { _p = p; size = 0; }\n+};\n+\n+class GenerationBlockIsObjClosure : public SpaceClosure {\n+ public:\n+  const HeapWord* _p;\n+  bool is_obj;\n+  virtual void do_space(Space* s) {\n+    if (!is_obj && s->is_in_reserved(_p)) {\n+      is_obj |= s->block_is_obj(_p);\n+    }\n+  }\n+  GenerationBlockIsObjClosure(const HeapWord* p) { _p = p; is_obj = false; }\n+};\n+\n+bool Generation::block_is_obj(const HeapWord* p) const {\n+  GenerationBlockIsObjClosure blk(p);\n+  \/\/ Cast away const\n+  ((Generation*)this)->space_iterate(&blk);\n+  return blk.is_obj;\n+}\n+\n+class GenerationObjIterateClosure : public SpaceClosure {\n+ private:\n+  ObjectClosure* _cl;\n+ public:\n+  virtual void do_space(Space* s) {\n+    s->object_iterate(_cl);\n+  }\n+  GenerationObjIterateClosure(ObjectClosure* cl) : _cl(cl) {}\n+};\n+\n+void Generation::object_iterate(ObjectClosure* cl) {\n+  GenerationObjIterateClosure blk(cl);\n+  space_iterate(&blk);\n+}\n+\n+void Generation::prepare_for_compaction(CompactPoint* cp) {\n+  \/\/ Generic implementation, can be specialized\n+  ContiguousSpace* space = first_compaction_space();\n+  while (space != nullptr) {\n+    space->prepare_for_compaction(cp);\n+    space = space->next_compaction_space();\n+  }\n+}\n+\n+class AdjustPointersClosure: public SpaceClosure {\n+ public:\n+  void do_space(Space* sp) {\n+    sp->adjust_pointers();\n+  }\n+};\n+\n+void Generation::adjust_pointers() {\n+  \/\/ Note that this is done over all spaces, not just the compactible\n+  \/\/ ones.\n+  AdjustPointersClosure blk;\n+  space_iterate(&blk, true);\n+}\n+\n+void Generation::compact() {\n+  ContiguousSpace* sp = first_compaction_space();\n+  while (sp != nullptr) {\n+    sp->compact();\n+    sp = sp->next_compaction_space();\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/serial\/generation.cpp","additions":260,"deletions":0,"binary":false,"changes":260,"status":"added"},{"patch":"@@ -57,1 +57,0 @@\n-class GenCollectedHeap;\n@@ -293,1 +292,0 @@\n-#if INCLUDE_SERIALGC\n@@ -300,1 +298,0 @@\n-#endif\n@@ -337,5 +334,0 @@\n-  \/\/ Requires \"addr\" to be the start of a chunk, and returns its size.\n-  \/\/ \"addr + size\" is required to be the start of a new chunk, or the end\n-  \/\/ of the active area of the heap.\n-  virtual size_t block_size(const HeapWord* addr) const ;\n-\n@@ -380,1 +372,1 @@\n-#endif \/\/ SHARE_GC_SHARED_GENERATION_HPP\n+#endif \/\/ SHARE_GC_SERIAL_GENERATION_HPP\n","filename":"src\/hotspot\/share\/gc\/serial\/generation.hpp","additions":1,"deletions":9,"binary":false,"changes":10,"previous_filename":"src\/hotspot\/share\/gc\/shared\/generation.hpp","status":"renamed"},{"patch":"@@ -480,1 +480,1 @@\n-    size_t word_size = _the_space->block_size(start);\n+    size_t word_size = cast_to_oop(start)->size();;\n","filename":"src\/hotspot\/share\/gc\/serial\/tenuredGeneration.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"gc\/shared\/generation.hpp\"\n+#include \"gc\/serial\/generation.hpp\"\n@@ -136,2 +136,0 @@\n-  inline size_t block_size(const HeapWord* addr) const;\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/tenuredGeneration.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -68,9 +68,0 @@\n-size_t TenuredGeneration::block_size(const HeapWord* addr) const {\n-  if (addr < _the_space->top()) {\n-    return cast_to_oop(addr)->size();\n-  } else {\n-    assert(addr == _the_space->top(), \"non-block head arg to block_size\");\n-    return _the_space->end() - _the_space->top();\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/tenuredGeneration.inline.hpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -458,1 +459,1 @@\n-  if (DumpSharedSpaces) {\n+  if (CDSConfig::is_dumping_heap()) {\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"gc\/serial\/generation.hpp\"\n@@ -28,1 +29,0 @@\n-#include \"gc\/shared\/generation.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/genArguments.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/serial\/generation.hpp\"\n@@ -29,1 +30,0 @@\n-#include \"gc\/shared\/generation.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/genCollectedHeap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-#include \"gc\/shared\/generation.hpp\"\n+#include \"gc\/serial\/generation.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/genMemoryPools.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,284 +0,0 @@\n-\/*\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"gc\/serial\/cardTableRS.hpp\"\n-#include \"gc\/shared\/collectedHeap.inline.hpp\"\n-#include \"gc\/shared\/continuationGCSupport.inline.hpp\"\n-#include \"gc\/shared\/gcLocker.hpp\"\n-#include \"gc\/shared\/gcTimer.hpp\"\n-#include \"gc\/shared\/gcTrace.hpp\"\n-#include \"gc\/shared\/genCollectedHeap.hpp\"\n-#include \"gc\/shared\/generation.hpp\"\n-#include \"gc\/shared\/generationSpec.hpp\"\n-#include \"gc\/shared\/space.inline.hpp\"\n-#include \"gc\/shared\/spaceDecorator.inline.hpp\"\n-#include \"logging\/log.hpp\"\n-#include \"memory\/allocation.inline.hpp\"\n-#include \"oops\/oop.inline.hpp\"\n-#include \"runtime\/java.hpp\"\n-#include \"utilities\/copy.hpp\"\n-#include \"utilities\/events.hpp\"\n-\n-Generation::Generation(ReservedSpace rs, size_t initial_size) :\n-  _gc_manager(nullptr) {\n-  if (!_virtual_space.initialize(rs, initial_size)) {\n-    vm_exit_during_initialization(\"Could not reserve enough space for \"\n-                    \"object heap\");\n-  }\n-  \/\/ Mangle all of the initial generation.\n-  if (ZapUnusedHeapArea) {\n-    MemRegion mangle_region((HeapWord*)_virtual_space.low(),\n-      (HeapWord*)_virtual_space.high());\n-    SpaceMangler::mangle_region(mangle_region);\n-  }\n-  _reserved = MemRegion((HeapWord*)_virtual_space.low_boundary(),\n-          (HeapWord*)_virtual_space.high_boundary());\n-}\n-\n-size_t Generation::initial_size() {\n-  GenCollectedHeap* gch = GenCollectedHeap::heap();\n-  if (gch->is_young_gen(this)) {\n-    return gch->young_gen_spec()->init_size();\n-  }\n-  return gch->old_gen_spec()->init_size();\n-}\n-\n-size_t Generation::max_capacity() const {\n-  return reserved().byte_size();\n-}\n-\n-void Generation::print() const { print_on(tty); }\n-\n-void Generation::print_on(outputStream* st)  const {\n-  st->print(\" %-20s\", name());\n-  st->print(\" total \" SIZE_FORMAT \"K, used \" SIZE_FORMAT \"K\",\n-             capacity()\/K, used()\/K);\n-  st->print_cr(\" [\" PTR_FORMAT \", \" PTR_FORMAT \", \" PTR_FORMAT \")\",\n-              p2i(_virtual_space.low_boundary()),\n-              p2i(_virtual_space.high()),\n-              p2i(_virtual_space.high_boundary()));\n-}\n-\n-void Generation::print_summary_info_on(outputStream* st) {\n-  StatRecord* sr = stat_record();\n-  double time = sr->accumulated_time.seconds();\n-  st->print_cr(\"Accumulated %s generation GC time %3.7f secs, \"\n-               \"%u GC's, avg GC time %3.7f\",\n-               GenCollectedHeap::heap()->is_young_gen(this) ? \"young\" : \"old\" ,\n-               time,\n-               sr->invocations,\n-               sr->invocations > 0 ? time \/ sr->invocations : 0.0);\n-}\n-\n-\/\/ Utility iterator classes\n-\n-class GenerationIsInReservedClosure : public SpaceClosure {\n- public:\n-  const void* _p;\n-  Space* sp;\n-  virtual void do_space(Space* s) {\n-    if (sp == nullptr) {\n-      if (s->is_in_reserved(_p)) sp = s;\n-    }\n-  }\n-  GenerationIsInReservedClosure(const void* p) : _p(p), sp(nullptr) {}\n-};\n-\n-class GenerationIsInClosure : public SpaceClosure {\n- public:\n-  const void* _p;\n-  Space* sp;\n-  virtual void do_space(Space* s) {\n-    if (sp == nullptr) {\n-      if (s->is_in(_p)) sp = s;\n-    }\n-  }\n-  GenerationIsInClosure(const void* p) : _p(p), sp(nullptr) {}\n-};\n-\n-bool Generation::is_in(const void* p) const {\n-  GenerationIsInClosure blk(p);\n-  ((Generation*)this)->space_iterate(&blk);\n-  return blk.sp != nullptr;\n-}\n-\n-size_t Generation::max_contiguous_available() const {\n-  \/\/ The largest number of contiguous free words in this or any higher generation.\n-  size_t avail = contiguous_available();\n-  size_t old_avail = 0;\n-  if (GenCollectedHeap::heap()->is_young_gen(this)) {\n-    old_avail = GenCollectedHeap::heap()->old_gen()->contiguous_available();\n-  }\n-  return MAX2(avail, old_avail);\n-}\n-\n-bool Generation::promotion_attempt_is_safe(size_t max_promotion_in_bytes) const {\n-  size_t available = max_contiguous_available();\n-  bool   res = (available >= max_promotion_in_bytes);\n-  log_trace(gc)(\"Generation: promo attempt is%s safe: available(\" SIZE_FORMAT \") %s max_promo(\" SIZE_FORMAT \")\",\n-                res? \"\":\" not\", available, res? \">=\":\"<\", max_promotion_in_bytes);\n-  return res;\n-}\n-\n-\/\/ Ignores \"ref\" and calls allocate().\n-oop Generation::promote(oop obj, size_t obj_size) {\n-  assert(obj_size == obj->size(), \"bad obj_size passed in\");\n-\n-#ifndef PRODUCT\n-  if (GenCollectedHeap::heap()->promotion_should_fail()) {\n-    return nullptr;\n-  }\n-#endif  \/\/ #ifndef PRODUCT\n-\n-  \/\/ Allocate new object.\n-  HeapWord* result = allocate(obj_size, false);\n-  if (result == nullptr) {\n-    \/\/ Promotion of obj into gen failed.  Try to expand and allocate.\n-    result = expand_and_allocate(obj_size, false);\n-    if (result == nullptr) {\n-      return nullptr;\n-    }\n-  }\n-\n-  \/\/ Copy to new location.\n-  Copy::aligned_disjoint_words(cast_from_oop<HeapWord*>(obj), result, obj_size);\n-  oop new_obj = cast_to_oop<HeapWord*>(result);\n-\n-  \/\/ Transform object if it is a stack chunk.\n-  ContinuationGCSupport::transform_stack_chunk(new_obj);\n-\n-  return new_obj;\n-}\n-\n-\/\/ Some of these are mediocre general implementations.  Should be\n-\/\/ overridden to get better performance.\n-\n-class GenerationBlockStartClosure : public SpaceClosure {\n- public:\n-  const void* _p;\n-  HeapWord* _start;\n-  virtual void do_space(Space* s) {\n-    if (_start == nullptr && s->is_in_reserved(_p)) {\n-      _start = s->block_start(_p);\n-    }\n-  }\n-  GenerationBlockStartClosure(const void* p) { _p = p; _start = nullptr; }\n-};\n-\n-HeapWord* Generation::block_start(const void* p) const {\n-  GenerationBlockStartClosure blk(p);\n-  \/\/ Cast away const\n-  ((Generation*)this)->space_iterate(&blk);\n-  return blk._start;\n-}\n-\n-class GenerationBlockSizeClosure : public SpaceClosure {\n- public:\n-  const HeapWord* _p;\n-  size_t size;\n-  virtual void do_space(Space* s) {\n-    if (size == 0 && s->is_in_reserved(_p)) {\n-      size = s->block_size(_p);\n-    }\n-  }\n-  GenerationBlockSizeClosure(const HeapWord* p) { _p = p; size = 0; }\n-};\n-\n-size_t Generation::block_size(const HeapWord* p) const {\n-  GenerationBlockSizeClosure blk(p);\n-  \/\/ Cast away const\n-  ((Generation*)this)->space_iterate(&blk);\n-  assert(blk.size > 0, \"seems reasonable\");\n-  return blk.size;\n-}\n-\n-class GenerationBlockIsObjClosure : public SpaceClosure {\n- public:\n-  const HeapWord* _p;\n-  bool is_obj;\n-  virtual void do_space(Space* s) {\n-    if (!is_obj && s->is_in_reserved(_p)) {\n-      is_obj |= s->block_is_obj(_p);\n-    }\n-  }\n-  GenerationBlockIsObjClosure(const HeapWord* p) { _p = p; is_obj = false; }\n-};\n-\n-bool Generation::block_is_obj(const HeapWord* p) const {\n-  GenerationBlockIsObjClosure blk(p);\n-  \/\/ Cast away const\n-  ((Generation*)this)->space_iterate(&blk);\n-  return blk.is_obj;\n-}\n-\n-class GenerationObjIterateClosure : public SpaceClosure {\n- private:\n-  ObjectClosure* _cl;\n- public:\n-  virtual void do_space(Space* s) {\n-    s->object_iterate(_cl);\n-  }\n-  GenerationObjIterateClosure(ObjectClosure* cl) : _cl(cl) {}\n-};\n-\n-void Generation::object_iterate(ObjectClosure* cl) {\n-  GenerationObjIterateClosure blk(cl);\n-  space_iterate(&blk);\n-}\n-\n-#if INCLUDE_SERIALGC\n-\n-void Generation::prepare_for_compaction(CompactPoint* cp) {\n-  \/\/ Generic implementation, can be specialized\n-  ContiguousSpace* space = first_compaction_space();\n-  while (space != nullptr) {\n-    space->prepare_for_compaction(cp);\n-    space = space->next_compaction_space();\n-  }\n-}\n-\n-class AdjustPointersClosure: public SpaceClosure {\n- public:\n-  void do_space(Space* sp) {\n-    sp->adjust_pointers();\n-  }\n-};\n-\n-void Generation::adjust_pointers() {\n-  \/\/ Note that this is done over all spaces, not just the compactible\n-  \/\/ ones.\n-  AdjustPointersClosure blk;\n-  space_iterate(&blk, true);\n-}\n-\n-void Generation::compact() {\n-  ContiguousSpace* sp = first_compaction_space();\n-  while (sp != nullptr) {\n-    sp->compact();\n-    sp = sp->next_compaction_space();\n-  }\n-}\n-\n-#endif \/\/ INCLUDE_SERIALGC\n","filename":"src\/hotspot\/share\/gc\/shared\/generation.cpp","additions":0,"deletions":284,"binary":false,"changes":284,"status":"deleted"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"gc\/shared\/generation.hpp\"\n+#include \"gc\/serial\/generation.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/generationSpec.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,18 +49,0 @@\n-void Space::initialize(MemRegion mr,\n-                       bool clear_space,\n-                       bool mangle_space) {\n-  HeapWord* bottom = mr.start();\n-  HeapWord* end    = mr.end();\n-  assert(Universe::on_page_boundary(bottom) && Universe::on_page_boundary(end),\n-         \"invalid space boundaries\");\n-  set_bottom(bottom);\n-  set_end(end);\n-  if (clear_space) clear(mangle_space);\n-}\n-\n-void Space::clear(bool mangle_space) {\n-  if (ZapUnusedHeapArea && mangle_space) {\n-    mangle_unused_area();\n-  }\n-}\n-\n@@ -82,2 +64,10 @@\n-  Space::initialize(mr, clear_space, mangle_space);\n-  set_compaction_top(bottom());\n+  HeapWord* bottom = mr.start();\n+  HeapWord* end    = mr.end();\n+  assert(Universe::on_page_boundary(bottom) && Universe::on_page_boundary(end),\n+         \"invalid space boundaries\");\n+  set_bottom(bottom);\n+  set_end(end);\n+  if (clear_space) {\n+    clear(mangle_space);\n+  }\n+  set_compaction_top(bottom);\n@@ -90,1 +80,3 @@\n-  Space::clear(mangle_space);\n+  if (ZapUnusedHeapArea && mangle_space) {\n+    mangle_unused_area();\n+  }\n","filename":"src\/hotspot\/share\/gc\/shared\/space.cpp","additions":13,"deletions":21,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -89,1 +89,1 @@\n-  virtual HeapWord* saved_mark_word() const  { return _saved_mark_word; }\n+  HeapWord* saved_mark_word() const  { return _saved_mark_word; }\n@@ -95,1 +95,1 @@\n-  virtual bool obj_allocated_since_save_marks(const oop obj) const {\n+  bool obj_allocated_since_save_marks(const oop obj) const {\n@@ -115,11 +115,0 @@\n-  \/\/ Initialization.\n-  \/\/ \"initialize\" should be called once on a space, before it is used for\n-  \/\/ any purpose.  The \"mr\" arguments gives the bounds of the space, and\n-  \/\/ the \"clear_space\" argument should be true unless the memory in \"mr\" is\n-  \/\/ known to be zeroed.\n-  virtual void initialize(MemRegion mr, bool clear_space, bool mangle_space);\n-\n-  \/\/ The \"clear\" method must be called on a region that may have\n-  \/\/ had allocation performed in it, but is now to be considered empty.\n-  virtual void clear(bool mangle_space);\n-\n@@ -181,1 +170,1 @@\n-  virtual HeapWord* block_start(const void* p);\n+  HeapWord* block_start(const void* p);\n@@ -194,1 +183,1 @@\n-  virtual bool obj_is_alive(const HeapWord* addr) const;\n+  bool obj_is_alive(const HeapWord* addr) const;\n@@ -209,1 +198,1 @@\n-  virtual void print() const;\n+  void print() const;\n@@ -211,2 +200,2 @@\n-  virtual void print_short() const;\n-  virtual void print_short_on(outputStream* st) const;\n+  void print_short() const;\n+  void print_short_on(outputStream* st) const;\n@@ -267,1 +256,6 @@\n-  void initialize(MemRegion mr, bool clear_space, bool mangle_space) override;\n+  \/\/ Initialization.\n+  \/\/ \"initialize\" should be called once on a space, before it is used for\n+  \/\/ any purpose.  The \"mr\" arguments gives the bounds of the space, and\n+  \/\/ the \"clear_space\" argument should be true unless the memory in \"mr\" is\n+  \/\/ known to be zeroed.\n+  void initialize(MemRegion mr, bool clear_space, bool mangle_space);\n@@ -269,1 +263,3 @@\n-  void clear(bool mangle_space) override;\n+  \/\/ The \"clear\" method must be called on a region that may have\n+  \/\/ had allocation performed in it, but is now to be considered empty.\n+  virtual void clear(bool mangle_space);\n","filename":"src\/hotspot\/share\/gc\/shared\/space.hpp","additions":16,"deletions":20,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"gc\/serial\/generation.hpp\"\n@@ -31,1 +32,0 @@\n-#include \"gc\/shared\/generation.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/space.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"gc\/shared\/generation.hpp\"\n@@ -47,0 +46,1 @@\n+#include \"gc\/serial\/generation.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/vmStructs_gc.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -630,1 +630,1 @@\n-    return BarrierSetC2::load_at_resolved(access, val_type);;\n+    return BarrierSetC2::load_at_resolved(access, val_type);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahBarrierSetC2.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -67,0 +67,1 @@\n+      if (C->failing()) return false;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -224,1 +224,1 @@\n-#endif \/\/ SHARE_GC_SHENANDOAH_SHENANDOAHCLOSURES_HPP\n+#endif \/\/ SHARE_GC_SHENANDOAH_SHENANDOAHCLOSURES_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahClosures.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,64 +39,0 @@\n-ShenandoahParallelCodeCacheIterator::ShenandoahParallelCodeCacheIterator(const GrowableArray<CodeHeap*>* heaps) {\n-  _length = heaps->length();\n-  _iters = NEW_C_HEAP_ARRAY(ShenandoahParallelCodeHeapIterator, _length, mtGC);\n-  for (int h = 0; h < _length; h++) {\n-    _iters[h] = ShenandoahParallelCodeHeapIterator(heaps->at(h));\n-  }\n-}\n-\n-ShenandoahParallelCodeCacheIterator::~ShenandoahParallelCodeCacheIterator() {\n-  FREE_C_HEAP_ARRAY(ParallelCodeHeapIterator, _iters);\n-}\n-\n-void ShenandoahParallelCodeCacheIterator::parallel_blobs_do(CodeBlobClosure* f) {\n-  for (int c = 0; c < _length; c++) {\n-    _iters[c].parallel_blobs_do(f);\n-  }\n-}\n-\n-ShenandoahParallelCodeHeapIterator::ShenandoahParallelCodeHeapIterator(CodeHeap* heap) :\n-        _heap(heap), _claimed_idx(0), _finished(false) {\n-}\n-\n-void ShenandoahParallelCodeHeapIterator::parallel_blobs_do(CodeBlobClosure* f) {\n-  assert(SafepointSynchronize::is_at_safepoint(), \"Must be at safepoint\");\n-\n-  \/*\n-   * Parallel code heap walk.\n-   *\n-   * This code makes all threads scan all code heaps, but only one thread would execute the\n-   * closure on given blob. This is achieved by recording the \"claimed\" blocks: if a thread\n-   * had claimed the block, it can process all blobs in it. Others have to fast-forward to\n-   * next attempt without processing.\n-   *\n-   * Late threads would return immediately if iterator is finished.\n-   *\/\n-\n-  if (_finished) {\n-    return;\n-  }\n-\n-  int stride = 256; \/\/ educated guess\n-  int stride_mask = stride - 1;\n-  assert (is_power_of_2(stride), \"sanity\");\n-\n-  int count = 0;\n-  bool process_block = true;\n-\n-  for (CodeBlob *cb = CodeCache::first_blob(_heap); cb != nullptr; cb = CodeCache::next_blob(_heap, cb)) {\n-    int current = count++;\n-    if ((current & stride_mask) == 0) {\n-      process_block = (current >= _claimed_idx) &&\n-                      (Atomic::cmpxchg(&_claimed_idx, current, current + stride, memory_order_relaxed) == current);\n-    }\n-    if (process_block) {\n-      f->do_code_blob(cb);\n-#ifdef ASSERT\n-      if (cb->is_nmethod())\n-        Universe::heap()->verify_nmethod((nmethod*)cb);\n-#endif\n-    }\n-  }\n-\n-  _finished = true;\n-}\n@@ -306,1 +242,0 @@\n-        _par_iterator(CodeCache::heaps()),\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCodeRoots.cpp","additions":0,"deletions":65,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -42,27 +42,0 @@\n-class ShenandoahParallelCodeHeapIterator {\n-  friend class CodeCache;\n-private:\n-  CodeHeap*     _heap;\n-  shenandoah_padding(0);\n-  volatile int  _claimed_idx;\n-  volatile bool _finished;\n-  shenandoah_padding(1);\n-public:\n-  ShenandoahParallelCodeHeapIterator(CodeHeap* heap);\n-  void parallel_blobs_do(CodeBlobClosure* f);\n-};\n-\n-class ShenandoahParallelCodeCacheIterator {\n-  friend class CodeCache;\n-private:\n-  ShenandoahParallelCodeHeapIterator* _iters;\n-  int                       _length;\n-\n-  NONCOPYABLE(ShenandoahParallelCodeCacheIterator);\n-\n-public:\n-  ShenandoahParallelCodeCacheIterator(const GrowableArray<CodeHeap*>* heaps);\n-  ~ShenandoahParallelCodeCacheIterator();\n-  void parallel_blobs_do(CodeBlobClosure* f);\n-};\n-\n@@ -72,2 +45,0 @@\n-  ShenandoahParallelCodeCacheIterator _par_iterator;\n-  ShenandoahSharedFlag _seq_claimed;\n@@ -91,1 +62,0 @@\n-  static void flush_nmethod(nmethod* nm);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCodeRoots.hpp","additions":0,"deletions":30,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -71,1 +71,0 @@\n-    ShenandoahHeap* heap = ShenandoahHeap::heap();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGC.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2558,8 +2558,12 @@\n-    CodeCache::UnloadingScope scope(is_alive.is_alive_closure());\n-    ShenandoahGCPhase gc_phase(phase);\n-    ShenandoahGCWorkerPhase worker_phase(phase);\n-    bool purged_class = SystemDictionary::do_unloading(gc_timer());\n-\n-    uint num_workers = _workers->active_workers();\n-    ShenandoahClassUnloadingTask unlink_task(phase, num_workers, purged_class);\n-    _workers->run_task(&unlink_task);\n+    {\n+      CodeCache::UnlinkingScope scope(is_alive.is_alive_closure());\n+      ShenandoahGCPhase gc_phase(phase);\n+      ShenandoahGCWorkerPhase worker_phase(phase);\n+      bool unloading_occurred = SystemDictionary::do_unloading(gc_timer());\n+\n+      uint num_workers = _workers->active_workers();\n+      ShenandoahClassUnloadingTask unlink_task(phase, num_workers, unloading_occurred);\n+      _workers->run_task(&unlink_task);\n+    }\n+    \/\/ Release unloaded nmethods's memory.\n+    CodeCache::flush_unlinked_nmethods();\n@@ -2640,4 +2644,0 @@\n-address ShenandoahHeap::gc_state_addr() {\n-  return (address) ShenandoahHeap::heap()->_gc_state.addr_of();\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -395,1 +395,0 @@\n-  static address gc_state_addr();\n@@ -423,1 +422,1 @@\n-  inline bool is_gc_in_progress_mask(uint mask) const;\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -709,4 +709,0 @@\n-inline bool ShenandoahHeap::is_gc_in_progress_mask(uint mask) const {\n-  return _gc_state.is_set(mask);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.inline.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-#endif \/\/ SHARE_VM_GC_SHENANDOAH_SHENANDOAHJFRSUPPORT_HPP\n+#endif \/\/ SHARE_GC_SHENANDOAH_SHENANDOAHJFRSUPPORT_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahJfrSupport.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMark.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -55,33 +55,0 @@\n-class ShenandoahHasCSetOopClosure : public OopClosure {\n-private:\n-  ShenandoahHeap* const _heap;\n-  bool                  _has_cset_oops;\n-\n-public:\n-  ShenandoahHasCSetOopClosure(ShenandoahHeap *heap) :\n-    _heap(heap),\n-    _has_cset_oops(false) {\n-  }\n-\n-  bool has_cset_oops() const {\n-    return _has_cset_oops;\n-  }\n-\n-  void do_oop(oop* p) {\n-    oop value = RawAccess<>::oop_load(p);\n-    if (!_has_cset_oops && _heap->in_collection_set(value)) {\n-      _has_cset_oops = true;\n-    }\n-  }\n-\n-  void do_oop(narrowOop* p) {\n-    ShouldNotReachHere();\n-  }\n-};\n-\n-bool ShenandoahNMethod::has_cset_oops(ShenandoahHeap *heap) {\n-  ShenandoahHasCSetOopClosure cl(heap);\n-  oops_do(&cl);\n-  return cl.has_cset_oops();\n-}\n-\n@@ -212,4 +179,0 @@\n-\n-  bool has_oops() {\n-    return !_oops.is_empty();\n-  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahNMethod.cpp","additions":0,"deletions":37,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -58,6 +58,0 @@\n-  bool has_cset_oops(ShenandoahHeap* heap);\n-\n-  inline int oop_count() const;\n-  inline bool has_oops() const;\n-\n-  inline void mark_unregistered();\n@@ -80,1 +74,0 @@\n-  bool has_non_immed_oops() const { return _has_non_immed_oops; }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahNMethod.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -42,12 +42,0 @@\n-int ShenandoahNMethod::oop_count() const {\n-  return _oops_count + static_cast<int>(nm()->oops_end() - nm()->oops_begin());\n-}\n-\n-bool ShenandoahNMethod::has_oops() const {\n-  return oop_count() > 0;\n-}\n-\n-void ShenandoahNMethod::mark_unregistered() {\n-  _unregistered = true;\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahNMethod.inline.hpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -92,1 +92,0 @@\n-  _phase(phase),\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRootProcessor.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -137,1 +137,0 @@\n-  const ShenandoahPhaseTimings::Phase _phase;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRootProcessor.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -38,1 +39,0 @@\n-#include \"runtime\/arguments.hpp\"\n@@ -121,1 +121,1 @@\n-  if (!HAS_PENDING_EXCEPTION && Arguments::is_dumping_archive()) {\n+  if (!HAS_PENDING_EXCEPTION && CDSConfig::is_dumping_archive()) {\n","filename":"src\/hotspot\/share\/interpreter\/rewriter.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -53,1 +54,0 @@\n-#include \"runtime\/arguments.hpp\"\n@@ -2448,1 +2448,1 @@\n-              if (REWRITE_BYTECODES && !UseSharedSpaces && !Arguments::is_dumping_archive()) {\n+              if (REWRITE_BYTECODES && !UseSharedSpaces && !CDSConfig::is_dumping_archive()) {\n","filename":"src\/hotspot\/share\/interpreter\/zero\/bytecodeInterpreter.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -112,0 +112,3 @@\n+    if (buffer == nullptr) {\n+      return false;\n+    }\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/jfrCheckpointManager.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -188,1 +189,1 @@\n-  if (Arguments::is_dumping_archive() && JfrOptionSet::start_flight_recording_options() != nullptr) {\n+  if (CDSConfig::is_dumping_archive() && JfrOptionSet::start_flight_recording_options() != nullptr) {\n@@ -230,1 +231,1 @@\n-  return Arguments::is_dumping_archive() || launch_command_line_recordings(JavaThread::current());\n+  return CDSConfig::is_dumping_archive() || launch_command_line_recordings(JavaThread::current());\n","filename":"src\/hotspot\/share\/jfr\/recorder\/jfrRecorder.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -134,0 +134,3 @@\n+    if (buffer == nullptr) {\n+      return false;\n+    }\n","filename":"src\/hotspot\/share\/jfr\/recorder\/stringpool\/jfrStringPool.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2439,0 +2439,10 @@\n+C2V_VMENTRY(void, clearOopHandle, (JNIEnv* env, jobject, jlong oop_handle))\n+  if (oop_handle == 0L) {\n+    JVMCI_THROW(NullPointerException);\n+  }\n+  \/\/ Assert before nulling out, for better debugging.\n+  assert(JVMCIRuntime::is_oop_handle(oop_handle), \"precondition\");\n+  oop* oop_ptr = (oop*) oop_handle;\n+  NativeAccess<>::oop_store(oop_ptr, (oop) nullptr);\n+C2V_END\n+\n@@ -3263,0 +3273,1 @@\n+  {CC \"clearOopHandle\",                               CC \"(J)V\",                                                                            FN_PTR(clearOopHandle)},\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -150,1 +150,1 @@\n-  _env = _runtime->init_shared_library_javavm(&_init_error);\n+  _env = _runtime->init_shared_library_javavm(&_init_error, &_init_error_msg);\n@@ -156,1 +156,2 @@\n-    JVMCI_event_1(\"[%s:%d] Error creating libjvmci (err: %d)\", _file, _line, _init_error);\n+    JVMCI_event_1(\"[%s:%d] Error creating libjvmci (err: %d, %s)\", _file, _line,\n+                  _init_error, _init_error_msg == nullptr ? \"unknown\" : _init_error_msg);\n@@ -198,1 +199,1 @@\n-    _throw_to_caller(false), _file(file), _line(line), _init_error(JNI_OK), _compile_state(compile_state) {\n+    _throw_to_caller(false), _file(file), _line(line), _init_error(JNI_OK), _init_error_msg(nullptr), _compile_state(compile_state) {\n@@ -203,1 +204,1 @@\n-    _throw_to_caller(false), _file(file), _line(line), _init_error(JNI_OK), _compile_state(nullptr) {\n+    _throw_to_caller(false), _file(file), _line(line), _init_error(JNI_OK), _init_error_msg(nullptr), _compile_state(nullptr) {\n@@ -208,1 +209,1 @@\n-    _throw_to_caller(true), _file(file), _line(line), _init_error(JNI_OK), _compile_state(nullptr) {\n+    _throw_to_caller(true), _file(file), _line(line), _init_error(JNI_OK), _init_error_msg(nullptr), _compile_state(nullptr) {\n@@ -221,0 +222,1 @@\n+  _init_error_msg = nullptr;\n@@ -240,1 +242,2 @@\n-  JVMCI_THROW_MSG(InternalError, err_msg(\"Error creating or attaching to libjvmci (err: %d)\", _init_error));\n+  JVMCI_THROW_MSG(InternalError, err_msg(\"Error creating or attaching to libjvmci (err: %d, description: %s)\",\n+                  _init_error, _init_error_msg == nullptr ? \"unknown\" : _init_error_msg));\n@@ -250,1 +253,2 @@\n-  THROW_MSG(vmSymbols::java_lang_OutOfMemoryError(), err_msg(\"Error creating or attaching to libjvmci (err: %d)\", _init_error));\n+  THROW_MSG(vmSymbols::java_lang_OutOfMemoryError(), err_msg(\"Error creating or attaching to libjvmci (err: %d, description: %s)\",\n+            _init_error, _init_error_msg == nullptr ? \"unknown\" : _init_error_msg));\n@@ -575,0 +579,3 @@\n+  if (_init_error_msg != nullptr) {\n+    os::free((void*) _init_error_msg);\n+  }\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.cpp","additions":14,"deletions":7,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -175,0 +175,1 @@\n+  const char*  _init_error_msg;  \/\/ Message for _init_error if available. C heap allocated.\n@@ -220,0 +221,6 @@\n+  \/\/ Gets a message describing a non-zero init_error().\n+  \/\/ Valid as long as this JVMCIEnv is valid.\n+  const char* init_error_msg() {\n+    return _init_error_msg;\n+  }\n+\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -890,0 +890,7 @@\n+#ifdef ASSERT\n+bool JVMCIRuntime::is_oop_handle(jlong handle) {\n+  const oop* ptr = (oop*) handle;\n+  return object_handles()->allocation_status(ptr) == OopStorage::ALLOCATED_ENTRY;\n+}\n+#endif\n+\n@@ -1249,1 +1256,1 @@\n-JNIEnv* JVMCIRuntime::init_shared_library_javavm(int* create_JavaVM_err) {\n+JNIEnv* JVMCIRuntime::init_shared_library_javavm(int* create_JavaVM_err, const char** err_msg) {\n@@ -1276,1 +1283,1 @@\n-    JavaVMOption options[5];\n+    JavaVMOption options[6];\n@@ -1293,0 +1300,2 @@\n+    options[5].optionString = (char*) \"_createvm_errorstr\";\n+    options[5].extraInfo = (void*) err_msg;\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -283,2 +283,4 @@\n-  \/\/ by JNI_CreateJavaVM is returned in create_JavaVM_err.\n-  JNIEnv* init_shared_library_javavm(int* create_JavaVM_err);\n+  \/\/ by JNI_CreateJavaVM is returned in create_JavaVM_err and, if available, an\n+  \/\/ error message is malloc'ed and assigned to err_msg. The caller is responsible\n+  \/\/ for freeing err_msg.\n+  JNIEnv* init_shared_library_javavm(int* create_JavaVM_err, const char** err_msg);\n@@ -320,0 +322,3 @@\n+#ifdef ASSERT\n+  static bool is_oop_handle(jlong handle);\n+#endif\n@@ -323,2 +328,0 @@\n-  \/\/ The method also resets _last_found_oop_handle_index to -1\n-  \/\/ and _null_oop_handles to 0.\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.hpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +52,2 @@\n-  const size_t sz = Message::calc_size(strlen(msg));\n+  const size_t len = strlen(msg);\n+  const size_t sz = Message::calc_size(len);\n@@ -57,1 +59,1 @@\n-    new(_buf + _pos) Message(output, decorations, msg);\n+    new(_buf + _pos) Message(output, decorations, msg, len);\n@@ -117,23 +119,1 @@\n-void AsyncLogWriter::write() {\n-  ResourceMark rm;\n-  AsyncLogMap<AnyObj::RESOURCE_AREA> snapshot;\n-\n-  \/\/ lock protection. This guarantees I\/O jobs don't block logsites.\n-  {\n-    AsyncLogLocker locker;\n-\n-    _buffer_staging->reset();\n-    swap(_buffer, _buffer_staging);\n-\n-    \/\/ move counters to snapshot and reset them.\n-    _stats.iterate([&] (LogFileStreamOutput* output, uint32_t& counter) {\n-      if (counter > 0) {\n-        bool created = snapshot.put(output, counter);\n-        assert(created == true, \"sanity check\");\n-        counter = 0;\n-      }\n-      return true;\n-    });\n-    _data_available = false;\n-  }\n-\n+void AsyncLogWriter::write(AsyncLogMap<AnyObj::RESOURCE_AREA>& snapshot) {\n@@ -160,1 +140,1 @@\n-      output->write_blocking(decorations, ss.as_string(false));\n+      output->write_blocking(decorations, ss.freeze());\n@@ -173,0 +153,2 @@\n+    ResourceMark rm;\n+    AsyncLogMap<AnyObj::RESOURCE_AREA> snapshot;\n@@ -179,0 +161,15 @@\n+      \/\/ Only doing a swap and statistics under the lock to\n+      \/\/ guarantee that I\/O jobs don't block logsites.\n+      _buffer_staging->reset();\n+      swap(_buffer, _buffer_staging);\n+\n+      \/\/ move counters to snapshot and reset them.\n+      _stats.iterate([&] (LogFileStreamOutput* output, uint32_t& counter) {\n+        if (counter > 0) {\n+          bool created = snapshot.put(output, counter);\n+          assert(created == true, \"sanity check\");\n+          counter = 0;\n+        }\n+        return true;\n+      });\n+      _data_available = false;\n@@ -180,2 +177,1 @@\n-\n-    write();\n+    write(snapshot);\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.cpp","additions":24,"deletions":28,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,1 +70,1 @@\n-  \/\/ Messsage is the envelop of a log line and its associative data.\n+  \/\/ Messsage is the envelope of a log line and its associative data.\n@@ -75,1 +76,1 @@\n-  \/\/ |_output|_decorations|\"a log line\", |pad| <- pointer aligned.\n+  \/\/ |_output|_decorations|\"a log line\", |pad| <- Message aligned.\n@@ -87,1 +88,2 @@\n-    Message(LogFileStreamOutput* output, const LogDecorations& decorations, const char* msg)\n+    \/\/ msglen excludes NUL-byte\n+    Message(LogFileStreamOutput* output, const LogDecorations& decorations, const char* msg, const size_t msglen)\n@@ -90,2 +92,1 @@\n-      PRAGMA_STRINGOP_OVERFLOW_IGNORED\n-      strcpy(reinterpret_cast<char* >(this+1), msg);\n+      memcpy(reinterpret_cast<char* >(this+1), msg, msglen + 1);\n@@ -96,1 +97,1 @@\n-      return align_up(sizeof(Message) + message_len + 1, sizeof(void*));\n+      return align_up(sizeof(Message) + message_len + 1, alignof(Message));\n@@ -117,0 +118,2 @@\n+      \/\/ Ensure _pos is Message-aligned\n+      _pos = align_up(_buf, alignof(Message)) - _buf;\n@@ -127,1 +130,4 @@\n-    void reset() { _pos = 0; }\n+    void reset() {\n+      \/\/ Ensure _pos is Message-aligned\n+      _pos = align_up(_buf, alignof(Message)) - _buf;\n+    }\n@@ -169,1 +175,1 @@\n-  void write();\n+  void write(AsyncLogMap<AnyObj::RESOURCE_AREA>& snapshot);\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.hpp","additions":14,"deletions":8,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-  static const size_t MaxSelections = 256;\n+  static const size_t MaxSelections = 300;\n","filename":"src\/hotspot\/share\/logging\/logSelectionList.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"compiler\/compilationMemoryStatistic.hpp\"\n@@ -212,1 +213,1 @@\n-Arena::Arena(MEMFLAGS flag, size_t init_size) : _flags(flag), _size_in_bytes(0)  {\n+Arena::Arena(MEMFLAGS flag, Tag tag, size_t init_size) : _flags(flag), _tag(tag), _size_in_bytes(0)  {\n@@ -222,1 +223,1 @@\n-Arena::Arena(MEMFLAGS flag) : _flags(flag), _size_in_bytes(0) {\n+Arena::Arena(MEMFLAGS flag, Tag tag) : _flags(flag), _tag(tag), _size_in_bytes(0) {\n@@ -254,0 +255,6 @@\n+    if (CompilationMemoryStatistic::enabled() && _flags == mtCompiler) {\n+      Thread* const t = Thread::current();\n+      if (t != nullptr && t->is_Compiler_thread()) {\n+        CompilationMemoryStatistic::on_arena_change(delta, this);\n+      }\n+    }\n","filename":"src\/hotspot\/share\/memory\/arena.cpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -89,0 +89,9 @@\n+public:\n+\n+  enum class Tag {\n+    tag_other = 0,\n+    tag_ra,   \/\/ resource area\n+    tag_ha,   \/\/ handle area\n+    tag_node  \/\/ C2 Node arena\n+  };\n+\n@@ -95,1 +104,1 @@\n-\n+  const Tag _tag;\n@@ -118,3 +127,2 @@\n-\n-  Arena(MEMFLAGS memflag);\n-  Arena(MEMFLAGS memflag, size_t init_size);\n+  Arena(MEMFLAGS memflag, Tag tag = Tag::tag_other);\n+  Arena(MEMFLAGS memflag, Tag tag, size_t init_size);\n@@ -174,0 +182,2 @@\n+  Tag get_tag() const { return _tag; }\n+\n","filename":"src\/hotspot\/share\/memory\/arena.hpp","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -491,12 +491,0 @@\n-size_t CodeHeap::alignment_unit() const {\n-  \/\/ this will be a power of two\n-  return _segment_size;\n-}\n-\n-\n-size_t CodeHeap::alignment_offset() const {\n-  \/\/ The lowest address in any allocated block will be\n-  \/\/ equal to alignment_offset (mod alignment_unit).\n-  return sizeof(HeapBlock) & (_segment_size - 1);\n-}\n-\n","filename":"src\/hotspot\/share\/memory\/heap.cpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -177,2 +177,0 @@\n-  size_t alignment_unit()       const;           \/\/ alignment of any block\n-  size_t alignment_offset()     const;           \/\/ offset of first byte of any block, within the enclosing alignment unit\n","filename":"src\/hotspot\/share\/memory\/heap.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -407,4 +407,0 @@\n-  assert(capacity_until_gc >= committed_bytes,\n-         \"capacity_until_gc: \" SIZE_FORMAT \" < committed_bytes: \" SIZE_FORMAT,\n-         capacity_until_gc, committed_bytes);\n-\n@@ -412,1 +408,4 @@\n-  size_t left_until_GC = capacity_until_gc - committed_bytes;\n+  \/\/ capacity_until_GC may have been decreased concurrently and may\n+  \/\/ temporarily be lower than what metaspace has committed. Allow for that.\n+  size_t left_until_GC = capacity_until_gc > committed_bytes ?\n+      capacity_until_gc - committed_bytes : 0;\n@@ -572,6 +571,0 @@\n-\n-  \/\/ This does currently not work because rs may be the result of a split\n-  \/\/ operation and NMT seems not to be able to handle splits.\n-  \/\/ Will be fixed with JDK-8243535.\n-  \/\/ MemTracker::record_virtual_memory_type((address)rs.base(), mtClass);\n-\n@@ -788,0 +781,5 @@\n+        LogTarget(Debug, metaspace) lt;\n+        if (lt.is_enabled()) {\n+          LogStream ls(lt);\n+          os::print_memory_mappings((char*)base, size, &ls);\n+        }\n@@ -807,0 +805,3 @@\n+    \/\/ Mark class space as such\n+    MemTracker::record_virtual_memory_type((address)rs.base(), mtClass);\n+\n","filename":"src\/hotspot\/share\/memory\/metaspace.cpp","additions":12,"deletions":11,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"memory\/arena.hpp\"\n@@ -54,1 +55,1 @@\n-    Arena(flags) DEBUG_ONLY(COMMA _nesting(0)) {}\n+    Arena(flags, Arena::Tag::tag_ra) DEBUG_ONLY(COMMA _nesting(0)) {}\n@@ -57,1 +58,2 @@\n-    Arena(flags, init_size) DEBUG_ONLY(COMMA _nesting(0)) {}\n+    Arena(flags, Arena::Tag::tag_ra, init_size) DEBUG_ONLY(COMMA _nesting(0)) {\n+  }\n","filename":"src\/hotspot\/share\/memory\/resourceArea.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -825,1 +826,1 @@\n-  if (Arguments::is_dumping_archive()) {\n+  if (CDSConfig::is_dumping_archive()) {\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-  : _holder_metadata(metadata), _holder_klass(klass), _is_metadata_method(is_method) {\n+  : _holder_metadata(metadata), _holder_klass(klass), _next(nullptr), _is_metadata_method(is_method) {\n","filename":"src\/hotspot\/share\/oops\/compiledICHolder.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n-  if (range < UnscaledClassSpaceMax) {\n+  if (range <= UnscaledClassSpaceMax) {\n","filename":"src\/hotspot\/share\/oops\/compressedKlass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -222,1 +223,1 @@\n-    if (DumpSharedSpaces) {\n+    if (CDSConfig::is_dumping_heap()) {\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -707,1 +708,1 @@\n-  Arguments::assert_is_dumping_archive();\n+  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n@@ -741,1 +742,1 @@\n-    Arguments::assert_is_dumping_archive();\n+    assert(CDSConfig::is_dumping_archive(), \"sanity\");\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+\/\/ HierarchicalFieldStream allows to also iterate over fields of supertypes.\n@@ -138,1 +139,1 @@\n-\/\/ Iterate over only the internal fields\n+\/\/ Iterate over only the Java fields\n@@ -182,0 +183,100 @@\n+\/\/ Iterate over fields including the ones declared in supertypes\n+template<typename FieldStreamType>\n+class HierarchicalFieldStream : public StackObj  {\n+ private:\n+  const Array<InstanceKlass*>* _interfaces;\n+  InstanceKlass* _next_klass; \/\/ null indicates no more type to visit\n+  FieldStreamType _current_stream;\n+  int _interface_index;\n+\n+  void prepare() {\n+    _next_klass = next_klass_with_fields();\n+    \/\/ special case: the initial klass has no fields. If any supertype has any fields, use that directly.\n+    \/\/ if no such supertype exists, done() will return false already.\n+    next_stream_if_done();\n+  }\n+\n+  InstanceKlass* next_klass_with_fields() {\n+    assert(_next_klass != nullptr, \"reached end of types already\");\n+    InstanceKlass* result = _next_klass;\n+    do  {\n+      if (!result->is_interface() && result->super() != nullptr) {\n+        result = result->java_super();\n+      } else if (_interface_index > 0) {\n+        result = _interfaces->at(--_interface_index);\n+      } else {\n+        return nullptr; \/\/ we did not find any more supertypes with fields\n+      }\n+    } while (FieldStreamType(result).done());\n+    return result;\n+  }\n+\n+  \/\/ sets _current_stream to the next if the current is done and any more is available\n+  void next_stream_if_done() {\n+    if (_next_klass != nullptr && _current_stream.done()) {\n+      _current_stream = FieldStreamType(_next_klass);\n+      assert(!_current_stream.done(), \"created empty stream\");\n+      _next_klass = next_klass_with_fields();\n+    }\n+  }\n+\n+ public:\n+  HierarchicalFieldStream(InstanceKlass* klass) :\n+    _interfaces(klass->transitive_interfaces()),\n+    _next_klass(klass),\n+    _current_stream(FieldStreamType(klass)),\n+    _interface_index(_interfaces->length()) {\n+      prepare();\n+  }\n+\n+  void next() {\n+    _current_stream.next();\n+    next_stream_if_done();\n+  }\n+\n+  bool done() const { return _next_klass == nullptr && _current_stream.done(); }\n+\n+  \/\/ bridge functions from FieldStreamBase\n+\n+  AccessFlags access_flags() const {\n+    return _current_stream.access_flags();\n+  }\n+\n+  FieldInfo::FieldFlags field_flags() const {\n+    return _current_stream.field_flags();\n+  }\n+\n+  Symbol* name() const {\n+    return _current_stream.name();\n+  }\n+\n+  Symbol* signature() const {\n+    return _current_stream.signature();\n+  }\n+\n+  Symbol* generic_signature() const {\n+    return _current_stream.generic_signature();\n+  }\n+\n+  int offset() const {\n+    return _current_stream.offset();\n+  }\n+\n+  bool is_contended() const {\n+    return _current_stream.is_contended();\n+  }\n+\n+  int contended_group() const {\n+    return _current_stream.contended_group();\n+  }\n+\n+  FieldInfo to_FieldInfo() {\n+    return _current_stream.to_FieldInfo();\n+  }\n+\n+  fieldDescriptor& field_descriptor() const {\n+    return _current_stream.field_descriptor();\n+  }\n+\n+};\n+\n","filename":"src\/hotspot\/share\/oops\/fieldStreams.hpp","additions":102,"deletions":1,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -705,1 +706,1 @@\n-  if (DumpSharedSpaces) {\n+  if (CDSConfig::is_dumping_heap()) {\n@@ -4090,1 +4091,1 @@\n-        ((UseSharedSpaces || Arguments::is_dumping_archive()) && length != 0)) {\n+        ((UseSharedSpaces || CDSConfig::is_dumping_archive()) && length != 0)) {\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -51,1 +52,0 @@\n-#include \"runtime\/arguments.hpp\"\n@@ -88,1 +88,1 @@\n-  if (Arguments::is_dumping_archive() && is_instance_klass()) {\n+  if (CDSConfig::is_dumping_archive() && is_instance_klass()) {\n@@ -523,1 +523,1 @@\n-  if (!Arguments::is_dumping_archive()) {\n+  if (!CDSConfig::is_dumping_archive()) {\n@@ -540,1 +540,1 @@\n-  assert (Arguments::is_dumping_archive(),\n+  assert(CDSConfig::is_dumping_archive(),\n@@ -558,1 +558,1 @@\n-  Arguments::assert_is_dumping_archive();\n+  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n@@ -648,1 +648,1 @@\n-  assert(DumpSharedSpaces, \"called only during dumptime\");\n+  assert(CDSConfig::is_dumping_heap(), \"sanity\");\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -62,1 +63,0 @@\n-#include \"runtime\/arguments.hpp\"\n@@ -68,0 +68,1 @@\n+#include \"runtime\/java.hpp\"\n@@ -1169,1 +1170,1 @@\n-  Arguments::assert_is_dumping_archive();\n+  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -165,1 +166,1 @@\n-  assert(DumpSharedSpaces, \"Used by CDS only. Do not abuse!\");\n+  assert(CDSConfig::is_dumping_heap(), \"Used by CDS only. Do not abuse!\");\n","filename":"src\/hotspot\/share\/oops\/oop.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"compiler\/compilationMemoryStatistic.hpp\"\n@@ -112,0 +113,2 @@\n+  CompilationMemoryStatisticMark cmsm(directive);\n+\n@@ -121,0 +124,1 @@\n+    ResourceMark rm;\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -100,0 +100,2 @@\n+  if (C->failing()) return nullptr;\n+\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1886,0 +1886,11 @@\n+\/\/ Returns the BasicType of a given convert node and a type, with special handling to ensure that conversions to\n+\/\/ and from half float will return the SHORT basic type, as that wouldn't be returned typically from TypeInt.\n+static BasicType get_convert_type(Node* convert, const Type* type) {\n+  int convert_op = convert->Opcode();\n+  if (type->isa_int() && (convert_op == Op_ConvHF2F || convert_op == Op_ConvF2HF)) {\n+    return T_SHORT;\n+  }\n+\n+  return type->basic_type();\n+}\n+\n@@ -2560,0 +2571,35 @@\n+  \/\/ Try to convert a Phi with two duplicated convert nodes into a phi of the pre-conversion type and the convert node\n+  \/\/ proceeding the phi, to de-duplicate the convert node and compact the IR.\n+  if (can_reshape && progress == nullptr) {\n+    ConvertNode* convert = in(1)->isa_Convert();\n+    if (convert != nullptr) {\n+      int conv_op = convert->Opcode();\n+      bool ok = true;\n+\n+      \/\/ Check the rest of the inputs\n+      for (uint i = 2; i < req(); i++) {\n+        \/\/ Make sure that all inputs are of the same type of convert node\n+        if (in(i)->Opcode() != conv_op) {\n+          ok = false;\n+          break;\n+        }\n+      }\n+\n+      if (ok) {\n+        \/\/ Find the local bottom type to set as the type of the phi\n+        const Type* source_type = Type::get_const_basic_type(convert->in_type()->basic_type());\n+        const Type* dest_type = convert->bottom_type();\n+\n+        PhiNode* newphi = new PhiNode(in(0), source_type, nullptr);\n+        \/\/ Set inputs to the new phi be the inputs of the convert\n+        for (uint i = 1; i < req(); i++) {\n+          newphi->init_req(i, in(i)->in(1));\n+        }\n+\n+        phase->is_IterGVN()->register_new_node_with_optimizer(newphi, this);\n+\n+        return ConvertNode::create_convert(get_convert_type(convert, source_type), get_convert_type(convert, dest_type), newphi);\n+      }\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":46,"deletions":0,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -649,2 +649,2 @@\n-                  _node_arena_one(mtCompiler),\n-                  _node_arena_two(mtCompiler),\n+                  _node_arena_one(mtCompiler, Arena::Tag::tag_node),\n+                  _node_arena_two(mtCompiler, Arena::Tag::tag_node),\n@@ -1857,0 +1857,1 @@\n+    if (failing()) return;\n@@ -2072,0 +2073,1 @@\n+    if (failing()) return;\n@@ -2248,0 +2250,2 @@\n+  if (failing())  return;\n+\n@@ -2258,0 +2262,2 @@\n+    if (failing())  return;\n+\n@@ -2273,0 +2279,2 @@\n+  if (failing())  return;\n+\n@@ -2277,0 +2285,2 @@\n+  if (failing())  return;\n+\n@@ -2282,1 +2292,1 @@\n-\n+    if (failing())  return;\n@@ -2296,0 +2306,1 @@\n+    if (failing()) return;\n@@ -2302,0 +2313,2 @@\n+  if (failing())  return;\n+\n@@ -2323,1 +2336,1 @@\n-      if (failing())  return;\n+      if (failing()) return;\n@@ -2333,0 +2346,2 @@\n+        if (failing()) return;\n+\n@@ -2414,0 +2429,2 @@\n+  if (failing())  return;\n+\n@@ -2440,0 +2457,1 @@\n+    if (failing()) return;\n@@ -2452,0 +2470,1 @@\n+    if (failing())  return;\n@@ -4012,2 +4031,0 @@\n-        DEBUG_ONLY( n->dump_bfs(1, 0, \"-\"); );\n-        assert(false, \"malformed control flow\");\n@@ -4358,0 +4375,1 @@\n+  if (_compile->failing()) return;\n@@ -4930,0 +4948,1 @@\n+      if (failing())  return;\n@@ -5074,0 +5093,1 @@\n+  if (failing()) { return; }\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":26,"deletions":6,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -91,0 +91,48 @@\n+uint ConvertNode::ideal_reg() const {\n+  return _type->ideal_reg();\n+}\n+\n+Node* ConvertNode::create_convert(BasicType source, BasicType target, Node* input) {\n+  if (source == T_INT) {\n+    if (target == T_LONG) {\n+      return new ConvI2LNode(input);\n+    } else if (target == T_FLOAT) {\n+      return new ConvI2FNode(input);\n+    } else if (target == T_DOUBLE) {\n+      return new ConvI2DNode(input);\n+    }\n+  } else if (source == T_LONG) {\n+    if (target == T_INT) {\n+      return new ConvL2INode(input);\n+    } else if (target == T_FLOAT) {\n+      return new ConvL2FNode(input);\n+    } else if (target == T_DOUBLE) {\n+      return new ConvL2DNode(input);\n+    }\n+  } else if (source == T_FLOAT) {\n+    if (target == T_INT) {\n+      return new ConvF2INode(input);\n+    } else if (target == T_LONG) {\n+      return new ConvF2LNode(input);\n+    } else if (target == T_DOUBLE) {\n+      return new ConvF2DNode(input);\n+    } else if (target == T_SHORT) {\n+      return new ConvF2HFNode(input);\n+    }\n+  } else if (source == T_DOUBLE) {\n+    if (target == T_INT) {\n+      return new ConvD2INode(input);\n+    } else if (target == T_LONG) {\n+      return new ConvD2LNode(input);\n+    } else if (target == T_FLOAT) {\n+      return new ConvD2FNode(input);\n+    }\n+  } else if (source == T_SHORT) {\n+    if (target == T_FLOAT) {\n+      return new ConvHF2FNode(input);\n+    }\n+  }\n+\n+  assert(false, \"Couldn't create conversion for type %s to %s\", type2name(source), type2name(target));\n+  return nullptr;\n+}\n@@ -196,2 +244,3 @@\n-  if (t == Type::FLOAT) return TypeInt::SHORT;\n-  if (StubRoutines::f2hf_adr() == nullptr) return bottom_type();\n+  if (t == Type::FLOAT || StubRoutines::f2hf_adr() == nullptr) {\n+    return TypeInt::SHORT;\n+  }\n@@ -266,2 +315,3 @@\n-  if (t == TypeInt::SHORT) return Type::FLOAT;\n-  if (StubRoutines::hf2f_adr() == nullptr) return bottom_type();\n+  if (t == TypeInt::SHORT || StubRoutines::hf2f_adr() == nullptr) {\n+    return Type::FLOAT;\n+  }\n@@ -273,1 +323,1 @@\n-  return bottom_type();\n+  return Type::FLOAT;\n@@ -283,1 +333,1 @@\n-  return bottom_type();\n+  return Type::DOUBLE;\n@@ -293,1 +343,1 @@\n-  return bottom_type();\n+  return Type::FLOAT;\n@@ -713,1 +763,1 @@\n-  return bottom_type();\n+  return Type::DOUBLE;\n@@ -723,1 +773,1 @@\n-  return bottom_type();\n+  return Type::FLOAT;\n","filename":"src\/hotspot\/share\/opto\/convertnode.cpp","additions":59,"deletions":9,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -45,0 +45,15 @@\n+class ConvertNode : public TypeNode {\n+protected:\n+  ConvertNode(const Type* t, Node* input) : TypeNode(t, 2) {\n+    init_class_id(Class_Convert);\n+    init_req(1, input);\n+  }\n+public:\n+  virtual const Type* in_type() const = 0;\n+  virtual uint ideal_reg() const;\n+\n+  \/\/ Create a convert node for a given input and output type.\n+  \/\/ Conversions to and from half float are specified via T_SHORT.\n+  static Node* create_convert(BasicType source, BasicType target, Node* input);\n+};\n+\n@@ -48,1 +63,1 @@\n-class ConvD2FNode : public Node {\n+class ConvD2FNode : public ConvertNode {\n@@ -50,1 +65,1 @@\n-  ConvD2FNode( Node *in1 ) : Node(0,in1) {}\n+  ConvD2FNode(Node* in1) : ConvertNode(Type::FLOAT,in1) {}\n@@ -52,1 +67,1 @@\n-  virtual const Type *bottom_type() const { return Type::FLOAT; }\n+  virtual const Type* in_type() const { return Type::DOUBLE; }\n@@ -55,2 +70,1 @@\n-  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n-  virtual uint  ideal_reg() const { return Op_RegF; }\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n@@ -61,1 +75,1 @@\n-class ConvD2INode : public Node {\n+class ConvD2INode : public ConvertNode {\n@@ -63,1 +77,1 @@\n-  ConvD2INode( Node *in1 ) : Node(0,in1) {}\n+  ConvD2INode(Node* in1) : ConvertNode(TypeInt::INT,in1) {}\n@@ -65,1 +79,1 @@\n-  virtual const Type *bottom_type() const { return TypeInt::INT; }\n+  virtual const Type* in_type() const { return Type::DOUBLE; }\n@@ -68,2 +82,1 @@\n-  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n-  virtual uint  ideal_reg() const { return Op_RegI; }\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n@@ -74,1 +87,1 @@\n-class ConvD2LNode : public Node {\n+class ConvD2LNode : public ConvertNode {\n@@ -76,1 +89,1 @@\n-  ConvD2LNode( Node *dbl ) : Node(0,dbl) {}\n+  ConvD2LNode(Node* in1) : ConvertNode(TypeLong::LONG, in1) {}\n@@ -78,1 +91,1 @@\n-  virtual const Type *bottom_type() const { return TypeLong::LONG; }\n+  virtual const Type* in_type() const { return Type::DOUBLE; }\n@@ -81,10 +94,1 @@\n-  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n-  virtual uint ideal_reg() const { return Op_RegL; }\n-};\n-\n-class RoundDNode : public Node {\n-  public:\n-  RoundDNode( Node *dbl ) : Node(0,dbl) {}\n-  virtual int Opcode() const;\n-  virtual const Type *bottom_type() const { return TypeLong::LONG; }\n-  virtual uint ideal_reg() const { return Op_RegL; }\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n@@ -95,1 +99,1 @@\n-class ConvF2DNode : public Node {\n+class ConvF2DNode : public ConvertNode {\n@@ -97,1 +101,1 @@\n-  ConvF2DNode( Node *in1 ) : Node(0,in1) {}\n+  ConvF2DNode(Node* in1) : ConvertNode(Type::DOUBLE,in1) {}\n@@ -99,1 +103,1 @@\n-  virtual const Type *bottom_type() const { return Type::DOUBLE; }\n+  virtual const Type* in_type() const { return Type::FLOAT; }\n@@ -101,1 +105,0 @@\n-  virtual uint  ideal_reg() const { return Op_RegD; }\n@@ -106,1 +109,1 @@\n-class ConvF2HFNode : public Node {\n+class ConvF2HFNode : public ConvertNode {\n@@ -108,1 +111,1 @@\n-  ConvF2HFNode( Node *in1 ) : Node(0,in1) {}\n+  ConvF2HFNode(Node* in1) : ConvertNode(TypeInt::SHORT, in1) {}\n@@ -110,1 +113,1 @@\n-  virtual const Type *bottom_type() const { return TypeInt::SHORT; }\n+  virtual const Type* in_type() const { return TypeInt::FLOAT; }\n@@ -112,1 +115,0 @@\n-  virtual uint  ideal_reg() const { return Op_RegI; }\n@@ -117,3 +119,3 @@\n-class ConvF2INode : public Node {\n-  public:\n-  ConvF2INode( Node *in1 ) : Node(0,in1) {}\n+class ConvF2INode : public ConvertNode {\n+public:\n+  ConvF2INode(Node* in1) : ConvertNode(TypeInt::INT, in1) {}\n@@ -121,1 +123,1 @@\n-  virtual const Type *bottom_type() const { return TypeInt::INT; }\n+  virtual const Type* in_type() const { return TypeInt::FLOAT; }\n@@ -124,2 +126,1 @@\n-  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n-  virtual uint  ideal_reg() const { return Op_RegI; }\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n@@ -128,1 +129,0 @@\n-\n@@ -131,3 +131,3 @@\n-class ConvF2LNode : public Node {\n-  public:\n-  ConvF2LNode( Node *in1 ) : Node(0,in1) {}\n+class ConvF2LNode : public ConvertNode {\n+public:\n+  ConvF2LNode(Node* in1) : ConvertNode(TypeLong::LONG, in1) {}\n@@ -135,1 +135,1 @@\n-  virtual const Type *bottom_type() const { return TypeLong::LONG; }\n+  virtual const Type* in_type() const { return TypeInt::FLOAT; }\n@@ -138,2 +138,1 @@\n-  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n-  virtual uint  ideal_reg() const { return Op_RegL; }\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n@@ -144,3 +143,3 @@\n-class ConvHF2FNode : public Node {\n-  public:\n-  ConvHF2FNode( Node *in1 ) : Node(0,in1) {}\n+class ConvHF2FNode : public ConvertNode {\n+public:\n+  ConvHF2FNode(Node* in1) : ConvertNode(Type::FLOAT, in1) {}\n@@ -148,1 +147,1 @@\n-  virtual const Type *bottom_type() const { return Type::FLOAT; }\n+  virtual const Type* in_type() const { return TypeInt::SHORT; }\n@@ -150,1 +149,0 @@\n-  virtual uint  ideal_reg() const { return Op_RegF; }\n@@ -155,3 +153,3 @@\n-class ConvI2DNode : public Node {\n-  public:\n-  ConvI2DNode( Node *in1 ) : Node(0,in1) {}\n+class ConvI2DNode : public ConvertNode {\n+public:\n+  ConvI2DNode(Node* in1) : ConvertNode(Type::DOUBLE, in1) {}\n@@ -159,1 +157,1 @@\n-  virtual const Type *bottom_type() const { return Type::DOUBLE; }\n+  virtual const Type* in_type() const { return TypeInt::INT; }\n@@ -161,1 +159,0 @@\n-  virtual uint  ideal_reg() const { return Op_RegD; }\n@@ -166,3 +163,3 @@\n-class ConvI2FNode : public Node {\n-  public:\n-  ConvI2FNode( Node *in1 ) : Node(0,in1) {}\n+class ConvI2FNode : public ConvertNode {\n+public:\n+  ConvI2FNode(Node* in1) : ConvertNode(Type::FLOAT, in1) {}\n@@ -170,1 +167,1 @@\n-  virtual const Type *bottom_type() const { return Type::FLOAT; }\n+  virtual const Type* in_type() const { return TypeInt::INT; }\n@@ -173,9 +170,0 @@\n-  virtual uint  ideal_reg() const { return Op_RegF; }\n-};\n-\n-class RoundFNode : public Node {\n-  public:\n-  RoundFNode( Node *in1 ) : Node(0,in1) {}\n-  virtual int Opcode() const;\n-  virtual const Type *bottom_type() const { return TypeInt::INT; }\n-  virtual uint  ideal_reg() const { return Op_RegI; }\n@@ -186,1 +174,1 @@\n-class ConvI2LNode : public TypeNode {\n+class ConvI2LNode : public ConvertNode {\n@@ -188,3 +176,1 @@\n-  ConvI2LNode(Node *in1, const TypeLong* t = TypeLong::INT)\n-  : TypeNode(t, 2)\n-  { init_req(1, in1); }\n+  ConvI2LNode(Node* in1, const TypeLong* t = TypeLong::INT) : ConvertNode(t, in1) {}\n@@ -192,0 +178,1 @@\n+  virtual const Type* in_type() const { return TypeInt::INT; }\n@@ -193,1 +180,1 @@\n-  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n@@ -195,1 +182,0 @@\n-  virtual uint  ideal_reg() const { return Op_RegL; }\n@@ -200,3 +186,3 @@\n-class ConvL2DNode : public Node {\n-  public:\n-  ConvL2DNode( Node *in1 ) : Node(0,in1) {}\n+class ConvL2DNode : public ConvertNode {\n+public:\n+  ConvL2DNode(Node* in1) : ConvertNode(Type::DOUBLE, in1) {}\n@@ -204,1 +190,1 @@\n-  virtual const Type *bottom_type() const { return Type::DOUBLE; }\n+  virtual const Type* in_type() const { return TypeLong::LONG; }\n@@ -206,1 +192,0 @@\n-  virtual uint ideal_reg() const { return Op_RegD; }\n@@ -211,3 +196,3 @@\n-class ConvL2FNode : public Node {\n-  public:\n-  ConvL2FNode( Node *in1 ) : Node(0,in1) {}\n+class ConvL2FNode : public ConvertNode {\n+public:\n+  ConvL2FNode(Node* in1) : ConvertNode(Type::FLOAT, in1) {}\n@@ -215,1 +200,1 @@\n-  virtual const Type *bottom_type() const { return Type::FLOAT; }\n+  virtual const Type* in_type() const { return TypeLong::LONG; }\n@@ -217,1 +202,0 @@\n-  virtual uint  ideal_reg() const { return Op_RegF; }\n@@ -222,1 +206,1 @@\n-class ConvL2INode : public TypeNode {\n+class ConvL2INode : public ConvertNode {\n@@ -224,4 +208,1 @@\n-  ConvL2INode(Node *in1, const TypeInt* t = TypeInt::INT)\n-  : TypeNode(t, 2) {\n-    init_req(1, in1);\n-  }\n+  ConvL2INode(Node* in1, const TypeInt* t = TypeInt::INT) : ConvertNode(t, in1) {}\n@@ -229,0 +210,1 @@\n+  virtual const Type* in_type() const { return TypeLong::LONG; }\n@@ -231,1 +213,16 @@\n-  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n+};\n+\n+class RoundDNode : public Node {\n+public:\n+  RoundDNode(Node* in1) : Node(nullptr, in1) {}\n+  virtual int Opcode() const;\n+  virtual const Type* bottom_type() const { return TypeLong::LONG; }\n+  virtual uint ideal_reg() const { return Op_RegL; }\n+};\n+\n+class RoundFNode : public Node {\n+public:\n+  RoundFNode(Node* in1) : Node(nullptr, in1) {}\n+  virtual int Opcode() const;\n+  virtual const Type* bottom_type() const { return TypeInt::INT; }\n","filename":"src\/hotspot\/share\/opto\/convertnode.hpp","additions":86,"deletions":89,"binary":false,"changes":175,"status":"modified"},{"patch":"@@ -85,1 +85,2 @@\n-    assert(!has_exceptions(), \"user must call transfer_exceptions_into_jvms\");\n+    assert(failing() || !has_exceptions(),\n+           \"unless compilation failed, user must call transfer_exceptions_into_jvms\");\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -5370,2 +5370,0 @@\n-  const char *stubName = \"array_partition_stub\";\n-\n@@ -5380,15 +5378,6 @@\n-  const TypeInstPtr* elem_klass = gvn().type(elementType)->isa_instptr();\n-  ciType* elem_type = elem_klass->const_oop()->as_instance()->java_mirror_type();\n-  BasicType bt = elem_type->basic_type();\n-  address stubAddr = nullptr;\n-  stubAddr = StubRoutines::select_array_partition_function();\n-  \/\/ stub not loaded\n-  if (stubAddr == nullptr) {\n-    return false;\n-  }\n-  \/\/ get the address of the array\n-  const TypeAryPtr* obj_t = _gvn.type(obj)->isa_aryptr();\n-  if (obj_t == nullptr || obj_t->elem() == Type::BOTTOM ) {\n-    return false; \/\/ failed input validation\n-  }\n-  Node* obj_adr = make_unsafe_address(obj, offset);\n+  Node* pivotIndices = nullptr;\n+\n+  \/\/ Set the original stack and the reexecute bit for the interpreter to reexecute\n+  \/\/ the bytecode that invokes DualPivotQuicksort.partition() if deoptimization happens.\n+  { PreserveReexecuteState preexecs(this);\n+    jvms()->set_should_reexecute(true);\n@@ -5396,7 +5385,15 @@\n-  \/\/ create the pivotIndices array of type int and size = 2\n-  Node* size = intcon(2);\n-  Node* klass_node = makecon(TypeKlassPtr::make(ciTypeArrayKlass::make(T_INT)));\n-  Node* pivotIndices = new_array(klass_node, size, 0);  \/\/ no arguments to push\n-  AllocateArrayNode* alloc = tightly_coupled_allocation(pivotIndices);\n-  guarantee(alloc != nullptr, \"created above\");\n-  Node* pivotIndices_adr = basic_plus_adr(pivotIndices, arrayOopDesc::base_offset_in_bytes(T_INT));\n+    const TypeInstPtr* elem_klass = gvn().type(elementType)->isa_instptr();\n+    ciType* elem_type = elem_klass->const_oop()->as_instance()->java_mirror_type();\n+    BasicType bt = elem_type->basic_type();\n+    address stubAddr = nullptr;\n+    stubAddr = StubRoutines::select_array_partition_function();\n+    \/\/ stub not loaded\n+    if (stubAddr == nullptr) {\n+      return false;\n+    }\n+    \/\/ get the address of the array\n+    const TypeAryPtr* obj_t = _gvn.type(obj)->isa_aryptr();\n+    if (obj_t == nullptr || obj_t->elem() == Type::BOTTOM ) {\n+      return false; \/\/ failed input validation\n+    }\n+    Node* obj_adr = make_unsafe_address(obj, offset);\n@@ -5404,2 +5401,7 @@\n-  \/\/ pass the basic type enum to the stub\n-  Node* elemType = intcon(bt);\n+    \/\/ create the pivotIndices array of type int and size = 2\n+    Node* size = intcon(2);\n+    Node* klass_node = makecon(TypeKlassPtr::make(ciTypeArrayKlass::make(T_INT)));\n+    pivotIndices = new_array(klass_node, size, 0);  \/\/ no arguments to push\n+    AllocateArrayNode* alloc = tightly_coupled_allocation(pivotIndices);\n+    guarantee(alloc != nullptr, \"created above\");\n+    Node* pivotIndices_adr = basic_plus_adr(pivotIndices, arrayOopDesc::base_offset_in_bytes(T_INT));\n@@ -5407,5 +5409,11 @@\n-  \/\/ Call the stub\n-  make_runtime_call(RC_LEAF|RC_NO_FP, OptoRuntime::array_partition_Type(),\n-                    stubAddr, stubName, TypePtr::BOTTOM,\n-                    obj_adr, elemType, fromIndex, toIndex, pivotIndices_adr,\n-                    indexPivot1, indexPivot2);\n+    \/\/ pass the basic type enum to the stub\n+    Node* elemType = intcon(bt);\n+\n+    \/\/ Call the stub\n+    const char *stubName = \"array_partition_stub\";\n+    make_runtime_call(RC_LEAF|RC_NO_FP, OptoRuntime::array_partition_Type(),\n+                      stubAddr, stubName, TypePtr::BOTTOM,\n+                      obj_adr, elemType, fromIndex, toIndex, pivotIndices_adr,\n+                      indexPivot1, indexPivot2);\n+\n+  } \/\/ original reexecute is set back here\n@@ -5424,3 +5432,0 @@\n-  const char *stubName;\n-  stubName = \"arraysort_stub\";\n-\n@@ -5454,0 +5459,1 @@\n+  const char *stubName = \"arraysort_stub\";\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":40,"deletions":34,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -3608,3 +3608,7 @@\n-    if (PartialPeelLoop && phase->partial_peel(this, old_new)) {\n-      \/\/ Partial peel succeeded so terminate this round of loop opts\n-      return false;\n+    if (PartialPeelLoop) {\n+      bool rc = phase->partial_peel(this, old_new);\n+      if (Compile::current()->failing()) { return false; }\n+      if (rc) {\n+        \/\/ Partial peel succeeded so terminate this round of loop opts\n+        return false;\n+      }\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -4695,0 +4695,1 @@\n+  if (C->failing()) return;\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1197,1 +1197,1 @@\n-\n+      if (C->failing()) { return; }\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3688,0 +3688,1 @@\n+            if (C->failing()) return false;\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -359,1 +359,3 @@\n-  C->set_cached_top_node(xform( C->top(), live_nodes ));\n+  Node* const n = xform(C->top(), live_nodes);\n+  if (C->failing()) return;\n+  C->set_cached_top_node(n);\n@@ -362,0 +364,1 @@\n+    if (C->failing()) return;\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -73,0 +73,1 @@\n+class ConvertNode;\n@@ -734,0 +735,1 @@\n+      DEFINE_CLASS_ID(Convert, Type, 10)\n@@ -892,0 +894,1 @@\n+  DEFINE_CLASS_QUERY(Convert)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1578,0 +1578,1 @@\n+    if (failing()) return;\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1597,1 +1597,1 @@\n-    \/\/ If changed Cast input, notify down for Phi and Sub - both do \"uncast\"\n+    \/\/ If changed Cast input, notify down for Phi, Sub, and Xor - all do \"uncast\"\n@@ -1601,0 +1601,1 @@\n+    \/\/ ConstraintCast+ -> Xor\n@@ -1602,2 +1603,2 @@\n-      auto push_phi_or_sub_uses_to_worklist = [&](Node* n){\n-        if (n->is_Phi() || n->is_Sub()) {\n+      auto push_the_uses_to_worklist = [&](Node* n){\n+        if (n->is_Phi() || n->is_Sub() || n->Opcode() == Op_XorI || n->Opcode() == Op_XorL) {\n@@ -1607,1 +1608,1 @@\n-      ConstraintCastNode::visit_uncasted_uses(use, push_phi_or_sub_uses_to_worklist);\n+      ConstraintCastNode::visit_uncasted_uses(use, push_the_uses_to_worklist);\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -109,14 +109,0 @@\n-static void enqueue_use(Node* n, Node* use, Unique_Node_List& work) {\n-  if (use->is_Phi()) {\n-    Node* r = use->in(0);\n-    assert(r->is_Region(), \"Phi should have Region\");\n-    for (uint i = 1; i < use->req(); i++) {\n-      if (use->in(i) == n) {\n-        work.push(r->in(i));\n-      }\n-    }\n-  } else {\n-    work.push(use);\n-  }\n-}\n-\n@@ -129,0 +115,6 @@\n+  ResourceMark rm;\n+  Node_Stack stack(0);\n+  Unique_Node_List to_fix; \/\/ nodes to clone + uses at the end of the chain that need to updated\n+  VectorSet seen;\n+  VectorSet valid_control;\n+\n@@ -135,5 +127,3 @@\n-    ResourceMark rm;\n-    Unique_Node_List work;\n-    \/\/ Go over all the uses of the node that is considered for replacement...\n-    for (DUIterator j = initial->outs(); initial->has_out(j); j++) {\n-      Node* use = initial->out(j);\n+    if (initial->outcnt() == 0) {\n+      continue;\n+    }\n@@ -141,11 +131,20 @@\n-      if (use == improved || use->outcnt() == 0) {\n-        continue;\n-      }\n-      work.clear();\n-      enqueue_use(initial, use, work);\n-      bool replace = true;\n-      \/\/ Check that this use is dominated by ctl. Go ahead with the replacement if it is.\n-      while (work.size() != 0 && replace) {\n-        Node* n = work.pop();\n-        if (use->outcnt() == 0) {\n-          continue;\n+    \/\/ Find uses of initial that are dominated by ctl so, initial can be replaced by improved.\n+    \/\/ Proving domination here is not straightforward. To do so, we follow uses of initial, and uses of uses until we\n+    \/\/ encounter a node which is a control node or is pinned at some control. Then, we try to prove this control is\n+    \/\/ dominated by ctl. If that's the case, it's legal to replace initial by improved but for this chain of uses only.\n+    \/\/ It may not be the case for some other chain of uses, so we clone that chain and perform the replacement only for\n+    \/\/ these uses.\n+    assert(stack.is_empty(), \"\");\n+    stack.push(initial, 1);\n+    Node* use = initial->raw_out(0);\n+    stack.push(use, 0);\n+\n+    while (!stack.is_empty()) {\n+      assert(stack.size() > 1, \"at least initial + one use\");\n+      Node* n = stack.node();\n+\n+      uint current_size = stack.size();\n+\n+      if (seen.test_set(n->_idx)) {\n+        if (to_fix.member(n)) {\n+          collect_nodes_to_clone(stack, to_fix);\n@@ -153,4 +152,14 @@\n-        if (n->is_CFG() || (n->in(0) != nullptr && !n->in(0)->is_top())) {\n-          \/\/ Skip projections, since some of the multi nodes aren't CFG (e.g., LoadStore and SCMemProj).\n-          if (n->is_Proj()) {\n-            n = n->in(0);\n+      } else if (n->outcnt() != 0 && n != improved) {\n+        if (n->is_Phi()) {\n+          Node* region = n->in(0);\n+          Node* prev = stack.node_at(stack.size() - 2);\n+          for (uint j = 1; j < region->req(); ++j) {\n+            if (n->in(j) == prev) {\n+              Node* in = region->in(j);\n+              if (in != nullptr && !in->is_top()) {\n+                if (is_dominator(ctl, in)) {\n+                  valid_control.set(in->_idx);\n+                  collect_nodes_to_clone(stack, to_fix);\n+                }\n+              }\n+            }\n@@ -158,2 +167,3 @@\n-          if (!n->is_CFG()) {\n-            n = n->in(0);\n+        } else if (n->is_CFG()) {\n+          if (is_dominator(ctl, n)) {\n+            collect_nodes_to_clone(stack, to_fix);\n@@ -161,10 +171,4 @@\n-          assert(n->is_CFG(), \"should be CFG now\");\n-          int depth = 0;\n-          while(n != ctl) {\n-            n = IfNode::up_one_dom(n);\n-            depth++;\n-            \/\/ limit search depth\n-            if (depth >= 100 || n == nullptr) {\n-              replace = false;\n-              break;\n-            }\n+        } else if (n->in(0) != nullptr && n->in(0)->is_CFG()) {\n+          Node* c = n->in(0);\n+          if (is_dominator(ctl, c)) {\n+            collect_nodes_to_clone(stack, to_fix);\n@@ -173,2 +177,4 @@\n-          for (DUIterator k = n->outs(); n->has_out(k); k++) {\n-            enqueue_use(n, n->out(k), work);\n+          uint idx = stack.index();\n+          if (idx < n->outcnt()) {\n+            stack.set_index(idx + 1);\n+            stack.push(n->raw_out(idx), 0);\n@@ -178,5 +184,13 @@\n-      if (replace) {\n-        bool is_in_table = C->initial_gvn()->hash_delete(use);\n-        int replaced = use->replace_edge(initial, improved);\n-        if (is_in_table) {\n-          C->initial_gvn()->hash_find_insert(use);\n+      if (stack.size() == current_size) {\n+        for (;;) {\n+          stack.pop();\n+          if (stack.is_empty()) {\n+            break;\n+          }\n+          n = stack.node();\n+          uint idx = stack.index();\n+          if (idx < n->outcnt()) {\n+            stack.set_index(idx + 1);\n+            stack.push(n->raw_out(idx), 0);\n+            break;\n+          }\n@@ -184,1 +198,25 @@\n-        C->record_for_igvn(use);\n+      }\n+    }\n+  }\n+  if (to_fix.size() > 0) {\n+    uint hash_table_size = _replaced_nodes->length();\n+    for (uint i = 0; i < to_fix.size(); ++i) {\n+      Node* n = to_fix.at(i);\n+      if (n->is_CFG() || n->in(0) != nullptr) { \/\/ End of a chain is not cloned\n+        continue;\n+      }\n+      hash_table_size++;\n+    }\n+    \/\/ Map from current node to cloned\/replaced node\n+    ResizeableResourceHashtable<Node*, Node*, AnyObj::RESOURCE_AREA, mtCompiler> clones(hash_table_size, hash_table_size);\n+    \/\/ Record mapping from initial to improved nodes\n+    for (int i = 0; i < _replaced_nodes->length(); i++) {\n+      ReplacedNode replaced = _replaced_nodes->at(i);\n+      Node* initial = replaced.initial();\n+      Node* improved = replaced.improved();\n+      clones.put(initial, improved);\n+      \/\/ If initial needs to be cloned but is also improved then there's no need to clone it.\n+      if (to_fix.member(initial)) {\n+        to_fix.remove(initial);\n+      }\n+    }\n@@ -186,2 +224,5 @@\n-        assert(replaced > 0, \"inconsistent\");\n-        --j;\n+    \/\/ Clone nodes and record mapping from current to cloned nodes\n+    for (uint i = 0; i < to_fix.size(); ++i) {\n+      Node* n = to_fix.at(i);\n+      if (n->is_CFG() || n->in(0) != nullptr) { \/\/ End of a chain\n+        continue;\n@@ -189,0 +230,45 @@\n+      Node* clone = n->clone();\n+      bool added = clones.put(n, clone);\n+      assert(added, \"clone node must be added to mapping\");\n+      C->initial_gvn()->set_type_bottom(clone);\n+      to_fix.map(i, clone); \/\/ Update list of nodes with cloned node\n+    }\n+\n+    \/\/ Fix edges in cloned nodes and use at the end of the chain\n+    for (uint i = 0; i < to_fix.size(); ++i) {\n+      Node* n = to_fix.at(i);\n+      bool is_in_table = C->initial_gvn()->hash_delete(n);\n+      uint updates = 0;\n+      for (uint j = 0; j < n->req(); ++j) {\n+        Node* in = n->in(j);\n+        if (in == nullptr || (n->is_Phi() && n->in(0)->in(j) == nullptr)) {\n+          continue;\n+        }\n+        if (n->is_Phi() && !valid_control.test(n->in(0)->in(j)->_idx)) {\n+          continue;\n+        }\n+        Node** clone_ptr = clones.get(in);\n+        if (clone_ptr != nullptr) {\n+          Node* clone = *clone_ptr;\n+          n->set_req(j, clone);\n+          updates++;\n+        }\n+      }\n+      assert(updates > 0, \"\");\n+      C->record_for_igvn(n);\n+      if (is_in_table) {\n+        C->initial_gvn()->hash_find_insert(n);\n+      }\n+    }\n+  }\n+}\n+\n+bool ReplacedNodes::is_dominator(const Node* ctl, Node* n) const {\n+  assert(n->is_CFG(), \"should be CFG now\");\n+  int depth = 0;\n+  while (n != ctl) {\n+    n = IfNode::up_one_dom(n);\n+    depth++;\n+    \/\/ limit search depth\n+    if (depth >= 100 || n == nullptr) {\n+      return false;\n@@ -191,0 +277,1 @@\n+  return true;\n@@ -227,0 +314,7 @@\n+\n+void ReplacedNodes::collect_nodes_to_clone(const Node_Stack& stack, Unique_Node_List& to_fix) {\n+  for (uint i = stack.size() - 1; i >= 1; i--) {\n+    Node* n = stack.node_at(i);\n+    to_fix.push(n);\n+  }\n+}\n","filename":"src\/hotspot\/share\/opto\/replacednodes.cpp","additions":150,"deletions":56,"binary":false,"changes":206,"status":"modified"},{"patch":"@@ -79,0 +79,4 @@\n+\n+  bool is_dominator(const Node* ctl, Node* n) const;\n+\n+  void collect_nodes_to_clone(const Node_Stack& stack, Unique_Node_List& to_fix);\n","filename":"src\/hotspot\/share\/opto\/replacednodes.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -3609,1 +3610,1 @@\n-  if (!Arguments::is_dumping_archive()) {\n+  if (!CDSConfig::is_dumping_archive()) {\n@@ -3697,1 +3698,1 @@\n-  return Arguments::is_dumping_archive();\n+  return CDSConfig::is_dumping_archive();\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -626,1 +627,1 @@\n-  assert(Arguments::is_dumping_archive(), \"invariant\");\n+  assert(CDSConfig::is_dumping_archive(), \"invariant\");\n@@ -642,1 +643,1 @@\n-  if (Arguments::is_dumping_archive()) {\n+  if (CDSConfig::is_dumping_archive()) {\n","filename":"src\/hotspot\/share\/prims\/jvmtiAgent.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -77,1 +77,1 @@\n-JavaThread* UpcallLinker::on_entry(UpcallStub::FrameData* context) {\n+JavaThread* UpcallLinker::on_entry(UpcallStub::FrameData* context, jobject receiver) {\n@@ -112,0 +112,2 @@\n+  thread->set_vm_result(JNIHandles::resolve(receiver));\n+\n","filename":"src\/hotspot\/share\/prims\/upcallLinker.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-  static void handle_uncaught_exception(oop exception);\n@@ -38,1 +37,1 @@\n-  static JavaThread* on_entry(UpcallStub::FrameData* context);\n+  static JavaThread* on_entry(UpcallStub::FrameData* context, jobject receiver);\n@@ -47,0 +46,3 @@\n+\n+  \/\/ public for stubGenerator\n+  static void handle_uncaught_exception(oop exception);\n","filename":"src\/hotspot\/share\/prims\/upcallLinker.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -384,1 +384,1 @@\n-    return jvmciEnv.runtime()->is_gc_supported(&jvmciEnv, (CollectedHeap::Name)name);\n+    return jvmciEnv.init_error() == JNI_OK && jvmciEnv.runtime()->is_gc_supported(&jvmciEnv, (CollectedHeap::Name)name);\n@@ -731,1 +731,1 @@\n-  Arena* arena =  new (mtTest) Arena(mtTest, size_t(init_size));\n+  Arena* arena =  new (mtTest) Arena(mtTest, Arena::Tag::tag_other, size_t(init_size));\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -133,0 +134,3 @@\n+\/\/ True if -Xint\/-Xmixed\/-Xcomp were specified\n+static bool mode_flag_cmd_line = false;\n+\n@@ -1335,1 +1339,1 @@\n-  assert(is_dumping_archive(),\n+  assert(CDSConfig::is_dumping_archive(),\n@@ -2602,0 +2606,1 @@\n+          mode_flag_cmd_line = true;\n@@ -2605,0 +2610,1 @@\n+          mode_flag_cmd_line = true;\n@@ -2609,0 +2615,1 @@\n+          mode_flag_cmd_line = true;\n@@ -3033,8 +3040,12 @@\n-    \/\/ Compiler threads may concurrently update the class metadata (such as method entries), so it's\n-    \/\/ unsafe with -Xshare:dump (which modifies the class metadata in place). Let's disable\n-    \/\/ compiler just to be safe.\n-    \/\/\n-    \/\/ Note: this is not a concern for dynamically dumping shared spaces, which makes a copy of the\n-    \/\/ class metadata instead of modifying them in place. The copy is inaccessible to the compiler.\n-    \/\/ TODO: revisit the following for the static archive case.\n-    set_mode_flags(_int);\n+    if (!mode_flag_cmd_line) {\n+      \/\/ By default, -Xshare:dump runs in interpreter-only mode, which is required for deterministic archive.\n+      \/\/\n+      \/\/ If your classlist is large and you don't care about deterministic dumping, you can use\n+      \/\/ -Xshare:dump -Xmixed to improve dumping speed.\n+      set_mode_flags(_int);\n+    } else if (_mode == _comp) {\n+      \/\/ -Xcomp may use excessive CPU for the test tiers. Also, -Xshare:dump runs a small and fixed set of\n+      \/\/ Java code, so there's not much benefit in running -Xcomp.\n+      log_info(cds)(\"reduced -Xcomp to -Xmixed for static dumping\");\n+      set_mode_flags(_mixed);\n+    }\n@@ -3454,1 +3465,1 @@\n-    if (is_dumping_archive() && archives > 1) {\n+    if (CDSConfig::is_dumping_archive() && archives > 1) {\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":21,"deletions":10,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -528,6 +528,0 @@\n-  static bool is_dumping_archive() { return DumpSharedSpaces || DynamicDumpSharedSpaces; }\n-\n-  static void assert_is_dumping_archive() {\n-    assert(Arguments::is_dumping_archive(), \"dump time only\");\n-  }\n-\n","filename":"src\/hotspot\/share\/runtime\/arguments.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -401,3 +401,3 @@\n-  \/\/ Support platforms that do not provide Read-Modify-Write\n-  \/\/ byte-level atomic access. To use, derive PlatformCmpxchg<1> from\n-  \/\/ this class.\n+  \/\/ Support platforms that do not provide Read-Modify-Write atomic\n+  \/\/ accesses for 1-byte and 8-byte widths. To use, derive PlatformCmpxchg<1>,\n+  \/\/ PlatformAdd<S>, PlatformXchg<S> from these classes.\n@@ -406,0 +406,4 @@\n+  template<size_t byte_size>\n+  struct XchgUsingCmpxchg;\n+  template<size_t byte_size>\n+  class AddUsingCmpxchg;\n@@ -680,0 +684,41 @@\n+\/\/ Define the class before including platform file, which may use this\n+\/\/ as a base class, requiring it be complete.  The definition is later\n+\/\/ in this file, near the other definitions related to xchg.\n+template<size_t byte_size>\n+struct Atomic::XchgUsingCmpxchg {\n+  template<typename T>\n+  T operator()(T volatile* dest,\n+               T exchange_value,\n+               atomic_memory_order order) const;\n+};\n+\n+\/\/ Define the class before including platform file, which may use this\n+\/\/ as a base class, requiring it be complete.\n+template<size_t byte_size>\n+class Atomic::AddUsingCmpxchg {\n+public:\n+  template<typename D, typename I>\n+  static inline D add_then_fetch(D volatile* dest,\n+                                 I add_value,\n+                                 atomic_memory_order order) {\n+    D addend = add_value;\n+    return fetch_then_add(dest, add_value, order) + add_value;\n+  }\n+\n+  template<typename D, typename I>\n+  static inline D fetch_then_add(D volatile* dest,\n+                          I add_value,\n+                          atomic_memory_order order) {\n+    STATIC_ASSERT(byte_size == sizeof(I));\n+    STATIC_ASSERT(byte_size == sizeof(D));\n+\n+    D old_value;\n+    D new_value;\n+    do {\n+      old_value = Atomic::load(dest);\n+      new_value = old_value + add_value;\n+    } while (old_value != Atomic::cmpxchg(dest, old_value, new_value, order));\n+    return old_value;\n+  }\n+};\n+\n@@ -1173,0 +1218,14 @@\n+template<size_t byte_size>\n+template<typename T>\n+inline T Atomic::XchgUsingCmpxchg<byte_size>::operator()(T volatile* dest,\n+                                             T exchange_value,\n+                                             atomic_memory_order order) const {\n+  STATIC_ASSERT(byte_size == sizeof(T));\n+\n+  T old_value;\n+  do {\n+    old_value = Atomic::load(dest);\n+  } while (old_value != Atomic::cmpxchg(dest, old_value, exchange_value, order));\n+  return old_value;\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/atomic.hpp","additions":62,"deletions":3,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -69,13 +69,16 @@\n-  if (displaced_header().is_neutral()) {\n-    \/\/ The object is locked and the resulting ObjectMonitor* will also be\n-    \/\/ locked so it can't be async deflated until ownership is dropped.\n-    ObjectSynchronizer::inflate_helper(obj);\n-    \/\/ WARNING: We cannot put a check here, because the inflation\n-    \/\/ will not update the displaced header. Once BasicLock is inflated,\n-    \/\/ no one should ever look at its content.\n-  } else {\n-    \/\/ Typically the displaced header will be 0 (recursive stack lock) or\n-    \/\/ unused_mark.  Naively we'd like to assert that the displaced mark\n-    \/\/ value is either 0, neutral, or 3.  But with the advent of the\n-    \/\/ store-before-CAS avoidance in fast_lock\/compiler_lock_object\n-    \/\/ we can find any flavor mark in the displaced mark.\n+  if (LockingMode == LM_LEGACY) {\n+    if (displaced_header().is_neutral()) {\n+      \/\/ The object is locked and the resulting ObjectMonitor* will also be\n+      \/\/ locked so it can't be async deflated until ownership is dropped.\n+      ObjectSynchronizer::inflate_helper(obj);\n+      \/\/ WARNING: We cannot put a check here, because the inflation\n+      \/\/ will not update the displaced header. Once BasicLock is inflated,\n+      \/\/ no one should ever look at its content.\n+    } else {\n+      \/\/ Typically the displaced header will be 0 (recursive stack lock) or\n+      \/\/ unused_mark.  Naively we'd like to assert that the displaced mark\n+      \/\/ value is either 0, neutral, or 3.  But with the advent of the\n+      \/\/ store-before-CAS avoidance in fast_lock\/compiler_lock_object\n+      \/\/ we can find any flavor mark in the displaced mark.\n+    }\n+    dest->set_displaced_header(displaced_header());\n@@ -83,1 +86,5 @@\n-  dest->set_displaced_header(displaced_header());\n+#ifdef ASSERT\n+  else {\n+    dest->set_displaced_header(markWord(badDispHeaderDeopt));\n+  }\n+#endif\n","filename":"src\/hotspot\/share\/runtime\/basicLock.cpp","additions":21,"deletions":14,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -41,5 +41,3 @@\n-  : _thread(map->thread()),\n-    _entry(Continuation::get_continuation_entry_for_continuation(_thread, map->stack_chunk()->cont())),\n-    _continuation(map->stack_chunk()->cont())\n-  {\n-  assert(oopDesc::is_oop(_continuation),\"Invalid cont: \" INTPTR_FORMAT, p2i((void*)_continuation));\n+  : ContinuationWrapper(map->thread(),\n+                        Continuation::get_continuation_entry_for_continuation(map->thread(), map->stack_chunk()->cont()),\n+                        map->stack_chunk()->cont()) {\n@@ -49,2 +47,0 @@\n-  disallow_safepoint();\n-  read();\n@@ -99,1 +95,0 @@\n-\n","filename":"src\/hotspot\/share\/runtime\/continuationWrapper.cpp","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+  bool               _done;\n@@ -61,0 +62,1 @@\n+      assert(!_done, \"\");\n@@ -72,1 +74,1 @@\n-      if (_continuation != nullptr && _current_thread->is_Java_thread()) {\n+      if (!_done && _current_thread->is_Java_thread()) {\n@@ -78,0 +80,2 @@\n+  ContinuationWrapper(JavaThread* thread, ContinuationEntry* entry, oop continuation);\n+\n@@ -81,1 +85,2 @@\n-    _continuation = nullptr;\n+    _done = true;\n+    *reinterpret_cast<intptr_t*>(&_continuation) = badHeapOopVal;\n@@ -143,3 +148,2 @@\n-inline ContinuationWrapper::ContinuationWrapper(JavaThread* thread, oop continuation)\n-  : _thread(thread), _entry(thread->last_continuation()), _continuation(continuation)\n-  {\n+inline ContinuationWrapper::ContinuationWrapper(JavaThread* thread, ContinuationEntry* entry, oop continuation)\n+  : _thread(thread), _entry(entry), _continuation(continuation), _done(false) {\n@@ -152,0 +156,3 @@\n+inline ContinuationWrapper::ContinuationWrapper(JavaThread* thread, oop continuation)\n+  : ContinuationWrapper(thread, thread->last_continuation(), continuation) {}\n+\n@@ -153,7 +160,1 @@\n-  : _thread(nullptr), _entry(nullptr), _continuation(continuation)\n-  {\n-  assert(oopDesc::is_oop(_continuation),\n-         \"Invalid continuation object: \" INTPTR_FORMAT, p2i((void*)_continuation));\n-  disallow_safepoint();\n-  read();\n-}\n+  : ContinuationWrapper(nullptr, nullptr, continuation) {}\n","filename":"src\/hotspot\/share\/runtime\/continuationWrapper.inline.hpp","additions":13,"deletions":12,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -190,1 +190,1 @@\n-  HandleArea(HandleArea* prev) : Arena(mtThread, Chunk::tiny_size) {\n+  HandleArea(HandleArea* prev) : Arena(mtThread, Tag::tag_ha, Chunk::tiny_size) {\n","filename":"src\/hotspot\/share\/runtime\/handles.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"compiler\/compilationMemoryStatistic.hpp\"\n@@ -228,0 +229,7 @@\n+#else\n+\n+void print_method_invocation_histogram() {}\n+void print_bytecode_count() {}\n+\n+#endif \/\/ PRODUCT\n+\n@@ -337,46 +345,2 @@\n-  ThreadsSMRSupport::log_statistics();\n-}\n-\n-#else \/\/ PRODUCT MODE STATISTICS\n-\n-void print_statistics() {\n-\n-  if (PrintMethodData) {\n-    print_method_profiling_data();\n-  }\n-\n-  if (CITime) {\n-    CompileBroker::print_times();\n-  }\n-\n-#ifdef COMPILER2_OR_JVMCI\n-  if ((LogVMOutput || LogCompilation) && UseCompiler) {\n-    \/\/ Only print the statistics to the log file\n-    FlagSetting fs(DisplayVMOutput, false);\n-    Deoptimization::print_statistics();\n-  }\n-#endif \/* COMPILER2 || INCLUDE_JVMCI *\/\n-\n-  if (PrintCodeCache) {\n-    MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n-    CodeCache::print();\n-  }\n-\n-  \/\/ CodeHeap State Analytics.\n-  if (PrintCodeHeapAnalytics) {\n-    CompileBroker::print_heapinfo(nullptr, \"all\", 4096); \/\/ details\n-  }\n-\n-#ifdef COMPILER2\n-  if (PrintPreciseRTMLockingStatistics) {\n-    OptoRuntime::print_named_counters();\n-  }\n-#endif\n-\n-  \/\/ Native memory tracking data\n-  if (PrintNMTStatistics) {\n-    MemTracker::final_report(tty);\n-  }\n-\n-  if (PrintMetaspaceStatisticsAtExit) {\n-    MetaspaceUtils::print_basic_report(tty, 0);\n+  if (CompilerOracle::should_print_final_memstat_report()) {\n+    CompilationMemoryStatistic::print_all_by_size(tty, false, 0);\n@@ -388,2 +352,0 @@\n-#endif\n-\n","filename":"src\/hotspot\/share\/runtime\/java.cpp","additions":10,"deletions":48,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -50,4 +50,8 @@\n-  JavaThread* thread = JavaThread::current();\n-  bool is_owning = &thread->lock_stack() == this;\n-  assert(is_owning == (get_thread() == thread), \"is_owning sanity\");\n-  return is_owning;\n+  Thread* current = Thread::current();\n+  if (current->is_Java_thread()) {\n+    JavaThread* thread = JavaThread::cast(current);\n+    bool is_owning = &thread->lock_stack() == this;\n+    assert(is_owning == (get_thread() == thread), \"is_owning sanity\");\n+    return is_owning;\n+  }\n+  return false;\n","filename":"src\/hotspot\/share\/runtime\/lockStack.inline.hpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -142,0 +142,1 @@\n+Mutex*   NMTCompilationCostHistory_lock = nullptr;\n@@ -297,1 +298,1 @@\n-  MUTEX_DEFN(JfrStacktrace_lock              , PaddedMutex  , stackwatermark-1);\n+  MUTEX_DEFN(JfrStacktrace_lock              , PaddedMutex  , event);\n@@ -312,0 +313,1 @@\n+  MUTEX_DEFN(NMTCompilationCostHistory_lock  , PaddedMutex  , nosafepoint);\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -120,0 +120,1 @@\n+extern Mutex*   NMTCompilationCostHistory_lock;  \/\/ guards NMT compilation cost history\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -523,1 +523,1 @@\n-    return ((UpcallStub*)blob)->exception_handler();\n+    return StubRoutines::upcall_stub_exception_handler();\n@@ -3260,6 +3260,11 @@\n-      \/\/ Inflate so the object's header no longer refers to the BasicLock.\n-      if (lock->displaced_header().is_unlocked()) {\n-        \/\/ The object is locked and the resulting ObjectMonitor* will also be\n-        \/\/ locked so it can't be async deflated until ownership is dropped.\n-        \/\/ See the big comment in basicLock.cpp: BasicLock::move_to().\n-        ObjectSynchronizer::inflate_helper(kptr2->obj());\n+      if (LockingMode == LM_LEGACY) {\n+        \/\/ Inflate so the object's header no longer refers to the BasicLock.\n+        if (lock->displaced_header().is_unlocked()) {\n+          \/\/ The object is locked and the resulting ObjectMonitor* will also be\n+          \/\/ locked so it can't be async deflated until ownership is dropped.\n+          \/\/ See the big comment in basicLock.cpp: BasicLock::move_to().\n+          ObjectSynchronizer::inflate_helper(kptr2->obj());\n+        }\n+        \/\/ Now the displaced header is free to move because the\n+        \/\/ object's header no longer refers to it.\n+        buf[i] = (intptr_t)lock->displaced_header().value();\n@@ -3267,3 +3272,6 @@\n-      \/\/ Now the displaced header is free to move because the\n-      \/\/ object's header no longer refers to it.\n-      buf[i++] = (intptr_t)lock->displaced_header().value();\n+#ifdef ASSERT\n+      else {\n+        buf[i] = badDispHeaderOSR;\n+      }\n+#endif\n+      i++;\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":18,"deletions":10,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -578,1 +578,0 @@\n-  static void print_statistics();\n@@ -582,0 +581,2 @@\n+\n+  static void print_statistics() PRODUCT_RETURN;\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -191,0 +191,2 @@\n+address StubRoutines::_upcall_stub_exception_handler = nullptr;\n+\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -272,0 +272,2 @@\n+  static address _upcall_stub_exception_handler;\n+\n@@ -468,0 +470,5 @@\n+  static address upcall_stub_exception_handler() {\n+    assert(_upcall_stub_exception_handler != nullptr, \"not implemented\");\n+    return _upcall_stub_exception_handler;\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+class CompilerThread;\n@@ -327,0 +328,6 @@\n+  \/\/ Convenience cast functions\n+  CompilerThread* as_Compiler_thread() const {\n+    assert(is_Compiler_thread(), \"Must be compiler thread\");\n+    return (CompilerThread*)this;\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1496,0 +1496,1 @@\n+  declare_c2_type(ConvertNode, TypeNode)                                  \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+#include \"compiler\/compilationMemoryStatistic.hpp\"\n+#include \"compiler\/compiler_globals.hpp\"\n@@ -141,0 +143,1 @@\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<CompilationMemoryStatisticDCmd>(full_export, true, false));\n@@ -1137,0 +1140,14 @@\n+\n+CompilationMemoryStatisticDCmd::CompilationMemoryStatisticDCmd(outputStream* output, bool heap) :\n+    DCmdWithParser(output, heap),\n+  _human_readable(\"-H\", \"Human readable format\", \"BOOLEAN\", false, \"false\"),\n+  _minsize(\"-s\", \"Minimum memory size\", \"MEMORY SIZE\", false, \"0\") {\n+  _dcmdparser.add_dcmd_option(&_human_readable);\n+  _dcmdparser.add_dcmd_option(&_minsize);\n+}\n+\n+void CompilationMemoryStatisticDCmd::execute(DCmdSource source, TRAPS) {\n+  const bool human_readable = _human_readable.value();\n+  const size_t minsize = _minsize.has_value() ? _minsize.value()._size : 0;\n+  CompilationMemoryStatistic::print_all_by_size(output(), human_readable, minsize);\n+}\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -957,0 +957,24 @@\n+class CompilationMemoryStatisticDCmd: public DCmdWithParser {\n+protected:\n+  DCmdArgument<bool> _human_readable;\n+  DCmdArgument<MemorySizeArgument> _minsize;\n+public:\n+  static int num_arguments() { return 2; }\n+  CompilationMemoryStatisticDCmd(outputStream* output, bool heap);\n+  static const char* name() {\n+    return \"Compiler.memory\";\n+  }\n+  static const char* description() {\n+    return \"Print compilation footprint\";\n+  }\n+  static const char* impact() {\n+    return \"Medium: Pause time depends on number of compiled methods\";\n+  }\n+  static const JavaPermission permission() {\n+    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n+                        \"monitor\", nullptr};\n+    return p;\n+  }\n+  virtual void execute(DCmdSource source, TRAPS);\n+};\n+\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"oops\/fieldStreams.inline.hpp\"\n@@ -46,0 +47,1 @@\n+#include \"runtime\/continuationWrapper.inline.hpp\"\n@@ -52,1 +54,0 @@\n-#include \"runtime\/reflectionUtils.hpp\"\n@@ -937,1 +938,1 @@\n-  for (FieldStream fld(ik, false, false); !fld.eos(); fld.next()) {\n+  for (HierarchicalFieldStream<JavaFieldStream> fld(ik); !fld.done(); fld.next()) {\n@@ -949,1 +950,1 @@\n-  for (FieldStream fldc(ik, true, true); !fldc.eos(); fldc.next()) {\n+  for (JavaFieldStream fldc(ik); !fldc.done(); fldc.next()) {\n@@ -983,1 +984,1 @@\n-  for (FieldStream fld(ik, true, true); !fld.eos(); fld.next()) {\n+  for (JavaFieldStream fld(ik); !fld.done(); fld.next()) {\n@@ -1017,1 +1018,1 @@\n-  for (FieldStream fld(ik, false, false); !fld.eos(); fld.next()) {\n+  for (HierarchicalFieldStream<JavaFieldStream> fld(ik); !fld.done(); fld.next()) {\n@@ -1029,1 +1030,1 @@\n-  for (FieldStream fldc(ik, true, true); !fldc.eos(); fldc.next()) {\n+  for (JavaFieldStream fldc(ik); !fldc.done(); fldc.next()) {\n@@ -1041,1 +1042,1 @@\n-  for (FieldStream fld(ik, true, true); !fld.eos(); fld.next()) {\n+  for (JavaFieldStream fld(ik); !fld.done(); fld.next()) {\n@@ -1388,1 +1389,0 @@\n-\n@@ -1454,0 +1454,304 @@\n+\/\/ Support class used to generate HPROF_GC_ROOT_JAVA_FRAME records.\n+\n+class JavaStackRefDumper : public StackObj {\n+private:\n+  AbstractDumpWriter* _writer;\n+  u4 _thread_serial_num;\n+  int _frame_num;\n+  AbstractDumpWriter* writer() const { return _writer; }\n+public:\n+  JavaStackRefDumper(AbstractDumpWriter* writer, u4 thread_serial_num)\n+      : _writer(writer), _thread_serial_num(thread_serial_num), _frame_num(-1) \/\/ default - empty stack\n+  {\n+  }\n+\n+  void set_frame_number(int n) { _frame_num = n; }\n+\n+  void dump_java_stack_refs(StackValueCollection* values);\n+};\n+\n+void JavaStackRefDumper::dump_java_stack_refs(StackValueCollection* values) {\n+  for (int index = 0; index < values->size(); index++) {\n+    if (values->at(index)->type() == T_OBJECT) {\n+      oop o = values->obj_at(index)();\n+      if (o != nullptr) {\n+        u4 size = 1 + sizeof(address) + 4 + 4;\n+        writer()->start_sub_record(HPROF_GC_ROOT_JAVA_FRAME, size);\n+        writer()->write_objectID(o);\n+        writer()->write_u4(_thread_serial_num);\n+        writer()->write_u4((u4)_frame_num);\n+        writer()->end_sub_record();\n+      }\n+    }\n+  }\n+}\n+\n+\/\/ Class to collect, store and dump thread-related data:\n+\/\/ - HPROF_TRACE and HPROF_FRAME records;\n+\/\/ - HPROF_GC_ROOT_THREAD_OBJ\/HPROF_GC_ROOT_JAVA_FRAME\/HPROF_GC_ROOT_JNI_LOCAL subrecords.\n+class ThreadDumper : public CHeapObj<mtInternal> {\n+public:\n+  enum class ThreadType { Platform, MountedVirtual, UnmountedVirtual };\n+\n+private:\n+  ThreadType _thread_type;\n+  JavaThread* _java_thread;\n+  oop _thread_oop;\n+\n+  GrowableArray<StackFrameInfo*>* _frames;\n+  \/\/ non-null if the thread is OOM thread\n+  Method* _oome_constructor;\n+  int _thread_serial_num;\n+  int _start_frame_serial_num;\n+\n+  vframe* get_top_frame() const;\n+\n+public:\n+  static bool should_dump_pthread(JavaThread* thread) {\n+    return thread->threadObj() != nullptr && !thread->is_exiting() && !thread->is_hidden_from_external_view();\n+  }\n+\n+  static bool should_dump_vthread(oop vt) {\n+    return java_lang_VirtualThread::state(vt) != java_lang_VirtualThread::NEW\n+        && java_lang_VirtualThread::state(vt) != java_lang_VirtualThread::TERMINATED;\n+  }\n+\n+  ThreadDumper(ThreadType thread_type, JavaThread* java_thread, oop thread_oop);\n+\n+  \/\/ affects frame_count\n+  void add_oom_frame(Method* oome_constructor) {\n+    assert(_start_frame_serial_num == 0, \"add_oom_frame cannot be called after init_serial_nums\");\n+    _oome_constructor = oome_constructor;\n+  }\n+\n+  void init_serial_nums(volatile int* thread_counter, volatile int* frame_counter) {\n+    assert(_start_frame_serial_num == 0, \"already initialized\");\n+    _thread_serial_num = Atomic::fetch_then_add(thread_counter, 1);\n+    _start_frame_serial_num = Atomic::fetch_then_add(frame_counter, frame_count());\n+  }\n+\n+  bool oom_thread() const {\n+    return _oome_constructor != nullptr;\n+  }\n+\n+  int frame_count() const {\n+    return _frames->length() + (oom_thread() ? 1 : 0);\n+  }\n+\n+  u4 thread_serial_num() const {\n+    return (u4)_thread_serial_num;\n+  }\n+\n+  u4 stack_trace_serial_num() const {\n+    return (u4)(_thread_serial_num + STACK_TRACE_ID);\n+  }\n+\n+  \/\/ writes HPROF_TRACE and HPROF_FRAME records\n+  \/\/ returns number of dumped frames\n+  void dump_stack_traces(AbstractDumpWriter* writer, GrowableArray<Klass*>* klass_map);\n+\n+  \/\/ writes HPROF_GC_ROOT_THREAD_OBJ subrecord\n+  void dump_thread_obj(AbstractDumpWriter* writer);\n+\n+  \/\/ Walk the stack of the thread.\n+  \/\/ Dumps a HPROF_GC_ROOT_JAVA_FRAME subrecord for each local\n+  \/\/ Dumps a HPROF_GC_ROOT_JNI_LOCAL subrecord for each JNI local\n+  void dump_stack_refs(AbstractDumpWriter* writer);\n+\n+};\n+\n+ThreadDumper::ThreadDumper(ThreadType thread_type, JavaThread* java_thread, oop thread_oop)\n+    : _thread_type(thread_type), _java_thread(java_thread), _thread_oop(thread_oop),\n+      _oome_constructor(nullptr),\n+      _thread_serial_num(0), _start_frame_serial_num(0)\n+{\n+  \/\/ sanity checks\n+  if (_thread_type == ThreadType::UnmountedVirtual) {\n+    assert(_java_thread == nullptr, \"sanity\");\n+    assert(_thread_oop != nullptr, \"sanity\");\n+  } else {\n+    assert(_java_thread != nullptr, \"sanity\");\n+    assert(_thread_oop != nullptr, \"sanity\");\n+  }\n+\n+  _frames = new (mtServiceability) GrowableArray<StackFrameInfo*>(10, mtServiceability);\n+  bool stop_at_vthread_entry = _thread_type == ThreadType::MountedVirtual;\n+\n+  \/\/ vframes are resource allocated\n+  Thread* current_thread = Thread::current();\n+  ResourceMark rm(current_thread);\n+  HandleMark hm(current_thread);\n+\n+  for (vframe* vf = get_top_frame(); vf != nullptr; vf = vf->sender()) {\n+    if (stop_at_vthread_entry && vf->is_vthread_entry()) {\n+      break;\n+    }\n+    if (vf->is_java_frame()) {\n+      javaVFrame* jvf = javaVFrame::cast(vf);\n+      _frames->append(new StackFrameInfo(jvf, false));\n+    } else {\n+      \/\/ ignore non-Java frames\n+    }\n+  }\n+}\n+\n+void ThreadDumper::dump_stack_traces(AbstractDumpWriter* writer, GrowableArray<Klass*>* klass_map) {\n+  assert(_thread_serial_num != 0 && _start_frame_serial_num != 0, \"serial_nums are not initialized\");\n+\n+  \/\/ write HPROF_FRAME records for this thread's stack trace\n+  int depth = _frames->length();\n+  int frame_serial_num = _start_frame_serial_num;\n+\n+  if (oom_thread()) {\n+    \/\/ OOM thread\n+    \/\/ write fake frame that makes it look like the thread, which caused OOME,\n+    \/\/ is in the OutOfMemoryError zero-parameter constructor\n+    int oome_serial_num = klass_map->find(_oome_constructor->method_holder());\n+    \/\/ the class serial number starts from 1\n+    assert(oome_serial_num > 0, \"OutOfMemoryError class not found\");\n+    DumperSupport::dump_stack_frame(writer, ++frame_serial_num, oome_serial_num, _oome_constructor, 0);\n+    depth++;\n+  }\n+\n+  for (int j = 0; j < _frames->length(); j++) {\n+    StackFrameInfo* frame = _frames->at(j);\n+    Method* m = frame->method();\n+    int class_serial_num = klass_map->find(m->method_holder());\n+    \/\/ the class serial number starts from 1\n+    assert(class_serial_num > 0, \"class not found\");\n+    DumperSupport::dump_stack_frame(writer, ++frame_serial_num, class_serial_num, m, frame->bci());\n+  }\n+\n+  \/\/ write HPROF_TRACE record for the thread\n+  DumperSupport::write_header(writer, HPROF_TRACE, checked_cast<u4>(3 * sizeof(u4) + depth * oopSize));\n+  writer->write_u4(stack_trace_serial_num());   \/\/ stack trace serial number\n+  writer->write_u4(thread_serial_num());        \/\/ thread serial number\n+  writer->write_u4((u4)depth);                  \/\/ frame count (including oom frame)\n+  for (int j = 1; j <= depth; j++) {\n+    writer->write_id(_start_frame_serial_num + j);\n+  }\n+}\n+\n+void ThreadDumper::dump_thread_obj(AbstractDumpWriter * writer) {\n+  assert(_thread_serial_num != 0 && _start_frame_serial_num != 0, \"serial_num is not initialized\");\n+\n+  u4 size = 1 + sizeof(address) + 4 + 4;\n+  writer->start_sub_record(HPROF_GC_ROOT_THREAD_OBJ, size);\n+  writer->write_objectID(_thread_oop);\n+  writer->write_u4(thread_serial_num());      \/\/ thread serial number\n+  writer->write_u4(stack_trace_serial_num()); \/\/ stack trace serial number\n+  writer->end_sub_record();\n+}\n+\n+void ThreadDumper::dump_stack_refs(AbstractDumpWriter * writer) {\n+  assert(_thread_serial_num != 0 && _start_frame_serial_num != 0, \"serial_num is not initialized\");\n+\n+  JNILocalsDumper blk(writer, thread_serial_num());\n+  if (_thread_type == ThreadType::Platform) {\n+    if (!_java_thread->has_last_Java_frame()) {\n+      \/\/ no last java frame but there may be JNI locals\n+      _java_thread->active_handles()->oops_do(&blk);\n+      return;\n+    }\n+  }\n+\n+  JavaStackRefDumper java_ref_dumper(writer, thread_serial_num());\n+\n+  \/\/ vframes are resource allocated\n+  Thread* current_thread = Thread::current();\n+  ResourceMark rm(current_thread);\n+  HandleMark hm(current_thread);\n+\n+  bool stopAtVthreadEntry = _thread_type == ThreadType::MountedVirtual;\n+  frame* last_entry_frame = nullptr;\n+  bool is_top_frame = true;\n+  int depth = 0;\n+  if (oom_thread()) {\n+    depth++;\n+  }\n+\n+  for (vframe* vf = get_top_frame(); vf != nullptr; vf = vf->sender()) {\n+    if (stopAtVthreadEntry && vf->is_vthread_entry()) {\n+      break;\n+    }\n+\n+    if (vf->is_java_frame()) {\n+      javaVFrame* jvf = javaVFrame::cast(vf);\n+      if (!(jvf->method()->is_native())) {\n+        java_ref_dumper.set_frame_number(depth);\n+        java_ref_dumper.dump_java_stack_refs(jvf->locals());\n+        java_ref_dumper.dump_java_stack_refs(jvf->expressions());\n+      } else {\n+        \/\/ native frame\n+        blk.set_frame_number(depth);\n+        if (is_top_frame) {\n+          \/\/ JNI locals for the top frame.\n+          assert(_java_thread != nullptr, \"impossible for unmounted vthread\");\n+          _java_thread->active_handles()->oops_do(&blk);\n+        } else {\n+          if (last_entry_frame != nullptr) {\n+            \/\/ JNI locals for the entry frame\n+            assert(last_entry_frame->is_entry_frame(), \"checking\");\n+            last_entry_frame->entry_frame_call_wrapper()->handles()->oops_do(&blk);\n+          }\n+        }\n+      }\n+      last_entry_frame = nullptr;\n+      \/\/ increment only for Java frames\n+      depth++;\n+    } else {\n+      \/\/ externalVFrame - for an entry frame then we report the JNI locals\n+      \/\/ when we find the corresponding javaVFrame\n+      frame* fr = vf->frame_pointer();\n+      assert(fr != nullptr, \"sanity check\");\n+      if (fr->is_entry_frame()) {\n+        last_entry_frame = fr;\n+      }\n+    }\n+  is_top_frame = false;\n+  }\n+  assert(depth == frame_count(), \"total number of Java frames not matched\");\n+}\n+\n+vframe* ThreadDumper::get_top_frame() const {\n+  if (_thread_type == ThreadType::UnmountedVirtual) {\n+    ContinuationWrapper cont(java_lang_VirtualThread::continuation(_thread_oop));\n+    if (cont.is_empty()) {\n+      return nullptr;\n+    }\n+    assert(!cont.is_mounted(), \"sanity check\");\n+    stackChunkOop chunk = cont.last_nonempty_chunk();\n+    if (chunk == nullptr || chunk->is_empty()) {\n+      return nullptr;\n+    }\n+\n+    RegisterMap reg_map(cont.continuation(), RegisterMap::UpdateMap::include);\n+    frame fr = chunk->top_frame(&reg_map);\n+    vframe* vf = vframe::new_vframe(&fr, &reg_map, nullptr); \/\/ don't need JavaThread\n+    return vf;\n+  }\n+\n+  RegisterMap reg_map(_java_thread,\n+      RegisterMap::UpdateMap::include,\n+      RegisterMap::ProcessFrames::include,\n+      RegisterMap::WalkContinuation::skip);\n+  switch (_thread_type) {\n+  case ThreadType::Platform:\n+    if (!_java_thread->has_last_Java_frame()) {\n+      return nullptr;\n+    }\n+    return _java_thread->is_vthread_mounted()\n+        ? _java_thread->carrier_last_java_vframe(&reg_map)\n+        : _java_thread->platform_thread_last_java_vframe(&reg_map);\n+\n+  case ThreadType::MountedVirtual:\n+    return _java_thread->last_java_vframe(&reg_map);\n+\n+  default: \/\/ make compilers happy\n+      break;\n+  }\n+  ShouldNotReachHere();\n+  return nullptr;\n+}\n+\n+\n@@ -1686,2 +1990,6 @@\n-  ThreadStackTrace**      _stack_traces;\n-  int                     _num_threads;\n+\n+  ThreadDumper**          _thread_dumpers; \/\/ platform, carrier and mounted virtual threads\n+  int                     _thread_dumpers_count;\n+  volatile int            _thread_serial_num;\n+  volatile int            _frame_serial_num;\n+\n@@ -1724,3 +2032,2 @@\n-  \/\/ HPROF_GC_ROOT_THREAD_OBJ records\n-  int do_thread(JavaThread* thread, u4 thread_serial_num);\n-  void do_threads();\n+  \/\/ HPROF_GC_ROOT_THREAD_OBJ records for platform and mounted virtual threads\n+  void dump_threads();\n@@ -1732,1 +2039,5 @@\n-  \/\/ HPROF_TRACE and HPROF_FRAME records\n+  bool is_oom_thread(JavaThread* thread) const {\n+    return thread == _oome_thread && _oome_constructor != nullptr;\n+  }\n+\n+  \/\/ HPROF_TRACE and HPROF_FRAME records for platform and mounted virtual threads\n@@ -1745,2 +2056,6 @@\n-    _stack_traces = nullptr;\n-    _num_threads = 0;\n+\n+    _thread_dumpers = nullptr;\n+    _thread_dumpers_count = 0;\n+    _thread_serial_num = 1;\n+    _frame_serial_num = 1;\n+\n@@ -1766,3 +2081,3 @@\n-    if (_stack_traces != nullptr) {\n-      for (int i=0; i < _num_threads; i++) {\n-        delete _stack_traces[i];\n+    if (_thread_dumpers != nullptr) {\n+      for (int i = 0; i < _thread_dumpers_count; i++) {\n+        delete _thread_dumpers[i];\n@@ -1770,1 +2085,1 @@\n-      FREE_C_HEAP_ARRAY(ThreadStackTrace*, _stack_traces);\n+      FREE_C_HEAP_ARRAY(ThreadDumper*, _thread_dumpers);\n@@ -1772,0 +2087,1 @@\n+\n@@ -1838,94 +2154,6 @@\n-\/\/ Walk the stack of the given thread.\n-\/\/ Dumps a HPROF_GC_ROOT_JAVA_FRAME record for each local\n-\/\/ Dumps a HPROF_GC_ROOT_JNI_LOCAL record for each JNI local\n-\/\/\n-\/\/ It returns the number of Java frames in this thread stack\n-int VM_HeapDumper::do_thread(JavaThread* java_thread, u4 thread_serial_num) {\n-  JNILocalsDumper blk(writer(), thread_serial_num);\n-\n-  oop threadObj = java_thread->threadObj();\n-  assert(threadObj != nullptr, \"sanity check\");\n-\n-  int stack_depth = 0;\n-  if (java_thread->has_last_Java_frame()) {\n-\n-    \/\/ vframes are resource allocated\n-    Thread* current_thread = Thread::current();\n-    ResourceMark rm(current_thread);\n-    HandleMark hm(current_thread);\n-\n-    RegisterMap reg_map(java_thread,\n-                        RegisterMap::UpdateMap::include,\n-                        RegisterMap::ProcessFrames::include,\n-                        RegisterMap::WalkContinuation::skip);\n-    frame f = java_thread->last_frame();\n-    vframe* vf = vframe::new_vframe(&f, &reg_map, java_thread);\n-    frame* last_entry_frame = nullptr;\n-    int extra_frames = 0;\n-\n-    if (java_thread == _oome_thread && _oome_constructor != nullptr) {\n-      extra_frames++;\n-    }\n-    while (vf != nullptr) {\n-      blk.set_frame_number(stack_depth);\n-      if (vf->is_java_frame()) {\n-\n-        \/\/ java frame (interpreted, compiled, ...)\n-        javaVFrame *jvf = javaVFrame::cast(vf);\n-        if (!(jvf->method()->is_native())) {\n-          StackValueCollection* locals = jvf->locals();\n-          for (int slot=0; slot<locals->size(); slot++) {\n-            if (locals->at(slot)->type() == T_OBJECT) {\n-              oop o = locals->obj_at(slot)();\n-\n-              if (o != nullptr) {\n-                u4 size = 1 + sizeof(address) + 4 + 4;\n-                writer()->start_sub_record(HPROF_GC_ROOT_JAVA_FRAME, size);\n-                writer()->write_objectID(o);\n-                writer()->write_u4(thread_serial_num);\n-                writer()->write_u4((u4) (stack_depth + extra_frames));\n-                writer()->end_sub_record();\n-              }\n-            }\n-          }\n-          StackValueCollection *exprs = jvf->expressions();\n-          for(int index = 0; index < exprs->size(); index++) {\n-            if (exprs->at(index)->type() == T_OBJECT) {\n-               oop o = exprs->obj_at(index)();\n-               if (o != nullptr) {\n-                 u4 size = 1 + sizeof(address) + 4 + 4;\n-                 writer()->start_sub_record(HPROF_GC_ROOT_JAVA_FRAME, size);\n-                 writer()->write_objectID(o);\n-                 writer()->write_u4(thread_serial_num);\n-                 writer()->write_u4((u4) (stack_depth + extra_frames));\n-                 writer()->end_sub_record();\n-               }\n-             }\n-          }\n-        } else {\n-          \/\/ native frame\n-          if (stack_depth == 0) {\n-            \/\/ JNI locals for the top frame.\n-            java_thread->active_handles()->oops_do(&blk);\n-          } else {\n-            if (last_entry_frame != nullptr) {\n-              \/\/ JNI locals for the entry frame\n-              assert(last_entry_frame->is_entry_frame(), \"checking\");\n-              last_entry_frame->entry_frame_call_wrapper()->handles()->oops_do(&blk);\n-            }\n-          }\n-        }\n-        \/\/ increment only for Java frames\n-        stack_depth++;\n-        last_entry_frame = nullptr;\n-\n-      } else {\n-        \/\/ externalVFrame - if it's an entry frame then report any JNI locals\n-        \/\/ as roots when we find the corresponding native javaVFrame\n-        frame* fr = vf->frame_pointer();\n-        assert(fr != nullptr, \"sanity check\");\n-        if (fr->is_entry_frame()) {\n-          last_entry_frame = fr;\n-        }\n-      }\n-      vf = vf->sender();\n+\/\/ Write a HPROF_GC_ROOT_THREAD_OBJ record for platform\/carrier and mounted virtual threads.\n+\/\/ Then walk the stack so that locals and JNI locals are dumped.\n+void VM_HeapDumper::dump_threads() {\n+    for (int i = 0; i < _thread_dumpers_count; i++) {\n+        _thread_dumpers[i]->dump_thread_obj(writer());\n+        _thread_dumpers[i]->dump_stack_refs(writer());\n@@ -1933,26 +2161,0 @@\n-  } else {\n-    \/\/ no last java frame but there may be JNI locals\n-    java_thread->active_handles()->oops_do(&blk);\n-  }\n-  return stack_depth;\n-}\n-\n-\n-\/\/ write a HPROF_GC_ROOT_THREAD_OBJ record for each java thread. Then walk\n-\/\/ the stack so that locals and JNI locals are dumped.\n-void VM_HeapDumper::do_threads() {\n-  for (int i=0; i < _num_threads; i++) {\n-    JavaThread* thread = _stack_traces[i]->thread();\n-    oop threadObj = thread->threadObj();\n-    u4 thread_serial_num = i+1;\n-    u4 stack_serial_num = thread_serial_num + STACK_TRACE_ID;\n-    u4 size = 1 + sizeof(address) + 4 + 4;\n-    writer()->start_sub_record(HPROF_GC_ROOT_THREAD_OBJ, size);\n-    writer()->write_objectID(threadObj);\n-    writer()->write_u4(thread_serial_num);  \/\/ thread number\n-    writer()->write_u4(stack_serial_num);   \/\/ stack trace serial number\n-    writer()->end_sub_record();\n-    int num_frames = do_thread(thread, thread_serial_num);\n-    assert(num_frames == _stack_traces[i]->get_stack_depth(),\n-           \"total number of Java frames not matched\");\n-  }\n@@ -2103,0 +2305,2 @@\n+    \/\/ HPROF_HEAP_DUMP\/HPROF_HEAP_DUMP_SEGMENT starts here\n+\n@@ -2110,1 +2314,1 @@\n-    do_threads();\n+    dump_threads();\n@@ -2166,2 +2370,2 @@\n-  DumperSupport::write_header(writer(), HPROF_TRACE, 3*sizeof(u4));\n-  writer()->write_u4((u4) STACK_TRACE_ID);\n+  DumperSupport::write_header(writer(), HPROF_TRACE, 3 * sizeof(u4));\n+  writer()->write_u4((u4)STACK_TRACE_ID);\n@@ -2171,27 +2375,10 @@\n-  _stack_traces = NEW_C_HEAP_ARRAY(ThreadStackTrace*, Threads::number_of_threads(), mtInternal);\n-  int frame_serial_num = 0;\n-  for (JavaThreadIteratorWithHandle jtiwh; JavaThread *thread = jtiwh.next(); ) {\n-    oop threadObj = thread->threadObj();\n-    if (threadObj != nullptr && !thread->is_exiting() && !thread->is_hidden_from_external_view()) {\n-      \/\/ dump thread stack trace\n-      Thread* current_thread = Thread::current();\n-      ResourceMark rm(current_thread);\n-      HandleMark hm(current_thread);\n-\n-      ThreadStackTrace* stack_trace = new ThreadStackTrace(thread, false);\n-      stack_trace->dump_stack_at_safepoint(-1, \/* ObjectMonitorsHashtable is not needed here *\/ nullptr, true);\n-      _stack_traces[_num_threads++] = stack_trace;\n-\n-      \/\/ write HPROF_FRAME records for this thread's stack trace\n-      int depth = stack_trace->get_stack_depth();\n-      int thread_frame_start = frame_serial_num;\n-      int extra_frames = 0;\n-      \/\/ write fake frame that makes it look like the thread, which caused OOME,\n-      \/\/ is in the OutOfMemoryError zero-parameter constructor\n-      if (thread == _oome_thread && _oome_constructor != nullptr) {\n-        int oome_serial_num = _klass_map->find(_oome_constructor->method_holder());\n-        \/\/ the class serial number starts from 1\n-        assert(oome_serial_num > 0, \"OutOfMemoryError class not found\");\n-        DumperSupport::dump_stack_frame(writer(), ++frame_serial_num, oome_serial_num,\n-                                        _oome_constructor, 0);\n-        extra_frames++;\n+  \/\/ max number if every platform thread is carrier with mounted virtual thread\n+  _thread_dumpers = NEW_C_HEAP_ARRAY(ThreadDumper*, Threads::number_of_threads() * 2, mtInternal);\n+\n+  for (JavaThreadIteratorWithHandle jtiwh; JavaThread * thread = jtiwh.next(); ) {\n+    if (ThreadDumper::should_dump_pthread(thread)) {\n+      bool add_oom_frame = is_oom_thread(thread);\n+\n+      oop mounted_vt = thread->is_vthread_mounted() ? thread->vthread() : nullptr;\n+      if (mounted_vt != nullptr && !ThreadDumper::should_dump_vthread(mounted_vt)) {\n+        mounted_vt = nullptr;\n@@ -2199,7 +2386,12 @@\n-      for (int j=0; j < depth; j++) {\n-        StackFrameInfo* frame = stack_trace->stack_frame_at(j);\n-        Method* m = frame->method();\n-        int class_serial_num = _klass_map->find(m->method_holder());\n-        \/\/ the class serial number starts from 1\n-        assert(class_serial_num > 0, \"class not found\");\n-        DumperSupport::dump_stack_frame(writer(), ++frame_serial_num, class_serial_num, m, frame->bci());\n+\n+      \/\/ mounted vthread (if any)\n+      if (mounted_vt != nullptr) {\n+        ThreadDumper* thread_dumper = new ThreadDumper(ThreadDumper::ThreadType::MountedVirtual, thread, mounted_vt);\n+        _thread_dumpers[_thread_dumpers_count++] = thread_dumper;\n+        if (add_oom_frame) {\n+          thread_dumper->add_oom_frame(_oome_constructor);\n+          \/\/ we add oom frame to the VT stack, don't add it to the carrier thread stack\n+          add_oom_frame = false;\n+        }\n+        thread_dumper->init_serial_nums(&_thread_serial_num, &_frame_serial_num);\n+        thread_dumper->dump_stack_traces(writer(), _klass_map);\n@@ -2207,10 +2399,6 @@\n-      depth += extra_frames;\n-\n-      \/\/ write HPROF_TRACE record for one thread\n-      DumperSupport::write_header(writer(), HPROF_TRACE, checked_cast<u4>(3*sizeof(u4) + depth*oopSize));\n-      int stack_serial_num = _num_threads + STACK_TRACE_ID;\n-      writer()->write_u4(stack_serial_num);      \/\/ stack trace serial number\n-      writer()->write_u4((u4) _num_threads);     \/\/ thread serial number\n-      writer()->write_u4(depth);                 \/\/ frame count\n-      for (int j=1; j <= depth; j++) {\n-        writer()->write_id(thread_frame_start + j);\n+\n+      \/\/ platform or carrier thread\n+      ThreadDumper* thread_dumper = new ThreadDumper(ThreadDumper::ThreadType::Platform, thread, thread->threadObj());\n+      _thread_dumpers[_thread_dumpers_count++] = thread_dumper;\n+      if (add_oom_frame) {\n+        thread_dumper->add_oom_frame(_oome_constructor);\n@@ -2218,0 +2406,2 @@\n+      thread_dumper->init_serial_nums(&_thread_serial_num, &_frame_serial_num);\n+      thread_dumper->dump_stack_traces(writer(), _klass_map);\n","filename":"src\/hotspot\/share\/services\/heapDumper.cpp","additions":377,"deletions":187,"binary":false,"changes":564,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n-#ifdef ASSERT\n@@ -62,1 +61,0 @@\n-#endif \/\/ ASSERT\n","filename":"src\/hotspot\/share\/services\/mallocTracker.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n-#ifdef ASSERT\n@@ -55,1 +54,0 @@\n-#endif \/\/ ASSERT\n@@ -58,4 +56,1 @@\n-  MemoryCounter() : _count(0), _size(0) {\n-    DEBUG_ONLY(_peak_count = 0;)\n-    DEBUG_ONLY(_peak_size  = 0;)\n-  }\n+  MemoryCounter() : _count(0), _size(0), _peak_count(0), _peak_size(0) {}\n@@ -67,1 +62,1 @@\n-      DEBUG_ONLY(update_peak(sum, cnt);)\n+      update_peak(sum, cnt);\n@@ -84,1 +79,1 @@\n-      DEBUG_ONLY(update_peak(sum, _count);)\n+      update_peak(sum, _count);\n@@ -92,1 +87,1 @@\n-    return DEBUG_ONLY(Atomic::load(&_peak_count)) NOT_DEBUG(0);\n+    return Atomic::load(&_peak_count);\n@@ -96,1 +91,1 @@\n-    return DEBUG_ONLY(Atomic::load(&_peak_size)) NOT_DEBUG(0);\n+    return Atomic::load(&_peak_size);\n@@ -184,5 +179,0 @@\n-  inline size_t thread_count() const {\n-    MallocMemorySnapshot* s = const_cast<MallocMemorySnapshot*>(this);\n-    return s->by_type(mtThreadStack)->malloc_count();\n-  }\n-\n","filename":"src\/hotspot\/share\/services\/mallocTracker.hpp","additions":5,"deletions":15,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -193,0 +193,1 @@\n+  _thread_count = ThreadStackTracker::thread_count();\n","filename":"src\/hotspot\/share\/services\/memBaseline.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -67,0 +67,1 @@\n+  size_t                 _thread_count;\n@@ -87,1 +88,1 @@\n-    _instance_class_count(0), _array_class_count(0),\n+    _instance_class_count(0), _array_class_count(0), _thread_count(0),\n@@ -174,1 +175,1 @@\n-    return _malloc_memory_snapshot.thread_count();\n+    return _thread_count;\n@@ -183,0 +184,1 @@\n+    _thread_count = 0;\n","filename":"src\/hotspot\/share\/services\/memBaseline.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -239,1 +239,0 @@\n-        assert(ThreadStackTracker::thread_count() == 0, \"Not used\");\n@@ -249,1 +248,1 @@\n-        DEBUG_ONLY(|| amount_in_current_scale(malloc_memory->malloc_peak_size()) > 0)) {\n+        || amount_in_current_scale(malloc_memory->malloc_peak_size()) > 0) {\n","filename":"src\/hotspot\/share\/services\/memReporter.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+  ThreadCritical tc;\n@@ -53,1 +54,0 @@\n-    ThreadCritical tc;\n@@ -55,1 +55,0 @@\n-    _thread_count ++;\n@@ -60,1 +59,0 @@\n-      ThreadCritical tc;\n@@ -66,0 +64,1 @@\n+  _thread_count++;\n@@ -71,0 +70,1 @@\n+  ThreadCritical tc;\n@@ -72,1 +72,0 @@\n-    ThreadCritical tc;\n@@ -74,1 +73,0 @@\n-    _thread_count--;\n@@ -79,1 +77,0 @@\n-      ThreadCritical tc;\n@@ -86,0 +83,1 @@\n+  _thread_count--;\n","filename":"src\/hotspot\/share\/services\/threadStackTracker.cpp","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1039,1 +1039,2 @@\n-\n+const intptr_t badDispHeaderDeopt = 0xDE0BD000;             \/\/ value to fill unused displaced header during deoptimization\n+const intptr_t badDispHeaderOSR   = 0xDEAD05A0;             \/\/ value to fill unused displaced header during OSR\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -77,0 +77,4 @@\n+#ifdef AIX\n+#include \"loadlib_aix.hpp\"\n+#endif\n+\n@@ -434,1 +438,1 @@\n-    if (fr.is_java_frame() || fr.is_native_frame() || fr.is_runtime_frame()) {\n+    if (fr.is_interpreted_frame() || (fr.cb() != nullptr && fr.cb()->frame_size() > 0)) {\n@@ -1346,0 +1350,2 @@\n+  AIX_ONLY(LoadedLibraries::reload());\n+\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+#include \"jni_util.h\"\n@@ -31,0 +32,1 @@\n+#include <procinfo.h>\n@@ -39,0 +41,18 @@\n+\/*\n+ * Return pids of active processes, and optionally parent pids and\n+ * start times for each process.\n+ * For a specific non-zero pid, only the direct children are returned.\n+ * If the pid is zero, all active processes are returned.\n+ * Use getprocs64 to accumulate any process following the rules above.\n+ * The resulting pids are stored into an array of longs named jarray.\n+ * The number of pids is returned if they all fit.\n+ * If the parentArray is non-null, store also the parent pid.\n+ * In this case the parentArray must have the same length as the result pid array.\n+ * Of course in the case of a given non-zero pid all entries in the parentArray\n+ * will contain this pid, so this array does only make sense in the case of a given\n+ * zero pid.\n+ * If the jstimesArray is non-null, store also the start time of the pid.\n+ * In this case the jstimesArray must have the same length as the result pid array.\n+ * If the array(s) (is|are) too short, excess pids are not stored and\n+ * the desired length is returned.\n+ *\/\n@@ -41,1 +61,101 @@\n-    return unix_getChildren(env, jpid, jarray, jparentArray, jstimesArray);\n+    pid_t pid = (pid_t) jpid;\n+    jlong* pids = NULL;\n+    jlong* ppids = NULL;\n+    jlong* stimes = NULL;\n+    jsize parentArraySize = 0;\n+    jsize arraySize = 0;\n+    jsize stimesSize = 0;\n+    jsize count = 0;\n+\n+    arraySize = (*env)->GetArrayLength(env, jarray);\n+    JNU_CHECK_EXCEPTION_RETURN(env, -1);\n+    if (jparentArray != NULL) {\n+        parentArraySize = (*env)->GetArrayLength(env, jparentArray);\n+        JNU_CHECK_EXCEPTION_RETURN(env, -1);\n+\n+        if (arraySize != parentArraySize) {\n+            JNU_ThrowIllegalArgumentException(env, \"array sizes not equal\");\n+            return 0;\n+        }\n+    }\n+    if (jstimesArray != NULL) {\n+        stimesSize = (*env)->GetArrayLength(env, jstimesArray);\n+        JNU_CHECK_EXCEPTION_RETURN(env, -1);\n+\n+        if (arraySize != stimesSize) {\n+            JNU_ThrowIllegalArgumentException(env, \"array sizes not equal\");\n+            return 0;\n+        }\n+    }\n+\n+    const int chunk = 100;\n+    struct procentry64 ProcessBuffer[chunk];\n+    pid_t idxptr = 0;\n+    int i, num = 0;\n+\n+    do { \/\/ Block to break out of on Exception\n+        pids = (*env)->GetLongArrayElements(env, jarray, NULL);\n+        if (pids == NULL) {\n+            break;\n+        }\n+        if (jparentArray != NULL) {\n+            ppids  = (*env)->GetLongArrayElements(env, jparentArray, NULL);\n+            if (ppids == NULL) {\n+                break;\n+            }\n+        }\n+        if (jstimesArray != NULL) {\n+            stimes  = (*env)->GetLongArrayElements(env, jstimesArray, NULL);\n+            if (stimes == NULL) {\n+                break;\n+            }\n+        }\n+\n+        while ((num = getprocs64(ProcessBuffer, sizeof(struct procentry64), NULL,\n+                                 sizeof(struct fdsinfo64), &idxptr, chunk)) != -1) {\n+            for (i = 0; i < num; i++) {\n+                pid_t childpid = (pid_t) ProcessBuffer[i].pi_pid;\n+                pid_t ppid = (pid_t) ProcessBuffer[i].pi_ppid;\n+\n+                \/\/ Get the parent pid, and start time\n+                if (pid == 0 || ppid == pid) {\n+                    if (count < arraySize) {\n+                        \/\/ Only store if it fits\n+                        pids[count] = (jlong) childpid;\n+\n+                        if (ppids != NULL) {\n+                            \/\/ Store the parentPid\n+                            ppids[count] = (jlong) ppid;\n+                        }\n+                        if (stimes != NULL) {\n+                            \/\/ Store the process start time\n+                            stimes[count] = ((jlong) ProcessBuffer[i].pi_start) * 1000;;\n+                        }\n+                    }\n+                    count++; \/\/ Count to tabulate size needed\n+                }\n+            }\n+            if (num < chunk) {\n+                break;\n+            }\n+        }\n+    } while (0);\n+\n+    if (pids != NULL) {\n+        (*env)->ReleaseLongArrayElements(env, jarray, pids, 0);\n+    }\n+    if (ppids != NULL) {\n+        (*env)->ReleaseLongArrayElements(env, jparentArray, ppids, 0);\n+    }\n+    if (stimes != NULL) {\n+        (*env)->ReleaseLongArrayElements(env, jstimesArray, stimes, 0);\n+    }\n+\n+    if (num == -1) {\n+        JNU_ThrowByNameWithLastError(env,\n+            \"java\/lang\/RuntimeException\", \"Unable to retrieve Process info\");\n+        return -1;\n+    }\n+\n+    \/\/ If more pids than array had size for; count will be greater than array size\n+    return count;\n","filename":"src\/java.base\/aix\/native\/libjava\/ProcessHandleImpl_aix.c","additions":122,"deletions":2,"binary":false,"changes":124,"status":"modified"},{"patch":"@@ -161,0 +161,5 @@\n+        if (fname == NULL) {\n+            JNU_ThrowOutOfMemoryError(env, NULL);\n+            return;\n+        }\n+\n@@ -173,0 +178,5 @@\n+        if (map_entry == NULL) {\n+            JNU_ThrowOutOfMemoryError(env, NULL);\n+            fclose(proc_file);\n+            return;\n+        }\n","filename":"src\/java.base\/aix\/native\/libnio\/MappedMemoryUtils.c","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2008, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2013, 2019 SAP SE. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023 SAP SE. All rights reserved.\n@@ -108,0 +108,4 @@\n+        if (buffer == NULL) {\n+            throwUnixException(env, errno);\n+            return NULL;\n+        }\n","filename":"src\/java.base\/aix\/native\/libnio\/fs\/AixNativeDispatcher.c","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -145,1 +145,1 @@\n-        \/\/ POSIX attributes not supported on FAT\n+        \/\/ POSIX attributes not supported on FAT32\n","filename":"src\/java.base\/linux\/classes\/sun\/nio\/fs\/LinuxFileStore.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-#include <immintrin.h>\n@@ -63,0 +62,10 @@\n+\/*\n+Workaround for the bug in GCC12 (that was fixed in GCC 12.3.1).\n+More details are available at: https:\/\/gcc.gnu.org\/bugzilla\/show_bug.cgi?id=105593\n+*\/\n+#pragma GCC diagnostic push\n+#pragma GCC diagnostic ignored \"-Wmaybe-uninitialized\"\n+#pragma GCC diagnostic ignored \"-Wuninitialized\"\n+#include <immintrin.h>\n+#pragma GCC diagnostic pop\n+\n","filename":"src\/java.base\/linux\/native\/libsimdsort\/avx512-common-qsort.h","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.io.IOException;\n@@ -29,0 +30,1 @@\n+import java.nio.file.attribute.PosixFileAttributeView;\n@@ -30,1 +32,0 @@\n-import java.io.IOException;\n@@ -103,0 +104,4 @@\n+        \/\/ POSIX attributes not supported on FAT32\n+        if (type == PosixFileAttributeView.class &&\n+            entry().fstype().equals(\"msdos\"))\n+            return false;\n@@ -110,0 +115,3 @@\n+        \/\/ UNIX attributes not supported on FAT32\n+        if (name.equals(\"unix\") && entry().fstype().equals(\"msdos\"))\n+            return false;\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/fs\/BsdFileStore.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -50,4 +50,6 @@\n- * Returns the children of the requested pid and optionally each parent.\n- *\n- * Use sysctl to accumulate any process whose parent pid is zero or matches.\n- * The resulting pids are stored into the array of longs.\n+ * Return pids of active processes, and optionally parent pids and\n+ * start times for each process.\n+ * For a specific non-zero pid jpid, only the direct children are returned.\n+ * If the pid jpid is zero, all active processes are returned.\n+ * Uses sysctl to accumulates any process following the rules above.\n+ * The resulting pids are stored into an array of longs named jarray.\n@@ -55,2 +57,8 @@\n- * If the parentArray is non-null, store the parent pid.\n- * If the array is too short, excess pids are not stored and\n+ * If the parentArray is non-null, store also the parent pid.\n+ * In this case the parentArray must have the same length as the result pid array.\n+ * Of course in the case of a given non-zero pid all entries in the parentArray\n+ * will contain this pid, so this array does only make sense in the case of a given\n+ * zero pid.\n+ * If the jstimesArray is non-null, store also the start time of the pid.\n+ * In this case the jstimesArray must have the same length as the result pid array.\n+ * If the array(s) (is|are) too short, excess pids are not stored and\n","filename":"src\/java.base\/macosx\/native\/libjava\/ProcessHandleImpl_macosx.c","additions":14,"deletions":6,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,1 @@\n-    private BlockCipherParamsCore core;\n+    private final BlockCipherParamsCore core;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/AESParameters.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n-    private int block_size = 0;\n+    private final int block_size;\n@@ -52,1 +52,1 @@\n-    private int[] moreSizes = null;\n+    private final int[] moreSizes;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/BlockCipherParamsCore.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,0 @@\n-import sun.security.util.*;\n@@ -34,1 +33,0 @@\n-import javax.crypto.spec.*;\n@@ -60,1 +58,1 @@\n-    private CipherCore core = null;\n+    private final CipherCore core;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/BlowfishCipher.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,1 @@\n-    private BlockCipherParamsCore core;\n+    private final BlockCipherParamsCore core;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/BlowfishParameters.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-import java.util.Objects;\n@@ -58,1 +57,1 @@\n-    private byte[] k;\n+    private final byte[] k;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/CipherBlockChaining.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,1 @@\n-    private byte[] buffer = null;\n+    private final byte[] buffer;\n@@ -65,1 +65,1 @@\n-    private int blockSize = 0;\n+    private final int blockSize;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/CipherCore.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,1 @@\n-    private int numBytes;\n+    private final int numBytes;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/CipherFeedback.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,0 @@\n-import javax.crypto.spec.*;\n@@ -55,1 +54,1 @@\n-    private CipherCore core = null;\n+    private final CipherCore core;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DESCipher.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import java.io.IOException;\n+import java.io.InvalidObjectException;\n@@ -48,1 +50,1 @@\n-    static final long serialVersionUID = 7724971015953279128L;\n+    private static final long serialVersionUID = 7724971015953279128L;\n@@ -146,2 +148,5 @@\n-     * readObject is called to restore the state of this key from\n-     * a stream.\n+     * Restores the state of this object from the stream.\n+     *\n+     * @param  s the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n@@ -151,1 +156,1 @@\n-         throws java.io.IOException, ClassNotFoundException\n+         throws IOException, ClassNotFoundException\n@@ -154,0 +159,3 @@\n+        if ((key == null) || (key.length != DESKeySpec.DES_KEY_LEN)) {\n+            throw new InvalidObjectException(\"Wrong key size\");\n+        }\n@@ -157,0 +165,3 @@\n+\n+        DESKeyGenerator.setParityBit(key, 0);\n+\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DESKey.java","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,1 @@\n-    private BlockCipherParamsCore core;\n+    private final BlockCipherParamsCore core;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DESParameters.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,0 @@\n-import javax.crypto.spec.*;\n@@ -53,1 +52,1 @@\n-    private CipherCore core = null;\n+    private final CipherCore core;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DESedeCipher.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2007, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,2 @@\n-    private byte[] buf1, buf2;\n+    private final byte[] buf1;\n+    private final byte[] buf2;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DESedeCrypt.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import java.io.IOException;\n+import java.io.InvalidObjectException;\n@@ -48,1 +50,1 @@\n-    static final long serialVersionUID = 2463986565756745178L;\n+    private static final long serialVersionUID = 2463986565756745178L;\n@@ -147,2 +149,5 @@\n-     * readObject is called to restore the state of this key from\n-     * a stream.\n+     * Restores the state of this object from the stream.\n+     *\n+     * @param  s the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n@@ -152,1 +157,1 @@\n-         throws java.io.IOException, ClassNotFoundException\n+         throws IOException, ClassNotFoundException\n@@ -155,0 +160,3 @@\n+        if ((key == null) || (key.length != DESedeKeySpec.DES_EDE_KEY_LEN)) {\n+            throw new InvalidObjectException(\"Wrong key size\");\n+        }\n@@ -158,0 +166,5 @@\n+\n+        DESKeyGenerator.setParityBit(key, 0);\n+        DESKeyGenerator.setParityBit(key, 8);\n+        DESKeyGenerator.setParityBit(key, 16);\n+\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DESedeKey.java","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-    private BlockCipherParamsCore core;\n+    private final BlockCipherParamsCore core;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DESedeParameters.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,1 @@\n-    private FeedbackCipher cipher;\n+    private final FeedbackCipher cipher;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DESedeWrapCipher.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -356,1 +356,1 @@\n-            if (ns.getName().equals(\"X25519\")) {\n+            if (ns.getName().equalsIgnoreCase(\"X25519\")) {\n@@ -358,1 +358,1 @@\n-            } else if (ns.getName().equals(\"X448\")) {\n+            } else if (ns.getName().equalsIgnoreCase(\"X448\")) {\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DHKEM.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -43,2 +43,0 @@\n- *\n- *\n@@ -52,1 +50,1 @@\n-    static final long serialVersionUID = 7565477590005668886L;\n+    private static final long serialVersionUID = 7565477590005668886L;\n@@ -58,1 +56,1 @@\n-    private BigInteger x;\n+    private final BigInteger x;\n@@ -67,1 +65,1 @@\n-    private BigInteger p;\n+    private final BigInteger p;\n@@ -70,1 +68,1 @@\n-    private BigInteger g;\n+    private final BigInteger g;\n@@ -73,1 +71,1 @@\n-    private int l;\n+    private final int l;\n@@ -166,0 +164,2 @@\n+            } else {\n+                this.l = 0;\n@@ -175,1 +175,3 @@\n-            parseKeyBits();\n+\n+            DerInputStream in = new DerInputStream(this.key);\n+            this.x = in.getBigInteger();\n@@ -276,10 +278,0 @@\n-    private void parseKeyBits() throws InvalidKeyException {\n-        try {\n-            DerInputStream in = new DerInputStream(this.key);\n-            this.x = in.getBigInteger();\n-        } catch (IOException e) {\n-            throw new InvalidKeyException(\n-                \"Error parsing key encoding: \" + e.getMessage(), e);\n-        }\n-    }\n-\n@@ -324,0 +316,24 @@\n+\n+    \/**\n+     * Restores the state of this object from the stream.\n+     * <p>\n+     * JDK 1.5+ objects use <code>KeyRep<\/code>s instead.\n+     *\n+     * @param  stream the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n+     *\/\n+    @java.io.Serial\n+    private void readObject(ObjectInputStream stream)\n+            throws IOException, ClassNotFoundException {\n+        stream.defaultReadObject();\n+        if ((key == null) || (key.length == 0)) {\n+            throw new InvalidObjectException(\"key not deserializable\");\n+        }\n+        this.key = key.clone();\n+        if ((encodedKey == null) || (encodedKey.length == 0)) {\n+            throw new InvalidObjectException(\n+                    \"encoded key not deserializable\");\n+        }\n+        this.encodedKey = encodedKey.clone();\n+    }\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DHPrivateKey.java","additions":34,"deletions":18,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -42,2 +42,0 @@\n- *\n- *\n@@ -51,1 +49,1 @@\n-    static final long serialVersionUID = 7647557958927458271L;\n+    private static final long serialVersionUID = 7647557958927458271L;\n@@ -54,1 +52,1 @@\n-    private BigInteger y;\n+    private final BigInteger y;\n@@ -63,1 +61,1 @@\n-    private BigInteger p;\n+    private final BigInteger p;\n@@ -66,1 +64,1 @@\n-    private BigInteger g;\n+    private final BigInteger g;\n@@ -69,1 +67,1 @@\n-    private int l;\n+    private final int l;\n@@ -72,1 +70,1 @@\n-    static ObjectIdentifier DH_OID =\n+    static final ObjectIdentifier DH_OID =\n@@ -158,0 +156,2 @@\n+            } else {\n+                this.l = 0;\n@@ -167,1 +167,4 @@\n-            parseKeyBits();\n+\n+            DerInputStream in = new DerInputStream(this.key);\n+            this.y = in.getBigInteger();\n+\n@@ -268,10 +271,0 @@\n-    private void parseKeyBits() throws InvalidKeyException {\n-        try {\n-            DerInputStream in = new DerInputStream(this.key);\n-            this.y = in.getBigInteger();\n-        } catch (IOException e) {\n-            throw new InvalidKeyException(\n-                \"Error parsing key encoding: \" + e.toString());\n-        }\n-    }\n-\n@@ -316,0 +309,24 @@\n+\n+    \/**\n+     * Restores the state of this object from the stream.\n+     * <p>\n+     * JDK 1.5+ objects use <code>KeyRep<\/code>s instead.\n+     *\n+     * @param  stream the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n+     *\/\n+    @java.io.Serial\n+    private void readObject(ObjectInputStream stream)\n+            throws IOException, ClassNotFoundException {\n+        stream.defaultReadObject();\n+        if ((key == null) || (key.length == 0)) {\n+            throw new InvalidObjectException(\"key not deserializable\");\n+        }\n+        this.key = key.clone();\n+        if ((encodedKey == null) || (encodedKey.length == 0)) {\n+            throw new InvalidObjectException(\n+                    \"encoded key not deserializable\");\n+        }\n+        this.encodedKey = encodedKey.clone();\n+    }\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DHPublicKey.java","additions":36,"deletions":19,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,1 @@\n-    private AlgorithmId algid;\n+    private final AlgorithmId algid;\n@@ -50,1 +50,1 @@\n-    private byte[] encryptedData;\n+    private final byte[] encryptedData;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/EncryptedPrivateKeyInfo.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -127,1 +127,1 @@\n-    private long[] subkeyHtbl;\n+    private final long[] subkeyHtbl;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/GHASH.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,2 +77,2 @@\n-    static int DEFAULT_IV_LEN = 12; \/\/ in bytes\n-    static int DEFAULT_TAG_LEN = 16; \/\/ in bytes\n+    private static final int DEFAULT_IV_LEN = 12; \/\/ in bytes\n+    private static final int DEFAULT_TAG_LEN = 16; \/\/ in bytes\n@@ -101,1 +101,1 @@\n-    SymmetricCipher blockCipher;\n+    final SymmetricCipher blockCipher;\n@@ -109,1 +109,1 @@\n-    int keySize;\n+    private final int keySize;\n@@ -621,3 +621,3 @@\n-     * Requires 768 bytes (48 AES blocks) to efficiently use the intrinsic.\n-     * inLen that is less than 768 size block sizes, before or after this\n-     * intrinsic is used, will be done by the calling method\n+     * Requires PARALLEN_LEN bytes to efficiently use the intrinsic.\n+     * The intrinsic returns the number of bytes processed.\n+     * The remaining bytes will be processed by the calling method.\n@@ -626,2 +626,2 @@\n-     * Only Intel processors with AVX512 that support vaes, vpclmulqdq,\n-     * avx512dq, and avx512vl trigger this intrinsic.\n+     * Intel processors with AVX2 support and above trigger this intrinsic.\n+     * Some AARCH64 processors also trigger this intrinsic.\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/GaloisCounterMode.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-    private int blockSize;\n+    private final int blockSize;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/ISO10126Padding.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -102,1 +102,1 @@\n-    private Hashtable<String, Object> entries = new Hashtable<String, Object>();\n+    private final Hashtable<String, Object> entries = new Hashtable<>();\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/JceKeyStore.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-    private char[] password;\n+    private final char[] password;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/KeyProtector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,1 @@\n-    private static ObjectIdentifier OID_MGF1 =\n+    private static final ObjectIdentifier OID_MGF1 =\n@@ -61,1 +61,1 @@\n-    private static ObjectIdentifier OID_PSpecified =\n+    private static final ObjectIdentifier OID_PSpecified =\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/OAEPParameters.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,1 @@\n-    private byte[] k = null;\n+    private final byte[] k;\n@@ -53,1 +53,1 @@\n-    private byte[] register = null;\n+    private final byte[] register;\n@@ -59,1 +59,1 @@\n-    private int numBytes;\n+    private final int numBytes;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/OutputFeedback.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import java.io.IOException;\n+import java.io.InvalidObjectException;\n@@ -49,1 +51,1 @@\n-    static final long serialVersionUID = -2234768909660948176L;\n+    private static final long serialVersionUID = -2234768909660948176L;\n@@ -53,1 +55,1 @@\n-    private String type;\n+    private final String type;\n@@ -165,2 +167,5 @@\n-     * readObject is called to restore the state of this key from\n-     * a stream.\n+     * Restores the state of this object from the stream.\n+     *\n+     * @param  s the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n@@ -170,1 +175,1 @@\n-         throws java.io.IOException, ClassNotFoundException\n+         throws IOException, ClassNotFoundException\n@@ -173,0 +178,4 @@\n+        if (key == null) {\n+            throw new InvalidObjectException(\n+                    \"PBEKey couldn't be deserialized\");\n+        }\n@@ -176,0 +185,11 @@\n+\n+        \/\/ Accept \"\\0\" to signify \"zero-length password with no terminator\".\n+        if (!(key.length == 1 && key[0] == 0)) {\n+            for (int i = 0; i < key.length; i++) {\n+                if ((key[i] < '\\u0020') || (key[i] > '\\u007E')) {\n+                    throw new InvalidObjectException(\n+                            \"PBEKey had non-ASCII chars\");\n+                }\n+            }\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PBEKey.java","additions":25,"deletions":5,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-    private String type;\n+    private final String type;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PBEKeyFactory.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,4 +46,3 @@\n-    private CipherCore cipher;\n-    private MessageDigest md;\n-    private int blkSize;\n-    private String algo = null;\n+    private final CipherCore cipher;\n+    private final MessageDigest md;\n+    private final String algo;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PBES1Core.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -95,1 +95,1 @@\n-    private static ObjectIdentifier pkcs5PBKDF2_OID =\n+    private static final ObjectIdentifier pkcs5PBKDF2_OID =\n@@ -97,1 +97,1 @@\n-    private static ObjectIdentifier pkcs5PBES2_OID =\n+    private static final ObjectIdentifier pkcs5PBES2_OID =\n@@ -99,1 +99,1 @@\n-    private static ObjectIdentifier aes128CBC_OID =\n+    private static final ObjectIdentifier aes128CBC_OID =\n@@ -101,1 +101,1 @@\n-    private static ObjectIdentifier aes192CBC_OID =\n+    private static final ObjectIdentifier aes192CBC_OID =\n@@ -103,1 +103,1 @@\n-    private static ObjectIdentifier aes256CBC_OID =\n+    private static final ObjectIdentifier aes256CBC_OID =\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PBES2Parameters.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-    private PBES1Core core;\n+    private final PBES1Core core;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PBEWithMD5AndDESCipher.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,1 +56,1 @@\n-    private PBES1Core core;\n+    private final PBES1Core core;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PBEWithMD5AndTripleDESCipher.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import java.io.ObjectStreamException;\n+import java.io.*;\n@@ -61,1 +61,1 @@\n-    static final long serialVersionUID = -2234868909660948157L;\n+    private static final long serialVersionUID = -2234868909660948157L;\n@@ -63,4 +63,4 @@\n-    private char[] passwd;\n-    private byte[] salt;\n-    private int iterCount;\n-    private byte[] key;\n+    private final char[] passwd;\n+    private final byte[] salt;\n+    private final int iterCount;\n+    private final byte[] key;\n@@ -69,2 +69,2 @@\n-    private transient Mac prf;\n-    private transient Cleaner.Cleanable cleaner;\n+    private final transient Mac prf;\n+    private final transient Cleaner.Cleanable cleaner;\n@@ -96,0 +96,1 @@\n+        byte[] key = null;\n@@ -114,1 +115,1 @@\n-            this.key = deriveKey(prf, passwdBytes, salt, iterCount, keyLength);\n+            key = deriveKey(prf, passwdBytes, salt, iterCount, keyLength);\n@@ -125,1 +126,1 @@\n-        final byte[] k = this.key;\n+        final byte[] k = this.key = key;\n@@ -144,0 +145,1 @@\n+            String algName = prf.getAlgorithm();\n@@ -150,1 +152,1 @@\n-                    return prf.getAlgorithm();\n+                    return algName;\n@@ -163,1 +165,1 @@\n-                      prf.getAlgorithm().toLowerCase(Locale.ENGLISH).hashCode();\n+                      algName.toLowerCase(Locale.ENGLISH).hashCode();\n@@ -170,1 +172,1 @@\n-                    return prf.getAlgorithm().equalsIgnoreCase(\n+                    return algName.equalsIgnoreCase(\n@@ -174,0 +176,8 @@\n+                \/\/ This derived key can't be deserialized.\n+                @java.io.Serial\n+                private void readObject(ObjectInputStream stream)\n+                        throws IOException, ClassNotFoundException {\n+                    throw new InvalidObjectException(\n+                            \"PBKDF2KeyImpl SecretKeys are not \" +\n+                            \"directly deserializable\");\n+                }\n@@ -175,0 +185,1 @@\n+\n@@ -306,0 +317,16 @@\n+\n+    \/**\n+     * Restores the state of this object from the stream.\n+     * <p>\n+     * Deserialization of this class is not supported.\n+     *\n+     * @param  stream the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n+     *\/\n+    @java.io.Serial\n+    private void readObject(ObjectInputStream stream)\n+            throws IOException, ClassNotFoundException {\n+        throw new InvalidObjectException(\n+                \"PBKDF2KeyImpl keys are not directly deserializable\");\n+    }\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PBKDF2KeyImpl.java","additions":40,"deletions":13,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-    private int blockSize;\n+    private final int blockSize;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PKCS5Padding.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,1 +56,1 @@\n-    private AlgorithmId algid;\n+    private final AlgorithmId algid;\n@@ -59,1 +59,1 @@\n-    private byte[] privkey;\n+    private final byte[] privkey;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PrivateKeyInfo.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import java.io.IOException;\n+import java.io.InvalidObjectException;\n+import java.io.ObjectInputStream;\n@@ -65,1 +68,1 @@\n-        if (params instanceof TlsMasterSecretParameterSpec == false) {\n+        if (!(params instanceof TlsMasterSecretParameterSpec)) {\n@@ -69,1 +72,1 @@\n-        if (\"RAW\".equals(spec.getPremasterSecret().getFormat()) == false) {\n+        if (!\"RAW\".equals(spec.getPremasterSecret().getFormat())) {\n@@ -194,1 +197,17 @@\n-    }\n+       \/**\n+        * Restores the state of this object from the stream.\n+        *\n+        * @param  stream the {@code ObjectInputStream} from which data is read\n+        * @throws IOException if an I\/O error occurs\n+        * @throws ClassNotFoundException if a serialized class cannot be loaded\n+        *\/\n+       @java.io.Serial\n+       private void readObject(ObjectInputStream stream)\n+               throws IOException, ClassNotFoundException {\n+           stream.defaultReadObject();\n+           if ((key == null) || (key.length == 0)) {\n+               throw new InvalidObjectException(\"TlsMasterSecretKey is null\");\n+           }\n+           key = key.clone();\n+       }\n+   }\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/TlsMasterSecretGenerator.java","additions":23,"deletions":4,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -86,0 +86,1 @@\n+import jdk.internal.vm.annotation.Stable;\n@@ -1063,0 +1064,1 @@\n+    @Stable\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -565,1 +565,1 @@\n-            throw new NumberFormatException(\"\");\n+            throw NumberFormatException.forInputString(\"\", radix);\n@@ -640,1 +640,1 @@\n-            throw new NumberFormatException(\"\");\n+            throw NumberFormatException.forInputString(\"\", radix);\n@@ -830,1 +830,1 @@\n-            throw new NumberFormatException(\"\");\n+            throw NumberFormatException.forInputString(\"\", radix);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Integer.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -595,1 +595,1 @@\n-            throw new NumberFormatException(\"\");\n+            throw NumberFormatException.forInputString(\"\", radix);\n@@ -670,1 +670,1 @@\n-            throw new NumberFormatException(\"\");\n+            throw NumberFormatException.forInputString(\"\", radix);\n@@ -867,1 +867,1 @@\n-            throw new NumberFormatException(\"\");\n+            throw NumberFormatException.forInputString(\"\", radix);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Long.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -275,1 +275,1 @@\n-     * @since 20\n+     * @since 22\n@@ -277,1 +277,0 @@\n-    @PreviewFeature(feature = PreviewFeature.Feature.FOREIGN)\n@@ -312,1 +311,1 @@\n-    void ensureNativeAccess(Class<?> owner, String methodName) {\n+    void ensureNativeAccess(Class<?> owner, String methodName, Class<?> currentClass) {\n@@ -323,1 +322,1 @@\n-                String mod = isNamed() ? \"module \" + getName() : \"the unnamed module\";\n+                String mod = isNamed() ? \"module \" + getName() : \"an unnamed module\";\n@@ -325,0 +324,1 @@\n+                String caller = currentClass != null ? currentClass.getName() : \"code\";\n@@ -327,3 +327,4 @@\n-                        WARNING: %s has been called by %s\n-                        WARNING: Use --enable-native-access=%s to avoid a warning for this module\n-                        %n\"\"\", cls, mtd, mod, modflag);\n+                        WARNING: %s has been called by %s in %s\n+                        WARNING: Use --enable-native-access=%s to avoid a warning for callers in this module\n+                        WARNING: Restricted methods will be blocked in a future release unless native access is enabled\n+                        %n\"\"\", cls, mtd, caller, mod, modflag);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Module.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -308,6 +308,0 @@\n-         * <p> This method is <a href=\"foreign\/package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-         * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-         * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain\n-         * from depending on restricted methods, and use safe and supported functionalities,\n-         * where possible.\n-         *\n@@ -325,1 +319,1 @@\n-         * @since 20\n+         * @since 22\n@@ -327,1 +321,0 @@\n-        @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ModuleLayer.java","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n@@ -1839,0 +1841,15 @@\n+    boolean bytesCompatible(Charset charset) {\n+        if (isLatin1()) {\n+            if (charset == ISO_8859_1.INSTANCE) {\n+                return true; \/\/ ok, same encoding\n+            } else if (charset == UTF_8.INSTANCE || charset == US_ASCII.INSTANCE) {\n+                return !StringCoding.hasNegatives(value, 0, value.length); \/\/ ok, if ASCII-compatible\n+            }\n+        }\n+        return false;\n+    }\n+\n+    void copyToSegmentRaw(MemorySegment segment, long offset) {\n+        MemorySegment.copy(value, 0, segment, ValueLayout.JAVA_BYTE, offset, value.length);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/String.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -141,1 +141,0 @@\n-\n@@ -155,1 +154,1 @@\n-    private static long prepend(long indexCoder, byte[] buf, boolean value) {\n+    static long prepend(long indexCoder, byte[] buf, boolean value) {\n@@ -201,1 +200,1 @@\n-        if (prefix != null) indexCoder = prepend(indexCoder, buf, prefix);\n+        indexCoder = prepend(indexCoder, buf, prefix);\n@@ -215,1 +214,1 @@\n-    private static long prepend(long indexCoder, byte[] buf, char value) {\n+    static long prepend(long indexCoder, byte[] buf, char value) {\n@@ -237,1 +236,1 @@\n-        if (prefix != null) indexCoder = prepend(indexCoder, buf, prefix);\n+        indexCoder = prepend(indexCoder, buf, prefix);\n@@ -251,1 +250,1 @@\n-    private static long prepend(long indexCoder, byte[] buf, int value) {\n+    static long prepend(long indexCoder, byte[] buf, int value) {\n@@ -272,1 +271,1 @@\n-        if (prefix != null) indexCoder = prepend(indexCoder, buf, prefix);\n+        indexCoder = prepend(indexCoder, buf, prefix);\n@@ -286,1 +285,1 @@\n-    private static long prepend(long indexCoder, byte[] buf, long value) {\n+    static long prepend(long indexCoder, byte[] buf, long value) {\n@@ -307,1 +306,1 @@\n-        if (prefix != null) indexCoder = prepend(indexCoder, buf, prefix);\n+        indexCoder = prepend(indexCoder, buf, prefix);\n@@ -321,1 +320,1 @@\n-    private static long prepend(long indexCoder, byte[] buf, String value) {\n+    static long prepend(long indexCoder, byte[] buf, String value) {\n@@ -344,1 +343,1 @@\n-        if (prefix != null) indexCoder = prepend(indexCoder, buf, prefix);\n+        indexCoder = prepend(indexCoder, buf, prefix);\n@@ -360,2 +359,1 @@\n-    private static long prepend(long indexCoder, byte[] buf,\n-                                FormatConcatItem value) {\n+    static long prepend(long indexCoder, byte[] buf, FormatConcatItem value) {\n@@ -387,1 +385,1 @@\n-        if (prefix != null) indexCoder = prepend(indexCoder, buf, prefix);\n+        indexCoder = prepend(indexCoder, buf, prefix);\n@@ -589,1 +587,2 @@\n-            return MethodHandles.lookup().findStatic(StringConcatHelper.class, name, methodType);\n+            return MethodHandles.lookup()\n+                    .findStatic(StringConcatHelper.class, name, methodType);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringConcatHelper.java","additions":14,"deletions":15,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -598,0 +598,1 @@\n+         * @sealedGraph\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringTemplate.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import java.lang.foreign.MemorySegment;\n@@ -91,1 +92,0 @@\n-import jdk.internal.vm.annotation.ForceInline;\n@@ -2457,2 +2457,2 @@\n-            public void ensureNativeAccess(Module m, Class<?> owner, String methodName) {\n-                m.ensureNativeAccess(owner, methodName);\n+            public void ensureNativeAccess(Module m, Class<?> owner, String methodName, Class<?> currentClass) {\n+                m.ensureNativeAccess(owner, methodName, currentClass);\n@@ -2672,0 +2672,10 @@\n+\n+            @Override\n+            public void copyToSegmentRaw(String string, MemorySegment segment, long offset) {\n+                string.copyToSegmentRaw(segment, offset);\n+            }\n+\n+            @Override\n+            public boolean bytesCompatible(String string, Charset charset) {\n+                return string.bytesCompatible(charset);\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":13,"deletions":3,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -109,1 +109,1 @@\n-\n+     *\n@@ -231,3 +231,0 @@\n-        \/\/ notify JVMTI before mount\n-        notifyJvmtiMount(\/*hide*\/true);\n-\n@@ -306,1 +303,0 @@\n-    @ChangesCurrentThread\n@@ -351,0 +347,3 @@\n+        \/\/ notify JVMTI before mount\n+        notifyJvmtiMount(\/*hide*\/true);\n+\n@@ -387,0 +386,3 @@\n+\n+        \/\/ notify JVMTI after unmount\n+        notifyJvmtiUnmount(\/*hide*\/false);\n@@ -451,0 +453,2 @@\n+\n+        \/\/ LockSupport.park\/parkNanos\n@@ -455,3 +459,0 @@\n-            \/\/ notify JVMTI that unmount has completed, thread is parked\n-            notifyJvmtiUnmount(\/*hide*\/false);\n-\n@@ -468,2 +469,2 @@\n-        } else if (s == YIELDING) {   \/\/ Thread.yield\n-            setState(RUNNABLE);\n+            return;\n+        }\n@@ -471,2 +472,3 @@\n-            \/\/ notify JVMTI that unmount has completed, thread is runnable\n-            notifyJvmtiUnmount(\/*hide*\/false);\n+        \/\/ Thread.yield\n+        if (s == YIELDING) {\n+            setState(RUNNABLE);\n@@ -480,2 +482,1 @@\n-        } else {\n-            assert false;\n+            return;\n@@ -483,0 +484,2 @@\n+\n+        assert false;\n@@ -489,1 +492,1 @@\n-        afterDone(true, true);\n+        afterDone(true);\n@@ -497,1 +500,0 @@\n-     * @param executed true if the thread executed, false if it failed to start\n@@ -499,1 +501,1 @@\n-    private void afterDone(boolean notifyContainer, boolean executed) {\n+    private void afterDone(boolean notifyContainer) {\n@@ -503,4 +505,0 @@\n-        if (executed) {\n-            notifyJvmtiUnmount(\/*hide*\/false);\n-        }\n-\n@@ -555,1 +553,1 @@\n-                afterDone(addedToContainer, \/*executed*\/false);\n+                afterDone(addedToContainer);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/VirtualThread.java","additions":20,"deletions":22,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+ * @sealedGraph\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/MethodHandleDesc.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.internal.javac.PreviewFeature;\n@@ -54,0 +53,3 @@\n+ * @implSpec\n+ * Implementations of this interface are immutable, thread-safe and <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>.\n+ *\n@@ -56,1 +58,1 @@\n- * @since 19\n+ * @since 22\n@@ -58,1 +60,0 @@\n-@PreviewFeature(feature = PreviewFeature.Feature.FOREIGN)\n@@ -98,1 +99,1 @@\n-     *         MemoryLayout.sequenceLayout(ValueLayout.JAVA_BYTE));\n+     *         MemoryLayout.sequenceLayout(Long.MAX_VALUE, ValueLayout.JAVA_BYTE));\n@@ -100,5 +101,0 @@\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/AddressLayout.java","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.internal.javac.PreviewFeature;\n@@ -47,3 +46,4 @@\n- * features an <em>unbounded lifetime<\/em>. As such, native segments allocated with the global arena are always\n- * accessible and their backing regions of memory are never deallocated. Moreover, memory segments allocated with the\n- * global arena can be {@linkplain MemorySegment#isAccessibleBy(Thread) accessed} from any thread.\n+ * features an <em>unbounded lifetime<\/em>. The scope of the global arena is the global scope.\n+ * As such, native segments allocated with the global arena are always accessible and their backing regions\n+ * of memory are never deallocated.\n+ * Moreover, memory segments allocated with the global arena can be {@linkplain MemorySegment#isAccessibleBy(Thread) accessed} from any thread.\n@@ -57,1 +57,2 @@\n- * which features a <em>bounded lifetime<\/em> that is managed, automatically, by the garbage collector. As such, the regions\n+ * which features a <em>bounded lifetime<\/em> that is managed, automatically, by the garbage collector. The scope\n+ * of an automatic arena is an automatic scope. As such, the regions\n@@ -71,5 +72,3 @@\n- * bounded lifetimes that are managed manually. For instance, the lifetime of a confined arena starts when the confined\n- * arena is created, and ends when the confined arena is {@linkplain #close() closed}. As a result, the regions of memory\n- * backing memory segments allocated with a confined arena are deallocated when the confined arena is closed.\n- * When this happens, all the segments allocated with the confined arena are invalidated, and subsequent access\n- * operations on these segments will fail {@link IllegalStateException}:\n+ * bounded lifetimes that are managed manually. For instance, when a confined arena is {@linkplain #close() closed}\n+ * successfully, its scope is {@linkplain Scope#isAlive() invalidated}. As a result, all the memory segments allocated\n+ * by the arena can no longer be accessed, and their regions of memory are deallocated:\n@@ -187,1 +186,1 @@\n- *         MemorySegment s = slicingArena.allocateArray(JAVA_INT, 1, 2, 3, 4, 5);\n+ *         MemorySegment s = slicingArena.allocateFrom(JAVA_INT, 1, 2, 3, 4, 5);\n@@ -198,1 +197,1 @@\n- * @since 20\n+ * @since 22\n@@ -200,1 +199,0 @@\n-@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n@@ -224,1 +222,1 @@\n-            static final Arena GLOBAL = MemorySessionImpl.GLOBAL.asArena();\n+            static final Arena GLOBAL = MemorySessionImpl.GLOBAL_SESSION.asArena();\n@@ -272,3 +270,1 @@\n-    default MemorySegment allocate(long byteSize, long byteAlignment) {\n-        return ((MemorySessionImpl)scope()).allocate(byteSize, byteAlignment);\n-    }\n+    MemorySegment allocate(long byteSize, long byteAlignment);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Arena.java","additions":13,"deletions":17,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import jdk.internal.javac.PreviewFeature;\n@@ -47,1 +46,1 @@\n- * @since 19\n+ * @since 22\n@@ -49,1 +48,0 @@\n-@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/FunctionDescriptor.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.internal.javac.PreviewFeature;\n@@ -41,1 +40,1 @@\n- * @since 19\n+ * @since 22\n@@ -43,1 +42,0 @@\n-@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/GroupLayout.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import jdk.internal.javac.PreviewFeature;\n@@ -35,1 +34,0 @@\n-import jdk.internal.reflect.Reflection;\n@@ -38,1 +36,1 @@\n-import java.nio.ByteOrder;\n+import java.util.Map;\n@@ -40,1 +38,0 @@\n-import java.util.Optional;\n@@ -63,0 +60,6 @@\n+ * A linker provides a way to look up the <em>canonical layouts<\/em> associated with the data types used by the ABI.\n+ * For example, a linker implementing the C ABI might choose to provide a canonical layout for the C {@code size_t}\n+ * type. On 64-bit platforms, this canonical layout might be equal to {@link ValueLayout#JAVA_LONG}. The canonical\n+ * layouts supported by a linker are exposed via the {@link #canonicalLayouts()} method, which returns a map from\n+ * type names to canonical layouts.\n+ * <p>\n@@ -96,1 +99,1 @@\n- *     MemorySegment str = arena.allocateUtf8String(\"Hello\");\n+ *     MemorySegment str = arena.allocateFrom(\"Hello\");\n@@ -99,1 +102,1 @@\n- * }\n+ *}\n@@ -107,5 +110,2 @@\n- * of a suitable carrier. The mapping between a scalar type and its corresponding layout is dependent on the ABI\n- * implemented by the native linker. For instance, the C type {@code long} maps to the layout constant\n- * {@link ValueLayout#JAVA_LONG} on Linux\/x64, but maps to the layout constant {@link ValueLayout#JAVA_INT} on\n- * Windows\/x64. Similarly, the C type {@code size_t} maps to the layout constant {@link ValueLayout#JAVA_LONG}\n- * on 64-bit platforms, but maps to the layout constant {@link ValueLayout#JAVA_INT} on 32-bit platforms.\n+ * of a suitable carrier. The {@linkplain #canonicalLayouts() mapping} between a scalar type and its corresponding\n+ * canonical layout is dependent on the ABI implemented by the native linker (see below).\n@@ -126,1 +126,27 @@\n- * The following table shows some examples of how C types are modelled in Linux\/x64:\n+ * All native linker implementations are guaranteed to provide canonical layouts for the following set of types:\n+ * <ul>\n+ *     <li>{@code bool}<\/li>\n+ *     <li>{@code char}<\/li>\n+ *     <li>{@code short}<\/li>\n+ *     <li>{@code int}<\/li>\n+ *     <li>{@code long}<\/li>\n+ *     <li>{@code long long}<\/li>\n+ *     <li>{@code float}<\/li>\n+ *     <li>{@code double}<\/li>\n+ *     <li>{@code size_t}<\/li>\n+ *     <li>{@code wchar_t}<\/li>\n+ *     <li>{@code void*}<\/li>\n+ * <\/ul>\n+ * As noted above, the specific canonical layout associated with each type can vary, depending on the data model\n+ * supported by a given ABI. For instance, the C type {@code long} maps to the layout constant {@link ValueLayout#JAVA_LONG}\n+ * on Linux\/x64, but maps to the layout constant {@link ValueLayout#JAVA_INT} on Windows\/x64. Similarly, the C type\n+ * {@code size_t} maps to the layout constant {@link ValueLayout#JAVA_LONG} on 64-bit platforms, but maps to the layout\n+ * constant {@link ValueLayout#JAVA_INT} on 32-bit platforms.\n+ * <p>\n+ * A native linker typically does not provide canonical layouts for C's unsigned integral types. Instead, they are\n+ * modelled using the canonical layouts associated with their corresponding signed integral types. For instance,\n+ * the C type {@code unsigned long} maps to the layout constant {@link ValueLayout#JAVA_LONG} on Linux\/x64, but maps to\n+ * the layout constant {@link ValueLayout#JAVA_INT} on Windows\/x64.\n+ * <p>\n+ * The following table shows some examples of how C types are modelled in Linux\/x64 according to the\n+ * \"System V Application Binary Interface\" (all the examples provided here will assume these platform-dependent mappings):\n@@ -141,1 +167,1 @@\n- * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code char}<\/th>\n+ * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code char} <br> {@code unsigned char}<\/th>\n@@ -144,1 +170,1 @@\n- * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code short}<\/th>\n+ * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code short} <br> {@code unsigned short}<\/th>\n@@ -147,1 +173,1 @@\n- * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code int}<\/th>\n+ * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code int} <br> {@code unsigned int}<\/th>\n@@ -150,1 +176,1 @@\n- * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code long}<\/th>\n+ * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code long} <br> {@code unsigned long}<\/th>\n@@ -153,1 +179,1 @@\n- * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code long long}<\/th>\n+ * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code long long} <br> {@code unsigned long long}<\/th>\n@@ -204,14 +230,1 @@\n- * <li>{@code L} is a value layout {@code V} and {@code V.withoutName()} is {@linkplain MemoryLayout#equals(Object) equal}\n- * to one of the following layout constants:\n- * <ul>\n- * <li>{@link ValueLayout#JAVA_BOOLEAN}<\/li>\n- * <li>{@link ValueLayout#JAVA_BYTE}<\/li>\n- * <li>{@link ValueLayout#JAVA_CHAR}<\/li>\n- * <li>{@link ValueLayout#JAVA_SHORT}<\/li>\n- * <li>{@link ValueLayout#JAVA_INT}<\/li>\n- * <li>{@link ValueLayout#JAVA_LONG}<\/li>\n- * <li>{@link ValueLayout#JAVA_FLOAT}<\/li>\n- * <li>{@link ValueLayout#JAVA_DOUBLE}<\/li>\n- * <\/ul><\/li>\n- * <li>{@code L} is an address layout {@code A} and {@code A.withoutTargetLayout().withoutName()} is\n- * {@linkplain MemoryLayout#equals(Object) equal} to {@link ValueLayout#ADDRESS}<\/li>\n+ * <li>{@code L} is a value layout {@code V} and {@code V.withoutName()} is a canonical layout<\/li>\n@@ -297,1 +310,1 @@\n- *     MemorySegment array = arena.allocateArray(JAVA_INT, 0, 9, 3, 4, 6, 5, 1, 8, 2, 7);\n+ *     MemorySegment array = arena.allocateFrom(JAVA_INT, 0, 9, 3, 4, 6, 5, 1, 8, 2, 7);\n@@ -355,1 +368,1 @@\n- * returned segment is a fresh scope that is always alive. To provide safe access to the segment, we must,\n+ * returned segment is the global scope. To provide safe access to the segment, we must,\n@@ -394,9 +407,5 @@\n- * Variadic functions are C functions which can accept a variable number and type of arguments. They are declared:\n- * <ol>\n- * <li>With a trailing ellipsis ({@code ...}) at the end of the formal parameter list, such as: {@code void foo(int x, ...);}<\/li>\n- * <li>With an empty formal parameter list, called a prototype-less function, such as: {@code void foo();}<\/li>\n- * <\/ol>\n- * The arguments passed in place of the ellipsis, or the arguments passed to a prototype-less function are called\n- * <em>variadic arguments<\/em>. Variadic functions are, essentially, templates that can be <em>specialized<\/em> into multiple\n- * non-variadic functions by replacing the {@code ...} or empty formal parameter list with a list of <em>variadic parameters<\/em>\n- * of a fixed number and type.\n+ * Variadic functions are C functions which can accept a variable number and type of arguments. They are declared with a\n+ * trailing ellipsis ({@code ...}) at the end of the formal parameter list, such as: {@code void foo(int x, ...);}\n+ * The arguments passed in place of the ellipsis are called <em>variadic arguments<\/em>. Variadic functions are,\n+ * essentially, templates that can be <em>specialized<\/em> into multiple non-variadic functions by replacing the\n+ * {@code ...} with a list of <em>variadic parameters<\/em> of a fixed number and type.\n@@ -414,2 +423,2 @@\n- * specialized form of a variadic function, as the variadic parameters of the specialized form will always have a promoted\n- * type.\n+ * types that can be used to replace the {@code ...}, as the variadic parameters of the specialized form of a variadic\n+ * function will always have a promoted type.\n@@ -421,2 +430,1 @@\n- * function descriptor, are called <em>variadic argument layouts<\/em>. For a prototype-less function, the index passed to\n- * {@link Linker.Option#firstVariadicArg(int)} should always be {@code 0}.\n+ * function descriptor, are called <em>variadic argument layouts<\/em>.\n@@ -424,5 +432,7 @@\n- * The native linker will reject an attempt to link a specialized function descriptor with any variadic argument layouts\n- * corresponding to a C type that would be subject to default argument promotion (as described above). Exactly which layouts\n- * will be rejected is platform specific, but as an example: on Linux\/x64 the layouts {@link ValueLayout#JAVA_BOOLEAN},\n- * {@link ValueLayout#JAVA_BYTE}, {@link ValueLayout#JAVA_CHAR}, {@link ValueLayout#JAVA_SHORT}, and\n- * {@link ValueLayout#JAVA_FLOAT} will be rejected.\n+ * The native linker does not automatically perform default argument promotions. However, since passing an argument of a\n+ * non-promoted type as a variadic argument is not supported in C, the native linker will reject an attempt to link a\n+ * specialized function descriptor with any variadic argument value layouts corresponding to a non-promoted C type.\n+ * Since the size of the C {@code int} type is platform-specific, exactly which layouts will be rejected is\n+ * platform-specific as well. As an example: on Linux\/x64 the layouts corresponding to the C types {@code _Bool},\n+ * {@code (unsigned) char}, {@code (unsigned) short}, and {@code float} (among others), will be rejected by the linker.\n+ * The {@link #canonicalLayouts()} method can be used to find which layout corresponds to a particular C type.\n@@ -464,2 +474,1 @@\n- *     int res = (int)printf.invokeExact(arena.allocateUtf8String(\"%d plus %d equals %d\"), 2, 2, 4); \/\/prints \"2 plus 2 equals 4\"\n- * }\n+ *     int res = (int)printf.invokeExact(arena.allocateFrom(\"%d plus %d equals %d\"), 2, 2, 4); \/\/prints \"2 plus 2 equals 4\"\n@@ -467,0 +476,1 @@\n+ *}\n@@ -486,1 +496,1 @@\n- * @since 19\n+ * @since 22\n@@ -488,1 +498,0 @@\n-@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n@@ -496,0 +505,2 @@\n+     * @implSpec A native linker implementation is guaranteed to provide canonical layouts for\n+     * <a href=\"#describing-c-sigs\">basic C types<\/a>.\n@@ -499,2 +510,0 @@\n-     *\n-     * @throws UnsupportedOperationException if the underlying native platform is not supported.\n@@ -513,5 +522,0 @@\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n@@ -558,1 +562,1 @@\n-     * a fresh scope that is always alive. Under normal conditions, the size of the returned segment is {@code 0}.\n+     * the global scope. Under normal conditions, the size of the returned segment is {@code 0}.\n@@ -563,7 +567,7 @@\n-     * representing the target address of the foreign function is the {@link MemorySegment#NULL} address.\n-     * The returned method handle will additionally throw {@link NullPointerException} if any argument passed to it is {@code null}.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n+     * representing the target address of the foreign function is the {@link MemorySegment#NULL} address. If an argument\n+     * is a {@link MemorySegment}, whose corresponding layout is a {@linkplain GroupLayout group layout}, the linker\n+     * might attempt to access the contents of the segment. As such, one of the exceptions specified by the\n+     * {@link MemorySegment#get(ValueLayout.OfByte, long)} or the\n+     * {@link MemorySegment#copy(MemorySegment, long, MemorySegment, long, long)} methods may be thrown.\n+     * The returned method handle will additionally throw {@link NullPointerException} if any argument\n+     * passed to it is {@code null}.\n@@ -593,1 +597,1 @@\n-     * is a native segment associated with a fresh scope that is always alive.\n+     * is a native segment associated with the global scope.\n@@ -603,5 +607,0 @@\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n@@ -642,0 +641,16 @@\n+    \/**\n+     * {@return an unmodifiable mapping between the names of data types used by the ABI implemented by this linker and their\n+     * <em>canonical layouts<\/em>}\n+     * <p>\n+     * Each {@link Linker} is responsible for choosing the data types that are widely recognized as useful on the OS\n+     * and processor combination supported by the {@link Linker}. Accordingly, the precise set of data type names\n+     * and canonical layouts exposed by the linker is unspecified; it varies from one {@link Linker} to another.\n+     * @implNote It is strongly recommended that the result of {@link #canonicalLayouts()} exposes a set of symbols that is stable over time.\n+     * Clients of {@link #canonicalLayouts()} are likely to fail if a data type that was previously exposed by the linker\n+     * is no longer exposed, or if its canonical layout is updated.\n+     * <p>If an implementer provides {@link Linker} implementations for multiple OS and processor combinations, then it is strongly\n+     * recommended that the result of {@link #canonicalLayouts()} exposes, as much as possible, a consistent set of symbols\n+     * across all the OS and processor combinations.\n+     *\/\n+    Map<String, MemoryLayout> canonicalLayouts();\n+\n@@ -644,1 +659,1 @@\n-     * @since 20\n+     * @since 22\n@@ -646,1 +661,0 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n@@ -710,0 +724,2 @@\n+         * <p>\n+         * This linker option can not be combined with {@link #critical}.\n@@ -753,1 +769,1 @@\n-         * {@return a linker option used to mark a foreign function as <em>trivial<\/em>}\n+         * {@return a linker option used to mark a foreign function as <em>critical<\/em>}\n@@ -755,2 +771,2 @@\n-         * A trivial function is a function that has an extremely short running time\n-         * in all cases (similar to calling an empty function), and does not call back into Java (e.g. using an upcall stub).\n+         * A critical function is a function that has an extremely short running time in all cases\n+         * (similar to calling an empty function), and does not call back into Java (e.g. using an upcall stub).\n@@ -759,1 +775,1 @@\n-         * optimizations that are only valid for trivial functions.\n+         * optimizations that are only valid for critical functions.\n@@ -761,1 +777,1 @@\n-         * Using this linker option when linking non trivial functions is likely to have adverse effects,\n+         * Using this linker option when linking non-critical functions is likely to have adverse effects,\n@@ -764,2 +780,2 @@\n-        static Option isTrivial() {\n-            return LinkerOptions.IsTrivial.INSTANCE;\n+        static Option critical() {\n+            return LinkerOptions.Critical.INSTANCE;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":101,"deletions":85,"binary":false,"changes":186,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.lang.invoke.MethodHandles;\n@@ -31,1 +30,0 @@\n-import java.util.EnumSet;\n@@ -34,2 +32,0 @@\n-import java.util.Set;\n-import java.util.function.Function;\n@@ -46,1 +42,0 @@\n-import jdk.internal.javac.PreviewFeature;\n@@ -51,1 +46,1 @@\n- * There are two leaves in the layout hierarchy, {@linkplain ValueLayout value layouts}, which are used to represent values of given size and kind (see\n+ * There are two leaves in the layout hierarchy, {@linkplain ValueLayout value layouts}, which are used to represent values of given size and kind\n@@ -79,1 +74,1 @@\n- * SequenceLayout taggedValues = MemoryLayout.sequenceLayout(5,\n+ * SequenceLayout TAGGED_VALUES = MemoryLayout.sequenceLayout(5,\n@@ -134,1 +129,1 @@\n- * long valueOffset = taggedValues.byteOffset(PathElement.sequenceElement(0),\n+ * long valueOffset = TAGGED_VALUES.byteOffset(PathElement.sequenceElement(0),\n@@ -140,1 +135,1 @@\n- * MemoryLayout value = taggedValues.select(PathElement.sequenceElement(),\n+ * MemoryLayout value = TAGGED_VALUES.select(PathElement.sequenceElement(),\n@@ -153,1 +148,1 @@\n- * VarHandle valueHandle = taggedValues.varHandle(PathElement.sequenceElement(),\n+ * VarHandle valueHandle = TAGGED_VALUES.varHandle(PathElement.sequenceElement(),\n@@ -155,2 +150,5 @@\n- * MemorySegment valuesSegment = ...\n- * int val = (int) valueHandle.get(valuesSegment, 2); \/\/ reads the \"value\" field of the third struct in the array\n+ * MemorySegment taggedValues = ...\n+ * \/\/ reads the \"value\" field of the third struct in the array (taggedValues[2].value)\n+ * int val = (int) valueHandle.get(taggedValues,\n+ *         0L,  \/\/ base offset\n+ *         2L); \/\/ sequence index\n@@ -166,1 +164,1 @@\n- * MethodHandle offsetHandle = taggedValues.byteOffsetHandle(PathElement.sequenceElement(),\n+ * MethodHandle offsetHandle = TAGGED_VALUES.byteOffsetHandle(PathElement.sequenceElement(),\n@@ -168,2 +166,2 @@\n- * long offset1 = (long) offsetHandle.invokeExact(1L); \/\/ 8\n- * long offset2 = (long) offsetHandle.invokeExact(2L); \/\/ 16\n+ * long offset1 = (long) offsetHandle.invokeExact(0L, 1L); \/\/ 0 + (1 * 8) = 8\n+ * long offset2 = (long) offsetHandle.invokeExact(0L, 2L); \/\/ 0 + (2 * 8) = 16\n@@ -207,1 +205,4 @@\n- * int rect_y_4 = (int) rectPointYs.get(rect, 2); \/\/ rect.points[2]->y\n+ * \/\/ dereferences the third point struct in the \"points\" array, and reads its \"y\" coordinate (rect.points[2]->y)\n+ * int rect_y_2 = (int) rectPointYs.get(rect,\n+ *     0L,  \/\/ base offset\n+ *     2L); \/\/ sequence index\n@@ -234,0 +235,158 @@\n+ * <h2 id=\"access-mode-restrictions\">Access mode restrictions<\/h2>\n+ *\n+ * A var handle returned by {@link #varHandle(PathElement...)} or {@link ValueLayout#varHandle()} features certain\n+ * access characteristics, which are derived from the selected layout {@code L}:\n+ * <ul>\n+ * <li>A carrier type {@code T}, derived from {@code L.carrier()}<\/li>\n+ * <li>An alignment constraint {@code A}, derived from {@code L.byteAlignment()}<\/li>\n+ * <li>An access size {@code S}, derived from {@code L.byteSize()}<\/li>\n+ * <\/ul>\n+ * Depending on the above characteristics, the returned var handle might feature certain <i>access mode restrictions<\/i>.\n+ * We say that a var handle is <em>aligned<\/em> if its alignment constraint {@code A} is compatible with the access size\n+ * {@code S}, that is if {@code A >= S}. An aligned var handle is guaranteed to support the following access modes:\n+ * <ul>\n+ * <li>read write access modes for all {@code T}. On 32-bit platforms, access modes\n+ *     {@code get} and {@code set} for {@code long}, {@code double} and {@code MemorySegment}\n+ *     are supported but might lead to word tearing, as described in Section {@jls 17.7}.\n+ *     of <cite>The Java Language Specification<\/cite>.\n+ * <li>atomic update access modes for {@code int}, {@code long},\n+ *     {@code float}, {@code double} and {@link MemorySegment}.\n+ *     (Future major platform releases of the JDK may support additional\n+ *     types for certain currently unsupported access modes.)\n+ * <li>numeric atomic update access modes for {@code int}, {@code long} and {@link MemorySegment}.\n+ *     (Future major platform releases of the JDK may support additional\n+ *     numeric types for certain currently unsupported access modes.)\n+ * <li>bitwise atomic update access modes for {@code int}, {@code long} and {@link MemorySegment}.\n+ *     (Future major platform releases of the JDK may support additional\n+ *     numeric types for certain currently unsupported access modes.)\n+ * <\/ul>\n+ * If {@code T} is {@code float}, {@code double} or {@link MemorySegment} then atomic update access modes compare\n+ * values using their bitwise representation (see {@link Float#floatToRawIntBits}, {@link Double#doubleToRawLongBits}\n+ * and {@link MemorySegment#address()}, respectively).\n+ * <p>\n+ * Alternatively, a var handle is <em>unaligned<\/em> if its alignment constraint {@code A} is incompatible with the\n+ * access size {@code S}, that is, if {@code A < S}. An unaligned var handle only supports the {@code get} and {@code set}\n+ * access modes. All other access modes will result in {@link UnsupportedOperationException} being thrown. Moreover,\n+ * while supported, access modes {@code get} and {@code set} might lead to word tearing.\n+ *\n+ * <h2 id=\"variable-length\">Working with variable-length arrays<\/h2>\n+ *\n+ * We have seen how sequence layouts are used to describe the contents of an array whose size is known <em>statically<\/em>.\n+ * There are cases, however, where the array size is only known <em>dynamically<\/em>. We call such arrays <em>variable-length arrays<\/em>.\n+ * There are two common kinds of variable-length arrays:\n+ * <ul>\n+ *     <li>a <em>toplevel<\/em> variable-length array whose size depends on the value of some unrelated variable, or parameter;<\/li>\n+ *     <li>an variable-length array <em>nested<\/em> in a struct, whose size depends on the value of some other field in the enclosing struct.<\/li>\n+ * <\/ul>\n+ * While variable-length arrays cannot be modelled directly using sequence layouts, clients can still enjoy structured\n+ * access to elements of variable-length arrays using var handles as demonstrated in the following sections.\n+ *\n+ * <h3 id=\"variable-length-toplevel\">Toplevel variable-length arrays<\/h3>\n+ *\n+ * Consider the following struct declaration in C:\n+ *\n+ * {@snippet lang=c :\n+ * typedef struct {\n+ *     int x;\n+ *     int y;\n+ * } Point;\n+ * }\n+ *\n+ * In the above code, a point is modelled as two coordinates ({@code x} and {@code y} respectively). Now consider\n+ * the following snippet of C code:\n+ *\n+ * {@snippet lang=c :\n+ * int size = ...\n+ * Point *points = (Point*)malloc(sizeof(Point) * size);\n+ * for (int i = 0 ; i < size ; i++) {\n+ *    ... points[i].x ...\n+ * }\n+ * }\n+ *\n+ * Here, we allocate an array of point ({@code points}). Crucially, the size of the array is dynamically bound to the value\n+ * of the {@code size} variable. Inside the loop, the {@code x} coordinate of all the points in the array is accessed.\n+ * <p>\n+ * To model this code in Java, let's start by defining a layout for the {@code Point} struct, as follows:\n+ *\n+ * {@snippet lang=java :\n+ * StructLayout POINT = MemoryLayout.structLayout(\n+ *             ValueLayout.JAVA_INT.withName(\"x\"),\n+ *             ValueLayout.JAVA_INT.withName(\"y\")\n+ * );\n+ * }\n+ *\n+ * Since we know we need to create and access an array of points, it would be tempting to create a sequence layout modelling\n+ * the variable-length array, and then derive the necessary access var handles from the sequence layout. But this approach\n+ * is problematic, as the size of the variable-length array is not known. Instead, a var handle that provides structured\n+ * access to the elements of a variable-length array can be obtained directly from the layout describing the array elements\n+ * (e.g. the point layout), as demonstrated below:\n+ *\n+ * {@snippet lang=java :\n+ * VarHandle POINT_ARR_X = POINT.arrayElementVarHandle(PathElement.groupElement(\"x\"));\n+ *\n+ * int size = ...\n+ * MemorySegment points = ...\n+ * for (int i = 0 ; i < size ; i++) {\n+ *     ... POINT_ARR_X.get(segment, 0L, (long)i) ...\n+ * }\n+ * }\n+ *\n+ * Here, the coordinate {@code x} of subsequent point in the array is accessed using the {@code POINT_ARR_X} var\n+ * handle, which is obtained using the {@link #arrayElementVarHandle(PathElement...)} method. This var handle\n+ * features two {@code long} coordinates: the first is a base offset (set to {@code 0L}), while the\n+ * second is a logical index that can be used to stride over all the elements of the point array.\n+ * <p>\n+ * The base offset coordinate allows clients to express complex access operations, by injecting additional offset\n+ * computation into the var handle (we will see an example of that below). In cases where the base offset is constant\n+ * (as in the previous example) clients can, if desired, drop the base offset parameter and make the access expression\n+ * simpler. This is achieved using the {@link java.lang.invoke.MethodHandles#insertCoordinates(VarHandle, int, Object...)}\n+ * var handle adapter.\n+ *\n+ * <h3 id=\"variable-length-nested\">Nested variable-length arrays<\/h3>\n+ *\n+ * Consider the following struct declaration in C:\n+ *\n+ * {@snippet lang=c :\n+ * typedef struct {\n+ *     int size;\n+ *     Point points[];\n+ * } Polygon;\n+ * }\n+ *\n+ * In the above code, a polygon is modelled as a size (the number of edges in the polygon) and an array of points\n+ * (one for each vertex in the polygon). The number of vertices depends on the number of edges in the polygon. As such,\n+ * the size of the {@code points} array is left <em>unspecified<\/em> in the C declaration, using a <em>Flexible Array Member<\/em>\n+ * (a feature standardized in C99).\n+ * <p>\n+ * Again, clients can perform structured access to elements in the nested variable-length array using the\n+ * {@link #arrayElementVarHandle(PathElement...)} method, as demonstrated below:\n+ *\n+ * {@snippet lang=java :\n+ * StructLayout POLYGON = MemoryLayout.structLayout(\n+ *             ValueLayout.JAVA_INT.withName(\"size\"),\n+ *             MemoryLayout.sequenceLayout(0, POINT).withName(\"points\")\n+ * );\n+ *\n+ * VarHandle POLYGON_SIZE = POLYGON.varHandle(0, PathElement.groupElement(\"size\"));\n+ * long POINTS_OFFSET = POLYGON.byteOffset(PathElement.groupElement(\"points\"));\n+ * }\n+ *\n+ * The {@code POLYGON} layout contains a sequence layout of size <em>zero<\/em>. The element layout of the sequence layout\n+ * is the {@code POINT} layout, shown previously. The polygon layout is used to obtain a var handle\n+ * that provides access to the polygon size, as well as an offset ({@code POINTS_OFFSET}) to the start of the\n+ * variable-length {@code points} array.\n+ * <p>\n+ * The {@code x} coordinates of all the points in a polygon can then be accessed as follows:\n+ * {@snippet lang=java :\n+ * MemorySegment polygon = ...\n+ * int size = POLYGON_SIZE.get(polygon, 0L);\n+ * for (int i = 0 ; i < size ; i++) {\n+ *     ... POINT_ARR_X.get(polygon, POINTS_OFFSET, (long)i) ...\n+ * }\n+ *  }\n+ * Here, we first obtain the polygon size, using the {@code POLYGON_SIZE} var handle. Then, in a loop, we read\n+ * the {@code x} coordinates of all the points in the polygon. This is done by providing a custom offset\n+ * (namely, {@code POINTS_OFFSET}) to the offset coordinate of the {@code POINT_ARR_X} var handle. As before,\n+ * the loop induction variable {@code i} is passed as the index of the {@code POINT_ARR_X} var handle,\n+ * to stride over all the elements of the variable-length array.\n+ *\n@@ -238,1 +397,1 @@\n- * @since 19\n+ * @since 22\n@@ -240,1 +399,0 @@\n-@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n@@ -295,0 +453,15 @@\n+    \/**\n+     * {@return {@code offset + (byteSize() * index)}}\n+     *\n+     * @param offset the base offset\n+     * @param index the index to be scaled by the byte size of this layout\n+     * @throws IllegalArgumentException if {@code offset} or {@code index} is negative\n+     * @throws ArithmeticException if either the addition or multiplication overflows\n+     *\/\n+    long scale(long offset, long index);\n+\n+    \/**\n+     *{@return a method handle that can be used to invoke {@link #scale(long, long)} on this layout}\n+     *\/\n+    MethodHandle scaleHandle();\n+\n@@ -305,4 +478,1 @@\n-    default long byteOffset(PathElement... elements) {\n-        return computePathOp(LayoutPath.rootPath(this), LayoutPath::offset,\n-                EnumSet.of(PathKind.SEQUENCE_ELEMENT, PathKind.SEQUENCE_RANGE, PathKind.DEREF_ELEMENT), elements);\n-    }\n+    long byteOffset(PathElement... elements);\n@@ -317,1 +487,2 @@\n-     *     <li>it has as zero or more parameters of type {@code long}, one for each <a href=#open-path-elements>open path element<\/a>\n+     *     <li>it has one leading {@code long} parameter representing the base offset;<\/li>\n+     *     <li>it has as zero or more trailing parameters of type {@code long}, one for each <a href=#open-path-elements>open path element<\/a>\n@@ -325,1 +496,1 @@\n-     * offset = c_1 + c_2 + ... + c_m + (x_1 * s_1) + (x_2 * s_2) + ... + (x_n * s_n)\n+     * offset = b + c_1 + c_2 + ... + c_m + (x_1 * s_1) + (x_2 * s_2) + ... + (x_n * s_n)\n@@ -328,4 +499,5 @@\n-     * where {@code x_1}, {@code x_2}, ... {@code x_n} are <em>dynamic<\/em> values provided as {@code long}\n-     * arguments, whereas {@code c_1}, {@code c_2}, ... {@code c_m} are <em>static<\/em> offset constants\n-     * and {@code s_0}, {@code s_1}, ... {@code s_n} are <em>static<\/em> stride constants which are derived from\n-     * the layout path.\n+     * where {@code b} represents the base offset provided as a <em>dynamic<\/em> {@code long} argument, {@code x_1}, {@code x_2},\n+     * ... {@code x_n} represent indices into sequences provided as <em>dynamic<\/em> {@code long} arguments, whereas\n+     * {@code s_1}, {@code s_2}, ... {@code s_n} are <em>static<\/em> stride constants derived from the size of the element\n+     * layout of a sequence, and {@code c_1}, {@code c_2}, ... {@code c_m} are other <em>static<\/em> offset constants\n+     * (such as field offsets) which are derived from the layout path.\n@@ -341,4 +513,1 @@\n-    default MethodHandle byteOffsetHandle(PathElement... elements) {\n-        return computePathOp(LayoutPath.rootPath(this), LayoutPath::offsetHandle,\n-                EnumSet.of(PathKind.DEREF_ELEMENT), elements);\n-    }\n+    MethodHandle byteOffsetHandle(PathElement... elements);\n@@ -354,4 +523,6 @@\n-     *     <li>it has as zero or more access coordinates of type {@code long}, one for each\n-     *     <a href=#open-path-elements>open path element<\/a> in the provided layout path. The order of these access\n-     *     coordinates corresponds to the order in which the open path elements occur in the provided\n-     *     layout path.\n+     *     <li>it has a leading parameter of type {@code MemorySegment} representing the accessed segment<\/li>\n+     *     <li>a following {@code long} parameter, corresponding to the base offset, denoted as {@code B};<\/li>\n+     *     <li>it has zero or more trailing access coordinates of type {@code long}, one for each\n+     *     <a href=#open-path-elements>open path element<\/a> in the provided layout path, denoted as\n+     *     {@code I1, I2, ... In}, respectively. The order of these access coordinates corresponds to the order\n+     *     in which the open path elements occur in the provided layout path.\n@@ -360,5 +531,2 @@\n-     * The final address accessed by the returned var handle can be computed as follows:\n-     *\n-     * <blockquote><pre>{@code\n-     * address = base(segment) + offset\n-     * }<\/pre><\/blockquote>\n+     * If the provided layout path {@code P} contains no dereference elements, then the offset {@code O} of the access\n+     * operation is computed as follows:\n@@ -366,13 +534,3 @@\n-     * Where {@code base(segment)} denotes a function that returns the physical base address of the accessed\n-     * memory segment. For native segments, this function just returns the native segment's\n-     * {@linkplain MemorySegment#address() address}. For heap segments, this function is more complex, as the address\n-     * of heap segments is virtualized. The {@code offset} value can be expressed in the following form:\n-     *\n-     * <blockquote><pre>{@code\n-     * offset = c_1 + c_2 + ... + c_m + (x_1 * s_1) + (x_2 * s_2) + ... + (x_n * s_n)\n-     * }<\/pre><\/blockquote>\n-     *\n-     * where {@code x_1}, {@code x_2}, ... {@code x_n} are <em>dynamic<\/em> values provided as {@code long}\n-     * arguments, whereas {@code c_1}, {@code c_2}, ... {@code c_m} are <em>static<\/em> offset constants\n-     * and {@code s_1}, {@code s_2}, ... {@code s_n} are <em>static<\/em> stride constants which are derived from\n-     * the layout path.\n+     * {@snippet lang = \"java\":\n+     * O = this.offsetHandle(P).invokeExact(B, I1, I2, ... In);\n+     * }\n@@ -380,2 +538,15 @@\n-     * Additionally, the provided dynamic values must conform to bounds which are derived from the layout path, that is,\n-     * {@code 0 <= x_i < b_i}, where {@code 1 <= i <= n}, or {@link IndexOutOfBoundsException} is thrown.\n+     * Accessing a memory segment using the var handle returned by this method is subject to the following checks:\n+     * <ul>\n+     *     <li>The physical address of the accessed memory segment must be <a href=\"MemorySegment.html#segment-alignment\">aligned<\/a>\n+     * according to the {@linkplain #byteAlignment() alignment constraint} of the root layout (this layout), or\n+     * an {@link IllegalArgumentException} will be issued. Note that the alignment constraint of the root layout\n+     * can be more strict (but not less) than the alignment constraint of the selected value layout.<\/li>\n+     *     <li>The offset of the access operation (computed as above) must fall inside the spatial bounds of the\n+     * accessed memory segment, or an {@link IndexOutOfBoundsException} is thrown. This is the case when {@code O + A <= S},\n+     * where {@code O} is the accessed offset (computed as above), {@code A} is the size of the selected layout and {@code S}\n+     * is the size of the accessed memory segment.<\/li>\n+     *     <li>The accessed memory segment must be {@link MemorySegment#isAccessibleBy(Thread) accessible} from the\n+     * thread performing the access operation, or a {@link WrongThreadException} is thrown.<\/li>\n+     *     <li>The {@linkplain MemorySegment#scope() scope} associated with the accessed segment must be\n+     * {@linkplain MemorySegment.Scope#isAlive() alive}, or an {@link IllegalStateException} is thrown.<\/li>\n+     * <\/ul>\n@@ -383,3 +554,13 @@\n-     * The base address must be <a href=\"MemorySegment.html#segment-alignment\">aligned<\/a> according to the {@linkplain\n-     * #byteAlignment() alignment constraint} of the root layout (this layout). Note that this can be more strict\n-     * (but not less) than the alignment constraint of the selected value layout.\n+     * If the selected layout is an {@linkplain AddressLayout address layout}, calling {@link VarHandle#get(Object...)}\n+     * on the returned var handle will return a new memory segment. The segment is associated with the global scope.\n+     * Moreover, the size of the segment depends on whether the address layout has a\n+     * {@linkplain AddressLayout#targetLayout() target layout}. More specifically:\n+     * <ul>\n+     *     <li>If the address layout has a target layout {@code T}, then the size of the returned segment\n+     *     is {@code T.byteSize()};<\/li>\n+     *     <li>Otherwise, the address layout has no target layout, and the size of the returned segment\n+     *     is <a href=\"MemorySegment.html#wrapping-addresses\">zero<\/a>.<\/li>\n+     * <\/ul>\n+     * Moreover, if the selected layout is an {@linkplain AddressLayout address layout}, calling {@link VarHandle#set(Object...)}\n+     * can throw {@link IllegalArgumentException} if the memory segment representing the address to be written is not a\n+     * {@linkplain MemorySegment#isNative() native} memory segment.\n@@ -387,5 +568,4 @@\n-     * Multiple paths can be chained, with <a href=#deref-path-elements>dereference path elements<\/a>.\n-     * A dereference path element constructs a fresh native memory segment whose base address is the address value\n-     * read obtained by accessing a memory segment at the offset determined by the layout path elements immediately preceding\n-     * the dereference path element. In other words, if a layout path contains one or more dereference path elements,\n-     * the final address accessed by the returned var handle can be computed as follows:\n+     * If the provided layout path has size {@code m} and contains a dereference path element in position {@code k}\n+     * (where {@code k <= m}) then two layout paths {@code P} and {@code P'} are derived, where P contains all the path\n+     * elements from 0 to {@code k - 1} and {@code P'} contains all the path elements from {@code k + 1} to\n+     * {@code m} (if any). Then, the returned var handle is computed as follows:\n@@ -393,6 +573,8 @@\n-     * <blockquote><pre>{@code\n-     * address_1 = base(segment) + offset_1\n-     * address_2 = base(segment_1) + offset_2\n-     * ...\n-     * address_k = base(segment_k-1) + offset_k\n-     * }<\/pre><\/blockquote>\n+     * {@snippet lang = \"java\":\n+     * VarHandle baseHandle = this.varHandle(P);\n+     * MemoryLayout target = ((AddressLayout)this.select(P)).targetLayout().get();\n+     * VarHandle targetHandle = target.varHandle(P);\n+     * targetHandle = MethodHandles.insertCoordinates(targetHandle, 1, 0L); \/\/ always access nested targets at offset 0\n+     * targetHandle = MethodHandles.collectCoordinates(targetHandle, 0,\n+     *         baseHandle.toMethodHandle(VarHandle.AccessMode.GET));\n+     * }\n@@ -400,8 +582,14 @@\n-     * where {@code k} is the number of dereference path elements in a layout path, {@code segment} is the input segment,\n-     * {@code segment_1}, ...  {@code segment_k-1} are the segments obtained by dereferencing the address associated with\n-     * a given dereference path element (e.g. {@code segment_1} is a native segment whose base address is {@code address_1}),\n-     * and {@code offset_1}, {@code offset_2}, ... {@code offset_k} are the offsets computed by evaluating\n-     * the path elements after a given dereference operation (these offsets are obtained using the computation described\n-     * above). In these more complex access operations, all memory accesses immediately preceding a dereference operation\n-     * (e.g. those at addresses {@code address_1}, {@code address_2}, ...,  {@code address_k-1} are performed using the\n-     * {@link VarHandle.AccessMode#GET} access mode.\n+     * (The above can be trivially generalized to cases where the provided layout path contains more than one dereference\n+     * path elements).\n+     * <p>\n+     * As an example, consider the memory layout expressed by a {@link GroupLayout} instance constructed as follows:\n+     * {@snippet lang = \"java\":\n+     *     GroupLayout grp = java.lang.foreign.MemoryLayout.structLayout(\n+     *             MemoryLayout.paddingLayout(4),\n+     *             ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN).withName(\"value\")\n+     *     );\n+     * }\n+     * To access the member layout named {@code value}, we can construct a var handle as follows:\n+     * {@snippet lang = \"java\":\n+     *     VarHandle handle = grp.varHandle(PathElement.groupElement(\"value\")); \/\/(MemorySegment, long) -> int\n+     * }\n@@ -409,2 +597,2 @@\n-     * @apiNote The resulting var handle features certain <em>access mode restrictions<\/em>, which are common to all\n-     * {@linkplain MethodHandles#memorySegmentViewVarHandle(ValueLayout) memory segment view handles}.\n+     * @apiNote The resulting var handle features certain <a href=\"#access-mode-restrictions\"><em>access mode restrictions<\/em><\/a>,\n+     * which are common to all var handles derived from memory layouts.\n@@ -416,1 +604,0 @@\n-     * @see MethodHandles#memorySegmentViewVarHandle(ValueLayout)\n@@ -418,4 +605,44 @@\n-    default VarHandle varHandle(PathElement... elements) {\n-        return computePathOp(LayoutPath.rootPath(this), LayoutPath::dereferenceHandle,\n-                Set.of(), elements);\n-    }\n+    VarHandle varHandle(PathElement... elements);\n+\n+    \/**\n+     * Creates a var handle that accesses adjacent elements in a memory segment at offsets selected by the given layout path,\n+     * where the accessed elements have this layout, and where the initial layout in the path is this layout.\n+     * <p>\n+     * The returned var handle has the following characteristics:\n+     * <ul>\n+     *     <li>its type is derived from the {@linkplain ValueLayout#carrier() carrier} of the\n+     *     selected value layout;<\/li>\n+     *     <li>it has a leading parameter of type {@code MemorySegment} representing the accessed segment<\/li>\n+     *     <li>a following {@code long} parameter, corresponding to the base offset, denoted as {@code B};<\/li>\n+     *     <li>a following {@code long} parameter, corresponding to the array index, denoted as {@code I0}. The array\n+     *     index is used to scale the accessed offset by this layout size;<\/li>\n+     *     <li>it has zero or more trailing access coordinates of type {@code long}, one for each\n+     *     <a href=#open-path-elements>open path element<\/a> in the provided layout path, denoted as\n+     *     {@code I1, I2, ... In}, respectively. The order of these access coordinates corresponds to the order\n+     *     in which the open path elements occur in the provided layout path.\n+     * <\/ul>\n+     * <p>\n+     * If the provided layout path {@code P} contains no dereference elements, then the offset {@code O} of the access\n+     * operation is computed as follows:\n+     *\n+     * {@snippet lang = \"java\":\n+     * O = this.offsetHandle(P).invokeExact(this.scale(B, I0), I1, I2, ... In);\n+     * }\n+     * <p>\n+     * More formally, this method can be obtained from the {@link #varHandle(PathElement...)}, as follows:\n+     * {@snippet lang = \"java\":\n+     * MethodHandles.collectCoordinates(varHandle(elements), 1, scaleHandle())\n+     * }\n+     *\n+     * @apiNote\n+     * As the leading index coordinate {@code I0} is not bound by any sequence layout, it can assume <em>any<\/em> non-negative\n+     * value - provided that the resulting offset computation does not overflow, or that the computed offset does not fall\n+     * outside the spatial bound of the accessed memory segment. As such, the var handles returned from this method can\n+     * be especially useful when accessing <a href=\"#variable-length\">variable-length arrays<\/a>.\n+     *\n+     * @param elements the layout path elements.\n+     * @return a var handle that accesses adjacent elements in a memory segment at offsets selected by the given layout path.\n+     * @throws IllegalArgumentException if the layout path is not <a href=\"#well-formedness\">well-formed<\/a> for this layout.\n+     * @throws IllegalArgumentException if the layout selected by the provided path is not a {@linkplain ValueLayout value layout}.\n+     *\/\n+    VarHandle arrayElementVarHandle(PathElement... elements);\n@@ -430,3 +657,3 @@\n-     *     <li>it has a leading parameter of type {@code MemorySegment}, corresponding to the memory segment\n-     *     to be sliced;<\/li>\n-     *     <li>it has as zero or more parameters of type {@code long}, one for each <a href=#open-path-elements>open path element<\/a>\n+     *     <li>it has a leading parameter of type {@code MemorySegment} corresponding to the memory segment to be sliced<\/li>\n+     *     <li>a following {@code long} parameter, corresponding to the base offset<\/li>\n+     *     <li>it has as zero or more trailing parameters of type {@code long}, one for each <a href=#open-path-elements>open path element<\/a>\n@@ -437,6 +664,2 @@\n-     * The offset of the returned segment is computed as follows:\n-     * {@snippet lang=java :\n-     * long offset = byteOffset(elements);\n-     * long size = select(elements).byteSize();\n-     * MemorySegment slice = segment.asSlice(offset, size);\n-     * }\n+     * The offset {@code O} of the returned segment is computed as if by a call to a\n+     * {@linkplain #byteOffsetHandle(PathElement...) byte offset handle} constructed using the given path elements.\n@@ -444,3 +667,11 @@\n-     * The segment to be sliced must be <a href=\"MemorySegment.html#segment-alignment\">aligned<\/a> according to the\n-     * {@linkplain #byteAlignment() alignment constraint} of the root layout (this layout). Note that this can be more\n-     * strict (but not less) than the alignment constraint of the selected value layout.\n+     * Computing a slice of a memory segment using the method handle returned by this method is subject to the following checks:\n+     * <ul>\n+     *     <li>The physical address of the accessed memory segment must be <a href=\"MemorySegment.html#segment-alignment\">aligned<\/a>\n+     * according to the {@linkplain #byteAlignment() alignment constraint} of the root layout (this layout), or\n+     * an {@link IllegalArgumentException} will be issued. Note that the alignment constraint of the root layout\n+     * can be more strict (but not less) than the alignment constraint of the selected layout.<\/li>\n+     *     <li>The start offset of the slicing operation (computed as above) must fall fall inside the spatial bounds of the\n+     * accessed memory segment, or an {@link IndexOutOfBoundsException} is thrown. This is the case when {@code O + A <= S},\n+     * where {@code O} is the start offset of the slicing operation (computed as above), {@code A} is the size of the\n+     * selected layout and {@code S} is the size of the accessed memory segment.<\/li>\n+     * <\/ul>\n@@ -456,4 +687,1 @@\n-    default MethodHandle sliceHandle(PathElement... elements) {\n-        return computePathOp(LayoutPath.rootPath(this), LayoutPath::sliceHandle,\n-                Set.of(PathKind.DEREF_ELEMENT), elements);\n-    }\n+    MethodHandle sliceHandle(PathElement... elements);\n@@ -471,17 +699,1 @@\n-    default MemoryLayout select(PathElement... elements) {\n-        return computePathOp(LayoutPath.rootPath(this), LayoutPath::layout,\n-                EnumSet.of(PathKind.SEQUENCE_ELEMENT_INDEX, PathKind.SEQUENCE_RANGE, PathKind.DEREF_ELEMENT), elements);\n-    }\n-\n-    private static <Z> Z computePathOp(LayoutPath path, Function<LayoutPath, Z> finalizer,\n-                                       Set<PathKind> badKinds, PathElement... elements) {\n-        Objects.requireNonNull(elements);\n-        for (PathElement e : elements) {\n-            LayoutPath.PathElementImpl pathElem = (LayoutPath.PathElementImpl)Objects.requireNonNull(e);\n-            if (badKinds.contains(pathElem.kind())) {\n-                throw new IllegalArgumentException(String.format(\"Invalid %s selection in layout path\", pathElem.kind().description()));\n-            }\n-            path = pathElem.apply(path);\n-        }\n-        return finalizer.apply(path);\n-    }\n+    MemoryLayout select(PathElement... elements);\n@@ -504,1 +716,1 @@\n-     * @since 19\n+     * @since 22\n@@ -506,1 +718,0 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n@@ -672,18 +883,0 @@\n-    \/**\n-     * Creates a sequence layout with the given element layout and the maximum element\n-     * count such that it does not overflow a {@code long}.\n-     *\n-     * This is equivalent to the following code:\n-     * {@snippet lang = java:\n-     * sequenceLayout(Long.MAX_VALUE \/ elementLayout.byteSize(), elementLayout);\n-     * }\n-     *\n-     * @param elementLayout the sequence element layout.\n-     * @return a new sequence layout with the given element layout and maximum element count.\n-     * @throws IllegalArgumentException if {@code elementLayout.byteSize() % elementLayout.byteAlignment() != 0}.\n-     *\/\n-    static SequenceLayout sequenceLayout(MemoryLayout elementLayout) {\n-        Objects.requireNonNull(elementLayout);\n-        return sequenceLayout(Long.MAX_VALUE \/ elementLayout.byteSize(), elementLayout);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryLayout.java","additions":331,"deletions":138,"binary":false,"changes":469,"status":"modified"},{"patch":"@@ -29,3 +29,1 @@\n-import java.lang.foreign.Linker.Option;\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n+import java.lang.foreign.ValueLayout.OfInt;\n@@ -37,1 +35,2 @@\n-import java.nio.channels.FileChannel.*;\n+import java.nio.channels.FileChannel.MapMode;\n+import java.nio.charset.Charset;\n@@ -46,1 +45,0 @@\n-import jdk.internal.foreign.HeapMemorySegmentImpl;\n@@ -48,5 +46,1 @@\n-import jdk.internal.foreign.NativeMemorySegmentImpl;\n-import jdk.internal.foreign.Utils;\n-import jdk.internal.foreign.abi.SharedUtils;\n-import jdk.internal.foreign.layout.ValueLayouts;\n-import jdk.internal.javac.PreviewFeature;\n+import jdk.internal.foreign.SegmentFactories;\n@@ -127,1 +121,0 @@\n- * MemorySegment segment = ...\n@@ -131,5 +124,3 @@\n- * For more complex access operations (e.g. structured memory access), clients can obtain a\n- * {@linkplain MethodHandles#memorySegmentViewVarHandle(ValueLayout) var handle}\n- * that accepts a segment and a {@code long} offset. More complex var handles\n- * can be obtained by adapting a segment var handle view using the var handle combinator functions defined in the\n- * {@link java.lang.invoke.MethodHandles} class:\n+ * Access operations on memory segments are implemented using var handles. The {@link ValueLayout#varHandle()}\n+ * method can be used to obtain a var handle that can be used to get\/set values represented by the given value layout\n+ * on a memory segment at the given offset:\n@@ -137,9 +128,3 @@\n- * {@snippet lang=java :\n- * MemorySegment segment = ...\n- * VarHandle intHandle = MethodHandles.memorySegmentViewVarHandle(ValueLayout.JAVA_INT);\n- * MethodHandle multiplyExact = MethodHandles.lookup()\n- *                                           .findStatic(Math.class, \"multiplyExact\",\n- *                                                                   MethodType.methodType(long.class, long.class, long.class));\n- * intHandle = MethodHandles.filterCoordinates(intHandle, 1,\n- *                                             MethodHandles.insertArguments(multiplyExact, 0, ValueLayout.JAVA_INT.byteSize()));\n- * int value = (int) intHandle.get(segment, 3L); \/\/ get int element at offset 3 * 4 = 12\n+ * {@snippet lang=java:\n+ * VarHandle intAtOffsetHandle = ValueLayout.JAVA_INT.varHandle(); \/\/ (MemorySegment, long)\n+ * int value = (int) intAtOffsetHandle.get(segment, 10L);          \/\/ segment.get(ValueLayout.JAVA_INT, 10L)\n@@ -148,3 +133,2 @@\n- * Alternatively, complex var handles can can be obtained\n- * from {@linkplain MemoryLayout#varHandle(MemoryLayout.PathElement...) memory layouts}\n- * by providing a so called <a href=\"MemoryLayout.html#layout-paths\"><em>layout path<\/em><\/a>:\n+ * Alternatively, a var handle that can be used to access an element of an {@code int} array at a given logical\n+ * index can be created as follows:\n@@ -152,4 +136,4 @@\n- * {@snippet lang=java :\n- * MemorySegment segment = ...\n- * VarHandle intHandle = ValueLayout.JAVA_INT.arrayElementVarHandle();\n- * int value = (int) intHandle.get(segment, 3L); \/\/ get int element at offset 3 * 4 = 12\n+ * {@snippet lang=java:\n+ * VarHandle intAtOffsetAndIndexHandle =\n+ *         ValueLayout.JAVA_INT.arrayElementVarHandle();             \/\/ (MemorySegment, long, long)\n+ * int value = (int) intAtOffsetAndIndexHandle.get(segment, 2L, 3L); \/\/ segment.get(ValueLayout.JAVA_INT, 2L + (3L * 4L))\n@@ -158,0 +142,13 @@\n+ * <p>\n+ * Clients can also drop the base offset parameter, in order to make the access expression simpler. This can be used to\n+ * implement access operations such as {@link #getAtIndex(OfInt, long)}:\n+ *\n+ * {@snippet lang=java:\n+ * VarHandle intAtIndexHandle =\n+ *         MethodHandles.insertCoordinates(intAtOffsetAndIndexHandle, 1, 0L); \/\/ (MemorySegment, long)\n+ * int value = (int) intAtIndexHandle.get(segment, 3L);                       \/\/ segment.getAtIndex(ValueLayout.JAVA_INT, 3L);\n+ * }\n+ *\n+ * Var handles for more complex access expressions (e.g. struct field access, pointer dereference) can be created directly\n+ * from memory layouts, using <a href=\"MemoryLayout.html#layout-paths\"><em>layout paths<\/em><\/a>.\n+ *\n@@ -375,1 +372,1 @@\n- *     <li>The segment is associated with a fresh scope that is always alive. Thus, while zero-length\n+ *     <li>The segment is associated with the global scope. Thus, while zero-length\n@@ -437,1 +434,1 @@\n- * @since 19\n+ * @since 22\n@@ -439,1 +436,0 @@\n-@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n@@ -573,4 +569,1 @@\n-    default MemorySegment asSlice(long offset, MemoryLayout layout) {\n-        Objects.requireNonNull(layout);\n-        return asSlice(offset, layout.byteSize(), layout.byteAlignment());\n-    }\n+    MemorySegment asSlice(long offset, MemoryLayout layout);\n@@ -597,5 +590,0 @@\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n@@ -629,1 +617,1 @@\n-     * That is, the cleanup action receives a segment that is associated with a fresh scope that is always alive,\n+     * That is, the cleanup action receives a segment that is associated with the global scope,\n@@ -631,5 +619,0 @@\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n@@ -669,1 +652,1 @@\n-     * That is, the cleanup action receives a segment that is associated with a fresh scope that is always alive,\n+     * That is, the cleanup action receives a segment that is associated with the global scope,\n@@ -671,5 +654,0 @@\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n@@ -742,24 +720,0 @@\n-    \/**\n-     * Returns the offset, in bytes, of the provided segment, relative to this\n-     * segment.\n-     *\n-     * <p>The offset is relative to the address of this segment and can be\n-     * a negative or positive value. For instance, if both segments are native\n-     * segments, or heap segments backed by the same array, the resulting offset\n-     * can be computed as follows:\n-     *\n-     * {@snippet lang=java :\n-     * other.address() - address()\n-     * }\n-     *\n-     * If the segments share the same address, {@code 0} is returned. If\n-     * {@code other} is a slice of this segment, the offset is always\n-     * {@code 0 <= x < this.byteSize()}.\n-     *\n-     * @param other the segment to retrieve an offset to.\n-     * @throws UnsupportedOperationException if the two segments cannot be compared, e.g. because they are of\n-     * different kinds, or because they are backed by different Java arrays.\n-     * @return the relative offset, in bytes, of the provided segment.\n-     *\/\n-    long segmentOffset(MemorySegment other);\n-\n@@ -774,1 +728,1 @@\n-     *     byteHandle.set(ValueLayout.JAVA_BYTE, offset, value);\n+     *     segment.set(ValueLayout.JAVA_BYTE, offset, value);\n@@ -815,4 +769,1 @@\n-    default MemorySegment copyFrom(MemorySegment src) {\n-        MemorySegment.copy(src, 0, this, 0, src.byteSize());\n-        return this;\n-    }\n+    MemorySegment copyFrom(MemorySegment src);\n@@ -847,4 +798,1 @@\n-    default long mismatch(MemorySegment other) {\n-        Objects.requireNonNull(other);\n-        return MemorySegment.mismatch(this, 0, byteSize(), other, 0, other.byteSize());\n-    }\n+    long mismatch(MemorySegment other);\n@@ -1075,1 +1023,2 @@\n-     * Reads a UTF-8 encoded, null-terminated string from this segment at the given offset.\n+     * Reads a null-terminated string from this segment at the given offset, using the\n+     * {@linkplain StandardCharsets#UTF_8 UTF-8} charset.\n@@ -1077,4 +1026,5 @@\n-     * This method always replaces malformed-input and unmappable-character\n-     * sequences with this charset's default replacement string.  The {@link\n-     * java.nio.charset.CharsetDecoder} class should be used when more control\n-     * over the decoding process is required.\n+     * Calling this method is equivalent to the following code:\n+     * {@snippet lang = java:\n+     * getString(offset, StandardCharsets.UTF_8);\n+     *}\n+     *\n@@ -1084,3 +1034,4 @@\n-     * @throws IllegalArgumentException if the size of the UTF-8 string is greater than the largest string supported by the platform.\n-     * @throws IndexOutOfBoundsException if {@code offset < 0} or {@code offset > byteSize() - S}, where {@code S} is the size of the UTF-8\n-     * string (including the terminator character).\n+     * @throws IllegalArgumentException if the size of the string is greater than the largest string supported by the platform.\n+     * @throws IndexOutOfBoundsException     if {@code offset < 0}.\n+     * @throws IndexOutOfBoundsException     if {@code offset > byteSize() - (B + 1)}, where {@code B} is the size,\n+     * in bytes, of the string encoded using UTF-8 charset {@code str.getBytes(StandardCharsets.UTF_8).length}).\n@@ -1092,3 +1043,1 @@\n-    default String getUtf8String(long offset) {\n-        return SharedUtils.toJavaStringInternal(this, offset);\n-    }\n+    String getString(long offset);\n@@ -1097,1 +1046,1 @@\n-     * Writes the given string into this segment at the given offset, converting it to a null-terminated byte sequence using UTF-8 encoding.\n+     * Reads a null-terminated string from this segment at the given offset, using the provided charset.\n@@ -1103,0 +1052,25 @@\n+     *\n+     * @param offset  offset in bytes (relative to this segment address) at which this access operation will occur.\n+     * @param charset the charset used to {@linkplain Charset#newDecoder() decode} the string bytes.\n+     * @return a Java string constructed from the bytes read from the given starting address up to (but not including)\n+     * the first {@code '\\0'} terminator character (assuming one is found).\n+     * @throws IllegalArgumentException      if the size of the string is greater than the largest string supported by the platform.\n+     * @throws IndexOutOfBoundsException     if {@code offset < 0}.\n+     * @throws IndexOutOfBoundsException     if {@code offset > byteSize() - (B + N)}, where:\n+     * <ul>\n+     *     <li>{@code B} is the size, in bytes, of the string encoded using the provided charset\n+     *     (e.g. {@code str.getBytes(charset).length});<\/li>\n+     *     <li>{@code N} is the size (in bytes) of the terminator char according to the provided charset. For instance,\n+     *     this is 1 for {@link StandardCharsets#US_ASCII} and 2 for {@link StandardCharsets#UTF_16}.<\/li>\n+     * <\/ul>\n+     * @throws IllegalStateException    if the {@linkplain #scope() scope} associated with this segment is not\n+     *                                  {@linkplain Scope#isAlive() alive}.\n+     * @throws WrongThreadException     if this method is called from a thread {@code T},\n+     *                                  such that {@code isAccessibleBy(T) == false}.\n+     * @throws IllegalArgumentException if {@code charset} is not a {@linkplain StandardCharsets standard charset}.\n+     *\/\n+    String getString(long offset, Charset charset);\n+\n+    \/**\n+     * Writes the given string into this segment at the given offset, converting it to a null-terminated byte sequence\n+     * using the {@linkplain StandardCharsets#UTF_8 UTF-8} charset.\n@@ -1104,4 +1078,4 @@\n-     * If the given string contains any {@code '\\0'} characters, they will be\n-     * copied as well. This means that, depending on the method used to read\n-     * the string, such as {@link MemorySegment#getUtf8String(long)}, the string\n-     * will appear truncated when read again.\n+     * Calling this method is equivalent to the following code:\n+     * {@snippet lang = java:\n+     * setString(offset, str, StandardCharsets.UTF_8);\n+     *}\n@@ -1111,1 +1085,3 @@\n-     * @throws IndexOutOfBoundsException if {@code offset < 0} or {@code offset > byteSize() - str.getBytes().length() + 1}.\n+     * @throws IndexOutOfBoundsException     if {@code offset < 0}.\n+     * @throws IndexOutOfBoundsException     if {@code offset > byteSize() - (B + 1)}, where {@code B} is the size,\n+     * in bytes, of the string encoded using UTF-8 charset {@code str.getBytes(StandardCharsets.UTF_8).length}).\n@@ -1117,3 +1093,1 @@\n-    default void setUtf8String(long offset, String str) {\n-        Utils.toCString(str.getBytes(StandardCharsets.UTF_8), SegmentAllocator.prefixAllocator(asSlice(offset)));\n-    }\n+    void setString(long offset, String str);\n@@ -1121,0 +1095,33 @@\n+    \/**\n+     * Writes the given string into this segment at the given offset, converting it to a null-terminated byte sequence\n+     * using the provided charset.\n+     * <p>\n+     * This method always replaces malformed-input and unmappable-character\n+     * sequences with this charset's default replacement string.  The {@link\n+     * java.nio.charset.CharsetDecoder} class should be used when more control\n+     * over the decoding process is required.\n+     * <p>\n+     * If the given string contains any {@code '\\0'} characters, they will be\n+     * copied as well. This means that, depending on the method used to read\n+     * the string, such as {@link MemorySegment#getString(long)}, the string\n+     * will appear truncated when read again.\n+     *\n+     * @param offset  offset in bytes (relative to this segment address) at which this access operation will occur.\n+     *                the final address of this write operation can be expressed as {@code address() + offset}.\n+     * @param str     the Java string to be written into this segment.\n+     * @param charset the charset used to {@linkplain Charset#newEncoder() encode} the string bytes.\n+     * @throws IndexOutOfBoundsException     if {@code offset < 0}.\n+     * @throws IndexOutOfBoundsException     if {@code offset > byteSize() - (B + N)}, where:\n+     * <ul>\n+     *     <li>{@code B} is the size, in bytes, of the string encoded using the provided charset\n+     *     (e.g. {@code str.getBytes(charset).length});<\/li>\n+     *     <li>{@code N} is the size (in bytes) of the terminator char according to the provided charset. For instance,\n+     *     this is 1 for {@link StandardCharsets#US_ASCII} and 2 for {@link StandardCharsets#UTF_16}.<\/li>\n+     * <\/ul>\n+     * @throws IllegalStateException    if the {@linkplain #scope() scope} associated with this segment is not\n+     *                                  {@linkplain Scope#isAlive() alive}.\n+     * @throws WrongThreadException     if this method is called from a thread {@code T},\n+     *                                  such that {@code isAccessibleBy(T) == false}.\n+     * @throws IllegalArgumentException if {@code charset} is not a {@linkplain StandardCharsets standard charset}.\n+     *\/\n+    void setString(long offset, String str, Charset charset);\n@@ -1132,5 +1139,3 @@\n-     * same scope {@code S}. Otherwise, the scope of the returned segment is a fresh scope that is always alive.\n-     * <p>\n-     * The scope associated with the returned segment keeps the provided buffer reachable. As such, if\n-     * the provided buffer is a direct buffer, its backing memory region will not be deallocated as long as the\n-     * returned segment (or any of its slices) are kept reachable.\n+     * same scope {@code S}. Otherwise, the scope of the returned segment is an automatic scope that keeps the provided\n+     * buffer reachable. As such, if the provided buffer is a direct buffer, its backing memory region will not be\n+     * deallocated as long as the returned segment (or any of its slices) are kept reachable.\n@@ -1151,1 +1156,1 @@\n-     * The scope of the returned segment is a fresh scope that is always alive, and keeps the given array reachable.\n+     * The scope of the returned segment is an automatic scope that keeps the given array reachable.\n@@ -1158,1 +1163,1 @@\n-        return HeapMemorySegmentImpl.OfByte.fromArray(byteArray);\n+        return SegmentFactories.fromArray(byteArray);\n@@ -1163,1 +1168,1 @@\n-     * The scope of the returned segment is a fresh scope that is always alive, and keeps the given array reachable.\n+     * The scope of the returned segment is an automatic scope that keeps the given array reachable.\n@@ -1170,1 +1175,1 @@\n-        return HeapMemorySegmentImpl.OfChar.fromArray(charArray);\n+        return SegmentFactories.fromArray(charArray);\n@@ -1175,1 +1180,1 @@\n-     * The scope of the returned segment is a fresh scope that is always alive, and keeps the given array reachable.\n+     * The scope of the returned segment is an automatic scope that keeps the given array reachable.\n@@ -1182,1 +1187,1 @@\n-        return HeapMemorySegmentImpl.OfShort.fromArray(shortArray);\n+        return SegmentFactories.fromArray(shortArray);\n@@ -1187,1 +1192,1 @@\n-     * The scope of the returned segment is a fresh scope that is always alive, and keeps the given array reachable.\n+     * The scope of the returned segment is an automatic scope that keeps the given array reachable.\n@@ -1194,1 +1199,1 @@\n-        return HeapMemorySegmentImpl.OfInt.fromArray(intArray);\n+        return SegmentFactories.fromArray(intArray);\n@@ -1199,1 +1204,1 @@\n-     * The scope of the returned segment is a fresh scope that is always alive, and keeps the given array reachable.\n+     * The scope of the returned segment is an automatic scope that keeps the given array reachable.\n@@ -1206,1 +1211,1 @@\n-        return HeapMemorySegmentImpl.OfFloat.fromArray(floatArray);\n+        return SegmentFactories.fromArray(floatArray);\n@@ -1211,1 +1216,1 @@\n-     * The scope of the returned segment is a fresh scope that is always alive, and keeps the given array reachable.\n+     * The scope of the returned segment is an automatic scope that keeps the given array reachable.\n@@ -1218,1 +1223,1 @@\n-        return HeapMemorySegmentImpl.OfLong.fromArray(longArray);\n+        return SegmentFactories.fromArray(longArray);\n@@ -1223,1 +1228,1 @@\n-     * The scope of the returned segment is a fresh scope that is always alive, and keeps the given array reachable.\n+     * The scope of the returned segment is an automatic scope that keeps the given array reachable.\n@@ -1230,1 +1235,1 @@\n-        return HeapMemorySegmentImpl.OfDouble.fromArray(doubleArray);\n+        return SegmentFactories.fromArray(doubleArray);\n@@ -1234,1 +1239,1 @@\n-     * A zero-length native segment modelling the {@code NULL} address.\n+     * A zero-length native segment modelling the {@code NULL} address. Equivalent to {@code MemorySegment.ofAddress(0L)}.\n@@ -1236,1 +1241,1 @@\n-    MemorySegment NULL = new NativeMemorySegmentImpl();\n+    MemorySegment NULL = MemorySegment.ofAddress(0L);\n@@ -1240,1 +1245,1 @@\n-     * The returned segment is associated with a scope that is always alive, and is accessible from any thread.\n+     * The returned segment is associated with the global scope, and is accessible from any thread.\n@@ -1250,1 +1255,1 @@\n-        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(address, 0);\n+        return SegmentFactories.makeNativeSegmentUnchecked(address, 0);\n@@ -1284,2 +1289,3 @@\n-     * @throws IndexOutOfBoundsException if {@code srcOffset > srcSegment.byteSize() - bytes} or if\n-     * {@code dstOffset > dstSegment.byteSize() - bytes}, or if either {@code srcOffset}, {@code dstOffset}\n+     * @throws IndexOutOfBoundsException if {@code srcOffset > srcSegment.byteSize() - bytes}.\n+     * @throws IndexOutOfBoundsException if {@code dstOffset > dstSegment.byteSize() - bytes}.\n+     * @throws IndexOutOfBoundsException if either {@code srcOffset}, {@code dstOffset}\n@@ -1323,1 +1329,3 @@\n-     * (resp. destination) element layout, or if the source (resp. destination) element layout alignment is greater than its size.\n+     * (resp. destination) element layout.\n+     * @throws IllegalArgumentException if {@code srcElementLayout.byteAlignment() > srcElementLayout.byteSize()}.\n+     * @throws IllegalArgumentException if {@code dstElementLayout.byteAlignment() > dstElementLayout.byteSize()}.\n@@ -1327,1 +1335,1 @@\n-     * such that {@code srcSegment().isAccessibleBy(T) == false}.\n+     * such that {@code srcSegment.isAccessibleBy(T) == false}.\n@@ -1331,1 +1339,1 @@\n-     * such that {@code dstSegment().isAccessibleBy(T) == false}.\n+     * such that {@code dstSegment.isAccessibleBy(T) == false}.\n@@ -1333,1 +1341,3 @@\n-     * @throws IndexOutOfBoundsException if {@code elementCount * srcLayout.byteSize()} or {@code elementCount * dtsLayout.byteSize()} overflows.\n+     * @throws IndexOutOfBoundsException if {@code elementCount * srcLayout.byteSize()} overflows.\n+     * @throws IndexOutOfBoundsException if {@code elementCount * dtsLayout.byteSize()} overflows.\n+     * @throws IndexOutOfBoundsException if {@code srcOffset > srcSegment.byteSize() - (elementCount * srcLayout.byteSize())}.\n@@ -1362,4 +1372,1 @@\n-    @ForceInline\n-    default byte get(ValueLayout.OfByte layout, long offset) {\n-        return (byte) ((ValueLayouts.OfByteImpl) layout).accessHandle().get(this, offset);\n-    }\n+    byte get(ValueLayout.OfByte layout, long offset);\n@@ -1382,4 +1389,1 @@\n-    @ForceInline\n-    default void set(ValueLayout.OfByte layout, long offset, byte value) {\n-        ((ValueLayouts.OfByteImpl) layout).accessHandle().set(this, offset, value);\n-    }\n+    void set(ValueLayout.OfByte layout, long offset, byte value);\n@@ -1401,4 +1405,1 @@\n-    @ForceInline\n-    default boolean get(ValueLayout.OfBoolean layout, long offset) {\n-        return (boolean) ((ValueLayouts.OfBooleanImpl) layout).accessHandle().get(this, offset);\n-    }\n+    boolean get(ValueLayout.OfBoolean layout, long offset);\n@@ -1421,4 +1422,1 @@\n-    @ForceInline\n-    default void set(ValueLayout.OfBoolean layout, long offset, boolean value) {\n-        ((ValueLayouts.OfBooleanImpl) layout).accessHandle().set(this, offset, value);\n-    }\n+    void set(ValueLayout.OfBoolean layout, long offset, boolean value);\n@@ -1440,4 +1438,1 @@\n-    @ForceInline\n-    default char get(ValueLayout.OfChar layout, long offset) {\n-        return (char) ((ValueLayouts.OfCharImpl) layout).accessHandle().get(this, offset);\n-    }\n+    char get(ValueLayout.OfChar layout, long offset);\n@@ -1460,4 +1455,1 @@\n-    @ForceInline\n-    default void set(ValueLayout.OfChar layout, long offset, char value) {\n-        ((ValueLayouts.OfCharImpl) layout).accessHandle().set(this, offset, value);\n-    }\n+    void set(ValueLayout.OfChar layout, long offset, char value);\n@@ -1479,4 +1471,1 @@\n-    @ForceInline\n-    default short get(ValueLayout.OfShort layout, long offset) {\n-        return (short) ((ValueLayouts.OfShortImpl) layout).accessHandle().get(this, offset);\n-    }\n+    short get(ValueLayout.OfShort layout, long offset);\n@@ -1499,4 +1488,1 @@\n-    @ForceInline\n-    default void set(ValueLayout.OfShort layout, long offset, short value) {\n-        ((ValueLayouts.OfShortImpl) layout).accessHandle().set(this, offset, value);\n-    }\n+    void set(ValueLayout.OfShort layout, long offset, short value);\n@@ -1518,4 +1504,1 @@\n-    @ForceInline\n-    default int get(ValueLayout.OfInt layout, long offset) {\n-        return (int) ((ValueLayouts.OfIntImpl) layout).accessHandle().get(this, offset);\n-    }\n+    int get(ValueLayout.OfInt layout, long offset);\n@@ -1538,4 +1521,1 @@\n-    @ForceInline\n-    default void set(ValueLayout.OfInt layout, long offset, int value) {\n-        ((ValueLayouts.OfIntImpl) layout).accessHandle().set(this, offset, value);\n-    }\n+    void set(ValueLayout.OfInt layout, long offset, int value);\n@@ -1557,4 +1537,1 @@\n-    @ForceInline\n-    default float get(ValueLayout.OfFloat layout, long offset) {\n-        return (float)((ValueLayouts.OfFloatImpl) layout).accessHandle().get(this, offset);\n-    }\n+    float get(ValueLayout.OfFloat layout, long offset);\n@@ -1577,4 +1554,1 @@\n-    @ForceInline\n-    default void set(ValueLayout.OfFloat layout, long offset, float value) {\n-        ((ValueLayouts.OfFloatImpl) layout).accessHandle().set(this, offset, value);\n-    }\n+    void set(ValueLayout.OfFloat layout, long offset, float value);\n@@ -1596,4 +1570,1 @@\n-    @ForceInline\n-    default long get(ValueLayout.OfLong layout, long offset) {\n-        return (long) ((ValueLayouts.OfLongImpl) layout).accessHandle().get(this, offset);\n-    }\n+    long get(ValueLayout.OfLong layout, long offset);\n@@ -1616,4 +1587,1 @@\n-    @ForceInline\n-    default void set(ValueLayout.OfLong layout, long offset, long value) {\n-        ((ValueLayouts.OfLongImpl) layout).accessHandle().set(this, offset, value);\n-    }\n+    void set(ValueLayout.OfLong layout, long offset, long value);\n@@ -1635,4 +1603,1 @@\n-    @ForceInline\n-    default double get(ValueLayout.OfDouble layout, long offset) {\n-        return (double) ((ValueLayouts.OfDoubleImpl) layout).accessHandle().get(this, offset);\n-    }\n+    double get(ValueLayout.OfDouble layout, long offset);\n@@ -1655,4 +1620,1 @@\n-    @ForceInline\n-    default void set(ValueLayout.OfDouble layout, long offset, double value) {\n-        ((ValueLayouts.OfDoubleImpl) layout).accessHandle().set(this, offset, value);\n-    }\n+    void set(ValueLayout.OfDouble layout, long offset, double value);\n@@ -1662,1 +1624,1 @@\n-     * a native segment, associated with a fresh scope that is always alive. Under normal conditions,\n+     * a native segment, associated with the global scope. Under normal conditions,\n@@ -1680,4 +1642,1 @@\n-    @ForceInline\n-    default MemorySegment get(AddressLayout layout, long offset) {\n-        return (MemorySegment) ((ValueLayouts.OfAddressImpl) layout).accessHandle().get(this, offset);\n-    }\n+    MemorySegment get(AddressLayout layout, long offset);\n@@ -1701,4 +1660,1 @@\n-    @ForceInline\n-    default void set(AddressLayout layout, long offset, MemorySegment value) {\n-        ((ValueLayouts.OfAddressImpl) layout).accessHandle().set(this, offset, value);\n-    }\n+    void set(AddressLayout layout, long offset, MemorySegment value);\n@@ -1718,2 +1674,2 @@\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IllegalArgumentException if {@code layout.byteAlignment() > layout.byteSize()}.\n@@ -1723,6 +1679,1 @@\n-    @ForceInline\n-    default byte getAtIndex(ValueLayout.OfByte layout, long index) {\n-        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n-        \/\/ note: we know size is a small value (as it comes from ValueLayout::byteSize())\n-        return (byte) ((ValueLayouts.OfByteImpl) layout).accessHandle().get(this, index * layout.byteSize());\n-    }\n+    byte getAtIndex(ValueLayout.OfByte layout, long index);\n@@ -1742,2 +1693,2 @@\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IllegalArgumentException if {@code layout.byteAlignment() > layout.byteSize()}.\n@@ -1747,6 +1698,1 @@\n-    @ForceInline\n-    default boolean getAtIndex(ValueLayout.OfBoolean layout, long index) {\n-        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n-        \/\/ note: we know size is a small value (as it comes from ValueLayout::byteSize())\n-        return (boolean) ((ValueLayouts.OfBooleanImpl) layout).accessHandle().get(this, index * layout.byteSize());\n-    }\n+    boolean getAtIndex(ValueLayout.OfBoolean layout, long index);\n@@ -1766,2 +1712,2 @@\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IllegalArgumentException if {@code layout.byteAlignment() > layout.byteSize()}.\n@@ -1771,6 +1717,1 @@\n-    @ForceInline\n-    default char getAtIndex(ValueLayout.OfChar layout, long index) {\n-        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n-        \/\/ note: we know size is a small value (as it comes from ValueLayout::byteSize())\n-        return (char) ((ValueLayouts.OfCharImpl) layout).accessHandle().get(this, index * layout.byteSize());\n-    }\n+    char getAtIndex(ValueLayout.OfChar layout, long index);\n@@ -1790,2 +1731,2 @@\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IllegalArgumentException if {@code layout.byteAlignment() > layout.byteSize()}.\n@@ -1796,6 +1737,1 @@\n-    @ForceInline\n-    default void setAtIndex(ValueLayout.OfChar layout, long index, char value) {\n-        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n-        \/\/ note: we know size is a small value (as it comes from ValueLayout::byteSize())\n-        ((ValueLayouts.OfCharImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n-    }\n+    void setAtIndex(ValueLayout.OfChar layout, long index, char value);\n@@ -1815,2 +1751,2 @@\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IllegalArgumentException if {@code layout.byteAlignment() > layout.byteSize()}.\n@@ -1820,6 +1756,1 @@\n-    @ForceInline\n-    default short getAtIndex(ValueLayout.OfShort layout, long index) {\n-        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n-        \/\/ note: we know size is a small value (as it comes from ValueLayout::byteSize())\n-        return (short) ((ValueLayouts.OfShortImpl) layout).accessHandle().get(this, index * layout.byteSize());\n-    }\n+    short getAtIndex(ValueLayout.OfShort layout, long index);\n@@ -1839,2 +1770,2 @@\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IllegalArgumentException if {@code layout.byteAlignment() > layout.byteSize()}.\n@@ -1845,7 +1776,1 @@\n-    @ForceInline\n-    default void setAtIndex(ValueLayout.OfByte layout, long index, byte value) {\n-        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n-        \/\/ note: we know size is a small value (as it comes from ValueLayout::byteSize())\n-        ((ValueLayouts.OfByteImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n-\n-    }\n+    void setAtIndex(ValueLayout.OfByte layout, long index, byte value);\n@@ -1865,2 +1790,2 @@\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IllegalArgumentException if {@code layout.byteAlignment() > layout.byteSize()}.\n@@ -1871,6 +1796,1 @@\n-    @ForceInline\n-    default void setAtIndex(ValueLayout.OfBoolean layout, long index, boolean value) {\n-        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n-        \/\/ note: we know size is a small value (as it comes from ValueLayout::byteSize())\n-        ((ValueLayouts.OfBooleanImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n-    }\n+    void setAtIndex(ValueLayout.OfBoolean layout, long index, boolean value);\n@@ -1890,2 +1810,2 @@\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IllegalArgumentException if {@code layout.byteAlignment() > layout.byteSize()}.\n@@ -1896,6 +1816,1 @@\n-    @ForceInline\n-    default void setAtIndex(ValueLayout.OfShort layout, long index, short value) {\n-        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n-        \/\/ note: we know size is a small value (as it comes from ValueLayout::byteSize())\n-        ((ValueLayouts.OfShortImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n-    }\n+    void setAtIndex(ValueLayout.OfShort layout, long index, short value);\n@@ -1915,2 +1830,2 @@\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IllegalArgumentException if {@code layout.byteAlignment() > layout.byteSize()}.\n@@ -1920,6 +1835,1 @@\n-    @ForceInline\n-    default int getAtIndex(ValueLayout.OfInt layout, long index) {\n-        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n-        \/\/ note: we know size is a small value (as it comes from ValueLayout::byteSize())\n-        return (int) ((ValueLayouts.OfIntImpl) layout).accessHandle().get(this, index * layout.byteSize());\n-    }\n+    int getAtIndex(ValueLayout.OfInt layout, long index);\n@@ -1939,2 +1849,2 @@\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IllegalArgumentException if {@code layout.byteAlignment() > layout.byteSize()}.\n@@ -1945,6 +1855,1 @@\n-    @ForceInline\n-    default void setAtIndex(ValueLayout.OfInt layout, long index, int value) {\n-        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n-        \/\/ note: we know size is a small value (as it comes from ValueLayout::byteSize())\n-        ((ValueLayouts.OfIntImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n-    }\n+    void setAtIndex(ValueLayout.OfInt layout, long index, int value);\n@@ -1964,2 +1869,2 @@\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IllegalArgumentException if {@code layout.byteAlignment() > layout.byteSize()}.\n@@ -1969,6 +1874,1 @@\n-    @ForceInline\n-    default float getAtIndex(ValueLayout.OfFloat layout, long index) {\n-        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n-        \/\/ note: we know size is a small value (as it comes from ValueLayout::byteSize())\n-        return (float) ((ValueLayouts.OfFloatImpl) layout).accessHandle().get(this, index * layout.byteSize());\n-    }\n+    float getAtIndex(ValueLayout.OfFloat layout, long index);\n@@ -1988,2 +1888,2 @@\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IllegalArgumentException if {@code layout.byteAlignment() > layout.byteSize()}.\n@@ -1994,6 +1894,1 @@\n-    @ForceInline\n-    default void setAtIndex(ValueLayout.OfFloat layout, long index, float value) {\n-        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n-        \/\/ note: we know size is a small value (as it comes from ValueLayout::byteSize())\n-        ((ValueLayouts.OfFloatImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n-    }\n+    void setAtIndex(ValueLayout.OfFloat layout, long index, float value);\n@@ -2013,2 +1908,2 @@\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IllegalArgumentException if {@code layout.byteAlignment() > layout.byteSize()}.\n@@ -2018,6 +1913,1 @@\n-    @ForceInline\n-    default long getAtIndex(ValueLayout.OfLong layout, long index) {\n-        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n-        \/\/ note: we know size is a small value (as it comes from ValueLayout::byteSize())\n-        return (long) ((ValueLayouts.OfLongImpl) layout).accessHandle().get(this, index * layout.byteSize());\n-    }\n+    long getAtIndex(ValueLayout.OfLong layout, long index);\n@@ -2037,2 +1927,2 @@\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IllegalArgumentException if {@code layout.byteAlignment() > layout.byteSize()}.\n@@ -2043,6 +1933,1 @@\n-    @ForceInline\n-    default void setAtIndex(ValueLayout.OfLong layout, long index, long value) {\n-        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n-        \/\/ note: we know size is a small value (as it comes from ValueLayout::byteSize())\n-        ((ValueLayouts.OfLongImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n-    }\n+    void setAtIndex(ValueLayout.OfLong layout, long index, long value);\n@@ -2062,2 +1947,2 @@\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IllegalArgumentException if {@code layout.byteAlignment() > layout.byteSize()}.\n@@ -2067,6 +1952,1 @@\n-    @ForceInline\n-    default double getAtIndex(ValueLayout.OfDouble layout, long index) {\n-        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n-        \/\/ note: we know size is a small value (as it comes from ValueLayout::byteSize())\n-        return (double) ((ValueLayouts.OfDoubleImpl) layout).accessHandle().get(this, index * layout.byteSize());\n-    }\n+    double getAtIndex(ValueLayout.OfDouble layout, long index);\n@@ -2086,2 +1966,2 @@\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IllegalArgumentException if {@code layout.byteAlignment() > layout.byteSize()}.\n@@ -2092,6 +1972,1 @@\n-    @ForceInline\n-    default void setAtIndex(ValueLayout.OfDouble layout, long index, double value) {\n-        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n-        \/\/ note: we know size is a small value (as it comes from ValueLayout::byteSize())\n-        ((ValueLayouts.OfDoubleImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n-    }\n+    void setAtIndex(ValueLayout.OfDouble layout, long index, double value);\n@@ -2101,1 +1976,1 @@\n-     * a native segment, associated with a fresh scope that is always alive. Under normal conditions,\n+     * a native segment, associated with the global scope. Under normal conditions,\n@@ -2114,2 +1989,2 @@\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IllegalArgumentException if {@code layout.byteAlignment() > layout.byteSize()}.\n@@ -2122,6 +1997,1 @@\n-    @ForceInline\n-    default MemorySegment getAtIndex(AddressLayout layout, long index) {\n-        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n-        \/\/ note: we know size is a small value (as it comes from ValueLayout::byteSize())\n-        return (MemorySegment) ((ValueLayouts.OfAddressImpl) layout).accessHandle().get(this, index * layout.byteSize());\n-    }\n+    MemorySegment getAtIndex(AddressLayout layout, long index);\n@@ -2141,2 +2011,2 @@\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IllegalArgumentException if {@code layout.byteAlignment() > layout.byteSize()}.\n@@ -2148,6 +2018,1 @@\n-    @ForceInline\n-    default void setAtIndex(AddressLayout layout, long index, MemorySegment value) {\n-        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n-        \/\/ note: we know size is a small value (as it comes from ValueLayout::byteSize())\n-        ((ValueLayouts.OfAddressImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n-    }\n+    void setAtIndex(AddressLayout layout, long index, MemorySegment value);\n@@ -2201,1 +2066,1 @@\n-     * such that {@code srcSegment().isAccessibleBy(T) == false}.\n+     * such that {@code srcSegment.isAccessibleBy(T) == false}.\n@@ -2240,1 +2105,1 @@\n-     * such that {@code dstSegment().isAccessibleBy(T) == false}.\n+     * such that {@code dstSegment.isAccessibleBy(T) == false}.\n@@ -2309,2 +2174,12 @@\n-     * cannot be accessed if its associated scope is not {@linkplain #isAlive() alive}. A new scope is typically\n-     * obtained indirectly, by creating a new {@linkplain Arena arena}.\n+     * cannot be accessed if its associated scope is not {@linkplain #isAlive() alive}. Scope instances can be compared\n+     * for equality. That is, two scopes are considered {@linkplain #equals(Object) equal} if they denote the same lifetime.\n+     * <p>\n+     * The lifetime of a memory segment can be either <em>unbounded<\/em> or <em>bounded<\/em>. An unbounded lifetime\n+     * is modelled with the <em>global scope<\/em>. The global scope is always {@link #isAlive() alive}. As such, a segment\n+     * associated with the global scope features trivial temporal bounds, and is always accessible.\n+     * Segments associated with the global scope are:\n+     * <ul>\n+     *     <li>Segments obtained from the {@linkplain Arena#global() global arena};<\/li>\n+     *     <li>Segments obtained from a raw address, using the {@link MemorySegment#ofAddress(long)} factory; and<\/li>\n+     *     <li><a href=\"#wrapping-addresses\">Zero-length memory segments.<\/a><\/li>\n+     * <\/ul>\n@@ -2312,2 +2187,19 @@\n-     * Scope instances can be compared for equality. That is, two scopes\n-     * are considered {@linkplain #equals(Object)} if they denote the same lifetime.\n+     * Conversely, a bounded lifetime is modelled with a segment scope that can be invalidated, either {@link Arena#close() explicitly},\n+     * or automatically, by the garbage collector. A segment scope that is invalidated automatically is an <em>automatic scope<\/em>.\n+     * An automatic scope is always {@link #isAlive() alive} as long as it is <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">reachable<\/a>.\n+     * Segments associated with an automatic scope are:\n+     * <ul>\n+     *     <li>Segments obtained from an {@linkplain Arena#ofAuto() automatic arena};<\/li>\n+     *     <li>Segments obtained from a Java array, e.g. using the {@link MemorySegment#ofArray(int[])} factory;<\/li>\n+     *     <li>Segments obtained from a buffer, using the {@link MemorySegment#ofBuffer(Buffer)} factory; and<\/li>\n+     *     <li>Segments obtained from {@linkplain SymbolLookup#loaderLookup() loader lookup}.<\/li>\n+     * <\/ul>\n+     * If two memory segments are obtained from the same {@linkplain #ofBuffer(Buffer) buffer}\n+     * or {@linkplain #ofArray(int[]) array}, the automatic scopes associated with said segments are considered\n+     * {@linkplain #equals(Object) equal}, as the two segments have the same lifetime:\n+     * {@snippet lang=java :\n+     * byte[] arr = new byte[10];\n+     * MemorySegment segment1 = MemorySegment.ofArray(arr);\n+     * MemorySegment segment2 = MemorySegment.ofArray(arr);\n+     * assert segment1.scope().equals(segment2.scope());\n+     * }\n@@ -2315,1 +2207,0 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":255,"deletions":364,"binary":false,"changes":619,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.internal.javac.PreviewFeature;\n@@ -38,1 +37,1 @@\n- * @since 20\n+ * @since 22\n@@ -40,1 +39,0 @@\n-@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/PaddingLayout.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,3 +28,1 @@\n-import java.lang.invoke.VarHandle;\n-import java.lang.reflect.Array;\n-import java.nio.ByteOrder;\n+import java.nio.charset.Charset;\n@@ -33,1 +31,1 @@\n-import java.util.function.Function;\n+\n@@ -35,0 +33,1 @@\n+import jdk.internal.foreign.ArenaImpl;\n@@ -36,2 +35,2 @@\n-import jdk.internal.foreign.Utils;\n-import jdk.internal.javac.PreviewFeature;\n+import jdk.internal.foreign.StringSupport;\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -73,1 +72,1 @@\n- * @since 19\n+ * @since 22\n@@ -76,1 +75,0 @@\n-@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n@@ -80,1 +78,20 @@\n-     * {@return a new memory segment with a Java string converted into a UTF-8 encoded, null-terminated C string}\n+     * Converts a Java string into a null-terminated C string using the {@linkplain StandardCharsets#UTF_8 UTF-8} charset,\n+     * storing the result into a memory segment.\n+     * <p>\n+     * Calling this method is equivalent to the following code:\n+     * {@snippet lang = java:\n+     * allocateFrom(str, StandardCharsets.UTF_8);\n+     *}\n+     *\n+     * @param str the Java string to be converted into a C string.\n+     * @return a new native segment containing the converted C string.\n+     *\/\n+    @ForceInline\n+    default MemorySegment allocateFrom(String str) {\n+        Objects.requireNonNull(str);\n+        return allocateFrom(str, sun.nio.cs.UTF_8.INSTANCE);\n+    }\n+\n+    \/**\n+     * Converts a Java string into a null-terminated C string using the provided charset,\n+     * and storing the result into a memory segment.\n@@ -89,1 +106,1 @@\n-     * the string, such as {@link MemorySegment#getUtf8String(long)}, the string\n+     * the string, such as {@link MemorySegment#getString(long)}, the string\n@@ -92,0 +109,4 @@\n+     * @param str     the Java string to be converted into a C string.\n+     * @param charset the charset used to {@linkplain Charset#newEncoder() encode} the string bytes.\n+     * @return a new native segment containing the converted C string.\n+     * @throws IllegalArgumentException if {@code charset} is not a {@linkplain StandardCharsets standard charset}.\n@@ -93,2 +114,7 @@\n-     * into a new memory segment obtained by calling {@code this.allocate(str.length() + 1)}.\n-     * @param str the Java string to be converted into a C string.\n+     * into a new memory segment obtained by calling {@code this.allocate(B + N)}, where:\n+     * <ul>\n+     *     <li>{@code B} is the size, in bytes, of the string encoded using the provided charset\n+     *     (e.g. {@code str.getBytes(charset).length});<\/li>\n+     *     <li>{@code N} is the size (in bytes) of the terminator char according to the provided charset. For instance,\n+     *     this is 1 for {@link StandardCharsets#US_ASCII} and 2 for {@link StandardCharsets#UTF_16}.<\/li>\n+     * <\/ul>\n@@ -96,1 +122,3 @@\n-    default MemorySegment allocateUtf8String(String str) {\n+    @ForceInline\n+    default MemorySegment allocateFrom(String str, Charset charset) {\n+        Objects.requireNonNull(charset);\n@@ -98,1 +126,17 @@\n-        return Utils.toCString(str.getBytes(StandardCharsets.UTF_8), this);\n+        int termCharSize = StringSupport.CharsetKind.of(charset).terminatorCharSize();\n+        MemorySegment segment;\n+        int length;\n+        if (StringSupport.bytesCompatible(str, charset)) {\n+            length = str.length();\n+            segment = allocateNoInit((long) length + termCharSize);\n+            StringSupport.copyToSegmentRaw(str, segment, 0);\n+        } else {\n+            byte[] bytes = str.getBytes(charset);\n+            length = bytes.length;\n+            segment = allocateNoInit((long) bytes.length + termCharSize);\n+            MemorySegment.copy(bytes, 0, segment, ValueLayout.JAVA_BYTE, 0, bytes.length);\n+        }\n+        for (int i = 0 ; i < termCharSize ; i++) {\n+            segment.set(ValueLayout.JAVA_BYTE, length + i, (byte)0);\n+        }\n+        return segment;\n@@ -102,2 +146,5 @@\n-     * {@return a new memory segment initialized with the provided {@code byte} {@code value} as\n-     * specified by the provided {@code layout} (i.e. byte ordering, alignment and size)}\n+     * {@return a new memory segment initialized with the provided byte value.}\n+     * <p>\n+     * The size of the allocated memory segment is the {@linkplain MemoryLayout#byteSize() size} of the given layout.\n+     * The given value is written into the segment according to the byte order and alignment constraint of the\n+     * given layout.\n@@ -115,1 +162,1 @@\n-    default MemorySegment allocate(ValueLayout.OfByte layout, byte value) {\n+    default MemorySegment allocateFrom(ValueLayout.OfByte layout, byte value) {\n@@ -117,3 +164,2 @@\n-        VarHandle handle = layout.varHandle();\n-        MemorySegment seg = allocate(layout);\n-        handle.set(seg, value);\n+        MemorySegment seg = allocateNoInit(layout);\n+        seg.set(layout, 0, value);\n@@ -124,2 +170,5 @@\n-     * {@return a new memory segment initialized with the provided {@code char} {@code value} as\n-     * specified by the provided {@code layout} (i.e. byte ordering, alignment and size)}\n+     * {@return a new memory segment initialized with the provided char value.}\n+     * <p>\n+     * The size of the allocated memory segment is the {@linkplain MemoryLayout#byteSize() size} of the given layout.\n+     * The given value is written into the segment according to the byte order and alignment constraint of the\n+     * given layout.\n@@ -137,1 +186,1 @@\n-    default MemorySegment allocate(ValueLayout.OfChar layout, char value) {\n+    default MemorySegment allocateFrom(ValueLayout.OfChar layout, char value) {\n@@ -139,3 +188,2 @@\n-        VarHandle handle = layout.varHandle();\n-        MemorySegment seg = allocate(layout);\n-        handle.set(seg, value);\n+        MemorySegment seg = allocateNoInit(layout);\n+        seg.set(layout, 0, value);\n@@ -146,2 +194,5 @@\n-     * {@return a new memory segment initialized with the provided {@code short} {@code value} as\n-     * specified by the provided {@code layout} (i.e. byte ordering, alignment and size)}\n+     * {@return a new memory segment initialized with the provided short value.}\n+     * <p>\n+     * The size of the allocated memory segment is the {@linkplain MemoryLayout#byteSize() size} of the given layout.\n+     * The given value is written into the segment according to the byte order and alignment constraint of the\n+     * given layout.\n@@ -159,1 +210,1 @@\n-    default MemorySegment allocate(ValueLayout.OfShort layout, short value) {\n+    default MemorySegment allocateFrom(ValueLayout.OfShort layout, short value) {\n@@ -161,3 +212,2 @@\n-        VarHandle handle = layout.varHandle();\n-        MemorySegment seg = allocate(layout);\n-        handle.set(seg, value);\n+        MemorySegment seg = allocateNoInit(layout);\n+        seg.set(layout, 0, value);\n@@ -168,2 +218,5 @@\n-     * {@return a new memory segment initialized with the provided {@code int} {@code value} as\n-     * specified by the provided {@code layout} (i.e. byte ordering, alignment and size)}\n+     * {@return a new memory segment initialized with the provided int value.}\n+     * <p>\n+     * The size of the allocated memory segment is the {@linkplain MemoryLayout#byteSize() size} of the given layout.\n+     * The given value is written into the segment according to the byte order and alignment constraint of the\n+     * given layout.\n@@ -181,1 +234,1 @@\n-    default MemorySegment allocate(ValueLayout.OfInt layout, int value) {\n+    default MemorySegment allocateFrom(ValueLayout.OfInt layout, int value) {\n@@ -183,3 +236,2 @@\n-        VarHandle handle = layout.varHandle();\n-        MemorySegment seg = allocate(layout);\n-        handle.set(seg, value);\n+        MemorySegment seg = allocateNoInit(layout);\n+        seg.set(layout, 0, value);\n@@ -190,2 +242,5 @@\n-     * {@return a new memory segment initialized with the provided {@code float} {@code value} as\n-     * specified by the provided {@code layout} (i.e. byte ordering, alignment and size)}\n+     * {@return a new memory segment initialized with the provided float value.}\n+     * <p>\n+     * The size of the allocated memory segment is the {@linkplain MemoryLayout#byteSize() size} of the given layout.\n+     * The given value is written into the segment according to the byte order and alignment constraint of the\n+     * given layout.\n@@ -203,1 +258,1 @@\n-    default MemorySegment allocate(ValueLayout.OfFloat layout, float value) {\n+    default MemorySegment allocateFrom(ValueLayout.OfFloat layout, float value) {\n@@ -205,3 +260,2 @@\n-        VarHandle handle = layout.varHandle();\n-        MemorySegment seg = allocate(layout);\n-        handle.set(seg, value);\n+        MemorySegment seg = allocateNoInit(layout);\n+        seg.set(layout, 0, value);\n@@ -212,2 +266,5 @@\n-     * {@return a new memory segment initialized with the provided {@code long} {@code value} as\n-     * specified by the provided {@code layout} (i.e. byte ordering, alignment and size)}\n+     * {@return a new memory segment initialized with the provided long value.}\n+     * <p>\n+     * The size of the allocated memory segment is the {@linkplain MemoryLayout#byteSize() size} of the given layout.\n+     * The given value is written into the segment according to the byte order and alignment constraint of the\n+     * given layout.\n@@ -225,1 +282,1 @@\n-    default MemorySegment allocate(ValueLayout.OfLong layout, long value) {\n+    default MemorySegment allocateFrom(ValueLayout.OfLong layout, long value) {\n@@ -227,3 +284,2 @@\n-        VarHandle handle = layout.varHandle();\n-        MemorySegment seg = allocate(layout);\n-        handle.set(seg, value);\n+        MemorySegment seg = allocateNoInit(layout);\n+        seg.set(layout, 0, value);\n@@ -234,2 +290,5 @@\n-     * {@return a new memory segment initialized with the provided {@code double} {@code value} as\n-     * specified by the provided {@code layout} (i.e. byte ordering, alignment and size)}\n+     * {@return a new memory segment initialized with the provided double value.}\n+     * <p>\n+     * The size of the allocated memory segment is the {@linkplain MemoryLayout#byteSize() size} of the given layout.\n+     * The given value is written into the segment according to the byte order and alignment constraint of the\n+     * given layout.\n@@ -247,1 +306,1 @@\n-    default MemorySegment allocate(ValueLayout.OfDouble layout, double value) {\n+    default MemorySegment allocateFrom(ValueLayout.OfDouble layout, double value) {\n@@ -249,3 +308,2 @@\n-        VarHandle handle = layout.varHandle();\n-        MemorySegment seg = allocate(layout);\n-        handle.set(seg, value);\n+        MemorySegment seg = allocateNoInit(layout);\n+        seg.set(layout, 0, value);\n@@ -256,2 +314,1 @@\n-     * {@return a new memory segment initialized with the address of the provided {@code value} as\n-     * specified by the provided {@code layout} (i.e. byte ordering, alignment and size)}\n+     * {@return a new memory segment initialized with the {@linkplain MemorySegment#address() address} of the provided memory segment.}\n@@ -260,0 +317,4 @@\n+     * <p>\n+     * The size of the allocated memory segment is the {@linkplain MemoryLayout#byteSize() size} of the given layout.\n+     * The given value is written into the segment according to the byte order and alignment constraint of the\n+     * given layout.\n@@ -271,0 +332,1 @@\n+     * @throws UnsupportedOperationException if {@code value} is not a {@linkplain MemorySegment#isNative() native} segment.\n@@ -272,1 +334,1 @@\n-    default MemorySegment allocate(AddressLayout layout, MemorySegment value) {\n+    default MemorySegment allocateFrom(AddressLayout layout, MemorySegment value) {\n@@ -275,3 +337,3 @@\n-        MemorySegment seg = allocate(layout);\n-        layout.varHandle().set(seg, value);\n-        return seg;\n+        MemorySegment segment = allocateNoInit(layout);\n+        segment.set(layout, 0, value);\n+        return segment;\n@@ -281,10 +343,11 @@\n-     * {@return a new memory segment with a {@linkplain MemorySegment#byteSize() byteSize()} of\n-     * {@code E*layout.byteSize()} initialized with the provided {@code E} {@code byte} {@code elements} as\n-     * specified by the provided {@code layout} (i.e. byte ordering, alignment and size)}\n-     *\n-     * @implSpec The default implementation is equivalent to:\n-     * {@snippet lang=java :\n-     *  int size = Objects.requireNonNull(elements).length;\n-     *  MemorySegment seg = allocateArray(Objects.requireNonNull(elementLayout), size);\n-     *  MemorySegment.copy(elements, 0, seg, elementLayout, 0, size);\n-     *  return seg;\n+     * {@return a new memory segment initialized with the contents of the provided segment.}\n+     * <p>\n+     * The size of the allocated memory segment is the {@code elementLayout.byteSize() * elementCount}.\n+     * The contents of the source segment is copied into the result segment element by element, according to the byte\n+     * order and alignment constraint of the given element layout.\n+     *\n+     * @implSpec the default implementation for this method is equivalent to the following code:\n+     * {@snippet lang = java:\n+     * MemorySegment dest = this.allocate(elementLayout, elementCount);\n+     * MemorySegment.copy(source, sourceElementLayout, sourceOffset, dest, elementLayout, 0, elementCount);\n+     * return dest;\n@@ -292,3 +355,17 @@\n-     *\n-     * @param elementLayout the element layout of the array to be allocated.\n-     * @param elements      the short elements to be copied to the newly allocated memory block.\n+     * @param elementLayout the element layout of the allocated array.\n+     * @param source the source segment.\n+     * @param sourceElementLayout the element layout of the source segment.\n+     * @param sourceOffset the starting offset, in bytes, of the source segment.\n+     * @param elementCount the number of elements in the source segment to be copied.\n+     * @throws IllegalArgumentException if {@code elementLayout.byteSize() != sourceElementLayout.byteSize()}.\n+     * @throws IllegalArgumentException if the source segment\/offset are <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a>\n+     * in the source element layout.\n+     * @throws IllegalArgumentException if {@code elementLayout.byteAlignment() > elementLayout.byteSize()}.\n+     * @throws IllegalArgumentException if {@code sourceElementLayout.byteAlignment() > sourceElementLayout.byteSize()}.\n+     * @throws IllegalStateException if the {@linkplain MemorySegment#scope() scope} associated with {@code source} is not\n+     * {@linkplain MemorySegment.Scope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code source.isAccessibleBy(T) == false}.\n+     * @throws IndexOutOfBoundsException if {@code elementCount * sourceElementLayout.byteSize()} overflows.\n+     * @throws IndexOutOfBoundsException if {@code sourceOffset > source.byteSize() - (elementCount * sourceElementLayout.byteSize())}.\n+     * @throws IndexOutOfBoundsException if either {@code sourceOffset} or {@code elementCount} are {@code < 0}.\n@@ -296,2 +373,9 @@\n-    default MemorySegment allocateArray(ValueLayout.OfByte elementLayout, byte... elements) {\n-        return copyArrayWithSwapIfNeeded(elements, elementLayout, MemorySegment::ofArray);\n+    @ForceInline\n+    default MemorySegment allocateFrom(ValueLayout elementLayout, MemorySegment source,\n+                                       ValueLayout sourceElementLayout, long sourceOffset, long elementCount) {\n+        Objects.requireNonNull(source);\n+        Objects.requireNonNull(sourceElementLayout);\n+        Objects.requireNonNull(elementLayout);\n+        MemorySegment dest = allocateNoInit(elementLayout, elementCount);\n+        MemorySegment.copy(source, sourceElementLayout, sourceOffset, dest, elementLayout, 0, elementCount);\n+        return dest;\n@@ -301,12 +385,11 @@\n-     * {@return a new memory segment with a {@linkplain MemorySegment#byteSize() byteSize()} of\n-     * {@code E*layout.byteSize()} initialized with the provided {@code E} {@code short} {@code elements} as\n-     * specified by the provided {@code layout} (i.e. byte ordering, alignment and size)}\n-     *\n-     * @implSpec The default implementation is equivalent to:\n-     * {@snippet lang=java :\n-     *  int size = Objects.requireNonNull(elements).length;\n-     *  MemorySegment seg = allocateArray(Objects.requireNonNull(elementLayout), size);\n-     *  MemorySegment.copy(elements, 0, seg, elementLayout, 0, size);\n-     *  return seg;\n-     * }\n-     *\n+     * {@return a new memory segment initialized with the elements in the provided byte array.}\n+     * <p>\n+     * The size of the allocated memory segment is {@code elementLayout.byteSize() * elements.length}.\n+     * The contents of the source array is copied into the result segment element by element, according to the byte\n+     * order and alignment constraint of the given element layout.\n+     *\n+     * @implSpec the default implementation for this method is equivalent to the following code:\n+     * {@snippet lang = java:\n+     * this.allocateFrom(layout, MemorySegment.ofArray(array),\n+     *                   ValueLayout.JAVA_BYTE, 0, array.length)\n+     *}\n@@ -314,1 +397,2 @@\n-     * @param elements      the short elements to be copied to the newly allocated memory block.\n+     * @param elements      the byte elements to be copied to the newly allocated memory block.\n+     * @throws IllegalArgumentException if {@code elementLayout.byteAlignment() > elementLayout.byteSize()}.\n@@ -316,2 +400,4 @@\n-    default MemorySegment allocateArray(ValueLayout.OfShort elementLayout, short... elements) {\n-        return copyArrayWithSwapIfNeeded(elements, elementLayout, MemorySegment::ofArray);\n+    @ForceInline\n+    default MemorySegment allocateFrom(ValueLayout.OfByte elementLayout, byte... elements) {\n+        return allocateFrom(elementLayout, MemorySegment.ofArray(elements),\n+                ValueLayout.JAVA_BYTE, 0, elements.length);\n@@ -321,12 +407,11 @@\n-     * {@return a new memory segment with a {@linkplain MemorySegment#byteSize() byteSize()} of\n-     * {@code E*layout.byteSize()} initialized with the provided {@code E} {@code char} {@code elements} as\n-     * specified by the provided {@code layout} (i.e. byte ordering, alignment and size)}\n-     *\n-     * @implSpec The default implementation is equivalent to:\n-     * {@snippet lang=java :\n-     *  int size = Objects.requireNonNull(elements).length;\n-     *  MemorySegment seg = allocateArray(Objects.requireNonNull(elementLayout), size);\n-     *  MemorySegment.copy(elements, 0, seg, elementLayout, 0, size);\n-     *  return seg;\n-     * }\n-     *\n+     * {@return a new memory segment initialized with the elements in the provided short array.}\n+     * <p>\n+     * The size of the allocated memory segment is {@code elementLayout.byteSize() * elements.length}.\n+     * The contents of the source array is copied into the result segment element by element, according to the byte\n+     * order and alignment constraint of the given element layout.\n+     *\n+     * @implSpec the default implementation for this method is equivalent to the following code:\n+     * {@snippet lang = java:\n+     * this.allocateFrom(layout, MemorySegment.ofArray(array),\n+     *                   ValueLayout.JAVA_SHORT, 0, array.length)\n+     *}\n@@ -335,0 +420,1 @@\n+     * @throws IllegalArgumentException if {@code elementLayout.byteAlignment() > elementLayout.byteSize()}.\n@@ -336,2 +422,4 @@\n-    default MemorySegment allocateArray(ValueLayout.OfChar elementLayout, char... elements) {\n-        return copyArrayWithSwapIfNeeded(elements, elementLayout, MemorySegment::ofArray);\n+    @ForceInline\n+    default MemorySegment allocateFrom(ValueLayout.OfShort elementLayout, short... elements) {\n+        return allocateFrom(elementLayout, MemorySegment.ofArray(elements),\n+                ValueLayout.JAVA_SHORT, 0, elements.length);\n@@ -341,12 +429,11 @@\n-     * {@return a new memory segment with a {@linkplain MemorySegment#byteSize() byteSize()} of\n-     * {@code E*layout.byteSize()} initialized with the provided {@code E} {@code int} {@code elements} as\n-     * specified by the provided {@code layout} (i.e. byte ordering, alignment and size)}\n-     *\n-     * @implSpec The default implementation is equivalent to:\n-     * {@snippet lang=java :\n-     *  int size = Objects.requireNonNull(elements).length;\n-     *  MemorySegment seg = allocateArray(Objects.requireNonNull(elementLayout), size);\n-     *  MemorySegment.copy(elements, 0, seg, elementLayout, 0, size);\n-     *  return seg;\n-     * }\n-     *\n+     * {@return a new memory segment initialized with the elements in the provided char array.}\n+     * <p>\n+     * The size of the allocated memory segment is {@code elementLayout.byteSize() * elements.length}.\n+     * The contents of the source array is copied into the result segment element by element, according to the byte\n+     * order and alignment constraint of the given element layout.\n+     *\n+     * @implSpec the default implementation for this method is equivalent to the following code:\n+     * {@snippet lang = java:\n+     * this.allocateFrom(layout, MemorySegment.ofArray(array),\n+     *                   ValueLayout.JAVA_CHAR, 0, array.length)\n+     *}\n@@ -354,1 +441,2 @@\n-     * @param elements      the short elements to be copied to the newly allocated memory block.\n+     * @param elements      the char elements to be copied to the newly allocated memory block.\n+     * @throws IllegalArgumentException if {@code elementLayout.byteAlignment() > elementLayout.byteSize()}.\n@@ -356,2 +444,4 @@\n-    default MemorySegment allocateArray(ValueLayout.OfInt elementLayout, int... elements) {\n-        return copyArrayWithSwapIfNeeded(elements, elementLayout, MemorySegment::ofArray);\n+    @ForceInline\n+    default MemorySegment allocateFrom(ValueLayout.OfChar elementLayout, char... elements) {\n+        return allocateFrom(elementLayout, MemorySegment.ofArray(elements),\n+                ValueLayout.JAVA_CHAR, 0, elements.length);\n@@ -361,12 +451,11 @@\n-     * {@return a new memory segment with a {@linkplain MemorySegment#byteSize() byteSize()} of\n-     * {@code E*layout.byteSize()} initialized with the provided {@code E} {@code float} {@code elements} as\n-     * specified by the provided {@code layout} (i.e. byte ordering, alignment and size)}\n-     *\n-     * @implSpec The default implementation is equivalent to:\n-     * {@snippet lang=java :\n-     *  int size = Objects.requireNonNull(elements).length;\n-     *  MemorySegment seg = allocateArray(Objects.requireNonNull(elementLayout), size);\n-     *  MemorySegment.copy(elements, 0, seg, elementLayout, 0, size);\n-     *  return seg;\n-     * }\n-     *\n+     * {@return a new memory segment initialized with the elements in the provided int array.}\n+     * <p>\n+     * The size of the allocated memory segment is {@code elementLayout.byteSize() * elements.length}.\n+     * The contents of the source array is copied into the result segment element by element, according to the byte\n+     * order and alignment constraint of the given element layout.\n+     *\n+     * @implSpec the default implementation for this method is equivalent to the following code:\n+     * {@snippet lang = java:\n+     * this.allocateFrom(layout, MemorySegment.ofArray(array),\n+     *                   ValueLayout.JAVA_INT, 0, array.length)\n+     *}\n@@ -374,1 +463,2 @@\n-     * @param elements      the short elements to be copied to the newly allocated memory block.\n+     * @param elements      the int elements to be copied to the newly allocated memory block.\n+     * @throws IllegalArgumentException if {@code elementLayout.byteAlignment() > elementLayout.byteSize()}.\n@@ -376,2 +466,4 @@\n-    default MemorySegment allocateArray(ValueLayout.OfFloat elementLayout, float... elements) {\n-        return copyArrayWithSwapIfNeeded(elements, elementLayout, MemorySegment::ofArray);\n+    @ForceInline\n+    default MemorySegment allocateFrom(ValueLayout.OfInt elementLayout, int... elements) {\n+        return allocateFrom(elementLayout, MemorySegment.ofArray(elements),\n+                ValueLayout.JAVA_INT, 0, elements.length);\n@@ -381,12 +473,11 @@\n-     * {@return a new memory segment with a {@linkplain MemorySegment#byteSize() byteSize()} of\n-     * {@code E*layout.byteSize()} initialized with the provided {@code E} {@code long} {@code elements} as\n-     * specified by the provided {@code layout} (i.e. byte ordering, alignment and size)}\n-     *\n-     * @implSpec The default implementation is equivalent to:\n-     * {@snippet lang=java :\n-     *  int size = Objects.requireNonNull(elements).length;\n-     *  MemorySegment seg = allocateArray(Objects.requireNonNull(elementLayout), size);\n-     *  MemorySegment.copy(elements, 0, seg, elementLayout, 0, size);\n-     *  return seg;\n-     * }\n-     *\n+     * {@return a new memory segment initialized with the elements in the provided float array.}\n+     * <p>\n+     * The size of the allocated memory segment is {@code elementLayout.byteSize() * elements.length}.\n+     * The contents of the source array is copied into the result segment element by element, according to the byte\n+     * order and alignment constraint of the given element layout.\n+     *\n+     * @implSpec the default implementation for this method is equivalent to the following code:\n+     * {@snippet lang = java:\n+     * this.allocateFrom(layout, MemorySegment.ofArray(array),\n+     *                   ValueLayout.JAVA_FLOAT, 0, array.length)\n+     *}\n@@ -394,1 +485,2 @@\n-     * @param elements      the short elements to be copied to the newly allocated memory block.\n+     * @param elements the float elements to be copied to the newly allocated memory block.\n+     * @throws IllegalArgumentException if {@code elementLayout.byteAlignment() > elementLayout.byteSize()}.\n@@ -396,2 +488,4 @@\n-    default MemorySegment allocateArray(ValueLayout.OfLong elementLayout, long... elements) {\n-        return copyArrayWithSwapIfNeeded(elements, elementLayout, MemorySegment::ofArray);\n+    @ForceInline\n+    default MemorySegment allocateFrom(ValueLayout.OfFloat elementLayout, float... elements) {\n+        return allocateFrom(elementLayout, MemorySegment.ofArray(elements),\n+                ValueLayout.JAVA_FLOAT, 0, elements.length);\n@@ -401,12 +495,11 @@\n-     * {@return a new memory segment with a {@linkplain MemorySegment#byteSize() byteSize()} of\n-     * {@code E*layout.byteSize()} initialized with the provided {@code E} {@code double} {@code elements} as\n-     * specified by the provided {@code layout} (i.e. byte ordering, alignment and size)}\n-     *\n-     * @implSpec The default implementation is equivalent to:\n-     * {@snippet lang=java :\n-     *  int size = Objects.requireNonNull(elements).length;\n-     *  MemorySegment seg = allocateArray(Objects.requireNonNull(elementLayout), size);\n-     *  MemorySegment.copy(elements, 0, seg, elementLayout, 0, size);\n-     *  return seg;\n-     * }\n-     *\n+     * {@return a new memory segment initialized with the elements in the provided long array.}\n+     * <p>\n+     * The size of the allocated memory segment is {@code elementLayout.byteSize() * elements.length}.\n+     * The contents of the source array is copied into the result segment element by element, according to the byte\n+     * order and alignment constraint of the given element layout.\n+     *\n+     * @implSpec the default implementation for this method is equivalent to the following code:\n+     * {@snippet lang = java:\n+     * this.allocateFrom(layout, MemorySegment.ofArray(array),\n+     *                   ValueLayout.JAVA_LONG, 0, array.length)\n+     *}\n@@ -414,1 +507,2 @@\n-     * @param elements      the short elements to be copied to the newly allocated memory block.\n+     * @param elements the long elements to be copied to the newly allocated memory block.\n+     * @throws IllegalArgumentException if {@code elementLayout.byteAlignment() > elementLayout.byteSize()}.\n@@ -416,2 +510,4 @@\n-    default MemorySegment allocateArray(ValueLayout.OfDouble elementLayout, double... elements) {\n-        return copyArrayWithSwapIfNeeded(elements, elementLayout, MemorySegment::ofArray);\n+    @ForceInline\n+    default MemorySegment allocateFrom(ValueLayout.OfLong elementLayout, long... elements) {\n+        return allocateFrom(elementLayout, MemorySegment.ofArray(elements),\n+                ValueLayout.JAVA_LONG, 0, elements.length);\n@@ -420,9 +516,20 @@\n-    private <Z> MemorySegment copyArrayWithSwapIfNeeded(Z array, ValueLayout elementLayout,\n-                                                        Function<Z, MemorySegment> heapSegmentFactory) {\n-        int size = Array.getLength(Objects.requireNonNull(array));\n-        MemorySegment seg = allocateArray(Objects.requireNonNull(elementLayout), size);\n-        if (size > 0) {\n-            MemorySegment.copy(heapSegmentFactory.apply(array), elementLayout, 0,\n-                    seg, elementLayout.withOrder(ByteOrder.nativeOrder()), 0, size);\n-        }\n-        return seg;\n+    \/**\n+     * {@return a new memory segment initialized with the elements in the provided double array.}\n+     * <p>\n+     * The size of the allocated memory segment is {@code elementLayout.byteSize() * elements.length}.\n+     * The contents of the source array is copied into the result segment element by element, according to the byte\n+     * order and alignment constraint of the given element layout.\n+     *\n+     * @implSpec the default implementation for this method is equivalent to the following code:\n+     * {@snippet lang = java:\n+     * this.allocateFrom(layout, MemorySegment.ofArray(array),\n+     *                   ValueLayout.JAVA_DOUBLE, 0, array.length)\n+     *}\n+     * @param elementLayout the element layout of the array to be allocated.\n+     * @param elements      the double elements to be copied to the newly allocated memory block.\n+     * @throws IllegalArgumentException if {@code elementLayout.byteAlignment() > elementLayout.byteSize()}.\n+     *\/\n+    @ForceInline\n+    default MemorySegment allocateFrom(ValueLayout.OfDouble elementLayout, double... elements) {\n+        return allocateFrom(elementLayout, MemorySegment.ofArray(elements),\n+                ValueLayout.JAVA_DOUBLE, 0, elements.length);\n@@ -455,1 +562,1 @@\n-    default MemorySegment allocateArray(MemoryLayout elementLayout, long count) {\n+    default MemorySegment allocate(MemoryLayout elementLayout, long count) {\n@@ -528,0 +635,21 @@\n+\n+    @ForceInline\n+    private MemorySegment allocateNoInit(long byteSize) {\n+        return this instanceof ArenaImpl arenaImpl ?\n+                arenaImpl.allocateNoInit(byteSize, 1) :\n+                allocate(byteSize);\n+    }\n+\n+    @ForceInline\n+    private MemorySegment allocateNoInit(MemoryLayout layout) {\n+        return this instanceof ArenaImpl arenaImpl ?\n+                arenaImpl.allocateNoInit(layout.byteSize(), layout.byteAlignment()) :\n+                allocate(layout);\n+    }\n+\n+    @ForceInline\n+    private MemorySegment allocateNoInit(MemoryLayout layout, long size) {\n+        return this instanceof ArenaImpl arenaImpl ?\n+                arenaImpl.allocateNoInit(layout.byteSize() * size, layout.byteAlignment()) :\n+                allocate(layout, size);\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SegmentAllocator.java","additions":304,"deletions":176,"binary":false,"changes":480,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.internal.javac.PreviewFeature;\n@@ -53,1 +52,1 @@\n- * @since 19\n+ * @since 22\n@@ -55,1 +54,0 @@\n-@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SequenceLayout.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.internal.javac.PreviewFeature;\n@@ -37,1 +36,1 @@\n- * @since 20\n+ * @since 22\n@@ -39,1 +38,0 @@\n-@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/StructLayout.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import jdk.internal.javac.PreviewFeature;\n@@ -123,1 +122,1 @@\n- * @since 19\n+ * @since 22\n@@ -125,1 +124,0 @@\n-@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n@@ -170,1 +168,1 @@\n-     * returned by this method is associated with a fresh {@linkplain MemorySegment.Scope scope} which keeps the caller's\n+     * returned by this method is associated with an automatic {@linkplain MemorySegment.Scope scope} which keeps the caller's\n@@ -194,1 +192,1 @@\n-            MemorySessionImpl session = MemorySessionImpl.heapSession(loader);\n+            MemorySessionImpl session = MemorySessionImpl.createHeap(loader);\n@@ -216,5 +214,0 @@\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n@@ -251,5 +244,0 @@\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SymbolLookup.java","additions":3,"deletions":15,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.internal.javac.PreviewFeature;\n@@ -37,1 +36,1 @@\n- * @since 20\n+ * @since 22\n@@ -39,1 +38,0 @@\n-@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/UnionLayout.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.lang.invoke.MethodHandles;\n@@ -31,1 +30,0 @@\n-\n@@ -33,1 +31,0 @@\n-import jdk.internal.javac.PreviewFeature;\n@@ -54,1 +51,1 @@\n- * @since 19\n+ * @since 22\n@@ -56,1 +53,0 @@\n-@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n@@ -79,60 +75,0 @@\n-    \/**\n-     * Creates a <em>strided<\/em> var handle that can be used to access a memory segment as multi-dimensional\n-     * array. This array has a notional sequence layout featuring {@code shape.length} nested sequence layouts. The element\n-     * layout of the innermost sequence layout in the notional sequence layout is this value layout. The resulting var handle\n-     * is obtained as if calling the {@link #varHandle(PathElement...)} method on the notional layout, with a layout\n-     * path containing exactly {@code shape.length + 1} {@linkplain PathElement#sequenceElement() open sequence layout path elements}.\n-     * <p>\n-     * For instance, the following method call:\n-     *\n-     * {@snippet lang=java :\n-     * VarHandle arrayHandle = ValueLayout.JAVA_INT.arrayElementVarHandle(10, 20);\n-     * }\n-     *\n-     * Is equivalent to the following code:\n-     *\n-     * {@snippet lang = java:\n-     * SequenceLayout notionalLayout = MemoryLayout.sequenceLayout(\n- *                                         MemoryLayout.sequenceLayout(10, MemoryLayout.sequenceLayout(20, ValueLayout.JAVA_INT)));\n-     * VarHandle arrayHandle = notionalLayout.varHandle(PathElement.sequenceElement(),\n-     *                                                  PathElement.sequenceElement(),\n-     *                                                  PathElement.sequenceElement());\n-     *}\n-     *\n-     * The resulting var handle {@code arrayHandle} will feature 3 coordinates of type {@code long}; each coordinate\n-     * is interpreted as an index into the corresponding sequence layout. If we refer to the var handle coordinates, from left\n-     * to right, as {@code x}, {@code y} and {@code z} respectively, the final offset accessed by the var handle can be\n-     * computed with the following formula:\n-     *\n-     * <blockquote><pre>{@code\n-     * offset = (10 * 20 * 4 * x) + (20 * 4 * y) + (4 * z)\n-     * }<\/pre><\/blockquote>\n-     *\n-     * Additionally, the values of {@code x}, {@code y} and {@code z} are constrained as follows:\n-     * <ul>\n-     *     <li>{@code 0 <= x < notionalLayout.elementCount() }<\/li>\n-     *     <li>{@code 0 <= y < 10 }<\/li>\n-     *     <li>{@code 0 <= z < 20 }<\/li>\n-     * <\/ul>\n-     * <p>\n-     * Consider the following access expressions:\n-     * {@snippet lang=java :\n-     * int value1 = (int) arrayHandle.get(10, 2, 4); \/\/ ok, accessed offset = 8176\n-     * int value2 = (int) arrayHandle.get(0, 0, 30); \/\/ out of bounds value for z\n-     * }\n-     * In the first case, access is well-formed, as the values for {@code x}, {@code y} and {@code z} conform to\n-     * the bounds specified above. In the second case, access fails with {@link IndexOutOfBoundsException},\n-     * as the value for {@code z} is outside its specified bounds.\n-     *\n-     * @param shape the size of each nested array dimension.\n-     * @return a var handle which can be used to access a memory segment as a multi-dimensional array,\n-     * featuring {@code shape.length + 1}\n-     * {@code long} coordinates.\n-     * @throws IllegalArgumentException if {@code shape[i] < 0}, for at least one index {@code i}.\n-     * @throws UnsupportedOperationException if {@code byteAlignment() > byteSize()}.\n-     * @see MethodHandles#memorySegmentViewVarHandle\n-     * @see MemoryLayout#varHandle(PathElement...)\n-     * @see SequenceLayout\n-     *\/\n-    VarHandle arrayElementVarHandle(int... shape);\n-\n@@ -152,0 +88,1 @@\n+     *\n@@ -157,0 +94,21 @@\n+    \/**\n+     * {@return a var handle which can be used to access values described by this value layout, in a given memory segment.}\n+     * <p>\n+     * The returned var handle's {@linkplain VarHandle#varType() var type} is the {@linkplain ValueLayout#carrier() carrier type} of\n+     * this value layout, and the list of coordinate types is {@code (MemorySegment, long)}, where the memory segment coordinate\n+     * corresponds to the memory segment to be accessed, and the {@code long} coordinate corresponds to the byte offset\n+     * into the accessed memory segment at which the access occurs.\n+     * <p>\n+     * The returned var handle checks that accesses are aligned according to this value layout's\n+     * {@linkplain MemoryLayout#byteAlignment() alignment constraint}.\n+     *\n+     * @apiNote This method is similar, but more efficient, than calling {@code MemoryLayout#varHandle(PathElement...)}\n+     * with an empty path element array, as it avoids the creation of the var args array.\n+     *\n+     * @apiNote The returned var handle features certain <a href=\"MemoryLayout.html#access-mode-restrictions\">access mode\n+     * restrictions<\/a> common to all memory access var handles derived from memory layouts.\n+     *\n+     * @see MemoryLayout#varHandle(PathElement...)\n+     *\/\n+    VarHandle varHandle();\n+\n@@ -161,1 +119,1 @@\n-     * @since 19\n+     * @since 22\n@@ -163,2 +121,1 @@\n-    @PreviewFeature(feature = PreviewFeature.Feature.FOREIGN)\n-    sealed interface OfBoolean extends ValueLayout permits ValueLayouts.OfBooleanImpl {\n+        sealed interface OfBoolean extends ValueLayout permits ValueLayouts.OfBooleanImpl {\n@@ -197,1 +154,1 @@\n-     * @since 19\n+     * @since 22\n@@ -199,2 +156,1 @@\n-    @PreviewFeature(feature = PreviewFeature.Feature.FOREIGN)\n-    sealed interface OfByte extends ValueLayout permits ValueLayouts.OfByteImpl {\n+        sealed interface OfByte extends ValueLayout permits ValueLayouts.OfByteImpl {\n@@ -234,1 +190,1 @@\n-     * @since 19\n+     * @since 22\n@@ -236,2 +192,1 @@\n-    @PreviewFeature(feature = PreviewFeature.Feature.FOREIGN)\n-    sealed interface OfChar extends ValueLayout permits ValueLayouts.OfCharImpl {\n+        sealed interface OfChar extends ValueLayout permits ValueLayouts.OfCharImpl {\n@@ -271,1 +226,1 @@\n-     * @since 19\n+     * @since 22\n@@ -273,2 +228,1 @@\n-    @PreviewFeature(feature = PreviewFeature.Feature.FOREIGN)\n-    sealed interface OfShort extends ValueLayout permits ValueLayouts.OfShortImpl {\n+        sealed interface OfShort extends ValueLayout permits ValueLayouts.OfShortImpl {\n@@ -308,1 +262,1 @@\n-     * @since 19\n+     * @since 22\n@@ -310,2 +264,1 @@\n-    @PreviewFeature(feature = PreviewFeature.Feature.FOREIGN)\n-    sealed interface OfInt extends ValueLayout permits ValueLayouts.OfIntImpl {\n+        sealed interface OfInt extends ValueLayout permits ValueLayouts.OfIntImpl {\n@@ -345,1 +298,1 @@\n-     * @since 19\n+     * @since 22\n@@ -347,2 +300,1 @@\n-    @PreviewFeature(feature = PreviewFeature.Feature.FOREIGN)\n-    sealed interface OfFloat extends ValueLayout permits ValueLayouts.OfFloatImpl {\n+        sealed interface OfFloat extends ValueLayout permits ValueLayouts.OfFloatImpl {\n@@ -381,1 +333,1 @@\n-     * @since 19\n+     * @since 22\n@@ -383,2 +335,1 @@\n-    @PreviewFeature(feature = PreviewFeature.Feature.FOREIGN)\n-    sealed interface OfLong extends ValueLayout permits ValueLayouts.OfLongImpl {\n+        sealed interface OfLong extends ValueLayout permits ValueLayouts.OfLongImpl {\n@@ -418,1 +369,1 @@\n-     * @since 19\n+     * @since 22\n@@ -420,2 +371,1 @@\n-    @PreviewFeature(feature = PreviewFeature.Feature.FOREIGN)\n-    sealed interface OfDouble extends ValueLayout permits ValueLayouts.OfDoubleImpl {\n+        sealed interface OfDouble extends ValueLayout permits ValueLayouts.OfDoubleImpl {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/ValueLayout.java","additions":39,"deletions":89,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -96,1 +96,1 @@\n- *     MemorySegment cString = arena.allocateUtf8String(\"Hello\");\n+ *     MemorySegment cString = arena.allocateFrom(\"Hello\");\n@@ -112,1 +112,1 @@\n- * {@linkplain java.lang.foreign.SegmentAllocator#allocateUtf8String(java.lang.String) converting} Java strings into\n+ * {@linkplain java.lang.foreign.SegmentAllocator#allocateFrom(java.lang.String) converting} Java strings into\n@@ -138,2 +138,2 @@\n- * @apiNote Usual memory model guarantees, for example stated in {@jls 6.6} and {@jls 10.4}, do not apply\n- * when accessing native memory segments as these segments are backed by off-heap regions of memory.\n+ * @apiNote Usual memory model guarantees (see {@jls 17.4}) do not apply when accessing native memory segments as\n+ * these segments are backed by off-heap regions of memory.\n@@ -150,1 +150,1 @@\n- * @since 19\n+ * @since 22\n@@ -152,1 +152,0 @@\n-@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n@@ -155,1 +154,0 @@\n-import jdk.internal.javac.PreviewFeature;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/package-info.java","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -125,1 +125,1 @@\n-                    MemorySegment s = slicingArena.allocateArray(JAVA_INT, 1, 2, 3, 4, 5);\n+                    MemorySegment s = slicingArena.allocateFrom(JAVA_INT, 1, 2, 3, 4, 5);\n@@ -151,1 +151,1 @@\n-                    sequenceLayout(ValueLayout.JAVA_BYTE));\n+                    sequenceLayout(Long.MAX_VALUE, ValueLayout.JAVA_BYTE));\n@@ -171,1 +171,1 @@\n-                MemorySegment str = arena.allocateUtf8String(\"Hello\");\n+                MemorySegment str = arena.allocateFrom(\"Hello\");\n@@ -200,1 +200,1 @@\n-                MemorySegment array = arena.allocateArray(JAVA_INT, 0, 9, 3, 4, 6, 5, 1, 8, 2, 7);\n+                MemorySegment array = arena.allocateFrom(JAVA_INT, 0, 9, 3, 4, 6, 5, 1, 8, 2, 7);\n@@ -291,1 +291,1 @@\n-                int res = (int) printf.invokeExact(arena.allocateUtf8String(\"%d plus %d equals %d\"), 2, 2, 4); \/\/prints \"2 plus 2 equals 4\"\n+                int res = (int) printf.invokeExact(arena.allocateFrom(\"%d plus %d equals %d\"), 2, 2, 4); \/\/prints \"2 plus 2 equals 4\"\n@@ -316,1 +316,1 @@\n-                int errno = (int) errnoHandle.get(capturedState);\n+                int errno = (int) errnoHandle.get(capturedState, 0L);\n@@ -354,2 +354,2 @@\n-            long offset1 = (long) offsetHandle.invokeExact(1L); \/\/ 8\n-            long offset2 = (long) offsetHandle.invokeExact(2L); \/\/ 16\n+            long offset1 = (long) offsetHandle.invokeExact(0L, 1L); \/\/ 8\n+            long offset2 = (long) offsetHandle.invokeExact(0L, 2L); \/\/ 16\n@@ -399,1 +399,1 @@\n-                VarHandle intHandle = MethodHandles.memorySegmentViewVarHandle(ValueLayout.JAVA_INT);\n+                VarHandle intHandle = ValueLayout.JAVA_INT.varHandle();\n@@ -411,2 +411,7 @@\n-                VarHandle intHandle = ValueLayout.JAVA_INT.arrayElementVarHandle();\n-                int value = (int) intHandle.get(segment, 3L); \/\/ get int element at offset 3 * 4 = 12\n+                MemoryLayout segmentLayout = MemoryLayout.structLayout(\n+                    ValueLayout.JAVA_INT.withName(\"size\"),\n+                    MemoryLayout.sequenceLayout(4, ValueLayout.JAVA_INT).withName(\"data\") \/\/ array of 4 elements\n+                );\n+                VarHandle intHandle = segmentLayout.varHandle(MemoryLayout.PathElement.groupElement(\"data\"),\n+                                                              MemoryLayout.PathElement.sequenceElement());\n+                int value = (int) intHandle.get(segment, 0L, 3L); \/\/ get int element at offset 0 + offsetof(data) + 3 * 4 = 12\n@@ -527,2 +532,0 @@\n-            var byteHandle = MemoryLayout.sequenceLayout(ValueLayout.JAVA_BYTE)\n-                    .varHandle(MemoryLayout.PathElement.sequenceElement());\n@@ -530,1 +533,1 @@\n-                byteHandle.set(segment.address(), l, value);\n+                segment.set(JAVA_BYTE, l, value);\n@@ -573,1 +576,1 @@\n-                MemorySegment cString = arena.allocateUtf8String(\"Hello\");\n+                MemorySegment cString = arena.allocateFrom(\"Hello\");\n@@ -657,11 +660,0 @@\n-        void arrayElementVarHandle() {\n-            VarHandle arrayHandle = ValueLayout.JAVA_INT.arrayElementVarHandle(10, 20);\n-\n-            SequenceLayout arrayLayout = MemoryLayout.sequenceLayout(\n-                    MemoryLayout.sequenceLayout(10,\n-                            MemoryLayout.sequenceLayout(20, ValueLayout.JAVA_INT)));\n-\n-            int value1 = (int) arrayHandle.get(10, 2, 4); \/\/ ok, accessed offset = 8176\n-            int value2 = (int) arrayHandle.get(0, 0, 30); \/\/ out of bounds value for z\n-        }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/snippet-files\/Snippets.java","additions":18,"deletions":26,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -29,2 +29,0 @@\n-import jdk.internal.foreign.Utils;\n-import jdk.internal.javac.PreviewFeature;\n@@ -48,4 +46,0 @@\n-import java.lang.foreign.GroupLayout;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.ValueLayout;\n@@ -7981,79 +7975,0 @@\n-    \/**\n-     * Creates a var handle object, which can be used to dereference a {@linkplain java.lang.foreign.MemorySegment memory segment}\n-     * at a given byte offset, using the provided value layout.\n-     *\n-     * <p>The provided layout specifies the {@linkplain ValueLayout#carrier() carrier type},\n-     * the {@linkplain ValueLayout#byteSize() byte size},\n-     * the {@linkplain ValueLayout#byteAlignment() byte alignment} and the {@linkplain ValueLayout#order() byte order}\n-     * associated with the returned var handle.\n-     *\n-     * <p>The list of coordinate types associated with the returned var handle is {@code (MemorySegment, long)},\n-     * where the {@code long} coordinate type corresponds to byte offset into the given memory segment coordinate.\n-     * Thus, the returned var handle accesses bytes at an offset in a given memory segment, composing bytes to or from\n-     * a value of the var handle type. Moreover, the access operation will honor the endianness and the\n-     * alignment constraints expressed in the provided layout.\n-     *\n-     * <p>As an example, consider the memory layout expressed by a {@link GroupLayout} instance constructed as follows:\n-     * {@snippet lang=\"java\" :\n-     *     GroupLayout seq = java.lang.foreign.MemoryLayout.structLayout(\n-     *             MemoryLayout.paddingLayout(4),\n-     *             ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN).withName(\"value\")\n-     *     );\n-     * }\n-     * To access the member layout named {@code value}, we can construct a memory segment view var handle as follows:\n-     * {@snippet lang=\"java\" :\n-     *     VarHandle handle = MethodHandles.memorySegmentViewVarHandle(ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN)); \/\/(MemorySegment, long) -> int\n-     *     handle = MethodHandles.insertCoordinates(handle, 1, 4); \/\/(MemorySegment) -> int\n-     * }\n-     *\n-     * @apiNote The resulting var handle features certain <i>access mode restrictions<\/i>,\n-     * which are common to all memory segment view var handles. A memory segment view var handle is associated\n-     * with an access size {@code S} and an alignment constraint {@code B}\n-     * (both expressed in bytes). We say that a memory access operation is <em>fully aligned<\/em> if it occurs\n-     * at a memory address {@code A} which is compatible with both alignment constraints {@code S} and {@code B}.\n-     * If access is fully aligned then following access modes are supported and are\n-     * guaranteed to support atomic access:\n-     * <ul>\n-     * <li>read write access modes for all {@code T}, with the exception of\n-     *     access modes {@code get} and {@code set} for {@code long} and\n-     *     {@code double} on 32-bit platforms.\n-     * <li>atomic update access modes for {@code int}, {@code long},\n-     *     {@code float}, {@code double} or {@link MemorySegment}.\n-     *     (Future major platform releases of the JDK may support additional\n-     *     types for certain currently unsupported access modes.)\n-     * <li>numeric atomic update access modes for {@code int}, {@code long} and {@link MemorySegment}.\n-     *     (Future major platform releases of the JDK may support additional\n-     *     numeric types for certain currently unsupported access modes.)\n-     * <li>bitwise atomic update access modes for {@code int}, {@code long} and {@link MemorySegment}.\n-     *     (Future major platform releases of the JDK may support additional\n-     *     numeric types for certain currently unsupported access modes.)\n-     * <\/ul>\n-     *\n-     * If {@code T} is {@code float}, {@code double} or {@link MemorySegment} then atomic\n-     * update access modes compare values using their bitwise representation\n-     * (see {@link Float#floatToRawIntBits},\n-     * {@link Double#doubleToRawLongBits} and {@link MemorySegment#address()}, respectively).\n-     * <p>\n-     * Alternatively, a memory access operation is <em>partially aligned<\/em> if it occurs at a memory address {@code A}\n-     * which is only compatible with the alignment constraint {@code B}; in such cases, access for anything other than the\n-     * {@code get} and {@code set} access modes will result in an {@code IllegalStateException}. If access is partially aligned,\n-     * atomic access is only guaranteed with respect to the largest power of two that divides the GCD of {@code A} and {@code S}.\n-     * <p>\n-     * In all other cases, we say that a memory access operation is <em>misaligned<\/em>; in such cases an\n-     * {@code IllegalStateException} is thrown, irrespective of the access mode being used.\n-     * <p>\n-     * Finally, if {@code T} is {@code MemorySegment} all write access modes throw {@link IllegalArgumentException}\n-     * unless the value to be written is a {@linkplain MemorySegment#isNative() native} memory segment.\n-     *\n-     * @param layout the value layout for which a memory access handle is to be obtained.\n-     * @return the new memory segment view var handle.\n-     * @throws NullPointerException if {@code layout} is {@code null}.\n-     * @see MemoryLayout#varHandle(MemoryLayout.PathElement...)\n-     * @since 19\n-     *\/\n-    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n-    public static VarHandle memorySegmentViewVarHandle(ValueLayout layout) {\n-        Objects.requireNonNull(layout);\n-        return Utils.makeSegmentViewVarHandle(layout);\n-    }\n-\n@@ -8090,1 +8005,1 @@\n-     * @since 19\n+     * @since 22\n@@ -8092,1 +8007,0 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n@@ -8126,1 +8040,1 @@\n-     * @since 19\n+     * @since 22\n@@ -8128,1 +8042,0 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n@@ -8158,1 +8071,1 @@\n-     * @since 19\n+     * @since 22\n@@ -8160,1 +8073,0 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n@@ -8201,1 +8113,1 @@\n-     * @since 19\n+     * @since 22\n@@ -8203,1 +8115,0 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n@@ -8245,1 +8156,1 @@\n-     * @since 19\n+     * @since 22\n@@ -8247,1 +8158,0 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n@@ -8271,1 +8181,1 @@\n-     * @since 19\n+     * @since 22\n@@ -8273,1 +8183,0 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":6,"deletions":97,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -703,8 +703,2 @@\n-        MethodHandle prepend;\n-        int idx = classIndex(cl);\n-        if (prefix == null) {\n-            prepend = NULL_PREPENDERS[idx];\n-            if (prepend == null) {\n-                NULL_PREPENDERS[idx] = prepend = MethodHandles.insertArguments(\n-                                prepender(cl), 3, (String)null);\n-            }\n+        if (prefix == null || prefix.isEmpty()) {\n+            return noPrefixPrepender(cl);\n@@ -712,1 +706,1 @@\n-            prepend = MethodHandles.insertArguments(\n+            return MethodHandles.insertArguments(\n@@ -715,1 +709,0 @@\n-        return prepend;\n@@ -732,0 +725,14 @@\n+    private static MethodHandle noPrefixPrepender(Class<?> cl) {\n+        int idx = classIndex(cl);\n+        MethodHandle prepend = NO_PREFIX_PREPENDERS[idx];\n+        if (prepend == null) {\n+            if (idx == STRING_CONCAT_ITEM) {\n+                cl = FormatConcatItem.class;\n+            }\n+            NO_PREFIX_PREPENDERS[idx] = prepend = JLA.stringConcatHelper(\"prepend\",\n+                    methodType(long.class, long.class, byte[].class,\n+                            Wrapper.asPrimitiveType(cl))).rebind();\n+        }\n+        return prepend;\n+    }\n+\n@@ -998,1 +1005,1 @@\n-    private static final @Stable MethodHandle[] NULL_PREPENDERS = new MethodHandle[TYPE_COUNT];\n+    private static final @Stable MethodHandle[] NO_PREFIX_PREPENDERS = new MethodHandle[TYPE_COUNT];\n@@ -1120,1 +1127,1 @@\n-            MethodHandle prepender = prepender(fragment.isEmpty() ? null : fragment, ttype);\n+            MethodHandle prepender = prepender(fragment, ttype);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/StringConcatFactory.java","additions":19,"deletions":12,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import jdk.internal.foreign.Utils;\n+\n@@ -57,1 +59,5 @@\n-        return new IllegalArgumentException(\"Misaligned access at address: \" + address);\n+        return new IllegalArgumentException(\"Misaligned access at address: \" + Utils.toHexString(address));\n+    }\n+\n+    static UnsupportedOperationException newUnsupportedAccessModeForAlignment(long alignment) {\n+        return new UnsupportedOperationException(\"Unsupported access mode for alignment: \" + alignment);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandleSegmentViewBase.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-    static final int VM_ALIGN = $BoxType$.BYTES - 1;\n+    static final int NON_PLAIN_ACCESS_MIN_ALIGN_MASK = $BoxType$.BYTES - 1;\n@@ -107,4 +107,3 @@\n-    static long offset(AbstractMemorySegmentImpl bb, long offset, long alignmentMask) {\n-        long address = offsetNoVMAlignCheck(bb, offset, alignmentMask);\n-        if ((address & VM_ALIGN) != 0) {\n-            throw VarHandleSegmentViewBase.newIllegalArgumentExceptionForMisalignedAccess(address);\n+    static long offsetNonPlain(AbstractMemorySegmentImpl bb, long offset, long alignmentMask) {\n+        if ((alignmentMask & NON_PLAIN_ACCESS_MIN_ALIGN_MASK) != NON_PLAIN_ACCESS_MIN_ALIGN_MASK) {\n+            throw VarHandleSegmentViewBase.newUnsupportedAccessModeForAlignment(alignmentMask + 1);\n@@ -112,1 +111,1 @@\n-        return address;\n+        return offsetPlain(bb, offset, alignmentMask);\n@@ -116,1 +115,1 @@\n-    static long offsetNoVMAlignCheck(AbstractMemorySegmentImpl bb, long offset, long alignmentMask) {\n+    static long offsetPlain(AbstractMemorySegmentImpl bb, long offset, long alignmentMask) {\n@@ -133,1 +132,1 @@\n-                offsetNoVMAlignCheck(bb, base, handle.alignmentMask),\n+                offsetPlain(bb, base, handle.alignmentMask),\n@@ -140,1 +139,1 @@\n-                offsetNoVMAlignCheck(bb, base, handle.alignmentMask));\n+                offsetPlain(bb, base, handle.alignmentMask));\n@@ -144,1 +143,1 @@\n-                offsetNoVMAlignCheck(bb, base, handle.alignmentMask),\n+                offsetPlain(bb, base, handle.alignmentMask),\n@@ -157,1 +156,1 @@\n-                offsetNoVMAlignCheck(bb, base, handle.alignmentMask),\n+                offsetPlain(bb, base, handle.alignmentMask),\n@@ -164,1 +163,1 @@\n-                offsetNoVMAlignCheck(bb, base, handle.alignmentMask),\n+                offsetPlain(bb, base, handle.alignmentMask),\n@@ -169,1 +168,1 @@\n-                offsetNoVMAlignCheck(bb, base, handle.alignmentMask),\n+                offsetPlain(bb, base, handle.alignmentMask),\n@@ -183,1 +182,1 @@\n-                                  offset(bb, base, handle.alignmentMask)));\n+                                  offsetNonPlain(bb, base, handle.alignmentMask)));\n@@ -192,1 +191,1 @@\n-                offset(bb, base, handle.alignmentMask),\n+                offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -203,1 +202,1 @@\n-                                  offset(bb, base, handle.alignmentMask)));\n+                                  offsetNonPlain(bb, base, handle.alignmentMask)));\n@@ -212,1 +211,1 @@\n-                offset(bb, base, handle.alignmentMask),\n+                offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -223,1 +222,1 @@\n-                                  offset(bb, base, handle.alignmentMask)));\n+                                  offsetNonPlain(bb, base, handle.alignmentMask)));\n@@ -232,1 +231,1 @@\n-                offset(bb, base, handle.alignmentMask),\n+                offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -243,1 +242,1 @@\n-                offset(bb, base, handle.alignmentMask),\n+                offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -254,1 +253,1 @@\n-                                  offset(bb, base, handle.alignmentMask),\n+                                  offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -265,1 +264,1 @@\n-                                  offset(bb, base, handle.alignmentMask),\n+                                  offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -276,1 +275,1 @@\n-                                  offset(bb, base, handle.alignmentMask),\n+                                  offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -286,1 +285,1 @@\n-                offset(bb, base, handle.alignmentMask),\n+                offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -296,1 +295,1 @@\n-                offset(bb, base, handle.alignmentMask),\n+                offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -306,1 +305,1 @@\n-                offset(bb, base, handle.alignmentMask),\n+                offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -316,1 +315,1 @@\n-                offset(bb, base, handle.alignmentMask),\n+                offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -327,1 +326,1 @@\n-                                  offset(bb, base, handle.alignmentMask),\n+                                  offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -338,1 +337,1 @@\n-                                  offset(bb, base, handle.alignmentMask),\n+                                  offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -349,1 +348,1 @@\n-                                  offset(bb, base, handle.alignmentMask),\n+                                  offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -362,1 +361,1 @@\n-                    offset(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -365,1 +364,1 @@\n-            return getAndAddConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), delta);\n+            return getAndAddConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), delta);\n@@ -376,1 +375,1 @@\n-                    offset(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -379,1 +378,1 @@\n-            return getAndAddConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), delta);\n+            return getAndAddConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), delta);\n@@ -390,1 +389,1 @@\n-                    offset(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -393,1 +392,1 @@\n-            return getAndAddConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), delta);\n+            return getAndAddConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), delta);\n@@ -418,1 +417,1 @@\n-                    offset(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -421,1 +420,1 @@\n-            return getAndBitwiseOrConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseOrConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), value);\n@@ -432,1 +431,1 @@\n-                    offset(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -435,1 +434,1 @@\n-            return getAndBitwiseOrConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseOrConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), value);\n@@ -446,1 +445,1 @@\n-                    offset(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -449,1 +448,1 @@\n-            return getAndBitwiseOrConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseOrConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), value);\n@@ -472,1 +471,1 @@\n-                    offset(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -475,1 +474,1 @@\n-            return getAndBitwiseAndConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseAndConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), value);\n@@ -486,1 +485,1 @@\n-                    offset(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -489,1 +488,1 @@\n-            return getAndBitwiseAndConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseAndConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), value);\n@@ -500,1 +499,1 @@\n-                    offset(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -503,1 +502,1 @@\n-            return getAndBitwiseAndConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseAndConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), value);\n@@ -527,1 +526,1 @@\n-                    offset(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -530,1 +529,1 @@\n-            return getAndBitwiseXorConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseXorConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), value);\n@@ -541,1 +540,1 @@\n-                    offset(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -544,1 +543,1 @@\n-            return getAndBitwiseXorConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseXorConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), value);\n@@ -555,1 +554,1 @@\n-                    offset(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -558,1 +557,1 @@\n-            return getAndBitwiseXorConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseXorConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), value);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/X-VarHandleSegmentView.java.template","additions":54,"deletions":55,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -282,1 +282,1 @@\n-\n+ *\n@@ -295,0 +295,21 @@\n+ * <h2><a id=algorithmicComplexity>Algorithmic Complexity<\/a><\/h2>\n+ *\n+ * Operations on {@code BigDecimal} values have a range of algorithmic\n+ * complexities; in general, those complexities are a function of both\n+ * the size of the unscaled value as well as the size of the\n+ * scale. For example, an {@linkplain BigDecimal#multiply(BigDecimal)\n+ * exact multiply} of two {@code BigDecimal} values is subject to the\n+ * same {@linkplain BigInteger##algorithmicComplexity complexity\n+ * constraints} as {@code BigInteger} multiply of the unscaled\n+ * values. In contrast, a {@code BigDecimal} value with a compact\n+ * representation like {@code new BigDecimal(1E-1000000000)} has a\n+ * {@link toPlainString} result with over one billion characters.\n+ *\n+ * <p>Operations may also allocate and compute on intermediate\n+ * results, potentially those allocations may be as large as in\n+ * proportion to the running time of the algorithm.\n+ *\n+ * <p>Users of {@code BigDecimal} concerned with bounding the running\n+ * time or space of operations can screen out {@code BigDecimal}\n+ * values with unscaled values or scales above a chosen magnitude.\n+ *\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigDecimal.java","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -121,0 +121,36 @@\n+ * @apiNote\n+ * <a id=algorithmicComplexity>As {@code BigInteger} values are\n+ * arbitrary precision integers, the algorithmic complexity of the\n+ * methods of this class varies and may be superlinear in the size of\n+ * the input. For example, a method like {@link intValue()} would be\n+ * expected to run in <i>O<\/i>(1), that is constant time, since with\n+ * the current internal representation only a fixed-size component of\n+ * the {@code BigInteger} needs to be accessed to perform the\n+ * conversion to {@code int}. In contrast, a method like {@link not()}\n+ * would be expected to run in <i>O<\/i>(<i>n<\/i>) time where <i>n<\/i>\n+ * is the size of the {@code BigInteger} in bits, that is, to run in\n+ * time proportional to the size of the input. For multiplying two\n+ * {@code BigInteger} values of size <i>n<\/i>, a naive multiplication\n+ * algorithm would run in time <i>O<\/i>(<i>n<sup>2<\/sup><\/i>) and\n+ * theoretical results indicate a multiplication algorithm for numbers\n+ * using this category of representation must run in <em>at least<\/em>\n+ * <i>O<\/i>(<i>n<\/i>&nbsp;log&nbsp;<i>n<\/i>). Common multiplication\n+ * algorithms between the bounds of the naive and theoretical cases\n+ * include the Karatsuba multiplication\n+ * (<i>O<\/i>(<i>n<sup>1.585<\/sup><\/i>)) and 3-way Toom-Cook\n+ * multiplication (<i>O<\/i>(<i>n<sup>1.465<\/sup><\/i>)).<\/a>\n+ *\n+ * <p>A particular implementation of {@link multiply(BigInteger)\n+ * multiply} is free to switch between different algorithms for\n+ * different inputs, such as to improve actual running time to produce\n+ * the product by using simpler algorithms for smaller inputs even if\n+ * the simpler algorithm has a larger asymptotic complexity.\n+ *\n+ * <p>Operations may also allocate and compute on intermediate\n+ * results, potentially those allocations may be as large as in\n+ * proportion to the running time of the algorithm.\n+ *\n+ * <p>Users of {@code BigInteger} concerned with bounding the running\n+ * time or space of operations can screen out {@code BigInteger}\n+ * values above a chosen magnitude.\n+ *\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigInteger.java","additions":37,"deletions":1,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.util.Locale;\n@@ -181,1 +180,2 @@\n-     * and HTTPS requests. If proxy is {@code null} then proxying is disabled.\n+     * and HTTPS requests. If {@code proxyAddress} is {@code null}\n+     * then proxying is disabled.\n@@ -210,0 +210,3 @@\n+            if (uri == null || sa == null || e == null) {\n+                throw new IllegalArgumentException(\"Arguments can't be null.\");\n+            }\n@@ -214,3 +217,9 @@\n-        public synchronized List<Proxy> select(URI uri) {\n-            String scheme = uri.getScheme().toLowerCase(Locale.ROOT);\n-            if (scheme.equals(\"http\") || scheme.equals(\"https\")) {\n+        public List<Proxy> select(URI uri) {\n+            if (uri == null) {\n+                throw new IllegalArgumentException(\"URI can't be null\");\n+            }\n+            String scheme = uri.getScheme();\n+            if (scheme == null) {\n+                throw new IllegalArgumentException(\"protocol can't be null\");\n+            }\n+            if (scheme.equalsIgnoreCase(\"http\") || scheme.equalsIgnoreCase(\"https\")) {\n","filename":"src\/java.base\/share\/classes\/java\/net\/ProxySelector.java","additions":14,"deletions":5,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -1099,1 +1099,4 @@\n-            SocketReadEvent.offer(start, nbytes, parent.getRemoteSocketAddress(), getSoTimeout());\n+            long duration = SocketReadEvent.timestamp() - start;\n+            if (SocketReadEvent.shouldCommit(duration)) {\n+                SocketReadEvent.emit(start, duration, nbytes, parent.getRemoteSocketAddress(), getSoTimeout());\n+            }\n@@ -1212,1 +1215,4 @@\n-            SocketWriteEvent.offer(start, len, parent.getRemoteSocketAddress());\n+            long duration = SocketWriteEvent.timestamp() - start;\n+            if (SocketWriteEvent.shouldCommit(duration)) {\n+                SocketWriteEvent.emit(start, duration, len, parent.getRemoteSocketAddress());\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/net\/Socket.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,2 @@\n+import static sun.net.util.IPAddressUtil.isIPv6LiteralAddress;\n+\n@@ -300,3 +302,1 @@\n-            \/\/ IPv6 literal?\n-            if (epoint.getAddress() instanceof Inet6Address &&\n-                (!host.startsWith(\"[\")) && (host.indexOf(':') >= 0)) {\n+            if (isIPv6LiteralAddress(host)) {\n@@ -304,0 +304,2 @@\n+            } else {\n+                host = ParseUtil.encodePath(host);\n@@ -306,1 +308,1 @@\n-                uri = new URI(\"socket:\/\/\" + ParseUtil.encodePath(host) + \":\"+ epoint.getPort());\n+                uri = new URI(\"socket:\/\/\" + host + \":\"+ epoint.getPort());\n@@ -308,3 +310,1 @@\n-                \/\/ This shouldn't happen\n-                assert false : e;\n-                uri = null;\n+                throw new IOException(\"Failed to select a proxy\", e);\n","filename":"src\/java.base\/share\/classes\/java\/net\/SocksSocketImpl.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -282,0 +282,3 @@\n+#if[byte]\n+ * @sealedGraph\n+#end[byte]\n","filename":"src\/java.base\/share\/classes\/java\/nio\/X-Buffer.java.template","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -544,1 +544,3 @@\n-        return StreamEncoder.forEncoder(ch, enc.reset(), minBufferCap);\n+        Objects.requireNonNull(enc, \"enc\");\n+        OutputStream out = newOutputStream(ch);\n+        return StreamEncoder.forOutputStreamWriter(out, enc.reset());\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/Channels.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1091,1 +1091,1 @@\n-     * @since   19\n+     * @since   22\n@@ -1093,1 +1093,0 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/FileChannel.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -145,1 +145,1 @@\n-        sb.append(\"Signer: \" + signerCertPath.getCertificates().get(0));\n+        sb.append(\"Signer: \").append(signerCertPath.getCertificates().get(0));\n@@ -147,1 +147,1 @@\n-            sb.append(\"timestamp: \" + timestamp);\n+            sb.append(\"timestamp: \").append(timestamp);\n@@ -163,3 +163,6 @@\n-        throws IOException, ClassNotFoundException {\n-     ois.defaultReadObject();\n-     myhash = -1;\n+            throws IOException, ClassNotFoundException {\n+        ois.defaultReadObject();\n+        if (signerCertPath == null) {\n+            throw new InvalidObjectException(\"signerCertPath is null\");\n+        }\n+        myhash = -1;\n","filename":"src\/java.base\/share\/classes\/java\/security\/CodeSigner.java","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-import java.util.*;\n+import java.util.Date;\n@@ -32,2 +32,0 @@\n-import sun.security.x509.GeneralNameInterface;\n-\n@@ -58,5 +56,0 @@\n-    protected void implSetPathToNames(X509CertSelector sel,\n-            Set<GeneralNameInterface> names) {\n-        sel.setPathToNamesInternal(names);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/security\/cert\/CertPathHelperImpl.java","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -90,4 +90,0 @@\n-    static {\n-        CertPathHelperImpl.initialize();\n-    }\n-\n@@ -1130,8 +1126,0 @@\n-    \/\/ called from CertPathHelper\n-    void setPathToNamesInternal(Set<GeneralNameInterface> names) {\n-        \/\/ set names to non-null dummy value\n-        \/\/ this breaks getPathToNames()\n-        pathToNames = Collections.<List<?>>emptySet();\n-        pathToGeneralNames = names;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/security\/cert\/X509CertSelector.java","additions":1,"deletions":13,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -190,0 +190,6 @@\n+ * <p>If a <i>Relation<\/i> symbol is to be used within a <i>Format<\/i> pattern,\n+ * it must be single quoted. For example,\n+ * {@code new ChoiceFormat(\"1# '#'1 \").format(1)} returns {@code \" #1 \"}.\n+ * Use two single quotes in a row to produce a literal single quote. For example,\n+ * {@code new ChoiceFormat(\"1# ''one'' \").format(1)} returns {@code \" 'one' \"}.\n+ *\n@@ -232,2 +238,3 @@\n-     * Patterns} section.\n-     *\n+     * Patterns} section. Unlike {@link #setChoices(double[], String[])} this\n+     * method will throw an {@code IllegalArgumentException} if the {@code\n+     * limits} are not in ascending order.\n","filename":"src\/java.base\/share\/classes\/java\/text\/ChoiceFormat.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -947,3 +947,6 @@\n-         * a {@code Calendar}, this would return\n-         * {@code Calendar.HOUR}. If there is no corresponding\n-         * {@code Calendar} constant, this will return -1.\n+         * a {@code Calendar}, this method would return {@code Calendar.HOUR}.\n+         * The return value of {@code -1} guarantees that this field does not\n+         * represent any corresponding constant in {@code Calendar}.\n+         *\n+         * @implSpec The default implementation always returns {@code -1} if it does\n+         * not represent any corresponding constant in {@code Calendar}.\n","filename":"src\/java.base\/share\/classes\/java\/text\/DateFormat.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -325,0 +325,20 @@\n+    \/**\n+     * {@return the {@code Locale} of this ListFormat}\n+     *\n+     * The {@code locale} is defined by {@link #getInstance(Locale, Type, Style)} or\n+     * {@link #getInstance(String[])}.\n+     *\/\n+    public Locale getLocale() {\n+        return locale;\n+    }\n+\n+    \/**\n+     * {@return the patterns used in this ListFormat}\n+     *\n+     * The {@code patterns} are defined by {@link #getInstance(Locale, Type, Style)} or\n+     * {@link #getInstance(String[])}.\n+     *\/\n+    public String[] getPatterns() {\n+        return Arrays.copyOf(patterns, patterns.length);\n+    }\n+\n@@ -483,5 +503,6 @@\n-     * Checks if this {@code ListFormat} is equal to another {@code ListFormat}.\n-     * The comparison is based on the {@code Locale} and formatting patterns, given or\n-     * generated with {@code Locale}, {@code Type}, and {@code Style}.\n-     * @param obj the object to check, {@code null} returns {@code false}\n-     * @return {@code true} if this is equals to the other {@code ListFormat}\n+     * Compares the specified object with this {@code ListFormat} for equality.\n+     * Returns {@code true} if the specified object is also a {@code ListFormat}, and\n+     * {@code locale} and {@code patterns}, returned from {@link #getLocale()}\n+     * and {@link #getPatterns()} respectively, are equal.\n+     * @param obj the object to be compared for equality.\n+     * @return {@code true} if the specified object is equal to this {@code ListFormat}\n","filename":"src\/java.base\/share\/classes\/java\/text\/ListFormat.java","additions":26,"deletions":5,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -489,1 +489,4 @@\n-        try {\n+        long secs = startInclusive.until(endExclusive, SECONDS);\n+        if (secs == 0) {\n+            \/\/ We don't know which Temporal is earlier, so the adjustment below would not work.\n+            \/\/ But we do know that there's no danger of until(NANOS) overflowing in that case.\n@@ -491,14 +494,0 @@\n-        } catch (DateTimeException | ArithmeticException ex) {\n-            long secs = startInclusive.until(endExclusive, SECONDS);\n-            long nanos;\n-            try {\n-                nanos = endExclusive.getLong(NANO_OF_SECOND) - startInclusive.getLong(NANO_OF_SECOND);\n-                if (secs > 0 && nanos < 0) {\n-                    secs++;\n-                } else if (secs < 0 && nanos > 0) {\n-                    secs--;\n-                }\n-            } catch (DateTimeException ex2) {\n-                nanos = 0;\n-            }\n-            return ofSeconds(secs, nanos);\n@@ -506,0 +495,14 @@\n+        long nanos;\n+        try {\n+            nanos = endExclusive.getLong(NANO_OF_SECOND) - startInclusive.getLong(NANO_OF_SECOND);\n+        } catch (DateTimeException ex2) {\n+            nanos = 0;\n+        }\n+        if (nanos < 0 && secs > 0) {\n+            \/\/ ofSeconds will subtract one even though until(SECONDS) already gave the correct\n+            \/\/ number of seconds. So compensate. Similarly for the secs < 0 case below.\n+            secs++;\n+        } else if (nanos > 0 && secs < 0) {\n+            secs--;\n+        }\n+        return ofSeconds(secs, nanos);\n","filename":"src\/java.base\/share\/classes\/java\/time\/Duration.java","additions":18,"deletions":15,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -353,1 +353,1 @@\n-            ks = new AbstractSet<K>() {\n+            ks = new AbstractSet<>() {\n@@ -355,15 +355,1 @@\n-                    return new Iterator<K>() {\n-                        private Iterator<Entry<K,V>> i = entrySet().iterator();\n-\n-                        public boolean hasNext() {\n-                            return i.hasNext();\n-                        }\n-\n-                        public K next() {\n-                            return i.next().getKey();\n-                        }\n-\n-                        public void remove() {\n-                            i.remove();\n-                        }\n-                    };\n+                    return new KeyIterator();\n@@ -412,1 +398,1 @@\n-            vals = new AbstractCollection<V>() {\n+            vals = new AbstractCollection<>() {\n@@ -414,15 +400,1 @@\n-                    return new Iterator<V>() {\n-                        private Iterator<Entry<K,V>> i = entrySet().iterator();\n-\n-                        public boolean hasNext() {\n-                            return i.hasNext();\n-                        }\n-\n-                        public V next() {\n-                            return i.next().getValue();\n-                        }\n-\n-                        public void remove() {\n-                            i.remove();\n-                        }\n-                    };\n+                    return new ValueIterator();\n@@ -927,0 +899,16 @@\n+\n+    \/\/ Iterator implementations.\n+\n+    final class KeyIterator implements Iterator<K> {\n+        private final Iterator<Entry<K,V>> i = entrySet().iterator();\n+        public boolean hasNext() { return i.hasNext(); }\n+        public void remove() { i.remove(); }\n+        public K next() { return i.next().getKey(); }\n+    }\n+\n+    final class ValueIterator implements Iterator<V> {\n+        private final Iterator<Entry<K,V>> i = entrySet().iterator();\n+        public boolean hasNext() { return i.hasNext(); }\n+        public void remove() { i.remove(); }\n+        public V next() { return i.next().getValue(); }\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/util\/AbstractMap.java","additions":20,"deletions":32,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -625,3 +625,3 @@\n-     * operations generally delegate to the appropriate method with the opposite\n-     * orientation. For example, calling {@code getFirst} on the view results in\n-     * a call to {@code getLast} on this Deque.\n+     * operations generally behave as if they delegate to the appropriate method\n+     * with the opposite orientation. For example, calling {@code getFirst} on\n+     * the view might result in a call to {@code getLast} on this Deque.\n","filename":"src\/java.base\/share\/classes\/java\/util\/Deque.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -169,3 +169,3 @@\n-         * @param a the array to be sorted\n-         * @param low the index of the first element, inclusive, to be sorted\n-         * @param high the index of the last element, exclusive, to be sorted\n+         * @param a the array to be partitioned\n+         * @param low the index of the first element, inclusive, to be partitioned\n+         * @param high the index of the last element, exclusive, to be partitioned\n@@ -181,2 +181,2 @@\n-     * @param elemType the class of the array to be sorted\n-     * @param array the array to be sorted\n+     * @param elemType the class of the array to be partitioned\n+     * @param array the array to be partitioned\n@@ -186,2 +186,2 @@\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n+     * @param low the index of the first element, inclusive, to be partitioned\n+     * @param high the index of the last element, exclusive, to be partitioned\n","filename":"src\/java.base\/share\/classes\/java\/util\/DualPivotQuicksort.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-                            String.class, String.class));\n+                            String.class));\n@@ -90,2 +90,1 @@\n-        return (long)STRING_PREPEND.invokeExact(lengthCoder, buffer, value,\n-                (String)null);\n+        return (long)STRING_PREPEND.invokeExact(lengthCoder, buffer, value);\n","filename":"src\/java.base\/share\/classes\/java\/util\/FormatItem.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.util.HexDigits;\n@@ -153,9 +154,1 @@\n-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1\n@@ -406,6 +399,3 @@\n-                out.append(prefix);\n-                toHexDigits(out, bytes[fromIndex]);\n-                if (suffix.isEmpty() && delimiter.isEmpty() && prefix.isEmpty()) {\n-                    for (int i = 1; i < length; i++) {\n-                        toHexDigits(out, bytes[fromIndex + i]);\n-                    }\n+                String s = formatOptDelimiter(bytes, fromIndex, toIndex);\n+                if (s != null) {\n+                    out.append(s);\n@@ -413,0 +403,2 @@\n+                    out.append(prefix);\n+                    toHexDigits(out, bytes[fromIndex]);\n@@ -419,0 +411,1 @@\n+                    out.append(suffix);\n@@ -420,1 +413,0 @@\n-                out.append(suffix);\n@@ -441,0 +433,1 @@\n+        char sep;\n@@ -445,0 +438,2 @@\n+\n+        boolean ucase = digitCase == Case.UPPERCASE;\n@@ -450,2 +445,4 @@\n-                rep[i * 2] = (byte)toHighHexDigit(bytes[fromIndex + i]);\n-                rep[i * 2 + 1] = (byte)toLowHexDigit(bytes[fromIndex + i]);\n+                short pair = HexDigits.digitPair(bytes[fromIndex + i], ucase);\n+                int pos = i * 2;\n+                rep[pos] = (byte)pair;\n+                rep[pos + 1] = (byte)(pair >>> 8);\n@@ -453,1 +450,1 @@\n-        } else if (delimiter.length() == 1 && delimiter.charAt(0) < 256) {\n+        } else if (delimiter.length() == 1 && (sep = delimiter.charAt(0)) < 256) {\n@@ -456,1 +453,0 @@\n-            char sep = delimiter.charAt(0);\n@@ -458,2 +454,3 @@\n-            rep[0] = (byte) toHighHexDigit(bytes[fromIndex]);\n-            rep[1] = (byte) toLowHexDigit(bytes[fromIndex]);\n+            short pair = HexDigits.digitPair(bytes[fromIndex], ucase);\n+            rep[0] = (byte)pair;\n+            rep[1] = (byte)(pair >>> 8);\n@@ -461,3 +458,5 @@\n-                rep[i * 3 - 1] = (byte) sep;\n-                rep[i * 3    ] = (byte) toHighHexDigit(bytes[fromIndex + i]);\n-                rep[i * 3 + 1] = (byte) toLowHexDigit(bytes[fromIndex + i]);\n+                int pos = i * 3;\n+                pair = HexDigits.digitPair(bytes[fromIndex + i], ucase);\n+                rep[pos - 1] = (byte) sep;\n+                rep[pos] = (byte)pair;\n+                rep[pos + 1] = (byte)(pair >>> 8);\n@@ -890,1 +889,1 @@\n-        return ((ch >>> 8) == 0 && DIGITS[ch] >= 0);\n+        return ((ch >>> 7) == 0 && DIGITS[ch] >= 0);\n@@ -908,1 +907,1 @@\n-        if ((ch >>> 8) == 0 && (value = DIGITS[ch]) >= 0) {\n+        if ((ch >>> 7) == 0 && (value = DIGITS[ch]) >= 0) {\n","filename":"src\/java.base\/share\/classes\/java\/util\/HexFormat.java","additions":26,"deletions":27,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+ * @sealedGraph\n","filename":"src\/java.base\/share\/classes\/java\/util\/IllegalFormatException.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -894,3 +894,3 @@\n-     * operations generally delegate to the appropriate method with the opposite\n-     * orientation. For example, calling {@code getFirst} on the view results in\n-     * a call to {@code getLast} on this List.\n+     * operations generally behave as if they delegate to the appropriate method\n+     * with the opposite orientation. For example, calling {@code getFirst} on\n+     * the view might result in a call to {@code getLast} on this List.\n","filename":"src\/java.base\/share\/classes\/java\/util\/List.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -324,3 +324,3 @@\n-     * operations generally delegate to the appropriate method with the opposite\n-     * orientation. For example, calling {@code firstEntry} on the view results in\n-     * a call to {@code lastEntry} on this SortedMap.\n+     * operations generally behave as if they delegate to the appropriate method\n+     * with the opposite orientation. For example, calling {@code firstEntry} on\n+     * the view might result in a call to {@code lastEntry} on this SortedMap.\n","filename":"src\/java.base\/share\/classes\/java\/util\/SortedMap.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -368,3 +368,3 @@\n-     * operations generally delegate to the appropriate method with the opposite\n-     * orientation. For example, calling {@code getFirst} on the view results in\n-     * a call to {@code getLast} on this SortedSet.\n+     * operations generally behave as if they delegate to the appropriate method\n+     * with the opposite orientation. For example, calling {@code getFirst} on the\n+     * view might result in a call to {@code getLast} on this SortedSet.\n","filename":"src\/java.base\/share\/classes\/java\/util\/SortedSet.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1062,1 +1062,1 @@\n-        Thread waiter;                     \/\/ blocked producer thread\n+        volatile Thread waiter;            \/\/ blocked producer thread\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/SubmissionPublisher.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -718,1 +718,1 @@\n-                \/\/ JDK internal attributes\n+                \/\/ JDK specific attributes\n@@ -721,0 +721,1 @@\n+                addName(names, new Name(\"Enable-Native-Access\"));\n","filename":"src\/java.base\/share\/classes\/java\/util\/jar\/Attributes.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -137,6 +137,0 @@\n-    \/**\n-     * True if there are any stateful ops in the pipeline; only valid for the\n-     * source stage.\n-     *\/\n-    private boolean sourceAnyStateful;\n-\n@@ -211,2 +205,0 @@\n-        if (opIsStateful())\n-            sourceStage.sourceAnyStateful = true;\n@@ -273,1 +265,1 @@\n-    @SuppressWarnings(\"unchecked\")\n+\n@@ -275,0 +267,1 @@\n+        \/\/ Ensures that this method is only ever called on the sourceStage\n@@ -282,1 +275,1 @@\n-        if (sourceStage.sourceSpliterator != null) {\n+        if (sourceSpliterator != null) {\n@@ -284,2 +277,2 @@\n-            Spliterator<E_OUT> s = sourceStage.sourceSpliterator;\n-            sourceStage.sourceSpliterator = null;\n+            Spliterator<E_OUT> s = (Spliterator<E_OUT>)sourceSpliterator;\n+            sourceSpliterator = null;\n@@ -288,1 +281,1 @@\n-        else if (sourceStage.sourceSupplier != null) {\n+        else if (sourceSupplier != null) {\n@@ -290,2 +283,2 @@\n-            Spliterator<E_OUT> s = (Spliterator<E_OUT>) sourceStage.sourceSupplier.get();\n-            sourceStage.sourceSupplier = null;\n+            Spliterator<E_OUT> s = (Spliterator<E_OUT>)sourceSupplier.get();\n+            sourceSupplier = null;\n@@ -320,2 +313,2 @@\n-        if (sourceStage.sourceCloseAction != null) {\n-            Runnable closeAction = sourceStage.sourceCloseAction;\n+        Runnable closeAction = sourceStage.sourceCloseAction;\n+        if (closeAction != null) {\n@@ -389,0 +382,15 @@\n+    \/**\n+     * Returns whether any of the stages of the current segment is stateful\n+     * or not.\n+     * @return {@code true} if any stage in this segment is stateful,\n+     *         {@code false} if not.\n+     *\/\n+    protected final boolean hasAnyStateful() {\n+         var result = false;\n+         for (var u = sourceStage.nextStage;\n+              u != null && !(result = u.opIsStateful()) && u != this;\n+              u = u.nextStage) {\n+         }\n+         return result;\n+     }\n+\n@@ -412,1 +420,1 @@\n-        if (isParallel() && sourceStage.sourceAnyStateful) {\n+        if (isParallel() && hasAnyStateful()) {\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/AbstractPipeline.java","additions":26,"deletions":18,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -1398,0 +1398,7 @@\n+        \/**\n+         * A class representing a key to a zip file. A key is based\n+         * on the file key if available, or the path value if the\n+         * file key is not available. The key is also based on the\n+         * file's last modified time to allow for cases where a zip\n+         * file is re-opened after it has been modified.\n+         *\/\n@@ -1412,1 +1419,3 @@\n-                return ((int)(t ^ (t >>> 32))) + file.hashCode();\n+                Object fk = attrs.fileKey();\n+                return Long.hashCode(t) +\n+                        (fk != null ? fk.hashCode() : file.hashCode());\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipFile.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -31,0 +31,3 @@\n+import java.io.IOException;\n+import java.io.InvalidObjectException;\n+import java.io.ObjectInputStream;\n@@ -63,1 +66,1 @@\n-    private final byte[] key;\n+    private byte[] key;\n@@ -254,0 +257,22 @@\n+\n+    \/**\n+     * Restores the state of this object from the stream.\n+     *\n+     * @param  stream the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n+     *\/\n+    @java.io.Serial\n+    private void readObject(ObjectInputStream stream)\n+            throws IOException, ClassNotFoundException {\n+        stream.defaultReadObject();\n+\n+        if (key == null || algorithm == null) {\n+            throw new InvalidObjectException(\"Missing argument\");\n+        }\n+\n+        this.key = key.clone();\n+        if (key.length == 0) {\n+            throw new InvalidObjectException(\"Invalid key length\");\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/spec\/SecretKeySpec.java","additions":26,"deletions":1,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,4 @@\n+import java.io.IOException;\n+import java.io.InvalidObjectException;\n+import java.io.ObjectInputStream;\n+\n@@ -51,1 +55,1 @@\n-    private final String[] choices;\n+    private String[] choices;\n@@ -75,1 +79,0 @@\n-     *\n@@ -107,0 +110,5 @@\n+        this.prompt = prompt;\n+        this.defaultChoice = defaultChoice;\n+        this.multipleSelectionsAllowed = multipleSelectionsAllowed;\n+\n+        this.choices = choices.clone();\n@@ -111,5 +119,0 @@\n-\n-        this.prompt = prompt;\n-        this.choices = choices.clone();\n-        this.defaultChoice = defaultChoice;\n-        this.multipleSelectionsAllowed = multipleSelectionsAllowed;\n@@ -199,0 +202,34 @@\n+\n+    \/**\n+     * Restores the state of this object from the stream.\n+     *\n+     * @param  stream the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n+     *\/\n+    @java.io.Serial\n+    private void readObject(ObjectInputStream stream)\n+            throws IOException, ClassNotFoundException {\n+        stream.defaultReadObject();\n+\n+        if ((prompt == null) || prompt.isEmpty() ||\n+                (choices == null) || (choices.length == 0) ||\n+                (defaultChoice < 0) || (defaultChoice >= choices.length)) {\n+            throw new InvalidObjectException(\n+                    \"Missing\/invalid prompt\/choices\");\n+        }\n+\n+        choices = choices.clone();\n+        for (int i = 0; i < choices.length; i++) {\n+            if ((choices[i] == null) || choices[i].isEmpty())\n+                throw new InvalidObjectException(\"Null\/empty choices\");\n+        }\n+\n+        if (selections != null) {\n+            selections = selections.clone();\n+            if (!multipleSelectionsAllowed && (selections.length != 1)) {\n+                throw new InvalidObjectException(\n+                        \"Multiple selections not allowed\");\n+            }\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/javax\/security\/auth\/callback\/ChoiceCallback.java","additions":45,"deletions":8,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+\n@@ -150,1 +153,1 @@\n-    private final String[] options;\n+    private String[] options;\n@@ -255,5 +258,0 @@\n-        for (int i = 0; i < options.length; i++) {\n-            if (options[i] == null || options[i].isEmpty())\n-                throw new IllegalArgumentException();\n-        }\n-\n@@ -263,1 +261,0 @@\n-        this.options = options.clone();\n@@ -265,0 +262,6 @@\n+\n+        this.options = options.clone();\n+        for (int i = 0; i < options.length; i++) {\n+            if (options[i] == null || options[i].isEmpty())\n+                throw new IllegalArgumentException();\n+        }\n@@ -375,5 +378,0 @@\n-        for (int i = 0; i < options.length; i++) {\n-            if (options[i] == null || options[i].isEmpty())\n-                throw new IllegalArgumentException();\n-        }\n-\n@@ -383,1 +381,0 @@\n-        this.options = options.clone();\n@@ -385,0 +382,6 @@\n+\n+        this.options = options.clone();\n+        for (int i = 0; i < options.length; i++) {\n+            if (options[i] == null || options[i].isEmpty())\n+                throw new IllegalArgumentException();\n+        }\n@@ -490,0 +493,16 @@\n+\n+    \/**\n+     * Restores the state of this object from the stream.\n+     *\n+     * @param  stream the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n+     *\/\n+    @java.io.Serial\n+    private void readObject(ObjectInputStream stream)\n+            throws IOException, ClassNotFoundException {\n+        stream.defaultReadObject();\n+        if (options != null) {\n+            options = options.clone();\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/javax\/security\/auth\/callback\/ConfirmationCallback.java","additions":33,"deletions":14,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import java.io.IOException;\n+import java.io.InvalidObjectException;\n+import java.io.ObjectInputStream;\n@@ -160,0 +163,23 @@\n+\n+    \/**\n+     * Restores the state of this object from the stream.\n+     *\n+     * @param  stream the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n+     *\/\n+    @java.io.Serial\n+    private void readObject(ObjectInputStream stream)\n+            throws IOException, ClassNotFoundException {\n+        stream.defaultReadObject();\n+\n+        if (prompt == null || prompt.isEmpty()) {\n+            throw new InvalidObjectException(\"Missing prompt\");\n+        }\n+\n+        if (inputPassword != null) {\n+            inputPassword = inputPassword.clone();\n+            cleanable = CleanerFactory.cleaner().register(\n+                    this, cleanerFor(inputPassword));\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/javax\/security\/auth\/callback\/PasswordCallback.java","additions":27,"deletions":1,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.lang.foreign.MemorySegment;\n@@ -276,1 +277,1 @@\n-    void ensureNativeAccess(Module m, Class<?> owner, String methodName);\n+    void ensureNativeAccess(Module m, Class<?> owner, String methodName, Class<?> currentClass);\n@@ -577,0 +578,10 @@\n+\n+    \/**\n+     * Copy the string bytes to an existing segment, avoiding intermediate copies.\n+     *\/\n+    void copyToSegmentRaw(String string, MemorySegment segment, long offset);\n+\n+    \/**\n+     * Are the string bytes compatible with the given charset?\n+     *\/\n+    boolean bytesCompatible(String string, Charset charset);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,2 @@\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -55,0 +57,2 @@\n+import jdk.internal.util.ArraysSupport;\n+\n@@ -145,0 +149,2 @@\n+        private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n+\n@@ -229,16 +235,3 @@\n-            int hash = 0;\n-            boolean foundHigh = false;\n-\n-            int px = offset;\n-            int utfend = px + rawLen;\n-            while (px < utfend) {\n-                int c = (int) rawBytes[px] & 0xff;\n-                if (c > 127) {\n-                    foundHigh = true;\n-                    break;\n-                }\n-                hash = 31 * hash + c;\n-                px++;\n-            }\n-\n-            if (!foundHigh) {\n+            int singleBytes = JLA.countPositives(rawBytes, offset, rawLen);\n+            int hash = ArraysSupport.vectorizedHashCode(rawBytes, offset, singleBytes, 0, ArraysSupport.T_BOOLEAN);\n+            if (singleBytes == rawLen) {\n@@ -251,1 +244,1 @@\n-                int chararr_count = 0;\n+                int chararr_count = singleBytes;\n@@ -253,4 +246,4 @@\n-                for (int i = offset; i < px; i++) {\n-                    int c = (int) rawBytes[i] & 0xff;\n-                    chararr[chararr_count++] = (char) c;\n-                }\n+                JLA.inflateBytesToChars(rawBytes, offset, chararr, 0, singleBytes);\n+\n+                int px = offset + singleBytes;\n+                int utfend = offset + rawLen;\n@@ -334,1 +327,1 @@\n-                              : new String(rawBytes, offset, charLen, StandardCharsets.UTF_8);\n+                              : new String(rawBytes, offset, charLen, StandardCharsets.ISO_8859_1);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractPoolEntry.java","additions":16,"deletions":23,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -116,0 +116,1 @@\n+     * @param duration the duration\n@@ -120,11 +121,8 @@\n-    public static void offer(long start, long nbytes, SocketAddress remote, long timeout) {\n-        long duration = timestamp() - start;\n-        if (shouldCommit(duration)) {\n-            boolean eof = nbytes < 0 ? true : false;\n-            nbytes = nbytes < 0 ? 0 : nbytes;\n-            if (remote instanceof InetSocketAddress isa) {\n-                commit(start, duration, isa.getHostString(), isa.getAddress().getHostAddress(), isa.getPort(), timeout, nbytes, eof);\n-            } else if (remote instanceof UnixDomainSocketAddress udsa) {\n-                String path = \"[\" + udsa.getPath().toString() + \"]\";\n-                commit(start, duration, \"Unix domain socket\", path, 0, timeout, nbytes, eof);\n-            }\n+    public static void emit(long start, long duration, long nbytes, SocketAddress remote, long timeout) {\n+        boolean eof = nbytes < 0 ? true : false;\n+        nbytes = nbytes < 0 ? 0 : nbytes;\n+        if (remote instanceof InetSocketAddress isa) {\n+            commit(start, duration, isa.getHostString(), isa.getAddress().getHostAddress(), isa.getPort(), timeout, nbytes, eof);\n+        } else if (remote instanceof UnixDomainSocketAddress udsa) {\n+            String path = \"[\" + udsa.getPath().toString() + \"]\";\n+            commit(start, duration, \"Unix domain socket\", path, 0, timeout, nbytes, eof);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/event\/SocketReadEvent.java","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -111,0 +111,1 @@\n+     * @param duration the duration\n@@ -114,10 +115,7 @@\n-    public static void offer(long start, long bytesWritten, SocketAddress remote) {\n-        long duration = timestamp() - start;\n-        if (shouldCommit(duration)) {\n-            long bytes = bytesWritten < 0 ? 0 : bytesWritten;\n-            if (remote instanceof InetSocketAddress isa) {\n-                commit(start, duration, isa.getHostString(), isa.getAddress().getHostAddress(), isa.getPort(), bytes);\n-            } else if (remote instanceof UnixDomainSocketAddress udsa) {\n-                String path = \"[\" + udsa.getPath().toString() + \"]\";\n-                commit(start, duration, \"Unix domain socket\", path, 0, bytes);\n-            }\n+    public static void emit(long start, long duration, long bytesWritten, SocketAddress remote) {\n+        long bytes = bytesWritten < 0 ? 0 : bytesWritten;\n+        if (remote instanceof InetSocketAddress isa) {\n+            commit(start, duration, isa.getHostString(), isa.getAddress().getHostAddress(), isa.getPort(), bytes);\n+        } else if (remote instanceof UnixDomainSocketAddress udsa) {\n+            String path = \"[\" + udsa.getPath().toString() + \"]\";\n+            commit(start, duration, \"Unix domain socket\", path, 0, bytes);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/event\/SocketWriteEvent.java","additions":8,"deletions":10,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import java.nio.charset.Charset;\n@@ -51,1 +52,0 @@\n-import jdk.internal.misc.Unsafe;\n@@ -57,0 +57,1 @@\n+import sun.nio.ch.DirectBuffer;\n@@ -125,0 +126,6 @@\n+    @Override\n+    public MemorySegment asSlice(long offset, MemoryLayout layout) {\n+        Objects.requireNonNull(layout);\n+        return asSlice(offset, layout.byteSize(), layout.byteAlignment());\n+    }\n+\n@@ -154,1 +161,1 @@\n-                () -> cleanup.accept(NativeMemorySegmentImpl.makeNativeSegmentUnchecked(address(), newSize)) :\n+                () -> cleanup.accept(SegmentFactories.makeNativeSegmentUnchecked(address(), newSize)) :\n@@ -156,1 +163,1 @@\n-        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(address(), newSize,\n+        return SegmentFactories.makeNativeSegmentUnchecked(address(), newSize,\n@@ -267,1 +274,1 @@\n-                long offsetToThat = this.segmentOffset(that);\n+                long offsetToThat = that.address() - this.address();\n@@ -276,6 +283,9 @@\n-    public final long segmentOffset(MemorySegment other) {\n-        AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl) Objects.requireNonNull(other);\n-        if (unsafeGetBase() == that.unsafeGetBase()) {\n-            return that.unsafeGetOffset() - this.unsafeGetOffset();\n-        }\n-        throw new UnsupportedOperationException(\"Cannot compute offset from native to heap (or vice versa).\");\n+    public MemorySegment copyFrom(MemorySegment src) {\n+        MemorySegment.copy(src, 0, this, 0, src.byteSize());\n+        return this;\n+    }\n+\n+    @Override\n+    public long mismatch(MemorySegment other) {\n+        Objects.requireNonNull(other);\n+        return MemorySegment.mismatch(this, 0, byteSize(), other, 0, other.byteSize());\n@@ -549,1 +559,1 @@\n-            bufferScope = MemorySessionImpl.heapSession(bb);\n+            bufferScope = MemorySessionImpl.createHeap(bufferRef(bb));\n@@ -552,17 +562,17 @@\n-            if (base instanceof byte[]) {\n-                return new HeapMemorySegmentImpl.OfByte(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n-            } else if (base instanceof short[]) {\n-                return new HeapMemorySegmentImpl.OfShort(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n-            } else if (base instanceof char[]) {\n-                return new HeapMemorySegmentImpl.OfChar(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n-            } else if (base instanceof int[]) {\n-                return new HeapMemorySegmentImpl.OfInt(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n-            } else if (base instanceof float[]) {\n-                return new HeapMemorySegmentImpl.OfFloat(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n-            } else if (base instanceof long[]) {\n-                return new HeapMemorySegmentImpl.OfLong(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n-            } else if (base instanceof double[]) {\n-                return new HeapMemorySegmentImpl.OfDouble(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n-            } else {\n-                throw new AssertionError(\"Cannot get here\");\n-            }\n+            return switch (base) {\n+                case byte[] __ ->\n+                        new HeapMemorySegmentImpl.OfByte(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n+                case short[] __ ->\n+                        new HeapMemorySegmentImpl.OfShort(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n+                case char[] __ ->\n+                        new HeapMemorySegmentImpl.OfChar(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n+                case int[] __ ->\n+                        new HeapMemorySegmentImpl.OfInt(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n+                case float[] __ ->\n+                        new HeapMemorySegmentImpl.OfFloat(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n+                case long[] __ ->\n+                        new HeapMemorySegmentImpl.OfLong(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n+                case double[] __ ->\n+                        new HeapMemorySegmentImpl.OfDouble(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n+                default -> throw new AssertionError(\"Cannot get here\");\n+            };\n@@ -577,15 +587,5 @@\n-    private static int getScaleFactor(Buffer buffer) {\n-        if (buffer instanceof ByteBuffer) {\n-            return 0;\n-        } else if (buffer instanceof CharBuffer) {\n-            return 1;\n-        } else if (buffer instanceof ShortBuffer) {\n-            return 1;\n-        } else if (buffer instanceof IntBuffer) {\n-            return 2;\n-        } else if (buffer instanceof FloatBuffer) {\n-            return 2;\n-        } else if (buffer instanceof LongBuffer) {\n-            return 3;\n-        } else if (buffer instanceof DoubleBuffer) {\n-            return 3;\n+    private static Object bufferRef(Buffer buffer) {\n+        if (buffer instanceof DirectBuffer directBuffer) {\n+            \/\/ direct buffer, return either the buffer attachment (for slices and views), or the buffer itself\n+            return directBuffer.attachment() != null ?\n+                    directBuffer.attachment() : directBuffer;\n@@ -593,1 +593,2 @@\n-            throw new AssertionError(\"Cannot get here\");\n+            \/\/ heap buffer, return the underlying array\n+            return NIO_ACCESS.getBufferBase(buffer);\n@@ -634,1 +635,1 @@\n-        long baseAndScale = getBaseAndScale(dstArray.getClass());\n+        var dstInfo = Utils.BaseAndScale.of(dstArray);\n@@ -638,2 +639,0 @@\n-        int dstBase = (int)baseAndScale;\n-        long dstWidth = (int)(baseAndScale >> 32); \/\/ Use long arithmetics below\n@@ -645,1 +644,1 @@\n-        srcImpl.checkAccess(srcOffset, elementCount * dstWidth, true);\n+        srcImpl.checkAccess(srcOffset, elementCount * dstInfo.scale(), true);\n@@ -647,1 +646,1 @@\n-        if (dstWidth == 1 || srcLayout.order() == ByteOrder.nativeOrder()) {\n+        if (dstInfo.scale() == 1 || srcLayout.order() == ByteOrder.nativeOrder()) {\n@@ -650,1 +649,1 @@\n-                    dstArray, dstBase + (dstIndex * dstWidth), elementCount * dstWidth);\n+                    dstArray, dstInfo.base() + (dstIndex * dstInfo.scale()), elementCount * dstInfo.scale());\n@@ -654,1 +653,1 @@\n-                    dstArray, dstBase + (dstIndex * dstWidth), elementCount * dstWidth, dstWidth);\n+                    dstArray, dstInfo.base() + (dstIndex * dstInfo.scale()), elementCount * dstInfo.scale(), dstInfo.scale());\n@@ -663,1 +662,1 @@\n-        long baseAndScale = getBaseAndScale(srcArray.getClass());\n+        var srcInfo = Utils.BaseAndScale.of(srcArray);\n@@ -667,2 +666,0 @@\n-        int srcBase = (int)baseAndScale;\n-        long srcWidth = (int)(baseAndScale >> 32); \/\/ Use long arithmetics below\n@@ -675,2 +672,2 @@\n-        destImpl.checkAccess(dstOffset, elementCount * srcWidth, false);\n-        if (srcWidth == 1 || dstLayout.order() == ByteOrder.nativeOrder()) {\n+        destImpl.checkAccess(dstOffset, elementCount * srcInfo.scale(), false);\n+        if (srcInfo.scale() == 1 || dstLayout.order() == ByteOrder.nativeOrder()) {\n@@ -678,2 +675,2 @@\n-                    srcArray, srcBase + (srcIndex * srcWidth),\n-                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffset, elementCount * srcWidth);\n+                    srcArray, srcInfo.base() + (srcIndex * srcInfo.scale()),\n+                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffset, elementCount * srcInfo.scale());\n@@ -682,2 +679,2 @@\n-                    srcArray, srcBase + (srcIndex * srcWidth),\n-                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffset, elementCount * srcWidth, srcWidth);\n+                    srcArray, srcInfo.base() + (srcIndex * srcInfo.scale()),\n+                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffset, elementCount * srcInfo.scale(), srcInfo.scale());\n@@ -725,18 +722,270 @@\n-    private static long getBaseAndScale(Class<?> arrayType) {\n-        if (arrayType.equals(byte[].class)) {\n-            return (long) Unsafe.ARRAY_BYTE_BASE_OFFSET | ((long)Unsafe.ARRAY_BYTE_INDEX_SCALE << 32);\n-        } else if (arrayType.equals(char[].class)) {\n-            return (long) Unsafe.ARRAY_CHAR_BASE_OFFSET | ((long)Unsafe.ARRAY_CHAR_INDEX_SCALE << 32);\n-        } else if (arrayType.equals(short[].class)) {\n-            return (long)Unsafe.ARRAY_SHORT_BASE_OFFSET | ((long)Unsafe.ARRAY_SHORT_INDEX_SCALE << 32);\n-        } else if (arrayType.equals(int[].class)) {\n-            return (long)Unsafe.ARRAY_INT_BASE_OFFSET | ((long) Unsafe.ARRAY_INT_INDEX_SCALE << 32);\n-        } else if (arrayType.equals(float[].class)) {\n-            return (long)Unsafe.ARRAY_FLOAT_BASE_OFFSET | ((long)Unsafe.ARRAY_FLOAT_INDEX_SCALE << 32);\n-        } else if (arrayType.equals(long[].class)) {\n-            return (long)Unsafe.ARRAY_LONG_BASE_OFFSET | ((long)Unsafe.ARRAY_LONG_INDEX_SCALE << 32);\n-        } else if (arrayType.equals(double[].class)) {\n-            return (long)Unsafe.ARRAY_DOUBLE_BASE_OFFSET | ((long)Unsafe.ARRAY_DOUBLE_INDEX_SCALE << 32);\n-        } else {\n-            throw new IllegalArgumentException(\"Not a supported array class: \" + arrayType.getSimpleName());\n-        }\n+    private static int getScaleFactor(Buffer buffer) {\n+        return switch (buffer) {\n+            case ByteBuffer   __ -> 0;\n+            case CharBuffer   __ -> 1;\n+            case ShortBuffer  __ -> 1;\n+            case IntBuffer    __ -> 2;\n+            case FloatBuffer  __ -> 2;\n+            case LongBuffer   __ -> 3;\n+            case DoubleBuffer __ -> 3;\n+        };\n+    }\n+\n+    \/\/ accessors\n+\n+    @ForceInline\n+    @Override\n+    public byte get(ValueLayout.OfByte layout, long offset) {\n+        return (byte) layout.varHandle().get(this, offset);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public void set(ValueLayout.OfByte layout, long offset, byte value) {\n+        layout.varHandle().set(this, offset, value);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public boolean get(ValueLayout.OfBoolean layout, long offset) {\n+        return (boolean) layout.varHandle().get(this, offset);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public void set(ValueLayout.OfBoolean layout, long offset, boolean value) {\n+        layout.varHandle().set(this, offset, value);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public char get(ValueLayout.OfChar layout, long offset) {\n+        return (char) layout.varHandle().get(this, offset);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public void set(ValueLayout.OfChar layout, long offset, char value) {\n+        layout.varHandle().set(this, offset, value);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public short get(ValueLayout.OfShort layout, long offset) {\n+        return (short) layout.varHandle().get(this, offset);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public void set(ValueLayout.OfShort layout, long offset, short value) {\n+        layout.varHandle().set(this, offset, value);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public int get(ValueLayout.OfInt layout, long offset) {\n+        return (int) layout.varHandle().get(this, offset);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public void set(ValueLayout.OfInt layout, long offset, int value) {\n+        layout.varHandle().set(this, offset, value);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public float get(ValueLayout.OfFloat layout, long offset) {\n+        return (float) layout.varHandle().get(this, offset);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public void set(ValueLayout.OfFloat layout, long offset, float value) {\n+        layout.varHandle().set(this, offset, value);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public long get(ValueLayout.OfLong layout, long offset) {\n+        return (long) layout.varHandle().get(this, offset);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public void set(ValueLayout.OfLong layout, long offset, long value) {\n+        layout.varHandle().set(this, offset, value);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public double get(ValueLayout.OfDouble layout, long offset) {\n+        return (double) layout.varHandle().get(this, offset);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public void set(ValueLayout.OfDouble layout, long offset, double value) {\n+        layout.varHandle().set(this, offset, value);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public MemorySegment get(AddressLayout layout, long offset) {\n+        return (MemorySegment) layout.varHandle().get(this, offset);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public void set(AddressLayout layout, long offset, MemorySegment value) {\n+        layout.varHandle().set(this, offset, value);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public byte getAtIndex(ValueLayout.OfByte layout, long index) {\n+        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n+        return (byte) layout.varHandle().get(this, index * layout.byteSize());\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public boolean getAtIndex(ValueLayout.OfBoolean layout, long index) {\n+        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n+        return (boolean) layout.varHandle().get(this, index * layout.byteSize());\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public char getAtIndex(ValueLayout.OfChar layout, long index) {\n+        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n+        return (char) layout.varHandle().get(this, index * layout.byteSize());\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public void setAtIndex(ValueLayout.OfChar layout, long index, char value) {\n+        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n+        layout.varHandle().set(this, index * layout.byteSize(), value);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public short getAtIndex(ValueLayout.OfShort layout, long index) {\n+        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n+        return (short) layout.varHandle().get(this, index * layout.byteSize());\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public void setAtIndex(ValueLayout.OfByte layout, long index, byte value) {\n+        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n+        layout.varHandle().set(this, index * layout.byteSize(), value);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public void setAtIndex(ValueLayout.OfBoolean layout, long index, boolean value) {\n+        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n+        layout.varHandle().set(this, index * layout.byteSize(), value);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public void setAtIndex(ValueLayout.OfShort layout, long index, short value) {\n+        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n+        layout.varHandle().set(this, index * layout.byteSize(), value);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public int getAtIndex(ValueLayout.OfInt layout, long index) {\n+        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n+        return (int) layout.varHandle().get(this, index * layout.byteSize());\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public void setAtIndex(ValueLayout.OfInt layout, long index, int value) {\n+        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n+        layout.varHandle().set(this, index * layout.byteSize(), value);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public float getAtIndex(ValueLayout.OfFloat layout, long index) {\n+        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n+        return (float) layout.varHandle().get(this, index * layout.byteSize());\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public void setAtIndex(ValueLayout.OfFloat layout, long index, float value) {\n+        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n+        layout.varHandle().set(this, index * layout.byteSize(), value);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public long getAtIndex(ValueLayout.OfLong layout, long index) {\n+        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n+        return (long) layout.varHandle().get(this, index * layout.byteSize());\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public void setAtIndex(ValueLayout.OfLong layout, long index, long value) {\n+        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n+        layout.varHandle().set(this, index * layout.byteSize(), value);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public double getAtIndex(ValueLayout.OfDouble layout, long index) {\n+        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n+        return (double) layout.varHandle().get(this, index * layout.byteSize());\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public void setAtIndex(ValueLayout.OfDouble layout, long index, double value) {\n+        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n+        layout.varHandle().set(this, index * layout.byteSize(), value);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public MemorySegment getAtIndex(AddressLayout layout, long index) {\n+        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n+        return (MemorySegment) layout.varHandle().get(this, index * layout.byteSize());\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public void setAtIndex(AddressLayout layout, long index, MemorySegment value) {\n+        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n+        layout.varHandle().set(this, index * layout.byteSize(), value);\n+    }\n+\n+    @Override\n+    public String getString(long offset) {\n+        return getString(offset, sun.nio.cs.UTF_8.INSTANCE);\n+    }\n+\n+    @Override\n+    public String getString(long offset, Charset charset) {\n+        Objects.requireNonNull(charset);\n+        return StringSupport.read(this, offset, charset);\n+    }\n+\n+    @Override\n+    public void setString(long offset, String str) {\n+        Objects.requireNonNull(str);\n+        setString(offset, str, sun.nio.cs.UTF_8.INSTANCE);\n+    }\n+\n+    @Override\n+    public void setString(long offset, String str, Charset charset) {\n+        Objects.requireNonNull(charset);\n+        Objects.requireNonNull(str);\n+        StringSupport.write(this, offset, charset, str);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":327,"deletions":78,"binary":false,"changes":405,"status":"modified"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.foreign;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.MemorySegment.Scope;\n+import java.util.Objects;\n+\n+public final class ArenaImpl implements Arena {\n+\n+    private final MemorySessionImpl session;\n+    private final boolean shouldReserveMemory;\n+    ArenaImpl(MemorySessionImpl session) {\n+        this.session = session;\n+        shouldReserveMemory = session instanceof ImplicitSession;\n+    }\n+\n+    @Override\n+    public Scope scope() {\n+        return session;\n+    }\n+\n+    @Override\n+    public void close() {\n+        session.close();\n+    }\n+\n+    public MemorySegment allocateNoInit(long byteSize, long byteAlignment) {\n+        Utils.checkAllocationSizeAndAlign(byteSize, byteAlignment);\n+        return SegmentFactories.allocateSegment(byteSize, byteAlignment, session, shouldReserveMemory);\n+    }\n+\n+    @Override\n+    public MemorySegment allocate(long byteSize, long byteAlignment) {\n+        MemorySegment segment = allocateNoInit(byteSize, byteAlignment);\n+        return segment.fill((byte)0);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/ArenaImpl.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -30,1 +30,0 @@\n-import java.lang.ref.Cleaner;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/ConfinedSession.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import jdk.internal.access.JavaNioAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -29,0 +31,4 @@\n+import sun.nio.ch.DirectBuffer;\n+\n+import java.nio.Buffer;\n+import java.util.Objects;\n@@ -35,3 +41,1 @@\n-final class GlobalSession extends MemorySessionImpl {\n-\n-    final Object ref;\n+non-sealed class GlobalSession extends MemorySessionImpl {\n@@ -39,1 +43,1 @@\n-    public GlobalSession(Object ref) {\n+    public GlobalSession() {\n@@ -41,1 +45,0 @@\n-        this.ref = ref;\n@@ -70,0 +73,28 @@\n+\n+    \/**\n+     * This is a global session that wraps a heap object. Possible objects are: Java arrays, buffers and\n+     * class loaders. Objects of two heap sessions are compared by identity. That is, if the wrapped object is the same,\n+     * then the resulting heap sessions are also considered equals. We do not compare the objects using\n+     * {@link Object#equals(Object)}, as that would be problematic when comparing buffers, whose equality and\n+     * hash codes are content-dependent.\n+     *\/\n+    static class HeapSession extends GlobalSession {\n+\n+        final Object ref;\n+\n+        public HeapSession(Object ref) {\n+            super();\n+            this.ref = Objects.requireNonNull(ref);\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            return obj instanceof HeapSession session &&\n+                    ref == session.ref;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return System.identityHashCode(ref);\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/GlobalSession.java","additions":36,"deletions":5,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.lang.foreign.MemorySegment;\n@@ -37,1 +36,0 @@\n-import jdk.internal.misc.Unsafe;\n@@ -44,1 +42,1 @@\n- * of {@link HeapMemorySegmentImpl} are defined (e.g. {@link OfFloat}, so that each subclass can override the\n+ * of {@link HeapMemorySegmentImpl} are defined (e.g. {@link OfFloat}), so that each subclass can override the\n@@ -51,1 +49,1 @@\n-public abstract sealed class HeapMemorySegmentImpl extends AbstractMemorySegmentImpl {\n+abstract sealed class HeapMemorySegmentImpl extends AbstractMemorySegmentImpl {\n@@ -53,2 +51,4 @@\n-    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n-    private static final int BYTE_ARR_BASE = UNSAFE.arrayBaseOffset(byte[].class);\n+    \/\/ Constants defining the maximum alignment supported by various kinds of heap arrays.\n+    \/\/ While for most arrays, the maximum alignment is constant (the size, in bytes, of the array elements),\n+    \/\/ note that the alignment of a long[]\/double[] depends on the platform: it's 4-byte on x86, but 8 bytes on x64\n+    \/\/ (as specified by the JAVA_LONG layout constant).\n@@ -56,4 +56,4 @@\n-    private static final long MAX_ALIGN_1 = ValueLayout.JAVA_BYTE.byteAlignment();\n-    private static final long MAX_ALIGN_2 = ValueLayout.JAVA_SHORT.byteAlignment();\n-    private static final long MAX_ALIGN_4 = ValueLayout.JAVA_INT.byteAlignment();\n-    private static final long MAX_ALIGN_8 = ValueLayout.JAVA_LONG.byteAlignment();\n+    private static final long MAX_ALIGN_BYTE_ARRAY = ValueLayout.JAVA_BYTE.byteAlignment();\n+    private static final long MAX_ALIGN_SHORT_ARRAY = ValueLayout.JAVA_SHORT.byteAlignment();\n+    private static final long MAX_ALIGN_INT_ARRAY = ValueLayout.JAVA_INT.byteAlignment();\n+    private static final long MAX_ALIGN_LONG_ARRAY = ValueLayout.JAVA_LONG.byteAlignment();\n@@ -92,1 +92,1 @@\n-        return nioAccess.newHeapByteBuffer(baseByte, (int)offset - BYTE_ARR_BASE, (int) byteSize(), null);\n+        return nioAccess.newHeapByteBuffer(baseByte, (int)offset - Utils.BaseAndScale.BYTE.base(), (int) byteSize(), null);\n@@ -113,7 +113,0 @@\n-        public static MemorySegment fromArray(byte[] arr) {\n-            Objects.requireNonNull(arr);\n-            long byteSize = (long)arr.length * Unsafe.ARRAY_BYTE_INDEX_SCALE;\n-            return new OfByte(Unsafe.ARRAY_BYTE_BASE_OFFSET, arr, byteSize, false,\n-                    MemorySessionImpl.heapSession(arr));\n-        }\n-\n@@ -122,1 +115,1 @@\n-            return MAX_ALIGN_1;\n+            return MAX_ALIGN_BYTE_ARRAY;\n@@ -127,1 +120,1 @@\n-            return offset - Unsafe.ARRAY_BYTE_BASE_OFFSET;\n+            return offset - Utils.BaseAndScale.BYTE.base();\n@@ -147,7 +140,0 @@\n-        public static MemorySegment fromArray(char[] arr) {\n-            Objects.requireNonNull(arr);\n-            long byteSize = (long)arr.length * Unsafe.ARRAY_CHAR_INDEX_SCALE;\n-            return new OfChar(Unsafe.ARRAY_CHAR_BASE_OFFSET, arr, byteSize, false,\n-                    MemorySessionImpl.heapSession(arr));\n-        }\n-\n@@ -156,1 +142,1 @@\n-            return MAX_ALIGN_2;\n+            return MAX_ALIGN_SHORT_ARRAY;\n@@ -161,1 +147,1 @@\n-            return offset - Unsafe.ARRAY_CHAR_BASE_OFFSET;\n+            return offset - Utils.BaseAndScale.CHAR.base();\n@@ -181,7 +167,0 @@\n-        public static MemorySegment fromArray(short[] arr) {\n-            Objects.requireNonNull(arr);\n-            long byteSize = (long)arr.length * Unsafe.ARRAY_SHORT_INDEX_SCALE;\n-            return new OfShort(Unsafe.ARRAY_SHORT_BASE_OFFSET, arr, byteSize, false,\n-                    MemorySessionImpl.heapSession(arr));\n-        }\n-\n@@ -190,1 +169,1 @@\n-            return MAX_ALIGN_2;\n+            return MAX_ALIGN_SHORT_ARRAY;\n@@ -195,1 +174,1 @@\n-            return offset - Unsafe.ARRAY_SHORT_BASE_OFFSET;\n+            return offset - Utils.BaseAndScale.SHORT.base();\n@@ -215,7 +194,0 @@\n-        public static MemorySegment fromArray(int[] arr) {\n-            Objects.requireNonNull(arr);\n-            long byteSize = (long)arr.length * Unsafe.ARRAY_INT_INDEX_SCALE;\n-            return new OfInt(Unsafe.ARRAY_INT_BASE_OFFSET, arr, byteSize, false,\n-                    MemorySessionImpl.heapSession(arr));\n-        }\n-\n@@ -224,1 +196,1 @@\n-            return MAX_ALIGN_4;\n+            return MAX_ALIGN_INT_ARRAY;\n@@ -229,1 +201,1 @@\n-            return offset - Unsafe.ARRAY_INT_BASE_OFFSET;\n+            return offset - Utils.BaseAndScale.INT.base();\n@@ -249,7 +221,0 @@\n-        public static MemorySegment fromArray(long[] arr) {\n-            Objects.requireNonNull(arr);\n-            long byteSize = (long)arr.length * Unsafe.ARRAY_LONG_INDEX_SCALE;\n-            return new OfLong(Unsafe.ARRAY_LONG_BASE_OFFSET, arr, byteSize, false,\n-                    MemorySessionImpl.heapSession(arr));\n-        }\n-\n@@ -258,1 +223,1 @@\n-            return MAX_ALIGN_8;\n+            return MAX_ALIGN_LONG_ARRAY;\n@@ -263,1 +228,1 @@\n-            return offset - Unsafe.ARRAY_LONG_BASE_OFFSET;\n+            return offset - Utils.BaseAndScale.LONG.base();\n@@ -283,7 +248,0 @@\n-        public static MemorySegment fromArray(float[] arr) {\n-            Objects.requireNonNull(arr);\n-            long byteSize = (long)arr.length * Unsafe.ARRAY_FLOAT_INDEX_SCALE;\n-            return new OfFloat(Unsafe.ARRAY_FLOAT_BASE_OFFSET, arr, byteSize, false,\n-                    MemorySessionImpl.heapSession(arr));\n-        }\n-\n@@ -292,1 +250,1 @@\n-            return MAX_ALIGN_4;\n+            return MAX_ALIGN_INT_ARRAY;\n@@ -297,1 +255,1 @@\n-            return offset - Unsafe.ARRAY_FLOAT_BASE_OFFSET;\n+            return offset - Utils.BaseAndScale.FLOAT.base();\n@@ -317,7 +275,0 @@\n-        public static MemorySegment fromArray(double[] arr) {\n-            Objects.requireNonNull(arr);\n-            long byteSize = (long)arr.length * Unsafe.ARRAY_DOUBLE_INDEX_SCALE;\n-            return new OfDouble(Unsafe.ARRAY_DOUBLE_BASE_OFFSET, arr, byteSize, false,\n-                    MemorySessionImpl.heapSession(arr));\n-        }\n-\n@@ -326,1 +277,1 @@\n-            return MAX_ALIGN_8;\n+            return MAX_ALIGN_LONG_ARRAY;\n@@ -331,1 +282,1 @@\n-            return offset - Unsafe.ARRAY_DOUBLE_BASE_OFFSET;\n+            return offset - Utils.BaseAndScale.DOUBLE.base();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/HeapMemorySegmentImpl.java","additions":25,"deletions":74,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-\n@@ -42,0 +41,1 @@\n+import java.util.List;\n@@ -44,0 +44,4 @@\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import static java.util.stream.Collectors.joining;\n@@ -46,1 +50,1 @@\n- * This class provide support for constructing layout paths; that is, starting from a root path (see {@link #rootPath(MemoryLayout)},\n+ * This class provide support for constructing layout paths; that is, starting from a root path (see {@link #rootPath(MemoryLayout)}),\n@@ -64,0 +68,1 @@\n+    private static final MethodHandle MH_ADD;\n@@ -75,1 +80,1 @@\n-                    MethodType.methodType(MemorySegment.class, MemorySegment.class, MemoryLayout.class));\n+                    MethodType.methodType(void.class, MemorySegment.class, long.class, MemoryLayout.class));\n@@ -78,0 +83,2 @@\n+            MH_ADD = lookup.findStatic(Long.class, \"sum\",\n+                    MethodType.methodType(long.class, long.class, long.class));\n@@ -87,1 +94,0 @@\n-\n@@ -103,2 +109,1 @@\n-        check(SequenceLayout.class, \"attempting to select a sequence element from a non-sequence layout\");\n-        SequenceLayout seq = (SequenceLayout)layout;\n+        SequenceLayout seq = requireSequenceLayout();\n@@ -110,2 +115,1 @@\n-        check(SequenceLayout.class, \"attempting to select a sequence element from a non-sequence layout\");\n-        SequenceLayout seq = (SequenceLayout)layout;\n+        SequenceLayout seq = requireSequenceLayout();\n@@ -120,1 +124,1 @@\n-                                     addStride(elemSize * step), addBound(maxIndex), derefAdapters, this);\n+                addStride(elemSize * step), addBound(maxIndex), derefAdapters, this);\n@@ -124,2 +128,1 @@\n-        check(SequenceLayout.class, \"attempting to select a sequence element from a non-sequence layout\");\n-        SequenceLayout seq = (SequenceLayout)layout;\n+        SequenceLayout seq = requireSequenceLayout();\n@@ -129,1 +132,1 @@\n-        return LayoutPath.nestedPath(seq.elementLayout(), offset + elemOffset, strides, bounds, derefAdapters,this);\n+        return LayoutPath.nestedPath(seq.elementLayout(), offset + elemOffset, strides, bounds, derefAdapters, this);\n@@ -133,2 +136,1 @@\n-        check(GroupLayout.class, \"attempting to select a group element from a non-group layout\");\n-        GroupLayout g = (GroupLayout)layout;\n+        GroupLayout g = requireGroupLayout();\n@@ -148,1 +150,2 @@\n-            throw badLayoutPath(\"cannot resolve '\" + name + \"' in layout \" + layout);\n+            throw badLayoutPath(\n+                    String.format(\"cannot resolve '%s' in layout %s\", name, breadcrumbs()));\n@@ -154,2 +157,1 @@\n-        check(GroupLayout.class, \"attempting to select a group element from a non-group layout\");\n-        GroupLayout g = (GroupLayout)layout;\n+        GroupLayout g = requireGroupLayout();\n@@ -161,1 +163,2 @@\n-                throw badLayoutPath(\"cannot resolve element \" + index + \" in layout \" + layout);\n+                throw badLayoutPath(\n+                        String.format(\"cannot resolve element %d in layout: %s\", index, breadcrumbs()));\n@@ -174,1 +177,2 @@\n-            throw badLayoutPath(\"Cannot dereference layout: \" + layout);\n+            throw badLayoutPath(\n+                    String.format(\"Cannot dereference layout: %s\", breadcrumbs()));\n@@ -199,1 +203,2 @@\n-            throw new IllegalArgumentException(\"Path does not select a value layout\");\n+            throw new IllegalArgumentException(\n+                    String.format(\"Path does not select a value layout: %s\", breadcrumbs()));\n@@ -205,1 +210,1 @@\n-        VarHandle handle = Utils.makeSegmentViewVarHandle(accessedLayout);\n+        VarHandle handle = accessedLayout.varHandle();\n@@ -212,2 +217,6 @@\n-            MethodHandle checkHandle = MethodHandles.insertArguments(MH_CHECK_ALIGN, 1, rootLayout());\n-            handle = MethodHandles.filterCoordinates(handle, 0, checkHandle);\n+            \/\/ insert align check for the root layout on the initial MS + offset\n+            List<Class<?>> coordinateTypes = handle.coordinateTypes();\n+            MethodHandle alignCheck = MethodHandles.insertArguments(MH_CHECK_ALIGN, 2, rootLayout());\n+            handle = MethodHandles.collectCoordinates(handle, 0, alignCheck);\n+            int[] reorder = IntStream.concat(IntStream.of(0, 1), IntStream.range(0, coordinateTypes.size())).toArray();\n+            handle = MethodHandles.permuteCoordinates(handle, coordinateTypes, reorder);\n@@ -217,0 +226,4 @@\n+            if (derefAdapters.length > 0) {\n+                \/\/ plug up the base offset if we have at least 1 enclosing dereference\n+                handle = MethodHandles.insertCoordinates(handle, 1, 0);\n+            }\n@@ -218,1 +231,7 @@\n-                handle = MethodHandles.collectCoordinates(handle, 0, derefAdapters[i - 1]);\n+                MethodHandle adapter = derefAdapters[i - 1];\n+                \/\/ the first\/outermost adapter will have a base offset coordinate, the rest are constant 0\n+                if (i > 1) {\n+                    \/\/ plug in a constant 0 base offset for all but the outermost access in a deref chain\n+                    adapter = MethodHandles.insertArguments(adapter, 1, 0);\n+                }\n+                handle = MethodHandles.collectCoordinates(handle, 0, adapter);\n@@ -231,2 +250,2 @@\n-        MethodHandle mh = MethodHandles.identity(long.class);\n-        for (int i = strides.length - 1; i >=0; i--) {\n+        MethodHandle mh = MethodHandles.insertArguments(MH_ADD, 0, offset);\n+        for (int i = strides.length - 1; i >= 0; i--) {\n@@ -238,1 +257,1 @@\n-        mh = MethodHandles.insertArguments(mh, 0, offset);\n+\n@@ -256,1 +275,1 @@\n-        sliceHandle = MethodHandles.collectArguments(sliceHandle, 1, offsetHandle()); \/\/ (MS, ...) -> MS\n+        sliceHandle = MethodHandles.collectArguments(sliceHandle, 1, offsetHandle()); \/\/ (MS, long, ...) -> MS\n@@ -259,2 +278,6 @@\n-            MethodHandle checkHandle = MethodHandles.insertArguments(MH_CHECK_ALIGN, 1, rootLayout());\n-            sliceHandle = MethodHandles.filterArguments(sliceHandle, 0, checkHandle);\n+            \/\/ insert align check for the root layout on the initial MS + offset\n+            MethodType oldType = sliceHandle.type();\n+            MethodHandle alignCheck = MethodHandles.insertArguments(MH_CHECK_ALIGN, 2, rootLayout());\n+            sliceHandle = MethodHandles.collectArguments(sliceHandle, 0, alignCheck); \/\/ (MS, long, MS, long) -> MS\n+            int[] reorder = IntStream.concat(IntStream.of(0, 1), IntStream.range(0, oldType.parameterCount())).toArray();\n+            sliceHandle = MethodHandles.permuteArguments(sliceHandle, oldType, reorder); \/\/ (MS, long, ...) -> MS\n@@ -266,3 +289,5 @@\n-    private static MemorySegment checkAlign(MemorySegment segment, MemoryLayout constraint) {\n-        if (!((AbstractMemorySegmentImpl) segment).isAlignedForElement(0, constraint)) {\n-            throw new IllegalArgumentException(\"Target offset incompatible with alignment constraints: \" + constraint.byteAlignment());\n+    private static void checkAlign(MemorySegment segment, long offset, MemoryLayout constraint) {\n+        if (!((AbstractMemorySegmentImpl) segment).isAlignedForElement(offset, constraint)) {\n+            throw new IllegalArgumentException(String.format(\n+                    \"Target offset %d is incompatible with alignment constraint %d (of %s) for segment %s\"\n+                    , offset, constraint.byteAlignment(), constraint, segment));\n@@ -270,1 +295,0 @@\n-        return segment;\n@@ -295,1 +319,9 @@\n-    private void check(Class<?> layoutClass, String msg) {\n+    private SequenceLayout requireSequenceLayout() {\n+        return requireLayoutType(SequenceLayout.class, \"sequence\");\n+    }\n+\n+    private GroupLayout requireGroupLayout() {\n+        return requireLayoutType(GroupLayout.class, \"group\");\n+    }\n+\n+    private <T extends MemoryLayout> T requireLayoutType(Class<T> layoutClass, String name) {\n@@ -297,1 +329,3 @@\n-            throw badLayoutPath(msg);\n+            throw badLayoutPath(\n+                    String.format(\"attempting to select a %s element from a non-%s layout: %s\",\n+                            name, name, breadcrumbs()));\n@@ -299,0 +333,1 @@\n+        return layoutClass.cast(layout);\n@@ -303,1 +338,2 @@\n-            throw badLayoutPath(String.format(\"Sequence index out of bound; found: %d, size: %d\", index, seq.elementCount()));\n+            throw badLayoutPath(String.format(\"sequence index out of bounds; index: %d, elementCount is %d for layout %s\",\n+                    index, seq.elementCount(), breadcrumbs()));\n@@ -323,0 +359,7 @@\n+    private String breadcrumbs() {\n+        return Stream.iterate(this, Objects::nonNull, lp -> lp.enclosing)\n+                .map(LayoutPath::layout)\n+                .map(Object::toString)\n+                .collect(joining(\", selected from: \"));\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/LayoutPath.java","additions":80,"deletions":37,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-public final class MappedMemorySegmentImpl extends NativeMemorySegmentImpl {\n+final class MappedMemorySegmentImpl extends NativeMemorySegmentImpl {\n@@ -51,2 +51,1 @@\n-        return NIO_ACCESS.newMappedByteBuffer(unmapper, min, (int)length, null,\n-                scope == MemorySessionImpl.GLOBAL ? null : this);\n+        return NIO_ACCESS.newMappedByteBuffer(unmapper, min, (int)length, null, this);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MappedMemorySegmentImpl.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+\n+import jdk.internal.foreign.GlobalSession.HeapSession;\n@@ -62,2 +64,0 @@\n-    public static final MemorySessionImpl GLOBAL = new GlobalSession(null);\n-\n@@ -66,0 +66,2 @@\n+    \/\/ This is the session of all zero-length memory segments\n+    public static final MemorySessionImpl GLOBAL_SESSION = new GlobalSession();\n@@ -80,11 +82,1 @@\n-        return new Arena() {\n-            @Override\n-            public Scope scope() {\n-                return MemorySessionImpl.this;\n-            }\n-\n-            @Override\n-            public void close() {\n-                MemorySessionImpl.this.close();\n-            }\n-        };\n+        return new ArenaImpl(this);\n@@ -94,1 +86,1 @@\n-    public static final MemorySessionImpl toMemorySession(Arena arena) {\n+    public static MemorySessionImpl toMemorySession(Arena arena) {\n@@ -110,1 +102,1 @@\n-     * Add a cleanup action. If a failure occurred (because of a add vs. close race), call the cleanup action.\n+     * Add a cleanup action. If a failure occurred (because of an add vs. close race), call the cleanup action.\n@@ -113,1 +105,1 @@\n-     * cleanup memory. From the perspective of the client, such a failure would manifest as a factory\n+     * clean up memory. From the perspective of the client, such a failure would manifest as a factory\n@@ -156,3 +148,2 @@\n-    public MemorySegment allocate(long byteSize, long byteAlignment) {\n-        Utils.checkAllocationSizeAndAlign(byteSize, byteAlignment);\n-        return NativeMemorySegmentImpl.makeNativeSegment(byteSize, byteAlignment, this);\n+    public static MemorySessionImpl createHeap(Object ref) {\n+        return new HeapSession(ref);\n@@ -213,1 +204,1 @@\n-     * a confined session and this method is called outside of the owner thread.\n+     * a confined session and this method is called outside the owner thread.\n@@ -223,1 +214,1 @@\n-    public static final void checkValidState(MemorySegment segment) {\n+    public static void checkValidState(MemorySegment segment) {\n@@ -239,1 +230,1 @@\n-     * a confined session and this method is called outside of the owner thread.\n+     * a confined session and this method is called outside the owner thread.\n@@ -248,4 +239,0 @@\n-    public static MemorySessionImpl heapSession(Object ref) {\n-        return new GlobalSession(ref);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MemorySessionImpl.java","additions":13,"deletions":26,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import jdk.internal.misc.VM;\n@@ -36,1 +35,0 @@\n-import sun.security.action.GetBooleanAction;\n@@ -42,8 +40,1 @@\n-public sealed class NativeMemorySegmentImpl extends AbstractMemorySegmentImpl permits MappedMemorySegmentImpl {\n-\n-    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n-\n-    \/\/ The maximum alignment supported by malloc - typically 16 bytes on\n-    \/\/ 64-bit platforms and 8 bytes on 32-bit platforms.\n-    private static final long MAX_MALLOC_ALIGN = Unsafe.ADDRESS_SIZE == 4 ? 8 : 16;\n-    private static final boolean SKIP_ZERO_MEMORY = GetBooleanAction.privilegedGetProperty(\"jdk.internal.foreign.skipZeroMemory\");\n+sealed class NativeMemorySegmentImpl extends AbstractMemorySegmentImpl permits MappedMemorySegmentImpl {\n@@ -63,11 +54,0 @@\n-    \/**\n-     * This constructor should only be used when initializing {@link MemorySegment#NULL}. Note: because of the memory\n-     * segment class hierarchy, it is possible to end up in a situation where this constructor is called\n-     * when the static fields in this class are not yet initialized.\n-     *\/\n-    @ForceInline\n-    public NativeMemorySegmentImpl() {\n-        super(0L, false, new GlobalSession(null));\n-        this.min = 0L;\n-    }\n-\n@@ -92,2 +72,1 @@\n-        return NIO_ACCESS.newDirectByteBuffer(min, (int) this.length, null,\n-                scope == MemorySessionImpl.GLOBAL ? null : this);\n+        return NIO_ACCESS.newDirectByteBuffer(min, (int) this.length, null, this);\n@@ -115,58 +94,0 @@\n-\n-    \/\/ factories\n-\n-    public static MemorySegment makeNativeSegment(long byteSize, long byteAlignment, MemorySessionImpl sessionImpl) {\n-        sessionImpl.checkValidState();\n-        if (VM.isDirectMemoryPageAligned()) {\n-            byteAlignment = Math.max(byteAlignment, NIO_ACCESS.pageSize());\n-        }\n-        long alignedSize = Math.max(1L, byteAlignment > MAX_MALLOC_ALIGN ?\n-                byteSize + (byteAlignment - 1) :\n-                byteSize);\n-\n-        NIO_ACCESS.reserveMemory(alignedSize, byteSize);\n-\n-        long buf = UNSAFE.allocateMemory(alignedSize);\n-        if (!SKIP_ZERO_MEMORY) {\n-            UNSAFE.setMemory(buf, alignedSize, (byte)0);\n-        }\n-        long alignedBuf = Utils.alignUp(buf, byteAlignment);\n-        AbstractMemorySegmentImpl segment = new NativeMemorySegmentImpl(buf, alignedSize,\n-                false, sessionImpl);\n-        sessionImpl.addOrCleanupIfFail(new MemorySessionImpl.ResourceList.ResourceCleanup() {\n-            @Override\n-            public void cleanup() {\n-                UNSAFE.freeMemory(buf);\n-                NIO_ACCESS.unreserveMemory(alignedSize, byteSize);\n-            }\n-        });\n-        if (alignedSize != byteSize) {\n-            long delta = alignedBuf - buf;\n-            segment = segment.asSlice(delta, byteSize);\n-        }\n-        return segment;\n-    }\n-\n-    \/\/ Unsafe native segment factories. These are used by the implementation code, to skip the sanity checks\n-    \/\/ associated with MemorySegment::ofAddress.\n-\n-    @ForceInline\n-    public static MemorySegment makeNativeSegmentUnchecked(long min, long byteSize, MemorySessionImpl sessionImpl, Runnable action) {\n-        if (action == null) {\n-            sessionImpl.checkValidState();\n-        } else {\n-            sessionImpl.addCloseAction(action);\n-        }\n-        return new NativeMemorySegmentImpl(min, byteSize, false, sessionImpl);\n-    }\n-\n-    @ForceInline\n-    public static MemorySegment makeNativeSegmentUnchecked(long min, long byteSize, MemorySessionImpl sessionImpl) {\n-        sessionImpl.checkValidState();\n-        return new NativeMemorySegmentImpl(min, byteSize, false, sessionImpl);\n-    }\n-\n-    @ForceInline\n-    public static MemorySegment makeNativeSegmentUnchecked(long min, long byteSize) {\n-        return new NativeMemorySegmentImpl(min, byteSize, false, new GlobalSession(null));\n-    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/NativeMemorySegmentImpl.java","additions":2,"deletions":81,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -0,0 +1,211 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.foreign;\n+\n+import jdk.internal.access.foreign.UnmapperProxy;\n+import jdk.internal.foreign.HeapMemorySegmentImpl.OfByte;\n+import jdk.internal.foreign.HeapMemorySegmentImpl.OfChar;\n+import jdk.internal.foreign.HeapMemorySegmentImpl.OfDouble;\n+import jdk.internal.foreign.HeapMemorySegmentImpl.OfFloat;\n+import jdk.internal.foreign.HeapMemorySegmentImpl.OfInt;\n+import jdk.internal.foreign.HeapMemorySegmentImpl.OfLong;\n+import jdk.internal.foreign.HeapMemorySegmentImpl.OfShort;\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.misc.VM;\n+import jdk.internal.vm.annotation.ForceInline;\n+\n+import java.lang.foreign.MemorySegment;\n+import java.util.Objects;\n+\n+\/**\n+ * This class is used to retrieve concrete memory segment implementations, while making sure that classes\n+ * are initialized in the right order (that is, that {@code MemorySegment} is always initialized first).\n+ * See {@link SegmentFactories#ensureInitialized()}.\n+ *\/\n+public class SegmentFactories {\n+\n+    \/\/ The maximum alignment supported by malloc - typically 16 bytes on\n+    \/\/ 64-bit platforms and 8 bytes on 32-bit platforms.\n+    private static final long MAX_MALLOC_ALIGN = Unsafe.ADDRESS_SIZE == 4 ? 8 : 16;\n+\n+    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+\n+    \/\/ Unsafe native segment factories. These are used by the implementation code, to skip the sanity checks\n+    \/\/ associated with MemorySegment::ofAddress.\n+\n+    @ForceInline\n+    public static MemorySegment makeNativeSegmentUnchecked(long min, long byteSize, MemorySessionImpl sessionImpl, Runnable action) {\n+        ensureInitialized();\n+        if (action == null) {\n+            sessionImpl.checkValidState();\n+        } else {\n+            sessionImpl.addCloseAction(action);\n+        }\n+        return new NativeMemorySegmentImpl(min, byteSize, false, sessionImpl);\n+    }\n+\n+    @ForceInline\n+    public static MemorySegment makeNativeSegmentUnchecked(long min, long byteSize, MemorySessionImpl sessionImpl) {\n+        ensureInitialized();\n+        sessionImpl.checkValidState();\n+        return new NativeMemorySegmentImpl(min, byteSize, false, sessionImpl);\n+    }\n+\n+    @ForceInline\n+    public static MemorySegment makeNativeSegmentUnchecked(long min, long byteSize) {\n+        ensureInitialized();\n+        return new NativeMemorySegmentImpl(min, byteSize, false, MemorySessionImpl.GLOBAL_SESSION);\n+    }\n+\n+    public static MemorySegment fromArray(byte[] arr) {\n+        ensureInitialized();\n+        Objects.requireNonNull(arr);\n+        long byteSize = (long)arr.length * Utils.BaseAndScale.BYTE.scale();\n+        return new OfByte(Utils.BaseAndScale.BYTE.base(), arr, byteSize, false,\n+                MemorySessionImpl.createHeap(arr));\n+    }\n+\n+    public static MemorySegment fromArray(short[] arr) {\n+        ensureInitialized();\n+        Objects.requireNonNull(arr);\n+        long byteSize = (long)arr.length * Utils.BaseAndScale.SHORT.scale();\n+        return new OfShort(Utils.BaseAndScale.SHORT.base(), arr, byteSize, false,\n+                MemorySessionImpl.createHeap(arr));\n+    }\n+\n+    public static MemorySegment fromArray(int[] arr) {\n+        ensureInitialized();\n+        Objects.requireNonNull(arr);\n+        long byteSize = (long)arr.length * Utils.BaseAndScale.INT.scale();\n+        return new OfInt(Utils.BaseAndScale.INT.base(), arr, byteSize, false,\n+                MemorySessionImpl.createHeap(arr));\n+    }\n+\n+    public static MemorySegment fromArray(char[] arr) {\n+        ensureInitialized();\n+        Objects.requireNonNull(arr);\n+        long byteSize = (long)arr.length * Utils.BaseAndScale.CHAR.scale();\n+        return new OfChar(Utils.BaseAndScale.CHAR.base(), arr, byteSize, false,\n+                MemorySessionImpl.createHeap(arr));\n+    }\n+\n+    public static MemorySegment fromArray(float[] arr) {\n+        ensureInitialized();\n+        Objects.requireNonNull(arr);\n+        long byteSize = (long)arr.length * Utils.BaseAndScale.FLOAT.scale();\n+        return new OfFloat(Utils.BaseAndScale.FLOAT.base(), arr, byteSize, false,\n+                MemorySessionImpl.createHeap(arr));\n+    }\n+\n+    public static MemorySegment fromArray(double[] arr) {\n+        ensureInitialized();\n+        Objects.requireNonNull(arr);\n+        long byteSize = (long)arr.length * Utils.BaseAndScale.DOUBLE.scale();\n+        return new OfDouble(Utils.BaseAndScale.DOUBLE.base(), arr, byteSize, false,\n+                MemorySessionImpl.createHeap(arr));\n+    }\n+\n+    public static MemorySegment fromArray(long[] arr) {\n+        ensureInitialized();\n+        Objects.requireNonNull(arr);\n+        long byteSize = (long)arr.length * Utils.BaseAndScale.LONG.scale();\n+        return new OfLong(Utils.BaseAndScale.LONG.base(), arr, byteSize, false,\n+                MemorySessionImpl.createHeap(arr));\n+    }\n+\n+    public static MemorySegment allocateSegment(long byteSize, long byteAlignment, MemorySessionImpl sessionImpl,\n+                                                  boolean shouldReserve) {\n+        ensureInitialized();\n+        sessionImpl.checkValidState();\n+        if (VM.isDirectMemoryPageAligned()) {\n+            byteAlignment = Math.max(byteAlignment, AbstractMemorySegmentImpl.NIO_ACCESS.pageSize());\n+        }\n+        long alignedSize = Math.max(1L, byteAlignment > MAX_MALLOC_ALIGN ?\n+                byteSize + (byteAlignment - 1) :\n+                byteSize);\n+\n+        if (shouldReserve) {\n+            AbstractMemorySegmentImpl.NIO_ACCESS.reserveMemory(alignedSize, byteSize);\n+        }\n+\n+        long buf = allocateMemoryWrapper(alignedSize);\n+        long alignedBuf = Utils.alignUp(buf, byteAlignment);\n+        AbstractMemorySegmentImpl segment = new NativeMemorySegmentImpl(buf, alignedSize,\n+                false, sessionImpl);\n+        sessionImpl.addOrCleanupIfFail(new MemorySessionImpl.ResourceList.ResourceCleanup() {\n+            @Override\n+            public void cleanup() {\n+                UNSAFE.freeMemory(buf);\n+                if (shouldReserve) {\n+                    AbstractMemorySegmentImpl.NIO_ACCESS.unreserveMemory(alignedSize, byteSize);\n+                }\n+            }\n+        });\n+        if (alignedSize != byteSize) {\n+            long delta = alignedBuf - buf;\n+            segment = segment.asSlice(delta, byteSize);\n+        }\n+        return segment;\n+    }\n+\n+    private static long allocateMemoryWrapper(long size) {\n+        try {\n+            return UNSAFE.allocateMemory(size);\n+        } catch (IllegalArgumentException ex) {\n+            throw new OutOfMemoryError();\n+        }\n+    }\n+\n+    public static MemorySegment mapSegment(long size, UnmapperProxy unmapper, boolean readOnly, MemorySessionImpl sessionImpl) {\n+        ensureInitialized();\n+        if (unmapper != null) {\n+            AbstractMemorySegmentImpl segment =\n+                    new MappedMemorySegmentImpl(unmapper.address(), unmapper, size,\n+                            readOnly, sessionImpl);\n+            MemorySessionImpl.ResourceList.ResourceCleanup resource =\n+                    new MemorySessionImpl.ResourceList.ResourceCleanup() {\n+                        @Override\n+                        public void cleanup() {\n+                            unmapper.unmap();\n+                        }\n+                    };\n+            sessionImpl.addOrCleanupIfFail(resource);\n+            return segment;\n+        } else {\n+            return new MappedMemorySegmentImpl(0, null, 0, readOnly, sessionImpl);\n+        }\n+    }\n+\n+    \/\/ The method below needs to be called before any concrete subclass of MemorySegment\n+    \/\/ is instantiated. This is to make sure that we cannot have an initialization deadlock\n+    \/\/ where one thread attempts to initialize e.g. MemorySegment (and then NativeMemorySegmentImpl, via\n+    \/\/ the MemorySegment.NULL field) while another thread is attempting to initialize\n+    \/\/ NativeMemorySegmentImpl (and then MemorySegment, the super-interface).\n+    @ForceInline\n+    private static void ensureInitialized() {\n+        MemorySegment segment = MemorySegment.NULL;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SegmentFactories.java","additions":211,"deletions":0,"binary":false,"changes":211,"status":"added"},{"patch":"@@ -30,1 +30,0 @@\n-import java.lang.ref.Cleaner;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SharedSession.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-    private final long maxAlign;\n@@ -40,1 +39,0 @@\n-        this.maxAlign = ((AbstractMemorySegmentImpl)segment).maxAlignMask();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SlicingAllocator.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,332 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.foreign;\n+\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.foreign.abi.SharedUtils;\n+import jdk.internal.util.ArraysSupport;\n+import sun.security.action.GetPropertyAction;\n+\n+import java.lang.foreign.MemorySegment;\n+import java.nio.charset.Charset;\n+\n+import static java.lang.foreign.ValueLayout.*;\n+\n+\/**\n+ * Miscellaneous functions to read and write strings, in various charsets.\n+ *\/\n+public final class StringSupport {\n+\n+    static final JavaLangAccess JAVA_LANG_ACCESS = SharedSecrets.getJavaLangAccess();\n+\n+    private StringSupport() {}\n+\n+    public static String read(MemorySegment segment, long offset, Charset charset) {\n+        return switch (CharsetKind.of(charset)) {\n+            case SINGLE_BYTE -> readByte(segment, offset, charset);\n+            case DOUBLE_BYTE -> readShort(segment, offset, charset);\n+            case QUAD_BYTE -> readInt(segment, offset, charset);\n+        };\n+    }\n+\n+    public static void write(MemorySegment segment, long offset, Charset charset, String string) {\n+        switch (CharsetKind.of(charset)) {\n+            case SINGLE_BYTE -> writeByte(segment, offset, charset, string);\n+            case DOUBLE_BYTE -> writeShort(segment, offset, charset, string);\n+            case QUAD_BYTE -> writeInt(segment, offset, charset, string);\n+        }\n+    }\n+\n+    private static String readByte(MemorySegment segment, long offset, Charset charset) {\n+        long len = chunkedStrlenByte(segment, offset);\n+        byte[] bytes = new byte[(int)len];\n+        MemorySegment.copy(segment, JAVA_BYTE, offset, bytes, 0, (int)len);\n+        return new String(bytes, charset);\n+    }\n+\n+    private static void writeByte(MemorySegment segment, long offset, Charset charset, String string) {\n+        int bytes = copyBytes(string, segment, charset, offset);\n+        segment.set(JAVA_BYTE, offset + bytes, (byte)0);\n+    }\n+\n+    private static String readShort(MemorySegment segment, long offset, Charset charset) {\n+        long len = chunkedStrlenShort(segment, offset);\n+        byte[] bytes = new byte[(int)len];\n+        MemorySegment.copy(segment, JAVA_BYTE, offset, bytes, 0, (int)len);\n+        return new String(bytes, charset);\n+    }\n+\n+    private static void writeShort(MemorySegment segment, long offset, Charset charset, String string) {\n+        int bytes = copyBytes(string, segment, charset, offset);\n+        segment.set(JAVA_SHORT, offset + bytes, (short)0);\n+    }\n+\n+    private static String readInt(MemorySegment segment, long offset, Charset charset) {\n+        long len = strlenInt(segment, offset);\n+        byte[] bytes = new byte[(int)len];\n+        MemorySegment.copy(segment, JAVA_BYTE, offset, bytes, 0, (int)len);\n+        return new String(bytes, charset);\n+    }\n+\n+    private static void writeInt(MemorySegment segment, long offset, Charset charset, String string) {\n+        int bytes = copyBytes(string, segment, charset, offset);\n+        segment.set(JAVA_INT, offset + bytes, 0);\n+    }\n+\n+    \/**\n+     * {@return the shortest distance beginning at the provided {@code start}\n+     *  to the encountering of a zero byte in the provided {@code segment}}\n+     * <p>\n+     * The method divides the region of interest into three distinct regions:\n+     * <ul>\n+     *     <li>head (access made on a byte-by-byte basis) (if any)<\/li>\n+     *     <li>body (access made with eight bytes at a time at physically 64-bit-aligned memory) (if any)<\/li>\n+     *     <li>tail (access made on a byte-by-byte basis) (if any)<\/li>\n+     * <\/ul>\n+     * <p>\n+     * The body is using a heuristic method to determine if a long word\n+     * contains a zero byte. The method might have false positives but\n+     * never false negatives.\n+     * <p>\n+     * This method is inspired by the `glibc\/string\/strlen.c` implementation\n+     *\n+     * @param segment to examine\n+     * @param start   from where examination shall begin\n+     * @throws IllegalArgumentException if the examined region contains no zero bytes\n+     *                                  within a length that can be accepted by a String\n+     *\/\n+    public static int chunkedStrlenByte(MemorySegment segment, long start) {\n+\n+        \/\/ Handle the first unaligned \"head\" bytes separately\n+        int headCount = (int)SharedUtils.remainsToAlignment(segment.address() + start, Long.BYTES);\n+\n+        int offset = 0;\n+        for (; offset < headCount; offset++) {\n+            byte curr = segment.get(JAVA_BYTE, start + offset);\n+            if (curr == 0) {\n+                return offset;\n+            }\n+        }\n+\n+        \/\/ We are now on a long-aligned boundary so this is the \"body\"\n+        int bodyCount = bodyCount(segment.byteSize() - start - headCount);\n+\n+        for (; offset < bodyCount; offset += Long.BYTES) {\n+            \/\/ We know we are `long` aligned so, we can save on alignment checking here\n+            long curr = segment.get(JAVA_LONG_UNALIGNED, start + offset);\n+            \/\/ Is this a candidate?\n+            if (mightContainZeroByte(curr)) {\n+                for (int j = 0; j < 8; j++) {\n+                    if (segment.get(JAVA_BYTE, start + offset + j) == 0) {\n+                        return offset + j;\n+                    }\n+                }\n+            }\n+        }\n+\n+        \/\/ Handle the \"tail\"\n+        return requireWithinArraySize((long) offset + strlenByte(segment, start + offset));\n+    }\n+\n+    \/* Bits 63 and N * 8 (N = 1..7) of this number are zero.  Call these bits\n+       the \"holes\".  Note that there is a hole just to the left of\n+       each byte, with an extra at the end:\n+\n+       bits:  01111110 11111110 11111110 11111110 11111110 11111110 11111110 11111111\n+       bytes: AAAAAAAA BBBBBBBB CCCCCCCC DDDDDDDD EEEEEEEE FFFFFFFF GGGGGGGG HHHHHHHH\n+\n+       The 1-bits make sure that carries propagate to the next 0-bit.\n+       The 0-bits provide holes for carries to fall into.\n+    *\/\n+    private static final long HIMAGIC_FOR_BYTES = 0x8080_8080_8080_8080L;\n+    private static final long LOMAGIC_FOR_BYTES = 0x0101_0101_0101_0101L;\n+\n+    static boolean mightContainZeroByte(long l) {\n+        return ((l - LOMAGIC_FOR_BYTES) & (~l) & HIMAGIC_FOR_BYTES) != 0;\n+    }\n+\n+    private static final long HIMAGIC_FOR_SHORTS = 0x8000_8000_8000_8000L;\n+    private static final long LOMAGIC_FOR_SHORTS = 0x0001_0001_0001_0001L;\n+\n+    static boolean mightContainZeroShort(long l) {\n+        return ((l - LOMAGIC_FOR_SHORTS) & (~l) & HIMAGIC_FOR_SHORTS) != 0;\n+    }\n+\n+    static int requireWithinArraySize(long size) {\n+        if (size > ArraysSupport.SOFT_MAX_ARRAY_LENGTH) {\n+            throw newIaeStringTooLarge();\n+        }\n+        return (int) size;\n+    }\n+\n+    static int bodyCount(long remaining) {\n+        return (int) Math.min(\n+                \/\/ Make sure we do not wrap around\n+                Integer.MAX_VALUE - Long.BYTES,\n+                \/\/ Remaining bytes to consider\n+                remaining)\n+                & -Long.BYTES; \/\/ Mask 0xFFFFFFF8\n+    }\n+\n+    private static int strlenByte(MemorySegment segment, long start) {\n+        for (int offset = 0; offset < ArraysSupport.SOFT_MAX_ARRAY_LENGTH; offset += 1) {\n+            byte curr = segment.get(JAVA_BYTE, start + offset);\n+            if (curr == 0) {\n+                return offset;\n+            }\n+        }\n+        throw newIaeStringTooLarge();\n+    }\n+\n+    \/**\n+     * {@return the shortest distance beginning at the provided {@code start}\n+     *  to the encountering of a zero short in the provided {@code segment}}\n+     * <p>\n+     * Note: The inspected region must be short aligned.\n+     *\n+     * @see #chunkedStrlenByte(MemorySegment, long) for more information\n+     *\n+     * @param segment to examine\n+     * @param start   from where examination shall begin\n+     * @throws IllegalArgumentException if the examined region contains no zero shorts\n+     *                                  within a length that can be accepted by a String\n+     *\/\n+    public static int chunkedStrlenShort(MemorySegment segment, long start) {\n+\n+        \/\/ Handle the first unaligned \"head\" bytes separately\n+        int headCount = (int)SharedUtils.remainsToAlignment(segment.address() + start, Long.BYTES);\n+\n+        int offset = 0;\n+        for (; offset < headCount; offset += Short.BYTES) {\n+            short curr = segment.get(JAVA_SHORT, start + offset);\n+            if (curr == 0) {\n+                return offset;\n+            }\n+        }\n+\n+        \/\/ We are now on a long-aligned boundary so this is the \"body\"\n+        int bodyCount = bodyCount(segment.byteSize() - start - headCount);\n+\n+        for (; offset < bodyCount; offset += Long.BYTES) {\n+            \/\/ We know we are `long` aligned so, we can save on alignment checking here\n+            long curr = segment.get(JAVA_LONG_UNALIGNED, start + offset);\n+            \/\/ Is this a candidate?\n+            if (mightContainZeroShort(curr)) {\n+                for (int j = 0; j < Long.BYTES; j += Short.BYTES) {\n+                    if (segment.get(JAVA_SHORT_UNALIGNED, start + offset + j) == 0) {\n+                        return offset + j;\n+                    }\n+                }\n+            }\n+        }\n+\n+        \/\/ Handle the \"tail\"\n+        return requireWithinArraySize((long) offset + strlenShort(segment, start + offset));\n+    }\n+\n+    private static int strlenShort(MemorySegment segment, long start) {\n+        for (int offset = 0; offset < ArraysSupport.SOFT_MAX_ARRAY_LENGTH; offset += Short.BYTES) {\n+            short curr = segment.get(JAVA_SHORT_UNALIGNED, start + offset);\n+            if (curr == (short)0) {\n+                return offset;\n+            }\n+        }\n+        throw newIaeStringTooLarge();\n+    }\n+\n+    \/\/ The gain of using `long` wide operations for `int` is lower than for the two other `byte` and `short` variants\n+    \/\/ so, there is only one method for ints.\n+    public static int strlenInt(MemorySegment segment, long start) {\n+        for (int offset = 0; offset < ArraysSupport.SOFT_MAX_ARRAY_LENGTH; offset += Integer.BYTES) {\n+            \/\/ We are guaranteed to be aligned here so, we can use unaligned access.\n+            int curr = segment.get(JAVA_INT_UNALIGNED, start + offset);\n+            if (curr == 0) {\n+                return offset;\n+            }\n+        }\n+        throw newIaeStringTooLarge();\n+    }\n+\n+    public enum CharsetKind {\n+        SINGLE_BYTE(1),\n+        DOUBLE_BYTE(2),\n+        QUAD_BYTE(4);\n+\n+        final int terminatorCharSize;\n+\n+        CharsetKind(int terminatorCharSize) {\n+            this.terminatorCharSize = terminatorCharSize;\n+        }\n+\n+        public int terminatorCharSize() {\n+            return terminatorCharSize;\n+        }\n+\n+        public static CharsetKind of(Charset charset) {\n+            \/\/ Comparing the charset to specific internal implementations avoids loading the class `StandardCharsets`\n+            if        (charset == sun.nio.cs.UTF_8.INSTANCE ||\n+                       charset == sun.nio.cs.ISO_8859_1.INSTANCE ||\n+                       charset == sun.nio.cs.US_ASCII.INSTANCE) {\n+                return SINGLE_BYTE;\n+            } else if (charset instanceof sun.nio.cs.UTF_16LE ||\n+                       charset instanceof sun.nio.cs.UTF_16BE ||\n+                       charset instanceof sun.nio.cs.UTF_16) {\n+                return DOUBLE_BYTE;\n+            } else if (charset instanceof sun.nio.cs.UTF_32LE ||\n+                       charset instanceof sun.nio.cs.UTF_32BE ||\n+                       charset instanceof sun.nio.cs.UTF_32) {\n+                return QUAD_BYTE;\n+            } else {\n+                throw new IllegalArgumentException(\"Unsupported charset: \" + charset);\n+            }\n+        }\n+    }\n+\n+    public static boolean bytesCompatible(String string, Charset charset) {\n+        return JAVA_LANG_ACCESS.bytesCompatible(string, charset);\n+    }\n+\n+    public static int copyBytes(String string, MemorySegment segment, Charset charset, long offset) {\n+        if (bytesCompatible(string, charset)) {\n+            copyToSegmentRaw(string, segment, offset);\n+            return string.length();\n+        } else {\n+            byte[] bytes = string.getBytes(charset);\n+            MemorySegment.copy(bytes, 0, segment, JAVA_BYTE, offset, bytes.length);\n+            return bytes.length;\n+        }\n+    }\n+\n+    public static void copyToSegmentRaw(String string, MemorySegment segment, long offset) {\n+        JAVA_LANG_ACCESS.copyToSegmentRaw(string, segment, offset);\n+    }\n+\n+    private static IllegalArgumentException newIaeStringTooLarge() {\n+        return new IllegalArgumentException(\"String too large\");\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/StringSupport.java","additions":332,"deletions":0,"binary":false,"changes":332,"status":"added"},{"patch":"@@ -78,1 +78,1 @@\n-        String systemRoot = AccessController.doPrivileged(new PrivilegedAction<String>() {\n+        String systemRoot = AccessController.doPrivileged(new PrivilegedAction<>() {\n@@ -89,1 +89,1 @@\n-        boolean useUCRT = AccessController.doPrivileged(new PrivilegedAction<Boolean>() {\n+        boolean useUCRT = AccessController.doPrivileged(new PrivilegedAction<>() {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SystemLookup.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import java.lang.foreign.SegmentAllocator;\n@@ -47,0 +46,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -50,1 +50,0 @@\n-import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n@@ -101,0 +100,11 @@\n+\n+            static VarHandle get(ValueLayout layout) {\n+                return HANDLE_MAP.get(layout);\n+            }\n+        }\n+        layout = layout.withoutName(); \/\/ name doesn't matter\n+        \/\/ keep the addressee layout as it's used below\n+\n+        VarHandle handle = VarHandleCache.get(layout);\n+        if (handle != null) {\n+            return handle;\n@@ -102,0 +112,1 @@\n+\n@@ -113,1 +124,1 @@\n-        VarHandle handle = SharedSecrets.getJavaLangInvokeAccess().memorySegmentViewHandle(baseCarrier,\n+        handle = SharedSecrets.getJavaLangInvokeAccess().memorySegmentViewHandle(baseCarrier,\n@@ -139,1 +150,1 @@\n-            throw new IllegalArgumentException(\"Invalid alignment constraint for address: \" + addr);\n+            throw new IllegalArgumentException(\"Invalid alignment constraint for address: \" + toHexString(addr));\n@@ -141,1 +152,1 @@\n-        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(addr, size);\n+        return SegmentFactories.makeNativeSegmentUnchecked(addr, size);\n@@ -147,1 +158,1 @@\n-            throw new IllegalArgumentException(\"Invalid alignment constraint for address: \" + addr);\n+            throw new IllegalArgumentException(\"Invalid alignment constraint for address: \" + toHexString(addr));\n@@ -149,13 +160,1 @@\n-        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(addr, size, scope);\n-    }\n-\n-    public static void copy(MemorySegment addr, byte[] bytes) {\n-        var heapSegment = MemorySegment.ofArray(bytes);\n-        addr.copyFrom(heapSegment);\n-        addr.set(JAVA_BYTE, bytes.length, (byte)0);\n-    }\n-\n-    public static MemorySegment toCString(byte[] bytes, SegmentAllocator allocator) {\n-        MemorySegment addr = allocator.allocate(bytes.length + 1);\n-        copy(addr, bytes);\n-        return addr;\n+        return SegmentFactories.makeNativeSegmentUnchecked(addr, size, scope);\n@@ -281,0 +280,32 @@\n+    public record BaseAndScale(int base, long scale) {\n+\n+        public static final BaseAndScale BYTE =\n+                new BaseAndScale(Unsafe.ARRAY_BYTE_BASE_OFFSET, Unsafe.ARRAY_BYTE_INDEX_SCALE);\n+        public static final BaseAndScale CHAR =\n+                new BaseAndScale(Unsafe.ARRAY_CHAR_BASE_OFFSET, Unsafe.ARRAY_CHAR_INDEX_SCALE);\n+        public static final BaseAndScale SHORT =\n+                new BaseAndScale(Unsafe.ARRAY_SHORT_BASE_OFFSET, Unsafe.ARRAY_SHORT_INDEX_SCALE);\n+        public static final BaseAndScale INT =\n+                new BaseAndScale(Unsafe.ARRAY_INT_BASE_OFFSET, Unsafe.ARRAY_INT_INDEX_SCALE);\n+        public static final BaseAndScale FLOAT =\n+                new BaseAndScale(Unsafe.ARRAY_FLOAT_BASE_OFFSET, Unsafe.ARRAY_FLOAT_INDEX_SCALE);\n+        public static final BaseAndScale LONG =\n+                new BaseAndScale(Unsafe.ARRAY_LONG_BASE_OFFSET, Unsafe.ARRAY_LONG_INDEX_SCALE);\n+        public static final BaseAndScale DOUBLE =\n+                new BaseAndScale(Unsafe.ARRAY_DOUBLE_BASE_OFFSET, Unsafe.ARRAY_DOUBLE_INDEX_SCALE);\n+\n+        public static BaseAndScale of(Object array) {\n+            return switch (array) {\n+                case byte[]   __ -> BaseAndScale.BYTE;\n+                case char[]   __ -> BaseAndScale.CHAR;\n+                case short[]  __ -> BaseAndScale.SHORT;\n+                case int[]    __ -> BaseAndScale.INT;\n+                case float[]  __ -> BaseAndScale.FLOAT;\n+                case long[]   __ -> BaseAndScale.LONG;\n+                case double[] __ -> BaseAndScale.DOUBLE;\n+                default -> throw new IllegalArgumentException(\"Not a supported array class: \" + array.getClass().getSimpleName());\n+            };\n+        }\n+\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/Utils.java","additions":50,"deletions":19,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+import java.util.HashSet;\n@@ -76,0 +77,1 @@\n+    private final Set<MemoryLayout> CANONICAL_LAYOUTS_CACHE = new HashSet<>(canonicalLayouts().values());\n@@ -92,1 +94,1 @@\n-    private final MethodHandle downcallHandle0(FunctionDescriptor function, Option... options) {\n+    private MethodHandle downcallHandle0(FunctionDescriptor function, Option... options) {\n@@ -216,1 +218,1 @@\n-    private static void checkGroupSize(GroupLayout gl, long maxUnpaddedOffset) {\n+    private void checkGroupSize(GroupLayout gl, long maxUnpaddedOffset) {\n@@ -226,1 +228,1 @@\n-    private static void checkMemberOffset(StructLayout parent, MemoryLayout memberLayout,\n+    private void checkMemberOffset(StructLayout parent, MemoryLayout memberLayout,\n@@ -235,1 +237,1 @@\n-    private static void checkSupported(ValueLayout valueLayout) {\n+    private void checkSupported(ValueLayout valueLayout) {\n@@ -240,1 +242,1 @@\n-        if (!SUPPORTED_LAYOUTS.contains(valueLayout.withoutName())) {\n+        if (!CANONICAL_LAYOUTS_CACHE.contains(valueLayout.withoutName())) {\n@@ -245,1 +247,1 @@\n-    private static void checkHasNaturalAlignment(MemoryLayout layout) {\n+    private void checkHasNaturalAlignment(MemoryLayout layout) {\n@@ -276,12 +278,0 @@\n-\n-    private static final Set<MemoryLayout> SUPPORTED_LAYOUTS = Set.of(\n-            ValueLayout.JAVA_BOOLEAN,\n-            ValueLayout.JAVA_BYTE,\n-            ValueLayout.JAVA_CHAR,\n-            ValueLayout.JAVA_SHORT,\n-            ValueLayout.JAVA_INT,\n-            ValueLayout.JAVA_FLOAT,\n-            ValueLayout.JAVA_LONG,\n-            ValueLayout.JAVA_DOUBLE,\n-            ValueLayout.ADDRESS\n-    );\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/AbstractLinker.java","additions":8,"deletions":18,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import java.nio.ByteOrder;\n@@ -60,1 +59,1 @@\n- * ABI-specific). Note that each argument has it's own recipe, which is indicated by '[number]:' (though, the only\n+ * ABI-specific). Note that each argument has its own recipe, which is indicated by '[number]:' (though, the only\n@@ -467,1 +466,1 @@\n-            storeFunc.store(storage(), type(), stack.pop());\n+            storeFunc.store(storage(), stack.pop());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/Binding.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -52,2 +52,2 @@\n-    interface StoreFunc {\n-        void store(VMStorage storage, Class<?> type, Object o);\n+    public interface StoreFunc {\n+        void store(VMStorage storage, Object o);\n@@ -57,1 +57,1 @@\n-    interface LoadFunc {\n+    public interface LoadFunc {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/BindingInterpreter.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -195,1 +195,1 @@\n-        return !linkerOptions.isTrivial();\n+        return !linkerOptions.isCritical();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/CallingSequence.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-import static sun.security.action.GetPropertyAction.privilegedGetProperty;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/CapturableState.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.lang.foreign.AddressLayout;\n@@ -37,0 +38,1 @@\n+import java.util.ArrayList;\n@@ -38,0 +40,1 @@\n+import java.util.List;\n@@ -41,0 +44,3 @@\n+import jdk.internal.foreign.AbstractMemorySegmentImpl;\n+import jdk.internal.foreign.MemorySessionImpl;\n+\n@@ -96,1 +102,0 @@\n-            Map<VMStorage, Integer> retIndexMap = SharedUtils.indexMap(retMoves);\n@@ -98,1 +103,1 @@\n-            InvocationData invData = new InvocationData(handle, argIndexMap, retIndexMap);\n+            InvocationData invData = new InvocationData(handle, callingSequence, argIndexMap);\n@@ -149,1 +154,1 @@\n-    private record InvocationData(MethodHandle leaf, Map<VMStorage, Integer> argIndexMap, Map<VMStorage, Integer> retIndexMap) {}\n+    private record InvocationData(MethodHandle leaf, CallingSequence callingSequence, Map<VMStorage, Integer> argIndexMap) {}\n@@ -155,0 +160,1 @@\n+        List<MemorySessionImpl> acquiredScopes = new ArrayList<>();\n@@ -159,1 +165,0 @@\n-            Object[] leafArgs = new Object[invData.leaf.type().parameterCount()];\n@@ -168,0 +173,2 @@\n+\n+            Object[] leafArgs = new Object[invData.leaf.type().parameterCount()];\n@@ -170,0 +177,9 @@\n+                if (callingSequence.functionDesc().argumentLayouts().get(i) instanceof AddressLayout) {\n+                    MemorySessionImpl sessionImpl = ((AbstractMemorySegmentImpl) arg).sessionImpl();\n+                    if (!(callingSequence.needsReturnBuffer() && i == 0)) { \/\/ don't acquire unboxArena's scope\n+                        sessionImpl.acquire0();\n+                        \/\/ add this scope _after_ we acquire, so we only release scopes we actually acquired\n+                        \/\/ in case an exception occurs\n+                        acquiredScopes.add(sessionImpl);\n+                    }\n+                }\n@@ -171,1 +187,1 @@\n-                        (storage, type, value) -> leafArgs[invData.argIndexMap.get(storage)] = value, unboxArena);\n+                    (storage, value) -> leafArgs[invData.argIndexMap.get(storage)] = value, unboxArena);\n@@ -197,0 +213,4 @@\n+        } finally {\n+            for (MemorySessionImpl sessionImpl : acquiredScopes) {\n+                sessionImpl.release0();\n+            }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/DowncallLinker.java","additions":25,"deletions":5,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -66,1 +66,5 @@\n-        return new LinkerOptions(optionMap);\n+        LinkerOptions linkerOptions = new LinkerOptions(optionMap);\n+        if (linkerOptions.hasCapturedCallState() && linkerOptions.isCritical()) {\n+            throw new IllegalArgumentException(\"Incompatible linker options: captureCallState, critical\");\n+        }\n+        return linkerOptions;\n@@ -100,3 +104,3 @@\n-    public boolean isTrivial() {\n-        IsTrivial it = getOption(IsTrivial.class);\n-        return it != null;\n+    public boolean isCritical() {\n+        Critical c = getOption(Critical.class);\n+        return c != null;\n@@ -118,1 +122,1 @@\n-            permits CaptureCallState, FirstVariadicArg, IsTrivial {\n+            permits CaptureCallState, FirstVariadicArg, Critical {\n@@ -144,2 +148,2 @@\n-    public record IsTrivial() implements LinkerOptionImpl {\n-        public static IsTrivial INSTANCE = new IsTrivial();\n+    public record Critical() implements LinkerOptionImpl {\n+        public static Critical INSTANCE = new Critical();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/LinkerOptions.java","additions":11,"deletions":7,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -57,1 +57,0 @@\n-import java.lang.invoke.VarHandle;\n@@ -60,1 +59,0 @@\n-import java.nio.charset.StandardCharsets;\n@@ -86,1 +84,1 @@\n-            .withTargetLayout(MemoryLayout.sequenceLayout(JAVA_BYTE));\n+            .withTargetLayout(MemoryLayout.sequenceLayout(Long.MAX_VALUE, JAVA_BYTE));\n@@ -95,1 +93,1 @@\n-        public MemorySegment allocate(long byteSize) {\n+        public MemorySegment allocate(long byteSize, long byteAlignment) {\n@@ -132,0 +130,4 @@\n+    public static long remainsToAlignment(long addr, long alignment) {\n+        return alignUp(addr, alignment) - addr;\n+    }\n+\n@@ -179,1 +181,1 @@\n-            \/\/ adjust return type so it matches the inferred type of the effective\n+            \/\/ adjust return type so that it matches the inferred type of the effective\n@@ -254,18 +256,0 @@\n-    public static String toJavaStringInternal(MemorySegment segment, long start) {\n-        int len = strlen(segment, start);\n-        byte[] bytes = new byte[len];\n-        MemorySegment.copy(segment, JAVA_BYTE, start, bytes, 0, len);\n-        return new String(bytes, StandardCharsets.UTF_8);\n-    }\n-\n-    private static int strlen(MemorySegment segment, long start) {\n-        \/\/ iterate until overflow (String can only hold a byte[], whose length can be expressed as an int)\n-        for (int offset = 0; offset >= 0; offset++) {\n-            byte curr = segment.get(JAVA_BYTE, start + offset);\n-            if (curr == 0) {\n-                return offset;\n-            }\n-        }\n-        throw new IllegalArgumentException(\"String too large\");\n-    }\n-\n@@ -437,14 +421,0 @@\n-    public static final class SimpleVaArg {\n-        public final MemoryLayout layout;\n-        public final Object value;\n-\n-        public SimpleVaArg(MemoryLayout layout, Object value) {\n-            this.layout = layout;\n-            this.value = value;\n-        }\n-\n-        public VarHandle varHandle() {\n-            return layout.varHandle();\n-        }\n-    }\n-\n@@ -518,0 +488,31 @@\n+\n+    public static Map<String, MemoryLayout> canonicalLayouts(ValueLayout longLayout, ValueLayout sizetLayout, ValueLayout wchartLayout) {\n+        return Map.ofEntries(\n+                \/\/ specified canonical layouts\n+                Map.entry(\"bool\", ValueLayout.JAVA_BOOLEAN),\n+                Map.entry(\"char\", ValueLayout.JAVA_BYTE),\n+                Map.entry(\"short\", ValueLayout.JAVA_SHORT),\n+                Map.entry(\"int\", ValueLayout.JAVA_INT),\n+                Map.entry(\"float\", ValueLayout.JAVA_FLOAT),\n+                Map.entry(\"long\", longLayout),\n+                Map.entry(\"long long\", ValueLayout.JAVA_LONG),\n+                Map.entry(\"double\", ValueLayout.JAVA_DOUBLE),\n+                Map.entry(\"void*\", ValueLayout.ADDRESS),\n+                Map.entry(\"size_t\", sizetLayout),\n+                Map.entry(\"wchar_t\", wchartLayout),\n+                \/\/ unspecified size-dependent layouts\n+                Map.entry(\"int8_t\", ValueLayout.JAVA_BYTE),\n+                Map.entry(\"int16_t\", ValueLayout.JAVA_SHORT),\n+                Map.entry(\"int32_t\", ValueLayout.JAVA_INT),\n+                Map.entry(\"int64_t\", ValueLayout.JAVA_LONG),\n+                \/\/ unspecified JNI layouts\n+                Map.entry(\"jboolean\", ValueLayout.JAVA_BOOLEAN),\n+                Map.entry(\"jchar\", ValueLayout.JAVA_CHAR),\n+                Map.entry(\"jbyte\", ValueLayout.JAVA_BYTE),\n+                Map.entry(\"jshort\", ValueLayout.JAVA_SHORT),\n+                Map.entry(\"jint\", ValueLayout.JAVA_INT),\n+                Map.entry(\"jlong\", ValueLayout.JAVA_LONG),\n+                Map.entry(\"jfloat\", ValueLayout.JAVA_FLOAT),\n+                Map.entry(\"jdouble\", ValueLayout.JAVA_DOUBLE)\n+        );\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":38,"deletions":37,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-class SoftReferenceCache<K, V> {\n+final class SoftReferenceCache<K, V> {\n@@ -44,4 +44,1 @@\n-        public Node() {\n-        }\n-\n-        public V get(K key, Function<K, V> valueFactory) {\n+        V get(K key, Function<K, V> valueFactory) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SoftReferenceCache.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -180,1 +180,1 @@\n-                        (storage, type, value) -> returnValues[invData.retIndexMap.get(storage)] = value, null);\n+                        (storage, value) -> returnValues[invData.retIndexMap.get(storage)] = value, null);\n@@ -190,6 +190,1 @@\n-                Binding.VMStore[] retMoves = invData.callingSequence.returnBindings().stream()\n-                        .filter(Binding.VMStore.class::isInstance)\n-                        .map(Binding.VMStore.class::cast)\n-                        .toArray(Binding.VMStore[]::new);\n-\n-                assert returnValues.length == retMoves.length;\n+                assert returnValues.length == invData.retMoves().length;\n@@ -197,2 +192,2 @@\n-                for (int i = 0; i < retMoves.length; i++) {\n-                    Binding.VMStore store = retMoves[i];\n+                for (int i = 0; i < invData.retMoves().length; i++) {\n+                    Binding.VMStore store = invData.retMoves()[i];\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/UpcallLinker.java","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import jdk.internal.foreign.Utils;\n@@ -39,1 +40,1 @@\n-            throw new IllegalStateException(\"Not a stub address: \" + stubAddress);\n+            throw new IllegalStateException(\"Not a stub address: \" + Utils.toHexString(stubAddress));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/UpcallStubs.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-import jdk.internal.foreign.abi.UpcallLinker;\n@@ -249,2 +248,2 @@\n-        MacOs, non-VA   | FW in regs       | FW on the stack                 | FW on the stack\n-        MacOs, VA       | FW in regs       | CW on the stack                 | CW on the stack\n+        macOS, non-VA   | FW in regs       | FW on the stack                 | FW on the stack\n+        macOS, VA       | FW in regs       | CW on the stack                 | CW on the stack\n@@ -260,1 +259,1 @@\n-        MacOs           | CW in regs       | CW on the stack                 | CW on the stack\n+        macOS           | CW in regs       | CW on the stack                 | CW on the stack\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/CallArranger.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.foreign.abi.SharedUtils;\n@@ -33,0 +34,2 @@\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.ValueLayout;\n@@ -36,0 +39,1 @@\n+import java.util.Map;\n@@ -43,0 +47,3 @@\n+    static final Map<String, MemoryLayout> CANONICAL_LAYOUTS =\n+            SharedUtils.canonicalLayouts(ValueLayout.JAVA_LONG, ValueLayout.JAVA_LONG, ValueLayout.JAVA_INT);\n+\n@@ -69,0 +76,5 @@\n+\n+    @Override\n+    public Map<String, MemoryLayout> canonicalLayouts() {\n+        return CANONICAL_LAYOUTS;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64Linker.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.foreign.abi.SharedUtils;\n@@ -33,0 +34,2 @@\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.ValueLayout;\n@@ -36,0 +39,1 @@\n+import java.util.Map;\n@@ -38,1 +42,1 @@\n- * ABI implementation for macOS on Apple silicon. Based on AAPCS with\n+ * ABI implementation for macOS on Apple Silicon. Based on AAPCS with\n@@ -43,0 +47,3 @@\n+    static final Map<String, MemoryLayout> CANONICAL_LAYOUTS =\n+            SharedUtils.canonicalLayouts(ValueLayout.JAVA_LONG, ValueLayout.JAVA_LONG, ValueLayout.JAVA_INT);\n+\n@@ -69,0 +76,5 @@\n+\n+    @Override\n+    public Map<String, MemoryLayout> canonicalLayouts() {\n+        return CANONICAL_LAYOUTS;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64Linker.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-    \/\/ r2-7 and v4-7 so they are omitted here.\n+    \/\/ r2-7 and v4-7 so, they are omitted here.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/windows\/WindowsAArch64CallArranger.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import jdk.internal.foreign.abi.SharedUtils;\n@@ -34,0 +35,2 @@\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.ValueLayout;\n@@ -37,0 +40,1 @@\n+import java.util.Map;\n@@ -43,1 +47,3 @@\n-    private static WindowsAArch64Linker instance;\n+\n+    static final Map<String, MemoryLayout> CANONICAL_LAYOUTS =\n+            SharedUtils.canonicalLayouts(ValueLayout.JAVA_INT, ValueLayout.JAVA_LONG, ValueLayout.JAVA_CHAR);\n@@ -46,2 +52,2 @@\n-        if (instance == null) {\n-            instance = new WindowsAArch64Linker();\n+        class Holder {\n+            private static final WindowsAArch64Linker INSTANCE =  new WindowsAArch64Linker();\n@@ -49,1 +55,1 @@\n-        return instance;\n+        return Holder.INSTANCE;\n@@ -66,0 +72,5 @@\n+\n+    @Override\n+    public Map<String, MemoryLayout> canonicalLayouts() {\n+        return CANONICAL_LAYOUTS;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/windows\/WindowsAArch64Linker.java","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-import java.util.Comparator;\n@@ -47,0 +46,1 @@\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n@@ -61,5 +61,2 @@\n-    private static final ValueLayout SIZE_T = switch ((int) ADDRESS.byteSize()) {\n-            case 8 -> JAVA_LONG;\n-            case 4 -> JAVA_INT;\n-            default -> throw new IllegalStateException(\"Address size not supported: \" + ADDRESS.byteSize());\n-        };\n+\n+    static final ValueLayout SIZE_T = layoutFor((int)ADDRESS.byteSize());\n@@ -72,1 +69,1 @@\n-    private static final VarHandle VH_SIZE_T_ARRAY = SIZE_T.arrayElementVarHandle();\n+    private static final VarHandle VH_SIZE_T = SIZE_T.varHandle();\n@@ -86,2 +83,2 @@\n-        VH_TYPE.set(ffiType, LibFallback.structTag());\n-        VH_ELEMENTS.set(ffiType, elementsSeg);\n+        VH_TYPE.set(ffiType, 0L, LibFallback.structTag());\n+        VH_ELEMENTS.set(ffiType, 0L, elementsSeg);\n@@ -135,1 +132,1 @@\n-                    long ffiOffset = (long) VH_SIZE_T_ARRAY.get(offsetsOut, offsetIdx++);\n+                    long ffiOffset = sizeTAtIndex(offsetsOut, offsetIdx++);\n@@ -146,0 +143,19 @@\n+\n+    static ValueLayout layoutFor(int byteSize) {\n+        return switch (byteSize) {\n+            case 1 -> JAVA_BYTE;\n+            case 2 -> JAVA_SHORT;\n+            case 4 -> JAVA_INT;\n+            case 8 -> JAVA_LONG;\n+            default -> throw new IllegalStateException(\"Unsupported size: \" + byteSize);\n+        };\n+    }\n+\n+    private static long sizeTAtIndex(MemorySegment segment, int index) {\n+        long offset = SIZE_T.scale(0, index);\n+        if (VH_SIZE_T.varType() == long.class) {\n+            return (long) VH_SIZE_T.get(segment, offset);\n+        } else {\n+            return (int) VH_SIZE_T.get(segment, offset); \/\/ 'erase' to long\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/fallback\/FFIType.java","additions":26,"deletions":10,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+import java.util.Map;\n@@ -52,0 +53,8 @@\n+import static java.lang.foreign.ValueLayout.JAVA_BOOLEAN;\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n+import static java.lang.foreign.ValueLayout.JAVA_CHAR;\n+import static java.lang.foreign.ValueLayout.JAVA_DOUBLE;\n+import static java.lang.foreign.ValueLayout.JAVA_FLOAT;\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n+import static java.lang.foreign.ValueLayout.JAVA_LONG;\n+import static java.lang.foreign.ValueLayout.JAVA_SHORT;\n@@ -234,24 +243,19 @@\n-        if (layout instanceof ValueLayout.OfBoolean bl) {\n-            argSeg.set(bl, 0, (Boolean) arg);\n-        } else if (layout instanceof ValueLayout.OfByte bl) {\n-            argSeg.set(bl, 0, (Byte) arg);\n-        } else if (layout instanceof ValueLayout.OfShort sl) {\n-            argSeg.set(sl, 0, (Short) arg);\n-        } else if (layout instanceof ValueLayout.OfChar cl) {\n-            argSeg.set(cl, 0, (Character) arg);\n-        } else if (layout instanceof ValueLayout.OfInt il) {\n-            argSeg.set(il, 0, (Integer) arg);\n-        } else if (layout instanceof ValueLayout.OfLong ll) {\n-            argSeg.set(ll, 0, (Long) arg);\n-        } else if (layout instanceof ValueLayout.OfFloat fl) {\n-            argSeg.set(fl, 0, (Float) arg);\n-        } else if (layout instanceof ValueLayout.OfDouble dl) {\n-            argSeg.set(dl, 0, (Double) arg);\n-        } else if (layout instanceof AddressLayout al) {\n-            MemorySegment addrArg = (MemorySegment) arg;\n-            acquireCallback.accept(addrArg);\n-            argSeg.set(al, 0, addrArg);\n-        } else if (layout instanceof GroupLayout) {\n-            MemorySegment.copy((MemorySegment) arg, 0, argSeg, 0, argSeg.byteSize()); \/\/ by-value struct\n-        } else {\n-            assert layout == null;\n+        switch (layout) {\n+            case ValueLayout.OfBoolean bl -> argSeg.set(bl, 0, (Boolean) arg);\n+            case ValueLayout.OfByte    bl -> argSeg.set(bl, 0, (Byte) arg);\n+            case ValueLayout.OfShort   sl -> argSeg.set(sl, 0, (Short) arg);\n+            case ValueLayout.OfChar    cl -> argSeg.set(cl, 0, (Character) arg);\n+            case ValueLayout.OfInt     il -> argSeg.set(il, 0, (Integer) arg);\n+            case ValueLayout.OfLong    ll -> argSeg.set(ll, 0, (Long) arg);\n+            case ValueLayout.OfFloat   fl -> argSeg.set(fl, 0, (Float) arg);\n+            case ValueLayout.OfDouble  dl -> argSeg.set(dl, 0, (Double) arg);\n+            case AddressLayout         al -> {\n+                MemorySegment addrArg = (MemorySegment) arg;\n+                acquireCallback.accept(addrArg);\n+                argSeg.set(al, 0, addrArg);\n+            }\n+            case GroupLayout           __ ->\n+                    MemorySegment.copy((MemorySegment) arg, 0, argSeg, 0, argSeg.byteSize()); \/\/ by-value struct\n+            case null, default -> {\n+                assert layout == null;\n+            }\n@@ -286,0 +290,43 @@\n+\n+    @Override\n+    public Map<String, MemoryLayout> canonicalLayouts() {\n+        \/\/ Avoid eager dependency on LibFallback, so we can safely check LibFallback.SUPPORTED\n+        class Holder {\n+            static final Map<String, MemoryLayout> CANONICAL_LAYOUTS;\n+\n+            static {\n+                int wchar_size = LibFallback.wcharSize();\n+                MemoryLayout wchartLayout = switch(wchar_size) {\n+                    case 2 -> JAVA_CHAR; \/\/ prefer JAVA_CHAR\n+                    default -> FFIType.layoutFor(wchar_size);\n+                };\n+\n+                CANONICAL_LAYOUTS = Map.ofEntries(\n+                    \/\/ specified canonical layouts\n+                    Map.entry(\"bool\", JAVA_BOOLEAN),\n+                    Map.entry(\"char\", JAVA_BYTE),\n+                    Map.entry(\"float\", JAVA_FLOAT),\n+                    Map.entry(\"long long\", JAVA_LONG),\n+                    Map.entry(\"double\", JAVA_DOUBLE),\n+                    Map.entry(\"void*\", ADDRESS),\n+                    \/\/ platform-dependent sizes\n+                    Map.entry(\"size_t\", FFIType.SIZE_T),\n+                    Map.entry(\"short\", FFIType.layoutFor(LibFallback.shortSize())),\n+                    Map.entry(\"int\", FFIType.layoutFor(LibFallback.intSize())),\n+                    Map.entry(\"long\", FFIType.layoutFor(LibFallback.longSize())),\n+                    Map.entry(\"wchar_t\", wchartLayout),\n+                    \/\/ JNI types\n+                    Map.entry(\"jboolean\", JAVA_BOOLEAN),\n+                    Map.entry(\"jchar\", JAVA_CHAR),\n+                    Map.entry(\"jbyte\", JAVA_BYTE),\n+                    Map.entry(\"jshort\", JAVA_SHORT),\n+                    Map.entry(\"jint\", JAVA_INT),\n+                    Map.entry(\"jlong\", JAVA_LONG),\n+                    Map.entry(\"jfloat\", JAVA_FLOAT),\n+                    Map.entry(\"jdouble\", JAVA_DOUBLE)\n+                );\n+            }\n+        }\n+\n+        return Holder.CANONICAL_LAYOUTS;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/fallback\/FallbackLinker.java","additions":71,"deletions":24,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -68,0 +68,6 @@\n+    \/\/ platform-dependent types\n+    static int shortSize() { return NativeConstants.SIZEOF_SHORT; }\n+    static int intSize() { return NativeConstants.SIZEOF_INT; }\n+    static int longSize() {return NativeConstants.SIZEOF_LONG; }\n+    static int wcharSize() {return NativeConstants.SIZEOF_WCHAR; }\n+\n@@ -225,0 +231,4 @@\n+    private static native int ffi_sizeof_short();\n+    private static native int ffi_sizeof_int();\n+    private static native int ffi_sizeof_long();\n+    private static native int ffi_sizeof_wchar();\n@@ -242,0 +252,5 @@\n+        static final int SIZEOF_SHORT = ffi_sizeof_short();\n+        static final int SIZEOF_INT = ffi_sizeof_int();\n+        static final int SIZEOF_LONG = ffi_sizeof_long();\n+        static final int SIZEOF_WCHAR = ffi_sizeof_wchar();\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/fallback\/LibFallback.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -55,3 +55,3 @@\n-        switch (cls) {\n-            case StorageType.INTEGER: return INTEGER_REG_SIZE;\n-            case StorageType.FLOAT: return FLOAT_REG_SIZE;\n+        return switch (cls) {\n+            case StorageType.INTEGER -> INTEGER_REG_SIZE;\n+            case StorageType.FLOAT   -> FLOAT_REG_SIZE;\n@@ -59,3 +59,2 @@\n-        }\n-\n-        throw new IllegalArgumentException(\"Invalid Storage Class: \" + cls);\n+            default -> throw new IllegalArgumentException(\"Invalid Storage Class: \" + cls);\n+        };\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/ppc64\/PPC64Architecture.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.foreign.abi.SharedUtils;\n@@ -33,0 +34,2 @@\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.ValueLayout;\n@@ -36,0 +39,1 @@\n+import java.util.Map;\n@@ -39,0 +43,3 @@\n+    static final Map<String, MemoryLayout> CANONICAL_LAYOUTS =\n+        SharedUtils.canonicalLayouts(ValueLayout.JAVA_LONG, ValueLayout.JAVA_LONG, ValueLayout.JAVA_INT);\n+\n@@ -65,0 +72,5 @@\n+\n+    @Override\n+    public Map<String, MemoryLayout> canonicalLayouts() {\n+        return CANONICAL_LAYOUTS;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/ppc64\/linux\/LinuxPPC64Linker.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.foreign.abi.SharedUtils;\n@@ -33,0 +34,2 @@\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.ValueLayout;\n@@ -36,0 +39,1 @@\n+import java.util.Map;\n@@ -39,0 +43,3 @@\n+    static final Map<String, MemoryLayout> CANONICAL_LAYOUTS =\n+            SharedUtils.canonicalLayouts(ValueLayout.JAVA_LONG, ValueLayout.JAVA_LONG, ValueLayout.JAVA_INT);\n+\n@@ -65,0 +72,5 @@\n+\n+    @Override\n+    public Map<String, MemoryLayout> canonicalLayouts() {\n+        return CANONICAL_LAYOUTS;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/ppc64\/linux\/LinuxPPC64leLinker.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import jdk.internal.foreign.abi.riscv64.linux.TypeClass;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/riscv64\/RISCV64Architecture.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n-import jdk.internal.foreign.abi.UpcallLinker;\n@@ -48,1 +47,0 @@\n-import java.lang.foreign.ValueLayout;\n@@ -153,1 +151,1 @@\n-        \/\/ Aggregates or scalars passed on the stack are aligned to the greater of\n+        \/\/ Aggregates or scalars passed on the stack are aligned to the greatest of\n@@ -256,2 +254,2 @@\n-    static class UnboxBindingCalculator extends BindingCalculator {\n-        boolean forArguments;\n+    static final class UnboxBindingCalculator extends BindingCalculator {\n+        final boolean forArguments;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/riscv64\/linux\/LinuxRISCV64CallArranger.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import jdk.internal.foreign.abi.SharedUtils;\n@@ -35,0 +36,2 @@\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.ValueLayout;\n@@ -38,0 +41,1 @@\n+import java.util.Map;\n@@ -41,0 +45,3 @@\n+    static final Map<String, MemoryLayout> CANONICAL_LAYOUTS =\n+            SharedUtils.canonicalLayouts(ValueLayout.JAVA_LONG, ValueLayout.JAVA_LONG, ValueLayout.JAVA_INT);\n+\n@@ -67,0 +74,5 @@\n+\n+    @Override\n+    public Map<String, MemoryLayout> canonicalLayouts() {\n+        return CANONICAL_LAYOUTS;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/riscv64\/linux\/LinuxRISCV64Linker.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-    private static record FieldCounter(long integerCnt, long floatCnt, long pointerCnt) {\n+    private record FieldCounter(long integerCnt, long floatCnt, long pointerCnt) {\n@@ -131,3 +131,1 @@\n-    public static record FlattenedFieldDesc(TypeClass typeClass, long offset, ValueLayout layout) {\n-\n-    }\n+    public record FlattenedFieldDesc(TypeClass typeClass, long offset, ValueLayout layout) { }\n@@ -136,10 +134,16 @@\n-        if (layout instanceof ValueLayout valueLayout) {\n-            TypeClass typeClass = classifyValueType(valueLayout);\n-            return List.of(switch (typeClass) {\n-                case INTEGER, FLOAT -> new FlattenedFieldDesc(typeClass, offset, valueLayout);\n-                default -> throw new IllegalStateException(\"Should not reach here.\");\n-            });\n-        } else if (layout instanceof GroupLayout groupLayout) {\n-            List<FlattenedFieldDesc> fields = new ArrayList<>();\n-            for (MemoryLayout memberLayout : groupLayout.memberLayouts()) {\n-                if (memberLayout instanceof PaddingLayout) {\n+        return switch (layout) {\n+            case ValueLayout valueLayout -> {\n+                TypeClass typeClass = classifyValueType(valueLayout);\n+                yield List.of(switch (typeClass) {\n+                    case INTEGER, FLOAT -> new FlattenedFieldDesc(typeClass, offset, valueLayout);\n+                    default -> throw new IllegalStateException(\"Should not reach here.\");\n+                });\n+            }\n+            case GroupLayout groupLayout -> {\n+                List<FlattenedFieldDesc> fields = new ArrayList<>();\n+                for (MemoryLayout memberLayout : groupLayout.memberLayouts()) {\n+                    if (memberLayout instanceof PaddingLayout) {\n+                        offset += memberLayout.byteSize();\n+                        continue;\n+                    }\n+                    fields.addAll(getFlattenedFieldsInner(offset, memberLayout));\n@@ -147,1 +151,0 @@\n-                    continue;\n@@ -149,2 +152,1 @@\n-                fields.addAll(getFlattenedFieldsInner(offset, memberLayout));\n-                offset += memberLayout.byteSize();\n+                yield fields;\n@@ -152,7 +154,8 @@\n-            return fields;\n-        } else if (layout instanceof SequenceLayout sequenceLayout) {\n-            List<FlattenedFieldDesc> fields = new ArrayList<>();\n-            MemoryLayout elementLayout = sequenceLayout.elementLayout();\n-            for (long i = 0; i < sequenceLayout.elementCount(); i++) {\n-                fields.addAll(getFlattenedFieldsInner(offset, elementLayout));\n-                offset += elementLayout.byteSize();\n+            case SequenceLayout sequenceLayout -> {\n+                List<FlattenedFieldDesc> fields = new ArrayList<>();\n+                MemoryLayout elementLayout = sequenceLayout.elementLayout();\n+                for (long i = 0; i < sequenceLayout.elementCount(); i++) {\n+                    fields.addAll(getFlattenedFieldsInner(offset, elementLayout));\n+                    offset += elementLayout.byteSize();\n+                }\n+                yield fields;\n@@ -160,4 +163,2 @@\n-            return fields;\n-        } else {\n-            throw new IllegalStateException(\"Cannot get here: \" + layout);\n-        }\n+            case null, default -> throw new IllegalStateException(\"Cannot get here: \" + layout);\n+        };\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/riscv64\/linux\/TypeClass.java","additions":29,"deletions":28,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -55,5 +55,3 @@\n-        switch (cls) {\n-            case StorageType.INTEGER:\n-                return INTEGER_REG_SIZE;\n-            case StorageType.FLOAT:\n-                return FLOAT_REG_SIZE;\n+        return switch (cls) {\n+            case StorageType.INTEGER -> INTEGER_REG_SIZE;\n+            case StorageType.FLOAT   -> FLOAT_REG_SIZE;\n@@ -61,3 +59,2 @@\n-        }\n-\n-        throw new IllegalArgumentException(\"Invalid Storage Class: \" + cls);\n+            default -> throw new IllegalArgumentException(\"Invalid Storage Class: \" + cls);\n+        };\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/s390\/S390Architecture.java","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-import jdk.internal.foreign.abi.UpcallLinker;\n@@ -45,1 +44,0 @@\n-import java.lang.foreign.ValueLayout;\n@@ -49,1 +47,0 @@\n-import java.util.Map;\n@@ -52,1 +49,0 @@\n-import static jdk.internal.foreign.abi.s390.linux.TypeClass.*;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/s390\/linux\/LinuxS390CallArranger.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.foreign.abi.SharedUtils;\n@@ -32,0 +33,2 @@\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.ValueLayout;\n@@ -35,0 +38,1 @@\n+import java.util.Map;\n@@ -38,0 +42,3 @@\n+    private static final Map<String, MemoryLayout> CANONICAL_LAYOUTS =\n+            SharedUtils.canonicalLayouts(ValueLayout.JAVA_LONG, ValueLayout.JAVA_LONG, ValueLayout.JAVA_INT);\n+\n@@ -64,0 +71,5 @@\n+\n+    @Override\n+    public Map<String, MemoryLayout> canonicalLayouts() {\n+        return CANONICAL_LAYOUTS;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/s390\/linux\/LinuxS390Linker.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -99,4 +99,1 @@\n-        if (baseArgClass != FLOAT)\n-            return false;\n-\n-        return true;\n+        return baseArgClass == FLOAT;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/s390\/linux\/TypeClass.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import jdk.internal.foreign.abi.UpcallLinker;\n@@ -80,1 +79,3 @@\n-        new VMStorage[] { xmm8, xmm9, xmm10, xmm11, xmm12, xmm13, xmm14, xmm15 },\n+        new VMStorage[] { xmm8, xmm9, xmm10, xmm11, xmm12, xmm13, xmm14, xmm15,\n+                          xmm16, xmm17, xmm18, xmm19, xmm20, xmm21, xmm22, xmm23,\n+                          xmm24, xmm25, xmm26, xmm27, xmm28, xmm29, xmm30, xmm31 },\n@@ -211,1 +212,1 @@\n-            \/\/ok, let's pass pass on registers\n+            \/\/ok, let's pass on registers\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/CallArranger.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.foreign.abi.SharedUtils;\n@@ -32,0 +33,2 @@\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.ValueLayout;\n@@ -35,0 +38,1 @@\n+import java.util.Map;\n@@ -41,0 +45,3 @@\n+    static final Map<String, MemoryLayout> CANONICAL_LAYOUTS =\n+            SharedUtils.canonicalLayouts(ValueLayout.JAVA_LONG, ValueLayout.JAVA_LONG, ValueLayout.JAVA_INT);\n+\n@@ -67,0 +74,5 @@\n+\n+    @Override\n+    public Map<String, MemoryLayout> canonicalLayouts() {\n+        return CANONICAL_LAYOUTS;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVx64Linker.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -211,6 +211,10 @@\n-    private static void groupByEightBytes(MemoryLayout l, long offset, List<ArgumentClassImpl>[] groups) {\n-        if (l instanceof GroupLayout group) {\n-            for (MemoryLayout m : group.memberLayouts()) {\n-                groupByEightBytes(m, offset, groups);\n-                if (group instanceof StructLayout) {\n-                    offset += m.byteSize();\n+    private static void groupByEightBytes(MemoryLayout layout,\n+                                          long offset,\n+                                          List<ArgumentClassImpl>[] groups) {\n+        switch (layout) {\n+            case GroupLayout group -> {\n+                for (MemoryLayout m : group.memberLayouts()) {\n+                    groupByEightBytes(m, offset, groups);\n+                    if (group instanceof StructLayout) {\n+                        offset += m.byteSize();\n+                    }\n@@ -219,7 +223,1 @@\n-        } else if (l instanceof PaddingLayout) {\n-            return;\n-        } else if (l instanceof SequenceLayout seq) {\n-            MemoryLayout elem = seq.elementLayout();\n-            for (long i = 0 ; i < seq.elementCount() ; i++) {\n-                groupByEightBytes(elem, offset, groups);\n-                offset += elem.byteSize();\n+            case PaddingLayout __ -> {\n@@ -227,5 +225,6 @@\n-        } else if (l instanceof ValueLayout vl) {\n-            List<ArgumentClassImpl> layouts = groups[(int)offset \/ 8];\n-            if (layouts == null) {\n-                layouts = new ArrayList<>();\n-                groups[(int)offset \/ 8] = layouts;\n+            case SequenceLayout seq -> {\n+                MemoryLayout elem = seq.elementLayout();\n+                for (long i = 0; i < seq.elementCount(); i++) {\n+                    groupByEightBytes(elem, offset, groups);\n+                    offset += elem.byteSize();\n+                }\n@@ -233,7 +232,13 @@\n-            \/\/ if the aggregate contains unaligned fields, it has class MEMORY\n-            ArgumentClassImpl argumentClass = (offset % vl.byteAlignment()) == 0 ?\n-                    argumentClassFor(vl) :\n-                    ArgumentClassImpl.MEMORY;\n-            layouts.add(argumentClass);\n-        } else {\n-            throw new IllegalStateException(\"Unexpected layout: \" + l);\n+            case ValueLayout vl -> {\n+                List<ArgumentClassImpl> layouts = groups[(int) offset \/ 8];\n+                if (layouts == null) {\n+                    layouts = new ArrayList<>();\n+                    groups[(int) offset \/ 8] = layouts;\n+                }\n+                \/\/ if the aggregate contains unaligned fields, it has class MEMORY\n+                ArgumentClassImpl argumentClass = (offset % vl.byteAlignment()) == 0 ?\n+                        argumentClassFor(vl) :\n+                        ArgumentClassImpl.MEMORY;\n+                layouts.add(argumentClass);\n+            }\n+            case null, default -> throw new IllegalStateException(\"Unexpected layout: \" + layout);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/TypeClass.java","additions":30,"deletions":25,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-import jdk.internal.foreign.abi.UpcallLinker;\n@@ -45,1 +44,0 @@\n-import java.lang.foreign.ValueLayout;\n@@ -71,1 +69,3 @@\n-        new VMStorage[] { xmm4, xmm5 },\n+        new VMStorage[] { xmm4, xmm5,\n+                          xmm16, xmm17, xmm18, xmm19, xmm20, xmm21, xmm22, xmm23,\n+                          xmm24, xmm25, xmm26, xmm27, xmm28, xmm29, xmm30, xmm31 },\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/CallArranger.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-        \/\/ No 128-bit integers in the Windows C ABI. There are __m128(i|d) intrinsic types but they act just\n+        \/\/ No 128-bit integers in the Windows C ABI. There are __m128(i|d) intrinsic types but, they act just\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/TypeClass.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.foreign.abi.SharedUtils;\n@@ -31,0 +32,2 @@\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.ValueLayout;\n@@ -34,0 +37,1 @@\n+import java.util.Map;\n@@ -40,0 +44,3 @@\n+    static final Map<String, MemoryLayout> CANONICAL_LAYOUTS =\n+            SharedUtils.canonicalLayouts(ValueLayout.JAVA_INT, ValueLayout.JAVA_LONG, ValueLayout.JAVA_CHAR);\n+\n@@ -66,0 +73,5 @@\n+\n+    @Override\n+    public Map<String, MemoryLayout> canonicalLayouts() {\n+        return CANONICAL_LAYOUTS;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/Windowsx64Linker.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -42,2 +42,0 @@\n- *\n- * @since 19\n@@ -45,1 +43,1 @@\n-public sealed abstract class AbstractGroupLayout<L extends AbstractGroupLayout<L> & MemoryLayout>\n+abstract sealed class AbstractGroupLayout<L extends AbstractGroupLayout<L> & MemoryLayout>\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/AbstractGroupLayout.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import jdk.internal.foreign.LayoutPath;\n+import jdk.internal.foreign.LayoutPath.PathElementImpl.PathKind;\n@@ -32,0 +34,1 @@\n+import java.lang.foreign.MemoryLayout.PathElement;\n@@ -36,0 +39,5 @@\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.invoke.VarHandle;\n+import java.util.EnumSet;\n@@ -38,0 +46,2 @@\n+import java.util.Set;\n+import java.util.function.Function;\n@@ -56,0 +66,1 @@\n+    @SuppressWarnings(\"unchecked\")\n@@ -57,1 +68,1 @@\n-        return dup(byteAlignment(), Optional.empty());\n+        return name.isPresent() ? dup(byteAlignment(), Optional.empty()) : (L) this;\n@@ -142,0 +153,72 @@\n+    public long scale(long offset, long index) {\n+        if (offset < 0) {\n+            throw new IllegalArgumentException(\"Negative offset: \" + offset);\n+        }\n+        if (index < 0) {\n+            throw new IllegalArgumentException(\"Negative index: \" + index);\n+        }\n+\n+        return Math.addExact(offset, Math.multiplyExact(byteSize(), index));\n+    }\n+\n+    public MethodHandle scaleHandle() {\n+        class Holder {\n+            static final MethodHandle MH_SCALE;\n+            static {\n+                try {\n+                    MH_SCALE = MethodHandles.lookup().findVirtual(MemoryLayout.class, \"scale\",\n+                            MethodType.methodType(long.class, long.class, long.class));\n+                } catch (ReflectiveOperationException e) {\n+                    throw new ExceptionInInitializerError(e);\n+                }\n+            }\n+        }\n+        return Holder.MH_SCALE.bindTo(this);\n+    }\n+\n+\n+    public long byteOffset(PathElement... elements) {\n+        return computePathOp(LayoutPath.rootPath((MemoryLayout) this), LayoutPath::offset,\n+                EnumSet.of(PathKind.SEQUENCE_ELEMENT, PathKind.SEQUENCE_RANGE, PathKind.DEREF_ELEMENT), elements);\n+    }\n+\n+    public MethodHandle byteOffsetHandle(PathElement... elements) {\n+        return computePathOp(LayoutPath.rootPath((MemoryLayout) this), LayoutPath::offsetHandle,\n+                EnumSet.of(PathKind.DEREF_ELEMENT), elements);\n+    }\n+\n+    public VarHandle varHandle(PathElement... elements) {\n+        Objects.requireNonNull(elements);\n+        if (this instanceof ValueLayout vl && elements.length == 0) {\n+            return vl.varHandle(); \/\/ fast path\n+        }\n+        return computePathOp(LayoutPath.rootPath((MemoryLayout) this), LayoutPath::dereferenceHandle,\n+                Set.of(), elements);\n+    }\n+\n+    public VarHandle arrayElementVarHandle(PathElement... elements) {\n+        return MethodHandles.collectCoordinates(varHandle(elements), 1, scaleHandle());\n+    }\n+\n+    public MethodHandle sliceHandle(PathElement... elements) {\n+        return computePathOp(LayoutPath.rootPath((MemoryLayout) this), LayoutPath::sliceHandle,\n+                Set.of(PathKind.DEREF_ELEMENT), elements);\n+    }\n+\n+    public MemoryLayout select(PathElement... elements) {\n+        return computePathOp(LayoutPath.rootPath((MemoryLayout) this), LayoutPath::layout,\n+                EnumSet.of(PathKind.SEQUENCE_ELEMENT_INDEX, PathKind.SEQUENCE_RANGE, PathKind.DEREF_ELEMENT), elements);\n+    }\n+\n+    private static <Z> Z computePathOp(LayoutPath path, Function<LayoutPath, Z> finalizer,\n+                                       Set<PathKind> badKinds, PathElement... elements) {\n+        Objects.requireNonNull(elements);\n+        for (PathElement e : elements) {\n+            LayoutPath.PathElementImpl pathElem = (LayoutPath.PathElementImpl)Objects.requireNonNull(e);\n+            if (badKinds.contains(pathElem.kind())) {\n+                throw new IllegalArgumentException(String.format(\"Invalid %s selection in layout path\", pathElem.kind().description()));\n+            }\n+            path = pathElem.apply(path);\n+        }\n+        return finalizer.apply(path);\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/AbstractLayout.java","additions":84,"deletions":1,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import sun.invoke.util.Wrapper;\n@@ -36,0 +35,1 @@\n+import java.lang.foreign.AddressLayout;\n@@ -38,1 +38,0 @@\n-import java.lang.foreign.AddressLayout;\n@@ -42,2 +41,0 @@\n-import java.util.ArrayList;\n-import java.util.List;\n@@ -65,1 +62,1 @@\n-    abstract sealed static class AbstractValueLayout<V extends AbstractValueLayout<V> & ValueLayout> extends AbstractLayout<V> {\n+    abstract static sealed class AbstractValueLayout<V extends AbstractValueLayout<V> & ValueLayout> extends AbstractLayout<V> {\n@@ -118,18 +115,0 @@\n-        public final VarHandle arrayElementVarHandle(int... shape) {\n-            Objects.requireNonNull(shape);\n-            if (!Utils.isElementAligned((ValueLayout) this)) {\n-                throw new UnsupportedOperationException(\"Layout alignment greater than its size\");\n-            }\n-            MemoryLayout layout = self();\n-            List<MemoryLayout.PathElement> path = new ArrayList<>();\n-            for (int i = shape.length; i > 0; i--) {\n-                int size = shape[i - 1];\n-                if (size < 0) throw new IllegalArgumentException(\"Invalid shape size: \" + size);\n-                layout = MemoryLayout.sequenceLayout(size, layout);\n-                path.add(MemoryLayout.PathElement.sequenceElement());\n-            }\n-            layout = MemoryLayout.sequenceLayout(layout);\n-            path.add(MemoryLayout.PathElement.sequenceElement());\n-            return layout.varHandle(path.toArray(new MemoryLayout.PathElement[0]));\n-        }\n-\n@@ -180,1 +159,1 @@\n-        public final VarHandle accessHandle() {\n+        public final VarHandle varHandle() {\n@@ -396,1 +375,1 @@\n-     *     <li>{@link ValueLayout.OfAddress}, for {@code MemorySegment.class}<\/li>\n+     *     <li>{@link AddressLayout}, for {@code MemorySegment.class}<\/li>\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/ValueLayouts.java","additions":4,"deletions":25,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -4598,1 +4598,1 @@\n-        if (0 > count || objects.length < (objectStart+count)) {\n+        if (0 > count || objects.length - count < objectStart) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/icu\/text\/BidiBase.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-        \/\/ not used\n+        \/\/ not used, but required for interim javac to not warn.\n@@ -69,1 +69,0 @@\n-        @JEP(number=442, title=\"Foreign Function & Memory API\", status=\"Third Preview\")\n@@ -71,0 +70,1 @@\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/javac\/PreviewFeature.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -151,0 +151,1 @@\n+    @Stable\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/VM.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -137,0 +137,7 @@\n+    \/**\n+     * Adds native access to all unnamed modules.\n+     *\/\n+    public static void addEnableNativeAccessToAllUnnamed() {\n+        JLA.addEnableNativeAccessToAllUnnamed();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/Modules.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+import jdk.internal.access.JavaLangAccess;\n@@ -118,1 +119,4 @@\n-        SharedSecrets.getJavaLangAccess().ensureNativeAccess(module, owner, methodName);\n+        class Holder {\n+            static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n+        }\n+        Holder.JLA.ensureNativeAccess(module, owner, methodName, currentClass);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/Reflection.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -117,1 +117,1 @@\n-    private static Architecture CURRENT_ARCH = initArch(PlatformProps.CURRENT_ARCH_STRING);\n+    private static final Architecture CURRENT_ARCH = initArch(PlatformProps.CURRENT_ARCH_STRING);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/Architecture.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -94,0 +94,24 @@\n+    \/**\n+     * For values from 0 to 255 return a short encoding a pair of hex ASCII-encoded digit characters in little-endian\n+     * @param i value to convert\n+     * @param ucase true uppper case, false lower case\n+     * @return a short encoding a pair of hex ASCII-encoded digit characters\n+     *\/\n+    public static short digitPair(int i, boolean ucase) {\n+        \/*\n+         * 0b0100_0000_0100_0000 is a selector that selects letters (1 << 6),\n+         * uppercase or not, and shifting it right by 1 bit incidentally\n+         * becomes a bit offset between cases (1 << 5).\n+         *\n+         *  ([0-9] & 0b100_0000) >> 1 => 0\n+         *  ([a-f] & 0b100_0000) >> 1 => 32\n+         *\n+         *  [0-9] -  0 => [0-9]\n+         *  [a-f] - 32 => [A-F]\n+         *\/\n+        short v = DIGITS[i & 0xff];\n+        return ucase\n+                ? (short) (v - ((v & 0b0100_0000_0100_0000) >> 1))\n+                : v;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/HexDigits.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -51,0 +51,4 @@\n+    \/**\n+     * @param bitIndex the bit index to test\n+     * @return true if the bit is in the range of the BitSet and the bit is set, otherwise false\n+     *\/\n@@ -53,2 +57,3 @@\n-        if (bitIndex < 0)\n-            throw new IndexOutOfBoundsException(\"bitIndex < 0: \" + bitIndex);\n+        if (bitIndex < 0) {\n+            return false;\n+        }\n@@ -56,1 +61,1 @@\n-        int wordIndex = wordIndex(bitIndex);\n+        int wordIndex = bitIndex >> 6;\n@@ -61,7 +66,0 @@\n-    \/**\n-     * Given a bit index, return word index containing it.\n-     *\/\n-    private static int wordIndex(int bitIndex) {\n-        return bitIndex >> 6;\n-    }\n-\n@@ -82,0 +80,6 @@\n+        if (original.size() <= 128) {\n+            long[] array = original.toLongArray();\n+            return new SmallImmutableBitSetPredicate(\n+                    array.length > 0 ? array[0] : 0L,\n+                    array.length > 1 ? array[1] : 0L);\n+        }\n@@ -85,0 +89,25 @@\n+    \/**\n+     * Specialization for small sets of 128 bits or less\n+     * @param first - bits index 0 through 63, inclusive\n+     * @param second - bits index 64 through 127, inclusive\n+     *\/\n+    public record SmallImmutableBitSetPredicate(long first, long second) implements IntPredicate {\n+\n+        \/**\n+         * @param bitIndex the bit index to test\n+         * @return true if the bit is in the range of the BitSet and the bit is set, otherwise false\n+         *\/\n+        @Override\n+        public boolean test(int bitIndex) {\n+            if (bitIndex < 0) {\n+                return false;\n+            }\n+\n+            int wordIndex = bitIndex >> 6;\n+            if (wordIndex > 1) {\n+                return false;\n+            }\n+            long bits = wordIndex == 0 ? first : second;\n+            return (bits & (1L << bitIndex)) != 0;\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/ImmutableBitSetPredicate.java","additions":39,"deletions":10,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -606,4 +606,0 @@\n-        \/**\n-         * The size of the stack.\n-         *\/\n-        protected short _Depth;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/xml\/impl\/XMLStreamWriterImpl.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -152,1 +152,1 @@\n-        jdk.incubator.vector, \/\/ participates in preview features\n+        jdk.incubator.vector,\n@@ -190,0 +190,1 @@\n+        jdk.jfr,\n@@ -195,0 +196,1 @@\n+        jdk.jfr,\n@@ -196,0 +198,2 @@\n+    exports jdk.internal.classfile.components to\n+        jdk.jfr;\n@@ -199,0 +203,1 @@\n+        jdk.jfr,\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -105,0 +105,1 @@\n+    private static final String ENABLE_NATIVE_ACCESS = \"Enable-Native-Access\";\n@@ -635,0 +636,7 @@\n+            String enableNativeAccess = mainAttrs.getValue(ENABLE_NATIVE_ACCESS);\n+            if (enableNativeAccess != null) {\n+                if (!enableNativeAccess.equals(\"ALL-UNNAMED\")) {\n+                    abort(null, \"java.launcher.jar.error.illegal.ena.value\", enableNativeAccess);\n+                }\n+                Modules.addEnableNativeAccessToAllUnnamed();\n+            }\n","filename":"src\/java.base\/share\/classes\/sun\/launcher\/LauncherHelper.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -66,2 +66,2 @@\n-\\                  modules that are permitted to perform restricted native operations.\\n\\\n-\\                  <module name> can also be ALL-UNNAMED.\\n\\\n+\\                  allow code in modules to access code and data outside the Java runtime.\\n\\\n+\\                  <module name> can also be ALL-UNNAMED to indicate code on the class path.\\n\\\n@@ -271,0 +271,2 @@\n+java.launcher.jar.error.illegal.ena.value=\\\n+    Error: illegal value \\\"{0}\\\" for Enable-Native-Access manifest attribute. Only 'ALL-UNNAMED' is allowed\n","filename":"src\/java.base\/share\/classes\/sun\/launcher\/resources\/launcher.properties","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -53,2 +53,0 @@\n-import jdk.internal.foreign.AbstractMemorySegmentImpl;\n-import jdk.internal.foreign.MappedMemorySegmentImpl;\n@@ -56,0 +54,1 @@\n+import jdk.internal.foreign.SegmentFactories;\n@@ -1338,16 +1337,1 @@\n-        if (unmapper != null) {\n-            AbstractMemorySegmentImpl segment =\n-                new MappedMemorySegmentImpl(unmapper.address(), unmapper, size,\n-                                            readOnly, sessionImpl);\n-            MemorySessionImpl.ResourceList.ResourceCleanup resource =\n-                new MemorySessionImpl.ResourceList.ResourceCleanup() {\n-                    @Override\n-                    public void cleanup() {\n-                        unmapper.unmap();\n-                    }\n-                };\n-            sessionImpl.addOrCleanupIfFail(resource);\n-            return segment;\n-        } else {\n-            return new MappedMemorySegmentImpl(0, null, 0, readOnly, sessionImpl);\n-        }\n+        return SegmentFactories.mapSegment(size, unmapper, readOnly, sessionImpl);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/FileChannelImpl.java","additions":2,"deletions":18,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,6 +73,2 @@\n-    private static final ThreadLocal<GroupAndInvokeCount> myGroupAndInvokeCount =\n-        new ThreadLocal<GroupAndInvokeCount>() {\n-            @Override protected GroupAndInvokeCount initialValue() {\n-                return null;\n-            }\n-        };\n+    private static final ThreadLocal<GroupAndInvokeCount> myGroupAndInvokeCount\n+        = new ThreadLocal<GroupAndInvokeCount>();\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/Invoker.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -497,1 +497,4 @@\n-        SocketReadEvent.offer(start, nbytes, remoteAddress(), 0);\n+        long duration = SocketReadEvent.timestamp() - start;\n+        if (SocketReadEvent.shouldCommit(duration)) {\n+            SocketReadEvent.emit(start, duration, nbytes, remoteAddress(), 0);\n+        }\n@@ -511,1 +514,4 @@\n-        SocketReadEvent.offer(start, nbytes, remoteAddress(), 0);\n+        long duration = SocketReadEvent.timestamp() - start;\n+        if (SocketReadEvent.shouldCommit(duration)) {\n+            SocketReadEvent.emit(start, duration, nbytes, remoteAddress(), 0);\n+        }\n@@ -622,1 +628,4 @@\n-        SocketWriteEvent.offer(start, nbytes, remoteAddress());\n+        long duration = SocketWriteEvent.timestamp() - start;\n+        if (SocketWriteEvent.shouldCommit(duration)) {\n+            SocketWriteEvent.emit(start, duration, nbytes, remoteAddress());\n+        }\n@@ -635,1 +644,4 @@\n-        SocketWriteEvent.offer(start, nbytes, remoteAddress());\n+        long duration = SocketWriteEvent.timestamp() - start;\n+        if (SocketWriteEvent.shouldCommit(duration)) {\n+            SocketWriteEvent.emit(start, duration, nbytes, remoteAddress());\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/SocketChannelImpl.java","additions":16,"deletions":4,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import java.nio.channels.WritableByteChannel;\n@@ -82,6 +81,2 @@\n-\n-    \/\/ Factory for java.nio.channels.Channels.newWriter\n-\n-    public static StreamEncoder forEncoder(WritableByteChannel ch,\n-                                           CharsetEncoder enc,\n-                                           int minBufferCap)\n+    public static StreamEncoder forOutputStreamWriter(OutputStream out,\n+                                                      CharsetEncoder enc)\n@@ -89,1 +84,1 @@\n-        return new StreamEncoder(ch, enc, minBufferCap);\n+        return new StreamEncoder(out, enc);\n@@ -92,1 +87,0 @@\n-\n@@ -255,1 +249,0 @@\n-    \/\/ Exactly one of these is non-null\n@@ -257,1 +250,0 @@\n-    private final WritableByteChannel ch;\n@@ -274,1 +266,0 @@\n-        this.ch = null;\n@@ -282,3 +273,3 @@\n-    private StreamEncoder(WritableByteChannel ch, CharsetEncoder enc, int mbc) {\n-        this.out = null;\n-        this.ch = ch;\n+    private StreamEncoder(OutputStream out, CharsetEncoder enc) {\n+        super();\n+        this.out = out;\n@@ -288,7 +279,2 @@\n-        if (mbc > 0) {\n-            this.bb = ByteBuffer.allocate(mbc);\n-            this.maxBufferCapacity = mbc;\n-        } else {\n-            this.bb = ByteBuffer.allocate(INITIAL_BYTE_BUFFER_CAPACITY);\n-            this.maxBufferCapacity = MAX_BYTE_BUFFER_CAPACITY;\n-        }\n+        this.bb = ByteBuffer.allocate(INITIAL_BYTE_BUFFER_CAPACITY);\n+        this.maxBufferCapacity = MAX_BYTE_BUFFER_CAPACITY;\n@@ -305,6 +291,1 @@\n-            if (ch != null) {\n-                int wc = ch.write(bb);\n-                assert wc == rem : rem;\n-            } else {\n-                out.write(bb.array(), bb.arrayOffset() + pos, rem);\n-            }\n+            out.write(bb.array(), bb.arrayOffset() + pos, rem);\n@@ -411,3 +392,1 @@\n-        if (out != null) {\n-            out.flush();\n-        }\n+        out.flush();\n@@ -417,1 +396,1 @@\n-        try (ch; out) {\n+        try (out) {\n@@ -433,2 +412,1 @@\n-            if (out != null)\n-                out.flush();\n+            out.flush();\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/cs\/StreamEncoder.java","additions":12,"deletions":34,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import java.io.InvalidObjectException;\n+import java.io.ObjectInputStream;\n@@ -44,1 +46,1 @@\n- *\n+ * <p>\n@@ -67,0 +69,1 @@\n+    @java.io.Serial\n@@ -221,0 +224,16 @@\n+\n+    \/**\n+     * Restores the state of this object from the stream.\n+     * <p>\n+     * Deserialization of this object is not supported.\n+     *\n+     * @param  stream the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n+     *\/\n+    @java.io.Serial\n+    private void readObject(ObjectInputStream stream)\n+            throws IOException, ClassNotFoundException {\n+        throw new InvalidObjectException(\n+                \"ECPrivateKeyImpl keys are not directly deserializable\");\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/ECPrivateKeyImpl.java","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,2 @@\n+import java.io.InvalidObjectException;\n+import java.io.ObjectInputStream;\n@@ -47,0 +49,1 @@\n+    @java.io.Serial\n@@ -126,1 +129,2 @@\n-    protected Object writeReplace() throws java.io.ObjectStreamException {\n+    @java.io.Serial\n+    private Object writeReplace() throws java.io.ObjectStreamException {\n@@ -132,1 +136,17 @@\n-}\n+\n+    \/**\n+     * Restores the state of this object from the stream.\n+     * <p>\n+     * Deserialization of this object is not supported.\n+     *\n+     * @param  stream the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n+     *\/\n+    @java.io.Serial\n+    private void readObject(ObjectInputStream stream)\n+            throws IOException, ClassNotFoundException {\n+        throw new InvalidObjectException(\n+                \"ECPublicKeyImpl keys are not directly deserializable\");\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/ECPublicKeyImpl.java","additions":23,"deletions":3,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+    @java.io.Serial\n@@ -106,1 +107,1 @@\n-        XECParameters params = paramSpec.getName().equals(\"X25519\")\n+        XECParameters params = paramSpec.getName().equalsIgnoreCase(\"X25519\")\n@@ -117,1 +118,0 @@\n-}\n@@ -119,0 +119,16 @@\n+    \/**\n+     * Restores the state of this object from the stream.\n+     * <p>\n+     * Deserialization of this object is not supported.\n+     *\n+     * @param  stream the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n+     *\/\n+    @java.io.Serial\n+    private void readObject(ObjectInputStream stream)\n+            throws IOException, ClassNotFoundException {\n+        throw new InvalidObjectException(\n+                \"XDHPrivateKeyImpl keys are not directly deserializable\");\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/XDHPrivateKeyImpl.java","additions":18,"deletions":2,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import java.io.IOException;\n+import java.io.InvalidObjectException;\n+import java.io.ObjectInputStream;\n@@ -42,0 +45,1 @@\n+    @java.io.Serial\n@@ -110,1 +114,2 @@\n-    protected Object writeReplace() throws java.io.ObjectStreamException {\n+    @java.io.Serial\n+    private Object writeReplace() throws java.io.ObjectStreamException {\n@@ -133,0 +138,16 @@\n+\n+    \/**\n+     * Restores the state of this object from the stream.\n+     * <p>\n+     * Deserialization of this object is not supported.\n+     *\n+     * @param  stream the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n+     *\/\n+    @java.io.Serial\n+    private void readObject(ObjectInputStream stream)\n+            throws IOException, ClassNotFoundException {\n+        throw new InvalidObjectException(\n+                \"XDHPublicKeyImpl keys are not directly deserializable\");\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/XDHPublicKeyImpl.java","additions":23,"deletions":2,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,2 @@\n+import java.io.InvalidObjectException;\n+import java.io.ObjectInputStream;\n@@ -41,0 +43,1 @@\n+    @java.io.Serial\n@@ -105,0 +108,16 @@\n+\n+    \/**\n+     * Restores the state of this object from the stream.\n+     * <p>\n+     * Deserialization of this object is not supported.\n+     *\n+     * @param  stream the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n+     *\/\n+    @java.io.Serial\n+    private void readObject(ObjectInputStream stream)\n+            throws IOException, ClassNotFoundException {\n+        throw new InvalidObjectException(\n+                \"EdDSAPrivateKeyImpl keys are not directly deserializable\");\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/ed\/EdDSAPrivateKeyImpl.java","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import java.io.IOException;\n+import java.io.InvalidObjectException;\n+import java.io.ObjectInputStream;\n@@ -42,0 +45,1 @@\n+    @java.io.Serial\n@@ -111,1 +115,2 @@\n-    protected Object writeReplace() throws java.io.ObjectStreamException {\n+    @java.io.Serial\n+    private Object writeReplace() throws java.io.ObjectStreamException {\n@@ -132,0 +137,16 @@\n+\n+    \/**\n+     * Restores the state of this object from the stream.\n+     * <p>\n+     * Deserialization of this object is not supported.\n+     *\n+     * @param  stream the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n+     *\/\n+    @java.io.Serial\n+    private void readObject(ObjectInputStream stream)\n+            throws IOException, ClassNotFoundException {\n+        throw new InvalidObjectException(\n+                \"EdDSAPublicKeyImpl keys are not directly deserializable\");\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/ed\/EdDSAPublicKeyImpl.java","additions":23,"deletions":2,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import java.io.IOException;\n+import java.io.InvalidObjectException;\n+import java.io.ObjectInputStream;\n@@ -34,1 +37,1 @@\n- *\n+ * <p>\n@@ -38,1 +41,1 @@\n- *\n+ * <p>\n@@ -75,1 +78,1 @@\n-    protected Object writeReplace() throws java.io.ObjectStreamException {\n+    private Object writeReplace() throws java.io.ObjectStreamException {\n@@ -81,0 +84,16 @@\n+\n+    \/**\n+     * Restores the state of this object from the stream.\n+     * <p>\n+     * Deserialization of this object is not supported.\n+     *\n+     * @param  stream the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n+     *\/\n+    @java.io.Serial\n+    private void readObject(ObjectInputStream stream)\n+            throws IOException, ClassNotFoundException {\n+        throw new InvalidObjectException(\n+                \"DSAPublicKeyImpl keys are not directly deserializable\");\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/DSAPublicKeyImpl.java","additions":23,"deletions":4,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2101,1 +2101,9 @@\n-            if (this.certs.length != that.certs.length)\n+            if ((this.certs == null) && (that.certs == null)) {\n+                return true;\n+            }\n+\n+            if ((this.certs == null) || (that.certs == null)) {\n+                return false;\n+            }\n+\n+            if (this.certs.length != that.certs.length) {\n@@ -2103,0 +2111,1 @@\n+            }\n@@ -2166,1 +2175,1 @@\n-            return certs;\n+            return (certs == null ? null : certs.clone());\n@@ -2179,0 +2188,16 @@\n+\n+        \/**\n+         * Restores the state of this object from the stream.\n+         *\n+         * @param  stream the {@code ObjectInputStream} from which data is read\n+         * @throws IOException if an I\/O error occurs\n+         * @throws ClassNotFoundException if a serialized class cannot be loaded\n+         *\/\n+        @java.io.Serial\n+        private void readObject(ObjectInputStream stream)\n+                throws IOException, ClassNotFoundException {\n+            stream.defaultReadObject();\n+            if (certs != null) {\n+                this.certs = certs.clone();\n+            }\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/PolicyFile.java","additions":27,"deletions":2,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.io.InvalidObjectException;\n@@ -195,1 +196,1 @@\n-     *\n+     * <p>\n@@ -268,2 +269,4 @@\n-     * readObject is called to restore the state of the random object from\n-     * a stream.  We have to create a new instance of MessageDigest, because\n+     * This method is called to restore the state of the random object from\n+     * a stream.\n+     * <p>\n+     * We have to create a new instance of {@code MessageDigest}, because\n@@ -271,3 +274,3 @@\n-     *\n-     * Note that the engineNextBytes() method invoked on the restored random\n-     * object will yield the exact same (random) bytes as the original.\n+     * <p>\n+     * Note that the {@code engineNextBytes()} method invoked on the restored\n+     * random object will yield the exact same (random) bytes as the original.\n@@ -275,1 +278,5 @@\n-     * random object, using engineSetSeed().\n+     * random object, using {@code engineSetSeed()}.\n+     *\n+     * @param  s the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n@@ -279,1 +286,1 @@\n-        throws IOException, ClassNotFoundException {\n+            throws IOException, ClassNotFoundException {\n@@ -298,0 +305,29 @@\n+\n+        \/\/ Various consistency checks\n+        if ((remainder == null) && (remCount > 0)) {\n+            throw new InvalidObjectException(\n+                    \"Remainder indicated, but no data available\");\n+        }\n+\n+        \/\/ Not yet allocated state\n+        if (state == null) {\n+            if (remainder == null) {\n+                return;\n+            } else {\n+                throw new InvalidObjectException(\n+                        \"Inconsistent buffer allocations\");\n+            }\n+        }\n+\n+        \/\/ Sanity check on sizes\/pointer\n+        if ((state.length != DIGEST_SIZE) ||\n+                ((remainder != null) && (remainder.length != DIGEST_SIZE)) ||\n+                (remCount < 0 ) || (remCount >= DIGEST_SIZE)) {\n+            throw new InvalidObjectException(\n+                    \"Inconsistent buffer sizes\/state\");\n+        }\n+\n+        state = state.clone();\n+        if (remainder != null) {\n+            remainder = remainder.clone();\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/SecureRandom.java","additions":45,"deletions":9,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-import java.util.Set;\n@@ -32,1 +31,0 @@\n-import java.security.cert.X509CertSelector;\n@@ -35,2 +33,0 @@\n-import sun.security.x509.GeneralNameInterface;\n-\n@@ -58,3 +54,0 @@\n-    protected abstract void implSetPathToNames(X509CertSelector sel,\n-            Set<GeneralNameInterface> names);\n-\n@@ -65,5 +58,0 @@\n-    static void setPathToNames(X509CertSelector sel,\n-            Set<GeneralNameInterface> names) {\n-        instance.implSetPathToNames(sel, names);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/certpath\/CertPathHelper.java","additions":1,"deletions":13,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -50,1 +50,0 @@\n-import sun.security.x509.SubjectAlternativeNameExtension;\n@@ -260,8 +259,0 @@\n-            \/*\n-             * Match on subjectNamesTraversed (both DNs and AltNames)\n-             * (checks that current cert's name constraints permit it\n-             * to certify all the DNs and AltNames that have been traversed)\n-             *\/\n-            CertPathHelper.setPathToNames\n-                (caSelector, currentState.subjectNamesTraversed);\n-\n@@ -700,13 +691,0 @@\n-        \/*\n-         * Abort if we encounter the same certificate or a certificate with\n-         * the same public key, subject DN, and subjectAltNames as a cert\n-         * that is already in path.\n-         *\/\n-        for (X509Certificate cpListCert : certPathList) {\n-            if (repeated(cpListCert, cert)) {\n-                throw new CertPathValidatorException(\n-                    \"cert with repeated subject, public key, and \" +\n-                    \"subjectAltNames detected\");\n-            }\n-        }\n-\n@@ -790,43 +768,0 @@\n-    \/**\n-     * Return true if two certificates are equal or have the same subject,\n-     * public key, and subject alternative names.\n-     *\/\n-    private static boolean repeated(\n-            X509Certificate currCert, X509Certificate nextCert) {\n-        if (currCert.equals(nextCert)) {\n-            return true;\n-        }\n-        return (currCert.getSubjectX500Principal().equals(\n-            nextCert.getSubjectX500Principal()) &&\n-            currCert.getPublicKey().equals(nextCert.getPublicKey()) &&\n-            altNamesEqual(currCert, nextCert));\n-    }\n-\n-    \/**\n-     * Return true if two certificates have the same subject alternative names.\n-     *\/\n-    private static boolean altNamesEqual(\n-            X509Certificate currCert, X509Certificate nextCert) {\n-        X509CertImpl curr, next;\n-        try {\n-            curr = X509CertImpl.toImpl(currCert);\n-            next = X509CertImpl.toImpl(nextCert);\n-        } catch (CertificateException ce) {\n-            return false;\n-        }\n-\n-        SubjectAlternativeNameExtension currAltNameExt =\n-            curr.getSubjectAlternativeNameExtension();\n-        SubjectAlternativeNameExtension nextAltNameExt =\n-            next.getSubjectAlternativeNameExtension();\n-        if (currAltNameExt != null) {\n-            if (nextAltNameExt == null) {\n-                return false;\n-            }\n-            return Arrays.equals(currAltNameExt.getExtensionValue(),\n-                nextAltNameExt.getExtensionValue());\n-        } else {\n-            return (nextAltNameExt == null);\n-        }\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/certpath\/ForwardBuilder.java","additions":0,"deletions":65,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import java.util.HashSet;\n@@ -40,5 +39,0 @@\n-import sun.security.x509.SubjectAlternativeNameExtension;\n-import sun.security.x509.GeneralNames;\n-import sun.security.x509.GeneralName;\n-import sun.security.x509.GeneralNameInterface;\n-import sun.security.x509.X500Name;\n@@ -64,3 +58,0 @@\n-    \/* The set of subjectDNs and subjectAltNames of all certs in the path *\/\n-    HashSet<GeneralNameInterface> subjectNamesTraversed;\n-\n@@ -76,1 +67,0 @@\n-\n@@ -106,2 +96,0 @@\n-                \"\\n  subjectNamesTraversed: \\n\" +\n-                subjectNamesTraversed +\n@@ -120,1 +108,0 @@\n-        subjectNamesTraversed = new HashSet<>();\n@@ -170,16 +157,0 @@\n-        \/* update subjectNamesTraversed only if this is the EE cert or if\n-           this cert is not self-issued *\/\n-        if (init || !selfIssued) {\n-            X500Principal subjName = cert.getSubjectX500Principal();\n-            subjectNamesTraversed.add(X500Name.asX500Name(subjName));\n-\n-            SubjectAlternativeNameExtension subjAltNameExt\n-                    = icert.getSubjectAlternativeNameExtension();\n-            if (subjAltNameExt != null) {\n-                GeneralNames gNames = subjAltNameExt.getNames();\n-                for (GeneralName gName : gNames.names()) {\n-                    subjectNamesTraversed.add(gName.getName());\n-                }\n-            }\n-        }\n-\n@@ -193,4 +164,0 @@\n-     *\n-     * Note that this is a SMART clone. Not all fields are fully copied,\n-     * because some of them will\n-     * not have their contents modified by subsequent calls to updateState.\n@@ -216,7 +183,0 @@\n-            \/*\n-             * Shallow copy traversed names. There is no need to\n-             * deep copy contents, since the elements of the Set\n-             * are never modified by subsequent calls to updateState().\n-             *\/\n-            clonedState.subjectNamesTraversed\n-                = (HashSet<GeneralNameInterface>)subjectNamesTraversed.clone();\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/certpath\/ForwardState.java","additions":0,"deletions":40,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.util.Arrays;\n@@ -45,0 +46,1 @@\n+import sun.security.x509.SubjectAlternativeNameExtension;\n@@ -268,1 +270,1 @@\n-        List<Vertex> vertices = addVertices(certs, adjList);\n+        List<Vertex> vertices = addVertices(certs, adjList, cpList);\n@@ -328,0 +330,1 @@\n+                PublicKey rootKey = cert.getPublicKey();\n@@ -330,0 +333,6 @@\n+                    rootKey = builder.trustAnchor.getCAPublicKey();\n+                    if (debug != null)\n+                        debug.println(\n+                            \"SunCertPathBuilder.depthFirstSearchForward \" +\n+                            \"using buildParams public key: \" +\n+                            rootKey.toString());\n@@ -331,0 +340,2 @@\n+                TrustAnchor anchor = new TrustAnchor\n+                    (cert.getSubjectX500Principal(), rootKey, null);\n@@ -332,0 +343,7 @@\n+                \/\/ add the basic checker\n+                List<PKIXCertPathChecker> checkers = new ArrayList<>();\n+                BasicChecker basicChecker = new BasicChecker(anchor,\n+                                                    buildParams.date(),\n+                                                    buildParams.sigProvider(),\n+                                                    true);\n+                checkers.add(basicChecker);\n@@ -338,1 +356,0 @@\n-                List<PKIXCertPathChecker> checkers = new ArrayList<>();\n@@ -349,0 +366,3 @@\n+                \/\/ add the constraints checker\n+                checkers.add(new ConstraintsChecker(appendedCerts.size()));\n+\n@@ -353,18 +373,0 @@\n-                PublicKey rootKey = cert.getPublicKey();\n-                if (builder.trustAnchor.getTrustedCert() == null) {\n-                    rootKey = builder.trustAnchor.getCAPublicKey();\n-                    if (debug != null)\n-                        debug.println(\n-                            \"SunCertPathBuilder.depthFirstSearchForward \" +\n-                            \"using buildParams public key: \" +\n-                            rootKey.toString());\n-                }\n-                TrustAnchor anchor = new TrustAnchor\n-                    (cert.getSubjectX500Principal(), rootKey, null);\n-\n-                \/\/ add the basic checker\n-                BasicChecker basicChecker = new BasicChecker(anchor,\n-                                                    buildParams.date(),\n-                                                    buildParams.sigProvider(),\n-                                                    true);\n-                checkers.add(basicChecker);\n@@ -566,1 +568,2 @@\n-                                            List<List<Vertex>> adjList)\n+                                            List<List<Vertex>> adjList,\n+                                            List<X509Certificate> cpList)\n@@ -571,2 +574,19 @@\n-            Vertex v = new Vertex(cert);\n-            l.add(v);\n+            boolean repeated = false;\n+            for (X509Certificate cpListCert : cpList) {\n+                \/*\n+                 * Ignore if we encounter the same certificate or a\n+                 * certificate with the same public key, subject DN, and\n+                 * subjectAltNames as a cert that is already in path.\n+                 *\/\n+                if (repeated(cpListCert, cert)) {\n+                    if (debug != null) {\n+                        debug.println(\"cert with repeated subject, \" +\n+                            \"public key, and subjectAltNames detected\");\n+                    }\n+                    repeated = true;\n+                    break;\n+                }\n+            }\n+            if (!repeated) {\n+                l.add(new Vertex(cert));\n+            }\n@@ -578,0 +598,43 @@\n+    \/**\n+     * Return true if two certificates are equal or have the same subject,\n+     * public key, and subject alternative names.\n+     *\/\n+    private static boolean repeated(\n+            X509Certificate currCert, X509Certificate nextCert) {\n+        if (currCert.equals(nextCert)) {\n+            return true;\n+        }\n+        return (currCert.getSubjectX500Principal().equals(\n+            nextCert.getSubjectX500Principal()) &&\n+            currCert.getPublicKey().equals(nextCert.getPublicKey()) &&\n+            altNamesEqual(currCert, nextCert));\n+    }\n+\n+    \/**\n+     * Return true if two certificates have the same subject alternative names.\n+     *\/\n+    private static boolean altNamesEqual(\n+            X509Certificate currCert, X509Certificate nextCert) {\n+        X509CertImpl curr, next;\n+        try {\n+            curr = X509CertImpl.toImpl(currCert);\n+            next = X509CertImpl.toImpl(nextCert);\n+        } catch (CertificateException ce) {\n+            return false;\n+        }\n+\n+        SubjectAlternativeNameExtension currAltNameExt =\n+            curr.getSubjectAlternativeNameExtension();\n+        SubjectAlternativeNameExtension nextAltNameExt =\n+            next.getSubjectAlternativeNameExtension();\n+        if (currAltNameExt != null) {\n+            if (nextAltNameExt == null) {\n+                return false;\n+            }\n+            return Arrays.equals(currAltNameExt.getExtensionValue(),\n+                nextAltNameExt.getExtensionValue());\n+        } else {\n+            return (nextAltNameExt == null);\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/certpath\/SunCertPathBuilder.java","additions":86,"deletions":23,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,1 @@\n-import java.io.ByteArrayInputStream;\n-import java.io.IOException;\n-import java.io.InputStream;\n+import java.io.*;\n@@ -382,0 +380,16 @@\n+\n+    \/**\n+     * Restores the state of this object from the stream.\n+     * <p>\n+     * Deserialization of this object is not supported.\n+     *\n+     * @param  stream the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n+     *\/\n+    @java.io.Serial\n+    private void readObject(ObjectInputStream stream)\n+            throws IOException, ClassNotFoundException {\n+        throw new InvalidObjectException(\n+                \"X509CertPaths are not directly deserializable\");\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/certpath\/X509CertPath.java","additions":18,"deletions":4,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,2 @@\n+import java.io.InvalidObjectException;\n+import java.io.ObjectInputStream;\n@@ -46,1 +48,1 @@\n- *\n+ * <p>\n@@ -359,0 +361,16 @@\n+\n+    \/**\n+     * Restores the state of this object from the stream.\n+     * <p>\n+     * Deserialization of this object is not supported.\n+     *\n+     * @param  stream the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n+     *\/\n+    @java.io.Serial\n+    private void readObject(ObjectInputStream stream)\n+            throws IOException, ClassNotFoundException {\n+        throw new InvalidObjectException(\n+                \"RSAPrivateCrtKeyImpl keys are not directly deserializable\");\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/rsa\/RSAPrivateCrtKeyImpl.java","additions":20,"deletions":2,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import java.io.IOException;\n+import java.io.InvalidObjectException;\n+import java.io.ObjectInputStream;\n@@ -42,4 +45,5 @@\n- * form (modulus, private exponent only). For CRT private keys, see\n- * RSAPrivateCrtKeyImpl. We need separate classes to ensure correct behavior\n- * in instanceof checks, etc.\n- *\n+ * form (modulus, private exponent only).\n+ * <p>\n+ * For CRT private keys, see RSAPrivateCrtKeyImpl. We need separate classes\n+ * to ensure correct behavior in instanceof checks, etc.\n+ * <p>\n@@ -144,0 +148,16 @@\n+\n+    \/**\n+     * Restores the state of this object from the stream.\n+     * <p>\n+     * Deserialization of this object is not supported.\n+     *\n+     * @param  stream the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n+     *\/\n+    @java.io.Serial\n+    private void readObject(ObjectInputStream stream)\n+            throws IOException, ClassNotFoundException {\n+        throw new InvalidObjectException(\n+                \"RSAPrivateKeyImpl keys are not directly deserializable\");\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/rsa\/RSAPrivateKeyImpl.java","additions":25,"deletions":5,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,2 @@\n+import java.io.InvalidObjectException;\n+import java.io.ObjectInputStream;\n@@ -42,1 +44,1 @@\n- *\n+ * <p>\n@@ -236,1 +238,1 @@\n-    protected Object writeReplace() throws java.io.ObjectStreamException {\n+    private Object writeReplace() throws java.io.ObjectStreamException {\n@@ -242,0 +244,16 @@\n+\n+    \/**\n+     * Restores the state of this object from the stream.\n+     * <p>\n+     * Deserialization of this object is not supported.\n+     *\n+     * @param  stream the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n+     *\/\n+    @java.io.Serial\n+    private void readObject(ObjectInputStream stream)\n+            throws IOException, ClassNotFoundException {\n+        throw new InvalidObjectException(\n+                \"RSAPublicKeyImpl keys are not directly deserializable\");\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/rsa\/RSAPublicKeyImpl.java","additions":21,"deletions":3,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -408,2 +408,0 @@\n-    private Main() { }\n-\n@@ -412,1 +410,13 @@\n-        kt.run(args, System.out);\n+        int exitCode = kt.run(args, System.out);\n+        if (exitCode != 0) {\n+            System.exit(exitCode);\n+        }\n+    }\n+\n+    private static class ExitException extends RuntimeException {\n+        @java.io.Serial\n+        static final long serialVersionUID = 0L;\n+        private final int errorCode;\n+        public ExitException(int errorCode) {\n+            this.errorCode = errorCode;\n+        }\n@@ -415,1 +425,1 @@\n-    private void run(String[] args, PrintStream out) throws Exception {\n+    public int run(String[] args, PrintStream out) throws Exception {\n@@ -417,1 +427,1 @@\n-            args = parseArgs(args);\n+            parseArgs(args);\n@@ -421,0 +431,2 @@\n+        } catch (ExitException ee) {\n+            return ee.errorCode;\n@@ -427,1 +439,1 @@\n-                System.exit(1);\n+                return 1;\n@@ -444,0 +456,1 @@\n+        return 0;\n@@ -5250,1 +5263,1 @@\n-            System.exit(1);\n+            throw new ExitException(1);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/tools\/keytool\/Main.java","additions":20,"deletions":7,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -539,1 +539,1 @@\n-     *\n+     * <p>\n@@ -1221,1 +1221,1 @@\n-            nameEntry.add(Integer.valueOf(name.getType()));\n+            nameEntry.add(name.getType());\n@@ -1634,0 +1634,16 @@\n+\n+    \/**\n+     * Restores the state of this object from the stream.\n+     * <p>\n+     * Deserialization of this object is not supported.\n+     *\n+     * @param  stream the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n+     *\/\n+    @java.io.Serial\n+    private void readObject(ObjectInputStream stream)\n+            throws IOException, ClassNotFoundException {\n+        throw new InvalidObjectException(\n+                \"X509CertImpls are not directly deserializable\");\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/X509CertImpl.java","additions":19,"deletions":3,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -0,0 +1,39 @@\n+Owner: CN=Telia Root CA v2, O=Telia Finland Oyj, C=FI\n+Issuer: CN=Telia Root CA v2, O=Telia Finland Oyj, C=FI\n+Serial number: 1675f27d6fe7ae3e4acbe095b059e\n+Valid from: Thu Nov 29 11:55:54 GMT 2018 until: Sun Nov 29 11:55:54 GMT 2043\n+Signature algorithm name: SHA256withRSA\n+Subject Public Key Algorithm: 4096-bit RSA key\n+Version: 3\n+-----BEGIN CERTIFICATE-----\n+MIIFdDCCA1ygAwIBAgIPAWdfJ9b+euPkrL4JWwWeMA0GCSqGSIb3DQEBCwUAMEQx\r\n+CzAJBgNVBAYTAkZJMRowGAYDVQQKDBFUZWxpYSBGaW5sYW5kIE95ajEZMBcGA1UE\r\n+AwwQVGVsaWEgUm9vdCBDQSB2MjAeFw0xODExMjkxMTU1NTRaFw00MzExMjkxMTU1\r\n+NTRaMEQxCzAJBgNVBAYTAkZJMRowGAYDVQQKDBFUZWxpYSBGaW5sYW5kIE95ajEZ\r\n+MBcGA1UEAwwQVGVsaWEgUm9vdCBDQSB2MjCCAiIwDQYJKoZIhvcNAQEBBQADggIP\r\n+ADCCAgoCggIBALLQPwe84nvQa5n44ndp586dpAO8gm2h\/oFlH0wnrI4AuhZ76zBq\r\n+AMCzdGh+sq\/H1WKzej9Qyow2RCRj0jbpDIX2Q3bVTKFgcmfiKDOlyzG4OiIjNLh9\r\n+vVYiQJ3q9HsDrWj8soFPmNB06o3lfc1jw6P23pLCWBnglrvFxKk9pXSW\/q\/5iaq9\r\n+lRdU2HhE8Qx3FZLgmEKnpNaqIJLNwaCzlrI6hEKNfdWV5Nbb6WLEWLN5xYzTNTOD\r\n+n3WhUidhOPFZPY5Q4L15POdslv5e2QJltI5c0BE0312\/UqeBAMN\/mUWZFdUXyApT\r\n+7GPzmX3MaRKGwhfwAZ6\/hLzRUssbkmbOpFPlob\/E2wnW5olWK8jjfN7j\/4nlNW4o\r\n+6GwLI1GpJQXrSPjdscr6bAhR77cYbETKJuFzxokGgeWKrLDiKca5JLNrRBH0pUPC\r\n+TEPlcDaMtjNXepUugqD0XBCzYYP2AgWGLnwtbNwDRm41k9V6lS\/eINhbfpSQBGq6\r\n+WT0EBXWdN6IOLj3rwaRSg\/7Qa9RmjtzG6RJOHSpXqhC8fF6CfaamyfItufUXJ63R\r\n+DolUK5X6wK0dmBR4M0KGCqlztft0DbcbMBnEWg4cJ7faGND\/isgFuvGqHKI3t+ZI\r\n+pEYslOqodmJHixBTB0hXbOKSTbauBcvcwUpej6w9GU7C7WB1K9vBykLVAgMBAAGj\r\n+YzBhMB8GA1UdIwQYMBaAFHKs5DN5qkWH9v2sHZ7Wxy+G2CQ5MB0GA1UdDgQWBBRy\r\n+rOQzeapFh\/b9rB2e1scvhtgkOTAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH\/BAUw\r\n+AwEB\/zANBgkqhkiG9w0BAQsFAAOCAgEAoDtZpwmUPjaE0n4vOaWWl\/oRrfxn83EJ\r\n+8rKJhGdEr7nv7ZbsnGTbMjBvZ5qsfl+yqwE2foH65IRe0qw24GtixX1LDoJt0nZi\r\n+0f6X+J8wfBj5tFJ3gh1229MdqfDBmgC9bXXYfef6xzijnHDoRnkDry5023X4blMM\r\n+A8iZGok1GTzTyVR8qPAs5m4HeW9q4ebqkYJpCh3DflminmtGFZhb069GHWLIzoBS\r\n+SRE\/yQQSwxN8PzuKlts8oB4KtItUsiRnDe+Cy748fdHif64W1lZYudogsYMVoe+K\r\n+TTJvQS8TUoKU1xrBeKJR3Stwbbca+few4GeXVtt8YVMJAygCQMez2P2ccGrGKMOF\r\n+6eLtGpOg3kuYooQ+BXcBlj37tCAPnHICehIv1aO6UXivKitEZU61\/Qrowc15h2Er\r\n+3oBXRb9n8ZuRXqWk7FlIEA04x7D6w0RtBPV4UBySllva9bguulvP5fBqnUsvWHMt\r\n+Ty3EHD70sz+rFQ47GUGKpMFXEmZxTPpT41frYpUJnlTd0cI8Vzy9OK2YZLe4A5pT\r\n+VmBds9hCG1xLEooc6+t9xnppxyd\/pPiL8uSUZodL6ZQHCRJ5irLrdATczvREWeAW\r\n+ysUsWNc8e89ihmpQfTU2Zqf7N+cox9jQraVplI\/owd8k+BsHMYeB2F326CjYSlKA\r\n+rBPuUBQemMc=\n+-----END CERTIFICATE-----\n","filename":"src\/java.base\/share\/data\/cacerts\/teliarootcav2","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -1,1 +1,1 @@\n-File-Date: 2023-08-02\n+File-Date: 2023-10-16\n@@ -44883,0 +44883,5 @@\n+Subtag: Chis\n+Description: Chisoi\n+Added: 2023-10-16\n+%%\n+Type: script\n@@ -44978,0 +44983,5 @@\n+Subtag: Gara\n+Description: Garay\n+Added: 2023-10-16\n+%%\n+Type: script\n@@ -45023,0 +45033,5 @@\n+Subtag: Gukh\n+Description: Gurung Khema\n+Added: 2023-10-16\n+%%\n+Type: script\n@@ -45193,0 +45208,5 @@\n+Subtag: Krai\n+Description: Kirat Rai\n+Added: 2023-10-16\n+%%\n+Type: script\n@@ -45440,0 +45460,5 @@\n+Subtag: Onao\n+Description: Ol Onal\n+Added: 2023-10-16\n+%%\n+Type: script\n@@ -45619,0 +45644,5 @@\n+Subtag: Sidt\n+Description: Sidetic\n+Added: 2023-10-16\n+%%\n+Type: script\n@@ -45722,0 +45752,5 @@\n+Subtag: Tayo\n+Description: Tai Yo\n+Added: 2023-10-16\n+%%\n+Type: script\n@@ -45770,0 +45805,10 @@\n+Subtag: Todr\n+Description: Todhri\n+Added: 2023-10-16\n+%%\n+Type: script\n+Subtag: Tols\n+Description: Tolong Siki\n+Added: 2023-10-16\n+%%\n+Type: script\n@@ -45775,0 +45820,5 @@\n+Subtag: Tutg\n+Description: Tulu-Tigalari\n+Added: 2023-10-16\n+%%\n+Type: script\n","filename":"src\/java.base\/share\/data\/lsrdata\/language-subtag-registry.txt","additions":51,"deletions":1,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -166,1 +166,1 @@\n-grant codeBase \"jrt:\/jdk.internal.vm.compiler\" {\n+grant codeBase \"jrt:\/jdk.graal.compiler\" {\n@@ -170,12 +170,0 @@\n-grant codeBase \"jrt:\/jdk.internal.vm.compiler.management\" {\n-    permission java.lang.RuntimePermission \"accessClassInPackage.jdk.internal.vm.compiler.collections\";\n-    permission java.lang.RuntimePermission \"accessClassInPackage.jdk.vm.ci.runtime\";\n-    permission java.lang.RuntimePermission \"accessClassInPackage.jdk.vm.ci.services\";\n-    permission java.lang.RuntimePermission \"accessClassInPackage.org.graalvm.compiler.core.common\";\n-    permission java.lang.RuntimePermission \"accessClassInPackage.org.graalvm.compiler.debug\";\n-    permission java.lang.RuntimePermission \"accessClassInPackage.org.graalvm.compiler.hotspot\";\n-    permission java.lang.RuntimePermission \"accessClassInPackage.org.graalvm.compiler.options\";\n-    permission java.lang.RuntimePermission \"accessClassInPackage.org.graalvm.compiler.phases.common.jmx\";\n-    permission java.lang.RuntimePermission \"accessClassInPackage.org.graalvm.compiler.serviceprovider\";\n-};\n-\n","filename":"src\/java.base\/share\/lib\/security\/default.policy","additions":1,"deletions":13,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -524,0 +524,14 @@\n+\\f[V]--enable-native-access\\f[R] \\f[I]module\\f[R][\\f[V],\\f[R]\\f[I]module\\f[R]...]\n+Native access involves access to code or data outside the Java runtime.\n+This is generally unsafe and, if done incorrectly, might crash the JVM\n+or result in memory corruption.\n+Methods that provide native access are restricted, and by default their\n+use causes warnings.\n+This option allows code in the specified modules to use restricted\n+methods without warnings.\n+\\f[I]module\\f[R] can be \\f[V]ALL-UNNAMED\\f[R] to indicate code on the\n+class path.\n+When this option is present, any use of restricted methods by code\n+outside the specified modules causes an\n+\\f[V]IllegalCallerException\\f[R].\n+.TP\n@@ -533,4 +547,5 @@\n-Specifies where to find application modules with a list of path elements.\n-The elements of a module path can be a file path to a module or a directory\n-containing modules. Each module is either a modular JAR or an\n-exploded-module directory.\n+Specifies where to find application modules with a list of path\n+elements.\n+The elements of a module path can be a file path to a module or a\n+directory containing modules.\n+Each module is either a modular JAR or an exploded-module directory.\n@@ -539,2 +554,2 @@\n-On Windows, semicolons (\\f[V];\\f[R]) separate path elements in this list;\n-on other platforms it is a colon (\\f[V]:\\f[R]).\n+On Windows, semicolons (\\f[V];\\f[R]) separate path elements in this\n+list; on other platforms it is a colon (\\f[V]:\\f[R]).\n@@ -544,5 +559,5 @@\n-Specifies where to find module replacements of upgradeable modules in the\n-runtime image with a list of path elements.\n-The elements of a module path can be a file path to a module or a directory\n-containing modules. Each module is either a modular JAR or an\n-exploded-module directory.\n+Specifies where to find module replacements of upgradeable modules in\n+the runtime image with a list of path elements.\n+The elements of a module path can be a file path to a module or a\n+directory containing modules.\n+Each module is either a modular JAR or an exploded-module directory.\n@@ -551,2 +566,2 @@\n-On Windows, semicolons (\\f[V];\\f[R]) separate path elements in this list;\n-on other platforms it is a colon (\\f[V]:\\f[R]).\n+On Windows, semicolons (\\f[V];\\f[R]) separate path elements in this\n+list; on other platforms it is a colon (\\f[V]:\\f[R]).\n@@ -557,1 +572,1 @@\n-\\f[I]module\\f[R] also can be \\f[V]ALL-DEFAULT\\f[R],\n+\\f[I]module\\f[R] can also be \\f[V]ALL-DEFAULT\\f[R],\n@@ -1119,1 +1134,2 @@\n-\\f[I]target-module\\f[R] can be all unnamed to read all unnamed modules.\n+\\f[I]target-module\\f[R] can be \\f[V]ALL-UNNAMED\\f[R] to read all unnamed\n+modules.\n@@ -1124,2 +1140,2 @@\n-The \\f[I]target-module\\f[R] can be all unnamed to export to all unnamed\n-modules.\n+\\f[I]target-module\\f[R] can be \\f[V]ALL-UNNAMED\\f[R] to export to all\n+unnamed modules.\n@@ -1307,0 +1323,1 @@\n+Multiple parameters can be specified by separating them with a comma.\n@@ -1372,3 +1389,0 @@\n-.PP\n-You can specify values for multiple parameters by separating them with a\n-comma.\n@@ -1661,0 +1675,3 @@\n+.PP\n+If %p and\/or %t is specified in the filename, it expands to the\n+JVM\\[aq]s PID and the current timestamp, respectively.\n@@ -1815,13 +1832,0 @@\n-\\f[V]-XX:+UseHugeTLBFS\\f[R]\n-\\f[B]Linux only:\\f[R] This option is the equivalent of specifying\n-\\f[V]-XX:+UseLargePages\\f[R].\n-This option is disabled by default.\n-This option pre-allocates all large pages up-front, when memory is\n-reserved; consequently the JVM can\\[aq]t dynamically grow or shrink\n-large pages memory areas; see \\f[V]-XX:UseTransparentHugePages\\f[R] if\n-you want this behavior.\n-.RS\n-.PP\n-See \\f[B]Large Pages\\f[R].\n-.RE\n-.TP\n@@ -2175,16 +2179,0 @@\n-Specify each method with the full class name (including the packages and\n-subpackages).\n-For example, to compile only the \\f[V]length()\\f[R] method of the\n-\\f[V]String\\f[R] class and the \\f[V]size()\\f[R] method of the\n-\\f[V]List\\f[R] class, use the following:\n-.RS\n-.RS\n-.PP\n-\\f[V]-XX:CompileOnly=java\/lang\/String.length,java\/util\/List.size\\f[R]\n-.RE\n-.PP\n-Note that the full class name is specified, including all packages and\n-subpackages separated by a slash (\\f[V]\/\\f[R]).\n-For easier cut and paste operations, it\\[aq]s also possible to use the\n-method name format produced by the \\f[V]-XX:+PrintCompilation\\f[R] and\n-\\f[V]-XX:+LogCompilation\\f[R] options:\n@@ -2193,7 +2181,1 @@\n-\\f[V]-XX:CompileOnly=java.lang.String::length,java.util.List::size\\f[R]\n-.RE\n-.PP\n-Although wildcards aren\\[aq]t supported, you can specify only the class\n-or package name to compile all methods in that class or package, as well\n-as specify just the method to compile methods with this name in any\n-class:\n+\\f[V]-XX:CompileOnly=method1,method2,...,methodN\\f[R] is an alias for:\n@@ -2203,3 +2185,4 @@\n--XX:CompileOnly=java\/lang\/String\n--XX:CompileOnly=java\/lang\n--XX:CompileOnly=.length\n+-XX:CompileCommand=compileonly,method1\n+-XX:CompileCommand=compileonly,method2\n+\\&...\n+-XX:CompileCommand=compileonly,methodN\n@@ -3658,8 +3641,0 @@\n-\\f[V]-XX:+UseSHM\\f[R]\n-\\f[B]Linux only:\\f[R] Enables the JVM to use shared memory to set up\n-large pages.\n-.RS\n-.PP\n-See \\f[B]Large Pages\\f[R] for setting up large pages.\n-.RE\n-.TP\n@@ -3818,0 +3793,13 @@\n+.TP\n+\\f[V]-XX:+UseHugeTLBFS\\f[R]\n+\\f[B]Linux only:\\f[R] This option is the equivalent of specifying\n+\\f[V]-XX:+UseLargePages\\f[R].\n+This option is disabled by default.\n+This option pre-allocates all large pages up-front, when memory is\n+reserved; consequently the JVM can\\[aq]t dynamically grow or shrink\n+large pages memory areas; see \\f[V]-XX:UseTransparentHugePages\\f[R] if\n+you want this behavior.\n+.TP\n+\\f[V]-XX:+UseSHM\\f[R]\n+\\f[B]Linux only:\\f[R] Enables the JVM to use shared memory to set up\n+large pages.\n@@ -4918,14 +4906,0 @@\n-.PP\n-When using the option \\f[V]-XX:+UseSHM\\f[R] to enable large pages you\n-also need to make sure the \\f[V]SHMMAX\\f[R] parameter is configured to\n-allow large enough shared memory segments to be allocated.\n-To allow a maximum shared segment of 8 GB, login as \\f[V]root\\f[R] and\n-run:\n-.RS\n-.PP\n-\\f[V]# echo 8589934592 > \/proc\/sys\/kernel\/shmmax\\f[R]\n-.RE\n-.PP\n-In some environments this is not needed since the default value is large\n-enough, but it is important to make sure the value is large enough to\n-fit the amount of memory intended to be backed by large pages.\n@@ -5098,0 +5072,12 @@\n+.PP\n+By default, when the \\f[V]-Xshare:dump\\f[R] option is used, the JVM runs\n+in interpreter-only mode (as if the \\f[V]-Xint\\f[R] option were\n+specified).\n+This is required for generating deterministic output in the shared\n+archive file.\n+I.e., the exact same archive will be generated, bit-for-bit, every time\n+you dump it.\n+However, if deterministic output is not needed, and you have a large\n+classlist, you can explicitly add \\f[V]-Xmixed\\f[R] to the command-line\n+to enable the JIT compiler.\n+This will speed up the archive creation.\n","filename":"src\/java.base\/share\/man\/java.1","additions":67,"deletions":81,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include <wchar.h>\n@@ -209,0 +210,20 @@\n+\n+JNIEXPORT jint JNICALL\n+Java_jdk_internal_foreign_abi_fallback_LibFallback_ffi_1sizeof_1short(JNIEnv* env, jclass cls) {\n+  return sizeof(short);\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_jdk_internal_foreign_abi_fallback_LibFallback_ffi_1sizeof_1int(JNIEnv* env, jclass cls) {\n+  return sizeof(int);\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_jdk_internal_foreign_abi_fallback_LibFallback_ffi_1sizeof_1long(JNIEnv* env, jclass cls) {\n+  return sizeof(long);\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_jdk_internal_foreign_abi_fallback_LibFallback_ffi_1sizeof_1wchar(JNIEnv* env, jclass cls) {\n+  return sizeof(wchar_t);\n+}\n","filename":"src\/java.base\/share\/native\/libfallbackLinker\/fallbackLinker.c","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -164,3 +164,0 @@\n-JNIEXPORT int JNICALL\n-NET_SocketAvailable(int fd, int *pbytes);\n-\n@@ -176,6 +173,0 @@\n-JNIEXPORT int JNICALL\n-NET_MapSocketOption(jint cmd, int *level, int *optname);\n-\n-JNIEXPORT int JNICALL\n-NET_MapSocketOptionV6(jint cmd, int *level, int *optname);\n-\n","filename":"src\/java.base\/share\/native\/libnet\/net_util.h","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,6 @@\n-import java.nio.file.attribute.*;\n-import java.util.concurrent.TimeUnit;\n-import java.util.Set;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.FileTime;\n+import java.nio.file.attribute.GroupPrincipal;\n+import java.nio.file.attribute.PosixFileAttributes;\n+import java.nio.file.attribute.PosixFilePermission;\n+import java.nio.file.attribute.UserPrincipal;\n@@ -32,0 +35,2 @@\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n@@ -55,0 +60,1 @@\n+    private long    st_birthtime_nsec;\n@@ -161,1 +167,1 @@\n-            return FileTime.from(st_birthtime_sec, TimeUnit.SECONDS);\n+            return toFileTime(st_birthtime_sec, st_birthtime_nsec);\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixFileAttributes.java","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -488,1 +488,1 @@\n- * The following functions are common on Solaris, Linux and AIX.\n+ * The following functions are for Linux\n@@ -491,1 +491,1 @@\n-#if defined (__linux__) || defined(_AIX)\n+#if defined (__linux__)\n@@ -494,4 +494,6 @@\n- * Returns the children of the requested pid and optionally each parent and\n- * start time.\n- * Reads \/proc and accumulates any process who parent pid matches.\n- * The resulting pids are stored into the array of longs.\n+ * Return pids of active processes, and optionally parent pids and\n+ * start times for each process.\n+ * For a specific non-zero pid, only the direct children are returned.\n+ * If the pid is zero, all active processes are returned.\n+ * Reads \/proc and accumulates any process following the rules above.\n+ * The resulting pids are stored into an array of longs named jarray.\n@@ -499,1 +501,9 @@\n- * If the array is too short, the negative of the desired length is returned.\n+ * If the parentArray is non-null, store also the parent pid.\n+ * In this case the parentArray must have the same length as the result pid array.\n+ * Of course in the case of a given non-zero pid all entries in the parentArray\n+ * will contain this pid, so this array does only make sense in the case of a given\n+ * zero pid.\n+ * If the jstimesArray is non-null, store also the start time of the pid.\n+ * In this case the jstimesArray must have the same length as the result pid array.\n+ * If the array(s) (is|are) too short, excess pids are not stored and\n+ * the desired length is returned.\n@@ -610,1 +620,1 @@\n-#endif \/\/ defined (__linux__) || defined(_AIX)\n+#endif \/\/ defined (__linux__)\n","filename":"src\/java.base\/unix\/native\/libjava\/ProcessHandleImpl_unix.c","additions":18,"deletions":8,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -241,0 +241,5 @@\n+            if (*std_language == NULL) {\n+                free(encoding_variant);\n+                JNU_ThrowOutOfMemoryError(env, NULL);\n+                return 0;\n+            }\n@@ -249,0 +254,5 @@\n+            if (*std_country == NULL) {\n+                free(encoding_variant);\n+                JNU_ThrowOutOfMemoryError(env, NULL);\n+                return 0;\n+            }\n","filename":"src\/java.base\/unix\/native\/libjava\/java_props_md.c","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -94,7 +94,7 @@\n-typedef GProxyResolver* g_proxy_resolver_get_default_func();\n-typedef char** g_proxy_resolver_lookup_func();\n-typedef GSocketConnectable* g_network_address_parse_uri_func();\n-typedef const char* g_network_address_get_hostname_func();\n-typedef unsigned short g_network_address_get_port_func();\n-typedef void g_strfreev_func();\n-typedef void g_clear_error_func();\n+typedef GProxyResolver* g_proxy_resolver_get_default_func(void);\n+typedef char** g_proxy_resolver_lookup_func(GProxyResolver* resolver, char* uri, void *null, GError **error_p);\n+typedef GSocketConnectable* g_network_address_parse_uri_func(char* proxy, unsigned short default_port, GError **error_p);\n+typedef const char* g_network_address_get_hostname_func(GSocketConnectable* conn);\n+typedef unsigned short g_network_address_get_port_func(GSocketConnectable* conn);\n+typedef void g_strfreev_func(char** proxies);\n+typedef void g_clear_error_func(GError **error_p);\n","filename":"src\/java.base\/unix\/native\/libnet\/DefaultProxySelector.c","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include <sys\/ioctl.h>\n@@ -54,12 +53,0 @@\n-#define RESTARTABLE(_cmd, _result) do { \\\n-    do { \\\n-        _result = _cmd; \\\n-    } while((_result == -1) && (errno == EINTR)); \\\n-} while(0)\n-\n-int NET_SocketAvailable(int s, int *pbytes) {\n-    int result;\n-    RESTARTABLE(ioctl(s, FIONREAD, pbytes), result);\n-    return result;\n-}\n-\n@@ -330,66 +317,0 @@\n-\/*\n- * Map the Java level socket option to the platform specific\n- * level and option name.\n- *\/\n-int\n-NET_MapSocketOption(jint cmd, int *level, int *optname) {\n-    static struct {\n-        jint cmd;\n-        int level;\n-        int optname;\n-    } const opts[] = {\n-        { java_net_SocketOptions_TCP_NODELAY,           IPPROTO_TCP,    TCP_NODELAY },\n-        { java_net_SocketOptions_SO_OOBINLINE,          SOL_SOCKET,     SO_OOBINLINE },\n-        { java_net_SocketOptions_SO_LINGER,             SOL_SOCKET,     SO_LINGER },\n-        { java_net_SocketOptions_SO_SNDBUF,             SOL_SOCKET,     SO_SNDBUF },\n-        { java_net_SocketOptions_SO_RCVBUF,             SOL_SOCKET,     SO_RCVBUF },\n-        { java_net_SocketOptions_SO_KEEPALIVE,          SOL_SOCKET,     SO_KEEPALIVE },\n-        { java_net_SocketOptions_SO_REUSEADDR,          SOL_SOCKET,     SO_REUSEADDR },\n-        { java_net_SocketOptions_SO_REUSEPORT,          SOL_SOCKET,     SO_REUSEPORT },\n-        { java_net_SocketOptions_SO_BROADCAST,          SOL_SOCKET,     SO_BROADCAST },\n-        { java_net_SocketOptions_IP_TOS,                IPPROTO_IP,     IP_TOS },\n-        { java_net_SocketOptions_IP_MULTICAST_IF,       IPPROTO_IP,     IP_MULTICAST_IF },\n-        { java_net_SocketOptions_IP_MULTICAST_IF2,      IPPROTO_IP,     IP_MULTICAST_IF },\n-        { java_net_SocketOptions_IP_MULTICAST_LOOP,     IPPROTO_IP,     IP_MULTICAST_LOOP },\n-    };\n-\n-    int i;\n-\n-    if (ipv6_available()) {\n-        switch (cmd) {\n-            \/\/ Different multicast options if IPv6 is enabled\n-            case java_net_SocketOptions_IP_MULTICAST_IF:\n-            case java_net_SocketOptions_IP_MULTICAST_IF2:\n-                *level = IPPROTO_IPV6;\n-                *optname = IPV6_MULTICAST_IF;\n-                return 0;\n-\n-            case java_net_SocketOptions_IP_MULTICAST_LOOP:\n-                *level = IPPROTO_IPV6;\n-                *optname = IPV6_MULTICAST_LOOP;\n-                return 0;\n-#if defined(MACOSX)\n-            \/\/ Map IP_TOS request to IPV6_TCLASS\n-            case java_net_SocketOptions_IP_TOS:\n-                *level = IPPROTO_IPV6;\n-                *optname = IPV6_TCLASS;\n-                return 0;\n-#endif\n-        }\n-    }\n-\n-    \/*\n-     * Map the Java level option to the native level\n-     *\/\n-    for (i=0; i<(int)(sizeof(opts) \/ sizeof(opts[0])); i++) {\n-        if (cmd == opts[i].cmd) {\n-            *level = opts[i].level;\n-            *optname = opts[i].optname;\n-            return 0;\n-        }\n-    }\n-\n-    \/* not found *\/\n-    return -1;\n-}\n-\n","filename":"src\/java.base\/unix\/native\/libnet\/net_util_md.c","additions":0,"deletions":79,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include <sys\/ioctl.h>\n@@ -857,1 +858,4 @@\n-    if (NET_SocketAvailable(fdval(env, fdo), &count) != 0) {\n+    int result;\n+    RESTARTABLE(ioctl(fdval(env, fdo), FIONREAD, &count), result);\n+\n+    if (result != 0) {\n","filename":"src\/java.base\/unix\/native\/libnio\/ch\/Net.c","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+#include <sys\/sysmacros.h> \/\/ makedev macros\n@@ -74,0 +75,92 @@\n+#if defined(__linux__)\n+\/\/ Account for the case where we compile on a system without statx\n+\/\/ support. We still want to ensure we can call statx at runtime\n+\/\/ if the runtime glibc version supports it (>= 2.28). We do this\n+\/\/ by defining binary compatible statx structs in this file and\n+\/\/ not relying on included headers.\n+\n+#ifndef __GLIBC__\n+\/\/ Alpine doesn't know these types, define them\n+typedef unsigned int       __uint32_t;\n+typedef unsigned short     __uint16_t;\n+typedef unsigned long int  __uint64_t;\n+#endif\n+\n+\/*\n+ * Timestamp structure for the timestamps in struct statx.\n+ *\/\n+struct my_statx_timestamp {\n+        int64_t   tv_sec;\n+        __uint32_t  tv_nsec;\n+        int32_t   __reserved;\n+};\n+\n+\/*\n+ * struct statx used by statx system call on >= glibc 2.28\n+ * systems\n+ *\/\n+struct my_statx\n+{\n+  __uint32_t stx_mask;\n+  __uint32_t stx_blksize;\n+  __uint64_t stx_attributes;\n+  __uint32_t stx_nlink;\n+  __uint32_t stx_uid;\n+  __uint32_t stx_gid;\n+  __uint16_t stx_mode;\n+  __uint16_t __statx_pad1[1];\n+  __uint64_t stx_ino;\n+  __uint64_t stx_size;\n+  __uint64_t stx_blocks;\n+  __uint64_t stx_attributes_mask;\n+  struct my_statx_timestamp stx_atime;\n+  struct my_statx_timestamp stx_btime;\n+  struct my_statx_timestamp stx_ctime;\n+  struct my_statx_timestamp stx_mtime;\n+  __uint32_t stx_rdev_major;\n+  __uint32_t stx_rdev_minor;\n+  __uint32_t stx_dev_major;\n+  __uint32_t stx_dev_minor;\n+  __uint64_t __statx_pad2[14];\n+};\n+\n+\/\/ statx masks, flags, constants\n+\n+#ifndef AT_SYMLINK_NOFOLLOW\n+#define AT_SYMLINK_NOFOLLOW 0x100\n+#endif\n+\n+#ifndef AT_STATX_SYNC_AS_STAT\n+#define AT_STATX_SYNC_AS_STAT 0x0000\n+#endif\n+\n+#ifndef AT_EMPTY_PATH\n+#define AT_EMPTY_PATH 0x1000\n+#endif\n+\n+#ifndef STATX_BASIC_STATS\n+#define STATX_BASIC_STATS 0x000007ffU\n+#endif\n+\n+#ifndef STATX_BTIME\n+#define STATX_BTIME 0x00000800U\n+#endif\n+\n+#ifndef STATX_ALL\n+#define STATX_ALL (STATX_BTIME | STATX_BASIC_STATS)\n+#endif\n+\n+#ifndef AT_FDCWD\n+#define AT_FDCWD -100\n+#endif\n+\n+#ifndef RTLD_DEFAULT\n+#define RTLD_DEFAULT RTLD_LOCAL\n+#endif\n+\n+#define NO_FOLLOW_SYMLINK 1\n+#define FOLLOW_SYMLINK 0\n+\n+#endif \/\/ __linux__\n+\n+\n@@ -120,1 +213,1 @@\n-#ifdef _DARWIN_FEATURE_64_BIT_INODE\n+#if defined(_DARWIN_FEATURE_64_BIT_INODE) || defined(__linux__)\n@@ -123,0 +216,3 @@\n+#if defined(__linux__) \/\/ Linux has nsec granularity if supported\n+static jfieldID attrs_st_birthtime_nsec;\n+#endif\n@@ -146,0 +242,4 @@\n+#if defined(__linux__)\n+typedef int statx_func(int dirfd, const char *restrict pathname, int flags,\n+                       unsigned int mask, struct my_statx *restrict statxbuf);\n+#endif\n@@ -155,0 +255,3 @@\n+#if defined(__linux__)\n+static statx_func* my_statx_func = NULL;\n+#endif\n@@ -180,0 +283,7 @@\n+#if defined(__linux__)\n+static int statx_wrapper(int dirfd, const char *restrict pathname, int flags,\n+                         unsigned int mask, struct my_statx *restrict statxbuf) {\n+    return (*my_statx_func)(dirfd, pathname, flags, mask, statxbuf);\n+}\n+#endif\n+\n@@ -232,1 +342,1 @@\n-#ifdef _DARWIN_FEATURE_64_BIT_INODE\n+#if defined(_DARWIN_FEATURE_64_BIT_INODE) || defined(__linux__)\n@@ -236,0 +346,4 @@\n+#if defined (__linux__) \/\/ Linux has nsec granularity\n+    attrs_st_birthtime_nsec = (*env)->GetFieldID(env, clazz, \"st_birthtime_nsec\", \"J\");\n+    CHECK_NULL_RETURN(attrs_st_birthtime_nsec, 0);\n+#endif\n@@ -317,0 +431,6 @@\n+#if defined(__linux__)\n+    my_statx_func = (statx_func*) dlsym(RTLD_DEFAULT, \"statx\");\n+    if (my_statx_func != NULL) {\n+        capabilities |= sun_nio_fs_UnixNativeDispatcher_SUPPORTS_BIRTHTIME;\n+    }\n+#endif\n@@ -493,0 +613,27 @@\n+#if defined(__linux__)\n+\/**\n+ * Copy statx members into sun.nio.fs.UnixFileAttributes\n+ *\/\n+static void copy_statx_attributes(JNIEnv* env, struct my_statx* buf, jobject attrs) {\n+    (*env)->SetIntField(env, attrs, attrs_st_mode, (jint)buf->stx_mode);\n+    (*env)->SetLongField(env, attrs, attrs_st_ino, (jlong)buf->stx_ino);\n+    (*env)->SetIntField(env, attrs, attrs_st_nlink, (jint)buf->stx_nlink);\n+    (*env)->SetIntField(env, attrs, attrs_st_uid, (jint)buf->stx_uid);\n+    (*env)->SetIntField(env, attrs, attrs_st_gid, (jint)buf->stx_gid);\n+    (*env)->SetLongField(env, attrs, attrs_st_size, (jlong)buf->stx_size);\n+    (*env)->SetLongField(env, attrs, attrs_st_atime_sec, (jlong)buf->stx_atime.tv_sec);\n+    (*env)->SetLongField(env, attrs, attrs_st_mtime_sec, (jlong)buf->stx_mtime.tv_sec);\n+    (*env)->SetLongField(env, attrs, attrs_st_ctime_sec, (jlong)buf->stx_ctime.tv_sec);\n+    (*env)->SetLongField(env, attrs, attrs_st_birthtime_sec, (jlong)buf->stx_btime.tv_sec);\n+    (*env)->SetLongField(env, attrs, attrs_st_birthtime_nsec, (jlong)buf->stx_btime.tv_nsec);\n+    (*env)->SetLongField(env, attrs, attrs_st_atime_nsec, (jlong)buf->stx_atime.tv_nsec);\n+    (*env)->SetLongField(env, attrs, attrs_st_mtime_nsec, (jlong)buf->stx_mtime.tv_nsec);\n+    (*env)->SetLongField(env, attrs, attrs_st_ctime_nsec, (jlong)buf->stx_ctime.tv_nsec);\n+    \/\/ convert statx major:minor to dev_t using makedev\n+    dev_t dev = makedev(buf->stx_dev_major, buf->stx_dev_minor);\n+    dev_t rdev = makedev(buf->stx_rdev_major, buf->stx_rdev_minor);\n+    (*env)->SetLongField(env, attrs, attrs_st_dev, (jlong)dev);\n+    (*env)->SetLongField(env, attrs, attrs_st_rdev, (jlong)rdev);\n+}\n+#endif\n+\n@@ -496,1 +643,1 @@\n-static void prepAttributes(JNIEnv* env, struct stat64* buf, jobject attrs) {\n+static void copy_stat64_attributes(JNIEnv* env, struct stat64* buf, jobject attrs) {\n@@ -511,0 +658,1 @@\n+    \/\/ rely on default value of 0 for st_birthtime_nsec field on Darwin\n@@ -531,1 +679,16 @@\n-\n+#if defined(__linux__)\n+    struct my_statx statx_buf;\n+    int flags = AT_STATX_SYNC_AS_STAT;\n+    unsigned int mask = STATX_ALL;\n+\n+    if (my_statx_func != NULL) {\n+        \/\/ Prefer statx over stat64 on Linux if it's available\n+        RESTARTABLE(statx_wrapper(AT_FDCWD, path, flags, mask, &statx_buf), err);\n+        if (err == 0) {\n+            copy_statx_attributes(env, &statx_buf, attrs);\n+            return 0;\n+        } else {\n+            return errno;\n+        }\n+    }\n+#endif\n@@ -534,1 +697,1 @@\n-        prepAttributes(env, &buf, attrs);\n+        copy_stat64_attributes(env, &buf, attrs);\n@@ -548,1 +711,17 @@\n-\n+#if defined(__linux__)\n+    struct my_statx statx_buf;\n+    int flags = AT_STATX_SYNC_AS_STAT | AT_SYMLINK_NOFOLLOW;\n+    unsigned int mask = STATX_ALL;\n+\n+    if (my_statx_func != NULL) {\n+        \/\/ Prefer statx over stat64 on Linux if it's available\n+        RESTARTABLE(statx_wrapper(AT_FDCWD, path, flags, mask, &statx_buf), err);\n+        if (err == 0) {\n+            copy_statx_attributes(env, &statx_buf, attrs);\n+        } else {\n+            throwUnixException(env, errno);\n+        }\n+        \/\/ statx was available, so return now\n+        return;\n+    }\n+#endif\n@@ -553,1 +732,1 @@\n-        prepAttributes(env, &buf, attrs);\n+        copy_stat64_attributes(env, &buf, attrs);\n@@ -563,1 +742,18 @@\n-\n+#if defined(__linux__)\n+    struct my_statx statx_buf;\n+    int flags = AT_EMPTY_PATH | AT_STATX_SYNC_AS_STAT;\n+    unsigned int mask = STATX_ALL;\n+\n+    if (my_statx_func != NULL) {\n+        \/\/ statx supports FD use via dirfd iff pathname is an empty string and the\n+        \/\/ AT_EMPTY_PATH flag is specified in flags\n+        RESTARTABLE(statx_wrapper((int)fd, \"\", flags, mask, &statx_buf), err);\n+        if (err == 0) {\n+            copy_statx_attributes(env, &statx_buf, attrs);\n+        } else {\n+            throwUnixException(env, errno);\n+        }\n+        \/\/ statx was available, so return now\n+        return;\n+    }\n+#endif\n@@ -568,1 +764,1 @@\n-        prepAttributes(env, &buf, attrs);\n+        copy_stat64_attributes(env, &buf, attrs);\n@@ -579,0 +775,20 @@\n+#if defined(__linux__)\n+    struct my_statx statx_buf;\n+    int flags = AT_STATX_SYNC_AS_STAT;\n+    unsigned int mask = STATX_ALL;\n+\n+    if (my_statx_func != NULL) {\n+        \/\/ Prefer statx over stat64 on Linux if it's available\n+        if (((int)flag & AT_SYMLINK_NOFOLLOW) > 0) { \/\/ flag set in java code\n+            flags |= AT_SYMLINK_NOFOLLOW;\n+        }\n+        RESTARTABLE(statx_wrapper((int)dfd, path, flags, mask, &statx_buf), err);\n+        if (err == 0) {\n+            copy_statx_attributes(env, &statx_buf, attrs);\n+        } else {\n+            throwUnixException(env, errno);\n+        }\n+        \/\/ statx was available, so return now\n+        return;\n+    }\n+#endif\n@@ -588,1 +804,1 @@\n-        prepAttributes(env, &buf, attrs);\n+        copy_stat64_attributes(env, &buf, attrs);\n","filename":"src\/java.base\/unix\/native\/libnio\/fs\/UnixNativeDispatcher.c","additions":226,"deletions":10,"binary":false,"changes":236,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -327,0 +327,4 @@\n+        if (cptr == NULL) {\n+            printf(\"*** cannot allocate memory\\n\");\n+            doabort();\n+        }\n","filename":"src\/java.base\/windows\/native\/libjli\/cmdtoargs.c","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -242,1 +242,1 @@\n-        _snwprintf(url, sizeof(url) - 1, L\"%s:\/\/%s\", lpProto, lpHost);\n+        swprintf(url, MAX_STR_LEN, L\"%s:\/\/%s\", lpProto, lpHost);\n","filename":"src\/java.base\/windows\/native\/libnet\/DefaultProxySelector.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -228,69 +228,0 @@\n-\/* call NET_MapSocketOptionV6 for the IPv6 fd only\n- * and NET_MapSocketOption for the IPv4 fd\n- *\/\n-JNIEXPORT int JNICALL\n-NET_MapSocketOptionV6(jint cmd, int *level, int *optname) {\n-\n-    switch (cmd) {\n-        case java_net_SocketOptions_IP_MULTICAST_IF:\n-        case java_net_SocketOptions_IP_MULTICAST_IF2:\n-            *level = IPPROTO_IPV6;\n-            *optname = IPV6_MULTICAST_IF;\n-            return 0;\n-\n-        case java_net_SocketOptions_IP_MULTICAST_LOOP:\n-            *level = IPPROTO_IPV6;\n-            *optname = IPV6_MULTICAST_LOOP;\n-            return 0;\n-    }\n-    return NET_MapSocketOption (cmd, level, optname);\n-}\n-\n-\/*\n- * Map the Java level socket option to the platform specific\n- * level and option name.\n- *\/\n-\n-JNIEXPORT int JNICALL\n-NET_MapSocketOption(jint cmd, int *level, int *optname) {\n-\n-    typedef struct {\n-        jint cmd;\n-        int level;\n-        int optname;\n-    } sockopts;\n-\n-    static sockopts opts[] = {\n-        { java_net_SocketOptions_TCP_NODELAY,   IPPROTO_TCP,    TCP_NODELAY },\n-        { java_net_SocketOptions_SO_OOBINLINE,  SOL_SOCKET,     SO_OOBINLINE },\n-        { java_net_SocketOptions_SO_LINGER,     SOL_SOCKET,     SO_LINGER },\n-        { java_net_SocketOptions_SO_SNDBUF,     SOL_SOCKET,     SO_SNDBUF },\n-        { java_net_SocketOptions_SO_RCVBUF,     SOL_SOCKET,     SO_RCVBUF },\n-        { java_net_SocketOptions_SO_KEEPALIVE,  SOL_SOCKET,     SO_KEEPALIVE },\n-        { java_net_SocketOptions_SO_REUSEADDR,  SOL_SOCKET,     SO_REUSEADDR },\n-        { java_net_SocketOptions_SO_BROADCAST,  SOL_SOCKET,     SO_BROADCAST },\n-        { java_net_SocketOptions_IP_MULTICAST_IF,   IPPROTO_IP, IP_MULTICAST_IF },\n-        { java_net_SocketOptions_IP_MULTICAST_LOOP, IPPROTO_IP, IP_MULTICAST_LOOP },\n-        { java_net_SocketOptions_IP_TOS,            IPPROTO_IP, IP_TOS },\n-\n-    };\n-\n-\n-    int i;\n-\n-    \/*\n-     * Map the Java level option to the native level\n-     *\/\n-    for (i=0; i<(int)(sizeof(opts) \/ sizeof(opts[0])); i++) {\n-        if (cmd == opts[i].cmd) {\n-            *level = opts[i].level;\n-            *optname = opts[i].optname;\n-            return 0;\n-        }\n-    }\n-\n-    \/* not found *\/\n-    return -1;\n-}\n-\n-\n@@ -395,11 +326,0 @@\n-JNIEXPORT int JNICALL\n-NET_SocketAvailable(int s, int *pbytes) {\n-    u_long arg;\n-    if (ioctlsocket((SOCKET)s, FIONREAD, &arg) == SOCKET_ERROR) {\n-        return -1;\n-    } else {\n-        *pbytes = (int) arg;\n-        return 0;\n-    }\n-}\n-\n@@ -407,1 +327,1 @@\n- * Sets SO_ECLUSIVEADDRUSE if SO_REUSEADDR is not already set.\n+ * Sets SO_EXCLUSIVEADDRUSE if SO_REUSEADDR is not already set.\n","filename":"src\/java.base\/windows\/native\/libnet\/net_util_md.c","additions":1,"deletions":81,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -92,1 +92,1 @@\n-        handleSocketError(env, WSAGetLastError());\n+        NET_ThrowNew(env, WSAGetLastError(), \"connect\");\n@@ -139,1 +139,4 @@\n-            } else return handleSocketError(env, theErr);\n+            } else {\n+                NET_ThrowNew(env, theErr, \"recvfrom\");\n+                return IOS_THROWN;\n+            }\n@@ -163,1 +166,2 @@\n-        return handleSocketError(env, (jint)WSAGetLastError());\n+        NET_ThrowNew(env, (jint)WSAGetLastError(), \"sendto\");\n+        return IOS_THROWN;\n","filename":"src\/java.base\/windows\/native\/libnio\/ch\/DatagramChannelImpl.c","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -152,2 +152,1 @@\n-        int error = WSAGetLastError();\n-        handleSocketError(env, (jint)error);\n+        NET_ThrowNew(env, WSAGetLastError(), \"ioctlsocket\");\n","filename":"src\/java.base\/windows\/native\/libnio\/ch\/IOUtil.c","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -80,6 +80,0 @@\n-jint handleSocketError(JNIEnv *env, int errorValue)\n-{\n-    NET_ThrowNew(env, errorValue, NULL);\n-    return IOS_THROWN;\n-}\n-\n@@ -395,1 +389,1 @@\n-        handleSocketError(env, WSAGetLastError());\n+        NET_ThrowNew(env, WSAGetLastError(), \"getsockopt\");\n@@ -439,1 +433,1 @@\n-        handleSocketError(env, WSAGetLastError());\n+        NET_ThrowNew(env, WSAGetLastError(), \"setsocketopt\");\n@@ -470,1 +464,1 @@\n-        handleSocketError(env, WSAGetLastError());\n+        NET_ThrowNew(env, WSAGetLastError(), \"setsocketopt\");\n@@ -492,1 +486,1 @@\n-        handleSocketError(env, WSAGetLastError());\n+        NET_ThrowNew(env, WSAGetLastError(), \"setsockopt\");\n@@ -545,1 +539,1 @@\n-        handleSocketError(env, WSAGetLastError());\n+        NET_ThrowNew(env, WSAGetLastError(), \"setsockopt\");\n@@ -557,1 +551,1 @@\n-        handleSocketError(env, WSAGetLastError());\n+        NET_ThrowNew(env, WSAGetLastError(), \"setsocketopt to block or unblock source\");\n@@ -574,1 +568,1 @@\n-        handleSocketError(env, WSAGetLastError());\n+        NET_ThrowNew(env, WSAGetLastError(), \"setsockopt\");\n@@ -587,1 +581,1 @@\n-        handleSocketError(env, WSAGetLastError());\n+        NET_ThrowNew(env, WSAGetLastError(), \"getsockopt\");\n@@ -603,1 +597,1 @@\n-        handleSocketError(env, WSAGetLastError());\n+        NET_ThrowNew(env, WSAGetLastError(), \"setsockopt\");\n@@ -616,1 +610,1 @@\n-        handleSocketError(env, WSAGetLastError());\n+        NET_ThrowNew(env, WSAGetLastError(), \"getsockopt\");\n@@ -634,3 +628,3 @@\n-    int count = 0;\n-    if (NET_SocketAvailable(fdval(env, fdo), &count) != 0) {\n-        handleSocketError(env, WSAGetLastError());\n+    u_long arg;\n+    if (ioctlsocket((SOCKET) fdval(env, fdo), FIONREAD, &arg) == SOCKET_ERROR) {\n+        NET_ThrowNew(env, WSAGetLastError(), \"ioctlsocket\");\n@@ -639,1 +633,1 @@\n-    return (jint) count;\n+    return (jint) arg;\n@@ -670,1 +664,1 @@\n-        handleSocketError(env, WSAGetLastError());\n+        NET_ThrowNew(env, WSAGetLastError(), \"select\");\n@@ -710,1 +704,1 @@\n-        handleSocketError(env, WSAGetLastError());\n+        NET_ThrowNew(env, WSAGetLastError(), \"select\");\n@@ -730,1 +724,1 @@\n-            handleSocketError(env, optError);\n+            NET_ThrowNew(env, optError, \"getsockopt\");\n","filename":"src\/java.base\/windows\/native\/libnio\/ch\/Net.c","additions":17,"deletions":23,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -121,0 +121,3 @@\n+            if (infoPtr == NULL) {\n+                return JNI_FALSE;\n+            }\n@@ -161,1 +164,2 @@\n-        return handleSocketError(env, WSAGetLastError());\n+        NET_ThrowNew(env, WSAGetLastError(), \"WSASocketW\");\n+        return IOS_THROWN;\n","filename":"src\/java.base\/windows\/native\/libnio\/ch\/UnixDomainSockets.c","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,0 @@\n-jint handleSocketError(JNIEnv *env, int errorValue);\n","filename":"src\/java.base\/windows\/native\/libnio\/ch\/nio_util.h","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -128,10 +128,1 @@\n-                            metalEnabled = MTLGraphicsConfig.isMetalAvailable();\n-                        }\n-                    } else if (metalEnabled && !oglEnabled) {\n-                        \/\/ Check whether Metal framework is available\n-                        if (!MTLGraphicsConfig.isMetalAvailable()) {\n-                            if (metalVerbose) {\n-                                System.out.println(\"Could not enable Metal pipeline (Metal framework not available)\");\n-                            }\n-                            metalEnabled = false;\n-                            oglEnabled = CGLGraphicsConfig.isCGLAvailable();\n+                            metalEnabled = true;\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/java2d\/MacOSFlags.java","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -75,1 +75,0 @@\n-    private static boolean mtlAvailable;\n@@ -92,1 +91,0 @@\n-    private static native boolean isMetalFrameworkAvailable();\n@@ -102,4 +100,0 @@\n-    static {\n-        mtlAvailable = isMetalFrameworkAvailable();\n-    }\n-\n@@ -136,4 +130,0 @@\n-        if (!mtlAvailable) {\n-            return null;\n-        }\n-\n@@ -174,4 +164,0 @@\n-    public static boolean isMetalAvailable() {\n-        return mtlAvailable;\n-    }\n-\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/java2d\/metal\/MTLGraphicsConfig.java","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,1 @@\n+static NSInteger architecture = -1;\n@@ -61,1 +62,11 @@\n-static BOOL isValidDisplayMode(CGDisplayModeRef mode){\n+static BOOL isValidDisplayMode(CGDisplayModeRef mode) {\n+    \/\/ Workaround for apple bug FB13261205, since it only affects arm based macs\n+    \/\/ and arm support started with macOS 11 ignore the workaround for previous versions\n+    if (@available(macOS 11, *)) {\n+        if (architecture == -1) {\n+            architecture = [[NSRunningApplication currentApplication] executableArchitecture];\n+        }\n+        if (architecture == NSBundleExecutableArchitectureARM64) {\n+            return (CGDisplayModeGetPixelWidth(mode) >= 800);\n+        }\n+    }\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/CGraphicsDevice.m","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -99,5 +99,1 @@\n-    if (@available(macOS 10.14, *)) {\n-        sColors[java_awt_SystemColor_CONTROL_HIGHLIGHT] =        [NSColor selectedContentBackgroundColor];\n-    } else {\n-        sColors[java_awt_SystemColor_CONTROL_HIGHLIGHT] =        [NSColor alternateSelectedControlColor];\n-    }\n+    sColors[java_awt_SystemColor_CONTROL_HIGHLIGHT] =        [NSColor selectedContentBackgroundColor];\n@@ -124,5 +120,1 @@\n-    if (@available(macOS 10.14, *)) {\n-        appleColors[sun_lwawt_macosx_LWCToolkit_CELL_HIGHLIGHT_COLOR] =               [NSColor controlAccentColor];\n-    } else {\n-        appleColors[sun_lwawt_macosx_LWCToolkit_CELL_HIGHLIGHT_COLOR] =               [NSColor keyboardFocusIndicatorColor];\n-    }\n+    appleColors[sun_lwawt_macosx_LWCToolkit_CELL_HIGHLIGHT_COLOR] =               [NSColor controlAccentColor];\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/CSystemColors.m","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -87,4 +87,1 @@\n-    if (@available(macOS 10.13, *)) {\n-        return NSAccessibilityTabButtonSubrole;\n-    }\n-    return NSAccessibilityUnknownSubrole;\n+    return NSAccessibilityTabButtonSubrole;\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/a11y\/TabButtonAccessibility.m","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -57,16 +57,0 @@\n-JNIEXPORT jboolean JNICALL\n-Java_sun_java2d_metal_MTLGraphicsConfig_isMetalFrameworkAvailable\n-    (JNIEnv *env, jclass mtlgc)\n-{\n-    jboolean metalSupported = JNI_FALSE;\n-\n-    \/\/ It is guaranteed that metal supported GPU is available since macOS 10.14\n-    if (@available(macOS 10.14, *)) {\n-        metalSupported = JNI_TRUE;\n-    }\n-\n-    J2dRlsTraceLn1(J2D_TRACE_INFO, \"MTLGraphicsConfig_isMetalFrameworkAvailable : %d\", metalSupported);\n-\n-    return metalSupported;\n-}\n-\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLGraphicsConfig.m","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -299,0 +299,5 @@\n+    if (mtlsdo == NULL) {\n+        JNU_ThrowOutOfMemoryError(env, \"Initialization of SurfaceData failed.\");\n+        return;\n+    }\n+\n@@ -306,6 +311,1 @@\n-        JNU_ThrowOutOfMemoryError(env, \"Initialization of SurfaceData failed.\");\n-        return;\n-    }\n-\n-    if (mtlsdo == NULL) {\n-        (*env)->DeleteGlobalRef(env, gc);\n+        free(mtlsdo);\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLSurfaceData.m","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -276,1 +276,2 @@\n-    pthread_attr_init(&attr);\n+    int rslt = pthread_attr_init(&attr);\n+    if (rslt != 0) return;\n@@ -278,0 +279,1 @@\n+    pthread_attr_destroy(&attr);\n","filename":"src\/java.desktop\/macosx\/native\/libsplashscreen\/splashscreen_sys.m","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n- Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,1 +61,0 @@\n-            class=\"centered\"\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/doc-files\/FocusCycle.svg","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -937,1 +937,1 @@\n-     * the popup menu menu is to be displayed.\n+     * the popup menu is to be displayed.\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JPopupMenu.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -560,0 +560,1 @@\n+        this.rdrCtx.doRender = true;\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/Renderer.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -81,0 +81,2 @@\n+    \/\/ flag indicating to render the shape\n+    boolean doRender = false;\n@@ -172,0 +174,1 @@\n+        doRender   = false;\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/RendererContext.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -173,5 +173,4 @@\n-            final double limitMin = ((this.rdrCtx.clipInvScale == 0.0d) ? JOIN_ERROR\n-                    : (JOIN_ERROR * this.rdrCtx.clipInvScale))\n-                    + lineWidth2;\n-\n-            this.joinLimitMinSq = limitMin * limitMin;\n+            if (rdrCtx.doRender) {\n+                final double limitMin = ((this.rdrCtx.clipInvScale == 0.0d) ? JOIN_ERROR\n+                        : (JOIN_ERROR * this.rdrCtx.clipInvScale))\n+                        + lineWidth2;\n@@ -179,0 +178,5 @@\n+                this.joinLimitMinSq = limitMin * limitMin;\n+            } else {\n+                \/\/ createStrokedShape(): disable limit checks:\n+                this.joinLimitMinSq = 0.0;\n+            }\n@@ -180,12 +184,17 @@\n-            \/\/ chord:  s = 2 r * sin( phi \/ 2)\n-            \/\/ height: h = 2 r * sin( phi \/ 4)^2\n-            \/\/ small angles (phi < 90):\n-            \/\/ h = s^2 \/ (8 r)\n-            \/\/ so s^2 = (8 h * r)\n-\n-            \/\/ height max (note ROUND_JOIN_ERROR = 8 * JOIN_ERROR)\n-            final double limitMin = ((this.rdrCtx.clipInvScale == 0.0d) ? ROUND_JOIN_ERROR\n-                    : (ROUND_JOIN_ERROR * this.rdrCtx.clipInvScale));\n-\n-            \/\/ chord limit (s^2):\n-            this.joinLimitMinSq = limitMin * this.lineWidth2;\n+            if (rdrCtx.doRender) {\n+                \/\/ chord:  s = 2 r * sin( phi \/ 2)\n+                \/\/ height: h = 2 r * sin( phi \/ 4)^2\n+                \/\/ small angles (phi < 90):\n+                \/\/ h = s^2 \/ (8 r)\n+                \/\/ so s^2 = (8 h * r)\n+\n+                \/\/ height max (note ROUND_JOIN_ERROR = 8 * JOIN_ERROR)\n+                final double limitMin = ((this.rdrCtx.clipInvScale == 0.0d) ? ROUND_JOIN_ERROR\n+                        : (ROUND_JOIN_ERROR * this.rdrCtx.clipInvScale));\n+\n+                \/\/ chord limit (s^2):\n+                this.joinLimitMinSq = limitMin * this.lineWidth2;\n+            } else {\n+                \/\/ createStrokedShape(): disable limit checks:\n+                this.joinLimitMinSq = 0.0;\n+            }\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/Stroker.java","additions":27,"deletions":18,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-    private static final String VERSION = \"marlin-0.9.4.6-Unsafe-OpenJDK\";\n+    private static final String VERSION = \"marlin-0.9.4.6.1-Unsafe-OpenJDK\";\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/Version.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -373,7 +373,0 @@\n-        contentPane.add(component);\n-        if (\"true\".equals(AccessController.\n-            doPrivileged(new GetPropertyAction(\"swing.jlf.contentPaneTransparent\", \"false\"))))\n-        {\n-            contentPane.setOpaque(false);\n-        }\n-        setContentPane(contentPane);\n@@ -399,0 +392,9 @@\n+        contentPane.add(component);\n+        contentPane.revalidate();\n+        contentPane.repaint();\n+        if (\"true\".equals(AccessController.\n+            doPrivileged(new GetPropertyAction(\"swing.jlf.contentPaneTransparent\", \"false\"))))\n+        {\n+            contentPane.setOpaque(false);\n+        }\n+        setContentPane(contentPane);\n","filename":"src\/java.desktop\/share\/classes\/sun\/swing\/JLightweightFrame.java","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-## libpng v1.6.39\n+## libpng v1.6.40\n@@ -12,2 +12,2 @@\n-Copyright (c) 1995-2022 The PNG Reference Library Authors.\n-Copyright (c) 2018-2022 Cosmin Truta\n+Copyright (c) 1995-2023 The PNG Reference Library Authors.\n+Copyright (c) 2018-2023 Cosmin Truta\n@@ -178,0 +178,1 @@\n+ * Philippe Antoine\n@@ -196,0 +197,1 @@\n+   - Wan-Teh Chang\n","filename":"src\/java.desktop\/share\/legal\/libpng.md","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -207,1 +207,1 @@\n-    all configurable options can be selected from command-line instead\n+    all configurable options can be selected from command line instead\n@@ -945,1 +945,1 @@\n-  Fixed seqence-point bug in contrib\/pngminus\/png2pnm (Martin Zinser)\n+  Fixed sequence-point bug in contrib\/pngminus\/png2pnm (Martin Zinser)\n@@ -2298,1 +2298,1 @@\n-  Reformated sources in libpng style (3-space indentation, comment format)\n+  Reformatted sources in libpng style (3-space indentation, comment format)\n@@ -2664,1 +2664,1 @@\n-  Added defineable PNG_USER_CHUNK_CACHE_MAX, PNG_USER_CHUNK_MALLOC_MAX,\n+  Added definable PNG_USER_CHUNK_CACHE_MAX, PNG_USER_CHUNK_MALLOC_MAX,\n@@ -3922,1 +3922,1 @@\n-    option is now done automagically only when required, so that commandline\n+    option is now done automagically only when required, so that command-line\n@@ -4055,1 +4055,1 @@\n-  Fixed PNG_LIBPNG_BUILD_BASE_TYPE definition. \n+  Fixed PNG_LIBPNG_BUILD_BASE_TYPE definition.\n@@ -4965,1 +4965,1 @@\n-    \n+\n@@ -5456,1 +5456,1 @@\n-    in the BigEndian tests by not testing it, making the BE code the same \n+    in the BigEndian tests by not testing it, making the BE code the same\n@@ -5520,1 +5520,1 @@\n-    were accidentally removed from libpng-1.6.17. \n+    were accidentally removed from libpng-1.6.17.\n@@ -5930,1 +5930,1 @@\n-  Replaced local eXIf_buf with info_ptr-eXIf_buf in png_handle_eXIf().\n+  Replaced local eXIf_buf with info_ptr->eXIf_buf in png_handle_eXIf().\n@@ -5953,1 +5953,1 @@\n-  \n+\n@@ -6124,0 +6124,8 @@\n+Version 1.6.40 [June 21, 2023]\n+  Fixed the eXIf chunk multiplicity checks.\n+  Fixed a memory leak in pCAL processing.\n+  Corrected the validity report about tRNS inside png_get_valid().\n+  Fixed various build issues on *BSD, Mac and Windows.\n+  Updated the configurations and the scripts for continuous integration.\n+  Cleaned up the code, the build scripts, and the documentation.\n+\n","filename":"src\/java.desktop\/share\/native\/libsplashscreen\/libpng\/CHANGES","additions":19,"deletions":11,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -7,2 +7,2 @@\n- * Copyright (c) 1995-2022 The PNG Reference Library Authors.\n- * Copyright (c) 2018-2022 Cosmin Truta.\n+ * Copyright (c) 1995-2023 The PNG Reference Library Authors.\n+ * Copyright (c) 2018-2023 Cosmin Truta.\n@@ -134,1 +134,1 @@\n-be appreciated.\n\\ No newline at end of file\n+be appreciated.\n","filename":"src\/java.desktop\/share\/native\/libsplashscreen\/libpng\/LICENSE","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-README for libpng version 1.6.39\n+README for libpng version 1.6.40\n@@ -4,2 +4,2 @@\n-See the note about version numbers near the top of png.h.\n-See INSTALL for instructions on how to install libpng.\n+See the note about version numbers near the top of `png.h`.\n+See `INSTALL` for instructions on how to install libpng.\n@@ -7,3 +7,3 @@\n-Libpng comes in several distribution formats.  Get libpng-*.tar.gz or\n-libpng-*.tar.xz if you want UNIX-style line endings in the text files,\n-or lpng*.7z or lpng*.zip if you want DOS-style line endings.\n+Libpng comes in several distribution formats.  Get `libpng-*.tar.gz`\n+or `libpng-*.tar.xz` if you want UNIX-style line endings in the text\n+files, or `lpng*.7z` or `lpng*.zip` if you want DOS-style line endings.\n@@ -11,7 +11,5 @@\n-Version 0.89 was the first official release of libpng.  Don't let the\n-fact that it's the first release fool you.  The libpng library has been\n-in extensive use and testing since mid-1995.  By late 1997 it had\n-finally gotten to the stage where there hadn't been significant\n-changes to the API in some time, and people have a bad feeling about\n-libraries with versions < 1.0.  Version 1.0.0 was released in\n-March 1998.\n+For a detailed description on using libpng, read `libpng-manual.txt`.\n+For examples of libpng in a program, see `example.c` and `pngtest.c`.\n+For usage information and restrictions (what little they are) on libpng,\n+see `png.h`.  For a description on using zlib (the compression library\n+used by libpng) and zlib's restrictions, see `zlib.h`.\n@@ -19,56 +17,1 @@\n-****\n-Note that some of the changes to the png_info structure render this\n-version of the library binary incompatible with libpng-0.89 or\n-earlier versions if you are using a shared library.  The type of the\n-\"filler\" parameter for png_set_filler() has changed from png_byte to\n-png_uint_32, which will affect shared-library applications that use\n-this function.\n-\n-To avoid problems with changes to the internals of the png info_struct,\n-new APIs have been made available in 0.95 to avoid direct application\n-access to info_ptr.  These functions are the png_set_<chunk> and\n-png_get_<chunk> functions.  These functions should be used when\n-accessing\/storing the info_struct data, rather than manipulating it\n-directly, to avoid such problems in the future.\n-\n-It is important to note that the APIs did not make current programs\n-that access the info struct directly incompatible with the new\n-library, through libpng-1.2.x.  In libpng-1.4.x, which was meant to\n-be a transitional release, members of the png_struct and the\n-info_struct can still be accessed, but the compiler will issue a\n-warning about deprecated usage.  Since libpng-1.5.0, direct access\n-to these structs is not allowed, and the definitions of the structs\n-reside in private pngstruct.h and pnginfo.h header files that are not\n-accessible to applications.  It is strongly suggested that new\n-programs use the new APIs (as shown in example.c and pngtest.c), and\n-older programs be converted to the new format, to facilitate upgrades\n-in the future.\n-****\n-\n-Additions since 0.90 include the ability to compile libpng as a\n-Windows DLL, and new APIs for accessing data in the info struct.\n-Experimental functions include the ability to set weighting and cost\n-factors for row filter selection, direct reads of integers from buffers\n-on big-endian processors that support misaligned data access, faster\n-methods of doing alpha composition, and more accurate 16->8 bit color\n-conversion.\n-\n-The additions since 0.89 include the ability to read from a PNG stream\n-which has had some (or all) of the signature bytes read by the calling\n-application.  This also allows the reading of embedded PNG streams that\n-do not have the PNG file signature.  As well, it is now possible to set\n-the library action on the detection of chunk CRC errors.  It is possible\n-to set different actions based on whether the CRC error occurred in a\n-critical or an ancillary chunk.\n-\n-For a detailed description on using libpng, read libpng-manual.txt.\n-For examples of libpng in a program, see example.c and pngtest.c.  For\n-usage information and restrictions (what little they are) on libpng,\n-see png.h.  For a description on using zlib (the compression library\n-used by libpng) and zlib's restrictions, see zlib.h\n-\n-I have included a general makefile, as well as several machine and\n-compiler specific ones, but you may have to modify one for your own\n-needs.\n-\n-You should use zlib 1.0.4 or later to run this, but it MAY work with\n+You should use zlib 1.0.4 or later to run this, but it _may_ work with\n@@ -81,1 +24,1 @@\n-replacement for fread() and fwrite(), if you are so inclined.\n+replacement for `fread()` and `fwrite()`, if you are so inclined.\n@@ -84,1 +27,1 @@\n-https:\/\/zlib.net.\n+https:\/\/zlib.net .\n@@ -90,2 +33,2 @@\n-This code is currently being archived at libpng.sourceforge.io in the\n-[DOWNLOAD] area, and at http:\/\/libpng.download\/src .\n+This code is currently being archived at https:\/\/libpng.sourceforge.io\n+in the download area, and at http:\/\/libpng.download\/src .\n@@ -97,2 +40,2 @@\n-Send comments\/corrections\/commendations to png-mng-implement at\n-lists.sourceforge.net (subscription required; visit\n+Send comments, corrections and commendations to `png-mng-implement`\n+at `lists.sourceforge.net`.  (Subscription is required; visit\n@@ -100,1 +43,6 @@\n-to subscribe).\n+to subscribe.)\n+\n+Send general questions about the PNG specification to `png-mng-misc`\n+at `lists.sourceforge.net`.  (Subscription is required; visit\n+https:\/\/lists.sourceforge.net\/lists\/listinfo\/png-mng-misc\n+to subscribe.)\n@@ -102,4 +50,53 @@\n-Send general questions about the PNG specification to png-mng-misc\n-at lists.sourceforge.net (subscription required; visit\n-https:\/\/lists.sourceforge.net\/lists\/listinfo\/png-mng-misc to\n-subscribe).\n+Historical notes\n+----------------\n+\n+The libpng library has been in extensive use and testing since mid-1995.\n+Version 0.89, published a year later, was the first official release.\n+By late 1997, it had finally gotten to the stage where there hadn't\n+been significant changes to the API in some time, and people have a bad\n+feeling about libraries with versions below 1.0.  Version 1.0.0 was\n+released in March 1998.\n+\n+Note that some of the changes to the `png_info` structure render this\n+version of the library binary incompatible with libpng-0.89 or\n+earlier versions if you are using a shared library.  The type of the\n+`filler` parameter for `png_set_filler()` has changed from `png_byte`\n+to `png_uint_32`, which will affect shared-library applications that\n+use this function.\n+\n+To avoid problems with changes to the internals of the `info_struct`,\n+new APIs have been made available in 0.95 to avoid direct application\n+access to `info_ptr`.  These functions are the `png_set_<chunk>` and\n+`png_get_<chunk>` functions.  These functions should be used when\n+accessing\/storing the `info_struct` data, rather than manipulating it\n+directly, to avoid such problems in the future.\n+\n+It is important to note that the APIs did not make current programs\n+that access the info struct directly incompatible with the new\n+library, through libpng-1.2.x.  In libpng-1.4.x, which was meant to\n+be a transitional release, members of the `png_struct` and the\n+`info_struct` can still be accessed, but the compiler will issue a\n+warning about deprecated usage.  Since libpng-1.5.0, direct access\n+to these structs is not allowed, and the definitions of the structs\n+reside in private `pngstruct.h` and `pnginfo.h` header files that are\n+not accessible to applications.  It is strongly suggested that new\n+programs use the new APIs (as shown in `example.c` and `pngtest.c`),\n+and older programs be converted to the new format, to facilitate\n+upgrades in the future.\n+\n+The additions since 0.89 include the ability to read from a PNG stream\n+which has had some (or all) of the signature bytes read by the calling\n+application.  This also allows the reading of embedded PNG streams that\n+do not have the PNG file signature.  As well, it is now possible to set\n+the library action on the detection of chunk CRC errors.  It is possible\n+to set different actions based on whether the CRC error occurred in a\n+critical or an ancillary chunk.\n+\n+The additions since 0.90 include the ability to compile libpng as a\n+Windows DLL, and new APIs for accessing data in the `info_struct`.\n+Experimental functions included the ability to set weighting and cost\n+factors for row filter selection, direct reads of integers from buffers\n+on big-endian processors that support misaligned data access, faster\n+methods of doing alpha composition, and more accurate 16-to-8 bit color\n+conversion.  Some of these experimental functions, such as the weighted\n+filter heuristics, have since been removed.\n@@ -107,1 +104,2 @@\n-Files in this distribution:\n+Files included in this distribution\n+-----------------------------------\n@@ -156,1 +154,1 @@\n-        examples\/     =>  Example programs\n+        examples\/     =>  Examples of libpng usage\n","filename":"src\/java.desktop\/share\/native\/libsplashscreen\/libpng\/README","additions":80,"deletions":82,"binary":false,"changes":162,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * Copyright (c) 2018-2022 Cosmin Truta\n+ * Copyright (c) 2018-2023 Cosmin Truta\n@@ -45,1 +45,1 @@\n-typedef png_libpng_version_1_6_39 Your_png_h_is_not_version_1_6_39;\n+typedef png_libpng_version_1_6_40 Your_png_h_is_not_version_1_6_40;\n@@ -846,2 +846,2 @@\n-      \"libpng version 1.6.39\" PNG_STRING_NEWLINE \\\n-      \"Copyright (c) 2018-2022 Cosmin Truta\" PNG_STRING_NEWLINE \\\n+      \"libpng version 1.6.40\" PNG_STRING_NEWLINE \\\n+      \"Copyright (c) 2018-2023 Cosmin Truta\" PNG_STRING_NEWLINE \\\n","filename":"src\/java.desktop\/share\/native\/libsplashscreen\/libpng\/png.c","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * libpng version 1.6.39 - November 20, 2022\n+ * libpng version 1.6.40\n@@ -34,1 +34,1 @@\n- * Copyright (c) 2018-2022 Cosmin Truta\n+ * Copyright (c) 2018-2023 Cosmin Truta\n@@ -46,1 +46,1 @@\n- *   libpng versions 1.6.36, December 2018, through 1.6.39, November 2022:\n+ *   libpng versions 1.6.36, December 2018, through 1.6.40, June 2023:\n@@ -58,2 +58,2 @@\n- *  * Copyright (c) 1995-2022 The PNG Reference Library Authors.\n- *  * Copyright (c) 2018-2022 Cosmin Truta.\n+ *  * Copyright (c) 1995-2023 The PNG Reference Library Authors.\n+ *  * Copyright (c) 2018-2023 Cosmin Truta.\n@@ -270,1 +270,1 @@\n- *    1.6.39                  16    10639  16.so.16.39[.0]\n+ *    1.6.40                  16    10640  16.so.16.40[.0]\n@@ -309,2 +309,2 @@\n-#define PNG_LIBPNG_VER_STRING \"1.6.39\"\n-#define PNG_HEADER_VERSION_STRING \" libpng version 1.6.39 - November 20, 2022\\n\"\n+#define PNG_LIBPNG_VER_STRING \"1.6.40\"\n+#define PNG_HEADER_VERSION_STRING \" libpng version 1.6.40 - June 21, 2023\\n\"\n@@ -318,1 +318,1 @@\n-#define PNG_LIBPNG_VER_RELEASE 39\n+#define PNG_LIBPNG_VER_RELEASE 40\n@@ -349,1 +349,1 @@\n-#define PNG_LIBPNG_VER 10639 \/* 1.6.39 *\/\n+#define PNG_LIBPNG_VER 10640 \/* 1.6.40 *\/\n@@ -459,1 +459,1 @@\n-typedef char* png_libpng_version_1_6_39;\n+typedef char* png_libpng_version_1_6_40;\n","filename":"src\/java.desktop\/share\/native\/libsplashscreen\/libpng\/png.h","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * libpng version 1.6.39\n+ * libpng version 1.6.40\n","filename":"src\/java.desktop\/share\/native\/libsplashscreen\/libpng\/pngconf.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * Copyright (c) 2018 Cosmin Truta\n+ * Copyright (c) 2018-2023 Cosmin Truta\n@@ -52,0 +52,10 @@\n+   {\n+#ifdef PNG_READ_tRNS_SUPPORTED\n+      \/* png_handle_PLTE() may have canceled a valid tRNS chunk but left the\n+       * 'valid' flag for the detection of duplicate chunks. Do not report a\n+       * valid tRNS chunk in this case.\n+       *\/\n+      if (flag == PNG_INFO_tRNS && png_ptr->num_trans == 0)\n+         return(0);\n+#endif\n+\n@@ -53,0 +63,1 @@\n+   }\n","filename":"src\/java.desktop\/share\/native\/libsplashscreen\/libpng\/pngget.c","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-\/* libpng version 1.6.39 *\/\n+\/* libpng version 1.6.40 *\/\n@@ -36,1 +36,1 @@\n-\/* Copyright (c) 2018-2022 Cosmin Truta *\/\n+\/* Copyright (c) 2018-2023 Cosmin Truta *\/\n","filename":"src\/java.desktop\/share\/native\/libsplashscreen\/libpng\/pnglibconf.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * Copyright (c) 2018-2022 Cosmin Truta\n+ * Copyright (c) 2018-2023 Cosmin Truta\n@@ -657,1 +657,1 @@\n-                   \/*             0x4000U (unused) *\/\n+#define PNG_WROTE_eXIf            0x4000U\n@@ -1941,1 +1941,1 @@\n-\/* Result codes for the parser (boolean - true meants ok, false means\n+\/* Result codes for the parser (boolean - true means ok, false means\n","filename":"src\/java.desktop\/share\/native\/libsplashscreen\/libpng\/pngpriv.h","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * Copyright (c) 2018-2022 Cosmin Truta\n+ * Copyright (c) 2018-2023 Cosmin Truta\n@@ -168,1 +168,1 @@\n-    png_bytep eXIf_buf)\n+    png_bytep exif)\n@@ -172,1 +172,1 @@\n-  PNG_UNUSED(eXIf_buf)\n+  PNG_UNUSED(exif)\n@@ -177,1 +177,1 @@\n-    png_uint_32 num_exif, png_bytep eXIf_buf)\n+    png_uint_32 num_exif, png_bytep exif)\n@@ -179,1 +179,1 @@\n-   int i;\n+   png_bytep new_exif;\n@@ -183,1 +183,2 @@\n-   if (png_ptr == NULL || info_ptr == NULL)\n+   if (png_ptr == NULL || info_ptr == NULL ||\n+       (png_ptr->mode & PNG_WROTE_eXIf) != 0)\n@@ -186,5 +187,1 @@\n-   if (info_ptr->exif)\n-   {\n-      png_free(png_ptr, info_ptr->exif);\n-      info_ptr->exif = NULL;\n-   }\n+   new_exif = png_voidcast(png_bytep, png_malloc_warn(png_ptr, num_exif));\n@@ -192,6 +189,1 @@\n-   info_ptr->num_exif = num_exif;\n-\n-   info_ptr->exif = png_voidcast(png_bytep, png_malloc_warn(png_ptr,\n-       info_ptr->num_exif));\n-\n-   if (info_ptr->exif == NULL)\n+   if (new_exif == NULL)\n@@ -203,1 +195,1 @@\n-   info_ptr->free_me |= PNG_FREE_EXIF;\n+   memcpy(new_exif, exif, (size_t)num_exif);\n@@ -205,2 +197,1 @@\n-   for (i = 0; i < (int) info_ptr->num_exif; i++)\n-      info_ptr->exif[i] = eXIf_buf[i];\n+   png_free_data(png_ptr, info_ptr, PNG_FREE_EXIF, 0);\n@@ -208,0 +199,3 @@\n+   info_ptr->num_exif = num_exif;\n+   info_ptr->exif = new_exif;\n+   info_ptr->free_me |= PNG_FREE_EXIF;\n@@ -268,1 +262,0 @@\n-\n@@ -272,2 +265,0 @@\n-   info_ptr->free_me |= PNG_FREE_HIST;\n-\n@@ -277,0 +268,1 @@\n+   info_ptr->free_me |= PNG_FREE_HIST;\n@@ -398,0 +390,2 @@\n+   info_ptr->free_me |= PNG_FREE_PCAL;\n+\n@@ -414,1 +408,0 @@\n-\n@@ -426,1 +419,0 @@\n-\n@@ -444,1 +436,0 @@\n-\n@@ -452,1 +443,0 @@\n-   info_ptr->free_me |= PNG_FREE_PCAL;\n@@ -509,1 +499,1 @@\n-      png_free (png_ptr, info_ptr->scal_s_width);\n+      png_free(png_ptr, info_ptr->scal_s_width);\n@@ -513,1 +503,0 @@\n-\n@@ -519,1 +508,0 @@\n-   info_ptr->valid |= PNG_INFO_sCAL;\n@@ -521,0 +509,1 @@\n+   info_ptr->valid |= PNG_INFO_sCAL;\n@@ -656,0 +645,1 @@\n+\n@@ -658,1 +648,0 @@\n-\n@@ -660,1 +649,0 @@\n-\n@@ -1051,1 +1039,0 @@\n-          info_ptr->valid |= PNG_INFO_tRNS;\n@@ -1053,0 +1040,1 @@\n+          info_ptr->valid |= PNG_INFO_tRNS;\n@@ -1085,1 +1073,0 @@\n-      info_ptr->valid |= PNG_INFO_tRNS;\n@@ -1087,0 +1074,1 @@\n+      info_ptr->valid |= PNG_INFO_tRNS;\n@@ -1120,1 +1108,0 @@\n-\n@@ -1125,0 +1112,1 @@\n+\n@@ -1278,1 +1266,0 @@\n-\n@@ -1283,0 +1270,1 @@\n+\n","filename":"src\/java.desktop\/share\/native\/libsplashscreen\/libpng\/pngset.c","additions":24,"deletions":36,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import sun.java2d.pipe.Region;\n@@ -31,0 +32,1 @@\n+import java.awt.GraphicsConfiguration;\n@@ -34,0 +36,1 @@\n+import java.awt.geom.AffineTransform;\n@@ -112,3 +115,14 @@\n-                .map(graphicsDevice ->\n-                        graphicsDevice.getDefaultConfiguration().getBounds()\n-                ).toList();\n+                .map(graphicsDevice -> {\n+                    GraphicsConfiguration gc =\n+                            graphicsDevice.getDefaultConfiguration();\n+                    Rectangle screen = gc.getBounds();\n+                    AffineTransform tx = gc.getDefaultTransform();\n+\n+                    return new Rectangle(\n+                            Region.clipRound(screen.x * tx.getScaleX()),\n+                            Region.clipRound(screen.y * tx.getScaleY()),\n+                            Region.clipRound(screen.width * tx.getScaleX()),\n+                            Region.clipRound(screen.height * tx.getScaleY())\n+                    );\n+                })\n+                .toList();\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/screencast\/ScreencastHelper.java","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -372,0 +372,11 @@\n+        \/\/ 3. add tokens with the same or greater number of screens\n+        \/\/ This is useful if we once received a token with one screen resolution\n+        \/\/ and the same screen was later scaled in the system.\n+        \/\/ In that case, the token is still valid.\n+\n+        allTokenItems\n+                .stream()\n+                .filter(t ->\n+                        t.allowedScreensBounds.size() >= affectedScreenBounds.size())\n+                .forEach(result::add);\n+\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/screencast\/TokenStorage.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -53,2 +53,0 @@\n-extern int XShmQueryExtension();\n-\n","filename":"src\/java.desktop\/unix\/native\/common\/awt\/awt_GraphicsEnv.h","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1468,1 +1468,1 @@\n-                    (*fp_gtk_notebook_new)(NULL);\n+                    (*fp_gtk_notebook_new)();\n@@ -1476,1 +1476,1 @@\n-                    (*fp_gtk_toggle_button_new)(NULL);\n+                    (*fp_gtk_toggle_button_new)();\n@@ -1485,1 +1485,1 @@\n-                    (*fp_gtk_toolbar_new)(NULL);\n+                    (*fp_gtk_toolbar_new)();\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/awt\/gtk2_interface.c","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -322,0 +322,4 @@\n+        fp_gdk_pixbuf_new_from_data = dl_symbol(\"gdk_pixbuf_new_from_data\");\n+        fp_gdk_pixbuf_scale_simple = dl_symbol(\"gdk_pixbuf_scale_simple\");\n+        fp_gdk_pixbuf_copy_area = dl_symbol(\"gdk_pixbuf_copy_area\");\n+\n@@ -1255,1 +1259,1 @@\n-                    (*fp_gtk_notebook_new)(NULL);\n+                    (*fp_gtk_notebook_new)();\n@@ -1263,1 +1267,1 @@\n-                    (*fp_gtk_toggle_button_new)(NULL);\n+                    (*fp_gtk_toggle_button_new)();\n@@ -1272,1 +1276,1 @@\n-                    (*fp_gtk_toolbar_new)(NULL);\n+                    (*fp_gtk_toolbar_new)();\n@@ -3126,0 +3130,6 @@\n+\n+    gtk->gdk_pixbuf_new = fp_gdk_pixbuf_new;\n+    gtk->gdk_pixbuf_new_from_data = fp_gdk_pixbuf_new_from_data;\n+    gtk->gdk_pixbuf_scale_simple = fp_gdk_pixbuf_scale_simple;\n+    gtk->gdk_pixbuf_get_pixels = fp_gdk_pixbuf_get_pixels;\n+    gtk->gdk_pixbuf_copy_area = fp_gdk_pixbuf_copy_area;\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/awt\/gtk3_interface.c","additions":13,"deletions":3,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -531,0 +531,24 @@\n+\n+static GdkPixbuf *(*fp_gdk_pixbuf_new_from_data)(\n+        const guchar *data,\n+        GdkColorspace colorspace,\n+        gboolean has_alpha,\n+        int bits_per_sample,\n+        int width,\n+        int height,\n+        int rowstride,\n+        GdkPixbufDestroyNotify destroy_fn,\n+        gpointer destroy_fn_data\n+);\n+\n+static void (*fp_gdk_pixbuf_copy_area) (\n+        const GdkPixbuf* src_pixbuf,\n+        int src_x,\n+        int src_y,\n+        int width,\n+        int height,\n+        GdkPixbuf* dest_pixbuf,\n+        int dest_x,\n+        int dest_y\n+);\n+\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/awt\/gtk3_interface.h","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -535,0 +535,2 @@\n+typedef void GdkPixbuf;\n+typedef void (* GdkPixbufDestroyNotify) (guchar *pixels, gpointer data);\n@@ -800,0 +802,40 @@\n+    GdkPixbuf *(*gdk_pixbuf_new)(GdkColorspace colorspace,\n+                                 gboolean has_alpha,\n+                                 int bits_per_sample,\n+                                 int width,\n+                                 int height);\n+\n+\n+    GdkPixbuf *(*gdk_pixbuf_new_from_data)(\n+            const guchar *data,\n+            GdkColorspace colorspace,\n+            gboolean has_alpha,\n+            int bits_per_sample,\n+            int width,\n+            int height,\n+            int rowstride,\n+            GdkPixbufDestroyNotify destroy_fn,\n+            gpointer destroy_fn_data\n+    );\n+\n+\n+    GdkPixbuf *(*gdk_pixbuf_scale_simple)(GdkPixbuf *src,\n+                                          int dest_width,\n+                                          int dest_heigh,\n+                                          GdkInterpType interp_type\n+    );\n+\n+    guchar* (*gdk_pixbuf_get_pixels) (const GdkPixbuf* pixbuf);\n+\n+\n+    void (*gdk_pixbuf_copy_area) (\n+            const GdkPixbuf* src_pixbuf,\n+            int src_x,\n+            int src_y,\n+            int width,\n+            int height,\n+            GdkPixbuf* dest_pixbuf,\n+            int dest_x,\n+            int dest_y\n+    );\n+\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/awt\/gtk_interface.h","additions":42,"deletions":0,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -178,43 +178,0 @@\n-static inline void convertRGBxToBGRx(int* in) {\n-    char* o = (char*) in;\n-    char tmp = o[0];\n-    o[0] = o[2];\n-    o[2] = tmp;\n-}\n-\n-static gchar * cropTo(\n-        struct spa_data data,\n-        struct spa_video_info_raw raw,\n-        guint32 x,\n-        guint32 y,\n-        guint32 width,\n-        guint32 height\n-) {\n-    int srcW = raw.size.width;\n-    if (data.chunk->stride \/ 4 != srcW) {\n-        fprintf(stderr, \"%s:%i Unexpected stride \/ 4: %i srcW: %i\\n\",\n-                __func__, __LINE__, data.chunk->stride \/ 4, srcW);\n-    }\n-\n-    int* d = data.data;\n-\n-    int *outData = calloc(width * height, sizeof(int));\n-    if (!outData) {\n-        ERR(\"failed to allocate memory\\n\");\n-        return NULL;\n-    }\n-\n-    gboolean needConversion = raw.format != SPA_VIDEO_FORMAT_BGRx;\n-    for (guint32 j = y; j < y + height; ++j) {\n-        for (guint32 i = x; i < x + width; ++i) {\n-            int color = *(d + (j * srcW) + i);\n-            if (needConversion) {\n-                convertRGBxToBGRx(&color);\n-            }\n-            *(outData + ((j - y) * width) + (i - x)) = color;\n-        }\n-    }\n-\n-    return (gchar*) outData;\n-}\n-\n@@ -304,0 +261,3 @@\n+    gint streamWidth = data->rawFormat.size.width;\n+    gint streamHeight = data->rawFormat.size.height;\n+\n@@ -307,1 +267,1 @@\n-                        \"flags %d FD %li captureDataReady %i\\n\",\n+                        \"flags %d FD %li captureDataReady %i of stream %dx%d\\n\",\n@@ -313,1 +273,3 @@\n-                        screen->captureDataReady\n+                        screen->captureDataReady,\n+                        streamWidth,\n+                        streamHeight\n@@ -316,6 +278,58 @@\n-    data->screenProps->captureData = cropTo(\n-            spaData,\n-            data->rawFormat,\n-            screen->captureArea.x, screen->captureArea.y,\n-            screen->captureArea.width, screen->captureArea.height\n-    );\n+    GdkRectangle captureArea = screen->captureArea;\n+    GdkRectangle screenBounds = screen->bounds;\n+\n+    GdkPixbuf *pixbuf = gtk->gdk_pixbuf_new_from_data(spaData.data,\n+                                                      GDK_COLORSPACE_RGB,\n+                                                      TRUE,\n+                                                      8,\n+                                                      streamWidth,\n+                                                      streamHeight,\n+                                                      spaData.chunk->stride,\n+                                                      NULL,\n+                                                      NULL);\n+\n+    if (screen->bounds.width != streamWidth\n+        || screen->bounds.height != streamHeight) {\n+\n+        DEBUG_SCREEN_PREFIX(screen, \"scaling stream data %dx%d -> %dx%d\\n\",\n+                         streamWidth, streamHeight,\n+                         screen->bounds.width, screen->bounds.height\n+        );\n+\n+        GdkPixbuf *scaled = gtk->gdk_pixbuf_scale_simple(pixbuf,\n+                                                         screen->bounds.width,\n+                                                         screen->bounds.height,\n+                                                         GDK_INTERP_BILINEAR);\n+\n+        gtk->g_object_unref(pixbuf);\n+        pixbuf = scaled;\n+    }\n+\n+    GdkPixbuf *cropped = NULL;\n+    if (captureArea.width != screenBounds.width\n+        || captureArea.height != screenBounds.height) {\n+\n+        cropped = gtk->gdk_pixbuf_new(GDK_COLORSPACE_RGB,\n+                                      TRUE,\n+                                      8,\n+                                      captureArea.width,\n+                                      captureArea.height);\n+        if (cropped) {\n+            gtk->gdk_pixbuf_copy_area(pixbuf,\n+                                      captureArea.x,\n+                                      captureArea.y,\n+                                      captureArea.width,\n+                                      captureArea.height,\n+                                      cropped,\n+                                      0, 0);\n+        } else {\n+            ERR(\"Cannot create a new pixbuf.\\n\");\n+        }\n+\n+        gtk->g_object_unref(pixbuf);\n+        pixbuf = NULL;\n+\n+        data->screenProps->captureDataPixbuf = cropped;\n+    } else {\n+        data->screenProps->captureDataPixbuf = pixbuf;\n+    }\n@@ -369,5 +383,1 @@\n-            SPA_POD_CHOICE_ENUM_Id(\n-                    2,\n-                    SPA_VIDEO_FORMAT_RGBx,\n-                    SPA_VIDEO_FORMAT_BGRx\n-            ),\n+            SPA_POD_Id(SPA_VIDEO_FORMAT_BGRx),\n@@ -913,1 +923,1 @@\n-                                i, screenProps->captureData,\n+                                i, screenProps->captureDataPixbuf,\n@@ -927,1 +937,1 @@\n-            if (screenProps->captureData) {\n+            if (screenProps->captureDataPixbuf) {\n@@ -942,2 +952,4 @@\n-                            ((jint *) screenProps->captureData)\n-                                + (captureArea.width * y)\n+                            ((jint *) gtk->gdk_pixbuf_get_pixels(\n+                                    screenProps->captureDataPixbuf\n+                            ))\n+                            + (captureArea.width * y)\n@@ -948,2 +960,4 @@\n-            free(screenProps->captureData);\n-            screenProps->captureData = NULL;\n+            if (screenProps->captureDataPixbuf) {\n+                gtk->g_object_unref(screenProps->captureDataPixbuf);\n+                screenProps->captureDataPixbuf = NULL;\n+            }\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/awt\/screencast_pipewire.c","additions":76,"deletions":62,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-    gchar *captureData;\n+    GdkPixbuf *captureDataPixbuf;\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/awt\/screencast_pipewire.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -776,1 +776,2 @@\n-    pthread_attr_init(&attr);\n+    int rslt = pthread_attr_init(&attr);\n+    if (rslt != 0) return;\n@@ -778,0 +779,1 @@\n+    pthread_attr_destroy(&attr);\n","filename":"src\/java.desktop\/unix\/native\/libsplashscreen\/splashscreen_sys.c","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -581,0 +581,1 @@\n+                        return true;\n@@ -582,1 +583,1 @@\n-                    return true;\n+                    return false;\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/HttpClientImpl.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -186,1 +186,1 @@\n-            while (!inputQ.isEmpty()) {\n+            while (!inputQ.isEmpty() && errorRef.get() == null) {\n@@ -420,0 +420,4 @@\n+        \/\/ ensure that the body subscriber will be subscribed and onError() is\n+        \/\/ invoked\n+        pendingResponseSubscriber = bodySubscriber;\n+\n@@ -430,3 +434,0 @@\n-        \/\/ ensure that the body subscriber will be subscribed and onError() is\n-        \/\/ invoked\n-        pendingResponseSubscriber = bodySubscriber;\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Stream.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -107,0 +107,3 @@\n+                                case AIX -> new String[]{\n+                                        \"\/opt\/freeware\/lib64\/libgssapi_krb5.so\",\n+                                };\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/security\/jgss\/wrapper\/SunNativeProvider.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -95,2 +95,4 @@\n-        try {\n-            Kinit self = new Kinit(args);\n+        Kinit kinit = new Kinit();\n+        int exitCode = kinit.run(args);\n+        if (exitCode != 0) {\n+            System.exit(exitCode);\n@@ -98,5 +100,33 @@\n-        catch (Exception e) {\n-            String msg = null;\n-            if (e instanceof KrbException) {\n-                msg = ((KrbException)e).krbErrorMessage() + \" \" +\n-                    ((KrbException)e).returnCodeMessage();\n+    }\n+\n+    \/**\n+     * Run the Kinit command.\n+     * @param args array of ticket request options.\n+     * Available options are: -f, -p, -c, principal, password.\n+     * @return the exit code\n+     *\/\n+    public int run(String[] args) {\n+        try {\n+            if (args == null || args.length == 0) {\n+                options = new KinitOptions();\n+            } else {\n+                options = new KinitOptions(args);\n+            }\n+            switch (options.action) {\n+                case 0:\n+                    \/\/ Help, already displayed in new KinitOptions().\n+                    break;\n+                case 1:\n+                    acquire();\n+                    break;\n+                case 2:\n+                    renew();\n+                    break;\n+                default:\n+                    throw new KrbException(\"kinit does not support action \"\n+                            + options.action);\n+            }\n+        } catch (Exception e) {\n+            String msg;\n+            if (e instanceof KrbException ke) {\n+                msg = ke.krbErrorMessage() + \" \" + ke.returnCodeMessage();\n@@ -112,30 +142,1 @@\n-            System.exit(-1);\n-        }\n-        return;\n-    }\n-\n-    \/**\n-     * Constructs a new Kinit object.\n-     * @param args array of ticket request options.\n-     * Available options are: -f, -p, -c, principal, password.\n-     * @exception IOException if an I\/O error occurs.\n-     * @exception RealmException if the Realm could not be instantiated.\n-     * @exception KrbException if error occurs during Kerberos operation.\n-     *\/\n-    private Kinit(String[] args)\n-        throws IOException, RealmException, KrbException {\n-        if (args == null || args.length == 0) {\n-            options = new KinitOptions();\n-        } else {\n-            options = new KinitOptions(args);\n-        }\n-        switch (options.action) {\n-            case 1:\n-                acquire();\n-                break;\n-            case 2:\n-                renew();\n-                break;\n-            default:\n-                throw new KrbException(\"kinit does not support action \"\n-                        + options.action);\n+            return -1;\n@@ -143,0 +144,1 @@\n+        return 0;\n","filename":"src\/java.security.jgss\/windows\/classes\/sun\/security\/krb5\/internal\/tools\/Kinit.java","additions":40,"deletions":38,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n-    \/\/ 1. acquire, 2. renew, 3. validate\n+    \/\/ 0. Help, 1. acquire, 2. renew, 3. validate\n@@ -146,1 +146,2 @@\n-                System.exit(0);\n+                action = 0;\n+                return;\n","filename":"src\/java.security.jgss\/windows\/classes\/sun\/security\/krb5\/internal\/tools\/KinitOptions.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -81,0 +81,7 @@\n+        int exitCode = klist.run(args);\n+        if (exitCode != 0) {\n+            System.exit(exitCode);\n+        }\n+    }\n+\n+    public int run(String[] args) {\n@@ -82,1 +89,1 @@\n-            klist.action = 'c'; \/\/ default will list default credentials cache.\n+            action = 'c'; \/\/ default will list default credentials cache.\n@@ -84,1 +91,51 @@\n-            klist.processArgs(args);\n+            Character arg;\n+            for (int i = 0; i < args.length; i++) {\n+                if (args[i].equals(\"-?\") ||\n+                        args[i].equals(\"-h\") ||\n+                        args[i].equals(\"--help\")) {\n+                    printHelp();\n+                    return 0;\n+                }\n+                if ((args[i].length() >= 2) && (args[i].startsWith(\"-\"))) {\n+                    arg = Character.valueOf(args[i].charAt(1));\n+                    switch (arg.charValue()) {\n+                        case 'c':\n+                            action = 'c';\n+                            break;\n+                        case 'k':\n+                            action = 'k';\n+                            break;\n+                        case 'a':\n+                            options[2] = 'a';\n+                            break;\n+                        case 'n':\n+                            options[3] = 'n';\n+                            break;\n+                        case 'f':\n+                            options[1] = 'f';\n+                            break;\n+                        case 'e':\n+                            options[0] = 'e';\n+                            break;\n+                        case 'K':\n+                            options[1] = 'K';\n+                            break;\n+                        case 't':\n+                            options[2] = 't';\n+                            break;\n+                        default:\n+                            System.out.println(\"Invalid argument: \" + args[i]);\n+                            printHelp();\n+                            return -1;\n+                    }\n+                } else {\n+                    if (!args[i].startsWith(\"-\") && (i == args.length - 1)) {\n+                        \/\/ the argument is the last one.\n+                        name = args[i];\n+                    } else {\n+                        System.out.println(\"Invalid argument: \" + args[i]);\n+                        printHelp(); \/\/ incorrect input format.\n+                        return -1;\n+                    }\n+                }\n+            }\n@@ -86,1 +143,1 @@\n-        switch (klist.action) {\n+        switch (action) {\n@@ -88,3 +145,3 @@\n-            if (klist.name == null) {\n-                klist.target = CredentialsCache.getInstance();\n-                klist.name = CredentialsCache.cacheName();\n+            if (name == null) {\n+                target = CredentialsCache.getInstance();\n+                name = CredentialsCache.cacheName();\n@@ -92,1 +149,1 @@\n-                klist.target = CredentialsCache.getInstance(klist.name);\n+                target = CredentialsCache.getInstance(name);\n@@ -94,2 +151,2 @@\n-            if (klist.target != null)  {\n-                klist.displayCache();\n+            if (target != null) {\n+                return displayCache();\n@@ -97,2 +154,1 @@\n-                klist.displayMessage(\"Credentials cache\");\n-                System.exit(-1);\n+                return displayError(\"Credentials cache\");\n@@ -100,1 +156,0 @@\n-            break;\n@@ -102,1 +157,1 @@\n-            KeyTab ktab = KeyTab.getInstance(klist.name);\n+            KeyTab ktab = KeyTab.getInstance(name);\n@@ -104,2 +159,2 @@\n-                System.out.println(\"KeyTab \" + klist.name + \" not found.\");\n-                System.exit(-1);\n+                System.out.println(\"KeyTab \" + name + \" not found.\");\n+                return -1;\n@@ -107,1 +162,1 @@\n-                System.out.println(\"KeyTab \" + klist.name\n+                System.out.println(\"KeyTab \" + name\n@@ -109,1 +164,1 @@\n-                System.exit(-1);\n+                return -1;\n@@ -111,4 +166,3 @@\n-            klist.target = ktab;\n-            klist.name = ktab.tabName();\n-            klist.displayTab();\n-            break;\n+            target = ktab;\n+            name = ktab.tabName();\n+            return displayTab();\n@@ -116,25 +170,1 @@\n-            if (klist.name != null) {\n-                klist.printHelp();\n-                System.exit(-1);\n-            } else {\n-                klist.target = CredentialsCache.getInstance();\n-                klist.name = CredentialsCache.cacheName();\n-                if (klist.target != null) {\n-                    klist.displayCache();\n-                } else {\n-                    klist.displayMessage(\"Credentials cache\");\n-                    System.exit(-1);\n-                }\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Parses the command line arguments.\n-     *\/\n-    void processArgs(String[] args) {\n-        Character arg;\n-        for (int i = 0; i < args.length; i++) {\n-            if (args[i].equals(\"-?\") ||\n-                args[i].equals(\"-h\") ||\n-                args[i].equals(\"--help\")) {\n+            if (name != null) {\n@@ -142,34 +172,1 @@\n-                System.exit(0);\n-            }\n-            if ((args[i].length() >= 2) && (args[i].startsWith(\"-\"))) {\n-                arg = Character.valueOf(args[i].charAt(1));\n-                switch (arg.charValue()) {\n-                case 'c':\n-                    action = 'c';\n-                    break;\n-                case 'k':\n-                    action = 'k';\n-                    break;\n-                case 'a':\n-                    options[2] = 'a';\n-                    break;\n-                case 'n':\n-                    options[3] = 'n';\n-                    break;\n-                case 'f':\n-                    options[1] = 'f';\n-                    break;\n-                case 'e':\n-                    options[0] = 'e';\n-                    break;\n-                case 'K':\n-                    options[1] = 'K';\n-                    break;\n-                case 't':\n-                    options[2] = 't';\n-                    break;\n-                default:\n-                    printHelp();\n-                    System.exit(-1);\n-                }\n-\n+                return -1;\n@@ -177,4 +174,4 @@\n-                if (!args[i].startsWith(\"-\") && (i == args.length - 1)) {\n-                    \/\/ the argument is the last one.\n-                    name = args[i];\n-                    arg = null;\n+                target = CredentialsCache.getInstance();\n+                name = CredentialsCache.cacheName();\n+                if (target != null) {\n+                    return displayCache();\n@@ -182,2 +179,1 @@\n-                    printHelp(); \/\/ incorrect input format.\n-                    System.exit(-1);\n+                    return displayError(\"Credentials cache\");\n@@ -189,1 +185,1 @@\n-    void displayTab() {\n+    int displayTab() {\n@@ -204,1 +200,1 @@\n-                                   \"Service principal: \"  +\n+                                   \"Service principal: \" +\n@@ -224,0 +220,1 @@\n+        return 0;\n@@ -226,1 +223,1 @@\n-    void displayCache() {\n+    int displayCache() {\n@@ -233,1 +230,1 @@\n-            System.exit(-1);\n+            return -1;\n@@ -235,1 +232,1 @@\n-        System.out.println(\"\\nCredentials cache: \" +  name);\n+        System.out.println(\"\\nCredentials cache: \" + name);\n@@ -330,1 +327,1 @@\n-                    System.exit(-1);\n+                    return -1;\n@@ -345,0 +342,2 @@\n+\n+        return 0;\n@@ -347,1 +346,1 @@\n-    void displayMessage(String target) {\n+    int displayError(String target) {\n@@ -353,0 +352,1 @@\n+        return -1;\n@@ -362,1 +362,1 @@\n-     * @param date the string form of Date object.\n+     * @param kt the string form of Date object.\n","filename":"src\/java.security.jgss\/windows\/classes\/sun\/security\/krb5\/internal\/tools\/Klist.java","additions":95,"deletions":95,"binary":false,"changes":190,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,0 +76,25 @@\n+        int exitCode = ktab.run(args);\n+        if (exitCode != 0) {\n+            System.exit(exitCode);\n+        }\n+    }\n+\n+    private static class ExitException extends RuntimeException {\n+        @java.io.Serial\n+        static final long serialVersionUID = 0L;\n+        private final int errorCode;\n+        public ExitException(int errorCode) {\n+            this.errorCode = errorCode;\n+        }\n+    }\n+\n+    public int run(String[] args) {\n+        try {\n+            run0(args);\n+            return 0;\n+        } catch (ExitException ee) {\n+            return ee.errorCode;\n+        }\n+    }\n+\n+    private void run0(String[] args) throws ExitException {\n@@ -82,2 +107,1 @@\n-            ktab.printHelp();\n-            System.exit(0);\n+            printHelp();\n@@ -86,1 +110,1 @@\n-            ktab.action = 'l';\n+            action = 'l';\n@@ -88,1 +112,1 @@\n-            ktab.processArgs(args);\n+            processArgs(args);\n@@ -90,3 +114,3 @@\n-        ktab.table = KeyTab.getInstance(ktab.name);\n-        if (ktab.table.isMissing() && ktab.action != 'a') {\n-            if (ktab.name == null) {\n+        table = KeyTab.getInstance(name);\n+        if (table.isMissing() && action != 'a') {\n+            if (name == null) {\n@@ -96,1 +120,1 @@\n-                        ktab.name + \" does not exist.\");\n+                        name + \" does not exist.\");\n@@ -98,1 +122,1 @@\n-            System.exit(-1);\n+            throw new ExitException(-1);\n@@ -100,2 +124,2 @@\n-        if (!ktab.table.isValid()) {\n-            if (ktab.name == null) {\n+        if (!table.isValid()) {\n+            if (name == null) {\n@@ -106,1 +130,1 @@\n-                        ktab.name + \" is incorrect.\");\n+                        name + \" is incorrect.\");\n@@ -108,1 +132,1 @@\n-            System.exit(-1);\n+            throw new ExitException(-1);\n@@ -110,1 +134,1 @@\n-        switch (ktab.action) {\n+        switch (action) {\n@@ -112,1 +136,1 @@\n-            ktab.listKt();\n+            listKt();\n@@ -115,1 +139,1 @@\n-            ktab.addEntry();\n+            addEntry();\n@@ -118,1 +142,1 @@\n-            ktab.deleteEntry();\n+            deleteEntry();\n@@ -121,1 +145,1 @@\n-            ktab.error(\"A command must be provided\");\n+            error(\"A command must be provided\");\n@@ -270,1 +294,1 @@\n-            System.exit(-1);\n+            throw new ExitException(-1);\n@@ -279,1 +303,1 @@\n-            System.exit(-1);\n+            throw new ExitException(-1);\n@@ -291,1 +315,1 @@\n-                System.exit(-1);\n+                throw new ExitException(-1);\n@@ -316,1 +340,1 @@\n-            System.exit(-1);\n+            throw new ExitException(-1);\n@@ -320,1 +344,1 @@\n-            System.exit(-1);\n+            throw new ExitException(-1);\n@@ -402,2 +426,3 @@\n-                    answer.equalsIgnoreCase(\"Yes\"));\n-                else {\n+                    answer.equalsIgnoreCase(\"Yes\")) {\n+                    ;\n+                } else {\n@@ -405,1 +430,1 @@\n-                    System.exit(0);\n+                    return;\n@@ -412,1 +437,1 @@\n-            System.exit(-1);\n+            throw new ExitException(-1);\n@@ -417,1 +442,1 @@\n-            System.exit(-1);\n+            throw new ExitException(-1);\n@@ -425,1 +450,1 @@\n-            System.exit(-1);\n+            throw new ExitException(-1);\n@@ -433,1 +458,1 @@\n-                System.exit(-1);\n+                throw new ExitException(-1);\n@@ -444,1 +469,1 @@\n-        System.exit(-1);\n+        throw new ExitException(-1);\n","filename":"src\/java.security.jgss\/windows\/classes\/sun\/security\/krb5\/internal\/tools\/Ktab.java","additions":57,"deletions":32,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -5407,31 +5407,31 @@\n-            if (c.isSealed() &&\n-                    !c.isEnum() &&\n-                    !c.isPermittedExplicit &&\n-                    c.permitted.isEmpty()) {\n-                log.error(TreeInfo.diagnosticPositionFor(c, env.tree), Errors.SealedClassMustHaveSubclasses);\n-            }\n-\n-            if (c.isSealed()) {\n-                Set<Symbol> permittedTypes = new HashSet<>();\n-                boolean sealedInUnnamed = c.packge().modle == syms.unnamedModule || c.packge().modle == syms.noModule;\n-                for (Symbol subTypeSym : c.permitted) {\n-                    boolean isTypeVar = false;\n-                    if (subTypeSym.type.getTag() == TYPEVAR) {\n-                        isTypeVar = true; \/\/error recovery\n-                        log.error(TreeInfo.diagnosticPositionFor(subTypeSym, env.tree),\n-                                Errors.InvalidPermitsClause(Fragments.IsATypeVariable(subTypeSym.type)));\n-                    }\n-                    if (subTypeSym.isAnonymous() && !c.isEnum()) {\n-                        log.error(TreeInfo.diagnosticPositionFor(subTypeSym, env.tree),  Errors.LocalClassesCantExtendSealed(Fragments.Anonymous));\n-                    }\n-                    if (permittedTypes.contains(subTypeSym)) {\n-                        DiagnosticPosition pos =\n-                                env.enclClass.permitting.stream()\n-                                        .filter(permittedExpr -> TreeInfo.diagnosticPositionFor(subTypeSym, permittedExpr, true) != null)\n-                                        .limit(2).collect(List.collector()).get(1);\n-                        log.error(pos, Errors.InvalidPermitsClause(Fragments.IsDuplicated(subTypeSym.type)));\n-                    } else {\n-                        permittedTypes.add(subTypeSym);\n-                    }\n-                    if (sealedInUnnamed) {\n-                        if (subTypeSym.packge() != c.packge()) {\n+            \/\/ The info.lint field in the envs stored in typeEnvs is deliberately uninitialized,\n+            \/\/ because the annotations were not available at the time the env was created. Therefore,\n+            \/\/ we look up the environment chain for the first enclosing environment for which the\n+            \/\/ lint value is set. Typically, this is the parent env, but might be further if there\n+            \/\/ are any envs created as a result of TypeParameter nodes.\n+            Env<AttrContext> lintEnv = env;\n+            while (lintEnv.info.lint == null)\n+                lintEnv = lintEnv.next;\n+\n+            \/\/ Having found the enclosing lint value, we can initialize the lint value for this class\n+            env.info.lint = lintEnv.info.lint.augment(c);\n+\n+            Lint prevLint = chk.setLint(env.info.lint);\n+            JavaFileObject prev = log.useSource(c.sourcefile);\n+            ResultInfo prevReturnRes = env.info.returnResult;\n+\n+            try {\n+                if (c.isSealed() &&\n+                        !c.isEnum() &&\n+                        !c.isPermittedExplicit &&\n+                        c.permitted.isEmpty()) {\n+                    log.error(TreeInfo.diagnosticPositionFor(c, env.tree), Errors.SealedClassMustHaveSubclasses);\n+                }\n+\n+                if (c.isSealed()) {\n+                    Set<Symbol> permittedTypes = new HashSet<>();\n+                    boolean sealedInUnnamed = c.packge().modle == syms.unnamedModule || c.packge().modle == syms.noModule;\n+                    for (Symbol subTypeSym : c.permitted) {\n+                        boolean isTypeVar = false;\n+                        if (subTypeSym.type.getTag() == TYPEVAR) {\n+                            isTypeVar = true; \/\/error recovery\n@@ -5439,2 +5439,1 @@\n-                                    Errors.ClassInUnnamedModuleCantExtendSealedInDiffPackage(c)\n-                            );\n+                                    Errors.InvalidPermitsClause(Fragments.IsATypeVariable(subTypeSym.type)));\n@@ -5442,18 +5441,19 @@\n-                    } else if (subTypeSym.packge().modle != c.packge().modle) {\n-                        log.error(TreeInfo.diagnosticPositionFor(subTypeSym, env.tree),\n-                                Errors.ClassInModuleCantExtendSealedInDiffModule(c, c.packge().modle)\n-                        );\n-                    }\n-                    if (subTypeSym == c.type.tsym || types.isSuperType(subTypeSym.type, c.type)) {\n-                        log.error(TreeInfo.diagnosticPositionFor(subTypeSym, ((JCClassDecl)env.tree).permitting),\n-                                Errors.InvalidPermitsClause(\n-                                        subTypeSym == c.type.tsym ?\n-                                                Fragments.MustNotBeSameClass :\n-                                                Fragments.MustNotBeSupertype(subTypeSym.type)\n-                                )\n-                        );\n-                    } else if (!isTypeVar) {\n-                        boolean thisIsASuper = types.directSupertypes(subTypeSym.type)\n-                                                    .stream()\n-                                                    .anyMatch(d -> d.tsym == c);\n-                        if (!thisIsASuper) {\n+                        if (subTypeSym.isAnonymous() && !c.isEnum()) {\n+                            log.error(TreeInfo.diagnosticPositionFor(subTypeSym, env.tree),  Errors.LocalClassesCantExtendSealed(Fragments.Anonymous));\n+                        }\n+                        if (permittedTypes.contains(subTypeSym)) {\n+                            DiagnosticPosition pos =\n+                                    env.enclClass.permitting.stream()\n+                                            .filter(permittedExpr -> TreeInfo.diagnosticPositionFor(subTypeSym, permittedExpr, true) != null)\n+                                            .limit(2).collect(List.collector()).get(1);\n+                            log.error(pos, Errors.InvalidPermitsClause(Fragments.IsDuplicated(subTypeSym.type)));\n+                        } else {\n+                            permittedTypes.add(subTypeSym);\n+                        }\n+                        if (sealedInUnnamed) {\n+                            if (subTypeSym.packge() != c.packge()) {\n+                                log.error(TreeInfo.diagnosticPositionFor(subTypeSym, env.tree),\n+                                        Errors.ClassInUnnamedModuleCantExtendSealedInDiffPackage(c)\n+                                );\n+                            }\n+                        } else if (subTypeSym.packge().modle != c.packge().modle) {\n@@ -5461,1 +5461,19 @@\n-                                    Errors.InvalidPermitsClause(Fragments.DoesntExtendSealed(subTypeSym.type)));\n+                                    Errors.ClassInModuleCantExtendSealedInDiffModule(c, c.packge().modle)\n+                            );\n+                        }\n+                        if (subTypeSym == c.type.tsym || types.isSuperType(subTypeSym.type, c.type)) {\n+                            log.error(TreeInfo.diagnosticPositionFor(subTypeSym, ((JCClassDecl)env.tree).permitting),\n+                                    Errors.InvalidPermitsClause(\n+                                            subTypeSym == c.type.tsym ?\n+                                                    Fragments.MustNotBeSameClass :\n+                                                    Fragments.MustNotBeSupertype(subTypeSym.type)\n+                                    )\n+                            );\n+                        } else if (!isTypeVar) {\n+                            boolean thisIsASuper = types.directSupertypes(subTypeSym.type)\n+                                                        .stream()\n+                                                        .anyMatch(d -> d.tsym == c);\n+                            if (!thisIsASuper) {\n+                                log.error(TreeInfo.diagnosticPositionFor(subTypeSym, env.tree),\n+                                        Errors.InvalidPermitsClause(Fragments.DoesntExtendSealed(subTypeSym.type)));\n+                            }\n@@ -5465,1 +5483,0 @@\n-            }\n@@ -5467,5 +5484,5 @@\n-            List<ClassSymbol> sealedSupers = types.directSupertypes(c.type)\n-                                                  .stream()\n-                                                  .filter(s -> s.tsym.isSealed())\n-                                                  .map(s -> (ClassSymbol) s.tsym)\n-                                                  .collect(List.collector());\n+                List<ClassSymbol> sealedSupers = types.directSupertypes(c.type)\n+                                                      .stream()\n+                                                      .filter(s -> s.tsym.isSealed())\n+                                                      .map(s -> (ClassSymbol) s.tsym)\n+                                                      .collect(List.collector());\n@@ -5473,3 +5490,3 @@\n-            if (sealedSupers.isEmpty()) {\n-                if ((c.flags_field & Flags.NON_SEALED) != 0) {\n-                    boolean hasErrorSuper = false;\n+                if (sealedSupers.isEmpty()) {\n+                    if ((c.flags_field & Flags.NON_SEALED) != 0) {\n+                        boolean hasErrorSuper = false;\n@@ -5477,3 +5494,3 @@\n-                    hasErrorSuper |= types.directSupertypes(c.type)\n-                                          .stream()\n-                                          .anyMatch(s -> s.tsym.kind == Kind.ERR);\n+                        hasErrorSuper |= types.directSupertypes(c.type)\n+                                              .stream()\n+                                              .anyMatch(s -> s.tsym.kind == Kind.ERR);\n@@ -5481,1 +5498,1 @@\n-                    ClassType ct = (ClassType) c.type;\n+                        ClassType ct = (ClassType) c.type;\n@@ -5483,1 +5500,1 @@\n-                    hasErrorSuper |= !ct.isCompound() && ct.interfaces_field != ct.all_interfaces_field;\n+                        hasErrorSuper |= !ct.isCompound() && ct.interfaces_field != ct.all_interfaces_field;\n@@ -5485,2 +5502,7 @@\n-                    if (!hasErrorSuper) {\n-                        log.error(TreeInfo.diagnosticPositionFor(c, env.tree), Errors.NonSealedWithNoSealedSupertype(c));\n+                        if (!hasErrorSuper) {\n+                            log.error(TreeInfo.diagnosticPositionFor(c, env.tree), Errors.NonSealedWithNoSealedSupertype(c));\n+                        }\n+                    }\n+                } else {\n+                    if (c.isDirectlyOrIndirectlyLocal() && !c.isEnum()) {\n+                        log.error(TreeInfo.diagnosticPositionFor(c, env.tree), Errors.LocalClassesCantExtendSealed(c.isAnonymous() ? Fragments.Anonymous : Fragments.Local));\n@@ -5488,5 +5510,0 @@\n-                }\n-            } else {\n-                if (c.isDirectlyOrIndirectlyLocal() && !c.isEnum()) {\n-                    log.error(TreeInfo.diagnosticPositionFor(c, env.tree), Errors.LocalClassesCantExtendSealed(c.isAnonymous() ? Fragments.Anonymous : Fragments.Local));\n-                }\n@@ -5494,4 +5511,11 @@\n-                if (!c.type.isCompound()) {\n-                    for (ClassSymbol supertypeSym : sealedSupers) {\n-                        if (!supertypeSym.permitted.contains(c.type.tsym)) {\n-                            log.error(TreeInfo.diagnosticPositionFor(c.type.tsym, env.tree), Errors.CantInheritFromSealed(supertypeSym));\n+                    if (!c.type.isCompound()) {\n+                        for (ClassSymbol supertypeSym : sealedSupers) {\n+                            if (!supertypeSym.permitted.contains(c.type.tsym)) {\n+                                log.error(TreeInfo.diagnosticPositionFor(c.type.tsym, env.tree), Errors.CantInheritFromSealed(supertypeSym));\n+                            }\n+                        }\n+                        if (!c.isNonSealed() && !c.isFinal() && !c.isSealed()) {\n+                            log.error(TreeInfo.diagnosticPositionFor(c, env.tree),\n+                                    c.isInterface() ?\n+                                            Errors.NonSealedOrSealedExpected :\n+                                            Errors.NonSealedSealedOrFinalExpected);\n@@ -5499,6 +5523,0 @@\n-                    }\n-                    if (!c.isNonSealed() && !c.isFinal() && !c.isSealed()) {\n-                        log.error(TreeInfo.diagnosticPositionFor(c, env.tree),\n-                                c.isInterface() ?\n-                                        Errors.NonSealedOrSealedExpected :\n-                                        Errors.NonSealedSealedOrFinalExpected);\n@@ -5507,1 +5525,0 @@\n-            }\n@@ -5509,17 +5526,0 @@\n-            \/\/ The info.lint field in the envs stored in typeEnvs is deliberately uninitialized,\n-            \/\/ because the annotations were not available at the time the env was created. Therefore,\n-            \/\/ we look up the environment chain for the first enclosing environment for which the\n-            \/\/ lint value is set. Typically, this is the parent env, but might be further if there\n-            \/\/ are any envs created as a result of TypeParameter nodes.\n-            Env<AttrContext> lintEnv = env;\n-            while (lintEnv.info.lint == null)\n-                lintEnv = lintEnv.next;\n-\n-            \/\/ Having found the enclosing lint value, we can initialize the lint value for this class\n-            env.info.lint = lintEnv.info.lint.augment(c);\n-\n-            Lint prevLint = chk.setLint(env.info.lint);\n-            JavaFileObject prev = log.useSource(c.sourcefile);\n-            ResultInfo prevReturnRes = env.info.returnResult;\n-\n-            try {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":101,"deletions":101,"binary":false,"changes":202,"status":"modified"},{"patch":"@@ -4653,1 +4653,1 @@\n-                    hasBindings(patternLabel.pat)) {\n+                    (hasBindings(patternLabel.pat) || hasBindings(c.guard))) {\n@@ -4657,1 +4657,1 @@\n-                           hasBindings(patternLabel.pat) &&\n+                           (hasBindings(patternLabel.pat) || hasBindings(c.guard)) &&\n@@ -4666,1 +4666,1 @@\n-    boolean hasBindings(JCPattern p) {\n+    boolean hasBindings(JCTree p) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3608,0 +3608,12 @@\n+\n+        @Override\n+        Symbol access(Env<AttrContext> env, DiagnosticPosition pos, Symbol location, Symbol sym) {\n+            if (originalSite.hasTag(TYPEVAR) && sym.kind == MTH) {\n+                sym = (sym.flags() & Flags.PRIVATE) != 0 ?\n+                        new AccessError(env, site, sym) :\n+                        sym;\n+                return accessBase(sym, pos, location, originalSite, name, true);\n+            } else {\n+                return super.access(env, pos, location, sym);\n+            }\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -170,1 +170,1 @@\n-    private final Set<Pair<JCTree, RefSet<Ref>>> invocations = new HashSet<>();\n+    private final Set<Pair<JCMethodDecl, RefSet<Ref>>> invocations = new HashSet<>();\n@@ -593,1 +593,1 @@\n-            Pair<JCTree, RefSet<Ref>> invocation = Pair.of(site, refs.clone());\n+            Pair<JCMethodDecl, RefSet<Ref>> invocation = Pair.of(methodInfo.declaration, refs.clone());\n@@ -681,1 +681,5 @@\n-        visitLooped(tree, super::visitForeachLoop);\n+        visitLooped(tree, foreach -> {\n+            scan(foreach.expr);\n+            refs.discardExprs(depth);       \/\/ we don't handle iterator() yet\n+            scan(foreach.body);\n+        });\n@@ -732,1 +736,4 @@\n-        visitDeferred(() -> visitScoped(false, () -> super.visitLambda(lambda)));\n+        visitDeferred(() -> visitScoped(false, () -> {\n+            scan(lambda.body);\n+            refs.discardExprs(depth);       \/\/ needed in case body is a JCExpression\n+        }));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ThisEscapeAnalyzer.java","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -912,0 +912,1 @@\n+                checkNoMods(pos, mods.flags & Flags.FINAL);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1653,1 +1653,1 @@\n-                    node.body.stats.nonEmpty() && TreeInfo.isSuperCall(node.body.stats.head) &&\n+                    node.body != null && node.body.stats.nonEmpty() && TreeInfo.isSuperCall(node.body.stats.head) &&\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/processing\/JavacProcessingEnvironment.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1324,9 +1324,0 @@\n-    public static JCModuleDecl getModule(JCCompilationUnit t) {\n-        if (t.defs.nonEmpty()) {\n-            JCTree def = t.defs.head;\n-            if (def.hasTag(MODULEDEF))\n-                return (JCModuleDecl) def;\n-        }\n-        return null;\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -762,0 +762,2 @@\n+\\f[V]restricted\\f[R]: Warns about the use of restricted methods.\n+.IP \\[bu] 2\n","filename":"src\/jdk.compiler\/share\/man\/javac.1","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -431,0 +431,1 @@\n+    @java.io.Serial\n@@ -433,1 +434,1 @@\n-            throw new NotSerializableException(\"Token has been removed\");\n+            throw new InvalidObjectException(\"Token has been removed\");\n@@ -438,0 +439,16 @@\n+    \/**\n+     * Restores the state of this object from the stream.\n+     * <p>\n+     * Deserialization of this object is not supported.\n+     *\n+     * @param  stream the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n+     *\/\n+    @java.io.Serial\n+    private void readObject(ObjectInputStream stream)\n+            throws IOException, ClassNotFoundException {\n+        throw new InvalidObjectException(\n+                \"Tokens are not directly deserializable\");\n+    }\n+\n@@ -452,0 +469,1 @@\n+        @java.io.Serial\n@@ -461,1 +479,1 @@\n-            throw new NotSerializableException(\"Could not find token\");\n+            throw new InvalidObjectException(\"Could not find token\");\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/Token.java","additions":21,"deletions":3,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import java.io.IOException;\n+import java.io.InvalidObjectException;\n+import java.io.ObjectInputStream;\n@@ -38,0 +41,1 @@\n+    @java.io.Serial\n@@ -75,0 +79,1 @@\n+    @java.io.Serial\n@@ -77,1 +82,18 @@\n-        throw new java.io.NotSerializableException();\n+        throw new java.io.InvalidObjectException(\n+                \"CPrivateKeys are not serializable\");\n+    }\n+\n+    \/**\n+     * Restores the state of this object from the stream.\n+     * <p>\n+     * Deserialization of this object is not supported.\n+     *\n+     * @param  stream the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n+     *\/\n+    @java.io.Serial\n+    private void readObject(ObjectInputStream stream)\n+            throws IOException, ClassNotFoundException {\n+        throw new InvalidObjectException(\n+                \"CPrivateKeys are not deserializable\");\n","filename":"src\/jdk.crypto.mscapi\/windows\/classes\/sun\/security\/mscapi\/CPrivateKey.java","additions":24,"deletions":2,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -28,0 +28,3 @@\n+import java.io.IOException;\n+import java.io.InvalidObjectException;\n+import java.io.ObjectInputStream;\n@@ -53,0 +56,1 @@\n+    @java.io.Serial\n@@ -61,0 +65,2 @@\n+\n+        @java.io.Serial\n@@ -112,1 +118,1 @@\n-            sb.append(algorithm + \"PublicKey [size=\").append(keyLength)\n+            sb.append(algorithm).append(\"PublicKey [size=\").append(keyLength)\n@@ -123,0 +129,2 @@\n+\n+        @java.io.Serial\n@@ -131,1 +139,1 @@\n-            sb.append(algorithm + \"PublicKey [size=\").append(keyLength)\n+            sb.append(algorithm).append(\"PublicKey [size=\").append(keyLength)\n@@ -218,0 +226,1 @@\n+    @java.io.Serial\n@@ -225,0 +234,16 @@\n+    \/**\n+     * Restores the state of this object from the stream.\n+     * <p>\n+     * Deserialization of this object is not supported.\n+     *\n+     * @param  stream the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n+     *\/\n+    @java.io.Serial\n+    private void readObject(ObjectInputStream stream)\n+            throws IOException, ClassNotFoundException {\n+        throw new InvalidObjectException(\n+                \"CPublicKeys are not deserializable\");\n+    }\n+\n","filename":"src\/jdk.crypto.mscapi\/windows\/classes\/sun\/security\/mscapi\/CPublicKey.java","additions":27,"deletions":2,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n- * @since 10\n+ * @since 22\n@@ -38,1 +38,1 @@\n-module jdk.internal.vm.compiler.management {\n+module jdk.graal.compiler.management {\n","filename":"src\/jdk.graal.compiler.management\/share\/classes\/module-info.java","additions":3,"deletions":3,"binary":false,"changes":6,"previous_filename":"src\/jdk.internal.vm.compiler.management\/share\/classes\/module-info.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-  * @since 9\n+  * @since 22\n@@ -39,1 +39,1 @@\n-module jdk.internal.vm.compiler {\n+module jdk.graal.compiler {\n","filename":"src\/jdk.graal.compiler\/share\/classes\/module-info.java","additions":3,"deletions":3,"binary":false,"changes":6,"previous_filename":"src\/jdk.internal.vm.compiler\/share\/classes\/module-info.java","status":"renamed"},{"patch":"@@ -26,2 +26,0 @@\n-import jdk.internal.javac.ParticipatesInPreview;\n-\n@@ -36,1 +34,0 @@\n-@ParticipatesInPreview\n","filename":"src\/jdk.incubator.vector\/share\/classes\/module-info.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -417,1 +417,1 @@\n-            return buffer.get();\n+            return buffer.get() & 0xFF;\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/PumpReader.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1303,0 +1303,5 @@\n+    \/**\n+     * Clears the oop handle in {@code handle}.\n+     *\/\n+    native void clearOopHandle(long handle);\n+\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/CompilerToVM.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -158,1 +158,2 @@\n-     * {@link CompilerToVM#releaseClearedOopHandles}.\n+     * {@link CompilerToVM#releaseClearedOopHandles}. This must be done with a VM call so\n+     * that the JNI handle is cleared at a safepoint.\n@@ -161,1 +162,1 @@\n-        UNSAFE.putLong(handle, 0);\n+        runtime().compilerToVm.clearOopHandle(handle);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/IndirectHotSpotObjectConstantImpl.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -102,1 +102,1 @@\n-        return new RISCV64HotSpotRegisterConfig(target, config.useCompressedOops, config.linuxOs);\n+        return new RISCV64HotSpotRegisterConfig(target, config.useCompressedOops, target.linuxOs);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/riscv64\/RISCV64HotSpotJVMCIBackendFactory.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n-import jdk.vm.ci.services.Services;\n-import jdk.internal.util.OperatingSystem;\n@@ -41,2 +39,0 @@\n-    final boolean linuxOs = OperatingSystem.isLinux();\n-\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/riscv64\/RISCV64HotSpotVMConfig.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,2 +28,2 @@\n-        jdk.internal.vm.compiler,\n-        jdk.internal.vm.compiler.management;\n+        jdk.graal.compiler,\n+        jdk.graal.compiler.management;\n@@ -31,5 +31,5 @@\n-        jdk.internal.vm.compiler,\n-        jdk.internal.vm.compiler.management;\n-    exports jdk.vm.ci.meta to jdk.internal.vm.compiler;\n-    exports jdk.vm.ci.code to jdk.internal.vm.compiler;\n-    exports jdk.vm.ci.hotspot to jdk.internal.vm.compiler;\n+        jdk.graal.compiler,\n+        jdk.graal.compiler.management;\n+    exports jdk.vm.ci.meta to jdk.graal.compiler;\n+    exports jdk.vm.ci.code to jdk.graal.compiler;\n+    exports jdk.vm.ci.hotspot to jdk.graal.compiler;\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/module-info.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -138,1 +138,13 @@\n-        js.run(args);\n+        int exitCode = js.run(args);\n+        if (exitCode != 0) {\n+            System.exit(exitCode);\n+        }\n+    }\n+\n+    private static class ExitException extends RuntimeException {\n+        @java.io.Serial\n+        static final long serialVersionUID = 0L;\n+        private final int errorCode;\n+        public ExitException(int errorCode) {\n+            this.errorCode = errorCode;\n+        }\n@@ -233,1 +245,1 @@\n-    public void run(String args[]) {\n+    public int run(String args[]) {\n@@ -235,1 +247,1 @@\n-            args = parseArgs(args);\n+            parseArgs(args);\n@@ -239,1 +251,1 @@\n-                for (String provName: providers) {\n+                for (String provName : providers) {\n@@ -266,1 +278,1 @@\n-                for (String provClass: providerClasses) {\n+                for (String provClass : providerClasses) {\n@@ -288,6 +300,1 @@\n-                        System.out.println(rb.getString(\"jarsigner.error.\") +\n-                                        e.getMessage());\n-                        if (debug) {\n-                            e.printStackTrace();\n-                        }\n-                        System.exit(1);\n+                        throw e;\n@@ -296,5 +303,0 @@\n-                \/*              if (debug) {\n-                    SignatureFileVerifier.setDebug(true);\n-                    ManifestEntryVerifier.setDebug(true);\n-                }\n-                *\/\n@@ -308,0 +310,2 @@\n+        } catch (ExitException ee) {\n+            return ee.errorCode;\n@@ -313,1 +317,1 @@\n-            System.exit(1);\n+            return 1;\n@@ -346,3 +350,1 @@\n-            if (exitCode != 0) {\n-                System.exit(exitCode);\n-            }\n+            return exitCode;\n@@ -350,0 +352,2 @@\n+\n+        return 0;\n@@ -615,1 +619,1 @@\n-        System.exit(1);\n+        throw new ExitException(1);\n@@ -620,1 +624,1 @@\n-        System.exit(0);\n+        throw new ExitException(0);\n@@ -722,1 +726,1 @@\n-        System.exit(0);\n+        throw new ExitException(0);\n@@ -1108,6 +1112,0 @@\n-            return;\n-        } catch (Exception e) {\n-            System.out.println(rb.getString(\"jarsigner.\") + e);\n-            if (debug) {\n-                e.printStackTrace();\n-            }\n@@ -1119,2 +1117,0 @@\n-\n-        System.exit(1);\n@@ -2472,1 +2468,1 @@\n-        System.exit(1);\n+        throw new ExitException(1);\n@@ -2481,1 +2477,1 @@\n-        System.exit(1);\n+        throw new ExitException(1);\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/security\/tools\/jarsigner\/Main.java","additions":29,"deletions":33,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -540,0 +540,10 @@\n+    \/**\n+     * Add the restricted information for the given method.\n+     *\n+     * @param method the method being documented.\n+     * @param content the content to which the preview information will be added.\n+     *\/\n+    protected void addRestrictedInfo(ExecutableElement method, Content content) {\n+        writer.addRestrictedInfo(method, content);\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/AbstractMemberWriter.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -116,0 +116,5 @@\n+    @Override\n+    public boolean isIndexable() {\n+        return true;\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/AbstractOverviewIndexWriter.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -97,3 +97,3 @@\n-\n-                buildAnnotationTypeMemberChildren(annotationContent);\n-\n+                Content div = HtmlTree.DIV(HtmlStyle.horizontalScroll);\n+                buildAnnotationTypeMemberChildren(div);\n+                annotationContent.add(div);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/AnnotationTypeMemberWriter.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -161,1 +161,1 @@\n-        Content c = new ContentBuilder();\n+        Content c = HtmlTree.DIV(HtmlStyle.horizontalScroll);\n@@ -772,0 +772,5 @@\n+\n+    @Override\n+    public boolean isIndexable() {\n+        return true;\n+    }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/ClassWriter.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -109,7 +109,7 @@\n-\n-                buildSignature(constructorContent);\n-                buildDeprecationInfo(constructorContent);\n-                buildPreviewInfo(constructorContent);\n-                buildConstructorComments(constructorContent);\n-                buildTagInfo(constructorContent);\n-\n+                Content div = HtmlTree.DIV(HtmlStyle.horizontalScroll);\n+                buildSignature(div);\n+                buildDeprecationInfo(div);\n+                buildPreviewInfo(div);\n+                buildConstructorComments(div);\n+                buildTagInfo(div);\n+                constructorContent.add(div);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/ConstructorWriter.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -160,0 +160,3 @@\n+    public final Content restrictedMark;\n+    public final Content restrictedMethods;\n+    public final Content restrictedPhrase;\n@@ -306,0 +309,3 @@\n+        restrictedMark = getContent(\"doclet.Restricted_Mark\");\n+        restrictedMethods = getContent(\"doclet.Restricted_Methods\");\n+        restrictedPhrase = getContent(\"doclet.Restricted\");\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/Contents.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -304,0 +304,5 @@\n+\n+        @Override\n+        public boolean isIndexable() {\n+            return true;\n+        }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/DocFilesHandler.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -76,7 +76,7 @@\n-\n-                buildSignature(enumConstantContent);\n-                buildDeprecationInfo(enumConstantContent);\n-                buildPreviewInfo(enumConstantContent);\n-                buildEnumConstantComments(enumConstantContent);\n-                buildTagInfo(enumConstantContent);\n-\n+                Content div = HtmlTree.DIV(HtmlStyle.horizontalScroll);\n+                buildSignature(div);\n+                buildDeprecationInfo(div);\n+                buildPreviewInfo(div);\n+                buildEnumConstantComments(div);\n+                buildTagInfo(div);\n+                enumConstantContent.add(div);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/EnumConstantWriter.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -86,7 +86,7 @@\n-\n-                buildSignature(fieldContent);\n-                buildDeprecationInfo(fieldContent);\n-                buildPreviewInfo(fieldContent);\n-                buildFieldComments(fieldContent);\n-                buildTagInfo(fieldContent);\n-\n+                Content div = HtmlTree.DIV(HtmlStyle.horizontalScroll);\n+                buildSignature(div);\n+                buildDeprecationInfo(div);\n+                buildPreviewInfo(div);\n+                buildFieldComments(div);\n+                buildTagInfo(div);\n+                fieldContent.add(div);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/FieldWriter.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -345,0 +345,9 @@\n+        \/\/ Restricted\n+        if (configuration.conditionalPages.contains(HtmlConfiguration.ConditionalPage.RESTRICTED)) {\n+            section = newHelpSection(contents.restrictedMethods, PageMode.RESTRICTED, subTOC);\n+            Content restrictedBody = getContent(\"doclet.help.restricted.body\",\n+                    links.createLink(DocPaths.RESTRICTED_LIST, resources.getText(\"doclet.Restricted_Methods\")));\n+            section.add(HtmlTree.P(restrictedBody));\n+            pageKindsSection.add(section);\n+        }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HelpWriter.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -71,0 +71,1 @@\n+import jdk.javadoc.internal.doclets.toolkit.util.RestrictedAPIListBuilder;\n@@ -142,0 +143,8 @@\n+    \/**\n+     * The collection of restricted methods, if any, to be displayed on the\n+     * restricted-list page, or null if the page should not be generated.\n+     * The page will not be generated if there are no restricted methods to be\n+     * documented.\n+     *\/\n+    protected RestrictedAPIListBuilder restrictedAPIListBuilder;\n+\n@@ -165,1 +174,2 @@\n-        CONSTANT_VALUES, DEPRECATED, EXTERNAL_SPECS, PREVIEW, SERIALIZED_FORM, SYSTEM_PROPERTIES, NEW\n+        CONSTANT_VALUES, DEPRECATED, EXTERNAL_SPECS, PREVIEW, RESTRICTED,\n+        SERIALIZED_FORM, SYSTEM_PROPERTIES, NEW\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlConfiguration.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+import jdk.javadoc.internal.doclets.toolkit.util.RestrictedAPIListBuilder;\n@@ -198,0 +199,5 @@\n+        RestrictedAPIListBuilder restrictedBuilder = new RestrictedAPIListBuilder(configuration);\n+        if (!restrictedBuilder.isEmpty()) {\n+            configuration.restrictedAPIListBuilder = restrictedBuilder;\n+            configuration.conditionalPages.add(HtmlConfiguration.ConditionalPage.RESTRICTED);\n+        }\n@@ -250,0 +256,1 @@\n+                HtmlConfiguration.ConditionalPage.RESTRICTED,\n@@ -256,0 +263,1 @@\n+                    case RESTRICTED -> writerFactory.newRestrictedListWriter();\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlDoclet.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -414,0 +414,14 @@\n+    \/**\n+     * {@return true if the page written by this writer should be indexed,\n+     * false otherwise}\n+     *\n+     * Some pages merely aggregate filtered information available on other pages\n+     * and, thus, have no indexing value. In fact, if indexed, they would\n+     * clutter the index and mislead the reader.\n+     *\n+     * @implSpec The default implementation returns {@code false}.\n+     *\/\n+    public boolean isIndexable() {\n+        return false;\n+    }\n+\n@@ -507,1 +521,1 @@\n-    protected HtmlTree getHeader(Navigation.PageMode pageMode) {\n+    protected Content getHeader(Navigation.PageMode pageMode) {\n@@ -520,1 +534,1 @@\n-    protected HtmlTree getHeader(Navigation.PageMode pageMode, Element element) {\n+    protected Content getHeader(Navigation.PageMode pageMode, Element element) {\n@@ -522,2 +536,2 @@\n-                .add(RawHtml.of(replaceDocRootDir(options.top())))\n-                .add(getNavBar(pageMode, element).getContent());\n+                        .add(RawHtml.of(replaceDocRootDir(options.top())))\n+                        .add(getNavBar(pageMode, element).getContent());\n@@ -1372,1 +1386,2 @@\n-                    if (node.getName().toString().matches(\"(?i)h[1-6]\")) {\n+                    if (node.getName().toString().matches(\"(?i)h[1-6]\")\n+                            && isIndexable()) {\n@@ -2056,0 +2071,8 @@\n+    public void addRestrictedSummary(Element forWhat, Content target) {\n+        if (utils.isRestrictedAPI(forWhat)) {\n+            var div = HtmlTree.DIV(HtmlStyle.block);\n+            div.add(HtmlTree.SPAN(HtmlStyle.restrictedLabel, contents.restrictedPhrase));\n+            target.add(div);\n+        }\n+    }\n+\n@@ -2206,0 +2229,20 @@\n+    public void addRestrictedInfo(ExecutableElement forWhat, Content target) {\n+        if (utils.isRestrictedAPI(forWhat)) {\n+            \/\/in Java platform:\n+            var restrictedDiv = HtmlTree.DIV(HtmlStyle.restrictedBlock);\n+            restrictedDiv.setId(htmlIds.forRestrictedSection(forWhat));\n+            String name = forWhat.getSimpleName().toString();\n+            var nameCode = HtmlTree.CODE(Text.of(name));\n+            String leadingNoteKey = \"doclet.RestrictedLeadingNote\";\n+            Content leadingNote =\n+                    contents.getContent(leadingNoteKey, nameCode);\n+            restrictedDiv.add(HtmlTree.SPAN(HtmlStyle.restrictedLabel,\n+                    leadingNote));\n+            Content note1 = contents.getContent(\"doclet.RestrictedTrailingNote1\", nameCode);\n+            restrictedDiv.add(HtmlTree.DIV(HtmlStyle.restrictedComment, note1));\n+            Content note2 = contents.getContent(\"doclet.RestrictedTrailingNote2\", nameCode);\n+            restrictedDiv.add(HtmlTree.DIV(HtmlStyle.restrictedComment, note2));\n+            target.add(restrictedDiv);\n+        }\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlDocletWriter.java","additions":48,"deletions":5,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -492,0 +492,11 @@\n+    \/**\n+     * Returns an id for the \"restricted\" section for an executable element.\n+     *\n+     * @param el the executable element\n+     *\n+     * @return the id\n+     *\/\n+    public HtmlId forRestrictedSection(ExecutableElement el) {\n+        return HtmlId.of(\"restricted-\" + forMember(el).name());\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlIds.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.util.function.Consumer;\n@@ -35,0 +36,1 @@\n+import javax.lang.model.element.ExecutableElement;\n@@ -45,0 +47,1 @@\n+import jdk.javadoc.internal.doclets.formats.html.markup.Entity;\n@@ -238,0 +241,1 @@\n+        ExecutableElement restrictedTarget;\n@@ -242,0 +246,1 @@\n+            restrictedTarget = null;\n@@ -244,0 +249,3 @@\n+            \/\/ We piggy back on whether to show preview info, for both preview AND\n+            \/\/ restricted methods superscripts. That's because when e.g. we are generating a\n+            \/\/ method summary we do not want either superscript.\n@@ -257,0 +265,5 @@\n+            if (flags.contains(ElementFlag.RESTRICTED)) {\n+                restrictedTarget = (ExecutableElement) linkInfo.getTargetMember();\n+            } else {\n+                restrictedTarget = null;\n+            }\n@@ -259,0 +272,1 @@\n+            restrictedTarget = null;\n@@ -272,0 +286,1 @@\n+                        Content spacer = Text.EMPTY;\n@@ -276,0 +291,7 @@\n+                            spacer = Entity.NO_BREAK_SPACE;\n+                        }\n+                        if (flags.contains(ElementFlag.RESTRICTED)) {\n+                            link.add(spacer);\n+                            link.add(HtmlTree.SUP(m_writer.links.createLink(\n+                                    filename.fragment(m_writer.htmlIds.forRestrictedSection(restrictedTarget).name()),\n+                                    m_writer.contents.restrictedMark)));\n@@ -286,0 +308,1 @@\n+                Content spacer = Text.EMPTY;\n@@ -292,0 +315,9 @@\n+                    spacer = Entity.NO_BREAK_SPACE;\n+                }\n+                if (flags.contains(ElementFlag.RESTRICTED)) {\n+                    link.add(spacer);\n+                    link.add(HtmlTree.SUP(m_writer.getCrossClassLink(\n+                            typeElement,\n+                            m_writer.htmlIds.forRestrictedSection(restrictedTarget).name(),\n+                            m_writer.contents.restrictedMark,\n+                            null, false)));\n@@ -298,0 +330,1 @@\n+        Content spacer = Text.EMPTY;\n@@ -300,0 +333,5 @@\n+            spacer = Entity.NO_BREAK_SPACE;\n+        }\n+        if (flags.contains(ElementFlag.RESTRICTED)) {\n+            link.add(spacer);\n+            link.add(HtmlTree.SUP(m_writer.contents.restrictedMark));\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlLinkFactory.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -108,7 +108,8 @@\n-\n-                buildSignature(methodContent);\n-                buildDeprecationInfo(methodContent);\n-                buildPreviewInfo(methodContent);\n-                buildMethodComments(methodContent);\n-                buildTagInfo(methodContent);\n-\n+                Content div = HtmlTree.DIV(HtmlStyle.horizontalScroll);\n+                buildSignature(div);\n+                buildDeprecationInfo(div);\n+                buildPreviewInfo(div);\n+                buildRestrictedInfo(div);\n+                buildMethodComments(div);\n+                buildTagInfo(div);\n+                methodContent.add(div);\n@@ -137,0 +138,9 @@\n+    \/**\n+     * Builds the restricted method info.\n+     *\n+     * @param target the content to which the documentation will be added\n+     *\/\n+    protected void buildRestrictedInfo(Content target) {\n+        addRestricted(currentMethod, target);\n+    }\n+\n@@ -218,0 +228,4 @@\n+    protected void addRestricted(ExecutableElement method, Content content) {\n+        addRestrictedInfo(method, content);\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/MethodWriter.java","additions":21,"deletions":7,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -194,3 +194,5 @@\n-\n-        addModuleSignature(moduleContent);\n-        buildModuleDescription(moduleContent);\n+        moduleContent.add(new HtmlTree(TagName.HR));\n+        Content div = HtmlTree.DIV(HtmlStyle.horizontalScroll);\n+        addModuleSignature(div);\n+        buildModuleDescription(div);\n+        moduleContent.add(div);\n@@ -885,1 +887,0 @@\n-        moduleContent.add(new HtmlTree(TagName.HR));\n@@ -925,0 +926,5 @@\n+\n+    @Override\n+    public boolean isIndexable() {\n+        return true;\n+    }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/ModuleWriter.java","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -94,0 +94,1 @@\n+        RESTRICTED,\n@@ -319,0 +320,1 @@\n+            case RESTRICTED:\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/Navigation.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-    private final HtmlTree section = HtmlTree.SECTION(HtmlStyle.packageDescription, new ContentBuilder());\n+    private final HtmlTree section = HtmlTree.SECTION(HtmlStyle.packageDescription);\n@@ -131,4 +131,6 @@\n-\n-        addPackageSignature(packageContent);\n-        buildPackageDescription(packageContent);\n-        buildPackageTags(packageContent);\n+        packageContent.add(new HtmlTree(TagName.HR));\n+        Content div = HtmlTree.DIV(HtmlStyle.horizontalScroll);\n+        addPackageSignature(div);\n+        buildPackageDescription(div);\n+        buildPackageTags(div);\n+        packageContent.add(div);\n@@ -180,2 +182,2 @@\n-        if (options.noComment()) {\n-            return;\n+        if (!options.noComment()) {\n+            addPackageDescription(packageContent);\n@@ -183,1 +185,0 @@\n-        addPackageDescription(packageContent);\n@@ -192,2 +193,2 @@\n-        if (options.noComment()) {\n-            return;\n+        if (!options.noComment()) {\n+            addPackageTags(packageContent);\n@@ -195,1 +196,0 @@\n-        addPackageTags(packageContent);\n@@ -425,1 +425,0 @@\n-        packageContent.add(new HtmlTree(TagName.HR));\n@@ -459,0 +458,5 @@\n+\n+    @Override\n+    public boolean isIndexable() {\n+        return true;\n+    }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/PackageWriter.java","additions":16,"deletions":12,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -81,7 +81,7 @@\n-\n-                buildSignature(propertyContent);\n-                buildDeprecationInfo(propertyContent);\n-                buildPreviewInfo(propertyContent);\n-                buildPropertyComments(propertyContent);\n-                buildTagInfo(propertyContent);\n-\n+                Content div = HtmlTree.DIV(HtmlStyle.horizontalScroll);\n+                buildSignature(div);\n+                buildDeprecationInfo(div);\n+                buildPreviewInfo(div);\n+                buildPropertyComments(div);\n+                buildTagInfo(div);\n+                propertyContent.add(div);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/PropertyWriter.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html;\n+\n+import javax.lang.model.element.Element;\n+\n+import jdk.javadoc.internal.doclets.formats.html.Navigation.PageMode;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocPaths;\n+import jdk.javadoc.internal.doclets.toolkit.util.IndexItem;\n+import jdk.javadoc.internal.doclets.toolkit.util.RestrictedAPIListBuilder;\n+\n+\/**\n+ * Generate File to list all the restricted methods with the\n+ * appropriate links.\n+ *\/\n+public class RestrictedListWriter extends SummaryListWriter<RestrictedAPIListBuilder> {\n+\n+    \/**\n+     * Constructor.\n+     *\n+     * @param configuration the configuration for this doclet\n+     *\/\n+    public RestrictedListWriter(HtmlConfiguration configuration) {\n+        super(configuration, DocPaths.RESTRICTED_LIST, configuration.restrictedAPIListBuilder);\n+        if (configuration.restrictedAPIListBuilder != null) {\n+            configuration.indexBuilder.add(IndexItem.of(IndexItem.Category.TAGS,\n+                    resources.getText(\"doclet.Restricted_Methods\"), path));\n+        }\n+    }\n+\n+    @Override\n+    protected PageMode getPageMode() {\n+        return PageMode.RESTRICTED;\n+    }\n+\n+    @Override\n+    protected String getDescription() {\n+        return \"restricted methods\";\n+    }\n+\n+    @Override\n+    protected boolean showContentsList() {\n+        \/\/ This list contains only methods, no need to show list of element kinds.\n+        return false;\n+    }\n+\n+    @Override\n+    protected Content getHeadContent() {\n+        return configuration.contents.restrictedMethods;\n+    }\n+\n+    @Override\n+    protected String getTitleKey() {\n+        return \"doclet.Window_Restricted_List\";\n+    }\n+\n+    @Override\n+    protected void addComments(Element e, Content desc) {\n+        addSummaryComment(e, desc);\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/RestrictedListWriter.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -116,0 +116,1 @@\n+        addRestrictedSummary(member, tdSummaryContent);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/SubWriterHolderWriter.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.util.Arrays;\n@@ -141,2 +142,4 @@\n-        content.add(HtmlTree.HEADING_TITLE(Headings.CONTENT_HEADING, contents.contentsHeading));\n-        content.add(getContentsList());\n+        if (showContentsList()) {\n+            content.add(HtmlTree.HEADING_TITLE(Headings.CONTENT_HEADING, contents.contentsHeading));\n+            content.add(getContentsList());\n+        }\n@@ -187,0 +190,7 @@\n+    \/**\n+     * {@return {@code true} if the contents list should be generated, {@code false} if not}\n+     *\/\n+    protected boolean showContentsList() {\n+        return true;\n+    }\n+\n@@ -307,2 +317,2 @@\n-     * Subclasses allow the user to show or hide parts of the content in the page.\n-     * This method should be used to add the UI to select the visible page content.\n+     * Allow Subclasses to add a content selector UI such as a row of radio buttons\n+     * near the top of the page. This method does not add anything.\n@@ -312,1 +322,1 @@\n-    protected abstract void addContentSelectors(Content target);\n+    protected void addContentSelectors(Content target) {}\n@@ -315,2 +325,2 @@\n-     * Some subclasses of this class display an extra column in their element tables.\n-     * This methods allows them to return the content to show for {@code element}.\n+     * Allow subclasses to add an extra table column for an element.\n+     * This methods does not add any content by returning {@code null}.\n@@ -321,1 +331,3 @@\n-    protected abstract Content getExtraContent(Element element);\n+    protected Content getExtraContent(Element element) {\n+        return null;\n+    }\n@@ -355,1 +367,2 @@\n-     * Allow subclasses to add extra tabs to the element tables.\n+     * Allow subclasses to add extra tabs to the element tables. This method does not\n+     * add any tabs.\n@@ -360,1 +373,1 @@\n-    protected abstract void addTableTabs(Table<Element> table, String headingKey);\n+    protected void addTableTabs(Table<Element> table, String headingKey) {}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/SummaryListWriter.java","additions":23,"deletions":10,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -173,0 +173,7 @@\n+    \/**\n+     * {@return a new writer for the list of restricted methods in this release}\n+     *\/\n+    public HtmlDocletWriter newRestrictedListWriter() {\n+        return new RestrictedListWriter(configuration);\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/WriterFactory.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -46,2 +46,2 @@\n-    private HtmlTree header = null;\n-    private HtmlTree footer = null;\n+    private Content header = null;\n+    private Content footer = null;\n@@ -54,1 +54,1 @@\n-    public BodyContents setHeader(HtmlTree header) {\n+    public BodyContents setHeader(Content header) {\n@@ -59,1 +59,1 @@\n-    public BodyContents setFooter(HtmlTree footer) {\n+    public BodyContents setFooter(Content footer) {\n@@ -90,3 +90,2 @@\n-        HtmlTree flexHeader = header.addStyle(HtmlStyle.flexHeader);\n-\n-        var flexContent = HtmlTree.DIV(HtmlStyle.flexContent)\n+        return new ContentBuilder()\n+                .add(header)\n@@ -95,4 +94,0 @@\n-\n-        return HtmlTree.DIV(HtmlStyle.flexBox)\n-                .add(flexHeader)\n-                .add(flexContent);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/markup\/BodyContents.java","additions":6,"deletions":11,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -385,0 +385,16 @@\n+    \/**\n+     * The class for a block describing the \"restricted\" status of a declaration.\n+     *\/\n+    restrictedBlock,\n+\n+    \/**\n+     * The class for the details in a block describing the \"restricted\" status of a declaration.\n+     *\/\n+    restrictedComment,\n+\n+    \/**\n+     * The class for the \"Restricted\" label in a block describing the \"restricted\" status\n+     * of a declaration.\n+     *\/\n+    restrictedLabel,\n+\n@@ -566,23 +582,0 @@\n-    \/\/<editor-fold desc=\"flex layout\">\n-    \/\/\n-    \/\/ The following constants are used for the components of the top-level structures for \"flex\" layout.\n-\n-    \/**\n-     * The class of the top-level {@code div} element used to arrange for \"flex\" layout in\n-     * a browser window. The element should contain two child elements: one with class\n-     * {@link #flexHeader flex-header} and one with class {@link #flexContent flex-content}.\n-     *\/\n-    flexBox,\n-\n-    \/**\n-     * The class of the {@code header} element within a {@link #flexBox flex-box} container.\n-     * The element is always displayed at the top of the viewport.\n-     *\/\n-    flexHeader,\n-\n-    \/**\n-     * The class of the {@code div} element within a {@link #flexBox flex-box} container\n-     * This element appears below the header and can be scrolled if too big for the available height.\n-     *\/\n-    flexContent,\n-    \/\/<\/editor-fold>\n@@ -819,0 +812,5 @@\n+    \/**\n+     * The class of the {@code body} element for the page listing restricted methods.\n+     *\/\n+    restrictedListPage,\n+\n@@ -967,0 +965,5 @@\n+    \/**\n+     * The class of a {@code div} element that allows its horizontal overflow to be scrolled.\n+     *\/\n+    horizontalScroll,\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/markup\/HtmlStyle.java","additions":27,"deletions":24,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -230,1 +230,1 @@\n-\/\/ Workaround for scroll position not being included in browser history (8249133)\n+\/\/ Dynamically set scroll margin to accomodate for draft header\n@@ -232,21 +232,4 @@\n-    var contentDiv = document.querySelector(\"div.flex-content\");\n-    window.addEventListener(\"popstate\", function(e) {\n-        if (e.state !== null) {\n-            contentDiv.scrollTop = e.state;\n-        }\n-    });\n-    window.addEventListener(\"hashchange\", function(e) {\n-        history.replaceState(contentDiv.scrollTop, document.title);\n-    });\n-    var timeoutId;\n-    contentDiv.addEventListener(\"scroll\", function(e) {\n-        if (timeoutId) {\n-            clearTimeout(timeoutId);\n-        }\n-        timeoutId = setTimeout(function() {\n-            history.replaceState(contentDiv.scrollTop, document.title);\n-        }, 100);\n-    });\n-    if (!location.hash) {\n-        history.replaceState(contentDiv.scrollTop, document.title);\n-    }\n+    document.querySelectorAll(':not(input)[id]').forEach(\n+        function(c) {\n+            c.style[\"scroll-margin-top\"] = Math.ceil(document.querySelector(\"header\").offsetHeight) + \"px\"\n+        });\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/script.js","additions":5,"deletions":22,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -88,0 +88,1 @@\n+doclet.Window_Restricted_List=Restricted Method List\n@@ -132,0 +133,2 @@\n+doclet.Restricted_Methods=Restricted Methods\n+doclet.Restricted_Mark=RESTRICTED\n@@ -306,0 +309,3 @@\n+doclet.help.restricted.body=\\\n+    The {0} page lists all restricted methods. Restricted methods are unsafe, and, if used \\\n+    incorrectly, might crash the JVM or result in memory corruption.\n@@ -413,0 +419,4 @@\n+doclet.RestrictedLeadingNote={0} is a restricted method of the Java platform.\n+doclet.RestrictedTrailingNote1=Programs can only use {0} when access to restricted methods is enabled.\n+doclet.RestrictedTrailingNote2=Restricted methods are unsafe, and, if used incorrectly, might crash \\\n+    the JVM or result in memory corruption.\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/standard.properties","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -87,0 +87,3 @@\n+:not(input)[id] {\n+    scroll-margin-top: 78px;\n+}\n@@ -175,13 +178,5 @@\n-    div.flex-box {\n-        position:fixed;\n-        display:flex;\n-        flex-direction:column;\n-        height: 100%;\n-        width: 100%;\n-    }\n-    header.flex-header {\n-        flex: 0 0 auto;\n-    }\n-    div.flex-content {\n-        flex: 1 1 auto;\n-        overflow-y: auto;\n+    header {\n+        position:sticky;\n+        top:0;\n+        z-index:1;\n+        background: var(--body-background-color);\n@@ -308,2 +303,1 @@\n-body.class-declaration-page .details h3,\n-body.class-declaration-page .summary .inherited-list h2 {\n+body.class-declaration-page .details h3 {\n@@ -314,0 +308,1 @@\n+    overflow-x:auto;\n@@ -323,0 +318,4 @@\n+section[id$=-description] :is(dl, ol, ul, p, div, blockquote, pre):last-child,\n+section[id$=-description] :is(dl, ol, ul):last-child > :is(li, dd):last-child {\n+    margin-bottom:4px;\n+}\n@@ -446,2 +445,2 @@\n-    padding:10px 0 0 1px;\n-    margin:10px 0 0 0;\n+    padding: 10px 0 0 1px;\n+    margin: 0;\n@@ -530,1 +529,1 @@\n-    overflow-x: auto;\n+    overflow: auto hidden;\n@@ -618,1 +617,1 @@\n-    margin:14px 0;\n+    margin:8px 0 14px 0;\n@@ -651,1 +650,1 @@\n-.package-hierarchy-label, .type-name-label, .type-name-link, .search-tag-link, .preview-label {\n+.package-hierarchy-label, .type-name-label, .type-name-link, .search-tag-link, .preview-label, .restricted-label {\n@@ -654,1 +653,1 @@\n-.deprecation-comment, .help-footnote, .preview-comment {\n+.deprecation-comment, .help-footnote, .preview-comment, .restricted-comment {\n@@ -657,12 +656,1 @@\n-.deprecation-block {\n-    font-size:1em;\n-    font-family:var(--block-font-family);\n-    border-style:solid;\n-    border-width:thin;\n-    border-radius:10px;\n-    padding:10px;\n-    margin-bottom:10px;\n-    margin-right:10px;\n-    display:inline-block;\n-}\n-.preview-block {\n+.deprecation-block, .preview-block, .restricted-block {\n@@ -701,0 +689,3 @@\n+nav {\n+    overflow:hidden;\n+}\n@@ -857,0 +848,3 @@\n+.horizontal-scroll {\n+    overflow: auto hidden;\n+}\n@@ -1101,1 +1095,1 @@\n-    header.flex-header {\n+    header {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/stylesheet.css","additions":28,"deletions":34,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -52,0 +52,2 @@\n+import jdk.javadoc.internal.doclets.formats.html.IndexWriter;\n+import jdk.javadoc.internal.doclets.formats.html.SummaryListWriter;\n@@ -373,1 +375,2 @@\n-        if (context.isFirstSentence && context.inSummary || context.inTags.contains(DocTree.Kind.INDEX)) {\n+        if (context.isFirstSentence && context.inSummary || context.inTags.contains(DocTree.Kind.INDEX)\n+                || !htmlWriter.isIndexable()) {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/TagletWriter.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -432,0 +432,5 @@\n+    public boolean isRestrictedAPI(Element el) {\n+        Symbol sym = (Symbol) el;\n+        return sym.kind == MTH && (sym.flags() & Flags.RESTRICTED) != 0;\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/WorkArounds.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -216,0 +216,1 @@\n+doclet.Restricted=Restricted.\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/resources\/doclets.properties","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -151,0 +151,3 @@\n+    \/** The name of the file for restricted methods. *\/\n+    public static final DocPath RESTRICTED_LIST = DocPath.create(\"restricted-list.html\");\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/DocPaths.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.toolkit.util;\n+\n+import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n+\n+import javax.lang.model.element.Element;\n+\n+\/**\n+ * Build list of all the restricted methods.\n+ *\/\n+public class RestrictedAPIListBuilder extends SummaryAPIListBuilder {\n+\n+\n+    \/**\n+     * Constructor.\n+     *\n+     * @param configuration the current configuration of the doclet\n+     *\/\n+    public RestrictedAPIListBuilder(BaseConfiguration configuration) {\n+        super(configuration, configuration.utils::isRestrictedAPI);\n+        buildSummaryAPIInfo();\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/RestrictedAPIListBuilder.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -2743,0 +2743,10 @@\n+    \/**\n+     * Checks whether the given ExecutableElement should be marked as a restricted API.\n+     *\n+     * @param el the element to check\n+     * @return true if and only if the given element should be marked as a restricted API\n+     *\/\n+    public boolean isRestrictedAPI(Element el) {\n+        return configuration.workArounds.isRestrictedAPI(el);\n+    }\n+\n@@ -2756,0 +2766,4 @@\n+        if (el.getKind() == ElementKind.METHOD && configuration.workArounds.isRestrictedAPI((ExecutableElement)el)) {\n+            flags.add(ElementFlag.RESTRICTED);\n+        }\n+\n@@ -2769,1 +2783,2 @@\n-        PREVIEW\n+        PREVIEW,\n+        RESTRICTED\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/Utils.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,1 +70,0 @@\n-import com.sun.tools.javac.tree.TreeInfo;\n@@ -394,1 +393,1 @@\n-                JCModuleDecl module = TreeInfo.getModule(jcu);\n+                JCModuleDecl module = jcu.getModule();\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/tool\/ElementsTable.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -456,0 +456,2 @@\n+If %p and\/or %t is specified in the filename, it expands to the\n+JVM\\[aq]s PID and the current timestamp, respectively.\n@@ -524,0 +526,2 @@\n+If %p and\/or %t is specified in the filename, it expands to the\n+JVM\\[aq]s PID and the current timestamp, respectively.\n@@ -615,0 +619,2 @@\n+If %p and\/or %t is specified in the filename, it expands to the\n+JVM\\[aq]s PID and the current timestamp, respectively.\n","filename":"src\/jdk.jcmd\/share\/man\/jcmd.1","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -247,4 +247,0 @@\n-\\f[V]-P\\f[R] or \\f[V]-profile\\f[R]\n-Shows the profile containing a package.\n-This option is deprecated and may be removed in a future release.\n-.TP\n","filename":"src\/jdk.jdeps\/share\/man\/jdeps.1","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -105,1 +105,1 @@\n-static void initialize(JNIEnv *env, jthread thread, EventIndex triggering_ei);\n+static void initialize(JNIEnv *env, jthread thread, EventIndex triggering_ei, EventInfo *opt_info);\n@@ -394,1 +394,1 @@\n-        initialize(env, thread, EI_VM_INIT);\n+        initialize(env, thread, EI_VM_INIT, NULL);\n@@ -447,0 +447,13 @@\n+    EventInfo info;\n+    info.ei = EI_EXCEPTION;\n+    info.thread = thread;\n+    info.clazz = getMethodClass(jvmti_env, method);\n+    info.method = method;\n+    info.location = location;\n+    info.object = exception;\n+    if (gdata->vthreadsSupported) {\n+        info.is_vthread = isVThread(thread);\n+    }\n+    info.u.exception.catch_clazz = getMethodClass(jvmti_env, catch_method);\n+    info.u.exception.catch_method = catch_method;\n+    info.u.exception.catch_location = catch_location;\n@@ -461,1 +474,1 @@\n-        initialize(env, thread, EI_EXCEPTION);\n+        initialize(env, thread, EI_EXCEPTION, &info);\n@@ -465,5 +478,3 @@\n-        jclass clazz;\n-\n-        \/* Get class of exception thrown *\/\n-        clazz = JNI_FUNC_PTR(env,GetObjectClass)(env, exception);\n-        if ( clazz != NULL ) {\n+        jclass exception_clazz = JNI_FUNC_PTR(env, GetObjectClass)(env, exception);\n+        \/* check class of exception thrown *\/\n+        if ( exception_clazz != NULL ) {\n@@ -472,1 +483,1 @@\n-            error = classSignature(clazz, &signature, NULL);\n+            error = classSignature(exception_clazz, &signature, NULL);\n@@ -478,1 +489,1 @@\n-                initialize(env, thread, EI_EXCEPTION);\n+                initialize(env, thread, EI_EXCEPTION, &info);\n@@ -619,0 +630,2 @@\n+ *\n+ * @param opt_info optional event info to use, might be null\n@@ -621,1 +634,1 @@\n-initialize(JNIEnv *env, jthread thread, EventIndex triggering_ei)\n+initialize(JNIEnv *env, jthread thread, EventIndex triggering_ei, EventInfo *opt_info)\n@@ -709,1 +722,0 @@\n-        EventInfo info;\n@@ -711,1 +723,3 @@\n-        LOG_MISC((\"triggering_ei != EI_VM_INIT\"));\n+        LOG_MISC((\"triggering_ei == EI_EXCEPTION\"));\n+        JDI_ASSERT(triggering_ei == EI_EXCEPTION);\n+        JDI_ASSERT(opt_info != NULL);\n@@ -713,3 +727,2 @@\n-        (void)memset(&info,0,sizeof(info));\n-        info.ei = triggering_ei;\n-        eventHelper_recordEvent(&info, 0, suspendPolicy, initEventBag);\n+        threadControl_onEventHandlerEntry(currentSessionID, opt_info, NULL);\n+        eventHelper_recordEvent(opt_info, 0, suspendPolicy, initEventBag);\n@@ -1371,1 +1384,1 @@\n-        initialize(env, thread, EI_VM_INIT);\n+        initialize(env, thread, EI_VM_INIT, NULL);\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/debugInit.c","additions":30,"deletions":17,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n-import jdk.jfr.internal.EventInstrumentation;\n+import jdk.jfr.internal.util.Utils;\n@@ -60,1 +60,1 @@\n-        return getTyped(EventInstrumentation.FIELD_STACK_TRACE, RecordedStackTrace.class, null);\n+        return getTyped(Utils.FIELD_STACK_TRACE, RecordedStackTrace.class, null);\n@@ -70,1 +70,1 @@\n-        return getTyped(EventInstrumentation.FIELD_EVENT_THREAD, RecordedThread.class, null);\n+        return getTyped(Utils.FIELD_EVENT_THREAD, RecordedThread.class, null);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/RecordedEvent.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1,102 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jfr.internal;\n-\n-import java.io.ByteArrayOutputStream;\n-import java.io.PrintWriter;\n-\n-import jdk.internal.org.objectweb.asm.ClassReader;\n-import jdk.internal.org.objectweb.asm.Type;\n-import jdk.internal.org.objectweb.asm.util.TraceClassVisitor;\n-import jdk.jfr.ValueDescriptor;\n-\n-final class ASMToolkit {\n-    public static final Type TYPE_STRING = Type.getType(String.class);\n-    private static final Type TYPE_THREAD = Type.getType(Thread.class);\n-    private static final Type TYPE_CLASS = Type.getType(Class.class);\n-\n-    public static Type toType(ValueDescriptor v) {\n-        return switch (v.getTypeName()) {\n-            case \"byte\" -> Type.BYTE_TYPE;\n-            case \"short\" -> Type.SHORT_TYPE;\n-            case \"int\" ->  Type.INT_TYPE;\n-            case \"long\" ->Type.LONG_TYPE;\n-            case \"double\" -> Type.DOUBLE_TYPE;\n-            case \"float\" -> Type.FLOAT_TYPE;\n-            case \"char\" -> Type.CHAR_TYPE;\n-            case \"boolean\" -> Type.BOOLEAN_TYPE;\n-            case \"java.lang.String\" -> TYPE_STRING;\n-            case \"java.lang.Thread\" -> TYPE_THREAD;\n-            case \"java.lang.Class\" -> TYPE_CLASS;\n-            default -> throw new Error(\"Not a valid type \" + v.getTypeName());\n-        };\n-    }\n-\n-    \/**\n-     * Converts \"int\" into \"I\" and \"java.lang.String\" into \"Ljava\/lang\/String;\"\n-     *\n-     * @param typeName\n-     *            type\n-     *\n-     * @return descriptor\n-     *\/\n-    public static String getDescriptor(String typeName) {\n-        return switch (typeName) {\n-            case \"int\" -> \"I\";\n-            case \"long\" -> \"J\";\n-            case \"boolean\" -> \"Z\";\n-            case \"float\" -> \"F\";\n-            case \"double\" -> \"D\";\n-            case \"short\" -> \"S\";\n-            case \"char\" -> \"C\";\n-            case \"byte\" -> \"B\";\n-            default -> Type.getObjectType(getInternalName(typeName)).getDescriptor();\n-        };\n-    }\n-\n-    \/**\n-     * Converts java.lang.String into java\/lang\/String\n-     *\n-     * @param className\n-     *\n-     * @return internal name\n-     *\/\n-    public static String getInternalName(String className) {\n-        return className.replace(\".\", \"\/\");\n-    }\n-\n-    public static void logASM(String className, byte[] bytes) {\n-        Logger.log(LogTag.JFR_SYSTEM_BYTECODE, LogLevel.INFO, \"Generated bytecode for class \" + className);\n-        if (Logger.shouldLog(LogTag.JFR_SYSTEM_BYTECODE, LogLevel.TRACE)) {\n-            ClassReader cr = new ClassReader(bytes);\n-            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-            PrintWriter w = new PrintWriter(baos);\n-            w.println(\"Bytecode:\");\n-            cr.accept(new TraceClassVisitor(w), 0);\n-            Logger.log(LogTag.JFR_SYSTEM_BYTECODE, LogLevel.TRACE, baos.toString());\n-        };\n-    }\n-}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/ASMToolkit.java","additions":0,"deletions":102,"binary":false,"changes":102,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,6 @@\n+import static jdk.jfr.internal.util.Bytecode.invokespecial;\n+\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDescs;\n+import java.lang.reflect.AccessFlag;\n+import java.util.ArrayList;\n@@ -31,8 +37,5 @@\n-import jdk.internal.org.objectweb.asm.AnnotationVisitor;\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.Label;\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n-import jdk.internal.org.objectweb.asm.Opcodes;\n-import jdk.internal.org.objectweb.asm.Type;\n-import jdk.internal.org.objectweb.asm.commons.GeneratorAdapter;\n-import jdk.internal.org.objectweb.asm.commons.Method;\n+import jdk.internal.classfile.AnnotationValue;\n+import jdk.internal.classfile.ClassBuilder;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.Label;\n+import jdk.internal.classfile.attribute.RuntimeVisibleAnnotationsAttribute;\n@@ -42,1 +45,2 @@\n-\n+import jdk.jfr.internal.util.Bytecode;\n+import jdk.jfr.internal.util.Bytecode.MethodDesc;\n@@ -46,5 +50,4 @@\n-\n-    private static final Type TYPE_EVENT = Type.getType(Event.class);\n-    private static final Type TYPE_IOBE = Type.getType(IndexOutOfBoundsException.class);\n-    private static final Method DEFAULT_CONSTRUCTOR = Method.getMethod(\"void <init> ()\");\n-    private static final Method SET_METHOD = Method.getMethod(\"void set (int, java.lang.Object)\");\n+    private static final ClassDesc TYPE_EVENT = Bytecode.classDesc(Event.class);\n+    private static final ClassDesc TYPE_IOBE = Bytecode.classDesc(IndexOutOfBoundsException.class);\n+    private static final MethodDesc DEFAULT_CONSTRUCTOR = MethodDesc.of(\"<init>\", \"()V\");\n+    private static final MethodDesc SET_METHOD = MethodDesc.of(\"set\", \"(ILjava\/lang\/Object;)V\");\n@@ -52,1 +55,1 @@\n-    private final ClassWriter classWriter = new ClassWriter(ClassWriter.COMPUTE_MAXS | ClassWriter.COMPUTE_FRAMES);\n+\n@@ -54,1 +57,1 @@\n-    private final Type type;\n+    private final ClassDesc type;\n@@ -60,1 +63,1 @@\n-        this.type = Type.getType(\"L\" + fullClassName.replace(\".\", \"\/\") + \";\");\n+        this.type = ClassDesc.of(fullClassName);\n@@ -66,7 +69,2 @@\n-        buildClassInfo();\n-        buildConstructor();\n-        buildFields();\n-        buildSetMethod();\n-        endClass();\n-        byte[] bytes = classWriter.toByteArray();\n-        ASMToolkit.logASM(fullClassName, bytes);\n+        byte[] bytes = Classfile.of().build(ClassDesc.of(fullClassName), cb -> build(cb));\n+        Bytecode.log(fullClassName, bytes);\n@@ -76,2 +74,5 @@\n-    private void endClass() {\n-        classWriter.visitEnd();\n+    void build(ClassBuilder builder) {\n+        buildClassInfo(builder);\n+        buildConstructor(builder);\n+        buildFields(builder);\n+        buildSetMethod(builder);\n@@ -80,19 +81,20 @@\n-    private void buildSetMethod() {\n-        GeneratorAdapter ga = new GeneratorAdapter(Opcodes.ACC_PUBLIC, SET_METHOD, null, null, classWriter);\n-        int index = 0;\n-        for (ValueDescriptor v : fields) {\n-            ga.loadArg(0);\n-            ga.visitLdcInsn(index);\n-            Label notEqual = new Label();\n-            ga.ifICmp(GeneratorAdapter.NE, notEqual);\n-            ga.loadThis();\n-            ga.loadArg(1);\n-            Type fieldType = ASMToolkit.toType(v);\n-            ga.unbox(ASMToolkit.toType(v));\n-            ga.putField(type, v.getName(), fieldType);\n-            ga.visitInsn(Opcodes.RETURN);\n-            ga.visitLabel(notEqual);\n-            index++;\n-        }\n-        ga.throwException(TYPE_IOBE, \"Index must between 0 and \" + fields.size());\n-        ga.endMethod();\n+    private void buildSetMethod(ClassBuilder builder) {\n+        \/\/ void Event::set(int index, Object value);\n+        builder.withMethod(SET_METHOD.name(), SET_METHOD.descriptor(), Classfile.ACC_PUBLIC, methodBuilder -> methodBuilder.withCode(codeBuilder -> {\n+            int index = 0;\n+            for (ValueDescriptor v : fields) {\n+                codeBuilder.iload(1);\n+                codeBuilder.ldc(index);\n+                Label notEqual = codeBuilder.newLabel();\n+                codeBuilder.if_icmpne(notEqual);\n+                codeBuilder.aload(0); \/\/ this\n+                codeBuilder.aload(2); \/\/ value\n+                ClassDesc cd = Bytecode.classDesc(v);\n+                Bytecode.unbox(codeBuilder, cd);\n+                codeBuilder.putfield(type, v.getName(), cd);\n+                codeBuilder.return_();\n+                codeBuilder.labelBinding(notEqual);\n+                index++;\n+            }\n+            Bytecode.throwException(codeBuilder, TYPE_IOBE, \"Index must between 0 and \" + fields.size());\n+        }));\n@@ -101,6 +103,6 @@\n-    private void buildConstructor() {\n-        MethodVisitor mv = classWriter.visitMethod(Opcodes.ACC_PUBLIC, DEFAULT_CONSTRUCTOR.getName(), DEFAULT_CONSTRUCTOR.getDescriptor(), null, null);\n-        mv.visitIntInsn(Opcodes.ALOAD, 0);\n-        mv.visitMethodInsn(Opcodes.INVOKESPECIAL, TYPE_EVENT.getInternalName(), DEFAULT_CONSTRUCTOR.getName(), DEFAULT_CONSTRUCTOR.getDescriptor(), false);\n-        mv.visitInsn(Opcodes.RETURN);\n-        mv.visitMaxs(0, 0);\n+    private void buildConstructor(ClassBuilder builder) {\n+        builder.withMethod(ConstantDescs.INIT_NAME, ConstantDescs.MTD_void, Classfile.ACC_PUBLIC, methodBuilder -> methodBuilder.withCode(codeBuilder -> {\n+            codeBuilder.aload(0);\n+            invokespecial(codeBuilder, TYPE_EVENT, DEFAULT_CONSTRUCTOR);\n+            codeBuilder.return_();\n+        }));\n@@ -109,8 +111,6 @@\n-    private void buildClassInfo() {\n-        String internalSuperName = ASMToolkit.getInternalName(Event.class.getName());\n-        String internalClassName = type.getInternalName();\n-        classWriter.visit(52, Opcodes.ACC_PUBLIC + Opcodes.ACC_FINAL + Opcodes.ACC_SUPER, internalClassName, null, internalSuperName, null);\n-\n-        for (AnnotationElement a : annotationElements) {\n-            String descriptor = ASMToolkit.getDescriptor(a.getTypeName());\n-            AnnotationVisitor av = classWriter.visitAnnotation(descriptor, true);\n+    private void buildClassInfo(ClassBuilder builder) {\n+        builder.withSuperclass(Bytecode.classDesc(Event.class));\n+        builder.withFlags(AccessFlag.FINAL, AccessFlag.PUBLIC, AccessFlag.SUPER);\n+        List<jdk.internal.classfile.Annotation> annotations = new ArrayList<>();\n+        for (jdk.jfr.AnnotationElement a : annotationElements) {\n+            List<jdk.internal.classfile.AnnotationElement> list = new ArrayList<>();\n@@ -118,12 +118,6 @@\n-                Object value = a.getValue(v.getName());\n-                String name = v.getName();\n-                if (v.isArray()) {\n-                    AnnotationVisitor arrayVisitor = av.visitArray(name);\n-                    Object[] array = (Object[]) value;\n-                    for (int i = 0; i < array.length; i++) {\n-                        arrayVisitor.visit(null, array[i]);\n-                    }\n-                    arrayVisitor.visitEnd();\n-                } else {\n-                    av.visit(name, value);\n-                }\n+                \/\/ ValueDescriptor can only hold primitive\n+                \/\/ No need to care about classes\/enums\n+                var value = a.getValue(v.getName());\n+                var av = AnnotationValue.of(value);\n+                var ae = jdk.internal.classfile.AnnotationElement.of(v.getName(), av);\n+                list.add(ae);\n@@ -131,1 +125,2 @@\n-            av.visitEnd();\n+            ClassDesc cd = ClassDesc.of(a.getTypeName());\n+            annotations.add(jdk.internal.classfile.Annotation.of(cd, list));\n@@ -133,0 +128,1 @@\n+        builder.with(RuntimeVisibleAnnotationsAttribute.of(annotations));\n@@ -135,1 +131,1 @@\n-    private void buildFields() {\n+    private void buildFields(ClassBuilder builder) {\n@@ -137,2 +133,1 @@\n-            String internal = ASMToolkit.getDescriptor(v.getTypeName());\n-            classWriter.visitField(Opcodes.ACC_PRIVATE, v.getName(), internal, null, null);\n+            builder.withField(v.getName(), Bytecode.classDesc(v), Classfile.ACC_PRIVATE);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/EventClassBuilder.java","additions":71,"deletions":76,"binary":false,"changes":147,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n@@ -30,1 +32,0 @@\n-import java.lang.reflect.Parameter;\n@@ -33,0 +34,1 @@\n+import java.util.LinkedHashMap;\n@@ -34,0 +36,1 @@\n+import java.util.Map;\n@@ -37,11 +40,16 @@\n-import jdk.internal.org.objectweb.asm.ClassReader;\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.Label;\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n-import jdk.internal.org.objectweb.asm.Opcodes;\n-import jdk.internal.org.objectweb.asm.Type;\n-import jdk.internal.org.objectweb.asm.commons.Method;\n-import jdk.internal.org.objectweb.asm.tree.AnnotationNode;\n-import jdk.internal.org.objectweb.asm.tree.ClassNode;\n-import jdk.internal.org.objectweb.asm.tree.FieldNode;\n-import jdk.internal.org.objectweb.asm.tree.MethodNode;\n+import jdk.internal.classfile.Annotation;\n+import jdk.internal.classfile.AnnotationElement;\n+import jdk.internal.classfile.AnnotationValue;\n+import jdk.internal.classfile.ClassElement;\n+import jdk.internal.classfile.ClassModel;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.CodeBuilder;\n+import jdk.internal.classfile.CodeBuilder.BlockCodeBuilder;\n+import jdk.internal.classfile.FieldModel;\n+import jdk.internal.classfile.Label;\n+import jdk.internal.classfile.MethodModel;\n+import jdk.internal.classfile.Opcode;\n+import jdk.internal.classfile.TypeKind;\n+import jdk.internal.classfile.attribute.RuntimeVisibleAnnotationsAttribute;\n+import jdk.jfr.internal.event.EventConfiguration;\n+import jdk.jfr.internal.event.EventWriter;\n@@ -49,1 +57,0 @@\n-import jdk.jfr.Event;\n@@ -54,2 +61,0 @@\n-import jdk.jfr.internal.event.EventConfiguration;\n-import jdk.jfr.internal.event.EventWriter;\n@@ -57,0 +62,8 @@\n+import jdk.jfr.internal.util.Bytecode;\n+import jdk.jfr.internal.util.Bytecode.FieldDesc;\n+import jdk.jfr.internal.util.Bytecode.MethodDesc;\n+import static jdk.jfr.internal.util.Bytecode.invokevirtual;\n+import static jdk.jfr.internal.util.Bytecode.invokestatic;\n+import static jdk.jfr.internal.util.Bytecode.getfield;\n+import static jdk.jfr.internal.util.Bytecode.putfield;\n+import static jdk.jfr.internal.util.Bytecode.classDesc;\n@@ -62,42 +75,33 @@\n-public final class EventInstrumentation {\n-\n-    record SettingInfo(Type paramType, String methodName) {\n-    }\n-\n-    record FieldInfo(String name, String descriptor) {\n-    }\n-\n-    public static final String FIELD_EVENT_THREAD = \"eventThread\";\n-    public static final String FIELD_STACK_TRACE = \"stackTrace\";\n-    public static final String FIELD_DURATION = \"duration\";\n-\n-    static final String FIELD_EVENT_CONFIGURATION = \"eventConfiguration\";\n-    static final String FIELD_START_TIME = \"startTime\";\n-\n-    private static final String ANNOTATION_NAME_DESCRIPTOR = Type.getDescriptor(Name.class);\n-    private static final String ANNOTATION_REGISTERED_DESCRIPTOR = Type.getDescriptor(Registered.class);\n-    private static final String ANNOTATION_ENABLED_DESCRIPTOR = Type.getDescriptor(Enabled.class);\n-    private static final Type TYPE_EVENT_CONFIGURATION = Type.getType(EventConfiguration.class);\n-    private static final Type TYPE_EVENT_WRITER = Type.getType(EventWriter.class);\n-    private static final Type TYPE_EVENT_WRITER_FACTORY = Type.getType(\"Ljdk\/jfr\/internal\/event\/EventWriterFactory;\");\n-    private static final Type TYPE_SETTING_CONTROL = Type.getType(SettingControl.class);\n-    private static final String TYPE_OBJECT_DESCRIPTOR = Type.getDescriptor(Object.class);\n-    private static final String TYPE_EVENT_CONFIGURATION_DESCRIPTOR = TYPE_EVENT_CONFIGURATION.getDescriptor();\n-    private static final String TYPE_SETTING_DEFINITION_DESCRIPTOR = Type.getDescriptor(SettingDefinition.class);\n-    private static final Method METHOD_COMMIT = new Method(\"commit\", Type.VOID_TYPE, new Type[0]);\n-    private static final Method METHOD_BEGIN = new Method(\"begin\", Type.VOID_TYPE, new Type[0]);\n-    private static final Method METHOD_END = new Method(\"end\", Type.VOID_TYPE, new Type[0]);\n-    private static final Method METHOD_IS_ENABLED = new Method(\"isEnabled\", Type.BOOLEAN_TYPE, new Type[0]);\n-    private static final Method METHOD_TIME_STAMP = new Method(\"timestamp\", Type.LONG_TYPE, new Type[0]);\n-    private static final Method METHOD_GET_EVENT_WRITER_KEY = new Method(\"getEventWriter\", TYPE_EVENT_WRITER, new Type[] { Type.LONG_TYPE });\n-    private static final Method METHOD_EVENT_SHOULD_COMMIT = new Method(\"shouldCommit\", Type.BOOLEAN_TYPE, new Type[0]);\n-    private static final Method METHOD_EVENT_CONFIGURATION_SHOULD_COMMIT = new Method(\"shouldCommit\", Type.BOOLEAN_TYPE, new Type[] { Type.LONG_TYPE });\n-    private static final Method METHOD_EVENT_CONFIGURATION_GET_SETTING = new Method(\"getSetting\", TYPE_SETTING_CONTROL, new Type[] { Type.INT_TYPE });\n-    private static final Method METHOD_DURATION = new Method(\"duration\", Type.LONG_TYPE, new Type[] { Type.LONG_TYPE });\n-    private static final Method METHOD_RESET = new Method(\"reset\", \"()V\");\n-    private static final Method METHOD_ENABLED = new Method(\"enabled\", Type.BOOLEAN_TYPE, new Type[0]);\n-    private static final Method METHOD_SHOULD_COMMIT_LONG = new Method(\"shouldCommit\", Type.BOOLEAN_TYPE, new Type[] { Type.LONG_TYPE });\n-\n-    private final ClassNode classNode;\n-    private final List<SettingInfo> settingInfos;\n-    private final List<FieldInfo> fieldInfos;;\n+final class EventInstrumentation {\n+\n+    private record SettingDesc(ClassDesc paramType, String methodName) {\n+    }\n+\n+    private static final FieldDesc FIELD_DURATION = FieldDesc.of(long.class, Utils.FIELD_DURATION);\n+    private static final FieldDesc FIELD_EVENT_CONFIGURATION = FieldDesc.of(Object.class, \"eventConfiguration\");;\n+    private static final FieldDesc FIELD_START_TIME = FieldDesc.of(long.class, Utils.FIELD_START_TIME);\n+    private static final ClassDesc ANNOTATION_ENABLED = classDesc(Enabled.class);\n+    private static final ClassDesc ANNOTATION_NAME = classDesc(Name.class);\n+    private static final ClassDesc ANNOTATION_REGISTERED = classDesc(Registered.class);\n+    private static final ClassDesc TYPE_EVENT_CONFIGURATION = classDesc(EventConfiguration.class);\n+    private static final ClassDesc TYPE_EVENT_WRITER = classDesc(EventWriter.class);\n+    private static final ClassDesc TYPE_EVENT_WRITER_FACTORY = ClassDesc.of(\"jdk.jfr.internal.event.EventWriterFactory\");\n+    private static final ClassDesc TYPE_OBJECT = Bytecode.classDesc(Object.class);\n+    private static final ClassDesc TYPE_SETTING_DEFINITION = Bytecode.classDesc(SettingDefinition.class);\n+    private static final MethodDesc METHOD_BEGIN = MethodDesc.of(\"begin\", \"()V\");\n+    private static final MethodDesc METHOD_COMMIT = MethodDesc.of(\"commit\", \"()V\");\n+    private static final MethodDesc METHOD_DURATION = MethodDesc.of(\"duration\", \"(J)J\");\n+    private static final MethodDesc METHOD_ENABLED = MethodDesc.of(\"enabled\", \"()Z\");\n+    private static final MethodDesc METHOD_END = MethodDesc.of(\"end\", \"()V\");\n+    private static final MethodDesc METHOD_EVENT_CONFIGURATION_SHOULD_COMMIT = MethodDesc.of(\"shouldCommit\", \"(J)Z\");\n+    private static final MethodDesc METHOD_EVENT_CONFIGURATION_GET_SETTING = MethodDesc.of(\"getSetting\", SettingControl.class, int.class);\n+    private static final MethodDesc METHOD_EVENT_SHOULD_COMMIT = MethodDesc.of(\"shouldCommit\", \"()Z\");\n+    private static final MethodDesc METHOD_GET_EVENT_WRITER_KEY = MethodDesc.of(\"getEventWriter\", \"(J)\" + TYPE_EVENT_WRITER.descriptorString());\n+    private static final MethodDesc METHOD_IS_ENABLED = MethodDesc.of(\"isEnabled\", \"()Z\");\n+    private static final MethodDesc METHOD_RESET = MethodDesc.of(\"reset\", \"()V\");\n+    private static final MethodDesc METHOD_SHOULD_COMMIT_LONG = MethodDesc.of(\"shouldCommit\", \"(J)Z\");\n+    private static final MethodDesc METHOD_TIME_STAMP = MethodDesc.of(\"timestamp\", \"()J\");\n+\n+    private final ClassModel classModel;\n+    private final List<SettingDesc> settingDescs;\n+    private final List<FieldDesc> fieldDescs;;\n@@ -107,1 +111,1 @@\n-    private final Method staticCommitMethod;\n+    private final MethodDesc staticCommitMethod;\n@@ -111,0 +115,1 @@\n+    private final Map<MethodDesc, Consumer<CodeBuilder>> methodUpdates = new LinkedHashMap<>();\n@@ -115,6 +120,6 @@\n-        this.classNode = createClassNode(bytes);\n-        this.settingInfos = buildSettingInfos(superClass, classNode);\n-        this.fieldInfos = buildFieldInfos(superClass, classNode);\n-        String n = annotationValue(classNode, ANNOTATION_NAME_DESCRIPTOR, String.class);\n-        this.eventName = n == null ? classNode.name.replace(\"\/\", \".\") : n;\n-        this.staticCommitMethod = isJDK ? findStaticCommitMethod(classNode, fieldInfos) : null;\n+        this.classModel = createClassModel(bytes);\n+        this.settingDescs = buildSettingDescs(superClass, classModel);\n+        this.fieldDescs = buildFieldDescs(superClass, classModel);\n+        String n = annotationValue(classModel, ANNOTATION_NAME, String.class);\n+        this.eventName = n == null ? classModel.thisClass().asInternalName().replace(\"\/\", \".\") : n;\n+        this.staticCommitMethod = isJDK ? findStaticCommitMethod(classModel, fieldDescs) : null;\n@@ -122,2 +127,4 @@\n-        \/\/ Corner case when we are forced to generate bytecode (bytesForEagerInstrumentation)\n-        \/\/ We can't reference EventConfiguration::isEnabled() before event class has been registered,\n+        \/\/ Corner case when we are forced to generate bytecode\n+        \/\/ (bytesForEagerInstrumentation)\n+        \/\/ We can't reference EventConfiguration::isEnabled() before event class has\n+        \/\/ been registered,\n@@ -129,1 +136,1 @@\n-    public static Method findStaticCommitMethod(ClassNode classNode, List<FieldInfo> fields) {\n+    static MethodDesc findStaticCommitMethod(ClassModel classModel, List<FieldDesc> fields) {\n@@ -132,2 +139,2 @@\n-        for (FieldInfo field : fields) {\n-            sb.append(field.descriptor);\n+        for (FieldDesc field : fields) {\n+            sb.append(field.type().descriptorString());\n@@ -136,3 +143,4 @@\n-        Method m = new Method(\"commit\", sb.toString());\n-        for (MethodNode method : classNode.methods) {\n-            if (\"commit\".equals(method.name) && m.getDescriptor().equals(method.desc)) {\n+        MethodDesc m = MethodDesc.of(\"commit\", sb.toString());\n+        for (MethodModel method : classModel.methods()) {\n+            String d = method.methodTypeSymbol().descriptorString();\n+            if (method.methodName().equalsString(\"commit\") && m.descriptor().descriptorString().equals(d)) {\n@@ -146,3 +154,3 @@\n-        for (FieldNode field : classNode.fields) {\n-            if (FIELD_EVENT_CONFIGURATION.equals(field.name)) {\n-                return field.desc.equals(TYPE_OBJECT_DESCRIPTOR);\n+        for (FieldModel f : classModel.fields()) {\n+            if (f.fieldName().equalsString(FIELD_EVENT_CONFIGURATION.name())) {\n+                return f.fieldType().equalsString(TYPE_OBJECT.descriptorString());\n@@ -155,1 +163,1 @@\n-        return classNode.name.replace(\"\/\", \".\");\n+        return classModel.thisClass().asInternalName().replace(\"\/\", \".\");\n@@ -158,5 +166,2 @@\n-    private ClassNode createClassNode(byte[] bytes) {\n-        ClassNode classNode = new ClassNode();\n-        ClassReader classReader = new ClassReader(bytes);\n-        classReader.accept(classNode, 0);\n-        return classNode;\n+    private ClassModel createClassModel(byte[] bytes) {\n+        return Classfile.of().parse(bytes);\n@@ -166,1 +171,1 @@\n-        Boolean result = annotationValue(classNode, ANNOTATION_REGISTERED_DESCRIPTOR, Boolean.class);\n+        Boolean result = annotationValue(classModel, ANNOTATION_REGISTERED, Boolean.class);\n@@ -180,1 +185,1 @@\n-        Boolean result = annotationValue(classNode, ANNOTATION_ENABLED_DESCRIPTOR, Boolean.class);\n+        Boolean result = annotationValue(classModel, ANNOTATION_ENABLED, Boolean.class);\n@@ -194,12 +199,17 @@\n-    private static <T> T annotationValue(ClassNode classNode, String typeDescriptor, Class<?> type) {\n-        if (classNode.visibleAnnotations != null) {\n-            for (AnnotationNode a : classNode.visibleAnnotations) {\n-                if (typeDescriptor.equals(a.desc)) {\n-                    List<Object> values = a.values;\n-                    if (values != null && values.size() == 2) {\n-                        Object key = values.get(0);\n-                        Object value = values.get(1);\n-                        if (key instanceof String keyName && value != null) {\n-                            if (type == value.getClass()) {\n-                                if (\"value\".equals(keyName)) {\n-                                    return (T) value;\n+    \/\/ Only supports String and Boolean values\n+    private static <T> T annotationValue(ClassModel classModel, ClassDesc classDesc, Class<T> type) {\n+        String typeDescriptor = classDesc.descriptorString();\n+        for (ClassElement ce : classModel.elements()) {\n+            if (ce instanceof RuntimeVisibleAnnotationsAttribute rvaa) {\n+                for (Annotation a : rvaa.annotations()) {\n+                    if (a.className().equalsString(typeDescriptor)) {\n+                        if (a.elements().size() == 1) {\n+                            AnnotationElement ae = a.elements().getFirst();\n+                            if (ae.name().equalsString(\"value\")) {\n+                                if (ae.value() instanceof AnnotationValue.OfBoolean ofb && type.equals(Boolean.class)) {\n+                                    Boolean b = ofb.booleanValue();\n+                                    return (T)b;\n+                                }\n+                                if (ae.value() instanceof AnnotationValue.OfString ofs && type.equals(String.class)) {\n+                                    String s = ofs.stringValue();\n+                                    return (T)s;\n@@ -216,1 +226,1 @@\n-    private static List<SettingInfo> buildSettingInfos(Class<?> superClass, ClassNode classNode) {\n+    private static List<SettingDesc> buildSettingDescs(Class<?> superClass, ClassModel classModel) {\n@@ -218,14 +228,21 @@\n-        List<SettingInfo> settingInfos = new ArrayList<>();\n-        for (MethodNode m : classNode.methods) {\n-            if (m.visibleAnnotations != null) {\n-                for (AnnotationNode an : m.visibleAnnotations) {\n-                    \/\/ We can't really validate the method at this\n-                    \/\/ stage. We would need to check that the parameter\n-                    \/\/ is an instance of SettingControl.\n-                    if (TYPE_SETTING_DEFINITION_DESCRIPTOR.equals(an.desc)) {\n-                        String name = m.name;\n-                        for (AnnotationNode nameCandidate : m.visibleAnnotations) {\n-                            if (ANNOTATION_NAME_DESCRIPTOR.equals(nameCandidate.desc)) {\n-                                List<Object> values = nameCandidate.values;\n-                                if (values.size() == 1 && values.getFirst() instanceof String s) {\n-                                    name = Utils.validJavaIdentifier(s, name);\n+        List<SettingDesc> settingDescs = new ArrayList<>();\n+        for (MethodModel m : classModel.methods()) {\n+            for (var me : m.elements()) {\n+                if (me instanceof RuntimeVisibleAnnotationsAttribute rvaa) {\n+                    for (Annotation a : rvaa.annotations()) {\n+                        \/\/ We can't really validate the method at this\n+                        \/\/ stage. We would need to check that the parameter\n+                        \/\/ is an instance of SettingControl.\n+                        if (a.className().equalsString(TYPE_SETTING_DEFINITION.descriptorString())) {\n+                            String name = m.methodName().stringValue();\n+                            \/\/ Use @Name if it exists\n+                            for (Annotation nameCandidate : rvaa.annotations()) {\n+                                if (nameCandidate.className().equalsString(ANNOTATION_NAME.descriptorString())) {\n+                                    if (nameCandidate.elements().size() == 1) {\n+                                        AnnotationElement ae = nameCandidate.elements().getFirst();\n+                                        if (ae.name().equalsString(\"value\")) {\n+                                            if (ae.value() instanceof AnnotationValue.OfString s) {\n+                                                name = Utils.validJavaIdentifier(s.stringValue(), name);\n+                                            }\n+                                        }\n+                                    }\n@@ -234,8 +251,11 @@\n-                        }\n-                        Type returnType = Type.getReturnType(m.desc);\n-                        if (returnType.equals(Type.getType(Boolean.TYPE))) {\n-                            Type[] args = Type.getArgumentTypes(m.desc);\n-                            if (args.length == 1) {\n-                                Type paramType = args[0];\n-                                methodSet.add(m.name);\n-                                settingInfos.add(new SettingInfo(paramType, m.name));\n+                            \/\/ Add setting if method returns boolean and has one parameter\n+                            MethodTypeDesc mtd = m.methodTypeSymbol();\n+                            if (\"Z\".equals(mtd.returnType().descriptorString())) {\n+                                if (mtd.parameterList().size() == 1) {\n+                                    ClassDesc type = mtd.parameterList().getFirst();\n+                                    if (type.isClassOrInterface()) {\n+                                        String methodName = m.methodName().stringValue();\n+                                        methodSet.add(methodName);\n+                                        settingDescs.add(new SettingDesc(type, methodName));\n+                                    }\n+                                }\n@@ -248,1 +268,1 @@\n-        for (Class<?> c = superClass; c != jdk.internal.event.Event.class; c = c.getSuperclass()) {\n+        for (Class<?> c = superClass; jdk.internal.event.Event.class != c; c = c.getSuperclass()) {\n@@ -255,4 +275,6 @@\n-                                Parameter param = method.getParameters()[0];\n-                                Type paramType = Type.getType(param.getType());\n-                                methodSet.add(method.getName());\n-                                settingInfos.add(new SettingInfo(paramType, method.getName()));\n+                                Class<?> type = method.getParameters()[0].getType();\n+                                if (SettingControl.class.isAssignableFrom(type)) {\n+                                    ClassDesc paramType = Bytecode.classDesc(type);\n+                                    methodSet.add(method.getName());\n+                                    settingDescs.add(new SettingDesc(paramType, method.getName()));\n+                                }\n@@ -265,1 +287,1 @@\n-        return settingInfos;\n+        return settingDescs;\n@@ -268,1 +290,1 @@\n-    private static List<FieldInfo> buildFieldInfos(Class<?> superClass, ClassNode classNode) {\n+    private static List<FieldDesc> buildFieldDescs(Class<?> superClass, ClassModel classModel) {\n@@ -270,1 +292,1 @@\n-        List<FieldInfo> fieldInfos = new ArrayList<>(classNode.fields.size());\n+        List<FieldDesc> fieldDescs = new ArrayList<>(classModel.fields().size());\n@@ -277,7 +299,7 @@\n-        fieldInfos.add(new FieldInfo(\"startTime\", Type.LONG_TYPE.getDescriptor()));\n-        fieldInfos.add(new FieldInfo(\"duration\", Type.LONG_TYPE.getDescriptor()));\n-        for (FieldNode field : classNode.fields) {\n-            if (!fieldSet.contains(field.name) && isValidField(field.access, Type.getType(field.desc).getClassName())) {\n-                FieldInfo fi = new FieldInfo(field.name, field.desc);\n-                fieldInfos.add(fi);\n-                fieldSet.add(field.name);\n+        fieldDescs.add(FIELD_START_TIME);\n+        fieldDescs.add(FIELD_DURATION);\n+        for (FieldModel field : classModel.fields()) {\n+            if (!fieldSet.contains(field.fieldName().stringValue()) && isValidField(field.flags().flagsMask(), field.fieldTypeSymbol())) {\n+                FieldDesc fi = FieldDesc.of(field.fieldTypeSymbol(), field.fieldName().stringValue());\n+                fieldDescs.add(fi);\n+                fieldSet.add(field.fieldName().stringValue());\n@@ -286,1 +308,1 @@\n-        for (Class<?> c = superClass; c != jdk.internal.event.Event.class; c = c.getSuperclass()) {\n+        for (Class<?> c = superClass; jdk.internal.event.Event.class != c; c = c.getSuperclass()) {\n@@ -293,2 +315,1 @@\n-                            Type fieldType = Type.getType(field.getType());\n-                            fieldInfos.add(new FieldInfo(fieldName, fieldType.getDescriptor()));\n+                            fieldDescs.add(FieldDesc.of(field.getType(), fieldName));\n@@ -301,1 +322,10 @@\n-        return fieldInfos;\n+        return fieldDescs;\n+    }\n+\n+    public static boolean isValidField(int access, ClassDesc classDesc) {\n+        String className = classDesc.packageName();\n+        if (!className.isEmpty()) {\n+            className = className + \".\";\n+        }\n+        className += classDesc.displayName();\n+        return isValidField(access, className);\n@@ -308,1 +338,1 @@\n-        return jdk.jfr.internal.Type.isValidJavaFieldType(className);\n+        return Type.isValidJavaFieldType(className);\n@@ -316,5 +346,18 @@\n-    private byte[] toByteArray() {\n-        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES);\n-        classNode.accept(cw);\n-        cw.visitEnd();\n-        return cw.toByteArray();\n+    byte[] toByteArray() {\n+        return Classfile.of().build(classModel.thisClass().asSymbol(), classBuilder -> {\n+            for (ClassElement ce : classModel) {\n+                boolean updated = false;\n+                if (ce instanceof MethodModel method) {\n+                    Consumer<CodeBuilder> methodUpdate = findMethodUpdate(method);\n+                    if (methodUpdate != null) {\n+                        classBuilder.withMethod(method.methodName().stringValue(), method.methodTypeSymbol(), method.flags().flagsMask(), methodBuilder -> {\n+                            methodBuilder.withCode(methodUpdate);\n+                        });\n+                        updated = true;\n+                    }\n+                }\n+                if (!updated) {\n+                    classBuilder.with(ce);\n+                }\n+            }\n+        });\n@@ -333,5 +376,5 @@\n-        updateMethod(METHOD_BEGIN, methodVisitor -> {\n-            methodVisitor.visitIntInsn(Opcodes.ALOAD, 0);\n-            invokeStatic(methodVisitor, TYPE_EVENT_CONFIGURATION.getInternalName(), METHOD_TIME_STAMP);\n-            methodVisitor.visitFieldInsn(Opcodes.PUTFIELD, getInternalClassName(), FIELD_START_TIME, \"J\");\n-            methodVisitor.visitInsn(Opcodes.RETURN);\n+        updateMethod(METHOD_BEGIN, codeBuilder -> {\n+            codeBuilder.aload(0);\n+            invokestatic(codeBuilder, TYPE_EVENT_CONFIGURATION, METHOD_TIME_STAMP);\n+            putfield(codeBuilder, getEventClassDesc(), FIELD_START_TIME);\n+            codeBuilder.return_();\n@@ -341,8 +384,7 @@\n-        updateMethod(METHOD_END, methodVisitor -> {\n-            methodVisitor.visitIntInsn(Opcodes.ALOAD, 0);\n-            methodVisitor.visitIntInsn(Opcodes.ALOAD, 0);\n-            methodVisitor.visitFieldInsn(Opcodes.GETFIELD, getInternalClassName(), FIELD_START_TIME, \"J\");\n-            invokeStatic(methodVisitor, TYPE_EVENT_CONFIGURATION.getInternalName(), METHOD_DURATION);\n-            methodVisitor.visitFieldInsn(Opcodes.PUTFIELD, getInternalClassName(), FIELD_DURATION, \"J\");\n-            methodVisitor.visitInsn(Opcodes.RETURN);\n-            methodVisitor.visitMaxs(0, 0);\n+        updateMethod(METHOD_END, codeBuilder -> {\n+            codeBuilder.aload(0);\n+            codeBuilder.aload(0);\n+            getfield(codeBuilder, getEventClassDesc(), FIELD_START_TIME);\n+            invokestatic(codeBuilder, TYPE_EVENT_CONFIGURATION, METHOD_DURATION);\n+            putfield(codeBuilder, getEventClassDesc(), FIELD_DURATION);\n+            codeBuilder.return_();\n@@ -352,218 +394,9 @@\n-        if (staticCommitMethod != null) {\n-            updateExistingWithEmptyVoidMethod(METHOD_COMMIT);\n-            updateMethod(staticCommitMethod, mv -> {\n-                \/\/ indexes the argument type array, the argument type array does not include\n-                \/\/ 'this'\n-                int argIndex = 0;\n-                \/\/ indexes the proper slot in the local variable table, takes type size into\n-                \/\/ account, therefore sometimes argIndex != slotIndex\n-                int slotIndex = 0;\n-                int fieldIndex = 0;\n-                Type[] argumentTypes = Type.getArgumentTypes(staticCommitMethod.getDescriptor());\n-                mv.visitCode();\n-                Label start = new Label();\n-                Label endTryBlock = new Label();\n-                Label exceptionHandler = new Label();\n-                mv.visitTryCatchBlock(start, endTryBlock, exceptionHandler, \"java\/lang\/Throwable\");\n-                mv.visitLabel(start);\n-                getEventWriter(mv);\n-                \/\/ stack: [EW]\n-                mv.visitInsn(Opcodes.DUP);\n-                \/\/ stack: [EW], [EW]\n-                \/\/ write begin event\n-                getEventConfiguration(mv);\n-                \/\/ stack: [EW], [EW], [EventConfiguration]\n-                mv.visitLdcInsn(eventTypeId);\n-                \/\/ stack: [EW], [EW], [EventConfiguration] [long]\n-                visitMethod(mv, Opcodes.INVOKEVIRTUAL, TYPE_EVENT_WRITER, EventWriterMethod.BEGIN_EVENT.asASM());\n-                \/\/ stack: [EW], [integer]\n-                Label excluded = new Label();\n-                mv.visitJumpInsn(Opcodes.IFEQ, excluded);\n-                \/\/ stack: [EW]\n-                \/\/ write startTime\n-                mv.visitInsn(Opcodes.DUP);\n-                \/\/ stack: [EW], [EW]\n-                mv.visitVarInsn(argumentTypes[argIndex].getOpcode(Opcodes.ILOAD), slotIndex);\n-                \/\/ stack: [EW], [EW], [long]\n-                slotIndex += argumentTypes[argIndex++].getSize();\n-                visitMethod(mv, Opcodes.INVOKEVIRTUAL, TYPE_EVENT_WRITER, EventWriterMethod.PUT_LONG.asASM());\n-                \/\/ stack: [EW]\n-                fieldIndex++;\n-                \/\/ write duration\n-                mv.visitInsn(Opcodes.DUP);\n-                \/\/ stack: [EW], [EW]\n-                mv.visitVarInsn(argumentTypes[argIndex].getOpcode(Opcodes.ILOAD), slotIndex);\n-                \/\/ stack: [EW], [EW], [long]\n-                slotIndex += argumentTypes[argIndex++].getSize();\n-                visitMethod(mv, Opcodes.INVOKEVIRTUAL, TYPE_EVENT_WRITER, EventWriterMethod.PUT_LONG.asASM());\n-                \/\/ stack: [EW]\n-                fieldIndex++;\n-                \/\/ write eventThread\n-                mv.visitInsn(Opcodes.DUP);\n-                \/\/ stack: [EW], [EW]\n-                visitMethod(mv, Opcodes.INVOKEVIRTUAL, TYPE_EVENT_WRITER, EventWriterMethod.PUT_EVENT_THREAD.asASM());\n-                \/\/ stack: [EW]\n-                \/\/ write stackTrace\n-                mv.visitInsn(Opcodes.DUP);\n-                \/\/ stack: [EW], [EW]\n-                visitMethod(mv, Opcodes.INVOKEVIRTUAL, TYPE_EVENT_WRITER, EventWriterMethod.PUT_STACK_TRACE.asASM());\n-                \/\/ stack: [EW]\n-                \/\/ write custom fields\n-                while (fieldIndex < fieldInfos.size()) {\n-                    mv.visitInsn(Opcodes.DUP);\n-                    \/\/ stack: [EW], [EW]\n-                    mv.visitVarInsn(argumentTypes[argIndex].getOpcode(Opcodes.ILOAD), slotIndex);\n-                    \/\/ stack:[EW], [EW], [field]\n-                    slotIndex += argumentTypes[argIndex++].getSize();\n-                    FieldInfo field = fieldInfos.get(fieldIndex);\n-                    EventWriterMethod eventMethod = EventWriterMethod.lookupMethod(field);\n-                    visitMethod(mv, Opcodes.INVOKEVIRTUAL, TYPE_EVENT_WRITER, eventMethod.asASM());\n-                    \/\/ stack: [EW]\n-                    fieldIndex++;\n-                }\n-                \/\/ stack: [EW]\n-                \/\/ write end event (writer already on stack)\n-                visitMethod(mv, Opcodes.INVOKEVIRTUAL, TYPE_EVENT_WRITER, EventWriterMethod.END_EVENT.asASM());\n-                \/\/ stack [integer]\n-                \/\/ notified -> restart event write attempt\n-                mv.visitJumpInsn(Opcodes.IFEQ, start);\n-                \/\/ stack:\n-                mv.visitLabel(endTryBlock);\n-                Label end = new Label();\n-                mv.visitJumpInsn(Opcodes.GOTO, end);\n-                mv.visitLabel(exceptionHandler);\n-                \/\/ stack: [ex]\n-                mv.visitFrame(Opcodes.F_SAME1, 0, null, 1, new Object[] { \"java\/lang\/Throwable\" });\n-                getEventWriter(mv);\n-                \/\/ stack: [ex] [EW]\n-                mv.visitInsn(Opcodes.DUP);\n-                \/\/ stack: [ex] [EW] [EW]\n-                Label rethrow = new Label();\n-                mv.visitJumpInsn(Opcodes.IFNULL, rethrow);\n-                \/\/ stack: [ex] [EW]\n-                mv.visitInsn(Opcodes.DUP);\n-                \/\/ stack: [ex] [EW] [EW]\n-                visitMethod(mv, Opcodes.INVOKEVIRTUAL, TYPE_EVENT_WRITER, METHOD_RESET);\n-                mv.visitLabel(rethrow);\n-                \/\/ stack:[ex] [EW]\n-                mv.visitFrame(Opcodes.F_SAME, 0, null, 2, new Object[] { \"java\/lang\/Throwable\", TYPE_EVENT_WRITER.getInternalName() });\n-                mv.visitInsn(Opcodes.POP);\n-                \/\/ stack:[ex]\n-                mv.visitInsn(Opcodes.ATHROW);\n-                mv.visitLabel(excluded);\n-                \/\/ stack: [EW]\n-                mv.visitFrame(Opcodes.F_SAME, 0, null, 1, new Object[] { TYPE_EVENT_WRITER.getInternalName() });\n-                mv.visitInsn(Opcodes.POP);\n-                mv.visitLabel(end);\n-                \/\/ stack:\n-                mv.visitFrame(Opcodes.F_SAME, 0, null, 0, null);\n-                mv.visitInsn(Opcodes.RETURN);\n-                mv.visitMaxs(0, 0);\n-                mv.visitEnd();\n-            });\n-        } else {\n-            updateMethod(METHOD_COMMIT, methodVisitor -> {\n-                \/\/ if (!isEnable()) {\n-                \/\/ return;\n-                \/\/ }\n-                methodVisitor.visitCode();\n-                Label start = new Label();\n-                Label endTryBlock = new Label();\n-                Label exceptionHandler = new Label();\n-                methodVisitor.visitTryCatchBlock(start, endTryBlock, exceptionHandler, \"java\/lang\/Throwable\");\n-                methodVisitor.visitLabel(start);\n-                methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);\n-                methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, getInternalClassName(), METHOD_IS_ENABLED.getName(), METHOD_IS_ENABLED.getDescriptor(), false);\n-                Label l0 = new Label();\n-                methodVisitor.visitJumpInsn(Opcodes.IFNE, l0);\n-                methodVisitor.visitInsn(Opcodes.RETURN);\n-                methodVisitor.visitLabel(l0);\n-                methodVisitor.visitFrame(Opcodes.F_SAME, 0, null, 0, null);\n-                \/\/ long startTime = this.startTime\n-                methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);\n-                methodVisitor.visitFieldInsn(Opcodes.GETFIELD, getInternalClassName(), FIELD_START_TIME, \"J\");\n-                methodVisitor.visitVarInsn(Opcodes.LSTORE, 1);\n-                \/\/ if (startTime == 0) {\n-                \/\/ startTime = EventWriter.timestamp();\n-                \/\/ } else {\n-                methodVisitor.visitVarInsn(Opcodes.LLOAD, 1);\n-                methodVisitor.visitInsn(Opcodes.LCONST_0);\n-                methodVisitor.visitInsn(Opcodes.LCMP);\n-                Label durationalEvent = new Label();\n-                methodVisitor.visitJumpInsn(Opcodes.IFNE, durationalEvent);\n-                methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, TYPE_EVENT_CONFIGURATION.getInternalName(), METHOD_TIME_STAMP.getName(), METHOD_TIME_STAMP.getDescriptor(), false);\n-                methodVisitor.visitVarInsn(Opcodes.LSTORE, 1);\n-                Label commit = new Label();\n-                methodVisitor.visitJumpInsn(Opcodes.GOTO, commit);\n-                \/\/ if (duration == 0) {\n-                \/\/ duration = EventWriter.timestamp() - startTime;\n-                \/\/ }\n-                \/\/ }\n-                methodVisitor.visitLabel(durationalEvent);\n-                methodVisitor.visitFrame(Opcodes.F_SAME, 0, null, 0, null);\n-                methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);\n-                methodVisitor.visitFieldInsn(Opcodes.GETFIELD, getInternalClassName(), FIELD_DURATION, \"J\");\n-                methodVisitor.visitInsn(Opcodes.LCONST_0);\n-                methodVisitor.visitInsn(Opcodes.LCMP);\n-                methodVisitor.visitJumpInsn(Opcodes.IFNE, commit);\n-                methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);\n-                methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, TYPE_EVENT_CONFIGURATION.getInternalName(), METHOD_TIME_STAMP.getName(), METHOD_TIME_STAMP.getDescriptor(), false);\n-                methodVisitor.visitVarInsn(Opcodes.LLOAD, 1);\n-                methodVisitor.visitInsn(Opcodes.LSUB);\n-                methodVisitor.visitFieldInsn(Opcodes.PUTFIELD, getInternalClassName(), FIELD_DURATION, \"J\");\n-                methodVisitor.visitLabel(commit);\n-                \/\/ if (shouldCommit()) {\n-                methodVisitor.visitFrame(Opcodes.F_SAME, 0, null, 0, null);\n-                methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);\n-                invokeVirtual(methodVisitor, getInternalClassName(), METHOD_EVENT_SHOULD_COMMIT);\n-                Label end = new Label();\n-                methodVisitor.visitJumpInsn(Opcodes.IFEQ, end);\n-                getEventWriter(methodVisitor);\n-                \/\/ stack: [EW]\n-                methodVisitor.visitInsn(Opcodes.DUP);\n-                \/\/ stack: [EW] [EW]\n-                getEventConfiguration(methodVisitor);\n-                \/\/ stack: [EW] [EW] [EC]\n-                methodVisitor.visitLdcInsn(eventTypeId);\n-                invokeVirtual(methodVisitor, TYPE_EVENT_WRITER, EventWriterMethod.BEGIN_EVENT.asmMethod);\n-                Label excluded = new Label();\n-                \/\/ stack: [EW] [int]\n-                methodVisitor.visitJumpInsn(Opcodes.IFEQ, excluded);\n-                \/\/ stack: [EW]\n-                int fieldIndex = 0;\n-                methodVisitor.visitInsn(Opcodes.DUP);\n-                \/\/ stack: [EW] [EW]\n-                methodVisitor.visitVarInsn(Opcodes.LLOAD, 1);\n-                \/\/ stack: [EW] [EW] [long]\n-                invokeVirtual(methodVisitor, TYPE_EVENT_WRITER, EventWriterMethod.PUT_LONG.asmMethod);\n-                \/\/ stack: [EW]\n-                fieldIndex++;\n-                methodVisitor.visitInsn(Opcodes.DUP);\n-                \/\/ stack: [EW] [EW]\n-                methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);\n-                \/\/ stack: [EW] [EW] [this]\n-                methodVisitor.visitFieldInsn(Opcodes.GETFIELD, getInternalClassName(), FIELD_DURATION, \"J\");\n-                \/\/ stack: [EW] [EW] [long]\n-                invokeVirtual(methodVisitor, TYPE_EVENT_WRITER, EventWriterMethod.PUT_LONG.asmMethod);\n-                \/\/ stack: [EW]\n-                fieldIndex++;\n-                methodVisitor.visitInsn(Opcodes.DUP);\n-                \/\/ stack: [EW] [EW]\n-                invokeVirtual(methodVisitor, TYPE_EVENT_WRITER, EventWriterMethod.PUT_EVENT_THREAD.asASM());\n-                \/\/ stack: [EW]\n-                methodVisitor.visitInsn(Opcodes.DUP);\n-                \/\/ stack: [EW] [EW]\n-                invokeVirtual(methodVisitor, TYPE_EVENT_WRITER, EventWriterMethod.PUT_STACK_TRACE.asASM());\n-                \/\/ stack: [EW]\n-                while (fieldIndex < fieldInfos.size()) {\n-                    FieldInfo field = fieldInfos.get(fieldIndex);\n-                    methodVisitor.visitInsn(Opcodes.DUP);\n-                    \/\/ stack: [EW] [EW]\n-                    methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);\n-                    \/\/ stack: [EW] [EW] [this]\n-                    methodVisitor.visitFieldInsn(Opcodes.GETFIELD, getInternalClassName(), field.name, field.descriptor);\n-                    \/\/ stack: [EW] [EW] <T>\n-                    EventWriterMethod eventMethod = EventWriterMethod.lookupMethod(field);\n-                    invokeVirtual(methodVisitor, TYPE_EVENT_WRITER, eventMethod.asmMethod);\n-                    \/\/ stack: [EW]\n-                    fieldIndex++;\n+        MethodDesc m = staticCommitMethod == null ? METHOD_COMMIT : staticCommitMethod;\n+        updateMethod(m, codeBuilder -> {\n+            Label excluded = codeBuilder.newLabel();\n+            Label end = codeBuilder.newLabel();\n+            codeBuilder.trying(blockCodeBuilder -> {\n+                if (staticCommitMethod != null) {\n+                    updateStaticCommit(blockCodeBuilder, excluded);\n+                } else {\n+                    updateInstanceCommit(blockCodeBuilder, end, excluded);\n@@ -571,3 +404,1 @@\n-                \/\/ stack:[EW]\n-                invokeVirtual(methodVisitor, TYPE_EVENT_WRITER, EventWriterMethod.END_EVENT.asASM());\n-                \/\/ stack [int]\n+                \/\/ stack: [integer]\n@@ -575,32 +406,21 @@\n-                methodVisitor.visitJumpInsn(Opcodes.IFEQ, start);\n-                methodVisitor.visitLabel(endTryBlock);\n-                methodVisitor.visitJumpInsn(Opcodes.GOTO, end);\n-                methodVisitor.visitLabel(exceptionHandler);\n-                \/\/ stack: [ex]\n-                methodVisitor.visitFrame(Opcodes.F_SAME1, 0, null, 1, new Object[] { \"java\/lang\/Throwable\" });\n-                getEventWriter(methodVisitor);\n-                \/\/ stack: [ex] [EW]\n-                methodVisitor.visitInsn(Opcodes.DUP);\n-                \/\/ stack: [ex] [EW] [EW]\n-                Label rethrow = new Label();\n-                methodVisitor.visitJumpInsn(Opcodes.IFNULL, rethrow);\n-                \/\/ stack: [ex] [EW]\n-                methodVisitor.visitInsn(Opcodes.DUP);\n-                \/\/ stack: [ex] [EW] [EW]\n-                visitMethod(methodVisitor, Opcodes.INVOKEVIRTUAL, TYPE_EVENT_WRITER, METHOD_RESET);\n-                methodVisitor.visitLabel(rethrow);\n-                \/\/ stack:[ex] [EW]\n-                methodVisitor.visitFrame(Opcodes.F_SAME, 0, null, 2, new Object[] { \"java\/lang\/Throwable\", TYPE_EVENT_WRITER.getInternalName() });\n-                methodVisitor.visitInsn(Opcodes.POP);\n-                \/\/ stack:[ex]\n-                methodVisitor.visitInsn(Opcodes.ATHROW);\n-                methodVisitor.visitLabel(excluded);\n-                \/\/ stack: [EW]\n-                methodVisitor.visitFrame(Opcodes.F_SAME, 0, null, 1, new Object[] { TYPE_EVENT_WRITER.getInternalName() });\n-                methodVisitor.visitInsn(Opcodes.POP);\n-                methodVisitor.visitLabel(end);\n-                \/\/ stack:\n-                methodVisitor.visitFrame(Opcodes.F_SAME, 0, null, 0, null);\n-                methodVisitor.visitInsn(Opcodes.RETURN);\n-                methodVisitor.visitMaxs(0, 0);\n-                methodVisitor.visitEnd();\n+                blockCodeBuilder.ifeq(blockCodeBuilder.startLabel());\n+                \/\/ stack: []\n+                blockCodeBuilder.goto_(end);\n+            }, catchBuilder -> {\n+                catchBuilder.catchingAll(catchAllHandler -> {\n+                    getEventWriter(catchAllHandler);\n+                    \/\/ stack: [ex] [EW]\n+                    catchAllHandler.dup();\n+                    \/\/ stack: [ex] [EW] [EW]\n+                    Label rethrow = catchAllHandler.newLabel();\n+                    catchAllHandler.if_null(rethrow);\n+                    \/\/ stack: [ex] [EW]\n+                    catchAllHandler.dup();\n+                    \/\/ stack: [ex] [EW] [EW]\n+                    invokevirtual(catchAllHandler, TYPE_EVENT_WRITER, METHOD_RESET);\n+                    catchAllHandler.labelBinding(rethrow);\n+                    \/\/ stack:[ex] [EW]\n+                    catchAllHandler.pop();\n+                    \/\/ stack:[ex]\n+                    catchAllHandler.throwInstruction();\n+                });\n@@ -608,1 +428,7 @@\n-        }\n+            codeBuilder.labelBinding(excluded);\n+            \/\/ stack: [EW]\n+            codeBuilder.pop();\n+            codeBuilder.labelBinding(end);\n+            \/\/ stack: []\n+            codeBuilder.return_();\n+        });\n@@ -611,2 +437,2 @@\n-        updateMethod(METHOD_EVENT_SHOULD_COMMIT, methodVisitor -> {\n-            Label fail = new Label();\n+        updateMethod(METHOD_EVENT_SHOULD_COMMIT, codeBuilder -> {\n+            Label fail = codeBuilder.newLabel();\n@@ -614,2 +440,2 @@\n-                getEventConfiguration(methodVisitor);\n-                methodVisitor.visitJumpInsn(Opcodes.IFNULL, fail);\n+                getEventConfiguration(codeBuilder);\n+                codeBuilder.if_null(fail);\n@@ -618,7 +444,7 @@\n-            getEventConfiguration(methodVisitor);\n-            methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);\n-            methodVisitor.visitFieldInsn(Opcodes.GETFIELD, getInternalClassName(), FIELD_DURATION, \"J\");\n-            invokeVirtual(methodVisitor, TYPE_EVENT_CONFIGURATION, METHOD_EVENT_CONFIGURATION_SHOULD_COMMIT);\n-            methodVisitor.visitJumpInsn(Opcodes.IFEQ, fail);\n-            for (int index = 0; index < settingInfos.size(); index++) {\n-                SettingInfo si = settingInfos.get(index);\n+            getEventConfiguration(codeBuilder);\n+            codeBuilder.aload(0);\n+            getfield(codeBuilder, getEventClassDesc(), FIELD_DURATION);\n+            invokevirtual(codeBuilder, TYPE_EVENT_CONFIGURATION, METHOD_EVENT_CONFIGURATION_SHOULD_COMMIT);\n+            codeBuilder.ifeq(fail);\n+            for (int index = 0; index < settingDescs.size(); index++) {\n+                SettingDesc sd = settingDescs.get(index);\n@@ -626,12 +452,9 @@\n-                methodVisitor.visitIntInsn(Opcodes.ALOAD, 0);\n-                if (untypedEventConfiguration) {\n-                    methodVisitor.visitFieldInsn(Opcodes.GETSTATIC, getInternalClassName(), FIELD_EVENT_CONFIGURATION, TYPE_OBJECT_DESCRIPTOR);\n-                } else {\n-                    methodVisitor.visitFieldInsn(Opcodes.GETSTATIC, getInternalClassName(), FIELD_EVENT_CONFIGURATION, TYPE_EVENT_CONFIGURATION_DESCRIPTOR);\n-                }\n-                methodVisitor.visitTypeInsn(Opcodes.CHECKCAST, TYPE_EVENT_CONFIGURATION.getInternalName());\n-                methodVisitor.visitLdcInsn(index);\n-                invokeVirtual(methodVisitor, TYPE_EVENT_CONFIGURATION, METHOD_EVENT_CONFIGURATION_GET_SETTING);\n-                methodVisitor.visitTypeInsn(Opcodes.CHECKCAST, si.paramType().getInternalName());\n-                methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, getInternalClassName(), si.methodName, \"(\" + si.paramType().getDescriptor() + \")Z\", false);\n-                methodVisitor.visitJumpInsn(Opcodes.IFEQ, fail);\n+                codeBuilder.aload(0);\n+                getEventConfiguration(codeBuilder);\n+                codeBuilder.checkcast(TYPE_EVENT_CONFIGURATION);\n+                codeBuilder.ldc(index);\n+                invokevirtual(codeBuilder, TYPE_EVENT_CONFIGURATION, METHOD_EVENT_CONFIGURATION_GET_SETTING);\n+                MethodTypeDesc mdesc = MethodTypeDesc.ofDescriptor(\"(\" + sd.paramType().descriptorString() + \")Z\");\n+                codeBuilder.checkcast(sd.paramType());\n+                codeBuilder.invokevirtual(getEventClassDesc(), sd.methodName(), mdesc);\n+                codeBuilder.ifeq(fail);\n@@ -640,2 +463,2 @@\n-            methodVisitor.visitInsn(Opcodes.ICONST_1);\n-            methodVisitor.visitInsn(Opcodes.IRETURN);\n+            codeBuilder.iconst_1();\n+            codeBuilder.ireturn();\n@@ -643,3 +466,3 @@\n-            methodVisitor.visitLabel(fail);\n-            methodVisitor.visitInsn(Opcodes.ICONST_0);\n-            methodVisitor.visitInsn(Opcodes.IRETURN);\n+            codeBuilder.labelBinding(fail);\n+            codeBuilder.iconst_0();\n+            codeBuilder.ireturn();\n@@ -651,3 +474,4 @@\n-            };\n-            updateIfStaticMethodExists(METHOD_SHOULD_COMMIT_LONG, methodVisitor -> {\n-                Label fail = new Label();\n+            }\n+\n+            updateIfStaticMethodExists(METHOD_SHOULD_COMMIT_LONG, codeBuilder -> {\n+                Label fail = codeBuilder.newLabel();\n@@ -656,2 +480,2 @@\n-                    getEventConfiguration(methodVisitor);\n-                    methodVisitor.visitJumpInsn(Opcodes.IFNULL, fail);\n+                    getEventConfiguration(codeBuilder);\n+                    codeBuilder.if_null(fail);\n@@ -660,4 +484,4 @@\n-                getEventConfiguration(methodVisitor);\n-                methodVisitor.visitVarInsn(Opcodes.LLOAD, 0);\n-                invokeVirtual(methodVisitor, TYPE_EVENT_CONFIGURATION, METHOD_EVENT_CONFIGURATION_SHOULD_COMMIT);\n-                methodVisitor.visitInsn(Opcodes.IRETURN);\n+                getEventConfiguration(codeBuilder);\n+                codeBuilder.lload(0);\n+                codeBuilder.invokevirtual(TYPE_EVENT_CONFIGURATION, METHOD_EVENT_CONFIGURATION_SHOULD_COMMIT.name(), METHOD_EVENT_CONFIGURATION_SHOULD_COMMIT.descriptor());\n+                codeBuilder.ireturn();\n@@ -665,1 +489,1 @@\n-                methodVisitor.visitLabel(fail);\n+                codeBuilder.labelBinding(fail);\n@@ -667,4 +491,2 @@\n-                methodVisitor.visitInsn(Opcodes.ICONST_0);\n-                methodVisitor.visitInsn(Opcodes.IRETURN);\n-                methodVisitor.visitMaxs(0, 0);\n-                methodVisitor.visitEnd();\n+                codeBuilder.iconst_0();\n+                codeBuilder.ireturn();\n@@ -672,5 +494,3 @@\n-            updateIfStaticMethodExists(METHOD_TIME_STAMP, methodVisitor -> {\n-                invokeStatic(methodVisitor, TYPE_EVENT_CONFIGURATION.getInternalName(), METHOD_TIME_STAMP);\n-                methodVisitor.visitInsn(Opcodes.LRETURN);\n-                methodVisitor.visitMaxs(0, 0);\n-                methodVisitor.visitEnd();\n+            updateIfStaticMethodExists(METHOD_TIME_STAMP, codeBuilder -> {\n+                invokestatic(codeBuilder, TYPE_EVENT_CONFIGURATION, METHOD_TIME_STAMP);\n+                codeBuilder.lreturn();\n@@ -681,3 +501,176 @@\n-    private void updateEnabledMethod(Method method) {\n-        updateMethod(method, methodVisitor -> {\n-            Label nullLabel = new Label();\n+    void updateStaticCommit(BlockCodeBuilder blockCodeBuilder, Label excluded) {\n+        \/\/ indexes the argument type array, the argument type array does not include\n+        \/\/ 'this'\n+        int argIndex = 0;\n+        \/\/ indexes the proper slot in the local variable table, takes type size into\n+        \/\/ account, therefore sometimes argIndex != slotIndex\n+        int slotIndex = 0;\n+        int fieldIndex = 0;\n+        ClassDesc[] argumentTypes = staticCommitMethod.descriptor().parameterArray();\n+        TypeKind tk = null;\n+        getEventWriter(blockCodeBuilder);\n+        \/\/ stack: [EW],\n+        blockCodeBuilder.dup();\n+        \/\/ stack: [EW], [EW]\n+        \/\/ write begin event\n+        getEventConfiguration(blockCodeBuilder);\n+        \/\/ stack: [EW], [EW], [EventConfiguration]\n+        blockCodeBuilder.constantInstruction(Opcode.LDC2_W, eventTypeId);\n+        \/\/ stack: [EW], [EW], [EventConfiguration] [long]\n+        invokevirtual(blockCodeBuilder, TYPE_EVENT_WRITER, EventWriterMethod.BEGIN_EVENT.method());\n+        \/\/ stack: [EW], [integer]\n+        blockCodeBuilder.ifeq(excluded);\n+        \/\/ stack: [EW]\n+        \/\/ write startTime\n+        blockCodeBuilder.dup();\n+        \/\/ stack: [EW], [EW]\n+        tk = TypeKind.from(argumentTypes[argIndex++]);\n+        blockCodeBuilder.loadInstruction(tk, slotIndex);\n+        \/\/ stack: [EW], [EW], [long]\n+        slotIndex += tk.slotSize();\n+        invokevirtual(blockCodeBuilder, TYPE_EVENT_WRITER, EventWriterMethod.PUT_LONG.method());\n+        \/\/ stack: [EW]\n+        fieldIndex++;\n+        \/\/ write duration\n+        blockCodeBuilder.dup();\n+        \/\/ stack: [EW], [EW]\n+        tk = TypeKind.from(argumentTypes[argIndex++]);\n+        blockCodeBuilder.loadInstruction(tk, slotIndex);\n+        \/\/ stack: [EW], [EW], [long]\n+        slotIndex += tk.slotSize();\n+        invokevirtual(blockCodeBuilder, TYPE_EVENT_WRITER, EventWriterMethod.PUT_LONG.method());\n+        \/\/ stack: [EW]\n+        fieldIndex++;\n+        \/\/ write eventThread\n+        blockCodeBuilder.dup();\n+        \/\/ stack: [EW], [EW]\n+        invokevirtual(blockCodeBuilder, TYPE_EVENT_WRITER, EventWriterMethod.PUT_EVENT_THREAD.method());\n+        \/\/ stack: [EW]\n+        \/\/ write stackTrace\n+        blockCodeBuilder.dup();\n+        \/\/ stack: [EW], [EW]\n+        invokevirtual(blockCodeBuilder, TYPE_EVENT_WRITER, EventWriterMethod.PUT_STACK_TRACE.method());\n+        \/\/ stack: [EW]\n+        \/\/ write custom fields\n+        while (fieldIndex < fieldDescs.size()) {\n+            blockCodeBuilder.dup();\n+            \/\/ stack: [EW], [EW]\n+            tk = TypeKind.from(argumentTypes[argIndex++]);\n+            blockCodeBuilder.loadInstruction(tk, slotIndex);\n+            \/\/ stack:[EW], [EW], [field]\n+            slotIndex += tk.slotSize();\n+            FieldDesc field = fieldDescs.get(fieldIndex);\n+            EventWriterMethod eventMethod = EventWriterMethod.lookupMethod(field);\n+            invokevirtual(blockCodeBuilder, TYPE_EVENT_WRITER, eventMethod.method());\n+            \/\/ stack: [EW]\n+            fieldIndex++;\n+        }\n+        \/\/ stack: [EW]\n+        \/\/ write end event (writer already on stack)\n+        invokevirtual(blockCodeBuilder, TYPE_EVENT_WRITER, EventWriterMethod.END_EVENT.method());\n+        \/\/ stack: [int]\n+    }\n+\n+    void updateInstanceCommit(BlockCodeBuilder blockCodeBuilder, Label end, Label excluded) {\n+        \/\/ if (!isEnable()) {\n+        \/\/ return;\n+        \/\/ }\n+        blockCodeBuilder.aload(0);\n+        invokevirtual(blockCodeBuilder, getEventClassDesc(), METHOD_IS_ENABLED);\n+        Label l0 = blockCodeBuilder.newLabel();\n+        blockCodeBuilder.ifne(l0);\n+        blockCodeBuilder.return_();\n+        blockCodeBuilder.labelBinding(l0);\n+        \/\/ long startTime = this.startTime\n+        blockCodeBuilder.aload(0);\n+        getfield(blockCodeBuilder, getEventClassDesc(), FIELD_START_TIME);\n+        blockCodeBuilder.lstore(1);\n+        \/\/ if (startTime == 0) {\n+        \/\/   startTime = EventWriter.timestamp();\n+        \/\/ } else {\n+        blockCodeBuilder.lload(1);\n+        blockCodeBuilder.lconst_0();\n+        blockCodeBuilder.lcmp();\n+        Label durationEvent = blockCodeBuilder.newLabel();\n+        blockCodeBuilder.ifne(durationEvent);\n+        invokestatic(blockCodeBuilder, TYPE_EVENT_CONFIGURATION, METHOD_TIME_STAMP);\n+        blockCodeBuilder.lstore(1);\n+        Label commit = blockCodeBuilder.newLabel();\n+        blockCodeBuilder.goto_(commit);\n+        \/\/   if (duration == 0) {\n+        \/\/     duration = EventWriter.timestamp() - startTime;\n+        \/\/   }\n+        \/\/ }\n+        blockCodeBuilder.labelBinding(durationEvent);\n+        blockCodeBuilder.aload(0);\n+        getfield(blockCodeBuilder, getEventClassDesc(), FIELD_DURATION);\n+        blockCodeBuilder.lconst_0();\n+        blockCodeBuilder.lcmp();\n+        blockCodeBuilder.ifne(commit);\n+        blockCodeBuilder.aload(0);\n+        invokestatic(blockCodeBuilder, TYPE_EVENT_CONFIGURATION, METHOD_TIME_STAMP);\n+        blockCodeBuilder.lload(1);\n+        blockCodeBuilder.lsub();\n+        putfield(blockCodeBuilder, getEventClassDesc(), FIELD_DURATION);\n+        blockCodeBuilder.labelBinding(commit);\n+        \/\/ if (shouldCommit()) {\n+        blockCodeBuilder.aload(0);\n+        invokevirtual(blockCodeBuilder, getEventClassDesc(), METHOD_EVENT_SHOULD_COMMIT);\n+        blockCodeBuilder.ifeq(end);\n+        getEventWriter(blockCodeBuilder);\n+        \/\/ stack: [EW]\n+        blockCodeBuilder.dup();\n+        \/\/ stack: [EW] [EW]\n+        getEventConfiguration(blockCodeBuilder);\n+        \/\/ stack: [EW] [EW] [EC]\n+        blockCodeBuilder.constantInstruction(Opcode.LDC2_W, eventTypeId);\n+        invokevirtual(blockCodeBuilder, TYPE_EVENT_WRITER, EventWriterMethod.BEGIN_EVENT.method());\n+        \/\/ stack: [EW] [int]\n+        blockCodeBuilder.ifeq(excluded);\n+        \/\/ stack: [EW]\n+        int fieldIndex = 0;\n+        blockCodeBuilder.dup();\n+        \/\/ stack: [EW] [EW]\n+        blockCodeBuilder.lload(1);\n+        \/\/ stack: [EW] [EW] [long]\n+        invokevirtual(blockCodeBuilder, TYPE_EVENT_WRITER, EventWriterMethod.PUT_LONG.method());\n+        \/\/ stack: [EW]\n+        fieldIndex++;\n+        blockCodeBuilder.dup();\n+        \/\/ stack: [EW] [EW]\n+        blockCodeBuilder.aload(0);\n+        \/\/ stack: [EW] [EW] [this]\n+        getfield(blockCodeBuilder, getEventClassDesc(), FIELD_DURATION);\n+        \/\/ stack: [EW] [EW] [long]\n+        invokevirtual(blockCodeBuilder, TYPE_EVENT_WRITER, EventWriterMethod.PUT_LONG.method());\n+        \/\/ stack: [EW]\n+        fieldIndex++;\n+        blockCodeBuilder.dup();\n+        \/\/ stack: [EW] [EW]\n+        invokevirtual(blockCodeBuilder, TYPE_EVENT_WRITER, EventWriterMethod.PUT_EVENT_THREAD.method());\n+        \/\/ stack: [EW]\n+        blockCodeBuilder.dup();\n+        \/\/ stack: [EW] [EW]\n+        invokevirtual(blockCodeBuilder, TYPE_EVENT_WRITER, EventWriterMethod.PUT_STACK_TRACE.method());\n+        \/\/ stack: [EW]\n+        while (fieldIndex < fieldDescs.size()) {\n+            FieldDesc field = fieldDescs.get(fieldIndex);\n+            blockCodeBuilder.dup();\n+            \/\/ stack: [EW] [EW]\n+            blockCodeBuilder.aload(0);\n+            \/\/ stack: [EW] [EW] [this]\n+            getfield(blockCodeBuilder, getEventClassDesc(), field);\n+            \/\/ stack: [EW] [EW] <T>\n+            EventWriterMethod eventMethod = EventWriterMethod.lookupMethod(field);\n+            invokevirtual(blockCodeBuilder, TYPE_EVENT_WRITER, eventMethod.method());\n+            \/\/ stack: [EW]\n+            fieldIndex++;\n+        }\n+        \/\/ stack:[EW]\n+        invokevirtual(blockCodeBuilder, TYPE_EVENT_WRITER, EventWriterMethod.END_EVENT.method());\n+        \/\/ stack:[int]\n+    }\n+\n+    private void updateEnabledMethod(MethodDesc method) {\n+        updateMethod(method, codeBuilder -> {\n+            Label nullLabel = codeBuilder.newLabel();\n@@ -685,2 +678,2 @@\n-                getEventConfiguration(methodVisitor);\n-                methodVisitor.visitJumpInsn(Opcodes.IFNULL, nullLabel);\n+                getEventConfiguration(codeBuilder);\n+                codeBuilder.branchInstruction(Opcode.IFNULL, nullLabel);\n@@ -688,3 +681,3 @@\n-            getEventConfiguration(methodVisitor);\n-            invokeVirtual(methodVisitor, TYPE_EVENT_CONFIGURATION, METHOD_IS_ENABLED);\n-            methodVisitor.visitInsn(Opcodes.IRETURN);\n+            getEventConfiguration(codeBuilder);\n+            invokevirtual(codeBuilder, TYPE_EVENT_CONFIGURATION, METHOD_IS_ENABLED);\n+            codeBuilder.ireturn();\n@@ -692,4 +685,3 @@\n-                methodVisitor.visitLabel(nullLabel);\n-                methodVisitor.visitFrame(Opcodes.F_SAME, 0, null, 0, null);\n-                methodVisitor.visitInsn(Opcodes.ICONST_0);\n-                methodVisitor.visitInsn(Opcodes.IRETURN);\n+                codeBuilder.labelBinding(nullLabel);\n+                codeBuilder.iconst_0();\n+                codeBuilder.ireturn();\n@@ -697,2 +689,0 @@\n-            methodVisitor.visitMaxs(0, 0);\n-            methodVisitor.visitEnd();\n@@ -702,1 +692,1 @@\n-    private void updateIfStaticMethodExists(Method method, Consumer<MethodVisitor> code) {\n+    private void updateIfStaticMethodExists(MethodDesc method, Consumer<CodeBuilder> code) {\n@@ -708,4 +698,4 @@\n-    private boolean hasStaticMethod(Method method) {\n-        for (MethodNode m : classNode.methods) {\n-            if (m.name.equals(method.getName()) && m.desc.equals(method.getDescriptor())) {\n-                return Modifier.isStatic(m.access);\n+    private boolean hasStaticMethod(MethodDesc method) {\n+        for (MethodModel m : classModel.methods()) {\n+            if (m.methodName().equalsString(method.name()) && m.methodTypeSymbol().equals(method.descriptor())) {\n+                return Modifier.isStatic(m.flags().flagsMask());\n@@ -717,3 +707,3 @@\n-    private void getEventWriter(MethodVisitor mv) {\n-        mv.visitLdcInsn(EventWriterKey.getKey());\n-        visitMethod(mv, Opcodes.INVOKESTATIC, TYPE_EVENT_WRITER_FACTORY, METHOD_GET_EVENT_WRITER_KEY);\n+    private void getEventWriter(CodeBuilder codeBuilder) {\n+        codeBuilder.ldc(EventWriterKey.getKey());\n+        invokestatic(codeBuilder, TYPE_EVENT_WRITER_FACTORY, METHOD_GET_EVENT_WRITER_KEY);\n@@ -722,17 +712,1 @@\n-    private void visitMethod(final MethodVisitor mv, final int opcode, final Type type, final Method method) {\n-        mv.visitMethodInsn(opcode, type.getInternalName(), method.getName(), method.getDescriptor(), false);\n-    }\n-\n-    private static void invokeStatic(MethodVisitor methodVisitor, String className, Method m) {\n-        methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, className, m.getName(), m.getDescriptor(), false);\n-    }\n-\n-    private static void invokeVirtual(MethodVisitor methodVisitor, String className, Method m) {\n-        methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, className, m.getName(), m.getDescriptor(), false);\n-    }\n-\n-    private void invokeVirtual(MethodVisitor methodVisitor, Type type, Method method) {\n-        methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, type.getInternalName(), method.getName(), method.getDescriptor(), false);\n-    }\n-\n-    private void getEventConfiguration(MethodVisitor methodVisitor) {\n+    private void getEventConfiguration(CodeBuilder codeBuilder) {\n@@ -740,1 +714,1 @@\n-            methodVisitor.visitFieldInsn(Opcodes.GETSTATIC, getInternalClassName(), FIELD_EVENT_CONFIGURATION, TYPE_OBJECT_DESCRIPTOR);\n+            codeBuilder.getstatic(getEventClassDesc(), FIELD_EVENT_CONFIGURATION.name(), TYPE_OBJECT);\n@@ -742,1 +716,1 @@\n-            methodVisitor.visitFieldInsn(Opcodes.GETSTATIC, getInternalClassName(), FIELD_EVENT_CONFIGURATION, TYPE_EVENT_CONFIGURATION_DESCRIPTOR);\n+            codeBuilder.getstatic(getEventClassDesc(), FIELD_EVENT_CONFIGURATION.name(), TYPE_EVENT_CONFIGURATION);\n@@ -757,3 +731,3 @@\n-    private final void updateExistingWithEmptyVoidMethod(Method voidMethod) {\n-        updateMethod(voidMethod, methodVisitor -> {\n-            methodVisitor.visitInsn(Opcodes.RETURN);\n+    private final void updateExistingWithEmptyVoidMethod(MethodDesc voidMethod) {\n+        updateMethod(voidMethod, codeBuilder -> {\n+            codeBuilder.return_();\n@@ -763,4 +737,4 @@\n-    private final void updateExistingWithReturnFalse(Method voidMethod) {\n-        updateMethod(voidMethod, methodVisitor -> {\n-            methodVisitor.visitInsn(Opcodes.ICONST_0);\n-            methodVisitor.visitInsn(Opcodes.IRETURN);\n+    private final void updateExistingWithReturnFalse(MethodDesc voidMethod) {\n+        updateMethod(voidMethod, codeBuilder -> {\n+            codeBuilder.iconst_0();\n+            codeBuilder.ireturn();\n@@ -770,7 +744,3 @@\n-    private MethodNode getMethodNode(Method method) {\n-        for (MethodNode m : classNode.methods) {\n-            if (m.name.equals(method.getName()) && m.desc.equals(method.getDescriptor())) {\n-                return m;\n-            }\n-        }\n-        return null;\n+    private Consumer<CodeBuilder> findMethodUpdate(MethodModel mm) {\n+        MethodDesc m = MethodDesc.of(mm.methodName().stringValue(), mm.methodType().stringValue());\n+        return methodUpdates.get(m);\n@@ -779,11 +749,2 @@\n-    private final void updateMethod(Method method, Consumer<MethodVisitor> code) {\n-        MethodNode old = getMethodNode(method);\n-        int index = classNode.methods.indexOf(old);\n-        classNode.methods.remove(old);\n-        MethodVisitor mv = classNode.visitMethod(old.access, old.name, old.desc, null, null);\n-        mv.visitCode();\n-        code.accept(mv);\n-        mv.visitMaxs(0, 0);\n-        MethodNode newMethod = getMethodNode(method);\n-        classNode.methods.remove(newMethod);\n-        classNode.methods.add(index, newMethod);\n+    private void updateMethod(MethodDesc method, Consumer<CodeBuilder> codeBuilder) {\n+        methodUpdates.put(method, codeBuilder);\n@@ -792,2 +753,2 @@\n-    private String getInternalClassName() {\n-        return classNode.name;\n+    private ClassDesc getEventClassDesc() {\n+        return classModel.thisClass().asSymbol();\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/EventInstrumentation.java","additions":486,"deletions":525,"binary":false,"changes":1011,"status":"modified"},{"patch":"@@ -28,3 +28,3 @@\n-import jdk.internal.org.objectweb.asm.commons.Method;\n-import jdk.jfr.internal.EventInstrumentation.FieldInfo;\n-import jdk.jfr.internal.event.EventConfiguration;\n+import jdk.jfr.internal.util.Bytecode.FieldDesc;\n+import jdk.jfr.internal.util.Bytecode.MethodDesc;\n+import jdk.jfr.internal.util.Utils;\n@@ -34,15 +34,15 @@\n-    BEGIN_EVENT(\"(\" + jdk.internal.org.objectweb.asm.Type.getType(EventConfiguration.class).getDescriptor() + \"J)Z\", \"???\", \"beginEvent\"),\n-    END_EVENT(\"()Z\", \"???\", \"endEvent\"),\n-    PUT_BYTE(\"(B)V\", \"byte\", \"putByte\"),\n-    PUT_SHORT(\"(S)V\", \"short\", \"putShort\"),\n-    PUT_INT(\"(I)V\", \"int\", \"putInt\"),\n-    PUT_LONG(\"(J)V\", \"long\", \"putLong\"),\n-    PUT_FLOAT(\"(F)V\", \"float\", \"putFloat\"),\n-    PUT_DOUBLE(\"(D)V\", \"double\", \"putDouble\"),\n-    PUT_CHAR(\"(C)V\", \"char\", \"putChar\"),\n-    PUT_BOOLEAN(\"(Z)V\", \"boolean\", \"putBoolean\"),\n-    PUT_THREAD(\"(Ljava\/lang\/Thread;)V\", Type.THREAD.getName(), \"putThread\"),\n-    PUT_CLASS(\"(Ljava\/lang\/Class;)V\", Type.CLASS.getName(), \"putClass\"),\n-    PUT_STRING(\"(Ljava\/lang\/String;)V\", Type.STRING.getName(), \"putString\"),\n-    PUT_EVENT_THREAD(\"()V\", Type.THREAD.getName(), \"putEventThread\"),\n-    PUT_STACK_TRACE(\"()V\", Type.TYPES_PREFIX + \"StackTrace\", \"putStackTrace\");\n+     BEGIN_EVENT(\"beginEvent\", \"(Ljdk\/jfr\/internal\/event\/EventConfiguration;J)Z\", \"???\"),\n+     END_EVENT(\"endEvent\", \"()Z\", \"???\"),\n+     PUT_BYTE(\"putByte\", \"(B)V\", \"B\"),\n+     PUT_SHORT(\"putShort\", \"(S)V\", \"S\"),\n+     PUT_INT(\"putInt\", \"(I)V\", \"I\"),\n+     PUT_LONG(\"putLong\", \"(J)V\", \"J\"),\n+     PUT_FLOAT(\"putFloat\", \"(F)V\", \"F\"),\n+     PUT_DOUBLE(\"putDouble\", \"(D)V\", \"D\"),\n+     PUT_CHAR(\"putChar\", \"(C)V\", \"C\"),\n+     PUT_BOOLEAN(\"putBoolean\", \"(Z)V\", \"Z\"),\n+     PUT_THREAD(\"putThread\", \"(Ljava\/lang\/Thread;)V\", \"Ljava\/lang\/Thread;\"),\n+     PUT_CLASS(\"putClass\", \"(Ljava\/lang\/Class;)V\", \"Ljava\/lang\/Class;\"),\n+     PUT_STRING(\"putString\", \"(Ljava\/lang\/String;)V\", \"Ljava\/lang\/String;\"),\n+     PUT_EVENT_THREAD(\"putEventThread\", \"()V\", \"???\"),\n+     PUT_STACK_TRACE(\"putStackTrace\", \"()V\", \"???\");\n@@ -50,2 +50,2 @@\n-    final Method asmMethod;\n-    final String typeDescriptor;\n+    final MethodDesc method;\n+    final String fieldType;\n@@ -53,3 +53,3 @@\n-    EventWriterMethod(String paramSignature, String typeName, String methodName) {\n-        this.typeDescriptor = ASMToolkit.getDescriptor(typeName);\n-        this.asmMethod = new Method(methodName, paramSignature);\n+    EventWriterMethod(String methodName, String paramType, String fieldType) {\n+        this.fieldType = fieldType;\n+        this.method = MethodDesc.of(methodName, paramType);\n@@ -58,2 +58,2 @@\n-    public Method asASM() {\n-        return asmMethod;\n+    public MethodDesc method() {\n+        return method;\n@@ -70,1 +70,1 @@\n-    public static EventWriterMethod lookupMethod(FieldInfo field) {\n+    public static EventWriterMethod lookupMethod(FieldDesc field) {\n@@ -72,1 +72,1 @@\n-        if (field.name().equals(EventInstrumentation.FIELD_EVENT_THREAD)) {\n+        if (field.name().equals(Utils.FIELD_EVENT_THREAD)) {\n@@ -76,1 +76,1 @@\n-            if (field.descriptor().equals(m.typeDescriptor)) {\n+            if (field.type().descriptorString().equals(m.fieldType)) {\n@@ -80,1 +80,1 @@\n-        throw new Error(\"Unknown type \" + field.descriptor());\n+        throw new Error(\"Unknown field type \" + field.type());\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/EventWriterMethod.java","additions":29,"deletions":29,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import jdk.jfr.internal.util.Utils;\n+import jdk.jfr.internal.util.Bytecode;\n@@ -78,1 +78,1 @@\n-                ASMToolkit.logASM(clazz.getName(), bytes);\n+                Bytecode.log(clazz.getName(), bytes);\n@@ -129,1 +129,1 @@\n-            ASMToolkit.logASM(ei.getClassName() + \"(\" + traceId + \")\", bytes);\n+            Bytecode.log(ei.getClassName() + \"(\" + traceId + \")\", bytes);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/JVMUpcalls.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -79,2 +79,2 @@\n-        return PrivateAccess.getInstance().newValueDescriptor(EventInstrumentation.FIELD_START_TIME, Type.LONG, annos, 0, false,\n-                EventInstrumentation.FIELD_START_TIME);\n+        return PrivateAccess.getInstance().newValueDescriptor(Utils.FIELD_START_TIME, Type.LONG, annos, 0, false,\n+                Utils.FIELD_START_TIME);\n@@ -85,2 +85,2 @@\n-        return PrivateAccess.getInstance().newValueDescriptor(EventInstrumentation.FIELD_STACK_TRACE, Type.STACK_TRACE, annos, 0, true,\n-                EventInstrumentation.FIELD_STACK_TRACE);\n+        return PrivateAccess.getInstance().newValueDescriptor(Utils.FIELD_STACK_TRACE, Type.STACK_TRACE, annos, 0, true,\n+                Utils.FIELD_STACK_TRACE);\n@@ -91,2 +91,2 @@\n-        return PrivateAccess.getInstance().newValueDescriptor(EventInstrumentation.FIELD_EVENT_THREAD, Type.THREAD, annos, 0, true,\n-                EventInstrumentation.FIELD_EVENT_THREAD);\n+        return PrivateAccess.getInstance().newValueDescriptor(Utils.FIELD_EVENT_THREAD, Type.THREAD, annos, 0, true,\n+                Utils.FIELD_EVENT_THREAD);\n@@ -98,1 +98,1 @@\n-        return PrivateAccess.getInstance().newValueDescriptor(EventInstrumentation.FIELD_DURATION, Type.LONG, annos, 0, false, EventInstrumentation.FIELD_DURATION);\n+        return PrivateAccess.getInstance().newValueDescriptor(Utils.FIELD_DURATION, Type.LONG, annos, 0, false, Utils.FIELD_DURATION);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/TypeLibrary.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import static jdk.jfr.internal.EventInstrumentation.FIELD_DURATION;\n+import static jdk.jfr.internal.util.Utils.FIELD_DURATION;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/EventParser.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,166 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.util;\n+\n+import jdk.jfr.ValueDescriptor;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDescs;\n+import java.lang.constant.MethodTypeDesc;\n+import java.util.Objects;\n+import jdk.jfr.internal.Logger;\n+import jdk.jfr.internal.LogLevel;\n+import jdk.jfr.internal.LogTag;\n+import jdk.internal.classfile.CodeBuilder;\n+import jdk.internal.classfile.ClassModel;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.components.ClassPrinter;\n+\n+\/**\n+ * Helper class when working with bytecode.\n+ *\/\n+public final class Bytecode {\n+\n+    private static final ClassDesc CD_Thread = classDesc(Thread.class);\n+\n+    public record ClassMethodDesc(ClassDesc type, MethodDesc method) {\n+        public static ClassMethodDesc of(Class<?> clazz, String method, String desrciptor) {\n+            return new ClassMethodDesc(classDesc(clazz), MethodDesc.of(method, desrciptor));\n+        }\n+    }\n+\n+    public record FieldDesc(ClassDesc type, String name) {\n+        public static FieldDesc of(ClassDesc type, String name) {\n+            return new FieldDesc(type, name);\n+        }\n+\n+        public static FieldDesc of(Class<?> type, String name) {\n+            return of(classDesc(type), name);\n+        }\n+    }\n+\n+    public record MethodDesc(String name, MethodTypeDesc descriptor) {\n+        public static MethodDesc of(String methodName, String descriptor) {\n+            return new MethodDesc(methodName, MethodTypeDesc.ofDescriptor(descriptor));\n+        }\n+\n+        public static MethodDesc of(String methodName, Class<?> returnType, Class<?>... parameters) {\n+            ClassDesc[] parameterDesc = new ClassDesc[parameters.length];\n+            for (int i = 0; i < parameterDesc.length; i++) {\n+                parameterDesc[i] = classDesc(parameters[i]);\n+            }\n+            ClassDesc returnDesc = classDesc(returnType);\n+            MethodTypeDesc mtd = MethodTypeDesc.of(returnDesc, parameterDesc);\n+            return new MethodDesc(methodName, mtd);\n+        }\n+    }\n+\n+    public static ClassDesc classDesc(ValueDescriptor v) {\n+        String typeName = v.getTypeName();\n+        return switch (typeName) {\n+            case \"boolean\" -> ConstantDescs.CD_boolean;\n+            case \"byte\" -> ConstantDescs.CD_byte;\n+            case \"short\" -> ConstantDescs.CD_short;\n+            case \"char\" -> ConstantDescs.CD_char;\n+            case \"int\" -> ConstantDescs.CD_int;\n+            case \"long\" -> ConstantDescs.CD_long;\n+            case \"double\" -> ConstantDescs.CD_double;\n+            case \"float\" -> ConstantDescs.CD_float;\n+            case \"java.lang.String\" -> ConstantDescs.CD_String;\n+            case \"java.lang.Class\" -> ConstantDescs.CD_Class;\n+            case \"java.lang.Thread\" -> CD_Thread;\n+            default -> throw new InternalError(\"Unsupported JFR type \" + v.getTypeName());\n+        };\n+    }\n+\n+    public static ClassDesc classDesc(Class<?> clazz) {\n+        return ClassDesc.ofDescriptor(clazz.descriptorString());\n+    }\n+\n+    public static void getfield(CodeBuilder codeBuilder, ClassDesc owner, FieldDesc field) {\n+        codeBuilder.getfield(owner, field.name(), field.type());\n+    }\n+\n+    public static void putfield(CodeBuilder codeBuilder, ClassDesc owner, FieldDesc field) {\n+        codeBuilder.putfield(owner, field.name(), field.type());\n+    }\n+\n+    public static void invokestatic(CodeBuilder codeBuilder, ClassDesc owner, MethodDesc method) {\n+        codeBuilder.invokestatic(owner, method.name(), method.descriptor());\n+    }\n+\n+    public static void invokespecial(CodeBuilder codeBuilder, ClassDesc owner, MethodDesc method) {\n+        codeBuilder.invokespecial(owner, method.name(), method.descriptor());\n+    }\n+\n+    public static void invokevirtual(CodeBuilder codeBuilder, ClassDesc owner, MethodDesc method) {\n+        codeBuilder.invokevirtual(owner, method.name(), method.descriptor());\n+    }\n+\n+    public static void invokevirtual(CodeBuilder codeBuilder, ClassMethodDesc cmd) {\n+        invokevirtual(codeBuilder, cmd.type(), cmd.method());\n+    }\n+\n+    public static void unbox(CodeBuilder codeBuilder, ClassDesc type) {\n+        if (!type.isPrimitive()) {\n+            codeBuilder.checkcast(type);\n+            return;\n+        }\n+        ClassMethodDesc unboxer = switch (type.descriptorString()) {\n+            case \"B\" -> ClassMethodDesc.of(Byte.class, \"byteValue\", \"()B\");\n+            case \"S\" -> ClassMethodDesc.of(Short.class, \"shortValue\", \"()S\");\n+            case \"C\" -> ClassMethodDesc.of(Character.class, \"charValue\", \"()C\");\n+            case \"I\" -> ClassMethodDesc.of(Integer.class, \"intValue\", \"()I\");\n+            case \"J\" -> ClassMethodDesc.of(Long.class, \"longValue\", \"()J\");\n+            case \"F\" -> ClassMethodDesc.of(Float.class, \"floatValue\", \"()F\");\n+            case \"D\" -> ClassMethodDesc.of(Double.class, \"doubleValue\", \"()D\");\n+            case \"Z\" -> ClassMethodDesc.of(Boolean.class, \"booleanValue\", \"()Z\");\n+            default -> throw new InternalError(\"Unsupported JFR type \" + type.descriptorString());\n+        };\n+        codeBuilder.checkcast(unboxer.type());\n+        invokevirtual(codeBuilder, unboxer);\n+    }\n+\n+    public static void throwException(CodeBuilder cb, ClassDesc type, String message) {\n+        Objects.requireNonNull(message);\n+        cb.new_(type);\n+        cb.dup();\n+        cb.ldc(message);\n+        MethodDesc md = MethodDesc.of(\"<init>\", void.class, String.class);\n+        invokespecial(cb, type, md);\n+        cb.athrow();\n+    }\n+\n+    public static void log(String className, byte[] bytes) {\n+        Logger.log(LogTag.JFR_SYSTEM_BYTECODE, LogLevel.INFO, \"Generated bytecode for class \" + className);\n+        if (Logger.shouldLog(LogTag.JFR_SYSTEM_BYTECODE, LogLevel.TRACE)) {\n+            StringBuilder out = new StringBuilder();\n+            out.append(\"Bytecode:\");\n+            out.append(System.lineSeparator());\n+            ClassModel classModel = Classfile.of().parse(bytes);\n+            ClassPrinter.toYaml(classModel, ClassPrinter.Verbosity.TRACE_ALL, out::append);\n+            Logger.log(LogTag.JFR_SYSTEM_BYTECODE, LogLevel.TRACE, out.toString());\n+        }\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/util\/Bytecode.java","additions":166,"deletions":0,"binary":false,"changes":166,"status":"added"},{"patch":"@@ -59,0 +59,5 @@\n+    public static final String FIELD_DURATION = \"duration\";\n+    public static final String FIELD_STACK_TRACE = \"stackTrace\";\n+    public static final String FIELD_START_TIME = \"startTime\";\n+    public static final String FIELD_EVENT_THREAD = \"eventThread\";\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/util\/Utils.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -224,1 +224,1 @@\n-The parameter can be an event type name.\n+The <\\f[I]view\\f[R]> parameter can be an event type name.\n@@ -261,2 +261,3 @@\n-Use the form: <\\f[I]event-name>#=<value\\f[R]> To add a new event\n-setting, prefix the event name with \\[aq]+\\[aq].\n+Use the form:\n+<\\f[I]event-name\\f[R]>#<\\f[I]setting-name\\f[R]>=<\\f[I]value\\f[R]> To add\n+a new event setting, prefix the event name with \\[aq]+\\[aq].\n@@ -319,1 +320,1 @@\n-<\\f[I]filter\\f[R]>] <\\f[I]input-file\\f[R]> []\n+<\\f[I]filter\\f[R]>] <\\f[I]input-file\\f[R]> [<\\f[I]output-file\\f[R]>]\n@@ -338,2 +339,3 @@\n-.PP\n-<\\f[I]input-file\\f[R]> :The input file to read events from.\n+.TP\n+<\\f[I]input-file\\f[R]>\n+The input file to read events from.\n@@ -349,1 +351,1 @@\n-.SS jfr \\f[V]assemble\\f[R] subcommand\n+.SS \\f[V]jfr assemble\\f[R] subcommand\n","filename":"src\/jdk.jfr\/share\/man\/jfr.1","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -88,0 +88,7 @@\n+    public static final BundlerParamInfo<String> APP_IMAGE_SIGN_IDENTITY =\n+            new StandardBundlerParam<>(\n+            Arguments.CLIOptions.MAC_APP_IMAGE_SIGN_IDENTITY.getId(),\n+            String.class,\n+            params -> \"\",\n+            null);\n+\n@@ -130,6 +137,10 @@\n-            String signingIdentity =\n-                    DEVELOPER_ID_APP_SIGNING_KEY.fetchFrom(params);\n-            if (signingIdentity == null) {\n-                throw new ConfigException(\n-                        I18N.getString(\"error.explicit-sign-no-cert\"),\n-                        I18N.getString(\"error.explicit-sign-no-cert.advice\"));\n+            \/\/ Validate DEVELOPER_ID_APP_SIGNING_KEY only if user provided\n+            \/\/ SIGNING_KEY_USER.\n+            if (!SIGNING_KEY_USER.getIsDefaultValue(params)) { \/\/ --mac-signing-key-user-name\n+                String signingIdentity =\n+                        DEVELOPER_ID_APP_SIGNING_KEY.fetchFrom(params);\n+                if (signingIdentity == null) {\n+                    throw new ConfigException(\n+                            I18N.getString(\"error.explicit-sign-no-cert\"),\n+                            I18N.getString(\"error.explicit-sign-no-cert.advice\"));\n+                }\n@@ -138,0 +149,3 @@\n+            \/\/ No need to validate --mac-app-image-sign-identity, since it is\n+            \/\/ pass through option.\n+\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacAppBundler.java","additions":20,"deletions":6,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.io.ByteArrayOutputStream;\n@@ -30,0 +31,1 @@\n+import java.io.PrintStream;\n@@ -56,0 +58,1 @@\n+import static jdk.jpackage.internal.MacAppBundler.APP_IMAGE_SIGN_IDENTITY;\n@@ -57,0 +60,2 @@\n+import static jdk.jpackage.internal.MacBaseInstallerBundler.SIGNING_KEY_USER;\n+import static jdk.jpackage.internal.MacBaseInstallerBundler.INSTALLER_SIGN_IDENTITY;\n@@ -398,2 +403,12 @@\n-            String signingIdentity =\n-                    DEVELOPER_ID_APP_SIGNING_KEY.fetchFrom(params);\n+            String signingIdentity = null;\n+            \/\/ Try --mac-app-image-sign-identity first if set\n+            if (!APP_IMAGE_SIGN_IDENTITY.getIsDefaultValue(params)) {\n+                signingIdentity = APP_IMAGE_SIGN_IDENTITY.fetchFrom(params);\n+            } else {\n+                \/\/ Check if INSTALLER_SIGN_IDENTITY is set and if it is set\n+                \/\/ then do not sign app image, otherwise use --mac-signing-key-user-name\n+                if (INSTALLER_SIGN_IDENTITY.getIsDefaultValue(params)) {\n+                    \/\/ --mac-sign and\/or --mac-signing-key-user-name case\n+                    signingIdentity = DEVELOPER_ID_APP_SIGNING_KEY.fetchFrom(params);\n+                }\n+            }\n@@ -404,0 +419,3 @@\n+            } else {\n+                \/\/ Case when user requested to sign installer only\n+                signAppBundle(params, root, \"-\", null, null);\n@@ -718,0 +736,19 @@\n+    private static void runCodesign(ProcessBuilder pb, boolean quiet)\n+                                                            throws IOException {\n+        try (ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+             PrintStream ps = new PrintStream(baos)) {\n+            try {\n+            IOUtils.exec(pb, false, ps, false,\n+                         Executor.INFINITE_TIMEOUT, quiet);\n+            } catch (IOException ioe) {\n+                \/\/ Log output of \"codesign\" in case of\n+                \/\/ error. It should help user to diagnose\n+                \/\/ issue when using --mac-app-image-sign-identity\n+                Log.info(MessageFormat.format(I18N.getString(\n+                         \"error.tool.failed.with.output\"), \"codesign\"));\n+                Log.info(baos.toString().strip());\n+                throw ioe;\n+            }\n+        }\n+    }\n+\n@@ -784,2 +821,1 @@\n-                            IOUtils.exec(pb, false, null, false,\n-                                    Executor.INFINITE_TIMEOUT, true);\n+                            runCodesign(pb, true);\n@@ -813,2 +849,1 @@\n-\n-                IOUtils.exec(pb);\n+                runCodesign(pb, false);\n@@ -845,2 +880,1 @@\n-\n-        IOUtils.exec(pb);\n+        runCodesign(pb, false);\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacAppImageBuilder.java","additions":42,"deletions":8,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -82,0 +82,7 @@\n+    public static final BundlerParamInfo<String> INSTALLER_SIGN_IDENTITY =\n+            new StandardBundlerParam<>(\n+            Arguments.CLIOptions.MAC_INSTALLER_SIGN_IDENTITY.getId(),\n+            String.class,\n+            params -> \"\",\n+            null);\n+\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacBaseInstallerBundler.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.io.ByteArrayOutputStream;\n@@ -32,0 +33,1 @@\n+import java.io.PrintStream;\n@@ -57,0 +59,2 @@\n+import static jdk.jpackage.internal.MacBaseInstallerBundler.INSTALLER_SIGN_IDENTITY;\n+import static jdk.jpackage.internal.MacAppBundler.APP_IMAGE_SIGN_IDENTITY;\n@@ -608,2 +612,13 @@\n-                String signingIdentity =\n-                        DEVELOPER_ID_INSTALLER_SIGNING_KEY.fetchFrom(params);\n+                String signingIdentity = null;\n+                \/\/ --mac-installer-sign-identity\n+                if (!INSTALLER_SIGN_IDENTITY.getIsDefaultValue(params)) {\n+                    signingIdentity = INSTALLER_SIGN_IDENTITY.fetchFrom(params);\n+                } else {\n+                    \/\/ Use --mac-signing-key-user-name if user did not request\n+                    \/\/ to sign just app image using --mac-app-image-sign-identity\n+                    if (APP_IMAGE_SIGN_IDENTITY.getIsDefaultValue(params)) {\n+                        \/\/ --mac-signing-key-user-name\n+                        signingIdentity = DEVELOPER_ID_INSTALLER_SIGNING_KEY.fetchFrom(params);\n+                    }\n+                }\n+\n@@ -641,1 +656,15 @@\n-            IOUtils.exec(pb, false, null, true, Executor.INFINITE_TIMEOUT);\n+\n+            try (ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+                 PrintStream ps = new PrintStream(baos)) {\n+                try {\n+                    IOUtils.exec(pb, false, ps, true, Executor.INFINITE_TIMEOUT);\n+                } catch (IOException ioe) {\n+                    \/\/ Log output of \"productbuild\" in case of\n+                    \/\/ error. It should help user to diagnose\n+                    \/\/ issue when using --mac-installer-sign-identity\n+                    Log.info(MessageFormat.format(I18N.getString(\n+                             \"error.tool.failed.with.output\"), \"productbuild\"));\n+                    Log.info(baos.toString().strip());\n+                    throw ioe;\n+                }\n+            }\n@@ -705,7 +734,9 @@\n-                String signingIdentity =\n-                        DEVELOPER_ID_INSTALLER_SIGNING_KEY.fetchFrom(params);\n-                if (signingIdentity == null) {\n-                    throw new ConfigException(\n-                            I18N.getString(\"error.explicit-sign-no-cert\"),\n-                            I18N.getString(\n-                            \"error.explicit-sign-no-cert.advice\"));\n+                if (!SIGNING_KEY_USER.getIsDefaultValue(params)) {\n+                    String signingIdentity =\n+                            DEVELOPER_ID_INSTALLER_SIGNING_KEY.fetchFrom(params);\n+                    if (signingIdentity == null) {\n+                        throw new ConfigException(\n+                                I18N.getString(\"error.explicit-sign-no-cert\"),\n+                                I18N.getString(\n+                                \"error.explicit-sign-no-cert.advice\"));\n+                    }\n@@ -713,0 +744,3 @@\n+\n+                \/\/ No need to validate --mac-installer-sign-identity, since it is\n+                \/\/ pass through option.\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacPkgBundler.java","additions":44,"deletions":10,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,1 @@\n+error.tool.failed.with.output=Error: \"{0}\" failed with following output:\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/resources\/MacResources.properties","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,1 @@\n+error.tool.failed.with.output=Error: \"{0}\" failed with following output:\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/resources\/MacResources_de.properties","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,1 @@\n+error.tool.failed.with.output=Error: \"{0}\" failed with following output:\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/resources\/MacResources_ja.properties","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,1 @@\n+error.tool.failed.with.output=Error: \"{0}\" failed with following output:\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/resources\/MacResources_zh_CN.properties","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -341,0 +341,6 @@\n+        MAC_APP_IMAGE_SIGN_IDENTITY (\"mac-app-image-sign-identity\",\n+                    OptionCategories.PLATFORM_MAC),\n+\n+        MAC_INSTALLER_SIGN_IDENTITY (\"mac-installer-sign-identity\",\n+                    OptionCategories.PLATFORM_MAC),\n+\n@@ -634,0 +640,18 @@\n+        if (allOptions.contains(CLIOptions.MAC_SIGNING_KEY_NAME) &&\n+            allOptions.contains(CLIOptions.MAC_APP_IMAGE_SIGN_IDENTITY)) {\n+                throw new PackagerException(\"ERR_MutuallyExclusiveOptions\",\n+                        CLIOptions.MAC_SIGNING_KEY_NAME.getIdWithPrefix(),\n+                        CLIOptions.MAC_APP_IMAGE_SIGN_IDENTITY.getIdWithPrefix());\n+        }\n+        if (allOptions.contains(CLIOptions.MAC_SIGNING_KEY_NAME) &&\n+            allOptions.contains(CLIOptions.MAC_INSTALLER_SIGN_IDENTITY)) {\n+                throw new PackagerException(\"ERR_MutuallyExclusiveOptions\",\n+                        CLIOptions.MAC_SIGNING_KEY_NAME.getIdWithPrefix(),\n+                        CLIOptions.MAC_INSTALLER_SIGN_IDENTITY.getIdWithPrefix());\n+        }\n+        if (isMac && (imageOnly || \"dmg\".equals(type)) &&\n+            allOptions.contains(CLIOptions.MAC_INSTALLER_SIGN_IDENTITY)) {\n+                throw new PackagerException(\"ERR_InvalidTypeOption\",\n+                        CLIOptions.MAC_INSTALLER_SIGN_IDENTITY.getIdWithPrefix(),\n+                        type);\n+        }\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/Arguments.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,5 +49,0 @@\n-    \/**\n-     * Indicates if value was set using default value function\n-     *\/\n-    boolean isDefaultValue;\n-\n@@ -73,2 +68,18 @@\n-    boolean getIsDefaultValue() {\n-        return isDefaultValue;\n+    \/**\n+     * Returns true if value was not provided on command line for this\n+     * parameter.\n+     *\n+     * @param params - params from which value will be fetch\n+     * @return true if value was not provided on command line, false otherwise\n+     *\/\n+    boolean getIsDefaultValue(Map<String, ? super Object> params) {\n+        Object o = params.get(getID());\n+        if (o != null) {\n+            return false; \/\/ We have user provided value\n+        }\n+\n+        if (params.containsKey(getID())) {\n+            return false; \/\/ explicit nulls are allowed for provided value\n+        }\n+\n+        return true;\n@@ -117,1 +128,0 @@\n-                isDefaultValue = true;\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/BundlerParamInfo.java","additions":19,"deletions":9,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+\n@@ -65,1 +66,0 @@\n-\n@@ -133,0 +133,4 @@\n+            put(CLIOptions.MAC_APP_IMAGE_SIGN_IDENTITY.getId(),\n+                    EnumSet.of(USE.ALL, USE.SIGN));\n+            put(CLIOptions.MAC_INSTALLER_SIGN_IDENTITY.getId(),\n+                    EnumSet.of(USE.INSTALL, USE.SIGN));\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/ValidOptions.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -268,1 +268,13 @@\n-\\          Team or user name portion of Apple signing identities.\\n\\\n+\\          Team or user name portion of Apple signing identities. For direct\\n\\\n+\\          control of the signing identity used to sign application images or\\n\\\n+\\          installers use --mac-app-image-sign-identity and\/or\\n\\\n+\\          --mac-installer-sign-identity. This option cannot be combined with\\n\\\n+\\          --mac-app-image-sign-identity or --mac-installer-sign-identity.\\n\\\n+\\  --mac-app-image-sign-identity <identity>\\n\\\n+\\          Identity used to sign application image. This value will be passed\\n\\\n+\\          directly to --sign option of \"codesign\" tool. This option cannot\\n\\\n+\\          be combined with --mac-signing-key-user-name.\\n\\\n+\\  --mac-installer-sign-identity <identity>\\n\\\n+\\          Identity used to sign \"pkg\" installer. This value will be passed\\n\\\n+\\          directly to --sign option of \"productbuild\" tool. This option\\n\\\n+\\          cannot be combined with --mac-signing-key-user-name.\\n\\\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/resources\/HelpResources.properties","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -95,1 +95,1 @@\n-ERR_MutuallyExclusiveOptions=\"Error: Mutually exclusive options [{0}] and [{1}]\n+ERR_MutuallyExclusiveOptions=Error: Mutually exclusive options [{0}] and [{1}]\n@@ -99,0 +99,1 @@\n+ERR_MissingRequiredArgument=Error: {0} argument requires at least one of [{1}] argument(s)\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/resources\/MainResources.properties","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -98,0 +98,1 @@\n+ERR_MissingRequiredArgument=Error: {0} argument requires at least one of [{1}] argument(s)\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/resources\/MainResources_de.properties","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -98,0 +98,1 @@\n+ERR_MissingRequiredArgument=Error: {0} argument requires at least one of [{1}] argument(s)\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/resources\/MainResources_ja.properties","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -98,0 +98,1 @@\n+ERR_MissingRequiredArgument=Error: {0} argument requires at least one of [{1}] argument(s)\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/resources\/MainResources_zh_CN.properties","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -193,1 +193,1 @@\n-        UNDERSCORE(TokenKind.UNDERSCORE, XERRO),  \/\/  _\n+        UNDERSCORE(TokenKind.UNDERSCORE, XDECL1),  \/\/  _\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/CompletenessAnalyzer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import java.io.IOException;\n+import java.io.InvalidObjectException;\n+import java.io.ObjectInputStream;\n@@ -50,0 +53,1 @@\n+    @java.io.Serial\n@@ -138,0 +142,27 @@\n+\n+    \/**\n+     * Restores the state of this object from the stream.\n+     *\n+     * @param  stream the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n+     *\/\n+    @java.io.Serial\n+    private void readObject(ObjectInputStream stream)\n+            throws IOException, ClassNotFoundException {\n+        stream.defaultReadObject();\n+        if ((name == null) || (nameString == null)) {\n+            throw new InvalidObjectException(\n+                    \"null name\/nameString is illegal\");\n+        }\n+        try {\n+            if (!name.equals(getLdapName(nameString))) {\n+                throw new InvalidObjectException(\"Inconsistent names\");\n+            }\n+        } catch  (InvalidNameException e) {\n+            InvalidObjectException nse = new InvalidObjectException(\n+                    \"Invalid Name\");\n+            nse.initCause(e);\n+            throw nse;\n+        }\n+    }\n","filename":"src\/jdk.security.auth\/share\/classes\/com\/sun\/security\/auth\/LdapPrincipal.java","additions":32,"deletions":1,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import java.io.IOException;\n+import java.io.InvalidObjectException;\n+import java.io.ObjectInputStream;\n@@ -50,0 +53,1 @@\n+    @java.io.Serial\n@@ -123,3 +127,1 @@\n-            if (name.equals(that.getName()))\n-                return true;\n-            return false;\n+        return name.equals(that.getName());\n@@ -136,0 +138,20 @@\n+\n+    \/**\n+     * Restores the state of this object from the stream.\n+     *\n+     * @param  stream the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n+     *\/\n+    @java.io.Serial\n+    private void readObject(ObjectInputStream stream)\n+            throws IOException, ClassNotFoundException {\n+        stream.defaultReadObject();\n+        if (name == null) {\n+            java.text.MessageFormat form = new java.text.MessageFormat\n+                    (sun.security.util.ResourcesMgr.getAuthResourceString\n+                            (\"invalid.null.input.value\"));\n+            Object[] source = {\"name\"};\n+            throw new InvalidObjectException(form.format(source));\n+        }\n+    }\n","filename":"src\/jdk.security.auth\/share\/classes\/com\/sun\/security\/auth\/NTDomainPrincipal.java","additions":26,"deletions":4,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import java.io.IOException;\n+import java.io.InvalidObjectException;\n+import java.io.ObjectInputStream;\n@@ -52,0 +55,1 @@\n+    @java.io.Serial\n@@ -83,1 +87,1 @@\n-        sid = new String(stringSid);\n+        sid = stringSid;\n@@ -131,4 +135,1 @@\n-        if (sid.equals(that.sid)) {\n-            return true;\n-        }\n-        return false;\n+        return sid.equals(that.sid);\n@@ -145,0 +146,25 @@\n+\n+    \/**\n+     * Restores the state of this object from the stream.\n+     *\n+     * @param  stream the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n+     *\/\n+    @java.io.Serial\n+    private void readObject(ObjectInputStream stream)\n+            throws IOException, ClassNotFoundException {\n+        stream.defaultReadObject();\n+        if (sid == null) {\n+            java.text.MessageFormat form = new java.text.MessageFormat\n+                    (sun.security.util.ResourcesMgr.getAuthResourceString\n+                            (\"invalid.null.input.value\"));\n+            Object[] source = {\"stringSid\"};\n+            throw new InvalidObjectException(form.format(source));\n+        }\n+        if (sid.length() == 0) {\n+            throw new InvalidObjectException\n+                    (sun.security.util.ResourcesMgr.getAuthResourceString\n+                            (\"Invalid.NTSid.value\"));\n+        }\n+    }\n","filename":"src\/jdk.security.auth\/share\/classes\/com\/sun\/security\/auth\/NTSid.java","additions":32,"deletions":6,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import java.io.IOException;\n+import java.io.InvalidObjectException;\n+import java.io.ObjectInputStream;\n@@ -46,0 +49,1 @@\n+    @java.io.Serial\n@@ -117,3 +121,1 @@\n-            if (name.equals(that.getName()))\n-                return true;\n-            return false;\n+        return name.equals(that.getName());\n@@ -130,0 +132,21 @@\n+\n+\n+    \/**\n+     * Restores the state of this object from the stream.\n+     *\n+     * @param  stream the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n+     *\/\n+    @java.io.Serial\n+    private void readObject(ObjectInputStream stream)\n+            throws IOException, ClassNotFoundException {\n+        stream.defaultReadObject();\n+        if (name == null) {\n+            java.text.MessageFormat form = new java.text.MessageFormat\n+                    (sun.security.util.ResourcesMgr.getAuthResourceString\n+                            (\"invalid.null.input.value\"));\n+            Object[] source = {\"name\"};\n+            throw new InvalidObjectException(form.format(source));\n+        }\n+    }\n","filename":"src\/jdk.security.auth\/share\/classes\/com\/sun\/security\/auth\/NTUserPrincipal.java","additions":27,"deletions":4,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import java.io.IOException;\n+import java.io.InvalidObjectException;\n+import java.io.ObjectInputStream;\n@@ -49,0 +52,1 @@\n+    @java.io.Serial\n@@ -187,4 +191,2 @@\n-        if (this.getName().equals(that.getName()) &&\n-            this.isPrimaryGroup() == that.isPrimaryGroup())\n-            return true;\n-        return false;\n+        return this.getName().equals(that.getName()) &&\n+                this.isPrimaryGroup() == that.isPrimaryGroup();\n@@ -201,0 +203,20 @@\n+\n+    \/**\n+     * Restores the state of this object from the stream.\n+     *\n+     * @param  stream the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n+     *\/\n+    @java.io.Serial\n+    private void readObject(ObjectInputStream stream)\n+            throws IOException, ClassNotFoundException {\n+        stream.defaultReadObject();\n+        if (name == null) {\n+            java.text.MessageFormat form = new java.text.MessageFormat\n+                    (sun.security.util.ResourcesMgr.getAuthResourceString\n+                            (\"invalid.null.input.value\"));\n+            Object[] source = {\"name\"};\n+            throw new InvalidObjectException(form.format(source));\n+        }\n+    }\n","filename":"src\/jdk.security.auth\/share\/classes\/com\/sun\/security\/auth\/UnixNumericGroupPrincipal.java","additions":27,"deletions":5,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import java.io.IOException;\n+import java.io.InvalidObjectException;\n+import java.io.ObjectInputStream;\n@@ -47,0 +50,1 @@\n+    @java.io.Serial\n@@ -149,3 +153,1 @@\n-        if (this.getName().equals(that.getName()))\n-            return true;\n-        return false;\n+        return this.getName().equals(that.getName());\n@@ -162,0 +164,20 @@\n+\n+    \/**\n+     * Restores the state of this object from the stream.\n+     *\n+     * @param  stream the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n+     *\/\n+    @java.io.Serial\n+    private void readObject(ObjectInputStream stream)\n+            throws IOException, ClassNotFoundException {\n+        stream.defaultReadObject();\n+        if (name == null) {\n+            java.text.MessageFormat form = new java.text.MessageFormat\n+                    (sun.security.util.ResourcesMgr.getAuthResourceString\n+                            (\"invalid.null.input.value\"));\n+            Object[] source = {\"name\"};\n+            throw new InvalidObjectException(form.format(source));\n+        }\n+    }\n","filename":"src\/jdk.security.auth\/share\/classes\/com\/sun\/security\/auth\/UnixNumericUserPrincipal.java","additions":26,"deletions":4,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import java.io.IOException;\n+import java.io.InvalidObjectException;\n+import java.io.ObjectInputStream;\n@@ -46,0 +49,1 @@\n+    @java.io.Serial\n@@ -118,3 +122,1 @@\n-        if (this.getName().equals(that.getName()))\n-            return true;\n-        return false;\n+        return this.getName().equals(that.getName());\n@@ -131,0 +133,20 @@\n+\n+    \/**\n+     * Restores the state of this object from the stream.\n+     *\n+     * @param  stream the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n+     *\/\n+    @java.io.Serial\n+    private void readObject(ObjectInputStream stream)\n+            throws IOException, ClassNotFoundException {\n+        stream.defaultReadObject();\n+        if (name == null) {\n+            java.text.MessageFormat form = new java.text.MessageFormat\n+                    (sun.security.util.ResourcesMgr.getAuthResourceString\n+                            (\"invalid.null.input.value\"));\n+            Object[] source = {\"name\"};\n+            throw new InvalidObjectException(form.format(source));\n+        }\n+    }\n","filename":"src\/jdk.security.auth\/share\/classes\/com\/sun\/security\/auth\/UnixPrincipal.java","additions":26,"deletions":4,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import java.io.IOException;\n+import java.io.InvalidObjectException;\n+import java.io.ObjectInputStream;\n@@ -47,0 +50,1 @@\n+    @java.io.Serial\n@@ -112,0 +116,16 @@\n+\n+    \/**\n+     * Restores the state of this object from the stream.\n+     *\n+     * @param  stream the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n+     *\/\n+    @java.io.Serial\n+    private void readObject(ObjectInputStream stream)\n+            throws IOException, ClassNotFoundException {\n+        stream.defaultReadObject();\n+        if (name == null) {\n+            throw new InvalidObjectException(\"null name is illegal\");\n+        }\n+    }\n","filename":"src\/jdk.security.auth\/share\/classes\/com\/sun\/security\/auth\/UserPrincipal.java","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,4 +52,0 @@\n-#ifndef SYSTEM_BINUTILS\n-#include <config.h> \/* required by bfd.h *\/\n-#endif\n-\n@@ -60,1 +56,6 @@\n-#include <libiberty.h>\n+#ifndef SYSTEM_BINUTILS\n+\/* defines for bfd.h *\/\n+#define PACKAGE \"hsdis\"\n+#define PACKAGE_VERSION 1\n+#endif\n+\n@@ -559,0 +560,17 @@\n+static fprintf_ftype target_fprintf_func = NULL;\n+\n+#ifdef BINUTILS_NEW_API\n+static int wrapper_fprintf_styled_ftype(void *v, enum disassembler_style style_unused, const char* fmt, ...) {\n+  char buffer[1024] = {};\n+  va_list args;\n+  int r;\n+  va_start(args, fmt);\n+  r = vsnprintf(buffer, sizeof(buffer), fmt, args);\n+  va_end(args);\n+  if (target_fprintf_func != NULL) {\n+    return target_fprintf_func(v, \"%s\", buffer);\n+  }\n+  return r;\n+}\n+#endif\n+\n@@ -564,0 +582,4 @@\n+  target_fprintf_func = fprintf_func;\n+#ifdef BINUTILS_NEW_API\n+  init_disassemble_info(dinfo, stream, fprintf_func, wrapper_fprintf_styled_ftype);\n+#else\n@@ -565,0 +587,1 @@\n+#endif\n","filename":"src\/utils\/hsdis\/binutils\/hsdis-binutils.c","additions":29,"deletions":6,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -332,1 +332,1 @@\n-  Arena ar(mtTest, 4097);\n+  Arena ar(mtTest, Arena::Tag::tag_other, 4097);\n@@ -345,1 +345,1 @@\n-  Arena ar(mtTest, 100); \/\/ first chunk is small\n+  Arena ar(mtTest, Arena::Tag::tag_other, 100); \/\/ first chunk is small\n@@ -375,8 +375,8 @@\n-    Arena ar0(mtTest, random_arena_chunk_size());\n-    Arena ar1(mtTest, random_arena_chunk_size());\n-    Arena ar2(mtTest, random_arena_chunk_size());\n-    Arena ar3(mtTest, random_arena_chunk_size());\n-    Arena ar4(mtTest, random_arena_chunk_size());\n-    Arena ar5(mtTest, random_arena_chunk_size());\n-    Arena ar6(mtTest, random_arena_chunk_size());\n-    Arena ar7(mtTest, random_arena_chunk_size());\n+    Arena ar0(mtTest, Arena::Tag::tag_other, random_arena_chunk_size());\n+    Arena ar1(mtTest, Arena::Tag::tag_other, random_arena_chunk_size());\n+    Arena ar2(mtTest, Arena::Tag::tag_other, random_arena_chunk_size());\n+    Arena ar3(mtTest, Arena::Tag::tag_other, random_arena_chunk_size());\n+    Arena ar4(mtTest, Arena::Tag::tag_other, random_arena_chunk_size());\n+    Arena ar5(mtTest, Arena::Tag::tag_other, random_arena_chunk_size());\n+    Arena ar6(mtTest, Arena::Tag::tag_other, random_arena_chunk_size());\n+    Arena ar7(mtTest, Arena::Tag::tag_other, random_arena_chunk_size());\n","filename":"test\/hotspot\/gtest\/memory\/test_arena.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-TEST(AtomicAddTest, int32) {\n+TEST_VM(AtomicAddTest, int32) {\n@@ -62,3 +62,4 @@\n-\/\/ 64bit Atomic::add is only supported on 64bit platforms.\n-#ifdef _LP64\n-TEST(AtomicAddTest, int64) {\n+TEST_VM(AtomicAddTest, int64) {\n+  \/\/ Check if 64-bit atomics are available on the machine.\n+  if (!VM_Version::supports_cx8()) return;\n+\n@@ -69,1 +70,0 @@\n-#endif \/\/ _LP64\n@@ -71,1 +71,1 @@\n-TEST(AtomicAddTest, ptr) {\n+TEST_VM(AtomicAddTest, ptr) {\n@@ -106,1 +106,1 @@\n-TEST(AtomicXchgTest, int32) {\n+TEST_VM(AtomicXchgTest, int32) {\n@@ -111,3 +111,4 @@\n-\/\/ 64bit Atomic::xchg is only supported on 64bit platforms.\n-#ifdef _LP64\n-TEST(AtomicXchgTest, int64) {\n+TEST_VM(AtomicXchgTest, int64) {\n+  \/\/ Check if 64-bit atomics are available on the machine.\n+  if (!VM_Version::supports_cx8()) return;\n+\n@@ -117,1 +118,0 @@\n-#endif \/\/ _LP64\n@@ -139,1 +139,1 @@\n-TEST(AtomicCmpxchgTest, int32) {\n+TEST_VM(AtomicCmpxchgTest, int32) {\n@@ -144,1 +144,4 @@\n-TEST(AtomicCmpxchgTest, int64) {\n+TEST_VM(AtomicCmpxchgTest, int64) {\n+  \/\/ Check if 64-bit atomics are available on the machine.\n+  if (!VM_Version::supports_cx8()) return;\n+\n@@ -189,1 +192,1 @@\n-TEST(AtomicCmpxchg1Byte, stress) {\n+TEST_VM(AtomicCmpxchg1Byte, stress) {\n@@ -227,1 +230,1 @@\n-TEST(AtomicEnumTest, unscoped_enum) {\n+TEST_VM(AtomicEnumTest, unscoped_enum) {\n@@ -238,1 +241,1 @@\n-TEST(AtomicEnumTest, scoped_enum) {\n+TEST_VM(AtomicEnumTest, scoped_enum) {\n@@ -332,1 +335,1 @@\n-TEST(AtomicBitopsTest, int8) {\n+TEST_VM(AtomicBitopsTest, int8) {\n@@ -336,1 +339,1 @@\n-TEST(AtomicBitopsTest, uint8) {\n+TEST_VM(AtomicBitopsTest, uint8) {\n@@ -340,1 +343,1 @@\n-TEST(AtomicBitopsTest, int32) {\n+TEST_VM(AtomicBitopsTest, int32) {\n@@ -344,1 +347,1 @@\n-TEST(AtomicBitopsTest, uint32) {\n+TEST_VM(AtomicBitopsTest, uint32) {\n@@ -348,2 +351,4 @@\n-#ifdef _LP64\n-TEST(AtomicBitopsTest, int64) {\n+TEST_VM(AtomicBitopsTest, int64) {\n+  \/\/ Check if 64-bit atomics are available on the machine.\n+  if (!VM_Version::supports_cx8()) return;\n+\n@@ -353,1 +358,4 @@\n-TEST(AtomicBitopsTest, uint64) {\n+TEST_VM(AtomicBitopsTest, uint64) {\n+  \/\/ Check if 64-bit atomics are available on the machine.\n+  if (!VM_Version::supports_cx8()) return;\n+\n@@ -356,1 +364,0 @@\n-#endif \/\/ _LP64\n","filename":"test\/hotspot\/gtest\/runtime\/test_atomic.cpp","additions":31,"deletions":24,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -380,1 +380,1 @@\n-#define PRINT_MAPPINGS(s) { tty->print_cr(\"%s\", s); os::print_memory_mappings((char*)p, total_range_len, tty); }\n+#define PRINT_MAPPINGS(s) { tty->print_cr(\"%s\", s); os::print_memory_mappings((char*)p, total_range_len, tty); tty->cr(); }\n","filename":"test\/hotspot\/gtest\/runtime\/test_os.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,0 +49,2 @@\n+\n+gc\/cslocker\/TestCSLocker.java 8310480 linux-x64\n","filename":"test\/hotspot\/jtreg\/ProblemList-Xcomp.txt","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -76,0 +76,2 @@\n+compiler\/codecache\/CheckLargePages.java 8317831 linux-x64\n+\n@@ -94,1 +96,1 @@\n-runtime\/jni\/terminatedThread\/TestTerminatedThread.java 8219652 aix-ppc64\n+runtime\/jni\/terminatedThread\/TestTerminatedThread.java 8317789 aix-ppc64\n@@ -113,0 +115,2 @@\n+runtime\/CompressedOops\/CompressedClassPointers.java 8317610 linux-x64,windows-x64\n+\n@@ -176,0 +180,2 @@\n+\n+vmTestbase\/nsk\/monitoring\/ThreadMXBean\/findMonitorDeadlockedThreads\/find006\/TestDescription.java 8310144 macosx-aarch64\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -35,1 +35,2 @@\n-keys=stress headful intermittent randomness cgroups\n+# flag-sensitive:       test is sensitive to certain flags and might fail when flags are passed using -vmoptions and -javaoptions\n+keys=stress headful intermittent randomness cgroups flag-sensitive\n","filename":"test\/hotspot\/jtreg\/TEST.ROOT","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8318049\n+ * @summary Test that xor nodes are properly notified when constraint casts change.\n+ * @run main\/othervm -Xcomp -XX:-TieredCompilation -XX:CompileOnly=compiler.c2.TestNotifyCastToXor::test\n+                     -XX:+IgnoreUnrecognizedVMOptions -XX:VerifyIterativeGVN=10 compiler.c2.TestNotifyCastToXor\n+ *\/\n+\n+package compiler.c2;\n+\n+public class TestNotifyCastToXor {\n+    public static long longField = 0L;\n+\n+    public static void test() {\n+        int ind = -15;\n+\n+        ind %= ind;\n+        for (int i = 0; i < 40; ++i) {\n+            int j = 1;\n+\n+            do {\n+                ind ^= (int)longField;\n+\n+                \/\/ Dead loop\n+                for (int k = 1; k < 1; k++) {\n+                }\n+            } while (j++ < 10);\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        test();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestNotifyCastToXor.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2022, 2023, Red Hat, Inc. All rights reserved.\n@@ -32,1 +32,1 @@\n- * @requires os.arch==\"amd64\" | os.arch==\"x86_64\"\n+ * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"riscv64\"\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/CmpUWithZero.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,155 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n+\/*\n+ * @test\n+ * @summary Test that patterns involving duplicated conversion nodes behind phi are properly optimized.\n+ * @bug 8316918\n+ * @library \/test\/lib \/\n+ * @requires vm.compiler2.enabled\n+ * @run driver compiler.c2.irTests.TestPhiDuplicatedConversion\n+ *\/\n+public class TestPhiDuplicatedConversion {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CONV, \"1\"})\n+    public static float int2Float(boolean c, int a, int b) {\n+        return c ? a : b;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CONV, \"1\"})\n+    public static double int2Double(boolean c, int a, int b) {\n+        return c ? a : b;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CONV, \"1\"})\n+    public static long int2Long(boolean c, int a, int b) {\n+        return c ? a : b;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CONV, \"1\"})\n+    public static int float2Int(boolean c, float a, float b) {\n+        return c ? (int)a : (int)b;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CONV, \"1\"})\n+    public static double float2Double(boolean c, float a, float b) {\n+        return c ? (double)a : (double)b;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CONV, \"1\"})\n+    public static long float2Long(boolean c, float a, float b) {\n+        return c ? (long)a : (long)b;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CONV, \"1\"})\n+    public static int double2Int(boolean c, double a, double b) {\n+        return c ? (int)a : (int)b;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CONV, \"1\"})\n+    public static float double2Float(boolean c, double a, double b) {\n+        return c ? (float)a : (float)b;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CONV, \"1\"})\n+    public static long double2Long(boolean c, double a, double b) {\n+        return c ? (long)a : (long)b;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CONV, \"1\"})\n+    public static float long2Float(boolean c, long a, long b) {\n+        return c ? a : b;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CONV, \"1\"})\n+    public static double long2Double(boolean c, long a, long b) {\n+        return c ? a : b;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CONV, \"1\"})\n+    public static int long2Int(boolean c, long a, long b) {\n+        return c ? (int)a : (int)b;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CONV, \"1\"}, applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    public static short float2HalfFloat(boolean c, float a, float b) {\n+        return c ? Float.floatToFloat16(a) : Float.floatToFloat16(b);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CONV, \"1\"}, applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    public static float halfFloat2Float(boolean c, short a, short b) {\n+        return c ? Float.float16ToFloat(a) : Float.float16ToFloat(b);\n+    }\n+\n+    @Run(test = {\"int2Float\", \"int2Double\", \"int2Long\",\n+                 \"float2Int\", \"float2Double\", \"float2Long\",\n+                 \"double2Int\", \"double2Float\", \"double2Long\",\n+                 \"long2Float\", \"long2Double\", \"long2Int\",\n+                 \"float2HalfFloat\", \"halfFloat2Float\"})\n+    public void runTests() {\n+        assertResults(true, 10, 20, 3.14f, -1.6f, 3.1415, -1.618, 30L, 400L, Float.floatToFloat16(10.5f), Float.floatToFloat16(20.5f));\n+        assertResults(false, 10, 20, 3.14f, -1.6f, 3.1415, -1.618, 30L, 400L, Float.floatToFloat16(10.5f), Float.floatToFloat16(20.5f));\n+    }\n+\n+    @DontCompile\n+    public void assertResults(boolean c, int intA, int intB, float floatA, float floatB, double doubleA, double doubleB, long longA, long longB, short halfFloatA, short halfFloatB) {\n+        Asserts.assertEQ(c ? (float)intA : (float)intB, int2Float(c, intA, intB));\n+        Asserts.assertEQ(c ? (double)intA : (double)intB, int2Double(c, intA, intB));\n+        Asserts.assertEQ(c ? (long)intA : (long)intB, int2Long(c, intA, intB));\n+        Asserts.assertEQ(c ? (int)floatA : (int)floatB, float2Int(c, floatA, floatB));\n+        Asserts.assertEQ(c ? (double)floatA : (double)floatB, float2Double(c, floatA, floatB));\n+        Asserts.assertEQ(c ? (long)floatA : (long)floatB, float2Long(c, floatA, floatB));\n+        Asserts.assertEQ(c ? (int)doubleA : (int)doubleB, double2Int(c, doubleA, doubleB));\n+        Asserts.assertEQ(c ? (float)doubleA : (float)doubleB, double2Float(c, doubleA, doubleB));\n+        Asserts.assertEQ(c ? (long)doubleA : (long)doubleB, double2Long(c, doubleA, doubleB));\n+        Asserts.assertEQ(c ? (float)longA : (float)longB, long2Float(c, longA, longB));\n+        Asserts.assertEQ(c ? (double)longA : (double)longB, long2Double(c, longA, longB));\n+        Asserts.assertEQ(c ? (int)longA : (int)longB, long2Int(c, longA, longB));\n+        Asserts.assertEQ(c ? Float.floatToFloat16(floatA) : Float.floatToFloat16(floatB), float2HalfFloat(c, floatA, floatB));\n+        Asserts.assertEQ(c ? Float.float16ToFloat(halfFloatA) : Float.float16ToFloat(halfFloatB), halfFloat2Float(c, halfFloatA, halfFloatB));\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestPhiDuplicatedConversion.java","additions":155,"deletions":0,"binary":false,"changes":155,"status":"added"},{"patch":"@@ -70,1 +70,1 @@\n-        if (oa.getExitValue() != 0 && !oa.getOutput().contains(\"Out of space in CodeCache for adapters\")) {\n+        if (oa.getExitValue() != 0 && !oa.getOutput().contains(\"Out of space in CodeCache\")) {\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/CodeCacheFullCountTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * bug 8312980\n+ * @summary C2: \"malformed control flow\" created during incremental inlining\n+ * @requires vm.compiler2.enabled\n+ * @run main\/othervm -XX:-TieredCompilation -XX:-BackgroundCompilation -XX:+IgnoreUnrecognizedVMOptions -XX:+AlwaysIncrementalInline TestReplacedNodesAfterLateInline\n+ *\/\n+\n+public class TestReplacedNodesAfterLateInline {\n+    private static B fieldB = new B();\n+    private static A fieldA = new A();\n+    private static volatile int volatileField;\n+\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 20_000; i++) {\n+            test(false, fieldA, true);\n+            test(false, fieldA, false);\n+            testHelper(fieldB);\n+            testHelper2(fieldB, true, false, true);\n+            testHelper2(fieldA, false, true, true);\n+            continue;\n+        }\n+    }\n+\n+    private static int test(boolean flag, Object o, boolean flag2) {\n+        if (o == null) {\n+        }\n+        if (flag2) {\n+            return testHelper2(o, true, true, flag);\n+        }\n+        return ((A) o).field;\n+    }\n+\n+    private static int testHelper2(Object o, boolean flag, boolean flag2, boolean flag3) {\n+        if (flag3) {\n+            if (flag) {\n+                testHelper(o);\n+            }\n+            if (flag2) {\n+                return ((A) o).field;\n+            }\n+        }\n+        volatileField = 42;\n+        return volatileField;\n+    }\n+\n+    private static void testHelper(Object o) {\n+        B b = (B)o;\n+    }\n+\n+    private static class A {\n+        public int field;\n+    }\n+\n+    private static class B {\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/inlining\/TestReplacedNodesAfterLateInline.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * bug 8312980\n+ * @summary C2: \"malformed control flow\" created during incremental inlining\n+ * @requires vm.compiler2.enabled\n+ * @run main\/othervm  -XX:CompileCommand=compileonly,TestReplacedNodesAfterLateInlineManyPaths::* -XX:-BackgroundCompilation\n+ *                    -XX:+IgnoreUnrecognizedVMOptions -XX:+AlwaysIncrementalInline TestReplacedNodesAfterLateInlineManyPaths\n+ *\/\n+\n+public class TestReplacedNodesAfterLateInlineManyPaths {\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 20_000; i++) {\n+            test(\"\" + i);\n+        }\n+    }\n+\n+    public static int test(String s) {\n+        int result = 0;\n+        int len = s.length();\n+        int i = 0;\n+        while (i < len) {\n+            \/\/ charAt is inlined late, and i is constrained by CastII(i >= 0)\n+            \/\/ The constraint comes from intrinsic checkIndex\n+            s.charAt(i);\n+            \/\/ Graph below intentionally branches out 4x, and merges again (4-fold diamonds).\n+            \/\/ This creates an exponential explosion in number of paths.\n+            int e = i;\n+            e = (e & 7) + (e & 31) + (e & 1111) + (e & 1000_000);\n+            e = (e & 7) + (e & 31) + (e & 1111) + (e & 1000_000);\n+            e = (e & 7) + (e & 31) + (e & 1111) + (e & 1000_000);\n+            e = (e & 7) + (e & 31) + (e & 1111) + (e & 1000_000);\n+            e = (e & 7) + (e & 31) + (e & 1111) + (e & 1000_000);\n+            \/\/ Comment out lines below to make it not assert\n+            \/\/ assert(C->live_nodes() <= C->max_node_limit()) failed: Live Node limit exceeded limit\n+            e = (e & 7) + (e & 31) + (e & 1111) + (e & 1000_000);\n+            e = (e & 7) + (e & 31) + (e & 1111) + (e & 1000_000);\n+            e = (e & 7) + (e & 31) + (e & 1111) + (e & 1000_000);\n+            e = (e & 7) + (e & 31) + (e & 1111) + (e & 1000_000);\n+            e = (e & 7) + (e & 31) + (e & 1111) + (e & 1000_000);\n+            e = (e & 7) + (e & 31) + (e & 1111) + (e & 1000_000);\n+            e = (e & 7) + (e & 31) + (e & 1111) + (e & 1000_000);\n+            e = (e & 7) + (e & 31) + (e & 1111) + (e & 1000_000);\n+            e = (e & 7) + (e & 31) + (e & 1111) + (e & 1000_000);\n+            result += e;\n+            i++;\n+        }\n+        return result;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/inlining\/TestReplacedNodesAfterLateInlineManyPaths.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8318306\n+ * @run main\/othervm\/timeout=200 -XX:+IgnoreUnrecognizedVMOptions -Xcomp -ea -esa -XX:CompileThreshold=100 -XX:+UnlockExperimentalVMOptions -server -XX:-TieredCompilation -XX:+DeoptimizeALot SortingDeoptimizationTest 1e-2 100 50\n+ * @summary Exercise Arrays.parallelSort when -XX:+DeoptimizeALot is enabled\n+ *\n+ *\/\n+\n+import java.io.PrintStream;\n+import java.util.Arrays;\n+import java.util.Random;\n+\n+public class SortingDeoptimizationTest {\n+\n+    private static final PrintStream err = System.err;\n+    private static final PrintStream out = System.out;\n+\n+    public static void main(String[] args) {\n+        int MAX = 2147483647; \/\/ 2^32 - 1\n+        float fraction = Float.parseFloat(args[0]);\n+        int size = (int) (fraction * MAX); \/\/ size is a fraction of the MAX size\n+        int iters = Integer.parseInt(args[1]); \/\/ number of iterations\n+        int max = args.length > 2 ? Integer.parseInt(args[2]) : -1 ; \/\/ max value for the array elements\n+        long seed = 0xC0FFEE;\n+        Random rand = new Random(seed);\n+\n+        for (int i = 0; i < iters; i++) {\n+            boolean isSorted = runSort(size, max, rand);\n+            out.println(\"Iteration \" + i + \": is sorted? -> \"+ isSorted);\n+            if (!isSorted) fail(\"Array is not correctly sorted.\");\n+        }\n+    }\n+\n+    private static void fail(String message) {\n+        err.format(\"\\n*** TEST FAILED ***\\n\\n%s\\n\\n\", message);\n+        throw new RuntimeException(\"Test failed\");\n+    }\n+\n+    private static boolean runSort(int size, int max, Random rand) {\n+        int[] a = new int[size];\n+        for (int i = 0; i < a.length; i++) a[i] =  max > 0 ? rand.nextInt(max) : rand.nextInt();\n+        \/\/ call parallel sort\n+        Arrays.parallelSort(a);\n+        \/\/ check if sorted\n+        boolean isSorted = true;\n+        for (int i = 0; i < (a.length -1); i++) isSorted = isSorted && (a[i] <= a[i+1]);\n+        return isSorted;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/SortingDeoptimizationTest.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -33,1 +33,1 @@\n- * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\"\n+ * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\" | os.arch==\"riscv64\"\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/TestCompareUnsigned.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,2 +24,0 @@\n-package compiler.intrinsics.string;\n-\n@@ -28,1 +26,1 @@\n- * @bug 8999999\n+ * @bug 8281146\n@@ -30,0 +28,1 @@\n+ * @key randomness\n@@ -31,0 +30,1 @@\n+ * @library \/test\/lib\n@@ -35,0 +35,24 @@\n+\/*\n+ * @test\n+ * @bug 8281146 8318509\n+ * @summary Validates StringCoding.countPositives intrinsic for AVX3 works with and without\n+ *          AVX3Threshold=0\n+ * @key randomness\n+ * @library \/compiler\/patches\n+ * @library \/test\/lib\n+ *\n+ * @build java.base\/java.lang.Helper\n+ * @requires vm.cpu.features ~= \".*avx512.*\"\n+ * @run main\/othervm\/timeout=1200 -XX:UseAVX=3 compiler.intrinsics.string.TestCountPositives\n+ * @run main\/othervm\/timeout=1200 -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:AVX3Threshold=0 compiler.intrinsics.string.TestCountPositives\n+ *\/\n+\/**\n+ * This test was derived from compiler.intrinsics.string.TestHasNegatives\n+ *\/\n+package compiler.intrinsics.string;\n+\n+import java.lang.Helper;\n+import java.util.Random;\n+import java.util.stream.IntStream;\n+\n+import jdk.test.lib.Utils;\n@@ -38,1 +62,3 @@\n-    private static byte[] tBa = new byte[4096 + 16];\n+    private static byte[] bytes = new byte[4096 + 32];\n+\n+    private static final Random RANDOM = Utils.getRandomInstance();\n@@ -43,1 +69,2 @@\n-     * length, and number of negative bytes.\n+     * length, and number of negative bytes. The lowest index that will be\n+     * negative is marked by negOffset\n@@ -45,2 +72,2 @@\n-    public static void initialize(int off, int len, int neg) {\n-        assert (len + off <= tBa.length);\n+    public static void initialize(int off, int len, int neg, int negOffset) {\n+        assert (len + off <= bytes.length);\n@@ -49,1 +76,1 @@\n-            tBa[i] = (byte) (((i + 15) & 0x7F) | 0x80);\n+            bytes[i] = (byte) (((i + 15) & 0x7F) | 0x80);\n@@ -53,1 +80,1 @@\n-            tBa[i] = (byte) (((i - off + 15) & 0x7F));\n+            bytes[i] = (byte) (((i - off + 15) & 0x7F));\n@@ -58,5 +85,3 @@\n-            int div = (neg > 1) ? (len - 1) \/ (neg - 1) : 0;\n-            int idx;\n-            for (int i = 0; i < neg; ++i) {\n-                idx = off + (len - 1) - div * i;\n-                tBa[idx] = (byte) (0x80 | tBa[idx]);\n+            for (int i = 0; i < neg; i++) {\n+                int idx = off + RANDOM.nextInt(len - negOffset) + negOffset;\n+                bytes[idx] = (byte) (0x80 | bytes[idx]);\n@@ -66,2 +91,2 @@\n-        for (int i = len + off; i < tBa.length; ++i) {\n-            tBa[i] = (byte) (((i + 15) & 0x7F) | 0x80);\n+        for (int i = len + off; i < bytes.length; ++i) {\n+            bytes[i] = (byte) (((i + 15) & 0x7F) | 0x80);\n@@ -71,4 +96,0 @@\n-    \/** Sizes of array segments to test. *\/\n-    private static int sizes[] = { 1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 13, 17, 19, 23, 37, 61, 131,\n-            4099 };\n-\n@@ -80,2 +101,22 @@\n-        int len, off;\n-        int ng;\n+        for (int off = 0; off < 16; off++) { \/\/ starting offset of array segment\n+            \/\/ Test all array segment sizes 1-63\n+            for (int len = 1; len < 64; len++) {\n+                test_countPositives(off, len, 0, 0);\n+                test_countPositives(off, len, 1, 0);\n+                test_countPositives(off, len, RANDOM.nextInt(30) + 2, 0);\n+            }\n+            \/\/ Test a random selection of sizes between 64 and 4099, inclusive\n+            for (int i = 0; i < 20; i++) {\n+                int len = 64 + RANDOM.nextInt(4100 - 64);\n+                test_countPositives(off, len, 0, 0);\n+                test_countPositives(off, len, 1, 0);\n+                test_countPositives(off, len, RANDOM.nextInt(len) + 2, 0);\n+            }\n+            for (int len : new int[] { 128, 2048 }) {\n+                \/\/ test with negatives only in a 1-63 byte tail\n+                int tail = RANDOM.nextInt(63) + 1;\n+                int ng = RANDOM.nextInt(tail) + 1;\n+                test_countPositives(off, len + tail, ng, len);\n+            }\n+        }\n+    }\n@@ -83,22 +124,11 @@\n-        for (ng = 0; ng < 57; ++ng) { \/\/ number of negatives in array segment\n-            for (off = 0; off < 8; ++off) { \/\/ starting offset of array segment\n-                for (int i = 0; i < sizes.length; ++i) { \/\/ array segment size\n-                                                         \/\/ choice\n-                    len = sizes[i];\n-                    if (len + off > tBa.length)\n-                        continue;\n-                    initialize(off, len, ng);\n-                    int calculated = Helper.StringCodingCountPositives(tBa, off, len);\n-                    int expected = countPositives(tBa, off, len);\n-                    if (calculated != expected) {\n-                        if (expected != len && calculated >= 0 && calculated < expected) {\n-                            \/\/ allow intrinsics to return early with a lower value,\n-                            \/\/ but only if we're not expecting the full length (no\n-                            \/\/ negative bytes)\n-                            continue;\n-                        }\n-                        throw new Exception(\"Failed test countPositives \" + \"offset: \" + off + \" \"\n-                                + \"length: \" + len + \" \" + \"return: \" + calculated + \" expected: \" + expected + \" negatives: \"\n-                                + ng);\n-                    }\n-                }\n+    private static void test_countPositives(int off, int len, int ng, int ngOffset) throws Exception {\n+        assert (len + off < bytes.length);\n+        initialize(off, len, ng, ngOffset);\n+        int calculated = Helper.StringCodingCountPositives(bytes, off, len);\n+        int expected = countPositives(bytes, off, len);\n+        if (calculated != expected) {\n+            if (expected != len && ng >= 0 && calculated >= 0 && calculated < expected) {\n+                \/\/ allow intrinsics to return early with a lower value,\n+                \/\/ but only if we're not expecting the full length (no\n+                \/\/ negative bytes)\n+                return;\n@@ -106,0 +136,3 @@\n+            throw new Exception(\"Failed test countPositives \" + \"offset: \" + off + \" \"\n+                    + \"length: \" + len + \" \" + \"return: \" + calculated + \" expected: \" + expected + \" negatives: \"\n+                    + ng + \" offset: \" + ngOffset);\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/string\/TestCountPositives.java","additions":78,"deletions":45,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+ * @library \/test\/lib\n@@ -33,0 +34,14 @@\n+\/*\n+ * @test\n+ * @bug 8054307 8318509\n+ * @summary Validates StringCoding.hasNegatives intrinsic for AVX3 works with and without\n+ *          AVX3Threshold=0\n+ * @key randomness\n+ * @library \/compiler\/patches\n+ * @library \/test\/lib\n+ *\n+ * @build java.base\/java.lang.Helper\n+ * @requires vm.cpu.features ~= \".*avx512.*\"\n+ * @run main\/othervm\/timeout=1200 -XX:UseAVX=3 compiler.intrinsics.string.TestHasNegatives\n+ * @run main\/othervm\/timeout=1200 -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:AVX3Threshold=0 compiler.intrinsics.string.TestHasNegatives\n+ *\/\n@@ -36,4 +51,6 @@\n-\/*\n- * @summary Validates StringCoding.hasNegatives intrinsic with a small\n- *          range of tests.\n- *\/\n+import java.lang.Helper;\n+import java.util.Random;\n+import java.util.stream.IntStream;\n+\n+import jdk.test.lib.Utils;\n+\n@@ -42,1 +59,3 @@\n-    private static byte[] tBa = new byte[4096 + 16];\n+    private static byte[] bytes = new byte[4096 + 32];\n+\n+    private static final Random RANDOM = Utils.getRandomInstance();\n@@ -50,1 +69,1 @@\n-        assert (len + off <= tBa.length);\n+        assert (len + off <= bytes.length);\n@@ -53,1 +72,1 @@\n-            tBa[i] = (byte) (((i + 15) & 0x7F) | 0x80);\n+            bytes[i] = (byte) (((i + 15) & 0x7F) | 0x80);\n@@ -57,1 +76,1 @@\n-            tBa[i] = (byte) (((i - off + 15) & 0x7F));\n+            bytes[i] = (byte) (((i - off + 15) & 0x7F));\n@@ -62,5 +81,3 @@\n-            int div = (neg > 1) ? (len - 1) \/ (neg - 1) : 0;\n-            int idx;\n-            for (int i = 0; i < neg; ++i) {\n-                idx = off + (len - 1) - div * i;\n-                tBa[idx] = (byte) (0x80 | tBa[idx]);\n+            for (int i = 0; i < neg; i++) {\n+                int idx = off + RANDOM.nextInt(len);\n+                bytes[idx] = (byte) (0x80 | bytes[idx]);\n@@ -70,2 +87,2 @@\n-        for (int i = len + off; i < tBa.length; ++i) {\n-            tBa[i] = (byte) (((i + 15) & 0x7F) | 0x80);\n+        for (int i = len + off; i < bytes.length; ++i) {\n+            bytes[i] = (byte) (((i + 15) & 0x7F) | 0x80);\n@@ -75,4 +92,0 @@\n-    \/** Sizes of array segments to test. *\/\n-    private static int sizes[] = { 1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 13, 17, 19, 23, 37, 61, 131,\n-            4099 };\n-\n@@ -84,19 +97,6 @@\n-        int len, off;\n-        int ng;\n-        boolean r;\n-\n-        for (ng = 0; ng < 57; ++ng) { \/\/ number of negatives in array segment\n-            for (off = 0; off < 8; ++off) { \/\/ starting offset of array segment\n-                for (int i = 0; i < sizes.length; ++i) { \/\/ array segment size\n-                                                         \/\/ choice\n-                    len = sizes[i];\n-                    if (len + off > tBa.length)\n-                        continue;\n-                    initialize(off, len, ng);\n-                    r = Helper.StringCodingHasNegatives(tBa, off, len);\n-                    if (r ^ ((ng == 0) ? false : true)) {\n-                        throw new Exception(\"Failed test hasNegatives \" + \"offset: \" + off + \" \"\n-                                + \"length: \" + len + \" \" + \"return: \" + r + \" \" + \"negatives: \"\n-                                + ng);\n-                    }\n-                }\n+        for (int off = 0; off < 16; off++) { \/\/ starting offset of array segment\n+            \/\/ Test all array segment sizes 1-63\n+            for (int len = 1; len < 64; len++) {\n+                test_hasNegatives(off, len, 0);\n+                test_hasNegatives(off, len, 1);\n+                test_hasNegatives(off, len, RANDOM.nextInt(30) + 2);\n@@ -104,0 +104,19 @@\n+            \/\/ Test a random selection of sizes between 64 and 4099, inclusive\n+            for (int i = 0; i < 20; i++) {\n+                int len = 64 + RANDOM.nextInt(4100 - 64);\n+                test_hasNegatives(off, len, 0);\n+                test_hasNegatives(off, len, 1);\n+                test_hasNegatives(off, len, RANDOM.nextInt(len) + 2);\n+            }\n+        }\n+    }\n+\n+    private static void test_hasNegatives(int off, int len, int maxNegatives) throws Exception {\n+        assert (len + off < bytes.length);\n+        initialize(off, len, maxNegatives);\n+        boolean expected = (maxNegatives > 0);\n+        boolean actual = Helper.StringCodingHasNegatives(bytes, off, len);\n+        if (actual != expected) {\n+            throw new Exception(\"Failed test hasNegatives \" + \"offset: \" + off + \" \"\n+                    + \"length: \" + len + \" \" + \"return: \" + actual + \" \" + \"negatives: \"\n+                    + maxNegatives);\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/string\/TestHasNegatives.java","additions":58,"deletions":39,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n- * @modules jdk.internal.vm.compiler\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/compilerToVM\/IsCompilableTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -445,0 +445,5 @@\n+    public static final String CONV = PREFIX + \"CONV\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CONV, \"Conv\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,102 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Checks that -XX:CompileCommand=PrintMemStat,... works\n+ * @library \/test\/lib\n+ * @run driver compiler.print.CompileCommandPrintMemStat\n+ *\/\n+\n+package compiler.print;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class CompileCommandPrintMemStat {\n+\n+    final static String METHOD1 = \"method1\";\n+    final static String METHOD2 = \"method2\";\n+\n+    public static void main(String[] args) throws Exception {\n+        test(METHOD1, METHOD2);\n+        test(METHOD2, METHOD1);\n+    }\n+\n+    private static void test(String include, String exclude) throws Exception {\n+        List<String> options = new ArrayList<String>();\n+        options.add(\"-Xcomp\");\n+        options.add(\"-XX:-Inline\");\n+        options.add(\"-XX:CompileCommand=compileonly,\" + getTestClass() + \"::*\");\n+        options.add(\"-XX:CompileCommand=MemStat,\" + getTestMethod(include) + \",print\");\n+        options.add(getTestClass());\n+\n+        OutputAnalyzer oa = ProcessTools.executeTestJvm(options);\n+\n+        \/\/ We expect two printouts for \"PrintMemStat\". A line at compilation time, and a line in a summary report\n+        \/\/ that is printed when we exit. Both use the typical <class>::name format but use \/ as separator and also\n+        \/\/ print the signature.\n+        String expectedNameIncl = getTestMethod(include)\n+                .replace('.', '\/')\n+                .replace(\"$\", \"\\\\$\");\n+        String expectedNameExcl = getTestMethod(exclude)\n+                .replace('.', '\/')\n+                .replace(\"$\", \"\\\\$\");\n+\n+        \/\/ Should see trace output when methods are compiled\n+        oa.shouldHaveExitValue(0)\n+          .shouldMatch(\".*\" + expectedNameIncl + \".*\")\n+          .shouldNotMatch(\".*\" + expectedNameExcl + \".*\");\n+\n+        \/\/ Should see final report\n+        \/\/ Looks like this:\n+        \/\/ total     NA        RA        #nodes  time    type  #rc thread              method\n+        \/\/ 621832    0         589104    0       0,025   c1    1   0x00007f5ccc1951a0  java\/util\/zip\/ZipFile$Source::checkAndAddEntry((II)I)\n+        oa.shouldMatch(\"total.*method\");\n+        oa.shouldMatch(\"\\\\d+ +\\\\d+ +\\\\d+ +\\\\d+.*\" + expectedNameIncl + \".*\");\n+        oa.shouldNotMatch(\"\\\\d+ +\\\\d+ +\\\\d+ +\\\\d+.*\" + expectedNameExcl + \".*\");\n+    }\n+\n+    \/\/ Test class that is invoked by the sub process\n+    public static String getTestClass() {\n+        return TestMain.class.getName();\n+    }\n+\n+    public static String getTestMethod(String method) {\n+        return getTestClass() + \"::\" + method;\n+    }\n+\n+    public static class TestMain {\n+        public static void main(String[] args) {\n+            method1();\n+            method2();\n+        }\n+\n+        static void method1() {}\n+        static void method2() {}\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/print\/CompileCommandPrintMemStat.java","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"},{"patch":"@@ -31,2 +31,1 @@\n- * @compile --enable-preview -source ${jdk.version} TestRangeCheckHoistingScaledIV.java\n- * @run main\/othervm --enable-preview compiler.rangechecks.TestRangeCheckHoistingScaledIV\n+ * @run main\/othervm compiler.rangechecks.TestRangeCheckHoistingScaledIV\n@@ -86,1 +85,1 @@\n-                \"--enable-preview\", \"--add-modules\", \"jdk.incubator.vector\",\n+                \"--add-modules\", \"jdk.incubator.vector\",\n","filename":"test\/hotspot\/jtreg\/compiler\/rangechecks\/TestRangeCheckHoistingScaledIV.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-    private static void runTest(String test) throws Exception {\n+    private static void runTest(String compiler, String test) throws Exception {\n@@ -57,0 +57,1 @@\n+        command.add(compiler);\n@@ -83,1 +84,1 @@\n-            runTest(methodName);\n+            runTest(args[0], methodName);\n","filename":"test\/hotspot\/jtreg\/compiler\/sharedstubs\/SharedStubToInterpTest.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ * @requires vm.compiler2.enabled\n@@ -49,1 +50,1 @@\n-    private static void runTest(String test) throws Exception {\n+    private static void runTest(String compiler, String test) throws Exception {\n@@ -52,0 +53,1 @@\n+        command.add(compiler);\n@@ -75,1 +77,1 @@\n-            runTest(test);\n+            runTest(args[0], test);\n","filename":"test\/hotspot\/jtreg\/compiler\/sharedstubs\/SharedTrampolineTest.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n- * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestIntrinsicBailOut.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-                                    \"-XX:+EnableVectorReboxing\", \"-Xlog:compilation\", \"-version\", \"--enable-preview\")\n+                                    \"-XX:+EnableVectorReboxing\", \"-Xlog:compilation\", \"-version\")\n@@ -46,1 +46,1 @@\n-                                    \"-XX:+EnableVectorAggressiveReboxing\", \"-Xlog:compilation\", \"-version\", \"--enable-preview\")\n+                                    \"-XX:+EnableVectorAggressiveReboxing\", \"-Xlog:compilation\", \"-version\")\n@@ -51,1 +51,1 @@\n-                                    \"-XX:-EnableVectorReboxing\", \"-Xlog:compilation\", \"-version\", \"--enable-preview\")\n+                                    \"-XX:-EnableVectorReboxing\", \"-Xlog:compilation\", \"-version\")\n@@ -57,1 +57,1 @@\n-                                    \"-XX:-EnableVectorAggressiveReboxing\", \"-Xlog:compilation\", \"-version\", \"--enable-preview\")\n+                                    \"-XX:-EnableVectorAggressiveReboxing\", \"-Xlog:compilation\", \"-version\")\n@@ -62,1 +62,1 @@\n-                                    \"-XX:-EnableVectorSupport\", \"-Xlog:compilation\", \"-version\", \"--enable-preview\")\n+                                    \"-XX:-EnableVectorSupport\", \"-Xlog:compilation\", \"-version\")\n@@ -69,1 +69,1 @@\n-                                    \"-XX:-EnableVectorSupport\", \"-XX:+EnableVectorReboxing\", \"-Xlog:compilation\", \"-version\", \"--enable-preview\")\n+                                    \"-XX:-EnableVectorSupport\", \"-XX:+EnableVectorReboxing\", \"-Xlog:compilation\", \"-version\")\n@@ -76,1 +76,1 @@\n-                                    \"-XX:-EnableVectorSupport\", \"-XX:+EnableVectorAggressiveReboxing\", \"-Xlog:compilation\", \"-version\", \"--enable-preview\")\n+                                    \"-XX:-EnableVectorSupport\", \"-XX:+EnableVectorAggressiveReboxing\", \"-Xlog:compilation\", \"-version\")\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestVectorErgonomics.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n- * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorMemoryAlias.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,0 @@\n- * @enablePreview\n@@ -51,1 +50,0 @@\n- * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorRebracket128Test.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n- * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/TestVectorCastAVX1.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n- * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/TestVectorCastAVX2.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n- * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/TestVectorCastAVX512.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n- * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/TestVectorCastAVX512BW.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n- * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/TestVectorCastAVX512DQ.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n- * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/TestVectorCastNeon.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n- * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/TestVectorCastSVE.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,0 @@\n- * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/TestVectorReinterpret.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -80,1 +80,1 @@\n-        test.addFlags(\"--add-modules=jdk.incubator.vector\", \"--add-exports=java.base\/jdk.internal.misc=ALL-UNNAMED\", \"--enable-preview\");\n+        test.addFlags(\"--add-modules=jdk.incubator.vector\", \"--add-exports=java.base\/jdk.internal.misc=ALL-UNNAMED\");\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/utils\/VectorReshapeHelper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,1 @@\n+ * @requires vm.opt.CompressedClassSpaceSize == null & vm.opt.UseCompressedClassPointers == null\n@@ -53,1 +54,1 @@\n-        ProcessBuilder pb = GCArguments.createJavaProcessBuilder(args);\n+        ProcessBuilder pb = GCArguments.createTestJvm(args);\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestCompressedClassFlags.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,7 +43,7 @@\n-        ProcessBuilder pb = GCArguments.createJavaProcessBuilder(\"-XX:-UseSerialGC\",\n-                                                                 \"-XX:-UseParallelGC\",\n-                                                                 \"-XX:-UseG1GC\",\n-                                                                 \"-XX:-UseZGC\",\n-                                                                 \"-XX:+UnlockExperimentalVMOptions\",\n-                                                                 \"-XX:-UseShenandoahGC\",\n-                                                                 \"-version\");\n+        ProcessBuilder pb = GCArguments.createTestJvm(\"-XX:-UseSerialGC\",\n+                                                      \"-XX:-UseParallelGC\",\n+                                                      \"-XX:-UseG1GC\",\n+                                                      \"-XX:-UseZGC\",\n+                                                      \"-XX:+UnlockExperimentalVMOptions\",\n+                                                      \"-XX:-UseShenandoahGC\",\n+                                                      \"-version\");\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestDisableDefaultGC.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @requires vm.gc.G1\n+ * @requires vm.gc.G1 & vm.opt.G1ConcMarkStepDurationMillis == null\n@@ -81,1 +81,1 @@\n-    ProcessBuilder pb = GCArguments.createJavaProcessBuilder(vmOpts);\n+    ProcessBuilder pb = GCArguments.createTestJvm(vmOpts);\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestG1ConcMarkStepDurationMillis.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @requires vm.gc.G1\n+ * @requires vm.gc.G1 & vm.opt.G1ConcRefinementThreads == null\n@@ -72,1 +72,1 @@\n-    ProcessBuilder pb = GCArguments.createJavaProcessBuilder(vmOpts);\n+    ProcessBuilder pb = GCArguments.createTestJvm(vmOpts);\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestG1ConcRefinementThreads.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @requires vm.gc.G1\n+ * @requires vm.gc.G1 & vm.opt.G1HeapRegionSize == null\n@@ -56,1 +56,1 @@\n-    ProcessBuilder pb = GCArguments.createJavaProcessBuilder(flagList);\n+    ProcessBuilder pb = GCArguments.createTestJvm(flagList);\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestG1HeapRegionSize.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n- * @requires vm.gc.G1\n@@ -31,0 +30,2 @@\n+ * @key flag-sensitive\n+ * @requires vm.gc.G1 & vm.opt.x.Xmx == null & vm.opt.x.Xms == null & vm.opt.MinHeapSize == null & vm.opt.MaxHeapSize == null & vm.opt.InitialHeapSize == null\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestG1HeapSizeFlags.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @requires vm.gc.G1\n+ * @requires vm.gc.G1 & vm.opt.G1ConfidencePercent == null\n@@ -66,2 +66,1 @@\n-        ProcessBuilder pb = GCArguments.createJavaProcessBuilder(\n-                \"-XX:+UseG1GC\", flag, \"-version\");\n+        ProcessBuilder pb = GCArguments.createTestJvm(\"-XX:+UseG1GC\", flag, \"-version\");\n@@ -76,2 +75,1 @@\n-    private static\n-    void check(String name, String value, boolean is_valid) throws Exception {\n+    private static void check(String name, String value, boolean is_valid) throws Exception {\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestG1PercentageOptions.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @requires vm.gc.G1\n+ * @requires vm.gc.G1 & vm.opt.UnlockExperimentalVMOptions == null & vm.opt.G1RemSetHowlNumBuckets == null & vm.opt.G1RemSetHowlMaxNumBuckets == null\n@@ -51,1 +51,1 @@\n-    ProcessBuilder pb = GCArguments.createJavaProcessBuilder(flagList);\n+    ProcessBuilder pb = GCArguments.createTestJvm(flagList);\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestG1RemSetFlags.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+ * @requires vm.opt.x.Xminf == null & vm.opt.x.Xmaxf == null & vm.opt.MinHeapFreeRatio == null & vm.opt.MaxHeapFreeRatio == null\n@@ -50,1 +51,1 @@\n-    ProcessBuilder pb = GCArguments.createJavaProcessBuilder(\n+    ProcessBuilder pb = GCArguments.createTestJvm(\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestHeapFreeRatio.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @requires vm.gc.Parallel\n+ * @requires vm.gc.Parallel & vm.opt.InitialTenuringThreshold == null & vm.opt.MaxTenuringThreshold == null\n@@ -44,1 +44,1 @@\n-    ProcessBuilder pb = GCArguments.createJavaProcessBuilder(\n+    ProcessBuilder pb = GCArguments.createTestJvm(\n@@ -61,1 +61,1 @@\n-    ProcessBuilder pb = GCArguments.createJavaProcessBuilder(\n+    ProcessBuilder pb = GCArguments.createTestJvm(\n@@ -63,0 +63,1 @@\n+      \"-XX:+UseParallelGC\",\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestInitialTenuringThreshold.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,0 @@\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n@@ -30,0 +28,2 @@\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n@@ -118,1 +118,1 @@\n-    ProcessBuilder pb = GCArguments.createJavaProcessBuilder(gcflag,\n+    ProcessBuilder pb = GCArguments.createTestJvm(gcflag,\n@@ -211,1 +211,1 @@\n-    ProcessBuilder pb = GCArguments.createJavaProcessBuilder(finalargs.toArray(String[]::new));\n+    ProcessBuilder pb = GCArguments.createTestJvm(finalargs.toArray(String[]::new));\n@@ -311,1 +311,1 @@\n-    ProcessBuilder pb = GCArguments.createJavaProcessBuilder(flags);\n+    ProcessBuilder pb = GCArguments.createTestJvm(flags);\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestMaxHeapSizeTools.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,2 @@\n- * @requires vm.gc.Serial\n+ * @key flag-sensitive\n+ * @requires vm.gc.Serial & vm.opt.MaxNewSize == null & vm.opt.NewRatio == null & vm.opt.NewSize == null & vm.opt.OldSize == null & vm.opt.x.Xms == null & vm.opt.x.Xmx == null\n@@ -45,1 +46,2 @@\n- * @requires vm.gc.Parallel\n+ * @key flag-sensitive\n+ * @requires vm.gc.Parallel & vm.opt.MaxNewSize == null & vm.opt.NewRatio == null & vm.opt.NewSize == null & vm.opt.OldSize == null & vm.opt.x.Xms == null & vm.opt.x.Xmx == null\n@@ -59,1 +61,2 @@\n- * @requires vm.gc.G1\n+ * @key flag-sensitive\n+ * @requires vm.gc.G1 & vm.opt.MaxNewSize == null & vm.opt.NewRatio == null & vm.opt.NewSize == null & vm.opt.OldSize == null & vm.opt.x.Xms == null & vm.opt.x.Xmx == null\n@@ -82,2 +85,2 @@\n-    System.out.println(actual);\n-    if (actual.compareTo(new BigInteger((new Long(heapsize)).toString())) == 1) {\n+    System.out.println(\"asserting: \" + actual + \" <= \" + heapsize);\n+    if (actual.compareTo(new BigInteger(\"\" + heapsize)) > 0) {\n@@ -89,19 +92,0 @@\n-  private static void checkIncompatibleNewSize(String[] flags) throws Exception {\n-    ArrayList<String> finalargs = new ArrayList<String>();\n-    finalargs.addAll(Arrays.asList(flags));\n-    finalargs.add(\"-version\");\n-\n-    ProcessBuilder pb = GCArguments.createJavaProcessBuilder(finalargs);\n-    OutputAnalyzer output = new OutputAnalyzer(pb.start());\n-    output.shouldContain(\"Initial young gen size set larger than the maximum young gen size\");\n-  }\n-\n-  private static boolean isRunningG1(String[] args) {\n-    for (int i = 0; i < args.length; i++) {\n-      if (args[i].contains(\"+UseG1GC\")) {\n-        return true;\n-      }\n-    }\n-    return false;\n-  }\n-\n@@ -111,3 +95,0 @@\n-    if (isRunningG1(flags)) {\n-      finalargs.add(\"-XX:G1HeapRegionSize=1M\");\n-    }\n@@ -117,1 +98,1 @@\n-    ProcessBuilder pb = GCArguments.createJavaProcessBuilder(finalargs);\n+    ProcessBuilder pb = GCArguments.createTestJvm(finalargs);\n@@ -121,1 +102,0 @@\n-    \/\/System.out.println(stdout);\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestMaxNewSize.java","additions":10,"deletions":30,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,2 @@\n- * @requires vm.gc.Parallel\n+ * @key flag-sensitive\n+ * @requires vm.gc.Parallel & vm.opt.x.Xmx == null & vm.opt.x.Xms == null & vm.opt.MinHeapSize == null & vm.opt.MaxHeapSize == null & vm.opt.InitialHeapSize == null\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestParallelHeapSizeFlags.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,2 @@\n+ * @key flag-sensitive\n+ * @requires vm.gc.Serial & vm.opt.x.Xmx == null & vm.opt.x.Xms == null & vm.opt.MinHeapSize == null & vm.opt.MaxHeapSize == null & vm.opt.InitialHeapSize == null\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestSerialHeapSizeFlags.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/compiler\/TestLinkToNativeRBP.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n-    private static final Class<?> PREVIEW_API = java.lang.foreign.MemorySegment.class;\n+    private static final Class<?> PREVIEW_API = java.lang.ScopedValue.class;\n","filename":"test\/hotspot\/jtreg\/runtime\/ClassFile\/ClassFileVersionTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Testing that, faced with a given (possibly odd) mapping address of class space, the encoding\n+ *          scheme fits the address\n+ * @requires vm.bits == 64 & !vm.graal.enabled & vm.debug == true\n+ * @requires vm.flagless\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @run driver CompressedClassPointersEncodingScheme\n+ *\/\n+\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import jtreg.SkippedException;\n+\n+import java.io.IOException;\n+\n+public class CompressedClassPointersEncodingScheme {\n+\n+    private static void test(long forceAddress, long classSpaceSize, long expectedEncodingBase, int expectedEncodingShift) throws IOException {\n+        String forceAddressString = String.format(\"0x%016X\", forceAddress).toLowerCase();\n+        String expectedEncodingBaseString = String.format(\"0x%016X\", expectedEncodingBase).toLowerCase();\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n+                \"-Xshare:off\", \/\/ to make CompressedClassSpaceBaseAddress work\n+                \"-XX:+UnlockDiagnosticVMOptions\",\n+                \"-XX:-UseCompressedOops\", \/\/ keep VM from optimizing heap location\n+                \"-XX:CompressedClassSpaceBaseAddress=\" + forceAddress,\n+                \"-XX:CompressedClassSpaceSize=\" + classSpaceSize,\n+                \"-Xmx128m\",\n+                \"-Xlog:metaspace*\",\n+                \"-version\");\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+\n+        output.reportDiagnosticSummary();\n+\n+        \/\/ We ignore cases where we were not able to map at the force address\n+        if (output.contains(\"reserving class space failed\")) {\n+            throw new SkippedException(\"Skipping because we cannot force ccs to \" + forceAddressString);\n+        }\n+\n+        output.shouldHaveExitValue(0);\n+        output.shouldContain(\"Narrow klass base: \" + expectedEncodingBaseString + \", Narrow klass shift: \" + expectedEncodingShift);\n+    }\n+\n+    final static long K = 1024;\n+    final static long M = K * 1024;\n+    final static long G = M * 1024;\n+    public static void main(String[] args) throws Exception {\n+        \/\/ Test ccs nestling right at the end of the 4G range\n+        \/\/ Expecting base=0, shift=0\n+        test(4 * G - 128 * M, 128 * M, 0, 0);\n+\n+        \/\/ add more...\n+\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/CompressedOops\/CompressedClassPointersEncodingScheme.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -0,0 +1,134 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.Utils;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+\/*\n+ * @test StackWalkNativeToJava\n+ * @bug 8316309\n+ * @summary Check that walking the stack works fine when going from C++ frame to Java frame.\n+ * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\"\n+ * @requires os.family != \"windows\"\n+ * @requires vm.flagless\n+ * @library \/test\/lib\n+ * @run driver StackWalkNativeToJava\n+ *\/\n+\n+public class StackWalkNativeToJava {\n+\n+    public static void main(String[] args) throws Exception {\n+        \/\/ Check stack walking works fine when sender of C++ frame\n+        \/\/ is a Java native method.\n+        testStackWalkNativeToJavaNative(\"-Xint\");\n+        testStackWalkNativeToJavaNative(\"-Xcomp\", \"-XX:CompileCommand=dontinline,StackWalkNativeToJava$TestNativeToJavaNative::*\");\n+\n+        \/\/ Check stack walking works fine when sender of C++ frame\n+        \/\/ is a runtime stub or interpreted Java method (VM call from Java).\n+        testStackWalkNativeToJava(\"-Xint\");\n+        testStackWalkNativeToJava(\"-Xcomp\", \"-XX:TieredStopAtLevel=3\",\n+                                  \"-XX:CompileCommand=dontinline,StackWalkNativeToJava$TestNativeToJava::*\");\n+    }\n+\n+    public static void testStackWalkNativeToJavaNative(String... extraFlags) throws Exception {\n+        List<String> commands = new ArrayList<>();\n+        commands.add(\"-Xbootclasspath\/a:.\");\n+        commands.add(\"-XX:-CreateCoredumpOnCrash\");\n+        commands.add(\"-XX:+UnlockDiagnosticVMOptions\");\n+        commands.add(\"-XX:AbortVMOnException=java.lang.IllegalMonitorStateException\");\n+        commands.add(\"-XX:+ErrorFileToStdout\");\n+        commands.addAll(Arrays.asList(extraFlags));\n+        commands.add(\"StackWalkNativeToJava$TestNativeToJavaNative\");\n+\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(commands);\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldNotContain(\"java.lang.RuntimeException: Reached statement after obj.wait()\");\n+        output.shouldNotContain(\"[error occurred during error reporting (printing native stack\");\n+        String[] res = output.getOutput().split(\"StackWalkNativeToJava\\\\$TestNativeToJavaNative\\\\.callNativeMethod\\\\(\\\\)V\");\n+        assertTrue(res.length - 1 == 2, res.length - 1);\n+        output.shouldNotHaveExitValue(0);\n+    }\n+\n+    public static class TestNativeToJavaNative {\n+        public static void main(String[] args) throws Exception {\n+            TestNativeToJavaNative test = new TestNativeToJavaNative();\n+            test.callNativeMethod();\n+        }\n+\n+        public void callNativeMethod() throws Exception {\n+            Object obj = new Object();\n+            \/\/ Trigger a fatal exit due to IllegalMonitorStateException during\n+            \/\/ a call to the VM from a Java native method.\n+            obj.wait();\n+            throw new RuntimeException(\"Reached statement after obj.wait()\");\n+        }\n+    }\n+\n+    public static void testStackWalkNativeToJava(String... extraFlags) throws Exception {\n+        List<String> commands = new ArrayList<>();\n+        commands.add(\"-Xbootclasspath\/a:.\");\n+        commands.add(\"-XX:-CreateCoredumpOnCrash\");\n+        commands.add(\"-XX:+UnlockDiagnosticVMOptions\");\n+        commands.add(\"-XX:DiagnoseSyncOnValueBasedClasses=1\");\n+        commands.add(\"-XX:+ErrorFileToStdout\");\n+        commands.addAll(Arrays.asList(extraFlags));\n+        commands.add(\"StackWalkNativeToJava$TestNativeToJava\");\n+\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(commands);\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldNotContain(\"java.lang.RuntimeException: Reached statement after synchronized\");\n+        output.shouldNotContain(\"[error occurred during error reporting (printing native stack\");\n+        String[] res = output.getOutput().split(\"StackWalkNativeToJava\\\\$TestNativeToJava\\\\.callVMMethod\\\\(\\\\)V\");\n+        assertTrue(res.length - 1 == 2, res.length - 1);\n+        output.shouldNotHaveExitValue(0);\n+    }\n+\n+    public static class TestNativeToJava {\n+        static Integer counter = 0;\n+\n+        public static void main(String[] args) throws Exception {\n+            TestNativeToJava test = new TestNativeToJava();\n+            test.callVMMethod();\n+        }\n+\n+        public void callVMMethod() throws Exception {\n+            \/\/ Trigger a fatal exit for trying to synchronize on a value based class\n+            \/\/ during a call to the VM from a Java method.\n+            synchronized (counter) {\n+                counter++;\n+            }\n+            throw new RuntimeException(\"Reached statement after synchronized\");\n+        }\n+    }\n+\n+    private static void assertTrue(boolean condition, int count) {\n+        if (!condition) {\n+            throw new RuntimeException(\"Count error: count was \" + count);\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/StackWalkNativeToJava.java","additions":134,"deletions":0,"binary":false,"changes":134,"status":"added"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+\/*\n+ * @test symbolsHsErr\n+ * @summary Test that function names are present in native frames of hs-err file as a proof that symbols are available.\n+ * @library \/test\/lib\n+ * @requires vm.flagless\n+ * @requires vm.debug\n+ * @requires os.family == \"windows\"\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @run driver TestSymbolsInHsErrFile\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class TestSymbolsInHsErrFile {\n+\n+  public static void main(String[] args) throws Exception {\n+\n+    \/\/ Start a jvm and cause a SIGSEGV \/ ACCESS_VIOLATION\n+    ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n+        \"-XX:+UnlockDiagnosticVMOptions\",\n+        \"-Xmx100M\",\n+        \"-XX:-CreateCoredumpOnCrash\",\n+        \"-XX:ErrorHandlerTest=14\",\n+        \"-version\");\n+\n+    OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+    output.shouldNotHaveExitValue(0);\n+\n+    \/\/ Verify that the hs_err problematic frame contains a function name that points to origin of the crash;\n+    \/\/ on Windows\/MSVC, if symbols are present and loaded, we should see a ref to  either 'crash_with_segfault'\n+    \/\/ 'VMError::controlled_crash' depending on whether the compile optimizations (i.e. crash_with_segfault\n+    \/\/ was inlined or not):\n+    \/\/ # Problematic frame:\n+    \/\/ # V  [jvm.dll+0x.....]  crash_with_segfault+0x10\n+    \/\/ or\n+    \/\/ # V  [jvm.dll+0x.....]  VMError::controlled_crash+0x99\n+    \/\/\n+    \/\/ If symbols could not be loaded, however, then the frame will contain not function name at all, i.e.\n+    \/\/ # Problematic frame:\n+    \/\/ # V  [jvm.dll+0x.....]\n+    \/\/ NB: this is not true for other OS\/Compilers, where the functions names are present even with no symbols,\n+    \/\/ hence this test being restricted to Windows only.\n+    output.shouldMatch((\"# V  \\\\[jvm.dll.*\\\\].*(crash_with_segfault|controlled_crash).*\"));\n+\n+  }\n+\n+}\n+\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/TestSymbolsInHsErrFile.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -38,0 +38,1 @@\n+    private static int classesBeforeGC = 0;\n@@ -99,0 +100,8 @@\n+        \/\/ Every N-th classes, force a GC to kick out the loaded classes from previous tests.\n+        \/\/ Different tests come in with different number of classes, so testNum is not reliable.\n+        classesBeforeGC -= classes.size();\n+        if (classesBeforeGC <= 0) {\n+            System.gc();\n+            classesBeforeGC = 3000;\n+        }\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/InvocationTests\/shared\/AbstractGenerator.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary run NMT baseline, create threads and verify output from summary.diff\n+ * @author Evgeny Ignatenko\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:NativeMemoryTracking=summary SummaryDiffThreadCount\n+ *\/\n+\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.JDKToolFinder;\n+\n+public class SummaryDiffThreadCount {\n+    public static void main(String args[]) throws Exception {\n+        ProcessBuilder pb = new ProcessBuilder();\n+        OutputAnalyzer output;\n+        \/\/ Grab my own PID.\n+        String pid = Long.toString(ProcessTools.getProcessId());\n+\n+        pb.command(new String[] { JDKToolFinder.getJDKTool(\"jcmd\"), pid, \"VM.native_memory\", \"baseline=true\"});\n+        pb.start().waitFor();\n+\n+        output = new OutputAnalyzer(pb.start());\n+        output.shouldContain(\"Baseline taken\");\n+\n+        \/\/ Creating 10 threads.\n+        for (int i = 0; i < 10; i++) {\n+            new Thread(()-> {\n+                while (true) { continue; }\n+            }).start();\n+        }\n+\n+        \/\/ Running \"jcmd <pid> VM.native_memory summary.diff\" and checking for five new threads reported.\n+        pb.command(new String[] { JDKToolFinder.getJDKTool(\"jcmd\"), pid, \"VM.native_memory\", \"summary.diff\"});\n+        output = new OutputAnalyzer(pb.start());\n+\n+        \/\/ Trailing '+' is needed to check that NMT now reports that now we have more threads than it\n+        \/\/ was during the baseline.\n+        output.shouldMatch(\"threads #\\\\d+ \\\\+\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/SummaryDiffThreadCount.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -82,0 +82,1 @@\n+            .addPrefix(\"-Xint\") \/\/ Override any -Xmixed\/-Xcomp flags from jtreg -vmoptions\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/DeterministicDump.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,1 +62,4 @@\n-        \"-XX:ObjectAlignmentInBytes=64\"\n+        \"-XX:ObjectAlignmentInBytes=64\",\n+        \"-Xint\",\n+        \"-Xmixed\",\n+        \"-Xcomp\",\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/CommandLineFlagCombo.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @requires vm.cds.write.archived.java.heap\n+ * @requires vm.debug == true & vm.cds.write.archived.java.heap\n@@ -64,5 +64,1 @@\n-        if (Platform.isDebugBuild()) {\n-            testDebugBuild();\n-        } else {\n-            testProductBuild();\n-        }\n+        testDebugBuild();\n@@ -172,7 +168,0 @@\n-\n-    static void testProductBuild() throws Exception {\n-        OutputAnalyzer output;\n-\n-        output = dumpHelloOnly(\"-XX:-IgnoreUnrecognizedVMOptions\", \"-XX:ArchiveHeapTestClass=NoSuchClass\");\n-        mustFail(output, \"VM option 'ArchiveHeapTestClass' is develop and is available only in debug version of VM.\");\n-    }\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/cacheObject\/ArchiveHeapTestClass.java","additions":3,"deletions":14,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,2 @@\n+ * @comment CDS archive heap mapping is not supported with large pages\n+ * @requires vm.opt.UseLargePages == null | !vm.opt.UseLargePages\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/sharedStrings\/InternSharedString.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8317262\n+ * @library \/testlibrary \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+HandshakeALot -XX:GuaranteedSafepointInterval=1 TestStackWalk\n+ *\/\n+\n+import jvmti.JVMTIUtils;\n+import jdk.test.lib.Asserts;\n+import jdk.test.whitebox.WhiteBox;\n+import java.util.concurrent.CountDownLatch;\n+\n+public class TestStackWalk {\n+    static Thread worker1;\n+    static Thread worker2;\n+    static volatile boolean done;\n+    static volatile int counter = 0;\n+    static Object lock = new Object();\n+\n+    public static void main(String... args) throws Exception {\n+        worker1 = new Thread(() -> syncedWorker());\n+        worker1.start();\n+        worker2 = new Thread(() -> syncedWorker());\n+        worker2.start();\n+        Thread worker3 = new Thread(() -> stackWalker());\n+        worker3.start();\n+\n+        worker1.join();\n+        worker2.join();\n+        worker3.join();\n+    }\n+\n+    public static void syncedWorker() {\n+        synchronized (lock) {\n+            while (!done) {\n+                counter++;\n+            }\n+        }\n+    }\n+\n+    public static void stackWalker() {\n+        \/\/ Suspend workers so the one looping waiting for \"done\"\n+        \/\/ doesn't execute the handshake below, increasing the\n+        \/\/ chances the VMThread will do it.\n+        suspendWorkers();\n+\n+        WhiteBox wb = WhiteBox.getWhiteBox();\n+        long end = System.currentTimeMillis() + 20000;\n+        while (end > System.currentTimeMillis()) {\n+            wb.handshakeWalkStack(worker1, false \/* all_threads *\/);\n+            wb.handshakeWalkStack(worker2, false \/* all_threads *\/);\n+        }\n+\n+        resumeWorkers();\n+        done = true;\n+    }\n+\n+    static void suspendWorkers() {\n+        JVMTIUtils.suspendThread(worker1);\n+        JVMTIUtils.suspendThread(worker2);\n+    }\n+\n+    static void resumeWorkers() {\n+        JVMTIUtils.resumeThread(worker1);\n+        JVMTIUtils.resumeThread(worker2);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/lockStack\/TestStackWalk.java","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test id=int\n+ * @summary Check that monitorenter A; monitorenter B; monitorexit A; monitorexit B; works\n+ * @compile TestOutOfOrderUnlocking.jasm\n+ * @run main\/othervm -Xint TestOutOfOrderUnlocking\n+ *\/\n+\/*\n+ * @test id=comp\n+ * @summary Check that monitorenter A; monitorenter B; monitorexit A; monitorexit B; works, with -Xcomp\n+ * @compile TestOutOfOrderUnlocking.jasm\n+ * @run main\/othervm -Xcomp TestOutOfOrderUnlocking\n+ *\/\n+\n+super public class TestOutOfOrderUnlocking version 64:0 {\n+\n+    public static Method main:\"([Ljava\/lang\/String;)V\" stack 2 locals 4 {\n+        new class java\/lang\/Object;\n+        dup;\n+        invokespecial Method java\/lang\/Object.\"<init>\":\"()V\";\n+        astore_1;\n+        new class java\/lang\/Object;\n+        dup;\n+        invokespecial Method java\/lang\/Object.\"<init>\":\"()V\";\n+        astore_2;\n+        aload_1;\n+        monitorenter;\n+        aload_2;\n+        monitorenter;\n+        aload_1;\n+        monitorexit;\n+        aload_2;\n+        monitorexit;\n+        return;\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/locking\/TestOutOfOrderUnlocking.jasm","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -0,0 +1,190 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.File;\n+import java.lang.ref.Reference;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.JDKToolLauncher;\n+import jdk.test.lib.apps.LingeredApp;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.hprof.model.JavaClass;\n+import jdk.test.lib.hprof.model.JavaHeapObject;\n+import jdk.test.lib.hprof.model.JavaObject;\n+import jdk.test.lib.hprof.model.JavaThing;\n+import jdk.test.lib.hprof.model.Snapshot;\n+import jdk.test.lib.hprof.parser.Reader;\n+\n+\/*\n+ * @test\n+ * @bug 8317692\n+ * @summary Verifies heap dump contains all fields of an instance\n+ * @library \/test\/lib\n+ * @run driver FieldsInInstanceTest\n+ *\/\n+class FieldsInInstanceTarg extends LingeredApp {\n+\n+    public static void main(String[] args) {\n+        B b = new B();\n+        NoFields2 nf = new NoFields2();\n+        NoParentFields npf = new NoParentFields();\n+        OnlyParentFields opf = new OnlyParentFields();\n+        DirectParentNoFields dpnf = new DirectParentNoFields();\n+        LingeredApp.main(args);\n+        Reference.reachabilityFence(b);\n+        Reference.reachabilityFence(nf);\n+        Reference.reachabilityFence(npf);\n+        Reference.reachabilityFence(opf);\n+        Reference.reachabilityFence(dpnf);\n+    }\n+\n+    interface I {\n+        int i = -10;\n+    }\n+    static abstract class A implements I {\n+        static boolean b;\n+        int a = 3;\n+        String s = \"Field\";\n+    }\n+    static class B extends A {\n+        static String f = null;\n+        int a = 7;\n+        double s = 0.5d;\n+    }\n+\n+    \/\/ no fields:\n+    interface I1 {\n+    }\n+    static class NoFields1 {\n+    }\n+    static class NoFields2 extends NoFields1 implements I1 {\n+    }\n+\n+    \/\/ no parent fields\n+    static class NoParentFields extends NoFields1 implements I1 {\n+        int i1 = 1;\n+        int i2 = 2;\n+    }\n+\n+    \/\/ only parent fields\n+    static class Parent1 {\n+        int i3 = 3;\n+    }\n+    static class OnlyParentFields extends Parent1 {\n+    }\n+\n+    \/\/ in between parent with no fields\n+    static class DirectParentNoFields extends OnlyParentFields {\n+        int i = 17;\n+    }\n+}\n+\n+public class FieldsInInstanceTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        File dumpFile = new File(\"Myheapdump.hprof\");\n+        createDump(dumpFile, args);\n+        verifyDump(dumpFile);\n+    }\n+\n+    private static void createDump(File dumpFile, String[] extraOptions) throws Exception {\n+        LingeredApp theApp = null;\n+        try {\n+            theApp = new FieldsInInstanceTarg();\n+\n+            List<String> extraVMArgs = new ArrayList<>();\n+            extraVMArgs.addAll(Arrays.asList(extraOptions));\n+            LingeredApp.startApp(theApp, extraVMArgs.toArray(new String[0]));\n+\n+            \/\/jcmd <pid> GC.heap_dump <file_path>\n+            JDKToolLauncher launcher = JDKToolLauncher\n+                    .createUsingTestJDK(\"jcmd\")\n+                    .addToolArg(Long.toString(theApp.getPid()))\n+                    .addToolArg(\"GC.heap_dump\")\n+                    .addToolArg(dumpFile.getAbsolutePath());\n+            Process p = ProcessTools.startProcess(\"jcmd\", new ProcessBuilder(launcher.getCommand()));\n+            \/\/ If something goes wrong with heap dumping most likely we'll get crash of the target VM.\n+            while (!p.waitFor(5, TimeUnit.SECONDS)) {\n+                if (!theApp.getProcess().isAlive()) {\n+                    log(\"ERROR: target VM died, killing jcmd...\");\n+                    p.destroyForcibly();\n+                    throw new Exception(\"Target VM died\");\n+                }\n+            }\n+\n+            if (p.exitValue() != 0) {\n+                throw new Exception(\"Jcmd exited with code \" + p.exitValue());\n+            }\n+        } finally {\n+            LingeredApp.stopApp(theApp);\n+        }\n+    }\n+\n+    private static void verifyDump(File dumpFile) throws Exception {\n+        Asserts.assertTrue(dumpFile.exists(), \"Heap dump file not found.\");\n+\n+        log(\"Reading \" + dumpFile + \"...\");\n+        try (Snapshot snapshot = Reader.readFile(dumpFile.getPath(), true, 0)) {\n+            log(\"Resolving snapshot...\");\n+            snapshot.resolve(true);\n+            log(\"Snapshot resolved.\");\n+\n+            List<JavaThing> bFields = getFields(snapshot, FieldsInInstanceTarg.B.class);\n+            \/\/ B has 2 instance fields, A has 2 instance fields\n+            Asserts.assertEquals(bFields.size(), 4);\n+            \/\/ JavaObject reverses the order of fields, so fields of B are at the end.\n+            \/\/ Order is only specified for supertypes, so we check if values are *anywhere* in their range\n+            \/\/ by using the toString output.\n+            String asString = bFields.subList(2, 4).toString();\n+            Asserts.assertTrue(asString.contains(\"0.5\"), \"value for field B.s not found\");\n+            Asserts.assertTrue(asString.contains(\"7\"), \"value for field B.a not found\");\n+            asString = bFields.subList(0, 2).toString();\n+            Asserts.assertTrue(asString.contains(\"3\"), \"value for field A.a not found\");\n+            Asserts.assertTrue(asString.contains(\"Field\"), \"value for field A.s not found\");\n+\n+            Asserts.assertEquals(getFields(snapshot, FieldsInInstanceTarg.NoFields2.class).size(), 0);\n+\n+            Asserts.assertEquals(getFields(snapshot, FieldsInInstanceTarg.NoParentFields.class).size(), 2);\n+\n+            Asserts.assertEquals(getFields(snapshot, FieldsInInstanceTarg.OnlyParentFields.class).size(), 1);\n+\n+            Asserts.assertEquals(getFields(snapshot, FieldsInInstanceTarg.DirectParentNoFields.class).size(), 2);\n+        }\n+    }\n+\n+    private static List<JavaThing> getFields(Snapshot snapshot, Class<?> clazz) {\n+        JavaObject javaObject = (JavaObject) snapshot.findClass(clazz.getName()).getInstances(false).nextElement();\n+        List<JavaThing> fields = Arrays.asList(javaObject.getFields());\n+        log(\"Fields for \" + clazz + \" (including superclasses): \" + fields);\n+        return fields;\n+    }\n+\n+    private static void log(Object s) {\n+        System.out.println(s);\n+    }\n+\n+}\n\\ No newline at end of file\n","filename":"test\/hotspot\/jtreg\/serviceability\/HeapDump\/FieldsInInstanceTest.java","additions":190,"deletions":0,"binary":false,"changes":190,"status":"added"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Red Hat, Inc. and\/or its affiliates.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.dcmd.PidJcmdExecutor;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+import java.util.Iterator;\n+\n+\/*\n+ * @test CompilerMemoryStatisticTest\n+ * @summary Test Compiler.memory\n+ * @requires vm.compiler1.enabled\n+ * @requires vm.compiler2.enabled\n+ *\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @run main\/othervm -XX:CompileCommand=memstat,*.* CompilerMemoryStatisticTest\n+ *\/\n+\n+\/*\n+ * @test CompilerMemoryStatisticTest\n+ * @summary Test Compiler.memory\n+ * @requires vm.compiler1.enabled\n+ * @requires vm.compiler2.enabled\n+ *\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @run main\/othervm -XX:CompileCommand=memstat,*.*,collect CompilerMemoryStatisticTest\n+ *\/\n+\n+public class CompilerMemoryStatisticTest {\n+\n+    public static void main(String args[]) throws Exception {\n+        PidJcmdExecutor executor = new PidJcmdExecutor();\n+        OutputAnalyzer out = executor.execute(\"Compiler.memory\");\n+        out.shouldHaveExitValue(0);\n+\n+        \/\/ Looks like this:\n+        \/\/ total     NA        RA        #nodes  time    type  #rc thread              method\n+        \/\/ 621832    0         589104    0       0,025   c1    1   0x00007f5ccc1951a0  java\/util\/zip\/ZipFile$Source.checkAndAddEntry((II)I)\n+        out.shouldMatch(\"total.*method\");\n+        out.shouldMatch(\"\\\\d+ +\\\\d+ +\\\\d+ +\\\\d+.*java.*\\\\(.*\\\\)\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/compiler\/CompilerMemoryStatisticTest.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -0,0 +1,300 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.File;\n+import java.lang.ref.Reference;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.JDKToolLauncher;\n+import jdk.test.lib.apps.LingeredApp;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import jdk.test.lib.hprof.model.JavaClass;\n+import jdk.test.lib.hprof.model.JavaHeapObject;\n+import jdk.test.lib.hprof.model.Root;\n+import jdk.test.lib.hprof.model.Snapshot;\n+import jdk.test.lib.hprof.model.StackFrame;\n+import jdk.test.lib.hprof.model.StackTrace;\n+import jdk.test.lib.hprof.model.ThreadObject;\n+import jdk.test.lib.hprof.parser.Reader;\n+\n+\/**\n+ * @test id=default\n+ * @requires vm.jvmti\n+ * @requires vm.continuations\n+ * @library \/test\/lib\n+ * @run main VThreadInHeapDump\n+ *\/\n+\n+\/**\n+ * @test id=no-vmcontinuations\n+ * @requires vm.jvmti\n+ * @library \/test\/lib\n+ * @comment pass extra VM arguments as the test arguments\n+ * @run main VThreadInHeapDump\n+ *           -XX:+UnlockExperimentalVMOptions -XX:-VMContinuations\n+ *\/\n+\n+class VThreadInHeapDumpTarg extends LingeredApp {\n+\n+    public static class VThreadUnmountedReferenced {\n+    }\n+    public static class VThreadMountedReferenced {\n+    }\n+    public static class PThreadReferenced {\n+    }\n+\n+    public class ThreadBase {\n+        private volatile boolean threadReady = false;\n+\n+        protected void ready() {\n+            threadReady = true;\n+        }\n+\n+        public void waitReady() {\n+            while (!threadReady) {\n+                try {\n+                    Thread.sleep(10);\n+                } catch (InterruptedException e) {\n+                }\n+            }\n+        }\n+    }\n+\n+    public class VthreadUnmounted extends ThreadBase implements Runnable {\n+        public void run() {\n+            Object referenced = new VThreadUnmountedReferenced();\n+            ready();\n+            \/\/ The thread will be unmounted in awaitToStop().\n+            awaitToStop();\n+            Reference.reachabilityFence(referenced);\n+        }\n+    }\n+\n+    public class VthreadMounted extends ThreadBase implements Runnable {\n+        int dummy = -1;\n+\n+        public void run() {\n+            Object referenced = new VThreadMountedReferenced();\n+            ready();\n+            \/\/ Don't give a chance for the thread to unmount.\n+            while (!timeToStop) {\n+                if (++dummy == 10000) {\n+                    dummy = 0;\n+                }\n+            }\n+            Reference.reachabilityFence(referenced);\n+        }\n+    }\n+\n+    public class Pthread extends ThreadBase implements Runnable {\n+        public void run() {\n+            Object referenced = new PThreadReferenced();\n+            ready();\n+            awaitToStop();\n+            Reference.reachabilityFence(referenced);\n+        }\n+    }\n+\n+    CountDownLatch timeToStopLatch = new CountDownLatch(1);\n+    volatile boolean timeToStop = false;\n+\n+    void awaitToStop() {\n+        try {\n+            timeToStopLatch.await();\n+        } catch (InterruptedException e) {\n+        }\n+    }\n+\n+    private void runTest(String[] args) {\n+        try {\n+            \/\/ Unmounted virtual thread.\n+            VthreadUnmounted vthreadUnmounted = new VthreadUnmounted();\n+            Thread.ofVirtual().start(vthreadUnmounted);\n+            vthreadUnmounted.waitReady();\n+\n+            \/\/ Mounted virtual thread.\n+            VthreadMounted vthreadMounted = new VthreadMounted();\n+            Thread.ofVirtual().start(vthreadMounted);\n+            vthreadMounted.waitReady();\n+\n+            \/\/ Platform thread.\n+            Pthread pthread = new Pthread();\n+            Thread.ofPlatform().start(pthread);\n+            pthread.waitReady();\n+\n+            \/\/ We are ready.\n+            LingeredApp.main(args);\n+\n+        } finally {\n+            \/\/ Signal all threads to finish.\n+            timeToStop = true;\n+            timeToStopLatch.countDown();\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        VThreadInHeapDumpTarg test = new VThreadInHeapDumpTarg();\n+        test.runTest(args);\n+    }\n+\n+}\n+\n+\n+public class VThreadInHeapDump {\n+\n+    \/\/ test arguments are extra VM options for target process\n+    public static void main(String[] args) throws Exception {\n+        File dumpFile = new File(\"Myheapdump.hprof\");\n+        createDump(dumpFile, args);\n+        verifyDump(dumpFile);\n+    }\n+\n+    private static void createDump(File dumpFile, String[] extraOptions) throws Exception {\n+        LingeredApp theApp = null;\n+        try {\n+            theApp = new VThreadInHeapDumpTarg();\n+\n+            List<String> extraVMArgs = new ArrayList<>();\n+            extraVMArgs.add(\"-Djdk.virtualThreadScheduler.parallelism=1\");\n+            extraVMArgs.addAll(Arrays.asList(extraOptions));\n+            LingeredApp.startApp(theApp, extraVMArgs.toArray(new String[0]));\n+\n+            \/\/jcmd <pid> GC.heap_dump <file_path>\n+            JDKToolLauncher launcher = JDKToolLauncher\n+                    .createUsingTestJDK(\"jcmd\")\n+                    .addToolArg(Long.toString(theApp.getPid()))\n+                    .addToolArg(\"GC.heap_dump\")\n+                    .addToolArg(dumpFile.getAbsolutePath());\n+            Process p = ProcessTools.startProcess(\"jcmd\", new ProcessBuilder(launcher.getCommand()));\n+            \/\/ If something goes wrong with heap dumping most likely we'll get crash of the target VM.\n+            while (!p.waitFor(5, TimeUnit.SECONDS)) {\n+                if (!theApp.getProcess().isAlive()) {\n+                    log(\"ERROR: target VM died, killing jcmd...\");\n+                    p.destroyForcibly();\n+                    throw new Exception(\"Target VM died\");\n+                }\n+            }\n+\n+            if (p.exitValue() != 0) {\n+                throw new Exception(\"Jcmd exited with code \" + p.exitValue());\n+            }\n+        } finally {\n+            LingeredApp.stopApp(theApp);\n+        }\n+    }\n+\n+    private static void verifyDump(File dumpFile) throws Exception {\n+        Asserts.assertTrue(dumpFile.exists(), \"Heap dump file not found.\");\n+\n+        log(\"Reading \" + dumpFile + \"...\");\n+        try (Snapshot snapshot = Reader.readFile(dumpFile.getPath(), true, 0)) {\n+            log(\"Resolving snapshot...\");\n+            snapshot.resolve(true);\n+            log(\"Snapshot resolved.\");\n+\n+            \/\/ Log all threads with stack traces and stack references.\n+            List<ThreadObject> threads = snapshot.getThreads();\n+            List<Root> roots = Collections.list(snapshot.getRoots());\n+            log(\"Threads:\");\n+            for (ThreadObject thread: threads) {\n+                StackTrace st = thread.getStackTrace();\n+                StackFrame[] frames = st.getFrames();\n+                log(\"thread \" + thread.getIdString() + \", \" + frames.length + \" frames\");\n+\n+                List<Root> stackRoots = findStackRoot(roots, thread);\n+                for (int i = 0; i < frames.length; i++) {\n+                    log(\"  - [\" + i + \"] \"\n+                        + frames[i].getClassName() + \".\" + frames[i].getMethodName()\n+                        + frames[i].getMethodSignature()\n+                        + \" (\" + frames[i].getSourceFileName()\n+                        + \":\" + frames[i].getLineNumber() + \")\");\n+\n+                    for (Root r: stackRoots) {\n+                        StackFrame[] rootFrames = r.getStackTrace().getFrames();\n+                        \/\/ the frame this local belongs to\n+                        StackFrame frame = rootFrames[rootFrames.length - 1];\n+                        if (frame == frames[i]) {\n+                            JavaHeapObject obj = snapshot.findThing(r.getId());\n+                            JavaClass objClass = obj.getClazz();\n+                            log(\"      \" + r.getDescription() + \": \" + objClass.getName());\n+                        }\n+                    }\n+                }\n+            }\n+\n+            \/\/ Verify objects from thread stacks are dumped.\n+            test(snapshot, VThreadInHeapDumpTarg.VThreadMountedReferenced.class);\n+            test(snapshot, VThreadInHeapDumpTarg.PThreadReferenced.class);\n+            \/\/ Dumping of unmounted vthreads is not implemented yet\n+            \/\/test(snapshot, VThreadInHeapDumpTarg.VThreadUnmountedReferenced.class);\n+        }\n+\n+    }\n+\n+    private static List<Root> findStackRoot(List<Root> roots, ThreadObject thread) {\n+        List<Root> result = new ArrayList<>();\n+        for (Root root: roots) {\n+            if (root.getReferrerId() == thread.getId()) {\n+                result.add(root);\n+            }\n+        }\n+        return result;\n+    }\n+\n+    private static void test(Snapshot snapshot, String className) {\n+        log(\"Testing \" + className + \"...\");\n+        JavaClass jClass = snapshot.findClass(className);\n+        if (jClass == null) {\n+            throw new RuntimeException(\"'\" + className + \"' not found\");\n+        }\n+        int instanceCount = jClass.getInstancesCount(false);\n+        if (instanceCount != 1) {\n+            throw new RuntimeException(\"Expected 1 instance, \" + instanceCount + \" instances found\");\n+        }\n+        \/\/ There is the only instance.\n+        JavaHeapObject heapObj = jClass.getInstances(false).nextElement();\n+\n+        Root root = heapObj.getRoot();\n+        if (root == null) {\n+            throw new RuntimeException(\"No root for \" + className + \" instance\");\n+        }\n+        log(\"  root: \" + root.getDescription());\n+        JavaHeapObject referrer = root.getReferrer();\n+        log(\"  referrer: \" + referrer);\n+    }\n+\n+    private static void test(Snapshot snapshot, Class cls) {\n+        test(snapshot, cls.getName());\n+    }\n+\n+    private static void log(Object s) {\n+        System.out.println(s);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/HeapDump\/VThreadInHeapDump.java","additions":300,"deletions":0,"binary":false,"changes":300,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,9 @@\n+import java.io.InputStream;\n+import java.util.List;\n+import java.util.ArrayList;\n+\n+import jdk.internal.org.objectweb.asm.ClassReader;\n+import jdk.internal.org.objectweb.asm.ClassVisitor;\n+import jdk.internal.org.objectweb.asm.FieldVisitor;\n+import jdk.internal.org.objectweb.asm.Opcodes;\n+\n@@ -43,1 +52,1 @@\n-    native static void check(int i, Class cls);\n+    native static void check(Class cls, String[] expectedFields);\n@@ -55,11 +64,11 @@\n-            check(0, Class.forName(InnerClass1.class.getName()));\n-            check(1, Class.forName(InnerInterface.class.getName()));\n-            check(2, Class.forName(InnerClass2.class.getName()));\n-            check(3, Class.forName(OuterClass1.class.getName()));\n-            check(4, Class.forName(OuterClass2.class.getName()));\n-            check(5, Class.forName(OuterClass3.class.getName()));\n-            check(6, Class.forName(OuterInterface1.class.getName()));\n-            check(7, Class.forName(OuterInterface2.class.getName()));\n-            check(8, Class.forName(OuterClass4.class.getName()));\n-            check(9, Class.forName(OuterClass5.class.getName()));\n-        } catch (ClassNotFoundException e) {\n+            check(Class.forName(InnerClass1.class.getName()));\n+            check(Class.forName(InnerInterface.class.getName()));\n+            check(Class.forName(InnerClass2.class.getName()));\n+            check(Class.forName(OuterClass1.class.getName()));\n+            check(Class.forName(OuterClass2.class.getName()));\n+            check(Class.forName(OuterClass3.class.getName()));\n+            check(Class.forName(OuterInterface1.class.getName()));\n+            check(Class.forName(OuterInterface2.class.getName()));\n+            check(Class.forName(OuterClass4.class.getName()));\n+            check(Class.forName(OuterClass5.class.getName()));\n+        } catch (Exception e) {\n@@ -71,0 +80,42 @@\n+\n+    static void check(Class cls) throws Exception {\n+        FieldExplorer explorer = new FieldExplorer(cls);\n+        List<String> fields = explorer.get();\n+        check(cls, fields.toArray(new String[0]));\n+    }\n+\n+    \/\/ helper class to get list of the class fields\n+    \/\/ in the order they appear in the class file\n+    static class FieldExplorer extends ClassVisitor {\n+        private final Class cls;\n+        private List<String> fieldNameAndSig = new ArrayList<>();\n+        private FieldExplorer(Class cls) {\n+            super(Opcodes.ASM7);\n+            this.cls = cls;\n+        }\n+\n+        @Override\n+        public FieldVisitor visitField(int access, String name, String descriptor, String signature, Object value) {\n+            System.out.println(\"  field '\" + name + \"', type = \" + descriptor);\n+            fieldNameAndSig.add(name);\n+            fieldNameAndSig.add(descriptor);\n+            return super.visitField(access, name, descriptor, signature, value);\n+        }\n+\n+        private InputStream getClassBytes() throws Exception {\n+            String clsName = cls.getName();\n+            String clsPath = clsName.replace('.', '\/') + \".class\";\n+            return cls.getClassLoader().getResourceAsStream(clsPath);\n+        }\n+\n+        \/\/ each field is represented by 2 Strings in the list: name and type descriptor\n+        public List<String> get() throws Exception {\n+            System.out.println(\"Class \" + cls.getName());\n+            try (InputStream classBytes = getClassBytes()) {\n+                ClassReader classReader = new ClassReader(classBytes);\n+                classReader.accept(this, 0);\n+            }\n+            return fieldNameAndSig;\n+        }\n+    }\n+\n@@ -122,0 +173,1 @@\n+\/\/ class with multiple fields to verify correctness of the field order\n@@ -124,0 +176,4 @@\n+    String fld_s1 = \"str\";\n+    int fld_i2 = 2;\n+    String fld_s2 = \"str2\";\n+\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetClassFields\/getclfld007.java","additions":69,"deletions":13,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,3 +34,3 @@\n- *     The test checks if the function returns the expected list of fields.\n- *     That is the field list contains only directly declared (not inherited)\n- *     fields.\n+ *     The test checks if the function returns the expected list of fields:\n+ *         - the list contains only directly declared (not inherited) fields;\n+ *         - fields are returned in the order they occur in the class file.\n@@ -48,0 +48,1 @@\n+ * @modules java.base\/jdk.internal.org.objectweb.asm\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetClassFields\/getclfld007\/TestDescription.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,11 +36,0 @@\n-typedef struct {\n-    const char *name;\n-    const char *sig;\n-} fld_info;\n-\n-typedef struct {\n-    const char *name;\n-    jint fcount;\n-    fld_info *flds;\n-} class_info;\n-\n@@ -49,50 +38,17 @@\n-static jboolean printdump = JNI_FALSE;\n-\n-static fld_info f0[] = {\n-    { \"fld_1\", \"Ljava\/lang\/String;\" }\n-};\n-\n-static fld_info f1[] = {\n-    { \"fld_n1\", \"I\" }\n-};\n-\n-static fld_info f2[] = {\n-    { \"fld_n2\", \"I\" }\n-};\n-\n-static fld_info f4[] = {\n-    { \"fld_o2\", \"I\" }\n-};\n-\n-static fld_info f5[] = {\n-    { \"fld_o3\", \"I\" }\n-};\n-\n-static fld_info f6[] = {\n-    { \"fld_i1\", \"I\" }\n-};\n-\n-static fld_info f7[] = {\n-    { \"fld_i2\", \"I\" }\n-};\n-\n-static fld_info f8[] = {\n-    { \"fld_i2\", \"I\" }\n-};\n-\n-static fld_info f9[] = {\n-    { \"fld_i1\", \"I\" }\n-};\n-\n-static class_info classes[] = {\n-    { \"InnerClass1\", 1, f0 },\n-    { \"InnerInterface\", 1, f1 },\n-    { \"InnerClass2\", 1, f2 },\n-    { \"OuterClass1\", 0, NULL },\n-    { \"OuterClass2\", 1, f4 },\n-    { \"OuterClass3\", 1, f5 },\n-    { \"OuterInterface1\", 1, f6 },\n-    { \"OuterInterface2\", 1, f7 },\n-    { \"OuterClass4\", 1, f8 },\n-    { \"OuterClass5\", 1, f9 }\n-};\n+\n+\n+\/\/ compares 'value' with jobject_arr[index]\n+static bool equals_str(JNIEnv *env, const char *value, jobjectArray jobject_arr, jint index) {\n+    jstring jstr = (jstring)env->GetObjectArrayElement(jobject_arr, index);\n+    const char* utf = env->GetStringUTFChars(jstr, NULL);\n+    bool res = false;\n+    if (utf != NULL) {\n+        res = strcmp(value, utf) == 0;\n+        env->ReleaseStringUTFChars(jstr, utf);\n+    } else {\n+        printf(\"GetStringUTFChars failed\\n\");\n+        result = STATUS_FAILED;\n+    }\n+    env->DeleteLocalRef(jstr);\n+    return res;\n+}\n@@ -114,4 +70,0 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n-        printdump = JNI_TRUE;\n-    }\n-\n@@ -128,1 +80,1 @@\n-Java_nsk_jvmti_GetClassFields_getclfld007_check(JNIEnv *env, jclass cls, jint i, jclass clazz) {\n+Java_nsk_jvmti_GetClassFields_getclfld007_check(JNIEnv *env, jclass cls, jclass clazz, jobjectArray fieldArr) {\n@@ -132,1 +84,1 @@\n-    char *name, *sig, *generic;\n+    char *name, *sig;\n@@ -137,0 +89,1 @@\n+        fflush(0);\n@@ -141,3 +94,2 @@\n-    if (printdump == JNI_TRUE) {\n-        printf(\">>> %s:\\n\", classes[i].name);\n-    }\n+    \/\/ fieldArr contains 2 elements for each field\n+    jint field_count = env->GetArrayLength(fieldArr) \/ 2;\n@@ -147,2 +99,3 @@\n-        printf(\"(GetClassFields#%d) unexpected error: %s (%d)\\n\",\n-               i, TranslateError(err), err);\n+        printf(\"GetClassFields unexpected error: %s (%d)\\n\",\n+               TranslateError(err), err);\n+        fflush(0);\n@@ -153,3 +106,3 @@\n-    if (fcount != classes[i].fcount) {\n-        printf(\"(%d) wrong number of fields: %d, expected: %d\\n\",\n-               i, fcount, classes[i].fcount);\n+    if (fcount != field_count) {\n+        printf(\"wrong number of fields: %d, expected: %d\\n\",\n+               fcount, field_count);\n@@ -160,21 +113,18 @@\n-            printf(\"(%d:%d) fieldID = null\\n\", i, j);\n-        } else {\n-            err = jvmti->GetFieldName(clazz, fields[j],\n-                &name, &sig, &generic);\n-            if (err != JVMTI_ERROR_NONE) {\n-                printf(\"(GetFieldName#%d:%d) unexpected error: %s (%d)\\n\",\n-                       i, j, TranslateError(err), err);\n-            } else {\n-                if (printdump == JNI_TRUE) {\n-                    printf(\">>>   [%d]: %s, sig = \\\"%s\\\"\\n\", j, name, sig);\n-                }\n-                if ((j < classes[i].fcount) &&\n-                       (name == NULL || sig == NULL ||\n-                        strcmp(name, classes[i].flds[j].name) != 0 ||\n-                        strcmp(sig, classes[i].flds[j].sig) != 0)) {\n-                    printf(\"(%d:%d) wrong field: \\\"%s%s\\\"\", i, j, name, sig);\n-                    printf(\", expected: \\\"%s%s\\\"\\n\",\n-                           classes[i].flds[j].name, classes[i].flds[j].sig);\n-                    result = STATUS_FAILED;\n-                }\n-            }\n+            printf(\"(%d) fieldID = null\\n\", j);\n+            result = STATUS_FAILED;\n+            continue;\n+        }\n+        err = jvmti->GetFieldName(clazz, fields[j], &name, &sig, NULL);\n+        if (err != JVMTI_ERROR_NONE) {\n+            printf(\"(GetFieldName#%d) unexpected error: %s (%d)\\n\",\n+                   j, TranslateError(err), err);\n+            result = STATUS_FAILED;\n+            continue;\n+        }\n+        printf(\">>>   [%d]: %s, sig = \\\"%s\\\"\\n\", j, name, sig);\n+        if ((j < field_count) &&\n+               (name == NULL || sig == NULL ||\n+                !equals_str(env, name, fieldArr, j * 2) ||\n+                !equals_str(env, sig, fieldArr, j * 2 + 1))) {\n+            printf(\"(%d) wrong field: \\\"%s%s\\\"\", j, name, sig);\n+            result = STATUS_FAILED;\n@@ -182,0 +132,2 @@\n+        jvmti->Deallocate((unsigned char *)name);\n+        jvmti->Deallocate((unsigned char *)sig);\n@@ -183,0 +135,1 @@\n+    fflush(0);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetClassFields\/getclfld007\/getclfld007.cpp","additions":50,"deletions":97,"binary":false,"changes":147,"status":"modified"},{"patch":"@@ -520,1 +520,3 @@\n-            return null;\n+            e.printStackTrace(logger.getOutStream());\n+            throw new Failure(\"Caught EOFException while reading an object from \" + name + \" connection.\"\n+                    + \" Check if debuggee process exited prematurely (crashed or killed).\\n\\t\");\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jpda\/SocketConnection.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,24 +0,0 @@\n-#\n-# Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/jni\/TEST.properties","additions":0,"deletions":24,"binary":false,"changes":24,"status":"deleted"},{"patch":"@@ -1,24 +0,0 @@\n-#\n-# Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/thread\/TEST.properties","additions":0,"deletions":24,"binary":false,"changes":24,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/gc\/concurrent\/lp30yp0rp0mr30st300\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/gc\/concurrent\/lp30yp0rp0mr70st300t1\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/gc\/concurrent\/lp30yp0rp30mr0st300\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/gc\/concurrent\/lp30yp0rp30mr30st0t1\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/gc\/concurrent\/lp30yp0rp30mr70st0\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/gc\/concurrent\/lp30yp0rp30mr70st300t1\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/gc\/concurrent\/lp30yp0rp70mr30st0\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/gc\/concurrent\/lp30yp0rp70mr30st300t1\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/gc\/concurrent\/lp30yp10rp0mr30st300\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/gc\/concurrent\/lp30yp10rp0mr70st300t1\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/gc\/concurrent\/lp30yp10rp30mr0st300\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/gc\/concurrent\/lp30yp10rp30mr30st0t1\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/gc\/concurrent\/lp30yp10rp30mr70st0\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/gc\/concurrent\/lp30yp10rp30mr70st300t1\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/gc\/concurrent\/lp30yp10rp70mr30st0\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/gc\/concurrent\/lp30yp10rp70mr30st300t1\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/gc\/concurrent\/lp30yp25rp0mr30st300\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/gc\/concurrent\/lp30yp25rp0mr70st300t1\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/gc\/concurrent\/lp30yp25rp30mr0st300\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/gc\/concurrent\/lp30yp25rp30mr30st0t1\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/gc\/concurrent\/lp30yp25rp30mr70st0\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/gc\/concurrent\/lp30yp25rp30mr70st300t1\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/gc\/concurrent\/lp30yp25rp70mr30st0\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/gc\/concurrent\/lp30yp25rp70mr30st300t1\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/gc\/concurrent\/lp50yp0rp0mr30st300\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/gc\/concurrent\/lp50yp0rp0mr70st300t1\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/gc\/concurrent\/lp50yp0rp30mr0st300\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/gc\/concurrent\/lp50yp0rp30mr30st0t1\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/gc\/concurrent\/lp50yp0rp30mr70st0\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/gc\/concurrent\/lp50yp0rp30mr70st300t1\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/gc\/concurrent\/lp50yp0rp70mr30st0\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/gc\/concurrent\/lp50yp0rp70mr30st300t1\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/gc\/concurrent\/lp50yp10rp0mr30st300\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/gc\/concurrent\/lp50yp10rp0mr70st300t1\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/gc\/concurrent\/lp50yp10rp30mr0st300\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/gc\/concurrent\/lp50yp10rp30mr30st0t1\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/gc\/concurrent\/lp50yp10rp30mr70st0\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/gc\/concurrent\/lp50yp10rp30mr70st300t1\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/gc\/concurrent\/lp50yp10rp70mr30st0\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/gc\/concurrent\/lp50yp10rp70mr30st300t1\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/gc\/concurrent\/lp60yp0rp30mr0st300\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -42,0 +42,1 @@\n+java\/nio\/channels\/vthread\/BlockingChannelOps.java#direct-register 8315544 windows-x64\n","filename":"test\/jdk\/ProblemList-generational-zgc.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -381,1 +381,1 @@\n-java\/awt\/Mouse\/MouseModifiersUnitTest\/MouseModifiersUnitTest_Standard.java 7124407 macosx-all\n+java\/awt\/Mouse\/MouseModifiersUnitTest\/MouseModifiersUnitTest_Standard.java 7124407,8302787  macosx-all,windows-all\n@@ -445,1 +445,1 @@\n-java\/awt\/PopupMenu\/PopupMenuLocation.java 8238720,8315878 windows-all,macosx-aarch64\n+java\/awt\/PopupMenu\/PopupMenuLocation.java 8259913,8315878 windows-all,macosx-aarch64\n@@ -459,0 +459,2 @@\n+java\/awt\/KeyboardFocusmanager\/ConsumeNextMnemonicKeyTypedTest\/ConsumeForModalDialogTest\/ConsumeForModalDialogTest.java 8302787 windows-all\n+java\/awt\/KeyboardFocusmanager\/TypeAhead\/MenuItemActivatedTest\/MenuItemActivatedTest.java 8302787 windows-all\n@@ -463,1 +465,0 @@\n-java\/awt\/GraphicsDevice\/CheckDisplayModes.java 8266242 macosx-aarch64\n@@ -557,0 +558,2 @@\n+java\/net\/Socket\/asyncClose\/Race.java                            8317801 aix-ppc64\n+\n@@ -563,0 +566,2 @@\n+java\/nio\/channels\/Channels\/SocketChannelStreams.java            8317838 aix-ppc64\n+\n@@ -620,6 +625,6 @@\n-sun\/security\/tools\/keytool\/NssTest.java                         8295343 linux-all\n-sun\/security\/pkcs11\/Signature\/TestRSAKeyLength.java             8295343 linux-all\n-sun\/security\/pkcs11\/rsa\/TestSignatures.java                     8295343 linux-all\n-sun\/security\/pkcs11\/rsa\/TestKeyPairGenerator.java               8295343 linux-all\n-sun\/security\/pkcs11\/rsa\/TestKeyFactory.java                     8295343 linux-all\n-sun\/security\/pkcs11\/KeyStore\/Basic.java                         8295343 linux-all\n+sun\/security\/tools\/keytool\/NssTest.java                         8295343 generic-all\n+sun\/security\/pkcs11\/Signature\/TestRSAKeyLength.java             8295343 generic-all\n+sun\/security\/pkcs11\/rsa\/TestSignatures.java                     8295343 generic-all\n+sun\/security\/pkcs11\/rsa\/TestKeyPairGenerator.java               8295343 generic-all\n+sun\/security\/pkcs11\/rsa\/TestKeyFactory.java                     8295343 generic-all\n+sun\/security\/pkcs11\/KeyStore\/Basic.java                         8295343 generic-all\n@@ -722,2 +727,0 @@\n-java\/util\/Locale\/LocaleProvidersRun.java                        8268379 macosx-x64\n-sun\/util\/locale\/provider\/CalendarDataRegression.java            8268379 macosx-x64\n@@ -758,1 +761,1 @@\n-jdk\/jfr\/api\/consumer\/recordingstream\/TestOnEvent.java           8255404 linux-x64\n+jdk\/jfr\/api\/consumer\/recordingstream\/TestOnEvent.java           8255404 linux-x64,linux-aarch64\n","filename":"test\/jdk\/ProblemList.txt","additions":15,"deletions":12,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8318328\n+ * @summary DHKEM should check XDH name in case-insensitive mode\n+ * @library \/test\/lib\n+ * @modules java.base\/com.sun.crypto.provider\n+ *\/\n+import javax.crypto.KEM;\n+import java.math.BigInteger;\n+import java.security.KeyPairGenerator;\n+import java.security.interfaces.XECPublicKey;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.NamedParameterSpec;\n+\n+public class NameSensitiveness {\n+    public static void main(String[] args) throws Exception {\n+        var g = KeyPairGenerator.getInstance(\"XDH\");\n+        g.initialize(NamedParameterSpec.X25519);\n+        var pk1 = (XECPublicKey) g.generateKeyPair().getPublic();\n+        var pk2 = new XECPublicKey() {\n+            public BigInteger getU() {\n+                return pk1.getU();\n+            }\n+            public AlgorithmParameterSpec getParams() {\n+                return new NamedParameterSpec(\"x25519\"); \/\/ lowercase!!!\n+            }\n+            public String getAlgorithm() {\n+                return pk1.getAlgorithm();\n+            }\n+            public String getFormat() {\n+                return pk1.getFormat();\n+            }\n+            public byte[] getEncoded() {\n+                return pk1.getEncoded();\n+            }\n+        };\n+        var kem = KEM.getInstance(\"DHKEM\");\n+        kem.newEncapsulator(pk2);\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/DHKEM\/NameSensitiveness.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,157 @@\n+\/*\n+ * Copyright (c) 2023 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import com.sun.jdi.Bootstrap;\n+import com.sun.jdi.VirtualMachine;\n+import com.sun.jdi.connect.AttachingConnector;\n+import com.sun.jdi.connect.Connector;\n+import com.sun.jdi.connect.IllegalConnectorArgumentsException;\n+import com.sun.jdi.event.EventIterator;\n+import com.sun.jdi.event.EventQueue;\n+import com.sun.jdi.event.EventSet;\n+import com.sun.jdi.event.Event;\n+import com.sun.jdi.event.ExceptionEvent;\n+import lib.jdb.Debuggee;\n+\n+import java.io.IOException;\n+import java.net.ServerSocket;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+\/*\n+ * @test\n+ * @bug 8317920\n+ * @summary Tests for JDWP agent to send valid exception event with onthrow option\n+ * @library \/test\/lib\n+ *\n+ * @build ThrowCaughtException JdwpOnThrowTest\n+ * @run main\/othervm JdwpOnThrowTest\n+ *\/\n+public class JdwpOnThrowTest {\n+\n+    private static long TIMEOUT = 10000;\n+\n+    private static String ATTACH_CONNECTOR = \"com.sun.jdi.SocketAttach\";\n+    \/\/ cache socket attaching connector\n+    private static AttachingConnector attachingConnector;\n+\n+    public static void main(String[] args) throws Exception {\n+        int port = findFreePort();\n+        try (Debuggee debuggee = Debuggee.launcher(\"ThrowCaughtException\").setAddress(\"localhost:\" + port)\n+                                         .enableOnThrow(\"Ex\", \"Start\").setSuspended(true).launch()) {\n+            VirtualMachine vm = null;\n+            try {\n+                vm = attach(\"localhost\", \"\" + port);\n+                EventQueue queue = vm.eventQueue();\n+                log(\"Waiting for exception event\");\n+                long start = System.currentTimeMillis();\n+                while (start + TIMEOUT > System.currentTimeMillis()) {\n+                    EventSet eventSet = queue.remove(TIMEOUT);\n+                    EventIterator eventIterator = eventSet.eventIterator();\n+                    while(eventIterator.hasNext() && start + TIMEOUT > System.currentTimeMillis()) {\n+                        Event event = eventIterator.next();\n+                        if (event instanceof ExceptionEvent ex) {\n+                            verifyExceptionEvent(ex);\n+                            log(\"Received exception event: \" + event);\n+                            vm.dispose();\n+                            return;\n+                        }\n+                        log(\"Received event: \" + event);\n+                    }\n+                }\n+                throw new RuntimeException(\"ERROR: failed to receive exception event\");\n+            } catch (IOException ex) {\n+                throw new RuntimeException(\"ERROR: failed to attach\", ex);\n+            }\n+        }\n+    }\n+\n+    private static void verifyExceptionEvent(ExceptionEvent ex) throws Exception {\n+        if (ex.exception() == null) {\n+            throw new RuntimeException(\"Exception is null\");\n+        }\n+        if (ex.exception().type() == null) {\n+            throw new RuntimeException(\"Exception type is null\");\n+        }\n+        if (ex.exception().referenceType() == null) {\n+            throw new RuntimeException(\"Exception reference type is null\");\n+        }\n+        if (ex.catchLocation() == null) {\n+            throw new RuntimeException(\"Exception catch location is null\");\n+        }\n+        if (!ex.location().equals(ex.thread().frame(0).location())) {\n+            throw new RuntimeException(\n+                String.format(\"Throw location %s and location of first frame %s are not equal\",\n+                                ex.location(), ex.thread().frame(0).location()));\n+        }\n+        if (!ex.exception().type().name().equals(\"Ex\")) {\n+            throw new RuntimeException(\"Exception has wrong type: \" + ex.exception().type().name());\n+        }\n+    }\n+\n+    private static int findFreePort() {\n+        try (ServerSocket socket = new ServerSocket(0)) {\n+            return socket.getLocalPort();\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static VirtualMachine attach(String address, String port) throws IOException {\n+        if (attachingConnector == null) {\n+            attachingConnector = (AttachingConnector)getConnector(ATTACH_CONNECTOR);\n+        }\n+        Map<String, Connector.Argument> args = attachingConnector.defaultArguments();\n+        setConnectorArg(args, \"hostname\", address);\n+        setConnectorArg(args, \"port\", port);\n+        try {\n+            return attachingConnector.attach(args);\n+        } catch (IllegalConnectorArgumentsException e) {\n+            \/\/ unexpected.. wrap in RuntimeException\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static Connector getConnector(String name) {\n+        for (Connector connector : Bootstrap.virtualMachineManager().allConnectors()) {\n+            if (connector.name().equalsIgnoreCase(name)) {\n+                return connector;\n+            }\n+        }\n+        throw new IllegalArgumentException(\"Connector \" + name + \" not found\");\n+    }\n+\n+    private static void setConnectorArg(Map<String, Connector.Argument> args, String name, String value) {\n+        Connector.Argument arg = args.get(name);\n+        if (arg == null) {\n+            throw new IllegalArgumentException(\"Argument \" + name + \" is not defined\");\n+        }\n+        arg.setValue(value);\n+    }\n+\n+    private static void log(Object o) {\n+        System.out.println(String.valueOf(o));\n+    }\n+\n+}\n","filename":"test\/jdk\/com\/sun\/jdi\/JdwpOnThrowTest.java","additions":157,"deletions":0,"binary":false,"changes":157,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2023 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+ public class ThrowCaughtException {\n+    public static void main(String args[]) throws Exception {\n+        try {\n+            System.out.println(\"Start\");\n+            throw new Ex();\n+        } catch (Exception e) {\n+            System.out.println(e);\n+        }\n+    }\n+}\n+\n+class Ex extends RuntimeException {\n+}\n","filename":"test\/jdk\/com\/sun\/jdi\/ThrowCaughtException.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -71,0 +71,3 @@\n+        private String onthrow = \"\";\n+        private boolean waitForPortPrint = true;\n+        private String expectedOutputBeforeThrow = \"\";\n@@ -103,0 +106,8 @@\n+        \/\/ required to pass non null port with address and emit string before the throw\n+        public Launcher enableOnThrow(String value, String expectedOutputBeforeThrow) {\n+            this.onthrow = value;\n+            this.waitForPortPrint = false;\n+            this.expectedOutputBeforeThrow = expectedOutputBeforeThrow;\n+            return this;\n+        }\n+\n@@ -108,0 +119,1 @@\n+            String onthrowArgs = onthrow.isEmpty() ? \"\" : \",onthrow=\" + onthrow + \",launch=exit\";\n@@ -110,1 +122,2 @@\n-                    + \",server=y,suspend=\" + (suspended ? \"y\" : \"n\"));\n+                    + \",server=y,suspend=\" + (suspended ? \"y\" : \"n\")\n+                    + onthrowArgs);\n@@ -117,1 +130,1 @@\n-            return new Debuggee(prepare(), name);\n+            return new Debuggee(prepare(), name, waitForPortPrint, expectedOutputBeforeThrow);\n@@ -125,1 +138,1 @@\n-    private Debuggee(ProcessBuilder pb, String name) {\n+    private Debuggee(ProcessBuilder pb, String name, boolean waitForPortPrint, String expectedOutputBeforeThrow) {\n@@ -127,0 +140,12 @@\n+        if (!waitForPortPrint) {\n+            try {\n+                p = ProcessTools.startProcess(name, pb, s -> {output.add(s);}, s -> {\n+                    return s.equals(expectedOutputBeforeThrow);\n+                }, 30, TimeUnit.SECONDS);\n+            } catch (IOException | InterruptedException | TimeoutException ex) {\n+                throw new RuntimeException(\"failed to launch debuggee\", ex);\n+            }\n+            transport = null;\n+            address = null;\n+            return;\n+        }\n@@ -170,0 +195,3 @@\n+        if (transport == null) {\n+            throw new IllegalStateException(\"transport is not available\");\n+        }\n@@ -174,0 +202,3 @@\n+        if (address == null) {\n+            throw new IllegalStateException(\"address is not available\");\n+        }\n","filename":"test\/jdk\/com\/sun\/jdi\/lib\/jdb\/Debuggee.java","additions":35,"deletions":4,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+                .screenCapture()\n","filename":"test\/jdk\/java\/awt\/Frame\/DefaultSizeTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n-import javax.swing.UIManager;\n@@ -57,0 +56,6 @@\n+        if (\"2\".equals(System.getProperty(\"jdk.gtk.version\"))\n+                && System.getenv(\"WAYLAND_DISPLAY\") != null) {\n+            \/\/ screen capture is not supported with gtk2 on Wayland\n+            return;\n+        }\n+\n","filename":"test\/jdk\/java\/awt\/Robot\/HiDPIScreenCapture\/ScreenCaptureGtkTest.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-  @run main RejectDragDropActionTest\n+  @run main\/timeout=300 RejectDragDropActionTest\n@@ -33,1 +33,0 @@\n-import java.awt.AWTException;\n@@ -49,1 +48,0 @@\n-import java.lang.reflect.InvocationTargetException;\n@@ -56,1 +54,1 @@\n-    private static final int FRAME_ACTIVATION_TIMEOUT = 3000;\n+    private static final int DELAY_TIME = 500;\n@@ -77,2 +75,1 @@\n-    public static void main(String[] args) throws InterruptedException,\n-            InvocationTargetException, AWTException {\n+    public static void main(String[] args) throws Exception {\n@@ -83,2 +80,4 @@\n-            dgr = ds.createDefaultDragGestureRecognizer(frame, DnDConstants.ACTION_COPY, dgl);\n-            frame.setBounds(100, 100, 200, 200);\n+            dgr = ds.createDefaultDragGestureRecognizer(frame,\n+                    DnDConstants.ACTION_COPY, dgl);\n+            frame.setSize(200, 200);\n+            frame.setLocationRelativeTo(null);\n@@ -90,0 +89,1 @@\n+            robot.setAutoWaitForIdle(true);\n@@ -91,1 +91,1 @@\n-            robot.delay(FRAME_ACTIVATION_TIMEOUT);\n+            robot.delay(DELAY_TIME);\n@@ -100,1 +100,2 @@\n-            for (Point p = new Point(startPoint); !p.equals(endPoint);\n+            for (Point p = new Point(startPoint);\n+                 !p.equals(endPoint) && !incorrectActionDetected;\n@@ -102,1 +103,1 @@\n-                         sign(endPoint.y - p.y))) {\n+                             sign(endPoint.y - p.y))) {\n@@ -104,1 +105,0 @@\n-                robot.delay(50);\n","filename":"test\/jdk\/java\/awt\/dnd\/RejectDragDropActionTest.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,132 @@\n+\/*\n+ * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.List;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.TextArea;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+import java.awt.event.MouseListener;\n+\n+\/*\n+ * @test\n+ * @key headful\n+ * @bug 4454304\n+ * @summary On Solaris, TextArea triggers MouseEntered when the mouse is inside the component\n+ * @run main MouseEnterExitTest\n+ *\/\n+public class MouseEnterExitTest {\n+\n+    private static Frame frame;\n+\n+    private volatile static boolean entered = false;\n+    private volatile static boolean exited = false;\n+    private volatile static boolean passed = true;\n+\n+    private volatile static Point compAt;\n+    private volatile static Dimension compSize;\n+\n+    private static final MouseListener mouseListener = new MouseAdapter() {\n+        @Override\n+        public void mouseEntered(MouseEvent e) {\n+            System.out.println(\n+                \"MouseEntered component \" + e.getSource().getClass().getName());\n+            if (entered) {\n+                passed = false;\n+            }\n+            entered = true;\n+            exited = false;\n+        }\n+\n+        @Override\n+        public void mouseExited(MouseEvent e) {\n+            System.out.println(\n+                \"MouseExited component \" + e.getSource().getClass().getName());\n+            if (exited) {\n+                passed = false;\n+            }\n+            entered = false;\n+            exited = true;\n+        }\n+    };\n+\n+    private static void initializeGUI() {\n+        frame = new Frame(\"MouseEnterExitTest\");\n+        frame.setLayout(new FlowLayout());\n+        List list = new List(4);\n+        for (int i = 0; i < 10; i++) {\n+            list.add(\"item \" + i);\n+        }\n+        list.addMouseListener(mouseListener);\n+        frame.add(list);\n+\n+        TextArea textArea = new TextArea(\"TextArea\", 10, 20);\n+        textArea.addMouseListener(mouseListener);\n+        frame.add(textArea);\n+\n+        frame.pack();\n+        frame.setLocationRelativeTo(null);\n+        frame.setVisible(true);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        try {\n+            Robot robot = new Robot();\n+            robot.setAutoDelay(100);\n+            robot.setAutoWaitForIdle(true);\n+\n+            EventQueue.invokeAndWait(MouseEnterExitTest::initializeGUI);\n+            robot.waitForIdle();\n+\n+            EventQueue.invokeAndWait(() -> {\n+                compAt = frame.getLocationOnScreen();\n+                compSize = frame.getSize();\n+            });\n+            compAt.y += compSize.getHeight() \/ 2;\n+            int xr = compAt.x + compSize.width + 1;\n+            for (int i = compAt.x - 5; (i < xr) && passed; i++) {\n+                robot.mouseMove(i, compAt.y);\n+            }\n+\n+            if (!passed || entered || !exited) {\n+                throw new RuntimeException(\n+                    \"MouseEnterExitTest FAILED. MouseEntered\/MouseExited \"\n+                        + \"not properly triggered. Please see the log\");\n+            }\n+            System.out.println(\"Test PASSED\");\n+        } finally {\n+            EventQueue.invokeAndWait(MouseEnterExitTest::disposeFrame);\n+        }\n+    }\n+\n+    private static void disposeFrame() {\n+        if (frame != null) {\n+            frame.dispose();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/event\/MouseEvent\/MouseEnterExitTest.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-   @author Anton Nashatyrev\n@@ -32,3 +31,9 @@\n-import javax.swing.*;\n-import java.awt.*;\n-import java.awt.event.*;\n+import java.awt.AWTEvent;\n+import java.awt.Dimension;\n+import java.awt.FlowLayout;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.Toolkit;\n+import java.awt.event.AWTEventListener;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n@@ -37,0 +42,4 @@\n+import javax.swing.JButton;\n+import javax.swing.JFrame;\n+import javax.swing.SwingUtilities;\n+\n@@ -47,0 +56,3 @@\n+    private volatile Point sLoc;\n+    private volatile Dimension bSize;\n+\n@@ -101,2 +113,5 @@\n-        Point sLoc = fb.getLocationOnScreen();\n-        Dimension bSize = fb.getSize();\n+        SwingUtilities.invokeAndWait(() -> {\n+            sLoc = fb.getLocationOnScreen();\n+            bSize = fb.getSize();\n+        });\n+\n@@ -104,1 +119,1 @@\n-        r.mousePress(MouseEvent.BUTTON1_MASK);\n+        r.mousePress(MouseEvent.BUTTON1_DOWN_MASK);\n@@ -122,1 +137,1 @@\n-        r.mouseRelease(MouseEvent.BUTTON1_MASK);\n+        r.mouseRelease(MouseEvent.BUTTON1_DOWN_MASK);\n","filename":"test\/jdk\/java\/awt\/event\/MouseWheelEvent\/WheelModifier\/WheelModifier.java","additions":24,"deletions":9,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.awt.Point;\n@@ -36,0 +37,2 @@\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n@@ -38,0 +41,1 @@\n+import java.awt.event.WindowListener;\n@@ -44,0 +48,1 @@\n+import java.util.Collection;\n@@ -45,0 +50,1 @@\n+import java.util.Objects;\n@@ -54,0 +60,1 @@\n+import javax.swing.JEditorPane;\n@@ -61,0 +68,3 @@\n+import javax.swing.text.JTextComponent;\n+import javax.swing.text.html.HTMLEditorKit;\n+import javax.swing.text.html.StyleSheet;\n@@ -62,0 +72,1 @@\n+import static java.util.Collections.unmodifiableList;\n@@ -65,0 +76,73 @@\n+\/**\n+ * Provides a framework for manual tests to display test instructions and\n+ * Pass\/Fail buttons.\n+ * <p>\n+ * Instructions for the user can be either plain text or HTML as supported\n+ * by Swing. If the instructions start with {@code <html>}, the\n+ * instructions are displayed as HTML.\n+ * <p>\n+ * A simple test would look like this:\n+ * <pre>{@code\n+ * public class SampleManualTest {\n+ *     private static final String INSTRUCTIONS =\n+ *             \"Click Pass, or click Fail if the test failed.\";\n+ *\n+ *     public static void main(String[] args) throws Exception {\n+ *         PassFailJFrame.builder()\n+ *                       .instructions(INSTRUCTIONS)\n+ *                       .testUI(() -> createTestUI())\n+ *                       .build()\n+ *                       .awaitAndCheck();\n+ *     }\n+ *\n+ *     private static List<Window> createTestUI() {\n+ *         JFrame testUI = new JFrame(\"Test UI\");\n+ *         testUI.setSize(250, 150);\n+ *         return List.of(testUI);\n+ *     }\n+ * }\n+ * }<\/pre>\n+ * <p>\n+ * The above example uses the {@link Builder Builder} to set the parameters of\n+ * the instruction frame. It is the recommended way.\n+ * <p>\n+ * The framework will create instruction UI, it will call\n+ * the provided {@code createTestUI} on the Event Dispatch Thread (EDT),\n+ * and it will automatically position the test UI and make it visible.\n+ * <p>\n+ * Alternatively, use one of the {@code PassFailJFrame} constructors to\n+ * create an object, then create secondary test UI, register it\n+ * with {@code PassFailJFrame}, position it and make it visible.\n+ * The following sample demonstrates it:\n+ * <pre>{@code\n+ * public class SampleOldManualTest {\n+ *     private static final String INSTRUCTIONS =\n+ *             \"Click Pass, or click Fail if the test failed.\";\n+ *\n+ *     public static void main(String[] args) throws Exception {\n+ *         PassFailJFrame passFail = new PassFailJFrame(INSTRUCTIONS);\n+ *\n+ *         SwingUtilities.invokeAndWait(() -> createTestUI());\n+ *\n+ *         passFail.awaitAndCheck();\n+ *     }\n+ *\n+ *     private static void createTestUI() {\n+ *         JFrame testUI = new JFrame(\"Test UI\");\n+ *         testUI.setSize(250, 150);\n+ *         PassFailJFrame.addTestWindow(testUI);\n+ *         PassFailJFrame.positionTestWindow(testUI, PassFailJFrame.Position.HORIZONTAL);\n+ *         testUI.setVisible(true);\n+ *     }\n+ * }\n+ * }<\/pre>\n+ * <p>\n+ * Use methods of the {@code Builder} class or constructors of the\n+ * {@code PassFailJFrame} class to control other parameters:\n+ * <ul>\n+ *     <li>the title of the instruction UI,<\/li>\n+ *     <li>the timeout of the test,<\/li>\n+ *     <li>the size of the instruction UI via rows and columns, and<\/li>\n+ *     <li>to enable screenshots.<\/li>\n+ * <\/ul>\n+ *\/\n@@ -76,0 +160,4 @@\n+    \/**\n+     * The failure reason message when the user didn't provide one.\n+     *\/\n+    private static final String EMPTY_REASON = \"(no reason provided)\";\n@@ -78,1 +166,1 @@\n-    private static final Timer timer = new Timer(0, null);\n+\n@@ -81,3 +169,12 @@\n-    private static volatile boolean failed;\n-    private static volatile boolean timeout;\n-    private static volatile String testFailedReason;\n+    private static TimeoutHandler timeoutHandler;\n+\n+    \/**\n+     * The description of why the test fails.\n+     * <p>\n+     * Note: <strong>do not use<\/strong> this field directly,\n+     * use the {@link #setFailureReason(String) setFailureReason} and\n+     * {@link #getFailureReason() getFailureReason} methods to modify and\n+     * to read its value.\n+     *\/\n+    private static String failureReason;\n+\n@@ -85,0 +182,1 @@\n+\n@@ -86,0 +184,1 @@\n+\n@@ -168,9 +267,6 @@\n-                          boolean enableScreenCapture) throws InterruptedException,\n-            InvocationTargetException {\n-        if (isEventDispatchThread()) {\n-            createUI(title, instructions, testTimeOut, rows, columns,\n-                    enableScreenCapture);\n-        } else {\n-            invokeAndWait(() -> createUI(title, instructions, testTimeOut,\n-                    rows, columns, enableScreenCapture));\n-        }\n+                          boolean enableScreenCapture)\n+            throws InterruptedException, InvocationTargetException {\n+        invokeOnEDT(() -> createUI(title, instructions,\n+                                   testTimeOut,\n+                                   rows, columns,\n+                                   enableScreenCapture));\n@@ -182,1 +278,50 @@\n-                builder.rows, builder.columns, builder.screenCapture);\n+             builder.rows, builder.columns, builder.screenCapture);\n+\n+        if (builder.windowCreator != null) {\n+            invokeOnEDT(() ->\n+                    builder.testWindows = builder.windowCreator.createTestUI());\n+        }\n+\n+        if (builder.testWindows != null) {\n+            addTestWindow(builder.testWindows);\n+            builder.testWindows\n+                   .forEach(w -> w.addWindowListener(windowClosingHandler));\n+\n+            if (builder.positionWindows != null) {\n+                positionInstructionFrame(builder.position);\n+                invokeOnEDT(() -> {\n+                    builder.positionWindows\n+                           .positionTestWindows(unmodifiableList(builder.testWindows),\n+                                                builder.instructionUIHandler);\n+\n+                    windowList.forEach(w -> w.setVisible(true));\n+                });\n+            } else if (builder.testWindows.size() == 1) {\n+                Window window = builder.testWindows.get(0);\n+                positionTestWindow(window, builder.position);\n+                window.setVisible(true);\n+            } else {\n+                positionTestWindow(null, builder.position);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Performs an operation on EDT. If called on EDT, invokes {@code run}\n+     * directly, otherwise wraps into {@code invokeAndWait}.\n+     *\n+     * @param doRun an operation to run on EDT\n+     * @throws InterruptedException if we're interrupted while waiting for\n+     *              the event dispatching thread to finish executing\n+     *              {@code doRun.run()}\n+     * @throws InvocationTargetException if an exception is thrown while\n+     *              running {@code doRun}\n+     * @see javax.swing.SwingUtilities#invokeAndWait(Runnable)\n+     *\/\n+    private static void invokeOnEDT(Runnable doRun)\n+            throws InterruptedException, InvocationTargetException {\n+        if (isEventDispatchThread()) {\n+            doRun.run();\n+        } else {\n+            invokeAndWait(doRun);\n+        }\n@@ -190,22 +335,3 @@\n-        JTextArea instructionsText = new JTextArea(instructions, rows, columns);\n-        instructionsText.setEditable(false);\n-        instructionsText.setLineWrap(true);\n-\n-        long tTimeout = TimeUnit.MINUTES.toMillis(testTimeOut);\n-\n-        final JLabel testTimeoutLabel = new JLabel(String.format(\"Test \" +\n-                \"timeout: %s\", convertMillisToTimeStr(tTimeout)), JLabel.CENTER);\n-        final long startTime = System.currentTimeMillis();\n-        timer.setDelay(1000);\n-        timer.addActionListener((e) -> {\n-            long leftTime = tTimeout - (System.currentTimeMillis() - startTime);\n-            if ((leftTime < 0) || failed) {\n-                timer.stop();\n-                testFailedReason = FAILURE_REASON\n-                                   + \"Timeout User did not perform testing.\";\n-                timeout = true;\n-                latch.countDown();\n-            }\n-            testTimeoutLabel.setText(String.format(\"Test timeout: %s\", convertMillisToTimeStr(leftTime)));\n-        });\n-        timer.start();\n+\n+        JLabel testTimeoutLabel = new JLabel(\"\", JLabel.CENTER);\n+        timeoutHandler = new TimeoutHandler(testTimeoutLabel, testTimeOut);\n@@ -213,1 +339,7 @@\n-        frame.add(new JScrollPane(instructionsText), BorderLayout.CENTER);\n+\n+        JTextComponent text = instructions.startsWith(\"<html>\")\n+                              ? configureHTML(instructions, rows, columns)\n+                              : configurePlainText(instructions, rows, columns);\n+        text.setEditable(false);\n+\n+        frame.add(new JScrollPane(text), BorderLayout.CENTER);\n@@ -218,1 +350,1 @@\n-            timer.stop();\n+            timeoutHandler.stop();\n@@ -223,2 +355,2 @@\n-            getFailureReason();\n-            timer.stop();\n+            requestFailureReason();\n+            timeoutHandler.stop();\n@@ -235,10 +367,1 @@\n-        frame.addWindowListener(new WindowAdapter() {\n-            @Override\n-            public void windowClosing(WindowEvent e) {\n-                super.windowClosing(e);\n-                testFailedReason = FAILURE_REASON\n-                                   + \"User closed the instruction Frame\";\n-                failed = true;\n-                latch.countDown();\n-            }\n-        });\n+        frame.addWindowListener(windowClosingHandler);\n@@ -252,0 +375,167 @@\n+    private static JTextComponent configurePlainText(String instructions,\n+                                                     int rows, int columns) {\n+        JTextArea text = new JTextArea(instructions, rows, columns);\n+        text.setLineWrap(true);\n+        text.setWrapStyleWord(true);\n+        return text;\n+    }\n+\n+    private static JTextComponent configureHTML(String instructions,\n+                                                int rows, int columns) {\n+        JEditorPane text = new JEditorPane(\"text\/html\", instructions);\n+        text.putClientProperty(JEditorPane.HONOR_DISPLAY_PROPERTIES,\n+                               Boolean.TRUE);\n+        \/\/ Set preferred size as if it were JTextArea\n+        text.setPreferredSize(new JTextArea(rows, columns).getPreferredSize());\n+\n+        HTMLEditorKit kit = (HTMLEditorKit) text.getEditorKit();\n+        StyleSheet styles = kit.getStyleSheet();\n+        \/\/ Reduce the default margins\n+        styles.addRule(\"ol, ul { margin-left-ltr: 20; margin-left-rtl: 20 }\");\n+        \/\/ Make the size of code blocks the same as other text\n+        styles.addRule(\"code { font-size: inherit }\");\n+\n+        return text;\n+    }\n+\n+\n+    \/**\n+     * Creates one or more windows for test UI.\n+     *\/\n+    @FunctionalInterface\n+    public interface WindowCreator {\n+        \/**\n+         * Creates one or more windows for test UI.\n+         * This method is called by the framework on the EDT.\n+         * @return a list of windows.\n+         *\/\n+        List<? extends Window> createTestUI();\n+    }\n+\n+    \/**\n+     * Positions test UI windows.\n+     *\/\n+    @FunctionalInterface\n+    public interface PositionWindows {\n+        \/**\n+         * Positions test UI windows.\n+         * This method is called by the framework on the EDT after\n+         * the instruction UI frame was positioned on the screen.\n+         * <p>\n+         * The list of the test windows contains the windows\n+         * that were passed to the framework via\n+         * {@link Builder#testUI(WindowCreator) testUI} method.\n+         *\n+         * @param testWindows the list of test windows\n+         * @param instructionUI information about the instruction frame\n+         *\/\n+        void positionTestWindows(List<? extends Window> testWindows,\n+                                 InstructionUI instructionUI);\n+    }\n+\n+    \/**\n+     * Provides information about the instruction frame.\n+     *\/\n+    public interface InstructionUI {\n+        \/**\n+         * {@return the location of the instruction frame}\n+         *\/\n+        Point getLocation();\n+\n+        \/**\n+         * {@return the size of the instruction frame}\n+         *\/\n+        Dimension getSize();\n+\n+        \/**\n+         * {@return the bounds of the instruction frame}\n+         *\/\n+        Rectangle getBounds();\n+\n+        \/**\n+         * Allows to change the location of the instruction frame.\n+         *\n+         * @param location the new location of the instruction frame\n+         *\/\n+        void setLocation(Point location);\n+\n+        \/**\n+         * Allows to change the location of the instruction frame.\n+         *\n+         * @param x the <i>x<\/i> coordinate of the new location\n+         * @param y the <i>y<\/i> coordinate of the new location\n+         *\/\n+        void setLocation(int x, int y);\n+\n+        \/**\n+         * Returns the specified position that was used to set\n+         * the initial location of the instruction frame.\n+         *\n+         * @return the specified position\n+         *\n+         * @see Position\n+         *\/\n+        Position getPosition();\n+    }\n+\n+\n+    private static final class TimeoutHandler implements ActionListener {\n+        private final long endTime;\n+\n+        private final Timer timer;\n+\n+        private final JLabel label;\n+\n+        public TimeoutHandler(final JLabel label, final long testTimeOut) {\n+            endTime = System.currentTimeMillis() + TimeUnit.MINUTES.toMillis(testTimeOut);\n+\n+            this.label = label;\n+\n+            timer = new Timer(1000, this);\n+            timer.start();\n+            updateTime(testTimeOut);\n+        }\n+\n+        @Override\n+        public void actionPerformed(ActionEvent e) {\n+            long leftTime = endTime - System.currentTimeMillis();\n+            if (leftTime < 0) {\n+                timer.stop();\n+                setFailureReason(FAILURE_REASON\n+                                 + \"Timeout - User did not perform testing.\");\n+                latch.countDown();\n+            }\n+            updateTime(leftTime);\n+        }\n+\n+        private void updateTime(final long leftTime) {\n+            if (leftTime < 0) {\n+                label.setText(\"Test timeout: 00:00:00\");\n+                return;\n+            }\n+            long hours = leftTime \/ 3_600_000;\n+            long minutes = (leftTime - hours * 3_600_000) \/ 60_000;\n+            long seconds = (leftTime - hours * 3_600_000 - minutes * 60_000) \/ 1_000;\n+            label.setText(String.format(\"Test timeout: %02d:%02d:%02d\",\n+                                        hours, minutes, seconds));\n+        }\n+\n+        public void stop() {\n+            timer.stop();\n+        }\n+    }\n+\n+\n+    private static final class WindowClosingHandler extends WindowAdapter {\n+        @Override\n+        public void windowClosing(WindowEvent e) {\n+            setFailureReason(FAILURE_REASON\n+                             + \"User closed a window\");\n+            latch.countDown();\n+        }\n+    }\n+\n+    private static final WindowListener windowClosingHandler =\n+            new WindowClosingHandler();\n+\n+\n@@ -337,3 +627,14 @@\n-    private static String convertMillisToTimeStr(long millis) {\n-        if (millis < 0) {\n-            return \"00:00:00\";\n+    \/**\n+     * Sets the failure reason which describes why the test fails.\n+     * This method ensures the {@code failureReason} field does not change\n+     * after it's set to a non-{@code null} value.\n+     * @param reason the description of why the test fails\n+     * @throws IllegalArgumentException if the {@code reason} parameter\n+     *         is {@code null}\n+     *\/\n+    private static synchronized void setFailureReason(final String reason) {\n+        if (reason == null) {\n+            throw new IllegalArgumentException(\"The failure reason must not be null\");\n+        }\n+        if (failureReason == null) {\n+            failureReason = reason;\n@@ -341,4 +642,7 @@\n-        long hours = millis \/ 3_600_000;\n-        long minutes = (millis - hours * 3_600_000) \/ 60_000;\n-        long seconds = (millis - hours * 3_600_000 - minutes * 60_000) \/ 1_000;\n-        return String.format(\"%02d:%02d:%02d\", hours, minutes, seconds);\n+    }\n+\n+    \/**\n+     * {@return the description of why the test fails}\n+     *\/\n+    private static synchronized String getFailureReason() {\n+        return failureReason;\n@@ -365,6 +669,3 @@\n-        if (timeout) {\n-            throw new RuntimeException(testFailedReason);\n-        }\n-\n-        if (failed) {\n-            throw new RuntimeException(\"Test failed! : \" + testFailedReason);\n+        String failure = getFailureReason();\n+        if (failure != null) {\n+            throw new RuntimeException(failure);\n@@ -377,2 +678,1 @@\n-     * Dispose all the window(s) i,e both the test instruction frame and\n-     * the window(s) that is added via addTestWindow(Window testWindow)\n+     * Requests the description of the test failure reason from the tester.\n@@ -380,11 +680,1 @@\n-    private static synchronized void disposeWindows() {\n-        for (Window win : windowList) {\n-            win.dispose();\n-        }\n-    }\n-\n-    \/**\n-     * Read the test failure reason and add the reason to the test result\n-     * example in the jtreg .jtr file.\n-     *\/\n-    private static void getFailureReason() {\n+    private static void requestFailureReason() {\n@@ -398,1 +688,3 @@\n-            testFailedReason = FAILURE_REASON + jTextArea.getText();\n+            String text = jTextArea.getText();\n+            setFailureReason(FAILURE_REASON\n+                             + (!text.isEmpty() ? text : EMPTY_REASON));\n@@ -413,1 +705,4 @@\n-        failed = true;\n+        \/\/ Ensure the test fails even if the dialog is closed\n+        \/\/ without clicking the OK button\n+        setFailureReason(FAILURE_REASON + EMPTY_REASON);\n+\n@@ -418,0 +713,38 @@\n+    \/**\n+     * Disposes of all the windows. It disposes of the test instruction frame\n+     * and all other windows added via {@link #addTestWindow(Window)}.\n+     *\/\n+    private static synchronized void disposeWindows() {\n+        windowList.forEach(Window::dispose);\n+    }\n+\n+    private static void positionInstructionFrame(final Position position) {\n+        Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\n+\n+        \/\/ Get the screen insets to position the frame by taking into\n+        \/\/ account the location of taskbar or menu bar on screen.\n+        GraphicsConfiguration gc = GraphicsEnvironment.getLocalGraphicsEnvironment()\n+                                                      .getDefaultScreenDevice()\n+                                                      .getDefaultConfiguration();\n+        Insets screenInsets = Toolkit.getDefaultToolkit().getScreenInsets(gc);\n+\n+        switch (position) {\n+            case HORIZONTAL:\n+                int newX = ((screenSize.width \/ 2) - frame.getWidth());\n+                frame.setLocation((newX + screenInsets.left),\n+                                  (frame.getY() + screenInsets.top));\n+                break;\n+\n+            case VERTICAL:\n+                int newY = ((screenSize.height \/ 2) - frame.getHeight());\n+                frame.setLocation((frame.getX() + screenInsets.left),\n+                                  (newY + screenInsets.top));\n+                break;\n+\n+            case TOP_LEFT_CORNER:\n+                frame.setLocation(screenInsets.left, screenInsets.top);\n+                break;\n+        }\n+        syncLocationToWindowManager();\n+    }\n+\n@@ -448,32 +781,14 @@\n-        Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\n-\n-        \/\/ Get the screen insets to position the frame by taking into\n-        \/\/ account the location of taskbar\/menubars on screen.\n-        GraphicsConfiguration gc = GraphicsEnvironment.getLocalGraphicsEnvironment()\n-                .getDefaultScreenDevice().getDefaultConfiguration();\n-        Insets screenInsets = Toolkit.getDefaultToolkit().getScreenInsets(gc);\n-\n-        if (position.equals(Position.HORIZONTAL)) {\n-            int newX = ((screenSize.width \/ 2) - frame.getWidth());\n-            frame.setLocation((newX + screenInsets.left),\n-                    (frame.getY() + screenInsets.top));\n-            syncLocationToWindowManager();\n-            if (testWindow != null) {\n-                testWindow.setLocation((frame.getX() + frame.getWidth() + 5),\n-                        frame.getY());\n-            }\n-        } else if (position.equals(Position.VERTICAL)) {\n-            int newY = ((screenSize.height \/ 2) - frame.getHeight());\n-            frame.setLocation((frame.getX() + screenInsets.left),\n-                    (newY + screenInsets.top));\n-            syncLocationToWindowManager();\n-            if (testWindow != null) {\n-                testWindow.setLocation(frame.getX(),\n-                        (frame.getY() + frame.getHeight() + 5));\n-            }\n-        } else if (position.equals(Position.TOP_LEFT_CORNER)) {\n-            frame.setLocation(screenInsets.left, screenInsets.top);\n-            syncLocationToWindowManager();\n-            if (testWindow != null) {\n-                testWindow.setLocation((frame.getX() + frame.getWidth() + 5),\n-                        frame.getY());\n+        positionInstructionFrame(position);\n+\n+        if (testWindow != null) {\n+            switch (position) {\n+                case HORIZONTAL:\n+                case TOP_LEFT_CORNER:\n+                    testWindow.setLocation((frame.getX() + frame.getWidth() + 5),\n+                                           frame.getY());\n+                    break;\n+\n+                case VERTICAL:\n+                    testWindow.setLocation(frame.getX(),\n+                                           (frame.getY() + frame.getHeight() + 5));\n+                    break;\n@@ -482,0 +797,1 @@\n+\n@@ -521,7 +837,1 @@\n-        if (isEventDispatchThread()) {\n-            bounds[0] = frame != null ? frame.getBounds() : null;\n-        } else {\n-            invokeAndWait(() -> {\n-                bounds[0] = frame != null ? frame.getBounds() : null;\n-            });\n-        }\n+        invokeOnEDT(() -> bounds[0] = frame != null ? frame.getBounds() : null);\n@@ -542,0 +852,10 @@\n+    \/**\n+     * Adds a collection of test windows to the windowList to be disposed of\n+     * when the test completes.\n+     *\n+     * @param testWindows the collection of test windows to be disposed of\n+     *\/\n+    public static synchronized void addTestWindow(Collection<? extends Window> testWindows) {\n+        windowList.addAll(testWindows);\n+    }\n+\n@@ -570,2 +890,1 @@\n-        failed = true;\n-        testFailedReason = FAILURE_REASON + reason;\n+        setFailureReason(FAILURE_REASON + reason);\n@@ -575,1 +894,1 @@\n-    public static class Builder {\n+    public static final class Builder {\n@@ -581,1 +900,8 @@\n-        private boolean screenCapture = false;\n+        private boolean screenCapture;\n+\n+        private List<? extends Window> testWindows;\n+        private WindowCreator windowCreator;\n+        private PositionWindows positionWindows;\n+        private InstructionUI instructionUIHandler;\n+\n+        private Position position;\n@@ -613,0 +939,45 @@\n+        public Builder testUI(Window window) {\n+            return testUI(List.of(window));\n+        }\n+\n+        public Builder testUI(Window... windows) {\n+            return testUI(List.of(windows));\n+        }\n+\n+        public Builder testUI(List<Window> windows) {\n+            if (windows == null) {\n+                throw new IllegalArgumentException(\"The list of windows can't be null\");\n+            }\n+            if (windows.stream()\n+                       .anyMatch(Objects::isNull)) {\n+                throw new IllegalArgumentException(\"The windows list can't contain null\");\n+            }\n+\n+            if (windowCreator != null) {\n+                throw new IllegalStateException(\"windowCreator is already set\");\n+            }\n+            this.testWindows = windows;\n+            return this;\n+        }\n+\n+        public Builder testUI(WindowCreator windowCreator) {\n+            if (windowCreator == null) {\n+                throw new IllegalArgumentException(\"The window creator can't be null\");\n+            }\n+            if (testWindows != null) {\n+                throw new IllegalStateException(\"testWindows are already set\");\n+            }\n+            this.windowCreator = windowCreator;\n+            return this;\n+        }\n+\n+        public Builder positionTestUI(PositionWindows positionWindows) {\n+            this.positionWindows = positionWindows;\n+            return this;\n+        }\n+\n+        public Builder position(Position position) {\n+            this.position = position;\n+            return this;\n+        }\n+\n@@ -620,2 +991,2 @@\n-            if (this.title == null) {\n-                this.title = TITLE;\n+            if (title == null) {\n+                title = TITLE;\n@@ -624,3 +995,3 @@\n-            if (this.instructions == null || this.instructions.length() == 0) {\n-                throw new RuntimeException(\"Please provide the test \" +\n-                        \"instruction for this manual test\");\n+            if (instructions == null || instructions.isEmpty()) {\n+                throw new IllegalStateException(\"Please provide the test \" +\n+                        \"instructions for this manual test\");\n@@ -629,2 +1000,2 @@\n-            if (this.testTimeOut == 0L) {\n-                this.testTimeOut = TEST_TIMEOUT;\n+            if (testTimeOut == 0L) {\n+                testTimeOut = TEST_TIMEOUT;\n@@ -633,2 +1004,2 @@\n-            if (this.rows == 0) {\n-                this.rows = ROWS;\n+            if (rows == 0) {\n+                rows = ROWS;\n@@ -637,2 +1008,48 @@\n-            if (this.columns == 0) {\n-                this.columns = COLUMNS;\n+            if (columns == 0) {\n+                columns = COLUMNS;\n+            }\n+\n+            if (position == null\n+                && (testWindows != null || windowCreator != null)) {\n+\n+                position = Position.HORIZONTAL;\n+            }\n+\n+            if (positionWindows != null) {\n+                if (testWindows == null && windowCreator == null) {\n+                    throw new IllegalStateException(\"To position windows, \"\n+                            + \"provide an a list of windows to the builder\");\n+                }\n+                instructionUIHandler = new InstructionUIHandler();\n+            }\n+        }\n+\n+        private final class InstructionUIHandler implements InstructionUI {\n+            @Override\n+            public Point getLocation() {\n+                return frame.getLocation();\n+            }\n+\n+            @Override\n+            public Dimension getSize() {\n+                return frame.getSize();\n+            }\n+\n+            @Override\n+            public Rectangle getBounds() {\n+                return frame.getBounds();\n+            }\n+\n+            @Override\n+            public void setLocation(Point location) {\n+                setLocation(location.x, location.y);\n+            }\n+\n+            @Override\n+            public void setLocation(int x, int y) {\n+                frame.setLocation(x, y);\n+            }\n+\n+            @Override\n+            public Position getPosition() {\n+                return position;\n@@ -642,0 +1059,4 @@\n+\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n","filename":"test\/jdk\/java\/awt\/regtesthelpers\/PassFailJFrame.java","additions":553,"deletions":132,"binary":false,"changes":685,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/CompositeLookupTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -37,4 +37,13 @@\n- * @test\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n- * @run testng\/othervm --enable-native-access=ALL-UNNAMED LibraryLookupTest\n+ * @test id=specialized\n+ * @run testng\/othervm\n+ *  -Djdk.internal.foreign.DowncallLinker.USE_SPEC=true\n+ *  --enable-native-access=ALL-UNNAMED\n+ *  LibraryLookupTest\n+ *\/\n+\n+\/*\n+ * @test id=interpreted\n+ * @run testng\/othervm\n+ *   -Djdk.internal.foreign.DowncallLinker.USE_SPEC=false\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   LibraryLookupTest\n","filename":"test\/jdk\/java\/foreign\/LibraryLookupTest.java","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/MemoryLayoutPrincipalTotalityTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/MemoryLayoutTypeRetentionTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -89,0 +89,2 @@\n+    public static final Linker LINKER = Linker.nativeLinker();\n+\n@@ -94,1 +96,1 @@\n-    public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;\n+    public static final ValueLayout.OfBoolean C_BOOL = (ValueLayout.OfBoolean) LINKER.canonicalLayouts().get(\"bool\");\n@@ -98,1 +100,1 @@\n-    public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;\n+    public static final ValueLayout.OfByte C_CHAR = (ValueLayout.OfByte) LINKER.canonicalLayouts().get(\"char\");\n@@ -102,1 +104,1 @@\n-    public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT;\n+    public static final ValueLayout.OfShort C_SHORT = (ValueLayout.OfShort) LINKER.canonicalLayouts().get(\"short\");\n@@ -106,1 +108,1 @@\n-    public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT;\n+    public static final ValueLayout.OfInt C_INT = (ValueLayout.OfInt) LINKER.canonicalLayouts().get(\"int\");\n@@ -111,1 +113,1 @@\n-    public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG;\n+    public static final ValueLayout.OfLong C_LONG_LONG = (ValueLayout.OfLong) LINKER.canonicalLayouts().get(\"long long\");\n@@ -115,1 +117,1 @@\n-    public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT;\n+    public static final ValueLayout.OfFloat C_FLOAT = (ValueLayout.OfFloat) LINKER.canonicalLayouts().get(\"float\");\n@@ -119,1 +121,1 @@\n-    public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE;\n+    public static final ValueLayout.OfDouble C_DOUBLE = (ValueLayout.OfDouble) LINKER.canonicalLayouts().get(\"double\");\n@@ -123,4 +125,21 @@\n-    public static final AddressLayout C_POINTER = ValueLayout.ADDRESS\n-            .withTargetLayout(MemoryLayout.sequenceLayout(C_CHAR));\n-\n-    public static final Linker LINKER = Linker.nativeLinker();\n+    public static final AddressLayout C_POINTER = ((AddressLayout) LINKER.canonicalLayouts().get(\"void*\"))\n+            .withTargetLayout(MemoryLayout.sequenceLayout(Long.MAX_VALUE, C_CHAR));\n+    \/**\n+     * The layout for the {@code size_t} C type\n+     *\/\n+    public static final ValueLayout C_SIZE_T = (ValueLayout) LINKER.canonicalLayouts().get(\"size_t\");\n+\n+    \/\/ Common layout shared by some tests\n+    \/\/ struct S_PDI { void* p0; double p1; int p2; };\n+    public static final MemoryLayout S_PDI_LAYOUT = switch ((int) ValueLayout.ADDRESS.byteSize()) {\n+        case 8 -> MemoryLayout.structLayout(\n+            C_POINTER.withName(\"p0\"),\n+            C_DOUBLE.withName(\"p1\"),\n+            C_INT.withName(\"p2\"),\n+            MemoryLayout.paddingLayout(4));\n+        case 4 -> MemoryLayout.structLayout(\n+            C_POINTER.withName(\"p0\"),\n+            C_DOUBLE.withName(\"p1\"),\n+            C_INT.withName(\"p2\"));\n+        default -> throw new UnsupportedOperationException(\"Unsupported address size\");\n+    };\n@@ -251,2 +270,2 @@\n-            accessor.set(container, fieldValue.value());\n-            return actual -> fieldCheck.accept(accessor.get((MemorySegment) actual));\n+            accessor.set(container, 0L, fieldValue.value());\n+            return actual -> fieldCheck.accept(accessor.get((MemorySegment) actual, 0L));\n@@ -260,1 +279,1 @@\n-                return (MemorySegment) slicer.invokeExact(container);\n+                return (MemorySegment) slicer.invokeExact(container, 0L);\n","filename":"test\/jdk\/java\/foreign\/NativeTestHelper.java","additions":33,"deletions":14,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -25,4 +25,13 @@\n- * @test\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n- * @run testng\/othervm --enable-native-access=ALL-UNNAMED SafeFunctionAccessTest\n+ * @test id=specialized\n+ * @run testng\/othervm\n+ *  -Djdk.internal.foreign.DowncallLinker.USE_SPEC=true\n+ *  --enable-native-access=ALL-UNNAMED\n+ *  SafeFunctionAccessTest\n+ *\/\n+\n+\/*\n+ * @test id=interpreted\n+ * @run testng\/othervm\n+ *   -Djdk.internal.foreign.DowncallLinker.USE_SPEC=false\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   SafeFunctionAccessTest\n","filename":"test\/jdk\/java\/foreign\/SafeFunctionAccessTest.java","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -54,1 +52,0 @@\n-@Test\n@@ -124,2 +121,5 @@\n-        String formatArgs = args.stream()\n-                .map(a -> a.format)\n+        String javaFormatArgs = args.stream()\n+                .map(a -> a.javaFormat)\n+                .collect(Collectors.joining(\",\"));\n+        String nativeFormatArgs = args.stream()\n+                .map(a -> a.nativeFormat)\n@@ -128,1 +128,2 @@\n-        String formatString = \"hello(\" + formatArgs + \")\\n\";\n+        String javaFormatString = \"hello(\" + javaFormatArgs + \")\\n\";\n+        String nativeFormatString = \"hello(\" + nativeFormatArgs + \")\\n\";\n@@ -130,1 +131,1 @@\n-        String expected = String.format(formatString, args.stream()\n+        String expected = String.format(javaFormatString, args.stream()\n@@ -133,1 +134,1 @@\n-        int found = stdLibHelper.printf(formatString, args);\n+        int found = stdLibHelper.printf(nativeFormatString, args);\n@@ -159,0 +160,1 @@\n+        \/\/ void qsort( void *ptr, size_t count, size_t size, int (*comp)(const void *, const void *) );\n@@ -160,1 +162,1 @@\n-                FunctionDescriptor.ofVoid(C_POINTER, C_LONG_LONG, C_LONG_LONG, C_POINTER));\n+                FunctionDescriptor.ofVoid(C_POINTER, C_SIZE_T, C_SIZE_T, C_POINTER));\n@@ -190,3 +192,3 @@\n-                buf.setUtf8String(0, s1);\n-                MemorySegment other = arena.allocateUtf8String(s2);\n-                return ((MemorySegment)strcat.invokeExact(buf, other)).getUtf8String(0);\n+                buf.setString(0, s1);\n+                MemorySegment other = arena.allocateFrom(s2);\n+                return ((MemorySegment)strcat.invokeExact(buf, other)).getString(0);\n@@ -198,2 +200,2 @@\n-                MemorySegment ns1 = arena.allocateUtf8String(s1);\n-                MemorySegment ns2 = arena.allocateUtf8String(s2);\n+                MemorySegment ns1 = arena.allocateFrom(s1);\n+                MemorySegment ns2 = arena.allocateFrom(s2);\n@@ -206,1 +208,1 @@\n-                MemorySegment s = arena.allocateUtf8String(msg);\n+                MemorySegment s = arena.allocateFrom(msg);\n@@ -213,1 +215,1 @@\n-                MemorySegment s = arena.allocateUtf8String(msg);\n+                MemorySegment s = arena.allocateFrom(msg);\n@@ -280,1 +282,1 @@\n-                MemorySegment nativeArr = arena.allocateArray(C_INT, arr);\n+                MemorySegment nativeArr = arena.allocateFrom(C_INT, arr);\n@@ -285,1 +287,5 @@\n-                qsort.invokeExact(nativeArr, (long)arr.length, C_INT.byteSize(), qsortUpcallStub);\n+                \/\/ both of these fit in an int\n+                \/\/ automatically widen them to long on x64\n+                int count = arr.length;\n+                int size = (int) C_INT.byteSize();\n+                qsort.invoke(nativeArr, count, size, qsortUpcallStub);\n@@ -303,1 +309,1 @@\n-                MemorySegment formatStr = arena.allocateUtf8String(format);\n+                MemorySegment formatStr = arena.allocateFrom(format);\n@@ -381,4 +387,4 @@\n-        INT(int.class, C_INT, \"%d\", arena -> 42, 42),\n-        LONG(long.class, C_LONG_LONG, \"%d\", arena -> 84L, 84L),\n-        DOUBLE(double.class, C_DOUBLE, \"%.4f\", arena -> 1.2345d, 1.2345d),\n-        STRING(MemorySegment.class, C_POINTER, \"%s\", arena -> arena.allocateUtf8String(\"str\"), \"str\");\n+        INT(int.class, C_INT, \"%d\", \"%d\", arena -> 42, 42),\n+        LONG(long.class, C_LONG_LONG, \"%lld\", \"%d\", arena -> 84L, 84L),\n+        DOUBLE(double.class, C_DOUBLE, \"%.4f\", \"%.4f\", arena -> 1.2345d, 1.2345d),\n+        STRING(MemorySegment.class, C_POINTER, \"%s\", \"%s\", arena -> arena.allocateFrom(\"str\"), \"str\");\n@@ -388,1 +394,2 @@\n-        final String format;\n+        final String nativeFormat;\n+        final String javaFormat;\n@@ -392,1 +399,2 @@\n-        <Z, L extends ValueLayout> PrintfArg(Class<?> carrier, L layout, String format, Function<Arena, Z> nativeValueFactory, Object javaValue) {\n+        <Z, L extends ValueLayout> PrintfArg(Class<?> carrier, L layout, String nativeFormat, String javaFormat,\n+                                             Function<Arena, Z> nativeValueFactory, Object javaValue) {\n@@ -395,1 +403,2 @@\n-            this.format = format;\n+            this.nativeFormat = nativeFormat;\n+            this.javaFormat = javaFormat;\n","filename":"test\/jdk\/java\/foreign\/StdLibTest.java","additions":35,"deletions":26,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -0,0 +1,179 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng\/othervm -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=true -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=false -Xverify:all TestAccessModes\n+ * @run testng\/othervm -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=true -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=true -Xverify:all TestAccessModes\n+ * @run testng\/othervm -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=false -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=false -Xverify:all TestAccessModes\n+ * @run testng\/othervm -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=false -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=true -Xverify:all TestAccessModes\n+ *\/\n+\n+import java.lang.foreign.AddressLayout;\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.invoke.VarHandle;\n+import java.lang.invoke.VarHandle.AccessMode;\n+import java.util.ArrayList;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.testng.annotations.*;\n+\n+import static org.testng.Assert.*;\n+public class TestAccessModes {\n+\n+    @Test(dataProvider = \"segmentsAndLayoutsAndModes\")\n+    public void testAccessModes(MemorySegment segment, ValueLayout layout, AccessMode mode) throws Throwable {\n+        VarHandle varHandle = layout.varHandle();\n+        MethodHandle methodHandle = varHandle.toMethodHandle(mode);\n+        boolean compatible = AccessModeKind.supportedModes(layout).contains(AccessModeKind.of(mode));\n+        try {\n+            Object o = methodHandle.invokeWithArguments(makeArgs(segment, varHandle.accessModeType(mode)));\n+            assertTrue(compatible);\n+        } catch (UnsupportedOperationException ex) {\n+            assertFalse(compatible);\n+        } catch (IllegalArgumentException ex) {\n+            \/\/ access is unaligned, but access mode is supported\n+            assertTrue(compatible);\n+        }\n+    }\n+\n+    Object[] makeArgs(MemorySegment segment, MethodType type) throws Throwable {\n+        List<Object> args = new ArrayList<>();\n+        args.add(segment);\n+        for (Class argType : type.dropParameterTypes(0, 1).parameterList()) {\n+            args.add(defaultValue(argType));\n+        }\n+        return args.toArray();\n+    }\n+\n+    Object defaultValue(Class<?> clazz) throws Throwable {\n+        if (clazz == MemorySegment.class) {\n+            return MemorySegment.NULL;\n+        } else if (clazz.isPrimitive()) {\n+            return MethodHandles.zero(clazz).invoke();\n+        } else {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+\n+    \/*\n+     * See the javadoc of MemoryLayout::varHandle.\n+     *\/\n+    enum AccessModeKind {\n+        PLAIN,\n+        READ_WRITE,\n+        ATOMIC_UPDATE,\n+        ATOMIC_NUMERIC_UPDATE,\n+        ATOMIC_BITWISE_UPDATE;\n+\n+        static AccessModeKind of(AccessMode mode) {\n+            return switch (mode) {\n+                case GET, SET -> PLAIN;\n+                case GET_ACQUIRE, GET_OPAQUE, GET_VOLATILE, SET_VOLATILE,\n+                        SET_OPAQUE, SET_RELEASE -> READ_WRITE;\n+                case GET_AND_SET, GET_AND_SET_ACQUIRE, GET_AND_SET_RELEASE,\n+                        WEAK_COMPARE_AND_SET, WEAK_COMPARE_AND_SET_RELEASE,\n+                        WEAK_COMPARE_AND_SET_ACQUIRE, WEAK_COMPARE_AND_SET_PLAIN,\n+                        COMPARE_AND_EXCHANGE, COMPARE_AND_EXCHANGE_ACQUIRE,\n+                        COMPARE_AND_EXCHANGE_RELEASE, COMPARE_AND_SET -> ATOMIC_UPDATE;\n+                case GET_AND_ADD, GET_AND_ADD_ACQUIRE, GET_AND_ADD_RELEASE -> ATOMIC_NUMERIC_UPDATE;\n+                default -> ATOMIC_BITWISE_UPDATE;\n+            };\n+        }\n+\n+        static Set<AccessModeKind> supportedModes(ValueLayout layout) {\n+            Set<AccessModeKind> supportedModes = EnumSet.noneOf(AccessModeKind.class);\n+            supportedModes.add(PLAIN);\n+            if (layout.byteAlignment() >= layout.byteSize()) {\n+                supportedModes.add(READ_WRITE);\n+                if (layout instanceof ValueLayout.OfInt || layout instanceof ValueLayout.OfLong ||\n+                        layout instanceof ValueLayout.OfFloat || layout instanceof ValueLayout.OfDouble ||\n+                        layout instanceof AddressLayout) {\n+                    supportedModes.add(ATOMIC_UPDATE);\n+                }\n+                if (layout instanceof ValueLayout.OfInt || layout instanceof ValueLayout.OfLong ||\n+                        layout instanceof AddressLayout) {\n+                    supportedModes.add(ATOMIC_NUMERIC_UPDATE);\n+                    supportedModes.add(ATOMIC_BITWISE_UPDATE);\n+                }\n+            }\n+            return supportedModes;\n+        }\n+    }\n+\n+    static MemoryLayout[] layouts() {\n+        MemoryLayout[] valueLayouts = {\n+                ValueLayout.JAVA_BOOLEAN,\n+                ValueLayout.JAVA_CHAR,\n+                ValueLayout.JAVA_BYTE,\n+                ValueLayout.JAVA_SHORT,\n+                ValueLayout.JAVA_INT,\n+                ValueLayout.JAVA_FLOAT,\n+                ValueLayout.JAVA_LONG,\n+                ValueLayout.JAVA_DOUBLE,\n+                ValueLayout.ADDRESS\n+        };\n+        List<MemoryLayout> layouts = new ArrayList<>();\n+        for (MemoryLayout layout : valueLayouts) {\n+            for (int align : new int[] { 1, 2, 4, 8 }) {\n+                layouts.add(layout.withByteAlignment(align));\n+            }\n+        }\n+        return layouts.toArray(new MemoryLayout[0]);\n+    }\n+\n+    static MemorySegment[] segments() {\n+        return new MemorySegment[]{\n+                Arena.ofAuto().allocate(8),\n+                MemorySegment.ofArray(new byte[8]),\n+                MemorySegment.ofArray(new char[4]),\n+                MemorySegment.ofArray(new short[4]),\n+                MemorySegment.ofArray(new int[2]),\n+                MemorySegment.ofArray(new float[2]),\n+                MemorySegment.ofArray(new long[1]),\n+                MemorySegment.ofArray(new double[1])\n+        };\n+    }\n+\n+    @DataProvider(name = \"segmentsAndLayoutsAndModes\")\n+    static Object[][] segmentsAndLayoutsAndModes() {\n+        List<Object[]> segmentsAndLayouts = new ArrayList<>();\n+        for (MemorySegment segment : segments()) {\n+            for (MemoryLayout layout : layouts()) {\n+                for (AccessMode mode : AccessMode.values()) {\n+                    segmentsAndLayouts.add(new Object[]{segment, layout, mode});\n+                }\n+            }\n+        }\n+        return segmentsAndLayouts.toArray(new Object[0][]);\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/foreign\/TestAccessModes.java","additions":179,"deletions":0,"binary":false,"changes":179,"status":"added"},{"patch":"@@ -27,1 +27,0 @@\n- * @enablePreview\n@@ -86,1 +85,2 @@\n-    static final VarHandle intHandleIndexed = ValueLayout.JAVA_INT.arrayElementVarHandle();\n+    static final VarHandle intHandleIndexed = MethodHandles.insertCoordinates(\n+            ValueLayout.JAVA_INT.arrayElementVarHandle(), 1, 0L);\n@@ -88,1 +88,1 @@\n-    static final VarHandle intHandle = ValueLayout.JAVA_INT.varHandle();\n+    static final VarHandle intHandle = MethodHandles.insertCoordinates(ValueLayout.JAVA_INT.varHandle(), 1, 0L);\n@@ -90,1 +90,1 @@\n-    static final VarHandle floatHandle = ValueLayout.JAVA_FLOAT.varHandle();\n+    static final VarHandle floatHandle = MethodHandles.insertCoordinates(ValueLayout.JAVA_FLOAT.varHandle(), 1, 0L);\n@@ -99,2 +99,2 @@\n-        i2SHandle.set(segment, \"1\");\n-        String oldValue = (String)i2SHandle.getAndAdd(segment, \"42\");\n+        i2SHandle.set(segment, 0L, \"1\");\n+        String oldValue = (String)i2SHandle.getAndAdd(segment, 0L, \"42\");\n@@ -102,1 +102,1 @@\n-        String value = (String)i2SHandle.get(segment);\n+        String value = (String)i2SHandle.get(segment, 0L);\n@@ -104,1 +104,1 @@\n-        boolean swapped = (boolean)i2SHandle.compareAndSet(segment, \"43\", \"12\");\n+        boolean swapped = (boolean)i2SHandle.compareAndSet(segment, 0L, \"43\", \"12\");\n@@ -106,1 +106,1 @@\n-        oldValue = (String)i2SHandle.compareAndExchange(segment, \"12\", \"42\");\n+        oldValue = (String)i2SHandle.compareAndExchange(segment, 0L, \"12\", \"42\");\n@@ -108,1 +108,1 @@\n-        value = (String)i2SHandle.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment);\n+        value = (String)i2SHandle.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment, 0L);\n@@ -120,3 +120,3 @@\n-        i2SHandle = MethodHandles.insertCoordinates(i2SHandle, 1, \"a\", \"b\");\n-        i2SHandle.set(segment, \"1\");\n-        String oldValue = (String)i2SHandle.getAndAdd(segment, \"42\");\n+        i2SHandle = MethodHandles.insertCoordinates(i2SHandle, 2, \"a\", \"b\");\n+        i2SHandle.set(segment, 0L, \"1\");\n+        String oldValue = (String)i2SHandle.getAndAdd(segment, 0L, \"42\");\n@@ -124,1 +124,1 @@\n-        String value = (String)i2SHandle.get(segment);\n+        String value = (String)i2SHandle.get(segment, 0L);\n@@ -126,1 +126,1 @@\n-        boolean swapped = (boolean)i2SHandle.compareAndSet(segment, \"43\", \"12\");\n+        boolean swapped = (boolean)i2SHandle.compareAndSet(segment, 0L, \"43\", \"12\");\n@@ -128,1 +128,1 @@\n-        oldValue = (String)i2SHandle.compareAndExchange(segment, \"12\", \"42\");\n+        oldValue = (String)i2SHandle.compareAndExchange(segment, 0L, \"12\", \"42\");\n@@ -130,1 +130,1 @@\n-        value = (String)i2SHandle.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment);\n+        value = (String)i2SHandle.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment, 0L);\n@@ -141,2 +141,2 @@\n-        i2SHandle.set(segment, \"1\");\n-        String oldValue = (String)i2SHandle.getAndAdd(segment, \"42\");\n+        i2SHandle.set(segment, 0L, \"1\");\n+        String oldValue = (String)i2SHandle.getAndAdd(segment, 0L, \"42\");\n@@ -144,1 +144,1 @@\n-        String value = (String)i2SHandle.get(segment);\n+        String value = (String)i2SHandle.get(segment, 0L);\n@@ -146,1 +146,1 @@\n-        boolean swapped = (boolean)i2SHandle.compareAndSet(segment, \"43\", \"12\");\n+        boolean swapped = (boolean)i2SHandle.compareAndSet(segment, 0L, \"43\", \"12\");\n@@ -148,1 +148,1 @@\n-        oldValue = (String)i2SHandle.compareAndExchange(segment, \"12\", \"42\");\n+        oldValue = (String)i2SHandle.compareAndExchange(segment, 0L, \"12\", \"42\");\n@@ -150,1 +150,1 @@\n-        value = (String)(Object)i2SHandle.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment);\n+        value = (String)(Object)i2SHandle.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment, 0L);\n@@ -197,2 +197,2 @@\n-            vh.set(seg, \"42\");\n-            String x = (String) vh.get(seg); \/\/ should throw\n+            vh.set(seg, 0L, \"42\");\n+            String x = (String) vh.get(seg, 0L); \/\/ should throw\n@@ -208,1 +208,1 @@\n-            vh.set(seg, \"42\"); \/\/ should throw\n+            vh.set(seg, 0L, \"42\"); \/\/ should throw\n","filename":"test\/jdk\/java\/foreign\/TestAdaptVarHandles.java","additions":26,"deletions":26,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n@@ -28,1 +27,0 @@\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -43,0 +41,2 @@\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n@@ -187,0 +187,2 @@\n+        private static final Pattern LAYOUT_PATTERN = Pattern.compile(\"^(?<align>\\\\d+%)?(?<char>[azcsifjdAZCSIFJD])\\\\d+$\");\n+\n@@ -188,11 +190,14 @@\n-            return switch (layoutString.charAt(0)) {\n-                case 'A','a' -> ADDRESS;\n-                case 'z','Z' -> BOOL;\n-                case 'c','C' -> CHAR;\n-                case 's','S' -> SHORT;\n-                case 'i','I' -> INT;\n-                case 'f','F' -> FLOAT;\n-                case 'j','J' -> LONG;\n-                case 'd','D' -> DOUBLE;\n-                default -> throw new AssertionError(\"Invalid layout string: \" + layoutString);\n-            };\n+            Matcher matcher = LAYOUT_PATTERN.matcher(layoutString);\n+            if (matcher.matches()) {\n+                switch (matcher.group(\"char\")) {\n+                    case \"A\",\"a\": return ADDRESS;\n+                    case \"z\",\"Z\": return BOOL;\n+                    case \"c\",\"C\": return CHAR;\n+                    case \"s\",\"S\": return SHORT;\n+                    case \"i\",\"I\": return INT;\n+                    case \"f\",\"F\": return FLOAT;\n+                    case \"j\",\"J\": return LONG;\n+                    case \"d\",\"D\": return DOUBLE;\n+                };\n+            }\n+            throw new AssertionError(\"Invalid layout string: \" + layoutString);\n","filename":"test\/jdk\/java\/foreign\/TestAddressDereference.java","additions":18,"deletions":13,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @enablePreview\n@@ -30,0 +29,1 @@\n+import java.lang.foreign.MemoryLayout;\n@@ -32,0 +32,3 @@\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n@@ -291,0 +294,4 @@\n+    private static VarHandle arrayVarHandle(ValueLayout layout) {\n+        return MethodHandles.insertCoordinates(layout.arrayElementVarHandle(), 1, 0L);\n+    }\n+\n@@ -292,2 +299,2 @@\n-        VarHandle indexedHandleNO = helper.elementLayout.withOrder(NATIVE_ORDER).arrayElementVarHandle();\n-        VarHandle indexedHandleNNO = helper.elementLayout.withOrder(NON_NATIVE_ORDER).arrayElementVarHandle();\n+        VarHandle indexedHandleNO = arrayVarHandle(helper.elementLayout.withOrder(NATIVE_ORDER));\n+        VarHandle indexedHandleNNO = arrayVarHandle(helper.elementLayout.withOrder(NON_NATIVE_ORDER));\n","filename":"test\/jdk\/java\/foreign\/TestArrayCopy.java","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @enablePreview\n@@ -34,0 +33,3 @@\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n@@ -147,1 +149,1 @@\n-                (base) -> initBytes(base, bytes, (addr, pos) -> byteHandle.set(addr, pos, (byte)(long)pos));\n+                (base) -> initBytes(base, bytes, (addr, pos) -> byteHandle.set(addr, 0L, pos, (byte)(long)pos));\n@@ -149,1 +151,1 @@\n-                (base) -> initBytes(base, chars, (addr, pos) -> charHandle.set(addr, pos, (char)(long)pos));\n+                (base) -> initBytes(base, chars, (addr, pos) -> charHandle.set(addr, 0L, pos, (char)(long)pos));\n@@ -151,1 +153,1 @@\n-                (base) -> initBytes(base, shorts, (addr, pos) -> shortHandle.set(addr, pos, (short)(long)pos));\n+                (base) -> initBytes(base, shorts, (addr, pos) -> shortHandle.set(addr, 0L, pos, (short)(long)pos));\n@@ -153,1 +155,1 @@\n-                (base) -> initBytes(base, ints, (addr, pos) -> intHandle.set(addr, pos, (int)(long)pos));\n+                (base) -> initBytes(base, ints, (addr, pos) -> intHandle.set(addr, 0L, pos, (int)(long)pos));\n@@ -155,1 +157,1 @@\n-                (base) -> initBytes(base, floats, (addr, pos) -> floatHandle.set(addr, pos, (float)(long)pos));\n+                (base) -> initBytes(base, floats, (addr, pos) -> floatHandle.set(addr, 0L, pos, (float)(long)pos));\n@@ -157,1 +159,1 @@\n-                (base) -> initBytes(base, longs, (addr, pos) -> longHandle.set(addr, pos, (long)pos));\n+                (base) -> initBytes(base, longs, (addr, pos) -> longHandle.set(addr, 0L, pos, (long)pos));\n@@ -159,1 +161,1 @@\n-                (base) -> initBytes(base, doubles, (addr, pos) -> doubleHandle.set(addr, pos, (double)(long)pos));\n+                (base) -> initBytes(base, doubles, (addr, pos) -> doubleHandle.set(addr, 0L, pos, (double)(long)pos));\n@@ -162,1 +164,1 @@\n-                (base) -> checkBytes(base, bytes, s -> s.toArray(JAVA_BYTE), (addr, pos) -> (byte)byteHandle.get(addr, pos));\n+                (base) -> checkBytes(base, bytes, s -> s.toArray(JAVA_BYTE), (addr, pos) -> (byte)byteHandle.get(addr, 0L, pos));\n@@ -164,1 +166,1 @@\n-                (base) -> checkBytes(base, shorts, s -> s.toArray(JAVA_SHORT), (addr, pos) -> (short)shortHandle.get(addr, pos));\n+                (base) -> checkBytes(base, shorts, s -> s.toArray(JAVA_SHORT), (addr, pos) -> (short)shortHandle.get(addr, 0L, pos));\n@@ -166,1 +168,1 @@\n-                (base) -> checkBytes(base, chars, s -> s.toArray(JAVA_CHAR), (addr, pos) -> (char)charHandle.get(addr, pos));\n+                (base) -> checkBytes(base, chars, s -> s.toArray(JAVA_CHAR), (addr, pos) -> (char)charHandle.get(addr, 0L, pos));\n@@ -168,1 +170,1 @@\n-                (base) -> checkBytes(base, ints, s -> s.toArray(JAVA_INT), (addr, pos) -> (int)intHandle.get(addr, pos));\n+                (base) -> checkBytes(base, ints, s -> s.toArray(JAVA_INT), (addr, pos) -> (int)intHandle.get(addr, 0L, pos));\n@@ -170,1 +172,1 @@\n-                (base) -> checkBytes(base, floats, s -> s.toArray(JAVA_FLOAT), (addr, pos) -> (float)floatHandle.get(addr, pos));\n+                (base) -> checkBytes(base, floats, s -> s.toArray(JAVA_FLOAT), (addr, pos) -> (float)floatHandle.get(addr, 0L, pos));\n@@ -172,1 +174,1 @@\n-                (base) -> checkBytes(base, longs, s -> s.toArray(JAVA_LONG), (addr, pos) -> (long)longHandle.get(addr, pos));\n+                (base) -> checkBytes(base, longs, s -> s.toArray(JAVA_LONG), (addr, pos) -> (long)longHandle.get(addr, 0L, pos));\n@@ -174,1 +176,1 @@\n-                (base) -> checkBytes(base, doubles, s -> s.toArray(JAVA_DOUBLE), (addr, pos) -> (double)doubleHandle.get(addr, pos));\n+                (base) -> checkBytes(base, doubles, s -> s.toArray(JAVA_DOUBLE), (addr, pos) -> (double)doubleHandle.get(addr, 0L, pos));\n","filename":"test\/jdk\/java\/foreign\/TestArrays.java","additions":17,"deletions":15,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n@@ -73,3 +72,0 @@\n-import jdk.internal.foreign.HeapMemorySegmentImpl;\n-import jdk.internal.foreign.MappedMemorySegmentImpl;\n-import jdk.internal.foreign.NativeMemorySegmentImpl;\n@@ -125,2 +121,2 @@\n-            indexHandle.set(base, i, (int)i);\n-            valueHandle.set(base, i, (float)(i \/ 500f));\n+            indexHandle.set(base, 0L, i, (int)i);\n+            valueHandle.set(base, 0L, i, (float)(i \/ 500f));\n@@ -134,2 +130,2 @@\n-            assertEquals(index = bb.getInt(), (int)indexHandle.get(base, i));\n-            assertEquals(value = bb.getFloat(), (float)valueHandle.get(base, i));\n+            assertEquals(index = bb.getInt(), (int)indexHandle.get(base, 0L, i));\n+            assertEquals(value = bb.getFloat(), (float)valueHandle.get(base, 0L, i));\n@@ -991,3 +987,3 @@\n-        Predicate<MemorySegment> heapTest = segment -> segment instanceof HeapMemorySegmentImpl;\n-        Predicate<MemorySegment> nativeTest = segment -> segment instanceof NativeMemorySegmentImpl;\n-        Predicate<MemorySegment> mappedTest = segment -> segment instanceof MappedMemorySegmentImpl;\n+        Predicate<MemorySegment> heapTest = segment -> !segment.isNative() && !segment.isMapped();\n+        Predicate<MemorySegment> nativeTest = segment -> segment.isNative() && !segment.isMapped();\n+        Predicate<MemorySegment> mappedTest = segment -> segment.isNative() && segment.isMapped();\n@@ -1005,1 +1001,1 @@\n-                            nativeTest \/* this seems to be an existing bug in the BB implementation *\/ }\n+                            mappedTest }\n","filename":"test\/jdk\/java\/foreign\/TestByteBuffer.java","additions":8,"deletions":12,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/TestClassLoaderFindNative.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,101 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=Arena_allocateFrom\n+ * @run main\/othervm\/timeout=5 --enable-native-access=ALL-UNNAMED -Xlog:class+init TestDeadlock Arena\n+ *\/\n+\n+\/*\n+ * @test id=FileChannel_map\n+ * @run main\/othervm\/timeout=5 --enable-native-access=ALL-UNNAMED -Xlog:class+init TestDeadlock FileChannel\n+ *\/\n+\n+import java.lang.foreign.*;\n+import java.io.IOException;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.concurrent.CountDownLatch;\n+\n+public class TestDeadlock {\n+    public static void main(String[] args) throws Throwable {\n+        CountDownLatch latch = new CountDownLatch(2);\n+\n+        Runnable tester = switch (args[0]) {\n+            case \"Arena\" -> () -> {\n+                Arena arena = Arena.global();\n+                arena.scope(); \/\/ init ArenaImpl\n+                ValueLayout.JAVA_INT.byteSize(); \/\/ init ValueLayout (and impls)\n+                latch.countDown();\n+                try {\n+                    latch.await();\n+                } catch(InterruptedException e) {\n+                    throw new RuntimeException(e);\n+                }\n+\n+                \/\/ Access ArenaImpl -> NativeMemorySegmentImpl -> MemorySegment\n+                arena.allocateFrom(ValueLayout.JAVA_INT, 42);\n+            };\n+            case \"FileChannel\" -> () -> {\n+                try {\n+                    Arena arena = Arena.global();\n+                    Path p = Files.createFile(Path.of(\"test.out\"));\n+\n+                    try (FileChannel channel = FileChannel.open(p, StandardOpenOption.READ, StandardOpenOption.WRITE)) {\n+                        channel.map(FileChannel.MapMode.READ_WRITE, 0, 4); \/\/ create MappedByteBuffer to initialize other things\n+                        latch.countDown();\n+                        latch.await();\n+\n+                        \/\/ Access MappedMemorySegmentImpl -> MemorySegment\n+                        channel.map(FileChannel.MapMode.READ_WRITE, 0, 4, arena);\n+                    }\n+                } catch(InterruptedException | IOException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            };\n+            default -> throw new IllegalArgumentException(\"Unknown test selection: \" + args[0]);\n+        };\n+\n+        Thread t1 = Thread.ofPlatform().start(tester);\n+        Thread t2 = Thread.ofPlatform().start(() -> {\n+            latch.countDown();\n+            try {\n+                latch.await();\n+            } catch(InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+\n+            \/\/ Access MemorySegment -> NativeMemorySegmentImpl\n+            MemorySegment.ofAddress(42);\n+        });\n+\n+        \/\/ wait for potential deadlock\n+\n+        t1.join();\n+        t2.join();\n+\n+        \/\/ all good\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/TestDeadlock.java","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"},{"patch":"@@ -27,1 +27,0 @@\n- * @enablePreview\n@@ -76,1 +75,1 @@\n-            int val = (int) abcx.get(a);\n+            int val = (int) abcx.get(a, 0L);\n@@ -101,2 +100,2 @@\n-            MemorySegment b = arena.allocateArray(B, 2);\n-            MemorySegment c = arena.allocateArray(C, 4);\n+            MemorySegment b = arena.allocate(B, 2);\n+            MemorySegment c = arena.allocate(C, 4);\n@@ -112,1 +111,1 @@\n-            int val00 = (int) abcx_multi.get(a, 0, 0); \/\/ a->b[0]->c[0] = 1\n+            int val00 = (int) abcx_multi.get(a, 0L, 0, 0); \/\/ a->b[0]->c[0] = 1\n@@ -114,1 +113,1 @@\n-            int val10 = (int) abcx_multi.get(a, 1, 0); \/\/ a->b[1]->c[0] = 3\n+            int val10 = (int) abcx_multi.get(a, 0L, 1, 0); \/\/ a->b[1]->c[0] = 3\n@@ -116,1 +115,1 @@\n-            int val01 = (int) abcx_multi.get(a, 0, 1); \/\/ a->b[0]->c[1] = 2\n+            int val01 = (int) abcx_multi.get(a, 0L, 0, 1); \/\/ a->b[0]->c[1] = 2\n@@ -118,1 +117,1 @@\n-            int val11 = (int) abcx_multi.get(a, 1, 1); \/\/ a->b[1]->c[1] = 4\n+            int val11 = (int) abcx_multi.get(a, 0L, 1, 1); \/\/ a->b[1]->c[1] = 4\n@@ -155,1 +154,1 @@\n-            vhX.set(segment, 42); \/\/ should throw\n+            vhX.set(segment, 0L, 42); \/\/ should throw\n","filename":"test\/jdk\/java\/foreign\/TestDereferencePath.java","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/TestDowncallScope.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/TestDowncallStack.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/TestFallbackLookup.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @enablePreview\n@@ -42,1 +41,1 @@\n-        assertEquals(str, addr.getUtf8String(0));\n+        assertEquals(str, addr.getString(0));\n","filename":"test\/jdk\/java\/foreign\/TestFree.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/TestFunctionDescriptor.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/TestHFA.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/TestHandshake.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -48,2 +46,2 @@\n-        assertAligned(align, layout, () -> layout.varHandle().get(segment));\n-        assertAligned(align, layout, () -> layout.varHandle().set(segment, val));\n+        assertAligned(align, layout, () -> layout.varHandle().get(segment, 0L));\n+        assertAligned(align, layout, () -> layout.varHandle().set(segment, 0L, val));\n@@ -51,2 +49,2 @@\n-        assertAligned(align, layout, () -> seq.varHandle(MemoryLayout.PathElement.sequenceElement()).get(segment, 0L));\n-        assertAligned(align, layout, () -> seq.varHandle(MemoryLayout.PathElement.sequenceElement()).set(segment, 0L, val));\n+        assertAligned(align, layout, () -> seq.varHandle(MemoryLayout.PathElement.sequenceElement()).get(segment, 0L, 0L));\n+        assertAligned(align, layout, () -> seq.varHandle(MemoryLayout.PathElement.sequenceElement()).set(segment, 0L, 0L, val));\n","filename":"test\/jdk\/java\/foreign\/TestHeapAlignment.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -50,0 +48,2 @@\n+import static java.lang.foreign.ValueLayout.*;\n+\n@@ -105,1 +105,1 @@\n-            { Linker.Option.isTrivial() },\n+            { Linker.Option.critical() },\n@@ -131,1 +131,1 @@\n-                    IS_LE ? \"Unsupported layout: 2%a8\" : \"Unsupported layout: 2%A8\"\n+                    (IS_LE ? \"Unsupported layout: 2%a\" : \"Unsupported layout: 2%A\")  + ADDRESS.byteSize()\n@@ -159,1 +159,1 @@\n-                            MemoryLayout.sequenceLayout(\n+                            MemoryLayout.sequenceLayout(1,\n@@ -184,1 +184,1 @@\n-                    FunctionDescriptor.of(MemoryLayout.structLayout(MemoryLayout.sequenceLayout(C_INT.withOrder(nonNativeOrder())))),\n+                    FunctionDescriptor.of(MemoryLayout.structLayout(MemoryLayout.sequenceLayout(1, C_INT.withOrder(nonNativeOrder())))),\n@@ -188,7 +188,0 @@\n-            {\n-                    FunctionDescriptor.ofVoid(MemoryLayout.structLayout(\n-                            ValueLayout.JAVA_LONG,\n-                            ValueLayout.JAVA_INT)), \/\/ missing trailing padding\n-                    NO_OPTIONS,\n-                    \"has unexpected size\"\n-            },\n@@ -202,0 +195,5 @@\n+            {\n+                    FunctionDescriptor.ofVoid(),\n+                    new Linker.Option[]{Linker.Option.critical(), Linker.Option.captureCallState(\"errno\")},\n+                    \"Incompatible linker options: captureCallState, critical\"\n+            },\n@@ -215,1 +213,1 @@\n-                            MemoryLayout.sequenceLayout(\n+                            MemoryLayout.sequenceLayout(Long.MAX_VALUE \/ C_INT.byteSize(),\n@@ -222,0 +220,9 @@\n+        if (ValueLayout.JAVA_LONG.byteAlignment() == 8) {\n+            cases.add(new Object[]{\n+                    FunctionDescriptor.ofVoid(MemoryLayout.structLayout(\n+                            ValueLayout.JAVA_LONG,\n+                            ValueLayout.JAVA_INT)), \/\/ missing trailing padding\n+                    NO_OPTIONS,\n+                    \"has unexpected size\"\n+            });\n+        }\n","filename":"test\/jdk\/java\/foreign\/TestIllegalLink.java","additions":21,"deletions":14,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/TestIntrinsics.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/TestLargeSegmentCopy.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @enablePreview\n@@ -38,0 +37,1 @@\n+import java.nio.ByteOrder;\n@@ -139,1 +139,1 @@\n-    public void testBadAlignmentOfRoot() throws Throwable {\n+    public void testBadAlignmentOfRoot() {\n@@ -141,2 +141,2 @@\n-            JAVA_INT,\n-            JAVA_SHORT.withName(\"x\"));\n+            JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN),\n+            JAVA_SHORT.withOrder(ByteOrder.LITTLE_ENDIAN).withName(\"x\"));\n@@ -150,1 +150,1 @@\n-            String expectedMessage = \"Target offset incompatible with alignment constraints: \" + struct.byteAlignment();\n+            String expectedMessage = \"Target offset 0 is incompatible with alignment constraint \" + struct.byteAlignment() + \" (of [i4s2(x)]) for segment MemorySegment\";\n@@ -154,1 +154,1 @@\n-                vhX.set(seg, (short) 42);\n+                vhX.set(seg, 0L, (short) 42);\n@@ -156,1 +156,1 @@\n-            assertEquals(iae.getMessage(), expectedMessage);\n+            assertTrue(iae.getMessage().startsWith(expectedMessage));\n@@ -160,1 +160,1 @@\n-                MemorySegment slice = (MemorySegment) sliceX.invokeExact(seg);\n+                MemorySegment slice = (MemorySegment) sliceX.invokeExact(seg, 0L);\n@@ -162,1 +162,1 @@\n-            assertEquals(iae.getMessage(), expectedMessage);\n+            assertTrue(iae.getMessage().startsWith(expectedMessage));\n@@ -166,0 +166,36 @@\n+    @Test\n+    public void testWrongTypeRoot() {\n+        MemoryLayout struct = MemoryLayout.structLayout(\n+                JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN),\n+                JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN)\n+        );\n+\n+        var expectedMessage = \"Bad layout path: attempting to select a sequence element from a non-sequence layout: [i4i4]\";\n+\n+        IllegalArgumentException iae = expectThrows(IllegalArgumentException.class, () ->\n+                struct.select(PathElement.sequenceElement()));\n+        assertEquals(iae.getMessage(), expectedMessage);\n+    }\n+\n+    @Test\n+    public void testWrongTypeEnclosing() {\n+        MemoryLayout struct = MemoryLayout.structLayout(\n+                MemoryLayout.sequenceLayout(2, MemoryLayout.structLayout(\n+                                JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN).withName(\"3a\"),\n+                                JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN).withName(\"3b\")\n+                        ).withName(\"2\")\n+                ).withName(\"1\")\n+        ).withName(\"0\");\n+\n+        var expectedMessage = \"Bad layout path: attempting to select a sequence element from a non-sequence layout: \" +\n+                \"[i4(3a)i4(3b)](2), selected from: \" +\n+                \"[2:[i4(3a)i4(3b)](2)](1), selected from: \" +\n+                \"[[2:[i4(3a)i4(3b)](2)](1)](0)\";\n+\n+        IllegalArgumentException iae = expectThrows(IllegalArgumentException.class, () ->\n+                struct.select(PathElement.groupElement(\"1\"),\n+                        PathElement.sequenceElement(),\n+                        PathElement.sequenceElement()));\n+        assertEquals(iae.getMessage(), expectedMessage);\n+    }\n+\n@@ -274,1 +310,1 @@\n-        long actualByteOffset = (long) byteOffsetHandle.invokeExact(indexes);\n+        long actualByteOffset = (long) byteOffsetHandle.invokeExact(0L, indexes);\n@@ -363,1 +399,1 @@\n-            MemorySegment slice = (MemorySegment) sliceHandle.invokeExact(segment, indexes);\n+            MemorySegment slice = (MemorySegment) sliceHandle.invokeExact(segment, 0L, indexes);\n","filename":"test\/jdk\/java\/foreign\/TestLayoutPaths.java","additions":47,"deletions":11,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n@@ -101,1 +100,1 @@\n-                indexHandle.set(segment, (long)i, i);\n+                indexHandle.set(segment, 0L, (long)i, i);\n@@ -106,2 +105,2 @@\n-                int expected = (int)indexHandle.get(segment, (long)i);\n-                int found = (int)preindexHandle.get(segment);\n+                int expected = (int)indexHandle.get(segment, 0L, (long)i);\n+                int found = (int)preindexHandle.get(segment, 0L);\n@@ -204,6 +203,1 @@\n-    @Test(dataProvider = \"basicLayouts\")\n-    public void testSequenceInferredCount(MemoryLayout layout) {\n-        assertEquals(MemoryLayout.sequenceLayout(layout),\n-                     MemoryLayout.sequenceLayout(Long.MAX_VALUE \/ layout.byteSize(), layout));\n-    }\n-\n+    @Test\n@@ -303,1 +297,1 @@\n-        MemoryLayout.sequenceLayout(layout);\n+        MemoryLayout.sequenceLayout(1, layout);\n@@ -310,1 +304,1 @@\n-            MemoryLayout.sequenceLayout(layout);\n+            MemoryLayout.sequenceLayout(1, layout);\n@@ -341,8 +335,0 @@\n-    @Test(dataProvider=\"layoutsAndAlignments\")\n-    public void testArrayElementVarHandleBadAlignment(MemoryLayout layout, long byteAlign) {\n-        if (layout instanceof ValueLayout) {\n-            assertThrows(UnsupportedOperationException.class, () ->\n-                    ((ValueLayout) layout).withByteAlignment(byteAlign * 2).arrayElementVarHandle());\n-        }\n-    }\n-\n@@ -362,0 +348,31 @@\n+    @Test\n+    public void testVarHandleCaching() {\n+        assertSame(JAVA_INT.varHandle(), JAVA_INT.varHandle());\n+        assertSame(JAVA_INT.withName(\"foo\").varHandle(), JAVA_INT.varHandle());\n+\n+        assertNotSame(JAVA_INT_UNALIGNED.varHandle(), JAVA_INT.varHandle());\n+        assertNotSame(ADDRESS.withTargetLayout(JAVA_INT).varHandle(), ADDRESS.varHandle());\n+    }\n+\n+    @Test(expectedExceptions=IllegalArgumentException.class,\n+        expectedExceptionsMessageRegExp=\".*Negative offset.*\")\n+    public void testScaleNegativeOffset() {\n+        JAVA_INT.scale(-1, 0);\n+    }\n+\n+    @Test(expectedExceptions=IllegalArgumentException.class,\n+        expectedExceptionsMessageRegExp=\".*Negative index.*\")\n+    public void testScaleNegativeIndex() {\n+        JAVA_INT.scale(0, -1);\n+    }\n+\n+    @Test(expectedExceptions=ArithmeticException.class)\n+    public void testScaleAddOverflow() {\n+        JAVA_INT.scale(Long.MAX_VALUE, 1);\n+    }\n+\n+    @Test(expectedExceptions=ArithmeticException.class)\n+    public void testScaleMultiplyOverflow() {\n+        JAVA_INT.scale(0, Long.MAX_VALUE);\n+    }\n+\n@@ -499,1 +516,0 @@\n-                MemoryLayout.sequenceLayout(JAVA_INT),\n","filename":"test\/jdk\/java\/foreign\/TestLayouts.java","additions":37,"deletions":21,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -40,0 +38,2 @@\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.ValueLayout;\n@@ -48,0 +48,1 @@\n+import static org.testng.Assert.assertNotNull;\n@@ -50,0 +51,1 @@\n+import static org.testng.Assert.assertTrue;\n@@ -94,4 +96,0 @@\n-            { FunctionDescriptor.ofVoid(structLayout(C_INT, paddingLayout(4), C_LONG_LONG)),\n-                    FunctionDescriptor.ofVoid(structLayout(C_INT, paddingLayout(4), C_LONG_LONG.withName(\"x\"))) },\n-            { FunctionDescriptor.ofVoid(structLayout(C_INT, paddingLayout(4), C_LONG_LONG)),\n-                    FunctionDescriptor.ofVoid(structLayout(C_INT, paddingLayout(4).withName(\"x\"), C_LONG_LONG)) },\n@@ -116,0 +114,6 @@\n+        if (C_LONG_LONG.byteAlignment() == 8) {\n+            cases.add(new Object[]{ FunctionDescriptor.ofVoid(structLayout(C_INT, paddingLayout(4), C_LONG_LONG)),\n+                    FunctionDescriptor.ofVoid(structLayout(C_INT, paddingLayout(4), C_LONG_LONG.withName(\"x\"))) });\n+            cases.add(new Object[]{ FunctionDescriptor.ofVoid(structLayout(C_INT, paddingLayout(4), C_LONG_LONG)),\n+                    FunctionDescriptor.ofVoid(structLayout(C_INT, paddingLayout(4).withName(\"x\"), C_LONG_LONG)) });\n+        }\n@@ -143,0 +147,28 @@\n+    @Test(dataProvider = \"canonicalTypeNames\")\n+    public void testCanonicalLayouts(String typeName) {\n+        MemoryLayout layout = LINKER.canonicalLayouts().get(typeName);\n+        assertNotNull(layout);\n+        assertTrue(layout instanceof ValueLayout);\n+    }\n+\n+    @DataProvider\n+    public static Object[][] canonicalTypeNames() {\n+        return new Object[][]{\n+                { \"bool\" },\n+                { \"char\" },\n+                { \"short\" },\n+                { \"int\" },\n+                { \"long\" },\n+                { \"long long\" },\n+                { \"float\" },\n+                { \"double\" },\n+                { \"void*\" },\n+                { \"size_t\" },\n+                { \"wchar_t\" },\n+        };\n+    }\n+\n+    @Test(expectedExceptions=UnsupportedOperationException.class)\n+    public void testCanonicalLayoutsUnmodifiable() {\n+        LINKER.canonicalLayouts().put(\"asdf\", C_INT);\n+    }\n","filename":"test\/jdk\/java\/foreign\/TestLinker.java","additions":39,"deletions":7,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,2 +35,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -48,2 +46,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -61,2 +57,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -74,2 +68,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -87,2 +79,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -99,2 +89,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -111,2 +99,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -123,2 +109,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -135,2 +119,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -148,2 +130,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -161,2 +141,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -174,2 +152,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -187,2 +163,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -200,2 +174,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -213,2 +185,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -226,2 +196,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -239,2 +207,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -252,2 +218,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -265,2 +229,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -278,2 +240,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -292,2 +252,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/TestMatrix.java","additions":1,"deletions":43,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n@@ -69,6 +68,0 @@\n-    @Test(dataProvider = \"arrayElements\")\n-    public void testArrayAccessAlt(Function<MemorySegment, MemorySegment> viewFactory, ValueLayout elemLayout, ArrayChecker checker) {\n-        SequenceLayout seq = MemoryLayout.sequenceLayout(10, elemLayout.withName(\"elem\"));\n-        testArrayAccessInternal(viewFactory, seq, elemLayout.arrayElementVarHandle(), checker);\n-    }\n-\n@@ -161,7 +154,0 @@\n-    @Test(dataProvider = \"matrixElements\")\n-    public void testMatrixAccessAlt(Function<MemorySegment, MemorySegment> viewFactory, ValueLayout elemLayout, MatrixChecker checker) {\n-        SequenceLayout seq = MemoryLayout.sequenceLayout(20,\n-                MemoryLayout.sequenceLayout(10, elemLayout.withName(\"elem\")));\n-        testMatrixAccessInternal(viewFactory, seq, elemLayout.arrayElementVarHandle(10), checker);\n-    }\n-\n@@ -270,2 +256,2 @@\n-            handle.set(segment, (byte)42);\n-            assertEquals(42, (byte)handle.get(segment));\n+            handle.set(segment, 0L, (byte)42);\n+            assertEquals(42, (byte)handle.get(segment, 0L));\n@@ -275,2 +261,2 @@\n-            handle.set(segment, (short)42);\n-            assertEquals(42, (short)handle.get(segment));\n+            handle.set(segment, 0L, (short)42);\n+            assertEquals(42, (short)handle.get(segment, 0L));\n@@ -280,2 +266,2 @@\n-            handle.set(segment, (char)42);\n-            assertEquals(42, (char)handle.get(segment));\n+            handle.set(segment, 0L, (char)42);\n+            assertEquals(42, (char)handle.get(segment, 0L));\n@@ -285,2 +271,2 @@\n-            handle.set(segment, 42);\n-            assertEquals(42, (int)handle.get(segment));\n+            handle.set(segment, 0L, 42);\n+            assertEquals(42, (int)handle.get(segment, 0L));\n@@ -290,2 +276,2 @@\n-            handle.set(segment, (long)42);\n-            assertEquals(42, (long)handle.get(segment));\n+            handle.set(segment, 0L, (long)42);\n+            assertEquals(42, (long)handle.get(segment, 0L));\n@@ -295,2 +281,2 @@\n-            handle.set(segment, (float)42);\n-            assertEquals((float)42, (float)handle.get(segment));\n+            handle.set(segment, 0L, (float)42);\n+            assertEquals((float)42, (float)handle.get(segment, 0L));\n@@ -300,2 +286,2 @@\n-            handle.set(segment, (double)42);\n-            assertEquals((double)42, (double)handle.get(segment));\n+            handle.set(segment, 0L, (double)42);\n+            assertEquals((double)42, (double)handle.get(segment, 0L));\n@@ -347,2 +333,2 @@\n-            handle.set(segment, i, (byte)i);\n-            assertEquals(i, (byte)handle.get(segment, i));\n+            handle.set(segment, 0L, i, (byte)i);\n+            assertEquals(i, (byte)handle.get(segment, 0L, i));\n@@ -352,2 +338,2 @@\n-            handle.set(segment, i, (short)i);\n-            assertEquals(i, (short)handle.get(segment, i));\n+            handle.set(segment, 0L, i, (short)i);\n+            assertEquals(i, (short)handle.get(segment, 0L, i));\n@@ -357,2 +343,2 @@\n-            handle.set(segment, i, (char)i);\n-            assertEquals(i, (char)handle.get(segment, i));\n+            handle.set(segment, 0L, i, (char)i);\n+            assertEquals(i, (char)handle.get(segment, 0L, i));\n@@ -362,2 +348,2 @@\n-            handle.set(segment, i, (int)i);\n-            assertEquals(i, (int)handle.get(segment, i));\n+            handle.set(segment, 0L, i, (int)i);\n+            assertEquals(i, (int)handle.get(segment, 0L, i));\n@@ -367,2 +353,2 @@\n-            handle.set(segment, i, (long)i);\n-            assertEquals(i, (long)handle.get(segment, i));\n+            handle.set(segment, 0L, i, (long)i);\n+            assertEquals(i, (long)handle.get(segment, 0L, i));\n@@ -372,2 +358,2 @@\n-            handle.set(segment, i, (float)i);\n-            assertEquals((float)i, (float)handle.get(segment, i));\n+            handle.set(segment, 0L, i, (float)i);\n+            assertEquals((float)i, (float)handle.get(segment, 0L, i));\n@@ -377,2 +363,2 @@\n-            handle.set(segment, i, (double)i);\n-            assertEquals((double)i, (double)handle.get(segment, i));\n+            handle.set(segment, 0L, i, (double)i);\n+            assertEquals((double)i, (double)handle.get(segment, 0L, i));\n@@ -432,2 +418,2 @@\n-            handle.set(segment, r, c, (byte)(r + c));\n-            assertEquals(r + c, (byte)handle.get(segment, r, c));\n+            handle.set(segment, 0L, r, c, (byte)(r + c));\n+            assertEquals(r + c, (byte)handle.get(segment, 0L, r, c));\n@@ -437,2 +423,2 @@\n-            handle.set(segment, r, c, (r + c) != 0);\n-            assertEquals((r + c) != 0, (boolean)handle.get(segment, r, c));\n+            handle.set(segment, 0L, r, c, (r + c) != 0);\n+            assertEquals((r + c) != 0, (boolean)handle.get(segment, 0L, r, c));\n@@ -442,2 +428,2 @@\n-            handle.set(segment, r, c, (short)(r + c));\n-            assertEquals(r + c, (short)handle.get(segment, r, c));\n+            handle.set(segment, 0L, r, c, (short)(r + c));\n+            assertEquals(r + c, (short)handle.get(segment, 0L, r, c));\n@@ -447,2 +433,2 @@\n-            handle.set(segment, r, c, (char)(r + c));\n-            assertEquals(r + c, (char)handle.get(segment, r, c));\n+            handle.set(segment, 0L, r, c, (char)(r + c));\n+            assertEquals(r + c, (char)handle.get(segment, 0L, r, c));\n@@ -452,2 +438,2 @@\n-            handle.set(segment, r, c, (int)(r + c));\n-            assertEquals(r + c, (int)handle.get(segment, r, c));\n+            handle.set(segment, 0L, r, c, (int)(r + c));\n+            assertEquals(r + c, (int)handle.get(segment, 0L, r, c));\n@@ -457,2 +443,2 @@\n-            handle.set(segment, r, c, r + c);\n-            assertEquals(r + c, (long)handle.get(segment, r, c));\n+            handle.set(segment, 0L, r, c, r + c);\n+            assertEquals(r + c, (long)handle.get(segment, 0L, r, c));\n@@ -462,2 +448,2 @@\n-            handle.set(segment, r, c, MemorySegment.ofAddress(r + c));\n-            assertEquals(MemorySegment.ofAddress(r + c), (MemorySegment) handle.get(segment, r, c));\n+            handle.set(segment, 0L, r, c, MemorySegment.ofAddress(r + c));\n+            assertEquals(MemorySegment.ofAddress(r + c), (MemorySegment) handle.get(segment, 0L, r, c));\n@@ -467,2 +453,2 @@\n-            handle.set(segment, r, c, (float)(r + c));\n-            assertEquals((float)(r + c), (float)handle.get(segment, r, c));\n+            handle.set(segment, 0L, r, c, (float)(r + c));\n+            assertEquals((float)(r + c), (float)handle.get(segment, 0L, r, c));\n@@ -472,2 +458,2 @@\n-            handle.set(segment, r, c, (double)(r + c));\n-            assertEquals((double)(r + c), (double)handle.get(segment, r, c));\n+            handle.set(segment, 0L, r, c, (double)(r + c));\n+            assertEquals((double)(r + c), (double)handle.get(segment, 0L, r, c));\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAccess.java","additions":46,"deletions":60,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAccessInstance.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n@@ -51,2 +50,2 @@\n-            vh.set(segment, -42);\n-            int val = (int)vh.get(segment);\n+            vh.set(segment, 0L, -42);\n+            int val = (int)vh.get(segment, 0L);\n@@ -68,1 +67,1 @@\n-            vh.set(segment.asSlice(1L), -42);\n+            vh.set(segment.asSlice(1L), 0L, -42);\n@@ -96,1 +95,1 @@\n-                    vh.set(segment, i, -42);\n+                    vh.set(segment, 0L, i, -42);\n@@ -119,6 +118,6 @@\n-            vh_c.set(segment, Byte.MIN_VALUE);\n-            assertEquals(vh_c.get(segment), Byte.MIN_VALUE);\n-            vh_s.set(segment, Short.MIN_VALUE);\n-            assertEquals(vh_s.get(segment), Short.MIN_VALUE);\n-            vh_i.set(segment, Integer.MIN_VALUE);\n-            assertEquals(vh_i.get(segment), Integer.MIN_VALUE);\n+            vh_c.set(segment, 0L, Byte.MIN_VALUE);\n+            assertEquals(vh_c.get(segment, 0L), Byte.MIN_VALUE);\n+            vh_s.set(segment, 0L, Short.MIN_VALUE);\n+            assertEquals(vh_s.get(segment, 0L), Short.MIN_VALUE);\n+            vh_i.set(segment, 0L, Integer.MIN_VALUE);\n+            assertEquals(vh_i.get(segment, 0L), Integer.MIN_VALUE);\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAlignment.java","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/TestMemoryDereference.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/TestMemorySession.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/TestMismatch.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/TestNULLAddress.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -211,1 +209,1 @@\n-                (base) -> initBytes(base, bytes, (addr, pos) -> byteHandle.set(addr, pos, (byte)(long)pos));\n+                (base) -> initBytes(base, bytes, (addr, pos) -> byteHandle.set(addr, 0L, pos, (byte)(long)pos));\n@@ -213,1 +211,1 @@\n-                (base) -> initBytes(base, chars, (addr, pos) -> charHandle.set(addr, pos, (char)(long)pos));\n+                (base) -> initBytes(base, chars, (addr, pos) -> charHandle.set(addr, 0L, pos, (char)(long)pos));\n@@ -215,1 +213,1 @@\n-                (base) -> initBytes(base, shorts, (addr, pos) -> shortHandle.set(addr, pos, (short)(long)pos));\n+                (base) -> initBytes(base, shorts, (addr, pos) -> shortHandle.set(addr, 0L, pos, (short)(long)pos));\n@@ -217,1 +215,1 @@\n-                (base) -> initBytes(base, ints, (addr, pos) -> intHandle.set(addr, pos, (int)(long)pos));\n+                (base) -> initBytes(base, ints, (addr, pos) -> intHandle.set(addr, 0L, pos, (int)(long)pos));\n@@ -219,1 +217,1 @@\n-                (base) -> initBytes(base, floats, (addr, pos) -> floatHandle.set(addr, pos, (float)(long)pos));\n+                (base) -> initBytes(base, floats, (addr, pos) -> floatHandle.set(addr, 0L, pos, (float)(long)pos));\n@@ -221,1 +219,1 @@\n-                (base) -> initBytes(base, longs, (addr, pos) -> longHandle.set(addr, pos, (long)pos));\n+                (base) -> initBytes(base, longs, (addr, pos) -> longHandle.set(addr, 0L, pos, (long)pos));\n@@ -223,1 +221,1 @@\n-                (base) -> initBytes(base, doubles, (addr, pos) -> doubleHandle.set(addr, pos, (double)(long)pos));\n+                (base) -> initBytes(base, doubles, (addr, pos) -> doubleHandle.set(addr, 0L, pos, (double)(long)pos));\n@@ -226,1 +224,1 @@\n-                (base) -> checkBytes(base, bytes, byteHandle::get, bb -> bb, TestNative::getByteBuffer, TestNative::getByteRaw);\n+                (base) -> checkBytes(base, bytes, (addr, pos) -> byteHandle.get(addr, 0L, pos), bb -> bb, TestNative::getByteBuffer, TestNative::getByteRaw);\n@@ -228,1 +226,1 @@\n-                (base) -> checkBytes(base, chars, charHandle::get, ByteBuffer::asCharBuffer, TestNative::getCharBuffer, TestNative::getCharRaw);\n+                (base) -> checkBytes(base, chars, (addr, pos) -> charHandle.get(addr, 0L, pos), ByteBuffer::asCharBuffer, TestNative::getCharBuffer, TestNative::getCharRaw);\n@@ -230,1 +228,1 @@\n-                (base) -> checkBytes(base, shorts, shortHandle::get, ByteBuffer::asShortBuffer, TestNative::getShortBuffer, TestNative::getShortRaw);\n+                (base) -> checkBytes(base, shorts, (addr, pos) -> shortHandle.get(addr, 0L, pos), ByteBuffer::asShortBuffer, TestNative::getShortBuffer, TestNative::getShortRaw);\n@@ -232,1 +230,1 @@\n-                (base) -> checkBytes(base, ints, intHandle::get, ByteBuffer::asIntBuffer, TestNative::getIntBuffer, TestNative::getIntRaw);\n+                (base) -> checkBytes(base, ints, (addr, pos) -> intHandle.get(addr, 0L, pos), ByteBuffer::asIntBuffer, TestNative::getIntBuffer, TestNative::getIntRaw);\n@@ -234,1 +232,1 @@\n-                (base) -> checkBytes(base, floats, floatHandle::get, ByteBuffer::asFloatBuffer, TestNative::getFloatBuffer, TestNative::getFloatRaw);\n+                (base) -> checkBytes(base, floats, (addr, pos) -> floatHandle.get(addr, 0L, pos), ByteBuffer::asFloatBuffer, TestNative::getFloatBuffer, TestNative::getFloatRaw);\n@@ -236,1 +234,1 @@\n-                (base) -> checkBytes(base, longs, longHandle::get, ByteBuffer::asLongBuffer, TestNative::getLongBuffer, TestNative::getLongRaw);\n+                (base) -> checkBytes(base, longs, (addr, pos) -> longHandle.get(addr, 0L, pos), ByteBuffer::asLongBuffer, TestNative::getLongBuffer, TestNative::getLongRaw);\n@@ -238,1 +236,1 @@\n-                (base) -> checkBytes(base, doubles, doubleHandle::get, ByteBuffer::asDoubleBuffer, TestNative::getDoubleBuffer, TestNative::getDoubleRaw);\n+                (base) -> checkBytes(base, doubles, (addr, pos) -> doubleHandle.get(addr, 0L, pos), ByteBuffer::asDoubleBuffer, TestNative::getDoubleBuffer, TestNative::getDoubleRaw);\n","filename":"test\/jdk\/java\/foreign\/TestNative.java","additions":14,"deletions":16,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -147,1 +145,1 @@\n-        addDefaultMapping(VarHandle.class, MethodHandles.memorySegmentViewVarHandle(JAVA_INT));\n+        addDefaultMapping(VarHandle.class, JAVA_INT.varHandle());\n","filename":"test\/jdk\/java\/foreign\/TestNulls.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/TestOfBufferIssue.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/TestReshape.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/TestRestricted.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,122 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestScope\n+ *\/\n+\n+import org.testng.annotations.*;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.SymbolLookup;\n+import java.nio.ByteBuffer;\n+import java.nio.IntBuffer;\n+\n+import static org.testng.Assert.*;\n+\n+public class TestScope {\n+\n+    static {\n+        System.loadLibrary(\"LookupTest\");\n+    }\n+\n+    @Test\n+    public void testDifferentArrayScope() {\n+        MemorySegment.Scope scope1 = MemorySegment.ofArray(new byte[10]).scope();\n+        MemorySegment.Scope scope2 = MemorySegment.ofArray(new byte[10]).scope();\n+        assertNotEquals(scope1, scope2);\n+    }\n+\n+    @Test\n+    public void testDifferentBufferScope() {\n+        MemorySegment.Scope scope1 = MemorySegment.ofBuffer(ByteBuffer.allocateDirect(10)).scope();\n+        MemorySegment.Scope scope2 = MemorySegment.ofBuffer(ByteBuffer.allocateDirect(10)).scope();\n+        assertNotEquals(scope1, scope2);\n+    }\n+\n+    @Test\n+    public void testDifferentArenaScope() {\n+        MemorySegment.Scope scope1 = Arena.ofAuto().allocate(10).scope();\n+        MemorySegment.Scope scope2 = Arena.ofAuto().allocate(10).scope();\n+        assertNotEquals(scope1, scope2);\n+    }\n+\n+    @Test\n+    public void testSameArrayScope() {\n+        byte[] arr = new byte[10];\n+        assertEquals(MemorySegment.ofArray(arr).scope(), MemorySegment.ofArray(arr).scope());\n+        ByteBuffer buf = ByteBuffer.wrap(arr);\n+        assertEquals(MemorySegment.ofArray(arr).scope(), MemorySegment.ofBuffer(buf).scope());\n+        testDerivedBufferScope(MemorySegment.ofArray(arr));\n+    }\n+\n+    @Test\n+    public void testSameBufferScope() {\n+        ByteBuffer buf = ByteBuffer.allocateDirect(10);\n+        assertEquals(MemorySegment.ofBuffer(buf).scope(), MemorySegment.ofBuffer(buf).scope());\n+        testDerivedBufferScope(MemorySegment.ofBuffer(buf));\n+    }\n+\n+    @Test\n+    public void testSameArenaScope() {\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment segment1 = arena.allocate(10);\n+            MemorySegment segment2 = arena.allocate(10);\n+            assertEquals(segment1.scope(), segment2.scope());\n+            testDerivedBufferScope(segment1);\n+        }\n+    }\n+\n+    @Test\n+    public void testSameNativeScope() {\n+        MemorySegment segment1 = MemorySegment.ofAddress(42);\n+        MemorySegment segment2 = MemorySegment.ofAddress(43);\n+        assertEquals(segment1.scope(), segment2.scope());\n+        assertEquals(segment1.scope(), segment2.reinterpret(10).scope());\n+        assertEquals(segment1.scope(), Arena.global().scope());\n+        testDerivedBufferScope(segment1.reinterpret(10));\n+    }\n+\n+    @Test\n+    public void testSameLookupScope() {\n+        SymbolLookup loaderLookup = SymbolLookup.loaderLookup();\n+        MemorySegment segment1 = loaderLookup.find(\"f\").get();\n+        MemorySegment segment2 = loaderLookup.find(\"c\").get();\n+        assertEquals(segment1.scope(), segment2.scope());\n+        testDerivedBufferScope(segment1.reinterpret(10));\n+    }\n+\n+    void testDerivedBufferScope(MemorySegment segment) {\n+        ByteBuffer buffer = segment.asByteBuffer();\n+        MemorySegment.Scope expectedScope = segment.scope();\n+        assertEquals(MemorySegment.ofBuffer(buffer).scope(), expectedScope);\n+        \/\/ buffer slices should have same scope\n+        ByteBuffer slice = buffer.slice(0, 2);\n+        assertEquals(expectedScope, MemorySegment.ofBuffer(slice).scope());\n+        \/\/ buffer views should have same scope\n+        IntBuffer view = buffer.asIntBuffer();\n+        assertEquals(expectedScope, MemorySegment.ofBuffer(view).scope());\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/TestScope.java","additions":122,"deletions":0,"binary":false,"changes":122,"status":"added"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -125,15 +123,15 @@\n-        ScopedOperation.ofScope(a -> a.allocate(JAVA_BYTE, (byte) 0), \"Arena::allocate\/byte\");\n-        ScopedOperation.ofScope(a -> a.allocate(ValueLayout.JAVA_CHAR, (char) 0), \"Arena::allocate\/char\");\n-        ScopedOperation.ofScope(a -> a.allocate(ValueLayout.JAVA_SHORT, (short) 0), \"Arena::allocate\/short\");\n-        ScopedOperation.ofScope(a -> a.allocate(ValueLayout.JAVA_INT, 0), \"Arena::allocate\/int\");\n-        ScopedOperation.ofScope(a -> a.allocate(ValueLayout.JAVA_FLOAT, 0f), \"Arena::allocate\/float\");\n-        ScopedOperation.ofScope(a -> a.allocate(ValueLayout.JAVA_LONG, 0L), \"Arena::allocate\/long\");\n-        ScopedOperation.ofScope(a -> a.allocate(ValueLayout.JAVA_DOUBLE, 0d), \"Arena::allocate\/double\");\n-        ScopedOperation.ofScope(a -> a.allocateArray(JAVA_BYTE, 1L), \"Arena::allocateArray\/size\");\n-        ScopedOperation.ofScope(a -> a.allocateArray(JAVA_BYTE, new byte[]{0}), \"Arena::allocateArray\/byte\");\n-        ScopedOperation.ofScope(a -> a.allocateArray(ValueLayout.JAVA_CHAR, new char[]{0}), \"Arena::allocateArray\/char\");\n-        ScopedOperation.ofScope(a -> a.allocateArray(ValueLayout.JAVA_SHORT, new short[]{0}), \"Arena::allocateArray\/short\");\n-        ScopedOperation.ofScope(a -> a.allocateArray(ValueLayout.JAVA_INT, new int[]{0}), \"Arena::allocateArray\/int\");\n-        ScopedOperation.ofScope(a -> a.allocateArray(ValueLayout.JAVA_FLOAT, new float[]{0}), \"Arena::allocateArray\/float\");\n-        ScopedOperation.ofScope(a -> a.allocateArray(ValueLayout.JAVA_LONG, new long[]{0}), \"Arena::allocateArray\/long\");\n-        ScopedOperation.ofScope(a -> a.allocateArray(ValueLayout.JAVA_DOUBLE, new double[]{0}), \"Arena::allocateArray\/double\");\n+        ScopedOperation.ofScope(a -> a.allocateFrom(JAVA_BYTE, (byte) 0), \"Arena::allocate\/byte\");\n+        ScopedOperation.ofScope(a -> a.allocateFrom(ValueLayout.JAVA_CHAR, (char) 0), \"Arena::allocate\/char\");\n+        ScopedOperation.ofScope(a -> a.allocateFrom(ValueLayout.JAVA_SHORT, (short) 0), \"Arena::allocate\/short\");\n+        ScopedOperation.ofScope(a -> a.allocateFrom(ValueLayout.JAVA_INT, 0), \"Arena::allocate\/int\");\n+        ScopedOperation.ofScope(a -> a.allocateFrom(ValueLayout.JAVA_FLOAT, 0f), \"Arena::allocate\/float\");\n+        ScopedOperation.ofScope(a -> a.allocateFrom(ValueLayout.JAVA_LONG, 0L), \"Arena::allocate\/long\");\n+        ScopedOperation.ofScope(a -> a.allocateFrom(ValueLayout.JAVA_DOUBLE, 0d), \"Arena::allocate\/double\");\n+        ScopedOperation.ofScope(a -> a.allocate(JAVA_BYTE, 1L), \"Arena::allocate\/size\");\n+        ScopedOperation.ofScope(a -> a.allocateFrom(JAVA_BYTE, new byte[]{0}), \"Arena::allocateFrom\/byte\");\n+        ScopedOperation.ofScope(a -> a.allocateFrom(ValueLayout.JAVA_CHAR, new char[]{0}), \"Arena::allocateFrom\/char\");\n+        ScopedOperation.ofScope(a -> a.allocateFrom(ValueLayout.JAVA_SHORT, new short[]{0}), \"Arena::allocateFrom\/short\");\n+        ScopedOperation.ofScope(a -> a.allocateFrom(ValueLayout.JAVA_INT, new int[]{0}), \"Arena::allocateFrom\/int\");\n+        ScopedOperation.ofScope(a -> a.allocateFrom(ValueLayout.JAVA_FLOAT, new float[]{0}), \"Arena::allocateFrom\/float\");\n+        ScopedOperation.ofScope(a -> a.allocateFrom(ValueLayout.JAVA_LONG, new long[]{0}), \"Arena::allocateFrom\/long\");\n+        ScopedOperation.ofScope(a -> a.allocateFrom(ValueLayout.JAVA_DOUBLE, new double[]{0}), \"Arena::allocateFrom\/double\");\n","filename":"test\/jdk\/java\/foreign\/TestScopedOperations.java","additions":15,"deletions":17,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @enablePreview\n@@ -34,2 +33,0 @@\n-import jdk.internal.foreign.MappedMemorySegmentImpl;\n-import jdk.internal.foreign.NativeMemorySegmentImpl;\n@@ -85,1 +82,1 @@\n-                        assertEquals(value, handle.get(address));\n+                        assertEquals(value, handle.get(address, 0L));\n@@ -151,1 +148,1 @@\n-        allocator.allocateArray(ValueLayout.JAVA_BYTE, -1);\n+        allocator.allocate(ValueLayout.JAVA_BYTE, -1);\n@@ -156,1 +153,1 @@\n-        allocator.allocateArray(ValueLayout.JAVA_LONG,  Long.MAX_VALUE);\n+        allocator.allocate(ValueLayout.JAVA_LONG,  Long.MAX_VALUE);\n@@ -172,1 +169,1 @@\n-                return null;\n+                return MemorySegment.NULL;\n@@ -176,1 +173,1 @@\n-            public MemorySegment allocateArray(MemoryLayout elementLayout, long count) {\n+            public MemorySegment allocateFrom(ValueLayout elementLayout, MemorySegment source, ValueLayout sourceElementLayout, long sourceOffset, long elementCount) {\n@@ -178,2 +175,2 @@\n-                return null;\n-            };\n+                return MemorySegment.NULL;\n+            }\n@@ -181,7 +178,7 @@\n-        allocator.allocateArray(ValueLayout.JAVA_BYTE);\n-        allocator.allocateArray(ValueLayout.JAVA_SHORT);\n-        allocator.allocateArray(ValueLayout.JAVA_CHAR);\n-        allocator.allocateArray(ValueLayout.JAVA_INT);\n-        allocator.allocateArray(ValueLayout.JAVA_FLOAT);\n-        allocator.allocateArray(ValueLayout.JAVA_LONG);\n-        allocator.allocateArray(ValueLayout.JAVA_DOUBLE);\n+        allocator.allocateFrom(ValueLayout.JAVA_BYTE);\n+        allocator.allocateFrom(ValueLayout.JAVA_SHORT);\n+        allocator.allocateFrom(ValueLayout.JAVA_CHAR);\n+        allocator.allocateFrom(ValueLayout.JAVA_INT);\n+        allocator.allocateFrom(ValueLayout.JAVA_FLOAT);\n+        allocator.allocateFrom(ValueLayout.JAVA_LONG);\n+        allocator.allocateFrom(ValueLayout.JAVA_DOUBLE);\n@@ -196,1 +193,0 @@\n-\n@@ -207,1 +203,1 @@\n-        allocator.allocateUtf8String(\"Hello\");\n+        allocator.allocateFrom(\"Hello\");\n@@ -245,1 +241,1 @@\n-                assertEquals(segment.isNative(), segment instanceof NativeMemorySegmentImpl);\n+                assertTrue(segment.isNative());\n@@ -255,1 +251,1 @@\n-                    (AllocationFunction.OfByte) SegmentAllocator::allocate,\n+                    (AllocationFunction.OfByte) SegmentAllocator::allocateFrom,\n@@ -258,1 +254,1 @@\n-                    (AllocationFunction.OfShort) SegmentAllocator::allocate,\n+                    (AllocationFunction.OfShort) SegmentAllocator::allocateFrom,\n@@ -261,1 +257,1 @@\n-                    (AllocationFunction.OfChar) SegmentAllocator::allocate,\n+                    (AllocationFunction.OfChar) SegmentAllocator::allocateFrom,\n@@ -265,1 +261,1 @@\n-                    (AllocationFunction.OfInt) SegmentAllocator::allocate,\n+                    (AllocationFunction.OfInt) SegmentAllocator::allocateFrom,\n@@ -268,1 +264,1 @@\n-                    (AllocationFunction.OfFloat) SegmentAllocator::allocate,\n+                    (AllocationFunction.OfFloat) SegmentAllocator::allocateFrom,\n@@ -271,1 +267,1 @@\n-                    (AllocationFunction.OfLong) SegmentAllocator::allocate,\n+                    (AllocationFunction.OfLong) SegmentAllocator::allocateFrom,\n@@ -274,1 +270,1 @@\n-                    (AllocationFunction.OfDouble) SegmentAllocator::allocate,\n+                    (AllocationFunction.OfDouble) SegmentAllocator::allocateFrom,\n@@ -277,1 +273,1 @@\n-                    (AllocationFunction.OfAddress) SegmentAllocator::allocate,\n+                    (AllocationFunction.OfAddress) SegmentAllocator::allocateFrom,\n@@ -281,1 +277,1 @@\n-                    (AllocationFunction.OfShort) SegmentAllocator::allocate,\n+                    (AllocationFunction.OfShort) SegmentAllocator::allocateFrom,\n@@ -284,1 +280,1 @@\n-                    (AllocationFunction.OfChar) SegmentAllocator::allocate,\n+                    (AllocationFunction.OfChar) SegmentAllocator::allocateFrom,\n@@ -288,1 +284,1 @@\n-                    (AllocationFunction.OfInt) SegmentAllocator::allocate,\n+                    (AllocationFunction.OfInt) SegmentAllocator::allocateFrom,\n@@ -291,1 +287,1 @@\n-                    (AllocationFunction.OfFloat) SegmentAllocator::allocate,\n+                    (AllocationFunction.OfFloat) SegmentAllocator::allocateFrom,\n@@ -294,1 +290,1 @@\n-                    (AllocationFunction.OfLong) SegmentAllocator::allocate,\n+                    (AllocationFunction.OfLong) SegmentAllocator::allocateFrom,\n@@ -297,1 +293,1 @@\n-                    (AllocationFunction.OfDouble) SegmentAllocator::allocate,\n+                    (AllocationFunction.OfDouble) SegmentAllocator::allocateFrom,\n@@ -300,1 +296,1 @@\n-                    (AllocationFunction.OfAddress) SegmentAllocator::allocate,\n+                    (AllocationFunction.OfAddress) SegmentAllocator::allocateFrom,\n@@ -311,1 +307,1 @@\n-                    (AllocationFunction.OfByteArray) SegmentAllocator::allocateArray,\n+                    (AllocationFunction.OfByteArray) SegmentAllocator::allocateFrom,\n@@ -314,1 +310,1 @@\n-                    (AllocationFunction.OfCharArray) SegmentAllocator::allocateArray,\n+                    (AllocationFunction.OfCharArray) SegmentAllocator::allocateFrom,\n@@ -317,1 +313,1 @@\n-                    (AllocationFunction.OfShortArray) SegmentAllocator::allocateArray,\n+                    (AllocationFunction.OfShortArray) SegmentAllocator::allocateFrom,\n@@ -321,1 +317,1 @@\n-                    (AllocationFunction.OfIntArray) SegmentAllocator::allocateArray,\n+                    (AllocationFunction.OfIntArray) SegmentAllocator::allocateFrom,\n@@ -324,1 +320,1 @@\n-                    (AllocationFunction.OfFloatArray) SegmentAllocator::allocateArray,\n+                    (AllocationFunction.OfFloatArray) SegmentAllocator::allocateFrom,\n@@ -327,1 +323,1 @@\n-                    (AllocationFunction.OfLongArray) SegmentAllocator::allocateArray,\n+                    (AllocationFunction.OfLongArray) SegmentAllocator::allocateFrom,\n@@ -330,1 +326,1 @@\n-                    (AllocationFunction.OfDoubleArray) SegmentAllocator::allocateArray,\n+                    (AllocationFunction.OfDoubleArray) SegmentAllocator::allocateFrom,\n@@ -334,1 +330,1 @@\n-                    (AllocationFunction.OfCharArray) SegmentAllocator::allocateArray,\n+                    (AllocationFunction.OfCharArray) SegmentAllocator::allocateFrom,\n@@ -337,1 +333,1 @@\n-                    (AllocationFunction.OfShortArray) SegmentAllocator::allocateArray,\n+                    (AllocationFunction.OfShortArray) SegmentAllocator::allocateFrom,\n@@ -341,1 +337,1 @@\n-                    (AllocationFunction.OfIntArray) SegmentAllocator::allocateArray,\n+                    (AllocationFunction.OfIntArray) SegmentAllocator::allocateFrom,\n@@ -344,1 +340,1 @@\n-                    (AllocationFunction.OfFloatArray) SegmentAllocator::allocateArray,\n+                    (AllocationFunction.OfFloatArray) SegmentAllocator::allocateFrom,\n@@ -347,1 +343,1 @@\n-                    (AllocationFunction.OfLongArray) SegmentAllocator::allocateArray,\n+                    (AllocationFunction.OfLongArray) SegmentAllocator::allocateFrom,\n@@ -350,1 +346,1 @@\n-                    (AllocationFunction.OfDoubleArray) SegmentAllocator::allocateArray,\n+                    (AllocationFunction.OfDoubleArray) SegmentAllocator::allocateFrom,\n","filename":"test\/jdk\/java\/foreign\/TestSegmentAllocators.java","additions":44,"deletions":48,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @enablePreview\n@@ -174,1 +173,1 @@\n-            return MethodHandles.memorySegmentViewVarHandle(layout);\n+            return layout.varHandle();\n","filename":"test\/jdk\/java\/foreign\/TestSegmentCopy.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n@@ -33,0 +32,1 @@\n+import org.testng.SkipException;\n@@ -47,0 +47,3 @@\n+        if (s1.kind != s2.kind) {\n+            throw new SkipException(\"Slices of different segment kinds\");\n+        }\n@@ -49,1 +52,1 @@\n-            long offset = s1.segment.segmentOffset(s2.segment);\n+            long offset = s1.offset(s2);\n@@ -56,9 +59,0 @@\n-        } else if (s1.kind != s2.kind) {\n-            \/\/ check that offset from s1 to s2 fails\n-            try {\n-                long offset = s1.segment.segmentOffset(s2.segment);\n-                out.format(\"testOffset s1:%s, s2:%s, offset:%d\\n\", s1, s2, offset);\n-                fail(\"offset unexpectedly passed!\");\n-            } catch (UnsupportedOperationException ex) {\n-                assertTrue(ex.getMessage().contains(\"Cannot compute offset from native to heap (or vice versa).\"));\n-            }\n@@ -67,1 +61,1 @@\n-            long offset = s1.segment.segmentOffset(s2.segment);\n+            long offset = s1.offset(s2);\n@@ -119,0 +113,4 @@\n+\n+        long offset(SegmentSlice that) {\n+            return that.segment.address() - segment.address();\n+        }\n","filename":"test\/jdk\/java\/foreign\/TestSegmentOffset.java","additions":10,"deletions":12,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/TestSegmentOverlap.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,2 +26,1 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n+ * @requires vm.bits == 64\n@@ -87,1 +86,1 @@\n-        VarHandle byteHandle = ValueLayout.JAVA_BYTE.arrayElementVarHandle();\n+        VarHandle byteHandle = ValueLayout.JAVA_BYTE.varHandle();\n@@ -98,1 +97,1 @@\n-        VarHandle byteHandle = ValueLayout.JAVA_BYTE.arrayElementVarHandle();\n+        VarHandle byteHandle = ValueLayout.JAVA_BYTE.varHandle();\n@@ -266,1 +265,1 @@\n-        VarHandle byteHandle = ValueLayout.JAVA_BYTE.arrayElementVarHandle();\n+        VarHandle byteHandle = ValueLayout.JAVA_BYTE.varHandle();\n","filename":"test\/jdk\/java\/foreign\/TestSegments.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @enablePreview\n@@ -154,1 +153,1 @@\n-        return (int)intHandle.getVolatile(base);\n+        return (int)intHandle.getVolatile(base, 0L);\n@@ -158,1 +157,1 @@\n-        intHandle.setVolatile(base, value);\n+        intHandle.setVolatile(base, 0L, value);\n","filename":"test\/jdk\/java\/foreign\/TestSharedAccess.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n- * @enablePreview\n@@ -56,1 +55,1 @@\n-                    VH_ALL.set(segment, i, j, (int)j + 1 + ((int)i * 5));\n+                    VH_ALL.set(segment, 0L, i, j, (int)j + 1 + ((int)i * 5));\n@@ -68,2 +67,2 @@\n-            assertThrows(() -> handle.get(segment, lo, 0));\n-            assertThrows(() -> handle.get(segment, 0, hi));\n+            assertThrows(() -> handle.get(segment, 0L, lo, 0));\n+            assertThrows(() -> handle.get(segment, 0L, 0, hi));\n@@ -77,1 +76,1 @@\n-                int x = (int) handle.get(segment, i, j);\n+                int x = (int) handle.get(segment, 0L, i, j);\n","filename":"test\/jdk\/java\/foreign\/TestSlices.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n@@ -47,2 +46,0 @@\n-    static final VarHandle INT_HANDLE = ValueLayout.JAVA_INT.arrayElementVarHandle();\n-\n@@ -59,1 +56,1 @@\n-                INT_HANDLE.set(segment, (long) i, i);\n+                segment.setAtIndex(ValueLayout.JAVA_INT, i, i);\n@@ -86,1 +83,1 @@\n-            INT_HANDLE.set(segment, (long) i, i);\n+            segment.setAtIndex(ValueLayout.JAVA_INT, i, i);\n@@ -163,1 +160,1 @@\n-        return acc + (int)INT_HANDLE.get(segment, 0L);\n+        return acc + segment.getAtIndex(ValueLayout.JAVA_INT, 0);\n@@ -170,1 +167,1 @@\n-            sum += (int)INT_HANDLE.get(segment, (long)i);\n+            sum += segment.getAtIndex(ValueLayout.JAVA_INT, i);\n","filename":"test\/jdk\/java\/foreign\/TestSpliterator.java","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -25,0 +25,2 @@\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n@@ -26,0 +28,3 @@\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemoryLayout;\n@@ -27,0 +32,15 @@\n+import java.lang.foreign.SegmentAllocator;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.reflect.Field;\n+import java.nio.channels.FileChannel;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.function.Consumer;\n+import java.util.function.UnaryOperator;\n@@ -28,0 +48,1 @@\n+import jdk.internal.foreign.StringSupport;\n@@ -29,0 +50,2 @@\n+\n+import static java.lang.foreign.ValueLayout.*;\n@@ -33,2 +56,1 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n+ * @modules java.base\/jdk.internal.foreign\n@@ -41,3 +63,196 @@\n-    public void testStrings(String testString, int expectedByteLength) {\n-        try (Arena arena = Arena.ofConfined()) {\n-            MemorySegment text = arena.allocateUtf8String(testString);\n+    public void testStrings(String testString) {\n+        for (Charset charset : Charset.availableCharsets().values()) {\n+            if (isStandard(charset)) {\n+                for (Arena arena : arenas()) {\n+                    try (arena) {\n+                        MemorySegment text = arena.allocateFrom(testString, charset);\n+\n+                        int terminatorSize = \"\\0\".getBytes(charset).length;\n+                        if (charset == StandardCharsets.UTF_16) {\n+                            terminatorSize -= 2; \/\/ drop BOM\n+                        }\n+                        \/\/ Note that the JDK's UTF_32 encoder doesn't add a BOM.\n+                        \/\/ This is legal under the Unicode standard, and means the byte order is BE.\n+                        \/\/ See: https:\/\/unicode.org\/faq\/utf_bom.html#gen7\n+\n+                        int expectedByteLength =\n+                                testString.getBytes(charset).length +\n+                                        terminatorSize;\n+\n+                        assertEquals(text.byteSize(), expectedByteLength);\n+\n+                        String roundTrip = text.getString(0, charset);\n+                        if (charset.newEncoder().canEncode(testString)) {\n+                            assertEquals(roundTrip, testString);\n+                        }\n+                    }\n+                }\n+            } else {\n+                assertThrows(IllegalArgumentException.class, () -> Arena.global().allocateFrom(testString, charset));\n+            }\n+        }\n+    }\n+\n+\n+    @Test(dataProvider = \"strings\")\n+    public void testStringsHeap(String testString) {\n+        for (Charset charset : singleByteCharsets()) {\n+            for (var arena : arenas()) {\n+                try (arena) {\n+                    MemorySegment text = arena.allocateFrom(testString, charset);\n+                    text = toHeapSegment(text);\n+\n+                    int expectedByteLength =\n+                            testString.getBytes(charset).length + 1;\n+\n+                    assertEquals(text.byteSize(), expectedByteLength);\n+\n+                    String roundTrip = text.getString(0, charset);\n+                    if (charset.newEncoder().canEncode(testString)) {\n+                        assertEquals(roundTrip, testString);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    MemorySegment toHeapSegment(MemorySegment segment) {\n+        var heapArray = segment.toArray(JAVA_BYTE);\n+        return MemorySegment.ofArray(heapArray);\n+    }\n+\n+    @Test(dataProvider = \"strings\")\n+    public void unboundedSegment(String testString) {\n+        testModifyingSegment(testString,\n+                standardCharsets(),\n+                s -> s.reinterpret(Long.MAX_VALUE),\n+                UnaryOperator.identity());\n+    }\n+\n+    @Test(dataProvider = \"strings\")\n+    public void unalignedSegmentSingleByte(String testString) {\n+        testModifyingSegment(testString,\n+                singleByteCharsets(),\n+                s -> s.byteSize() > 1 ? s.asSlice(1) : s,\n+                s -> s.length() > 0 ? s.substring(1) : s);\n+    }\n+\n+    @Test(dataProvider = \"strings\")\n+    public void expandedSegment(String testString) {\n+        try (var arena = Arena.ofConfined()) {\n+            for (int i = 0; i < Long.BYTES; i++) {\n+                int extra = i;\n+                testModifyingSegment(testString,\n+                        \/\/ Single byte charsets\n+                        standardCharsets(),\n+                        s -> {\n+                            var s2 = arena.allocate(s.byteSize() + extra);\n+                            MemorySegment.copy(s, 0, s2, 0, s.byteSize());\n+                            return s2;\n+                        },\n+                        UnaryOperator.identity());\n+            }\n+        }\n+    }\n+\n+    public void testModifyingSegment(String testString,\n+                                     List<Charset> charsets,\n+                                     UnaryOperator<MemorySegment> segmentMapper,\n+                                     UnaryOperator<String> stringMapper) {\n+        for (var charset : charsets) {\n+            try (Arena arena = Arena.ofConfined()) {\n+                MemorySegment text = arena.allocateFrom(testString, charset);\n+                text = segmentMapper.apply(text);\n+                String roundTrip = text.getString(0, charset);\n+                String expected = stringMapper.apply(testString);\n+                if (charset.newEncoder().canEncode(testString)) {\n+                    assertEquals(roundTrip, expected);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test()\n+    public void testPeculiarContentSingleByte() {\n+        Random random = new Random(42);\n+        for (int len = 7; len < 71; len++) {\n+            for (var arena : arenas()) {\n+                try (arena) {\n+                    var segment = arena.allocate(len, 1);\n+                    var arr = new byte[len];\n+                    random.nextBytes(arr);\n+                    segment.copyFrom(MemorySegment.ofArray(arr));\n+                    int terminatorIndex = random.nextInt(len);\n+                    segment.set(ValueLayout.JAVA_BYTE, terminatorIndex, (byte) 0);\n+                    for (Charset charset : singleByteCharsets()) {\n+                        var s = segment.getString(0, charset);\n+                        var ref = referenceImpl(segment, 0, charset);\n+                        assertEquals(s, ref);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"strings\")\n+    public void testOffset(String testString) {\n+        if (testString.length() < 3 || !containsOnlyRegularCharacters(testString)) {\n+            return;\n+        }\n+        for (var charset : singleByteCharsets()) {\n+            for (var arena: arenas()) {\n+                try (arena) {\n+                    MemorySegment inSegment = arena.allocateFrom(testString, charset);\n+                    for (int i = 0; i < 3; i++) {\n+                        String actual = inSegment.getString(i, charset);\n+                        assertEquals(actual, testString.substring(i));\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static final MemoryLayout CHAR_POINTER = ADDRESS\n+            .withTargetLayout(MemoryLayout.sequenceLayout(Long.MAX_VALUE, JAVA_BYTE));\n+    private static final Linker LINKER = Linker.nativeLinker();\n+    private static final MethodHandle STRCAT = LINKER.downcallHandle(\n+            LINKER.defaultLookup().find(\"strcat\").orElseThrow(),\n+            FunctionDescriptor.of(CHAR_POINTER, CHAR_POINTER, CHAR_POINTER));\n+\n+    @Test(dataProvider = \"strings\")\n+    public void nativeSegFromNativeCall(String testString) {\n+        String addition = \"123\";\n+        try (var arena = Arena.ofConfined()) {\n+            try {\n+                var testStringSegment = arena.allocateFrom(testString);\n+                var additionSegment = arena.allocateFrom(addition);\n+                var destination = arena.allocate(testStringSegment.byteSize() + additionSegment.byteSize() - 1);\n+                destination.copyFrom(testStringSegment);\n+\n+                MemorySegment concatenation = (MemorySegment) STRCAT.invokeExact(destination, arena.allocateFrom(addition));\n+                var actual = concatenation.getString(0);\n+                assertEquals(actual, testString + addition);\n+            } catch (Throwable t) {\n+                throw new AssertionError(t);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void segmentationFault() {\n+        for (int i = 1; i < 18; i++) {\n+            var size = 1 << i;\n+            try (var arena = Arena.ofConfined()) {\n+                var seg = arena.allocate(size, size);\n+                seg.fill((byte) 1);\n+                try {\n+                    var s = seg.getString(0);\n+                    System.out.println(\"s.length() = \" + s.length());\n+                } catch (IndexOutOfBoundsException e) {\n+                    \/\/ we will end up here if strlen finds a zero outside the MS\n+                }\n+            }\n+        }\n+    }\n+\n+    private static final int TEST_LENGTH_MAX = 277;\n@@ -45,1 +260,51 @@\n-            assertEquals(text.byteSize(), expectedByteLength);\n+    private Random deterministicRandom() {\n+        return new Random(42);\n+    }\n+\n+    @Test\n+    public void chunked_strlen_byte() {\n+        Random random = deterministicRandom();\n+        for (int skew = 0; skew < Long.BYTES; skew++) {\n+            for (int len = 0; len < TEST_LENGTH_MAX; len++) {\n+                try (var arena = Arena.ofConfined()) {\n+                    var segment = arena.allocate(len + 1 + skew)\n+                            .asSlice(skew);\n+                    for (int i = 0; i < len; i++) {\n+                        byte value;\n+                        while ((value = (byte) random.nextInt()) == 0) {\n+                        }\n+                        segment.setAtIndex(JAVA_BYTE, i, value);\n+                    }\n+                    segment.setAtIndex(JAVA_BYTE, len, (byte) 0);\n+                    for (int j = 0; j < len; j++) {\n+                        int actual = StringSupport.chunkedStrlenByte(segment, j);\n+                        assertEquals(actual, len - j);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void chunked_strlen_short() {\n+        Random random = deterministicRandom();\n+        for (int skew = 0; skew < Long.BYTES; skew += Short.BYTES) {\n+            for (int len = 0; len < TEST_LENGTH_MAX; len++) {\n+                try (var arena = Arena.ofConfined()) {\n+                    var segment = arena.allocate((len + 1) * Short.BYTES + skew, JAVA_SHORT.byteAlignment())\n+                            .asSlice(skew);\n+                    for (int i = 0; i < len; i++) {\n+                        short value;\n+                        while ((value = (short) random.nextInt()) == 0) {\n+                        }\n+                        segment.setAtIndex(JAVA_SHORT, i, value);\n+                    }\n+                    segment.setAtIndex(JAVA_SHORT, len, (short) 0);\n+                    for (int j = 0; j < len; j++) {\n+                        int actual = StringSupport.chunkedStrlenShort(segment, j * Short.BYTES);\n+                        assertEquals(actual, (len - j) * Short.BYTES);\n+                    }\n+                }\n+            }\n+        }\n+    }\n@@ -47,2 +312,21 @@\n-            String roundTrip = text.getUtf8String(0);\n-            assertEquals(roundTrip, testString);\n+    @Test\n+    public void strlen_int() {\n+        Random random = deterministicRandom();\n+        for (int skew = 0; skew < Long.BYTES; skew += Integer.BYTES) {\n+            for (int len = 0; len < TEST_LENGTH_MAX; len++) {\n+                try (var arena = Arena.ofConfined()) {\n+                    var segment = arena.allocate((len + 1) * Integer.BYTES + skew, JAVA_INT.byteAlignment())\n+                            .asSlice(skew);\n+                    for (int i = 0; i < len; i++) {\n+                        int value;\n+                        while ((value = random.nextInt()) == 0) {\n+                        }\n+                        segment.setAtIndex(JAVA_INT, i, value);\n+                    }\n+                    segment.setAtIndex(JAVA_INT, len, 0);\n+                    for (int j = 0; j < len; j++) {\n+                        int actual = StringSupport.strlenInt(segment, j * Integer.BYTES);\n+                        assertEquals(actual, (len - j) * Integer.BYTES);\n+                    }\n+                }\n+            }\n@@ -54,8 +338,18 @@\n-        return new Object[][] {\n-            { \"testing\",               8 },\n-            { \"\",                      1 },\n-            { \"X\",                     2 },\n-            { \"12345\",                 6 },\n-            { \"yen \\u00A5\",            7 }, \/\/ in UTF-8 2 bytes: 0xC2 0xA5\n-            { \"snowman \\u26C4\",       12 }, \/\/ in UTF-8 three bytes: 0xE2 0x9B 0x84\n-            { \"rainbow \\uD83C\\uDF08\", 13 }  \/\/ in UTF-8 four bytes: 0xF0 0x9F 0x8C 0x88\n+        return new Object[][]{\n+                {\"testing\"},\n+                {\"\"},\n+                {\"X\"},\n+                {\"12345\"},\n+                {\"yen \\u00A5\"},\n+                {\"snowman \\u26C4\"},\n+                {\"rainbow \\uD83C\\uDF08\"},\n+                {\"0\"},\n+                {\"01\"},\n+                {\"012\"},\n+                {\"0123\"},\n+                {\"01234\"},\n+                {\"012345\"},\n+                {\"0123456\"},\n+                {\"01234567\"},\n+                {\"012345678\"},\n+                {\"0123456789\"}\n@@ -64,0 +358,101 @@\n+\n+    public static boolean containsOnlyRegularCharacters(String s) {\n+        return s.chars()\n+                .allMatch(c -> Character.isLetterOrDigit((char) c));\n+    }\n+\n+    boolean isStandard(Charset charset) {\n+        for (Field standardCharset : StandardCharsets.class.getDeclaredFields()) {\n+            try {\n+                if (standardCharset.get(null) == charset) {\n+                    return true;\n+                }\n+            } catch (ReflectiveOperationException e) {\n+                throw new AssertionError(e);\n+            }\n+        }\n+        return false;\n+    }\n+\n+    List<Charset> standardCharsets() {\n+        return Charset.availableCharsets().values().stream()\n+                .filter(this::isStandard)\n+                .toList();\n+    }\n+\n+    List<Charset> singleByteCharsets() {\n+        return Arrays.asList(StandardCharsets.UTF_8, StandardCharsets.ISO_8859_1, StandardCharsets.US_ASCII);\n+    }\n+\n+    static String referenceImpl(MemorySegment segment, long offset, Charset charset) {\n+        long len = strlen_byte(segment, offset);\n+        byte[] bytes = new byte[(int) len];\n+        MemorySegment.copy(segment, JAVA_BYTE, offset, bytes, 0, (int) len);\n+        return new String(bytes, charset);\n+    }\n+\n+    \/\/ Reference implementation\n+    private static int strlen_byte(MemorySegment segment, long start) {\n+        \/\/ iterate until overflow (String can only hold a byte[], whose length can be expressed as an int)\n+        for (int offset = 0; offset >= 0; offset++) {\n+            byte curr = segment.get(JAVA_BYTE, start + offset);\n+            if (curr == 0) {\n+                return offset;\n+            }\n+        }\n+        throw new IllegalArgumentException(\"String too large\");\n+    }\n+\n+    private static List<Arena> arenas() {\n+        return Arrays.asList(\n+                Arena.ofConfined(),          \/\/ Native memory\n+                new HeapArena(byte.class),   \/\/ Heap memory backed by a byte array\n+                new HeapArena(short.class),  \/\/ Heap memory backed by a short array\n+                new HeapArena(int.class),    \/\/ Heap memory backed by an int array\n+                new HeapArena(long.class));  \/\/ Heap memory backed by a long array\n+    }\n+\n+    private static final class HeapArena implements Arena {\n+\n+        private static final int ELEMENT_SIZE = 1_000;\n+\n+        private final MemorySegment backingSegment;\n+        private final SegmentAllocator allocator;\n+\n+        public HeapArena(Class<?> type) {\n+            backingSegment = switch (type) {\n+                case Class<?> c when byte.class.equals(c) -> MemorySegment.ofArray(new byte[ELEMENT_SIZE]);\n+                case Class<?> c when short.class.equals(c) ->\n+                        MemorySegment.ofArray(new short[ELEMENT_SIZE]);\n+                case Class<?> c when int.class.equals(c) ->\n+                        MemorySegment.ofArray(new int[ELEMENT_SIZE]);\n+                case Class<?> c when long.class.equals(c) ->\n+                        MemorySegment.ofArray(new long[ELEMENT_SIZE]);\n+                default -> throw new IllegalArgumentException(type.toString());\n+            };\n+            allocator = SegmentAllocator.slicingAllocator(backingSegment);\n+        }\n+\n+        @Override\n+        public MemorySegment allocate(long byteSize, long byteAlignment) {\n+            return allocator.allocate(byteSize, byteAlignment);\n+        }\n+\n+        @Override\n+        public MemorySegment.Scope scope() {\n+            return backingSegment.scope();\n+        }\n+\n+        @Override\n+        public void close() {\n+            \/\/ Do nothing\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"HeapArena{\" +\n+                    \"type=\" + backingSegment.heapBase().orElseThrow().getClass().getName() +\n+                    '}';\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestStringEncoding.java","additions":411,"deletions":16,"binary":false,"changes":427,"status":"modified"},{"patch":"@@ -0,0 +1,102 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.*;\n+\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.function.Consumer;\n+\n+import static java.lang.foreign.ValueLayout.*;\n+import static org.testng.Assert.*;\n+\n+\/*\n+ * @test\n+ * @modules java.base\/jdk.internal.foreign\n+ * @requires sun.arch.data.model == \"64\"\n+ * @requires vm.flavor != \"zero\"\n+ *\n+ * @run testng\/othervm -Xmx6G TestStringEncodingJumbo\n+ *\/\n+\n+public class TestStringEncodingJumbo {\n+\n+    @Test()\n+    public void testJumboSegment() {\n+        testWithJumboSegment(\"testJumboSegment\", segment -> {\n+            segment.fill((byte) 1);\n+            segment.set(JAVA_BYTE, Integer.MAX_VALUE + 10L, (byte) 0);\n+            String big = segment.getString(100);\n+            assertEquals(big.length(), Integer.MAX_VALUE - (100 - 10));\n+        });\n+    }\n+\n+    @Test()\n+    public void testStringLargerThanMaxInt() {\n+        testWithJumboSegment(\"testStringLargerThanMaxInt\", segment -> {\n+            segment.fill((byte) 1);\n+            segment.set(JAVA_BYTE, Integer.MAX_VALUE + 10L, (byte) 0);\n+            assertThrows(IllegalArgumentException.class, () -> {\n+                segment.getString(0);\n+            });\n+        });\n+    }\n+\n+    private static void testWithJumboSegment(String testName, Consumer<MemorySegment> tester) {\n+        Path path = Paths.get(\"mapped_file\");\n+        try {\n+            \/\/ Relly try to make sure the file is deleted after use\n+            path.toFile().deleteOnExit();\n+            deleteIfExistsOrThrow(path);\n+            try (RandomAccessFile raf = new RandomAccessFile(path.toFile(), \"rw\")) {\n+                FileChannel fc = raf.getChannel();\n+                try (Arena arena = Arena.ofConfined()) {\n+                    var segment = fc.map(FileChannel.MapMode.READ_WRITE, 0L, (long) Integer.MAX_VALUE + 100, arena);\n+                    tester.accept(segment);\n+                }\n+            }\n+        } catch (Exception e) {\n+            throw new AssertionError(e);\n+        } catch (OutOfMemoryError oome) {\n+            \/\/ Unfortunately, we run out of memory and cannot run this test in this configuration\n+            System.out.println(\"Skipping test because of insufficient memory: \" + testName);\n+        } finally {\n+            deleteIfExistsOrThrow(path);\n+        }\n+    }\n+\n+    private static void deleteIfExistsOrThrow(Path file) {\n+        try {\n+            Files.deleteIfExists(file);\n+        } catch (IOException ioe) {\n+            throw new AssertionError(\"Unable to delete mapped file: \" + file);\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/foreign\/TestStringEncodingJumbo.java","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"},{"patch":"@@ -27,1 +27,0 @@\n- * @enablePreview\n@@ -46,1 +45,1 @@\n-        int v = (int)INT_HANDLE.get(\"string\");\n+        int v = (int)INT_HANDLE.get(\"string\", 0L);\n@@ -57,2 +56,2 @@\n-            MemorySegment s = arena.allocate(8, 8);;\n-            String address = (String)ADDR_HANDLE.get(s);\n+            MemorySegment s = arena.allocate(8, 8);\n+            String address = (String)ADDR_HANDLE.get(s, 0L);\n@@ -66,1 +65,1 @@\n-            ADDR_HANDLE.set(s, \"string\");\n+            ADDR_HANDLE.set(s, 0L, \"string\");\n@@ -73,2 +72,2 @@\n-            MemorySegment s = arena.allocate(8, 8);;\n-            int address = (int)ADDR_HANDLE.get(s);\n+            MemorySegment s = arena.allocate(8, 8);\n+            int address = (int)ADDR_HANDLE.get(s, 0L);\n","filename":"test\/jdk\/java\/foreign\/TestTypeAccess.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @enablePreview\n- *\n- * @run testng\/othervm -Djdk.internal.foreign.CABI=UNSUPPORTED --enable-native-access=ALL-UNNAMED TestUnsupportedLinker\n- *\/\n-\n-import java.lang.foreign.Linker;\n-\n-import org.testng.annotations.Test;\n-\n-public class TestUnsupportedLinker {\n-\n-    @Test(expectedExceptions = UnsupportedOperationException.class)\n-    public void testLinker() {\n-        Linker.nativeLinker();\n-    }\n-}\n","filename":"test\/jdk\/java\/foreign\/TestUnsupportedLinker.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/TestUpcallAsync.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/TestUpcallException.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -51,9 +49,0 @@\n-    static final Linker LINKER = Linker.nativeLinker();\n-\n-    \/\/ struct S_PDI { void* p0; double p1; int p2; };\n-    static final MemoryLayout S_PDI_LAYOUT = MemoryLayout.structLayout(\n-        C_POINTER.withName(\"p0\"),\n-        C_DOUBLE.withName(\"p1\"),\n-        C_INT.withName(\"p2\"),\n-        MemoryLayout.paddingLayout(4)\n-    );\n","filename":"test\/jdk\/java\/foreign\/TestUpcallHighArity.java","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/TestUpcallScope.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/TestUpcallStack.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -54,1 +52,0 @@\n-    static final Linker LINKER = Linker.nativeLinker();\n@@ -57,8 +54,0 @@\n-    \/\/ struct S_PDI { void* p0; double p1; int p2; };\n-    static final MemoryLayout S_PDI_LAYOUT = MemoryLayout.structLayout(\n-        C_POINTER.withName(\"p0\"),\n-        C_DOUBLE.withName(\"p1\"),\n-        C_INT.withName(\"p2\"),\n-        MemoryLayout.paddingLayout(4)\n-    );\n-\n","filename":"test\/jdk\/java\/foreign\/TestUpcallStructScope.java","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/TestValueLayouts.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -43,0 +41,1 @@\n+import java.lang.foreign.ValueLayout;\n@@ -54,1 +53,0 @@\n-    static final VarHandle VH_IntArray = C_INT.arrayElementVarHandle();\n@@ -85,1 +83,1 @@\n-                VH_IntArray.set(argIDs, (long) i, args.get(i).id.ordinal());\n+                argIDs.setAtIndex(ValueLayout.JAVA_INT, i, args.get(i).id.ordinal());\n@@ -200,1 +198,1 @@\n-            VH_writeback.set(seg, addr);\n+            VH_writeback.set(seg, 0L, addr);\n@@ -203,1 +201,1 @@\n-            VH_argIDs.set(seg, addr);\n+            VH_argIDs.set(seg, 0L, addr);\n@@ -222,1 +220,3 @@\n-            return new Arg(id, layout, value, layout.varHandle().toMethodHandle(VarHandle.AccessMode.GET));\n+            MethodHandle getterHandle = layout.varHandle().toMethodHandle(VarHandle.AccessMode.GET);\n+            getterHandle = MethodHandles.insertArguments(getterHandle, 1, 0L); \/\/ align signature with getter for structs\n+            return new Arg(id, layout, value, getterHandle);\n","filename":"test\/jdk\/java\/foreign\/TestVarArgs.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @enablePreview\n@@ -47,1 +46,1 @@\n-        VarHandle vh = MethodHandles.memorySegmentViewVarHandle(ValueLayout.JAVA_BYTE);\n+        VarHandle vh = ValueLayout.JAVA_BYTE.varHandle();\n@@ -56,1 +55,1 @@\n-        VarHandle vh = MethodHandles.memorySegmentViewVarHandle(ValueLayout.JAVA_BYTE.withByteAlignment(4));\n+        VarHandle vh = ValueLayout.JAVA_BYTE.withByteAlignment(4).varHandle();\n@@ -66,1 +65,1 @@\n-        VarHandle vh = MethodHandles.memorySegmentViewVarHandle(ValueLayout.JAVA_BYTE.withByteAlignment(2));\n+        VarHandle vh = ValueLayout.JAVA_BYTE.withByteAlignment(2).varHandle();\n@@ -76,2 +75,1 @@\n-        VarHandle vh = MethodHandles.memorySegmentViewVarHandle(ValueLayout.JAVA_SHORT_UNALIGNED\n-                .withOrder(ByteOrder.LITTLE_ENDIAN));\n+        VarHandle vh = ValueLayout.JAVA_SHORT_UNALIGNED.withOrder(ByteOrder.LITTLE_ENDIAN).varHandle();\n@@ -87,2 +85,1 @@\n-        VarHandle vh = MethodHandles.memorySegmentViewVarHandle(ValueLayout.JAVA_SHORT_UNALIGNED\n-                .withOrder(ByteOrder.BIG_ENDIAN));\n+        VarHandle vh = ValueLayout.JAVA_SHORT_UNALIGNED.withOrder(ByteOrder.BIG_ENDIAN).varHandle();\n@@ -103,1 +100,1 @@\n-        VarHandle vh = MethodHandles.memorySegmentViewVarHandle(ValueLayout.JAVA_INT);\n+        VarHandle vh = ValueLayout.JAVA_INT.varHandle();\n","filename":"test\/jdk\/java\/foreign\/TestVarHandleCombinators.java","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-            \"--enable-preview\",\n","filename":"test\/jdk\/java\/foreign\/UpcallTestHelper.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n@@ -28,1 +27,0 @@\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -40,1 +38,0 @@\n- * @enablePreview\n@@ -42,1 +39,0 @@\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/arraystructs\/TestArrayStructs.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestLayoutEquality.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestLinuxAArch64CallArranger.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestMacOsAArch64CallArranger.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestRISCV64CallArranger.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestSysVCallArranger.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestWindowsAArch64CallArranger.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestWindowsCallArranger.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n@@ -28,1 +27,0 @@\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -66,1 +64,1 @@\n-    private record SaveValuesCase(String nativeTarget, FunctionDescriptor nativeDesc, boolean trivial, String threadLocalName, Consumer<Object> resultCheck) {}\n+    private record SaveValuesCase(String nativeTarget, FunctionDescriptor nativeDesc, String threadLocalName, Consumer<Object> resultCheck) {}\n@@ -70,6 +68,2 @@\n-        List<Linker.Option> options = new ArrayList<>();\n-        options.add(Linker.Option.captureCallState(testCase.threadLocalName()));\n-        if (testCase.trivial()) {\n-            options.add(Linker.Option.isTrivial());\n-        }\n-        MethodHandle handle = downcallHandle(testCase.nativeTarget(), testCase.nativeDesc(), options.toArray(Linker.Option[]::new));\n+        Linker.Option stl = Linker.Option.captureCallState(testCase.threadLocalName());\n+        MethodHandle handle = downcallHandle(testCase.nativeTarget(), testCase.nativeDesc(), stl);\n@@ -88,1 +82,1 @@\n-            int savedErrno = (int) errnoHandle.get(saveSeg);\n+            int savedErrno = (int) errnoHandle.get(saveSeg, 0L);\n@@ -108,4 +102,0 @@\n-    interface CaseAdder {\n-      void addCase(String nativeTarget, FunctionDescriptor nativeDesc, String threadLocalName, Consumer<Object> resultCheck);\n-    }\n-\n@@ -115,4 +105,0 @@\n-        CaseAdder adder = (nativeTarget, nativeDesc, threadLocalName, resultCheck) -> {\n-          cases.add(new SaveValuesCase(nativeTarget, nativeDesc, false, threadLocalName, resultCheck));\n-          cases.add(new SaveValuesCase(nativeTarget, nativeDesc, true, threadLocalName, resultCheck));\n-        };\n@@ -120,16 +106,16 @@\n-        adder.addCase(\"set_errno_V\", FunctionDescriptor.ofVoid(JAVA_INT), \"errno\", o -> {});\n-        adder.addCase(\"set_errno_I\", FunctionDescriptor.of(JAVA_INT, JAVA_INT), \"errno\", o -> assertEquals((int) o, 42));\n-        adder.addCase(\"set_errno_D\", FunctionDescriptor.of(JAVA_DOUBLE, JAVA_INT), \"errno\", o -> assertEquals((double) o, 42.0));\n-\n-        structCase(adder, \"SL\",  Map.of(JAVA_LONG.withName(\"x\"), 42L));\n-        structCase(adder, \"SLL\", Map.of(JAVA_LONG.withName(\"x\"), 42L,\n-                                         JAVA_LONG.withName(\"y\"), 42L));\n-        structCase(adder, \"SLLL\", Map.of(JAVA_LONG.withName(\"x\"), 42L,\n-                                         JAVA_LONG.withName(\"y\"), 42L,\n-                                         JAVA_LONG.withName(\"z\"), 42L));\n-        structCase(adder, \"SD\",  Map.of(JAVA_DOUBLE.withName(\"x\"), 42D));\n-        structCase(adder, \"SDD\", Map.of(JAVA_DOUBLE.withName(\"x\"), 42D,\n-                                         JAVA_DOUBLE.withName(\"y\"), 42D));\n-        structCase(adder, \"SDDD\", Map.of(JAVA_DOUBLE.withName(\"x\"), 42D,\n-                                         JAVA_DOUBLE.withName(\"y\"), 42D,\n-                                         JAVA_DOUBLE.withName(\"z\"), 42D));\n+        cases.add(new SaveValuesCase(\"set_errno_V\", FunctionDescriptor.ofVoid(JAVA_INT), \"errno\", o -> {}));\n+        cases.add(new SaveValuesCase(\"set_errno_I\", FunctionDescriptor.of(JAVA_INT, JAVA_INT), \"errno\", o -> assertEquals((int) o, 42)));\n+        cases.add(new SaveValuesCase(\"set_errno_D\", FunctionDescriptor.of(JAVA_DOUBLE, JAVA_INT), \"errno\", o -> assertEquals((double) o, 42.0)));\n+\n+        cases.add(structCase(\"SL\",  Map.of(JAVA_LONG.withName(\"x\"), 42L)));\n+        cases.add(structCase(\"SLL\", Map.of(JAVA_LONG.withName(\"x\"), 42L,\n+                                           JAVA_LONG.withName(\"y\"), 42L)));\n+        cases.add(structCase(\"SLLL\", Map.of(JAVA_LONG.withName(\"x\"), 42L,\n+                                            JAVA_LONG.withName(\"y\"), 42L,\n+                                            JAVA_LONG.withName(\"z\"), 42L)));\n+        cases.add(structCase(\"SD\",  Map.of(JAVA_DOUBLE.withName(\"x\"), 42D)));\n+        cases.add(structCase(\"SDD\", Map.of(JAVA_DOUBLE.withName(\"x\"), 42D,\n+                                           JAVA_DOUBLE.withName(\"y\"), 42D)));\n+        cases.add(structCase(\"SDDD\", Map.of(JAVA_DOUBLE.withName(\"x\"), 42D,\n+                                            JAVA_DOUBLE.withName(\"y\"), 42D,\n+                                            JAVA_DOUBLE.withName(\"z\"), 42D)));\n@@ -138,2 +124,2 @@\n-            adder.addCase(\"SetLastError\", FunctionDescriptor.ofVoid(JAVA_INT), \"GetLastError\", o -> {});\n-            adder.addCase(\"WSASetLastError\", FunctionDescriptor.ofVoid(JAVA_INT), \"WSAGetLastError\", o -> {});\n+            cases.add(new SaveValuesCase(\"SetLastError\", FunctionDescriptor.ofVoid(JAVA_INT), \"GetLastError\", o -> {}));\n+            cases.add(new SaveValuesCase(\"WSASetLastError\", FunctionDescriptor.ofVoid(JAVA_INT), \"WSAGetLastError\", o -> {}));\n@@ -145,1 +131,1 @@\n-    static void structCase(CaseAdder adder, String name, Map<MemoryLayout, Object> fields) {\n+    static SaveValuesCase structCase(String name, Map<MemoryLayout, Object> fields) {\n@@ -153,1 +139,1 @@\n-            check = check.andThen(o -> assertEquals(fieldHandle.get(o), value));\n+            check = check.andThen(o -> assertEquals(fieldHandle.get(o, 0L), value));\n@@ -156,1 +142,1 @@\n-        adder.addCase(\"set_errno_\" + name, FunctionDescriptor.of(layout, JAVA_INT), \"errno\", check);\n+        return new SaveValuesCase(\"set_errno_\" + name, FunctionDescriptor.of(layout, JAVA_INT), \"errno\", check);\n","filename":"test\/jdk\/java\/foreign\/capturecallstate\/TestCaptureCallState.java","additions":25,"deletions":39,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/channels\/TestAsyncSocketChannels.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/channels\/TestSocketChannels.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n@@ -29,1 +28,0 @@\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/dontrelease\/TestDontRelease.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -33,1 +31,1 @@\n- *        org.openjdk.foreigntest.PanamaMainUnnamedModule\n+ *        org.openjdk.foreigntest.unnamed.PanamaMainUnnamedModule\n@@ -38,1 +36,0 @@\n-import java.util.ArrayList;\n@@ -60,69 +57,1 @@\n-public class TestEnableNativeAccess {\n-\n-    static final String MODULE_PATH = System.getProperty(\"jdk.module.path\");\n-\n-    static final String PANAMA_MAIN = \"panama_module\/org.openjdk.foreigntest.PanamaMainDirect\";\n-    static final String PANAMA_REFLECTION = \"panama_module\/org.openjdk.foreigntest.PanamaMainReflection\";\n-    static final String PANAMA_INVOKE = \"panama_module\/org.openjdk.foreigntest.PanamaMainInvoke\";\n-    static final String PANAMA_JNI = \"panama_module\/org.openjdk.foreigntest.PanamaMainJNI\";\n-    static final String UNNAMED = \"org.openjdk.foreigntest.PanamaMainUnnamedModule\";\n-\n-    \/**\n-     * Represents the expected result of a test.\n-     *\/\n-    static final class Result {\n-        private final boolean success;\n-        private final List<String> expectedOutput = new ArrayList<>();\n-        private final List<String> notExpectedOutput = new ArrayList<>();\n-\n-        Result(boolean success) {\n-            this.success = success;\n-        }\n-\n-        Result expect(String msg) {\n-            expectedOutput.add(msg);\n-            return this;\n-        }\n-\n-        Result doNotExpect(String msg) {\n-            notExpectedOutput.add(msg);\n-            return this;\n-        }\n-\n-        boolean shouldSucceed() {\n-            return success;\n-        }\n-\n-        Stream<String> expectedOutput() {\n-            return expectedOutput.stream();\n-        }\n-\n-        Stream<String> notExpectedOutput() {\n-            return notExpectedOutput.stream();\n-        }\n-\n-        @Override\n-        public String toString() {\n-            String s = (success) ? \"success\" : \"failure\";\n-            for (String msg : expectedOutput) {\n-                s += \"\/\" + msg;\n-            }\n-            return s;\n-        }\n-    }\n-\n-    static Result success() {\n-        return new Result(true);\n-    }\n-\n-    static Result successNoWarning() {\n-        return success().doNotExpect(\"WARNING\");\n-    }\n-\n-    static Result successWithWarning(String moduleName) {\n-        return success().expect(\"WARNING\").expect(\"--enable-native-access=\" + moduleName);\n-    }\n-\n-    static Result failWithWarning(String expectedOutput) {\n-        return new Result(false).expect(expectedOutput).expect(\"WARNING\");\n-    }\n+public class TestEnableNativeAccess extends TestEnableNativeAccessBase {\n@@ -153,15 +82,0 @@\n-    \/**\n-     * Checks an expected result with the output captured by the given\n-     * OutputAnalyzer.\n-     *\/\n-    void checkResult(Result expectedResult, OutputAnalyzer outputAnalyzer) {\n-        expectedResult.expectedOutput().forEach(outputAnalyzer::shouldContain);\n-        expectedResult.notExpectedOutput().forEach(outputAnalyzer::shouldNotContain);\n-        int exitValue = outputAnalyzer.getExitValue();\n-        if (expectedResult.shouldSucceed()) {\n-            assertTrue(exitValue == 0);\n-        } else {\n-            assertTrue(exitValue != 0);\n-        }\n-    }\n-\n@@ -179,2 +93,2 @@\n-        Stream<String> s2 = cls.equals(UNNAMED) ? Stream.of(\"--enable-preview\", \"-p\", MODULE_PATH, cls, action)\n-                : Stream.of(\"--enable-preview\", \"-p\", MODULE_PATH, \"-m\", cls, action);\n+        Stream<String> s2 = cls.equals(UNNAMED) ? Stream.of(\"-p\", MODULE_PATH, cls, action)\n+                : Stream.of(\"-p\", MODULE_PATH, \"-m\", cls, action);\n@@ -202,1 +116,1 @@\n-        assertTrue(count(output1, \"WARNING\") == 3);  \/\/ 3 on first access, none on subsequent access\n+        assertTrue(count(output1, \"WARNING\") == 4);  \/\/ 4 on first access, none on subsequent access\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/TestEnableNativeAccess.java","additions":6,"deletions":92,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -0,0 +1,124 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.util.List;\n+import java.util.ArrayList;\n+import java.util.stream.Stream;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+import static org.testng.Assert.*;\n+\n+public class TestEnableNativeAccessBase {\n+    static final String MODULE_PATH = System.getProperty(\"jdk.module.path\");\n+\n+    static final String PANAMA_MAIN_CLS = \"org.openjdk.foreigntest.PanamaMainDirect\";\n+    static final String PANAMA_MAIN = \"panama_module\/\" + PANAMA_MAIN_CLS;\n+    static final String PANAMA_REFLECTION_CLS = \"org.openjdk.foreigntest.PanamaMainReflection\";\n+    static final String PANAMA_REFLECTION = \"panama_module\/\" + PANAMA_REFLECTION_CLS;\n+    static final String PANAMA_INVOKE_CLS = \"org.openjdk.foreigntest.PanamaMainInvoke\";\n+    static final String PANAMA_INVOKE = \"panama_module\/\" + PANAMA_INVOKE_CLS;\n+    static final String PANAMA_JNI_CLS = \"org.openjdk.foreigntest.PanamaMainJNI\";\n+    static final String PANAMA_JNI = \"panama_module\/\" + PANAMA_JNI_CLS;\n+    static final String UNNAMED = \"org.openjdk.foreigntest.unnamed.PanamaMainUnnamedModule\";\n+\n+    \/**\n+     * Represents the expected result of a test.\n+     *\/\n+    static final class Result {\n+        private final boolean success;\n+        private final List<String> expectedOutput = new ArrayList<>();\n+        private final List<String> notExpectedOutput = new ArrayList<>();\n+\n+        Result(boolean success) {\n+            this.success = success;\n+        }\n+\n+        Result expect(String msg) {\n+            expectedOutput.add(msg);\n+            return this;\n+        }\n+\n+        Result doNotExpect(String msg) {\n+            notExpectedOutput.add(msg);\n+            return this;\n+        }\n+\n+        boolean shouldSucceed() {\n+            return success;\n+        }\n+\n+        Stream<String> expectedOutput() {\n+            return expectedOutput.stream();\n+        }\n+\n+        Stream<String> notExpectedOutput() {\n+            return notExpectedOutput.stream();\n+        }\n+\n+        @Override\n+        public String toString() {\n+            String s = (success) ? \"success\" : \"failure\";\n+            for (String msg : expectedOutput) {\n+                s += \"\/\" + msg;\n+            }\n+            return s;\n+        }\n+\n+    }\n+\n+    static Result success() {\n+        return new Result(true);\n+    }\n+\n+    static Result successNoWarning() {\n+        return success().doNotExpect(\"WARNING\");\n+    }\n+\n+    static Result successWithWarning(String moduleName) {\n+        return success().expect(\"WARNING\").expect(\"--enable-native-access=\" + moduleName);\n+    }\n+\n+    static Result failWithWarning(String expectedOutput) {\n+        return new Result(false).expect(expectedOutput).expect(\"WARNING\");\n+    }\n+\n+    static Result failWithError(String expectedOutput) {\n+        return new Result(false).expect(expectedOutput);\n+    }\n+\n+    \/**\n+     * Checks an expected result with the output captured by the given\n+     * OutputAnalyzer.\n+     *\/\n+    void checkResult(Result expectedResult, OutputAnalyzer outputAnalyzer) {\n+        expectedResult.expectedOutput().forEach(outputAnalyzer::shouldContain);\n+        expectedResult.notExpectedOutput().forEach(outputAnalyzer::shouldNotContain);\n+        int exitValue = outputAnalyzer.getExitValue();\n+        if (expectedResult.shouldSucceed()) {\n+            assertTrue(exitValue == 0);\n+        } else {\n+            assertTrue(exitValue != 0);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/TestEnableNativeAccessBase.java","additions":124,"deletions":0,"binary":false,"changes":124,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -40,1 +38,0 @@\n-import java.util.stream.Stream;\n@@ -47,1 +44,0 @@\n-import static org.testng.Assert.*;\n@@ -50,64 +46,1 @@\n-public class TestEnableNativeAccessDynamic {\n-\n-    static final String MODULE_PATH = System.getProperty(\"jdk.module.path\");\n-\n-    static final String PANAMA_MAIN = \"panama_module\/org.openjdk.foreigntest.PanamaMainDirect\";\n-    static final String PANAMA_REFLECTION = \"panama_module\/org.openjdk.foreigntest.PanamaMainReflection\";\n-    static final String PANAMA_INVOKE = \"panama_module\/org.openjdk.foreigntest.PanamaMainInvoke\";\n-    static final String PANAMA_JNI = \"panama_module\/org.openjdk.foreigntest.PanamaMainJNI\";\n-\n-    \/**\n-     * Represents the expected result of a test.\n-     *\/\n-    static final class Result {\n-        private final boolean success;\n-        private final List<String> expectedOutput = new ArrayList<>();\n-        private final List<String> notExpectedOutput = new ArrayList<>();\n-\n-        Result(boolean success) {\n-            this.success = success;\n-        }\n-\n-        Result expect(String msg) {\n-            expectedOutput.add(msg);\n-            return this;\n-        }\n-\n-        Result doNotExpect(String msg) {\n-            notExpectedOutput.add(msg);\n-            return this;\n-        }\n-\n-        boolean shouldSucceed() {\n-            return success;\n-        }\n-\n-        Stream<String> expectedOutput() {\n-            return expectedOutput.stream();\n-        }\n-\n-        Stream<String> notExpectedOutput() {\n-            return notExpectedOutput.stream();\n-        }\n-\n-        @Override\n-        public String toString() {\n-            String s = (success) ? \"success\" : \"failure\";\n-            for (String msg : expectedOutput) {\n-                s += \"\/\" + msg;\n-            }\n-            return s;\n-        }\n-    }\n-\n-    static Result success() {\n-        return new Result(true);\n-    }\n-\n-    static Result successNoWarning() {\n-        return success().doNotExpect(\"WARNING\");\n-    }\n-\n-    static Result failWithError(String expectedOutput) {\n-        return new Result(false).expect(expectedOutput);\n-    }\n+public class TestEnableNativeAccessDynamic extends TestEnableNativeAccessBase {\n@@ -134,15 +67,0 @@\n-    \/**\n-     * Checks an expected result with the output captured by the given\n-     * OutputAnalyzer.\n-     *\/\n-    void checkResult(Result expectedResult, OutputAnalyzer outputAnalyzer) {\n-        expectedResult.expectedOutput().forEach(outputAnalyzer::shouldContain);\n-        expectedResult.notExpectedOutput().forEach(outputAnalyzer::shouldNotContain);\n-        int exitValue = outputAnalyzer.getExitValue();\n-        if (expectedResult.shouldSucceed()) {\n-            assertTrue(exitValue == 0);\n-        } else {\n-            assertTrue(exitValue != 0);\n-        }\n-    }\n-\n@@ -158,1 +76,0 @@\n-        list.add(\"--enable-preview\");\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/TestEnableNativeAccessDynamic.java","additions":2,"deletions":85,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -0,0 +1,141 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary Basic test for Enable-Native-Access attribute in the\n+ *          manifest of a main application JAR\n+ * @library \/test\/lib\n+ * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n+ * @requires !vm.musl\n+ *\n+ * @enablePreview\n+ * @build TestEnableNativeAccessJarManifest\n+ *        panama_module\/*\n+ *        org.openjdk.foreigntest.unnamed.PanamaMainUnnamedModule\n+ * @run testng TestEnableNativeAccessJarManifest\n+ *\/\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+import java.util.ArrayList;\n+import java.util.jar.Attributes;\n+import java.util.jar.Manifest;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.util.JarUtils;\n+\n+import org.testng.annotations.Test;\n+import org.testng.annotations.DataProvider;\n+\n+public class TestEnableNativeAccessJarManifest extends TestEnableNativeAccessBase {\n+\n+    private static final String REINVOKER = \"TestEnableNativeAccessJarManifest$Reinvoker\";\n+\n+    static record Attribute(String name, String value) {}\n+\n+    @Test(dataProvider = \"cases\")\n+    public void testEnableNativeAccessInJarManifest(String action, String cls, Result expectedResult,\n+                                                    List<Attribute> attributes, List<String> vmArgs, List<String> programArgs) throws Exception {\n+        Manifest man = new Manifest();\n+        Attributes attrs = man.getMainAttributes();\n+        attrs.put(Attributes.Name.MANIFEST_VERSION, \"1.0\");\n+        attrs.put(Attributes.Name.MAIN_CLASS, cls);\n+\n+        for (Attribute attrib : attributes) {\n+            attrs.put(new Attributes.Name(attrib.name()), attrib.value());\n+        }\n+\n+        \/\/ create the JAR file with Test1 and Test2\n+        Path jarfile = Paths.get(action + \".jar\");\n+        Files.deleteIfExists(jarfile);\n+\n+        Path classes = Paths.get(System.getProperty(\"test.classes\", \"\"));\n+        JarUtils.createJarFile(jarfile, man, classes, Paths.get(cls.replace('.', '\/') + \".class\"));\n+\n+        \/\/ java -jar test.jar\n+        List<String> command = new ArrayList<>(List.of(\n+            \"--enable-preview\",\n+            \"-Djava.library.path=\" + System.getProperty(\"java.library.path\")\n+        ));\n+        command.addAll(vmArgs);\n+        command.add(\"-jar\");\n+        command.add(jarfile.toString());\n+        command.addAll(programArgs);\n+        OutputAnalyzer outputAnalyzer = ProcessTools.executeTestJava(command.toArray(String[]::new))\n+                .outputTo(System.out)\n+                .errorTo(System.out);\n+        checkResult(expectedResult, outputAnalyzer);\n+    }\n+\n+    @DataProvider\n+    public Object[][] cases() {\n+        return new Object[][] {\n+            \/\/ simple cases where a jar contains a single main class with no dependencies\n+            { \"panama_no_unnamed_module_native_access\", UNNAMED, successWithWarning(\"ALL-UNNAMED\"),\n+                    List.of(), List.of(), List.of() },\n+            { \"panama_unnamed_module_native_access\", UNNAMED, successNoWarning(),\n+                    List.of(new Attribute(\"Enable-Native-Access\", \"ALL-UNNAMED\")), List.of(), List.of() },\n+            { \"panama_unnamed_module_native_access_invalid\", UNNAMED,\n+                    failWithError(\"Error: illegal value \\\"asdf\\\" for Enable-Native-Access manifest attribute. Only ALL-UNNAMED is allowed\"),\n+                    List.of(new Attribute(\"Enable-Native-Access\", \"asdf\")), List.of(), List.of() },\n+\n+            \/\/ more complex cases where a jar invokes a module on the module path that does native access\n+            { \"panama_enable_native_access_false\", REINVOKER, successWithWarning(\"panama_module\"),\n+                    List.of(new Attribute(\"Enable-Native-Access\", \"ALL-UNNAMED\")),\n+                    List.of(\"-p\", MODULE_PATH, \"--add-modules=panama_module\"),\n+                    List.of(PANAMA_MAIN_CLS) },\n+            { \"panama_enable_native_access_reflection_false\", REINVOKER, successWithWarning(\"panama_module\"),\n+                    List.of(new Attribute(\"Enable-Native-Access\", \"ALL-UNNAMED\")),\n+                    List.of(\"-p\", MODULE_PATH, \"--add-modules=panama_module\"),\n+                    List.of(PANAMA_REFLECTION_CLS) },\n+            { \"panama_enable_native_access_invoke_false\", REINVOKER, successWithWarning(\"panama_module\"),\n+                    List.of(new Attribute(\"Enable-Native-Access\", \"ALL-UNNAMED\")),\n+                    List.of(\"-p\", MODULE_PATH, \"--add-modules=panama_module\"),\n+                    List.of(PANAMA_INVOKE_CLS) },\n+\n+            { \"panama_enable_native_access_true\", REINVOKER, successNoWarning(),\n+                    List.of(new Attribute(\"Enable-Native-Access\", \"ALL-UNNAMED\")),\n+                    List.of(\"-p\", MODULE_PATH, \"--add-modules=panama_module\", \"--enable-native-access=panama_module\"),\n+                    List.of(PANAMA_MAIN_CLS) },\n+            { \"panama_enable_native_access_reflection_true\", REINVOKER, successNoWarning(),\n+                    List.of(new Attribute(\"Enable-Native-Access\", \"ALL-UNNAMED\")),\n+                    List.of(\"-p\", MODULE_PATH, \"--add-modules=panama_module\", \"--enable-native-access=panama_module\"),\n+                    List.of(PANAMA_REFLECTION_CLS) },\n+            { \"panama_enable_native_access_invoke_true\", REINVOKER, successNoWarning(),\n+                    List.of(new Attribute(\"Enable-Native-Access\", \"ALL-UNNAMED\")),\n+                    List.of(\"-p\", MODULE_PATH, \"--add-modules=panama_module\", \"--enable-native-access=panama_module\"),\n+                    List.of(PANAMA_INVOKE_CLS) }\n+        };\n+    }\n+\n+    public class Reinvoker {\n+        public static void main(String[] args) throws Throwable {\n+            Class<?> realMainClass = Class.forName(args[0]);\n+            realMainClass.getMethod(\"main\", String[].class).invoke(null, (Object) new String[0]);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/TestEnableNativeAccessJarManifest.java","additions":141,"deletions":0,"binary":false,"changes":141,"status":"added"},{"patch":"@@ -24,1 +24,1 @@\n-package org.openjdk.foreigntest;\n+package org.openjdk.foreigntest.unnamed;\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/org\/openjdk\/foreigntest\/unnamed\/PanamaMainUnnamedModule.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/org\/openjdk\/foreigntest\/PanamaMainUnnamedModule.java","status":"renamed"},{"patch":"@@ -39,1 +39,1 @@\n-    Java_org_openjdk_foreigntest_PanamaMainUnnamedModule_nativeLinker0(JNIEnv *env, jclass cls) {\n+    Java_org_openjdk_foreigntest_unnamed_PanamaMainUnnamedModule_nativeLinker0(JNIEnv *env, jclass cls) {\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/org\/openjdk\/foreigntest\/unnamed\/libLinkerInvokerUnnamed.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/org\/openjdk\/foreigntest\/libLinkerInvokerUnnamed.cpp","status":"renamed"},{"patch":"@@ -1,34 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.openjdk.foreigntest;\n-\n-import java.lang.foreign.*;\n-\n-public class PanamaMain {\n-   public static void main(String[] args) {\n-       System.out.println(\"Trying to obtain a downcall handle\");\n-       Linker.nativeLinker().downcallHandle(FunctionDescriptor.ofVoid());\n-       System.out.println(\"Got downcall handle\");\n-   }\n-}\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_module\/org\/openjdk\/foreigntest\/PanamaMain.java","additions":0,"deletions":34,"binary":false,"changes":34,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+   jthrowable exception;\n@@ -42,0 +43,2 @@\n+    context->exception = (jthrowable) env->NewGlobalRef(env->ExceptionOccurred());\n+    env->ExceptionClear();\n@@ -54,0 +57,3 @@\n+        if (context.exception != nullptr) {\n+            env->Throw(context.exception); \/\/ transfer exception to this thread\n+        }\n@@ -57,0 +63,1 @@\n+        env->DeleteGlobalRef(context.exception);\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_module\/org\/openjdk\/foreigntest\/libLinkerInvokerModule.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/handles\/Driver.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n@@ -28,1 +27,0 @@\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/largestub\/TestLargeStub.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/loaderLookup\/TestLoaderLookup.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,2 +32,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/loaderLookup\/TestLoaderLookupJNI.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n@@ -28,1 +27,0 @@\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/nested\/TestNested.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n@@ -28,1 +27,0 @@\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/normalize\/TestNormalize.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @enablePreview\n@@ -28,1 +27,0 @@\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/passheapsegment\/TestPassHeapSegment.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -45,2 +43,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -65,2 +61,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -85,2 +79,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/stackwalk\/TestAsyncStackWalk.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/stackwalk\/TestReentrantUpcalls.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -45,2 +43,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -65,2 +61,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -85,2 +79,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/stackwalk\/TestStackWalk.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @library ..\/ \/test\/lib\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestCritical\n+ *\/\n+\n+import org.testng.annotations.Test;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.SegmentAllocator;\n+import java.lang.foreign.StructLayout;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+\n+import static org.testng.Assert.assertEquals;\n+\n+public class TestCritical extends NativeTestHelper {\n+\n+    static {\n+        System.loadLibrary(\"Critical\");\n+    }\n+\n+    @Test\n+    public void testEmpty() throws Throwable {\n+        MethodHandle handle = downcallHandle(\"empty\", FunctionDescriptor.ofVoid(), Linker.Option.critical());\n+        handle.invokeExact();\n+    }\n+\n+    @Test\n+    public void testIdentity() throws Throwable {\n+        MethodHandle handle = downcallHandle(\"identity\", FunctionDescriptor.of(C_INT, C_INT), Linker.Option.critical());\n+        int result = (int) handle.invokeExact(42);\n+        assertEquals(result, 42);\n+    }\n+\n+    @Test\n+    public void testWithReturnBuffer() throws Throwable {\n+        StructLayout bigLayout = MemoryLayout.structLayout(\n+                C_LONG_LONG.withName(\"x\"),\n+                C_LONG_LONG.withName(\"y\"));\n+\n+        MethodHandle handle = downcallHandle(\"with_return_buffer\", FunctionDescriptor.of(bigLayout), Linker.Option.critical());\n+        VarHandle vhX = bigLayout.varHandle(MemoryLayout.PathElement.groupElement(\"x\"));\n+        VarHandle vhY = bigLayout.varHandle(MemoryLayout.PathElement.groupElement(\"y\"));\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment result = (MemorySegment) handle.invokeExact((SegmentAllocator) arena);\n+            long x = (long) vhX.get(result, 0L);\n+            assertEquals(x, 10);\n+            long y = (long) vhY.get(result, 0L);\n+            assertEquals(y, 11);\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/foreign\/trivial\/TestCritical.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @library ..\/ \/test\/lib\n+ * @requires jdk.foreign.linker != \"FALLBACK\"\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestCriticalUpcall\n+ *\/\n+\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.invoke.MethodHandle;\n+\n+import static org.testng.Assert.fail;\n+\n+public class TestCriticalUpcall extends UpcallTestHelper {\n+\n+    @Test\n+    public void testUpcallFailure() throws IOException, InterruptedException {\n+        \/\/ test to see if we catch a trivial downcall doing an upcall\n+        runInNewProcess(Runner.class, true).assertStdOutContains(\"wrong thread state for upcall\");\n+    }\n+\n+    public static class Runner extends NativeTestHelper {\n+        public static void main(String[] args) throws Throwable {\n+            System.loadLibrary(\"Critical\");\n+\n+            MethodHandle mh = downcallHandle(\"do_upcall\", FunctionDescriptor.ofVoid(C_POINTER), Linker.Option.critical());\n+            MemorySegment stub = upcallStub(Runner.class, \"target\", FunctionDescriptor.ofVoid());\n+            mh.invokeExact(stub);\n+        }\n+\n+        public static void target() {\n+            fail(\"Should not get here\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/trivial\/TestCriticalUpcall.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -1,98 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @enablePreview\n- * @library ..\/ \/test\/lib\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n- * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestTrivial\n- *\/\n-\n-import org.testng.annotations.Test;\n-\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.Linker;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.SegmentAllocator;\n-import java.lang.foreign.StructLayout;\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.VarHandle;\n-\n-import static org.testng.Assert.assertEquals;\n-\n-public class TestTrivial extends NativeTestHelper {\n-\n-    static {\n-        System.loadLibrary(\"Trivial\");\n-    }\n-\n-    @Test\n-    public void testEmpty() throws Throwable {\n-        MethodHandle handle = downcallHandle(\"empty\", FunctionDescriptor.ofVoid(), Linker.Option.isTrivial());\n-        handle.invokeExact();\n-    }\n-\n-    @Test\n-    public void testIdentity() throws Throwable {\n-        MethodHandle handle = downcallHandle(\"identity\", FunctionDescriptor.of(C_INT, C_INT), Linker.Option.isTrivial());\n-        int result = (int) handle.invokeExact(42);\n-        assertEquals(result, 42);\n-    }\n-\n-    @Test\n-    public void testWithReturnBuffer() throws Throwable {\n-        StructLayout bigLayout = MemoryLayout.structLayout(\n-                C_LONG_LONG.withName(\"x\"),\n-                C_LONG_LONG.withName(\"y\"));\n-\n-        MethodHandle handle = downcallHandle(\"with_return_buffer\", FunctionDescriptor.of(bigLayout), Linker.Option.isTrivial());\n-        VarHandle vhX = bigLayout.varHandle(MemoryLayout.PathElement.groupElement(\"x\"));\n-        VarHandle vhY = bigLayout.varHandle(MemoryLayout.PathElement.groupElement(\"y\"));\n-        try (Arena arena = Arena.ofConfined()) {\n-            MemorySegment result = (MemorySegment) handle.invokeExact((SegmentAllocator) arena);\n-            long x = (long) vhX.get(result);\n-            assertEquals(x, 10);\n-            long y = (long) vhY.get(result);\n-            assertEquals(y, 11);\n-        }\n-    }\n-\n-    @Test\n-    public void testCaptureErrno() throws Throwable {\n-        Linker.Option ccs = Linker.Option.captureCallState(\"errno\");\n-        MethodHandle handle = downcallHandle(\"capture_errno\", FunctionDescriptor.ofVoid(C_INT), Linker.Option.isTrivial(), ccs);\n-        StructLayout capturedStateLayout = Linker.Option.captureStateLayout();\n-        VarHandle errnoHandle = capturedStateLayout.varHandle(MemoryLayout.PathElement.groupElement(\"errno\"));\n-        try (Arena arena = Arena.ofConfined()) {\n-            MemorySegment captureSeg = arena.allocate(capturedStateLayout);\n-            handle.invokeExact(captureSeg, 42);\n-            int capturedErrno = (int) errnoHandle.get(captureSeg);\n-            assertEquals(capturedErrno, 42);\n-        }\n-    }\n-\n-\n-}\n","filename":"test\/jdk\/java\/foreign\/trivial\/TestTrivial.java","additions":0,"deletions":98,"binary":false,"changes":98,"status":"deleted"},{"patch":"@@ -1,64 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @enablePreview\n- * @library ..\/ \/test\/lib\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n- * @requires jdk.foreign.linker != \"FALLBACK\"\n- * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestTrivialUpcall\n- *\/\n-\n-import org.testng.annotations.Test;\n-\n-import java.io.IOException;\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.Linker;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.invoke.MethodHandle;\n-\n-import static org.testng.Assert.fail;\n-\n-public class TestTrivialUpcall extends UpcallTestHelper {\n-\n-    @Test\n-    public void testUpcallFailure() throws IOException, InterruptedException {\n-        \/\/ test to see if we catch a trivial downcall doing an upcall\n-        runInNewProcess(Runner.class, true).assertStdOutContains(\"wrong thread state for upcall\");\n-    }\n-\n-    public static class Runner extends NativeTestHelper {\n-        public static void main(String[] args) throws Throwable {\n-            System.loadLibrary(\"Trivial\");\n-\n-            MethodHandle mh = downcallHandle(\"do_upcall\", FunctionDescriptor.ofVoid(C_POINTER), Linker.Option.isTrivial());\n-            MemorySegment stub = upcallStub(Runner.class, \"target\", FunctionDescriptor.ofVoid());\n-            mh.invokeExact(stub);\n-        }\n-\n-        public static void target() {\n-            fail(\"Should not get here\");\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/foreign\/trivial\/TestTrivialUpcall.java","additions":0,"deletions":64,"binary":false,"changes":64,"status":"deleted"},{"patch":"@@ -51,4 +51,0 @@\n-EXPORT void capture_errno(int value) {\n-    errno = value;\n-}\n-\n","filename":"test\/jdk\/java\/foreign\/trivial\/libCritical.c","additions":0,"deletions":4,"binary":false,"changes":4,"previous_filename":"test\/jdk\/java\/foreign\/trivial\/libTrivial.c","status":"renamed"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n@@ -28,1 +27,0 @@\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/upcalldeopt\/TestUpcallDeopt.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/virtual\/TestVirtualCalls.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -314,2 +314,2 @@\n-                    \/\/ exported to jdk.internal.vm.compiler\n-                    \"jdk.internal.vm.compiler\", \"jdk.internal.vm.compiler.management\"\n+                    \/\/ exported to Graal\n+                    \"jdk.graal.compiler\", \"jdk.graal.compiler.management\"\n@@ -317,3 +317,2 @@\n-            \/\/ Filters all modules that directly or indirectly require jdk.internal.vm.compiler\n-            \/\/ and jdk.internal.vm.compiler.management, as these are upgradeable and\n-            \/\/ also provide APIs to add qualified exports dynamically\n+            \/\/ Filters all modules that directly or indirectly require Graal modules\n+            \/\/ as these are upgradeable and also provide APIs to add qualified exports dynamically\n","filename":"test\/jdk\/java\/lang\/Class\/getDeclaredField\/FieldSetAccessibleTest.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,4 +41,4 @@\n- * @compile --enable-preview -source ${jdk.version} ImplicitAttach.java\n- * @run main AttachTest --enable-preview --enable-native-access=ALL-UNNAMED ImplicitAttach 1\n- * @run main AttachTest --enable-preview --enable-native-access=ALL-UNNAMED ImplicitAttach 2\n- * @run main AttachTest --enable-preview --enable-native-access=ALL-UNNAMED ImplicitAttach 4\n+ * @compile ImplicitAttach.java\n+ * @run main AttachTest --enable-native-access=ALL-UNNAMED ImplicitAttach 1\n+ * @run main AttachTest --enable-native-access=ALL-UNNAMED ImplicitAttach 2\n+ * @run main AttachTest --enable-native-access=ALL-UNNAMED ImplicitAttach 4\n","filename":"test\/jdk\/java\/lang\/Thread\/jni\/AttachCurrentThread\/AttachTest.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @requires vm.flagless\n","filename":"test\/jdk\/java\/lang\/instrument\/modules\/AppendToClassPathModuleTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/IndirectVarHandleTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n@@ -174,1 +173,1 @@\n-        VarHandle vh = MethodHandles.memorySegmentViewVarHandle(ValueLayouts.valueLayout(carrier, ByteOrder.nativeOrder()));\n+        VarHandle vh = ValueLayouts.valueLayout(carrier, ByteOrder.nativeOrder()).varHandle();\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestExact.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n- * @bug 4937962\n+ * @bug 4937962 8318150\n@@ -27,0 +27,1 @@\n+ * @run junit NullArguments\n@@ -29,1 +30,0 @@\n-import java.util.List;\n@@ -31,0 +31,7 @@\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.Assumptions;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -33,49 +40,26 @@\n-    public static void main(String[] args) {\n-        ProxySelector ps = ProxySelector.getDefault();\n-        List p = null;\n-        boolean ok = false;\n-        if (ps != null) {\n-            try {\n-                p = ps.select(null);\n-            } catch (IllegalArgumentException iae) {\n-                System.out.println(\"OK\");\n-                ok = true;\n-            }\n-            if (!ok)\n-                throw new RuntimeException(\"Expected IllegalArgumentException!\");\n-            URI uri = null;\n-            try {\n-                uri = new URI(\"http:\/\/java.sun.com\");\n-            } catch (java.net.URISyntaxException use) {\n-                \/\/ can't happen\n-            }\n-            SocketAddress sa = new InetSocketAddress(\"localhost\", 80);\n-            IOException ioe = new IOException(\"dummy IOE\");\n-            ok = false;\n-            try {\n-                ps.connectFailed(uri, sa, null);\n-            } catch (IllegalArgumentException iae) {\n-                System.out.println(\"OK\");\n-                ok = true;\n-            }\n-            if (!ok)\n-                throw new RuntimeException(\"Expected IllegalArgumentException!\");\n-            ok = false;\n-            try {\n-                ps.connectFailed(uri, null, ioe);\n-            } catch (IllegalArgumentException iae) {\n-                System.out.println(\"OK\");\n-                ok = true;\n-            }\n-            if (!ok)\n-                throw new RuntimeException(\"Expected IllegalArgumentException!\");\n-            ok = false;\n-            try {\n-                ps.connectFailed(null, sa, ioe);\n-            } catch (IllegalArgumentException iae) {\n-                System.out.println(\"OK\");\n-                ok = true;\n-            }\n-            if (!ok)\n-                throw new RuntimeException(\"Expected IllegalArgumentException!\");\n-        }\n+\n+    public static Stream<ProxySelector> testProxies() {\n+        return Stream.of(\n+                ProxySelector.getDefault(),\n+                ProxySelector.of(new InetSocketAddress(1234)));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"testProxies\")\n+    void testNullArguments(ProxySelector ps) throws URISyntaxException {\n+        Assumptions.assumeTrue(ps != null, \"Skipping null selector\");\n+        assertThrows(IllegalArgumentException.class,\n+                () -> ps.select(null),\n+                \"Expected IllegalArgumentException!\");\n+        URI uri = new URI(\"http:\/\/java.sun.com\");\n+        SocketAddress sa = new InetSocketAddress(\"localhost\", 80);\n+        IOException ioe = new IOException(\"dummy IOE\");\n+        assertThrows(IllegalArgumentException.class,\n+                () -> ps.connectFailed(uri, sa, null),\n+                \"Expected IllegalArgumentException!\");\n+        assertThrows(IllegalArgumentException.class,\n+                () -> ps.connectFailed(uri, null, ioe),\n+                \"Expected IllegalArgumentException!\");\n+        assertThrows(IllegalArgumentException.class,\n+                () -> ps.connectFailed(null, sa, ioe),\n+                \"Expected IllegalArgumentException!\");\n","filename":"test\/jdk\/java\/net\/ProxySelector\/NullArguments.java","additions":36,"deletions":52,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -0,0 +1,195 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.net.Proxy;\n+import java.net.ProxySelector;\n+import java.net.Socket;\n+import java.net.SocketAddress;\n+import java.net.SocketException;\n+import java.net.URI;\n+import java.net.UnknownHostException;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+\/**\n+ * @test\n+ * @bug 8318130\n+ * @summary Tests that java.net.SocksSocketImpl produces correct arguments\n+ *      for proxy selector\n+ * @run junit\/othervm SocksSocketProxySelectorTest\n+ *\/\n+public class SocksSocketProxySelectorTest {\n+\n+    public static final String SHORTEN_IPV6 = \"((?<=\\\\[)0)?:(0:)+\";\n+\n+    @BeforeAll\n+    public static void beforeTest() {\n+        ProxySelector.setDefault(new LoggingProxySelector());\n+    }\n+\n+    \/\/ should match the host name\n+    public static Stream<String> ipLiterals() {\n+        return Stream.of(\"127.0.0.1\",\n+                \"[::1]\",\n+                \"[fe80::1%1234567890]\");\n+    }\n+\n+    \/\/ should be wrapped in [ ]\n+    public static Stream<String> shortIpv6Literals() {\n+        return Stream.of(\"::1\",\n+                \"fe80::1%1234567890\");\n+    }\n+\n+    \/\/ with real interface names in scope\n+    \/\/ should be wrapped in [ ], repeated 0's not trimmed\n+    public static Stream<String> linkLocalIpv6Literals() throws SocketException {\n+        return NetworkInterface.networkInterfaces()\n+                        .flatMap(NetworkInterface::inetAddresses)\n+                        .filter(InetAddress::isLinkLocalAddress)\n+                        .map(InetAddress::getHostAddress);\n+    }\n+\n+    public static Stream<InetAddress> hostNames() throws UnknownHostException {\n+        return Stream.of(\n+                InetAddress.getByAddress(\"localhost\", new byte[] {127,0,0,1}),\n+                InetAddress.getByAddress(\"bugs.openjdk.org\", new byte[] {127,0,0,1}),\n+                InetAddress.getByAddress(\"xn--kda4b0koi.com\", new byte[] {127,0,0,1})\n+                );\n+    }\n+\n+    \/**\n+     * Creates a socket connection, which internally triggers proxy selection for the target\n+     * address. The test has been configured to use a {@link LoggingProxySelector ProxySelector}\n+     * which throws an {@link IllegalArgumentException} with hostname in exception message.\n+     * The test then verifies that the hostname matches the expected one.\n+     *\n+     * @throws Exception\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"ipLiterals\")\n+    public void testIpLiterals(String host) throws Exception {\n+        try (Socket s1 = new Socket(host, 80)) {\n+            fail(\"IOException was expected to be thrown, but wasn't\");\n+        } catch (IOException ioe) {\n+            \/\/ expected\n+            \/\/ now verify the IOE was thrown for the correct expected reason\n+            if (!(ioe.getCause() instanceof IllegalArgumentException iae)) {\n+                \/\/ rethrow this so that the test output failure will capture the entire\/real\n+                \/\/ cause in its stacktrace\n+                throw ioe;\n+            }\n+            assertNotNull(iae.getMessage(), \"Host not found\");\n+            assertEquals(host,\n+                    iae.getMessage().replaceFirst(SHORTEN_IPV6, \"::\"),\n+                    \"Found unexpected host\");\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"shortIpv6Literals\")\n+    public void testShortIpv6Literals(String host) throws Exception {\n+        try (Socket s1 = new Socket(host, 80)) {\n+            fail(\"IOException was expected to be thrown, but wasn't\");\n+        } catch (IOException ioe) {\n+            \/\/ expected\n+            \/\/ now verify the IOE was thrown for the correct expected reason\n+            if (!(ioe.getCause() instanceof IllegalArgumentException iae)) {\n+                \/\/ rethrow this so that the test output failure will capture the entire\/real\n+                \/\/ cause in its stacktrace\n+                throw ioe;\n+            }\n+            assertNotNull(iae.getMessage(), \"Host not found\");\n+            assertEquals('[' + host + ']',\n+                    iae.getMessage().replaceFirst(SHORTEN_IPV6, \"::\"),\n+                    \"Found unexpected host\");\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"linkLocalIpv6Literals\")\n+    public void testLinkLocalIpv6Literals(String host) throws Exception {\n+        try (Socket s1 = new Socket(host, 80)) {\n+            fail(\"IOException was expected to be thrown, but wasn't\");\n+        } catch (IOException ioe) {\n+            \/\/ expected\n+            \/\/ now verify the IOE was thrown for the correct expected reason\n+            if (!(ioe.getCause() instanceof IllegalArgumentException iae)) {\n+                \/\/ rethrow this so that the test output failure will capture the entire\/real\n+                \/\/ cause in its stacktrace\n+                throw ioe;\n+            }\n+            assertNotNull(iae.getMessage(), \"Host not found\");\n+            assertEquals('[' + host + ']',\n+                    iae.getMessage(),\n+                    \"Found unexpected host\");\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"hostNames\")\n+    public void testHostNames(InetAddress host) throws Exception {\n+        try (Socket s1 = new Socket(host, 80)) {\n+            fail(\"IOException was expected to be thrown, but wasn't\");\n+        } catch (IOException ioe) {\n+            \/\/ expected\n+            \/\/ now verify the IOE was thrown for the correct expected reason\n+            if (!(ioe.getCause() instanceof IllegalArgumentException iae)) {\n+                \/\/ rethrow this so that the test output failure will capture the entire\/real\n+                \/\/ cause in its stacktrace\n+                throw ioe;\n+            }\n+            assertNotNull(iae.getMessage(), \"Host not found\");\n+            assertEquals(host.getHostName(),\n+                    iae.getMessage(),\n+                    \"Found unexpected host\");\n+        }\n+    }\n+\n+    \/**\n+     * A {@link ProxySelector} which throws an IllegalArgumentException\n+     * with the given hostname in exception message\n+     *\/\n+    private static final class LoggingProxySelector extends\n+            ProxySelector {\n+\n+        @Override\n+        public List<Proxy> select(final URI uri) {\n+            throw new IllegalArgumentException(uri.getHost());\n+        }\n+\n+        @Override\n+        public void connectFailed(URI uri, SocketAddress sa, IOException ioe) {\n+\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/Socks\/SocksSocketProxySelectorTest.java","additions":195,"deletions":0,"binary":false,"changes":195,"status":"added"},{"patch":"@@ -477,0 +477,1 @@\n+            var tracker = TRACKER.getTracker(client);\n@@ -485,1 +486,0 @@\n-                var tracker = TRACKER.getTracker(client);\n@@ -494,0 +494,8 @@\n+            } else {\n+                System.out.println(now() + \"waiting for operation to finish: \" + tracker.getName());\n+                System.err.println(now() + \"waiting for operation to finish: \" + tracker.getName());\n+                var error = TRACKER.checkFinished(tracker, 10000);\n+                if (error != null) throw error;\n+                System.out.println(now() + \"operation finished normally: \" + tracker.getName());\n+                System.err.println(now() + \"operation finished normally: \" + tracker.getName());\n+\n@@ -803,1 +811,1 @@\n-        AssertionError fail = TRACKER.check(500);\n+        AssertionError fail = TRACKER.check(5000);\n","filename":"test\/jdk\/java\/net\/httpclient\/AbstractThrowingSubscribers.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -118,0 +118,8 @@\n+    public AssertionError checkFinished(Tracker tracker, long graceDelayMs) {\n+        Predicate<Tracker> hasOperations = (t) -> t.getOutstandingOperations() > 0;\n+        Predicate<Tracker> hasSubscribers = (t) -> t.getOutstandingSubscribers() > 0;\n+        return check(tracker, graceDelayMs,\n+                hasOperations.or(hasSubscribers),\n+                \"outstanding operations or unreleased resources\", false);\n+    }\n+\n","filename":"test\/jdk\/java\/net\/httpclient\/ReferenceTracker.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,102 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.Writer;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.ServerSocket;\n+import java.net.StandardSocketOptions;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.Channels;\n+import java.nio.channels.IllegalBlockingModeException;\n+import java.nio.channels.SocketChannel;\n+import java.nio.channels.WritableByteChannel;\n+import java.nio.charset.StandardCharsets;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+\/**\n+ * @test\n+ * @bug 8295797\n+ * @summary Test behavior of Channels.newWriter for WritableByteChannels\n+ * @run junit NewWriter\n+ *\/\n+public class NewWriter {\n+    private static final String STRING = \"test\";\n+    private static final int COUNT = 5;\n+    private static final int EXPECTED = COUNT*STRING.length();\n+    private int actual = 0;\n+\n+    @Test\n+    public void oneByteChannel() throws IOException {\n+        try (Writer writer = Channels.newWriter(new WritableByteChannel() {\n+            @Override\n+            public int write(ByteBuffer src) {\n+                System.out.print((char) src.get());\n+                actual++;\n+                return 1;\n+            }\n+\n+            @Override\n+            public boolean isOpen() {\n+                return true;\n+            }\n+\n+            @Override\n+            public void close() {\n+            }\n+        }, StandardCharsets.UTF_8)) {\n+            for (int i = 1; i <= COUNT; i++) {\n+                writer.write(STRING);\n+                writer.flush();\n+                System.out.println(i);\n+            }\n+        }\n+        assertEquals(EXPECTED, actual);\n+    }\n+\n+    @Test\n+    public void socketChannel() throws IOException {\n+        Throwable thrown = assertThrows(IllegalBlockingModeException.class,\n+        () -> {\n+            try (ServerSocket ss = new ServerSocket();\n+                 SocketChannel sc = SocketChannel.open()) {\n+\n+                InetAddress lb = InetAddress.getLoopbackAddress();\n+                ss.bind(new InetSocketAddress(lb, 0));\n+                sc.connect(ss.getLocalSocketAddress());\n+                sc.configureBlocking(false);\n+                sc.setOption(StandardSocketOptions.SO_SNDBUF, 8192);\n+                try (Writer writer = Channels.newWriter(sc,\n+                    StandardCharsets.UTF_8)) {\n+                    for (int i = 1; i < Integer.MAX_VALUE; i++) {\n+                        writer.write(\"test\" + i);\n+                    }\n+                }\n+            }\n+        });\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/channels\/Channels\/NewWriter.java","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/nio\/channels\/FileChannel\/LargeMapTest.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/nio\/channels\/FileChannel\/MapToMemorySegmentTest.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -48,0 +48,12 @@\n+    private static final String FAT32_TYPE;\n+    static {\n+        if (Platform.isLinux())\n+            FAT32_TYPE = \"vfat\";\n+        else if (Platform.isOSX())\n+            FAT32_TYPE = \"msdos\";\n+        else if (Platform.isWindows())\n+            FAT32_TYPE = \"FAT32\";\n+        else\n+            FAT32_TYPE = \"unknown\";\n+    }\n+\n@@ -51,0 +63,1 @@\n+    private static boolean targetVolumeIsFAT32 = false;\n@@ -68,0 +81,2 @@\n+            targetVolumeIsFAT32 = fileStore2.type().equals(FAT32_TYPE);\n+\n@@ -101,0 +116,1 @@\n+            targetVolumeIsFAT32 = false;\n@@ -134,4 +150,9 @@\n-\n-            if (time1 != time2) {\n-                System.err.format(\"File time for %s is %s\\n\", attrs1.fileKey(), attrs1.lastModifiedTime());\n-                System.err.format(\"File time for %s is %s\\n\", attrs2.fileKey(), attrs2.lastModifiedTime());\n+            long delta = Math.abs(Math.subtractExact(time1, time2));\n+\n+            \/\/ FAT32 volumes have a time stamp resolution of 2 seconds for\n+            \/\/ last modified time (write time)\n+            if ((delta != 0 && !targetVolumeIsFAT32) || delta > 2) {\n+                System.err.format(\"File time for %s is %s\\n\",\n+                                  attrs1.fileKey(), attrs1.lastModifiedTime());\n+                System.err.format(\"File time for %s is %s\\n\",\n+                                  attrs2.fileKey(), attrs2.lastModifiedTime());\n","filename":"test\/jdk\/java\/nio\/file\/Files\/CopyAndMove.java","additions":25,"deletions":4,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n- * @bug 8011536 8151430\n+ * @bug 8011536 8151430 8316304\n@@ -33,0 +33,1 @@\n+import java.lang.foreign.Linker;\n@@ -91,0 +92,5 @@\n+        } else if (Platform.isLinux()) {\n+            \/\/ Creation time read depends on statx system call support\n+            supportsCreationTimeRead = Linker.nativeLinker().defaultLookup().find(\"statx\").isPresent();\n+            \/\/ Creation time updates are not supported on Linux\n+            supportsCreationTimeWrite = false;\n@@ -92,0 +98,1 @@\n+        System.out.println(\"supportsCreationTimeRead == \" + supportsCreationTimeRead);\n","filename":"test\/jdk\/java\/nio\/file\/attribute\/BasicFileAttributeView\/CreationTime.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"filename":"test\/jdk\/java\/security\/KeyRep\/RSA.pre.1.5.key","binary":true,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2005, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 4532506\n+ * @bug 4532506 8301126\n@@ -33,1 +33,0 @@\n-import java.security.*;\n@@ -43,1 +42,7 @@\n-        \/\/ verify pre-tiger keys still deserialize in our VM\n+        \/\/ verify pre-tiger keys still deserialize in our VM.\n+\n+        \/\/ There used to be a RSA test here, but the serialized file contained\n+        \/\/ classes introduced in JDK 5.0 (sun.security.rsa.RSA*).  The older\n+        \/\/ RSA keys from JDK 1.4.2 were of class JSA_* which were removed when\n+        \/\/ sun.security.rsa was introduced.  (See JDK-8301126 for more\n+        \/\/ details.)  The test\/data has been removed.\n@@ -46,1 +51,0 @@\n-        deserializeKey(\"RSA\");\n","filename":"test\/jdk\/java\/security\/KeyRep\/SerialOld.java","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,153 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6801704\n+ * @summary Test the expected behavior for a wide range of patterns (both\n+ *          correct and incorrect). This test documents the behavior of incorrect\n+ *          ChoiceFormat patterns either throwing an exception, or discarding\n+ *          the incorrect portion of a pattern.\n+ * @run junit PatternsTest\n+ *\/\n+\n+import java.text.ChoiceFormat;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.params.provider.Arguments.arguments;\n+\n+public class PatternsTest {\n+\n+    private static final String ERR1 =\n+            \"Each interval must contain a number before a format\";\n+    private static final String ERR2 =\n+            \"Incorrect order of intervals, must be in ascending order\";\n+\n+    \/\/ Check that some valid patterns do not throw an exception. Check\n+    \/\/ them against the expected values they should be formatted as.\n+    @ParameterizedTest\n+    @MethodSource\n+    public void validPatternsTest(String pattern, String[] expectedValues) {\n+        var fmt = new ChoiceFormat(pattern);\n+        for (int i=1; i<=expectedValues.length; i++) {\n+            assertEquals(expectedValues[i-1], fmt.format(i),\n+                    String.format(\"ChoiceFormat formatted %s incorrectly:\", i));\n+        }\n+    }\n+\n+    \/\/ Valid patterns ranging from normal appearing to odd. These should not\n+    \/\/ throw an exception or discard any portions of the pattern.\n+    private static Arguments[] validPatternsTest() {\n+        return new Arguments[] {\n+                \/\/ Multi pattern with trailing empty string Format\n+                arguments(\"1#foo|2#bar|3#\", new String[]{\"foo\", \"bar\", \"\"}),\n+                \/\/ Multi patten with trailing '|'\n+                arguments(\"1#foo|2#bar|\", new String[]{\"foo\", \"bar\"}),\n+                \/\/ Using a '>' (not a Relation) within a Format\n+                arguments(\"1#foo|2#bar>\", new String[]{\"foo\", \"bar>\"}),\n+                \/\/ Standard Multi Pattern\n+                arguments(\"1#foo|2#bar\", new String[]{\"foo\", \"bar\"}),\n+                \/\/ Same numerical value Limits, different Relations\n+                arguments(\"1#foo|1<baz\", new String[]{\"foo\", \"baz\"}),\n+                \/\/ Standard Single Pattern\n+                arguments(\"1#foo\", new String[]{\"foo\"}),\n+                \/\/ Single pattern with empty string Format\n+                arguments(\"1#\", new String[]{\"\"})\n+        };\n+    }\n+\n+    \/\/ Check that the incorrect pattern throws an IAE with the desired error msg\n+    \/\/ This also tests applyPattern, as the ChoiceFormat constructor calls applyPattern\n+    @ParameterizedTest\n+    @MethodSource\n+    public void invalidPatternsThrowsTest(String pattern, String errMsg) {\n+        var ex = assertThrows(IllegalArgumentException.class,\n+                () -> new ChoiceFormat(pattern));\n+        assertEquals(errMsg, ex.getMessage());\n+    }\n+\n+    \/\/ Variety of patterns that break the ChoiceFormat pattern syntax and throw\n+    \/\/ an exception.\n+    private static Arguments[] invalidPatternsThrowsTest() {\n+        return new Arguments[] {\n+                arguments(\"#foo\", ERR1), \/\/ No Limit\n+                arguments(\"0#foo|#|1#bar\", ERR1), \/\/ Missing Relation in SubPattern\n+                arguments(\"#|\", ERR1), \/\/ Missing Limit\n+                arguments(\"##|\", ERR1), \/\/ Double Relations\n+                arguments(\"0#foo1#\", ERR1), \/\/ SubPattern not separated by '|'\n+                arguments(\"0#foo#\", ERR1), \/\/ Using a Relation in a format\n+                arguments(\"0#test|#\", ERR1), \/\/ SubPattern missing Limit\n+                arguments(\"0#foo|3#bar|1#baz\", ERR2), \/\/ Non-ascending Limits\n+        };\n+    }\n+\n+    \/\/ Check that the incorrect pattern discards the trailing incorrect portion.\n+    \/\/ These incorrect patterns should ideally throw an exception, but for\n+    \/\/ behavioral compatibility reasons do not.\n+    @ParameterizedTest\n+    @MethodSource\n+    public void invalidPatternsDiscardedTest(String brokenPattern, String actualPattern) {\n+        var cf1 = new ChoiceFormat(brokenPattern);\n+        var cf2 = new ChoiceFormat(actualPattern);\n+        assertEquals(cf2, cf1,\n+                String.format(\"Expected %s, but got %s\", cf2.toPattern(), cf1.toPattern()));\n+    }\n+\n+    \/\/ Variety of incorrect patterns with the actual expected pattern\n+    \/\/ after discarding occurs.\n+    private static Arguments[] invalidPatternsDiscardedTest() {\n+        return new Arguments[] {\n+                \/\/ Incomplete SubPattern at the end of the Pattern\n+                arguments(\"0#foo|1#bar|baz\", \"0#foo|1#bar\"),\n+\n+                \/\/ --- These throw an ArrayIndexOutOfBoundsException\n+                \/\/ when attempting to format with them ---\n+                \/\/ SubPattern with only a Limit (which is interpreted as a Format)\n+                arguments(\"0\", \"\"),\n+                \/\/ SubPattern with only a Format\n+                arguments(\"foo\", \"\"),\n+                \/\/ empty string\n+                arguments(\"\", \"\")\n+        };\n+    }\n+\n+    \/\/ Calling format() with empty limits and formats\n+    \/\/ throws an ArrayIndexOutOfBoundsException\n+    @Test\n+    public void emptyLimitsAndFormatsTest() {\n+        var cf1 = new ChoiceFormat(\"\");\n+        assertThrows(ArrayIndexOutOfBoundsException.class,\n+                () -> cf1.format(1));\n+\n+        var cf2 = new ChoiceFormat(new double[]{}, new String[]{});\n+        assertThrows(ArrayIndexOutOfBoundsException.class,\n+                () -> cf2.format(2));\n+    }\n+}\n","filename":"test\/jdk\/java\/text\/Format\/ChoiceFormat\/PatternsTest.java","additions":153,"deletions":0,"binary":false,"changes":153,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8041488 8316974\n+ * @bug 8041488 8316974 8318569\n@@ -203,0 +203,1 @@\n+\n@@ -216,0 +217,11 @@\n+\n+    static Arguments[] getLocale_localeDependent() {\n+        return new Arguments[] {\n+                arguments(Locale.ROOT),\n+                arguments(Locale.US),\n+                arguments(Locale.GERMANY),\n+                arguments(Locale.JAPAN),\n+                arguments(Locale.SIMPLIFIED_CHINESE),\n+        };\n+    }\n+\n@@ -238,0 +250,27 @@\n+    @Test\n+    void getLocale_invariant() {\n+        var f = ListFormat.getInstance(CUSTOM_PATTERNS_FULL);\n+        assertEquals(Locale.ROOT, f.getLocale());\n+    }\n+\n+    @Test\n+    void getLocale_default() {\n+        var f = ListFormat.getInstance();\n+        assertEquals(Locale.getDefault(Locale.Category.FORMAT), f.getLocale());\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    void getLocale_localeDependent(Locale l) {\n+        var f = ListFormat.getInstance(l, ListFormat.Type.STANDARD, ListFormat.Style.FULL);\n+        assertEquals(l, f.getLocale());\n+    }\n+\n+    @Test\n+    void getPatterns_immutability() {\n+        var f = ListFormat.getInstance(CUSTOM_PATTERNS_FULL);\n+        var p = f.getPatterns();\n+        p[0] = null;\n+        assertArrayEquals(CUSTOM_PATTERNS_FULL, f.getPatterns());\n+    }\n+\n","filename":"test\/jdk\/java\/text\/Format\/ListFormat\/TestListFormat.java","additions":40,"deletions":1,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,5 @@\n- * @summary Confirm that DecimalFormat.parse() parses BigDecimal and BigInteger as expected.\n+ * @summary Confirm that DecimalFormat.parse() parses BigDecimal and BigInteger\n+ *          string values as expected. Specifically, ensure a ParseException is\n+ *          not thrown as well as the parsed value being numerically correct.\n+ *          Tests large String values with combinations of multipliers and exponents.\n+ * @run junit BigDecimalCompatibilityTest\n@@ -30,3 +34,15 @@\n-import java.math.*;\n-import java.text.*;\n-import java.util.*;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.text.DecimalFormat;\n+import java.util.ArrayList;\n+import java.util.Locale;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n@@ -36,1 +52,3 @@\n-    static boolean err = false;\n+    private static DecimalFormat df = new DecimalFormat();\n+    \/\/ Save JVM default Locale\n+    private static final Locale savedLocale = Locale.getDefault();\n@@ -38,10 +56,1 @@\n-    static final String[] input_data = {\n-        \"0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\",\n-        \"1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890\"\n-    };\n-    static final String[] exponents = {\n-        \"E-100\", \"E100\", \"E-900\", \"E900\", \"\"\n-    };\n-    static final int[] multipliers = {\n-        -1, 1, -100, 100, -9999, 9999\n-    };\n+    \/\/ ---- Used for the test data (start) ----\n@@ -49,3 +58,3 @@\n-    public static void main(String[] args) throws Exception {\n-        Locale loc = Locale.getDefault();\n-        Locale.setDefault(Locale.US);\n+    \/\/ Both ArrayList composed of Arguments(String longString, int multiplier)\n+    private static final ArrayList<Arguments> bigIntegers = new ArrayList<Arguments>();\n+    private static final ArrayList<Arguments> bigDecimals = new ArrayList<Arguments>();\n@@ -53,2 +62,4 @@\n-        testBigDecimal();\n-        testBigInteger();\n+    \/\/ Long string data to generate combinations of test values\n+    private static final String[] inputData = {\n+            \"0\".repeat(400),\n+            \"1234567890\".repeat(40)};\n@@ -56,1 +67,4 @@\n-        Locale.setDefault(loc);\n+    \/\/ Variety of exponents to test parse() against\n+    private static final String[] exponents = {\n+            \"E-100\", \"E100\", \"E-900\", \"E900\", \"\"\n+    };\n@@ -58,4 +72,5 @@\n-        if (err) {\n-            throw new RuntimeException(\"Error: Unexpected value\");\n-        }\n-    }\n+    \/\/ Variety of multipliers that DecimalFormat can apply\n+    private static final int[] multipliers = {\n+            -1, 1, -100, 100, -9999, 9999\n+    };\n+    \/\/ ---- Used for the test data (end) ----\n@@ -63,4 +78,6 @@\n-    static private void testBigDecimal() {\n-        DecimalFormat df = new DecimalFormat();\n-        df.setParseBigDecimal(true);\n-        df.setMaximumFractionDigits(Integer.MAX_VALUE);\n+    \/\/ Set JVM default Locale to US and populate the test arrayLists\n+    @BeforeAll\n+    static void initAll() {\n+        Locale.setDefault(Locale.US);\n+        buildTestData();\n+    }\n@@ -68,11 +85,21 @@\n-        for (int i = 0; i < input_data.length; i++) {\n-            for (int j = 0; j < input_data.length; j++) {\n-                for (int k = 0; k < input_data.length; k++) {\n-                    for (int l = 0; l < input_data.length; l++) {\n-                        for (int m = 0; m < exponents.length; m++) {\n-                            String s = input_data[i] + input_data[j] + '.' +\n-                                       input_data[k] + input_data[l] +\n-                                       exponents[m];\n-                            for (int n = 0; n < multipliers.length; n++) {\n-                                test(df, s, multipliers[n]);\n-                                test(df, '-'+s, multipliers[n]);\n+    \/*\n+     * Uses inputData and exponents to build long string\n+     * decimal and integer values and populate bigDecimals and bigIntegers\n+     * accordingly. Attaches a multiplier value as well to the test data.\n+     *\/\n+    private static void buildTestData() {\n+        for (String longString1 : inputData) {\n+            for (String longString2 : inputData) {\n+                String bigInteger = longString1 + longString2;\n+                for (int multiplier : multipliers) {\n+                    bigIntegers.add(Arguments.of(bigInteger, multiplier));\n+                    bigIntegers.add(Arguments.of('-' + bigInteger, multiplier));\n+                }\n+                for (String longString3 : inputData) {\n+                    for (String longString4 : inputData) {\n+                        for (String exponent : exponents) {\n+                            String bigDecimal = longString1 + longString2 + '.'\n+                                    + longString3 + longString4 + exponent;\n+                            for (int multiplier : multipliers) {\n+                                bigDecimals.add(Arguments.of(bigDecimal, multiplier));\n+                                bigDecimals.add(Arguments.of('-' + bigDecimal, multiplier));\n@@ -87,4 +114,5 @@\n-    static private void testBigInteger() {\n-        DecimalFormat df = new DecimalFormat();\n-        df.setParseBigDecimal(true);\n-        df.setMaximumFractionDigits(Integer.MAX_VALUE);\n+    \/\/ Restore JVM default Locale\n+    @AfterAll\n+    static void tearDownAll() {\n+        Locale.setDefault(savedLocale);\n+    }\n@@ -92,9 +120,24 @@\n-        for (int i = 0; i < input_data.length; i++) {\n-            for (int j = 0; j < input_data.length; j++) {\n-                String s = input_data[i] + input_data[j];\n-                for (int k = 0; k < multipliers.length; k++) {\n-                    test(df, s, multipliers[k]);\n-                    test(df, '-'+s, multipliers[k]);\n-                }\n-            }\n-        }\n+    \/\/ Tests strings with length 1600+. See test() for specific details.\n+    @ParameterizedTest\n+    @MethodSource(\"bigDecimalProvider\")\n+    public void bigDecimalParseTest(String longString, int multiplier) {\n+        test(longString, multiplier);\n+    }\n+\n+    \/\/ Returns 960 arrangements of bigDecimal string values and multipliers\n+    \/\/ In the form of (String, int).\n+    private static Stream<Arguments> bigDecimalProvider() {\n+        return bigDecimals.stream();\n+    }\n+\n+    \/\/ Tests strings with length 800+. See test() for specific details.\n+    @ParameterizedTest\n+    @MethodSource(\"bigIntegerProvider\")\n+    public void bigIntegerParseTest(String longString, int multiplier) {\n+        test(longString, multiplier);\n+    }\n+\n+    \/\/ Returns 48 arrangements of bigInteger string values and multipliers\n+    \/\/ In the form of (String, int).\n+    private static Stream<Arguments> bigIntegerProvider() {\n+        return bigIntegers.stream();\n@@ -103,1 +146,12 @@\n-    static void test(DecimalFormat df, String s, int multiplier) {\n+    \/*\n+     * Tests that parsing a large BigDecimal\/BigInteger string value\n+     * will not throw a ParseException with setParseBigDecimal as true.\n+     * Parses with a variety of multiplier values. Then ensures that the parsed\n+     * value is the expected number.\n+     *\/\n+    private static void test(String longString, int multiplier) {\n+        \/\/ Reset DecimalFormat for a clean test\n+        df = new DecimalFormat();\n+        df.setParseBigDecimal(true);\n+        \/\/ wide enough to support the long string test data\n+        df.setMaximumFractionDigits(Integer.MAX_VALUE);\n@@ -106,9 +160,7 @@\n-        Number num = null;\n-        try {\n-            num = df.parse(s);\n-        }\n-        catch (ParseException e) {\n-            err = true;\n-            System.err.println(\"Failed: Exception occurred: \" + e.getMessage());\n-            return;\n-        }\n+        \/\/ Check parse and returned value. This was originally intended to ensure\n+        \/\/ a ParseException is not thrown\n+        Number parsedValue = assertDoesNotThrow(()-> df.parse(longString),\n+                \"Should not throw an Exception\");\n+        BigDecimal expectedValue = getExpected(longString, multiplier);\n+        assertEquals(expectedValue, parsedValue, \"With multiplier: \" + multiplier);\n+    }\n@@ -116,1 +168,4 @@\n-        BigDecimal bd = new BigDecimal(s);\n+    \/\/ Utility to get a numerically correct value of a long string.\n+    \/\/ Dependent on BigDecimal implementation\n+    private static BigDecimal getExpected(String longString, int multiplier) {\n+        BigDecimal expected = new BigDecimal(longString);\n@@ -118,1 +173,1 @@\n-           bd = bd.divide(new BigDecimal(multiplier));\n+            expected = expected.divide(new BigDecimal(multiplier));\n@@ -121,11 +176,1 @@\n-           bd = bd.divide(new BigDecimal(multiplier), RoundingMode.HALF_EVEN);\n-        }\n-        check(num, bd, multiplier);\n-    }\n-\n-    static void check(Number got, BigDecimal expected, int multiplier) {\n-        if (!got.equals(expected)) {\n-            err = true;\n-            System.err.println(\"Failed: got:\" + got +\n-                               \", expected: \" + expected +\n-                               \", multiplier=\" + multiplier);\n+            expected = expected.divide(new BigDecimal(multiplier), RoundingMode.HALF_EVEN);\n@@ -133,0 +178,1 @@\n+        return expected;\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/BigDecimalCompatibilityTest.java","additions":123,"deletions":77,"binary":false,"changes":200,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,3 @@\n- * @summary Confirm that the decimal separator is shown when explicitly requested.\n+ * @summary Confirm that the decimal separator is shown when explicitly requested\n+ *          (or not shown if not requested). Tests against double, long, BigDecimal,\n+ *          and BigInteger with a combination of different patterns.\n@@ -28,0 +30,1 @@\n+ * @run junit Bug4208135\n@@ -30,3 +33,5 @@\n-import java.math.*;\n-import java.text.*;\n-import java.util.*;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.text.DecimalFormat;\n+import java.util.Locale;\n+import java.util.stream.Stream;\n@@ -34,1 +39,5 @@\n-public class Bug4208135 {\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n@@ -36,1 +45,1 @@\n-    static DecimalFormat df;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n@@ -38,1 +47,1 @@\n-    static boolean err = false;\n+public class Bug4208135 {\n@@ -40,1 +49,3 @@\n-    static public void main(String[] args){\n+    private static DecimalFormat df;\n+    \/\/ Save JVM default Locale\n+    private static final Locale savedLocale = Locale.getDefault();\n@@ -42,1 +53,3 @@\n-        Locale defaultLoc = Locale.getDefault();\n+    \/\/ Set JVM default locale to US\n+    @BeforeAll\n+    static void init() {\n@@ -44,0 +57,1 @@\n+    }\n@@ -45,1 +59,41 @@\n-        df = new DecimalFormat();\n+    \/\/ Restore JVM default locale\n+    @AfterAll\n+    static void tearDown() {\n+        Locale.setDefault(savedLocale);\n+    }\n+\n+    \/\/ Confirm that decimal separator shown when formatting a number\n+    @ParameterizedTest\n+    @MethodSource(\"fractionalDigitsWithSeparatorProvider\")\n+    public void fractionalDigitsWithSeparatorTest(Number num, String expected) {\n+        df = getDF(\"0.#E0\", true);\n+        String actualFormatted = df.format(num);\n+        assertEquals(expected, actualFormatted, getErrMsg(\"0.#E0\", true));\n+    }\n+\n+    \/\/ Combination of numbers and a fractional exponent pattern with a separator\n+    private static Stream<Arguments> fractionalDigitsWithSeparatorProvider() {\n+        return Stream.of(\n+                Arguments.of(0.0, \"0.E0\"),\n+                Arguments.of(10.0, \"1.E1\"),\n+                Arguments.of(1000.0, \"1.E3\"),\n+                Arguments.of(0L, \"0.E0\"),\n+                Arguments.of(10L, \"1.E1\"),\n+                Arguments.of(1000L, \"1.E3\"),\n+                Arguments.of(new BigDecimal(\"0.0\"), \"0.E0\"),\n+                Arguments.of(new BigDecimal(\"10.0\"), \"1.E1\"),\n+                Arguments.of(new BigDecimal(\"1000.0\"), \"1.E3\"),\n+                Arguments.of(new BigInteger(\"00\"), \"0.E0\"),\n+                Arguments.of(new BigInteger(\"10\"), \"1.E1\"),\n+                Arguments.of(new BigInteger(\"1000\"), \"1.E3\")\n+        );\n+    }\n+\n+    \/\/ Confirm that decimal separator not shown when formatting a number\n+    @ParameterizedTest\n+    @MethodSource(\"fractionalDigitsNoSeparatorProvider\")\n+    public void fractionalDigitsNoSeparatorTest(Number num, String expected) {\n+        df = getDF(\"0.#E0\", false);\n+        String actualFormatted = df.format(num);\n+        assertEquals(expected, actualFormatted, getErrMsg(\"0.#E0\", false));\n+    }\n@@ -47,65 +101,78 @@\n-        df.applyPattern(\"0.#E0\");\n-\n-        df.setDecimalSeparatorAlwaysShown(true);\n-        checkFormat(0.0, \"0.E0\");\n-        checkFormat(10.0, \"1.E1\");\n-        checkFormat(1000.0, \"1.E3\");\n-        checkFormat(0L, \"0.E0\");\n-        checkFormat(10L, \"1.E1\");\n-        checkFormat(1000L, \"1.E3\");\n-        checkFormat(new BigDecimal(\"0.0\"), \"0.E0\");\n-        checkFormat(new BigDecimal(\"10.0\"), \"1.E1\");\n-        checkFormat(new BigDecimal(\"1000.0\"), \"1.E3\");\n-        checkFormat(new BigInteger(\"00\"), \"0.E0\");\n-        checkFormat(new BigInteger(\"10\"), \"1.E1\");\n-        checkFormat(new BigInteger(\"1000\"), \"1.E3\");\n-\n-        df.setDecimalSeparatorAlwaysShown(false);\n-        checkFormat(0.0, \"0E0\");\n-        checkFormat(10.0, \"1E1\");\n-        checkFormat(1000.0, \"1E3\");\n-        checkFormat(0L, \"0E0\");\n-        checkFormat(10L, \"1E1\");\n-        checkFormat(1000L, \"1E3\");\n-        checkFormat(new BigDecimal(\"0.0\"), \"0E0\");\n-        checkFormat(new BigDecimal(\"10.0\"), \"1E1\");\n-        checkFormat(new BigDecimal(\"1000.0\"), \"1E3\");\n-        checkFormat(new BigInteger(\"0\"), \"0E0\");\n-        checkFormat(new BigInteger(\"10\"), \"1E1\");\n-        checkFormat(new BigInteger(\"1000\"), \"1E3\");\n-\n-        df.applyPattern(\"0.###\");\n-\n-        df.setDecimalSeparatorAlwaysShown(true);\n-        checkFormat(0.0, \"0.\");\n-        checkFormat(10.0, \"10.\");\n-        checkFormat(1000.0, \"1000.\");\n-        checkFormat(0L, \"0.\");\n-        checkFormat(10L, \"10.\");\n-        checkFormat(1000L, \"1000.\");\n-        checkFormat(new BigDecimal(\"0.0\"), \"0.\");\n-        checkFormat(new BigDecimal(\"10.0\"), \"10.\");\n-        checkFormat(new BigDecimal(\"1000.0\"), \"1000.\");\n-        checkFormat(new BigInteger(\"0\"), \"0.\");\n-        checkFormat(new BigInteger(\"10\"), \"10.\");\n-        checkFormat(new BigInteger(\"1000\"), \"1000.\");\n-\n-        df.setDecimalSeparatorAlwaysShown(false);\n-        checkFormat(0.0, \"0\");\n-        checkFormat(10.0, \"10\");\n-        checkFormat(1000.0, \"1000\");\n-        checkFormat(0L, \"0\");\n-        checkFormat(10L, \"10\");\n-        checkFormat(1000L, \"1000\");\n-        checkFormat(new BigDecimal(\"0.0\"), \"0\");\n-        checkFormat(new BigDecimal(\"10.0\"), \"10\");\n-        checkFormat(new BigDecimal(\"1000.0\"), \"1000\");\n-        checkFormat(new BigInteger(\"0\"), \"0\");\n-        checkFormat(new BigInteger(\"10\"), \"10\");\n-        checkFormat(new BigInteger(\"1000\"), \"1000\");\n-\n-        Locale.setDefault(defaultLoc);\n-\n-        if (err) {\n-            throw new RuntimeException(\"Wrong format\/parse with DecimalFormat\");\n-        }\n+    \/\/ Combination of numbers and a fractional exponent pattern with no separator\n+    private static Stream<Arguments> fractionalDigitsNoSeparatorProvider() {\n+        return Stream.of(\n+                Arguments.of(0.0, \"0E0\"),\n+                Arguments.of(10.0, \"1E1\"),\n+                Arguments.of(1000.0, \"1E3\"),\n+                Arguments.of(0L, \"0E0\"),\n+                Arguments.of(10L, \"1E1\"),\n+                Arguments.of(1000L, \"1E3\"),\n+                Arguments.of(new BigDecimal(\"0.0\"), \"0E0\"),\n+                Arguments.of(new BigDecimal(\"10.0\"), \"1E1\"),\n+                Arguments.of(new BigDecimal(\"1000.0\"), \"1E3\"),\n+                Arguments.of(new BigInteger(\"00\"), \"0E0\"),\n+                Arguments.of(new BigInteger(\"10\"), \"1E1\"),\n+                Arguments.of(new BigInteger(\"1000\"), \"1E3\")\n+        );\n+    }\n+\n+    \/\/ Confirm that decimal separator shown when formatting a number\n+    @ParameterizedTest\n+    @MethodSource(\"noFractionalDigitsWithSeparatorProvider\")\n+    public void noFractionalDigitsWithSeparatorTest(Number num, String expected) {\n+        df = getDF(\"0.###\", true);\n+        String actualFormatted = df.format(num);\n+        assertEquals(expected, actualFormatted, getErrMsg(\"0.###\", true));\n+    }\n+\n+    \/\/ Combination of numbers and a non-fractional exponent pattern with a separator\n+    private static Stream<Arguments> noFractionalDigitsWithSeparatorProvider() {\n+        return Stream.of(\n+                Arguments.of(0.0, \"0.\"),\n+                Arguments.of(10.0, \"10.\"),\n+                Arguments.of(1000.0, \"1000.\"),\n+                Arguments.of(0L, \"0.\"),\n+                Arguments.of(10L, \"10.\"),\n+                Arguments.of(1000L, \"1000.\"),\n+                Arguments.of(new BigDecimal(\"0.0\"), \"0.\"),\n+                Arguments.of(new BigDecimal(\"10.0\"), \"10.\"),\n+                Arguments.of(new BigDecimal(\"1000.0\"), \"1000.\"),\n+                Arguments.of(new BigInteger(\"00\"), \"0.\"),\n+                Arguments.of(new BigInteger(\"10\"), \"10.\"),\n+                Arguments.of(new BigInteger(\"1000\"), \"1000.\")\n+        );\n+    }\n+\n+    \/\/ Confirm that decimal separator not shown when formatting a number\n+    @ParameterizedTest\n+    @MethodSource(\"noFractionalDigitsNoSeparatorProvider\")\n+    public void noFractionalDigitsNoSeparatorTest(Number num, String expected) {\n+        df = getDF(\"0.###\", false);\n+        String actualFormatted = df.format(num);\n+        assertEquals(expected, actualFormatted, getErrMsg(\"0.###\", false));\n+    }\n+\n+    \/\/ Combination of numbers and a non-fractional exponent pattern with no separator\n+    private static Stream<Arguments> noFractionalDigitsNoSeparatorProvider() {\n+        return Stream.of(\n+                Arguments.of(0.0, \"0\"),\n+                Arguments.of(10.0, \"10\"),\n+                Arguments.of(1000.0, \"1000\"),\n+                Arguments.of(0L, \"0\"),\n+                Arguments.of(10L, \"10\"),\n+                Arguments.of(1000L, \"1000\"),\n+                Arguments.of(new BigDecimal(\"0.0\"), \"0\"),\n+                Arguments.of(new BigDecimal(\"10.0\"), \"10\"),\n+                Arguments.of(new BigDecimal(\"1000.0\"), \"1000\"),\n+                Arguments.of(new BigInteger(\"00\"), \"0\"),\n+                Arguments.of(new BigInteger(\"10\"), \"10\"),\n+                Arguments.of(new BigInteger(\"1000\"), \"1000\")\n+        );\n+    }\n+\n+    \/\/ Creates clean DF and sets the pattern and separatorShown value\n+    private static DecimalFormat getDF(String pattern, boolean separatorShown) {\n+        df = new DecimalFormat();\n+        df.applyPattern(pattern);\n+        df.setDecimalSeparatorAlwaysShown(separatorShown);\n+        return df;\n@@ -114,12 +181,4 @@\n-    static void checkFormat(Number num, String expected) {\n-        String got = df.format(num);\n-        if (!got.equals(expected)) {\n-            err = true;\n-            System.err.println(\"    DecimalFormat format(\" +\n-                               num.getClass().getName() +\n-                               \") error:\" +\n-                               \"\\n\\tnumber:           \" + num +\n-                               \"\\n\\tSeparatorShown? : \" + df.isDecimalSeparatorAlwaysShown() +\n-                               \"\\n\\tgot:              \" + got +\n-                               \"\\n\\texpected:         \" + expected);\n-        }\n+    \/\/ Utility to get a helpful error message when values are not as expected\n+    private static String getErrMsg(String pattern, boolean separatorShown) {\n+        return String.format(\"Fails with pattern= %s, with separatorShown = %s\",\n+                pattern, separatorShown);\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/Bug4208135.java","additions":147,"deletions":88,"binary":false,"changes":235,"status":"modified"},{"patch":"@@ -27,1 +27,3 @@\n- * @summary Confirm that DecimalFormat can format a number with negative exponent number correctly.\n+ * @summary Confirm that DecimalFormat can format a number with a negative\n+ *          exponent number correctly. Tests also involve using a DecimalFormat\n+ *          with a custom pattern or a custom minus sign.\n@@ -31,3 +33,6 @@\n-import java.math.*;\n-import java.util.*;\n-import java.text.*;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.text.DecimalFormat;\n+import java.text.DecimalFormatSymbols;\n+import java.util.Locale;\n+import java.util.stream.Stream;\n@@ -35,1 +40,5 @@\n-import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n@@ -37,0 +46,1 @@\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n@@ -39,0 +49,10 @@\n+\/*\n+ * This bug is about exponential formatting. But I added test cases for:\n+ *   - Double and BigDecimal numbers which don't have exponent parts.\n+ *   - Long and BigInteger numbers which don't support exponential\n+ *     notation.\n+ * because there are few test cases for suffix and prefix.\n+ * And also, I added test cases to guarantee further formatting and\n+ * parsing using the same DecimalFormat instance will not change the\n+ * Number's value anymore.\n+ *\/\n@@ -41,3 +61,2 @@\n-    static DecimalFormat df;\n-    static DecimalFormatSymbols dfs;\n-    static boolean err = false;\n+    \/\/ Save JVM default Locale\n+    private static final Locale savedLocale = Locale.getDefault();\n@@ -45,2 +64,3 @@\n-    static public void main(String[] args) {\n-        Locale defaultLoc = Locale.getDefault();\n+    \/\/ Set JVM default Locale to US\n+    @BeforeAll\n+    static void init() {\n@@ -48,22 +68,0 @@\n-\n-        \/**\n-         * This bug is about exponential formatting. But I added test cases for:\n-         *   - Double and BigDecimal numbers which don't have exponent parts.\n-         *   - Long and BigInteger numbers which don't support exponential\n-         *     notation.\n-         * because there are few test cases for suffix and prefix.\n-         * And also, I added test cases to guarantee further formatting and\n-         * parsing using the same DecimalFormat instance will not change the\n-         * Number's value anymore.\n-         *\/\n-\n-        test_double();\n-        test_long();\n-        test_BigDecimal();\n-        test_BigInteger();\n-\n-        Locale.setDefault(defaultLoc);\n-\n-        if (err) {\n-            throw new RuntimeException(\"Wrong format with DecimalFormat\");\n-        }\n@@ -72,46 +70,4 @@\n-    static void test_double() {\n-        df = new DecimalFormat();\n-        dfs = df.getDecimalFormatSymbols();\n-\n-        \/* Test with default pattern *\/\n-        test(1234D,    \"1,234\");\n-        test(0.1234,  \"0.123\");     \/\/ rounded\n-        test(-1234D,   \"-1,234\");\n-        test(-0.1234, \"-0.123\");    \/\/ rounded\n-\n-        test(Double.POSITIVE_INFINITY, \"\\u221e\");\n-        test(Double.NEGATIVE_INFINITY, \"-\\u221e\");\n-        test(Double.NaN, \"\\ufffd\"); \/\/ without prefix and suffix\n-        test(0.0,  \"0\");\n-        test(-0.0, \"-0\");   \/\/ with the minus sign\n-\n-        \/* Specify a pattern and the minus sign. *\/\n-        prepareFormatter(\"<P>#.###E00<S>\", 'm');\n-        test(1234D,    \"<P>1.234E03<S>\");\n-        test(0.1234,  \"<P>1.234Em01<S>\");\n-        test(-1234D,   \"m<P>1.234E03<S>\");\n-        test(-0.1234, \"m<P>1.234Em01<S>\");\n-\n-        prepareFormatter(\"<P>#.###E00<S>;#.###E00\", 'm');\n-        test(1234D,    \"<P>1.234E03<S>\");\n-        test(0.1234,  \"<P>1.234Em01<S>\");\n-        test(-1234D,   \"1.234E03\");\n-        test(-0.1234, \"1.234Em01\");\n-\n-        prepareFormatter(\"#.###E00;<P>#.###E00<S>\", 'm');\n-        test(1234D,    \"1.234E03\");\n-        test(0.1234,  \"1.234Em01\");\n-        test(-1234D,   \"<P>1.234E03<S>\");\n-        test(-0.1234, \"<P>1.234Em01<S>\");\n-\n-        prepareFormatter(\"<P>#.###E00<S>;<p>-#.###E00<s>\", 'm');\n-        test(1234D,    \"<P>1.234E03<S>\");\n-        test(0.1234,  \"<P>1.234Em01<S>\");\n-        test(-1234D,   \"<p>m1.234E03<s>\");\n-        test(-0.1234, \"<p>m1.234Em01<s>\");\n-\n-        test(Double.POSITIVE_INFINITY, \"<P>\\u221e<S>\");\n-        test(Double.NEGATIVE_INFINITY, \"<p>m\\u221e<s>\");\n-        test(Double.NaN, \"\\ufffd\"); \/\/ without prefix and suffix\n-        test(0.0,  \"<P>0E00<S>\");\n-        test(-0.0, \"<p>m0E00<s>\");  \/\/ with the minus sign\n+    \/\/ Restore the original JVM default locale\n+    @AfterAll\n+    static void tearDown() {\n+        Locale.setDefault(savedLocale);\n@@ -120,30 +76,5 @@\n-    static void test_BigDecimal() {\n-        df = new DecimalFormat();\n-        dfs = df.getDecimalFormatSymbols();\n-\n-        \/* Test with default pattern *\/\n-        test(new BigDecimal(\"123456789012345678901234567890\"),\n-             \"123,456,789,012,345,678,901,234,567,890\");\n-        test(new BigDecimal(\"0.000000000123456789012345678901234567890\"),\n-             \"0\");\n-        test(new BigDecimal(\"-123456789012345678901234567890\"),\n-             \"-123,456,789,012,345,678,901,234,567,890\");\n-        test(new BigDecimal(\"-0.000000000123456789012345678901234567890\"),\n-              \"-0\");\n-\n-        test(new BigDecimal(\"0\"), \"0\");\n-        test(new BigDecimal(\"-0\"), \"0\");\n-\n-        \/* Specify a pattern and the minus sign. *\/\n-        prepareFormatter(\"<P>#.####################E00<S>;<p>-#.####################E00<s>\", 'm');\n-        test(new BigDecimal(\"123456789012345678901234567890\"),\n-             \"<P>1.23456789012345678901E29<S>\");\n-        test(new BigDecimal(\"0.000000000123456789012345678901234567890\"),\n-             \"<P>1.23456789012345678901Em10<S>\");\n-        test(new BigDecimal(\"-123456789012345678901234567890\"),\n-             \"<p>m1.23456789012345678901E29<s>\");\n-        test(new BigDecimal(\"-0.000000000123456789012345678901234567890\"),\n-              \"<p>m1.23456789012345678901Em10<s>\");\n-\n-        test(new BigDecimal(\"0\"), \"<P>0E00<S>\");\n-        test(new BigDecimal(\"-0\"), \"<P>0E00<S>\");\n+    \/\/ Check that negative exponent number recognized for doubles\n+    @ParameterizedTest\n+    @MethodSource(\"doubles\")\n+    public void doubleTest(Number num, String str, DecimalFormat df) {\n+        test(num, str, df);\n@@ -152,18 +83,43 @@\n-    static void test_long() {\n-        df = new DecimalFormat();\n-        dfs = df.getDecimalFormatSymbols();\n-\n-        \/* Test with default pattern *\/\n-        test(123456789L,  \"123,456,789\");\n-        test(-123456789L, \"-123,456,789\");\n-\n-        test(0L, \"0\");\n-        test(-0L, \"0\");\n-\n-        \/* Specify a pattern and the minus sign. *\/\n-        prepareFormatter(\"<P>#,###<S>;<p>-#,###<s>\", 'm');\n-        test(123456789L,  \"<P>123,456,789<S>\");\n-        test(-123456789L, \"<p>m123,456,789<s>\");\n-\n-        test(0L, \"<P>0<S>\");\n-        test(-0L, \"<P>0<S>\");\n+    \/\/ Provides a double to be formatted, which is compared to the expected String.\n+    \/\/ Additionally, provides a DecimalFormat to do the formatting (can have a custom\n+    \/\/ pattern and minus sign). Given in the form (double, String, DecimalFormat).\n+    private static Stream<Arguments> doubles() {\n+        DecimalFormat defaultDf = new DecimalFormat();\n+        DecimalFormat customDf1 = getDecimalFormat(\"<P>#.###E00<S>\", 'm');\n+        DecimalFormat customDf2 = getDecimalFormat(\"<P>#.###E00<S>;#.###E00\", 'm');\n+        DecimalFormat customDf3 = getDecimalFormat(\"#.###E00;<P>#.###E00<S>\", 'm');\n+        DecimalFormat customDf4 = getDecimalFormat(\"<P>#.###E00<S>;<p>-#.###E00<s>\", 'm');\n+        return Stream.of(\n+                \/\/ Test with default pattern\n+                Arguments.of(1234D,    \"1,234\", defaultDf),\n+                Arguments.of(0.1234,  \"0.123\", defaultDf),    \/\/ rounded\n+                Arguments.of(-1234D,   \"-1,234\", defaultDf),\n+                Arguments.of(-0.1234, \"-0.123\", defaultDf),    \/\/ rounded\n+                Arguments.of(Double.POSITIVE_INFINITY, \"\\u221e\", defaultDf),\n+                Arguments.of(Double.NEGATIVE_INFINITY, \"-\\u221e\", defaultDf),\n+                Arguments.of(Double.NaN, \"\\ufffd\", defaultDf), \/\/ without prefix and suffix\n+                Arguments.of(0.0,  \"0\", defaultDf),\n+                Arguments.of(-0.0, \"-0\", defaultDf),   \/\/ with the minus sign\n+                \/\/ Test with a pattern and the minus sign\n+                Arguments.of(1234D,    \"<P>1.234E03<S>\", customDf1),\n+                Arguments.of(0.1234,  \"<P>1.234Em01<S>\", customDf1),\n+                Arguments.of(-1234D,   \"m<P>1.234E03<S>\", customDf1),\n+                Arguments.of(-0.1234, \"m<P>1.234Em01<S>\", customDf1),\n+                Arguments.of(1234D,    \"<P>1.234E03<S>\", customDf2),\n+                Arguments.of(0.1234,  \"<P>1.234Em01<S>\", customDf2),\n+                Arguments.of(-1234D,   \"1.234E03\", customDf2),\n+                Arguments.of(-0.1234, \"1.234Em01\", customDf2),\n+                Arguments.of(1234D,    \"1.234E03\", customDf3),\n+                Arguments.of(0.1234,  \"1.234Em01\", customDf3),\n+                Arguments.of(-1234D,   \"<P>1.234E03<S>\", customDf3),\n+                Arguments.of(-0.1234, \"<P>1.234Em01<S>\", customDf3),\n+                Arguments.of(1234D,    \"<P>1.234E03<S>\", customDf4),\n+                Arguments.of(0.1234,  \"<P>1.234Em01<S>\", customDf4),\n+                Arguments.of(-1234D,   \"<p>m1.234E03<s>\", customDf4),\n+                Arguments.of(-0.1234, \"<p>m1.234Em01<s>\", customDf4),\n+                Arguments.of(Double.POSITIVE_INFINITY, \"<P>\\u221e<S>\", customDf4),\n+                Arguments.of(Double.NEGATIVE_INFINITY, \"<p>m\\u221e<s>\", customDf4),\n+                Arguments.of(Double.NaN, \"\\ufffd\", customDf4), \/\/ without prefix and suffix\n+                Arguments.of(0.0,  \"<P>0E00<S>\", customDf4),\n+                Arguments.of(-0.0, \"<p>m0E00<s>\", customDf4) \/\/ with the minus sign\n+        );\n@@ -172,3 +128,6 @@\n-    static void test_BigInteger() {\n-        df = new DecimalFormat();\n-        dfs = df.getDecimalFormatSymbols();\n+    \/\/ Check that negative exponent number recognized for longs\n+    @ParameterizedTest\n+    @MethodSource(\"longs\")\n+    public void longTest(Number num, String str, DecimalFormat df) {\n+        test(num, str, df);\n+    }\n@@ -176,5 +135,19 @@\n-        \/* Test with default pattern *\/\n-        test(new BigInteger(\"123456789012345678901234567890\"),\n-             \"123,456,789,012,345,678,901,234,567,890\");\n-        test(new BigInteger(\"-123456789012345678901234567890\"),\n-             \"-123,456,789,012,345,678,901,234,567,890\");\n+    \/\/ Same as doubles() data provider, but with long values\n+    \/\/ Given in the form (long, String, DecimalFormat).\n+    private static Stream<Arguments> longs() {\n+        DecimalFormat defaultDf = new DecimalFormat();\n+        DecimalFormat customDf = getDecimalFormat(\n+                \"<P>#,###<S>;<p>-#,###<s>\", 'm');\n+        return Stream.of(\n+                \/\/ Test with default pattern\n+                Arguments.of(123456789L,  \"123,456,789\", defaultDf),\n+                Arguments.of(-123456789L, \"-123,456,789\", defaultDf),\n+                Arguments.of(0L, \"0\", defaultDf),\n+                Arguments.of(-0L, \"0\", defaultDf),\n+                \/\/ Test with a pattern and the minus sign\n+                Arguments.of(123456789L,  \"<P>123,456,789<S>\", customDf),\n+                Arguments.of(-123456789L, \"<p>m123,456,789<s>\", customDf),\n+                Arguments.of(0L, \"<P>0<S>\", customDf),\n+                Arguments.of(-0L, \"<P>0<S>\", customDf)\n+        );\n+    }\n@@ -182,2 +155,6 @@\n-        test(new BigInteger(\"0\"), \"0\");\n-        test(new BigInteger(\"-0\"), \"0\");\n+    \/\/ Check that negative exponent number recognized for bigDecimals\n+    @ParameterizedTest\n+    @MethodSource(\"bigDecimals\")\n+    public void bigDecimalTest(Number num, String str, DecimalFormat df) {\n+        test(num, str, df);\n+    }\n@@ -185,6 +162,31 @@\n-        \/* Specify a pattern and the minus sign. *\/\n-        prepareFormatter(\"<P>#,###<S>;<p>-#,###<s>\", 'm');\n-        test(new BigInteger(\"123456789012345678901234567890\"),\n-             \"<P>123,456,789,012,345,678,901,234,567,890<S>\");\n-        test(new BigInteger(\"-123456789012345678901234567890\"),\n-             \"<p>m123,456,789,012,345,678,901,234,567,890<s>\");\n+    \/\/ Same as doubles() data provider, but with BigDecimal values\n+    \/\/ Given in the form (BigDecimal, String, DecimalFormat).\n+    private static Stream<Arguments> bigDecimals() {\n+        DecimalFormat defaultDf = new DecimalFormat();\n+        DecimalFormat customDf = getDecimalFormat(\n+                \"<P>#.####################E00<S>;<p>-#.####################E00<s>\", 'm');\n+        return Stream.of(\n+                \/\/ Test with default pattern\n+                Arguments.of(new BigDecimal(\"123456789012345678901234567890\"),\n+                        \"123,456,789,012,345,678,901,234,567,890\", defaultDf),\n+                Arguments.of(new BigDecimal(\"0.000000000123456789012345678901234567890\"),\n+                        \"0\", defaultDf),\n+                Arguments.of(new BigDecimal(\"-123456789012345678901234567890\"),\n+                        \"-123,456,789,012,345,678,901,234,567,890\", defaultDf),\n+                Arguments.of(new BigDecimal(\"-0.000000000123456789012345678901234567890\"),\n+                        \"-0\", defaultDf),\n+                Arguments.of(new BigDecimal(\"0\"), \"0\", defaultDf),\n+                Arguments.of(new BigDecimal(\"-0\"), \"0\", defaultDf),\n+                \/\/ Test with a pattern and the minus sign\n+                Arguments.of(new BigDecimal(\"123456789012345678901234567890\"),\n+                        \"<P>1.23456789012345678901E29<S>\", customDf),\n+                Arguments.of(new BigDecimal(\"0.000000000123456789012345678901234567890\"),\n+                        \"<P>1.23456789012345678901Em10<S>\", customDf),\n+                Arguments.of(new BigDecimal(\"-123456789012345678901234567890\"),\n+                        \"<p>m1.23456789012345678901E29<s>\", customDf),\n+                Arguments.of(new BigDecimal(\"-0.000000000123456789012345678901234567890\"),\n+                        \"<p>m1.23456789012345678901Em10<s>\", customDf),\n+                Arguments.of(new BigDecimal(\"0\"), \"<P>0E00<S>\", customDf),\n+                Arguments.of(new BigDecimal(\"-0\"), \"<P>0E00<S>\", customDf)\n+        );\n+    }\n@@ -192,2 +194,5 @@\n-        test(new BigInteger(\"0\"), \"<P>0<S>\");\n-        test(new BigInteger(\"-0\"), \"<P>0<S>\");\n+    \/\/ Check that negative exponent number recognized for bigIntegers\n+    @ParameterizedTest\n+    @MethodSource(\"bigIntegers\")\n+    public void bigIntegerTest(Number num, String str, DecimalFormat df) {\n+        test(num, str, df);\n@@ -196,5 +201,22 @@\n-    static void prepareFormatter(String pattern, char minusSign) {\n-        dfs = df.getDecimalFormatSymbols();\n-        df.applyPattern(pattern);\n-        dfs.setMinusSign(minusSign);\n-        df.setDecimalFormatSymbols(dfs);\n+    \/\/ Same as doubles() data provider, but with BigInteger values\n+    \/\/ Given in the form (BigInteger, String, DecimalFormat).\n+    private static Stream<Arguments> bigIntegers() {\n+        DecimalFormat defaultDf = new DecimalFormat();\n+        DecimalFormat customDf = getDecimalFormat(\n+                \"<P>#,###<S>;<p>-#,###<s>\", 'm');\n+        return Stream.of(\n+                \/\/ Test with default pattern\n+                Arguments.of(new BigInteger(\"123456789012345678901234567890\"),\n+                        \"123,456,789,012,345,678,901,234,567,890\", defaultDf),\n+                Arguments.of(new BigInteger(\"-123456789012345678901234567890\"),\n+                        \"-123,456,789,012,345,678,901,234,567,890\", defaultDf),\n+                Arguments.of(new BigInteger(\"0\"), \"0\", defaultDf),\n+                Arguments.of(new BigInteger(\"-0\"), \"0\", defaultDf),\n+                \/\/ Test with a pattern and the minus sign\n+                Arguments.of(new BigInteger(\"123456789012345678901234567890\"),\n+                        \"<P>123,456,789,012,345,678,901,234,567,890<S>\", customDf),\n+                Arguments.of(new BigInteger(\"-123456789012345678901234567890\"),\n+                        \"<p>m123,456,789,012,345,678,901,234,567,890<s>\", customDf),\n+                Arguments.of(new BigInteger(\"0\"), \"<P>0<S>\", customDf),\n+                Arguments.of(new BigInteger(\"-0\"), \"<P>0<S>\", customDf)\n+        );\n@@ -203,1 +225,3 @@\n-    static void test(Number num, String str) {\n+    \/\/ Check that the formatted value is correct and also check that\n+    \/\/ it can be round-tripped via parse() and format()\n+    private static void test(Number num, String str, DecimalFormat df) {\n@@ -205,10 +229,2 @@\n-        if (!formatted.equals(str)) {\n-            err = true;\n-            System.err.println(\"    DecimalFormat format(\" +\n-                               num.getClass().getName() +\n-                               \") error: \\n\\tnumber: \" + num +\n-                               \"\\n\\tminus sign: \" + dfs.getMinusSign() +\n-                               \"\\n\\tgot:        \" + formatted +\n-                               \"\\n\\texpected:   \" + str);\n-            return;\n-        }\n+        assertEquals(str, formatted, String.format(\"DecimalFormat format(%s) \" +\n+                \"Error: number: %s, minus sign: %s\", num.getClass().getName(), num, df.getDecimalFormatSymbols().getMinusSign()));\n@@ -219,0 +235,6 @@\n+        testRoundTrip(formatted, str, num, df);\n+    }\n+\n+    \/\/ Test that a parsed value can be round-tripped via format() and parse()\n+    private static void testRoundTrip(String formatted, String str,\n+                                      Number num, DecimalFormat df) {\n@@ -224,12 +246,11 @@\n-            if (!parsed1.equals(parsed2)) {\n-                err = true;\n-                System.err.println(\"    DecimalFormat roundtrip parse(\" +\n-                                   num.getClass().getName() +\n-                                   \") error: \\n\\toriginal number:  \" + str +\n-                                   \"\\n\\tparsed number:    \" + parsed1 +\n-                                   \"  (\" + parsed1.getClass().getName() + \")\" +\n-                                   \"\\n\\tformatted number: \" + formatted +\n-                                   \"\\n\\tre-parsed number: \" + parsed2 +\n-                                   \"  (\" + parsed2.getClass().getName() + \")\" +\n-                                   \"\\n\\tminus sign: \" + dfs.getMinusSign());\n-            }\n+            assertEquals(parsed2, parsed1, \"\"\"\n+                            DecimalFormat round trip parse(%s) error:\n+                                original number: %s\n+                                parsed number: %s\n+                                (%s)\n+                                formatted number: %s\n+                                re-parsed number: %s\n+                                (%s)\n+                                minus sign: %s\n+                            \"\"\".formatted(num.getClass().getName(), str, parsed1, parsed1.getClass().getName(),\n+                                    formatted, parsed2, parsed2.getClass().getName(), df.getDecimalFormatSymbols().getMinusSign()));\n@@ -238,11 +259,11 @@\n-            err = true;\n-            System.err.println(\"    DecimalFormat parse(\" +\n-                               num.getClass().getName() +\n-                               \") threw an Exception:  \" + e.getMessage() +\n-                               \"\\n\\toriginal number:  \" + str +\n-                               \"\\n\\tparsed number   : \" + parsed1 +\n-                               \"  (\" + parsed1.getClass().getName() + \")\" +\n-                               \"\\n\\tformatted number: \" + formatted +\n-                               \"\\n\\tre-parsed number: \" + parsed2 +\n-                               \"  (\" + parsed2.getClass().getName() + \")\" +\n-                               \"\\n\\tminus sign: \" + dfs.getMinusSign());\n+            fail(\"\"\"\n+                    DecimalFormat parse(%s) threw an Exception: %s\n+                        original number: %s\n+                        parsed number: %s\n+                        (%s)\n+                        formatted number: %s\n+                        re-parsed number: %s\n+                        (%s)\n+                        minus sign: %s\n+                    \"\"\".formatted(num.getClass().getName(), e.getMessage(), str, parsed1, parsed1.getClass().getName(),\n+                            formatted, parsed2, parsed2.getClass().getName(), df.getDecimalFormatSymbols().getMinusSign()));\n@@ -251,0 +272,10 @@\n+\n+    \/\/ Set up custom DecimalFormat with DecimalFormatSymbols\n+    private static DecimalFormat getDecimalFormat(String pattern, char minusSign) {\n+        DecimalFormat df = new DecimalFormat();\n+        DecimalFormatSymbols dfs = df.getDecimalFormatSymbols();\n+        df.applyPattern(pattern);\n+        dfs.setMinusSign(minusSign);\n+        df.setDecimalFormatSymbols(dfs);\n+        return df;\n+    }\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/Bug4838107.java","additions":214,"deletions":183,"binary":false,"changes":397,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,3 @@\n- * and which are between Long.MIN_VALUE and Long.MAX_VALUE are returned as Long(not double).\n+ *          and which are between Long.MIN_VALUE and Long.MAX_VALUE are returned\n+ *          as Long(not double).\n+ * @run junit Bug4944439\n@@ -31,2 +33,0 @@\n-import java.math.BigDecimal;\n-import java.math.BigInteger;\n@@ -34,0 +34,1 @@\n+import java.util.ArrayList;\n@@ -35,0 +36,1 @@\n+import java.util.stream.Stream;\n@@ -36,4 +38,5 @@\n-public class Bug4944439 {\n-\n-    static boolean err = false;\n-    static DecimalFormat df;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n@@ -41,4 +44,3 @@\n-    public static void main(String[] args) throws Exception {\n-\n-        Locale defaultLoc = Locale.getDefault();\n-        Locale.setDefault(Locale.US);\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertInstanceOf;\n@@ -46,3 +48,1 @@\n-        df = new DecimalFormat();\n-        String s = \"-9223372036854775809\";      \/\/ Long.MIN_VALUE-1\n-        check_Double(s);\n+public class Bug4944439 {\n@@ -50,3 +50,3 @@\n-        test(Long.MIN_VALUE, Long.MIN_VALUE+10);\n-        test(-10, 10);\n-        test(Long.MAX_VALUE-10, Long.MAX_VALUE-1);\n+    \/\/ Save JVM default locale\n+    private static final Locale savedLocale = Locale.getDefault();\n+    private static final DecimalFormat df = new DecimalFormat();\n@@ -54,4 +54,5 @@\n-        s = \"9223372036854775807.00\";   \/\/ Long.MAX_VALUE\n-        check_Long(s);\n-        s = \"9223372036854775808\";      \/\/ Long.MAX_VALUE+1\n-        check_Double(s);\n+    \/\/ Set JVM default locale to US for testing\n+    @BeforeAll\n+    static void initAll() {\n+        Locale.setDefault(Locale.US);\n+    }\n@@ -59,4 +60,5 @@\n-        s = \"-0.0\";\n-        check_Double(s);\n-        s = \"0.0\";\n-        check_Long(s);\n+    \/\/ Restore JVM default locale\n+    @AfterAll\n+    static void tearDownAll() {\n+        Locale.setDefault(savedLocale);\n+    }\n@@ -64,1 +66,14 @@\n-        Locale.setDefault(defaultLoc);\n+    \/\/ Check return type and value returned by DecimalFormat.parse() for longs\n+    @ParameterizedTest\n+    @MethodSource(\"longs\")\n+    public void parseLongTest(String s) {\n+        \/\/ This was originally intended to ensure a ParseException is not thrown\n+        Number parsedNumber = assertDoesNotThrow(() -> df.parse(s),\n+                \"DecimalFormat.parse(\\\"%s\\\") should not throw an Exception\");\n+        assertInstanceOf(Long.class, parsedNumber,\n+                \"DecimalFormat.parse(\\\"%s\\\") did not return Long\");\n+        \/\/ Grab integer portion of value\n+        Long expectedVal = Long.valueOf(s.substring(0, s.indexOf('.')));\n+        assertEquals(parsedNumber, expectedVal,\n+                \"DecimalFormat.parse(\\\"%s\\\") returned numerically incorrect value\");\n+    }\n@@ -66,3 +81,9 @@\n-        if (err) {\n-            throw new RuntimeException(\"Wrong parsing with DecimalFormat\");\n-        }\n+    \/\/ Test some values between Long.MIN_VALUE and Long.MAX_VALUE\n+    private static Stream<String> longs() {\n+        ArrayList<String> longs = new ArrayList<>();\n+        addLongData(Long.MIN_VALUE, Long.MIN_VALUE+10, longs);\n+        addLongData(-10, 10, longs);\n+        addLongData(Long.MAX_VALUE-10, Long.MAX_VALUE-1, longs);\n+        longs.add(\"9223372036854775807.00\");\n+        longs.add(\"0.0\");\n+        return longs.stream();\n@@ -71,1 +92,2 @@\n-    private static void test(long from, long to) throws Exception {\n+    \/\/ Utility to add values between parameters(long, to) to testLongs ArrayList\n+    private static void addLongData(long from, long to, ArrayList<String> testLongs){\n@@ -73,1 +95,1 @@\n-            check_Long(Long.toString(l) + \".00\");\n+            testLongs.add(l + \".00\");\n@@ -77,16 +99,12 @@\n-    private static void check_Long(String s) throws Exception {\n-        Number number = df.parse(s);\n-        if (!(number instanceof Long)) {\n-            err = true;\n-            System.err.println(\"Failed: DecimalFormat.parse(\\\"\" + s +\n-                \"\\\") should return a Long, but returned a \" +\n-                number.getClass().getName());\n-        }\n-\n-        int index = s.indexOf('.');\n-        Long l = Long.valueOf(s.substring(0, index));\n-        if (!l.equals(number)) {\n-            err = true;\n-            System.err.println(\"Failed: DecimalFormat.parse(\" + s +\n-                \") should return a Long(\" + l + \"), but returned \" + number);\n-        }\n+    \/\/ Check return type and value returned by DecimalFormat.parse() for doubles\n+    @ParameterizedTest\n+    @MethodSource(\"doubles\")\n+    public void parseDoubleTest(String s) {\n+        \/\/ This was originally intended to ensure a ParseException is not thrown\n+        Number parsedNumber = assertDoesNotThrow(() -> df.parse(s),\n+                \"DecimalFormat.parse(\\\"%s\\\") should not throw an Exception\");\n+        assertInstanceOf(Double.class, parsedNumber,\n+                \"DecimalFormat.parse(\\\"%s\\\") did not return Double\");\n+        Double expectedVal = Double.valueOf(s);\n+        assertEquals(parsedNumber, expectedVal,\n+                \"DecimalFormat.parse(\\\"%s\\\") returned numerically incorrect value\");\n@@ -95,15 +113,7 @@\n-    private static void check_Double(String s) throws Exception {\n-        Number number = df.parse(s);\n-        if (!(number instanceof Double)) {\n-            err = true;\n-            System.err.println(\"Failed: DecimalFormat.parse(\\\"\" + s +\n-                \"\\\") should return a Double, but returned a \" +\n-                number.getClass().getName());\n-        }\n-\n-        Double d = Double.valueOf(s);\n-        if (!d.equals(number)) {\n-            err = true;\n-            System.err.println(\"Failed: DecimalFormat.parse(\" + s +\n-                \") should return a Double(\" + d + \"), but returned \" + number);\n-        }\n+    \/\/ Check values not between Long.MIN_VALUE and Long.MAX_VALUE\n+    private static Stream<String> doubles() {\n+        return Stream.of(\n+                \"-9223372036854775809\", \/\/ Long.MIN_VALUE-1\n+                \"9223372036854775808\", \/\/ Long.MAX_VALUE+1\n+                \"-0.0\"\n+        );\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/Bug4944439.java","additions":73,"deletions":63,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,1 @@\n-\/**\n+\/*\n@@ -27,1 +27,3 @@\n- * @summary Make sure that any subclass of Number can be formatted using DecimalFormat.format().\n+ * @summary Make sure that any subclass of Number can be formatted using\n+ *          DecimalFormat.format() without throwing an exception.\n+ * @run junit Bug4990596\n@@ -32,0 +34,4 @@\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+\n@@ -34,2 +40,6 @@\n-    public static void main(String[] args) {\n-        new DecimalFormat().format(new MutableInteger(0));\n+    \/\/ Test that a custom subclass of Number can be formatted by\n+    \/\/ DecimalFormat without throwing an IllegalArgumentException\n+    @Test\n+    public void formatSubclassedNumberTest() {\n+        assertDoesNotThrow(() -> new DecimalFormat().format(new MutableInteger(0)),\n+                \"DecimalFormat.format() should support subclasses of Number\");\n@@ -38,0 +48,2 @@\n+    \/\/ A custom subclass of Number. Prior to this fix, if an instance of this\n+    \/\/ class was formatted by DecimalFormat, an exception would be thrown.\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/Bug4990596.java","additions":17,"deletions":5,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,2 @@\n+ *          That is, make sure they are not treated as a double when formatted\n+ *          anymore (which can result in the loss of precision).\n@@ -28,0 +30,1 @@\n+ * @run junit Bug6278616\n@@ -34,1 +37,5 @@\n-import java.util.Locale;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n@@ -38,3 +45,1 @@\n-    static final int[] ints = {\n-        Integer.MIN_VALUE, -1, 0, 1, Integer.MAX_VALUE\n-    };\n+    private static final NumberFormat nf = NumberFormat.getInstance();\n@@ -42,3 +47,10 @@\n-    static final long[] longs = {\n-        Long.MIN_VALUE, -1, 0, 1, Long.MAX_VALUE\n-    };\n+    \/\/ Test that NumberFormat formats numerically equivalent int\n+    \/\/ and AtomicInteger values the same\n+    @ParameterizedTest\n+    @MethodSource(\"ints\")\n+    public void formattedAtomicIntTest(int testInt) {\n+        String formattedInt = nf.format(testInt);\n+        String formattedAtomicInt = nf.format(new AtomicInteger(testInt));\n+        assertEquals(formattedAtomicInt, formattedInt, \"Formatting numerically\" +\n+                \" equivalent AtomicInteger and int should produce the same String value\");\n+    }\n@@ -46,2 +58,4 @@\n-    public static void main(String[] args) {\n-        NumberFormat nf = NumberFormat.getInstance();\n+    \/\/ Various int values\n+    private static int[] ints() {\n+        return new int[] { Integer.MIN_VALUE, -1, 0, 1, Integer.MAX_VALUE};\n+    }\n@@ -49,9 +63,10 @@\n-        for (int j = 0; j < ints.length; j++) {\n-            String s_i = nf.format(ints[j]);\n-            String s_ai = nf.format(new AtomicInteger(ints[j]));\n-            if (!s_i.equals(s_ai)) {\n-                throw new RuntimeException(\"format(AtomicInteger \" + s_ai +\n-                                           \") doesn't equal format(Integer \" +\n-                                           s_i + \")\");\n-            }\n-        }\n+    \/\/ Test that NumberFormat formats numerically equivalent long\n+    \/\/ and AtomicLong values the same\n+    @ParameterizedTest\n+    @MethodSource(\"longs\")\n+    public void formattedAtomicLongTest(long testLong) {\n+        String formattedLong = nf.format(testLong);\n+        String formattedAtomicLong = nf.format(new AtomicLong(testLong));\n+        assertEquals(formattedAtomicLong, formattedLong, \"Formatting numerically\" +\n+                \" equivalent AtomicLong and long should produce the same String value\");\n+    }\n@@ -59,9 +74,3 @@\n-        for (int j = 0; j < longs.length; j++) {\n-            String s_l = nf.format(longs[j]);\n-            String s_al = nf.format(new AtomicLong(longs[j]));\n-            if (!s_l.equals(s_al)) {\n-                throw new RuntimeException(\"format(AtomicLong \" + s_al +\n-                                           \") doesn't equal format(Long \" +\n-                                           s_l + \")\");\n-            }\n-        }\n+    \/\/ Various long values\n+    private static long[] longs() {\n+        return new long[] { Long.MIN_VALUE, -1, 0, 1, Long.MAX_VALUE};\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/Bug6278616.java","additions":37,"deletions":28,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+ * @run junit Bug8132125\n@@ -31,2 +32,6 @@\n-import java.text.*;\n-import java.util.*;\n+import java.text.NumberFormat;\n+import java.util.Locale;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n@@ -35,1 +40,4 @@\n-    public static void main(String[] args) {\n+\n+    \/\/ Ensure the CLDRConverter does not omit the Swiss number elements\n+    @Test\n+    public void swissNumElementsTest() {\n@@ -39,1 +47,2 @@\n-        String expected = \"54\\u2019839\\u2019483.142\"; \/\/ i.e. \"\\u2019\" as decimal separator, \"\\u2019\" as grouping separator\n+        \/\/ \"\\u002E\" as decimal separator, \"\\u2019\" as grouping separator\n+        String expected = \"54\\u2019839\\u2019483.142\";\n@@ -41,3 +50,1 @@\n-        if (!actual.equals(expected)) {\n-            throw new RuntimeException(\"incorrect for de_CH: \" + expected + \" vs. actual \" + actual);\n-        }\n+        assertEquals(expected, actual, \"incorrect number elements for de_CH\");\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/Bug8132125.java","additions":15,"deletions":8,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ *          Tests both COMPAT and CLDR data.\n@@ -29,2 +30,2 @@\n- * @run main\/othervm -Djava.locale.providers=COMPAT CurrencyFormat COMPAT\n- * @run main\/othervm -Djava.locale.providers=CLDR CurrencyFormat CLDR\n+ * @run junit\/othervm -Djava.locale.providers=COMPAT CurrencyFormat\n+ * @run junit\/othervm -Djava.locale.providers=CLDR CurrencyFormat\n@@ -35,0 +36,1 @@\n+import java.io.IOException;\n@@ -37,0 +39,2 @@\n+import java.text.ParseException;\n+import java.util.ArrayList;\n@@ -45,0 +49,7 @@\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n@@ -48,1 +59,4 @@\n-    private static boolean isCompat;\n+    \/\/ Expected data is switched depending on COMPAT or CLDR\n+    \/\/ currencySymbolsTest() is only ran for COMPAT\n+    private static final boolean isCompat =\n+            \"COMPAT\".equals(System.getProperty(\"java.locale.providers\"));\n@@ -50,4 +64,15 @@\n-    public static void main(String[] args) throws Exception {\n-        isCompat = \"COMPAT\".equals(args[0]);\n-        testFormatting();\n-        testSymbols();\n+    \/\/ Tests the formatting of data for COMPAT + CLDR under various currencies\n+    \/\/ Using a NumberFormat generated by getCurrencyInstance()\n+    @ParameterizedTest\n+    @MethodSource(\"currencyFormatDataProvider\")\n+    public void currencyFormatTest(String expected, Currency currency,\n+                                   NumberFormat format, Locale locale) {\n+        if (currency != null) {\n+            format.setCurrency(currency);\n+            int digits = currency.getDefaultFractionDigits();\n+            format.setMinimumFractionDigits(digits);\n+            format.setMaximumFractionDigits(digits);\n+        }\n+        String result = format.format(1234.56);\n+        assertEquals(expected, result, String.format(\"Failed with locale: %s%s\",\n+                locale, (currency == null ? \", default currency\" : (\", currency: \" + currency))));\n@@ -56,2 +81,4 @@\n-    static void testFormatting() {\n-        boolean failed = false;\n+    \/\/ Generate a combination of expected data for 1234.56 formatted\n+    \/\/ under various currencies\/locale provider\/locale\n+    private static Stream<Arguments> currencyFormatDataProvider() {\n+        ArrayList<Arguments> data = new ArrayList<Arguments>();\n@@ -59,7 +86,7 @@\n-            Locale.US,\n-            Locale.JAPAN,\n-            Locale.GERMANY,\n-            Locale.ITALY,\n-            Locale.of(\"it\", \"IT\", \"EURO\"),\n-            Locale.forLanguageTag(\"de-AT\"),\n-            Locale.forLanguageTag(\"fr-CH\"),\n+                Locale.US,\n+                Locale.JAPAN,\n+                Locale.GERMANY,\n+                Locale.ITALY,\n+                Locale.of(\"it\", \"IT\", \"EURO\"),\n+                Locale.forLanguageTag(\"de-AT\"),\n+                Locale.forLanguageTag(\"fr-CH\"),\n@@ -68,5 +95,5 @@\n-            null,\n-            Currency.getInstance(\"USD\"),\n-            Currency.getInstance(\"JPY\"),\n-            Currency.getInstance(\"DEM\"),\n-            Currency.getInstance(\"EUR\"),\n+                null,\n+                Currency.getInstance(\"USD\"),\n+                Currency.getInstance(\"JPY\"),\n+                Currency.getInstance(\"DEM\"),\n+                Currency.getInstance(\"EUR\"),\n@@ -74,8 +101,8 @@\n-        String[][] expecteds = {\n-            {\"$1,234.56\", \"$1,234.56\", \"JPY1,235\", \"DEM1,234.56\", \"EUR1,234.56\"},\n-            {\"\\uFFE51,235\", \"USD1,234.56\", \"\\uFFE51,235\", \"DEM1,234.56\", \"EUR1,234.56\"},\n-            {\"1.234,56 \\u20AC\", \"1.234,56 USD\", \"1.235 JPY\", \"1.234,56 DM\", \"1.234,56 \\u20AC\"},\n-            {\"\\u20AC 1.234,56\", \"USD 1.234,56\", \"JPY 1.235\", \"DEM 1.234,56\", \"\\u20AC 1.234,56\"},\n-            {\"\\u20AC 1.234,56\", \"USD 1.234,56\", \"JPY 1.235\", \"DEM 1.234,56\", \"\\u20AC 1.234,56\"},\n-            {\"\\u20AC 1.234,56\", \"USD 1.234,56\", \"JPY 1.235\", \"DEM 1.234,56\", \"\\u20AC 1.234,56\"},\n-            {\"SFr. 1'234.56\", \"USD 1'234.56\", \"JPY 1'235\", \"DEM 1'234.56\", \"EUR 1'234.56\"},\n+        String[][] expectedCOMPATData = {\n+                {\"$1,234.56\", \"$1,234.56\", \"JPY1,235\", \"DEM1,234.56\", \"EUR1,234.56\"},\n+                {\"\\uFFE51,235\", \"USD1,234.56\", \"\\uFFE51,235\", \"DEM1,234.56\", \"EUR1,234.56\"},\n+                {\"1.234,56 \\u20AC\", \"1.234,56 USD\", \"1.235 JPY\", \"1.234,56 DM\", \"1.234,56 \\u20AC\"},\n+                {\"\\u20AC 1.234,56\", \"USD 1.234,56\", \"JPY 1.235\", \"DEM 1.234,56\", \"\\u20AC 1.234,56\"},\n+                {\"\\u20AC 1.234,56\", \"USD 1.234,56\", \"JPY 1.235\", \"DEM 1.234,56\", \"\\u20AC 1.234,56\"},\n+                {\"\\u20AC 1.234,56\", \"USD 1.234,56\", \"JPY 1.235\", \"DEM 1.234,56\", \"\\u20AC 1.234,56\"},\n+                {\"SFr. 1'234.56\", \"USD 1'234.56\", \"JPY 1'235\", \"DEM 1'234.56\", \"EUR 1'234.56\"},\n@@ -83,8 +110,8 @@\n-        String[][] expecteds_cldr = {\n-            {\"$1,234.56\", \"$1,234.56\", \"\\u00a51,235\", \"DEM1,234.56\", \"\\u20ac1,234.56\"},\n-            {\"\\uFFE51,235\", \"$1,234.56\", \"\\uFFE51,235\", \"DEM1,234.56\", \"\\u20ac1,234.56\"},\n-            {\"1.234,56\\u00a0\\u20ac\", \"1.234,56\\u00a0$\", \"1.235\\u00a0\\u00a5\", \"1.234,56\\u00a0DM\", \"1.234,56\\u00a0\\u20ac\"},\n-            {\"1.234,56\\u00a0\\u20ac\", \"1.234,56\\u00a0USD\", \"1.235\\u00a0JPY\", \"1.234,56\\u00a0DEM\", \"1.234,56\\u00a0\\u20ac\"},\n-            {\"1.234,56\\u00a0\\u20ac\", \"1.234,56\\u00a0USD\", \"1.235\\u00a0JPY\", \"1.234,56\\u00a0DEM\", \"1.234,56\\u00a0\\u20ac\"},\n-            {\"\\u20ac\\u00a01.234,56\", \"$\\u00a01.234,56\", \"\\u00a5\\u00a01.235\", \"DM\\u00a01.234,56\", \"\\u20ac\\u00a01.234,56\"},\n-            {\"1\\u202f234.56\\u00a0CHF\", \"1\\u202f234.56\\u00a0$US\", \"1\\u202f235\\u00a0JPY\", \"1\\u202f234.56\\u00a0DEM\", \"1\\u202f234.56\\u00a0\\u20ac\"},\n+        String[][] expectedCLDRData = {\n+                {\"$1,234.56\", \"$1,234.56\", \"\\u00a51,235\", \"DEM1,234.56\", \"\\u20ac1,234.56\"},\n+                {\"\\uFFE51,235\", \"$1,234.56\", \"\\uFFE51,235\", \"DEM1,234.56\", \"\\u20ac1,234.56\"},\n+                {\"1.234,56\\u00a0\\u20ac\", \"1.234,56\\u00a0$\", \"1.235\\u00a0\\u00a5\", \"1.234,56\\u00a0DM\", \"1.234,56\\u00a0\\u20ac\"},\n+                {\"1.234,56\\u00a0\\u20ac\", \"1.234,56\\u00a0USD\", \"1.235\\u00a0JPY\", \"1.234,56\\u00a0DEM\", \"1.234,56\\u00a0\\u20ac\"},\n+                {\"1.234,56\\u00a0\\u20ac\", \"1.234,56\\u00a0USD\", \"1.235\\u00a0JPY\", \"1.234,56\\u00a0DEM\", \"1.234,56\\u00a0\\u20ac\"},\n+                {\"\\u20ac\\u00a01.234,56\", \"$\\u00a01.234,56\", \"\\u00a5\\u00a01.235\", \"DM\\u00a01.234,56\", \"\\u20ac\\u00a01.234,56\"},\n+                {\"1\\u202f234.56\\u00a0CHF\", \"1\\u202f234.56\\u00a0$US\", \"1\\u202f235\\u00a0JPY\", \"1\\u202f234.56\\u00a0DEM\", \"1\\u202f234.56\\u00a0\\u20ac\"},\n@@ -92,1 +119,0 @@\n-\n@@ -98,15 +124,2 @@\n-                String expected = isCompat ? expecteds[i][j] : expecteds_cldr[i][j];\n-                if (currency != null) {\n-                    format.setCurrency(currency);\n-                    int digits = currency.getDefaultFractionDigits();\n-                    format.setMinimumFractionDigits(digits);\n-                    format.setMaximumFractionDigits(digits);\n-                }\n-                String result = format.format(1234.56);\n-                if (!result.equals(expected)) {\n-                    failed = true;\n-                    System.out.println(\"FAIL: Locale \" + locale\n-                        + (currency == null ? \", default currency\" : (\", currency: \" + currency))\n-                        + \", expected: \" + expected\n-                        + \", actual: \" + result);\n-                }\n+                String expected = isCompat ? expectedCOMPATData[i][j] : expectedCLDRData[i][j];\n+                data.add(Arguments.of(expected, currency, format, locale));\n@@ -115,4 +128,1 @@\n-\n-        if (failed) {\n-            throw new RuntimeException();\n-        }\n+        return data.stream();\n@@ -121,1 +131,5 @@\n-    static void testSymbols() throws Exception {\n+    \/\/ Compares the expected currency symbol of a locale to the value returned by\n+    \/\/ DecimalFormatSymbols.getCurrencySymbol().\n+    @ParameterizedTest\n+    @MethodSource(\"currencySymbolsDataProvider\")\n+    public void currencySymbolsTest(String expected, Locale locale) throws ParseException {\n@@ -123,2 +137,1 @@\n-            \/\/ For COMPAT only.\n-            return;\n+            return; \/\/ For COMPAT only.\n@@ -126,0 +139,13 @@\n+        if (expected == null) {\n+            System.out.println(\"Warning: No expected currency symbol defined for locale \" + locale);\n+        } else {\n+            \/\/ Reserved for when a currency will change its symbol at a given time in the future\n+            if (expected.contains(\";\")) {\n+                expected = getFutureSymbol(expected);\n+            }\n+            DecimalFormatSymbols symbols = DecimalFormatSymbols.getInstance(locale);\n+            String result = symbols.getCurrencySymbol();\n+            assertEquals(expected, result, \"Wrong currency symbol for locale \" +\n+                        locale + \", expected: \" + expected + \", got: \" + result);\n+        }\n+    }\n@@ -127,1 +153,6 @@\n-        FileInputStream stream = new FileInputStream(new File(System.getProperty(\"test.src\", \".\"), \"CurrencySymbols.properties\"));\n+    \/\/ Grabs the custom CurrencySymbols.properties and loads the file into a Properties\n+    \/\/ instance. Building the data set, which consists of the currency symbol for the locale.\n+    private static Stream<Arguments> currencySymbolsDataProvider() throws IOException {\n+        ArrayList<Arguments> data = new ArrayList<Arguments>();\n+        FileInputStream stream = new FileInputStream(new File(\n+                System.getProperty(\"test.src\", \".\"), \"CurrencySymbols.properties\"));\n@@ -131,2 +162,0 @@\n-        SimpleDateFormat format = null;\n-\n@@ -134,4 +163,1 @@\n-        for (int i = 0; i < locales.length; i++) {\n-            Locale locale = locales[i];\n-            DecimalFormatSymbols symbols = DecimalFormatSymbols.getInstance(locale);\n-            String result = symbols.getCurrencySymbol();\n+        for (Locale locale : locales) {\n@@ -139,0 +165,4 @@\n+            data.add(Arguments.of(expected, locale));\n+        }\n+        return data.stream();\n+    }\n@@ -140,25 +170,11 @@\n-            if (expected == null) {\n-                System.out.println(\"Warning: No expected currency symbol defined for locale \" + locale);\n-            } else {\n-                    if (expected.contains(\";\")) {\n-                        StringTokenizer tokens = new StringTokenizer(expected, \";\");\n-                        int tokensCount = tokens.countTokens();\n-\n-                        if (tokensCount == 3) {\n-                            expected = tokens.nextToken();\n-                            if (format == null) {\n-                                format = new SimpleDateFormat(\"yyyy-MM-dd-HH-mm-ss\", Locale.US);\n-                                format.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n-                                format.setLenient(false);\n-                            }\n-\n-                            if (format.parse(tokens.nextToken()).getTime() < System.currentTimeMillis()) {\n-                                expected = tokens.nextToken();\n-                            }\n-                        }\n-                    }\n-\n-                    if (!expected.equals(result)) {\n-                        throw new RuntimeException(\"Wrong currency symbol for locale \" +\n-                            locale + \", expected: \" + expected + \", got: \" + result);\n-                    }\n+    \/\/ Utility to grab the future symbol if in the right format and date cut-over allows\n+    private static String getFutureSymbol(String expected) throws ParseException {\n+        StringTokenizer tokens = new StringTokenizer(expected, \";\");\n+        int tokensCount = tokens.countTokens();\n+        if (tokensCount == 3) {\n+            expected = tokens.nextToken();\n+            SimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd-HH-mm-ss\", Locale.US);\n+            format.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n+            format.setLenient(false);\n+            if (format.parse(tokens.nextToken()).getTime() < System.currentTimeMillis()) {\n+                expected = tokens.nextToken();\n@@ -167,0 +183,1 @@\n+        return expected;\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/CurrencyFormat.java","additions":109,"deletions":92,"binary":false,"changes":201,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,1 @@\n-\/**\n+\/*\n@@ -27,1 +27,0 @@\n- * @summary Currency decimal marker incorrect for Peru.\n@@ -29,1 +28,2 @@\n- * @run main\/othervm -Djava.locale.providers=JRE TestPeruCurrencyFormat\n+ * @summary Currency decimal marker incorrect for Peru (COMPAT).\n+ * @run junit\/othervm -Djava.locale.providers=COMPAT TestPeruCurrencyFormat\n@@ -35,0 +35,4 @@\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n@@ -37,1 +41,3 @@\n-    public static void main(String[] args) {\n+    \/\/ Confirm correct decimal marker for Peru locale on COMPAT\n+    @Test\n+    public void peruDecimalMarketCOMPAT() {\n@@ -42,4 +48,2 @@\n-\n-        if (!s.equals(expected)) {\n-            throw new RuntimeException(\"Currency format for Peru failed, expected \" + expected + \", got \" + s);\n-        }\n+        assertEquals(expected, s,\n+                \"Currency format for Peru failed, expected \" + expected + \", got \" + s);\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/TestPeruCurrencyFormat.java","additions":13,"deletions":9,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8303440\n+ * @bug 8303440 8317979\n@@ -46,2 +46,2 @@\n-        \/\/ Assuming CLDR's SHORT name for \"America\/Los_Angeles\"\n-        \/\/ produces \"UTC\\u212208:00\"\n+        \/\/ Assuming CLDR's SHORT name for \"America\/Juneau\"\n+        \/\/ produces \"UTC\\u212209:00\"\n@@ -63,1 +63,1 @@\n-        var zdt = ZonedDateTime.of(2023, 3, 3, 0, 0, 0, 0, ZoneId.of(\"America\/Los_Angeles\"));\n+        var zdt = ZonedDateTime.of(2023, 3, 3, 0, 0, 0, 0, ZoneId.of(\"America\/Juneau\"));\n@@ -65,1 +65,1 @@\n-        assertEquals(formatted, \"UTC\\u221208:00\");\n+        assertEquals(formatted, \"UTC\\u221209:00\");\n","filename":"test\/jdk\/java\/time\/test\/java\/time\/format\/TestUTCParse.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import java.util.stream.IntStream;\n@@ -51,5 +52,6 @@\n-        BitSet bs = new BitSet();\n-        IntPredicate ibs = ImmutableBitSetPredicate.of(bs);\n-        assertThrows(IndexOutOfBoundsException.class, () -> {\n-            ibs.test(-1);\n-        });\n+        IntStream.of(0, 127, 128, 129, 143, 4711).forEach(k -> {\n+                    BitSet bs = new BitSet(k);\n+                    IntPredicate ibs = ImmutableBitSetPredicate.of(bs);\n+                    assertFalse(ibs.test(-1));\n+                    assertFalse(ibs.test(Integer.MIN_VALUE));\n+                });\n@@ -60,1 +62,5 @@\n-        BitSet bs = createReference(147);\n+        IntStream.of(0, 16, 127, 128, 129, 143, 4711).forEach(k -> basic(k));\n+    }\n+\n+    void basic(int length) {\n+        BitSet bs = createReference(length);\n@@ -67,4 +73,8 @@\n-        for (int i = Long.BYTES - 1; i < Long.BYTES + 2; i++) {\n-            BitSet bs = createReference(i);\n-            for (int j = bs.length() - 1; j > Long.BYTES - 1; j++) {\n-                bs.clear(j);\n+        IntStream.of(0, 16, 127, 128, 129, 143, 4711).forEach(k -> {\n+            for (int i = Long.BYTES - 1; i < Long.BYTES + 2; i++) {\n+                BitSet bs = createReference(k + i);\n+                for (int j = bs.length() - 1; j > Long.BYTES - 1; j--) {\n+                    bs.clear(j);\n+                }\n+                IntPredicate ibs = ImmutableBitSetPredicate.of(bs);\n+                test(bs, ibs);\n@@ -72,3 +82,1 @@\n-            IntPredicate ibs = ImmutableBitSetPredicate.of(bs);\n-            test(bs, ibs);\n-        }\n+        });\n@@ -84,1 +92,1 @@\n-        BitSet result = new BitSet();\n+        BitSet result = new BitSet(length);\n","filename":"test\/jdk\/java\/util\/BitSet\/ImmutableBitSet.java","additions":22,"deletions":14,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- *      8258795 8267038 8287180 8302512 8304761 8306031 8308021 8313702\n+ *      8258795 8267038 8287180 8302512 8304761 8306031 8308021 8313702 8318322\n@@ -29,1 +29,1 @@\n- *          (LSR Revision: 2023-08-02) with Locale and Locale.LanguageRange\n+ *          (LSR Revision: 2023-10-16) with Locale and Locale.LanguageRange\n","filename":"test\/jdk\/java\/util\/Locale\/LanguageSubtagRegistryTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- *      8234347 8236548\n+ *      8234347 8236548 8317979\n@@ -51,1 +51,1 @@\n-            \"GMT-08:00\",\n+            \"PST\",\n@@ -53,1 +53,1 @@\n-            \"GMT-07:00\",\n+            \"PDT\",\n@@ -60,1 +60,1 @@\n-            \"GMT-08:00\",\n+            \"PST\",\n@@ -62,1 +62,1 @@\n-            \"GMT-07:00\",\n+            \"PDT\",\n@@ -69,1 +69,1 @@\n-            \"GMT-08:00\",\n+            \"PST\",\n@@ -71,1 +71,1 @@\n-            \"GMT-07:00\",\n+            \"PDT\",\n","filename":"test\/jdk\/java\/util\/TimeZone\/CLDRDisplayNamesTest.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -9,3 +9,0 @@\n-\n-# To compile and run tests that use the foreign memory access API\n-enablePreview=true\n","filename":"test\/jdk\/java\/util\/stream\/test\/TEST.properties","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- * @ignore This test has brittle dependencies on an external working python.\n+ * @ignore 8303920 This test has brittle dependencies on an external working python.\n","filename":"test\/jdk\/java\/util\/zip\/DataDescriptorSignatureMissing.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,162 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 8317678\n+ * @modules java.base\/java.util.zip:open\n+ * @summary Fix up hashCode() for ZipFile.Source.Key\n+ * @run junit\/othervm ZipSourceCache\n+ *\/\n+\n+import java.io.*;\n+import java.lang.reflect.*;\n+import java.nio.file.*;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.*;\n+import java.util.zip.*;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.AfterAll;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class ZipSourceCache {\n+\n+    private static final String ZIPFILE_NAME =\n+            System.currentTimeMillis() + \"-bug8317678.zip\";\n+    private static final String ZIPENTRY_NAME = \"random.txt\";\n+    private static final String INVALID_LOC_EXCEPTION =\n+            \"ZipFile invalid LOC header (bad signature)\";\n+    private static final boolean DEBUG = false;\n+\n+    private static File relativeFile = new File(ZIPFILE_NAME);\n+    private static File absoluteFile = new File(ZIPFILE_NAME).getAbsoluteFile();\n+    private static boolean hasfileKeySupport;\n+\n+    @BeforeAll\n+    public static void setup() throws Exception {\n+        createZipFile(\"test1\");\n+        var attrs = Files.readAttributes(relativeFile.toPath(), BasicFileAttributes.class);\n+        hasfileKeySupport = (attrs.fileKey() != null);\n+    }\n+\n+    @AfterAll\n+    public static void cleanup() throws IOException {\n+        Files.deleteIfExists(Path.of(ZIPFILE_NAME));\n+    }\n+\n+    \/*\n+     * Monitor the internal \"files\" HashMap to ensure that we only\n+     * create one <Key, Source> mapping per unique zip file.\n+     *\n+     * This test also ensures that a new <Key, Source> mapping is created\n+     * if an update to an existing zip file is detected.\n+     *\/\n+    @Test\n+    public void testKeySourceMapping() throws Exception {\n+        ZipFile absoluteZipFile;\n+        HashMap internalMap;\n+        int numSources;\n+        try (ZipFile zipFile = new ZipFile(relativeFile)) {\n+            Class source = Class.forName(\"java.util.zip.ZipFile$Source\");\n+            Field filesMap = source.getDeclaredField(\"files\");\n+            filesMap.setAccessible(true);\n+            internalMap = (HashMap) filesMap.get(zipFile);\n+            numSources = internalMap.size();\n+            \/\/ opening of same zip file shouldn't cause new Source\n+            \/\/ to be constructed on filesystems which support fileKey()\n+            absoluteZipFile = new ZipFile(absoluteFile);\n+            if (hasfileKeySupport) {\n+                assertEquals(numSources, internalMap.size());\n+            } else {\n+                assertEquals(++numSources, internalMap.size());\n+            }\n+\n+            \/\/ update the zip file, should expect a new Source Object\n+            \/\/ ignore this part of test if file can't be updated (can't overwrite)\n+            if (createZipFile(\"differentContent\")) {\n+                ZipFile z = new ZipFile(relativeFile);\n+                \/\/ update of file should trigger new <Key, Source> mapping\n+                assertEquals(++numSources, internalMap.size());\n+                \/\/ new Source created, CEN structure should map fine\n+                readZipFileContents(z);\n+                \/\/ the old Source in use for old file, should no longer map correctly\n+                IOException ioe = assertThrows(IOException.class, () -> readZipFileContents(absoluteZipFile));\n+                assertEquals(INVALID_LOC_EXCEPTION, ioe.getMessage());\n+                z.close();\n+                assertEquals(--numSources, internalMap.size());\n+            }\n+        }\n+        \/\/ with fileKey() support, the close() call shouldn't remove the\n+        \/\/ Source entry just yet since we still have one reference to the file\n+        if (hasfileKeySupport) {\n+            assertEquals(numSources, internalMap.size());\n+        } else {\n+            assertEquals(--numSources, internalMap.size());\n+        }\n+        if (absoluteZipFile != null) {\n+            absoluteZipFile.close();\n+        }\n+        \/\/ now, the Source entry key should be removed\n+        assertEquals(--numSources, internalMap.size());\n+    }\n+\n+    private static void readZipFileContents(ZipFile zf) throws IOException {\n+        var e = zf.entries();\n+        while (e.hasMoreElements()) {\n+            InputStream is = zf.getInputStream(e.nextElement());\n+            String s = new String(is.readAllBytes());\n+            if (DEBUG) System.err.println(s);\n+        }\n+    }\n+\n+    private static boolean createZipFile(String content) {\n+        CRC32 crc32 = new CRC32();\n+        long t = System.currentTimeMillis();\n+        \/\/ let's have at least 2 entries created to ensure\n+        \/\/ that a bad zip structure is detected if file is updated\n+        int numEntries = new Random().nextInt(10) + 2;\n+        File zipFile = new File(ZIPFILE_NAME);\n+        try (FileOutputStream fos = new FileOutputStream(zipFile);\n+             BufferedOutputStream bos = new BufferedOutputStream(fos);\n+             ZipOutputStream zos = new ZipOutputStream(bos)) {\n+            for (int i = 0; i < numEntries; i++) {\n+                ZipEntry e = new ZipEntry(ZIPENTRY_NAME + i);\n+                e.setMethod(ZipEntry.STORED);\n+                byte[] toWrite = content.repeat(i+1).getBytes();\n+                e.setTime(t);\n+                e.setSize(toWrite.length);\n+                crc32.reset();\n+                crc32.update(toWrite);\n+                e.setCrc(crc32.getValue());\n+                zos.putNextEntry(e);\n+                zos.write(toWrite);\n+            }\n+        } catch (IOException e) {\n+            \/\/ some systems mightn't allow file to be updated while open\n+            System.err.println(\"error updating file. \" + e);\n+            return false;\n+        }\n+        return true;\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/ZipSourceCache.java","additions":162,"deletions":0,"binary":false,"changes":162,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -137,1 +137,1 @@\n-            = System.getProperty(\"test.security.protocol\", \"TLS\");\n+            = System.getProperty(\"test.security.protocol\");\n@@ -741,1 +741,3 @@\n-                    case \"DTLSv1.1\":\n+                    case \"DTLS\":\n+                    case \"DTLSv1.2\":\n+                    case \"TLS\":\n@@ -748,0 +750,3 @@\n+                    default:\n+                        throw new Error(\"Test error: Unsupported test \" +\n+                                \"security protocol: \" + TESTED_SECURITY_PROTOCOL);\n","filename":"test\/jdk\/javax\/net\/ssl\/TLSCommon\/SSLEngineTestCase.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @library \/test\/lib\/\n@@ -36,0 +37,2 @@\n+import jdk.test.lib.Asserts;\n+\n@@ -39,2 +42,2 @@\n-import java.net.ServerSocket;\n-import java.net.Socket;\n+import java.lang.ref.Reference;\n+import java.rmi.ConnectIOException;\n@@ -43,1 +46,0 @@\n-import java.rmi.server.RMIClientSocketFactory;\n@@ -53,1 +55,1 @@\n-        public String sayHello() throws RemoteException;\n+        String sayHello() throws RemoteException;\n@@ -56,9 +58,1 @@\n-    public class HelloImpl extends UnicastRemoteObject implements Hello {\n-\n-        public HelloImpl(int port,\n-                         RMIClientSocketFactory csf,\n-                         RMIServerSocketFactory ssf)\n-            throws RemoteException {\n-            super(port, csf, ssf);\n-        }\n-\n+    public class HelloImpl implements Hello {\n@@ -68,61 +62,0 @@\n-\n-        public Remote runServer() throws IOException {\n-            System.out.println(\"Inside HelloImpl::runServer\");\n-            \/\/ Get a remote stub for this RMI object\n-            \/\/\n-            Remote stub = toStub(this);\n-            System.out.println(\"Stub = \" + stub);\n-            return stub;\n-        }\n-    }\n-\n-    public class HelloClient {\n-\n-        public void runClient(Remote stub) throws IOException {\n-            System.out.println(\"Inside HelloClient::runClient\");\n-            \/\/ \"obj\" is the identifier that we'll use to refer\n-            \/\/ to the remote object that implements the \"Hello\"\n-            \/\/ interface\n-            Hello obj = (Hello) stub;\n-            String message = obj.sayHello();\n-            System.out.println(message);\n-        }\n-    }\n-\n-    public static class ClientFactory extends SslRMIClientSocketFactory {\n-\n-        public ClientFactory() {\n-            super();\n-        }\n-\n-        public Socket createSocket(String host, int port) throws IOException {\n-            System.out.println(\"ClientFactory::Calling createSocket(\" +\n-                               host + \",\" + port + \")\");\n-            return super.createSocket(host, port);\n-        }\n-    }\n-\n-    public static class ServerFactory extends SslRMIServerSocketFactory {\n-\n-        public ServerFactory() {\n-            super();\n-        }\n-\n-        public ServerFactory(String[] ciphers,\n-                             String[] protocols,\n-                             boolean need) {\n-            super(ciphers, protocols, need);\n-        }\n-\n-        public ServerFactory(SSLContext context,\n-                             String[] ciphers,\n-                             String[] protocols,\n-                             boolean need) {\n-            super(context, ciphers, protocols, need);\n-        }\n-\n-        public ServerSocket createServerSocket(int port) throws IOException {\n-            System.out.println(\"ServerFactory::Calling createServerSocket(\" +\n-                               port + \")\");\n-            return super.createServerSocket(port);\n-        }\n@@ -131,3 +64,4 @@\n-    public void testRmiCommunication(RMIServerSocketFactory serverFactory, boolean expectException) {\n-\n-        HelloImpl server = null;\n+    public void testRmiCommunication(RMIServerSocketFactory serverSocketFactory) throws Exception {\n+        HelloImpl server = new HelloImpl();\n+        Hello stub = (Hello)UnicastRemoteObject.exportObject(server,\n+                0, new SslRMIClientSocketFactory(), serverSocketFactory);\n@@ -135,17 +69,4 @@\n-            server = new HelloImpl(0,\n-                                    new ClientFactory(),\n-                                    serverFactory);\n-            Remote stub = server.runServer();\n-            HelloClient client = new HelloClient();\n-            client.runClient(stub);\n-            if (expectException) {\n-                throw new RuntimeException(\"Test completed without throwing an expected exception.\");\n-            }\n-\n-        } catch (IOException exc) {\n-            if (!expectException) {\n-                throw new RuntimeException(\"An error occurred during test execution\", exc);\n-            } else {\n-                System.out.println(\"Caught expected exception: \" + exc);\n-            }\n-\n+            String msg = stub.sayHello();\n+            Asserts.assertEquals(\"Hello World!\", msg);\n+        } finally {\n+            Reference.reachabilityFence(server);\n@@ -155,3 +76,2 @@\n-    private static void testServerFactory(String[] cipherSuites, String[] protocol, String expectedMessage) throws Exception {\n-        try {\n-            new ServerFactory(SSLContext.getDefault(),\n+    private static void testSslServerSocketFactory(String[] cipherSuites, String[] protocol) throws Exception {\n+        new SslRMIServerSocketFactory(SSLContext.getDefault(),\n@@ -159,9 +79,0 @@\n-            throw new RuntimeException(\n-                    \"The expected exception for \"+ expectedMessage + \" was not thrown.\");\n-        } catch (IllegalArgumentException exc) {\n-            \/\/ expecting an exception with a specific message\n-            \/\/ anything else is an error\n-            if (!exc.getMessage().toLowerCase().contains(expectedMessage)) {\n-                throw exc;\n-            }\n-        }\n@@ -175,1 +86,2 @@\n-            case 1 -> testRmiCommunication(new ServerFactory(), false);\n+            case 1 ->\n+                testRmiCommunication(new SslRMIServerSocketFactory());\n@@ -178,1 +90,2 @@\n-            case 2 -> testRmiCommunication(new ServerFactory(null, null, false), false);\n+            case 2 ->\n+                testRmiCommunication(new SslRMIServerSocketFactory(null, null, false));\n@@ -181,1 +94,2 @@\n-            case 3 -> testRmiCommunication(new ServerFactory(null, null, null, true), false);\n+            case 3 ->\n+                testRmiCommunication(new SslRMIServerSocketFactory(null, null, null, true));\n@@ -184,2 +98,7 @@\n-            case 4 ->\n-                testServerFactory(new String[]{\"dummy_ciphersuite\"}, null, \"unsupported ciphersuite\");\n+            case 4 -> {\n+                Exception exc = Asserts.assertThrows(IllegalArgumentException.class,\n+                        () -> testSslServerSocketFactory(new String[]{\"dummy_ciphersuite\"}, null));\n+                if (!exc.getMessage().toLowerCase().contains(\"unsupported ciphersuite\")) {\n+                    throw exc;\n+                }\n+            }\n@@ -188,2 +107,7 @@\n-            case 5 ->\n-                testServerFactory(null, new String[]{\"dummy_protocol\"}, \"unsupported protocol\");\n+            case 5 -> {\n+                Exception thrown = Asserts.assertThrows(IllegalArgumentException.class,\n+                        () -> testSslServerSocketFactory(null, new String[]{\"dummy_protocol\"}));\n+                if (!thrown.getMessage().toLowerCase().contains(\"unsupported protocol\")) {\n+                    throw thrown;\n+                }\n+            }\n@@ -195,1 +119,2 @@\n-                testRmiCommunication(new ServerFactory(), true);\n+                Asserts.assertThrows(ConnectIOException.class,\n+                        () -> testRmiCommunication(new SslRMIServerSocketFactory()));\n@@ -202,1 +127,2 @@\n-                testRmiCommunication(new ServerFactory(), true);\n+                Asserts.assertThrows(ConnectIOException.class,\n+                        () -> testRmiCommunication(new SslRMIServerSocketFactory()));\n","filename":"test\/jdk\/javax\/rmi\/ssl\/SSLSocketParametersTest.java","additions":41,"deletions":115,"binary":false,"changes":156,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,0 +77,1 @@\n+                <html><body>\n@@ -78,3 +79,4 @@\n-                1. Open an elevated Command Prompt.\n-                2. Paste the following commands:\n-                cd \/d C:\\\\\n+                <ol>\n+                <li>Open an elevated <i>Command Prompt<\/i>.\n+                <li>Paste the following commands:\n+                <pre><code>cd \/d C:\\\\\n@@ -84,1 +86,1 @@\n-                mklink \/d link target\n+                mklink \/d link target<\/code><\/pre>\n@@ -86,24 +88,34 @@\n-                3. Navigate to C:\\\\FileChooserTest in the JFileChooser.\n-                4. Use \"Enable Multi-Selection\" checkbox to enable\/disable\n-                   MultiSelection Mode\n-                5. Single-selection:\n-                   Click \"link\" directory, the absolute path of the symbolic\n-                   link should be displayed. If it's null, click FAIL.\n-                   Click \"target\" directory, its absolute path should be\n-                   displayed.\n-\n-                   Enable multiple selection by clicking the checkbox.\n-                   Multi-selection:\n-                   Click \"link\", press Ctrl and then click \"target\".\n-                   Both should be selected and their absolute paths should be\n-                   displayed.\n-\n-                   If \"link\" can't be selected or if its absolute path is null,\n-                   click FAIL.\n-\n-                   If \"link\" can be selected in both single- and multi-selection modes,\n-                   click PASS.\n-                6. When done with testing, paste the following commands to\n-                   remove the 'FileChooserTest' directory:\n-                cd \\\\\n-                rmdir \/s \/q C:\\\\FileChooserTest\n+                <li>Navigate to <code>C:\\\\FileChooserTest<\/code> in\n+                    the <code>JFileChooser<\/code>.\n+                <li>Perform testing in single- and multi-selection modes:\n+                    <ul style=\"margin-bottom: 0px\">\n+                    <li><strong>Single-selection:<\/strong>\n+                        <ol>\n+                        <li>Ensure <b>Enable multi-selection<\/b> is cleared\n+                            (the default state).\n+                        <li>Click <code>link<\/code> directory,\n+                            the absolute path of the symbolic\n+                            link should be displayed.<br>\n+                            If it's <code>null<\/code>, click <b>Fail<\/b>.\n+                        <li>Click <code>target<\/code> directory,\n+                            its absolute path should be displayed.\n+                        <\/ol>\n+                    <li><strong>Multi-selection:<\/strong>\n+                        <ol>\n+                        <li>Select <b>Enable multi-selection<\/b>.\n+                        <li>Click <code>link<\/code>,\n+                        <li>Press <kbd>Ctrl<\/kbd> and\n+                            then click <code>target<\/code>.\n+                        <li>Both should be selected and\n+                            their absolute paths should be displayed.\n+                        <li>If <code>link<\/code> can't be selected or\n+                            if its absolute path is <code>null<\/code>,\n+                            click <b>Fail<\/b>.\n+                        <\/ol>\n+                    <\/ul>\n+                    <p>If <code>link<\/code> can be selected in both\n+                    single- and multi-selection modes, click <b>Pass<\/b>.<\/p>\n+                <li>When done with testing, paste the following commands to\n+                    remove the <code>FileChooserTest<\/code> directory:\n+                <pre><code>cd \\\\\n+                rmdir \/s \/q C:\\\\FileChooserTest<\/code><\/pre>\n@@ -112,0 +124,1 @@\n+                <\/ol>\n@@ -118,1 +131,1 @@\n-        passFailJFrame = new PassFailJFrame(\"Test Instructions\", INSTRUCTIONS, 5L, 35, 40);\n+        passFailJFrame = new PassFailJFrame(\"Test Instructions\", INSTRUCTIONS, 5L, 35, 50);\n","filename":"test\/jdk\/javax\/swing\/JFileChooser\/FileChooserSymLinkTest.java","additions":43,"deletions":30,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -73,0 +73,2 @@\n+\n+            \"border-width: medium\",\n@@ -89,0 +91,8 @@\n+    private static final String[][] EQUALS_WITH_SPACE = {\n+            {\"font-size: 42px\", \"font-size: 42 px\"},\n+            {\"font-size: 100%\", \"font-size: 100 %\"},\n+\n+            {\"width: 42px\", \"width: 42 px\"},\n+            {\"width: 100%\", \"width: 100 %\"},\n+    };\n+\n@@ -100,0 +110,4 @@\n+        Arrays.stream(EQUALS_WITH_SPACE)\n+              .map(CSSAttributeEqualityBug::positiveTest)\n+              .filter(Objects::nonNull)\n+              .forEach(failures::add);\n@@ -103,1 +117,1 @@\n-            throw new RuntimeException(failures.size()\n+            throw new RuntimeException(\"The test failed: \" + failures.size()\n@@ -118,0 +132,9 @@\n+    private static String positiveTest(String[] cssDeclaration) {\n+        StyleSheet ss = new StyleSheet();\n+\n+        AttributeSet a = ss.getDeclaration(cssDeclaration[0]);\n+        AttributeSet b = ss.getDeclaration(cssDeclaration[1]);\n+\n+        return assertEquals(a, b);\n+    }\n+\n@@ -148,1 +171,0 @@\n-\n","filename":"test\/jdk\/javax\/swing\/text\/html\/CSS\/CSSAttributeEqualityBug.java","additions":24,"deletions":2,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * This class provide the template for JDK version specific GregorianCalendarAndDurationSerData.java src file.\n+ *\/\n+public class GregorianCalAndDurSerDataTemplate {\n+    public static final String ORACLE_COPY_RIGHT = \"\"\"\n+            \/*\n+             * Copyright (c) %s, Oracle and\/or its affiliates. All rights reserved.\n+             * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+             *\n+             * This code is free software; you can redistribute it and\/or modify it\n+             * under the terms of the GNU General Public License version 2 only, as\n+             * published by the Free Software Foundation.\n+             *\n+             * This code is distributed in the hope that it will be useful, but WITHOUT\n+             * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+             * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+             * version 2 for more details (a copy is included in the LICENSE file that\n+             * accompanied this code).\n+             *\n+             * You should have received a copy of the GNU General Public License version\n+             * 2 along with this work; if not, write to the Free Software Foundation,\n+             * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+             *\n+             * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+             * or visit www.oracle.com if you need additional information or have any\n+             * questions.\n+             *\/\n+             \\s\n+             \/**\n+              * Mechanically generated %s specific serialization bytes for XMLGregorianCalendar and Duration data type.\n+              * Do not edit this file.\n+              *\/\"\"\";\n+    public static final String GREGO_CAL_DUR_SER_CLASS = \"\"\"\n+            public class %sGregorianCalendarAndDurationSerData extends GregorianCalendarAndDurationSerData {\n+                %s\n+                %s\n+                @Override\n+                public byte[] getGregorianCalendarByteArray() {\n+                    return gregorianCalendarBytes;\n+                }\n+                \\s\n+                @Override\n+                public byte[] getDurationBytes() {\n+                    return durationBytes;\n+                }\n+            };\"\"\";\n+}\n","filename":"test\/jdk\/javax\/xml\/jaxp\/datatype\/8033980\/GregorianCalAndDurSerDataTemplate.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -0,0 +1,141 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary utility to generate Gregorian Calendar and Duration serialized data java classes.\n+ * @run junit\/manual GregorianCalAndDurSerDataUtil\n+ *\/\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectOutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.LocalDate;\n+import java.util.Formatter;\n+\n+import javax.xml.datatype.DatatypeConfigurationException;\n+import javax.xml.datatype.DatatypeFactory;\n+import javax.xml.datatype.Duration;\n+import javax.xml.datatype.XMLGregorianCalendar;\n+\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInstance;\n+\n+\/**\n+ * Utility to generate the java source file for Gregorian Calendar and Duration serialized data\n+ * for specific version of JDK to be added in SerializationTest. Execute this test with desired version\n+ * of JDK to generate the java source file.\n+ *\/\n+@TestInstance(TestInstance.Lifecycle.PER_CLASS)\n+public class GregorianCalAndDurSerDataUtil {\n+    static String JDK = \"JDK\" + System.getProperty(\"java.version\");\n+    static String testsrc = System.getProperty(\"test.src\");\n+    final static String EXPECTED_CAL = \"0001-01-01T00:00:00.0000000-05:00\";\n+    final static String EXPECTED_DURATION = \"P1Y1M1DT1H1M1S\";\n+    String srcFilePrefix = JDK.toUpperCase().replace(\"-\", \"_\");\n+\n+\n+    \/**\n+     * Create the serialized Bytes array and serialized bytes base64 string for GregorianCalender and Duration\n+     * with jdk under test and generate the java source file.\n+     * @throws DatatypeConfigurationException Unexpected.\n+     * @throws IOException Unexpected.\n+     *\/\n+    @BeforeAll\n+    public void setup() throws DatatypeConfigurationException, IOException {\n+        DatatypeFactory dtf = DatatypeFactory.newInstance();\n+        XMLGregorianCalendar xmlGregorianCalendar = dtf.newXMLGregorianCalendar(EXPECTED_CAL);\n+        Duration duration = dtf.newDuration(EXPECTED_DURATION);\n+        String copyRightStr = GregorianCalAndDurSerDataTemplate.ORACLE_COPY_RIGHT;\n+        String classStr = GregorianCalAndDurSerDataTemplate.GREGO_CAL_DUR_SER_CLASS;\n+        try(ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos);\n+            ByteArrayOutputStream baos2 = new ByteArrayOutputStream(); ObjectOutputStream oos2 = new ObjectOutputStream(baos2)) {\n+            \/\/Serialize the given xmlGregorianCalendar\n+            oos.writeObject(xmlGregorianCalendar);\n+            \/\/Serialize the given xml Duration\n+            oos2.writeObject(duration);\n+            Files.deleteIfExists(Path.of(testsrc,srcFilePrefix+\"GregorianCalendarAndDurationSerData.java\"));\n+\n+            copyRightStr = String.format(copyRightStr, LocalDate.now().getYear(), JDK);\n+            classStr = String.format(classStr, srcFilePrefix, generatePseudoCodeForGregCalSerBytes(baos),\n+                    generatePseudoCodeForDurationSerBytes(baos2));\n+            String srcStr = copyRightStr + \"\\n\" + classStr;\n+            Files.writeString(Path.of(testsrc,srcFilePrefix+\"GregorianCalendarAndDurationSerData.java\"), srcStr);\n+        }\n+    }\n+\n+    \/**\n+     * Verify that Java source file is created.\n+     *\/\n+    @Test\n+    void testFileCreated() {\n+        assertTrue(Files.exists(Path.of(testsrc,srcFilePrefix+\"GregorianCalendarAndDurationSerData.java\")));\n+    }\n+\n+    \/**\n+     * Generates the Java Pseudo code for serialized Gregorian Calendar byte array.\n+     * @param baos Serialized GregorianCalendar ByteArrayOutputStream.\n+     * @return pseudocode String for serialized Gregorian Calendar byte array.\n+     *\/\n+    public static String generatePseudoCodeForGregCalSerBytes(ByteArrayOutputStream baos) {\n+        byte [] bytes = baos.toByteArray();\n+        StringBuilder sb = new StringBuilder(bytes.length * 5);\n+        sb.append(\"private final byte[] gregorianCalendarBytes = {\");\n+        return generatePseudoCode(sb, bytes);\n+    }\n+\n+    \/**\n+     * Generates the Java Pseudo code for serialized Duration byte array.\n+     * @param baos Serialized Duration ByteArrayOutputStream.\n+     * @return pseudocode String for serialized Duration byte array.\n+     *\/\n+    public static String generatePseudoCodeForDurationSerBytes(ByteArrayOutputStream baos) {\n+        byte [] bytesdur = baos.toByteArray();\n+        StringBuilder sb = new StringBuilder(bytesdur.length * 5);\n+        sb.append(\"private final byte[] durationBytes = {\");\n+        return generatePseudoCode(sb, bytesdur);\n+    }\n+\n+    private static String generatePseudoCode(StringBuilder sb, byte [] bytes) {\n+        final int linelen = 8;\n+\/\/        HexFormat hex = HexFormat.of().withPrefix(\" (byte) 0x\").withSuffix(\",\");\n+\/\/        for (int i = 0; i < bytes.length; i += linelen) {\n+\/\/            sb.append(\"\\n\");\n+\/\/            sb.append(hex.formatHex(bytes, i, Math.min(i + linelen, bytes.length)));\n+\/\/        }\n+\/\/        sb.append(\"};\");\n+        Formatter fmt = new Formatter(sb);\n+        for (int i = 0; i <bytes.length; i++) {\n+            if (i % linelen == 0) {\n+                fmt.format(\"%n           \");\n+            }\n+            fmt.format(\" (byte) 0x%x,\", bytes[i] & 0xff);\n+        }\n+        fmt.format(\"%n    };%n\");\n+        return sb.toString();\n+    }\n+}\n","filename":"test\/jdk\/javax\/xml\/jaxp\/datatype\/8033980\/GregorianCalAndDurSerDataUtil.java","additions":141,"deletions":0,"binary":false,"changes":141,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * Abstract class for serialized bytes of XMLGregorianCalendar and Duration data type for different JDK versions.\n+ *\/\n+public abstract class GregorianCalendarAndDurationSerData {\n+    \/\/Returns byte array of serialized GregorianCalendar.\n+    public abstract byte[] getGregorianCalendarByteArray();\n+\n+    \/\/Returns byte array of serialized Duration.\n+    public abstract byte[] getDurationBytes();\n+}\n","filename":"test\/jdk\/javax\/xml\/jaxp\/datatype\/8033980\/GregorianCalendarAndDurationSerData.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * Mechanically generated JDK 6 specific serialization bytes for XMLGregorianCalendar and Duration data type.\n+ * Do not edit this file.\n+ *\/\n+public class JDK6GregorianCalendarAndDurationSerData extends GregorianCalendarAndDurationSerData {\n+    private final byte[] gregorianCalendarBytes = {\n+            (byte) 0xac, (byte) 0xed, (byte) 0x0, (byte) 0x5, (byte) 0x73, (byte) 0x72, (byte) 0x0, (byte) 0x49,\n+            (byte) 0x63, (byte) 0x6f, (byte) 0x6d, (byte) 0x2e, (byte) 0x73, (byte) 0x75, (byte) 0x6e, (byte) 0x2e,\n+            (byte) 0x6f, (byte) 0x72, (byte) 0x67, (byte) 0x2e, (byte) 0x61, (byte) 0x70, (byte) 0x61, (byte) 0x63,\n+            (byte) 0x68, (byte) 0x65, (byte) 0x2e, (byte) 0x78, (byte) 0x65, (byte) 0x72, (byte) 0x63, (byte) 0x65,\n+            (byte) 0x73, (byte) 0x2e, (byte) 0x69, (byte) 0x6e, (byte) 0x74, (byte) 0x65, (byte) 0x72, (byte) 0x6e,\n+            (byte) 0x61, (byte) 0x6c, (byte) 0x2e, (byte) 0x6a, (byte) 0x61, (byte) 0x78, (byte) 0x70, (byte) 0x2e,\n+            (byte) 0x64, (byte) 0x61, (byte) 0x74, (byte) 0x61, (byte) 0x74, (byte) 0x79, (byte) 0x70, (byte) 0x65,\n+            (byte) 0x2e, (byte) 0x58, (byte) 0x4d, (byte) 0x4c, (byte) 0x47, (byte) 0x72, (byte) 0x65, (byte) 0x67,\n+            (byte) 0x6f, (byte) 0x72, (byte) 0x69, (byte) 0x61, (byte) 0x6e, (byte) 0x43, (byte) 0x61, (byte) 0x6c,\n+            (byte) 0x65, (byte) 0x6e, (byte) 0x64, (byte) 0x61, (byte) 0x72, (byte) 0x49, (byte) 0x6d, (byte) 0x70,\n+            (byte) 0x6c, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x1, (byte) 0x2, (byte) 0x0, (byte) 0x9, (byte) 0x49, (byte) 0x0, (byte) 0x3, (byte) 0x64,\n+            (byte) 0x61, (byte) 0x79, (byte) 0x49, (byte) 0x0, (byte) 0x4, (byte) 0x68, (byte) 0x6f, (byte) 0x75,\n+            (byte) 0x72, (byte) 0x49, (byte) 0x0, (byte) 0x6, (byte) 0x6d, (byte) 0x69, (byte) 0x6e, (byte) 0x75,\n+            (byte) 0x74, (byte) 0x65, (byte) 0x49, (byte) 0x0, (byte) 0x5, (byte) 0x6d, (byte) 0x6f, (byte) 0x6e,\n+            (byte) 0x74, (byte) 0x68, (byte) 0x49, (byte) 0x0, (byte) 0x6, (byte) 0x73, (byte) 0x65, (byte) 0x63,\n+            (byte) 0x6f, (byte) 0x6e, (byte) 0x64, (byte) 0x49, (byte) 0x0, (byte) 0x8, (byte) 0x74, (byte) 0x69,\n+            (byte) 0x6d, (byte) 0x65, (byte) 0x7a, (byte) 0x6f, (byte) 0x6e, (byte) 0x65, (byte) 0x49, (byte) 0x0,\n+            (byte) 0x4, (byte) 0x79, (byte) 0x65, (byte) 0x61, (byte) 0x72, (byte) 0x4c, (byte) 0x0, (byte) 0x3,\n+            (byte) 0x65, (byte) 0x6f, (byte) 0x6e, (byte) 0x74, (byte) 0x0, (byte) 0x16, (byte) 0x4c, (byte) 0x6a,\n+            (byte) 0x61, (byte) 0x76, (byte) 0x61, (byte) 0x2f, (byte) 0x6d, (byte) 0x61, (byte) 0x74, (byte) 0x68,\n+            (byte) 0x2f, (byte) 0x42, (byte) 0x69, (byte) 0x67, (byte) 0x49, (byte) 0x6e, (byte) 0x74, (byte) 0x65,\n+            (byte) 0x67, (byte) 0x65, (byte) 0x72, (byte) 0x3b, (byte) 0x4c, (byte) 0x0, (byte) 0x10, (byte) 0x66,\n+            (byte) 0x72, (byte) 0x61, (byte) 0x63, (byte) 0x74, (byte) 0x69, (byte) 0x6f, (byte) 0x6e, (byte) 0x61,\n+            (byte) 0x6c, (byte) 0x53, (byte) 0x65, (byte) 0x63, (byte) 0x6f, (byte) 0x6e, (byte) 0x64, (byte) 0x74,\n+            (byte) 0x0, (byte) 0x16, (byte) 0x4c, (byte) 0x6a, (byte) 0x61, (byte) 0x76, (byte) 0x61, (byte) 0x2f,\n+            (byte) 0x6d, (byte) 0x61, (byte) 0x74, (byte) 0x68, (byte) 0x2f, (byte) 0x42, (byte) 0x69, (byte) 0x67,\n+            (byte) 0x44, (byte) 0x65, (byte) 0x63, (byte) 0x69, (byte) 0x6d, (byte) 0x61, (byte) 0x6c, (byte) 0x3b,\n+            (byte) 0x78, (byte) 0x70, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x1, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x1, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0xff, (byte) 0xff,\n+            (byte) 0xfe, (byte) 0xd4, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x1, (byte) 0x70, (byte) 0x73,\n+            (byte) 0x72, (byte) 0x0, (byte) 0x14, (byte) 0x6a, (byte) 0x61, (byte) 0x76, (byte) 0x61, (byte) 0x2e,\n+            (byte) 0x6d, (byte) 0x61, (byte) 0x74, (byte) 0x68, (byte) 0x2e, (byte) 0x42, (byte) 0x69, (byte) 0x67,\n+            (byte) 0x44, (byte) 0x65, (byte) 0x63, (byte) 0x69, (byte) 0x6d, (byte) 0x61, (byte) 0x6c, (byte) 0x54,\n+            (byte) 0xc7, (byte) 0x15, (byte) 0x57, (byte) 0xf9, (byte) 0x81, (byte) 0x28, (byte) 0x4f, (byte) 0x3,\n+            (byte) 0x0, (byte) 0x2, (byte) 0x49, (byte) 0x0, (byte) 0x5, (byte) 0x73, (byte) 0x63, (byte) 0x61,\n+            (byte) 0x6c, (byte) 0x65, (byte) 0x4c, (byte) 0x0, (byte) 0x6, (byte) 0x69, (byte) 0x6e, (byte) 0x74,\n+            (byte) 0x56, (byte) 0x61, (byte) 0x6c, (byte) 0x71, (byte) 0x0, (byte) 0x7e, (byte) 0x0, (byte) 0x1,\n+            (byte) 0x78, (byte) 0x72, (byte) 0x0, (byte) 0x10, (byte) 0x6a, (byte) 0x61, (byte) 0x76, (byte) 0x61,\n+            (byte) 0x2e, (byte) 0x6c, (byte) 0x61, (byte) 0x6e, (byte) 0x67, (byte) 0x2e, (byte) 0x4e, (byte) 0x75,\n+            (byte) 0x6d, (byte) 0x62, (byte) 0x65, (byte) 0x72, (byte) 0x86, (byte) 0xac, (byte) 0x95, (byte) 0x1d,\n+            (byte) 0xb, (byte) 0x94, (byte) 0xe0, (byte) 0x8b, (byte) 0x2, (byte) 0x0, (byte) 0x0, (byte) 0x78,\n+            (byte) 0x70, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x7, (byte) 0x73, (byte) 0x72, (byte) 0x0,\n+            (byte) 0x14, (byte) 0x6a, (byte) 0x61, (byte) 0x76, (byte) 0x61, (byte) 0x2e, (byte) 0x6d, (byte) 0x61,\n+            (byte) 0x74, (byte) 0x68, (byte) 0x2e, (byte) 0x42, (byte) 0x69, (byte) 0x67, (byte) 0x49, (byte) 0x6e,\n+            (byte) 0x74, (byte) 0x65, (byte) 0x67, (byte) 0x65, (byte) 0x72, (byte) 0x8c, (byte) 0xfc, (byte) 0x9f,\n+            (byte) 0x1f, (byte) 0xa9, (byte) 0x3b, (byte) 0xfb, (byte) 0x1d, (byte) 0x3, (byte) 0x0, (byte) 0x6,\n+            (byte) 0x49, (byte) 0x0, (byte) 0x8, (byte) 0x62, (byte) 0x69, (byte) 0x74, (byte) 0x43, (byte) 0x6f,\n+            (byte) 0x75, (byte) 0x6e, (byte) 0x74, (byte) 0x49, (byte) 0x0, (byte) 0x9, (byte) 0x62, (byte) 0x69,\n+            (byte) 0x74, (byte) 0x4c, (byte) 0x65, (byte) 0x6e, (byte) 0x67, (byte) 0x74, (byte) 0x68, (byte) 0x49,\n+            (byte) 0x0, (byte) 0x13, (byte) 0x66, (byte) 0x69, (byte) 0x72, (byte) 0x73, (byte) 0x74, (byte) 0x4e,\n+            (byte) 0x6f, (byte) 0x6e, (byte) 0x7a, (byte) 0x65, (byte) 0x72, (byte) 0x6f, (byte) 0x42, (byte) 0x79,\n+            (byte) 0x74, (byte) 0x65, (byte) 0x4e, (byte) 0x75, (byte) 0x6d, (byte) 0x49, (byte) 0x0, (byte) 0xc,\n+            (byte) 0x6c, (byte) 0x6f, (byte) 0x77, (byte) 0x65, (byte) 0x73, (byte) 0x74, (byte) 0x53, (byte) 0x65,\n+            (byte) 0x74, (byte) 0x42, (byte) 0x69, (byte) 0x74, (byte) 0x49, (byte) 0x0, (byte) 0x6, (byte) 0x73,\n+            (byte) 0x69, (byte) 0x67, (byte) 0x6e, (byte) 0x75, (byte) 0x6d, (byte) 0x5b, (byte) 0x0, (byte) 0x9,\n+            (byte) 0x6d, (byte) 0x61, (byte) 0x67, (byte) 0x6e, (byte) 0x69, (byte) 0x74, (byte) 0x75, (byte) 0x64,\n+            (byte) 0x65, (byte) 0x74, (byte) 0x0, (byte) 0x2, (byte) 0x5b, (byte) 0x42, (byte) 0x78, (byte) 0x71,\n+            (byte) 0x0, (byte) 0x7e, (byte) 0x0, (byte) 0x5, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff,\n+            (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xfe,\n+            (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xfe, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x75, (byte) 0x72, (byte) 0x0, (byte) 0x2, (byte) 0x5b, (byte) 0x42, (byte) 0xac, (byte) 0xf3,\n+            (byte) 0x17, (byte) 0xf8, (byte) 0x6, (byte) 0x8, (byte) 0x54, (byte) 0xe0, (byte) 0x2, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x78, (byte) 0x70, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x78,\n+            (byte) 0x78,\n+    };\n+    private final byte[] durationBytes = {\n+            (byte) 0xac, (byte) 0xed, (byte) 0x0, (byte) 0x5, (byte) 0x73, (byte) 0x72, (byte) 0x0, (byte) 0x4c,\n+            (byte) 0x63, (byte) 0x6f, (byte) 0x6d, (byte) 0x2e, (byte) 0x73, (byte) 0x75, (byte) 0x6e, (byte) 0x2e,\n+            (byte) 0x6f, (byte) 0x72, (byte) 0x67, (byte) 0x2e, (byte) 0x61, (byte) 0x70, (byte) 0x61, (byte) 0x63,\n+            (byte) 0x68, (byte) 0x65, (byte) 0x2e, (byte) 0x78, (byte) 0x65, (byte) 0x72, (byte) 0x63, (byte) 0x65,\n+            (byte) 0x73, (byte) 0x2e, (byte) 0x69, (byte) 0x6e, (byte) 0x74, (byte) 0x65, (byte) 0x72, (byte) 0x6e,\n+            (byte) 0x61, (byte) 0x6c, (byte) 0x2e, (byte) 0x6a, (byte) 0x61, (byte) 0x78, (byte) 0x70, (byte) 0x2e,\n+            (byte) 0x64, (byte) 0x61, (byte) 0x74, (byte) 0x61, (byte) 0x74, (byte) 0x79, (byte) 0x70, (byte) 0x65,\n+            (byte) 0x2e, (byte) 0x44, (byte) 0x75, (byte) 0x72, (byte) 0x61, (byte) 0x74, (byte) 0x69, (byte) 0x6f,\n+            (byte) 0x6e, (byte) 0x49, (byte) 0x6d, (byte) 0x70, (byte) 0x6c, (byte) 0x24, (byte) 0x44, (byte) 0x75,\n+            (byte) 0x72, (byte) 0x61, (byte) 0x74, (byte) 0x69, (byte) 0x6f, (byte) 0x6e, (byte) 0x53, (byte) 0x74,\n+            (byte) 0x72, (byte) 0x65, (byte) 0x61, (byte) 0x6d, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x1, (byte) 0x2, (byte) 0x0, (byte) 0x1, (byte) 0x4c,\n+            (byte) 0x0, (byte) 0x7, (byte) 0x6c, (byte) 0x65, (byte) 0x78, (byte) 0x69, (byte) 0x63, (byte) 0x61,\n+            (byte) 0x6c, (byte) 0x74, (byte) 0x0, (byte) 0x12, (byte) 0x4c, (byte) 0x6a, (byte) 0x61, (byte) 0x76,\n+            (byte) 0x61, (byte) 0x2f, (byte) 0x6c, (byte) 0x61, (byte) 0x6e, (byte) 0x67, (byte) 0x2f, (byte) 0x53,\n+            (byte) 0x74, (byte) 0x72, (byte) 0x69, (byte) 0x6e, (byte) 0x67, (byte) 0x3b, (byte) 0x78, (byte) 0x70,\n+            (byte) 0x74, (byte) 0x0, (byte) 0xe, (byte) 0x50, (byte) 0x31, (byte) 0x59, (byte) 0x31, (byte) 0x4d,\n+            (byte) 0x31, (byte) 0x44, (byte) 0x54, (byte) 0x31, (byte) 0x48, (byte) 0x31, (byte) 0x4d, (byte) 0x31,\n+            (byte) 0x53,\n+    };\n+\n+\n+    @Override\n+    public byte[] getGregorianCalendarByteArray() {\n+        return gregorianCalendarBytes;\n+    }\n+\n+    @Override\n+    public byte[] getDurationBytes() {\n+        return durationBytes;\n+    }\n+}\n","filename":"test\/jdk\/javax\/xml\/jaxp\/datatype\/8033980\/JDK6GregorianCalendarAndDurationSerData.java","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"},{"filename":"test\/jdk\/javax\/xml\/jaxp\/datatype\/8033980\/JDK6_Duration.ser","binary":true,"status":"deleted"},{"filename":"test\/jdk\/javax\/xml\/jaxp\/datatype\/8033980\/JDK6_XMLGregorianCalendar.ser","binary":true,"status":"deleted"},{"patch":"@@ -0,0 +1,127 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * Mechanically generated JDK 7 specific serialization bytes for XMLGregorianCalendar and Duration data type.\n+ * Do not edit this file.\n+ *\/\n+public class JDK7GregorianCalendarAndDurationSerData extends GregorianCalendarAndDurationSerData {\n+    private final byte[] gregorianCalendarBytes = {\n+            (byte) 0xac, (byte) 0xed, (byte) 0x0, (byte) 0x5, (byte) 0x73, (byte) 0x72, (byte) 0x0, (byte) 0x49,\n+            (byte) 0x63, (byte) 0x6f, (byte) 0x6d, (byte) 0x2e, (byte) 0x73, (byte) 0x75, (byte) 0x6e, (byte) 0x2e,\n+            (byte) 0x6f, (byte) 0x72, (byte) 0x67, (byte) 0x2e, (byte) 0x61, (byte) 0x70, (byte) 0x61, (byte) 0x63,\n+            (byte) 0x68, (byte) 0x65, (byte) 0x2e, (byte) 0x78, (byte) 0x65, (byte) 0x72, (byte) 0x63, (byte) 0x65,\n+            (byte) 0x73, (byte) 0x2e, (byte) 0x69, (byte) 0x6e, (byte) 0x74, (byte) 0x65, (byte) 0x72, (byte) 0x6e,\n+            (byte) 0x61, (byte) 0x6c, (byte) 0x2e, (byte) 0x6a, (byte) 0x61, (byte) 0x78, (byte) 0x70, (byte) 0x2e,\n+            (byte) 0x64, (byte) 0x61, (byte) 0x74, (byte) 0x61, (byte) 0x74, (byte) 0x79, (byte) 0x70, (byte) 0x65,\n+            (byte) 0x2e, (byte) 0x58, (byte) 0x4d, (byte) 0x4c, (byte) 0x47, (byte) 0x72, (byte) 0x65, (byte) 0x67,\n+            (byte) 0x6f, (byte) 0x72, (byte) 0x69, (byte) 0x61, (byte) 0x6e, (byte) 0x43, (byte) 0x61, (byte) 0x6c,\n+            (byte) 0x65, (byte) 0x6e, (byte) 0x64, (byte) 0x61, (byte) 0x72, (byte) 0x49, (byte) 0x6d, (byte) 0x70,\n+            (byte) 0x6c, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x1, (byte) 0x2, (byte) 0x0, (byte) 0x9, (byte) 0x49, (byte) 0x0, (byte) 0x3, (byte) 0x64,\n+            (byte) 0x61, (byte) 0x79, (byte) 0x49, (byte) 0x0, (byte) 0x4, (byte) 0x68, (byte) 0x6f, (byte) 0x75,\n+            (byte) 0x72, (byte) 0x49, (byte) 0x0, (byte) 0x6, (byte) 0x6d, (byte) 0x69, (byte) 0x6e, (byte) 0x75,\n+            (byte) 0x74, (byte) 0x65, (byte) 0x49, (byte) 0x0, (byte) 0x5, (byte) 0x6d, (byte) 0x6f, (byte) 0x6e,\n+            (byte) 0x74, (byte) 0x68, (byte) 0x49, (byte) 0x0, (byte) 0x6, (byte) 0x73, (byte) 0x65, (byte) 0x63,\n+            (byte) 0x6f, (byte) 0x6e, (byte) 0x64, (byte) 0x49, (byte) 0x0, (byte) 0x8, (byte) 0x74, (byte) 0x69,\n+            (byte) 0x6d, (byte) 0x65, (byte) 0x7a, (byte) 0x6f, (byte) 0x6e, (byte) 0x65, (byte) 0x49, (byte) 0x0,\n+            (byte) 0x4, (byte) 0x79, (byte) 0x65, (byte) 0x61, (byte) 0x72, (byte) 0x4c, (byte) 0x0, (byte) 0x3,\n+            (byte) 0x65, (byte) 0x6f, (byte) 0x6e, (byte) 0x74, (byte) 0x0, (byte) 0x16, (byte) 0x4c, (byte) 0x6a,\n+            (byte) 0x61, (byte) 0x76, (byte) 0x61, (byte) 0x2f, (byte) 0x6d, (byte) 0x61, (byte) 0x74, (byte) 0x68,\n+            (byte) 0x2f, (byte) 0x42, (byte) 0x69, (byte) 0x67, (byte) 0x49, (byte) 0x6e, (byte) 0x74, (byte) 0x65,\n+            (byte) 0x67, (byte) 0x65, (byte) 0x72, (byte) 0x3b, (byte) 0x4c, (byte) 0x0, (byte) 0x10, (byte) 0x66,\n+            (byte) 0x72, (byte) 0x61, (byte) 0x63, (byte) 0x74, (byte) 0x69, (byte) 0x6f, (byte) 0x6e, (byte) 0x61,\n+            (byte) 0x6c, (byte) 0x53, (byte) 0x65, (byte) 0x63, (byte) 0x6f, (byte) 0x6e, (byte) 0x64, (byte) 0x74,\n+            (byte) 0x0, (byte) 0x16, (byte) 0x4c, (byte) 0x6a, (byte) 0x61, (byte) 0x76, (byte) 0x61, (byte) 0x2f,\n+            (byte) 0x6d, (byte) 0x61, (byte) 0x74, (byte) 0x68, (byte) 0x2f, (byte) 0x42, (byte) 0x69, (byte) 0x67,\n+            (byte) 0x44, (byte) 0x65, (byte) 0x63, (byte) 0x69, (byte) 0x6d, (byte) 0x61, (byte) 0x6c, (byte) 0x3b,\n+            (byte) 0x78, (byte) 0x70, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x1, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x1, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0xff, (byte) 0xff,\n+            (byte) 0xfe, (byte) 0xd4, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x1, (byte) 0x70, (byte) 0x73,\n+            (byte) 0x72, (byte) 0x0, (byte) 0x14, (byte) 0x6a, (byte) 0x61, (byte) 0x76, (byte) 0x61, (byte) 0x2e,\n+            (byte) 0x6d, (byte) 0x61, (byte) 0x74, (byte) 0x68, (byte) 0x2e, (byte) 0x42, (byte) 0x69, (byte) 0x67,\n+            (byte) 0x44, (byte) 0x65, (byte) 0x63, (byte) 0x69, (byte) 0x6d, (byte) 0x61, (byte) 0x6c, (byte) 0x54,\n+            (byte) 0xc7, (byte) 0x15, (byte) 0x57, (byte) 0xf9, (byte) 0x81, (byte) 0x28, (byte) 0x4f, (byte) 0x3,\n+            (byte) 0x0, (byte) 0x2, (byte) 0x49, (byte) 0x0, (byte) 0x5, (byte) 0x73, (byte) 0x63, (byte) 0x61,\n+            (byte) 0x6c, (byte) 0x65, (byte) 0x4c, (byte) 0x0, (byte) 0x6, (byte) 0x69, (byte) 0x6e, (byte) 0x74,\n+            (byte) 0x56, (byte) 0x61, (byte) 0x6c, (byte) 0x71, (byte) 0x0, (byte) 0x7e, (byte) 0x0, (byte) 0x1,\n+            (byte) 0x78, (byte) 0x72, (byte) 0x0, (byte) 0x10, (byte) 0x6a, (byte) 0x61, (byte) 0x76, (byte) 0x61,\n+            (byte) 0x2e, (byte) 0x6c, (byte) 0x61, (byte) 0x6e, (byte) 0x67, (byte) 0x2e, (byte) 0x4e, (byte) 0x75,\n+            (byte) 0x6d, (byte) 0x62, (byte) 0x65, (byte) 0x72, (byte) 0x86, (byte) 0xac, (byte) 0x95, (byte) 0x1d,\n+            (byte) 0xb, (byte) 0x94, (byte) 0xe0, (byte) 0x8b, (byte) 0x2, (byte) 0x0, (byte) 0x0, (byte) 0x78,\n+            (byte) 0x70, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x7, (byte) 0x73, (byte) 0x72, (byte) 0x0,\n+            (byte) 0x14, (byte) 0x6a, (byte) 0x61, (byte) 0x76, (byte) 0x61, (byte) 0x2e, (byte) 0x6d, (byte) 0x61,\n+            (byte) 0x74, (byte) 0x68, (byte) 0x2e, (byte) 0x42, (byte) 0x69, (byte) 0x67, (byte) 0x49, (byte) 0x6e,\n+            (byte) 0x74, (byte) 0x65, (byte) 0x67, (byte) 0x65, (byte) 0x72, (byte) 0x8c, (byte) 0xfc, (byte) 0x9f,\n+            (byte) 0x1f, (byte) 0xa9, (byte) 0x3b, (byte) 0xfb, (byte) 0x1d, (byte) 0x3, (byte) 0x0, (byte) 0x6,\n+            (byte) 0x49, (byte) 0x0, (byte) 0x8, (byte) 0x62, (byte) 0x69, (byte) 0x74, (byte) 0x43, (byte) 0x6f,\n+            (byte) 0x75, (byte) 0x6e, (byte) 0x74, (byte) 0x49, (byte) 0x0, (byte) 0x9, (byte) 0x62, (byte) 0x69,\n+            (byte) 0x74, (byte) 0x4c, (byte) 0x65, (byte) 0x6e, (byte) 0x67, (byte) 0x74, (byte) 0x68, (byte) 0x49,\n+            (byte) 0x0, (byte) 0x13, (byte) 0x66, (byte) 0x69, (byte) 0x72, (byte) 0x73, (byte) 0x74, (byte) 0x4e,\n+            (byte) 0x6f, (byte) 0x6e, (byte) 0x7a, (byte) 0x65, (byte) 0x72, (byte) 0x6f, (byte) 0x42, (byte) 0x79,\n+            (byte) 0x74, (byte) 0x65, (byte) 0x4e, (byte) 0x75, (byte) 0x6d, (byte) 0x49, (byte) 0x0, (byte) 0xc,\n+            (byte) 0x6c, (byte) 0x6f, (byte) 0x77, (byte) 0x65, (byte) 0x73, (byte) 0x74, (byte) 0x53, (byte) 0x65,\n+            (byte) 0x74, (byte) 0x42, (byte) 0x69, (byte) 0x74, (byte) 0x49, (byte) 0x0, (byte) 0x6, (byte) 0x73,\n+            (byte) 0x69, (byte) 0x67, (byte) 0x6e, (byte) 0x75, (byte) 0x6d, (byte) 0x5b, (byte) 0x0, (byte) 0x9,\n+            (byte) 0x6d, (byte) 0x61, (byte) 0x67, (byte) 0x6e, (byte) 0x69, (byte) 0x74, (byte) 0x75, (byte) 0x64,\n+            (byte) 0x65, (byte) 0x74, (byte) 0x0, (byte) 0x2, (byte) 0x5b, (byte) 0x42, (byte) 0x78, (byte) 0x71,\n+            (byte) 0x0, (byte) 0x7e, (byte) 0x0, (byte) 0x5, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff,\n+            (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xfe,\n+            (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xfe, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x75, (byte) 0x72, (byte) 0x0, (byte) 0x2, (byte) 0x5b, (byte) 0x42, (byte) 0xac, (byte) 0xf3,\n+            (byte) 0x17, (byte) 0xf8, (byte) 0x6, (byte) 0x8, (byte) 0x54, (byte) 0xe0, (byte) 0x2, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x78, (byte) 0x70, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x78,\n+            (byte) 0x78,\n+    };\n+    private final byte[] durationBytes = {\n+            (byte) 0xac, (byte) 0xed, (byte) 0x0, (byte) 0x5, (byte) 0x73, (byte) 0x72, (byte) 0x0, (byte) 0x4c,\n+            (byte) 0x63, (byte) 0x6f, (byte) 0x6d, (byte) 0x2e, (byte) 0x73, (byte) 0x75, (byte) 0x6e, (byte) 0x2e,\n+            (byte) 0x6f, (byte) 0x72, (byte) 0x67, (byte) 0x2e, (byte) 0x61, (byte) 0x70, (byte) 0x61, (byte) 0x63,\n+            (byte) 0x68, (byte) 0x65, (byte) 0x2e, (byte) 0x78, (byte) 0x65, (byte) 0x72, (byte) 0x63, (byte) 0x65,\n+            (byte) 0x73, (byte) 0x2e, (byte) 0x69, (byte) 0x6e, (byte) 0x74, (byte) 0x65, (byte) 0x72, (byte) 0x6e,\n+            (byte) 0x61, (byte) 0x6c, (byte) 0x2e, (byte) 0x6a, (byte) 0x61, (byte) 0x78, (byte) 0x70, (byte) 0x2e,\n+            (byte) 0x64, (byte) 0x61, (byte) 0x74, (byte) 0x61, (byte) 0x74, (byte) 0x79, (byte) 0x70, (byte) 0x65,\n+            (byte) 0x2e, (byte) 0x44, (byte) 0x75, (byte) 0x72, (byte) 0x61, (byte) 0x74, (byte) 0x69, (byte) 0x6f,\n+            (byte) 0x6e, (byte) 0x49, (byte) 0x6d, (byte) 0x70, (byte) 0x6c, (byte) 0x24, (byte) 0x44, (byte) 0x75,\n+            (byte) 0x72, (byte) 0x61, (byte) 0x74, (byte) 0x69, (byte) 0x6f, (byte) 0x6e, (byte) 0x53, (byte) 0x74,\n+            (byte) 0x72, (byte) 0x65, (byte) 0x61, (byte) 0x6d, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x1, (byte) 0x2, (byte) 0x0, (byte) 0x1, (byte) 0x4c,\n+            (byte) 0x0, (byte) 0x7, (byte) 0x6c, (byte) 0x65, (byte) 0x78, (byte) 0x69, (byte) 0x63, (byte) 0x61,\n+            (byte) 0x6c, (byte) 0x74, (byte) 0x0, (byte) 0x12, (byte) 0x4c, (byte) 0x6a, (byte) 0x61, (byte) 0x76,\n+            (byte) 0x61, (byte) 0x2f, (byte) 0x6c, (byte) 0x61, (byte) 0x6e, (byte) 0x67, (byte) 0x2f, (byte) 0x53,\n+            (byte) 0x74, (byte) 0x72, (byte) 0x69, (byte) 0x6e, (byte) 0x67, (byte) 0x3b, (byte) 0x78, (byte) 0x70,\n+            (byte) 0x74, (byte) 0x0, (byte) 0xe, (byte) 0x50, (byte) 0x31, (byte) 0x59, (byte) 0x31, (byte) 0x4d,\n+            (byte) 0x31, (byte) 0x44, (byte) 0x54, (byte) 0x31, (byte) 0x48, (byte) 0x31, (byte) 0x4d, (byte) 0x31,\n+            (byte) 0x53,\n+    };\n+    @Override\n+    public byte[] getGregorianCalendarByteArray() {\n+        return gregorianCalendarBytes;\n+    }\n+\n+    @Override\n+    public byte[] getDurationBytes() {\n+        return durationBytes;\n+    }\n+}\n","filename":"test\/jdk\/javax\/xml\/jaxp\/datatype\/8033980\/JDK7GregorianCalendarAndDurationSerData.java","additions":127,"deletions":0,"binary":false,"changes":127,"status":"added"},{"filename":"test\/jdk\/javax\/xml\/jaxp\/datatype\/8033980\/JDK7_Duration.ser","binary":true,"status":"deleted"},{"filename":"test\/jdk\/javax\/xml\/jaxp\/datatype\/8033980\/JDK7_XMLGregorianCalendar.ser","binary":true,"status":"deleted"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * Mechanically generated JDK 8 specific serialization bytes for XMLGregorianCalendar and Duration data type.\n+ * Do not edit this file.\n+ *\/\n+public class JDK8GregorianCalendarAndDurationSerData extends GregorianCalendarAndDurationSerData {\n+    private final byte[] gregorianCalendarBytes = {\n+            (byte) 0xac, (byte) 0xed, (byte) 0x0, (byte) 0x5, (byte) 0x73, (byte) 0x72, (byte) 0x0, (byte) 0x49,\n+            (byte) 0x63, (byte) 0x6f, (byte) 0x6d, (byte) 0x2e, (byte) 0x73, (byte) 0x75, (byte) 0x6e, (byte) 0x2e,\n+            (byte) 0x6f, (byte) 0x72, (byte) 0x67, (byte) 0x2e, (byte) 0x61, (byte) 0x70, (byte) 0x61, (byte) 0x63,\n+            (byte) 0x68, (byte) 0x65, (byte) 0x2e, (byte) 0x78, (byte) 0x65, (byte) 0x72, (byte) 0x63, (byte) 0x65,\n+            (byte) 0x73, (byte) 0x2e, (byte) 0x69, (byte) 0x6e, (byte) 0x74, (byte) 0x65, (byte) 0x72, (byte) 0x6e,\n+            (byte) 0x61, (byte) 0x6c, (byte) 0x2e, (byte) 0x6a, (byte) 0x61, (byte) 0x78, (byte) 0x70, (byte) 0x2e,\n+            (byte) 0x64, (byte) 0x61, (byte) 0x74, (byte) 0x61, (byte) 0x74, (byte) 0x79, (byte) 0x70, (byte) 0x65,\n+            (byte) 0x2e, (byte) 0x58, (byte) 0x4d, (byte) 0x4c, (byte) 0x47, (byte) 0x72, (byte) 0x65, (byte) 0x67,\n+            (byte) 0x6f, (byte) 0x72, (byte) 0x69, (byte) 0x61, (byte) 0x6e, (byte) 0x43, (byte) 0x61, (byte) 0x6c,\n+            (byte) 0x65, (byte) 0x6e, (byte) 0x64, (byte) 0x61, (byte) 0x72, (byte) 0x49, (byte) 0x6d, (byte) 0x70,\n+            (byte) 0x6c, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x1, (byte) 0x2, (byte) 0x0, (byte) 0x9, (byte) 0x49, (byte) 0x0, (byte) 0x3, (byte) 0x64,\n+            (byte) 0x61, (byte) 0x79, (byte) 0x49, (byte) 0x0, (byte) 0x4, (byte) 0x68, (byte) 0x6f, (byte) 0x75,\n+            (byte) 0x72, (byte) 0x49, (byte) 0x0, (byte) 0x6, (byte) 0x6d, (byte) 0x69, (byte) 0x6e, (byte) 0x75,\n+            (byte) 0x74, (byte) 0x65, (byte) 0x49, (byte) 0x0, (byte) 0x5, (byte) 0x6d, (byte) 0x6f, (byte) 0x6e,\n+            (byte) 0x74, (byte) 0x68, (byte) 0x49, (byte) 0x0, (byte) 0x6, (byte) 0x73, (byte) 0x65, (byte) 0x63,\n+            (byte) 0x6f, (byte) 0x6e, (byte) 0x64, (byte) 0x49, (byte) 0x0, (byte) 0x8, (byte) 0x74, (byte) 0x69,\n+            (byte) 0x6d, (byte) 0x65, (byte) 0x7a, (byte) 0x6f, (byte) 0x6e, (byte) 0x65, (byte) 0x49, (byte) 0x0,\n+            (byte) 0x4, (byte) 0x79, (byte) 0x65, (byte) 0x61, (byte) 0x72, (byte) 0x4c, (byte) 0x0, (byte) 0x3,\n+            (byte) 0x65, (byte) 0x6f, (byte) 0x6e, (byte) 0x74, (byte) 0x0, (byte) 0x16, (byte) 0x4c, (byte) 0x6a,\n+            (byte) 0x61, (byte) 0x76, (byte) 0x61, (byte) 0x2f, (byte) 0x6d, (byte) 0x61, (byte) 0x74, (byte) 0x68,\n+            (byte) 0x2f, (byte) 0x42, (byte) 0x69, (byte) 0x67, (byte) 0x49, (byte) 0x6e, (byte) 0x74, (byte) 0x65,\n+            (byte) 0x67, (byte) 0x65, (byte) 0x72, (byte) 0x3b, (byte) 0x4c, (byte) 0x0, (byte) 0x10, (byte) 0x66,\n+            (byte) 0x72, (byte) 0x61, (byte) 0x63, (byte) 0x74, (byte) 0x69, (byte) 0x6f, (byte) 0x6e, (byte) 0x61,\n+            (byte) 0x6c, (byte) 0x53, (byte) 0x65, (byte) 0x63, (byte) 0x6f, (byte) 0x6e, (byte) 0x64, (byte) 0x74,\n+            (byte) 0x0, (byte) 0x16, (byte) 0x4c, (byte) 0x6a, (byte) 0x61, (byte) 0x76, (byte) 0x61, (byte) 0x2f,\n+            (byte) 0x6d, (byte) 0x61, (byte) 0x74, (byte) 0x68, (byte) 0x2f, (byte) 0x42, (byte) 0x69, (byte) 0x67,\n+            (byte) 0x44, (byte) 0x65, (byte) 0x63, (byte) 0x69, (byte) 0x6d, (byte) 0x61, (byte) 0x6c, (byte) 0x3b,\n+            (byte) 0x78, (byte) 0x70, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x1, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x1, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0xff, (byte) 0xff,\n+            (byte) 0xfe, (byte) 0xd4, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x1, (byte) 0x70, (byte) 0x73,\n+            (byte) 0x72, (byte) 0x0, (byte) 0x14, (byte) 0x6a, (byte) 0x61, (byte) 0x76, (byte) 0x61, (byte) 0x2e,\n+            (byte) 0x6d, (byte) 0x61, (byte) 0x74, (byte) 0x68, (byte) 0x2e, (byte) 0x42, (byte) 0x69, (byte) 0x67,\n+            (byte) 0x44, (byte) 0x65, (byte) 0x63, (byte) 0x69, (byte) 0x6d, (byte) 0x61, (byte) 0x6c, (byte) 0x54,\n+            (byte) 0xc7, (byte) 0x15, (byte) 0x57, (byte) 0xf9, (byte) 0x81, (byte) 0x28, (byte) 0x4f, (byte) 0x3,\n+            (byte) 0x0, (byte) 0x2, (byte) 0x49, (byte) 0x0, (byte) 0x5, (byte) 0x73, (byte) 0x63, (byte) 0x61,\n+            (byte) 0x6c, (byte) 0x65, (byte) 0x4c, (byte) 0x0, (byte) 0x6, (byte) 0x69, (byte) 0x6e, (byte) 0x74,\n+            (byte) 0x56, (byte) 0x61, (byte) 0x6c, (byte) 0x71, (byte) 0x0, (byte) 0x7e, (byte) 0x0, (byte) 0x1,\n+            (byte) 0x78, (byte) 0x72, (byte) 0x0, (byte) 0x10, (byte) 0x6a, (byte) 0x61, (byte) 0x76, (byte) 0x61,\n+            (byte) 0x2e, (byte) 0x6c, (byte) 0x61, (byte) 0x6e, (byte) 0x67, (byte) 0x2e, (byte) 0x4e, (byte) 0x75,\n+            (byte) 0x6d, (byte) 0x62, (byte) 0x65, (byte) 0x72, (byte) 0x86, (byte) 0xac, (byte) 0x95, (byte) 0x1d,\n+            (byte) 0xb, (byte) 0x94, (byte) 0xe0, (byte) 0x8b, (byte) 0x2, (byte) 0x0, (byte) 0x0, (byte) 0x78,\n+            (byte) 0x70, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x7, (byte) 0x73, (byte) 0x72, (byte) 0x0,\n+            (byte) 0x14, (byte) 0x6a, (byte) 0x61, (byte) 0x76, (byte) 0x61, (byte) 0x2e, (byte) 0x6d, (byte) 0x61,\n+            (byte) 0x74, (byte) 0x68, (byte) 0x2e, (byte) 0x42, (byte) 0x69, (byte) 0x67, (byte) 0x49, (byte) 0x6e,\n+            (byte) 0x74, (byte) 0x65, (byte) 0x67, (byte) 0x65, (byte) 0x72, (byte) 0x8c, (byte) 0xfc, (byte) 0x9f,\n+            (byte) 0x1f, (byte) 0xa9, (byte) 0x3b, (byte) 0xfb, (byte) 0x1d, (byte) 0x3, (byte) 0x0, (byte) 0x6,\n+            (byte) 0x49, (byte) 0x0, (byte) 0x8, (byte) 0x62, (byte) 0x69, (byte) 0x74, (byte) 0x43, (byte) 0x6f,\n+            (byte) 0x75, (byte) 0x6e, (byte) 0x74, (byte) 0x49, (byte) 0x0, (byte) 0x9, (byte) 0x62, (byte) 0x69,\n+            (byte) 0x74, (byte) 0x4c, (byte) 0x65, (byte) 0x6e, (byte) 0x67, (byte) 0x74, (byte) 0x68, (byte) 0x49,\n+            (byte) 0x0, (byte) 0x13, (byte) 0x66, (byte) 0x69, (byte) 0x72, (byte) 0x73, (byte) 0x74, (byte) 0x4e,\n+            (byte) 0x6f, (byte) 0x6e, (byte) 0x7a, (byte) 0x65, (byte) 0x72, (byte) 0x6f, (byte) 0x42, (byte) 0x79,\n+            (byte) 0x74, (byte) 0x65, (byte) 0x4e, (byte) 0x75, (byte) 0x6d, (byte) 0x49, (byte) 0x0, (byte) 0xc,\n+            (byte) 0x6c, (byte) 0x6f, (byte) 0x77, (byte) 0x65, (byte) 0x73, (byte) 0x74, (byte) 0x53, (byte) 0x65,\n+            (byte) 0x74, (byte) 0x42, (byte) 0x69, (byte) 0x74, (byte) 0x49, (byte) 0x0, (byte) 0x6, (byte) 0x73,\n+            (byte) 0x69, (byte) 0x67, (byte) 0x6e, (byte) 0x75, (byte) 0x6d, (byte) 0x5b, (byte) 0x0, (byte) 0x9,\n+            (byte) 0x6d, (byte) 0x61, (byte) 0x67, (byte) 0x6e, (byte) 0x69, (byte) 0x74, (byte) 0x75, (byte) 0x64,\n+            (byte) 0x65, (byte) 0x74, (byte) 0x0, (byte) 0x2, (byte) 0x5b, (byte) 0x42, (byte) 0x78, (byte) 0x71,\n+            (byte) 0x0, (byte) 0x7e, (byte) 0x0, (byte) 0x5, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff,\n+            (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xfe,\n+            (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xfe, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x75, (byte) 0x72, (byte) 0x0, (byte) 0x2, (byte) 0x5b, (byte) 0x42, (byte) 0xac, (byte) 0xf3,\n+            (byte) 0x17, (byte) 0xf8, (byte) 0x6, (byte) 0x8, (byte) 0x54, (byte) 0xe0, (byte) 0x2, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x78, (byte) 0x70, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x78,\n+            (byte) 0x78,\n+    };\n+    private final byte[] durationBytes = {\n+            (byte) 0xac, (byte) 0xed, (byte) 0x0, (byte) 0x5, (byte) 0x73, (byte) 0x72, (byte) 0x0, (byte) 0x4c,\n+            (byte) 0x63, (byte) 0x6f, (byte) 0x6d, (byte) 0x2e, (byte) 0x73, (byte) 0x75, (byte) 0x6e, (byte) 0x2e,\n+            (byte) 0x6f, (byte) 0x72, (byte) 0x67, (byte) 0x2e, (byte) 0x61, (byte) 0x70, (byte) 0x61, (byte) 0x63,\n+            (byte) 0x68, (byte) 0x65, (byte) 0x2e, (byte) 0x78, (byte) 0x65, (byte) 0x72, (byte) 0x63, (byte) 0x65,\n+            (byte) 0x73, (byte) 0x2e, (byte) 0x69, (byte) 0x6e, (byte) 0x74, (byte) 0x65, (byte) 0x72, (byte) 0x6e,\n+            (byte) 0x61, (byte) 0x6c, (byte) 0x2e, (byte) 0x6a, (byte) 0x61, (byte) 0x78, (byte) 0x70, (byte) 0x2e,\n+            (byte) 0x64, (byte) 0x61, (byte) 0x74, (byte) 0x61, (byte) 0x74, (byte) 0x79, (byte) 0x70, (byte) 0x65,\n+            (byte) 0x2e, (byte) 0x44, (byte) 0x75, (byte) 0x72, (byte) 0x61, (byte) 0x74, (byte) 0x69, (byte) 0x6f,\n+            (byte) 0x6e, (byte) 0x49, (byte) 0x6d, (byte) 0x70, (byte) 0x6c, (byte) 0x24, (byte) 0x44, (byte) 0x75,\n+            (byte) 0x72, (byte) 0x61, (byte) 0x74, (byte) 0x69, (byte) 0x6f, (byte) 0x6e, (byte) 0x53, (byte) 0x74,\n+            (byte) 0x72, (byte) 0x65, (byte) 0x61, (byte) 0x6d, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x1, (byte) 0x2, (byte) 0x0, (byte) 0x1, (byte) 0x4c,\n+            (byte) 0x0, (byte) 0x7, (byte) 0x6c, (byte) 0x65, (byte) 0x78, (byte) 0x69, (byte) 0x63, (byte) 0x61,\n+            (byte) 0x6c, (byte) 0x74, (byte) 0x0, (byte) 0x12, (byte) 0x4c, (byte) 0x6a, (byte) 0x61, (byte) 0x76,\n+            (byte) 0x61, (byte) 0x2f, (byte) 0x6c, (byte) 0x61, (byte) 0x6e, (byte) 0x67, (byte) 0x2f, (byte) 0x53,\n+            (byte) 0x74, (byte) 0x72, (byte) 0x69, (byte) 0x6e, (byte) 0x67, (byte) 0x3b, (byte) 0x78, (byte) 0x70,\n+            (byte) 0x74, (byte) 0x0, (byte) 0xe, (byte) 0x50, (byte) 0x31, (byte) 0x59, (byte) 0x31, (byte) 0x4d,\n+            (byte) 0x31, (byte) 0x44, (byte) 0x54, (byte) 0x31, (byte) 0x48, (byte) 0x31, (byte) 0x4d, (byte) 0x31,\n+            (byte) 0x53,\n+    };\n+\n+    @Override\n+    public byte[] getGregorianCalendarByteArray() {\n+        return gregorianCalendarBytes;\n+    }\n+\n+    @Override\n+    public byte[] getDurationBytes() {\n+        return durationBytes;\n+    }\n+}\n","filename":"test\/jdk\/javax\/xml\/jaxp\/datatype\/8033980\/JDK8GregorianCalendarAndDurationSerData.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"},{"filename":"test\/jdk\/javax\/xml\/jaxp\/datatype\/8033980\/JDK8_Duration.ser","binary":true,"status":"deleted"},{"filename":"test\/jdk\/javax\/xml\/jaxp\/datatype\/8033980\/JDK8_XMLGregorianCalendar.ser","binary":true,"status":"deleted"},{"patch":"@@ -0,0 +1,127 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * Mechanically generated JDK 9 specific serialization bytes for XMLGregorianCalendar and Duration data type.\n+ * Do not edit this file.\n+ *\/\n+public class JDK9GregorianCalendarAndDurationSerData extends GregorianCalendarAndDurationSerData {\n+    private final byte[] gregorianCalendarBytes = {\n+            (byte) 0xac, (byte) 0xed, (byte) 0x0, (byte) 0x5, (byte) 0x73, (byte) 0x72, (byte) 0x0, (byte) 0x49,\n+            (byte) 0x63, (byte) 0x6f, (byte) 0x6d, (byte) 0x2e, (byte) 0x73, (byte) 0x75, (byte) 0x6e, (byte) 0x2e,\n+            (byte) 0x6f, (byte) 0x72, (byte) 0x67, (byte) 0x2e, (byte) 0x61, (byte) 0x70, (byte) 0x61, (byte) 0x63,\n+            (byte) 0x68, (byte) 0x65, (byte) 0x2e, (byte) 0x78, (byte) 0x65, (byte) 0x72, (byte) 0x63, (byte) 0x65,\n+            (byte) 0x73, (byte) 0x2e, (byte) 0x69, (byte) 0x6e, (byte) 0x74, (byte) 0x65, (byte) 0x72, (byte) 0x6e,\n+            (byte) 0x61, (byte) 0x6c, (byte) 0x2e, (byte) 0x6a, (byte) 0x61, (byte) 0x78, (byte) 0x70, (byte) 0x2e,\n+            (byte) 0x64, (byte) 0x61, (byte) 0x74, (byte) 0x61, (byte) 0x74, (byte) 0x79, (byte) 0x70, (byte) 0x65,\n+            (byte) 0x2e, (byte) 0x58, (byte) 0x4d, (byte) 0x4c, (byte) 0x47, (byte) 0x72, (byte) 0x65, (byte) 0x67,\n+            (byte) 0x6f, (byte) 0x72, (byte) 0x69, (byte) 0x61, (byte) 0x6e, (byte) 0x43, (byte) 0x61, (byte) 0x6c,\n+            (byte) 0x65, (byte) 0x6e, (byte) 0x64, (byte) 0x61, (byte) 0x72, (byte) 0x49, (byte) 0x6d, (byte) 0x70,\n+            (byte) 0x6c, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x1, (byte) 0x2, (byte) 0x0, (byte) 0x9, (byte) 0x49, (byte) 0x0, (byte) 0x3, (byte) 0x64,\n+            (byte) 0x61, (byte) 0x79, (byte) 0x49, (byte) 0x0, (byte) 0x4, (byte) 0x68, (byte) 0x6f, (byte) 0x75,\n+            (byte) 0x72, (byte) 0x49, (byte) 0x0, (byte) 0x6, (byte) 0x6d, (byte) 0x69, (byte) 0x6e, (byte) 0x75,\n+            (byte) 0x74, (byte) 0x65, (byte) 0x49, (byte) 0x0, (byte) 0x5, (byte) 0x6d, (byte) 0x6f, (byte) 0x6e,\n+            (byte) 0x74, (byte) 0x68, (byte) 0x49, (byte) 0x0, (byte) 0x6, (byte) 0x73, (byte) 0x65, (byte) 0x63,\n+            (byte) 0x6f, (byte) 0x6e, (byte) 0x64, (byte) 0x49, (byte) 0x0, (byte) 0x8, (byte) 0x74, (byte) 0x69,\n+            (byte) 0x6d, (byte) 0x65, (byte) 0x7a, (byte) 0x6f, (byte) 0x6e, (byte) 0x65, (byte) 0x49, (byte) 0x0,\n+            (byte) 0x4, (byte) 0x79, (byte) 0x65, (byte) 0x61, (byte) 0x72, (byte) 0x4c, (byte) 0x0, (byte) 0x3,\n+            (byte) 0x65, (byte) 0x6f, (byte) 0x6e, (byte) 0x74, (byte) 0x0, (byte) 0x16, (byte) 0x4c, (byte) 0x6a,\n+            (byte) 0x61, (byte) 0x76, (byte) 0x61, (byte) 0x2f, (byte) 0x6d, (byte) 0x61, (byte) 0x74, (byte) 0x68,\n+            (byte) 0x2f, (byte) 0x42, (byte) 0x69, (byte) 0x67, (byte) 0x49, (byte) 0x6e, (byte) 0x74, (byte) 0x65,\n+            (byte) 0x67, (byte) 0x65, (byte) 0x72, (byte) 0x3b, (byte) 0x4c, (byte) 0x0, (byte) 0x10, (byte) 0x66,\n+            (byte) 0x72, (byte) 0x61, (byte) 0x63, (byte) 0x74, (byte) 0x69, (byte) 0x6f, (byte) 0x6e, (byte) 0x61,\n+            (byte) 0x6c, (byte) 0x53, (byte) 0x65, (byte) 0x63, (byte) 0x6f, (byte) 0x6e, (byte) 0x64, (byte) 0x74,\n+            (byte) 0x0, (byte) 0x16, (byte) 0x4c, (byte) 0x6a, (byte) 0x61, (byte) 0x76, (byte) 0x61, (byte) 0x2f,\n+            (byte) 0x6d, (byte) 0x61, (byte) 0x74, (byte) 0x68, (byte) 0x2f, (byte) 0x42, (byte) 0x69, (byte) 0x67,\n+            (byte) 0x44, (byte) 0x65, (byte) 0x63, (byte) 0x69, (byte) 0x6d, (byte) 0x61, (byte) 0x6c, (byte) 0x3b,\n+            (byte) 0x78, (byte) 0x70, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x1, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x1, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0xff, (byte) 0xff,\n+            (byte) 0xfe, (byte) 0xd4, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x1, (byte) 0x70, (byte) 0x73,\n+            (byte) 0x72, (byte) 0x0, (byte) 0x14, (byte) 0x6a, (byte) 0x61, (byte) 0x76, (byte) 0x61, (byte) 0x2e,\n+            (byte) 0x6d, (byte) 0x61, (byte) 0x74, (byte) 0x68, (byte) 0x2e, (byte) 0x42, (byte) 0x69, (byte) 0x67,\n+            (byte) 0x44, (byte) 0x65, (byte) 0x63, (byte) 0x69, (byte) 0x6d, (byte) 0x61, (byte) 0x6c, (byte) 0x54,\n+            (byte) 0xc7, (byte) 0x15, (byte) 0x57, (byte) 0xf9, (byte) 0x81, (byte) 0x28, (byte) 0x4f, (byte) 0x3,\n+            (byte) 0x0, (byte) 0x2, (byte) 0x49, (byte) 0x0, (byte) 0x5, (byte) 0x73, (byte) 0x63, (byte) 0x61,\n+            (byte) 0x6c, (byte) 0x65, (byte) 0x4c, (byte) 0x0, (byte) 0x6, (byte) 0x69, (byte) 0x6e, (byte) 0x74,\n+            (byte) 0x56, (byte) 0x61, (byte) 0x6c, (byte) 0x71, (byte) 0x0, (byte) 0x7e, (byte) 0x0, (byte) 0x1,\n+            (byte) 0x78, (byte) 0x72, (byte) 0x0, (byte) 0x10, (byte) 0x6a, (byte) 0x61, (byte) 0x76, (byte) 0x61,\n+            (byte) 0x2e, (byte) 0x6c, (byte) 0x61, (byte) 0x6e, (byte) 0x67, (byte) 0x2e, (byte) 0x4e, (byte) 0x75,\n+            (byte) 0x6d, (byte) 0x62, (byte) 0x65, (byte) 0x72, (byte) 0x86, (byte) 0xac, (byte) 0x95, (byte) 0x1d,\n+            (byte) 0xb, (byte) 0x94, (byte) 0xe0, (byte) 0x8b, (byte) 0x2, (byte) 0x0, (byte) 0x0, (byte) 0x78,\n+            (byte) 0x70, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x7, (byte) 0x73, (byte) 0x72, (byte) 0x0,\n+            (byte) 0x14, (byte) 0x6a, (byte) 0x61, (byte) 0x76, (byte) 0x61, (byte) 0x2e, (byte) 0x6d, (byte) 0x61,\n+            (byte) 0x74, (byte) 0x68, (byte) 0x2e, (byte) 0x42, (byte) 0x69, (byte) 0x67, (byte) 0x49, (byte) 0x6e,\n+            (byte) 0x74, (byte) 0x65, (byte) 0x67, (byte) 0x65, (byte) 0x72, (byte) 0x8c, (byte) 0xfc, (byte) 0x9f,\n+            (byte) 0x1f, (byte) 0xa9, (byte) 0x3b, (byte) 0xfb, (byte) 0x1d, (byte) 0x3, (byte) 0x0, (byte) 0x6,\n+            (byte) 0x49, (byte) 0x0, (byte) 0x8, (byte) 0x62, (byte) 0x69, (byte) 0x74, (byte) 0x43, (byte) 0x6f,\n+            (byte) 0x75, (byte) 0x6e, (byte) 0x74, (byte) 0x49, (byte) 0x0, (byte) 0x9, (byte) 0x62, (byte) 0x69,\n+            (byte) 0x74, (byte) 0x4c, (byte) 0x65, (byte) 0x6e, (byte) 0x67, (byte) 0x74, (byte) 0x68, (byte) 0x49,\n+            (byte) 0x0, (byte) 0x13, (byte) 0x66, (byte) 0x69, (byte) 0x72, (byte) 0x73, (byte) 0x74, (byte) 0x4e,\n+            (byte) 0x6f, (byte) 0x6e, (byte) 0x7a, (byte) 0x65, (byte) 0x72, (byte) 0x6f, (byte) 0x42, (byte) 0x79,\n+            (byte) 0x74, (byte) 0x65, (byte) 0x4e, (byte) 0x75, (byte) 0x6d, (byte) 0x49, (byte) 0x0, (byte) 0xc,\n+            (byte) 0x6c, (byte) 0x6f, (byte) 0x77, (byte) 0x65, (byte) 0x73, (byte) 0x74, (byte) 0x53, (byte) 0x65,\n+            (byte) 0x74, (byte) 0x42, (byte) 0x69, (byte) 0x74, (byte) 0x49, (byte) 0x0, (byte) 0x6, (byte) 0x73,\n+            (byte) 0x69, (byte) 0x67, (byte) 0x6e, (byte) 0x75, (byte) 0x6d, (byte) 0x5b, (byte) 0x0, (byte) 0x9,\n+            (byte) 0x6d, (byte) 0x61, (byte) 0x67, (byte) 0x6e, (byte) 0x69, (byte) 0x74, (byte) 0x75, (byte) 0x64,\n+            (byte) 0x65, (byte) 0x74, (byte) 0x0, (byte) 0x2, (byte) 0x5b, (byte) 0x42, (byte) 0x78, (byte) 0x71,\n+            (byte) 0x0, (byte) 0x7e, (byte) 0x0, (byte) 0x5, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff,\n+            (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xfe,\n+            (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xfe, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x75, (byte) 0x72, (byte) 0x0, (byte) 0x2, (byte) 0x5b, (byte) 0x42, (byte) 0xac, (byte) 0xf3,\n+            (byte) 0x17, (byte) 0xf8, (byte) 0x6, (byte) 0x8, (byte) 0x54, (byte) 0xe0, (byte) 0x2, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x78, (byte) 0x70, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x78,\n+            (byte) 0x78,\n+    };\n+    private final byte[] durationBytes = {\n+            (byte) 0xac, (byte) 0xed, (byte) 0x0, (byte) 0x5, (byte) 0x73, (byte) 0x72, (byte) 0x0, (byte) 0x4c,\n+            (byte) 0x63, (byte) 0x6f, (byte) 0x6d, (byte) 0x2e, (byte) 0x73, (byte) 0x75, (byte) 0x6e, (byte) 0x2e,\n+            (byte) 0x6f, (byte) 0x72, (byte) 0x67, (byte) 0x2e, (byte) 0x61, (byte) 0x70, (byte) 0x61, (byte) 0x63,\n+            (byte) 0x68, (byte) 0x65, (byte) 0x2e, (byte) 0x78, (byte) 0x65, (byte) 0x72, (byte) 0x63, (byte) 0x65,\n+            (byte) 0x73, (byte) 0x2e, (byte) 0x69, (byte) 0x6e, (byte) 0x74, (byte) 0x65, (byte) 0x72, (byte) 0x6e,\n+            (byte) 0x61, (byte) 0x6c, (byte) 0x2e, (byte) 0x6a, (byte) 0x61, (byte) 0x78, (byte) 0x70, (byte) 0x2e,\n+            (byte) 0x64, (byte) 0x61, (byte) 0x74, (byte) 0x61, (byte) 0x74, (byte) 0x79, (byte) 0x70, (byte) 0x65,\n+            (byte) 0x2e, (byte) 0x44, (byte) 0x75, (byte) 0x72, (byte) 0x61, (byte) 0x74, (byte) 0x69, (byte) 0x6f,\n+            (byte) 0x6e, (byte) 0x49, (byte) 0x6d, (byte) 0x70, (byte) 0x6c, (byte) 0x24, (byte) 0x44, (byte) 0x75,\n+            (byte) 0x72, (byte) 0x61, (byte) 0x74, (byte) 0x69, (byte) 0x6f, (byte) 0x6e, (byte) 0x53, (byte) 0x74,\n+            (byte) 0x72, (byte) 0x65, (byte) 0x61, (byte) 0x6d, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x1, (byte) 0x2, (byte) 0x0, (byte) 0x1, (byte) 0x4c,\n+            (byte) 0x0, (byte) 0x7, (byte) 0x6c, (byte) 0x65, (byte) 0x78, (byte) 0x69, (byte) 0x63, (byte) 0x61,\n+            (byte) 0x6c, (byte) 0x74, (byte) 0x0, (byte) 0x12, (byte) 0x4c, (byte) 0x6a, (byte) 0x61, (byte) 0x76,\n+            (byte) 0x61, (byte) 0x2f, (byte) 0x6c, (byte) 0x61, (byte) 0x6e, (byte) 0x67, (byte) 0x2f, (byte) 0x53,\n+            (byte) 0x74, (byte) 0x72, (byte) 0x69, (byte) 0x6e, (byte) 0x67, (byte) 0x3b, (byte) 0x78, (byte) 0x70,\n+            (byte) 0x74, (byte) 0x0, (byte) 0xe, (byte) 0x50, (byte) 0x31, (byte) 0x59, (byte) 0x31, (byte) 0x4d,\n+            (byte) 0x31, (byte) 0x44, (byte) 0x54, (byte) 0x31, (byte) 0x48, (byte) 0x31, (byte) 0x4d, (byte) 0x31,\n+            (byte) 0x53,\n+    };\n+    @Override\n+    public byte[] getGregorianCalendarByteArray() {\n+        return gregorianCalendarBytes;\n+    }\n+\n+    @Override\n+    public byte[] getDurationBytes() {\n+        return durationBytes;\n+    }\n+}\n","filename":"test\/jdk\/javax\/xml\/jaxp\/datatype\/8033980\/JDK9GregorianCalendarAndDurationSerData.java","additions":127,"deletions":0,"binary":false,"changes":127,"status":"added"},{"filename":"test\/jdk\/javax\/xml\/jaxp\/datatype\/8033980\/JDK9_Duration.ser","binary":true,"status":"deleted"},{"filename":"test\/jdk\/javax\/xml\/jaxp\/datatype\/8033980\/JDK9_XMLGregorianCalendar.ser","binary":true,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run main SerializationTest read\n+ * @run junit SerializationTest\n@@ -31,1 +31,7 @@\n-import java.io.*;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.util.stream.Stream;\n+\n@@ -37,0 +43,7 @@\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.TestInstance;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n@@ -38,7 +51,1 @@\n- * use \"read\" to test compatibility\n- * SerializationTest read\n- *\n- * use \"write\" to create test files\n- * SerializationTest write javaVersion\n- * where javaVersion is 6, 7, 8, or 9\n- *\n+ * Verify serialization compatibility for XMLGregorianCalendar and Duration\n@@ -47,0 +54,1 @@\n+@TestInstance(TestInstance.Lifecycle.PER_CLASS)\n@@ -49,12 +57,0 @@\n-    final String FILENAME_CAL = \"_XMLGregorianCalendar.ser\";\n-    final String FILENAME_DURATION = \"_Duration.ser\";\n-    String filePath;\n-\n-    {\n-        filePath = System.getProperty(\"test.src\");\n-        if (filePath == null) {\n-            \/\/current directory\n-            filePath = System.getProperty(\"user.dir\");\n-        }\n-        filePath += File.separator;\n-    }\n@@ -63,13 +59,1 @@\n-    static String[] JDK = {\"JDK6\", \"JDK7\", \"JDK8\", \"JDK9\"};\n-\n-    public static void main(String[] args) {\n-        SerializationTest test = new SerializationTest();\n-\n-        if (args[0].equalsIgnoreCase(\"read\")) {\n-            test.testReadCal();\n-            test.testReadDuration();\n-            test.report();\n-        } else {\n-            int ver = Integer.valueOf(args[1]).intValue();\n-            test.createTestFile(JDK[ver - 6]);\n-        }\n+    static String[] JDK = {System.getProperty(\"java.version\"), \"JDK6\", \"JDK7\", \"JDK8\", \"JDK9\"};\n@@ -77,1 +61,4 @@\n-    }\n+    \/\/ If needed to add serialized data of more JDK versions, serialized data source file can be generated using\n+    \/\/ GregorianCalAndDurSerDataUtil class.\n+    private GregorianCalendarAndDurationSerData[] gregorianCalendarAndDurationSerData = {null, new JDK6GregorianCalendarAndDurationSerData(),\n+    new JDK7GregorianCalendarAndDurationSerData(), new JDK8GregorianCalendarAndDurationSerData(), new JDK9GregorianCalendarAndDurationSerData()};\n@@ -79,11 +66,22 @@\n-    public void testReadCal() {\n-        try {\n-            for (String javaVersion : JDK) {\n-                XMLGregorianCalendar d1 = (XMLGregorianCalendar) fromFile(\n-                        javaVersion + FILENAME_CAL);\n-                if (!d1.toString().equalsIgnoreCase(EXPECTED_CAL)) {\n-                    fail(\"Java version: \" + javaVersion\n-                            + \"\\nExpected: \" + EXPECTED_CAL\n-                            + \"\\nActual: \" + d1.toString());\n-                } else {\n-                    success(\"testReadCal: read \" + javaVersion + \" serialized file, passed.\");\n+    \/**\n+     * Create the serialized Bytes array and serialized bytes base64 string for GregorianCalender and Duration\n+     * with jdk under test.\n+     * @throws DatatypeConfigurationException Unexpected.\n+     * @throws IOException Unexpected.\n+     *\/\n+    @BeforeAll\n+    public void setup() throws DatatypeConfigurationException, IOException {\n+        DatatypeFactory dtf = DatatypeFactory.newInstance();\n+        XMLGregorianCalendar xmlGregorianCalendar = dtf.newXMLGregorianCalendar(EXPECTED_CAL);\n+        Duration duration = dtf.newDuration(EXPECTED_DURATION);\n+        try(ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos);\n+            ByteArrayOutputStream baos2 = new ByteArrayOutputStream(); ObjectOutputStream oos2 = new ObjectOutputStream(baos2)) {\n+            \/\/Serialize the given xmlGregorianCalendar\n+            oos.writeObject(xmlGregorianCalendar);\n+            \/\/Serialize the given xml Duration\n+            oos2.writeObject(duration);\n+            \/\/ Create the Data for JDK under test.\n+            gregorianCalendarAndDurationSerData[0] = new GregorianCalendarAndDurationSerData() {\n+                @Override\n+                public byte[] getGregorianCalendarByteArray() {\n+                    return baos.toByteArray();\n@@ -91,7 +89,0 @@\n-            }\n-        } catch (ClassNotFoundException ex) {\n-            fail(\"testReadCal: \" + ex.getMessage());\n-        } catch (IOException ex) {\n-            fail(\"testReadCal: \" + ex.getMessage());\n-        }\n-    }\n@@ -99,11 +90,3 @@\n-    public void testReadDuration() {\n-        try {\n-            for (String javaVersion : JDK) {\n-                Duration d1 = (Duration) fromFile(\n-                        javaVersion + FILENAME_DURATION);\n-                if (!d1.toString().equalsIgnoreCase(EXPECTED_DURATION)) {\n-                    fail(\"Java version: \" + javaVersion\n-                            + \"\\nExpected: \" + EXPECTED_DURATION\n-                            + \"\\nActual: \" + d1.toString());\n-                } else {\n-                    success(\"testReadDuration: read \" + javaVersion + \" serialized file, passed.\");\n+                @Override\n+                public byte[] getDurationBytes() {\n+                    return baos2.toByteArray();\n@@ -111,5 +94,1 @@\n-            }\n-        } catch (ClassNotFoundException ex) {\n-            fail(\"testReadDuration: \" + ex.getMessage());\n-        } catch (IOException ex) {\n-            fail(\"testReadDuration: \" + ex.getMessage());\n+            };\n@@ -120,3 +99,4 @@\n-     * Create test files\n-     *\n-     * @param javaVersion JDK version\n+     * Provide data for JDK version and Gregorian Calendar serialized bytes.\n+     * @return A Stream of arguments where each element is an array of size three. First element contain JDK version,\n+     * second element contain object reference to GregorianCalendarAndDurationSerData specific to JDK version\n+     * and third element contain expected Gregorian Calendar as string.\n@@ -124,10 +104,9 @@\n-    public void createTestFile(String javaVersion) {\n-        try {\n-            DatatypeFactory dtf = DatatypeFactory.newInstance();\n-            XMLGregorianCalendar c = dtf.newXMLGregorianCalendar(EXPECTED_CAL);\n-            Duration d = dtf.newDuration(EXPECTED_DURATION);\n-            toFile((Serializable) c, filePath + javaVersion + FILENAME_CAL);\n-            toFile((Serializable) d, filePath + javaVersion + FILENAME_DURATION);\n-        } catch (Exception e) {\n-            fail(e.getMessage());\n-        }\n+\n+    public Stream<Arguments> gregorianCalendarDataBytes() {\n+        return Stream.of(\n+                Arguments.of(JDK[0], gregorianCalendarAndDurationSerData[0], EXPECTED_CAL),\n+                Arguments.of(JDK[1], gregorianCalendarAndDurationSerData[1], EXPECTED_CAL),\n+                Arguments.of(JDK[2], gregorianCalendarAndDurationSerData[2], EXPECTED_CAL),\n+                Arguments.of(JDK[3], gregorianCalendarAndDurationSerData[3], EXPECTED_CAL),\n+                Arguments.of(JDK[4], gregorianCalendarAndDurationSerData[4], EXPECTED_CAL)\n+        );\n@@ -137,1 +116,4 @@\n-     * Read the object from a file.\n+     * Provide data for JDK version and Duration serialized bytes.\n+     * @return A Stream of arguments where each element is an array of size three. First element contain JDK version,\n+     * second element contain object reference to GregorianCalendarAndDurationSerData specific to JDK version\n+     * and third element contain expected Duration as string.\n@@ -139,7 +121,7 @@\n-    private static Object fromFile(String filePath) throws IOException,\n-            ClassNotFoundException {\n-        InputStream streamIn = SerializationTest.class.getResourceAsStream(\n-            filePath);\n-        ObjectInputStream objectinputstream = new ObjectInputStream(streamIn);\n-        Object o = objectinputstream.readObject();\n-        return o;\n+\n+    public Stream<Arguments> durationData() {\n+        return Stream.of(Arguments.of(JDK[0], gregorianCalendarAndDurationSerData[0], EXPECTED_DURATION),\n+                Arguments.of(JDK[1], gregorianCalendarAndDurationSerData[1], EXPECTED_DURATION),\n+                Arguments.of(JDK[2], gregorianCalendarAndDurationSerData[2], EXPECTED_DURATION),\n+                Arguments.of(JDK[3], gregorianCalendarAndDurationSerData[3], EXPECTED_DURATION),\n+                Arguments.of(JDK[4], gregorianCalendarAndDurationSerData[4], EXPECTED_DURATION));\n@@ -149,1 +131,7 @@\n-     * Write the object to a file.\n+     * Verify that GregorianCalendar serialized with different old JDK versions can be deserialized correctly with\n+     * JDK under test.\n+     * @param javaVersion JDK version used to GregorianCalendar serialization.\n+     * @param gcsd JDK version specific GregorianCalendarAndDurationSerData.\n+     * @param gregorianDate String representation of GregorianCalendar Date.\n+     * @throws IOException Unexpected.\n+     * @throws ClassNotFoundException Unexpected.\n@@ -151,18 +139,0 @@\n-    private static void toFile(Serializable o, String filePath) throws IOException {\n-        FileOutputStream fout = new FileOutputStream(filePath, true);\n-        ObjectOutputStream oos = new ObjectOutputStream(fout);\n-        oos.writeObject(o);\n-        oos.close();\n-    }\n-\n-    static String errMessage;\n-    int passed = 0, failed = 0;\n-\n-    void fail(String errMsg) {\n-        if (errMessage == null) {\n-            errMessage = errMsg;\n-        } else {\n-            errMessage = errMessage + \"\\n\" + errMsg;\n-        }\n-        failed++;\n-    }\n@@ -170,3 +140,8 @@\n-    void success(String msg) {\n-        passed++;\n-        System.out.println(msg);\n+    @ParameterizedTest\n+    @MethodSource(\"gregorianCalendarDataBytes\")\n+    public void testReadCalBytes(String javaVersion, GregorianCalendarAndDurationSerData gcsd, String gregorianDate) throws IOException,\n+            ClassNotFoundException {\n+        final ByteArrayInputStream bais = new ByteArrayInputStream(gcsd.getGregorianCalendarByteArray());\n+        final ObjectInputStream ois = new ObjectInputStream(bais);\n+        final XMLGregorianCalendar xgc = (XMLGregorianCalendar) ois.readObject();\n+        assertEquals(gregorianDate, xgc.toString());\n@@ -175,4 +150,9 @@\n-    public void report() {\n-\n-        System.out.println(\"\\nNumber of tests passed: \" + passed);\n-        System.out.println(\"Number of tests failed: \" + failed + \"\\n\");\n+    \/**\n+     * Verify that Duration serialized with different old JDK versions can be deserialized correctly with\n+     * JDK under test.\n+     * @param javaVersion JDK version used to GregorianCalendar serialization.\n+     * @param gcsd JDK version specific GregorianCalendarAndDurationSerData.\n+     * @param duration String representation of Duration.\n+     * @throws IOException Unexpected.\n+     * @throws ClassNotFoundException Unexpected.\n+     *\/\n@@ -180,3 +160,8 @@\n-        if (errMessage != null) {\n-            throw new RuntimeException(errMessage);\n-        }\n+    @ParameterizedTest\n+    @MethodSource(\"durationData\")\n+    public void testReadDurationBytes(String javaVersion, GregorianCalendarAndDurationSerData gcsd, String duration) throws IOException,\n+            ClassNotFoundException {\n+        final ByteArrayInputStream bais = new ByteArrayInputStream(gcsd.getDurationBytes());\n+        final ObjectInputStream ois = new ObjectInputStream(bais);\n+        final Duration d1 = (Duration) ois.readObject();\n+        assertEquals(duration, d1.toString().toUpperCase());\n","filename":"test\/jdk\/javax\/xml\/jaxp\/datatype\/8033980\/SerializationTest.java","additions":105,"deletions":120,"binary":false,"changes":225,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorLoadStoreTests.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorLoadStoreTests.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorLoadStoreTests.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorLoadStoreTests.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorLoadStoreTests.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorLoadStoreTests.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -63,0 +63,2 @@\n+    \/\/ for floating point reduction ops that may introduce rounding errors\n+    private static final double RELATIVE_ROUNDING_ERROR = (double)0.000001;\n@@ -122,0 +124,6 @@\n+        assertReductionArraysEquals(r, rc, a, f, fa, (double)0.0);\n+    }\n+\n+    static void assertReductionArraysEquals(double[] r, double rc, double[] a,\n+                                            FReductionOp f, FReductionAllOp fa,\n+                                            double relativeError) {\n@@ -124,1 +132,1 @@\n-            Assert.assertEquals(rc, fa.apply(a));\n+            Assert.assertEquals(rc, fa.apply(a), Math.abs(rc * relativeError));\n@@ -126,1 +134,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                Assert.assertEquals(r[i], f.apply(a, i), Math.abs(r[i] * relativeError));\n@@ -129,2 +137,2 @@\n-            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            Assert.assertEquals(rc, fa.apply(a), Math.abs(rc * relativeError), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i), Math.abs(r[i] * relativeError), \"at index #\" + i);\n@@ -144,0 +152,6 @@\n+        assertReductionArraysEqualsMasked(r, rc, a, mask, f, fa, (double)0.0);\n+    }\n+\n+    static void assertReductionArraysEqualsMasked(double[] r, double rc, double[] a, boolean[] mask,\n+                                            FReductionMaskedOp f, FReductionAllMaskedOp fa,\n+                                            double relativeError) {\n@@ -146,1 +160,1 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask));\n+            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError));\n@@ -148,1 +162,2 @@\n-                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+                Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] *\n+relativeError));\n@@ -151,2 +166,2 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] * relativeError), \"at index #\" + i);\n@@ -1081,0 +1096,8 @@\n+            withToString(\"double[0.01 + (i \/ (i + 1))]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)0.01 + ((double)i \/ (i + 1)));\n+            }),\n+            withToString(\"double[i -> i % 17 == 0 ? cornerCaseValue(i) : 0.01 + (i \/ (i + 1))]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> i % 17 == 0 ? cornerCaseValue(i) : (double)0.01 + ((double)i \/ (i + 1)));\n+            }),\n@@ -2171,1 +2194,1 @@\n-                Double128VectorTests::ADDReduce, Double128VectorTests::ADDReduceAll);\n+                Double128VectorTests::ADDReduce, Double128VectorTests::ADDReduceAll, RELATIVE_ROUNDING_ERROR);\n@@ -2217,1 +2240,1 @@\n-                Double128VectorTests::ADDReduceMasked, Double128VectorTests::ADDReduceAllMasked);\n+                Double128VectorTests::ADDReduceMasked, Double128VectorTests::ADDReduceAllMasked, RELATIVE_ROUNDING_ERROR);\n@@ -2260,1 +2283,1 @@\n-                Double128VectorTests::MULReduce, Double128VectorTests::MULReduceAll);\n+                Double128VectorTests::MULReduce, Double128VectorTests::MULReduceAll, RELATIVE_ROUNDING_ERROR);\n@@ -2306,1 +2329,1 @@\n-                Double128VectorTests::MULReduceMasked, Double128VectorTests::MULReduceAllMasked);\n+                Double128VectorTests::MULReduceMasked, Double128VectorTests::MULReduceAllMasked, RELATIVE_ROUNDING_ERROR);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorTests.java","additions":35,"deletions":12,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorLoadStoreTests.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -63,0 +63,2 @@\n+    \/\/ for floating point reduction ops that may introduce rounding errors\n+    private static final double RELATIVE_ROUNDING_ERROR = (double)0.000001;\n@@ -122,0 +124,6 @@\n+        assertReductionArraysEquals(r, rc, a, f, fa, (double)0.0);\n+    }\n+\n+    static void assertReductionArraysEquals(double[] r, double rc, double[] a,\n+                                            FReductionOp f, FReductionAllOp fa,\n+                                            double relativeError) {\n@@ -124,1 +132,1 @@\n-            Assert.assertEquals(rc, fa.apply(a));\n+            Assert.assertEquals(rc, fa.apply(a), Math.abs(rc * relativeError));\n@@ -126,1 +134,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                Assert.assertEquals(r[i], f.apply(a, i), Math.abs(r[i] * relativeError));\n@@ -129,2 +137,2 @@\n-            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            Assert.assertEquals(rc, fa.apply(a), Math.abs(rc * relativeError), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i), Math.abs(r[i] * relativeError), \"at index #\" + i);\n@@ -144,0 +152,6 @@\n+        assertReductionArraysEqualsMasked(r, rc, a, mask, f, fa, (double)0.0);\n+    }\n+\n+    static void assertReductionArraysEqualsMasked(double[] r, double rc, double[] a, boolean[] mask,\n+                                            FReductionMaskedOp f, FReductionAllMaskedOp fa,\n+                                            double relativeError) {\n@@ -146,1 +160,1 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask));\n+            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError));\n@@ -148,1 +162,2 @@\n-                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+                Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] *\n+relativeError));\n@@ -151,2 +166,2 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] * relativeError), \"at index #\" + i);\n@@ -1081,0 +1096,8 @@\n+            withToString(\"double[0.01 + (i \/ (i + 1))]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)0.01 + ((double)i \/ (i + 1)));\n+            }),\n+            withToString(\"double[i -> i % 17 == 0 ? cornerCaseValue(i) : 0.01 + (i \/ (i + 1))]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> i % 17 == 0 ? cornerCaseValue(i) : (double)0.01 + ((double)i \/ (i + 1)));\n+            }),\n@@ -2171,1 +2194,1 @@\n-                Double256VectorTests::ADDReduce, Double256VectorTests::ADDReduceAll);\n+                Double256VectorTests::ADDReduce, Double256VectorTests::ADDReduceAll, RELATIVE_ROUNDING_ERROR);\n@@ -2217,1 +2240,1 @@\n-                Double256VectorTests::ADDReduceMasked, Double256VectorTests::ADDReduceAllMasked);\n+                Double256VectorTests::ADDReduceMasked, Double256VectorTests::ADDReduceAllMasked, RELATIVE_ROUNDING_ERROR);\n@@ -2260,1 +2283,1 @@\n-                Double256VectorTests::MULReduce, Double256VectorTests::MULReduceAll);\n+                Double256VectorTests::MULReduce, Double256VectorTests::MULReduceAll, RELATIVE_ROUNDING_ERROR);\n@@ -2306,1 +2329,1 @@\n-                Double256VectorTests::MULReduceMasked, Double256VectorTests::MULReduceAllMasked);\n+                Double256VectorTests::MULReduceMasked, Double256VectorTests::MULReduceAllMasked, RELATIVE_ROUNDING_ERROR);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorTests.java","additions":35,"deletions":12,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorLoadStoreTests.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -63,0 +63,2 @@\n+    \/\/ for floating point reduction ops that may introduce rounding errors\n+    private static final double RELATIVE_ROUNDING_ERROR = (double)0.000001;\n@@ -122,0 +124,6 @@\n+        assertReductionArraysEquals(r, rc, a, f, fa, (double)0.0);\n+    }\n+\n+    static void assertReductionArraysEquals(double[] r, double rc, double[] a,\n+                                            FReductionOp f, FReductionAllOp fa,\n+                                            double relativeError) {\n@@ -124,1 +132,1 @@\n-            Assert.assertEquals(rc, fa.apply(a));\n+            Assert.assertEquals(rc, fa.apply(a), Math.abs(rc * relativeError));\n@@ -126,1 +134,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                Assert.assertEquals(r[i], f.apply(a, i), Math.abs(r[i] * relativeError));\n@@ -129,2 +137,2 @@\n-            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            Assert.assertEquals(rc, fa.apply(a), Math.abs(rc * relativeError), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i), Math.abs(r[i] * relativeError), \"at index #\" + i);\n@@ -144,0 +152,6 @@\n+        assertReductionArraysEqualsMasked(r, rc, a, mask, f, fa, (double)0.0);\n+    }\n+\n+    static void assertReductionArraysEqualsMasked(double[] r, double rc, double[] a, boolean[] mask,\n+                                            FReductionMaskedOp f, FReductionAllMaskedOp fa,\n+                                            double relativeError) {\n@@ -146,1 +160,1 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask));\n+            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError));\n@@ -148,1 +162,2 @@\n-                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+                Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] *\n+relativeError));\n@@ -151,2 +166,2 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] * relativeError), \"at index #\" + i);\n@@ -1081,0 +1096,8 @@\n+            withToString(\"double[0.01 + (i \/ (i + 1))]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)0.01 + ((double)i \/ (i + 1)));\n+            }),\n+            withToString(\"double[i -> i % 17 == 0 ? cornerCaseValue(i) : 0.01 + (i \/ (i + 1))]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> i % 17 == 0 ? cornerCaseValue(i) : (double)0.01 + ((double)i \/ (i + 1)));\n+            }),\n@@ -2171,1 +2194,1 @@\n-                Double512VectorTests::ADDReduce, Double512VectorTests::ADDReduceAll);\n+                Double512VectorTests::ADDReduce, Double512VectorTests::ADDReduceAll, RELATIVE_ROUNDING_ERROR);\n@@ -2217,1 +2240,1 @@\n-                Double512VectorTests::ADDReduceMasked, Double512VectorTests::ADDReduceAllMasked);\n+                Double512VectorTests::ADDReduceMasked, Double512VectorTests::ADDReduceAllMasked, RELATIVE_ROUNDING_ERROR);\n@@ -2260,1 +2283,1 @@\n-                Double512VectorTests::MULReduce, Double512VectorTests::MULReduceAll);\n+                Double512VectorTests::MULReduce, Double512VectorTests::MULReduceAll, RELATIVE_ROUNDING_ERROR);\n@@ -2306,1 +2329,1 @@\n-                Double512VectorTests::MULReduceMasked, Double512VectorTests::MULReduceAllMasked);\n+                Double512VectorTests::MULReduceMasked, Double512VectorTests::MULReduceAllMasked, RELATIVE_ROUNDING_ERROR);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorTests.java","additions":35,"deletions":12,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorLoadStoreTests.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -63,0 +63,2 @@\n+    \/\/ for floating point reduction ops that may introduce rounding errors\n+    private static final double RELATIVE_ROUNDING_ERROR = (double)0.000001;\n@@ -122,0 +124,6 @@\n+        assertReductionArraysEquals(r, rc, a, f, fa, (double)0.0);\n+    }\n+\n+    static void assertReductionArraysEquals(double[] r, double rc, double[] a,\n+                                            FReductionOp f, FReductionAllOp fa,\n+                                            double relativeError) {\n@@ -124,1 +132,1 @@\n-            Assert.assertEquals(rc, fa.apply(a));\n+            Assert.assertEquals(rc, fa.apply(a), Math.abs(rc * relativeError));\n@@ -126,1 +134,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                Assert.assertEquals(r[i], f.apply(a, i), Math.abs(r[i] * relativeError));\n@@ -129,2 +137,2 @@\n-            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            Assert.assertEquals(rc, fa.apply(a), Math.abs(rc * relativeError), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i), Math.abs(r[i] * relativeError), \"at index #\" + i);\n@@ -144,0 +152,6 @@\n+        assertReductionArraysEqualsMasked(r, rc, a, mask, f, fa, (double)0.0);\n+    }\n+\n+    static void assertReductionArraysEqualsMasked(double[] r, double rc, double[] a, boolean[] mask,\n+                                            FReductionMaskedOp f, FReductionAllMaskedOp fa,\n+                                            double relativeError) {\n@@ -146,1 +160,1 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask));\n+            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError));\n@@ -148,1 +162,2 @@\n-                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+                Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] *\n+relativeError));\n@@ -151,2 +166,2 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] * relativeError), \"at index #\" + i);\n@@ -1081,0 +1096,8 @@\n+            withToString(\"double[0.01 + (i \/ (i + 1))]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)0.01 + ((double)i \/ (i + 1)));\n+            }),\n+            withToString(\"double[i -> i % 17 == 0 ? cornerCaseValue(i) : 0.01 + (i \/ (i + 1))]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> i % 17 == 0 ? cornerCaseValue(i) : (double)0.01 + ((double)i \/ (i + 1)));\n+            }),\n@@ -2171,1 +2194,1 @@\n-                Double64VectorTests::ADDReduce, Double64VectorTests::ADDReduceAll);\n+                Double64VectorTests::ADDReduce, Double64VectorTests::ADDReduceAll, RELATIVE_ROUNDING_ERROR);\n@@ -2217,1 +2240,1 @@\n-                Double64VectorTests::ADDReduceMasked, Double64VectorTests::ADDReduceAllMasked);\n+                Double64VectorTests::ADDReduceMasked, Double64VectorTests::ADDReduceAllMasked, RELATIVE_ROUNDING_ERROR);\n@@ -2260,1 +2283,1 @@\n-                Double64VectorTests::MULReduce, Double64VectorTests::MULReduceAll);\n+                Double64VectorTests::MULReduce, Double64VectorTests::MULReduceAll, RELATIVE_ROUNDING_ERROR);\n@@ -2306,1 +2329,1 @@\n-                Double64VectorTests::MULReduceMasked, Double64VectorTests::MULReduceAllMasked);\n+                Double64VectorTests::MULReduceMasked, Double64VectorTests::MULReduceAllMasked, RELATIVE_ROUNDING_ERROR);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorTests.java","additions":35,"deletions":12,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorLoadStoreTests.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -68,0 +68,2 @@\n+    \/\/ for floating point reduction ops that may introduce rounding errors\n+    private static final double RELATIVE_ROUNDING_ERROR = (double)0.000001;\n@@ -127,0 +129,6 @@\n+        assertReductionArraysEquals(r, rc, a, f, fa, (double)0.0);\n+    }\n+\n+    static void assertReductionArraysEquals(double[] r, double rc, double[] a,\n+                                            FReductionOp f, FReductionAllOp fa,\n+                                            double relativeError) {\n@@ -129,1 +137,1 @@\n-            Assert.assertEquals(rc, fa.apply(a));\n+            Assert.assertEquals(rc, fa.apply(a), Math.abs(rc * relativeError));\n@@ -131,1 +139,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                Assert.assertEquals(r[i], f.apply(a, i), Math.abs(r[i] * relativeError));\n@@ -134,2 +142,2 @@\n-            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            Assert.assertEquals(rc, fa.apply(a), Math.abs(rc * relativeError), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i), Math.abs(r[i] * relativeError), \"at index #\" + i);\n@@ -149,0 +157,6 @@\n+        assertReductionArraysEqualsMasked(r, rc, a, mask, f, fa, (double)0.0);\n+    }\n+\n+    static void assertReductionArraysEqualsMasked(double[] r, double rc, double[] a, boolean[] mask,\n+                                            FReductionMaskedOp f, FReductionAllMaskedOp fa,\n+                                            double relativeError) {\n@@ -151,1 +165,1 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask));\n+            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError));\n@@ -153,1 +167,2 @@\n-                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+                Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] *\n+relativeError));\n@@ -156,2 +171,2 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] * relativeError), \"at index #\" + i);\n@@ -1086,0 +1101,8 @@\n+            withToString(\"double[0.01 + (i \/ (i + 1))]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)0.01 + ((double)i \/ (i + 1)));\n+            }),\n+            withToString(\"double[i -> i % 17 == 0 ? cornerCaseValue(i) : 0.01 + (i \/ (i + 1))]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> i % 17 == 0 ? cornerCaseValue(i) : (double)0.01 + ((double)i \/ (i + 1)));\n+            }),\n@@ -2176,1 +2199,1 @@\n-                DoubleMaxVectorTests::ADDReduce, DoubleMaxVectorTests::ADDReduceAll);\n+                DoubleMaxVectorTests::ADDReduce, DoubleMaxVectorTests::ADDReduceAll, RELATIVE_ROUNDING_ERROR);\n@@ -2222,1 +2245,1 @@\n-                DoubleMaxVectorTests::ADDReduceMasked, DoubleMaxVectorTests::ADDReduceAllMasked);\n+                DoubleMaxVectorTests::ADDReduceMasked, DoubleMaxVectorTests::ADDReduceAllMasked, RELATIVE_ROUNDING_ERROR);\n@@ -2265,1 +2288,1 @@\n-                DoubleMaxVectorTests::MULReduce, DoubleMaxVectorTests::MULReduceAll);\n+                DoubleMaxVectorTests::MULReduce, DoubleMaxVectorTests::MULReduceAll, RELATIVE_ROUNDING_ERROR);\n@@ -2311,1 +2334,1 @@\n-                DoubleMaxVectorTests::MULReduceMasked, DoubleMaxVectorTests::MULReduceAllMasked);\n+                DoubleMaxVectorTests::MULReduceMasked, DoubleMaxVectorTests::MULReduceAllMasked, RELATIVE_ROUNDING_ERROR);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorTests.java","additions":35,"deletions":12,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorLoadStoreTests.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -63,0 +63,2 @@\n+    \/\/ for floating point reduction ops that may introduce rounding errors\n+    private static final float RELATIVE_ROUNDING_ERROR = (float)0.000001;\n@@ -122,0 +124,6 @@\n+        assertReductionArraysEquals(r, rc, a, f, fa, (float)0.0);\n+    }\n+\n+    static void assertReductionArraysEquals(float[] r, float rc, float[] a,\n+                                            FReductionOp f, FReductionAllOp fa,\n+                                            float relativeError) {\n@@ -124,1 +132,1 @@\n-            Assert.assertEquals(rc, fa.apply(a));\n+            Assert.assertEquals(rc, fa.apply(a), Math.abs(rc * relativeError));\n@@ -126,1 +134,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                Assert.assertEquals(r[i], f.apply(a, i), Math.abs(r[i] * relativeError));\n@@ -129,2 +137,2 @@\n-            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            Assert.assertEquals(rc, fa.apply(a), Math.abs(rc * relativeError), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i), Math.abs(r[i] * relativeError), \"at index #\" + i);\n@@ -144,0 +152,6 @@\n+        assertReductionArraysEqualsMasked(r, rc, a, mask, f, fa, (float)0.0);\n+    }\n+\n+    static void assertReductionArraysEqualsMasked(float[] r, float rc, float[] a, boolean[] mask,\n+                                            FReductionMaskedOp f, FReductionAllMaskedOp fa,\n+                                            float relativeError) {\n@@ -146,1 +160,1 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask));\n+            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError));\n@@ -148,1 +162,2 @@\n-                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+                Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] *\n+relativeError));\n@@ -151,2 +166,2 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] * relativeError), \"at index #\" + i);\n@@ -1092,0 +1107,8 @@\n+            withToString(\"float[0.01 + (i \/ (i + 1))]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)0.01 + ((float)i \/ (i + 1)));\n+            }),\n+            withToString(\"float[i -> i % 17 == 0 ? cornerCaseValue(i) : 0.01 + (i \/ (i + 1))]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> i % 17 == 0 ? cornerCaseValue(i) : (float)0.01 + ((float)i \/ (i + 1)));\n+            }),\n@@ -2182,1 +2205,1 @@\n-                Float128VectorTests::ADDReduce, Float128VectorTests::ADDReduceAll);\n+                Float128VectorTests::ADDReduce, Float128VectorTests::ADDReduceAll, RELATIVE_ROUNDING_ERROR);\n@@ -2228,1 +2251,1 @@\n-                Float128VectorTests::ADDReduceMasked, Float128VectorTests::ADDReduceAllMasked);\n+                Float128VectorTests::ADDReduceMasked, Float128VectorTests::ADDReduceAllMasked, RELATIVE_ROUNDING_ERROR);\n@@ -2271,1 +2294,1 @@\n-                Float128VectorTests::MULReduce, Float128VectorTests::MULReduceAll);\n+                Float128VectorTests::MULReduce, Float128VectorTests::MULReduceAll, RELATIVE_ROUNDING_ERROR);\n@@ -2317,1 +2340,1 @@\n-                Float128VectorTests::MULReduceMasked, Float128VectorTests::MULReduceAllMasked);\n+                Float128VectorTests::MULReduceMasked, Float128VectorTests::MULReduceAllMasked, RELATIVE_ROUNDING_ERROR);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorTests.java","additions":35,"deletions":12,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorLoadStoreTests.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -63,0 +63,2 @@\n+    \/\/ for floating point reduction ops that may introduce rounding errors\n+    private static final float RELATIVE_ROUNDING_ERROR = (float)0.000001;\n@@ -122,0 +124,6 @@\n+        assertReductionArraysEquals(r, rc, a, f, fa, (float)0.0);\n+    }\n+\n+    static void assertReductionArraysEquals(float[] r, float rc, float[] a,\n+                                            FReductionOp f, FReductionAllOp fa,\n+                                            float relativeError) {\n@@ -124,1 +132,1 @@\n-            Assert.assertEquals(rc, fa.apply(a));\n+            Assert.assertEquals(rc, fa.apply(a), Math.abs(rc * relativeError));\n@@ -126,1 +134,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                Assert.assertEquals(r[i], f.apply(a, i), Math.abs(r[i] * relativeError));\n@@ -129,2 +137,2 @@\n-            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            Assert.assertEquals(rc, fa.apply(a), Math.abs(rc * relativeError), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i), Math.abs(r[i] * relativeError), \"at index #\" + i);\n@@ -144,0 +152,6 @@\n+        assertReductionArraysEqualsMasked(r, rc, a, mask, f, fa, (float)0.0);\n+    }\n+\n+    static void assertReductionArraysEqualsMasked(float[] r, float rc, float[] a, boolean[] mask,\n+                                            FReductionMaskedOp f, FReductionAllMaskedOp fa,\n+                                            float relativeError) {\n@@ -146,1 +160,1 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask));\n+            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError));\n@@ -148,1 +162,2 @@\n-                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+                Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] *\n+relativeError));\n@@ -151,2 +166,2 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] * relativeError), \"at index #\" + i);\n@@ -1092,0 +1107,8 @@\n+            withToString(\"float[0.01 + (i \/ (i + 1))]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)0.01 + ((float)i \/ (i + 1)));\n+            }),\n+            withToString(\"float[i -> i % 17 == 0 ? cornerCaseValue(i) : 0.01 + (i \/ (i + 1))]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> i % 17 == 0 ? cornerCaseValue(i) : (float)0.01 + ((float)i \/ (i + 1)));\n+            }),\n@@ -2182,1 +2205,1 @@\n-                Float256VectorTests::ADDReduce, Float256VectorTests::ADDReduceAll);\n+                Float256VectorTests::ADDReduce, Float256VectorTests::ADDReduceAll, RELATIVE_ROUNDING_ERROR);\n@@ -2228,1 +2251,1 @@\n-                Float256VectorTests::ADDReduceMasked, Float256VectorTests::ADDReduceAllMasked);\n+                Float256VectorTests::ADDReduceMasked, Float256VectorTests::ADDReduceAllMasked, RELATIVE_ROUNDING_ERROR);\n@@ -2271,1 +2294,1 @@\n-                Float256VectorTests::MULReduce, Float256VectorTests::MULReduceAll);\n+                Float256VectorTests::MULReduce, Float256VectorTests::MULReduceAll, RELATIVE_ROUNDING_ERROR);\n@@ -2317,1 +2340,1 @@\n-                Float256VectorTests::MULReduceMasked, Float256VectorTests::MULReduceAllMasked);\n+                Float256VectorTests::MULReduceMasked, Float256VectorTests::MULReduceAllMasked, RELATIVE_ROUNDING_ERROR);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorTests.java","additions":35,"deletions":12,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorLoadStoreTests.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -63,0 +63,2 @@\n+    \/\/ for floating point reduction ops that may introduce rounding errors\n+    private static final float RELATIVE_ROUNDING_ERROR = (float)0.000001;\n@@ -122,0 +124,6 @@\n+        assertReductionArraysEquals(r, rc, a, f, fa, (float)0.0);\n+    }\n+\n+    static void assertReductionArraysEquals(float[] r, float rc, float[] a,\n+                                            FReductionOp f, FReductionAllOp fa,\n+                                            float relativeError) {\n@@ -124,1 +132,1 @@\n-            Assert.assertEquals(rc, fa.apply(a));\n+            Assert.assertEquals(rc, fa.apply(a), Math.abs(rc * relativeError));\n@@ -126,1 +134,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                Assert.assertEquals(r[i], f.apply(a, i), Math.abs(r[i] * relativeError));\n@@ -129,2 +137,2 @@\n-            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            Assert.assertEquals(rc, fa.apply(a), Math.abs(rc * relativeError), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i), Math.abs(r[i] * relativeError), \"at index #\" + i);\n@@ -144,0 +152,6 @@\n+        assertReductionArraysEqualsMasked(r, rc, a, mask, f, fa, (float)0.0);\n+    }\n+\n+    static void assertReductionArraysEqualsMasked(float[] r, float rc, float[] a, boolean[] mask,\n+                                            FReductionMaskedOp f, FReductionAllMaskedOp fa,\n+                                            float relativeError) {\n@@ -146,1 +160,1 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask));\n+            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError));\n@@ -148,1 +162,2 @@\n-                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+                Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] *\n+relativeError));\n@@ -151,2 +166,2 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] * relativeError), \"at index #\" + i);\n@@ -1092,0 +1107,8 @@\n+            withToString(\"float[0.01 + (i \/ (i + 1))]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)0.01 + ((float)i \/ (i + 1)));\n+            }),\n+            withToString(\"float[i -> i % 17 == 0 ? cornerCaseValue(i) : 0.01 + (i \/ (i + 1))]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> i % 17 == 0 ? cornerCaseValue(i) : (float)0.01 + ((float)i \/ (i + 1)));\n+            }),\n@@ -2182,1 +2205,1 @@\n-                Float512VectorTests::ADDReduce, Float512VectorTests::ADDReduceAll);\n+                Float512VectorTests::ADDReduce, Float512VectorTests::ADDReduceAll, RELATIVE_ROUNDING_ERROR);\n@@ -2228,1 +2251,1 @@\n-                Float512VectorTests::ADDReduceMasked, Float512VectorTests::ADDReduceAllMasked);\n+                Float512VectorTests::ADDReduceMasked, Float512VectorTests::ADDReduceAllMasked, RELATIVE_ROUNDING_ERROR);\n@@ -2271,1 +2294,1 @@\n-                Float512VectorTests::MULReduce, Float512VectorTests::MULReduceAll);\n+                Float512VectorTests::MULReduce, Float512VectorTests::MULReduceAll, RELATIVE_ROUNDING_ERROR);\n@@ -2317,1 +2340,1 @@\n-                Float512VectorTests::MULReduceMasked, Float512VectorTests::MULReduceAllMasked);\n+                Float512VectorTests::MULReduceMasked, Float512VectorTests::MULReduceAllMasked, RELATIVE_ROUNDING_ERROR);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorTests.java","additions":35,"deletions":12,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorLoadStoreTests.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -63,0 +63,2 @@\n+    \/\/ for floating point reduction ops that may introduce rounding errors\n+    private static final float RELATIVE_ROUNDING_ERROR = (float)0.000001;\n@@ -122,0 +124,6 @@\n+        assertReductionArraysEquals(r, rc, a, f, fa, (float)0.0);\n+    }\n+\n+    static void assertReductionArraysEquals(float[] r, float rc, float[] a,\n+                                            FReductionOp f, FReductionAllOp fa,\n+                                            float relativeError) {\n@@ -124,1 +132,1 @@\n-            Assert.assertEquals(rc, fa.apply(a));\n+            Assert.assertEquals(rc, fa.apply(a), Math.abs(rc * relativeError));\n@@ -126,1 +134,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                Assert.assertEquals(r[i], f.apply(a, i), Math.abs(r[i] * relativeError));\n@@ -129,2 +137,2 @@\n-            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            Assert.assertEquals(rc, fa.apply(a), Math.abs(rc * relativeError), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i), Math.abs(r[i] * relativeError), \"at index #\" + i);\n@@ -144,0 +152,6 @@\n+        assertReductionArraysEqualsMasked(r, rc, a, mask, f, fa, (float)0.0);\n+    }\n+\n+    static void assertReductionArraysEqualsMasked(float[] r, float rc, float[] a, boolean[] mask,\n+                                            FReductionMaskedOp f, FReductionAllMaskedOp fa,\n+                                            float relativeError) {\n@@ -146,1 +160,1 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask));\n+            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError));\n@@ -148,1 +162,2 @@\n-                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+                Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] *\n+relativeError));\n@@ -151,2 +166,2 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] * relativeError), \"at index #\" + i);\n@@ -1092,0 +1107,8 @@\n+            withToString(\"float[0.01 + (i \/ (i + 1))]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)0.01 + ((float)i \/ (i + 1)));\n+            }),\n+            withToString(\"float[i -> i % 17 == 0 ? cornerCaseValue(i) : 0.01 + (i \/ (i + 1))]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> i % 17 == 0 ? cornerCaseValue(i) : (float)0.01 + ((float)i \/ (i + 1)));\n+            }),\n@@ -2182,1 +2205,1 @@\n-                Float64VectorTests::ADDReduce, Float64VectorTests::ADDReduceAll);\n+                Float64VectorTests::ADDReduce, Float64VectorTests::ADDReduceAll, RELATIVE_ROUNDING_ERROR);\n@@ -2228,1 +2251,1 @@\n-                Float64VectorTests::ADDReduceMasked, Float64VectorTests::ADDReduceAllMasked);\n+                Float64VectorTests::ADDReduceMasked, Float64VectorTests::ADDReduceAllMasked, RELATIVE_ROUNDING_ERROR);\n@@ -2271,1 +2294,1 @@\n-                Float64VectorTests::MULReduce, Float64VectorTests::MULReduceAll);\n+                Float64VectorTests::MULReduce, Float64VectorTests::MULReduceAll, RELATIVE_ROUNDING_ERROR);\n@@ -2317,1 +2340,1 @@\n-                Float64VectorTests::MULReduceMasked, Float64VectorTests::MULReduceAllMasked);\n+                Float64VectorTests::MULReduceMasked, Float64VectorTests::MULReduceAllMasked, RELATIVE_ROUNDING_ERROR);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorTests.java","additions":35,"deletions":12,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/FloatMaxVectorLoadStoreTests.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -68,0 +68,2 @@\n+    \/\/ for floating point reduction ops that may introduce rounding errors\n+    private static final float RELATIVE_ROUNDING_ERROR = (float)0.000001;\n@@ -127,0 +129,6 @@\n+        assertReductionArraysEquals(r, rc, a, f, fa, (float)0.0);\n+    }\n+\n+    static void assertReductionArraysEquals(float[] r, float rc, float[] a,\n+                                            FReductionOp f, FReductionAllOp fa,\n+                                            float relativeError) {\n@@ -129,1 +137,1 @@\n-            Assert.assertEquals(rc, fa.apply(a));\n+            Assert.assertEquals(rc, fa.apply(a), Math.abs(rc * relativeError));\n@@ -131,1 +139,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                Assert.assertEquals(r[i], f.apply(a, i), Math.abs(r[i] * relativeError));\n@@ -134,2 +142,2 @@\n-            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            Assert.assertEquals(rc, fa.apply(a), Math.abs(rc * relativeError), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i), Math.abs(r[i] * relativeError), \"at index #\" + i);\n@@ -149,0 +157,6 @@\n+        assertReductionArraysEqualsMasked(r, rc, a, mask, f, fa, (float)0.0);\n+    }\n+\n+    static void assertReductionArraysEqualsMasked(float[] r, float rc, float[] a, boolean[] mask,\n+                                            FReductionMaskedOp f, FReductionAllMaskedOp fa,\n+                                            float relativeError) {\n@@ -151,1 +165,1 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask));\n+            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError));\n@@ -153,1 +167,2 @@\n-                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+                Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] *\n+relativeError));\n@@ -156,2 +171,2 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] * relativeError), \"at index #\" + i);\n@@ -1097,0 +1112,8 @@\n+            withToString(\"float[0.01 + (i \/ (i + 1))]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)0.01 + ((float)i \/ (i + 1)));\n+            }),\n+            withToString(\"float[i -> i % 17 == 0 ? cornerCaseValue(i) : 0.01 + (i \/ (i + 1))]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> i % 17 == 0 ? cornerCaseValue(i) : (float)0.01 + ((float)i \/ (i + 1)));\n+            }),\n@@ -2187,1 +2210,1 @@\n-                FloatMaxVectorTests::ADDReduce, FloatMaxVectorTests::ADDReduceAll);\n+                FloatMaxVectorTests::ADDReduce, FloatMaxVectorTests::ADDReduceAll, RELATIVE_ROUNDING_ERROR);\n@@ -2233,1 +2256,1 @@\n-                FloatMaxVectorTests::ADDReduceMasked, FloatMaxVectorTests::ADDReduceAllMasked);\n+                FloatMaxVectorTests::ADDReduceMasked, FloatMaxVectorTests::ADDReduceAllMasked, RELATIVE_ROUNDING_ERROR);\n@@ -2276,1 +2299,1 @@\n-                FloatMaxVectorTests::MULReduce, FloatMaxVectorTests::MULReduceAll);\n+                FloatMaxVectorTests::MULReduce, FloatMaxVectorTests::MULReduceAll, RELATIVE_ROUNDING_ERROR);\n@@ -2322,1 +2345,1 @@\n-                FloatMaxVectorTests::MULReduceMasked, FloatMaxVectorTests::MULReduceAllMasked);\n+                FloatMaxVectorTests::MULReduceMasked, FloatMaxVectorTests::MULReduceAllMasked, RELATIVE_ROUNDING_ERROR);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/FloatMaxVectorTests.java","additions":35,"deletions":12,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorLoadStoreTests.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorLoadStoreTests.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorLoadStoreTests.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorLoadStoreTests.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorLoadStoreTests.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorLoadStoreTests.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorLoadStoreTests.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorLoadStoreTests.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorLoadStoreTests.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorLoadStoreTests.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorLoadStoreTests.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorLoadStoreTests.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorLoadStoreTests.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorLoadStoreTests.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorLoadStoreTests.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/VectorReshapeTests.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -6,0 +6,3 @@\n+#if[FP]\n+                $vectorteststype$::[[TEST]]ReduceMasked, $vectorteststype$::[[TEST]]ReduceAllMasked, RELATIVE_ROUNDING_ERROR);\n+#else[FP]\n@@ -7,0 +10,1 @@\n+#end[FP]\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Reduction-Masked-op.template","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -6,0 +6,3 @@\n+#if[FP]\n+                $vectorteststype$::[[TEST]]Reduce, $vectorteststype$::[[TEST]]ReduceAll, RELATIVE_ROUNDING_ERROR);\n+#else[FP]\n@@ -7,0 +10,1 @@\n+#end[FP]\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Reduction-op.template","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -95,0 +95,4 @@\n+#if[FP]\n+    \/\/ for floating point reduction ops that may introduce rounding errors\n+    private static final $type$ RELATIVE_ROUNDING_ERROR = ($type$)0.000001;\n+#end[FP]\n@@ -154,0 +158,3 @@\n+#if[FP]\n+        assertReductionArraysEquals(r, rc, a, f, fa, ($type$)0.0);\n+#else[FP]\n@@ -164,0 +171,1 @@\n+#end[FP]\n@@ -165,0 +173,17 @@\n+#if[FP]\n+\n+    static void assertReductionArraysEquals($type$[] r, $type$ rc, $type$[] a,\n+                                            FReductionOp f, FReductionAllOp fa,\n+                                            $type$ relativeError) {\n+        int i = 0;\n+        try {\n+            Assert.assertEquals(rc, fa.apply(a), Math.abs(rc * relativeError));\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i), Math.abs(r[i] * relativeError));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rc, fa.apply(a), Math.abs(rc * relativeError), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i), Math.abs(r[i] * relativeError), \"at index #\" + i);\n+        }\n+    }\n+#end[FP]\n@@ -176,0 +201,3 @@\n+#if[FP]\n+        assertReductionArraysEqualsMasked(r, rc, a, mask, f, fa, ($type$)0.0);\n+#else[FP]\n@@ -186,0 +214,18 @@\n+#end[FP]\n+    }\n+#if[FP]\n+\n+    static void assertReductionArraysEqualsMasked($type$[] r, $type$ rc, $type$[] a, boolean[] mask,\n+                                            FReductionMaskedOp f, FReductionAllMaskedOp fa,\n+                                            $type$ relativeError) {\n+        int i = 0;\n+        try {\n+            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError));\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] *\n+relativeError));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] * relativeError), \"at index #\" + i);\n+        }\n@@ -187,0 +233,1 @@\n+#end[FP]\n@@ -1150,0 +1197,10 @@\n+#if[FP]\n+            withToString(\"$type$[0.01 + (i \/ (i + 1))]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> ($type$)0.01 + (($type$)i \/ (i + 1)));\n+            }),\n+            withToString(\"$type$[i -> i % 17 == 0 ? cornerCaseValue(i) : 0.01 + (i \/ (i + 1))]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> i % 17 == 0 ? cornerCaseValue(i) : ($type$)0.01 + (($type$)i \/ (i + 1)));\n+            }),\n+#end[FP]\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-header.template","additions":57,"deletions":0,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/X-LoadStoreTest.java.template","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n-        output.shouldContain(\"extends jdk\/jfr\/events\/AbstractJDKEvent\");\n+        output.shouldContain(\"superclass: jdk\/jfr\/events\/AbstractJDKEvent\");\n","filename":"test\/jdk\/jdk\/jfr\/jvm\/TestEventWriterLog.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -47,2 +47,2 @@\n-                \"jdk.internal.vm.compiler\",\n-                \"jdk.internal.vm.compiler.management\");\n+                \"jdk.graal.compiler\",\n+                \"jdk.graal.compiler.management\");\n","filename":"test\/jdk\/jdk\/modules\/etc\/UpgradeableModules.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -355,0 +355,50 @@\n+\/*\n+ * @test id=affirmtrustcommercialca\n+ * @bug 8040012\n+ * @summary Interoperability tests with AffirmTrust Commercial CA\n+ * @library \/test\/lib\n+ * @build jtreg.SkippedException ValidatePathWithURL CAInterop\n+ * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop affirmtrustcommercialca OCSP\n+ * @run main\/othervm -Djava.security.debug=certpath CAInterop affirmtrustcommercialca CRL\n+ *\/\n+\n+\/*\n+ * @test id=affirmtrustnetworkingca\n+ * @bug 8040012\n+ * @summary Interoperability tests with AffirmTrust Networking CA\n+ * @library \/test\/lib\n+ * @build jtreg.SkippedException ValidatePathWithURL CAInterop\n+ * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop affirmtrustnetworkingca OCSP\n+ * @run main\/othervm -Djava.security.debug=certpath CAInterop affirmtrustnetworkingca CRL\n+ *\/\n+\n+\/*\n+ * @test id=affirmtrustpremiumca\n+ * @bug 8040012\n+ * @summary Interoperability tests with AffirmTrust Premium CA\n+ * @library \/test\/lib\n+ * @build jtreg.SkippedException ValidatePathWithURL CAInterop\n+ * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop affirmtrustpremiumca OCSP\n+ * @run main\/othervm -Djava.security.debug=certpath CAInterop affirmtrustpremiumca CRL\n+ *\/\n+\n+\/*\n+ * @test id=affirmtrustpremiumeccca\n+ * @bug 8040012\n+ * @summary Interoperability tests with AffirmTrust Premium ECC CA\n+ * @library \/test\/lib\n+ * @build jtreg.SkippedException ValidatePathWithURL CAInterop\n+ * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop affirmtrustpremiumeccca OCSP\n+ * @run main\/othervm -Djava.security.debug=certpath CAInterop affirmtrustpremiumeccca CRL\n+ *\/\n+\n+\/*\n+ * @test id=teliarootcav2\n+ * @bug 8317373\n+ * @summary Interoperability tests with Telia Root CA V2\n+ * @library \/test\/lib\n+ * @build jtreg.SkippedException ValidatePathWithURL CAInterop\n+ * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop teliarootcav2 OCSP\n+ * @run main\/othervm -Djava.security.debug=certpath CAInterop teliarootcav2 CRL\n+ *\/\n+\n@@ -482,0 +532,18 @@\n+            \/\/ These are listed at https:\/\/www.affirmtrust.com\/resources\/\n+            case \"affirmtrustcommercialca\" ->\n+                    new CATestURLs(\"https:\/\/validcommercial.affirmtrust.com\",\n+                            \"https:\/\/revokedcommercial.affirmtrust.com\");\n+            case \"affirmtrustnetworkingca\" ->\n+                    new CATestURLs(\"https:\/\/validnetworking.affirmtrust.com\",\n+                            \"https:\/\/revokednetworking.affirmtrust.com\");\n+            case \"affirmtrustpremiumca\" ->\n+                    new CATestURLs(\"https:\/\/validpremium.affirmtrust.com\",\n+                            \"https:\/\/revokedpremium.affirmtrust.com\");\n+            case \"affirmtrustpremiumeccca\" ->\n+                    new CATestURLs(\"https:\/\/validpremiumecc.affirmtrust.com\",\n+                            \"https:\/\/revokedpremiumecc.affirmtrust.com\");\n+\n+            case \"teliarootcav2\" ->\n+                    new CATestURLs(\"https:\/\/juolukka.cover.telia.fi:10600\",\n+                            \"https:\/\/juolukka.cover.telia.fi:10601\");\n+\n","filename":"test\/jdk\/security\/infra\/java\/security\/cert\/CertPathValidator\/certification\/CAInterop.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.*;\n+import java.awt.*;\n+import java.awt.image.*;\n+import java.awt.geom.*;\n+import java.util.Arrays;\n+import javax.imageio.*;\n+\n+\/**\n+ * @test\n+ * @bug 8316741\n+ * @summary Verifies that Marlin renderer's Stroker generates properly joins\n+ * in createStrokedShape()\n+ * @run main TestCreateStrokedShapeJoins\n+ *\/\n+public class TestCreateStrokedShapeJoins {\n+\n+    static final boolean SAVE_IMAGE = false;\n+\n+    private final static int W = 200;\n+\n+    private final static int[] REF_COUNTS = new int[] {4561, 4790, 5499};\n+\n+    public static void main(String[] args) throws Exception {\n+        final int[] test = new int[] {\n+                test(BasicStroke.JOIN_BEVEL),\n+                test(BasicStroke.JOIN_ROUND),\n+                test(BasicStroke.JOIN_MITER)\n+        };\n+\n+        System.out.println(\"test: \" + Arrays.toString(test));\n+        System.out.println(\"ref:  \" + Arrays.toString(REF_COUNTS));\n+\n+        \/\/ check results:\n+        for (int i = 0; i < REF_COUNTS.length; i++) {\n+            if (test[i] != REF_COUNTS[i]) {\n+                throw new RuntimeException(\"Invalid test[\" + i + \"]: \" + test[i] + \" != \" + REF_COUNTS[i]);\n+            }\n+        }\n+    }\n+\n+    private static int test(int join) throws Exception {\n+        final BufferedImage image = new BufferedImage(W, W, BufferedImage.TYPE_INT_ARGB);\n+        final Graphics2D g = image.createGraphics();\n+        try {\n+            g.setPaint(Color.BLACK);\n+            g.fillRect(0, 0, W, W);\n+            g.setPaint(Color.WHITE);\n+            g.setTransform(new AffineTransform(W, 0, 0, W, 0, 0));\n+\n+            final BasicStroke stroke = new BasicStroke(0.15f, 0, join, 10);\n+\n+            final Path2D p = new Path2D.Float();\n+            p.moveTo(0.95f, 0.6f);\n+            p.lineTo(0.5f, 0.5f);\n+            p.lineTo(0.95f, 0.4f);\n+\n+            final Shape outline = stroke.createStrokedShape(p);\n+            g.fill(outline);\n+        } finally {\n+            g.dispose();\n+        }\n+        if (SAVE_IMAGE) {\n+            final File file = new File(\"TestCreateStrokedShapeJoins-\" + join + \".png\");\n+            System.out.println(\"Writing \" + file.getAbsolutePath());\n+            ImageIO.write(image, \"png\", file);\n+        }\n+        int count = 0;\n+\n+        for (int y = 0; y < W; y++) {\n+            for (int x = 0; x < W; x++) {\n+                final int rgb = image.getRGB(x, y);\n+                final int b = rgb & 0xFF;\n+\n+                if (b != 0) {\n+                    count++;\n+                }\n+            }\n+        }\n+        return count;\n+    }\n+}\n","filename":"test\/jdk\/sun\/java2d\/marlin\/TestCreateStrokedShapeJoins.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -101,0 +101,1 @@\n+        System.out.println(\"Terminating all processes\");\n@@ -141,1 +142,1 @@\n-            System.out.println(\"realeaseStarted(\" + ids + \")\");\n+            System.out.println(\"releaseStarted(\" + ids + \")\");\n@@ -152,1 +153,1 @@\n-                    System.out.println(\"RELEASED (id=\" + jp.getId() + \", args=\" + jp.getMainArgsIdentifier() + \")\");\n+                    System.out.println(\"RELEASED started (id=\" + jp.getId() + \", args=\" + jp.getMainArgsIdentifier() + \")\");\n@@ -157,0 +158,1 @@\n+            System.out.println(\"releaseStarted: not a test pid: \" + id);\n@@ -169,1 +171,1 @@\n-                    System.out.println(\"RELEASED (id=\" + jp.getId() + \", args=\" + jp.getMainArgsIdentifier() + \")\");\n+                    System.out.println(\"RELEASED terminated (id=\" + jp.getId() + \", args=\" + jp.getMainArgsIdentifier() + \")\");\n@@ -176,0 +178,2 @@\n+        private static final int ARGS_ATTEMPTS = 3;\n+\n@@ -177,0 +181,1 @@\n+            VmIdentifier vmid = null;\n@@ -178,5 +183,25 @@\n-                VmIdentifier vmid = new VmIdentifier(\"\/\/\" + id.intValue());\n-                MonitoredVm target = host.getMonitoredVm(vmid);\n-                String monitoredArgs = MonitoredVmUtil.mainArgs(target);\n-                if (monitoredArgs != null && monitoredArgs.contains(args)) {\n-                    return true;\n+                vmid = new VmIdentifier(\"\/\/\" + id.intValue());\n+            } catch (URISyntaxException e) {\n+                System.out.println(\"hasMainArgs(\" + id + \"): \" + e);\n+                return false;\n+            }\n+            \/\/ Retry a failing attempt to check arguments for a match,\n+            \/\/ as not recognizing a test process will cause timeout and failure.\n+            for (int i = 0; i < ARGS_ATTEMPTS; i++) {\n+                try {\n+                    MonitoredVm target = host.getMonitoredVm(vmid);\n+                    String monitoredArgs = MonitoredVmUtil.mainArgs(target);\n+                    System.out.println(\"hasMainArgs(\" + id + \"): has main args: '\" + monitoredArgs + \"'\");\n+                    if (monitoredArgs == null || monitoredArgs.equals(\"Unknown\")) {\n+                        System.out.println(\"hasMainArgs(\" + id + \"): retry\" );\n+                        takeNap();\n+                        continue;\n+                    } else if (monitoredArgs.contains(args)) {\n+                        return true;\n+                    } else {\n+                        return false;\n+                    }\n+                } catch (MonitorException e) {\n+                    \/\/ Process probably not running or not ours, e.g.\n+                    \/\/ sun.jvmstat.monitor.MonitorException: Could not attach to PID\n+                    System.out.println(\"hasMainArgs(\" + id + \"): \" + e);\n@@ -184,2 +209,0 @@\n-            } catch (URISyntaxException | MonitorException e) {\n-                \/\/ ok. process probably not running\n@@ -250,8 +273,0 @@\n-        private static void takeNap() {\n-            try {\n-                Thread.sleep(100);\n-            } catch (InterruptedException e) {\n-                \/\/ ignore\n-            }\n-        }\n-\n@@ -311,2 +326,1 @@\n-            String classPath = System.getProperty(\"test.classes\");\n-            ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n+            ProcessBuilder pb = ProcessTools.createTestJvm(\n@@ -314,1 +328,1 @@\n-                \"-cp\", classPath, className, mainArgsIdentifier);\n+                className, mainArgsIdentifier);\n@@ -326,0 +340,8 @@\n+\n+    public static void takeNap() {\n+        try {\n+            Thread.sleep(1000);\n+        } catch (InterruptedException e) {\n+            \/\/ ignore\n+        }\n+    }\n","filename":"test\/jdk\/sun\/jvmstat\/monitor\/MonitoredVm\/MonitorVmStartTerminate.java","additions":44,"deletions":22,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8316964\n+ * @summary check exit code in kinit, klist, and ktab\n+ * @requires os.family == \"windows\"\n+ * @library \/test\/lib\n+ * @modules java.security.jgss\/sun.security.krb5.internal.tools\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.SecurityTools;\n+\n+public class ExitOrNot {\n+\n+    private static final int BAD = Platform.isWindows() ? -1 : 255;\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        \/\/ launching the tool still exits\n+        SecurityTools.kinit(\"u@R p1 p2\")\n+                .shouldHaveExitValue(BAD);\n+\n+        SecurityTools.klist(\"-x\")\n+                .shouldHaveExitValue(BAD);\n+\n+        SecurityTools.ktab(\"-x\")\n+                .shouldHaveExitValue(BAD);\n+\n+        \/\/ calling the run() methods returns the exit code\n+        Asserts.assertEQ(new sun.security.krb5.internal.tools.Kinit()\n+                .run(\"u@R p1 p2\".split(\" \")), -1);\n+        Asserts.assertEQ(new sun.security.krb5.internal.tools.Klist()\n+                .run(\"-x\".split(\" \")), -1);\n+        Asserts.assertEQ(new sun.security.krb5.internal.tools.Ktab()\n+                .run(\"-x\".split(\" \")), -1);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/krb5\/tools\/ExitOrNot.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -31,1 +31,1 @@\n- *      8305975 8304760 8307134 8295894 8314960\n+ *      8305975 8304760 8307134 8295894 8314960 8317373\n@@ -50,1 +50,1 @@\n-    private static final int COUNT = 97;\n+    private static final int COUNT = 98;\n@@ -55,1 +55,1 @@\n-            = \"35:5B:BF:02:F8:3E:34:0D:72:01:6C:EB:10:90:CA:A1:DD:B5:01:EF:D8:0C:5B:26:F5:EF:C5:C5:4B:9D:61:3E\";\n+            = \"B3:2E:91:45:13:9B:CE:AC:65:58:DC:E2:8D:CB:35:3F:44:F5:59:AC:64:35:C0:DE:9F:2D:97:3B:4E:C0:E4:3E\";\n@@ -258,0 +258,2 @@\n+            put(\"teliarootcav2 [jdk]\",\n+                    \"24:2B:69:74:2F:CB:1E:5B:2A:BF:98:89:8B:94:57:21:87:54:4E:5B:4D:99:11:78:65:73:62:1F:6A:74:B8:2C\");\n","filename":"test\/jdk\/sun\/security\/lib\/cacerts\/VerifyCACerts.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -392,0 +392,4 @@\n+                    \/\/ if the exception is thrown before connecting to the\n+                    \/\/ server, the test will time out and the exception will\n+                    \/\/ be lost\/hidden.\n+                    e.printStackTrace(System.err);\n","filename":"test\/jdk\/sun\/security\/pkcs11\/KeyStore\/ClientAuth.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -82,0 +82,5 @@\n+    \/\/ Version of the NSS artifact. This coincides with the version of\n+    \/\/ the NSS version\n+    private static final String NSS_BUNDLE_VERSION = \"3.91\";\n+    private static final String NSSLIB = \"jpg.tests.jdk.nsslib\";\n+\n@@ -810,3 +815,0 @@\n-            case \"Windows-x86-32\":\n-                return fetchNssLib(WINDOWS_X86.class);\n-\n@@ -819,0 +821,3 @@\n+            case \"MacOSX-aarch64-64\":\n+                return fetchNssLib(MACOSX_AARCH64.class);\n+\n@@ -822,0 +827,3 @@\n+            case \"Linux-aarch64-64\":\n+                return fetchNssLib(LINUX_AARCH64.class);\n+\n@@ -831,2 +839,2 @@\n-                    .findAny().get().getValue() + File.separator + \"nsslib\"\n-                    + File.separator;\n+                    .findAny().get().getValue() + File.separator + \"nss\"\n+                    + File.separator + \"lib\" + File.separator;\n@@ -934,1 +942,1 @@\n-            organization = \"jpg.tests.jdk.nsslib\",\n+            organization = NSSLIB,\n@@ -936,1 +944,1 @@\n-            revision = \"3.46-VS2017\",\n+            revision = NSS_BUNDLE_VERSION,\n@@ -942,3 +950,3 @@\n-            organization = \"jpg.tests.jdk.nsslib\",\n-            name = \"nsslib-windows_x86\",\n-            revision = \"3.46-VS2017\",\n+            organization = NSSLIB,\n+            name = \"nsslib-macosx_x64\",\n+            revision = NSS_BUNDLE_VERSION,\n@@ -946,1 +954,1 @@\n-    private static class WINDOWS_X86 {\n+    private static class MACOSX_X64 {\n@@ -950,3 +958,3 @@\n-            organization = \"jpg.tests.jdk.nsslib\",\n-            name = \"nsslib-macosx_x64\",\n-            revision = \"3.46\",\n+            organization = NSSLIB,\n+            name = \"nsslib-macosx_aarch64\",\n+            revision = NSS_BUNDLE_VERSION,\n@@ -954,1 +962,1 @@\n-    private static class MACOSX_X64 {\n+    private static class MACOSX_AARCH64 {\n@@ -958,1 +966,1 @@\n-            organization = \"jpg.tests.jdk.nsslib\",\n+            organization = NSSLIB,\n@@ -960,1 +968,1 @@\n-            revision = \"3.46\",\n+            revision = NSS_BUNDLE_VERSION,\n@@ -964,0 +972,9 @@\n+\n+    @Artifact(\n+            organization = NSSLIB,\n+            name = \"nsslib-linux_aarch64\",\n+            revision = NSS_BUNDLE_VERSION,\n+            extension = \"zip\"\n+    )\n+    private static class LINUX_AARCH64{\n+    }\n","filename":"test\/jdk\/sun\/security\/pkcs11\/PKCS11Test.java","additions":34,"deletions":17,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8316964\n+ * @summary check exit code in jarsigner and keytool\n+ * @library \/test\/lib\n+ * @modules java.base\/sun.security.tools.keytool\n+ *          jdk.jartool\/sun.security.tools.jarsigner\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.SecurityTools;\n+\n+public class ExitOrNot {\n+    public static void main(String[] args) throws Exception {\n+\n+        \/\/ launching the tool still exits\n+        SecurityTools.jarsigner(\"1 2 3\")\n+                .shouldHaveExitValue(1);\n+        SecurityTools.keytool(\"-x\")\n+                .shouldHaveExitValue(1);\n+\n+        \/\/ calling the run() methods no longer\n+        Asserts.assertEQ(new sun.security.tools.jarsigner.Main()\n+                    .run(\"1 2 3\".split(\" \")), 1);\n+\n+        Asserts.assertEQ(new sun.security.tools.keytool.Main()\n+                    .run(\"-x\".split(\" \"), System.out), 1);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/tools\/jarsigner\/ExitOrNot.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -5243,1 +5243,1 @@\n-# bug 6507067\n+# bug 6507067 8317979\n@@ -5245,1 +5245,1 @@\n-TimeZoneNames\/zh_TW\/Asia\\\/Taipei\/2=\n+TimeZoneNames\/zh_TW\/Asia\\\/Taipei\/2=CST\n","filename":"test\/jdk\/sun\/text\/resources\/LocaleData.cldr","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n- *      8301206 8303472\n+ *      8301206 8303472 8317979\n","filename":"test\/jdk\/sun\/text\/resources\/LocaleDataTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n- * and checks that sun.tools.ProcessHelper.getMainClass(pid) method returns a correct main class.                                                                                                                               return a .\n+ * and checks that sun.tools.ProcessHelper.getMainClass(pid) method returns a correct main class.\n@@ -55,0 +55,1 @@\n+ * @requires vm.flagless\n","filename":"test\/jdk\/sun\/tools\/jcmd\/TestProcessHelper.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,3 +63,2 @@\n-            String[] params = new String[0];;\n-            LingeredApp.startAppExactJvmOpts(app1, params);\n-            LingeredApp.startAppExactJvmOpts(app2, params);\n+            LingeredApp.startApp(app1);\n+            LingeredApp.startApp(app2);\n@@ -92,3 +91,2 @@\n-            String[] params = new String[0];\n-            LingeredApp.startAppExactJvmOpts(app1, params);\n-            LingeredApp.startAppExactJvmOpts(app2, params);\n+            LingeredApp.startApp(app1);\n+            LingeredApp.startApp(app2);\n","filename":"test\/jdk\/sun\/tools\/jinfo\/JInfoTest.java","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+ * @requires vm.flagless\n@@ -63,3 +64,1 @@\n-        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n-            \"-cp\",\n-            System.getProperty(\"test.class.path\"),\n+        ProcessBuilder pb = ProcessTools.createTestJvm(\n","filename":"test\/jdk\/sun\/tools\/jstat\/JStatInterval.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -199,2 +199,2 @@\n-    \/\/ exported to jdk.internal.vm.compiler\n-    private static Set<String> EXCLUDED_MODULES = Set.of(\"jdk.internal.vm.compiler\");\n+    \/\/ exported to jdk.graal.compiler\n+    private static Set<String> EXCLUDED_MODULES = Set.of(\"jdk.graal.compiler\");\n","filename":"test\/jdk\/tools\/jimage\/VerifyJimage.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -105,0 +105,1 @@\n+                \"%define _build_id_links none\",\n","filename":"test\/jdk\/tools\/jpackage\/linux\/LinuxResourceTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n- * @run main\/othervm -Xmx512m jdk.jpackage.test.Main\n+ * @run main\/othervm\/timeout=720 -Xmx512m jdk.jpackage.test.Main\n@@ -64,3 +64,9 @@\n-    @Parameter({\"true\", \"0\"}) \/\/ ({\"sign or not\", \"certificate index\"})\n-    @Parameter({\"true\", \"1\"})\n-    @Parameter({\"false\", \"-1\"})\n+    \/\/ ({\"sign or not\", \"signing-key or sign-identity\", \"certificate index\"})\n+    \/\/ Sign, signing-key and ASCII certificate\n+    @Parameter({\"true\", \"true\", SigningBase.ASCII_INDEX})\n+    \/\/ Sign, signing-key and UNICODE certificate\n+    @Parameter({\"true\", \"true\", SigningBase.UNICODE_INDEX})\n+    \/\/ Sign, signing-indentity and UNICODE certificate\n+    @Parameter({\"true\", \"false\", SigningBase.UNICODE_INDEX})\n+    \/\/ Unsigned\n+    @Parameter({\"false\", \"true\", \"-1\"})\n@@ -69,1 +75,2 @@\n-        int certIndex = Integer.parseInt(testArgs[1]);\n+        boolean signingKey = Boolean.parseBoolean(testArgs[1]);\n+        int certIndex = Integer.parseInt(testArgs[2]);\n@@ -76,2 +83,0 @@\n-                    \"--mac-signing-key-user-name\",\n-                    SigningBase.getDevName(certIndex),\n@@ -80,0 +85,7 @@\n+            if (signingKey) {\n+                cmd.addArguments(\"--mac-signing-key-user-name\",\n+                        SigningBase.getDevName(certIndex));\n+            } else {\n+                cmd.addArguments(\"--mac-app-image-sign-identity\",\n+                        SigningBase.getAppCert(certIndex));\n+            }\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/SigningAppImageTest.java","additions":19,"deletions":7,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n- * @run main\/othervm\/timeout=360 -Xmx512m jdk.jpackage.test.Main\n+ * @run main\/othervm\/timeout=720 -Xmx512m jdk.jpackage.test.Main\n@@ -65,3 +65,11 @@\n-    @Parameter(\"true\")\n-    @Parameter(\"false\")\n-    public void test(boolean signAppImage) throws Exception {\n+    \/\/ ({\"sign or not\", \"signing-key or sign-identity\"})\n+    \/\/ Sign and signing-key\n+    @Parameter({\"true\", \"true\"})\n+    \/\/ Sign and sign-identity\n+    @Parameter({\"true\", \"false\"})\n+    \/\/ Unsigned\n+    @Parameter({\"false\", \"true\"})\n+    public void test(String... testArgs) throws Exception {\n+        boolean signAppImage = Boolean.parseBoolean(testArgs[0]);\n+        boolean signingKey = Boolean.parseBoolean(testArgs[1]);\n+\n@@ -79,2 +87,0 @@\n-                    \"--mac-signing-key-user-name\",\n-                    SigningBase.getDevName(SigningBase.DEFAULT_INDEX),\n@@ -83,0 +89,7 @@\n+            if (signingKey) {\n+                appImageCmd.addArguments(\"--mac-signing-key-user-name\",\n+                    SigningBase.getDevName(SigningBase.DEFAULT_INDEX));\n+            } else {\n+                appImageCmd.addArguments(\"--mac-app-image-sign-identity\",\n+                    SigningBase.getAppCert(SigningBase.DEFAULT_INDEX));\n+            }\n@@ -100,2 +113,0 @@\n-            .addArguments(\"--mac-signing-key-user-name\",\n-                SigningBase.getDevName(SigningBase.DEFAULT_INDEX))\n@@ -103,0 +114,7 @@\n+        if (signingKey) {\n+            cmd.addArguments(\"--mac-signing-key-user-name\",\n+                SigningBase.getDevName(SigningBase.DEFAULT_INDEX));\n+        } else {\n+            cmd.addArguments(\"--mac-app-image-sign-identity\",\n+                SigningBase.getAppCert(SigningBase.DEFAULT_INDEX));\n+        }\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/SigningAppImageTwoStepsTest.java","additions":26,"deletions":8,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.util.Collection;\n+import java.util.List;\n+import jdk.jpackage.test.Annotations.Parameters;\n+import jdk.jpackage.test.Annotations.Test;\n+import jdk.jpackage.test.JPackageCommand;\n+import jdk.jpackage.test.TKit;\n+\n+\/*\n+ * @test\n+ * @summary Test jpackage signing options errors\n+ * @library ..\/helpers\n+ * @build SigningOptionsTest\n+ * @modules jdk.jpackage\/jdk.jpackage.internal\n+ * @requires (os.family == \"mac\")\n+ * @run main\/othervm\/timeout=360 -Xmx512m jdk.jpackage.test.Main\n+ *  --jpt-run=SigningOptionsTest\n+ *  --jpt-before-run=jdk.jpackage.test.JPackageCommand.useExecutableByDefault\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test jpackage signing options errors\n+ * @library ..\/helpers\n+ * @build SigningOptionsTest\n+ * @modules jdk.jpackage\/jdk.jpackage.internal\n+ * @requires (os.family == \"mac\")\n+ * @run main\/othervm\/timeout=360 -Xmx512m jdk.jpackage.test.Main\n+ *  --jpt-run=SigningOptionsTest\n+ *  --jpt-before-run=jdk.jpackage.test.JPackageCommand.useToolProviderByDefault\n+ *\/\n+\n+public final class SigningOptionsTest {\n+\n+    private final String expectedError;\n+    private final JPackageCommand cmd;\n+\n+    @Parameters\n+    public static Collection input() {\n+        return List.of(new Object[][]{\n+            \/\/ --mac-signing-key-user-name and --mac-app-image-sign-identity\n+            {\"Hello\",\n+                    new String[]{\"--mac-sign\",\n+                                 \"--mac-signing-key-user-name\", \"test-key\",\n+                                 \"--mac-app-image-sign-identity\", \"test-identity\"},\n+                    null,\n+                    \"Mutually exclusive options\"},\n+            \/\/ --mac-signing-key-user-name and --mac-installer-sign-identity\n+            {\"Hello\",\n+                    new String[]{\"--mac-sign\",\n+                                 \"--mac-signing-key-user-name\", \"test-key\",\n+                                 \"--mac-installer-sign-identity\", \"test-identity\"},\n+                    null,\n+                    \"Mutually exclusive options\"},\n+            \/\/ --mac-installer-sign-identity and --type app-image\n+            {\"Hello\",\n+                    new String[]{\"--mac-sign\",\n+                                 \"--mac-installer-sign-identity\", \"test-identity\"},\n+                    null,\n+                    \"Option [--mac-installer-sign-identity] is not valid with type\"},\n+            \/\/ --mac-installer-sign-identity and --type dmg\n+            {\"Hello\",\n+                    new String[]{\"--type\", \"dmg\",\n+                                 \"--mac-sign\",\n+                                 \"--mac-installer-sign-identity\", \"test-identity\"},\n+                    new String[]{\"--type\"},\n+                    \"Option [--mac-installer-sign-identity] is not valid with type\"},\n+        });\n+    }\n+\n+    public SigningOptionsTest(String javaAppDesc, String[] jpackageArgs,\n+                              String[] removeArgs, String expectedError) {\n+        this.expectedError = expectedError;\n+\n+        cmd = JPackageCommand.helloAppImage(javaAppDesc)\n+                .saveConsoleOutput(true).dumpOutput(true);\n+        if (jpackageArgs != null) {\n+            cmd.addArguments(jpackageArgs);\n+        } if (removeArgs != null) {\n+            for (String arg : removeArgs) {\n+                cmd.removeArgumentWithValue(arg);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void test() {\n+        List<String> output = cmd.execute(1).getOutput();\n+        TKit.assertNotNull(output, \"output is null\");\n+        TKit.assertTextStream(expectedError).apply(output.stream());\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/SigningOptionsTest.java","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"},{"patch":"@@ -75,1 +75,1 @@\n-        SigningBase.verifyPkgutil(outputBundle, SigningBase.DEFAULT_INDEX);\n+        SigningBase.verifyPkgutil(outputBundle, true, SigningBase.DEFAULT_INDEX);\n@@ -100,3 +100,11 @@\n-    @Parameter(\"true\")\n-    @Parameter(\"false\")\n-    public static void test(boolean signAppImage) throws Exception {\n+    \/\/ ({\"sign or not\", \"signing-key or sign-identity\"})\n+    \/\/ Sign and signing-key\n+    @Parameter({\"true\", \"true\"})\n+    \/\/ Sign and sign-identity\n+    @Parameter({\"true\", \"false\"})\n+    \/\/ Unsigned\n+    @Parameter({\"false\", \"true\"})\n+    public void test(String... testArgs) throws Exception {\n+        boolean signAppImage = Boolean.parseBoolean(testArgs[0]);\n+        boolean signingKey = Boolean.parseBoolean(testArgs[1]);\n+\n@@ -113,2 +121,1 @@\n-            appImageCmd.addArguments(\"--mac-sign\", \"--mac-signing-key-user-name\",\n-                    SigningBase.getDevName(SigningBase.DEFAULT_INDEX),\n+            appImageCmd.addArguments(\"--mac-sign\",\n@@ -116,0 +123,7 @@\n+            if (signingKey) {\n+                appImageCmd.addArguments(\"--mac-signing-key-user-name\",\n+                    SigningBase.getDevName(SigningBase.DEFAULT_INDEX));\n+            } else {\n+                appImageCmd.addArguments(\"--mac-app-image-sign-identity\",\n+                    SigningBase.getAppCert(SigningBase.DEFAULT_INDEX));\n+            }\n@@ -129,2 +143,0 @@\n-            .addArguments(\"--mac-signing-key-user-name\",\n-                SigningBase.getDevName(SigningBase.DEFAULT_INDEX))\n@@ -132,0 +144,7 @@\n+        if (signingKey) {\n+            appImageSignedCmd.addArguments(\"--mac-signing-key-user-name\",\n+                SigningBase.getDevName(SigningBase.DEFAULT_INDEX));\n+        } else {\n+            appImageSignedCmd.addArguments(\"--mac-app-image-sign-identity\",\n+                SigningBase.getAppCert(SigningBase.DEFAULT_INDEX));\n+        }\n@@ -144,2 +163,0 @@\n-                                \"--mac-signing-key-user-name\",\n-                                SigningBase.getDevName(SigningBase.DEFAULT_INDEX),\n@@ -148,0 +165,7 @@\n+                        if (signingKey) {\n+                           cmd.addArguments(\"--mac-signing-key-user-name\",\n+                               SigningBase.getDevName(SigningBase.DEFAULT_INDEX));\n+                        } else {\n+                            cmd.addArguments(\"--mac-installer-sign-identity\",\n+                                SigningBase.getInstallerCert(SigningBase.DEFAULT_INDEX));\n+                        }\n@@ -154,0 +178,9 @@\n+                .addInitializer(cmd -> {\n+                    if (signAppImage && !signingKey) {\n+                        \/\/ jpackage throws expected error with\n+                        \/\/ --mac-installer-sign-identity and DMG type\n+                        cmd.removeArgument(\"--mac-sign\");\n+                        cmd.removeArgumentWithValue(\"--mac-signing-keychain\");\n+                        cmd.removeArgumentWithValue(\"--mac-installer-sign-identity\");\n+                    }\n+                })\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/SigningPackageFromTwoStepAppImageTest.java","additions":43,"deletions":10,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n- * @run main\/othervm\/timeout=360 -Xmx512m jdk.jpackage.test.Main\n+ * @run main\/othervm\/timeout=720 -Xmx512m jdk.jpackage.test.Main\n@@ -67,0 +67,10 @@\n+    private static boolean isAppImageSigned(JPackageCommand cmd) {\n+        return cmd.hasArgument(\"--mac-signing-key-user-name\") ||\n+               cmd.hasArgument(\"--mac-app-image-sign-identity\");\n+    }\n+\n+    private static boolean isPKGSigned(JPackageCommand cmd) {\n+        return cmd.hasArgument(\"--mac-signing-key-user-name\") ||\n+               cmd.hasArgument(\"--mac-installer-sign-identity\");\n+    }\n+\n@@ -69,2 +79,4 @@\n-        SigningBase.verifyPkgutil(outputBundle, getCertIndex(cmd));\n-        SigningBase.verifySpctl(outputBundle, \"install\", getCertIndex(cmd));\n+        SigningBase.verifyPkgutil(outputBundle, isPKGSigned(cmd), getCertIndex(cmd));\n+        if (isPKGSigned(cmd)) {\n+            SigningBase.verifySpctl(outputBundle, \"install\", getCertIndex(cmd));\n+        }\n@@ -85,3 +97,7 @@\n-                SigningBase.verifyCodesign(launcherPath, true, getCertIndex(cmd));\n-                SigningBase.verifyCodesign(dmgImage, true, getCertIndex(cmd));\n-                SigningBase.verifySpctl(dmgImage, \"exec\", getCertIndex(cmd));\n+                SigningBase.verifyCodesign(launcherPath, isAppImageSigned(cmd),\n+                                           getCertIndex(cmd));\n+                SigningBase.verifyCodesign(dmgImage, isAppImageSigned(cmd),\n+                                           getCertIndex(cmd));\n+                if (isAppImageSigned(cmd)) {\n+                    SigningBase.verifySpctl(dmgImage, \"exec\", getCertIndex(cmd));\n+                }\n@@ -93,2 +109,7 @@\n-        String devName = cmd.getArgumentValue(\"--mac-signing-key-user-name\");\n-        return SigningBase.getDevNameIndex(devName);\n+        if (cmd.hasArgument(\"--mac-signing-key-user-name\")) {\n+            String devName = cmd.getArgumentValue(\"--mac-signing-key-user-name\");\n+            return SigningBase.getDevNameIndex(devName);\n+        } else {\n+            \/\/ Signing-indentity\n+            return Integer.valueOf(SigningBase.UNICODE_INDEX);\n+        }\n@@ -98,3 +119,17 @@\n-    @Parameter(\"0\")\n-    @Parameter(\"1\")\n-    public static void test(int certIndex) throws Exception {\n+    \/\/ (\"signing-key or sign-identity\", \"sign app-image\", \"sign pkg\", \"certificate index\"})\n+    \/\/ Signing-key and ASCII certificate\n+    @Parameter({\"true\", \"true\", \"true\", SigningBase.ASCII_INDEX})\n+    \/\/ Signing-key and UNICODE certificate\n+    @Parameter({\"true\", \"true\", \"true\", SigningBase.UNICODE_INDEX})\n+    \/\/ Signing-indentity and UNICODE certificate\n+    @Parameter({\"false\", \"true\", \"true\", SigningBase.UNICODE_INDEX})\n+    \/\/ Signing-indentity, but sign app-image only and UNICODE certificate\n+    @Parameter({\"false\", \"true\", \"false\", SigningBase.UNICODE_INDEX})\n+    \/\/ Signing-indentity, but sign pkg only and UNICODE certificate\n+    @Parameter({\"false\", \"false\", \"true\", SigningBase.UNICODE_INDEX})\n+    public static void test(String... testArgs) throws Exception {\n+        boolean signingKey = Boolean.parseBoolean(testArgs[0]);\n+        boolean signAppImage = Boolean.parseBoolean(testArgs[1]);\n+        boolean signPKG = Boolean.parseBoolean(testArgs[2]);\n+        int certIndex = Integer.parseInt(testArgs[3]);\n+\n@@ -108,1 +143,0 @@\n-                            \"--mac-signing-key-user-name\", SigningBase.getDevName(certIndex),\n@@ -110,0 +144,13 @@\n+                    if (signingKey) {\n+                        cmd.addArguments(\"--mac-signing-key-user-name\",\n+                                         SigningBase.getDevName(certIndex));\n+                    } else {\n+                        if (signAppImage) {\n+                            cmd.addArguments(\"--mac-app-image-sign-identity\",\n+                                             SigningBase.getAppCert(certIndex));\n+                        }\n+                        if (signPKG) {\n+                            cmd.addArguments(\"--mac-installer-sign-identity\",\n+                                             SigningBase.getInstallerCert(certIndex));\n+                        }\n+                    }\n@@ -114,0 +161,15 @@\n+                .addInitializer(cmd -> {\n+                    if (!signingKey) {\n+                        \/\/ jpackage throws expected error with\n+                        \/\/ --mac-installer-sign-identity and DMG type\n+                        cmd.removeArgumentWithValue(\"--mac-installer-sign-identity\");\n+                        \/\/ In case of not signing app image and DMG we need to\n+                        \/\/ remove signing completely, otherwise we will default\n+                        \/\/ to --mac-signing-key-user-name once\n+                        \/\/ --mac-installer-sign-identity is removed.\n+                        if (!signAppImage) {\n+                            cmd.removeArgumentWithValue(\"--mac-signing-keychain\");\n+                            cmd.removeArgument(\"--mac-sign\");\n+                        }\n+                    }\n+                })\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/SigningPackageTest.java","additions":74,"deletions":12,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -76,1 +76,1 @@\n-        SigningBase.verifyPkgutil(outputBundle, SigningBase.DEFAULT_INDEX);\n+        SigningBase.verifyPkgutil(outputBundle, true, SigningBase.DEFAULT_INDEX);\n@@ -104,4 +104,12 @@\n-    @Parameter(\"true\")\n-    @Parameter(\"false\")\n-    public static void test(boolean signAppImage) throws Exception {\n-        SigningCheck.checkCertificates(0);\n+    \/\/ (Signed, \"signing-key or sign-identity\"})\n+    \/\/ Signed and signing-key\n+    @Parameter({\"true\", \"true\"})\n+    \/\/ Signed and signing-identity\n+    @Parameter({\"true\", \"false\"})\n+    \/\/ Unsigned\n+    @Parameter({\"false\", \"true\"})\n+    public static void test(String... testArgs) throws Exception {\n+        boolean signAppImage = Boolean.parseBoolean(testArgs[0]);\n+        boolean signingKey = Boolean.parseBoolean(testArgs[1]);\n+\n+        SigningCheck.checkCertificates(SigningBase.DEFAULT_INDEX);\n@@ -115,4 +123,9 @@\n-                    .addArguments(\"--mac-signing-key-user-name\",\n-                            SigningBase.getDevName(0))\n-                    .addArguments(\"--mac-signing-keychain\",\n-                            SigningBase.getKeyChain());\n+                       .addArguments(\"--mac-signing-keychain\",\n+                                     SigningBase.getKeyChain());\n+            if (signingKey) {\n+                appImageCmd.addArguments(\"--mac-signing-key-user-name\",\n+                                SigningBase.getDevName(SigningBase.DEFAULT_INDEX));\n+            } else {\n+                appImageCmd.addArguments(\"--mac-app-image-sign-identity\",\n+                                SigningBase.getAppCert(SigningBase.DEFAULT_INDEX));\n+            }\n@@ -129,2 +142,0 @@\n-                                \"--mac-signing-key-user-name\",\n-                                SigningBase.getDevName(0),\n@@ -133,0 +144,7 @@\n+                        if (signingKey) {\n+                            cmd.addArguments(\"--mac-signing-key-user-name\",\n+                                    SigningBase.getDevName(SigningBase.DEFAULT_INDEX));\n+                        } else {\n+                            cmd.addArguments(\"--mac-installer-sign-identity\",\n+                                    SigningBase.getInstallerCert(SigningBase.DEFAULT_INDEX));\n+                        }\n@@ -138,0 +156,11 @@\n+                .addInitializer(cmd -> {\n+                    if (signAppImage && !signingKey) {\n+                        \/\/ jpackage throws expected error with\n+                        \/\/ --mac-installer-sign-identity and DMG type\n+                        cmd.removeArgumentWithValue(\"--mac-installer-sign-identity\");\n+                        \/\/ It will do nothing, but it signals test that app\n+                        \/\/ image itself is signed for verification.\n+                        cmd.addArguments(\"--mac-app-image-sign-identity\",\n+                                SigningBase.getAppCert(SigningBase.DEFAULT_INDEX));\n+                    }\n+                })\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/SigningPackageTwoStepTest.java","additions":40,"deletions":11,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+    public static final String ASCII_INDEX = \"0\";\n+    public static final String UNICODE_INDEX = \"0\";\n@@ -185,1 +187,1 @@\n-    private static List<String> pkgutilResult(Path target) {\n+    private static List<String> pkgutilResult(Path target, boolean signed) {\n@@ -190,1 +192,3 @@\n-                .executeAndGetOutput();\n+                .saveOutput()\n+                .execute(signed ? 0 : 1)\n+                .getOutput();\n@@ -195,1 +199,2 @@\n-    private static void verifyPkgutilResult(List<String> result, int certIndex) {\n+    private static void verifyPkgutilResult(List<String> result, boolean signed,\n+                                            int certIndex) {\n@@ -197,4 +202,9 @@\n-        String lookupString = \"Status: signed by\";\n-        checkString(result, lookupString);\n-        lookupString = \"1. \" + getInstallerCert(certIndex);\n-        checkString(result, lookupString);\n+        if (signed) {\n+            String lookupString = \"Status: signed by\";\n+            checkString(result, lookupString);\n+            lookupString = \"1. \" + getInstallerCert(certIndex);\n+            checkString(result, lookupString);\n+        } else {\n+            String lookupString = \"Status: no signature\";\n+            checkString(result, lookupString);\n+        }\n@@ -231,3 +241,3 @@\n-    public static void verifyPkgutil(Path target, int certIndex) {\n-        List<String> result = pkgutilResult(target);\n-        verifyPkgutilResult(result, certIndex);\n+    public static void verifyPkgutil(Path target, boolean signed, int certIndex) {\n+        List<String> result = pkgutilResult(target, signed);\n+        verifyPkgutilResult(result, signed, certIndex);\n@@ -250,1 +260,1 @@\n-            SigningBase.verifySpctl(appImage, \"exec\", 0);\n+            SigningBase.verifySpctl(appImage, \"exec\", SigningBase.DEFAULT_INDEX);\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/base\/SigningBase.java","additions":21,"deletions":11,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-                    new String[]{\"--mac-sign\", \"--mac-app-store\"},\n+                    new String[]{\"--mac-sign\", \"--mac-app-store\", \"--mac-app-image-sign-identity\", \"test\"},\n","filename":"test\/jdk\/tools\/jpackage\/share\/jdk\/jpackage\/tests\/PredefinedAppImageErrorTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,0 +50,2 @@\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n@@ -52,1 +54,0 @@\n-\n@@ -86,0 +87,4 @@\n+\n+        public void putAll(Map<String, String> map) {\n+            map.entrySet().forEach(e -> put(e.getKey(), () -> e.getValue()));\n+        }\n@@ -138,0 +143,1 @@\n+        map.putAll(xOptFlags()); \/\/ -Xmx4g -> @requires vm.opt.x.Xmx == \"4g\" )\n@@ -605,3 +611,4 @@\n-        ProcessBuilder pb = new ProcessBuilder(Container.ENGINE_COMMAND, \"ps\");\n-        Map<String, String> logFileNames = redirectOutputToLogFile(\"checkDockerSupport(): <container> ps\",\n-                                                      pb, \"container-ps\");\n+        ProcessBuilder pb = new ProcessBuilder(\"which\", Container.ENGINE_COMMAND);\n+        Map<String, String> logFileNames =\n+            redirectOutputToLogFile(\"checkDockerSupport(): which \" + Container.ENGINE_COMMAND,\n+                                                      pb, \"which-container\");\n@@ -664,3 +671,1 @@\n-        List<String> allFlags = new ArrayList<String>();\n-        Collections.addAll(allFlags, System.getProperty(\"test.vm.opts\", \"\").trim().split(\"\\\\s+\"));\n-        Collections.addAll(allFlags, System.getProperty(\"test.java.opts\", \"\").trim().split(\"\\\\s+\"));\n+        List<String> allFlags = allFlags().toList();\n@@ -713,0 +718,25 @@\n+    private Stream<String> allFlags() {\n+        return Stream.of((System.getProperty(\"test.vm.opts\", \"\") + \" \" + System.getProperty(\"test.java.opts\", \"\")).trim().split(\"\\\\s+\"));\n+    }\n+\n+    \/**\n+     * Parses extra options, options that start with -X excluding the\n+     * bare -X option (as it is not considered an extra option).\n+     * Ignores extra options not starting with -X\n+     *\n+     * This could be improved to handle extra options not starting\n+     * with -X as well as \"standard\" options.\n+     *\/\n+    private Map<String, String> xOptFlags() {\n+        return allFlags()\n+            .filter(s -> s.startsWith(\"-X\") && !s.startsWith(\"-XX:\") && !s.equals(\"-X\"))\n+            .map(s -> s.replaceFirst(\"-\", \"\"))\n+            .map(flag -> flag.splitWithDelimiters(\"[:0123456789]\", 2))\n+            .collect(Collectors.toMap(a -> \"vm.opt.x.\" + a[0],\n+                                      a -> (a.length == 1)\n+                                      ? \"true\" \/\/ -Xnoclassgc\n+                                      : (a[1].equals(\":\")\n+                                         ? a[2]            \/\/ [\"-XshowSettings\", \":\", \"system\"]\n+                                         : a[1] + a[2]))); \/\/ [\"-Xmx\", \"4\", \"g\"]\n+    }\n+\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":37,"deletions":7,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -69,0 +69,1 @@\n+                    <div class=\"horizontal-scroll\">\n@@ -135,0 +136,1 @@\n+                    <div class=\"horizontal-scroll\">\n@@ -136,0 +138,1 @@\n+                    <\/div>\n@@ -141,0 +144,1 @@\n+                    <div class=\"horizontal-scroll\">\n@@ -146,0 +150,1 @@\n+                    <\/div>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testAnnotationTypes\/TestAnnotationTypes.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -196,1 +196,1 @@\n-        checkOutput(\"pkg\/TestClass.html\", false,\n+        checkOutput(\"pkg\/TestClass.html\", true,\n@@ -208,1 +208,1 @@\n-                    <div class=\"deprecation-comment\">class_test4 passes. This is the second sentence\\\n+                    <div class=\"deprecation-comment\">class_test5 passes. This is the second sentence\\\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testDeprecatedDocs\/TestDeprecatedDocs.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -280,0 +280,1 @@\n+                <div class=\"horizontal-scroll\">\n@@ -339,0 +340,1 @@\n+                <div class=\"horizontal-scroll\">\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testDirectedInheritance\/TestDirectedInheritance.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -389,0 +389,1 @@\n+                    <\/div>\n@@ -395,0 +396,1 @@\n+                    <\/div>\n@@ -404,0 +406,1 @@\n+                    <\/div>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testHtmlDefinitionListTag\/TestHtmlDefinitionListTag.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,1 +79,1 @@\n-                    <header role=\"banner\" class=\"flex-header\">\n+                    <header role=\"banner\">\n@@ -109,1 +109,1 @@\n-                    <header role=\"banner\" class=\"flex-header\">\n+                    <header role=\"banner\">\n@@ -147,1 +147,1 @@\n-                    <header role=\"banner\" class=\"flex-header\">\n+                    <header role=\"banner\">\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testHtmlLandmarkRegions\/TestHtmlLandmarkRegions.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-                    <header role=\"banner\" class=\"flex-header\">\n+                    <header role=\"banner\">\n@@ -102,1 +102,1 @@\n-                    <header role=\"banner\" class=\"flex-header\">\n+                    <header role=\"banner\">\n@@ -134,1 +134,1 @@\n-                    <header role=\"banner\" class=\"flex-header\">\n+                    <header role=\"banner\">\n@@ -167,1 +167,1 @@\n-                    <header role=\"banner\" class=\"flex-header\">\n+                    <header role=\"banner\">\n@@ -188,1 +188,1 @@\n-                    <header role=\"banner\" class=\"flex-header\">\n+                    <header role=\"banner\">\n@@ -217,1 +217,1 @@\n-                    <header role=\"banner\" class=\"flex-header\">\n+                    <header role=\"banner\">\n@@ -236,1 +236,1 @@\n-                    <header role=\"banner\" class=\"flex-header\">\n+                    <header role=\"banner\">\n@@ -260,1 +260,1 @@\n-                    <header role=\"banner\" class=\"flex-header\">\n+                    <header role=\"banner\">\n@@ -295,1 +295,1 @@\n-                    <header role=\"banner\" class=\"flex-header\">\n+                    <header role=\"banner\">\n@@ -300,1 +300,0 @@\n-                    <div class=\"flex-content\">\n@@ -322,1 +321,1 @@\n-                    <header role=\"banner\" class=\"flex-header\">\n+                    <header role=\"banner\">\n@@ -353,1 +352,1 @@\n-                    <header role=\"banner\" class=\"flex-header\">\n+                    <header role=\"banner\">\n@@ -403,1 +402,1 @@\n-                    <header role=\"banner\" class=\"flex-header\">\n+                    <header role=\"banner\">\n@@ -444,1 +443,1 @@\n-                    <header role=\"banner\" class=\"flex-header\">\n+                    <header role=\"banner\">\n@@ -476,1 +475,1 @@\n-                    <header role=\"banner\" class=\"flex-header\">\n+                    <header role=\"banner\">\n@@ -503,1 +502,1 @@\n-                    <header role=\"banner\" class=\"flex-header\">\n+                    <header role=\"banner\">\n@@ -530,1 +529,1 @@\n-                    <header role=\"banner\" class=\"flex-header\">\n+                    <header role=\"banner\">\n@@ -568,1 +567,1 @@\n-                    <header role=\"banner\" class=\"flex-header\">\n+                    <header role=\"banner\">\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testHtmlVersion\/TestHtmlVersion.java","additions":17,"deletions":18,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -0,0 +1,164 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Spliterator;\n+import java.util.Spliterators;\n+import java.util.regex.Pattern;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+\n+import javadoc.tester.JavadocTester;\n+import toolbox.ToolBox;\n+\n+\/*\n+ * @test\n+ * @bug 8318082\n+ * @library \/tools\/lib ..\/..\/lib\n+ * @modules jdk.javadoc\/jdk.javadoc.internal.tool\n+ * @build toolbox.ToolBox javadoc.tester.*\n+ * @run main TestSelfIndexing\n+ *\/\n+public class TestSelfIndexing extends JavadocTester {\n+\n+    public static void main(String... args) throws Exception {\n+        new TestSelfIndexing().runTests();\n+    }\n+\n+    private final ToolBox tb = new ToolBox();\n+\n+    \/*\n+     * Pages derived from other pages must not be indexed and may not\n+     * cross-reference each other except for navigation ergonomics.\n+     *\n+     * For example, it's okay for all-index.html to reference deprecated-list.html;\n+     * but it is not okay, for all-index.html to reference an anchor, such as\n+     * deprecated-list.html#java.lang.Object.finalize()\n+     *\/\n+    @Test\n+    public void test(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        int i = 0;\n+        \/\/ try to start a search tag (i) with the same letter, H,\n+        \/\/ as the class, Hello, and (ii) with some other letter, P\n+        for (var l : List.of(\"H\", \"P\")) {\n+            \/\/ try all markup constructs that cause indexing\n+            for (var t : List.of(\"<h2>%s<\/h2>\", \"{@index %s}\", \"{@systemProperty %s}\")) {\n+                tb.writeJavaFiles(src, \"\"\"\n+                        package pkg;\n+\n+                        \/** @deprecated %s *\/\n+                        public class Hello { }\n+                        \"\"\".formatted(t.formatted(l)));\n+\n+                Path out = base.resolve(\"out-\" + i);\n+                checking(t.formatted(l) + \"; results in: \" + out);\n+                setAutomaticCheckNoStacktrace(true); \/\/ no exceptions\n+                javadoc(\"-d\", out.toString(),\n+                        \"--source-path\", src.toString(),\n+                        \"pkg\");\n+                \/\/ check that index pages do not refer to derived pages\n+                try (var s = findIndexFiles(out)) {\n+                    record PathAndString(Path path, String str) { }\n+                    Optional<PathAndString> r = s.map(p -> {\n+                                try {\n+                                    return new PathAndString(p, Files.readString(p));\n+                                } catch (IOException e) {\n+                                    throw new UncheckedIOException(e);\n+                                }\n+                            })\n+                            .flatMap(pac -> findLinksToDerivedPages(pac.str)\n+                                    .map(link -> new PathAndString(pac.path, link)))\n+                            .findAny();\n+                    r.ifPresentOrElse(p -> failed(p.toString()), () -> passed(t.formatted(l)));\n+                }\n+                i++;\n+            }\n+        }\n+    }\n+\n+    \/\/ ----------- support and infrastructure -----------\n+\n+    private static Stream<Path> findIndexFiles(Path start) throws IOException {\n+        return Files.find(start, Integer.MAX_VALUE, (path, attr) -> {\n+            if (attr.isDirectory())\n+                return false;\n+            var fileName = path.getFileName().toString();\n+            if (!fileName.endsWith(\".html\") && !fileName.endsWith(\".js\"))\n+                return false;\n+            if (!fileName.contains(\"-index\") && !fileName.contains(\"index-\"))\n+                return false;\n+            var underDocFiles = StreamSupport.stream(Spliterators.spliterator(path.iterator(),\n+                            Integer.MAX_VALUE, Spliterator.ORDERED), false)\n+                    .anyMatch(p -> p.equals(DOC_FILES));\n+            return !underDocFiles;\n+        });\n+    }\n+\n+    private static final Path DOC_FILES = Path.of(\"doc-files\");\n+\n+    \/\/ good enough to capture relevant parts of URLs that javadoc uses,\n+    \/\/ from html and js files alike\n+    private static final Pattern URL = Pattern.compile(\n+            \"(?<path>([a-zA-Z.%0-9-]+\/)*+)(?<file>[a-zA-Z.%0-9-]+\\\\.html)#[a-zA-Z.%0-9-]+\");\n+\n+    static {\n+        assert findLinksToDerivedPages(\"module-summary.html#a\").findAny().isEmpty();\n+        assert findLinksToDerivedPages(\"package-summary.html#a\").findAny().isEmpty();\n+        assert findLinksToDerivedPages(\"Exception.html#a\").findAny().isEmpty();\n+        assert findLinksToDerivedPages(\"util\/doc-files\/coll-index.html#a\").findAny().isEmpty();\n+        assert findLinksToDerivedPages(\"util\/doc-files\/index-all.html#a\").findAny().isEmpty(); \/\/ tricky\n+\n+\n+        assert findLinksToDerivedPages(\"index-all.html#a\").findAny().isPresent();\n+        assert findLinksToDerivedPages(\"index-17.html#a\").findAny().isPresent();\n+    }\n+\n+    \/\/ NOTE: this will not find self-links that are allowed on some index pages.\n+    \/\/ For example, the quick-jump first-character links, such as #I:A,\n+    \/\/ #I:B, etc., on the top and at the bottom of index-all.html\n+    private static Stream<String> findLinksToDerivedPages(String content) {\n+        return URL.matcher(content).results()\n+                .filter(r -> {\n+                    String f = r.group(\"file\");\n+                    if (!f.contains(\"-\"))\n+                        return false;\n+                    return switch (f) {\n+                        case \"package-summary.html\",\n+                                \"module-summary.html\",\n+                                \"overview-summary.html\",\n+                                \"help-doc.html\" -> false;\n+                        default -> {\n+                            String p = r.group(\"path\");\n+                            yield !p.contains(\"\/doc-files\/\") && !p.startsWith(\"doc-files\/\");\n+                        }\n+                    };\n+                })\n+                .map(r -> r.group(0));\n+    }\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testIndex\/TestSelfIndexing.java","additions":164,"deletions":0,"binary":false,"changes":164,"status":"added"},{"patch":"@@ -131,0 +131,1 @@\n+                    <div class=\"horizontal-scroll\">\n@@ -150,0 +151,1 @@\n+                    <div class=\"horizontal-scroll\">\n@@ -160,0 +162,1 @@\n+                    <div class=\"horizontal-scroll\">\n@@ -314,0 +317,1 @@\n+                <div class=\"horizontal-scroll\">\n@@ -320,0 +324,1 @@\n+                <\/div>\n@@ -325,0 +330,1 @@\n+                <div class=\"horizontal-scroll\">\n@@ -332,0 +338,1 @@\n+                <\/div>\n@@ -337,0 +344,1 @@\n+                <div class=\"horizontal-scroll\">\n@@ -343,0 +351,1 @@\n+                <\/div>\n@@ -348,0 +357,1 @@\n+                <div class=\"horizontal-scroll\">\n@@ -350,0 +360,1 @@\n+                <\/div>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testInterface\/TestInterface.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -110,0 +110,1 @@\n+                    <div class=\"horizontal-scroll\">\n@@ -117,0 +118,1 @@\n+                    <div class=\"horizontal-scroll\">\n@@ -124,0 +126,1 @@\n+                    <div class=\"horizontal-scroll\">\n@@ -136,0 +139,1 @@\n+                    <div class=\"horizontal-scroll\">\n@@ -148,0 +152,1 @@\n+                    <div class=\"horizontal-scroll\">\n@@ -156,0 +161,1 @@\n+                    <div class=\"horizontal-scroll\">\n@@ -173,0 +179,1 @@\n+                    <div class=\"horizontal-scroll\">\n@@ -265,0 +272,1 @@\n+                        <div class=\"horizontal-scroll\">\n@@ -276,0 +284,1 @@\n+                        <\/div>\n@@ -281,0 +290,1 @@\n+                        <div class=\"horizontal-scroll\">\n@@ -292,0 +302,1 @@\n+                        <\/div>\n@@ -297,0 +308,1 @@\n+                        <div class=\"horizontal-scroll\">\n@@ -308,0 +320,1 @@\n+                        <\/div>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testJavaFX\/TestJavaFX.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -157,0 +157,1 @@\n+                                <div class=\"horizontal-scroll\">\n@@ -166,0 +167,1 @@\n+                                <\/div>\n@@ -179,0 +181,1 @@\n+                                <div class=\"horizontal-scroll\">\n@@ -185,0 +188,1 @@\n+                                <\/div>\n@@ -202,0 +206,1 @@\n+                                <div class=\"horizontal-scroll\">\n@@ -211,0 +216,1 @@\n+                                <\/div>\n@@ -223,0 +229,1 @@\n+                                <div class=\"horizontal-scroll\">\n@@ -229,0 +236,1 @@\n+                                <\/div>\n@@ -245,0 +253,1 @@\n+                                <div class=\"horizontal-scroll\">\n@@ -252,0 +261,1 @@\n+                                <\/div>\n@@ -265,0 +275,1 @@\n+                                <div class=\"horizontal-scroll\">\n@@ -272,0 +283,1 @@\n+                                <\/div>\n@@ -423,1 +435,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testJavaFX\/TestJavaFXCombo.java","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -92,0 +92,1 @@\n+                    <div class=\"horizontal-scroll\">\n@@ -108,0 +109,1 @@\n+                    <\/div>\n@@ -156,0 +158,1 @@\n+                    <div class=\"horizontal-scroll\">\n@@ -172,0 +175,1 @@\n+                    <\/div>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testJavaFX\/TestJavaFXMissingPropComments.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -123,0 +123,1 @@\n+                    <div class=\"horizontal-scroll\">\n@@ -127,0 +128,1 @@\n+                    <\/div>\n@@ -145,0 +147,1 @@\n+                    <div class=\"horizontal-scroll\">\n@@ -172,0 +175,1 @@\n+                    <div class=\"horizontal-scroll\">\n@@ -176,0 +180,1 @@\n+                    <\/div>\n@@ -188,0 +193,1 @@\n+                    <div class=\"horizontal-scroll\">\n@@ -191,0 +197,1 @@\n+                    <\/div>\n@@ -234,0 +241,1 @@\n+                    <div class=\"horizontal-scroll\">\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testMemberInheritance\/TestMemberInheritance.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -524,1 +524,0 @@\n-                    <div class=\"flex-content\">\n@@ -549,0 +548,1 @@\n+                    <div class=\"horizontal-scroll\">\n@@ -551,0 +551,1 @@\n+                    <\/div>\n@@ -562,0 +563,1 @@\n+                    <div class=\"horizontal-scroll\">\n@@ -568,0 +570,1 @@\n+                    <\/div>\n@@ -710,1 +713,0 @@\n-                    <div class=\"flex-content\">\n@@ -1132,0 +1134,1 @@\n+                    <div class=\"horizontal-scroll\">\n@@ -1145,0 +1148,1 @@\n+                    <div class=\"horizontal-scroll\">\n@@ -1357,0 +1361,1 @@\n+                    <div class=\"horizontal-scroll\">\n@@ -1362,0 +1367,1 @@\n+                    <\/div>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testModules\/TestModules.java","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+\n+import javadoc.tester.JavadocTester;\n+import toolbox.ToolBox;\n+\n+\/*\n+ * @test\n+ * @bug 8317289\n+ * @library \/tools\/lib ..\/..\/lib\n+ * @modules jdk.javadoc\/jdk.javadoc.internal.tool\n+ * @build toolbox.ToolBox javadoc.tester.*\n+ * @run main TestSourcePathModule\n+ *\/\n+public class TestSourcePathModule extends JavadocTester {\n+\n+    public static void main(String... args) throws Exception {\n+        new TestSourcePathModule().runTests();\n+    }\n+\n+    @Test\n+    public void testSourcePath(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        new ToolBox().writeJavaFiles(src, \"\"\"\n+                import java.lang.Object;\n+                \/** documentation *\/\n+                module m { }\n+                \"\"\");\n+        javadoc(\"-d\", \"out\",\n+                \"-sourcepath\", src.toString(),\n+                \"--module\", \"m\");\n+        checkExit(Exit.OK);\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testModules\/TestSourcePathModule.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -94,1 +94,0 @@\n-                    <div class=\"flex-content\">\n@@ -103,1 +102,0 @@\n-                    <div class=\"flex-content\">\n@@ -123,1 +121,0 @@\n-                    <div class=\"flex-content\">\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testNavigation\/TestNavigation.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -235,0 +235,1 @@\n+                    <div class=\"horizontal-scroll\">\n@@ -242,0 +243,1 @@\n+                    <div class=\"horizontal-scroll\">\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testOptions\/TestOptions.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,0 +58,1 @@\n+                    <div class=\"horizontal-scroll\">\n@@ -94,0 +95,1 @@\n+                    <div class=\"horizontal-scroll\">\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testPackageAnnotation\/TestPackageAnnotation.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,175 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8316972\n+ * @summary Add javadoc support for restricted methods\n+ * @library \/tools\/lib ..\/..\/lib\n+ * @modules jdk.javadoc\/jdk.javadoc.internal.tool\n+ * @build toolbox.ToolBox javadoc.tester.*\n+ * @run main TestRestricted\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+\n+import javadoc.tester.JavadocTester;\n+import toolbox.ToolBox;\n+\n+public class TestRestricted extends JavadocTester {\n+\n+    public final ToolBox tb;\n+    public static void main(String... args) throws Exception {\n+        var tester = new TestRestricted();\n+        tester.runTests();\n+    }\n+\n+    public TestRestricted() {\n+        tb = new ToolBox();\n+    }\n+\n+    @Test\n+    public void testRestricted(Path base) throws IOException {\n+        var src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                   package pkg;\n+\n+                   import jdk.internal.javac.PreviewFeature;\n+                   import jdk.internal.javac.PreviewFeature.Feature;\n+                   import jdk.internal.javac.Restricted;\n+\n+                   \/**\n+                    * Interface containing restricted methods.\n+                    * @see #restrictedMethod()\n+                    * @see #restrictedPreviewMethod()\n+                    *\/\n+                   public interface I {\n+\n+                       \/**\n+                        * Restricted method.\n+                        *\/\n+                       @Restricted\n+                       public void restrictedMethod();\n+\n+                       \/**\n+                        * Restricted preview method.\n+                        *\/\n+                       @PreviewFeature(feature=Feature.TEST)\n+                       @Restricted\n+                       public int restrictedPreviewMethod();\n+                   }\n+                   \"\"\");\n+\n+        javadoc(\"--enable-preview\", \"-source\", System.getProperty(\"java.specification.version\"),\n+                \"--add-exports\", \"java.base\/jdk.internal.javac=ALL-UNNAMED\",\n+                \"-d\", base.resolve(\"api\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                \"pkg\");\n+        checkExit(Exit.OK);\n+\n+        \/\/ Test restricted method note in class documentation\n+        checkOutput(\"pkg\/I.html\", true,\n+                \"\"\"\n+                <ul class=\"tag-list-long\">\n+                <li><a href=\"#restrictedMethod()\"><code>restrictedMethod()<\/code><\/a><sup><a href=\"\\\n+                #restricted-restrictedMethod()\">RESTRICTED<\/a><\/sup><\/li>\n+                <li><a href=\"#restrictedPreviewMethod()\"><code>restrictedPreviewMethod()<\/code><\/a>\\\n+                <sup><a href=\"#preview-restrictedPreviewMethod()\">PREVIEW<\/a><\/sup>&nbsp;<sup><a hr\\\n+                ef=\"#restricted-restrictedPreviewMethod()\">RESTRICTED<\/a><\/sup><\/li>\"\"\",\n+                        \"\"\"\n+                <div class=\"block\"><span class=\"restricted-label\">Restricted.<\/span><\/div>\n+                <div class=\"block\">Restricted method.<\/div>\"\"\",\n+                        \"\"\"\n+                <div class=\"block\"><span class=\"preview-label\">Preview.<\/span><\/div>\n+                <div class=\"block\"><span class=\"restricted-label\">Restricted.<\/span><\/div>\n+                <div class=\"block\">Restricted preview method.<\/div>\"\"\",\n+                        \"\"\"\n+                <h3>restrictedMethod<\/h3>\n+                <div class=\"horizontal-scroll\">\n+                <div class=\"member-signature\"><span class=\"modifiers\">sealed<\/span>&nbsp;<span clas\\\n+                s=\"return-type\">void<\/span>&nbsp;<span class=\"element-name\">restrictedMethod<\/span>\\\n+                ()<\/div>\n+                <div class=\"restricted-block\" id=\"restricted-restrictedMethod()\"><span class=\"restr\\\n+                icted-label\"><code>restrictedMethod<\/code> is a restricted method of the Java platf\\\n+                orm.<\/span>\n+                <div class=\"restricted-comment\">Programs can only use <code>restrictedMethod<\/code>\\\n+                 when access to restricted methods is enabled.<\/div>\n+                <div class=\"restricted-comment\">Restricted methods are unsafe, and, if used incorre\\\n+                ctly, might crash the JVM or result in memory corruption.<\/div>\n+                <\/div>\"\"\",\n+                        \"\"\"\n+                <h3>restrictedPreviewMethod<\/h3>\n+                <div class=\"horizontal-scroll\">\n+                <div class=\"member-signature\"><span class=\"modifiers\">sealed<\/span>&nbsp;<span clas\\\n+                s=\"return-type\">int<\/span>&nbsp;<span class=\"element-name\">restrictedPreviewMethod<\\\n+                \/span>()<\/div>\n+                <div class=\"preview-block\" id=\"preview-restrictedPreviewMethod()\"><span class=\"prev\\\n+                iew-label\"><code>restrictedPreviewMethod<\/code> is a preview API of the Java platfo\\\n+                rm.<\/span>\n+                <div class=\"preview-comment\">Programs can only use <code>restrictedPreviewMethod<\/c\\\n+                ode> when preview features are enabled.<\/div>\n+                <div class=\"preview-comment\">Preview features may be removed in a future release, o\\\n+                r upgraded to permanent features of the Java platform.<\/div>\n+                <\/div>\n+                <div class=\"restricted-block\" id=\"restricted-restrictedPreviewMethod()\"><span class\\\n+                =\"restricted-label\"><code>restrictedPreviewMethod<\/code> is a restricted method of \\\n+                the Java platform.<\/span>\n+                <div class=\"restricted-comment\">Programs can only use <code>restrictedPreviewMethod\\\n+                <\/code> when access to restricted methods is enabled.<\/div>\n+                <div class=\"restricted-comment\">Restricted methods are unsafe, and, if used incorre\\\n+                ctly, might crash the JVM or result in memory corruption.<\/div>\n+                <\/div>\"\"\");\n+\n+        \/\/ Test link on index page\n+        checkOutput(\"index-all.html\", true,\n+                        \"\"\"\n+                <a href=\"restricted-list.html\">Restricted&nbsp;Methods<\/a>\"\"\");\n+\n+        \/\/ Test restricted methods list\n+        checkOutput(\"restricted-list.html\", true,\n+                \"\"\"\n+                <h1 title=\"Restricted Methods\" class=\"title\">Restricted Methods<\/h1>\n+                <\/div>\n+                <ul class=\"block-list\">\n+                <li>\n+                <div id=\"method\">\n+                <div class=\"caption\"><span>Methods<\/span><\/div>\n+                <div class=\"summary-table two-column-summary\">\n+                <div class=\"table-header col-first\">Method<\/div>\n+                <div class=\"table-header col-last\">Description<\/div>\n+                <div class=\"col-summary-item-name even-row-color\"><a href=\"pkg\/I.html#restrictedMet\\\n+                hod()\">pkg.I.restrictedMethod()<\/a><sup><a href=\"pkg\/I.html#restricted-restrictedMe\\\n+                thod()\">RESTRICTED<\/a><\/sup><\/div>\n+                <div class=\"col-last even-row-color\">\n+                <div class=\"block\">Restricted method.<\/div>\n+                <\/div>\n+                <div class=\"col-summary-item-name odd-row-color\"><a href=\"pkg\/I.html#restrictedPrev\\\n+                iewMethod()\">pkg.I.restrictedPreviewMethod()<\/a><sup><a href=\"pkg\/I.html#preview-re\\\n+                strictedPreviewMethod()\">PREVIEW<\/a><\/sup>&nbsp;<sup><a href=\"pkg\/I.html#restricted\\\n+                -restrictedPreviewMethod()\">RESTRICTED<\/a><\/sup><\/div>\n+                <div class=\"col-last odd-row-color\">\n+                <div class=\"block\">Restricted preview method.<\/div>\n+                <\/div>\"\"\");\n+    }\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testRestricted\/TestRestricted.java","additions":175,"deletions":0,"binary":false,"changes":175,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -295,0 +295,1 @@\n+                    <\/div>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testReturnTag\/TestReturnTag.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- *      8266808 8248863 8305710\n+ *      8266808 8248863 8305710 8318082\n@@ -437,2 +437,0 @@\n-        checkOutput(fileName, true,\n-                \"<div class=\\\"flex-box\\\">\");\n@@ -508,8 +506,0 @@\n-        checkOutput(\"index-all.html\", true,\n-                \"\"\"\n-                    <div class=\"deprecation-comment\">class_test1 passes. Search tag <span id=\"Search\\\n-                    TagDeprecatedClass\" class=\"search-tag-result\">SearchTagDeprecatedClass<\/span><\/d\\\n-                    iv>\"\"\",\n-                \"\"\"\n-                    <div class=\"deprecation-comment\">error_test3 passes. Search tag for\n-                     method <span id=\"SearchTagDeprecatedMethod\" class=\"search-tag-result\">SearchTagDeprecatedMethod<\/span><\/div>\"\"\");\n@@ -626,7 +616,1 @@\n-                    Word<\/a> - Search tag in package pkg<\/dt>\"\"\",\n-                \"\"\"\n-                    <div class=\"deprecation-comment\">class_test1 passes. Search tag <span id=\"Search\\\n-                    TagDeprecatedClass\">SearchTagDeprecatedClass<\/div>\"\"\",\n-                \"\"\"\n-                    <div class=\"deprecation-comment\">error_test3 passes. Search tag for\n-                     method <span id=\"SearchTagDeprecatedMethod\">SearchTagDeprecatedMethod<\/span><\/div>\"\"\");\n+                    Word<\/a> - Search tag in package pkg<\/dt>\"\"\");\n@@ -670,7 +654,1 @@\n-                    nk\">SearchTagDeprecatedMethod<\/a> - Search tag in pkg2.TestError.TestError()<\/dt>\"\"\",\n-                \"\"\"\n-                    <div class=\"deprecation-comment\">class_test1 passes. Search tag <span id=\"Search\\\n-                    TagDeprecatedClass\">SearchTagDeprecatedClass<\/span><\/div>\"\"\",\n-                \"\"\"\n-                    <div class=\"deprecation-comment\">error_test3 passes. Search tag for\n-                     method <span id=\"SearchTagDeprecatedMethod\">SearchTagDeprecatedMethod<\/span><\/div>\"\"\");\n+                    nk\">SearchTagDeprecatedMethod<\/a> - Search tag in pkg2.TestError.TestError()<\/dt>\"\"\");\n@@ -844,2 +822,0 @@\n-                \"\"\"\n-                    {\"l\":\"search phrase deprecated\",\"h\":\"pkg2.TestEnum.ONE\",\"u\":\"deprecated-list.html#searchphrasedeprecated\"}\"\"\",\n@@ -848,2 +824,0 @@\n-                \"\"\"\n-                    {\"l\":\"search phrase with desc deprecated\",\"h\":\"annotation interface pkg2.TestAnnotationType\",\"d\":\"description for phrase deprecated\",\"u\":\"deprecated-list.html#searchphrasewithdescdeprecated\"}\"\"\",\n@@ -852,2 +826,0 @@\n-                \"\"\"\n-                    {\"l\":\"SearchTagDeprecatedClass\",\"h\":\"class pkg2.TestClass\",\"u\":\"deprecated-list.html#SearchTagDeprecatedClass\"}\"\"\",\n@@ -856,2 +828,0 @@\n-                \"\"\"\n-                    {\"l\":\"SearchTagDeprecatedMethod\",\"h\":\"pkg2.TestError.TestError()\",\"d\":\"with description\",\"u\":\"deprecated-list.html#SearchTagDeprecatedMethod\"}\"\"\",\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSearch\/TestSearch.java","additions":3,"deletions":33,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -141,1 +141,1 @@\n-                        overflow-x: auto;\n+                        overflow: auto hidden;\n@@ -164,1 +164,1 @@\n-                    .deprecation-block {\n+                    .deprecation-block, .preview-block, .restricted-block {\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testStylesheet\/TestStylesheet.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -95,0 +95,1 @@\n+                 <div class=\"horizontal-scroll\">\n@@ -98,0 +99,1 @@\n+                 <\/div>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSummaryTag\/TestSummaryTag.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,2 +70,1 @@\n-                    <div class=\"flex-box\">\n-                    <header role=\"banner\" class=\"flex-header\">\"\"\",\n+                    <header role=\"banner\">\"\"\",\n@@ -74,1 +73,0 @@\n-                    <div class=\"flex-content\">\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSystemPropertyPage\/TestSystemPropertyPage.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -683,0 +683,1 @@\n+                <\/div>\n@@ -738,0 +739,1 @@\n+                <\/div>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testThrowsInheritanceMultiple\/TestOneToMany.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -110,0 +110,1 @@\n+                    <div class=\"horizontal-scroll\">\n@@ -118,0 +119,1 @@\n+                    <\/div>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testUnicode\/TestUnicode.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -83,0 +83,1 @@\n+                    <div class=\"horizontal-scroll\">\n@@ -88,0 +89,1 @@\n+                    <div class=\"horizontal-scroll\">\n@@ -116,0 +118,1 @@\n+                    <div class=\"horizontal-scroll\">\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testValueTag\/TestValueFormats.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -427,0 +427,1 @@\n+        boolean haveSourcePath = false;\n@@ -433,0 +434,1 @@\n+                case \"-sourcepath\", \"--source-path\", \"--module-source-path\" -> haveSourcePath = true;\n@@ -454,0 +456,10 @@\n+        \/\/ explicitly set the source path if none specified\n+        \/\/ to override the javadoc tool default to use the classpath\n+        if (!haveSourcePath) {\n+            var newArgs = new String[args.length + 2];\n+            newArgs[0] = \"-sourcepath\";\n+            newArgs[1] = testSrc;\n+            System.arraycopy(args, 0, newArgs, 2, args.length);\n+            args = newArgs;\n+        }\n+\n","filename":"test\/langtools\/jdk\/javadoc\/lib\/javadoc\/tester\/JavadocTester.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 9999999\n+ * @bug 8315851 8315588\n@@ -37,0 +37,2 @@\n+\n+import jdk.jshell.SourceCodeAnalysis;\n@@ -43,0 +45,3 @@\n+import static jdk.jshell.SourceCodeAnalysis.Completeness.COMPLETE;\n+import static jdk.jshell.SourceCodeAnalysis.Completeness.DEFINITELY_INCOMPLETE;\n+\n@@ -53,0 +58,73 @@\n+    static final String[] definitely_incomplete = new String[]{\n+            \"int _ = \",\n+            \"int m(String v, int r) {\\n\" +\n+                    \"    try {\\n\" +\n+                    \"        return Integer.parseInt(v, r);\\n\" +\n+                    \"    } catch (NumberFormatException _) {\",\n+            \"try (final Lock _ = \",\n+            \"try (Lock _ = null) {\\n\" +\n+                \"            try (Lock _ = null) {\",\n+            \"for (var _ : strs\",\n+            \"TwoParams p1 = (_, _) ->\",\n+            \"for (int _ = 0, _ = 1, x = 1;\",\n+            \"if (r instanceof R(_\"\n+    };\n+\n+    static final String[] complete = new String[]{\n+            \"int _ = 42;\",\n+            \"int m(String v, int r) {\\n\" +\n+                    \"    try {\\n\" +\n+                    \"        return Integer.parseInt(v, r);\\n\" +\n+                    \"    } catch (NumberFormatException _) { } }\",\n+            \"try (final Lock _ = TEST) {}\",\n+            \"try (Lock _ = null) {\\n\" +\n+                    \"            try (Lock _ = null) { } }\",\n+            \"for (var _ : strs) { }\",\n+            \"TwoParams p1 = (_, _) -> {};\",\n+            \"for (int _ = 0, _ = 1, x = 1; x <= 1 ; x++) {}\",\n+            \"if (r instanceof R(_)) { }\"\n+    };\n+\n+    private void assertStatus(String input, SourceCodeAnalysis.Completeness status, String source) {\n+        String augSrc;\n+        switch (status) {\n+            case COMPLETE_WITH_SEMI:\n+                augSrc = source + \";\";\n+                break;\n+\n+            case DEFINITELY_INCOMPLETE:\n+                augSrc = null;\n+                break;\n+\n+            case CONSIDERED_INCOMPLETE:\n+                augSrc = source + \";\";\n+                break;\n+\n+            case EMPTY:\n+            case COMPLETE:\n+            case UNKNOWN:\n+                augSrc = source;\n+                break;\n+\n+            default:\n+                throw new AssertionError();\n+        }\n+        assertAnalyze(input, status, augSrc);\n+    }\n+\n+    private void assertStatus(String[] ins, SourceCodeAnalysis.Completeness status) {\n+        for (String input : ins) {\n+            assertStatus(input, status, input);\n+        }\n+    }\n+\n+    @Test\n+    public void test_definitely_incomplete() {\n+        assertStatus(definitely_incomplete, DEFINITELY_INCOMPLETE);\n+    }\n+\n+    @Test\n+    public void test_definitely_complete() {\n+        assertStatus(complete, COMPLETE);\n+    }\n+\n","filename":"test\/langtools\/jdk\/jshell\/UnnamedTest.java","additions":79,"deletions":1,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# This file identifies root(s) of the test-ng hierarchy.\n+# This file identifies root(s) of the JUnit hierarchy.\n@@ -3,1 +3,1 @@\n-TestNG.dirs = .\n+JUnit.dirs = .\n","filename":"test\/langtools\/lib\/combo\/TEST.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,31 @@\n+package tools.javac.combo;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.junit.jupiter.api.extension.AfterAllCallback;\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.api.extension.TestWatcher;\n+\n+public class ComboWatcher implements TestWatcher, AfterAllCallback {\n+    private final Set<String> errors = Collections.synchronizedSet(new HashSet<>());\n+\n+    @Override\n+    public void testFailed(ExtensionContext context, Throwable cause) {\n+        if (context.getRequiredTestInstance() instanceof JavacTemplateTestBase instance) {\n+            errors.addAll(instance.diags.errorKeys());\n+            if (instance instanceof CompilationTestCase) {\n+                \/\/ Make sure offending template ends up in log file on failure\n+                System.err.printf(\"Diagnostics: %s%nTemplate: %s%n\", instance.diags.errorKeys(),\n+                        instance.sourceFiles.stream().map(SourceFile::template).toList());\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void afterAll(ExtensionContext extensionContext) {\n+        if (errors.isEmpty()) return;\n+        System.err.println(\"Errors found in tests: \" + errors);\n+    }\n+}\n","filename":"test\/langtools\/lib\/combo\/tools\/javac\/combo\/ComboWatcher.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,6 +34,0 @@\n-import org.testng.ITestResult;\n-import org.testng.annotations.AfterMethod;\n-import org.testng.annotations.Test;\n-\n-import static java.util.stream.Collectors.toList;\n-\n@@ -43,1 +37,0 @@\n-@Test\n@@ -45,1 +38,1 @@\n-    private String[] compileOptions = new String[] { };\n+    private String[] compileOptions = new String[]{};\n@@ -49,9 +42,0 @@\n-    @AfterMethod\n-    public void dumpTemplateIfError(ITestResult result) {\n-        \/\/ Make sure offending template ends up in log file on failure\n-        if (!result.isSuccess()) {\n-            System.err.printf(\"Diagnostics: %s%nTemplate: %s%n\", diags.errorKeys(),\n-                              sourceFiles.stream().map(p -> p.snd).collect(toList()));\n-        }\n-    }\n-\n@@ -84,1 +68,1 @@\n-            compileOptions = new String[] {};\n+            compileOptions = new String[]{};\n@@ -108,2 +92,1 @@\n-        }\n-        catch (IOException e) {\n+        } catch (IOException e) {\n","filename":"test\/langtools\/lib\/combo\/tools\/javac\/combo\/CompilationTestCase.java","additions":4,"deletions":21,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,0 @@\n-import java.util.HashSet;\n@@ -39,1 +38,0 @@\n-import java.util.Set;\n@@ -51,6 +49,2 @@\n-import com.sun.tools.javac.util.Pair;\n-import org.testng.ITestResult;\n-import org.testng.annotations.AfterMethod;\n-import org.testng.annotations.AfterSuite;\n-import org.testng.annotations.BeforeMethod;\n-import org.testng.annotations.Test;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.extension.ExtendWith;\n@@ -58,1 +52,1 @@\n-import static org.testng.Assert.fail;\n+import static org.junit.jupiter.api.Assertions.fail;\n@@ -61,1 +55,1 @@\n- * Base class for template-driven TestNG javac tests that support on-the-fly\n+ * Base class for template-driven JUnit javac tests that support on-the-fly\n@@ -73,1 +67,1 @@\n-@Test\n+@ExtendWith(ComboWatcher.class)\n@@ -75,1 +69,0 @@\n-    private static final Set<String> suiteErrors = Collections.synchronizedSet(new HashSet<>());\n@@ -82,1 +75,1 @@\n-    protected final List<Pair<String, String>> sourceFiles = new ArrayList<>();\n+    protected final List<SourceFile> sourceFiles = new ArrayList<>();\n@@ -98,1 +91,1 @@\n-        sourceFiles.add(new Pair<>(name, template));\n+        sourceFiles.add(new SourceFile(name, template));\n@@ -133,1 +126,1 @@\n-    @BeforeMethod\n+    @BeforeEach\n@@ -142,32 +135,0 @@\n-    \/\/ After each test method, if the test failed, capture source files and diagnostics and put them in the log\n-    @AfterMethod\n-    public void copyErrors(ITestResult result) {\n-        if (!result.isSuccess()) {\n-            suiteErrors.addAll(diags.errorKeys());\n-\n-            List<Object> list = new ArrayList<>();\n-            Collections.addAll(list, result.getParameters());\n-            list.add(\"Test case: \" + getTestCaseDescription());\n-            for (Pair<String, String> e : sourceFiles)\n-                list.add(\"Source file \" + e.fst + \": \" + e.snd);\n-            if (diags.errorsFound())\n-                list.add(\"Compile diagnostics: \" + diags.toString());\n-            result.setParameters(list.toArray(new Object[list.size()]));\n-        }\n-    }\n-\n-    @AfterSuite\n-    \/\/ After the suite is done, dump any errors to output\n-    public void dumpErrors() {\n-        if (!suiteErrors.isEmpty())\n-            System.err.println(\"Errors found in test suite: \" + suiteErrors);\n-    }\n-\n-    \/**\n-     * Get a description of this test case; since test cases may be combinatorially\n-     * generated, this should include all information needed to describe the test case\n-     *\/\n-    protected String getTestCaseDescription() {\n-        return this.toString();\n-    }\n-\n@@ -261,3 +222,1 @@\n-        List<JavaFileObject> files = new ArrayList<>();\n-        for (Pair<String, String> e : sourceFiles)\n-            files.add(new FileAdapter(e.fst, e.snd));\n+        var files = sourceFiles.stream().map(FileAdapter::new).toList();\n@@ -271,3 +230,1 @@\n-        List<JavaFileObject> files = new ArrayList<>();\n-        for (Pair<String, String> e : sourceFiles)\n-            files.add(new FileAdapter(e.fst, e.snd));\n+        var files = sourceFiles.stream().map(FileAdapter::new).toList();\n@@ -277,1 +234,1 @@\n-    private File compile(List<File> classpaths, List<JavaFileObject> files, boolean generate) throws IOException {\n+    private File compile(List<File> classpaths, List<? extends JavaFileObject> files, boolean generate) throws IOException {\n@@ -330,3 +287,3 @@\n-        FileAdapter(String filename, String templateString) {\n-            super(URI.create(\"myfo:\/\" + filename), Kind.SOURCE);\n-            this.templateString = templateString;\n+        FileAdapter(SourceFile file) {\n+            super(URI.create(\"myfo:\/\" + file.name()), Kind.SOURCE);\n+            this.templateString = file.template();\n","filename":"test\/langtools\/lib\/combo\/tools\/javac\/combo\/JavacTemplateTestBase.java","additions":15,"deletions":58,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -0,0 +1,26 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package tools.javac.combo;\n+\n+public record SourceFile(String name, String template) {}\n","filename":"test\/langtools\/lib\/combo\/tools\/javac\/combo\/SourceFile.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,4 @@\n-import org.testng.annotations.BeforeTest;\n-import org.testng.annotations.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.BeforeEach;\n@@ -32,2 +34,0 @@\n-import static org.testng.Assert.assertEquals;\n-\n@@ -37,3 +37,2 @@\n-@Test\n-public class TemplateTest {\n-    Map<String, Template> vars = new HashMap<>();\n+class TemplateTest {\n+    final Map<String, Template> vars = new HashMap<>();\n@@ -41,1 +40,1 @@\n-    @BeforeTest\n+    @BeforeEach\n@@ -46,1 +45,1 @@\n-        assertEquals(result, expected, \"for \" + template);\n+        assertEquals(expected, result, \"for \" + template);\n@@ -53,1 +52,2 @@\n-    public void testTemplateExpansion() {\n+    @Test\n+    void testTemplateExpansion() {\n@@ -75,1 +75,2 @@\n-    public void testIndexedTemplate() {\n+    @Test\n+    void testIndexedTemplate() {\n@@ -85,1 +86,2 @@\n-    public void testAngleBrackets() {\n+    @Test\n+    void testAngleBrackets() {\n@@ -90,3 +92,3 @@\n-    @Test(expectedExceptions = IllegalStateException.class )\n-    public void testUnknownKey() {\n-        assertTemplate(\"#{Q}\", \"#{Q}\");\n+    @Test\n+    void testUnknownKey() {\n+        assertThrows(IllegalStateException.class, () -> assertTemplate(\"#{Q}\", \"#{Q}\"));\n","filename":"test\/langtools\/lib\/combo\/tools\/javac\/combo\/TemplateTest.java","additions":18,"deletions":16,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -5,2 +5,2 @@\n- * @compile\/fail\/ref=RestrictedMethods.out -Xlint:restricted -Werror -XDrawDiagnostics --enable-preview --source ${jdk.version} RestrictedMethods.java\n- * @compile -Werror --enable-preview --source ${jdk.version} RestrictedMethods.java\n+ * @compile\/fail\/ref=RestrictedMethods.out -Xlint:restricted -Werror -XDrawDiagnostics RestrictedMethods.java\n+ * @compile -Werror RestrictedMethods.java\n","filename":"test\/langtools\/tools\/javac\/RestrictedMethods.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -6,2 +6,0 @@\n-- compiler.note.preview.filename: RestrictedMethods.java, DEFAULT\n-- compiler.note.preview.recompile\n","filename":"test\/langtools\/tools\/javac\/RestrictedMethods.out","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,131 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8305971\n+ * @summary NPE in JavacProcessingEnvironment for missing enum constructor body\n+ * @library \/tools\/lib \/tools\/javac\/lib\n+ * @modules\n+ *      jdk.compiler\/com.sun.tools.javac.api\n+ *      jdk.compiler\/com.sun.tools.javac.main\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @run main CrashEmptyEnumConstructorTest\n+ *\/\n+\n+import java.io.IOException;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+import java.util.List;\n+import java.util.Set;\n+import javax.annotation.processing.AbstractProcessor;\n+import javax.annotation.processing.RoundEnvironment;\n+import javax.annotation.processing.SupportedAnnotationTypes;\n+import javax.lang.model.SourceVersion;\n+import javax.lang.model.element.TypeElement;\n+\n+import toolbox.JavacTask;\n+import toolbox.Task;\n+import toolbox.Task.Mode;\n+import toolbox.Task.OutputKind;\n+import toolbox.TestRunner;\n+import toolbox.ToolBox;\n+\n+public class CrashEmptyEnumConstructorTest extends TestRunner {\n+    protected ToolBox tb;\n+\n+    CrashEmptyEnumConstructorTest() {\n+        super(System.err);\n+        tb = new ToolBox();\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        new CrashEmptyEnumConstructorTest().runTests();\n+    }\n+\n+    protected void runTests() throws Exception {\n+        runTests(m -> new Object[]{Paths.get(m.getName())});\n+    }\n+\n+    Path[] findJavaFiles(Path... paths) throws IOException {\n+        return tb.findJavaFiles(paths);\n+    }\n+\n+    @Test\n+    public void testEmptyEnumConstructor(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        Path r = src.resolve(\"E\");\n+\n+        Path classes = base.resolve(\"classes\");\n+\n+        Files.createDirectories(classes);\n+\n+        tb.writeJavaFiles(r,\n+                \"\"\"\n+                enum E {\n+                    ONE(\"\");\n+                    E(String one);\n+                }\n+                \"\"\");\n+\n+        List<String> expected = List.of(\n+            \"E.java:3: error: missing method body, or declare abstract\",\n+            \"    E(String one);\",\n+            \"    ^\",\n+            \"1 error\");\n+\n+        List<String> log = new JavacTask(tb)\n+                .options(\"-processor\", SimpleProcessor.class.getName())\n+                .files(findJavaFiles(src))\n+                .outdir(classes)\n+                .run(Task.Expect.FAIL)\n+                .writeAll()\n+                .getOutputLines(Task.OutputKind.DIRECT);\n+\n+        if (log.size() != expected.size()) {\n+            throw new AssertionError(\"Unexpected output: \" + log);\n+        } else {\n+            for (int i = 0; i < expected.size(); i++) {\n+                if (!log.get(i).contains(expected.get(i))) {\n+                    throw new AssertionError(\"Unexpected output: \" + log);\n+                }\n+            }\n+        }\n+    }\n+\n+    @SupportedAnnotationTypes(\"*\")\n+    public static final class SimpleProcessor extends AbstractProcessor {\n+        @Override\n+        public SourceVersion getSupportedSourceVersion() {\n+            return SourceVersion.latestSupported();\n+        }\n+\n+        @Override\n+        public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n+            return false;\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/annotations\/crash_empty_enum_const\/CrashEmptyEnumConstructorTest.java","additions":131,"deletions":0,"binary":false,"changes":131,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,0 @@\n-import java.io.IOException;\n@@ -27,3 +26,1 @@\n-import org.testng.ITestResult;\n-import org.testng.annotations.AfterMethod;\n-import org.testng.annotations.Test;\n+import org.junit.jupiter.api.Test;\n@@ -31,1 +28,0 @@\n-import tools.javac.combo.JavacTemplateTestBase;\n@@ -33,4 +29,1 @@\n-import static java.util.stream.Collectors.toList;\n-\n-@Test\n-public class ExpSwitchNestingTest extends CompilationTestCase {\n+class ExpSwitchNestingTest extends CompilationTestCase {\n@@ -80,1 +73,2 @@\n-    public void testReallySimpleCases() {\n+    @Test\n+    void testReallySimpleCases() {\n@@ -87,1 +81,2 @@\n-    public void testLambda() {\n+    @Test\n+    void testLambda() {\n@@ -109,1 +104,2 @@\n-    public void testEswitch() {\n+    @Test\n+    void testEswitch() {\n@@ -154,1 +150,2 @@\n-    public void testNestedInExpSwitch() {\n+    @Test\n+    void testNestedInExpSwitch() {\n@@ -187,1 +184,2 @@\n-    public void testBreakExpressionLabelDisambiguation() {\n+    @Test\n+    void testBreakExpressionLabelDisambiguation() {\n@@ -197,1 +195,2 @@\n-    public void testFunReturningSwitchExp() {\n+    @Test\n+    void testFunReturningSwitchExp() {\n@@ -201,1 +200,2 @@\n-    public void testContinueLoops() {\n+    @Test\n+    void testContinueLoops() {\n","filename":"test\/langtools\/tools\/javac\/expswitch\/ExpSwitchNestingTest.java","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-TestNG.dirs = .\n+JUnit.dirs = .\n","filename":"test\/langtools\/tools\/javac\/expswitch\/TEST.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,2 +34,2 @@\n-import org.testng.annotations.BeforeMethod;\n-import org.testng.annotations.Test;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n@@ -39,1 +39,1 @@\n-import static org.testng.Assert.fail;\n+import static org.junit.jupiter.api.Assertions.fail;\n@@ -59,1 +59,0 @@\n-@Test\n@@ -232,1 +231,1 @@\n-    @BeforeMethod\n+    @BeforeEach\n","filename":"test\/langtools\/tools\/javac\/lambda\/bridge\/template_tests\/BridgeMethodTestCase.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,2 +25,3 @@\n-\n-import org.testng.annotations.Test;\n+import tools.javac.combo.*;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n@@ -33,2 +34,1 @@\n-@Test\n-public class BridgeMethodsTemplateTest extends BridgeMethodTestCase {\n+class BridgeMethodsTemplateTest extends BridgeMethodTestCase {\n@@ -42,1 +42,2 @@\n-    public void test1() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test1() throws IOException, ReflectiveOperationException {\n@@ -55,1 +56,2 @@\n-    public void test2() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test2() throws IOException, ReflectiveOperationException {\n@@ -68,1 +70,2 @@\n-    public void test3() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test3() throws IOException, ReflectiveOperationException {\n@@ -81,1 +84,2 @@\n-    public void test4() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test4() throws IOException, ReflectiveOperationException {\n@@ -94,1 +98,2 @@\n-    public void test5() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test5() throws IOException, ReflectiveOperationException {\n@@ -107,1 +112,2 @@\n-    public void test6() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test6() throws IOException, ReflectiveOperationException {\n@@ -120,1 +126,2 @@\n-    public void test7() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test7() throws IOException, ReflectiveOperationException {\n@@ -133,1 +140,2 @@\n-    public void test8() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test8() throws IOException, ReflectiveOperationException {\n@@ -146,1 +154,2 @@\n-    public void test9() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test9() throws IOException, ReflectiveOperationException {\n@@ -159,1 +168,2 @@\n-    public void test10() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test10() throws IOException, ReflectiveOperationException {\n@@ -172,1 +182,2 @@\n-    public void test11() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test11() throws IOException, ReflectiveOperationException {\n@@ -186,1 +197,2 @@\n-    public void test12() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test12() throws IOException, ReflectiveOperationException {\n@@ -200,1 +212,2 @@\n-    public void test13() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test13() throws IOException, ReflectiveOperationException {\n@@ -214,1 +227,2 @@\n-    public void test14() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test14() throws IOException, ReflectiveOperationException {\n@@ -228,1 +242,2 @@\n-    public void test15() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test15() throws IOException, ReflectiveOperationException {\n@@ -242,1 +257,2 @@\n-    public void test16() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test16() throws IOException, ReflectiveOperationException {\n@@ -256,1 +272,2 @@\n-    public void test17() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test17() throws IOException, ReflectiveOperationException {\n@@ -270,1 +287,2 @@\n-    public void test18() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test18() throws IOException, ReflectiveOperationException {\n@@ -284,1 +302,2 @@\n-    public void test19() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test19() throws IOException, ReflectiveOperationException {\n@@ -298,1 +317,2 @@\n-    public void test20() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test20() throws IOException, ReflectiveOperationException {\n@@ -312,1 +332,2 @@\n-    public void test21() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test21() throws IOException, ReflectiveOperationException {\n@@ -326,1 +347,2 @@\n-    public void test22() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test22() throws IOException, ReflectiveOperationException {\n@@ -340,1 +362,2 @@\n-    public void test23() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test23() throws IOException, ReflectiveOperationException {\n@@ -354,1 +377,2 @@\n-    public void test24() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test24() throws IOException, ReflectiveOperationException {\n@@ -368,1 +392,2 @@\n-    public void test25() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test25() throws IOException, ReflectiveOperationException {\n@@ -382,1 +407,2 @@\n-    public void test26() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test26() throws IOException, ReflectiveOperationException {\n@@ -395,1 +421,2 @@\n-    public void test27() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test27() throws IOException, ReflectiveOperationException {\n@@ -408,1 +435,2 @@\n-    public void test28() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test28() throws IOException, ReflectiveOperationException {\n@@ -421,1 +449,2 @@\n-    public void test29() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test29() throws IOException, ReflectiveOperationException {\n@@ -435,1 +464,2 @@\n-    public void test30() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test30() throws IOException, ReflectiveOperationException {\n@@ -449,1 +479,2 @@\n-    public void test31() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test31() throws IOException, ReflectiveOperationException {\n@@ -463,1 +494,2 @@\n-    public void test32() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test32() throws IOException, ReflectiveOperationException {\n@@ -477,1 +509,2 @@\n-    public void test33() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test33() throws IOException, ReflectiveOperationException {\n@@ -491,1 +524,2 @@\n-    public void test34() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test34() throws IOException, ReflectiveOperationException {\n@@ -505,1 +539,2 @@\n-    public void test35() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test35() throws IOException, ReflectiveOperationException {\n@@ -519,1 +554,2 @@\n-    public void test36() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test36() throws IOException, ReflectiveOperationException {\n@@ -533,1 +569,2 @@\n-    public void test37() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test37() throws IOException, ReflectiveOperationException {\n@@ -547,1 +584,2 @@\n-    public void test38() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test38() throws IOException, ReflectiveOperationException {\n@@ -561,1 +599,2 @@\n-    public void test39() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test39() throws IOException, ReflectiveOperationException {\n@@ -576,1 +615,2 @@\n-    public void test40() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test40() throws IOException, ReflectiveOperationException {\n@@ -590,1 +630,2 @@\n-    public void test41() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test41() throws IOException, ReflectiveOperationException {\n@@ -604,1 +645,2 @@\n-    public void test42() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test42() throws IOException, ReflectiveOperationException {\n@@ -618,1 +660,2 @@\n-    public void test43() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test43() throws IOException, ReflectiveOperationException {\n@@ -633,1 +676,2 @@\n-    public void test44() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test44() throws IOException, ReflectiveOperationException {\n@@ -648,1 +692,2 @@\n-    public void test45() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test45() throws IOException, ReflectiveOperationException {\n@@ -662,1 +707,2 @@\n-    public void test46() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test46() throws IOException, ReflectiveOperationException {\n@@ -676,1 +722,2 @@\n-    public void test47() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test47() throws IOException, ReflectiveOperationException {\n@@ -690,1 +737,2 @@\n-    public void test48() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test48() throws IOException, ReflectiveOperationException {\n@@ -704,1 +752,2 @@\n-    public void test49() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test49() throws IOException, ReflectiveOperationException {\n@@ -720,1 +769,2 @@\n-    public void test50() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test50() throws IOException, ReflectiveOperationException {\n@@ -735,1 +785,2 @@\n-    public void test51() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test51() throws IOException, ReflectiveOperationException {\n@@ -749,1 +800,2 @@\n-    public void test52() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test52() throws IOException, ReflectiveOperationException {\n@@ -763,1 +815,2 @@\n-    public void test53() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test53() throws IOException, ReflectiveOperationException {\n@@ -778,1 +831,2 @@\n-    public void test54() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test54() throws IOException, ReflectiveOperationException {\n@@ -793,1 +847,2 @@\n-    public void test55() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test55() throws IOException, ReflectiveOperationException {\n@@ -808,1 +863,2 @@\n-    public void test56() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test56() throws IOException, ReflectiveOperationException {\n@@ -823,1 +879,2 @@\n-    public void test57() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test57() throws IOException, ReflectiveOperationException {\n@@ -838,1 +895,2 @@\n-    public void test58() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test58() throws IOException, ReflectiveOperationException {\n@@ -853,1 +911,2 @@\n-    public void test59() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test59() throws IOException, ReflectiveOperationException {\n@@ -868,1 +927,2 @@\n-    public void test60() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test60() throws IOException, ReflectiveOperationException {\n@@ -883,1 +943,2 @@\n-    public void test61() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test61() throws IOException, ReflectiveOperationException {\n@@ -898,1 +959,2 @@\n-    public void test62() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test62() throws IOException, ReflectiveOperationException {\n@@ -913,1 +975,2 @@\n-    public void test63() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test63() throws IOException, ReflectiveOperationException {\n@@ -928,1 +991,2 @@\n-    public void test64() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test64() throws IOException, ReflectiveOperationException {\n@@ -943,1 +1007,2 @@\n-    public void test65() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test65() throws IOException, ReflectiveOperationException {\n@@ -958,1 +1023,2 @@\n-    public void test66() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test66() throws IOException, ReflectiveOperationException {\n@@ -973,1 +1039,2 @@\n-    public void test67() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void test67() throws IOException, ReflectiveOperationException {\n@@ -981,1 +1048,2 @@\n-    public void testA1() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void testA1() throws IOException, ReflectiveOperationException {\n@@ -986,1 +1054,2 @@\n-    public void testA2() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void testA2() throws IOException, ReflectiveOperationException {\n@@ -991,1 +1060,2 @@\n-    public void testA3() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void testA3() throws IOException, ReflectiveOperationException {\n@@ -996,1 +1066,2 @@\n-    public void testA4() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void testA4() throws IOException, ReflectiveOperationException {\n@@ -1002,1 +1073,2 @@\n-    public void testA5() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void testA5() throws IOException, ReflectiveOperationException {\n@@ -1007,1 +1079,2 @@\n-    public void testA6() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void testA6() throws IOException, ReflectiveOperationException {\n@@ -1013,1 +1086,2 @@\n-    public void testA7() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void testA7() throws IOException, ReflectiveOperationException {\n@@ -1018,1 +1092,2 @@\n-    public void testA8() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void testA8() throws IOException, ReflectiveOperationException {\n@@ -1022,1 +1097,2 @@\n-    public void testA9() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void testA9() throws IOException, ReflectiveOperationException {\n@@ -1027,1 +1103,2 @@\n-    public void testA10() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void testA10() throws IOException, ReflectiveOperationException {\n@@ -1031,1 +1108,2 @@\n-    public void testA11() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void testA11() throws IOException, ReflectiveOperationException {\n@@ -1039,1 +1117,2 @@\n-    public void testB1() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void testB1() throws IOException, ReflectiveOperationException {\n@@ -1046,1 +1125,2 @@\n-    public void testB2() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void testB2() throws IOException, ReflectiveOperationException {\n@@ -1059,1 +1139,2 @@\n-    public void testB5() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void testB5() throws IOException, ReflectiveOperationException {\n@@ -1064,1 +1145,2 @@\n-    public void testB6() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void testB6() throws IOException, ReflectiveOperationException {\n@@ -1069,1 +1151,2 @@\n-    public void testB7() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void testB7() throws IOException, ReflectiveOperationException {\n@@ -1074,1 +1157,2 @@\n-    public void testB8() throws IOException, ReflectiveOperationException {\n+    @Test\n+    void testB8() throws IOException, ReflectiveOperationException {\n","filename":"test\/langtools\/tools\/javac\/lambda\/bridge\/template_tests\/BridgeMethodsTemplateTest.java","additions":173,"deletions":89,"binary":false,"changes":262,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# This file identifies root(s) of the test-ng hierarchy.\n+# This file identifies root(s) of the JUnit hierarchy.\n@@ -3,1 +3,1 @@\n-TestNG.dirs = .\n+JUnit.dirs = .\n","filename":"test\/langtools\/tools\/javac\/lambda\/bridge\/template_tests\/TEST.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n- * @run testng BoundUnboundSearchTest\n+ * @run junit BoundUnboundSearchTest\n@@ -43,1 +43,1 @@\n-import org.testng.annotations.Test;\n+import org.junit.jupiter.api.Test;\n@@ -46,4 +46,1 @@\n-import static org.testng.Assert.assertEquals;\n-\n-@Test\n-public class BoundUnboundSearchTest extends CompilationTestCase {\n+class BoundUnboundSearchTest extends CompilationTestCase {\n@@ -61,1 +58,1 @@\n-    public BoundUnboundSearchTest() {\n+    BoundUnboundSearchTest() {\n@@ -78,1 +75,2 @@\n-    public void test() {\n+    @Test\n+    void test() {\n","filename":"test\/langtools\/tools\/javac\/lambda\/methodReference\/BoundUnboundSearchTest.java","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8318160\n+ * @summary javac does not reject private method reference with type-variable receiver\n+ * @compile\/fail\/ref=PrivateMethodReferenceWithTypeVarTest.out -XDrawDiagnostics PrivateMethodReferenceWithTypeVarTest.java\n+ *\/\n+\n+import java.util.function.*;\n+\n+class PrivateMethodReferenceWithTypeVarTest {\n+    class Foo<X> {\n+        X get() { return null; }\n+    }\n+\n+    private String asString() {\n+        return \"bar\";\n+    }\n+\n+    private String asString2(Object o) {\n+        return \"bar\";\n+    }\n+\n+    static <T extends PrivateMethodReferenceWithTypeVarTest> Function<T, String> m1() {\n+        return T::asString;\n+    }\n+\n+    static <T extends PrivateMethodReferenceWithTypeVarTest> Function<T, String> m2(T t) {\n+        return t::asString2;\n+    }\n+\n+    static Function<?, String> m2(Foo<? extends PrivateMethodReferenceWithTypeVarTest> foo) {\n+        return foo.get()::asString2;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/lambda\/methodReference\/PrivateMethodReferenceWithTypeVarTest.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,4 @@\n+PrivateMethodReferenceWithTypeVarTest.java:24:16: compiler.err.report.access: asString(), private, PrivateMethodReferenceWithTypeVarTest\n+PrivateMethodReferenceWithTypeVarTest.java:28:16: compiler.err.report.access: asString2(java.lang.Object), private, PrivateMethodReferenceWithTypeVarTest\n+PrivateMethodReferenceWithTypeVarTest.java:32:16: compiler.err.report.access: asString2(java.lang.Object), private, PrivateMethodReferenceWithTypeVarTest\n+3 errors\n","filename":"test\/langtools\/tools\/javac\/lambda\/methodReference\/PrivateMethodReferenceWithTypeVarTest.out","additions":4,"deletions":0,"binary":false,"changes":4,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/**\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8314578\n+ * @enablePreview\n+ * @summary Parsing of erroneous patterns succeeds\n+ * @compile\/fail\/ref=T8314578.out -XDrawDiagnostics T8314578.java\n+ *\/\n+public class T8314578 {\n+    record R1() {}\n+    record R2() {}\n+\n+    static void test(Object o) {\n+        switch (o) {\n+            case R1() when o instanceof String s:\n+            case R2() when o instanceof Integer i:\n+                System.out.println(\"hello: \" + i);\n+                break;\n+            default:\n+                break;\n+        }\n+    }\n+\n+    static void test2(Object o) {\n+        switch (o) {\n+            case R1() when o instanceof String s:\n+                System.out.println(\"hello: \" + s);\n+            case R2() when o instanceof Integer i:\n+                System.out.println(\"hello: \" + i);\n+                break;\n+            default:\n+                break;\n+        }\n+    }\n+\n+    static int unnamedInGuardsOK(String s) {\n+        return switch (s) {\n+            case String _ when s instanceof String _ ->  \/\/ should be OK\n+                    1;\n+            default ->\n+                    -1;\n+        };\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/patterns\/T8314578.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,6 @@\n+T8314578.java:14:18: compiler.err.flows.through.from.pattern\n+T8314578.java:15:18: compiler.err.flows.through.to.pattern\n+T8314578.java:27:18: compiler.err.flows.through.to.pattern\n+- compiler.note.preview.filename: T8314578.java, DEFAULT\n+- compiler.note.preview.recompile\n+3 errors\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/patterns\/T8314578.out","additions":6,"deletions":0,"binary":false,"changes":6,"status":"added"},{"patch":"@@ -0,0 +1,24 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8317300\n+ * @summary javac erroneously allows \"final\" in front of a record pattern\n+ * @compile\/fail\/ref=T8317300.out -XDrawDiagnostics T8317300.java\n+ *\/\n+public class T8317300 {\n+    record Foo (int x) {}\n+    record Bar (Foo x) {}\n+\n+    void test1(Object obj) {\n+        switch (obj) {\n+            case final Foo(int x) -> {}\n+            default -> {}\n+        }\n+    }\n+\n+    void test2(Object obj) {\n+        switch (obj) {\n+            case Bar(final Foo(int x)) -> {}\n+            default -> {}\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/T8317300.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"added"},{"patch":"@@ -0,0 +1,5 @@\n+T8317300.java:13:18: compiler.err.mod.not.allowed.here: final\n+T8317300.java:20:22: compiler.err.illegal.start.of.expr\n+T8317300.java:20:31: compiler.err.expected: token.identifier\n+T8317300.java:20:37: compiler.err.expected: ';'\n+4 errors\n","filename":"test\/langtools\/tools\/javac\/patterns\/T8317300.out","additions":5,"deletions":0,"binary":false,"changes":5,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n-import java.util.List;\n@@ -28,4 +27,1 @@\n-\n-import org.testng.ITestResult;\n-import org.testng.annotations.AfterMethod;\n-import org.testng.annotations.Test;\n+import org.junit.jupiter.api.Test;\n@@ -34,4 +30,1 @@\n-import static java.util.stream.Collectors.toList;\n-\n-@Test\n-public class ScopeTest extends JavacTemplateTestBase {\n+class ScopeTest extends JavacTemplateTestBase {\n@@ -87,8 +80,0 @@\n-    @AfterMethod\n-    public void dumpTemplateIfError(ITestResult result) {\n-        \/\/ Make sure offending template ends up in log file on failure\n-        if (!result.isSuccess()) {\n-            System.err.printf(\"Diagnostics: %s%nTemplate: %s%n\", diags.errorKeys(), sourceFiles.stream().map(p -> p.snd).collect(toList()));\n-        }\n-    }\n-\n@@ -124,1 +109,2 @@\n-    public void testIf() {\n+    @Test\n+    void testIf() {\n@@ -131,1 +117,2 @@\n-    public void testWhile() {\n+    @Test\n+    void testWhile() {\n@@ -136,1 +123,2 @@\n-    public void testDoWhile() {\n+    @Test\n+    void testDoWhile() {\n@@ -141,1 +129,2 @@\n-    public void testFor() {\n+    @Test\n+    void testFor() {\n","filename":"test\/langtools\/tools\/javac\/patterns\/scope\/ScopeTest.java","additions":11,"deletions":22,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-TestNG.dirs = .\n+JUnit.dirs = .\n","filename":"test\/langtools\/tools\/javac\/patterns\/scope\/TEST.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n- * @run testng\/othervm LocalStaticDeclarations2\n+ * @run junit\/othervm LocalStaticDeclarations2\n@@ -35,1 +35,1 @@\n-import org.testng.annotations.Test;\n+import org.junit.jupiter.api.Test;\n@@ -38,5 +38,3 @@\n-import static org.testng.Assert.assertEquals;\n-\n-@Test\n-public class LocalStaticDeclarations2 extends CompilationTestCase {\n-    public void testLocalStatic() {\n+class LocalStaticDeclarations2 extends CompilationTestCase {\n+    @Test\n+    void testLocalStatic() {\n","filename":"test\/langtools\/tools\/javac\/records\/LocalStaticDeclarations2.java","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,2 +42,2 @@\n- * @run testng\/othervm -DuseAP=false RecordCompilationTests\n- * @run testng\/othervm -DuseAP=true RecordCompilationTests\n+ * @run junit\/othervm -DuseAP=false RecordCompilationTests\n+ * @run junit\/othervm -DuseAP=true RecordCompilationTests\n@@ -84,1 +84,0 @@\n-import org.testng.annotations.Test;\n@@ -86,0 +85,1 @@\n+import org.junit.jupiter.api.Test;\n@@ -88,1 +88,0 @@\n-import static org.testng.Assert.assertEquals;\n@@ -102,2 +101,1 @@\n-@Test\n-public class RecordCompilationTests extends CompilationTestCase {\n+class RecordCompilationTests extends CompilationTestCase {\n@@ -131,1 +129,2 @@\n-    public void testMalformedDeclarations() {\n+    @Test\n+    void testMalformedDeclarations() {\n@@ -153,1 +152,2 @@\n-    public void testGoodDeclarations() {\n+    @Test\n+    void testGoodDeclarations() {\n@@ -183,1 +183,2 @@\n-    public void testGoodMemberDeclarations() {\n+    @Test\n+    void testGoodMemberDeclarations() {\n@@ -194,1 +195,2 @@\n-    public void testBadComponentNames() {\n+    @Test\n+    void testBadComponentNames() {\n@@ -199,1 +201,2 @@\n-    public void testRestrictedIdentifiers() {\n+    @Test\n+    void testRestrictedIdentifiers() {\n@@ -218,1 +221,2 @@\n-    public void testValidMembers() {\n+    @Test\n+    void testValidMembers() {\n@@ -229,1 +233,2 @@\n-    public void testCyclic() {\n+    @Test\n+    void testCyclic() {\n@@ -234,1 +239,2 @@\n-    public void testBadExtends() {\n+    @Test\n+    void testBadExtends() {\n@@ -242,1 +248,2 @@\n-    public void testNoExtendRecord() {\n+    @Test\n+    void testNoExtendRecord() {\n@@ -254,1 +261,2 @@\n-    public void testFieldDeclarations() {\n+    @Test\n+    void testFieldDeclarations() {\n@@ -282,1 +290,2 @@\n-    public void testAccessorRedeclaration() {\n+    @Test\n+    void testAccessorRedeclaration() {\n@@ -338,1 +347,2 @@\n-    public void testConstructorRedeclaration() {\n+    @Test\n+    void testConstructorRedeclaration() {\n@@ -429,1 +439,2 @@\n-    public void testAnnotationCriteria() {\n+    @Test\n+    void testAnnotationCriteria() {\n@@ -438,1 +449,1 @@\n-        assertEquals(goodSet.size() + badSet.size(), values().length);\n+        Assert.check(goodSet.size() + badSet.size() == values().length);\n@@ -462,1 +473,2 @@\n-    public void testNestedRecords() {\n+    @Test\n+    void testNestedRecords() {\n@@ -480,1 +492,2 @@\n-    public void testDuplicatedMember() {\n+    @Test\n+    void testDuplicatedMember() {\n@@ -489,1 +502,2 @@\n-    public void testStaticLocals() {\n+    @Test\n+    void testStaticLocals() {\n@@ -579,1 +593,2 @@\n-    public void testStaticDefinitionsInInnerClasses() {\n+    @Test\n+    void testStaticDefinitionsInInnerClasses() {\n@@ -1045,1 +1060,2 @@\n-    public void testReturnInCanonical_Compact() {\n+    @Test\n+    void testReturnInCanonical_Compact() {\n@@ -1054,1 +1070,2 @@\n-    public void testArgumentsAreNotFinalInCompact() {\n+    @Test\n+    void testArgumentsAreNotFinalInCompact() {\n@@ -1065,1 +1082,2 @@\n-    public void testNoNativeMethods() {\n+    @Test\n+    void testNoNativeMethods() {\n@@ -1072,1 +1090,2 @@\n-    public void testRecordsInsideInner() {\n+    @Test\n+    void testRecordsInsideInner() {\n@@ -1113,1 +1132,2 @@\n-    public void testAnnoInsideLocalOrAnonymous() {\n+    @Test\n+    void testAnnoInsideLocalOrAnonymous() {\n@@ -1217,1 +1237,2 @@\n-    public void testReceiverParameter() {\n+    @Test\n+    void testReceiverParameter() {\n@@ -1245,1 +1266,2 @@\n-    public void testOnlyOneFieldRef() throws Exception {\n+    @Test\n+    void testOnlyOneFieldRef() throws Exception {\n@@ -1295,1 +1317,2 @@\n-    public void testCheckInitializationOrderInCompactConstructor() throws Exception {\n+    @Test\n+    void testCheckInitializationOrderInCompactConstructor() throws Exception {\n@@ -1334,1 +1357,2 @@\n-    public void testAcceptRecordId() {\n+    @Test\n+    void testAcceptRecordId() {\n@@ -1351,1 +1375,2 @@\n-    public void testMultipleAnnosInRecord() throws Exception {\n+    @Test\n+    void testMultipleAnnosInRecord() throws Exception {\n@@ -1392,1 +1417,2 @@\n-    public void testAnnos() throws Exception {\n+    @Test\n+    void testAnnos() throws Exception {\n@@ -1535,1 +1561,2 @@\n-    public void testOnlyTypeAnnotationsOnComponentField() throws Exception {\n+    @Test\n+    void testOnlyTypeAnnotationsOnComponentField() throws Exception {\n@@ -1758,1 +1785,2 @@\n-    public void testMethodsInheritedFromRecordArePublicAndFinal() throws Exception {\n+    @Test\n+    void testMethodsInheritedFromRecordArePublicAndFinal() throws Exception {\n@@ -1777,1 +1805,2 @@\n-    public void testCanonicalAccessibility() throws Exception {\n+    @Test\n+    void testCanonicalAccessibility() throws Exception {\n@@ -1826,1 +1855,2 @@\n-    public void testSameArity() {\n+    @Test\n+    void testSameArity() {\n@@ -1900,1 +1930,2 @@\n-    public void testSafeVararsAnno() {\n+    @Test\n+    void testSafeVararsAnno() {\n@@ -1962,1 +1993,2 @@\n-    public void testOverrideAtAccessor() {\n+    @Test\n+    void testOverrideAtAccessor() {\n@@ -2000,1 +2032,2 @@\n-    public void testNoAssigmentInsideCompactRecord() {\n+    @Test\n+    void testNoAssigmentInsideCompactRecord() {\n@@ -2021,1 +2054,2 @@\n-    public void testNoNPEStaticAnnotatedFields() {\n+    @Test\n+    void testNoNPEStaticAnnotatedFields() {\n@@ -2054,1 +2088,2 @@\n-    public void testDoNotAllowCStyleArraySyntaxForRecComponents() {\n+    @Test\n+    void testDoNotAllowCStyleArraySyntaxForRecComponents() {\n@@ -2072,1 +2107,2 @@\n-    public void testNoWarningForSerializableRecords() {\n+    @Test\n+    void testNoWarningForSerializableRecords() {\n@@ -2087,1 +2123,2 @@\n-    public void testAnnotationsOnVarargsRecComp() {\n+    @Test\n+    void testAnnotationsOnVarargsRecComp() {\n@@ -2122,1 +2159,2 @@\n-    public void testSaveVarargsAnno() {\n+    @Test\n+    void testSaveVarargsAnno() {\n","filename":"test\/langtools\/tools\/javac\/records\/RecordCompilationTests.java","additions":86,"deletions":48,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,2 +36,2 @@\n- * @run testng\/othervm -DuseAP=false SealedCompilationTests\n- * @run testng\/othervm -DuseAP=true SealedCompilationTests\n+ * @run junit\/othervm -DuseAP=false SealedCompilationTests\n+ * @run junit\/othervm -DuseAP=true SealedCompilationTests\n@@ -40,4 +40,0 @@\n-import java.lang.constant.ClassDesc;\n-\n-import java.io.File;\n-\n@@ -48,2 +44,0 @@\n-\n-import java.util.ArrayList;\n@@ -57,1 +51,0 @@\n-\n@@ -63,4 +56,1 @@\n-import static org.testng.Assert.assertEquals;\n-import static org.testng.Assert.assertTrue;\n-import static org.testng.Assert.fail;\n-import org.testng.annotations.Test;\n+import org.junit.jupiter.api.Test;\n@@ -74,2 +64,3 @@\n-@Test\n-public class SealedCompilationTests extends CompilationTestCase {\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+class SealedCompilationTests extends CompilationTestCase {\n@@ -97,1 +88,1 @@\n-    public SealedCompilationTests() {\n+    SealedCompilationTests() {\n@@ -119,1 +110,2 @@\n-    public void testSimpleExtension() {\n+    @Test\n+    void testSimpleExtension() {\n@@ -197,1 +189,2 @@\n-    public void testSealedAndRecords() {\n+    @Test\n+    void testSealedAndRecords() {\n@@ -213,1 +206,2 @@\n-    public void testBadExtension() {\n+    @Test\n+    void testBadExtension() {\n@@ -244,1 +238,2 @@\n-    public void testRestrictedKeyword() {\n+    @Test\n+    void testRestrictedKeyword() {\n@@ -292,1 +287,2 @@\n-    public void testRejectPermitsInNonSealedClass() {\n+    @Test\n+    void testRejectPermitsInNonSealedClass() {\n@@ -305,1 +301,2 @@\n-    public void testTypeInPermitsIsSameClassOrSuper() {\n+    @Test\n+    void testTypeInPermitsIsSameClassOrSuper() {\n@@ -329,1 +326,2 @@\n-    public void testBadModifiers() {\n+    @Test\n+    void testBadModifiers() {\n@@ -347,1 +345,2 @@\n-    public void testAnonymous_FunctionalExpr_and_Sealed() {\n+    @Test\n+    void testAnonymous_FunctionalExpr_and_Sealed() {\n@@ -406,1 +405,2 @@\n-    public void testNoLocalSealedClasses() {\n+    @Test\n+    void testNoLocalSealedClasses() {\n@@ -425,1 +425,2 @@\n-    public void testLocalCantExtendSealed() {\n+    @Test\n+    void testLocalCantExtendSealed() {\n@@ -457,1 +458,2 @@\n-    public void testSealedInterfaceAndAbstracClasses() {\n+    @Test\n+    void testSealedInterfaceAndAbstracClasses() {\n@@ -499,1 +501,2 @@\n-    public void testEnumsCantBeSealedOrNonSealed() {\n+    @Test\n+    void testEnumsCantBeSealedOrNonSealed() {\n@@ -514,1 +517,2 @@\n-    public void testEnumsCanImplementSealedInterfaces() {\n+    @Test\n+    void testEnumsCanImplementSealedInterfaces() {\n@@ -524,1 +528,2 @@\n-    public void testClassesCanExtendNonSealed() {\n+    @Test\n+    void testClassesCanExtendNonSealed() {\n@@ -537,1 +542,2 @@\n-    public void testEmptyPermits() {\n+    @Test\n+    void testEmptyPermits() {\n@@ -547,1 +553,2 @@\n-    public void testTypeVarInPermits() {\n+    @Test\n+    void testTypeVarInPermits() {\n@@ -558,1 +565,2 @@\n-    public void testRepeatedTypeInPermits() {\n+    @Test\n+    void testRepeatedTypeInPermits() {\n@@ -569,1 +577,2 @@\n-    public void testSubtypeDoesntExtendSealed() {\n+    @Test\n+    void testSubtypeDoesntExtendSealed() {\n@@ -593,1 +602,2 @@\n-    public void testAPIForPrimitiveAndArrayClasses() {\n+    @Test\n+    void testAPIForPrimitiveAndArrayClasses() {\n@@ -602,1 +612,2 @@\n-    public void testPrinting() throws Exception {\n+    @Test\n+    void testPrinting() throws Exception {\n@@ -718,1 +729,2 @@\n-    public void testNonSealedErroneousSuper() {\n+    @Test\n+    void testNonSealedErroneousSuper() {\n@@ -730,1 +742,2 @@\n-    public void testNonSealedErroneousSuperInterface() {\n+    @Test\n+    void testNonSealedErroneousSuperInterface() {\n@@ -742,1 +755,2 @@\n-    public void testIllFormedNonSealed() {\n+    @Test\n+    void testIllFormedNonSealed() {\n@@ -770,1 +784,2 @@\n-    public void testPermitsClause() {\n+    @Test\n+    void testPermitsClause() {\n@@ -832,1 +847,2 @@\n-    public void testSealedNonSealedWithOtherModifiers() {\n+    @Test\n+    void testSealedNonSealedWithOtherModifiers() {\n@@ -875,1 +891,2 @@\n-    public void testSubClassBeforeSealedClassInSameCU() {\n+    @Test\n+    void testSubClassBeforeSealedClassInSameCU() {\n@@ -954,1 +971,2 @@\n-    public void testDoNotAllowSealedAnnotation() {\n+    @Test\n+    void testDoNotAllowSealedAnnotation() {\n@@ -965,1 +983,2 @@\n-    public void testNarrowConversion() {\n+    @Test\n+    void testNarrowConversion() {\n@@ -1267,1 +1286,2 @@\n-    public void testIntersectionWithSealedClasses() {\n+    @Test\n+    void testIntersectionWithSealedClasses() {\n","filename":"test\/langtools\/tools\/javac\/sealed\/SealedCompilationTests.java","additions":66,"deletions":46,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -0,0 +1,147 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8316470\n+ * @summary Verify correct source file is set while reporting errors for sealing from Attr\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @run main SealedErrorPositions\n+*\/\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+\n+import toolbox.TestRunner;\n+import toolbox.JavacTask;\n+import toolbox.Task;\n+import toolbox.ToolBox;\n+\n+public class SealedErrorPositions extends TestRunner {\n+\n+    ToolBox tb;\n+\n+    public static void main(String... args) throws Exception {\n+        new SealedErrorPositions().runTests();\n+    }\n+\n+    SealedErrorPositions() {\n+        super(System.err);\n+        tb = new ToolBox();\n+    }\n+\n+    public void runTests() throws Exception {\n+        runTests(m -> new Object[] { Paths.get(m.getName()) });\n+    }\n+\n+    @Test\n+    public void testDoesNotExtendErrorPosition(Path base) throws IOException {\n+        Path current = base.resolve(\".\");\n+        Path src = current.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                           \"\"\"\n+                           package test;\n+                           sealed class C permits A, B { }\n+                           \"\"\",\n+                           \"\"\"\n+                           package test;\n+                           final class A extends C { }\n+                           \"\"\",\n+                           \"\"\"\n+                           package test;\n+                           final class B { }\n+                           \"\"\");\n+        Path test = src.resolve(\"test\");\n+        Path classes = current.resolve(\"classes\");\n+\n+        Files.createDirectories(classes);\n+\n+        var log =\n+                new JavacTask(tb)\n+                    .options(\"-XDrawDiagnostics\",\n+                             \"-implicit:none\",\n+                             \"-sourcepath\", src.toString())\n+                    .outdir(classes)\n+                    .files(test.resolve(\"A.java\"))\n+                    .run(Task.Expect.FAIL)\n+                    .writeAll()\n+                    .getOutputLines(Task.OutputKind.DIRECT);\n+\n+        List<String> expectedErrors = List.of(\n+               \"C.java:2:27: compiler.err.invalid.permits.clause: (compiler.misc.doesnt.extend.sealed: test.B)\",\n+               \"1 error\");\n+\n+        if (!expectedErrors.equals(log)) {\n+            throw new AssertionError(\"Incorrect errors, expected: \" + expectedErrors +\n+                                      \", actual: \" + log);\n+        }\n+    }\n+\n+    @Test\n+    public void testEmptyImplicitPermitsErrorPosition(Path base) throws IOException {\n+        Path current = base.resolve(\".\");\n+        Path src = current.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                           \"\"\"\n+                           package test;\n+                           sealed class C { }\n+                           \"\"\",\n+                           \"\"\"\n+                           package test;\n+                           final class A extends C { }\n+                           \"\"\");\n+        Path test = src.resolve(\"test\");\n+        Path classes = current.resolve(\"classes\");\n+\n+        Files.createDirectories(classes);\n+\n+        var log =\n+                new JavacTask(tb)\n+                    .options(\"-XDrawDiagnostics\",\n+                             \"-implicit:none\",\n+                             \"-sourcepath\", src.toString())\n+                    .outdir(classes)\n+                    .files(test.resolve(\"A.java\"))\n+                    .run(Task.Expect.FAIL)\n+                    .writeAll()\n+                    .getOutputLines(Task.OutputKind.DIRECT);\n+\n+        List<String> expectedErrors = List.of(\n+               \"C.java:2:8: compiler.err.sealed.class.must.have.subclasses\",\n+               \"A.java:2:7: compiler.err.cant.inherit.from.sealed: test.C\",\n+               \"2 errors\");\n+\n+        if (!expectedErrors.equals(log)) {\n+            throw new AssertionError(\"Incorrect errors, expected: \" + expectedErrors +\n+                                      \", actual: \" + log);\n+        }\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/sealed\/SealedErrorPositions.java","additions":147,"deletions":0,"binary":false,"changes":147,"status":"added"},{"patch":"@@ -604,0 +604,46 @@\n+\n+    \/\/ Verify no assertion error occurs (JDK-8317336)\n+    public static class ThisEscapeAssertionError {\n+        public ThisEscapeAssertionError() {\n+            System.out.println((Supplier<Object>)() -> this);\n+        }\n+    }\n+\n+    \/\/ Verify no assertion error occurs (JDK-8317336)\n+    public static class ThisEscapeAssertionError2 {\n+        public ThisEscapeAssertionError2() {\n+            ThisEscapeAssertionError2[] array = new ThisEscapeAssertionError2[] { this };\n+            for (Object obj : array)\n+                ;\n+        }\n+    }\n+\n+    \/\/ Verify no infinite recursion loop occurs (JDK-8317818)\n+    public static class ThisEscapeRecursionExplosion {\n+        private Object obj;\n+        public ThisEscapeRecursionExplosion() {\n+            getObject();\n+        }\n+        private Object getObject() {\n+            if (this.obj == null) {\n+                this.obj = new Object();\n+                getObject().hashCode();\n+                getObject().hashCode();\n+                getObject().hashCode();\n+                getObject().hashCode();\n+                getObject().hashCode();\n+                getObject().hashCode();\n+                getObject().hashCode();\n+                getObject().hashCode();\n+                getObject().hashCode();\n+                getObject().hashCode();\n+                getObject().hashCode();\n+                getObject().hashCode();\n+                getObject().hashCode();\n+                getObject().hashCode();\n+                getObject().hashCode();\n+                getObject().hashCode();\n+            }\n+            return this.obj;\n+        }\n+    }\n","filename":"test\/langtools\/tools\/javac\/warnings\/ThisEscape.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -555,0 +555,40 @@\n+    \/**\n+     * A functional interface for executing tests in assertThrownException\n+     *\/\n+    @FunctionalInterface\n+    public interface TestMethod {\n+        void execute() throws Throwable;\n+    }\n+\n+\n+    public static <T extends Throwable> T assertThrows(Class<T> expected, TestMethod testMethod) {\n+        return assertThrows(expected, testMethod, \"An unexpected exception was thrown.\");\n+    }\n+\n+    \/**\n+     * Asserts that the given exception (or a subclass of it) is thrown when\n+     * executing the test method.\n+     *\n+     * If the test method throws the correct exception, the exception is returned\n+     * to the caller for additional validation e.g., comparing the exception\n+     * message.\n+     *\n+     * @param expected The expected exception\n+     * @param testMethod The code to execute that should throw the exception\n+     * @param msg A description of the assumption\n+     * @return The thrown exception.\n+     *\/\n+    public static <T extends Throwable> T assertThrows(Class<T> expected, TestMethod testMethod, String msg) {\n+        try {\n+            testMethod.execute();\n+        } catch (Throwable exc) {\n+            if (expected.isInstance(exc)) {\n+                return (T) exc;\n+            } else {\n+                fail(Objects.toString(msg, \"An unexpected exception was thrown.\")\n+                        + \" Expected \" + expected.getName(), exc);\n+            }\n+        }\n+        throw new RuntimeException(\"No exception was thrown. Expected: \" + expected.getName());\n+    }\n+\n","filename":"test\/lib\/jdk\/test\/lib\/Asserts.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,3 +56,3 @@\n-    \/\/ referers and referersLen go through two phases:  Building and\n-    \/\/ resolved.  When building, referers might have duplicates, but can\n-    \/\/ be appended to.  When resolved, referers has no duplicates or\n+    \/\/ referrers and referrersLen go through two phases:  Building and\n+    \/\/ resolved.  When building, referrers might have duplicates, but can\n+    \/\/ be appended to.  When resolved, referrers has no duplicates or\n@@ -61,2 +61,2 @@\n-    private JavaThing[] referers = null;\n-    private int referersLen = 0;        \/\/ -1 when resolved\n+    private JavaThing[] referrers = null;\n+    private int referrersLen = 0;        \/\/ -1 when resolved\n@@ -80,1 +80,1 @@\n-    \/\/  Eliminate duplicates from referers, and size the array exactly.\n+    \/\/ Eliminate duplicates from referrers, and size the array exactly.\n@@ -82,1 +82,1 @@\n-    \/\/ referers data member for details.\n+    \/\/ referrers data member for details.\n@@ -84,3 +84,3 @@\n-    void setupReferers() {\n-        if (referersLen > 1) {\n-            \/\/ Copy referers to map, screening out duplicates\n+    void setupReferrers() {\n+        if (referrersLen > 1) {\n+            \/\/ Copy referrers to map, screening out duplicates\n@@ -88,3 +88,3 @@\n-            for (int i = 0; i < referersLen; i++) {\n-                if (map.get(referers[i]) == null) {\n-                    map.put(referers[i], referers[i]);\n+            for (int i = 0; i < referrersLen; i++) {\n+                if (map.get(referrers[i]) == null) {\n+                    map.put(referrers[i], referrers[i]);\n@@ -95,2 +95,2 @@\n-            referers = new JavaThing[map.size()];\n-            map.keySet().toArray(referers);\n+            referrers = new JavaThing[map.size()];\n+            map.keySet().toArray(referrers);\n@@ -98,1 +98,1 @@\n-        referersLen = -1;\n+        referrersLen = -1;\n@@ -137,6 +137,6 @@\n-        if (referersLen == 0) {\n-            referers = new JavaThing[1];        \/\/ It was null\n-        } else if (referersLen == referers.length) {\n-            JavaThing[] copy = new JavaThing[(3 * (referersLen + 1)) \/ 2];\n-            System.arraycopy(referers, 0, copy, 0, referersLen);\n-            referers = copy;\n+        if (referrersLen == 0) {\n+            referrers = new JavaThing[1];        \/\/ It was null\n+        } else if (referrersLen == referrers.length) {\n+            JavaThing[] copy = new JavaThing[(3 * (referrersLen + 1)) \/ 2];\n+            System.arraycopy(referrers, 0, copy, 0, referrersLen);\n+            referrers = copy;\n@@ -144,2 +144,2 @@\n-        referers[referersLen++] = other;\n-        \/\/ We just append to referers here.  Measurements have shown that\n+        referrers[referrersLen++] = other;\n+        \/\/ We just append to referrers here.  Measurements have shown that\n@@ -167,2 +167,2 @@\n-    public Enumeration<JavaThing> getReferers() {\n-        if (referersLen != -1) {\n+    public Enumeration<JavaThing> getReferrers() {\n+        if (referrersLen != -1) {\n@@ -176,1 +176,1 @@\n-                return referers != null && num < referers.length;\n+                return referrers != null && num < referrers.length;\n@@ -180,1 +180,1 @@\n-                return referers[num++];\n+                return referrers[num++];\n@@ -186,1 +186,1 @@\n-     * Given other, which the caller promises is in referers, determines if\n+     * Given other, which the caller promises is in referrers, determines if\n","filename":"test\/lib\/jdk\/test\/lib\/hprof\/model\/JavaHeapObject.java","additions":30,"deletions":30,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,2 +49,2 @@\n-    private long refererId;     \/\/ Thread or Class responsible for this, or 0\n-    private int index = -1;             \/\/ Index in Snapshot.roots\n+    private long referrerId;    \/\/ Thread or Class responsible for this, or 0\n+    private int index = -1;     \/\/ Index in Snapshot.roots\n@@ -53,1 +53,1 @@\n-    private JavaHeapObject referer = null;\n+    private JavaHeapObject referrer = null;\n@@ -71,2 +71,2 @@\n-    public Root(long id, long refererId, int type, String description) {\n-        this(id, refererId, type, description, null);\n+    public Root(long id, long referrerId, int type, String description) {\n+        this(id, referrerId, type, description, null);\n@@ -76,1 +76,1 @@\n-    public Root(long id, long refererId, int type, String description,\n+    public Root(long id, long referrerId, int type, String description,\n@@ -79,1 +79,1 @@\n-        this.refererId = refererId;\n+        this.referrerId = referrerId;\n@@ -140,2 +140,6 @@\n-    public JavaHeapObject getReferer() {\n-        return referer;\n+    public JavaHeapObject getReferrer() {\n+        return referrer;\n+    }\n+\n+    public long getReferrerId() {\n+        return referrerId;\n@@ -160,2 +164,2 @@\n-        if (refererId != 0) {\n-            referer = ss.findThing(refererId);\n+        if (referrerId != 0) {\n+            referrer = ss.findThing(referrerId);\n","filename":"test\/lib\/jdk\/test\/lib\/hprof\/model\/Root.java","additions":16,"deletions":12,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,0 +85,3 @@\n+    \/\/ threads\n+    private ArrayList<ThreadObject> threads = new ArrayList<>();\n+\n@@ -178,0 +181,4 @@\n+    public void addThreadObject(ThreadObject thread) {\n+        threads.add(thread);\n+    }\n+\n@@ -296,1 +303,1 @@\n-            t.setupReferers();\n+            t.setupReferrers();\n@@ -436,0 +443,4 @@\n+    public List<ThreadObject> getThreads() {\n+        return Collections.unmodifiableList(threads);\n+    }\n+\n@@ -453,1 +464,1 @@\n-                \/\/ referers, because they might be more interesting.\n+                \/\/ referrers, because they might be more interesting.\n@@ -455,3 +466,3 @@\n-            Enumeration<JavaThing> referers = curr.getReferers();\n-            while (referers.hasMoreElements()) {\n-                JavaHeapObject t = (JavaHeapObject) referers.nextElement();\n+            Enumeration<JavaThing> referrers = curr.getReferrers();\n+            while (referrers.hasMoreElements()) {\n+                JavaHeapObject t = (JavaHeapObject)referrers.nextElement();\n","filename":"test\/lib\/jdk\/test\/lib\/hprof\/model\/Snapshot.java","additions":17,"deletions":6,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.hprof.model;\n+\n+import jdk.test.lib.hprof.util.Misc;\n+\n+public class ThreadObject {\n+\n+    private final long id;            \/\/ ID of the JavaThing we refer to\n+    private final StackTrace stackTrace;\n+\n+    public ThreadObject(long id, StackTrace stackTrace) {\n+        this.id = id;\n+        this.stackTrace = stackTrace;\n+    }\n+\n+    public long getId() {\n+        return id;\n+    }\n+\n+    public String getIdString() {\n+        return Misc.toHex(id);\n+    }\n+\n+    public StackTrace getStackTrace() {\n+        return stackTrace;\n+    }\n+\n+    void resolve(Snapshot ss) {\n+        if (stackTrace != null) {\n+            stackTrace.resolve(ss);\n+        }\n+    }\n+\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/hprof\/model\/ThreadObject.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -439,2 +439,4 @@\n-                    threadObjects.put(threadSeq,\n-                                      new ThreadObject(id, stackSeq));\n+                    StackTrace st = getStackTraceFromSerial(stackSeq);\n+                    ThreadObject threadObj = new ThreadObject(id, st);\n+                    threadObjects.put(threadSeq, threadObj);\n+                    snapshot.addThreadObject(threadObj);\n@@ -456,1 +458,1 @@\n-                    StackTrace st = getStackTraceFromSerial(to.stackSeq);\n+                    StackTrace st = to.getStackTrace();\n@@ -460,1 +462,1 @@\n-                    snapshot.addRoot(new Root(id, to.threadId,\n+                    snapshot.addRoot(new Root(id, to.getId(),\n@@ -470,1 +472,1 @@\n-                    StackTrace st = getStackTraceFromSerial(to.stackSeq);\n+                    StackTrace st = to.getStackTrace();;\n@@ -474,1 +476,1 @@\n-                    snapshot.addRoot(new Root(id, to.threadId,\n+                    snapshot.addRoot(new Root(id, to.getId(),\n@@ -483,2 +485,2 @@\n-                    StackTrace st = getStackTraceFromSerial(to.stackSeq);\n-                    snapshot.addRoot(new Root(id, to.threadId,\n+                    StackTrace st = to.getStackTrace();;\n+                    snapshot.addRoot(new Root(id, to.getId(),\n@@ -499,2 +501,2 @@\n-                    StackTrace st = getStackTraceFromSerial(to.stackSeq);\n-                    snapshot.addRoot(new Root(id, to.threadId,\n+                    StackTrace st = to.getStackTrace();\n+                    snapshot.addRoot(new Root(id, to.getId(),\n@@ -916,14 +918,0 @@\n-    \/\/\n-    \/\/ A trivial data-holder class for HPROF_GC_ROOT_THREAD_OBJ.\n-    \/\/\n-    private class ThreadObject {\n-\n-        long threadId;\n-        int stackSeq;\n-\n-        ThreadObject(long threadId, int stackSeq) {\n-            this.threadId = threadId;\n-            this.stackSeq = stackSeq;\n-        }\n-    }\n-\n","filename":"test\/lib\/jdk\/test\/lib\/hprof\/parser\/HprofReader.java","additions":13,"deletions":25,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -210,0 +210,21 @@\n+    \/**\n+     * Returns true if stdout contains the given string\n+     *\/\n+    public boolean stdoutContains(String expectedString) {\n+        return getStdout().contains(expectedString);\n+    }\n+\n+    \/**\n+     * Returns true if stderr contains the given string\n+     *\/\n+    public boolean stderrContains(String expectedString) {\n+        return getStderr().contains(expectedString);\n+    }\n+\n+    \/**\n+     * Returns true if either stdout or stderr contains the given string\n+     *\/\n+    public boolean contains(String expectedString) {\n+        return stdoutContains(expectedString) || stderrContains(expectedString);\n+    }\n+\n","filename":"test\/lib\/jdk\/test\/lib\/process\/OutputAnalyzer.java","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -474,1 +474,1 @@\n-    public double  sigNumDouble() {\n+    public double  signumDouble() {\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/MathBench.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\" })\n+public class AllocFromSliceTest extends CLayouts {\n+\n+    @Param({\"5\", \"20\", \"100\", \"500\", \"1000\"})\n+    public int size;\n+    public int start;\n+    public byte[] arr;\n+\n+    @Setup\n+    public void setup() {\n+        arr = new byte[1024];\n+        Random random = new Random(0);\n+        random.nextBytes(arr);\n+        start = random.nextInt(1024 - size);\n+    }\n+\n+    @Benchmark\n+    public MemorySegment alloc_confined() {\n+        Arena arena = Arena.ofConfined();\n+        MemorySegment segment = arena.allocate(size);\n+        MemorySegment.copy(arr, start, segment, C_CHAR, 0, size);\n+        arena.close();\n+        return segment;\n+    }\n+\n+    @Benchmark\n+    public MemorySegment alloc_confined_slice() {\n+        Arena arena = Arena.ofConfined();\n+        MemorySegment segment = arena.allocateFrom(C_CHAR, MemorySegment.ofArray(arr), C_CHAR, start, size);\n+        arena.close();\n+        return segment;\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/AllocFromSliceTest.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -0,0 +1,176 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.MemorySegment.Scope;\n+import java.lang.foreign.SegmentAllocator;\n+import java.lang.foreign.ValueLayout;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\" })\n+public class AllocFromTest extends CLayouts {\n+\n+    Arena arena = Arena.ofConfined();\n+\n+    SlicingPool pool = new SlicingPool();\n+\n+    @Param({\"5\", \"20\", \"100\", \"500\", \"1000\"})\n+    public int size;\n+    public byte[] arr;\n+\n+    @Setup\n+    public void setup() {\n+        arr = new byte[size];\n+        Random random = new Random(0);\n+        random.nextBytes(arr);\n+    }\n+\n+    @Benchmark\n+    public MemorySegment alloc_confined() {\n+        Arena arena = Arena.ofConfined();\n+        MemorySegment segment = arena.allocateFrom(ValueLayout.JAVA_BYTE, arr);\n+        arena.close();\n+        return segment;\n+    }\n+\n+    @Benchmark\n+    public MemorySegment alloc_malloc_arena() {\n+        MallocArena arena = new MallocArena();\n+        MemorySegment segment = arena.allocateFrom(ValueLayout.JAVA_BYTE, arr);\n+        arena.close();\n+        return segment;\n+    }\n+\n+    @Benchmark\n+    public MemorySegment alloc_unsafe_arena() {\n+        UnsafeArena arena = new UnsafeArena();\n+        MemorySegment segment = arena.allocateFrom(ValueLayout.JAVA_BYTE, arr);\n+        arena.close();\n+        return segment;\n+    }\n+\n+    @Benchmark\n+    public MemorySegment alloc_pool_arena() {\n+        Arena arena = pool.acquire();\n+        MemorySegment segment = arena.allocateFrom(ValueLayout.JAVA_BYTE, arr);\n+        arena.close();\n+        return segment;\n+    }\n+\n+    static class SlicingPool {\n+        final MemorySegment pool = Arena.ofAuto().allocate(1024);\n+        boolean isAcquired = false;\n+\n+        public Arena acquire() {\n+            if (isAcquired) {\n+                throw new IllegalStateException(\"An allocator is already in use\");\n+            }\n+            isAcquired = true;\n+            return new SlicingPoolAllocator();\n+        }\n+\n+        class SlicingPoolAllocator implements Arena {\n+\n+            final Arena arena = Arena.ofConfined();\n+            final SegmentAllocator slicing = SegmentAllocator.slicingAllocator(pool);\n+\n+            public MemorySegment allocate(long byteSize, long byteAlignment) {\n+                return slicing.allocate(byteSize, byteAlignment)\n+                        .reinterpret(arena, null);\n+            }\n+\n+            @Override\n+            public Scope scope() {\n+                return arena.scope();\n+            }\n+\n+            public void close() {\n+                isAcquired = false;\n+                arena.close();\n+            }\n+        }\n+    }\n+\n+    public static class MallocArena implements Arena {\n+\n+        final Arena arena = Arena.ofConfined();\n+\n+        @Override\n+        public Scope scope() {\n+            return arena.scope();\n+        }\n+\n+        @Override\n+        public void close() {\n+            arena.close();\n+        }\n+\n+        @Override\n+        public MemorySegment allocate(long byteSize, long byteAlignment) {\n+            return CLayouts.allocateMemory(byteSize)\n+                    .reinterpret(byteSize, arena, CLayouts::freeMemory);\n+        }\n+    }\n+\n+    public static class UnsafeArena implements Arena {\n+\n+        final Arena arena = Arena.ofConfined();\n+\n+        @Override\n+        public Scope scope() {\n+            return arena.scope();\n+        }\n+\n+        @Override\n+        public void close() {\n+            arena.close();\n+        }\n+\n+        @Override\n+        public MemorySegment allocate(long byteSize, long byteAlignment) {\n+            return MemorySegment.ofAddress(Utils.unsafe.allocateMemory(byteSize))\n+                    .reinterpret(byteSize, arena, ms -> Utils.unsafe.freeMemory(ms.address()));\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/AllocFromTest.java","additions":176,"deletions":0,"binary":false,"changes":176,"status":"added"},{"patch":"@@ -0,0 +1,145 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.MemorySegment.Scope;\n+import java.lang.foreign.SegmentAllocator;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.invoke.MethodHandle;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\" })\n+public class AllocTest extends CLayouts {\n+\n+    Arena arena = Arena.ofConfined();\n+\n+    @Param({\"5\", \"20\", \"100\", \"500\", \"1000\"})\n+    public int size;\n+\n+    @TearDown\n+    public void tearDown() {\n+        arena.close();\n+    }\n+\n+    @Benchmark\n+    public MemorySegment alloc_confined() {\n+        Arena arena = Arena.ofConfined();\n+        MemorySegment segment = arena.allocate(size);\n+        arena.close();\n+        return segment;\n+    }\n+\n+    @Benchmark\n+    public long alloc_calloc_arena() {\n+        CallocArena arena = new CallocArena();\n+        MemorySegment segment = arena.allocate(size);\n+        arena.close();\n+        return segment.address();\n+    }\n+\n+    @Benchmark\n+    public long alloc_unsafe_arena() {\n+        UnsafeArena arena = new UnsafeArena();\n+        MemorySegment segment = arena.allocate(size);\n+        arena.close();\n+        return segment.address();\n+    }\n+\n+    public static class CallocArena implements Arena {\n+\n+        static final MethodHandle CALLOC = Linker.nativeLinker()\n+                .downcallHandle(\n+                        Linker.nativeLinker().defaultLookup().find(\"calloc\").get(),\n+                        FunctionDescriptor.of(ValueLayout.ADDRESS, ValueLayout.JAVA_LONG, ValueLayout.JAVA_LONG));\n+\n+        static MemorySegment calloc(long size) {\n+            try {\n+                return (MemorySegment)CALLOC.invokeExact(size, 1L);\n+            } catch (Throwable ex) {\n+                throw new IllegalStateException(ex);\n+            }\n+        }\n+\n+        final Arena arena = Arena.ofConfined();\n+\n+        @Override\n+        public Scope scope() {\n+            return arena.scope();\n+        }\n+\n+        @Override\n+        public void close() {\n+            arena.close();\n+        }\n+\n+        @Override\n+        public MemorySegment allocate(long byteSize, long byteAlignment) {\n+            return calloc(byteSize)\n+                    .reinterpret(byteSize, arena, CLayouts::freeMemory);\n+        }\n+    }\n+\n+    public static class UnsafeArena implements Arena {\n+\n+        final Arena arena = Arena.ofConfined();\n+\n+        @Override\n+        public Scope scope() {\n+            return arena.scope();\n+        }\n+\n+        @Override\n+        public void close() {\n+            arena.close();\n+        }\n+\n+        @Override\n+        public MemorySegment allocate(long byteSize, long byteAlignment) {\n+            MemorySegment segment = MemorySegment.ofAddress(Utils.unsafe.allocateMemory(byteSize));\n+            Utils.unsafe.setMemory(segment.address(), byteSize, (byte)0);\n+            return segment.reinterpret(byteSize, arena, ms -> Utils.unsafe.freeMemory(segment.address()));\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/AllocTest.java","additions":145,"deletions":0,"binary":false,"changes":145,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,1 @@\n-@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n+@Fork(3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/BulkOps.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,1 +72,1 @@\n-            .withTargetLayout(MemoryLayout.sequenceLayout(C_CHAR));\n+            .withTargetLayout(MemoryLayout.sequenceLayout(Long.MAX_VALUE, C_CHAR));\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/CLayouts.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\", \"--enable-preview\" })\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\" })\n@@ -58,2 +58,2 @@\n-    public void panama_blank_trivial() throws Throwable {\n-        func_trivial.invokeExact();\n+    public void panama_blank_critical() throws Throwable {\n+        func_critical.invokeExact();\n@@ -73,2 +73,2 @@\n-    public int panama_identity_trivial() throws Throwable {\n-        return (int) identity_trivial.invokeExact(10);\n+    public int panama_identity_critical() throws Throwable {\n+        return (int) identity_critical.invokeExact(10);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/CallOverheadConstant.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-    static final MethodHandle func_trivial;\n+    static final MethodHandle func_critical;\n@@ -39,1 +39,1 @@\n-    static final MethodHandle func_trivial_v;\n+    static final MethodHandle func_critical_v;\n@@ -42,1 +42,1 @@\n-    static final MethodHandle identity_trivial;\n+    static final MethodHandle identity_critical;\n@@ -44,1 +44,1 @@\n-    static final MethodHandle identity_trivial_v;\n+    static final MethodHandle identity_critical_v;\n@@ -116,1 +116,1 @@\n-            func_trivial_v = abi.downcallHandle(fd, Linker.Option.isTrivial());\n+            func_critical_v = abi.downcallHandle(fd, Linker.Option.critical());\n@@ -118,1 +118,1 @@\n-            func_trivial = insertArguments(func_trivial_v, 0, func_addr);\n+            func_critical = insertArguments(func_critical_v, 0, func_addr);\n@@ -124,1 +124,1 @@\n-            identity_trivial_v = abi.downcallHandle(fd, Linker.Option.isTrivial());\n+            identity_critical_v = abi.downcallHandle(fd, Linker.Option.critical());\n@@ -126,1 +126,1 @@\n-            identity_trivial = insertArguments(identity_trivial_v, 0, identity_addr);\n+            identity_critical = insertArguments(identity_critical_v, 0, identity_addr);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/CallOverheadHelper.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\", \"--enable-preview\" })\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\" })\n@@ -58,2 +58,2 @@\n-    public void panama_blank_trivial() throws Throwable {\n-        func_trivial_v.invokeExact(func_addr);\n+    public void panama_blank_critical() throws Throwable {\n+        func_critical_v.invokeExact(func_addr);\n@@ -112,2 +112,2 @@\n-    public int panama_identity_trivial() throws Throwable {\n-        return (int) identity_trivial_v.invokeExact(identity_addr, 10);\n+    public int panama_identity_critical() throws Throwable {\n+        return (int) identity_critical_v.invokeExact(identity_addr, 10);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/CallOverheadVirtual.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,161 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import static java.lang.foreign.ValueLayout.*;\n+import static jdk.internal.foreign.StringSupport.*;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgsAppend = {\"--add-exports=java.base\/jdk.internal.foreign=ALL-UNNAMED\", \"--enable-native-access=ALL-UNNAMED\", \"--enable-preview\"})\n+public class InternalStrLen {\n+\n+    private MemorySegment singleByteSegment;\n+    private MemorySegment singleByteSegmentMisaligned;\n+    private MemorySegment doubleByteSegment;\n+    private MemorySegment quadByteSegment;\n+\n+    @Param({\"1\", \"4\", \"16\", \"251\", \"1024\"})\n+    int size;\n+\n+    @Setup\n+    public void setup() {\n+        var arena = Arena.ofAuto();\n+        singleByteSegment = arena.allocate((size + 1L) * Byte.BYTES);\n+        singleByteSegmentMisaligned = arena.allocate((size + 1L) * Byte.BYTES);\n+        doubleByteSegment = arena.allocate((size + 1L) * Short.BYTES);\n+        quadByteSegment = arena.allocate((size + 1L) * Integer.BYTES);\n+        Stream.of(singleByteSegment, doubleByteSegment, quadByteSegment)\n+                .forEach(s -> IntStream.range(0, (int) s.byteSize() - 1)\n+                        .forEach(i -> s.set(\n+                                ValueLayout.JAVA_BYTE,\n+                                i,\n+                                (byte) ThreadLocalRandom.current().nextInt(1, 254)\n+                        )));\n+        singleByteSegment.set(ValueLayout.JAVA_BYTE, singleByteSegment.byteSize() - Byte.BYTES, (byte) 0);\n+        doubleByteSegment.set(ValueLayout.JAVA_SHORT, doubleByteSegment.byteSize() - Short.BYTES, (short) 0);\n+        quadByteSegment.set(ValueLayout.JAVA_INT, quadByteSegment.byteSize() - Integer.BYTES, 0);\n+        singleByteSegmentMisaligned = arena.allocate(singleByteSegment.byteSize() + 1).\n+                asSlice(1);\n+        MemorySegment.copy(singleByteSegment, 0, singleByteSegmentMisaligned, 0, singleByteSegment.byteSize());\n+    }\n+\n+    @Benchmark\n+    public int elementSingle() {\n+        return legacy_strlen_byte(singleByteSegment, 0);\n+    }\n+\n+    @Benchmark\n+    public int elementByteMisaligned() {\n+        return legacy_strlen_byte(singleByteSegmentMisaligned, 0);\n+    }\n+\n+    @Benchmark\n+    public int elementDouble() {\n+        return legacy_strlen_short(doubleByteSegment, 0);\n+    }\n+\n+    @Benchmark\n+    public int elementQuad() {\n+        return legacy_strlen_int(quadByteSegment, 0);\n+    }\n+\n+    @Benchmark\n+    public int chunkedSingle() {\n+        return chunkedStrlenByte(singleByteSegment, 0);\n+    }\n+\n+    @Benchmark\n+    public int chunkedSingleMisaligned() {\n+        return chunkedStrlenByte(singleByteSegmentMisaligned, 0);\n+    }\n+\n+    @Benchmark\n+    public int chunkedDouble() {\n+        return chunkedStrlenShort(doubleByteSegment, 0);\n+    }\n+\n+    @Benchmark\n+    public int changedElementQuad() {\n+        return strlenInt(quadByteSegment, 0);\n+    }\n+\n+    \/\/ These are the legacy methods\n+\n+    private static int legacy_strlen_byte(MemorySegment segment, long start) {\n+        \/\/ iterate until overflow (String can only hold a byte[], whose length can be expressed as an int)\n+        for (int offset = 0; offset >= 0; offset++) {\n+            byte curr = segment.get(JAVA_BYTE, start + offset);\n+            if (curr == 0) {\n+                return offset;\n+            }\n+        }\n+        throw new IllegalArgumentException(\"String too large\");\n+    }\n+\n+    private static int legacy_strlen_short(MemorySegment segment, long start) {\n+        \/\/ iterate until overflow (String can only hold a byte[], whose length can be expressed as an int)\n+        for (int offset = 0; offset >= 0; offset += 2) {\n+            short curr = segment.get(JAVA_SHORT, start + offset);\n+            if (curr == 0) {\n+                return offset;\n+            }\n+        }\n+        throw new IllegalArgumentException(\"String too large\");\n+    }\n+\n+    private static int legacy_strlen_int(MemorySegment segment, long start) {\n+        \/\/ iterate until overflow (String can only hold a byte[], whose length can be expressed as an int)\n+        for (int offset = 0; offset >= 0; offset += 4) {\n+            int curr = segment.get(JAVA_INT, start + offset);\n+            if (curr == 0) {\n+                return offset;\n+            }\n+        }\n+        throw new IllegalArgumentException(\"String too large\");\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/InternalStrLen.java","additions":161,"deletions":0,"binary":false,"changes":161,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -29,1 +30,4 @@\n-import static java.lang.foreign.ValueLayout.*;\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n+import static java.lang.foreign.ValueLayout.JAVA_INT_UNALIGNED;\n+import static java.lang.foreign.ValueLayout.JAVA_LONG;\n+import static java.lang.foreign.ValueLayout.JAVA_LONG_UNALIGNED;\n@@ -32,1 +36,1 @@\n- * Some useful Java {@link ValueLayout} and associated {@link ValueLayout#arrayElementVarHandle(int...)} var handles.\n+ * Some useful Java {@link ValueLayout} and associated array var handles.\n@@ -36,1 +40,2 @@\n-    static final VarHandle VH_INT_UNALIGNED = JAVA_INT_UNALIGNED.arrayElementVarHandle();\n+    static final VarHandle VH_INT_UNALIGNED = arrayVarHandle(JAVA_INT_UNALIGNED);\n+    static final VarHandle VH_INT = arrayVarHandle(JAVA_INT);\n@@ -38,1 +43,6 @@\n-    static final VarHandle VH_INT = JAVA_INT.arrayElementVarHandle();\n+    static final VarHandle VH_LONG_UNALIGNED = arrayVarHandle(JAVA_LONG_UNALIGNED);\n+    static final VarHandle VH_LONG = arrayVarHandle(JAVA_LONG);\n+\n+    private static VarHandle arrayVarHandle(ValueLayout layout) {\n+        return MethodHandles.insertCoordinates(layout.arrayElementVarHandle(), 1, 0L);\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/JavaLayouts.java","additions":15,"deletions":5,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\", \"--enable-preview\" })\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\" })\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LinkUpcall.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,1 @@\n-@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n+@Fork(3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverConstant.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,1 @@\n-@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n+@Fork(3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNew.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,1 @@\n-@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n+@Fork(3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNewHeap.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--enable-preview\", \"--enable-native-access=ALL-UNNAMED\" })\n+@Fork(3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNonConstant.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,1 @@\n-@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n+@Fork(3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNonConstantFP.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,1 @@\n-@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n+@Fork(3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNonConstantHeap.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,1 @@\n-@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n+@Fork(3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNonConstantMapped.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,1 @@\n-@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n+@Fork(3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNonConstantShared.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n+@Fork(3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverOfAddress.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,1 @@\n-@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n+@Fork(3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverPollutedBuffer.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n-@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n+@Fork(3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverPollutedSegments.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--enable-preview\", \"--enable-native-access=ALL-UNNAMED\" })\n+@Fork(3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverSlice.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import sun.misc.Unsafe;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import static java.lang.foreign.ValueLayout.*;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgsAppend = {\"--enable-native-access=ALL-UNNAMED\"})\n+public class MemorySegmentCopyUnsafe {\n+\n+    static final Unsafe UNSAFE = Utils.unsafe;\n+\n+    long src;\n+    long dst;\n+\n+    @Setup\n+    public void setup() throws Throwable {\n+        src = Arena.global().allocate(JAVA_INT).address();\n+        dst = Arena.global().allocate(JAVA_INT).address();\n+    }\n+\n+    @Benchmark\n+    public void panama() {\n+        MemorySegment srcSeg = MemorySegment.ofAddress(src).reinterpret(JAVA_INT.byteSize());\n+        MemorySegment dstSeg = MemorySegment.ofAddress(dst).reinterpret(JAVA_INT.byteSize());\n+        dstSeg.copyFrom(srcSeg);\n+    }\n+\n+    @Benchmark\n+    public void unsafe() {\n+        UNSAFE.copyMemory(src, dst, JAVA_INT.byteSize());\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/MemorySegmentCopyUnsafe.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.invoke.VarHandle;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import sun.misc.Unsafe;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import static java.lang.foreign.ValueLayout.*;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgsAppend = {\"--enable-native-access=ALL-UNNAMED\"})\n+public class MemorySegmentGetUnsafe {\n+\n+    static final Unsafe UNSAFE = Utils.unsafe;\n+    static final MethodHandle OF_ADDRESS_UNSAFE;\n+\n+    static {\n+        try {\n+            OF_ADDRESS_UNSAFE = MethodHandles.lookup().findStatic(MemorySegmentGetUnsafe.class,\n+                    \"ofAddressUnsafe\", MethodType.methodType(MemorySegment.class, long.class));\n+        } catch (ReflectiveOperationException e) {\n+            throw new ExceptionInInitializerError(e);\n+        }\n+    }\n+\n+    static final VarHandle INT_HANDLE = adaptSegmentHandle(JAVA_INT.varHandle());\n+\n+    static VarHandle adaptSegmentHandle(VarHandle handle) {\n+        handle = MethodHandles.insertCoordinates(handle, 1, 0L);\n+        handle = MethodHandles.filterCoordinates(handle, 0, OF_ADDRESS_UNSAFE);\n+        return handle;\n+    }\n+\n+    static MemorySegment ofAddressUnsafe(long address) {\n+        return MemorySegment.ofAddress(address).reinterpret(JAVA_INT.byteSize());\n+    }\n+\n+    long addr;\n+\n+    @Setup\n+    public void setup() throws Throwable {\n+        addr = Arena.global().allocate(JAVA_INT).address();\n+    }\n+\n+    @Benchmark\n+    public int panama() {\n+        return (int) INT_HANDLE.get(addr);\n+    }\n+\n+    @Benchmark\n+    public int unsafe() {\n+        return UNSAFE.getInt(addr);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/MemorySegmentGetUnsafe.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,1 +61,1 @@\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-native-access=ALL-UNNAMED\", \"--enable-preview\"})\n+@Fork(3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/MemorySegmentVsBits.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n-@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n+@Fork(3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/MemorySessionClose.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,1 +55,1 @@\n-@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n+@Fork(3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/ParallelSum.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\", \"--enable-preview\" })\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\" })\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/PointerInvoke.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\", \"--enable-preview\" })\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\" })\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/QSort.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\", \"--enable-preview\" })\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\" })\n@@ -95,1 +95,1 @@\n-            MemorySegment segment = arena.allocateUtf8String(str);\n+            MemorySegment segment = arena.allocateFrom(str);\n@@ -102,1 +102,1 @@\n-        return (int)STRLEN.invokeExact(arenaAllocator.allocateUtf8String(str));\n+        return (int)STRLEN.invokeExact(arenaAllocator.allocateFrom(str));\n@@ -108,1 +108,1 @@\n-        int l = (int) STRLEN.invokeExact(arena.allocateUtf8String(str));\n+        int l = (int) STRLEN.invokeExact(arena.allocateFrom(str));\n@@ -115,1 +115,1 @@\n-        return (int)STRLEN.invokeExact(segmentAllocator.allocateUtf8String(str));\n+        return (int)STRLEN.invokeExact(segmentAllocator.allocateFrom(str));\n@@ -165,1 +165,1 @@\n-            long lastOffset = segment.segmentOffset(res) + res.byteSize();\n+            long lastOffset = res.address() - segment.address() + res.byteSize();\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/StrLenTest.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,1 @@\n-@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n+@Fork(3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/TestAdaptVarHandles.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,4 +51,1 @@\n-@Fork(value = 1, jvmArgsAppend = {\n-        \"-Dforeign.restricted=permit\",\n-        \"--enable-native-access\", \"ALL-UNNAMED\",\n-        \"--enable-preview\"})\n+@Fork(1)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/TestLoadBytes.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.MemorySegment.Scope;\n+import java.lang.foreign.SegmentAllocator;\n+import java.lang.invoke.MethodHandle;\n+import java.util.concurrent.TimeUnit;\n+\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\" })\n+public class ToCStringTest extends CLayouts {\n+\n+    @Param({\"5\", \"20\", \"100\", \"200\"})\n+    public int size;\n+    public String str;\n+\n+    static {\n+        System.loadLibrary(\"ToCString\");\n+    }\n+\n+    static final MethodHandle STRLEN;\n+\n+    static {\n+        Linker abi = Linker.nativeLinker();\n+        STRLEN = abi.downcallHandle(abi.defaultLookup().find(\"strlen\").get(),\n+                FunctionDescriptor.of(C_INT, C_POINTER));\n+    }\n+\n+    @Setup\n+    public void setup() {\n+        str = makeString(size);\n+    }\n+\n+    @Benchmark\n+    public long jni_writeString() throws Throwable {\n+        return writeString(str);\n+    }\n+\n+    @Benchmark\n+    public MemorySegment panama_writeString() throws Throwable {\n+        Arena arena = Arena.ofConfined();\n+        MemorySegment segment = arena.allocateFrom(str);\n+        arena.close();\n+        return segment;\n+    }\n+\n+    static native long writeString(String str);\n+\n+    static String makeString(int size) {\n+        String lorem = \"\"\"\n+                Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et\n+                 dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip\n+                 ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu\n+                 fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt\n+                 mollit anim id est laborum.\n+                \"\"\";\n+        return lorem.substring(0, size);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/ToCStringTest.java","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgsAppend = {\"--enable-native-access=ALL-UNNAMED\", \"--enable-preview\"})\n+public class ToJavaStringTest {\n+\n+    private MemorySegment strSegment;\n+\n+    @Param({\"5\", \"20\", \"100\", \"200\"})\n+    int size;\n+\n+    static {\n+        System.loadLibrary(\"ToJavaString\");\n+    }\n+\n+    @Setup\n+    public void setup() {\n+        var arena = Arena.ofAuto();\n+        strSegment = arena.allocateFrom(LOREM.substring(0, size));\n+    }\n+\n+    @Benchmark\n+    public String panama_readString() {\n+        return strSegment.getString(0);\n+    }\n+\n+    @Benchmark\n+    public String jni_readString() {\n+        return readString(strSegment.address());\n+    }\n+\n+    static native String readString(long addr);\n+\n+    static String LOREM = \"\"\"\n+                Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et\n+                 dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip\n+                 ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu\n+                 fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt\n+                 mollit anim id est laborum.\n+                \"\"\";\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/ToJavaStringTest.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--enable-preview\", \"--enable-native-access=ALL-UNNAMED\" })\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\" })\n@@ -48,4 +48,0 @@\n-    static final VarHandle VH_LONG_UNALIGNED = JAVA_LONG_UNALIGNED.arrayElementVarHandle();\n-\n-    static final VarHandle VH_LONG = JAVA_LONG.arrayElementVarHandle();\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/UnrolledAccess.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\", \"--enable-preview\" })\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\" })\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/Upcalls.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,1 @@\n-@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n+@Fork(3)\n@@ -57,1 +57,1 @@\n-        generic = MethodHandles.memorySegmentViewVarHandle(JAVA_INT);\n+        generic = JAVA_INT.varHandle();\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/VarHandleExact.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <jlong.h>\n+#include <jni.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+JNIEXPORT jlong JNICALL Java_org_openjdk_bench_java_lang_foreign_ToCStringTest_writeString(JNIEnv *const env, const jclass cls, const jstring text) {\n+    const char *str = (*env)->GetStringUTFChars(env, text, NULL);\n+    jlong addr = ptr_to_jlong(str);\n+    (*env)->ReleaseStringUTFChars(env, text, str);\n+    return addr;\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/libToCString.c","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <jlong.h>\n+#include <jni.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+JNIEXPORT jstring JNICALL Java_org_openjdk_bench_java_lang_foreign_ToJavaStringTest_readString(JNIEnv *const env, const jclass cls, jlong addr) {\n+    return (*env)->NewStringUTF(env, jlong_to_ptr(addr));\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/libToJavaString.c","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-            .withTargetLayout(MemoryLayout.sequenceLayout(ValueLayout.JAVA_BYTE));\n+            .withTargetLayout(MemoryLayout.sequenceLayout(Long.MAX_VALUE, ValueLayout.JAVA_BYTE));\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/pointers\/NativeType.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -81,1 +81,1 @@\n-        MemorySegment segment = allocator.allocateArray(type.layout(), size);\n+        MemorySegment segment = allocator.allocate(type.layout(), size);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/pointers\/Pointer.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n-@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n+@Fork(3)\n@@ -63,1 +63,1 @@\n-            .withTargetLayout(MemoryLayout.sequenceLayout(ValueLayout.JAVA_BYTE));\n+            .withTargetLayout(MemoryLayout.sequenceLayout(Long.MAX_VALUE, ValueLayout.JAVA_BYTE));\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/pointers\/PointerBench.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -71,1 +71,1 @@\n-        VH_x.set(segment, x);\n+        VH_x.set(segment, 0L, x);\n@@ -75,1 +75,1 @@\n-        return (int) VH_x.get(segment);\n+        return (int) VH_x.get(segment, 0L);\n@@ -79,1 +79,1 @@\n-        VH_y.set(segment, y);\n+        VH_y.set(segment, 0L, y);\n@@ -83,1 +83,1 @@\n-        return (int) VH_y.get(segment);\n+        return (int) VH_y.get(segment, 0L);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/points\/support\/PanamaPoint.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -140,1 +140,4 @@\n-                SocketWriteEvent.offer(start, nbytes, getRemoteAddress());\n+                long duration = start - SocketWriteEvent.timestamp();\n+                if (SocketWriteEvent.shouldCommit(duration)) {\n+                    SocketWriteEvent.emit(start, duration, nbytes, getRemoteAddress());\n+                }\n@@ -158,1 +161,4 @@\n-                SocketReadEvent.offer(start, nbytes, getRemoteAddress(), 0);\n+                long duration = start - SocketReadEvent.timestamp();\n+                if (SocketReadEvent.shouldCommit(duration)) {\n+                    SocketReadEvent.emit(start, duration, nbytes, getRemoteAddress(), 0);\n+                }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/net\/SocketEventOverhead.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -96,0 +96,19 @@\n+    @Benchmark\n+    public String formatLower() {\n+        return HexFormat.of().formatHex(bytes);\n+    }\n+\n+    @Benchmark\n+    public String formatUpper() {\n+        return HexFormat.of().withUpperCase().formatHex(bytes);\n+    }\n+\n+    @Benchmark\n+    public String formatLowerCached() {\n+        return LOWER_FORMATTER.formatHex(bytes);\n+    }\n+\n+    @Benchmark\n+    public String formatUpperCached() {\n+        return UPPER_FORMATTER.formatHex(bytes);\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/HexFormatBench.java","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.nio.file.Path;\n@@ -53,0 +54,1 @@\n+    public File relativePathFile;\n@@ -77,0 +79,2 @@\n+        relativePathFile = Path.of(System.getProperty(\"user.dir\"))\n+                                .relativize(zipFile.toPath()).toFile();\n@@ -93,0 +97,13 @@\n+\n+    @Benchmark\n+    public void openCloseZipFilex2() throws Exception {\n+        \/\/ A follow on from the openCloseZipFile benchmark.\n+        \/\/ The initCEN logic should be called once per file, if\n+        \/\/ opened multiple times and not closed, for the ZipFile\n+        \/\/ under test if that file is identified by a unique value\n+        \/\/ returned via attrs.fileKey()\n+        ZipFile zf = new ZipFile(zipFile);\n+        ZipFile zf2 = new ZipFile(relativePathFile);\n+        zf.close();\n+        zf2.close();\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/zip\/ZipFileOpen.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,0 +75,18 @@\n+    @Benchmark\n+    @BenchmarkMode(Mode.Throughput)\n+    public void jdkReadMemberNames(Blackhole bh) {\n+        var cc = Classfile.of();\n+        for (byte[] bytes : classes) {\n+            var cm = cc.parse(bytes);\n+            bh.consume(cm.thisClass().asInternalName());\n+            for (var f : cm.fields()) {\n+                bh.consume(f.fieldName().stringValue());\n+                bh.consume(f.fieldType().stringValue());\n+            }\n+            for (var m : cm.methods()) {\n+                bh.consume(m.methodName().stringValue());\n+                bh.consume(m.methodType().stringValue());\n+            }\n+        }\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/ReadMetadata.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,0 @@\n-    \"--enable-preview\",\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/MemorySegmentVectorAccess.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,0 @@\n-    \"--enable-preview\",\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/TestLoadStoreBytes.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,1 +55,0 @@\n-    \"--enable-preview\",\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/TestLoadStoreShorts.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,220 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Measurement(iterations = 4, time = 1000, timeUnit = TimeUnit.MILLISECONDS)\n+@Warmup(iterations = 3, time = 1000, timeUnit = TimeUnit.MILLISECONDS)\n+@Fork(3)\n+public class PhiDuplicatedConversion {\n+    public static final int SIZE = 300;\n+\n+    \/\/ Ints\n+\n+    @Benchmark\n+    public void testInt2Float(Blackhole blackhole, BenchState state) {\n+        for (int i = 0; i < SIZE; i++) {\n+            blackhole.consume(i2f(state.bools[i], state.ints[i], state.ints[SIZE - 1 - i]));\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testInt2Double(Blackhole blackhole, BenchState state) {\n+        for (int i = 0; i < SIZE; i++) {\n+            blackhole.consume(i2d(state.bools[i], state.ints[i], state.ints[SIZE - 1 - i]));\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testInt2Long(Blackhole blackhole, BenchState state) {\n+        for (int i = 0; i < SIZE; i++) {\n+            blackhole.consume(i2l(state.bools[i], state.ints[i], state.ints[SIZE - 1 - i]));\n+        }\n+    }\n+\n+    \/\/ Floats\n+\n+    @Benchmark\n+    public void testFloat2Int(Blackhole blackhole, BenchState state) {\n+        for (int i = 0; i < SIZE; i++) {\n+            blackhole.consume(f2i(state.bools[i], state.floats[i], state.floats[SIZE - 1 - i]));\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testFloat2Double(Blackhole blackhole, BenchState state) {\n+        for (int i = 0; i < SIZE; i++) {\n+            blackhole.consume(f2d(state.bools[i], state.floats[i], state.floats[SIZE - 1 - i]));\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testFloat2Long(Blackhole blackhole, BenchState state) {\n+        for (int i = 0; i < SIZE; i++) {\n+            blackhole.consume(f2l(state.bools[i], state.floats[i], state.floats[SIZE - 1 - i]));\n+        }\n+    }\n+\n+    \/\/ Doubles\n+\n+    @Benchmark\n+    public void testDouble2Int(Blackhole blackhole, BenchState state) {\n+        for (int i = 0; i < SIZE; i++) {\n+            blackhole.consume(d2i(state.bools[i], state.doubles[i], state.doubles[SIZE - 1 - i]));\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testDouble2Float(Blackhole blackhole, BenchState state) {\n+        for (int i = 0; i < SIZE; i++) {\n+            blackhole.consume(d2f(state.bools[i], state.doubles[i], state.doubles[SIZE - 1 - i]));\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testDouble2Long(Blackhole blackhole, BenchState state) {\n+        for (int i = 0; i < SIZE; i++) {\n+            blackhole.consume(d2l(state.bools[i], state.doubles[i], state.doubles[SIZE - 1 - i]));\n+        }\n+    }\n+\n+    \/\/ Longs\n+\n+    @Benchmark\n+    public void testLong2Float(Blackhole blackhole, BenchState state) {\n+        for (int i = 0; i < SIZE; i++) {\n+            blackhole.consume(l2f(state.bools[i], state.longs[i], state.longs[SIZE - 1 - i]));\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testLong2Double(Blackhole blackhole, BenchState state) {\n+        for (int i = 0; i < SIZE; i++) {\n+            blackhole.consume(l2d(state.bools[i], state.longs[i], state.longs[SIZE - 1 - i]));\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testLong2Int(Blackhole blackhole, BenchState state) {\n+        for (int i = 0; i < SIZE; i++) {\n+            blackhole.consume(l2i(state.bools[i], state.longs[i], state.longs[SIZE - 1 - i]));\n+        }\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public static float i2f(boolean c, int a, int b) {\n+        return c ? a : b;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public static double i2d(boolean c, int a, int b) {\n+        return c ? a : b;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public static long i2l(boolean c, int a, int b) {\n+        return c ? a : b;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public static int f2i(boolean c, float a, float b) {\n+        return c ? (int)a : (int)b;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public static double f2d(boolean c, float a, float b) {\n+        return c ? (double)a : (double)b;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public static long f2l(boolean c, float a, float b) {\n+        return c ? (long)a : (long)b;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public static int d2i(boolean c, double a, double b) {\n+        return c ? (int)a : (int)b;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public static float d2f(boolean c, double a, double b) {\n+        return c ? (float)a : (float)b;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public static long d2l(boolean c, double a, double b) {\n+        return c ? (long)a : (long)b;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public static float l2f(boolean c, long a, long b) {\n+        return c ? a : b;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public static double l2d(boolean c, long a, long b) {\n+        return c ? a : b;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public static int l2i(boolean c, long a, long b) {\n+        return c ? (int)a : (int)b;\n+    }\n+\n+    @State(Scope.Benchmark)\n+    public static class BenchState {\n+        public boolean[] bools;\n+        public int[] ints;\n+        public long[] longs;\n+        public float[] floats;\n+        public double[] doubles;\n+        public BenchState() {\n+\n+        }\n+\n+        @Setup(Level.Iteration)\n+        public void setup() {\n+            Random random = new Random(1000);\n+            bools = new boolean[SIZE];\n+            ints = new int[SIZE];\n+            longs = new long[SIZE];\n+            floats = new float[SIZE];\n+            doubles = new double[SIZE];\n+\n+            for (int i = 0; i < SIZE; i++) {\n+                bools[i] = random.nextBoolean();\n+                ints[i] = random.nextInt(100);\n+                longs[i] = random.nextLong(100);\n+                floats[i] = random.nextFloat(100);\n+                doubles[i] = random.nextDouble(100);\n+            }\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/PhiDuplicatedConversion.java","additions":220,"deletions":0,"binary":false,"changes":220,"status":"added"},{"patch":"@@ -0,0 +1,252 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.vm.runtime;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import jdk.internal.misc.Unsafe;\n+import java.util.concurrent.TimeUnit;\n+\n+\/**\n+ * The purpose of these microbenchmarks is to get the overhead of NMT in disable\/summary\/detail mode.\n+ *\/\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 2, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n+public abstract class NMTBenchmark {\n+  static final int S = 1024;\n+\n+  Unsafe unsafe;\n+  long addresses[];\n+\n+  \/\/@Param({\"100000\", \"1000000\"})\n+  @Param({\"100000\"})\n+  public int N;\n+\n+  @Param({\"0\", \"4\"})\n+  public int THREADS;\n+\n+  \/\/ Each TestThread instance allocates\/frees a portion (`start` to `end`) of the `addresses` array.\n+  \/\/ The thread index and a flag for doing allocate or freeing it are sent to the constructor.\n+  private class TestThread extends Thread {\n+    private int thr_index;\n+    private int count;\n+    private int start, end;\n+    private boolean allocate;\n+\n+    public TestThread(int index, boolean alloc_or_free) {\n+      thr_index = index;\n+      count = N \/ THREADS;\n+      start = thr_index * count;\n+      end = start + count;\n+      allocate = alloc_or_free;\n+    }\n+\n+    public void run() {\n+      for (int i = start; i < end; i++) {\n+        if (allocate) {\n+          alloc(i);\n+        } else {\n+          deallocate(i);\n+        }\n+      }\n+    }\n+\n+    \/\/ make a deeper and different stack trace\n+    \/\/ NMT uses hash of stack trace to store them in a static table.\n+    \/\/ So, if all allocations come from the same call-site, they all hashed into one entry in that table.\n+    private void alloc(int i) {\n+      if (i % 3 == 0) alloc0(i);\n+      if (i % 3 == 1) alloc1(i);\n+      if (i % 3 == 2) alloc2(i);\n+    }\n+    private void alloc0(int i) {\n+      if (unsafe == null) return;\n+      addresses[i] = unsafe.allocateMemory(S);\n+    }\n+    private void alloc1(int i) { alloc0(i); }\n+    private void alloc2(int i) { alloc1(i); }\n+\n+    private void deallocate(int i) {\n+      if (unsafe == null)\n+        return;\n+\n+      if (addresses[i] != 0) {\n+        unsafe.freeMemory(addresses[i]);\n+        addresses[i] = 0;\n+      }\n+    }\n+  }\n+\n+  @Benchmark\n+  public void mixAallocateFreeMemory(Blackhole bh) throws InterruptedException{\n+\n+    Unsafe unsafe = Unsafe.getUnsafe();\n+    if (unsafe == null) {\n+      throw new InterruptedException();\n+    }\n+\n+    addresses = new long[N];\n+    if (THREADS != 0) { \/\/ Multi-threaded\n+      TestThread threads[] = new TestThread[THREADS];\n+\n+      for (int t = 0; t < THREADS; t++) {\n+        \/\/ One half of threads allocate and the other half free the memory\n+        threads[t] = new TestThread(t, t < (THREADS \/ 2) ? true : false);\n+        threads[t].start();\n+      }\n+\n+      for (int t = 0; t < THREADS; t++) {\n+        try {\n+          threads[t].join();\n+        } catch (InterruptedException ie) {\n+          \/\/ do nothing\n+        }\n+      }\n+    } else { \/\/ No threads used.\n+\n+      for (int i = 0; i < N; i++) {\n+        addresses[i] = unsafe.allocateMemory(S);\n+        \/\/Mixing alloc\/free\n+        if (i % 3 == 0) {\n+          if (addresses[i] != 0) {\n+            unsafe.freeMemory(addresses[i]);\n+            addresses[i] = 0;\n+          }\n+        }\n+      }\n+\n+      for (int i = 0; i < N; i++) {\n+        if (i % 2 == 0) {\n+            if (addresses[i] != 0) {\n+              unsafe.freeMemory(addresses[i]);\n+              addresses[i] = 0;\n+            }\n+        }\n+      }\n+\n+      \/\/ free the rest of allocations\n+      for (int i = 0; i < N; i++) {\n+        if (addresses[i] != 0) {\n+          unsafe.freeMemory(addresses[i]);\n+          addresses[i] = 0;\n+        }\n+      }\n+    }\n+  }\n+\n+  @Benchmark\n+  public void onlyAllocateMemory() throws InterruptedException {\n+    Unsafe unsafe = Unsafe.getUnsafe();\n+    if (unsafe == null) {\n+      throw new InterruptedException();\n+    }\n+\n+    addresses = new long[N];\n+    if (THREADS != 0) { \/\/ Multi-threaded\n+      TestThread threads[] = new TestThread[THREADS];\n+\n+      for (int t = 0; t < THREADS; t++) {\n+        \/\/ One half of threads allocate and the other half free the memory\n+        threads[t] = new TestThread(t, t < (THREADS \/ 2) ? true : false);\n+        threads[t].start();\n+      }\n+\n+      for (int t = 0; t < THREADS; t++) {\n+        try {\n+          threads[t].join();\n+        } catch (InterruptedException ie) {\n+          \/\/ do nothing\n+        }\n+      }\n+    } else { \/\/ No threads used.\n+      for (int i = 0; i < N; i++) {\n+        addresses[i] = unsafe.allocateMemory(S);\n+      }\n+    }\n+  }\n+\n+  @Benchmark\n+  public void mixAllocateReallocateMemory() throws InterruptedException {\n+    Unsafe unsafe = Unsafe.getUnsafe();\n+    if (unsafe == null) {\n+      throw new InterruptedException();\n+    }\n+\n+    addresses = new long[N];\n+    if (THREADS != 0) { \/\/ Multi-threaded\n+      TestThread threads[] = new TestThread[THREADS];\n+\n+      for (int t = 0; t < THREADS; t++) {\n+        \/\/ One half of threads allocate and the other half free the memory\n+        threads[t] = new TestThread(t, t < (THREADS \/ 2) ? true : false);\n+        threads[t].start();\n+      }\n+\n+      for (int t = 0; t < THREADS; t++) {\n+        try {\n+          threads[t].join();\n+        } catch (InterruptedException ie) {\n+          \/\/ do nothing\n+        }\n+      }\n+    } else { \/\/ No threads used.\n+      for (int i = 0; i < N; i++) {\n+        addresses[i] = unsafe.allocateMemory(S);\n+        \/\/Mixing alloc\/realloc\n+        if (i % 3 == 0) {\n+          if (addresses[i] != 0) {\n+            unsafe.reallocateMemory(addresses[i], S * 2);\n+            addresses[i] = 0;\n+          }\n+        }\n+      }\n+\n+      for (int i = 0; i < N; i++) {\n+        if (i % 2 == 0) {\n+            if (addresses[i] != 0) {\n+              unsafe.reallocateMemory(addresses[i], S \/ 2);\n+              addresses[i] = 0;\n+            }\n+        }\n+      }\n+    }\n+  }\n+\n+  public static final String ADD_EXPORTS = \"--add-exports\";\n+  public static final String MISC_PACKAGE = \"java.base\/jdk.internal.misc=ALL-UNNAMED\"; \/\/ used for Unsafe API\n+\n+  @Fork(value = 2, jvmArgsPrepend = { \"-XX:NativeMemoryTracking=off\", ADD_EXPORTS, MISC_PACKAGE})\n+  public static class NMTOff extends NMTBenchmark { }\n+\n+  @Fork(value = 2, jvmArgsPrepend = { \"-XX:NativeMemoryTracking=summary\", ADD_EXPORTS, MISC_PACKAGE})\n+  public static class NMTSummary extends NMTBenchmark { }\n+\n+  @Fork(value = 2, jvmArgsPrepend = { \"-XX:NativeMemoryTracking=detail\", ADD_EXPORTS, MISC_PACKAGE})\n+  public static class NMTDetail extends NMTBenchmark { }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/runtime\/NMTBenchmark.java","additions":252,"deletions":0,"binary":false,"changes":252,"status":"added"}]}