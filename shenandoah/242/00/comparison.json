{"files":[{"patch":"@@ -852,1 +852,0 @@\n-    bool is_generational = _heap->mode()->is_generational();\n@@ -1074,5 +1073,0 @@\n-  if (heap->mode()->is_generational()) {\n-    heap->young_generation()->clear_used();\n-    heap->old_generation()->clear_used();\n-  }\n-\n@@ -1269,0 +1263,17 @@\n+static void account_for_region(ShenandoahHeapRegion* r, size_t &region_count, size_t &region_usage, size_t &humongous_waste) {\n+  region_count++;\n+  region_usage += r->used();\n+  if (r->is_humongous_start()) {\n+    \/\/ For each humongous object, we take this path once regardless of how many regions it spans.\n+    HeapWord* obj_addr = r->bottom();\n+    oop obj = cast_to_oop(obj_addr);\n+    size_t word_size = obj->size();\n+    size_t region_size_words = ShenandoahHeapRegion::region_size_words();\n+    size_t overreach = word_size % region_size_words;\n+    if (overreach != 0) {\n+      humongous_waste += (region_size_words - overreach) * HeapWordSize;\n+    }\n+    \/\/ else, this humongous object aligns exactly on region size, so no waste.\n+  }\n+}\n+\n@@ -1273,0 +1284,3 @@\n+  bool _is_generational;\n+  size_t _young_regions, _young_usage, _young_humongous_waste;\n+  size_t _old_regions, _old_usage, _old_humongous_waste;\n@@ -1275,1 +1289,4 @@\n-  ShenandoahPostCompactClosure() : _heap(ShenandoahHeap::heap()), _live(0) {\n+  ShenandoahPostCompactClosure() : _heap(ShenandoahHeap::heap()), _live(0), _is_generational(_heap->mode()->is_generational()),\n+                                   _young_regions(0), _young_usage(0), _young_humongous_waste(0),\n+                                   _old_regions(0), _old_usage(0), _old_humongous_waste(0)\n+  {\n@@ -1281,1 +1298,0 @@\n-    bool is_generational = _heap->mode()->is_generational();\n@@ -1294,0 +1310,1 @@\n+\n@@ -1296,1 +1313,1 @@\n-      if (!is_generational) {\n+      if (!_is_generational) {\n@@ -1312,8 +1329,5 @@\n-    }\n-\n-    \/\/ Update final usage for generations\n-    if (is_generational && live != 0) {\n-      if (r->is_young()) {\n-        _heap->young_generation()->increase_used(live);\n-      } else if (r->is_old()) {\n-        _heap->old_generation()->increase_used(live);\n+    } else if (_is_generational) {\n+      if (r->is_old()) {\n+        account_for_region(r, _old_regions, _old_usage, _old_humongous_waste);\n+      } else if (r->is_young()) {\n+        account_for_region(r, _young_regions, _young_usage, _young_humongous_waste);\n@@ -1331,0 +1345,6 @@\n+\n+  void update_generation_usage() {\n+    assert(_is_generational, \"Only update generation usage if generational\");\n+    _heap->old_generation()->establish_usage(_old_regions, _old_usage, _old_humongous_waste);\n+    _heap->young_generation()->establish_usage(_young_regions, _young_usage, _young_humongous_waste);\n+  }\n@@ -1453,17 +1473,0 @@\n-static void account_for_region(ShenandoahHeapRegion* r, size_t &region_count, size_t &region_usage, size_t &humongous_waste) {\n-  region_count++;\n-  region_usage += r->used();\n-  if (r->is_humongous_start()) {\n-    \/\/ For each humongous object, we take this path once regardless of how many regions it spans.\n-    HeapWord* obj_addr = r->bottom();\n-    oop obj = cast_to_oop(obj_addr);\n-    size_t word_size = obj->size();\n-    size_t region_size_words = ShenandoahHeapRegion::region_size_words();\n-    size_t overreach = word_size % region_size_words;\n-    if (overreach != 0) {\n-      humongous_waste += (region_size_words - overreach) * HeapWordSize;\n-    }\n-    \/\/ else, this humongous object aligns exactly on region size, so no waste.\n-  }\n-}\n-\n@@ -1473,36 +1476,0 @@\n-  size_t num_regions = heap->num_regions();\n-  size_t young_usage = 0;\n-  size_t young_regions = 0;\n-  size_t young_humongous_waste = 0;\n-  size_t old_usage = 0;\n-  size_t old_regions = 0;\n-  size_t old_humongous_waste = 0;\n-  ShenandoahHeapRegion* r;\n-\n-  if (heap->mode()->is_generational()) {\n-    \/\/ TODO: We may be able remove code that recomputes generation usage after we fix the incremental updates to generation\n-    \/\/ usage that are scattered throughout the existing Full GC implementation.  There's an error in there somewhere that\n-    \/\/ has not yet been figured out.  Or maybe it is easier to just not try to do the generation accounting on the fly, keep\n-    \/\/ this code, and remove all of the other attempts to increase\/decrease affiliated regions, used, and humongous_waste.\n-    {\n-      ShenandoahGCPhase phase(ShenandoahPhaseTimings::full_gc_recompute_generation_usage);\n-      for (size_t i = 0; i < num_regions; i++) {\n-        switch (heap->region_affiliation(i)) {\n-          case ShenandoahRegionAffiliation::FREE:\n-            break;\n-          case ShenandoahRegionAffiliation::YOUNG_GENERATION:\n-            r = heap->get_region(i);\n-            account_for_region(r, young_regions, young_usage, young_humongous_waste);\n-            break;\n-          case ShenandoahRegionAffiliation::OLD_GENERATION:\n-            r = heap->get_region(i);\n-            account_for_region(r, old_regions, old_usage, old_humongous_waste);\n-            break;\n-          default:\n-            assert(false, \"Should not reach\");\n-        }\n-      }\n-      heap->old_generation()->establish_usage(old_regions, old_usage, old_humongous_waste);\n-      heap->young_generation()->establish_usage(young_regions, young_usage, young_humongous_waste);\n-    }\n-  }\n@@ -1521,6 +1488,0 @@\n-\n-    if (heap->mode()->is_generational()) {\n-      heap->young_generation()->clear_used();\n-      heap->old_generation()->clear_used();\n-    }\n-\n@@ -1531,0 +1492,1 @@\n+      post_compact.update_generation_usage();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":38,"deletions":76,"binary":false,"changes":114,"status":"modified"},{"patch":"@@ -936,0 +936,4 @@\n+  shenandoah_assert_heaplocked_or_fullgc_safepoint();\n+  \/\/ During full gc, multiple GC worker threads may change region affiliations without a lock.  No lock is enforced\n+  \/\/ on read and write of _affiliated_region_count.  At the end of full gc, a single thread overwrites the count with\n+  \/\/ a coherent value.\n@@ -941,0 +945,4 @@\n+  shenandoah_assert_heaplocked_or_fullgc_safepoint();\n+  \/\/ During full gc, multiple GC worker threads may change region affiliations without a lock.  No lock is enforced\n+  \/\/ on read and write of _affiliated_region_count.  At the end of full gc, a single thread overwrites the count with\n+  \/\/ a coherent value.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -67,0 +67,6 @@\n+\n+    \/\/ TODO:\n+    \/\/ This comment has proven to be incorrect, because the now-disabled asserts that follow were failing.\n+    \/\/\n+    \/\/ Revisit what we believe to be truth and update this comment:\n+    \/\/\n@@ -80,3 +86,4 @@\n-    assert(!heap->active_generation()->is_old(), \"Expecting only young or global\");\n-    assert(heap->card_scan()->is_card_dirty(reinterpret_cast<HeapWord*>(field))\n-           || heap->active_generation()->is_global(), \"Expecting already dirty if young\");\n+    \/\/\n+    \/\/    assert(!heap->active_generation()->is_old(), \"Expecting only young or global\");\n+    \/\/    assert(heap->card_scan()->is_card_dirty(reinterpret_cast<HeapWord*>(field))\n+    \/\/           || heap->active_generation()->is_global(), \"Expecting already dirty if young\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahReferenceProcessor.cpp","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"}]}