{"files":[{"patch":"@@ -246,3 +246,0 @@\n-    log_info(gc, ergo)(\"At end of Concurrent GC, old_available: \" SIZE_FORMAT \"%s, young_available: \" SIZE_FORMAT \"%s\",\n-                       byte_size_in_proper_unit(old_available), proper_unit_for_byte_size(old_available),\n-                       byte_size_in_proper_unit(young_available), proper_unit_for_byte_size(young_available));\n@@ -250,1 +247,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -477,1 +477,7 @@\n-  log_heap_status(heap);\n+  const char* msg;\n+  if (heap->cancelled_gc()) {\n+    msg = (generation == YOUNG)? \"At end of Interrupted Concurrent Young GC\": \"At end of Interrupted Concurrent Bootstrap GC\";\n+  } else {\n+    msg = (generation == YOUNG)? \"At end of Concurrent Young GC\": \"At end of Concurrent Bootstrap GC\";\n+  }\n+  heap->log_heap_status(msg);\n@@ -484,0 +490,1 @@\n+  ShenandoahOldGeneration::State original_state = old_generation->state();\n@@ -487,1 +494,1 @@\n-  switch (old_generation->state()) {\n+  switch (original_state) {\n@@ -540,0 +547,5 @@\n+        if (original_state == ShenandoahOldGeneration::MARKING) {\n+          heap->log_heap_status(\"At end of Concurrent Old Marking finishing increment\");\n+        }\n+      } else if (original_state == ShenandoahOldGeneration::MARKING) {\n+        heap->log_heap_status(\"At end of Concurrent Old Marking increment\");\n@@ -583,9 +595,0 @@\n-void ShenandoahControlThread::log_heap_status(const ShenandoahHeap* heap) {\n-  if (heap->mode()->is_generational()) {\n-    heap->young_generation()->log_status();\n-    heap->old_generation()->log_status();\n-  } else {\n-    heap->global_generation()->log_status();\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":14,"deletions":11,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -193,1 +193,0 @@\n-  void log_heap_status(const ShenandoahHeap* heap);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -59,5 +59,1 @@\n-    size_t old_available = heap->old_generation()->available();\n-    size_t young_available = heap->young_generation()->available();\n-    log_info(gc, ergo)(\"At end of Degenerated GC, old_available: \" SIZE_FORMAT \"%s, young_available: \" SIZE_FORMAT \"%s\",\n-                       byte_size_in_proper_unit(old_available), proper_unit_for_byte_size(old_available),\n-                       byte_size_in_proper_unit(young_available), proper_unit_for_byte_size(young_available));\n+    heap->log_heap_status(\"At end of Degenerated GC\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahDegeneratedGC.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -68,0 +68,27 @@\n+\/\/ This is a temporary solution to work around a shortcoming with the existing free set implementation.\n+\/\/ TODO:\n+\/\/   Remove this function after restructing FreeSet representation.  A problem in the existing implementation is that old-gen\n+\/\/   regions are not considered to reside within the is_collector_free range.\n+\/\/\n+HeapWord* ShenandoahFreeSet::allocate_with_old_affiliation(ShenandoahAllocRequest& req, bool& in_new_region) {\n+  ShenandoahRegionAffiliation affiliation = ShenandoahRegionAffiliation::OLD_GENERATION;\n+\n+  size_t rightmost = MAX2(_collector_rightmost, _mutator_rightmost);\n+  size_t leftmost = MIN2(_collector_leftmost, _mutator_leftmost);\n+\n+  for (size_t c = rightmost + 1; c > leftmost; c--) {\n+    \/\/ size_t is unsigned, need to dodge underflow when _leftmost = 0\n+    size_t idx = c - 1;\n+    ShenandoahHeapRegion* r = _heap->get_region(idx);\n+    if (r->affiliation() == affiliation && !r->is_humongous()) {\n+      if (!r->is_cset() && !has_no_alloc_capacity(r)) {\n+        HeapWord* result = try_allocate_in(r, req, in_new_region);\n+        if (result != NULL) {\n+          return result;\n+        }\n+      }\n+    }\n+  }\n+  return nullptr;\n+}\n+\n@@ -148,1 +175,8 @@\n-      HeapWord* result = allocate_with_affiliation(req.affiliation(), req, in_new_region);\n+      HeapWord* result;\n+      if (req.affiliation() == ShenandoahRegionAffiliation::OLD_GENERATION) {\n+        \/\/ TODO: this is a work around to address a deficiency in FreeSet representation.  A better solution fixes\n+        \/\/ the FreeSet implementation to deal more efficiently with old-gen regions as being in the \"collector free set\"\n+        result = allocate_with_old_affiliation(req, in_new_region);\n+      } else {\n+        result = allocate_with_affiliation(req.affiliation(), req, in_new_region);\n+      }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":35,"deletions":1,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+  HeapWord* allocate_with_old_affiliation(ShenandoahAllocRequest& req, bool& in_new_region);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -177,5 +177,1 @@\n-    size_t old_available = heap->old_generation()->available();\n-    size_t young_available = heap->young_generation()->available();\n-    log_info(gc, ergo)(\"At end of Full GC, old_available: \" SIZE_FORMAT \"%s, young_available: \" SIZE_FORMAT \"%s\",\n-                       byte_size_in_proper_unit(old_available), proper_unit_for_byte_size(old_available),\n-                       byte_size_in_proper_unit(young_available), proper_unit_for_byte_size(young_available));\n+    heap->log_heap_status(\"At end of Full GC\");\n@@ -749,1 +745,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -145,1 +145,1 @@\n-void ShenandoahGeneration::log_status() const {\n+void ShenandoahGeneration::log_status(const char *msg) const {\n@@ -159,3 +159,5 @@\n-  LogGcInfo::print(\"%s generation used: \" SIZE_FORMAT \"%s, used regions: \" SIZE_FORMAT \"%s, \"\n-                   \"soft capacity: \" SIZE_FORMAT \"%s, max capacity: \" SIZE_FORMAT \" %s, available: \" SIZE_FORMAT \" %s\",\n-                   name(),\n+  size_t v_adjusted_avail = adjusted_available();\n+  LogGcInfo::print(\"%s: %s generation used: \" SIZE_FORMAT \"%s, used regions: \" SIZE_FORMAT \"%s, \"\n+                   \"soft capacity: \" SIZE_FORMAT \"%s, max capacity: \" SIZE_FORMAT \"%s, available: \" SIZE_FORMAT \"%s, \"\n+                   \"adjusted available: \" SIZE_FORMAT \"%s\",\n+                   msg, name(),\n@@ -166,1 +168,2 @@\n-                   byte_size_in_proper_unit(v_available), proper_unit_for_byte_size(v_available));\n+                   byte_size_in_proper_unit(v_available), proper_unit_for_byte_size(v_available),\n+                   byte_size_in_proper_unit(v_adjusted_avail), proper_unit_for_byte_size(v_adjusted_avail));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -128,1 +128,1 @@\n-  void log_status() const;\n+  void log_status(const char* msg) const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3154,0 +3154,1 @@\n+    HeapWord* tams = ctx? ctx->top_at_mark_start(r): nullptr;\n@@ -3188,1 +3189,1 @@\n-                                            \"Verify init-mark remembered set violation\", \"object not properly registered\", __FILE__, __LINE__);\n+                                               \"Verify init-mark remembered set violation\", \"object not properly registered\", __FILE__, __LINE__);\n@@ -3193,2 +3194,2 @@\n-            assert(ctx->top_at_mark_start(r) == top, \"Expect tams == top at start of mark.\");\n-            obj_addr = ctx->get_next_marked_addr(obj_addr, top);\n+            assert(tams != nullptr, \"If object is not live, ctx and tams should be non-null\");\n+            obj_addr = ctx->get_next_marked_addr(obj_addr, tams);\n@@ -3309,0 +3310,10 @@\n+\n+void ShenandoahHeap::log_heap_status(const char* msg) const {\n+  if (mode()->is_generational()) {\n+    young_generation()->log_status(msg);\n+    old_generation()->log_status(msg);\n+  } else {\n+    global_generation()->log_status(msg);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":14,"deletions":3,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -858,0 +858,3 @@\n+\n+  void log_heap_status(const char *msg) const;\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"}]}