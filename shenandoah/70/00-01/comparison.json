{"files":[{"patch":"@@ -805,0 +805,16 @@\n+void ShenandoahHeap::handle_old_evacuation(HeapWord* obj, size_t words, bool promotion) {\n+  \/\/ Only register the copy of the object that won the evacuation race.\n+  card_scan()->register_object_wo_lock(obj);\n+\n+  \/\/ Mark the entire range of the evacuated object as dirty.  At next remembered set scan,\n+  \/\/ we will clear dirty bits that do not hold interesting pointers.  It's more efficient to\n+  \/\/ do this in batch, in a background GC thread than to try to carefully dirty only cards\n+  \/\/ that hold interesting pointers right now.\n+  card_scan()->mark_range_as_dirty(obj, words);\n+\n+  if (promotion) {\n+    \/\/ This evacuation was a promotion, track this as allocation against old gen\n+    old_generation()->increase_allocated(words * HeapWordSize);\n+  }\n+}\n+\n@@ -1037,3 +1053,0 @@\n-      if (req.is_old()) {\n-        old_generation()->increase_allocated(actual_bytes);\n-      }\n@@ -1049,22 +1062,1 @@\n-  HeapWord* result = _free_set->allocate(req, in_new_region);\n-  if (result != NULL && req.affiliation() == ShenandoahRegionAffiliation::OLD_GENERATION) {\n-    \/\/ Register the newly allocated object while we're holding the global lock since there's no synchronization\n-    \/\/ built in to the implementation of register_object().  There are potential races when multiple independent\n-    \/\/ threads are allocating objects, some of which might span the same card region.  For example, consider\n-    \/\/ a card table's memory region within which three objects are being allocated by three different threads:\n-    \/\/\n-    \/\/ objects being \"concurrently\" allocated:\n-    \/\/    [-----a------][-----b-----][--------------c------------------]\n-    \/\/            [---- card table memory range --------------]\n-    \/\/\n-    \/\/ Before any objects are allocated, this card's memory range holds no objects.  Note that:\n-    \/\/   allocation of object a wants to set the has-object, first-start, and last-start attributes of the preceding card region.\n-    \/\/   allocation of object b wants to set the has-object, first-start, and last-start attributes of this card region.\n-    \/\/   allocation of object c also wants to set the has-object, first-start, and last-start attributes of this card region.\n-    \/\/\n-    \/\/ The thread allocating b and the thread allocating c can \"race\" in various ways, resulting in confusion, such as last-start\n-    \/\/ representing object b while first-start represents object c.  This is why we need to require all register_object()\n-    \/\/ invocations to be \"mutually exclusive\" with respect to each card's memory range.\n-    ShenandoahHeap::heap()->card_scan()->register_object(result);\n-  }\n-  return result;\n+  return _free_set->allocate(req, in_new_region);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":17,"deletions":25,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -676,0 +676,1 @@\n+  void handle_old_evacuation(HeapWord* obj, size_t words, bool promotion);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -314,4 +314,0 @@\n-\n-  if (mode()->is_generational() && obj != NULL) {\n-    ShenandoahHeap::heap()->card_scan()->register_object_wo_lock(obj);\n-  }\n@@ -396,1 +392,1 @@\n-      \/\/ Indicate that a promotion attempt failed.\n+      \/\/ TODO: Inform old generation heuristic of promotion failure\n@@ -411,12 +407,0 @@\n-  if (target_gen == YOUNG_GENERATION) {\n-    \/\/ Increment the age in young copies, absorbing region age.\n-    \/\/ (Only retired regions will have more than zero age to pass along.)\n-\n-    ShenandoahHeap::increase_object_age(copy_val, from_region->age() + 1);\n-\n-    \/\/ Note that p may have been forwarded by another thread,\n-    \/\/ anywhere between here and the check above for forwarding.\n-    \/\/ In that case try_update_forwardee() below will not be successful\n-    \/\/ and the increment we just performed will simply be forgotten,\n-    \/\/ but it will have succeeded in said other thread.\n-  }\n@@ -427,0 +411,1 @@\n+    \/\/ Successfully evacuated. Our copy is now the public one!\n@@ -428,10 +413,5 @@\n-      if (alloc_from_lab) {\n-        card_scan()->register_object_wo_lock(copy);\n-      }\n-      \/\/ else, allocate_memory_under_lock() has already registered the object\n-\n-      \/\/ Mark the entire range of the evacuated object as dirty.  At next remembered set scan,\n-      \/\/ we will clear dirty bits that do not hold interesting pointers.  It's more efficient to\n-      \/\/ do this in batch, in a background GC thread than to try to carefully dirty only cards\n-      \/\/ that hold interesting pointers right now.\n-      card_scan()->mark_range_as_dirty(copy, size);\n+      handle_old_evacuation(copy, size, from_region->is_young());\n+    } else if (target_gen == YOUNG_GENERATION) {\n+      ShenandoahHeap::increase_object_age(copy_val, from_region->age() + 1);\n+    } else {\n+      ShouldNotReachHere();\n@@ -439,1 +419,1 @@\n-    \/\/ Successfully evacuated. Our copy is now the public one!\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.inline.hpp","additions":8,"deletions":28,"binary":false,"changes":36,"status":"modified"}]}