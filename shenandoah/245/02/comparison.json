{"files":[{"patch":"@@ -388,1 +388,1 @@\n-      return;\n+    return;\n@@ -391,3 +391,0 @@\n-  ShenandoahBarrierSet* ctbs = ShenandoahBarrierSet::barrier_set();\n-  CardTable* ct = ctbs->card_table();\n-\n@@ -402,1 +399,1 @@\n-    __ ldrb(rscratch2,  Address(obj, rscratch1));\n+    __ ldrb(rscratch2, Address(obj, rscratch1));\n@@ -638,3 +635,0 @@\n-  ShenandoahBarrierSet* bs = ShenandoahBarrierSet::barrier_set();\n-  CardTable* ct = bs->card_table();\n-\n@@ -644,1 +638,2 @@\n-  __ cbz(count, L_done); \/\/ zero count - nothing to do\n+  \/\/ Zero count? Nothing to do.\n+  __ cbz(count, L_done);\n@@ -646,2 +641,4 @@\n-  __ lea(end, Address(start, count, Address::lsl(LogBytesPerHeapOop))); \/\/ end = start + count << LogBytesPerHeapOop\n-  __ sub(end, end, BytesPerHeapOop); \/\/ last element address to make inclusive\n+  \/\/ end = start + count << LogBytesPerHeapOop\n+  \/\/ last element address to make inclusive\n+  __ lea(end, Address(start, count, Address::lsl(LogBytesPerHeapOop)));\n+  __ sub(end, end, BytesPerHeapOop);\n@@ -650,1 +647,3 @@\n-  __ sub(count, end, start); \/\/ number of bytes to copy\n+\n+  \/\/ number of bytes to copy\n+  __ sub(count, end, start);\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shenandoah\/shenandoahBarrierSetAssembler_aarch64.cpp","additions":11,"deletions":12,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -64,1 +64,3 @@\n-  void gen_write_ref_array_post_barrier(MacroAssembler* masm, DecoratorSet decorators, Register start, Register count, Register scratch, RegSet saved_regs);\n+  void gen_write_ref_array_post_barrier(MacroAssembler* masm, DecoratorSet decorators,\n+                                        Register start, Register count,\n+                                        Register scratch, RegSet saved_regs);\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shenandoah\/shenandoahBarrierSetAssembler_aarch64.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -601,1 +601,1 @@\n-      return;\n+    return;\n@@ -806,1 +806,1 @@\n-  Label Lskip_loop, Lstore_loop;\n+  Label L_skip_loop, L_store_loop;\n@@ -809,1 +809,4 @@\n-  __ beq(CCR0, Lskip_loop); \/\/ zero length\n+\n+  \/\/ Zero length? Skip.\n+  __ beq(CCR0, L_skip_loop);\n+\n@@ -820,0 +823,1 @@\n+\n@@ -821,1 +825,1 @@\n-  __ bind(Lstore_loop);\n+  __ bind(L_store_loop);\n@@ -824,2 +828,2 @@\n-  __ bdnz(Lstore_loop);\n-  __ bind(Lskip_loop);\n+  __ bdnz(L_store_loop);\n+  __ bind(L_skip_loop);\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shenandoah\/shenandoahBarrierSetAssembler_ppc.cpp","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -96,1 +96,1 @@\n-  LIR_Opr result =  BarrierSetC1::atomic_cmpxchg_at_resolved(access, cmp_value, new_value);\n+  LIR_Opr result = BarrierSetC1::atomic_cmpxchg_at_resolved(access, cmp_value, new_value);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shenandoah\/c1\/shenandoahBarrierSetC1_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -129,3 +129,2 @@\n-      \/\/ We need to squirrel away the original element count because the\n-      \/\/ array copy assembly will destroy the value and we need it for the\n-      \/\/ card marking barrier.\n+      \/\/ We need to save the original element count because the array copy stub\n+      \/\/ will destroy the value and we need it for the card marking barrier.\n@@ -143,1 +142,1 @@\n-if (disjoint) {\n+      if (disjoint) {\n@@ -168,1 +167,1 @@\n-      Label done;\n+      Label L_done;\n@@ -171,1 +170,1 @@\n-      __ jcc(Assembler::zero, done);\n+      __ jcc(Assembler::zero, L_done);\n@@ -182,1 +181,1 @@\n-      __ jcc(Assembler::zero, done);\n+      __ jcc(Assembler::zero, L_done);\n@@ -202,1 +201,1 @@\n-      __ bind(done);\n+      __ bind(L_done);\n@@ -216,1 +215,1 @@\n-if (is_reference_type(type)) {\n+  if (is_reference_type(type)) {\n@@ -665,2 +664,2 @@\n-  \/\/ never need to be relocated. On 64bit however the value may be too\n-  \/\/ large for a 32bit displacement.\n+  \/\/ never need to be relocated. On 64-bit however the value may be too\n+  \/\/ large for a 32-bit displacement.\n@@ -684,1 +683,1 @@\n-    __ jcc(Assembler::equal, L_already_dirty);\n+    __ jccb(Assembler::equal, L_already_dirty);\n@@ -733,1 +732,1 @@\n-      \/\/ XXX: store_check missing from upstream\n+      \/\/ TODO: store_check missing in upstream\n@@ -941,1 +940,3 @@\n-void ShenandoahBarrierSetAssembler::gen_write_ref_array_post_barrier(MacroAssembler* masm, DecoratorSet decorators, Register addr, Register count, Register tmp) {\n+void ShenandoahBarrierSetAssembler::gen_write_ref_array_post_barrier(MacroAssembler* masm, DecoratorSet decorators,\n+                                                                     Register addr, Register count,\n+                                                                     Register tmp) {\n@@ -954,0 +955,1 @@\n+  \/\/ Zero count? Nothing to do.\n@@ -955,2 +957,1 @@\n-  __ jcc(Assembler::zero, L_done); \/\/ zero count - nothing to do\n-\n+  __ jccb(Assembler::zero, L_done);\n@@ -967,1 +968,2 @@\n-__ BIND(L_loop);\n+\n+  __ BIND(L_loop);\n@@ -970,1 +972,1 @@\n-  __ jcc(Assembler::greaterEqual, L_loop);\n+  __ jccb(Assembler::greaterEqual, L_loop);\n@@ -972,1 +974,1 @@\n-  __ lea(end,  Address(addr, count, Address::times_ptr, -wordSize));\n+  __ lea(end, Address(addr, count, Address::times_ptr, -wordSize));\n@@ -974,1 +976,1 @@\n-  __ shrptr(end,   CardTable::card_shift());\n+  __ shrptr(end,  CardTable::card_shift());\n@@ -976,1 +978,2 @@\n-__ BIND(L_loop);\n+\n+  __ BIND(L_loop);\n@@ -980,1 +983,1 @@\n-  __ jcc(Assembler::greaterEqual, L_loop);\n+  __ jccb(Assembler::greaterEqual, L_loop);\n@@ -983,1 +986,1 @@\n-__ BIND(L_done);\n+  __ BIND(L_done);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shenandoah\/shenandoahBarrierSetAssembler_x86.cpp","additions":26,"deletions":23,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -63,1 +63,3 @@\n-  void gen_write_ref_array_post_barrier(MacroAssembler* masm, DecoratorSet decorators, Register addr, Register count, Register tmp);\n+  void gen_write_ref_array_post_barrier(MacroAssembler* masm, DecoratorSet decorators,\n+                                        Register addr, Register count,\n+                                        Register tmp);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shenandoah\/shenandoahBarrierSetAssembler_x86.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -478,6 +478,1 @@\n-  ShenandoahBarrierSet* ctbs = barrier_set_cast<ShenandoahBarrierSet>(BarrierSet::barrier_set());\n-  CardTable* ct = ctbs->card_table();\n-  \/\/ No store check needed if we're storing a nullptr or an old object\n-  \/\/ (latter case is probably a string constant). The concurrent\n-  \/\/ mark sweep garbage collector, however, needs to have all nonNull\n-  \/\/ oop updates flagged via card-marks.\n+  \/\/ No store check needed if we're storing a null.\n@@ -488,1 +483,0 @@\n-      \/\/ stores of null never (?) need barriers\n@@ -615,1 +609,2 @@\n-    post_barrier(kit, kit->control(), access.raw_access(), access.base(), adr, adr_idx, val.node(), access.type(), use_precise);\n+    post_barrier(kit, kit->control(), access.raw_access(), access.base(),\n+                 adr, adr_idx, val.node(), access.type(), use_precise);\n@@ -741,1 +736,2 @@\n-    post_barrier(kit, kit->control(), access.raw_access(), access.base(), access.addr().node(), access.alias_idx(), new_val, T_OBJECT, true);\n+    post_barrier(kit, kit->control(), access.raw_access(), access.base(),\n+                 access.addr().node(), access.alias_idx(), new_val, T_OBJECT, true);\n@@ -904,1 +900,1 @@\n-    }\n+        }\n@@ -1020,15 +1016,14 @@\n-    assert(node->Opcode() == Op_CastP2X, \"ConvP2XNode required\");\n-     Node *shift = node->unique_out();\n-     Node *addp = shift->unique_out();\n-     for (DUIterator_Last jmin, j = addp->last_outs(jmin); j >= jmin; --j) {\n-       Node *mem = addp->last_out(j);\n-       if (UseCondCardMark && mem->is_Load()) {\n-         assert(mem->Opcode() == Op_LoadB, \"unexpected code shape\");\n-         \/\/ The load is checking if the card has been written so\n-         \/\/ replace it with zero to fold the test.\n-         macro->replace_node(mem, macro->intcon(0));\n-         continue;\n-       }\n-       assert(mem->is_Store(), \"store required\");\n-       macro->replace_node(mem, mem->in(MemNode::Memory));\n-     }\n+    Node* shift = node->unique_out();\n+    Node* addp = shift->unique_out();\n+    for (DUIterator_Last jmin, j = addp->last_outs(jmin); j >= jmin; --j) {\n+      Node *mem = addp->last_out(j);\n+      if (UseCondCardMark && mem->is_Load()) {\n+        assert(mem->Opcode() == Op_LoadB, \"unexpected code shape\");\n+        \/\/ The load is checking if the card has been written so\n+        \/\/ replace it with zero to fold the test.\n+        macro->replace_node(mem, macro->intcon(0));\n+        continue;\n+      }\n+      assert(mem->is_Store(), \"store required\");\n+      macro->replace_node(mem, mem->in(MemNode::Memory));\n+    }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahBarrierSetC2.cpp","additions":20,"deletions":25,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+\/\/ TODO: Provide comment here\n@@ -97,0 +98,1 @@\n+  \/\/ TODO: Split it in the separate methods for clarity.\n@@ -263,1 +265,2 @@\n-                        byte_size_in_proper_unit(available), proper_unit_for_byte_size(available), z_score,\n+                        byte_size_in_proper_unit(available),     proper_unit_for_byte_size(available),\n+                        z_score,\n@@ -265,1 +268,1 @@\n-                        byte_size_in_proper_unit(available_sd), proper_unit_for_byte_size(available_sd));\n+                        byte_size_in_proper_unit(available_sd),  proper_unit_for_byte_size(available_sd));\n@@ -338,1 +341,1 @@\n-                  byte_size_in_proper_unit(usable), proper_unit_for_byte_size(usable),\n+                  byte_size_in_proper_unit(usable),    proper_unit_for_byte_size(usable),\n@@ -352,2 +355,2 @@\n-                 byte_size_in_proper_unit(available), proper_unit_for_byte_size(available),\n-                 byte_size_in_proper_unit(min_threshold),       proper_unit_for_byte_size(min_threshold));\n+                 byte_size_in_proper_unit(available),     proper_unit_for_byte_size(available),\n+                 byte_size_in_proper_unit(min_threshold), proper_unit_for_byte_size(min_threshold));\n@@ -364,2 +367,2 @@\n-                   byte_size_in_proper_unit(available), proper_unit_for_byte_size(available),\n-                   byte_size_in_proper_unit(init_threshold),      proper_unit_for_byte_size(init_threshold));\n+                   byte_size_in_proper_unit(available),       proper_unit_for_byte_size(available),\n+                   byte_size_in_proper_unit(init_threshold),  proper_unit_for_byte_size(init_threshold));\n@@ -423,1 +426,2 @@\n-    _generation->name(), avg_cycle_time * 1000, byte_size_in_proper_unit(avg_alloc_rate), proper_unit_for_byte_size(avg_alloc_rate));\n+          _generation->name(), avg_cycle_time * 1000,\n+          byte_size_in_proper_unit(avg_alloc_rate), proper_unit_for_byte_size(avg_alloc_rate));\n@@ -426,1 +430,0 @@\n-\n@@ -429,1 +432,1 @@\n-                 byte_size_in_proper_unit(avg_alloc_rate), proper_unit_for_byte_size(avg_alloc_rate),\n+                 byte_size_in_proper_unit(avg_alloc_rate),      proper_unit_for_byte_size(avg_alloc_rate),\n@@ -449,1 +452,0 @@\n-\n@@ -466,2 +468,2 @@\n-    log_info(gc, ergo)(\"Not resizing %s for another \" UINT32_FORMAT \" cycles.\",\n-        _generation->name(),  _cycles_since_last_resize);\n+    log_info(gc, ergo)(\"Not resizing %s for another \" UINT32_FORMAT \" cycles\",\n+            _generation->name(), _cycles_since_last_resize);\n@@ -473,1 +475,1 @@\n-    log_info(gc, ergo)(\"Could not increase size of %s, begin gc cycle.\", _generation->name());\n+    log_info(gc, ergo)(\"Could not increase size of %s, begin gc cycle\", _generation->name());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.cpp","additions":16,"deletions":14,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -34,1 +34,6 @@\n-ShenandoahAggressiveHeuristics::ShenandoahAggressiveHeuristics(ShenandoahGeneration* generation) : ShenandoahHeuristics(generation) {\n+ShenandoahAggressiveHeuristics::ShenandoahAggressiveHeuristics(ShenandoahGeneration* generation) :\n+  ShenandoahHeuristics(generation) {\n+\n+  assert(!ShenandoahHeap::heap()->mode()->is_generational(),\n+         \"Aggressive heuristics is not available in generational mode\");\n+\n@@ -51,4 +56,2 @@\n-  assert(!ShenandoahHeap::heap()->mode()->is_generational(), \"AggressiveHeuristics not appropriate in generational mode\");\n-\n-  \/\/ Note that there's no bound on collection set size.  If we try to collect too much memory, we'll get an alloc\n-  \/\/ failure during collection and we'll degenerate.\n+  \/\/ Note that there is no bound on collection set size. If we try to collect too much memory,\n+  \/\/ we'll get an allocation failure during collection and slide to degenerated GC.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAggressiveHeuristics.cpp","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -50,2 +50,2 @@\n-  size_t capacity = _generation->soft_max_capacity();\n-  size_t available = _generation->available();\n+  size_t capacity     = _generation->soft_max_capacity();\n+  size_t available    = _generation->available();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahCompactHeuristics.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -78,1 +78,1 @@\n-size_t ShenandoahHeuristics::select_aged_regions(size_t old_available, size_t num_regions, bool preselected_regions[]) {\n+size_t ShenandoahHeuristics::select_aged_regions(size_t old_available, size_t num_regions, bool* preselected_regions) {\n@@ -80,0 +80,5 @@\n+  if (!heap->mode()->is_generational()) {\n+    \/\/ TODO: Do we need this check, or assert is enough?\n+    return 0;\n+  }\n+\n@@ -81,11 +86,7 @@\n-  if (heap->mode()->is_generational()) {\n-    for (size_t i = 0; i < num_regions; i++) {\n-      ShenandoahHeapRegion* region = heap->get_region(i);\n-      if (in_generation(region) && !region->is_empty() && region->is_regular() && (region->age() >= InitialTenuringThreshold)) {\n-        size_t promotion_need = (size_t) (region->get_live_data_bytes() * ShenandoahEvacWaste);\n-        if (old_consumed + promotion_need < old_available) {\n-          old_consumed += promotion_need;\n-          preselected_regions[i] = true;\n-        }\n-        \/\/ Note that we keep going even if one region is excluded from selection.  Subsequent regions may be selected\n-        \/\/ if they have smaller live data.\n+  for (size_t i = 0; i < num_regions; i++) {\n+    ShenandoahHeapRegion* region = heap->get_region(i);\n+    if (in_generation(region) && !region->is_empty() && region->is_regular() && (region->age() >= InitialTenuringThreshold)) {\n+      size_t promotion_need = (size_t) (region->get_live_data_bytes() * ShenandoahEvacWaste);\n+      if (old_consumed + promotion_need < old_available) {\n+        old_consumed += promotion_need;\n+        preselected_regions[i] = true;\n@@ -93,0 +94,2 @@\n+      \/\/ Note that we keep going even if one region is excluded from selection.\n+      \/\/ Subsequent regions may be selected if they have smaller live data.\n@@ -103,1 +106,2 @@\n-  assert(_generation->generation_mode() != OLD, \"Old GC invokes ShenandoahOldHeuristics::choose_collection_set()\");\n+  assert(!is_generational || _generation->generation_mode() != OLD,\n+         \"Old GC invokes ShenandoahOldHeuristics::choose_collection_set()\");\n@@ -123,1 +127,0 @@\n-  size_t live_memory = 0;\n@@ -144,1 +147,0 @@\n-        live_memory += region->get_live_data_bytes();\n@@ -170,2 +172,0 @@\n-      } else {\n-        live_memory += region->get_live_data_bytes();\n@@ -177,2 +177,0 @@\n-    } else {                      \/\/ region->is_humongous_cont() and !region->is_trash()\n-      live_memory += region->get_live_data_bytes();\n@@ -196,0 +194,2 @@\n+    } else {\n+      \/\/ This is a global collection and does not need to prime cset\n@@ -197,1 +197,0 @@\n-    \/\/ else, this is global collection and doesn't need to prime_collection_set\n@@ -199,2 +198,1 @@\n-    \/\/ Add young-gen regions into the collection set.  This is a virtual call, implemented differently by each\n-    \/\/ of the heuristics subclasses.\n+    \/\/ Call the subclasses to add young-gen regions into the collection set.\n@@ -203,1 +201,2 @@\n-    \/\/ we're going to skip evacuation and update refs because we reclaimed sufficient amounts of immediate garbage.\n+    \/\/ We are going to skip evacuation and update refs because we reclaimed\n+    \/\/ sufficient amounts of immediate garbage.\n@@ -216,2 +215,2 @@\n-                     \"Immediate: \" SIZE_FORMAT \"%s (\" SIZE_FORMAT \"%%) R: \" SIZE_FORMAT \", \"\n-                     \"CSet: \" SIZE_FORMAT \"%s (\" SIZE_FORMAT \"%%) R: \" SIZE_FORMAT,\n+                     \"Immediate: \" SIZE_FORMAT \"%s (\" SIZE_FORMAT \"%%), \" SIZE_FORMAT \" regions, \"\n+                     \"CSet: \" SIZE_FORMAT \"%s (\" SIZE_FORMAT \"%%), \" SIZE_FORMAT \" regions\",\n@@ -234,1 +233,1 @@\n-    size_t young_evac_bytes = collection_set->get_young_bytes_reserved_for_evacuation();\n+    size_t young_evac_bytes   = collection_set->get_young_bytes_reserved_for_evacuation();\n@@ -236,2 +235,2 @@\n-    size_t old_evac_bytes = collection_set->get_old_bytes_reserved_for_evacuation();\n-    size_t total_evac_bytes = young_evac_bytes + promote_evac_bytes + old_evac_bytes;\n+    size_t old_evac_bytes     = collection_set->get_old_bytes_reserved_for_evacuation();\n+    size_t total_evac_bytes   = young_evac_bytes + promote_evac_bytes + old_evac_bytes;\n@@ -242,1 +241,1 @@\n-                       byte_size_in_proper_unit(young_evac_bytes), proper_unit_for_byte_size(young_evac_bytes),\n+                       byte_size_in_proper_unit(young_evac_bytes),   proper_unit_for_byte_size(young_evac_bytes),\n@@ -244,2 +243,2 @@\n-                       byte_size_in_proper_unit(old_evac_bytes), proper_unit_for_byte_size(old_evac_bytes),\n-                       byte_size_in_proper_unit(total_evac_bytes), proper_unit_for_byte_size(total_evac_bytes));\n+                       byte_size_in_proper_unit(old_evac_bytes),     proper_unit_for_byte_size(old_evac_bytes),\n+                       byte_size_in_proper_unit(total_evac_bytes),   proper_unit_for_byte_size(total_evac_bytes));\n@@ -377,4 +376,2 @@\n-  size_t min_free_threshold =\n-      _generation->generation_mode() == GenerationMode::OLD\n-          ? ShenandoahOldMinFreeThreshold\n-          : ShenandoahMinFreeThreshold;\n+  size_t min_free_threshold = (_generation->generation_mode() == GenerationMode::OLD) ?\n+          ShenandoahOldMinFreeThreshold : ShenandoahMinFreeThreshold;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.cpp","additions":32,"deletions":35,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -77,6 +77,5 @@\n-  \/\/ if (_generation->generation_mode() == GLOBAL) _region_data represents\n-  \/\/  the results of most recently completed global marking pass\n-  \/\/ if (_generation->generation_mode() == OLD) _region_data represents\n-  \/\/  the results of most recently completed old-gen marking pass\n-  \/\/ if (_generation->generation_mode() == YOUNG) _region_data represents\n-  \/\/  the results of most recently completed young-gen marking pass\n+  \/\/ Depending on generation mode, region data represents the results of the relevant\n+  \/\/ most recently completed marking pass:\n+  \/\/   - in GLOBAL mode, global marking pass\n+  \/\/   - in OLD mode,    old-gen marking pass\n+  \/\/   - in YOUNG mode,  young-gen marking pass\n@@ -84,3 +83,3 @@\n-  \/\/ Note that there is some redundancy represented in _region_data because\n-  \/\/ each instance is an array large enough to hold all regions.  However,\n-  \/\/ any region in young-gen is not in old-gen.  And any time we are\n+  \/\/ Note that there is some redundancy represented in region data because\n+  \/\/ each instance is an array large enough to hold all regions. However,\n+  \/\/ any region in young-gen is not in old-gen. And any time we are\n@@ -88,1 +87,1 @@\n-  \/\/ YOUNG or OLD data.  Consider this redundancy of data structure to\n+  \/\/ YOUNG or OLD data. Consider this redundancy of data structure to\n@@ -159,1 +158,1 @@\n-  virtual size_t select_aged_regions(size_t old_available, size_t num_regions, bool preselected_regions[]);\n+  virtual size_t select_aged_regions(size_t old_available, size_t num_regions, bool* preselected_regions);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.hpp","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -86,3 +86,4 @@\n-    \/\/ It's probably overkill to compensate with lost_evacuation_capacity.  But it's the safe thing to do and\n-    \/\/  has minimal impact on content of primed collection set.\n-    if (r->get_live_data_bytes() + lost_evacuation_capacity <= remaining_old_evacuation_budget) {\n+    \/\/ It's probably overkill to compensate with lost_evacuation_capacity.\n+    \/\/ But it's the safe thing to do and has minimal impact on content of primed collection set.\n+    size_t live = r->get_live_data_bytes();\n+    if (live + lost_evacuation_capacity <= remaining_old_evacuation_budget) {\n@@ -91,1 +92,1 @@\n-      remaining_old_evacuation_budget -= r->get_live_data_bytes();\n+      remaining_old_evacuation_budget -= live;\n@@ -94,1 +95,1 @@\n-      evacuated_old_bytes += r->get_live_data_bytes();\n+      evacuated_old_bytes += live;\n@@ -124,1 +125,1 @@\n-      log_info(gc)(\"All candidate regions \" UINT32_FORMAT \" are pinned.\", unprocessed_old_collection_candidates());\n+      log_info(gc)(\"All candidate regions \" UINT32_FORMAT \" are pinned\", unprocessed_old_collection_candidates());\n@@ -140,1 +141,1 @@\n-    auto region = _region_data[i]._region;\n+    ShenandoahHeapRegion* region = _region_data[i]._region;\n@@ -188,1 +189,1 @@\n-  for (int32_t search = write_index - 1; search >= (int32_t)_first_pinned_candidate; --search) {\n+  for (int32_t search = (int32_t)write_index - 1; search >= (int32_t)_first_pinned_candidate; --search) {\n@@ -207,2 +208,2 @@\n-  assert((collection_set == nullptr) && (old_heuristics == nullptr),\n-         \"Expect null arguments in ShenandoahOldHeuristics::choose_collection_set()\");\n+  assert(collection_set == nullptr, \"Expect null\");\n+  assert(old_heuristics == nullptr, \"Expect null\");\n@@ -298,1 +299,1 @@\n-               byte_size_in_proper_unit(immediate_garbage), proper_unit_for_byte_size(immediate_garbage), immediate_regions);\n+               byte_size_in_proper_unit(immediate_garbage),   proper_unit_for_byte_size(immediate_garbage),   immediate_regions);\n@@ -307,0 +308,1 @@\n+\/\/ TODO: Unused?\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.cpp","additions":13,"deletions":11,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-  size_t available = MAX2((max_capacity \/ 100) * ShenandoahEvacReserve, actual_free);\n+  size_t available = MAX2(max_capacity \/ 100 * ShenandoahEvacReserve, actual_free);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahPassiveHeuristics.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,2 +45,2 @@\n-  size_t capacity = _generation->soft_max_capacity();\n-  size_t available = _generation->available();\n+  size_t capacity     = _generation->soft_max_capacity();\n+  size_t available    = _generation->available();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahStaticHeuristics.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -68,0 +68,2 @@\n+\/\/ TODO: These have no place in this compilation unit. Should probably be in shenandoahHeap.cpp\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/mode\/shenandoahGenerationalMode.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -432,1 +432,2 @@\n-\/\/ unlike assert_heaplocked_or_safepoint(), this does not require current thread in safepoint to be a VM-thread\n+\/\/ Unlike assert_heaplocked_or_safepoint(), this does not require current thread in safepoint to be a VM thread\n+\/\/ TODO: This should be more aptly named. Nothing in this method checks we are actually in Full GC.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAsserts.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -135,0 +135,1 @@\n+    \/\/ TODO: Assert this in retire_plab?\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -51,1 +51,3 @@\n-  inline ShenandoahCardTable* card_table()  { return _card_table; }\n+  inline ShenandoahCardTable* card_table() {\n+    return _card_table;\n+  }\n@@ -119,1 +121,1 @@\n-  void write_ref_field_post(T* field, oop newVal);\n+  void write_ref_field_post(T* field);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -188,1 +188,1 @@\n-inline void ShenandoahBarrierSet::write_ref_field_post(T* field, oop newVal) {\n+inline void ShenandoahBarrierSet::write_ref_field_post(T* field) {\n@@ -258,1 +258,3 @@\n-  shenandoah_assert_marked_if(nullptr, value, !CompressedOops::is_null(value) && ShenandoahHeap::heap()->is_evacuation_in_progress() &&\n+  shenandoah_assert_marked_if(nullptr, value,\n+                              !CompressedOops::is_null(value) &&\n+                              ShenandoahHeap::heap()->is_evacuation_in_progress() &&\n@@ -280,1 +282,2 @@\n-  ShenandoahBarrierSet::barrier_set()->write_ref_field_post<decorators>(addr, value);\n+  ShenandoahBarrierSet* bs = ShenandoahBarrierSet::barrier_set();\n+  bs->write_ref_field_post<decorators>(addr);\n@@ -302,1 +305,1 @@\n-  bs->write_ref_field_post<decorators>(addr, new_value);\n+  bs->write_ref_field_post<decorators>(addr);\n@@ -313,1 +316,1 @@\n-  bs->write_ref_field_post<decorators>(addr, new_value);\n+  bs->write_ref_field_post<decorators>(addr);\n@@ -331,1 +334,1 @@\n-  bs->write_ref_field_post<decorators>(addr, new_value);\n+  bs->write_ref_field_post<decorators>(addr);\n@@ -342,1 +345,1 @@\n-  bs->write_ref_field_post<decorators>(addr, new_value);\n+  bs->write_ref_field_post<decorators>(addr);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.inline.hpp","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -38,1 +38,2 @@\n-      _dirty_card_cnt, _max_dirty_run, _clean_card_cnt, _max_clean_run,\n+      _dirty_card_cnt, _max_dirty_run,\n+      _clean_card_cnt, _max_clean_run,\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCardStats.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -33,9 +33,9 @@\n-  DIRTY_RUN = 0,\n-  CLEAN_RUN = 1,\n-  DIRTY_CARDS = 2,\n-  CLEAN_CARDS = 3,\n-  MAX_DIRTY_RUN = 4,\n-  MAX_CLEAN_RUN = 5,\n-  DIRTY_SCAN_OBJS = 6,\n-  ALTERNATIONS = 7,\n-  MAX_CARD_STAT_TYPE = 8\n+  DIRTY_RUN           = 0,\n+  CLEAN_RUN           = 1,\n+  DIRTY_CARDS         = 2,\n+  CLEAN_CARDS         = 3,\n+  MAX_DIRTY_RUN       = 4,\n+  MAX_CLEAN_RUN       = 5,\n+  DIRTY_SCAN_OBJS     = 6,\n+  ALTERNATIONS        = 7,\n+  MAX_CARD_STAT_TYPE  = 8\n@@ -45,3 +45,3 @@\n-  CARD_STAT_SCAN_RS = 0,\n-  CARD_STAT_UPDATE_REFS = 1,\n-  MAX_CARD_STAT_LOG_TYPE = 2\n+  CARD_STAT_SCAN_RS       = 0,\n+  CARD_STAT_UPDATE_REFS   = 1,\n+  MAX_CARD_STAT_LOG_TYPE  = 2\n@@ -58,3 +58,0 @@\n-  size_t _dirty_run;\n-  size_t _clean_run;\n-\n@@ -87,2 +84,2 @@\n-      _local_card_stats[DIRTY_CARDS].add((double)_dirty_card_cnt*100\/(double)_cards_in_cluster);\n-      _local_card_stats[CLEAN_CARDS].add((double)_clean_card_cnt*100\/(double)_cards_in_cluster);\n+      _local_card_stats[DIRTY_CARDS].add(percent_of(_dirty_card_cnt, _cards_in_cluster));\n+      _local_card_stats[CLEAN_CARDS].add(percent_of(_clean_card_cnt, _cards_in_cluster));\n@@ -91,2 +88,2 @@\n-      _local_card_stats[MAX_DIRTY_RUN].add((double)_max_dirty_run*100\/(double)_cards_in_cluster);\n-      _local_card_stats[MAX_CLEAN_RUN].add((double)_max_clean_run*100\/(double)_cards_in_cluster);\n+      _local_card_stats[MAX_DIRTY_RUN].add(percent_of(_max_dirty_run, _cards_in_cluster));\n+      _local_card_stats[MAX_CLEAN_RUN].add(percent_of(_max_clean_run, _cards_in_cluster));\n@@ -111,1 +108,1 @@\n-      _local_card_stats[DIRTY_RUN].add((double)len*100.0\/(double)_cards_in_cluster);\n+      _local_card_stats[DIRTY_RUN].add(percent_of(len, _cards_in_cluster));\n@@ -123,1 +120,1 @@\n-      _local_card_stats[CLEAN_RUN].add((double)len*100.0\/(double)_cards_in_cluster);\n+      _local_card_stats[CLEAN_RUN].add(percent_of(len, _cards_in_cluster));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCardStats.hpp","additions":18,"deletions":21,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -34,0 +34,3 @@\n+\n+  \/\/ TODO: Why rs_align is 0 on page_size == os::vm_page_size?\n+  \/\/ ReservedSpace constructor would assert rs_align >= os::vm_page_size().\n@@ -47,1 +50,1 @@\n-  log_trace(gc, barrier)(\"ShenandoahCardTable::ShenandoahCardTable: \");\n+  log_trace(gc, barrier)(\"ShenandoahCardTable::ShenandoahCardTable:\");\n@@ -71,0 +74,1 @@\n+\/\/ TODO: Seems to be unused\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCardTable.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -93,0 +93,3 @@\n+  size_t live = r->get_live_data_bytes();\n+  size_t garbage = r->garbage();\n+\n@@ -95,1 +98,1 @@\n-    _young_bytes_to_evacuate += r->get_live_data_bytes();\n+    _young_bytes_to_evacuate += live;\n@@ -97,1 +100,1 @@\n-      _young_bytes_to_promote += r->get_live_data_bytes();\n+      _young_bytes_to_promote += live;\n@@ -101,2 +104,2 @@\n-    _old_bytes_to_evacuate += r->get_live_data_bytes();\n-    _old_garbage += r->garbage();\n+    _old_bytes_to_evacuate += live;\n+    _old_garbage += garbage;\n@@ -107,1 +110,1 @@\n-  _garbage += r->garbage();\n+  _garbage += garbage;\n@@ -109,1 +112,1 @@\n-  _live += r->get_live_data_bytes();\n+  _live += live;\n@@ -186,2 +189,2 @@\n-                byte_size_in_proper_unit(live()), proper_unit_for_byte_size(live()),\n-                byte_size_in_proper_unit(used()), proper_unit_for_byte_size(used()));\n+                byte_size_in_proper_unit(live()),    proper_unit_for_byte_size(live()),\n+                byte_size_in_proper_unit(used()),    proper_unit_for_byte_size(used()));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCollectionSet.cpp","additions":11,"deletions":8,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -60,1 +60,2 @@\n-  size_t                _old_garbage;        \/\/ How many bytes of old garbage are present in a mixed collection set?\n+  \/\/ How many bytes of old garbage are present in a mixed collection set?\n+  size_t                _old_garbage;\n@@ -62,3 +63,4 @@\n-  bool*                 _preselected_regions;   \/\/ Points to array identifying which tenure-age regions have been preselected\n-                                                \/\/ for inclusion in collection set.  This field is only valid during brief\n-                                                \/\/ spans of time while collection set is being constructed.\n+  \/\/ Points to array identifying which tenure-age regions have been preselected\n+  \/\/ for inclusion in collection set. This field is only valid during brief\n+  \/\/ spans of time while collection set is being constructed.\n+  bool*                 _preselected_regions;\n@@ -102,0 +104,1 @@\n+  \/\/ TODO: Seems unused.\n@@ -106,1 +109,0 @@\n-\n@@ -112,1 +114,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCollectionSet.hpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -118,1 +118,1 @@\n-    \/\/ Reset task queue stats here, rather than in mark_concurrent_roots\n+    \/\/ Reset task queue stats here, rather than in mark_concurrent_roots,\n@@ -125,2 +125,1 @@\n-    \/\/ When RS scanning yields, we will need a check_cancellation_and_abort()\n-    \/\/ degeneration point here.\n+    \/\/ TODO: When RS scanning yields, we will need a check_cancellation_and_abort() degeneration point here.\n@@ -221,1 +220,0 @@\n-    size_t old_available, young_available;\n@@ -237,3 +235,0 @@\n-      young_available = young_gen->adjusted_available();\n-      old_available = old_gen->adjusted_available();\n-\n@@ -624,1 +619,1 @@\n-      if (_generation->generation_mode() == YOUNG || (_generation->generation_mode() == GLOBAL && ShenandoahVerify)) {\n+    if (_generation->generation_mode() == YOUNG || (_generation->generation_mode() == GLOBAL && ShenandoahVerify)) {\n@@ -628,2 +623,3 @@\n-        ShenandoahGCPhase phase(ShenandoahPhaseTimings::init_swap_rset);\n-        _generation->swap_remembered_set();\n+      \/\/ TODO: This path should not really depend on ShenandoahVerify.\n+      ShenandoahGCPhase phase(ShenandoahPhaseTimings::init_swap_rset);\n+      _generation->swap_remembered_set();\n@@ -778,1 +774,2 @@\n-        size_t young_available = heap->young_generation()->adjust_available(heap->get_alloc_supplement_reserve());\n+        intptr_t adjustment = heap->get_alloc_supplement_reserve();\n+        size_t young_available = heap->young_generation()->adjust_available(adjustment);\n@@ -781,1 +778,1 @@\n-        size_t old_available = heap->old_generation()->adjust_available(-heap->get_alloc_supplement_reserve());\n+        size_t old_available = heap->old_generation()->adjust_available(-adjustment);\n@@ -785,1 +782,1 @@\n-                           byte_size_in_proper_unit(old_available), proper_unit_for_byte_size(old_available),\n+                           byte_size_in_proper_unit(old_available),   proper_unit_for_byte_size(old_available),\n@@ -1244,1 +1241,1 @@\n-         \"Should not have forwarded objects during final mark (unless old gen concurrent mark is running)\");\n+         \"Should not have forwarded objects during final mark, unless old gen concurrent mark is running\");\n@@ -1255,1 +1252,1 @@\n-         \"Should not have forwarded objects concurrent mark (unless old gen concurrent mark is running\");\n+         \"Should not have forwarded objects concurrent mark, unless old gen concurrent mark is running\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":12,"deletions":15,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -99,1 +99,0 @@\n-  virtual void op_final_mark();\n@@ -127,0 +126,2 @@\n+protected:\n+  virtual void op_final_mark();\n@@ -128,0 +129,1 @@\n+private:\n@@ -130,2 +132,1 @@\n-  \/\/ Messages for GC trace events, they have to be immortal for\n-  \/\/ passing around the logging\/tracing systems\n+  \/\/ Messages for GC trace events\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -120,1 +120,1 @@\n-      ShenandoahObjToScanQueue* old = _cm->get_old_queue(worker_id);\n+      ShenandoahObjToScanQueue* old_q = _cm->get_old_queue(worker_id);\n@@ -122,1 +122,1 @@\n-      ShenandoahSATBBufferClosure<GENERATION> cl(q, old);\n+      ShenandoahSATBBufferClosure<GENERATION> cl(q, old_q);\n@@ -127,1 +127,1 @@\n-      ShenandoahMarkRefsClosure<GENERATION> mark_cl(q, rp, old);\n+      ShenandoahMarkRefsClosure<GENERATION> mark_cl(q, rp, old_q);\n@@ -180,1 +180,2 @@\n-  ShenandoahObjToScanQueue* old = _old_queue_set == nullptr ? nullptr : _old_queue_set->queue(worker_id);\n+  ShenandoahObjToScanQueue* old = (_old_queue_set == nullptr) ?\n+          nullptr : _old_queue_set->queue(worker_id);\n@@ -194,1 +195,2 @@\n-      ShenandoahMarkConcurrentRootsTask<YOUNG> task(task_queues(), old_task_queues(), rp, ShenandoahPhaseTimings::conc_mark_roots, workers->active_workers());\n+      ShenandoahMarkConcurrentRootsTask<YOUNG> task(task_queues(), old_task_queues(), rp,\n+                                                    ShenandoahPhaseTimings::conc_mark_roots, workers->active_workers());\n@@ -199,2 +201,3 @@\n-      assert(old_task_queues() == nullptr, \"Global mark should not have old gen mark queues.\");\n-      ShenandoahMarkConcurrentRootsTask<GLOBAL> task(task_queues(), old_task_queues(), rp, ShenandoahPhaseTimings::conc_mark_roots, workers->active_workers());\n+      assert(old_task_queues() == nullptr, \"Global mark should not have old gen mark queues\");\n+      ShenandoahMarkConcurrentRootsTask<GLOBAL> task(task_queues(), nullptr, rp,\n+                                                     ShenandoahPhaseTimings::conc_mark_roots, workers->active_workers());\n@@ -204,0 +207,5 @@\n+    case OLD: {\n+      \/\/ We use a YOUNG generation cycle to bootstrap concurrent old marking.\n+      ShouldNotReachHere();\n+      break;\n+    }\n@@ -205,2 +213,0 @@\n-      \/\/ Intentionally haven't added OLD here. We use a YOUNG generation\n-      \/\/ cycle to bootstrap concurrent old marking.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentMark.cpp","additions":15,"deletions":9,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-template<GenerationMode GENERATION>\n+template <GenerationMode GENERATION>\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentMark.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -144,1 +144,2 @@\n-        _degen_generation = heap->mode()->is_generational() ? heap->young_generation() : heap->global_generation();\n+        _degen_generation = heap->mode()->is_generational() ?\n+                heap->young_generation() : heap->global_generation();\n@@ -146,1 +147,1 @@\n-        assert(_degen_generation != nullptr, \"Need to know which generation to resume.\");\n+        assert(_degen_generation != nullptr, \"Need to know which generation to resume\");\n@@ -153,1 +154,1 @@\n-      \/\/ Do not bother with degenerated cycle if old generation evacuation failed.\n+      \/\/ Do not bother with degenerated cycle if old generation evacuation failed\n@@ -205,1 +206,1 @@\n-          assert(!heap->is_concurrent_old_mark_in_progress(), \"Should not be running mixed collections and concurrent marking.\");\n+          assert(!heap->is_concurrent_old_mark_in_progress(), \"Should not be running mixed collections and concurrent marking\");\n@@ -215,1 +216,1 @@\n-        \/\/ Don't start a new old marking if there is one already in progress.\n+        \/\/ Don't start a new old marking if there is one already in progress\n@@ -234,3 +235,3 @@\n-        log_info(gc)(\"Resume old gc: marking=%s, preparing=%s\",\n-                     BOOL_TO_STR(heap->is_concurrent_old_mark_in_progress()),\n-                     BOOL_TO_STR(heap->is_prepare_for_old_mark_in_progress()));\n+        log_info(gc)(\"Resume old GC: marking is%s in progress, preparing is%s in progress\",\n+                     heap->is_concurrent_old_mark_in_progress() ? \"\" : \" NOT\",\n+                     heap->is_prepare_for_old_mark_in_progress() ? \"\" : \" NOT\");\n@@ -273,30 +274,11 @@\n-      {\n-        switch (_mode) {\n-          case concurrent_normal: {\n-            \/\/ At this point:\n-            \/\/  if (generation == YOUNG), this is a normal YOUNG cycle\n-            \/\/  if (generation == OLD), this is a bootstrap OLD cycle\n-            \/\/  if (generation == GLOBAL), this is a GLOBAL cycle triggered by System.gc()\n-            \/\/ In all three cases, we want to age old objects if this is an aging cycle\n-            if (age_period-- == 0) {\n-              heap->set_aging_cycle(true);\n-              age_period = ShenandoahAgingCyclePeriod - 1;\n-            }\n-            service_concurrent_normal_cycle(heap, generation, cause);\n-            break;\n-          }\n-          case stw_degenerated: {\n-            heap->set_aging_cycle(was_aging_cycle);\n-            if (!service_stw_degenerated_cycle(cause, degen_point)) {\n-              \/\/ The degenerated GC was upgraded to a Full GC\n-              generation = GLOBAL;\n-            }\n-            break;\n-          }\n-          case stw_full: {\n-            if (age_period-- == 0) {\n-              heap->set_aging_cycle(true);\n-              age_period = ShenandoahAgingCyclePeriod - 1;\n-            }\n-            service_stw_full_cycle(cause);\n-            break;\n+\n+      switch (_mode) {\n+        case concurrent_normal: {\n+          \/\/ At this point:\n+          \/\/  if (generation == YOUNG), this is a normal YOUNG cycle\n+          \/\/  if (generation == OLD), this is a bootstrap OLD cycle\n+          \/\/  if (generation == GLOBAL), this is a GLOBAL cycle triggered by System.gc()\n+          \/\/ In all three cases, we want to age old objects if this is an aging cycle\n+          if (age_period-- == 0) {\n+             heap->set_aging_cycle(true);\n+             age_period = ShenandoahAgingCyclePeriod - 1;\n@@ -304,5 +286,8 @@\n-          case servicing_old: {\n-            assert(generation == OLD, \"Expected old generation here\");\n-            GCIdMark gc_id_mark;\n-            service_concurrent_old_cycle(heap, cause);\n-            break;\n+          service_concurrent_normal_cycle(heap, generation, cause);\n+          break;\n+        }\n+        case stw_degenerated: {\n+          heap->set_aging_cycle(was_aging_cycle);\n+          if (!service_stw_degenerated_cycle(cause, degen_point)) {\n+            \/\/ The degenerated GC was upgraded to a Full GC\n+            generation = GLOBAL;\n@@ -310,2 +295,6 @@\n-          default: {\n-            ShouldNotReachHere();\n+          break;\n+        }\n+        case stw_full: {\n+          if (age_period-- == 0) {\n+            heap->set_aging_cycle(true);\n+            age_period = ShenandoahAgingCyclePeriod - 1;\n@@ -313,0 +302,8 @@\n+          service_stw_full_cycle(cause);\n+          break;\n+        }\n+        case servicing_old: {\n+          assert(generation == OLD, \"Expected old generation here\");\n+          GCIdMark gc_id_mark;\n+          service_concurrent_old_cycle(heap, cause);\n+          break;\n@@ -314,0 +311,2 @@\n+        default:\n+          ShouldNotReachHere();\n@@ -407,1 +406,0 @@\n-\n@@ -424,1 +422,1 @@\n-                                                             &evac_stats.mutators);\n+                                                        &evac_stats.mutators);\n@@ -433,1 +431,0 @@\n-\n@@ -461,2 +458,3 @@\n-void ShenandoahControlThread::service_concurrent_normal_cycle(\n-  const ShenandoahHeap* heap, const GenerationMode generation, GCCause::Cause cause) {\n+void ShenandoahControlThread::service_concurrent_normal_cycle(const ShenandoahHeap* heap,\n+                                                              const GenerationMode generation,\n+                                                              GCCause::Cause cause) {\n@@ -491,1 +489,2 @@\n-      msg = (generation == YOUNG)? \"At end of Interrupted Concurrent Young GC\": \"At end of Interrupted Concurrent Bootstrap GC\";\n+      msg = (generation == YOUNG) ? \"At end of Interrupted Concurrent Young GC\" :\n+                                    \"At end of Interrupted Concurrent Bootstrap GC\";\n@@ -493,1 +492,2 @@\n-      msg = (generation == YOUNG)? \"At end of Concurrent Young GC\": \"At end of Concurrent Bootstrap GC\";\n+      msg = (generation == YOUNG) ? \"At end of Concurrent Young GC\" :\n+                                    \"At end of Concurrent Bootstrap GC\";\n@@ -496,1 +496,2 @@\n-    msg = heap->cancelled_gc() ? \"At end of cancelled GC\" : \"At end of GC\";\n+    msg = heap->cancelled_gc() ? \"At end of cancelled GC\" :\n+                                 \"At end of GC\";\n@@ -502,1 +503,0 @@\n-\n@@ -512,2 +512,2 @@\n-      assert(!heap->is_concurrent_old_mark_in_progress(), \"Old already in progress.\");\n-      assert(old_generation->task_queues()->is_empty(), \"Old mark queues should be empty.\");\n+      assert(!heap->is_concurrent_old_mark_in_progress(), \"Old already in progress\");\n+      assert(old_generation->task_queues()->is_empty(), \"Old mark queues should be empty\");\n@@ -522,1 +522,1 @@\n-        assert(old_generation->state() == ShenandoahOldGeneration::FILLING, \"Prepare for mark should be in progress.\");\n+        assert(old_generation->state() == ShenandoahOldGeneration::FILLING, \"Prepare for mark should be in progress\");\n@@ -526,1 +526,1 @@\n-      assert(old_generation->state() == ShenandoahOldGeneration::BOOTSTRAPPING, \"Finished with filling, should be bootstrapping.\");\n+      assert(old_generation->state() == ShenandoahOldGeneration::BOOTSTRAPPING, \"Finished with filling, should be bootstrapping\");\n@@ -541,1 +541,1 @@\n-        log_info(gc)(\"Bootstrap cycle for old generation was cancelled.\");\n+        log_info(gc)(\"Bootstrap cycle for old generation was cancelled\");\n@@ -562,1 +562,1 @@\n-        assert(old_generation->state() != ShenandoahOldGeneration::MARKING, \"Should not still be marking.\");\n+        assert(old_generation->state() != ShenandoahOldGeneration::MARKING, \"Should not still be marking\");\n@@ -572,2 +572,1 @@\n-      log_error(gc)(\"Unexpected state for old GC: %d\", old_generation->state());\n-      ShouldNotReachHere();\n+      fatal(\"Unexpected state for old GC: %s\", ShenandoahOldGeneration::state_name(old_generation->state()));\n@@ -578,1 +577,0 @@\n-\n@@ -580,1 +578,1 @@\n-  log_debug(gc)(\"Resuming old generation with \" UINT32_FORMAT \" marking tasks queued.\", generation->task_queues()->tasks());\n+  log_debug(gc)(\"Resuming old generation with \" UINT32_FORMAT \" marking tasks queued\", generation->task_queues()->tasks());\n@@ -675,2 +673,4 @@\n-void ShenandoahControlThread::service_concurrent_cycle(const ShenandoahHeap* heap, ShenandoahGeneration* generation,\n-                                                       GCCause::Cause &cause, bool do_old_gc_bootstrap) {\n+void ShenandoahControlThread::service_concurrent_cycle(const ShenandoahHeap* heap,\n+                                                       ShenandoahGeneration* generation,\n+                                                       GCCause::Cause& cause,\n+                                                       bool do_old_gc_bootstrap) {\n@@ -723,1 +723,1 @@\n-  fatal(\"Cancel GC either for alloc failure GC, or gracefully exiting, or to pause old generation marking.\");\n+  fatal(\"Cancel GC either for alloc failure GC, or gracefully exiting, or to pause old generation marking\");\n@@ -744,2 +744,3 @@\n-bool ShenandoahControlThread::service_stw_degenerated_cycle(GCCause::Cause cause, ShenandoahGC::ShenandoahDegenPoint point) {\n-  assert (point != ShenandoahGC::_degenerated_unset, \"Degenerated point should be set\");\n+bool ShenandoahControlThread::service_stw_degenerated_cycle(GCCause::Cause cause,\n+                                                            ShenandoahGC::ShenandoahDegenPoint point) {\n+  assert(point != ShenandoahGC::_degenerated_unset, \"Degenerated point should be set\");\n@@ -759,4 +760,4 @@\n-    assert(_degen_generation->generation_mode() == YOUNG, \"Expected degenerated young cycle, if not global.\");\n-    ShenandoahOldGeneration* old_generation = (ShenandoahOldGeneration*) heap->old_generation();\n-    if (old_generation->state() == ShenandoahOldGeneration::BOOTSTRAPPING && !gc.upgraded_to_full()) {\n-      old_generation->transition_to(ShenandoahOldGeneration::MARKING);\n+    assert(_degen_generation->generation_mode() == YOUNG, \"Expected degenerated young cycle, if not global\");\n+    ShenandoahOldGeneration* old = heap->old_generation();\n+    if (old->state() == ShenandoahOldGeneration::BOOTSTRAPPING && !gc.upgraded_to_full()) {\n+      old->transition_to(ShenandoahOldGeneration::MARKING);\n@@ -800,1 +801,2 @@\n-  return !is_explicit_gc(cause) && cause != GCCause::_shenandoah_concurrent_gc;\n+  return !is_explicit_gc(cause) &&\n+          (cause != GCCause::_shenandoah_concurrent_gc);\n@@ -827,1 +829,1 @@\n-    \/\/ ignore subsequent requests from the heuristics\n+    \/\/ Ignore subsequent requests from the heuristics\n@@ -841,1 +843,1 @@\n-    log_info(gc)(\"Preempting old generation mark to allow %s GC.\", generation_name(generation));\n+    log_info(gc)(\"Preempting old generation mark to allow %s GC\", generation_name(generation));\n@@ -862,1 +864,1 @@\n-  return generation == YOUNG && _allow_old_preemption.try_unset();\n+  return (generation == YOUNG) && _allow_old_preemption.try_unset();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":79,"deletions":77,"binary":false,"changes":156,"status":"modified"},{"patch":"@@ -190,1 +190,3 @@\n-  void service_concurrent_cycle(const ShenandoahHeap* heap, ShenandoahGeneration* generation, GCCause::Cause &cause,\n+  void service_concurrent_cycle(const ShenandoahHeap* heap,\n+                                ShenandoahGeneration* generation,\n+                                GCCause::Cause &cause,\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -99,1 +99,1 @@\n-      assert(!heap->is_old_gc_active(), \"Old GC should not be active during global cycle.\");\n+      assert(!heap->is_old_gc_active(), \"Old GC should not be active during global cycle\");\n@@ -104,1 +104,1 @@\n-      assert(heap->old_generation()->task_queues()->is_empty(), \"Old gen task queues should be empty.\");\n+      assert(heap->old_generation()->task_queues()->is_empty(), \"Old gen task queues should be empty\");\n@@ -135,1 +135,2 @@\n-      heap->set_unload_classes((!heap->mode()->is_generational() || _generation->generation_mode() == GLOBAL) && _generation->heuristics()->can_unload_classes());\n+      heap->set_unload_classes(_generation->heuristics()->can_unload_classes() &&\n+                                (!heap->mode()->is_generational() || _generation->generation_mode() == GLOBAL));\n@@ -137,1 +138,3 @@\n-      if (heap->mode()->is_generational() && (_generation->generation_mode() == YOUNG || (_generation->generation_mode() == GLOBAL && ShenandoahVerify))) {\n+      if (heap->mode()->is_generational() &&\n+            (_generation->generation_mode() == YOUNG ||\n+                (_generation->generation_mode() == GLOBAL && ShenandoahVerify))) {\n@@ -139,0 +142,1 @@\n+        \/\/ TODO: This path should not depend on ShenandoahVerify\n@@ -278,2 +282,2 @@\n-    \/\/ In case degeneration interrupted concurrent evacuation or update references, we need to clean up transient state.\n-    \/\/ Otherwise, these actions have no effect.\n+    \/\/ In case degeneration interrupted concurrent evacuation or update references,\n+    \/\/ we need to clean up transient state. Otherwise, these actions have no effect.\n@@ -283,1 +287,2 @@\n-    \/\/ No need to old_gen->increase_used().  That was done when plabs were allocated, accounting for both old evacs and promotions.\n+    \/\/ No need to old_gen->increase_used(). That was done when plabs were allocated,\n+    \/\/ accounting for both old evacs and promotions.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahDegeneratedGC.cpp","additions":12,"deletions":7,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-    _age_table.add(age, bytes \/ oopSize);\n+    _age_table.add(age, bytes >> LogBytesPerWord);\n@@ -71,4 +71,4 @@\n-            byte_size_in_proper_unit(_bytes_completed),\n-            proper_unit_for_byte_size(_bytes_completed), _evacuations_completed,\n-            byte_size_in_proper_unit(abandoned_size),\n-            proper_unit_for_byte_size(abandoned_size), abandoned_count);\n+            byte_size_in_proper_unit(_bytes_completed), proper_unit_for_byte_size(_bytes_completed),\n+            _evacuations_completed,\n+            byte_size_in_proper_unit(abandoned_size),   proper_unit_for_byte_size(abandoned_size),\n+            abandoned_count);\n@@ -100,0 +100,1 @@\n+        assert(r->is_old(), \"Sanity\");\n@@ -112,1 +113,1 @@\n- public:\n+public:\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahEvacTracker.cpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- private:\n+private:\n@@ -40,1 +40,1 @@\n- public:\n+public:\n@@ -56,3 +56,3 @@\n- private:\n-  ShenandoahEvacuationStats  _workers_global;\n-  ShenandoahEvacuationStats  _mutators_global;\n+private:\n+  ShenandoahEvacuationStats _workers_global;\n+  ShenandoahEvacuationStats _mutators_global;\n@@ -60,1 +60,1 @@\n- public:\n+public:\n@@ -65,1 +65,3 @@\n-  static void print_evacuations_on(outputStream* st, ShenandoahEvacuationStats* workers, ShenandoahEvacuationStats* mutators);\n+  static void print_evacuations_on(outputStream* st,\n+                                   ShenandoahEvacuationStats* workers,\n+                                   ShenandoahEvacuationStats* mutators);\n@@ -68,1 +70,0 @@\n- private:\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahEvacTracker.hpp","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -146,0 +146,2 @@\n+        fatal(\"Should request affiliation\");\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -93,1 +93,0 @@\n-          HeapWord* end_object = r->bottom() + size;\n@@ -96,1 +95,1 @@\n-          size_t num_regions = (size + ShenandoahHeapRegion::region_size_words() - 1) \/ ShenandoahHeapRegion::region_size_words();\n+          size_t num_regions = ShenandoahHeapRegion::required_regions(size * HeapWordSize);\n@@ -126,0 +125,1 @@\n+      \/\/ TODO: Assert this.\n@@ -331,0 +331,1 @@\n+    \/\/ TODO: Merge with phase5_epilog?\n@@ -422,1 +423,2 @@\n-  ShenandoahPrepareForCompactionTask(PreservedMarksSet *preserved_marks, ShenandoahHeapRegionSet **worker_slices,\n+  ShenandoahPrepareForCompactionTask(PreservedMarksSet *preserved_marks,\n+                                     ShenandoahHeapRegionSet **worker_slices,\n@@ -442,1 +444,0 @@\n-  ShenandoahPrepareForCompactionTask* _compactor;\n@@ -460,2 +461,1 @@\n-  ShenandoahPrepareForGenerationalCompactionObjectClosure(ShenandoahPrepareForCompactionTask* compactor,\n-                                                          PreservedMarks* preserved_marks,\n+  ShenandoahPrepareForGenerationalCompactionObjectClosure(PreservedMarks* preserved_marks,\n@@ -465,1 +465,0 @@\n-      _compactor(compactor),\n@@ -747,2 +746,4 @@\n-    ShenandoahPrepareForGenerationalCompactionObjectClosure cl(this, _preserved_marks->get(worker_id), empty_regions,\n-                                                               old_to_region, young_to_region, worker_id);\n+    ShenandoahPrepareForGenerationalCompactionObjectClosure cl(_preserved_marks->get(worker_id),\n+                                                               empty_regions,\n+                                                               old_to_region, young_to_region,\n+                                                               worker_id);\n@@ -856,1 +857,1 @@\n-      \/\/ Leave afffiliation unchanged.\n+      \/\/ Leave affiliation unchanged\n@@ -881,22 +882,26 @@\n-    if (r->affiliation() != FREE) {\n-      if (r->is_humongous_start()) {\n-        oop humongous_obj = cast_to_oop(r->bottom());\n-        if (!_ctx->is_marked(humongous_obj)) {\n-          assert(!r->has_live(),\n-                 \"Humongous Start %s Region \" SIZE_FORMAT \" is not marked, should not have live\",\n-                 affiliation_name(r->affiliation()),  r->index());\n-          log_debug(gc)(\"Trashing immediate humongous region \" SIZE_FORMAT \" because not marked\", r->index());\n-          _heap->trash_humongous_region_at(r);\n-        } else {\n-          assert(r->has_live(),\n-                 \"Humongous Start %s Region \" SIZE_FORMAT \" should have live\", affiliation_name(r->affiliation()),  r->index());\n-        }\n-      } else if (r->is_humongous_continuation()) {\n-        \/\/ If we hit continuation, the non-live humongous starts should have been trashed already\n-        assert(r->humongous_start_region()->has_live(),\n-               \"Humongous Continuation %s Region \" SIZE_FORMAT \" should have live\", affiliation_name(r->affiliation()),  r->index());\n-      } else if (r->is_regular()) {\n-        if (!r->has_live()) {\n-          log_debug(gc)(\"Trashing immediate regular region \" SIZE_FORMAT \" because has no live\", r->index());\n-          r->make_trash_immediate();\n-        }\n+    if (r->affiliation() == FREE) {\n+      \/\/ Ignore free regions\n+      \/\/ TODO: change iterators so they do not process FREE regions.\n+      return;\n+    }\n+\n+    if (r->is_humongous_start()) {\n+      oop humongous_obj = cast_to_oop(r->bottom());\n+      if (!_ctx->is_marked(humongous_obj)) {\n+        assert(!r->has_live(),\n+               \"Humongous Start %s Region \" SIZE_FORMAT \" is not marked, should not have live\",\n+               affiliation_name(r->affiliation()),  r->index());\n+        log_debug(gc)(\"Trashing immediate humongous region \" SIZE_FORMAT \" because not marked\", r->index());\n+        _heap->trash_humongous_region_at(r);\n+      } else {\n+        assert(r->has_live(),\n+               \"Humongous Start %s Region \" SIZE_FORMAT \" should have live\", affiliation_name(r->affiliation()),  r->index());\n+      }\n+    } else if (r->is_humongous_continuation()) {\n+      \/\/ If we hit continuation, the non-live humongous starts should have been trashed already\n+      assert(r->humongous_start_region()->has_live(),\n+             \"Humongous Continuation %s Region \" SIZE_FORMAT \" should have live\", affiliation_name(r->affiliation()),  r->index());\n+    } else if (r->is_regular()) {\n+      if (!r->has_live()) {\n+        log_debug(gc)(\"Trashing immediate regular region \" SIZE_FORMAT \" because has no live\", r->index());\n+        r->make_trash_immediate();\n@@ -905,2 +910,0 @@\n-    \/\/ else, ignore this FREE region.\n-    \/\/ TODO: change iterators so they do not process FREE regions.\n@@ -1161,1 +1164,1 @@\n-        r->oop_fill_and_coalesce_wo_cancel();\n+        r->oop_fill_and_coalesce_without_cancel();\n@@ -1289,3 +1292,9 @@\n-  ShenandoahPostCompactClosure() : _heap(ShenandoahHeap::heap()), _live(0), _is_generational(_heap->mode()->is_generational()),\n-                                   _young_regions(0), _young_usage(0), _young_humongous_waste(0),\n-                                   _old_regions(0), _old_usage(0), _old_humongous_waste(0)\n+  ShenandoahPostCompactClosure() : _heap(ShenandoahHeap::heap()),\n+                                   _live(0),\n+                                   _is_generational(_heap->mode()->is_generational()),\n+                                   _young_regions(0),\n+                                   _young_usage(0),\n+                                   _young_humongous_waste(0),\n+                                   _old_regions(0),\n+                                   _old_usage(0),\n+                                   _old_humongous_waste(0)\n@@ -1310,1 +1319,0 @@\n-\n@@ -1334,0 +1342,2 @@\n+      } else {\n+        \/\/ TODO: Assert here?\n@@ -1493,2 +1503,4 @@\n-      log_info(gc)(\"FullGC done: GLOBAL usage: \" SIZE_FORMAT \", young usage: \" SIZE_FORMAT \", old usage: \" SIZE_FORMAT,\n-                    post_compact.get_live(), heap->young_generation()->used(), heap->old_generation()->used());\n+      log_info(gc)(\"FullGC done: GLOBAL usage: \" SIZE_FORMAT \"%s, young usage: \" SIZE_FORMAT \"%s, old usage: \" SIZE_FORMAT \"%s\",\n+                   byte_size_in_proper_unit(post_compact.get_live()),          proper_unit_for_byte_size(post_compact.get_live()),\n+                   byte_size_in_proper_unit(heap->young_generation()->used()), proper_unit_for_byte_size(heap->young_generation()->used()),\n+                   byte_size_in_proper_unit(heap->old_generation()->used()),   proper_unit_for_byte_size(heap->old_generation()->used()));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":53,"deletions":41,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -170,2 +170,2 @@\n-                   byte_size_in_proper_unit(v_used), proper_unit_for_byte_size(v_used),\n-                   byte_size_in_proper_unit(v_used_regions), proper_unit_for_byte_size(v_used_regions),\n+                   byte_size_in_proper_unit(v_used),              proper_unit_for_byte_size(v_used),\n+                   byte_size_in_proper_unit(v_used_regions),      proper_unit_for_byte_size(v_used_regions),\n@@ -173,3 +173,3 @@\n-                   byte_size_in_proper_unit(v_max_capacity), proper_unit_for_byte_size(v_max_capacity),\n-                   byte_size_in_proper_unit(v_available), proper_unit_for_byte_size(v_available),\n-                   byte_size_in_proper_unit(v_adjusted_avail), proper_unit_for_byte_size(v_adjusted_avail));\n+                   byte_size_in_proper_unit(v_max_capacity),      proper_unit_for_byte_size(v_max_capacity),\n+                   byte_size_in_proper_unit(v_available),         proper_unit_for_byte_size(v_available),\n+                   byte_size_in_proper_unit(v_adjusted_avail),    proper_unit_for_byte_size(v_adjusted_avail));\n@@ -493,1 +493,1 @@\n-    \/\/ Undo the prevous loan, if any.\n+    \/\/ Undo the previous loan, if any.\n@@ -521,2 +521,0 @@\n-\n-\n@@ -764,2 +762,4 @@\n-                     byte_size_in_proper_unit(old_available), proper_unit_for_byte_size(old_available),\n-                     byte_size_in_proper_unit(old_evacuation_reserve), proper_unit_for_byte_size(old_evacuation_reserve),\n+                     byte_size_in_proper_unit(old_available),\n+                     proper_unit_for_byte_size(old_available),\n+                     byte_size_in_proper_unit(old_evacuation_reserve),\n+                     proper_unit_for_byte_size(old_evacuation_reserve),\n@@ -768,1 +768,2 @@\n-                     byte_size_in_proper_unit(regular_promotion), proper_unit_for_byte_size(regular_promotion),\n+                     byte_size_in_proper_unit(regular_promotion),\n+                     proper_unit_for_byte_size(regular_promotion),\n@@ -771,2 +772,4 @@\n-                     byte_size_in_proper_unit(allocation_supplement), proper_unit_for_byte_size(allocation_supplement),\n-                     byte_size_in_proper_unit(excess), proper_unit_for_byte_size(excess));\n+                     byte_size_in_proper_unit(allocation_supplement),\n+                     proper_unit_for_byte_size(allocation_supplement),\n+                     byte_size_in_proper_unit(excess),\n+                     proper_unit_for_byte_size(excess));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":16,"deletions":13,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -65,2 +65,4 @@\n-  void compute_evacuation_budgets(ShenandoahHeap* heap, bool* preselected_regions, ShenandoahCollectionSet* collection_set,\n-                                  size_t &consumed_by_advance_promotion);\n+  void compute_evacuation_budgets(ShenandoahHeap* heap,\n+                                  bool* preselected_regions,\n+                                  ShenandoahCollectionSet* collection_set,\n+                                  size_t& consumed_by_advance_promotion);\n@@ -69,1 +71,2 @@\n-  void adjust_evacuation_budgets(ShenandoahHeap* heap, ShenandoahCollectionSet* collection_set,\n+  void adjust_evacuation_budgets(ShenandoahHeap* heap,\n+                                 ShenandoahCollectionSet* collection_set,\n@@ -73,1 +76,4 @@\n-  ShenandoahGeneration(GenerationMode generation_mode, uint max_workers, size_t max_capacity, size_t soft_max_capacity);\n+  ShenandoahGeneration(GenerationMode generation_mode,\n+                       uint max_workers,\n+                       size_t max_capacity,\n+                       size_t soft_max_capacity);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.hpp","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-  virtual void set_concurrent_mark_in_progress(bool in_progress)  override;\n+  virtual void set_concurrent_mark_in_progress(bool in_progress) override;\n@@ -50,1 +50,1 @@\n-  bool contains(ShenandoahHeapRegion* region) const  override;\n+  bool contains(ShenandoahHeapRegion* region) const override;\n@@ -52,1 +52,4 @@\n-  bool contains(oop obj) const override { return true; }\n+  bool contains(oop obj) const override {\n+    \/\/ TODO: Should this assert is_in()?\n+    return true;\n+  }\n@@ -54,1 +57,1 @@\n-  void parallel_heap_region_iterate(ShenandoahHeapRegionClosure* cl)  override;\n+  void parallel_heap_region_iterate(ShenandoahHeapRegionClosure* cl) override;\n@@ -56,1 +59,1 @@\n-  void heap_region_iterate(ShenandoahHeapRegionClosure* cl)  override;\n+  void heap_region_iterate(ShenandoahHeapRegionClosure* cl) override;\n@@ -58,1 +61,1 @@\n-  bool is_concurrent_mark_in_progress()  override;\n+  bool is_concurrent_mark_in_progress() override;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGlobalGeneration.hpp","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -626,1 +626,0 @@\n-    extern bool _is_at_shenandoah_safepoint();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.inline.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -449,1 +449,1 @@\n-bool ShenandoahHeapRegion::oop_fill_and_coalesce_wo_cancel() {\n+bool ShenandoahHeapRegion::oop_fill_and_coalesce_without_cancel() {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -397,1 +397,1 @@\n-  bool oop_fill_and_coalesce_wo_cancel();\n+  bool oop_fill_and_coalesce_without_cancel();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}