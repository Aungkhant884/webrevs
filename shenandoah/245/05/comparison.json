{"files":[{"patch":"@@ -389,1 +389,1 @@\n-      return;\n+    return;\n@@ -392,3 +392,0 @@\n-  ShenandoahBarrierSet* ctbs = ShenandoahBarrierSet::barrier_set();\n-  CardTable* ct = ctbs->card_table();\n-\n@@ -403,1 +400,1 @@\n-    __ ldrb(rscratch2,  Address(obj, rscratch1));\n+    __ ldrb(rscratch2, Address(obj, rscratch1));\n@@ -639,3 +636,0 @@\n-  ShenandoahBarrierSet* bs = ShenandoahBarrierSet::barrier_set();\n-  CardTable* ct = bs->card_table();\n-\n@@ -645,1 +639,2 @@\n-  __ cbz(count, L_done); \/\/ zero count - nothing to do\n+  \/\/ Zero count? Nothing to do.\n+  __ cbz(count, L_done);\n@@ -647,2 +642,4 @@\n-  __ lea(end, Address(start, count, Address::lsl(LogBytesPerHeapOop))); \/\/ end = start + count << LogBytesPerHeapOop\n-  __ sub(end, end, BytesPerHeapOop); \/\/ last element address to make inclusive\n+  \/\/ end = start + count << LogBytesPerHeapOop\n+  \/\/ last element address to make inclusive\n+  __ lea(end, Address(start, count, Address::lsl(LogBytesPerHeapOop)));\n+  __ sub(end, end, BytesPerHeapOop);\n@@ -651,1 +648,3 @@\n-  __ sub(count, end, start); \/\/ number of bytes to copy\n+\n+  \/\/ number of bytes to copy\n+  __ sub(count, end, start);\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shenandoah\/shenandoahBarrierSetAssembler_aarch64.cpp","additions":11,"deletions":12,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -65,1 +65,3 @@\n-  void gen_write_ref_array_post_barrier(MacroAssembler* masm, DecoratorSet decorators, Register start, Register count, Register scratch, RegSet saved_regs);\n+  void gen_write_ref_array_post_barrier(MacroAssembler* masm, DecoratorSet decorators,\n+                                        Register start, Register count,\n+                                        Register scratch, RegSet saved_regs);\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shenandoah\/shenandoahBarrierSetAssembler_aarch64.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -602,1 +602,1 @@\n-      return;\n+    return;\n@@ -807,1 +807,1 @@\n-  Label Lskip_loop, Lstore_loop;\n+  Label L_skip_loop, L_store_loop;\n@@ -810,1 +810,4 @@\n-  __ beq(CCR0, Lskip_loop); \/\/ zero length\n+\n+  \/\/ Zero length? Skip.\n+  __ beq(CCR0, L_skip_loop);\n+\n@@ -821,0 +824,1 @@\n+\n@@ -822,1 +826,1 @@\n-  __ bind(Lstore_loop);\n+  __ bind(L_store_loop);\n@@ -825,2 +829,2 @@\n-  __ bdnz(Lstore_loop);\n-  __ bind(Lskip_loop);\n+  __ bdnz(L_store_loop);\n+  __ bind(L_skip_loop);\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shenandoah\/shenandoahBarrierSetAssembler_ppc.cpp","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -97,1 +97,1 @@\n-  LIR_Opr result =  BarrierSetC1::atomic_cmpxchg_at_resolved(access, cmp_value, new_value);\n+  LIR_Opr result = BarrierSetC1::atomic_cmpxchg_at_resolved(access, cmp_value, new_value);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shenandoah\/c1\/shenandoahBarrierSetC1_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -130,3 +130,2 @@\n-      \/\/ We need to squirrel away the original element count because the\n-      \/\/ array copy assembly will destroy the value and we need it for the\n-      \/\/ card marking barrier.\n+      \/\/ We need to save the original element count because the array copy stub\n+      \/\/ will destroy the value and we need it for the card marking barrier.\n@@ -144,1 +143,1 @@\n-if (disjoint) {\n+      if (disjoint) {\n@@ -169,1 +168,1 @@\n-      Label done;\n+      Label L_done;\n@@ -172,1 +171,1 @@\n-      __ jcc(Assembler::zero, done);\n+      __ jcc(Assembler::zero, L_done);\n@@ -183,1 +182,1 @@\n-      __ jcc(Assembler::zero, done);\n+      __ jcc(Assembler::zero, L_done);\n@@ -203,1 +202,1 @@\n-      __ bind(done);\n+      __ bind(L_done);\n@@ -217,1 +216,1 @@\n-if (is_reference_type(type)) {\n+  if (is_reference_type(type)) {\n@@ -666,2 +665,2 @@\n-  \/\/ never need to be relocated. On 64bit however the value may be too\n-  \/\/ large for a 32bit displacement.\n+  \/\/ never need to be relocated. On 64-bit however the value may be too\n+  \/\/ large for a 32-bit displacement.\n@@ -685,1 +684,1 @@\n-    __ jcc(Assembler::equal, L_already_dirty);\n+    __ jccb(Assembler::equal, L_already_dirty);\n@@ -734,1 +733,1 @@\n-      \/\/ XXX: store_check missing from upstream\n+      \/\/ TODO: store_check missing in upstream\n@@ -942,1 +941,3 @@\n-void ShenandoahBarrierSetAssembler::gen_write_ref_array_post_barrier(MacroAssembler* masm, DecoratorSet decorators, Register addr, Register count, Register tmp) {\n+void ShenandoahBarrierSetAssembler::gen_write_ref_array_post_barrier(MacroAssembler* masm, DecoratorSet decorators,\n+                                                                     Register addr, Register count,\n+                                                                     Register tmp) {\n@@ -955,0 +956,1 @@\n+  \/\/ Zero count? Nothing to do.\n@@ -956,2 +958,1 @@\n-  __ jcc(Assembler::zero, L_done); \/\/ zero count - nothing to do\n-\n+  __ jccb(Assembler::zero, L_done);\n@@ -968,1 +969,2 @@\n-__ BIND(L_loop);\n+\n+  __ BIND(L_loop);\n@@ -971,1 +973,1 @@\n-  __ jcc(Assembler::greaterEqual, L_loop);\n+  __ jccb(Assembler::greaterEqual, L_loop);\n@@ -973,1 +975,1 @@\n-  __ lea(end,  Address(addr, count, Address::times_ptr, -wordSize));\n+  __ lea(end, Address(addr, count, Address::times_ptr, -wordSize));\n@@ -975,1 +977,1 @@\n-  __ shrptr(end,   CardTable::card_shift());\n+  __ shrptr(end,  CardTable::card_shift());\n@@ -977,1 +979,2 @@\n-__ BIND(L_loop);\n+\n+  __ BIND(L_loop);\n@@ -981,1 +984,1 @@\n-  __ jcc(Assembler::greaterEqual, L_loop);\n+  __ jccb(Assembler::greaterEqual, L_loop);\n@@ -984,1 +987,1 @@\n-__ BIND(L_done);\n+  __ BIND(L_done);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shenandoah\/shenandoahBarrierSetAssembler_x86.cpp","additions":26,"deletions":23,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -64,1 +64,3 @@\n-  void gen_write_ref_array_post_barrier(MacroAssembler* masm, DecoratorSet decorators, Register addr, Register count, Register tmp);\n+  void gen_write_ref_array_post_barrier(MacroAssembler* masm, DecoratorSet decorators,\n+                                        Register addr, Register count,\n+                                        Register tmp);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shenandoah\/shenandoahBarrierSetAssembler_x86.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -479,6 +479,1 @@\n-  ShenandoahBarrierSet* ctbs = barrier_set_cast<ShenandoahBarrierSet>(BarrierSet::barrier_set());\n-  CardTable* ct = ctbs->card_table();\n-  \/\/ No store check needed if we're storing a nullptr or an old object\n-  \/\/ (latter case is probably a string constant). The concurrent\n-  \/\/ mark sweep garbage collector, however, needs to have all nonNull\n-  \/\/ oop updates flagged via card-marks.\n+  \/\/ No store check needed if we're storing a null.\n@@ -489,1 +484,0 @@\n-      \/\/ stores of null never (?) need barriers\n@@ -616,1 +610,2 @@\n-    post_barrier(kit, kit->control(), access.raw_access(), access.base(), adr, adr_idx, val.node(), access.type(), use_precise);\n+    post_barrier(kit, kit->control(), access.raw_access(), access.base(),\n+                 adr, adr_idx, val.node(), access.type(), use_precise);\n@@ -742,1 +737,2 @@\n-    post_barrier(kit, kit->control(), access.raw_access(), access.base(), access.addr().node(), access.alias_idx(), new_val, T_OBJECT, true);\n+    post_barrier(kit, kit->control(), access.raw_access(), access.base(),\n+                 access.addr().node(), access.alias_idx(), new_val, T_OBJECT, true);\n@@ -905,1 +901,1 @@\n-    }\n+        }\n@@ -1021,15 +1017,14 @@\n-    assert(node->Opcode() == Op_CastP2X, \"ConvP2XNode required\");\n-     Node *shift = node->unique_out();\n-     Node *addp = shift->unique_out();\n-     for (DUIterator_Last jmin, j = addp->last_outs(jmin); j >= jmin; --j) {\n-       Node *mem = addp->last_out(j);\n-       if (UseCondCardMark && mem->is_Load()) {\n-         assert(mem->Opcode() == Op_LoadB, \"unexpected code shape\");\n-         \/\/ The load is checking if the card has been written so\n-         \/\/ replace it with zero to fold the test.\n-         macro->replace_node(mem, macro->intcon(0));\n-         continue;\n-       }\n-       assert(mem->is_Store(), \"store required\");\n-       macro->replace_node(mem, mem->in(MemNode::Memory));\n-     }\n+    Node* shift = node->unique_out();\n+    Node* addp = shift->unique_out();\n+    for (DUIterator_Last jmin, j = addp->last_outs(jmin); j >= jmin; --j) {\n+      Node* mem = addp->last_out(j);\n+      if (UseCondCardMark && mem->is_Load()) {\n+        assert(mem->Opcode() == Op_LoadB, \"unexpected code shape\");\n+        \/\/ The load is checking if the card has been written so\n+        \/\/ replace it with zero to fold the test.\n+        macro->replace_node(mem, macro->intcon(0));\n+        continue;\n+      }\n+      assert(mem->is_Store(), \"store required\");\n+      macro->replace_node(mem, mem->in(MemNode::Memory));\n+    }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahBarrierSetC2.cpp","additions":20,"deletions":25,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+\/\/ TODO: Provide comment here or remove if not used\n@@ -98,0 +99,1 @@\n+  \/\/ TODO: Split it in the separate methods for clarity.\n@@ -264,1 +266,2 @@\n-                        byte_size_in_proper_unit(available), proper_unit_for_byte_size(available), z_score,\n+                        byte_size_in_proper_unit(available),     proper_unit_for_byte_size(available),\n+                        z_score,\n@@ -266,1 +269,1 @@\n-                        byte_size_in_proper_unit(available_sd), proper_unit_for_byte_size(available_sd));\n+                        byte_size_in_proper_unit(available_sd),  proper_unit_for_byte_size(available_sd));\n@@ -339,1 +342,1 @@\n-                  byte_size_in_proper_unit(usable), proper_unit_for_byte_size(usable),\n+                  byte_size_in_proper_unit(usable),    proper_unit_for_byte_size(usable),\n@@ -353,2 +356,2 @@\n-                 byte_size_in_proper_unit(available), proper_unit_for_byte_size(available),\n-                 byte_size_in_proper_unit(min_threshold),       proper_unit_for_byte_size(min_threshold));\n+                 byte_size_in_proper_unit(available),     proper_unit_for_byte_size(available),\n+                 byte_size_in_proper_unit(min_threshold), proper_unit_for_byte_size(min_threshold));\n@@ -365,2 +368,2 @@\n-                   byte_size_in_proper_unit(available), proper_unit_for_byte_size(available),\n-                   byte_size_in_proper_unit(init_threshold),      proper_unit_for_byte_size(init_threshold));\n+                   byte_size_in_proper_unit(available),       proper_unit_for_byte_size(available),\n+                   byte_size_in_proper_unit(init_threshold),  proper_unit_for_byte_size(init_threshold));\n@@ -424,1 +427,2 @@\n-    _generation->name(), avg_cycle_time * 1000, byte_size_in_proper_unit(avg_alloc_rate), proper_unit_for_byte_size(avg_alloc_rate));\n+          _generation->name(), avg_cycle_time * 1000,\n+          byte_size_in_proper_unit(avg_alloc_rate), proper_unit_for_byte_size(avg_alloc_rate));\n@@ -427,1 +431,0 @@\n-\n@@ -430,1 +433,1 @@\n-                 byte_size_in_proper_unit(avg_alloc_rate), proper_unit_for_byte_size(avg_alloc_rate),\n+                 byte_size_in_proper_unit(avg_alloc_rate),      proper_unit_for_byte_size(avg_alloc_rate),\n@@ -450,1 +453,0 @@\n-\n@@ -467,2 +469,2 @@\n-    log_info(gc, ergo)(\"Not resizing %s for another \" UINT32_FORMAT \" cycles.\",\n-        _generation->name(),  _cycles_since_last_resize);\n+    log_info(gc, ergo)(\"Not resizing %s for another \" UINT32_FORMAT \" cycles\",\n+            _generation->name(), _cycles_since_last_resize);\n@@ -474,1 +476,1 @@\n-    log_info(gc, ergo)(\"Could not increase size of %s, begin gc cycle.\", _generation->name());\n+    log_info(gc, ergo)(\"Could not increase size of %s, begin gc cycle\", _generation->name());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.cpp","additions":16,"deletions":14,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -35,1 +35,6 @@\n-ShenandoahAggressiveHeuristics::ShenandoahAggressiveHeuristics(ShenandoahGeneration* generation) : ShenandoahHeuristics(generation) {\n+ShenandoahAggressiveHeuristics::ShenandoahAggressiveHeuristics(ShenandoahGeneration* generation) :\n+  ShenandoahHeuristics(generation) {\n+\n+  assert(!ShenandoahHeap::heap()->mode()->is_generational(),\n+         \"Aggressive heuristics is not available in generational mode\");\n+\n@@ -52,4 +57,2 @@\n-  assert(!ShenandoahHeap::heap()->mode()->is_generational(), \"AggressiveHeuristics not appropriate in generational mode\");\n-\n-  \/\/ Note that there's no bound on collection set size.  If we try to collect too much memory, we'll get an alloc\n-  \/\/ failure during collection and we'll degenerate.\n+  \/\/ Note that there is no bound on collection set size. If we try to collect too much memory,\n+  \/\/ we'll get an allocation failure during collection and slide to degenerated GC.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAggressiveHeuristics.cpp","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -51,2 +51,2 @@\n-  size_t capacity = _generation->soft_max_capacity();\n-  size_t available = _generation->available();\n+  size_t capacity     = _generation->soft_max_capacity();\n+  size_t available    = _generation->available();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahCompactHeuristics.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-size_t ShenandoahHeuristics::select_aged_regions(size_t old_available, size_t num_regions, bool preselected_regions[]) {\n+size_t ShenandoahHeuristics::select_aged_regions(size_t old_available, size_t num_regions, bool* preselected_regions) {\n@@ -81,0 +81,5 @@\n+  if (!heap->mode()->is_generational()) {\n+    \/\/ TODO: Do we need this check, or assert is enough?\n+    return 0;\n+  }\n+\n@@ -82,11 +87,7 @@\n-  if (heap->mode()->is_generational()) {\n-    for (size_t i = 0; i < num_regions; i++) {\n-      ShenandoahHeapRegion* region = heap->get_region(i);\n-      if (in_generation(region) && !region->is_empty() && region->is_regular() && (region->age() >= InitialTenuringThreshold)) {\n-        size_t promotion_need = (size_t) (region->get_live_data_bytes() * ShenandoahEvacWaste);\n-        if (old_consumed + promotion_need < old_available) {\n-          old_consumed += promotion_need;\n-          preselected_regions[i] = true;\n-        }\n-        \/\/ Note that we keep going even if one region is excluded from selection.  Subsequent regions may be selected\n-        \/\/ if they have smaller live data.\n+  for (size_t i = 0; i < num_regions; i++) {\n+    ShenandoahHeapRegion* region = heap->get_region(i);\n+    if (in_generation(region) && !region->is_empty() && region->is_regular() && (region->age() >= InitialTenuringThreshold)) {\n+      size_t promotion_need = (size_t) (region->get_live_data_bytes() * ShenandoahEvacWaste);\n+      if (old_consumed + promotion_need < old_available) {\n+        old_consumed += promotion_need;\n+        preselected_regions[i] = true;\n@@ -94,0 +95,2 @@\n+      \/\/ Note that we keep going even if one region is excluded from selection.\n+      \/\/ Subsequent regions may be selected if they have smaller live data.\n@@ -104,1 +107,1 @@\n-  assert(!_generation->is_old(), \"Old GC invokes ShenandoahOldHeuristics::choose_collection_set()\");\n+  assert(!is_generational || !_generation->is_old(), \"Old GC invokes ShenandoahOldHeuristics::choose_collection_set()\");\n@@ -124,1 +127,0 @@\n-  size_t live_memory = 0;\n@@ -145,1 +147,0 @@\n-        live_memory += region->get_live_data_bytes();\n@@ -171,2 +172,0 @@\n-      } else {\n-        live_memory += region->get_live_data_bytes();\n@@ -178,2 +177,0 @@\n-    } else {                      \/\/ region->is_humongous_cont() and !region->is_trash()\n-      live_memory += region->get_live_data_bytes();\n@@ -197,0 +194,2 @@\n+    } else {\n+      \/\/ This is a global collection and does not need to prime cset\n@@ -198,1 +197,0 @@\n-    \/\/ else, this is global collection and doesn't need to prime_collection_set\n@@ -200,2 +198,1 @@\n-    \/\/ Add young-gen regions into the collection set.  This is a virtual call, implemented differently by each\n-    \/\/ of the heuristics subclasses.\n+    \/\/ Call the subclasses to add young-gen regions into the collection set.\n@@ -204,1 +201,2 @@\n-    \/\/ we're going to skip evacuation and update refs because we reclaimed sufficient amounts of immediate garbage.\n+    \/\/ We are going to skip evacuation and update refs because we reclaimed\n+    \/\/ sufficient amounts of immediate garbage.\n@@ -217,2 +215,2 @@\n-                     \"Immediate: \" SIZE_FORMAT \"%s (\" SIZE_FORMAT \"%%) R: \" SIZE_FORMAT \", \"\n-                     \"CSet: \" SIZE_FORMAT \"%s (\" SIZE_FORMAT \"%%) R: \" SIZE_FORMAT,\n+                     \"Immediate: \" SIZE_FORMAT \"%s (\" SIZE_FORMAT \"%%), \" SIZE_FORMAT \" regions, \"\n+                     \"CSet: \" SIZE_FORMAT \"%s (\" SIZE_FORMAT \"%%), \" SIZE_FORMAT \" regions\",\n@@ -235,1 +233,1 @@\n-    size_t young_evac_bytes = collection_set->get_young_bytes_reserved_for_evacuation();\n+    size_t young_evac_bytes   = collection_set->get_young_bytes_reserved_for_evacuation();\n@@ -237,2 +235,2 @@\n-    size_t old_evac_bytes = collection_set->get_old_bytes_reserved_for_evacuation();\n-    size_t total_evac_bytes = young_evac_bytes + promote_evac_bytes + old_evac_bytes;\n+    size_t old_evac_bytes     = collection_set->get_old_bytes_reserved_for_evacuation();\n+    size_t total_evac_bytes   = young_evac_bytes + promote_evac_bytes + old_evac_bytes;\n@@ -243,1 +241,1 @@\n-                       byte_size_in_proper_unit(young_evac_bytes), proper_unit_for_byte_size(young_evac_bytes),\n+                       byte_size_in_proper_unit(young_evac_bytes),   proper_unit_for_byte_size(young_evac_bytes),\n@@ -245,2 +243,2 @@\n-                       byte_size_in_proper_unit(old_evac_bytes), proper_unit_for_byte_size(old_evac_bytes),\n-                       byte_size_in_proper_unit(total_evac_bytes), proper_unit_for_byte_size(total_evac_bytes));\n+                       byte_size_in_proper_unit(old_evac_bytes),     proper_unit_for_byte_size(old_evac_bytes),\n+                       byte_size_in_proper_unit(total_evac_bytes),   proper_unit_for_byte_size(total_evac_bytes));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.cpp","additions":29,"deletions":31,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -78,6 +78,5 @@\n-  \/\/ if (_generation->type() == GLOBAL) _region_data represents\n-  \/\/  the results of most recently completed global marking pass\n-  \/\/ if (_generation->type() == OLD) _region_data represents\n-  \/\/  the results of most recently completed old-gen marking pass\n-  \/\/ if (_generation->type() == YOUNG) _region_data represents\n-  \/\/  the results of most recently completed young-gen marking pass\n+  \/\/ Depending on generation mode, region data represents the results of the relevant\n+  \/\/ most recently completed marking pass:\n+  \/\/   - in GLOBAL mode, global marking pass\n+  \/\/   - in OLD mode,    old-gen marking pass\n+  \/\/   - in YOUNG mode,  young-gen marking pass\n@@ -85,3 +84,3 @@\n-  \/\/ Note that there is some redundancy represented in _region_data because\n-  \/\/ each instance is an array large enough to hold all regions.  However,\n-  \/\/ any region in young-gen is not in old-gen.  And any time we are\n+  \/\/ Note that there is some redundancy represented in region data because\n+  \/\/ each instance is an array large enough to hold all regions. However,\n+  \/\/ any region in young-gen is not in old-gen. And any time we are\n@@ -89,1 +88,1 @@\n-  \/\/ YOUNG or OLD data.  Consider this redundancy of data structure to\n+  \/\/ YOUNG or OLD data. Consider this redundancy of data structure to\n@@ -160,1 +159,1 @@\n-  virtual size_t select_aged_regions(size_t old_available, size_t num_regions, bool preselected_regions[]);\n+  virtual size_t select_aged_regions(size_t old_available, size_t num_regions, bool* preselected_regions);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.hpp","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -86,3 +86,4 @@\n-    \/\/ It's probably overkill to compensate with lost_evacuation_capacity.  But it's the safe thing to do and\n-    \/\/  has minimal impact on content of primed collection set.\n-    if (r->get_live_data_bytes() + lost_evacuation_capacity <= remaining_old_evacuation_budget) {\n+    \/\/ It's probably overkill to compensate with lost_evacuation_capacity.\n+    \/\/ But it's the safe thing to do and has minimal impact on content of primed collection set.\n+    size_t live = r->get_live_data_bytes();\n+    if (live + lost_evacuation_capacity <= remaining_old_evacuation_budget) {\n@@ -91,1 +92,1 @@\n-      remaining_old_evacuation_budget -= r->get_live_data_bytes();\n+      remaining_old_evacuation_budget -= live;\n@@ -94,1 +95,1 @@\n-      evacuated_old_bytes += r->get_live_data_bytes();\n+      evacuated_old_bytes += live;\n@@ -124,1 +125,1 @@\n-      log_info(gc)(\"All candidate regions \" UINT32_FORMAT \" are pinned.\", unprocessed_old_collection_candidates());\n+      log_info(gc)(\"All candidate regions \" UINT32_FORMAT \" are pinned\", unprocessed_old_collection_candidates());\n@@ -140,1 +141,1 @@\n-    auto region = _region_data[i]._region;\n+    ShenandoahHeapRegion* region = _region_data[i]._region;\n@@ -188,1 +189,1 @@\n-  for (int32_t search = write_index - 1; search >= (int32_t)_first_pinned_candidate; --search) {\n+  for (int32_t search = (int32_t)write_index - 1; search >= (int32_t)_first_pinned_candidate; --search) {\n@@ -207,2 +208,2 @@\n-  assert((collection_set == nullptr) && (old_heuristics == nullptr),\n-         \"Expect null arguments in ShenandoahOldHeuristics::choose_collection_set()\");\n+  assert(collection_set == nullptr, \"Expect null\");\n+  assert(old_heuristics == nullptr, \"Expect null\");\n@@ -298,1 +299,1 @@\n-               byte_size_in_proper_unit(immediate_garbage), proper_unit_for_byte_size(immediate_garbage), immediate_regions);\n+               byte_size_in_proper_unit(immediate_garbage),   proper_unit_for_byte_size(immediate_garbage),   immediate_regions);\n@@ -307,0 +308,1 @@\n+\/\/ TODO: Unused?\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.cpp","additions":13,"deletions":11,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-  size_t available = MAX2((max_capacity \/ 100) * ShenandoahEvacReserve, actual_free);\n+  size_t available = MAX2(max_capacity \/ 100 * ShenandoahEvacReserve, actual_free);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahPassiveHeuristics.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,2 +46,2 @@\n-  size_t capacity = _generation->soft_max_capacity();\n-  size_t available = _generation->available();\n+  size_t capacity     = _generation->soft_max_capacity();\n+  size_t available    = _generation->available();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahStaticHeuristics.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -66,0 +66,1 @@\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/mode\/shenandoahGenerationalMode.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -432,1 +432,2 @@\n-\/\/ unlike assert_heaplocked_or_safepoint(), this does not require current thread in safepoint to be a VM-thread\n+\/\/ Unlike assert_heaplocked_or_safepoint(), this does not require current thread in safepoint to be a VM thread\n+\/\/ TODO: This should be more aptly named. Nothing in this method checks we are actually in Full GC.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAsserts.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -136,0 +136,1 @@\n+    \/\/ TODO: Assert this in retire_plab?\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -52,1 +52,3 @@\n-  inline ShenandoahCardTable* card_table()  { return _card_table; }\n+  inline ShenandoahCardTable* card_table() {\n+    return _card_table;\n+  }\n@@ -120,1 +122,1 @@\n-  void write_ref_field_post(T* field, oop newVal);\n+  void write_ref_field_post(T* field);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -189,1 +189,1 @@\n-inline void ShenandoahBarrierSet::write_ref_field_post(T* field, oop newVal) {\n+inline void ShenandoahBarrierSet::write_ref_field_post(T* field) {\n@@ -259,1 +259,3 @@\n-  shenandoah_assert_marked_if(nullptr, value, !CompressedOops::is_null(value) && ShenandoahHeap::heap()->is_evacuation_in_progress() &&\n+  shenandoah_assert_marked_if(nullptr, value,\n+                              !CompressedOops::is_null(value) &&\n+                              ShenandoahHeap::heap()->is_evacuation_in_progress() &&\n@@ -281,1 +283,2 @@\n-  ShenandoahBarrierSet::barrier_set()->write_ref_field_post<decorators>(addr, value);\n+  ShenandoahBarrierSet* bs = ShenandoahBarrierSet::barrier_set();\n+  bs->write_ref_field_post<decorators>(addr);\n@@ -303,1 +306,1 @@\n-  bs->write_ref_field_post<decorators>(addr, new_value);\n+  bs->write_ref_field_post<decorators>(addr);\n@@ -314,1 +317,1 @@\n-  bs->write_ref_field_post<decorators>(addr, new_value);\n+  bs->write_ref_field_post<decorators>(addr);\n@@ -332,1 +335,1 @@\n-  bs->write_ref_field_post<decorators>(addr, new_value);\n+  bs->write_ref_field_post<decorators>(addr);\n@@ -343,1 +346,1 @@\n-  bs->write_ref_field_post<decorators>(addr, new_value);\n+  bs->write_ref_field_post<decorators>(addr);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.inline.hpp","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -37,1 +37,2 @@\n-      _dirty_card_cnt, _max_dirty_run, _clean_card_cnt, _max_clean_run,\n+      _dirty_card_cnt, _max_dirty_run,\n+      _clean_card_cnt, _max_clean_run,\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCardStats.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -32,9 +32,9 @@\n-  DIRTY_RUN = 0,\n-  CLEAN_RUN = 1,\n-  DIRTY_CARDS = 2,\n-  CLEAN_CARDS = 3,\n-  MAX_DIRTY_RUN = 4,\n-  MAX_CLEAN_RUN = 5,\n-  DIRTY_SCAN_OBJS = 6,\n-  ALTERNATIONS = 7,\n-  MAX_CARD_STAT_TYPE = 8\n+  DIRTY_RUN           = 0,\n+  CLEAN_RUN           = 1,\n+  DIRTY_CARDS         = 2,\n+  CLEAN_CARDS         = 3,\n+  MAX_DIRTY_RUN       = 4,\n+  MAX_CLEAN_RUN       = 5,\n+  DIRTY_SCAN_OBJS     = 6,\n+  ALTERNATIONS        = 7,\n+  MAX_CARD_STAT_TYPE  = 8\n@@ -44,3 +44,3 @@\n-  CARD_STAT_SCAN_RS = 0,\n-  CARD_STAT_UPDATE_REFS = 1,\n-  MAX_CARD_STAT_LOG_TYPE = 2\n+  CARD_STAT_SCAN_RS       = 0,\n+  CARD_STAT_UPDATE_REFS   = 1,\n+  MAX_CARD_STAT_LOG_TYPE  = 2\n@@ -57,3 +57,0 @@\n-  size_t _dirty_run;\n-  size_t _clean_run;\n-\n@@ -86,2 +83,2 @@\n-      _local_card_stats[DIRTY_CARDS].add((double)_dirty_card_cnt*100\/(double)_cards_in_cluster);\n-      _local_card_stats[CLEAN_CARDS].add((double)_clean_card_cnt*100\/(double)_cards_in_cluster);\n+      _local_card_stats[DIRTY_CARDS].add(percent_of(_dirty_card_cnt, _cards_in_cluster));\n+      _local_card_stats[CLEAN_CARDS].add(percent_of(_clean_card_cnt, _cards_in_cluster));\n@@ -90,2 +87,2 @@\n-      _local_card_stats[MAX_DIRTY_RUN].add((double)_max_dirty_run*100\/(double)_cards_in_cluster);\n-      _local_card_stats[MAX_CLEAN_RUN].add((double)_max_clean_run*100\/(double)_cards_in_cluster);\n+      _local_card_stats[MAX_DIRTY_RUN].add(percent_of(_max_dirty_run, _cards_in_cluster));\n+      _local_card_stats[MAX_CLEAN_RUN].add(percent_of(_max_clean_run, _cards_in_cluster));\n@@ -110,1 +107,1 @@\n-      _local_card_stats[DIRTY_RUN].add((double)len*100.0\/(double)_cards_in_cluster);\n+      _local_card_stats[DIRTY_RUN].add(percent_of(len, _cards_in_cluster));\n@@ -122,1 +119,1 @@\n-      _local_card_stats[CLEAN_RUN].add((double)len*100.0\/(double)_cards_in_cluster);\n+      _local_card_stats[CLEAN_RUN].add(percent_of(len, _cards_in_cluster));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCardStats.hpp","additions":18,"deletions":21,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -34,0 +34,3 @@\n+\n+  \/\/ TODO: Why rs_align is 0 on page_size == os::vm_page_size?\n+  \/\/ ReservedSpace constructor would assert rs_align >= os::vm_page_size().\n@@ -47,1 +50,1 @@\n-  log_trace(gc, barrier)(\"ShenandoahCardTable::ShenandoahCardTable: \");\n+  log_trace(gc, barrier)(\"ShenandoahCardTable::ShenandoahCardTable:\");\n@@ -71,0 +74,1 @@\n+\/\/ TODO: Seems to be unused\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCardTable.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -94,0 +94,3 @@\n+  size_t live = r->get_live_data_bytes();\n+  size_t garbage = r->garbage();\n+\n@@ -96,1 +99,1 @@\n-    _young_bytes_to_evacuate += r->get_live_data_bytes();\n+    _young_bytes_to_evacuate += live;\n@@ -98,1 +101,1 @@\n-      _young_bytes_to_promote += r->get_live_data_bytes();\n+      _young_bytes_to_promote += live;\n@@ -102,2 +105,2 @@\n-    _old_bytes_to_evacuate += r->get_live_data_bytes();\n-    _old_garbage += r->garbage();\n+    _old_bytes_to_evacuate += live;\n+    _old_garbage += garbage;\n@@ -108,1 +111,1 @@\n-  _garbage += r->garbage();\n+  _garbage += garbage;\n@@ -110,1 +113,1 @@\n-  _live += r->get_live_data_bytes();\n+  _live += live;\n@@ -187,2 +190,2 @@\n-                byte_size_in_proper_unit(live()), proper_unit_for_byte_size(live()),\n-                byte_size_in_proper_unit(used()), proper_unit_for_byte_size(used()));\n+                byte_size_in_proper_unit(live()),    proper_unit_for_byte_size(live()),\n+                byte_size_in_proper_unit(used()),    proper_unit_for_byte_size(used()));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCollectionSet.cpp","additions":11,"deletions":8,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -61,1 +61,2 @@\n-  size_t                _old_garbage;        \/\/ How many bytes of old garbage are present in a mixed collection set?\n+  \/\/ How many bytes of old garbage are present in a mixed collection set?\n+  size_t                _old_garbage;\n@@ -63,3 +64,4 @@\n-  bool*                 _preselected_regions;   \/\/ Points to array identifying which tenure-age regions have been preselected\n-                                                \/\/ for inclusion in collection set.  This field is only valid during brief\n-                                                \/\/ spans of time while collection set is being constructed.\n+  \/\/ Points to array identifying which tenure-age regions have been preselected\n+  \/\/ for inclusion in collection set. This field is only valid during brief\n+  \/\/ spans of time while collection set is being constructed.\n+  bool*                 _preselected_regions;\n@@ -103,0 +105,1 @@\n+  \/\/ TODO: Seems unused.\n@@ -107,1 +110,0 @@\n-\n@@ -113,1 +115,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCollectionSet.hpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -119,1 +119,1 @@\n-    \/\/ Reset task queue stats here, rather than in mark_concurrent_roots\n+    \/\/ Reset task queue stats here, rather than in mark_concurrent_roots,\n@@ -126,2 +126,1 @@\n-    \/\/ When RS scanning yields, we will need a check_cancellation_and_abort()\n-    \/\/ degeneration point here.\n+    \/\/ TODO: When RS scanning yields, we will need a check_cancellation_and_abort() degeneration point here.\n@@ -222,1 +221,0 @@\n-    size_t old_available, young_available;\n@@ -238,3 +236,0 @@\n-      young_available = young_gen->adjusted_available();\n-      old_available = old_gen->adjusted_available();\n-\n@@ -625,1 +620,1 @@\n-      if (_generation->is_young() || (_generation->is_global() && ShenandoahVerify)) {\n+    if (_generation->is_young() || (_generation->is_global() && ShenandoahVerify)) {\n@@ -629,2 +624,3 @@\n-        ShenandoahGCPhase phase(ShenandoahPhaseTimings::init_swap_rset);\n-        _generation->swap_remembered_set();\n+      \/\/ TODO: This path should not really depend on ShenandoahVerify.\n+      ShenandoahGCPhase phase(ShenandoahPhaseTimings::init_swap_rset);\n+      _generation->swap_remembered_set();\n@@ -779,1 +775,2 @@\n-        size_t young_available = heap->young_generation()->adjust_available(heap->get_alloc_supplement_reserve());\n+        intptr_t adjustment = heap->get_alloc_supplement_reserve();\n+        size_t young_available = heap->young_generation()->adjust_available(adjustment);\n@@ -782,1 +779,1 @@\n-        size_t old_available = heap->old_generation()->adjust_available(-heap->get_alloc_supplement_reserve());\n+        size_t old_available = heap->old_generation()->adjust_available(-adjustment);\n@@ -786,1 +783,1 @@\n-                           byte_size_in_proper_unit(old_available), proper_unit_for_byte_size(old_available),\n+                           byte_size_in_proper_unit(old_available),   proper_unit_for_byte_size(old_available),\n@@ -1245,1 +1242,1 @@\n-         \"Should not have forwarded objects during final mark (unless old gen concurrent mark is running)\");\n+         \"Should not have forwarded objects during final mark, unless old gen concurrent mark is running\");\n@@ -1256,1 +1253,1 @@\n-         \"Should not have forwarded objects concurrent mark (unless old gen concurrent mark is running\");\n+         \"Should not have forwarded objects concurrent mark, unless old gen concurrent mark is running\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":12,"deletions":15,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -100,1 +100,0 @@\n-  virtual void op_final_mark();\n@@ -128,0 +127,2 @@\n+protected:\n+  virtual void op_final_mark();\n@@ -129,0 +130,1 @@\n+private:\n@@ -131,2 +133,1 @@\n-  \/\/ Messages for GC trace events, they have to be immortal for\n-  \/\/ passing around the logging\/tracing systems\n+  \/\/ Messages for GC trace events\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -121,1 +121,1 @@\n-      ShenandoahObjToScanQueue* old = _cm->get_old_queue(worker_id);\n+      ShenandoahObjToScanQueue* old_q = _cm->get_old_queue(worker_id);\n@@ -123,1 +123,1 @@\n-      ShenandoahSATBBufferClosure<GENERATION> cl(q, old);\n+      ShenandoahSATBBufferClosure<GENERATION> cl(q, old_q);\n@@ -128,1 +128,1 @@\n-      ShenandoahMarkRefsClosure<GENERATION> mark_cl(q, rp, old);\n+      ShenandoahMarkRefsClosure<GENERATION> mark_cl(q, rp, old_q);\n@@ -181,2 +181,3 @@\n-  ShenandoahObjToScanQueue* old = _old_queue_set == nullptr ? nullptr : _old_queue_set->queue(worker_id);\n-  ShenandoahMarkRefsClosure<GENERATION> cl(q, _rp, old);\n+  ShenandoahObjToScanQueue* old_q = (_old_queue_set == nullptr) ?\n+          nullptr : _old_queue_set->queue(worker_id);\n+  ShenandoahMarkRefsClosure<GENERATION> cl(q, _rp, old_q);\n@@ -195,1 +196,2 @@\n-      ShenandoahMarkConcurrentRootsTask<YOUNG> task(task_queues(), old_task_queues(), rp, ShenandoahPhaseTimings::conc_mark_roots, workers->active_workers());\n+      ShenandoahMarkConcurrentRootsTask<YOUNG> task(task_queues(), old_task_queues(), rp,\n+                                                    ShenandoahPhaseTimings::conc_mark_roots, workers->active_workers());\n@@ -200,2 +202,3 @@\n-      assert(old_task_queues() == nullptr, \"Global mark should not have old gen mark queues.\");\n-      ShenandoahMarkConcurrentRootsTask<GLOBAL> task(task_queues(), old_task_queues(), rp, ShenandoahPhaseTimings::conc_mark_roots, workers->active_workers());\n+      assert(old_task_queues() == nullptr, \"Global mark should not have old gen mark queues\");\n+      ShenandoahMarkConcurrentRootsTask<GLOBAL> task(task_queues(), nullptr, rp,\n+                                                     ShenandoahPhaseTimings::conc_mark_roots, workers->active_workers());\n@@ -205,0 +208,5 @@\n+    case OLD: {\n+      \/\/ We use a YOUNG generation cycle to bootstrap concurrent old marking.\n+      ShouldNotReachHere();\n+      break;\n+    }\n@@ -206,2 +214,0 @@\n-      \/\/ Intentionally haven't added OLD here. We use a YOUNG generation\n-      \/\/ cycle to bootstrap concurrent old marking.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentMark.cpp","additions":16,"deletions":10,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-template<ShenandoahGenerationType GENERATION>\n+template <ShenandoahGenerationType GENERATION>\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentMark.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -145,1 +145,2 @@\n-        _degen_generation = heap->mode()->is_generational() ? heap->young_generation() : heap->global_generation();\n+        _degen_generation = heap->mode()->is_generational() ?\n+                heap->young_generation() : heap->global_generation();\n@@ -147,1 +148,1 @@\n-        assert(_degen_generation != nullptr, \"Need to know which generation to resume.\");\n+        assert(_degen_generation != nullptr, \"Need to know which generation to resume\");\n@@ -154,1 +155,1 @@\n-      \/\/ Do not bother with degenerated cycle if old generation evacuation failed.\n+      \/\/ Do not bother with degenerated cycle if old generation evacuation failed\n@@ -206,1 +207,1 @@\n-          assert(!heap->is_concurrent_old_mark_in_progress(), \"Should not be running mixed collections and concurrent marking.\");\n+          assert(!heap->is_concurrent_old_mark_in_progress(), \"Should not be running mixed collections and concurrent marking\");\n@@ -216,1 +217,1 @@\n-        \/\/ Don't start a new old marking if there is one already in progress.\n+        \/\/ Don't start a new old marking if there is one already in progress\n@@ -235,3 +236,3 @@\n-        log_info(gc)(\"Resume old gc: marking=%s, preparing=%s\",\n-                     BOOL_TO_STR(heap->is_concurrent_old_mark_in_progress()),\n-                     BOOL_TO_STR(heap->is_prepare_for_old_mark_in_progress()));\n+        log_info(gc)(\"Resume old GC: marking is%s in progress, preparing is%s in progress\",\n+                     heap->is_concurrent_old_mark_in_progress() ? \"\" : \" NOT\",\n+                     heap->is_prepare_for_old_mark_in_progress() ? \"\" : \" NOT\");\n@@ -274,30 +275,11 @@\n-      {\n-        switch (_mode) {\n-          case concurrent_normal: {\n-            \/\/ At this point:\n-            \/\/  if (generation == YOUNG), this is a normal YOUNG cycle\n-            \/\/  if (generation == OLD), this is a bootstrap OLD cycle\n-            \/\/  if (generation == GLOBAL), this is a GLOBAL cycle triggered by System.gc()\n-            \/\/ In all three cases, we want to age old objects if this is an aging cycle\n-            if (age_period-- == 0) {\n-              heap->set_aging_cycle(true);\n-              age_period = ShenandoahAgingCyclePeriod - 1;\n-            }\n-            service_concurrent_normal_cycle(heap, generation, cause);\n-            break;\n-          }\n-          case stw_degenerated: {\n-            heap->set_aging_cycle(was_aging_cycle);\n-            if (!service_stw_degenerated_cycle(cause, degen_point)) {\n-              \/\/ The degenerated GC was upgraded to a Full GC\n-              generation = GLOBAL;\n-            }\n-            break;\n-          }\n-          case stw_full: {\n-            if (age_period-- == 0) {\n-              heap->set_aging_cycle(true);\n-              age_period = ShenandoahAgingCyclePeriod - 1;\n-            }\n-            service_stw_full_cycle(cause);\n-            break;\n+\n+      switch (_mode) {\n+        case concurrent_normal: {\n+          \/\/ At this point:\n+          \/\/  if (generation == YOUNG), this is a normal YOUNG cycle\n+          \/\/  if (generation == OLD), this is a bootstrap OLD cycle\n+          \/\/  if (generation == GLOBAL), this is a GLOBAL cycle triggered by System.gc()\n+          \/\/ In all three cases, we want to age old objects if this is an aging cycle\n+          if (age_period-- == 0) {\n+             heap->set_aging_cycle(true);\n+             age_period = ShenandoahAgingCyclePeriod - 1;\n@@ -305,5 +287,8 @@\n-          case servicing_old: {\n-            assert(generation == OLD, \"Expected old generation here\");\n-            GCIdMark gc_id_mark;\n-            service_concurrent_old_cycle(heap, cause);\n-            break;\n+          service_concurrent_normal_cycle(heap, generation, cause);\n+          break;\n+        }\n+        case stw_degenerated: {\n+          heap->set_aging_cycle(was_aging_cycle);\n+          if (!service_stw_degenerated_cycle(cause, degen_point)) {\n+            \/\/ The degenerated GC was upgraded to a Full GC\n+            generation = GLOBAL;\n@@ -311,2 +296,6 @@\n-          default: {\n-            ShouldNotReachHere();\n+          break;\n+        }\n+        case stw_full: {\n+          if (age_period-- == 0) {\n+            heap->set_aging_cycle(true);\n+            age_period = ShenandoahAgingCyclePeriod - 1;\n@@ -314,0 +303,8 @@\n+          service_stw_full_cycle(cause);\n+          break;\n+        }\n+        case servicing_old: {\n+          assert(generation == OLD, \"Expected old generation here\");\n+          GCIdMark gc_id_mark;\n+          service_concurrent_old_cycle(heap, cause);\n+          break;\n@@ -315,0 +312,2 @@\n+        default:\n+          ShouldNotReachHere();\n@@ -408,1 +407,0 @@\n-\n@@ -425,1 +423,1 @@\n-                                                             &evac_stats.mutators);\n+                                                        &evac_stats.mutators);\n@@ -434,1 +432,0 @@\n-\n@@ -462,2 +459,3 @@\n-void ShenandoahControlThread::service_concurrent_normal_cycle(\n-        const ShenandoahHeap* heap, const ShenandoahGenerationType generation, GCCause::Cause cause) {\n+void ShenandoahControlThread::service_concurrent_normal_cycle(const ShenandoahHeap* heap,\n+                                                              const ShenandoahGenerationType generation,\n+                                                              GCCause::Cause cause) {\n@@ -492,1 +490,2 @@\n-      msg = (generation == YOUNG)? \"At end of Interrupted Concurrent Young GC\": \"At end of Interrupted Concurrent Bootstrap GC\";\n+      msg = (generation == YOUNG) ? \"At end of Interrupted Concurrent Young GC\" :\n+                                    \"At end of Interrupted Concurrent Bootstrap GC\";\n@@ -494,1 +493,2 @@\n-      msg = (generation == YOUNG)? \"At end of Concurrent Young GC\": \"At end of Concurrent Bootstrap GC\";\n+      msg = (generation == YOUNG) ? \"At end of Concurrent Young GC\" :\n+                                    \"At end of Concurrent Bootstrap GC\";\n@@ -497,1 +497,2 @@\n-    msg = heap->cancelled_gc() ? \"At end of cancelled GC\" : \"At end of GC\";\n+    msg = heap->cancelled_gc() ? \"At end of cancelled GC\" :\n+                                 \"At end of GC\";\n@@ -503,1 +504,0 @@\n-\n@@ -513,2 +513,2 @@\n-      assert(!heap->is_concurrent_old_mark_in_progress(), \"Old already in progress.\");\n-      assert(old_generation->task_queues()->is_empty(), \"Old mark queues should be empty.\");\n+      assert(!heap->is_concurrent_old_mark_in_progress(), \"Old already in progress\");\n+      assert(old_generation->task_queues()->is_empty(), \"Old mark queues should be empty\");\n@@ -523,1 +523,1 @@\n-        assert(old_generation->state() == ShenandoahOldGeneration::FILLING, \"Prepare for mark should be in progress.\");\n+        assert(old_generation->state() == ShenandoahOldGeneration::FILLING, \"Prepare for mark should be in progress\");\n@@ -527,1 +527,1 @@\n-      assert(old_generation->state() == ShenandoahOldGeneration::BOOTSTRAPPING, \"Finished with filling, should be bootstrapping.\");\n+      assert(old_generation->state() == ShenandoahOldGeneration::BOOTSTRAPPING, \"Finished with filling, should be bootstrapping\");\n@@ -542,1 +542,1 @@\n-        log_info(gc)(\"Bootstrap cycle for old generation was cancelled.\");\n+        log_info(gc)(\"Bootstrap cycle for old generation was cancelled\");\n@@ -563,1 +563,1 @@\n-        assert(old_generation->state() != ShenandoahOldGeneration::MARKING, \"Should not still be marking.\");\n+        assert(old_generation->state() != ShenandoahOldGeneration::MARKING, \"Should not still be marking\");\n@@ -573,2 +573,1 @@\n-      log_error(gc)(\"Unexpected state for old GC: %d\", old_generation->state());\n-      ShouldNotReachHere();\n+      fatal(\"Unexpected state for old GC: %s\", ShenandoahOldGeneration::state_name(old_generation->state()));\n@@ -579,1 +578,0 @@\n-\n@@ -581,1 +579,1 @@\n-  log_debug(gc)(\"Resuming old generation with \" UINT32_FORMAT \" marking tasks queued.\", generation->task_queues()->tasks());\n+  log_debug(gc)(\"Resuming old generation with \" UINT32_FORMAT \" marking tasks queued\", generation->task_queues()->tasks());\n@@ -676,2 +674,4 @@\n-void ShenandoahControlThread::service_concurrent_cycle(const ShenandoahHeap* heap, ShenandoahGeneration* generation,\n-                                                       GCCause::Cause &cause, bool do_old_gc_bootstrap) {\n+void ShenandoahControlThread::service_concurrent_cycle(const ShenandoahHeap* heap,\n+                                                       ShenandoahGeneration* generation,\n+                                                       GCCause::Cause& cause,\n+                                                       bool do_old_gc_bootstrap) {\n@@ -724,1 +724,1 @@\n-  fatal(\"Cancel GC either for alloc failure GC, or gracefully exiting, or to pause old generation marking.\");\n+  fatal(\"Cancel GC either for alloc failure GC, or gracefully exiting, or to pause old generation marking\");\n@@ -745,2 +745,3 @@\n-bool ShenandoahControlThread::service_stw_degenerated_cycle(GCCause::Cause cause, ShenandoahGC::ShenandoahDegenPoint point) {\n-  assert (point != ShenandoahGC::_degenerated_unset, \"Degenerated point should be set\");\n+bool ShenandoahControlThread::service_stw_degenerated_cycle(GCCause::Cause cause,\n+                                                            ShenandoahGC::ShenandoahDegenPoint point) {\n+  assert(point != ShenandoahGC::_degenerated_unset, \"Degenerated point should be set\");\n@@ -761,3 +762,3 @@\n-    ShenandoahOldGeneration* old_generation = (ShenandoahOldGeneration*) heap->old_generation();\n-    if (old_generation->state() == ShenandoahOldGeneration::BOOTSTRAPPING && !gc.upgraded_to_full()) {\n-      old_generation->transition_to(ShenandoahOldGeneration::MARKING);\n+    ShenandoahOldGeneration* old = heap->old_generation();\n+    if (old->state() == ShenandoahOldGeneration::BOOTSTRAPPING && !gc.upgraded_to_full()) {\n+      old->transition_to(ShenandoahOldGeneration::MARKING);\n@@ -801,1 +802,2 @@\n-  return !is_explicit_gc(cause) && cause != GCCause::_shenandoah_concurrent_gc;\n+  return !is_explicit_gc(cause) &&\n+          (cause != GCCause::_shenandoah_concurrent_gc);\n@@ -828,1 +830,1 @@\n-    \/\/ ignore subsequent requests from the heuristics\n+    \/\/ Ignore subsequent requests from the heuristics\n@@ -842,1 +844,1 @@\n-    log_info(gc)(\"Preempting old generation mark to allow %s GC.\", shenandoah_generation_name(generation));\n+    log_info(gc)(\"Preempting old generation mark to allow %s GC\", shenandoah_generation_name(generation));\n@@ -863,1 +865,1 @@\n-  return generation == YOUNG && _allow_old_preemption.try_unset();\n+  return (generation == YOUNG) && _allow_old_preemption.try_unset();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":78,"deletions":76,"binary":false,"changes":154,"status":"modified"},{"patch":"@@ -191,1 +191,3 @@\n-  void service_concurrent_cycle(const ShenandoahHeap* heap, ShenandoahGeneration* generation, GCCause::Cause &cause,\n+  void service_concurrent_cycle(const ShenandoahHeap* heap,\n+                                ShenandoahGeneration* generation,\n+                                GCCause::Cause &cause,\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -100,1 +100,1 @@\n-      assert(!heap->is_old_gc_active(), \"Old GC should not be active during global cycle.\");\n+      assert(!heap->is_old_gc_active(), \"Old GC should not be active during global cycle\");\n@@ -105,1 +105,1 @@\n-      assert(heap->old_generation()->task_queues()->is_empty(), \"Old gen task queues should be empty.\");\n+      assert(heap->old_generation()->task_queues()->is_empty(), \"Old gen task queues should be empty\");\n@@ -136,1 +136,2 @@\n-      heap->set_unload_classes((!heap->mode()->is_generational() || _generation->is_global()) && _generation->heuristics()->can_unload_classes());\n+      heap->set_unload_classes(_generation->heuristics()->can_unload_classes() &&\n+                                (!heap->mode()->is_generational() || _generation->is_global()));\n@@ -138,1 +139,2 @@\n-      if (heap->mode()->is_generational() && (_generation->is_young() || (_generation->is_global() && ShenandoahVerify))) {\n+      if (heap->mode()->is_generational() &&\n+            (_generation->is_young() || (_generation->is_global() && ShenandoahVerify))) {\n@@ -140,0 +142,1 @@\n+        \/\/ TODO: This path should not depend on ShenandoahVerify\n@@ -279,2 +282,2 @@\n-    \/\/ In case degeneration interrupted concurrent evacuation or update references, we need to clean up transient state.\n-    \/\/ Otherwise, these actions have no effect.\n+    \/\/ In case degeneration interrupted concurrent evacuation or update references,\n+    \/\/ we need to clean up transient state. Otherwise, these actions have no effect.\n@@ -284,1 +287,2 @@\n-    \/\/ No need to old_gen->increase_used().  That was done when plabs were allocated, accounting for both old evacs and promotions.\n+    \/\/ No need to old_gen->increase_used(). That was done when plabs were allocated,\n+    \/\/ accounting for both old evacs and promotions.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahDegeneratedGC.cpp","additions":11,"deletions":7,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-    _age_table.add(age, bytes \/ oopSize);\n+    _age_table.add(age, bytes >> LogBytesPerWord);\n@@ -71,4 +71,4 @@\n-            byte_size_in_proper_unit(_bytes_completed),\n-            proper_unit_for_byte_size(_bytes_completed), _evacuations_completed,\n-            byte_size_in_proper_unit(abandoned_size),\n-            proper_unit_for_byte_size(abandoned_size), abandoned_count);\n+            byte_size_in_proper_unit(_bytes_completed), proper_unit_for_byte_size(_bytes_completed),\n+            _evacuations_completed,\n+            byte_size_in_proper_unit(abandoned_size),   proper_unit_for_byte_size(abandoned_size),\n+            abandoned_count);\n@@ -100,0 +100,1 @@\n+        assert(r->is_old(), \"Sanity\");\n@@ -112,1 +113,1 @@\n- public:\n+public:\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahEvacTracker.cpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- private:\n+private:\n@@ -40,1 +40,1 @@\n- public:\n+public:\n@@ -56,3 +56,3 @@\n- private:\n-  ShenandoahEvacuationStats  _workers_global;\n-  ShenandoahEvacuationStats  _mutators_global;\n+private:\n+  ShenandoahEvacuationStats _workers_global;\n+  ShenandoahEvacuationStats _mutators_global;\n@@ -60,1 +60,1 @@\n- public:\n+public:\n@@ -65,1 +65,3 @@\n-  static void print_evacuations_on(outputStream* st, ShenandoahEvacuationStats* workers, ShenandoahEvacuationStats* mutators);\n+  static void print_evacuations_on(outputStream* st,\n+                                   ShenandoahEvacuationStats* workers,\n+                                   ShenandoahEvacuationStats* mutators);\n@@ -68,1 +70,0 @@\n- private:\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahEvacTracker.hpp","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -148,0 +148,2 @@\n+        fatal(\"Should request affiliation\");\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -94,1 +94,0 @@\n-          HeapWord* end_object = r->bottom() + size;\n@@ -97,1 +96,1 @@\n-          size_t num_regions = (size + ShenandoahHeapRegion::region_size_words() - 1) \/ ShenandoahHeapRegion::region_size_words();\n+          size_t num_regions = ShenandoahHeapRegion::required_regions(size * HeapWordSize);\n@@ -109,1 +108,1 @@\n-          scanner->register_object_wo_lock(obj_addr);\n+          scanner->register_object_without_lock(obj_addr);\n@@ -121,1 +120,1 @@\n-            scanner->register_object_wo_lock(obj_addr);\n+            scanner->register_object_without_lock(obj_addr);\n@@ -127,0 +126,1 @@\n+      \/\/ TODO: Assert this.\n@@ -332,0 +332,1 @@\n+    \/\/ TODO: Merge with phase5_epilog?\n@@ -423,1 +424,2 @@\n-  ShenandoahPrepareForCompactionTask(PreservedMarksSet *preserved_marks, ShenandoahHeapRegionSet **worker_slices,\n+  ShenandoahPrepareForCompactionTask(PreservedMarksSet *preserved_marks,\n+                                     ShenandoahHeapRegionSet **worker_slices,\n@@ -443,1 +445,0 @@\n-  ShenandoahPrepareForCompactionTask* _compactor;\n@@ -461,2 +462,1 @@\n-  ShenandoahPrepareForGenerationalCompactionObjectClosure(ShenandoahPrepareForCompactionTask* compactor,\n-                                                          PreservedMarks* preserved_marks,\n+  ShenandoahPrepareForGenerationalCompactionObjectClosure(PreservedMarks* preserved_marks,\n@@ -466,1 +466,0 @@\n-      _compactor(compactor),\n@@ -748,2 +747,4 @@\n-    ShenandoahPrepareForGenerationalCompactionObjectClosure cl(this, _preserved_marks->get(worker_id), empty_regions,\n-                                                               old_to_region, young_to_region, worker_id);\n+    ShenandoahPrepareForGenerationalCompactionObjectClosure cl(_preserved_marks->get(worker_id),\n+                                                               empty_regions,\n+                                                               old_to_region, young_to_region,\n+                                                               worker_id);\n@@ -857,1 +858,1 @@\n-      \/\/ Leave afffiliation unchanged.\n+      \/\/ Leave affiliation unchanged\n@@ -882,22 +883,26 @@\n-    if (r->affiliation() != FREE) {\n-      if (r->is_humongous_start()) {\n-        oop humongous_obj = cast_to_oop(r->bottom());\n-        if (!_ctx->is_marked(humongous_obj)) {\n-          assert(!r->has_live(),\n-                 \"Humongous Start %s Region \" SIZE_FORMAT \" is not marked, should not have live\",\n-                 r->affiliation_name(),  r->index());\n-          log_debug(gc)(\"Trashing immediate humongous region \" SIZE_FORMAT \" because not marked\", r->index());\n-          _heap->trash_humongous_region_at(r);\n-        } else {\n-          assert(r->has_live(),\n-                 \"Humongous Start %s Region \" SIZE_FORMAT \" should have live\", r->affiliation_name(),  r->index());\n-        }\n-      } else if (r->is_humongous_continuation()) {\n-        \/\/ If we hit continuation, the non-live humongous starts should have been trashed already\n-        assert(r->humongous_start_region()->has_live(),\n-               \"Humongous Continuation %s Region \" SIZE_FORMAT \" should have live\", r->affiliation_name(),  r->index());\n-      } else if (r->is_regular()) {\n-        if (!r->has_live()) {\n-          log_debug(gc)(\"Trashing immediate regular region \" SIZE_FORMAT \" because has no live\", r->index());\n-          r->make_trash_immediate();\n-        }\n+    if (!r->is_affiliated()) {\n+      \/\/ Ignore free regions\n+      \/\/ TODO: change iterators so they do not process FREE regions.\n+      return;\n+    }\n+\n+    if (r->is_humongous_start()) {\n+      oop humongous_obj = cast_to_oop(r->bottom());\n+      if (!_ctx->is_marked(humongous_obj)) {\n+        assert(!r->has_live(),\n+               \"Humongous Start %s Region \" SIZE_FORMAT \" is not marked, should not have live\",\n+               r->affiliation_name(),  r->index());\n+        log_debug(gc)(\"Trashing immediate humongous region \" SIZE_FORMAT \" because not marked\", r->index());\n+        _heap->trash_humongous_region_at(r);\n+      } else {\n+        assert(r->has_live(),\n+               \"Humongous Start %s Region \" SIZE_FORMAT \" should have live\", r->affiliation_name(),  r->index());\n+      }\n+    } else if (r->is_humongous_continuation()) {\n+      \/\/ If we hit continuation, the non-live humongous starts should have been trashed already\n+      assert(r->humongous_start_region()->has_live(),\n+             \"Humongous Continuation %s Region \" SIZE_FORMAT \" should have live\", r->affiliation_name(),  r->index());\n+    } else if (r->is_regular()) {\n+      if (!r->has_live()) {\n+        log_debug(gc)(\"Trashing immediate regular region \" SIZE_FORMAT \" because has no live\", r->index());\n+        r->make_trash_immediate();\n@@ -906,2 +911,0 @@\n-    \/\/ else, ignore this FREE region.\n-    \/\/ TODO: change iterators so they do not process FREE regions.\n@@ -1162,1 +1165,1 @@\n-        r->oop_fill_and_coalesce_wo_cancel();\n+        r->oop_fill_and_coalesce_without_cancel();\n@@ -1290,3 +1293,9 @@\n-  ShenandoahPostCompactClosure() : _heap(ShenandoahHeap::heap()), _live(0), _is_generational(_heap->mode()->is_generational()),\n-                                   _young_regions(0), _young_usage(0), _young_humongous_waste(0),\n-                                   _old_regions(0), _old_usage(0), _old_humongous_waste(0)\n+  ShenandoahPostCompactClosure() : _heap(ShenandoahHeap::heap()),\n+                                   _live(0),\n+                                   _is_generational(_heap->mode()->is_generational()),\n+                                   _young_regions(0),\n+                                   _young_usage(0),\n+                                   _young_humongous_waste(0),\n+                                   _old_regions(0),\n+                                   _old_usage(0),\n+                                   _old_humongous_waste(0)\n@@ -1311,1 +1320,0 @@\n-\n@@ -1335,0 +1343,2 @@\n+      } else {\n+        \/\/ TODO: Assert here?\n@@ -1494,2 +1504,4 @@\n-      log_info(gc)(\"FullGC done: GLOBAL usage: \" SIZE_FORMAT \", young usage: \" SIZE_FORMAT \", old usage: \" SIZE_FORMAT,\n-                    post_compact.get_live(), heap->young_generation()->used(), heap->old_generation()->used());\n+      log_info(gc)(\"FullGC done: GLOBAL usage: \" SIZE_FORMAT \"%s, young usage: \" SIZE_FORMAT \"%s, old usage: \" SIZE_FORMAT \"%s\",\n+                   byte_size_in_proper_unit(post_compact.get_live()),          proper_unit_for_byte_size(post_compact.get_live()),\n+                   byte_size_in_proper_unit(heap->young_generation()->used()), proper_unit_for_byte_size(heap->young_generation()->used()),\n+                   byte_size_in_proper_unit(heap->old_generation()->used()),   proper_unit_for_byte_size(heap->old_generation()->used()));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":55,"deletions":43,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -170,2 +170,2 @@\n-                   byte_size_in_proper_unit(v_used), proper_unit_for_byte_size(v_used),\n-                   byte_size_in_proper_unit(v_used_regions), proper_unit_for_byte_size(v_used_regions),\n+                   byte_size_in_proper_unit(v_used),              proper_unit_for_byte_size(v_used),\n+                   byte_size_in_proper_unit(v_used_regions),      proper_unit_for_byte_size(v_used_regions),\n@@ -173,3 +173,3 @@\n-                   byte_size_in_proper_unit(v_max_capacity), proper_unit_for_byte_size(v_max_capacity),\n-                   byte_size_in_proper_unit(v_available), proper_unit_for_byte_size(v_available),\n-                   byte_size_in_proper_unit(v_adjusted_avail), proper_unit_for_byte_size(v_adjusted_avail));\n+                   byte_size_in_proper_unit(v_max_capacity),      proper_unit_for_byte_size(v_max_capacity),\n+                   byte_size_in_proper_unit(v_available),         proper_unit_for_byte_size(v_available),\n+                   byte_size_in_proper_unit(v_adjusted_avail),    proper_unit_for_byte_size(v_adjusted_avail));\n@@ -493,1 +493,1 @@\n-    \/\/ Undo the prevous loan, if any.\n+    \/\/ Undo the previous loan, if any.\n@@ -521,2 +521,0 @@\n-\n-\n@@ -764,2 +762,4 @@\n-                     byte_size_in_proper_unit(old_available), proper_unit_for_byte_size(old_available),\n-                     byte_size_in_proper_unit(old_evacuation_reserve), proper_unit_for_byte_size(old_evacuation_reserve),\n+                     byte_size_in_proper_unit(old_available),\n+                     proper_unit_for_byte_size(old_available),\n+                     byte_size_in_proper_unit(old_evacuation_reserve),\n+                     proper_unit_for_byte_size(old_evacuation_reserve),\n@@ -768,1 +768,2 @@\n-                     byte_size_in_proper_unit(regular_promotion), proper_unit_for_byte_size(regular_promotion),\n+                     byte_size_in_proper_unit(regular_promotion),\n+                     proper_unit_for_byte_size(regular_promotion),\n@@ -771,2 +772,4 @@\n-                     byte_size_in_proper_unit(allocation_supplement), proper_unit_for_byte_size(allocation_supplement),\n-                     byte_size_in_proper_unit(excess), proper_unit_for_byte_size(excess));\n+                     byte_size_in_proper_unit(allocation_supplement),\n+                     proper_unit_for_byte_size(allocation_supplement),\n+                     byte_size_in_proper_unit(excess),\n+                     proper_unit_for_byte_size(excess));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":16,"deletions":13,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -66,2 +66,4 @@\n-  void compute_evacuation_budgets(ShenandoahHeap* heap, bool* preselected_regions, ShenandoahCollectionSet* collection_set,\n-                                  size_t &consumed_by_advance_promotion);\n+  void compute_evacuation_budgets(ShenandoahHeap* heap,\n+                                  bool* preselected_regions,\n+                                  ShenandoahCollectionSet* collection_set,\n+                                  size_t& consumed_by_advance_promotion);\n@@ -70,1 +72,2 @@\n-  void adjust_evacuation_budgets(ShenandoahHeap* heap, ShenandoahCollectionSet* collection_set,\n+  void adjust_evacuation_budgets(ShenandoahHeap* heap,\n+                                 ShenandoahCollectionSet* collection_set,\n@@ -74,1 +77,4 @@\n-  ShenandoahGeneration(ShenandoahGenerationType type, uint max_workers, size_t max_capacity, size_t soft_max_capacity);\n+  ShenandoahGeneration(ShenandoahGenerationType type,\n+                       uint max_workers,\n+                       size_t max_capacity,\n+                       size_t soft_max_capacity);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.hpp","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-  virtual void set_concurrent_mark_in_progress(bool in_progress)  override;\n+  virtual void set_concurrent_mark_in_progress(bool in_progress) override;\n@@ -50,1 +50,1 @@\n-  bool contains(ShenandoahHeapRegion* region) const  override;\n+  bool contains(ShenandoahHeapRegion* region) const override;\n@@ -52,1 +52,4 @@\n-  bool contains(oop obj) const override { return true; }\n+  bool contains(oop obj) const override {\n+    \/\/ TODO: Should this assert is_in()?\n+    return true;\n+  }\n@@ -54,1 +57,1 @@\n-  void parallel_heap_region_iterate(ShenandoahHeapRegionClosure* cl)  override;\n+  void parallel_heap_region_iterate(ShenandoahHeapRegionClosure* cl) override;\n@@ -56,1 +59,1 @@\n-  void heap_region_iterate(ShenandoahHeapRegionClosure* cl)  override;\n+  void heap_region_iterate(ShenandoahHeapRegionClosure* cl) override;\n@@ -58,1 +61,1 @@\n-  bool is_concurrent_mark_in_progress()  override;\n+  bool is_concurrent_mark_in_progress() override;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGlobalGeneration.hpp","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -812,1 +812,1 @@\n-  card_scan()->register_object_wo_lock(obj);\n+  card_scan()->register_object_without_lock(obj);\n@@ -1045,1 +1045,1 @@\n-    card_scan()->register_object_wo_lock(top);\n+    card_scan()->register_object_without_lock(top);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -627,1 +627,0 @@\n-    extern bool _is_at_shenandoah_safepoint();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.inline.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -438,1 +438,1 @@\n-bool ShenandoahHeapRegion::oop_fill_and_coalesce_wo_cancel() {\n+bool ShenandoahHeapRegion::oop_fill_and_coalesce_without_cancel() {\n@@ -1062,1 +1062,1 @@\n-  heap->card_scan()->register_object_wo_lock(bottom());\n+  heap->card_scan()->register_object_without_lock(bottom());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -400,1 +400,1 @@\n-  bool oop_fill_and_coalesce_wo_cancel();\n+  bool oop_fill_and_coalesce_without_cancel();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -622,1 +622,1 @@\n-  \/\/ register_object_wo_lock() does not require that the caller hold\n+  \/\/ register_object_without_lock() does not require that the caller hold\n@@ -627,1 +627,1 @@\n-  void register_object_wo_lock(HeapWord* address);\n+  void register_object_without_lock(HeapWord* address);\n@@ -843,1 +843,1 @@\n-  void register_object_wo_lock(HeapWord *addr);\n+  void register_object_without_lock(HeapWord *addr);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -186,1 +186,1 @@\n-  register_object_wo_lock(address);\n+  register_object_without_lock(address);\n@@ -191,1 +191,1 @@\n-ShenandoahCardCluster<RememberedSet>::register_object_wo_lock(HeapWord* address) {\n+ShenandoahCardCluster<RememberedSet>::register_object_without_lock(HeapWord* address) {\n@@ -422,2 +422,2 @@\n-ShenandoahScanRemembered<RememberedSet>::register_object_wo_lock(HeapWord *addr) {\n-  _scc->register_object_wo_lock(addr);\n+ShenandoahScanRemembered<RememberedSet>::register_object_without_lock(HeapWord *addr) {\n+  _scc->register_object_without_lock(addr);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.inline.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"}]}