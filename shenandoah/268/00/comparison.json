{"files":[{"patch":"@@ -124,4 +124,6 @@\n-\/\/ Merge this HdrSeq into hdr2: clear optional and on-by-default\n-\/\/ Note: this method isn't intrinsically MT-safe; callers must take care\n-\/\/ of any mutual exclusion as necessary.\n-void HdrSeq::merge(HdrSeq& hdr2, bool clear_this) {\n+void HdrSeq::add(HdrSeq& other) {\n+  if (other.num() == 0) {\n+    \/\/ Other sequence is empty, return\n+    return;\n+  }\n+\n@@ -129,24 +131,42 @@\n-    if (_hdr[mag] != nullptr) {\n-      int* that_bucket = hdr2._hdr[mag];\n-      if (that_bucket == nullptr) {\n-        if (clear_this) {\n-          \/\/ the target doesn't have any values, swap in ours.\n-          \/\/ Could this cause native memory fragmentation?\n-          hdr2._hdr[mag] = _hdr[mag];\n-          _hdr[mag] = nullptr;\n-        } else {\n-          \/\/ We can't clear this, so we create the entries & add in below\n-          that_bucket = NEW_C_HEAP_ARRAY(int, ValBuckets, mtInternal);\n-          for (int val = 0; val < ValBuckets; val++) {\n-            that_bucket[val] = _hdr[mag][val];\n-          }\n-          hdr2._hdr[mag] = that_bucket;\n-        }\n-      } else {\n-        \/\/ Add in our values into target\n-        for (int val = 0; val < ValBuckets; val++) {\n-          that_bucket[val] += _hdr[mag][val];\n-          if (clear_this) {\n-            _hdr[mag][val] = 0;\n-          }\n-        }\n+    int* other_bucket = other._hdr[mag];\n+    if (other_bucket == nullptr) {\n+      \/\/ Nothing to do\n+      continue;\n+    }\n+    int* bucket = _hdr[mag];\n+    if (bucket != nullptr) {\n+      \/\/ Add into our bucket\n+      for (int val = 0; val < ValBuckets; val++) {\n+        bucket[val] += other_bucket[val];\n+      }\n+    } else {\n+      \/\/ Create our bucket and copy the contents over\n+      bucket = NEW_C_HEAP_ARRAY(int, ValBuckets, mtInternal);\n+      for (int val = 0; val < ValBuckets; val++) {\n+        bucket[val] = other_bucket[val];\n+      }\n+      _hdr[mag] = bucket;\n+    }\n+  }\n+\n+  \/\/ This is a hacky way to only update the fields we want.\n+  \/\/ This inlines NumberSeq code without going into AbsSeq and\n+  \/\/ dealing with decayed average\/variance, which we do not\n+  \/\/ know how to compute yet.\n+  _last = other._last;\n+  _maximum = MAX2(_maximum, other._maximum);\n+  _sum += other._sum;\n+  _sum_of_squares += other._sum_of_squares;\n+  _num += other._num;\n+\n+  \/\/ Until JDK-8298902 is fixed, we taint the decaying statistics\n+  _davg = NAN;\n+  _dvariance = NAN;\n+}\n+\n+void HdrSeq::clear() {\n+  for (int mag = 0; mag < MagBuckets; mag++) {\n+    int* bucket = _hdr[mag];\n+    if (bucket != nullptr) {\n+      for (int c = 0; c < ValBuckets; c++) {\n+        bucket[c] = 0;\n@@ -156,2 +176,0 @@\n-  \/\/ Merge up the class hierarchy\n-  NumberSeq::merge(hdr2, clear_this);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahNumberSeq.cpp","additions":48,"deletions":30,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+  void add(HdrSeq& other);\n@@ -54,3 +55,1 @@\n-\n-  \/\/ Merge this HdrSeq into hdr2, optionally clearing this HdrSeq\n-  void merge(HdrSeq& hdr2, bool clear_this = true);\n+  void clear();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahNumberSeq.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -969,1 +969,2 @@\n-    worker_stats[i].merge(cum_stats[i]);\n+    cum_stats[i].add(worker_stats[i]);\n+    worker_stats[i].clear();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.inline.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -113,26 +113,0 @@\n-void AbsSeq::merge(AbsSeq& abs2, bool clear_this) {\n-\n-  if (num() == 0) return;  \/\/ nothing to do\n-\n-  abs2._num += _num;\n-  abs2._sum += _sum;\n-  abs2._sum_of_squares += _sum_of_squares;\n-\n-  \/\/ Decaying stats need a bit more thought\n-  assert(abs2._alpha == _alpha, \"Caution: merge incompatible?\");\n-  \/\/ Until JDK-8298902 is fixed, we taint the decaying statistics\n-  if (abs2._davg != NAN) {\n-    abs2._davg = NAN;\n-    abs2._dvariance = NAN;\n-  }\n-\n-  if (clear_this) {\n-    _num = 0;\n-    _sum = 0;\n-    _sum_of_squares = 0;\n-    _davg = 0;\n-    _dvariance = 0;\n-  }\n-}\n-\n-\n@@ -166,16 +140,0 @@\n-void NumberSeq::merge(NumberSeq& nseq2, bool clear_this) {\n-\n-  if (num() == 0) return;  \/\/ nothing to do\n-\n-  nseq2._last = _last;   \/\/ this is newer than that\n-  nseq2._maximum = MAX2(_maximum, nseq2._maximum);\n-\n-  AbsSeq::merge(nseq2, clear_this);\n-\n-  if (clear_this) {\n-    _last = 0;\n-    _maximum = 0;\n-    assert(num() == 0, \"Not cleared\");\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/utilities\/numberSeq.cpp","additions":0,"deletions":42,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -86,3 +86,0 @@\n-\n-  \/\/ Merge this AbsSeq into seq2, optionally clearing this AbsSeq\n-  void merge(AbsSeq& seq2, bool clear_this = true);\n@@ -108,3 +105,0 @@\n-\n-  \/\/ Merge this NumberSeq into seq2, optionally clearing this NumberSeq\n-  void merge(NumberSeq& seq2, bool clear_this = true);\n@@ -138,3 +132,0 @@\n-\n-  \/\/ Merge this AbsSeq into seq2, optionally clearing this AbsSeq\n-  void merge(AbsSeq& seq2, bool clear_this = true);\n","filename":"src\/hotspot\/share\/utilities\/numberSeq.hpp","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -115,18 +115,10 @@\n-  EXPECT_FALSE(isnan(seq2.davg()));  \/\/ Exercise the path; not a nan\n-  EXPECT_FALSE(isnan(seq2.dsd()));\n-  EXPECT_FALSE(isnan(seq2.dvariance()));\n-\n-  std::cout << \"Pre-merge: \\n\";\n-  print();\n-  seq1.merge(seq2);    \/\/ clears seq1, after merging into seq2\n-  std::cout << \"Post-merge: \\n\";\n-  print();\n-\n-  EXPECT_EQ(seq1.num(), 0);\n-  EXPECT_EQ(seq2.num(), 100);\n-  EXPECT_EQ(seq2.num(), seq3.num());\n-  EXPECT_TRUE(isnan(seq2.davg()));  \/\/ until we fix decayed stats\n-  EXPECT_TRUE(isnan(seq2.dvariance()));\n-\n-  EXPECT_EQ(seq2.maximum(), seq3.maximum());\n-  EXPECT_EQ(seq2.percentile(0), seq3.percentile(0));\n+  EXPECT_EQ(seq3.num(), 100);\n+\n+  HdrSeq merged;\n+  merged.add(seq1);\n+  merged.add(seq2);\n+\n+  EXPECT_EQ(merged.num(), seq3.num());\n+\n+  EXPECT_EQ(merged.maximum(), seq3.maximum());\n+  EXPECT_EQ(merged.percentile(0), seq3.percentile(0));\n@@ -134,1 +126,1 @@\n-    EXPECT_NEAR(seq2.percentile(i), seq3.percentile(i), err);\n+    EXPECT_NEAR(merged.percentile(i), seq3.percentile(i), err);\n@@ -136,2 +128,6 @@\n-  EXPECT_NEAR(seq2.avg(), seq3.avg(), err);\n-  EXPECT_NEAR(seq2.sd(),  seq3.sd(),  err);\n+  EXPECT_NEAR(merged.avg(), seq3.avg(), err);\n+  EXPECT_NEAR(merged.sd(),  seq3.sd(),  err);\n+\n+  \/\/ These are not implemented\n+  EXPECT_TRUE(isnan(merged.davg()));\n+  EXPECT_TRUE(isnan(merged.dvariance()));\n","filename":"test\/hotspot\/gtest\/gc\/shenandoah\/test_shenandoahNumberSeq.cpp","additions":17,"deletions":21,"binary":false,"changes":38,"status":"modified"}]}