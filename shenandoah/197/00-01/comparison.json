{"files":[{"patch":"@@ -3154,0 +3154,1 @@\n+    HeapWord* tams = ctx? ctx->top_at_mark_start(r): nullptr;\n@@ -3175,28 +3176,0 @@\n-        if (ctx) {\n-          \/\/ Require appropriate dirty card marks on marked objects between bottom and TAMS\n-          HeapWord* tams = ctx->top_at_mark_start(r);\n-          while (obj_addr < tams) {\n-            oop obj = cast_to_oop(obj_addr);\n-            if (ctx->is_marked(obj)) {\n-              \/\/ For regular objects (not object arrays), if the card holding the start of the object is dirty,\n-              \/\/ we do not need to verify that cards spanning interesting pointers within this object are dirty.\n-              if (!scanner->is_card_dirty(obj_addr) || obj->is_objArray()) {\n-                obj->oop_iterate(&check_interesting_pointers);\n-              }\n-              \/\/ else, object's start is marked dirty and obj is not an objArray, so any interesting pointers are covered\n-              if (!scanner->verify_registration(obj_addr, ctx)) {\n-                ShenandoahAsserts::print_failure(ShenandoahAsserts::_safe_all, obj, obj_addr, NULL,\n-                                                 \"Verify init-mark remembered set violation\",\n-                                                 \"object not properly registered\", __FILE__, __LINE__);\n-              }\n-              obj_addr += obj->size();\n-            } else {\n-              \/\/ This object is not live so we don't verify dirty cards contained therein.  If no more marked objects\n-              \/\/ below TAMS, get_next_marked_addr() returns TAMS.\n-              obj_addr = ctx->get_next_marked_addr(obj_addr, tams);\n-            }\n-          }\n-        }\n-        \/\/ Require appropriate dirty card marks on all objects throughout the remainder of this heap region.\n-        \/\/ At this point obj_addr either equals bottom() with ctx == nullptr, or obj_addr == TAMS\n-        \/\/ Between obj_addr and top, every object is considered live.\n@@ -3206,10 +3179,17 @@\n-          \/\/ For regular objects (not object arrays), if the card holding the start of the object is dirty,\n-          \/\/ we do not need to verify that cards spanning interesting pointers within this object are dirty.\n-          if (!scanner->is_card_dirty(obj_addr) || obj->is_objArray()) {\n-            obj->oop_iterate(&check_interesting_pointers);\n-          }\n-          \/\/ else, object's start is marked dirty and obj is not an objArray, so any interesting pointers are covered\n-          if (!scanner->verify_registration(obj_addr, ctx)) {\n-            ShenandoahAsserts::print_failure(ShenandoahAsserts::_safe_all, obj, obj_addr, NULL,\n-                                             \"Verify init-mark remembered set violation\",\n-                                             \"object not properly registered\", __FILE__, __LINE__);\n+          \/\/ ctx->is_marked() returns true if mark bit set (TAMS not relevant during init mark)\n+          if (!ctx || ctx->is_marked(obj)) {\n+            \/\/ For regular objects (not object arrays), if the card holding the start of the object is dirty,\n+            \/\/ we do not need to verify that cards spanning interesting pointers within this object are dirty.\n+            if (!scanner->is_card_dirty(obj_addr) || obj->is_objArray()) {\n+              obj->oop_iterate(&check_interesting_pointers);\n+            }\n+            \/\/ else, object's start is marked dirty and obj is not an objArray, so any interesting pointers are covered\n+            if (!scanner->verify_registration(obj_addr, ctx)) {\n+              ShenandoahAsserts::print_failure(ShenandoahAsserts::_safe_all, obj, obj_addr, NULL,\n+                                               \"Verify init-mark remembered set violation\", \"object not properly registered\", __FILE__, __LINE__);\n+            }\n+            obj_addr += obj->size();\n+          } else {\n+            \/\/ This object is not live so we don't verify dirty cards contained therein\n+            assert(tams != nullptr, \"If object is not live, ctx and tams should be non-null\");\n+            obj_addr = ctx->get_next_marked_addr(obj_addr, tams);\n@@ -3217,1 +3197,0 @@\n-          obj_addr += obj->size();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":18,"deletions":39,"binary":false,"changes":57,"status":"modified"}]}