{"files":[{"patch":"@@ -4,0 +4,1 @@\n+version=19\n","filename":".jcheck\/conf","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -392,1 +392,1 @@\n-  __ lsr(obj, obj, CardTable::card_shift);\n+  __ lsr(obj, obj, CardTable::card_shift());\n@@ -646,2 +646,2 @@\n-  __ lsr(start, start, CardTable::card_shift);\n-  __ lsr(end, end, CardTable::card_shift);\n+  __ lsr(start, start, CardTable::card_shift());\n+  __ lsr(end, end, CardTable::card_shift());\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shenandoah\/shenandoahBarrierSetAssembler_aarch64.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -477,1 +477,1 @@\n-      __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_strong_narrow), arg0, arg1);\n+      __ super_call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_strong_narrow), arg0, arg1);\n@@ -479,1 +479,1 @@\n-      __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_strong), arg0, arg1);\n+      __ super_call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_strong), arg0, arg1);\n@@ -490,1 +490,1 @@\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_phantom), arg0, arg1);\n+    __ super_call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_phantom), arg0, arg1);\n@@ -658,1 +658,1 @@\n-  __ shrptr(obj, CardTable::card_shift);\n+  __ shrptr(obj, CardTable::card_shift());\n@@ -961,2 +961,2 @@\n-  __ shrptr(addr, CardTable::card_shift);\n-  __ shrptr(end, CardTable::card_shift);\n+  __ shrptr(addr, CardTable::card_shift());\n+  __ shrptr(end, CardTable::card_shift());\n@@ -973,2 +973,2 @@\n-  __ shrptr(addr, CardTable::card_shift);\n-  __ shrptr(end,   CardTable::card_shift);\n+  __ shrptr(addr, CardTable::card_shift());\n+  __ shrptr(end,   CardTable::card_shift());\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shenandoah\/shenandoahBarrierSetAssembler_x86.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+#include \"gc\/shared\/gcLogPrecious.hpp\"\n+#include \"gc\/shared\/gc_globals.hpp\"\n@@ -35,0 +37,26 @@\n+#if INCLUDE_PARALLELGC\n+#include \"gc\/parallel\/objectStartArray.hpp\"\n+#endif\n+\n+uint CardTable::_card_shift = 0;\n+uint CardTable::_card_size = 0;\n+uint CardTable::_card_size_in_words = 0;\n+\n+void CardTable::initialize_card_size() {\n+  assert(UseG1GC || UseParallelGC || UseSerialGC || UseShenandoahGC,\n+         \"Initialize card size should only be called by card based collectors.\");\n+\n+  _card_size = GCCardSizeInBytes;\n+  _card_shift = log2i_exact(_card_size);\n+  _card_size_in_words = _card_size \/ sizeof(HeapWord);\n+\n+  \/\/ Set blockOffsetTable size based on card table entry size\n+  BOTConstants::initialize_bot_size(_card_shift);\n+\n+#if INCLUDE_PARALLELGC\n+  \/\/ Set ObjectStartArray block size based on card table entry size\n+  ObjectStartArray::initialize_block_size(_card_shift);\n+#endif\n+\n+  log_info_p(gc, init)(\"CardTable entry size: \" UINT32_FORMAT,  _card_size);\n+}\n@@ -57,4 +85,2 @@\n-  assert((uintptr_t(_whole_heap.start())  & (card_size - 1))  == 0, \"heap must start at card boundary\");\n-  assert((uintptr_t(_whole_heap.end()) & (card_size - 1))  == 0, \"heap must end at card boundary\");\n-\n-  assert(card_size <= 512, \"card_size must be less than 512\"); \/\/ why?\n+  assert((uintptr_t(_whole_heap.start())  & (_card_size - 1))  == 0, \"heap must start at card boundary\");\n+  assert((uintptr_t(_whole_heap.end()) & (_card_size - 1))  == 0, \"heap must end at card boundary\");\n@@ -97,1 +123,1 @@\n-  _byte_map_base = _byte_map - (uintptr_t(low_bound) >> card_shift);\n+  _byte_map_base = _byte_map - (uintptr_t(low_bound) >> _card_shift);\n@@ -139,10 +165,0 @@\n-int CardTable::find_covering_region_containing(HeapWord* addr) {\n-  for (int i = 0; i < _cur_covered_regions; i++) {\n-    if (_covered[i].contains(addr)) {\n-      return i;\n-    }\n-  }\n-  assert(0, \"address outside of heap?\");\n-  return -1;\n-}\n-\n@@ -390,1 +406,1 @@\n-                              dirty_cards*card_size_in_words);\n+                              dirty_cards*_card_size_in_words);\n@@ -416,1 +432,1 @@\n-                              dirty_cards*card_size_in_words);\n+                              dirty_cards * _card_size_in_words);\n@@ -431,1 +447,2 @@\n-  return card_size * os::vm_page_size();\n+  \/\/ Calculate maximum alignment using GCCardSizeInBytes as card_size hasn't been set yet\n+  return GCCardSizeInBytes * os::vm_page_size();\n@@ -469,1 +486,1 @@\n-                            p2i((HeapWord*) (((size_t) addr_for(curr)) + card_size)),\n+                            p2i((HeapWord*) (((size_t) addr_for(curr)) + _card_size)),\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTable.cpp","additions":36,"deletions":19,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -81,4 +81,0 @@\n-  \/\/ Same as above, but finds the region containing the given address\n-  \/\/ instead of starting at a given base address.\n-  int find_covering_region_containing(HeapWord* addr);\n-\n@@ -114,0 +110,5 @@\n+  \/\/ CardTable entry size\n+  static uint _card_shift;\n+  static uint _card_size;\n+  static uint _card_size_in_words;\n+\n@@ -136,2 +137,2 @@\n-    const size_t words = align_up(covered_words, card_size_in_words);\n-    return words \/ card_size_in_words + 1;\n+    const size_t words = align_up(covered_words, _card_size_in_words);\n+    return words \/ _card_size_in_words + 1;\n@@ -160,1 +161,1 @@\n-    CardValue* result = &_byte_map_base[uintptr_t(p) >> card_shift];\n+    CardValue* result = &_byte_map_base[uintptr_t(p) >> _card_shift];\n@@ -192,1 +193,1 @@\n-    HeapWord* result = (HeapWord*) (delta << card_shift);\n+    HeapWord* result = (HeapWord*) (delta << _card_shift);\n@@ -231,6 +232,11 @@\n-  \/\/ Constants\n-  enum SomePublicConstants {\n-    card_shift                  = 9,\n-    card_size                   = 1 << card_shift,\n-    card_size_in_words          = card_size \/ sizeof(HeapWord)\n-  };\n+  static uint card_shift() {\n+    return _card_shift;\n+  }\n+\n+  static uint card_size() {\n+    return _card_size;\n+  }\n+\n+  static uint card_size_in_words() {\n+    return _card_size_in_words;\n+  }\n@@ -242,0 +248,3 @@\n+  \/\/ Initialize card size\n+  static void initialize_card_size();\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTable.hpp","additions":23,"deletions":14,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -97,3 +97,0 @@\n-  \/\/ Allocate the object aligned to \"alignment_in_bytes\".\n-  inline HeapWord* allocate_aligned(size_t word_sz, unsigned short alignment_in_bytes);\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/plab.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -306,1 +306,1 @@\n-void ShenandoahBarrierSetC1::post_barrier(LIRAccess& access, LIR_OprDesc* addr, LIR_OprDesc* new_val) {\n+void ShenandoahBarrierSetC1::post_barrier(LIRAccess& access, LIR_Opr addr, LIR_Opr new_val) {\n@@ -340,1 +340,1 @@\n-    __ unsigned_shift_right(tmp, CardTable::card_shift, tmp);\n+    __ unsigned_shift_right(tmp, CardTable::card_shift(), tmp);\n@@ -342,1 +342,1 @@\n-    __ unsigned_shift_right(addr, CardTable::card_shift, tmp);\n+    __ unsigned_shift_right(addr, CardTable::card_shift(), tmp);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c1\/shenandoahBarrierSetC1.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -245,1 +245,1 @@\n-  void post_barrier(LIRAccess& access, LIR_OprDesc* addr, LIR_OprDesc* new_val);\n+  void post_barrier(LIRAccess& access, LIR_Opr addr, LIR_Opr new_val);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c1\/shenandoahBarrierSetC1.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -515,1 +515,1 @@\n-  Node* card_offset = __ URShiftX( cast, __ ConI(CardTable::card_shift) );\n+  Node* card_offset = __ URShiftX( cast, __ ConI(CardTable::card_shift()) );\n@@ -825,1 +825,1 @@\n-  if (node->Opcode() == Op_ShenandoahLoadReferenceBarrier) return true;\n+  if (node->Opcode() == Op_ShenandoahLoadReferenceBarrier || node->Opcode() == Op_ShenandoahIUBarrier) return true;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahBarrierSetC2.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -57,1 +57,0 @@\n-    DEBUG_ONLY(verify_raw_mem(C->root());)\n@@ -967,1 +966,1 @@\n-void ShenandoahBarrierC2Support::call_lrb_stub(Node*& ctrl, Node*& val, Node* load_addr, Node*& result_mem, Node* raw_mem,\n+void ShenandoahBarrierC2Support::call_lrb_stub(Node*& ctrl, Node*& val, Node* load_addr,\n@@ -972,7 +971,0 @@\n-  \/\/ The slow path stub consumes and produces raw memory in addition\n-  \/\/ to the existing memory edges\n-  Node* base = find_bottom_mem(ctrl, phase);\n-  MergeMemNode* mm = MergeMemNode::make(base);\n-  mm->set_memory_at(Compile::AliasIdxRaw, raw_mem);\n-  phase->register_new_node(mm, ctrl);\n-\n@@ -1016,1 +1008,1 @@\n-  call->init_req(TypeFunc::Memory, mm);\n+  call->init_req(TypeFunc::Memory, phase->C->top());\n@@ -1024,2 +1016,0 @@\n-  result_mem = new ProjNode(call, TypeFunc::Memory);\n-  phase->register_new_node(result_mem, call);\n@@ -1344,1 +1334,0 @@\n-\n@@ -1348,2 +1337,0 @@\n-    Node* init_raw_mem = raw_mem;\n-    Node* raw_mem_for_ctrl = fixer.find_mem(ctrl, NULL);\n@@ -1362,1 +1349,0 @@\n-    Node* raw_mem_phi = PhiNode::make(region, raw_mem, Type::MEMORY, TypeRawPtr::BOTTOM);\n@@ -1375,1 +1361,0 @@\n-    raw_mem_phi->init_req(_heap_stable, raw_mem);\n@@ -1387,1 +1372,0 @@\n-      raw_mem_phi->init_req(_not_cset, raw_mem);\n@@ -1391,1 +1375,0 @@\n-      raw_mem_phi->del_req(_not_cset);\n@@ -1432,1 +1415,1 @@\n-    call_lrb_stub(ctrl, val, addr, result_mem, raw_mem, lrb->decorators(), phase);\n+    call_lrb_stub(ctrl, val, addr, lrb->decorators(), phase);\n@@ -1435,1 +1418,0 @@\n-    raw_mem_phi->init_req(_evac_path, result_mem);\n@@ -1440,1 +1422,0 @@\n-    phase->register_new_node(raw_mem_phi, region);\n@@ -1453,1 +1434,1 @@\n-      assert(n != init_raw_mem, \"should leave input raw mem above the barrier\");\n+      assert(n != raw_mem, \"should leave input raw mem above the barrier\");\n@@ -1457,8 +1438,0 @@\n-\n-    \/\/ The slow path call produces memory: hook the raw memory phi\n-    \/\/ from the expanded load reference barrier with the rest of the graph\n-    \/\/ which may require adding memory phis at every post dominated\n-    \/\/ region and at enclosing loop heads. Use the memory state\n-    \/\/ collected in memory_nodes to fix the memory graph. Update that\n-    \/\/ memory state as we go.\n-    fixer.fix_mem(ctrl, region, init_raw_mem, raw_mem_for_ctrl, raw_mem_phi, uses);\n@@ -1905,99 +1878,0 @@\n-#ifdef ASSERT\n-void ShenandoahBarrierC2Support::verify_raw_mem(RootNode* root) {\n-  const bool trace = false;\n-  ResourceMark rm;\n-  Unique_Node_List nodes;\n-  Unique_Node_List controls;\n-  Unique_Node_List memories;\n-\n-  nodes.push(root);\n-  for (uint next = 0; next < nodes.size(); next++) {\n-    Node *n  = nodes.at(next);\n-    if (ShenandoahBarrierSetC2::is_shenandoah_lrb_call(n)) {\n-      controls.push(n);\n-      if (trace) { tty->print(\"XXXXXX verifying\"); n->dump(); }\n-      for (uint next2 = 0; next2 < controls.size(); next2++) {\n-        Node *m = controls.at(next2);\n-        for (DUIterator_Fast imax, i = m->fast_outs(imax); i < imax; i++) {\n-          Node* u = m->fast_out(i);\n-          if (u->is_CFG() && !u->is_Root() &&\n-              !(u->Opcode() == Op_CProj && u->in(0)->Opcode() == Op_NeverBranch && u->as_Proj()->_con == 1) &&\n-              !(u->is_Region() && u->unique_ctrl_out()->Opcode() == Op_Halt)) {\n-            if (trace) { tty->print(\"XXXXXX pushing control\"); u->dump(); }\n-            controls.push(u);\n-          }\n-        }\n-      }\n-      memories.push(n->as_Call()->proj_out(TypeFunc::Memory));\n-      for (uint next2 = 0; next2 < memories.size(); next2++) {\n-        Node *m = memories.at(next2);\n-        assert(m->bottom_type() == Type::MEMORY, \"\");\n-        for (DUIterator_Fast imax, i = m->fast_outs(imax); i < imax; i++) {\n-          Node* u = m->fast_out(i);\n-          if (u->bottom_type() == Type::MEMORY && (u->is_Mem() || u->is_ClearArray())) {\n-            if (trace) { tty->print(\"XXXXXX pushing memory\"); u->dump(); }\n-            memories.push(u);\n-          } else if (u->is_LoadStore()) {\n-            if (trace) { tty->print(\"XXXXXX pushing memory\"); u->find_out_with(Op_SCMemProj)->dump(); }\n-            memories.push(u->find_out_with(Op_SCMemProj));\n-          } else if (u->is_MergeMem() && u->as_MergeMem()->memory_at(Compile::AliasIdxRaw) == m) {\n-            if (trace) { tty->print(\"XXXXXX pushing memory\"); u->dump(); }\n-            memories.push(u);\n-          } else if (u->is_Phi()) {\n-            assert(u->bottom_type() == Type::MEMORY, \"\");\n-            if (u->adr_type() == TypeRawPtr::BOTTOM || u->adr_type() == TypePtr::BOTTOM) {\n-              assert(controls.member(u->in(0)), \"\");\n-              if (trace) { tty->print(\"XXXXXX pushing memory\"); u->dump(); }\n-              memories.push(u);\n-            }\n-          } else if (u->is_SafePoint() || u->is_MemBar()) {\n-            for (DUIterator_Fast jmax, j = u->fast_outs(jmax); j < jmax; j++) {\n-              Node* uu = u->fast_out(j);\n-              if (uu->bottom_type() == Type::MEMORY) {\n-                if (trace) { tty->print(\"XXXXXX pushing memory\"); uu->dump(); }\n-                memories.push(uu);\n-              }\n-            }\n-          }\n-        }\n-      }\n-      for (uint next2 = 0; next2 < controls.size(); next2++) {\n-        Node *m = controls.at(next2);\n-        if (m->is_Region()) {\n-          bool all_in = true;\n-          for (uint i = 1; i < m->req(); i++) {\n-            if (!controls.member(m->in(i))) {\n-              all_in = false;\n-              break;\n-            }\n-          }\n-          if (trace) { tty->print(\"XXX verifying %s\", all_in ? \"all in\" : \"\"); m->dump(); }\n-          bool found_phi = false;\n-          for (DUIterator_Fast jmax, j = m->fast_outs(jmax); j < jmax && !found_phi; j++) {\n-            Node* u = m->fast_out(j);\n-            if (u->is_Phi() && memories.member(u)) {\n-              found_phi = true;\n-              for (uint i = 1; i < u->req() && found_phi; i++) {\n-                Node* k = u->in(i);\n-                if (memories.member(k) != controls.member(m->in(i))) {\n-                  found_phi = false;\n-                }\n-              }\n-            }\n-          }\n-          assert(found_phi || all_in, \"\");\n-        }\n-      }\n-      controls.clear();\n-      memories.clear();\n-    }\n-    for( uint i = 0; i < n->len(); ++i ) {\n-      Node *m = n->in(i);\n-      if (m != NULL) {\n-        nodes.push(m);\n-      }\n-    }\n-  }\n-}\n-#endif\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.cpp","additions":4,"deletions":130,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -34,0 +34,3 @@\n+  if (ShenandoahGCHeuristics == NULL) {\n+    vm_exit_during_initialization(\"Unknown -XX:ShenandoahGCHeuristics option (null)\");\n+  }\n@@ -35,12 +38,10 @@\n-  if (ShenandoahGCHeuristics != NULL) {\n-    if (strcmp(ShenandoahGCHeuristics, \"aggressive\") == 0) {\n-      return new ShenandoahAggressiveHeuristics(generation);\n-    } else if (strcmp(ShenandoahGCHeuristics, \"static\") == 0) {\n-      return new ShenandoahStaticHeuristics(generation);\n-    } else if (strcmp(ShenandoahGCHeuristics, \"adaptive\") == 0) {\n-      return new ShenandoahAdaptiveHeuristics(generation);\n-    } else if (strcmp(ShenandoahGCHeuristics, \"compact\") == 0) {\n-      return new ShenandoahCompactHeuristics(generation);\n-    } else {\n-      vm_exit_during_initialization(\"Unknown -XX:ShenandoahGCHeuristics option\");\n-    }\n+  if (strcmp(ShenandoahGCHeuristics, \"aggressive\") == 0) {\n+    return new ShenandoahAggressiveHeuristics(generation);\n+  } else if (strcmp(ShenandoahGCHeuristics, \"static\") == 0) {\n+    return new ShenandoahStaticHeuristics(generation);\n+  } else if (strcmp(ShenandoahGCHeuristics, \"adaptive\") == 0) {\n+    return new ShenandoahAdaptiveHeuristics(generation);\n+  } else if (strcmp(ShenandoahGCHeuristics, \"compact\") == 0) {\n+    return new ShenandoahCompactHeuristics(generation);\n+  } else {\n+    vm_exit_during_initialization(\"Unknown -XX:ShenandoahGCHeuristics option\");\n@@ -48,0 +49,1 @@\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/mode\/shenandoahMode.cpp","additions":14,"deletions":12,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"runtime\/java.hpp\"\n@@ -58,2 +59,2 @@\n-  if (ShenandoahGCHeuristics != NULL) {\n-    return new ShenandoahPassiveHeuristics(generation);\n+  if (ShenandoahGCHeuristics == NULL) {\n+    vm_exit_during_initialization(\"Unknown -XX:ShenandoahGCHeuristics option (null)\");\n@@ -61,2 +62,1 @@\n-  ShouldNotReachHere();\n-  return NULL;\n+  return new ShenandoahPassiveHeuristics(generation);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/mode\/shenandoahPassiveMode.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-#if !(defined AARCH64 || defined AMD64 || defined IA32)\n+#if !(defined AARCH64 || defined AMD64 || defined IA32 || defined PPC64)\n@@ -181,0 +181,2 @@\n+  CardTable::initialize_card_size();\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahArguments.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-  _read_byte_map_base = _read_byte_map - (uintptr_t(low_bound) >> card_shift);\n+  _read_byte_map_base = _read_byte_map - (uintptr_t(low_bound) >> card_shift());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCardTable.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -230,1 +230,1 @@\n-  if (nm != NULL && nm->oops_do_try_claim()) {\n+  if (nm != NULL) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahClosures.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,0 +56,2 @@\n+private:\n+  const GCCause::Cause _cause;\n@@ -57,2 +59,5 @@\n-  ShenandoahBreakpointGCScope() {\n-    ShenandoahBreakpoint::at_before_gc();\n+  ShenandoahBreakpointGCScope(GCCause::Cause cause) : _cause(cause) {\n+    if (cause == GCCause::_wb_breakpoint) {\n+      ShenandoahBreakpoint::start_gc();\n+      ShenandoahBreakpoint::at_before_gc();\n+    }\n@@ -62,1 +67,3 @@\n-    ShenandoahBreakpoint::at_after_gc();\n+    if (_cause == GCCause::_wb_breakpoint) {\n+      ShenandoahBreakpoint::at_after_gc();\n+    }\n@@ -67,0 +74,2 @@\n+private:\n+  const GCCause::Cause _cause;\n@@ -68,2 +77,4 @@\n-  ShenandoahBreakpointMarkScope() {\n-    ShenandoahBreakpoint::at_after_marking_started();\n+  ShenandoahBreakpointMarkScope(GCCause::Cause cause) : _cause(cause) {\n+    if (_cause == GCCause::_wb_breakpoint) {\n+      ShenandoahBreakpoint::at_after_marking_started();\n+    }\n@@ -73,1 +84,3 @@\n-    ShenandoahBreakpoint::at_before_marking_completed();\n+    if (_cause == GCCause::_wb_breakpoint) {\n+      ShenandoahBreakpoint::at_before_marking_completed();\n+    }\n@@ -92,4 +105,2 @@\n-  if (cause == GCCause::_wb_breakpoint) {\n-    ShenandoahBreakpoint::start_gc();\n-  }\n-  ShenandoahBreakpointGCScope breakpoint_gc_scope;\n+\n+  ShenandoahBreakpointGCScope breakpoint_gc_scope(cause);\n@@ -104,1 +115,1 @@\n-    ShenandoahBreakpointMarkScope breakpoint_mark_scope;\n+    ShenandoahBreakpointMarkScope breakpoint_mark_scope(cause);\n@@ -771,1 +782,1 @@\n-class ShenandoahConcurrentEvacUpdateThreadTask : public AbstractGangTask {\n+class ShenandoahConcurrentEvacUpdateThreadTask : public WorkerTask {\n@@ -777,1 +788,1 @@\n-    AbstractGangTask(\"Shenandoah Evacuate\/Update Concurrent Thread Roots\"),\n+    WorkerTask(\"Shenandoah Evacuate\/Update Concurrent Thread Roots\"),\n@@ -803,1 +814,3 @@\n-  ShenandoahBreakpoint::at_after_reference_processing_started();\n+  if (heap->gc_cause() == GCCause::_wb_breakpoint) {\n+    ShenandoahBreakpoint::at_after_reference_processing_started();\n+  }\n@@ -873,1 +886,1 @@\n-class ShenandoahConcurrentWeakRootsEvacUpdateTask : public AbstractGangTask {\n+class ShenandoahConcurrentWeakRootsEvacUpdateTask : public WorkerTask {\n@@ -878,1 +891,1 @@\n-  ShenandoahClassLoaderDataRoots<true \/* concurrent *\/, true \/* single thread*\/>\n+  ShenandoahClassLoaderDataRoots<true \/* concurrent *\/>\n@@ -885,1 +898,1 @@\n-    AbstractGangTask(\"Shenandoah Evacuate\/Update Concurrent Weak Roots\"),\n+    WorkerTask(\"Shenandoah Evacuate\/Update Concurrent Weak Roots\"),\n@@ -887,1 +900,1 @@\n-    _cld_roots(phase, ShenandoahHeap::heap()->workers()->active_workers()),\n+    _cld_roots(phase, ShenandoahHeap::heap()->workers()->active_workers(), false \/*heap iteration*\/),\n@@ -987,1 +1000,1 @@\n-class ShenandoahConcurrentRootsEvacUpdateTask : public AbstractGangTask {\n+class ShenandoahConcurrentRootsEvacUpdateTask : public WorkerTask {\n@@ -991,1 +1004,2 @@\n-  ShenandoahClassLoaderDataRoots<true \/*concurrent*\/, false \/*single threaded*\/> _cld_roots;\n+  ShenandoahClassLoaderDataRoots<true \/*concurrent*\/>\n+                                                _cld_roots;\n@@ -996,1 +1010,1 @@\n-    AbstractGangTask(\"Shenandoah Evacuate\/Update Concurrent Strong Roots\"),\n+    WorkerTask(\"Shenandoah Evacuate\/Update Concurrent Strong Roots\"),\n@@ -999,1 +1013,1 @@\n-    _cld_roots(phase, ShenandoahHeap::heap()->workers()->active_workers()),\n+    _cld_roots(phase, ShenandoahHeap::heap()->workers()->active_workers(), false \/*heap iteration*\/),\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":36,"deletions":22,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -47,27 +47,0 @@\n-class ShenandoahUpdateRootsTask : public AbstractGangTask {\n-private:\n-  ShenandoahRootUpdater*  _root_updater;\n-  bool                    _check_alive;\n-public:\n-  ShenandoahUpdateRootsTask(ShenandoahRootUpdater* root_updater, bool check_alive) :\n-    AbstractGangTask(\"Shenandoah Update Roots\"),\n-    _root_updater(root_updater),\n-    _check_alive(check_alive){\n-  }\n-\n-  void work(uint worker_id) {\n-    assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), \"Must be at a safepoint\");\n-    ShenandoahParallelWorkerSession worker_session(worker_id);\n-\n-    ShenandoahHeap* heap = ShenandoahHeap::heap();\n-    ShenandoahUpdateRefsClosure cl;\n-    if (_check_alive) {\n-      ShenandoahForwardedIsAliveClosure is_alive;\n-      _root_updater->roots_do<ShenandoahForwardedIsAliveClosure, ShenandoahUpdateRefsClosure>(worker_id, &is_alive, &cl);\n-    } else {\n-      AlwaysTrueClosure always_true;;\n-      _root_updater->roots_do<AlwaysTrueClosure, ShenandoahUpdateRefsClosure>(worker_id, &always_true, &cl);\n-    }\n-  }\n-};\n-\n@@ -75,1 +48,1 @@\n-class ShenandoahConcurrentMarkingTask : public AbstractGangTask {\n+class ShenandoahConcurrentMarkingTask : public WorkerTask {\n@@ -82,1 +55,1 @@\n-    AbstractGangTask(\"Shenandoah Concurrent Mark\"), _cm(cm), _terminator(terminator) {\n+    WorkerTask(\"Shenandoah Concurrent Mark\"), _cm(cm), _terminator(terminator) {\n@@ -126,1 +99,1 @@\n-class ShenandoahFinalMarkingTask : public AbstractGangTask {\n+class ShenandoahFinalMarkingTask : public WorkerTask {\n@@ -134,1 +107,1 @@\n-    AbstractGangTask(\"Shenandoah Final Mark\"), _cm(cm), _terminator(terminator), _dedup_string(dedup_string) {\n+    WorkerTask(\"Shenandoah Final Mark\"), _cm(cm), _terminator(terminator), _dedup_string(dedup_string) {\n@@ -172,1 +145,1 @@\n-class ShenandoahMarkConcurrentRootsTask : public AbstractGangTask {\n+class ShenandoahMarkConcurrentRootsTask : public WorkerTask {\n@@ -195,1 +168,1 @@\n-  AbstractGangTask(\"Shenandoah Concurrent Mark Roots\"),\n+  WorkerTask(\"Shenandoah Concurrent Mark Roots\"),\n@@ -216,1 +189,1 @@\n-  WorkGang* workers = heap->workers();\n+  WorkerThreads* workers = heap->workers();\n@@ -253,1 +226,1 @@\n-  WorkGang* workers = heap->workers();\n+  WorkerThreads* workers = heap->workers();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentMark.cpp","additions":8,"deletions":35,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -54,3 +54,3 @@\n-  _alloc_failure_waiters_lock(Mutex::leaf, \"ShenandoahAllocFailureGC_lock\", Monitor::_safepoint_check_always, true),\n-  _gc_waiters_lock(Mutex::leaf, \"ShenandoahRequestedGC_lock\", Monitor::_safepoint_check_always, true),\n-  _control_lock(Mutex::leaf - 1, \"ShenandoahControlGC_lock\", Monitor::_safepoint_check_never, true),\n+  _alloc_failure_waiters_lock(Mutex::safepoint - 1, \"ShenandoahAllocFailureGC_lock\", true),\n+  _gc_waiters_lock(Mutex::safepoint - 1, \"ShenandoahRequestedGC_lock\", true),\n+  _control_lock(Mutex::nosafepoint - 1, \"ShenandoahControlGC_lock\", true),\n@@ -113,2 +113,4 @@\n-    bool explicit_gc_requested = _gc_requested.is_set() && is_explicit_gc(_requested_gc_cause);\n-    bool implicit_gc_requested = _gc_requested.is_set() && is_implicit_gc(_requested_gc_cause);\n+    bool is_gc_requested = _gc_requested.is_set();\n+    GCCause::Cause requested_gc_cause = _requested_gc_cause;\n+    bool explicit_gc_requested = is_gc_requested && is_explicit_gc(requested_gc_cause);\n+    bool implicit_gc_requested = is_gc_requested && is_implicit_gc(requested_gc_cause);\n@@ -158,0 +160,1 @@\n+      cause = requested_gc_cause;\n@@ -159,1 +162,0 @@\n-      cause = _requested_gc_cause;\n@@ -175,0 +177,1 @@\n+      cause = requested_gc_cause;\n@@ -176,1 +179,0 @@\n-      cause = _requested_gc_cause;\n@@ -782,1 +784,3 @@\n-    _gc_requested.set();\n+    \/\/ Although setting gc request is under _gc_waiters_lock, but read side (run_service())\n+    \/\/ does not take the lock. We need to enforce following order, so that read side sees\n+    \/\/ latest requested gc cause when the flag is set.\n@@ -784,0 +788,1 @@\n+    _gc_requested.set();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":13,"deletions":8,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -147,2 +147,4 @@\n-      \/\/ No fallthrough. Continue mark, handed over from concurrent mark\n-      if (_degen_point == ShenandoahDegenPoint::_degenerated_mark) {\n+      \/\/ No fallthrough. Continue mark, handed over from concurrent mark if\n+      \/\/ concurrent mark has yet completed\n+      if (_degen_point == ShenandoahDegenPoint::_degenerated_mark &&\n+          heap->is_concurrent_mark_in_progress()) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahDegeneratedGC.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -213,1 +213,1 @@\n-      size_t usable_free = (free \/ CardTable::card_size) << CardTable::card_shift;\n+      size_t usable_free = (free \/ CardTable::card_size()) << CardTable::card_shift();\n@@ -216,1 +216,1 @@\n-        usable_free -= CardTable::card_size;\n+        usable_free -= CardTable::card_size();\n@@ -224,1 +224,1 @@\n-        result = r->allocate_aligned(size, req, CardTable::card_size);\n+        result = r->allocate_aligned(size, req, CardTable::card_size());\n@@ -248,1 +248,1 @@\n-    size_t usable_free = (free \/ CardTable::card_size) << CardTable::card_shift;\n+    size_t usable_free = (free \/ CardTable::card_size()) << CardTable::card_shift();\n@@ -253,1 +253,1 @@\n-      usable_free -= CardTable::card_size;\n+      usable_free -= CardTable::card_size();\n@@ -256,1 +256,1 @@\n-      assert(size % CardTable::card_size_in_words == 0, \"PLAB size must be multiple of remembered set card size\");\n+      assert(size % CardTable::card_size_in_words() == 0, \"PLAB size must be multiple of remembered set card size\");\n@@ -258,1 +258,1 @@\n-      result = r->allocate_aligned(size, req, CardTable::card_size);\n+      result = r->allocate_aligned(size, req, CardTable::card_size());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"gc\/shared\/workerThread.hpp\"\n@@ -64,1 +65,0 @@\n-#include \"gc\/shared\/workgroup.hpp\"\n@@ -68,1 +68,1 @@\n-class ShenandoahReconstructRememberedSetTask : public AbstractGangTask {\n+class ShenandoahReconstructRememberedSetTask : public WorkerTask {\n@@ -74,1 +74,1 @@\n-    AbstractGangTask(\"Shenandoah Reset Bitmap\") { }\n+    WorkerTask(\"Shenandoah Reset Bitmap\") { }\n@@ -387,1 +387,1 @@\n-class ShenandoahPrepareForCompactionTask : public AbstractGangTask {\n+class ShenandoahPrepareForCompactionTask : public WorkerTask {\n@@ -691,1 +691,1 @@\n-    AbstractGangTask(\"Shenandoah Prepare For Compaction\"),\n+    WorkerTask(\"Shenandoah Prepare For Compaction\"),\n@@ -1109,1 +1109,1 @@\n-class ShenandoahAdjustPointersTask : public AbstractGangTask {\n+class ShenandoahAdjustPointersTask : public WorkerTask {\n@@ -1116,1 +1116,1 @@\n-    AbstractGangTask(\"Shenandoah Adjust Pointers\"),\n+    WorkerTask(\"Shenandoah Adjust Pointers\"),\n@@ -1133,1 +1133,1 @@\n-class ShenandoahAdjustRootPointersTask : public AbstractGangTask {\n+class ShenandoahAdjustRootPointersTask : public WorkerTask {\n@@ -1139,1 +1139,1 @@\n-    AbstractGangTask(\"Shenandoah Adjust Root Pointers\"),\n+    WorkerTask(\"Shenandoah Adjust Root Pointers\"),\n@@ -1157,1 +1157,1 @@\n-  WorkGang* workers = heap->workers();\n+  WorkerThreads* workers = heap->workers();\n@@ -1186,1 +1186,1 @@\n-    size_t size = (size_t)p->size();\n+    size_t size = p->size();\n@@ -1197,1 +1197,1 @@\n-class ShenandoahCompactObjectsTask : public AbstractGangTask {\n+class ShenandoahCompactObjectsTask : public WorkerTask {\n@@ -1204,1 +1204,1 @@\n-    AbstractGangTask(\"Shenandoah Compact Objects\"),\n+    WorkerTask(\"Shenandoah Compact Objects\"),\n@@ -1360,1 +1360,1 @@\n-class ShenandoahMCResetCompleteBitmapTask : public AbstractGangTask {\n+class ShenandoahMCResetCompleteBitmapTask : public WorkerTask {\n@@ -1366,1 +1366,1 @@\n-    AbstractGangTask(\"Shenandoah Reset Bitmap\") {\n+    WorkerTask(\"Shenandoah Reset Bitmap\") {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"gc\/shared\/workgroup.hpp\"\n+#include \"gc\/shared\/workerThread.hpp\"\n@@ -56,1 +56,1 @@\n-class ShenandoahUpdateRootsTask : public AbstractGangTask {\n+class ShenandoahUpdateRootsTask : public WorkerTask {\n@@ -62,1 +62,1 @@\n-    AbstractGangTask(\"Shenandoah Update Roots\"),\n+    WorkerTask(\"Shenandoah Update Roots\"),\n@@ -100,1 +100,1 @@\n-  WorkGang* workers = heap->workers();\n+  WorkerThreads* workers = heap->workers();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGC.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -101,1 +101,1 @@\n-class ShenandoahPretouchHeapTask : public AbstractGangTask {\n+class ShenandoahPretouchHeapTask : public WorkerTask {\n@@ -107,1 +107,1 @@\n-    AbstractGangTask(\"Shenandoah Pretouch Heap\"),\n+    WorkerTask(\"Shenandoah Pretouch Heap\"),\n@@ -121,1 +121,1 @@\n-class ShenandoahPretouchBitmapTask : public AbstractGangTask {\n+class ShenandoahPretouchBitmapTask : public WorkerTask {\n@@ -129,1 +129,1 @@\n-    AbstractGangTask(\"Shenandoah Pretouch Bitmap\"),\n+    WorkerTask(\"Shenandoah Pretouch Bitmap\"),\n@@ -236,3 +236,1 @@\n-  _workers = new ShenandoahWorkGang(\"Shenandoah GC Threads\", _max_workers,\n-                            \/* are_GC_task_threads *\/ true,\n-                            \/* are_ConcurrentGC_threads *\/ true);\n+  _workers = new ShenandoahWorkerThreads(\"Shenandoah GC Threads\", _max_workers);\n@@ -246,4 +244,1 @@\n-    _safepoint_workers = new ShenandoahWorkGang(\"Safepoint Cleanup Thread\",\n-                                                ParallelGCThreads,\n-                      \/* are_GC_task_threads *\/ false,\n-                 \/* are_ConcurrentGC_threads *\/ false);\n+    _safepoint_workers = new ShenandoahWorkerThreads(\"Safepoint Cleanup Thread\", ParallelGCThreads);\n@@ -474,1 +469,1 @@\n-    ShouldNotReachHere();\n+    vm_exit_during_initialization(\"Unknown -XX:ShenandoahGCMode option (null)\");\n@@ -631,1 +626,1 @@\n-  \/\/ Now, we will let WorkGang to initialize gclab when new worker is created.\n+  \/\/ Now, we will let WorkerThreads to initialize gclab when new worker is created.\n@@ -908,1 +903,1 @@\n-  size_t unalignment = new_size % CardTable::card_size_in_words;\n+  size_t unalignment = new_size % CardTable::card_size_in_words();\n@@ -910,1 +905,1 @@\n-    new_size = new_size - unalignment + CardTable::card_size_in_words;\n+    new_size = new_size - unalignment + CardTable::card_size_in_words();\n@@ -1291,1 +1286,1 @@\n-class ShenandoahEvacuationTask : public AbstractGangTask {\n+class ShenandoahEvacuationTask : public WorkerTask {\n@@ -1300,1 +1295,1 @@\n-    AbstractGangTask(\"Shenandoah Evacuation\"),\n+    WorkerTask(\"Shenandoah Evacuation\"),\n@@ -1340,1 +1335,1 @@\n-class ShenandoahGenerationalEvacuationTask : public AbstractGangTask {\n+class ShenandoahGenerationalEvacuationTask : public WorkerTask {\n@@ -1349,1 +1344,1 @@\n-    AbstractGangTask(\"Shenandoah Evacuation\"),\n+    WorkerTask(\"Shenandoah Evacuation\"),\n@@ -1770,1 +1765,2 @@\n-  ShenandoahHeapIterationRootScanner rp;\n+  uint n_workers = safepoint_workers() != NULL ? safepoint_workers()->active_workers() : 1;\n+  ShenandoahHeapIterationRootScanner rp(n_workers);\n@@ -1818,1 +1814,1 @@\n-class ShenandoahParallelObjectIterator : public ParallelObjectIterator {\n+class ShenandoahParallelObjectIterator : public ParallelObjectIteratorImpl {\n@@ -1917,1 +1913,1 @@\n-ParallelObjectIterator* ShenandoahHeap::parallel_object_iterator(uint workers) {\n+ParallelObjectIteratorImpl* ShenandoahHeap::parallel_object_iterator(uint workers) {\n@@ -1935,1 +1931,1 @@\n-class ShenandoahParallelHeapRegionTask : public AbstractGangTask {\n+class ShenandoahParallelHeapRegionTask : public WorkerTask {\n@@ -1946,1 +1942,1 @@\n-          AbstractGangTask(\"Shenandoah Parallel Region Operation\"),\n+          WorkerTask(\"Shenandoah Parallel Region Operation\"),\n@@ -2398,1 +2394,1 @@\n-class ShenandoahUpdateHeapRefsTask : public AbstractGangTask {\n+class ShenandoahUpdateHeapRefsTask : public WorkerTask {\n@@ -2406,1 +2402,1 @@\n-    AbstractGangTask(\"Shenandoah Update References\"),\n+    WorkerTask(\"Shenandoah Update References\"),\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":22,"deletions":26,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-class ShenandoahWorkGang;\n+class ShenandoahWorkerThreads;\n@@ -257,2 +257,2 @@\n-  ShenandoahWorkGang* _workers;\n-  ShenandoahWorkGang* _safepoint_workers;\n+  ShenandoahWorkerThreads* _workers;\n+  ShenandoahWorkerThreads* _safepoint_workers;\n@@ -264,2 +264,2 @@\n-  WorkGang* workers() const;\n-  WorkGang* safepoint_workers();\n+  WorkerThreads* workers() const;\n+  WorkerThreads* safepoint_workers();\n@@ -648,1 +648,1 @@\n-  virtual ParallelObjectIterator* parallel_object_iterator(uint workers);\n+  virtual ParallelObjectIteratorImpl* parallel_object_iterator(uint workers);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-inline WorkGang* ShenandoahHeap::workers() const {\n+inline WorkerThreads* ShenandoahHeap::workers() const {\n@@ -74,1 +74,1 @@\n-inline WorkGang* ShenandoahHeap::safepoint_workers() {\n+inline WorkerThreads* ShenandoahHeap::safepoint_workers() {\n@@ -763,1 +763,1 @@\n-    int size = obj->size();\n+    size_t size = obj->size();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-\n+#include \"logging\/log.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkingContext.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -274,1 +274,0 @@\n-  ShenandoahReentrantLocker data_locker(data != NULL ? data->lock() : NULL);\n@@ -279,0 +278,3 @@\n+    \/\/ Prevent updating a nmethod while concurrent iteration is in progress.\n+    wait_until_concurrent_iteration_done();\n+    ShenandoahReentrantLocker data_locker(data->lock());\n@@ -281,0 +283,2 @@\n+    \/\/ For a new nmethod, we can safely append it to the list, because\n+    \/\/ concurrent iteration will not touch it.\n@@ -385,0 +389,1 @@\n+  assert(CodeCache_lock->owned_by_self(), \"Must have CodeCache_lock held\");\n@@ -390,0 +395,1 @@\n+  assert(CodeCache_lock->owned_by_self(), \"Must have CodeCache_lock held\");\n@@ -496,1 +502,1 @@\n-    size_t cur = Atomic::fetch_and_add(&_claimed, stride);\n+    size_t cur = Atomic::fetch_and_add(&_claimed, stride, memory_order_relaxed);\n@@ -523,1 +529,1 @@\n-    size_t cur = Atomic::fetch_and_add(&_claimed, stride);\n+    size_t cur = Atomic::fetch_and_add(&_claimed, stride, memory_order_relaxed);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahNMethod.cpp","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-class ShenandoahConcurrentCoalesceAndFillTask : public AbstractGangTask {\n+class ShenandoahConcurrentCoalesceAndFillTask : public WorkerTask {\n@@ -49,1 +49,1 @@\n-    AbstractGangTask(\"Shenandoah Concurrent Coalesce and Fill\"),\n+    WorkerTask(\"Shenandoah Concurrent Coalesce and Fill\"),\n@@ -229,1 +229,1 @@\n-  WorkGang* workers = heap->workers();\n+  WorkerThreads* workers = heap->workers();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGC.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n-class ShenandoahPurgeSATBTask : public AbstractGangTask {\n+class ShenandoahPurgeSATBTask : public WorkerTask {\n@@ -103,1 +103,1 @@\n-    AbstractGangTask(\"Purge SATB\"),\n+    WorkerTask(\"Purge SATB\"),\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/shared\/workerThread.hpp\"\n@@ -347,1 +348,0 @@\n-  assert(worker_id != ShenandoahThreadLocalData::INVALID_WORKER_ID, \"need valid worker ID\");\n@@ -372,1 +372,1 @@\n-  uint worker_id = ShenandoahThreadLocalData::worker_id(Thread::current());\n+  uint worker_id = WorkerThread::worker_id();\n@@ -470,1 +470,1 @@\n-  uint worker_id = Atomic::add(&_iterate_discovered_list_id, 1U) - 1;\n+  uint worker_id = Atomic::add(&_iterate_discovered_list_id, 1U, memory_order_relaxed) - 1;\n@@ -477,1 +477,1 @@\n-    worker_id = Atomic::add(&_iterate_discovered_list_id, 1U) - 1;\n+    worker_id = Atomic::add(&_iterate_discovered_list_id, 1U, memory_order_relaxed) - 1;\n@@ -481,1 +481,1 @@\n-class ShenandoahReferenceProcessorTask : public AbstractGangTask {\n+class ShenandoahReferenceProcessorTask : public WorkerTask {\n@@ -489,1 +489,1 @@\n-    AbstractGangTask(\"ShenandoahReferenceProcessorTask\"),\n+    WorkerTask(\"ShenandoahReferenceProcessorTask\"),\n@@ -508,1 +508,1 @@\n-void ShenandoahReferenceProcessor::process_references(ShenandoahPhaseTimings::Phase phase, WorkGang* workers, bool concurrent) {\n+void ShenandoahReferenceProcessor::process_references(ShenandoahPhaseTimings::Phase phase, WorkerThreads* workers, bool concurrent) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahReferenceProcessor.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"gc\/shared\/workgroup.hpp\"\n+#include \"gc\/shared\/workerThread.hpp\"\n@@ -69,1 +69,1 @@\n-class ShenandoahSTWMarkTask : public AbstractGangTask {\n+class ShenandoahSTWMarkTask : public WorkerTask {\n@@ -79,1 +79,1 @@\n-  AbstractGangTask(\"Shenandoah STW mark\"),\n+  WorkerTask(\"Shenandoah STW mark\"),\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahSTWMark.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-  _card_shift = CardTable::card_shift;\n+  _card_shift = CardTable::card_shift();\n@@ -44,1 +44,1 @@\n-  _whole_heap_end = _whole_heap_base + total_card_count * CardTable::card_size;\n+  _whole_heap_end = _whole_heap_base + total_card_count * CardTable::card_size();\n@@ -91,1 +91,1 @@\n-  AbstractGangTask(\"Scan Remembered Set\"),\n+  WorkerTask(\"Scan Remembered Set\"),\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -210,1 +210,1 @@\n-#include \"gc\/shared\/workgroup.hpp\"\n+#include \"gc\/shared\/workerThread.hpp\"\n@@ -288,1 +288,1 @@\n-    size_t num_cards = word_count \/ CardTable::card_size_in_words;\n+    size_t num_cards = word_count \/ CardTable::card_size_in_words();\n@@ -307,1 +307,1 @@\n-    size_t num_cards = word_count \/ CardTable::card_size_in_words;\n+    size_t num_cards = word_count \/ CardTable::card_size_in_words();\n@@ -1007,1 +1007,1 @@\n-class ShenandoahScanRememberedTask : public AbstractGangTask {\n+class ShenandoahScanRememberedTask : public WorkerTask {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-  return _whole_heap_base + CardTable::card_size_in_words * card_index;\n+  return _whole_heap_base + CardTable::card_size_in_words() * card_index;\n@@ -118,1 +118,1 @@\n-  if (((unsigned long long) (p + num_heap_words)) & (CardTable::card_size - 1)) {\n+  if (((unsigned long long) (p + num_heap_words)) & (CardTable::card_size() - 1)) {\n@@ -144,1 +144,1 @@\n-  if (((unsigned long long) (p + num_heap_words)) & (CardTable::card_size - 1)) {\n+  if (((unsigned long long) (p + num_heap_words)) & (CardTable::card_size() - 1)) {\n@@ -167,2 +167,2 @@\n-  assert(((((unsigned long long) from) & (CardTable::card_size - 1)) == 0) &&\n-         ((((unsigned long long) to) & (CardTable::card_size - 1)) == 0),\n+  assert(((((unsigned long long) from) & (CardTable::card_size() - 1)) == 0) &&\n+         ((((unsigned long long) to) & (CardTable::card_size() - 1)) == 0),\n@@ -171,1 +171,1 @@\n-  size_t num_cards = (to - from) \/ CardTable::card_size_in_words;\n+  size_t num_cards = (to - from) \/ CardTable::card_size_in_words();\n@@ -213,1 +213,1 @@\n-  size_t card_at_end = card_at_start + ((address + length_in_words) - card_start_address) \/ CardTable::card_size_in_words;\n+  size_t card_at_end = card_at_start + ((address + length_in_words) - card_start_address) \/ CardTable::card_size_in_words();\n@@ -401,2 +401,2 @@\n-  if (max_offset > CardTable::card_size_in_words) {\n-    max_offset = CardTable::card_size_in_words;\n+  if (max_offset > CardTable::card_size_in_words()) {\n+    max_offset = CardTable::card_size_in_words();\n@@ -420,1 +420,1 @@\n-    size_t end_card_index = index + offset \/ CardTable::card_size_in_words;\n+    size_t end_card_index = index + offset \/ CardTable::card_size_in_words();\n@@ -518,1 +518,1 @@\n-    + count * ShenandoahCardCluster<RememberedSet>::CardsPerCluster * CardTable::card_size_in_words;\n+    + count * ShenandoahCardCluster<RememberedSet>::CardsPerCluster * CardTable::card_size_in_words();\n@@ -534,1 +534,1 @@\n-          HeapWord *endp = p + CardTable::card_size_in_words;\n+          HeapWord *endp = p + CardTable::card_size_in_words();\n@@ -544,1 +544,1 @@\n-            next_card_index = card_index + (endp - card_start) \/ CardTable::card_size_in_words;\n+            next_card_index = card_index + (endp - card_start) \/ CardTable::card_size_in_words();\n@@ -583,1 +583,1 @@\n-            card_index = card_index + (p - card_start) \/ CardTable::card_size_in_words;\n+            card_index = card_index + (p - card_start) \/ CardTable::card_size_in_words();\n@@ -607,1 +607,1 @@\n-          last_card = card_index + (nextp - card_start) \/ CardTable::card_size_in_words;\n+          last_card = card_index + (nextp - card_start) \/ CardTable::card_size_in_words();\n@@ -647,1 +647,1 @@\n-          last_card = card_index + (nextp - card_start) \/ CardTable::card_size_in_words;\n+          last_card = card_index + (nextp - card_start) \/ CardTable::card_size_in_words();\n@@ -701,1 +701,1 @@\n-  unsigned int cluster_size = CardTable::card_size_in_words * ShenandoahCardCluster<ShenandoahDirectCardMarkRememberedSet>::CardsPerCluster;\n+  unsigned int cluster_size = CardTable::card_size_in_words() * ShenandoahCardCluster<ShenandoahDirectCardMarkRememberedSet>::CardsPerCluster;\n@@ -729,1 +729,1 @@\n-      unsigned int cluster_size = CardTable::card_size_in_words *\n+      unsigned int cluster_size = CardTable::card_size_in_words() *\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.inline.hpp","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -39,3 +39,0 @@\n-public:\n-  static const uint INVALID_WORKER_ID = uint(-1);\n-\n@@ -80,1 +77,0 @@\n-    _worker_id(INVALID_WORKER_ID),\n@@ -129,10 +125,0 @@\n-  static void set_worker_id(Thread* thread, uint id) {\n-    assert(thread->is_Worker_thread(), \"Must be a worker thread\");\n-    data(thread)->_worker_id = id;\n-  }\n-\n-  static uint worker_id(Thread* thread) {\n-    assert(thread->is_Worker_thread(), \"Must be a worker thread\");\n-    return data(thread)->_worker_id;\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahThreadLocalData.hpp","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -126,3 +126,1 @@\n-  assert(!Thread::current()->is_Worker_thread() &&\n-              (Thread::current()->is_VM_thread() ||\n-               Thread::current()->is_ConcurrentGC_thread()),\n+  assert(Thread::current()->is_VM_thread() || Thread::current()->is_ConcurrentGC_thread(),\n@@ -163,4 +161,2 @@\n-ShenandoahWorkerSession::ShenandoahWorkerSession(uint worker_id) : _worker_id(worker_id) {\n-  Thread* thr = Thread::current();\n-  assert(ShenandoahThreadLocalData::worker_id(thr) == ShenandoahThreadLocalData::INVALID_WORKER_ID, \"Already set\");\n-  ShenandoahThreadLocalData::set_worker_id(thr, worker_id);\n+ShenandoahWorkerSession::ShenandoahWorkerSession(uint worker_id) {\n+  assert(worker_id == WorkerThread::worker_id(), \"Wrong worker id\");\n@@ -174,8 +170,1 @@\n-  _event.commit(GCId::current(), _worker_id, ShenandoahPhaseTimings::phase_name(ShenandoahGCPhase::current_phase()));\n-}\n-ShenandoahWorkerSession::~ShenandoahWorkerSession() {\n-#ifdef ASSERT\n-  Thread* thr = Thread::current();\n-  assert(ShenandoahThreadLocalData::worker_id(thr) != ShenandoahThreadLocalData::INVALID_WORKER_ID, \"Must be set\");\n-  ShenandoahThreadLocalData::set_worker_id(thr, ShenandoahThreadLocalData::INVALID_WORKER_ID);\n-#endif\n+  _event.commit(GCId::current(), WorkerThread::worker_id(), ShenandoahPhaseTimings::phase_name(ShenandoahGCPhase::current_phase()));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahUtils.cpp","additions":4,"deletions":15,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2017, 2021, Red Hat, Inc. All rights reserved.\n@@ -33,0 +33,1 @@\n+#include \"gc\/shared\/workerThread.hpp\"\n@@ -178,3 +179,0 @@\n-  uint _worker_id;\n-\n-  ~ShenandoahWorkerSession();\n@@ -184,4 +182,1 @@\n-    Thread* thr = Thread::current();\n-    uint id = ShenandoahThreadLocalData::worker_id(thr);\n-    assert(id != ShenandoahThreadLocalData::INVALID_WORKER_ID, \"Worker session has not been created\");\n-    return id;\n+    return WorkerThread::worker_id();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahUtils.hpp","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -504,1 +504,1 @@\n-class ShenandoahVerifierReachableTask : public AbstractGangTask {\n+class ShenandoahVerifierReachableTask : public WorkerTask {\n@@ -518,1 +518,1 @@\n-    AbstractGangTask(\"Shenandoah Verifier Reachable Objects\"),\n+    WorkerTask(\"Shenandoah Verifier Reachable Objects\"),\n@@ -567,1 +567,1 @@\n-class ShenandoahVerifierMarkedRegionTask : public AbstractGangTask {\n+class ShenandoahVerifierMarkedRegionTask : public WorkerTask {\n@@ -583,1 +583,1 @@\n-          AbstractGangTask(\"Shenandoah Verifier Marked Objects\"),\n+          WorkerTask(\"Shenandoah Verifier Marked Objects\"),\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVerifier.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"logging\/logAsyncWriter.hpp\"\n@@ -56,0 +57,16 @@\n+bool LogFileStreamOutput::set_option(const char* key, const char* value, outputStream* errstream) {\n+  bool success = false;\n+  if (strcmp(FoldMultilinesOptionKey, key) == 0) {\n+    if (strcmp(value, \"true\") == 0) {\n+      _fold_multilines = true;\n+      success = true;\n+    } else if (strcmp(value, \"false\") == 0) {\n+      _fold_multilines = false;\n+      success = true;\n+    } else {\n+      errstream->print_cr(\"Invalid option: %s must be 'true' or 'false'.\", key);\n+    }\n+  }\n+  return success;\n+}\n+\n@@ -108,1 +125,1 @@\n-int LogFileStreamOutput::write_internal(const char* msg) {\n+int LogFileStreamOutput::write_internal(const LogDecorations& decorations, const char* msg) {\n@@ -110,0 +127,7 @@\n+  const bool use_decorations = !_decorators.is_empty();\n+\n+  if (use_decorations) {\n+    WRITE_LOG_WITH_RESULT_CHECK(write_decorations(decorations), written);\n+    WRITE_LOG_WITH_RESULT_CHECK(jio_fprintf(_stream, \" \"), written);\n+  }\n+\n@@ -132,0 +156,5 @@\n+int LogFileStreamOutput::write_blocking(const LogDecorations& decorations, const char* msg) {\n+  int written = write_internal(decorations, msg);\n+  return flush() ? written : -1;\n+}\n+\n@@ -133,1 +162,5 @@\n-  const bool use_decorations = !_decorators.is_empty();\n+  AsyncLogWriter* aio_writer = AsyncLogWriter::instance();\n+  if (aio_writer != nullptr) {\n+    aio_writer->enqueue(*this, decorations, msg);\n+    return 0;\n+  }\n@@ -135,6 +168,1 @@\n-  int written = 0;\n-  if (use_decorations) {\n-    WRITE_LOG_WITH_RESULT_CHECK(write_decorations(decorations), written);\n-    WRITE_LOG_WITH_RESULT_CHECK(jio_fprintf(_stream, \" \"), written);\n-  }\n-  written += write_internal(msg);\n+  int written = write_internal(decorations, msg);\n@@ -147,1 +175,5 @@\n-  const bool use_decorations = !_decorators.is_empty();\n+  AsyncLogWriter* aio_writer = AsyncLogWriter::instance();\n+  if (aio_writer != nullptr) {\n+    aio_writer->enqueue(*this, msg_iterator);\n+    return 0;\n+  }\n@@ -152,5 +184,1 @@\n-    if (use_decorations) {\n-      WRITE_LOG_WITH_RESULT_CHECK(write_decorations(msg_iterator.decorations()), written);\n-      WRITE_LOG_WITH_RESULT_CHECK(jio_fprintf(_stream, \" \"), written);\n-    }\n-    written += write_internal(msg_iterator.message());\n+    written += write_internal(msg_iterator.decorations(), msg_iterator.message());\n@@ -161,0 +189,7 @@\n+\n+void LogFileStreamOutput::describe(outputStream *out) {\n+  LogOutput::describe(out);\n+  out->print(\" \");\n+\n+  out->print(\"foldmultilines=%s\", _fold_multilines ? \"true\" : \"false\");\n+}\n","filename":"src\/hotspot\/share\/logging\/logFileStreamOutput.cpp","additions":49,"deletions":14,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -45,0 +45,2 @@\n+  static const char* const FoldMultilinesOptionKey;\n+  bool                _fold_multilines;\n@@ -47,2 +49,0 @@\n-  int write_internal(const char* msg);\n-  static const char* const FoldMultilinesOptionKey;\n@@ -52,2 +52,1 @@\n-  bool                _fold_multilines;\n-  LogFileStreamOutput(FILE *stream) : _write_error_is_shown(false), _stream(stream), _fold_multilines(false) {\n+  LogFileStreamOutput(FILE *stream) : _fold_multilines(false), _write_error_is_shown(false), _stream(stream) {\n@@ -61,0 +60,1 @@\n+  int write_internal(const LogDecorations& decorations, const char* msg);\n@@ -64,0 +64,1 @@\n+  virtual bool set_option(const char* key, const char* value, outputStream* errstream);\n@@ -66,0 +67,3 @@\n+  \/\/ Write API used by AsyncLogWriter\n+  virtual int write_blocking(const LogDecorations& decorations, const char* msg);\n+  virtual void describe(outputStream* out);\n","filename":"src\/hotspot\/share\/logging\/logFileStreamOutput.hpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -49,0 +49,4 @@\n+hotspot_runtime_no_cds = \\\n+  runtime \\\n+  -runtime\/cds\n+\n@@ -74,0 +78,7 @@\n+# Test sets for running inside container environment\n+hotspot_containers_extended = \\\n+  runtime \\\n+  serviceability \\\n+  vmTestbase\/nsk\/jvmti \\\n+  vmTestbase\/nsk\/monitoring\n+\n@@ -97,0 +108,3 @@\n+hotspot_compiler_arraycopy = \\\n+  compiler\/arraycopy\/stress\n+\n@@ -118,1 +132,2 @@\n-  compiler\/gcbarriers\/PreserveFPRegistersTest.java\n+  compiler\/gcbarriers\/PreserveFPRegistersTest.java \\\n+  :hotspot_compiler_arraycopy\n@@ -135,0 +150,1 @@\n+  -:hotspot_slow_compiler\n@@ -176,0 +192,44 @@\n+tier2_compiler = \\\n+  compiler\/allocation\/ \\\n+  compiler\/arguments\/ \\\n+  compiler\/calls\/ \\\n+  compiler\/cha\/ \\\n+  compiler\/controldependency\/ \\\n+  compiler\/conversions\/ \\\n+  compiler\/codegen\/ \\\n+  compiler\/linkage\/ \\\n+  compiler\/loopstripmining\/ \\\n+  compiler\/loopopts\/Test7052494.java \\\n+  compiler\/longcountedloops\/ \\\n+  compiler\/intrinsics\/bmi \\\n+  compiler\/intrinsics\/mathexact \\\n+  compiler\/intrinsics\/sha \\\n+  compiler\/intrinsics\/bigInteger\/TestMultiplyToLen.java \\\n+  compiler\/intrinsics\/zip\/TestAdler32.java \\\n+  compiler\/membars\/ \\\n+  compiler\/onSpinWait\/ \\\n+  compiler\/parsing\/ \\\n+  compiler\/rangechecks\/ \\\n+  compiler\/reflection\/ \\\n+  compiler\/rtm\/ \\\n+  compiler\/runtime\/Test6826736.java \\\n+  compiler\/stable\/ \\\n+  compiler\/stringopts\/ \\\n+  -:tier1_compiler \\\n+  -:hotspot_slow_compiler\n+\n+tier3_compiler = \\\n+  compiler\/c2\/ \\\n+  compiler\/ciReplay\/ \\\n+  compiler\/compilercontrol\/ \\\n+  compiler\/debug\/ \\\n+  compiler\/oracle\/ \\\n+  compiler\/print\/ \\\n+  compiler\/relocations\/ \\\n+  compiler\/tiered\/ \\\n+  compiler\/vectorapi\/ \\\n+  compiler\/whitebox\/ \\\n+  :hotspot_slow_compiler \\\n+  -:tier1_compiler \\\n+  -:tier2_compiler\n+\n@@ -214,1 +274,0 @@\n-  -gc\/CriticalNativeArgs.java \\\n@@ -229,3 +288,1 @@\n-tier2_gc_epsilon = \\\n-  gc\/CriticalNativeArgs.java \\\n-  gc\/stress\/CriticalNativeStress.java\n+tier2_gc_epsilon =\n@@ -279,2 +336,0 @@\n-  gc\/CriticalNativeArgs.java \\\n-  gc\/stress\/CriticalNativeStress.java \\\n@@ -352,0 +407,2 @@\n+hotspot_cds_only = \\\n+  runtime\/cds\/\n@@ -373,0 +430,1 @@\n+ -runtime\/cds\/appcds\/DumpingWithNoCoops.java \\\n@@ -374,0 +432,1 @@\n+ -runtime\/cds\/appcds\/LambdaContainsOldInf.java \\\n@@ -377,0 +436,1 @@\n+ -runtime\/cds\/appcds\/LambdaWithJavaAgent.java \\\n@@ -386,1 +446,2 @@\n- -runtime\/cds\/appcds\/TestZGCWithCDS.java \\\n+ -runtime\/cds\/appcds\/TestSerialGCWithCDS.java \\\n+ -runtime\/cds\/appcds\/TestZGCWithCDS.java \\\n@@ -418,0 +479,13 @@\n+# No need to run every test with EpsilonGC. A small subset will provide enough\n+# coverage. Also avoid some tests that may OOM.\n+hotspot_cds_epsilongc = \\\n+  runtime\/cds\/appcds\/HelloTest.java \\\n+  runtime\/cds\/appcds\/MultiProcessSharing.java \\\n+  runtime\/cds\/appcds\/StaticArchiveWithLambda.java \\\n+  runtime\/cds\/appcds\/cacheObject \\\n+  runtime\/cds\/appcds\/customLoader\/ParallelTestSingleFP.java \\\n+  runtime\/cds\/appcds\/dynamicArchive\/HelloDynamic.java \\\n+  runtime\/cds\/appcds\/javaldr \\\n+  runtime\/cds\/appcds\/jigsaw \\\n+  runtime\/cds\/appcds\/loaderConstraints\n+\n@@ -476,0 +550,1 @@\n+  :tier2_compiler \\\n@@ -481,0 +556,1 @@\n+  :tier3_compiler \\\n@@ -483,0 +559,7 @@\n+# Everything that is not in other tiers, but not apps\n+tier4 = \\\n+  :hotspot_all_no_apps \\\n+ -:tier1 \\\n+ -:tier2 \\\n+ -:tier3\n+\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":91,"deletions":8,"binary":false,"changes":99,"status":"modified"}]}