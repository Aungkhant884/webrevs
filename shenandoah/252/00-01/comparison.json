{"files":[{"patch":"@@ -3135,167 +3135,0 @@\n-\/\/ Assure that the remember set has a dirty card everywhere there is an interesting pointer.\n-\/\/ This examines the read_card_table between bottom() and top() since all PLABS are retired\n-\/\/ before the safepoint for init_mark.  Actually, we retire them before update-references and don't\n-\/\/ restore them until the start of evacuation.\n-void ShenandoahHeap::verify_rem_set_at_mark() {\n-  shenandoah_assert_safepoint();\n-  assert(mode()->is_generational(), \"Only verify remembered set for generational operational modes\");\n-\n-  ShenandoahRegionIterator iterator;\n-  RememberedScanner* scanner = card_scan();\n-  ShenandoahVerifyRemSetClosure check_interesting_pointers(true);\n-  ShenandoahMarkingContext* ctx;\n-\n-  log_debug(gc)(\"Verifying remembered set at %s mark\", doing_mixed_evacuations()? \"mixed\": \"young\");\n-\n-  if (is_old_bitmap_stable() || active_generation()->is_global()) {\n-    ctx = complete_marking_context();\n-  } else {\n-    ctx = nullptr;\n-  }\n-\n-  while (iterator.has_next()) {\n-    ShenandoahHeapRegion* r = iterator.next();\n-    HeapWord* tams = ctx? ctx->top_at_mark_start(r): nullptr;\n-    if (r == nullptr)\n-      break;\n-    if (r->is_old() && r->is_active()) {\n-      HeapWord* obj_addr = r->bottom();\n-      if (r->is_humongous_start()) {\n-        oop obj = cast_to_oop(obj_addr);\n-        if (!ctx || ctx->is_marked(obj)) {\n-          \/\/ For humongous objects, the typical object is an array, so the following checks may be overkill\n-          \/\/ For regular objects (not object arrays), if the card holding the start of the object is dirty,\n-          \/\/ we do not need to verify that cards spanning interesting pointers within this object are dirty.\n-          if (!scanner->is_card_dirty(obj_addr) || obj->is_objArray()) {\n-            obj->oop_iterate(&check_interesting_pointers);\n-          }\n-          \/\/ else, object's start is marked dirty and obj is not an objArray, so any interesting pointers are covered\n-        }\n-        \/\/ else, this humongous object is not marked so no need to verify its internal pointers\n-        if (!scanner->verify_registration(obj_addr, ctx)) {\n-          ShenandoahAsserts::print_failure(ShenandoahAsserts::_safe_all, obj, obj_addr, nullptr,\n-                                          \"Verify init-mark remembered set violation\", \"object not properly registered\", __FILE__, __LINE__);\n-        }\n-      } else if (!r->is_humongous()) {\n-        HeapWord* top = r->top();\n-        while (obj_addr < top) {\n-          oop obj = cast_to_oop(obj_addr);\n-          \/\/ ctx->is_marked() returns true if mark bit set (TAMS not relevant during init mark)\n-          if (!ctx || ctx->is_marked(obj)) {\n-            \/\/ For regular objects (not object arrays), if the card holding the start of the object is dirty,\n-            \/\/ we do not need to verify that cards spanning interesting pointers within this object are dirty.\n-            if (!scanner->is_card_dirty(obj_addr) || obj->is_objArray()) {\n-              obj->oop_iterate(&check_interesting_pointers);\n-            }\n-            \/\/ else, object's start is marked dirty and obj is not an objArray, so any interesting pointers are covered\n-            if (!scanner->verify_registration(obj_addr, ctx)) {\n-              ShenandoahAsserts::print_failure(ShenandoahAsserts::_safe_all, obj, obj_addr, nullptr,\n-                                               \"Verify init-mark remembered set violation\", \"object not properly registered\", __FILE__, __LINE__);\n-            }\n-            obj_addr += obj->size();\n-          } else {\n-            \/\/ This object is not live so we don't verify dirty cards contained therein\n-            assert(tams != nullptr, \"If object is not live, ctx and tams should be non-null\");\n-            obj_addr = ctx->get_next_marked_addr(obj_addr, tams);\n-          }\n-        }\n-      } \/\/ else, we ignore humongous continuation region\n-    } \/\/ else, this is not an OLD region so we ignore it\n-  } \/\/ all regions have been processed\n-}\n-\n-void ShenandoahHeap::help_verify_region_rem_set(ShenandoahHeapRegion* r, ShenandoahMarkingContext* ctx, HeapWord* from,\n-                                                HeapWord* top, HeapWord* registration_watermark, const char* message) {\n-  RememberedScanner* scanner = card_scan();\n-  ShenandoahVerifyRemSetClosure check_interesting_pointers(false);\n-\n-  HeapWord* obj_addr = from;\n-  if (r->is_humongous_start()) {\n-    oop obj = cast_to_oop(obj_addr);\n-    if (!ctx || ctx->is_marked(obj)) {\n-      size_t card_index = scanner->card_index_for_addr(obj_addr);\n-      \/\/ For humongous objects, the typical object is an array, so the following checks may be overkill\n-      \/\/ For regular objects (not object arrays), if the card holding the start of the object is dirty,\n-      \/\/ we do not need to verify that cards spanning interesting pointers within this object are dirty.\n-      if (!scanner->is_write_card_dirty(card_index) || obj->is_objArray()) {\n-        obj->oop_iterate(&check_interesting_pointers);\n-      }\n-      \/\/ else, object's start is marked dirty and obj is not an objArray, so any interesting pointers are covered\n-    }\n-    \/\/ else, this humongous object is not live so no need to verify its internal pointers\n-\n-    if ((obj_addr < registration_watermark) && !scanner->verify_registration(obj_addr, ctx)) {\n-      ShenandoahAsserts::print_failure(ShenandoahAsserts::_safe_all, obj, obj_addr, nullptr, message,\n-                                       \"object not properly registered\", __FILE__, __LINE__);\n-    }\n-  } else if (!r->is_humongous()) {\n-    while (obj_addr < top) {\n-      oop obj = cast_to_oop(obj_addr);\n-      \/\/ ctx->is_marked() returns true if mark bit set or if obj above TAMS.\n-      if (!ctx || ctx->is_marked(obj)) {\n-        size_t card_index = scanner->card_index_for_addr(obj_addr);\n-        \/\/ For regular objects (not object arrays), if the card holding the start of the object is dirty,\n-        \/\/ we do not need to verify that cards spanning interesting pointers within this object are dirty.\n-        if (!scanner->is_write_card_dirty(card_index) || obj->is_objArray()) {\n-          obj->oop_iterate(&check_interesting_pointers);\n-        }\n-        \/\/ else, object's start is marked dirty and obj is not an objArray, so any interesting pointers are covered\n-\n-        if ((obj_addr < registration_watermark) && !scanner->verify_registration(obj_addr, ctx)) {\n-          ShenandoahAsserts::print_failure(ShenandoahAsserts::_safe_all, obj, obj_addr, nullptr, message,\n-                                           \"object not properly registered\", __FILE__, __LINE__);\n-        }\n-        obj_addr += obj->size();\n-      } else {\n-        \/\/ This object is not live so we don't verify dirty cards contained therein\n-        HeapWord* tams = ctx->top_at_mark_start(r);\n-        obj_addr = ctx->get_next_marked_addr(obj_addr, tams);\n-      }\n-    }\n-  }\n-}\n-\n-void ShenandoahHeap::verify_rem_set_after_full_gc() {\n-  shenandoah_assert_safepoint();\n-  assert(mode()->is_generational(), \"Only verify remembered set for generational operational modes\");\n-\n-  ShenandoahRegionIterator iterator;\n-\n-  while (iterator.has_next()) {\n-    ShenandoahHeapRegion* r = iterator.next();\n-    if (r == nullptr)\n-      break;\n-    if (r->is_old() && !r->is_cset()) {\n-      help_verify_region_rem_set(r, nullptr, r->bottom(), r->top(), r->top(), \"Remembered set violation at end of Full GC\");\n-    }\n-  }\n-}\n-\n-\/\/ Assure that the remember set has a dirty card everywhere there is an interesting pointer.  Even though\n-\/\/ the update-references scan of remembered set only examines cards up to update_watermark, the remembered\n-\/\/ set should be valid through top.  This examines the write_card_table between bottom() and top() because\n-\/\/ all PLABS are retired immediately before the start of update refs.\n-void ShenandoahHeap::verify_rem_set_at_update_ref() {\n-  shenandoah_assert_safepoint();\n-  assert(mode()->is_generational(), \"Only verify remembered set for generational operational modes\");\n-\n-  ShenandoahRegionIterator iterator;\n-  ShenandoahMarkingContext* ctx;\n-\n-  if (is_old_bitmap_stable() || active_generation()->is_global()) {\n-    ctx = complete_marking_context();\n-  } else {\n-    ctx = nullptr;\n-  }\n-\n-  while (iterator.has_next()) {\n-    ShenandoahHeapRegion* r = iterator.next();\n-    if (r == nullptr)\n-      break;\n-    if (r->is_old() && !r->is_cset()) {\n-      help_verify_region_rem_set(r, ctx, r->bottom(), r->top(), r->get_update_watermark(),\n-                                 \"Remembered set violation at init-update-references\");\n-    }\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":0,"deletions":167,"binary":false,"changes":167,"status":"modified"},{"patch":"@@ -209,3 +209,0 @@\n-  void verify_rem_set_at_mark();\n-  void verify_rem_set_at_update_ref();\n-  void verify_rem_set_after_full_gc();\n@@ -229,3 +226,0 @@\n-  void help_verify_region_rem_set(ShenandoahHeapRegion* r, ShenandoahMarkingContext* ctx,\n-                                  HeapWord* from, HeapWord* top, HeapWord* update_watermark, const char* message);\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-  \/\/ TODO: Have a separate memory pool implementation for non-generational\n@@ -42,1 +41,1 @@\n-                      const char* name = \"Shenandoah\");\n+                       const char* name = \"Shenandoah\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMemoryPool.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -39,0 +39,3 @@\n+  bool entry_coalesce_and_fill();\n+  bool coalesce_and_fill();\n+\n@@ -103,4 +106,0 @@\n-\n-private:\n-  bool entry_coalesce_and_fill();\n-  bool coalesce_and_fill();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.hpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -148,20 +148,0 @@\n-class ShenandoahVerifyRemSetClosure : public BasicOopIterateClosure {\n-protected:\n-  bool               const _init_mark;\n-  ShenandoahHeap*    const _heap;\n-  RememberedScanner* const _scanner;\n-\n-public:\n-  \/\/ Argument distinguishes between initial mark or start of update refs verification.\n-  ShenandoahVerifyRemSetClosure(bool init_mark) :\n-      _init_mark(init_mark),\n-      _heap(ShenandoahHeap::heap()),\n-      _scanner(_heap->card_scan()) {}\n-\n-  template<class T>\n-  inline void work(T* p);\n-\n-  virtual void do_oop(narrowOop* p) { work(p); }\n-  virtual void do_oop(oop* p) { work(p); }\n-};\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOopClosures.hpp","additions":0,"deletions":20,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -58,18 +58,0 @@\n-template<class T>\n-inline void ShenandoahVerifyRemSetClosure::work(T* p) {\n-  T o = RawAccess<>::oop_load(p);\n-  if (!CompressedOops::is_null(o)) {\n-    oop obj = CompressedOops::decode_not_null(o);\n-    if (_heap->is_in_young(obj)) {\n-      size_t card_index = _scanner->card_index_for_addr((HeapWord*) p);\n-      if (_init_mark && !_scanner->is_card_dirty(card_index)) {\n-        ShenandoahAsserts::print_failure(ShenandoahAsserts::_safe_all, obj, p, nullptr,\n-                                        \"Verify init-mark remembered set violation\", \"clean card should be dirty\", __FILE__, __LINE__);\n-      } else if (!_init_mark && !_scanner->is_write_card_dirty(card_index)) {\n-        ShenandoahAsserts::print_failure(ShenandoahAsserts::_safe_all, obj, p, nullptr,\n-                                        \"Verify init-update-refs remembered set violation\", \"clean card should be dirty\", __FILE__, __LINE__);\n-      }\n-    }\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOopClosures.inline.hpp","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -717,1 +717,1 @@\n-    if (verify_gc_state(actual, _expected)) {\n+    if (!verify_gc_state(actual, _expected)) {\n@@ -726,1 +726,1 @@\n-    return (actual != expected) && !(actual & ShenandoahHeap::OLD_MARKING);\n+    return (actual == expected) || (actual & ShenandoahHeap::OLD_MARKING);\n@@ -787,1 +787,1 @@\n-      if (VerifyThreadGCState::verify_gc_state(actual, expected)) {\n+      if (!VerifyThreadGCState::verify_gc_state(actual, expected)) {\n@@ -836,1 +836,1 @@\n-      case _verify_remembered_for_marking:\n+      case _verify_remembered_before_marking:\n@@ -838,1 +838,1 @@\n-        _heap->verify_rem_set_at_mark();\n+        verify_rem_set_before_mark();\n@@ -840,1 +840,1 @@\n-      case _verify_remembered_for_updating_references:\n+      case _verify_remembered_before_updating_references:\n@@ -842,1 +842,1 @@\n-        _heap->verify_rem_set_at_update_ref();\n+        verify_rem_set_before_update_ref();\n@@ -846,1 +846,1 @@\n-        _heap->verify_rem_set_after_full_gc();\n+        verify_rem_set_after_full_gc();\n@@ -981,2 +981,2 @@\n-          \"Before Mark\",\n-          _verify_remembered_for_marking,  \/\/ verify read-only remembered set from bottom() to top()\n+            \"Before Mark\",\n+            _verify_remembered_before_marking,  \/\/ verify read-only remembered set from bottom() to top()\n@@ -1047,1 +1047,1 @@\n-          _verify_remembered_for_updating_references,  \/\/ verify read-write remembered set\n+          _verify_remembered_before_updating_references,  \/\/ verify read-write remembered set\n@@ -1172,0 +1172,212 @@\n+\n+class ShenandoahVerifyRemSetClosure : public BasicOopIterateClosure {\n+protected:\n+  bool               const _init_mark;\n+  ShenandoahHeap*    const _heap;\n+  RememberedScanner* const _scanner;\n+\n+public:\n+  \/\/ Argument distinguishes between initial mark or start of update refs verification.\n+  ShenandoahVerifyRemSetClosure(bool init_mark) :\n+            _init_mark(init_mark),\n+            _heap(ShenandoahHeap::heap()),\n+            _scanner(_heap->card_scan()) {}\n+\n+  template<class T>\n+  inline void work(T* p) {\n+    T o = RawAccess<>::oop_load(p);\n+    if (!CompressedOops::is_null(o)) {\n+      oop obj = CompressedOops::decode_not_null(o);\n+      if (_heap->is_in_young(obj)) {\n+        size_t card_index = _scanner->card_index_for_addr((HeapWord*) p);\n+        if (_init_mark && !_scanner->is_card_dirty(card_index)) {\n+          ShenandoahAsserts::print_failure(ShenandoahAsserts::_safe_all, obj, p, nullptr,\n+                                           \"Verify init-mark remembered set violation\", \"clean card should be dirty\", __FILE__, __LINE__);\n+        } else if (!_init_mark && !_scanner->is_write_card_dirty(card_index)) {\n+          ShenandoahAsserts::print_failure(ShenandoahAsserts::_safe_all, obj, p, nullptr,\n+                                           \"Verify init-update-refs remembered set violation\", \"clean card should be dirty\", __FILE__, __LINE__);\n+        }\n+      }\n+    }\n+  }\n+\n+  virtual void do_oop(narrowOop* p) { work(p); }\n+  virtual void do_oop(oop* p)       { work(p); }\n+};\n+\n+void ShenandoahVerifier::help_verify_region_rem_set(ShenandoahHeapRegion* r, ShenandoahMarkingContext* ctx, HeapWord* from,\n+                                                    HeapWord* top, HeapWord* registration_watermark, const char* message) {\n+  RememberedScanner* scanner = _heap->card_scan();\n+  ShenandoahVerifyRemSetClosure check_interesting_pointers(false);\n+\n+  HeapWord* obj_addr = from;\n+  if (r->is_humongous_start()) {\n+    oop obj = cast_to_oop(obj_addr);\n+    if ((ctx == nullptr) || ctx->is_marked(obj)) {\n+      size_t card_index = scanner->card_index_for_addr(obj_addr);\n+      \/\/ For humongous objects, the typical object is an array, so the following checks may be overkill\n+      \/\/ For regular objects (not object arrays), if the card holding the start of the object is dirty,\n+      \/\/ we do not need to verify that cards spanning interesting pointers within this object are dirty.\n+      if (!scanner->is_write_card_dirty(card_index) || obj->is_objArray()) {\n+        obj->oop_iterate(&check_interesting_pointers);\n+      }\n+      \/\/ else, object's start is marked dirty and obj is not an objArray, so any interesting pointers are covered\n+    }\n+    \/\/ else, this humongous object is not live so no need to verify its internal pointers\n+\n+    if ((obj_addr < registration_watermark) && !scanner->verify_registration(obj_addr, ctx)) {\n+      ShenandoahAsserts::print_failure(ShenandoahAsserts::_safe_all, obj, obj_addr, nullptr, message,\n+                                       \"object not properly registered\", __FILE__, __LINE__);\n+    }\n+  } else if (!r->is_humongous()) {\n+    while (obj_addr < top) {\n+      oop obj = cast_to_oop(obj_addr);\n+      \/\/ ctx->is_marked() returns true if mark bit set or if obj above TAMS.\n+      if ((ctx == nullptr) || ctx->is_marked(obj)) {\n+        size_t card_index = scanner->card_index_for_addr(obj_addr);\n+        \/\/ For regular objects (not object arrays), if the card holding the start of the object is dirty,\n+        \/\/ we do not need to verify that cards spanning interesting pointers within this object are dirty.\n+        if (!scanner->is_write_card_dirty(card_index) || obj->is_objArray()) {\n+          obj->oop_iterate(&check_interesting_pointers);\n+        }\n+        \/\/ else, object's start is marked dirty and obj is not an objArray, so any interesting pointers are covered\n+\n+        if ((obj_addr < registration_watermark) && !scanner->verify_registration(obj_addr, ctx)) {\n+          ShenandoahAsserts::print_failure(ShenandoahAsserts::_safe_all, obj, obj_addr, nullptr, message,\n+                                           \"object not properly registered\", __FILE__, __LINE__);\n+        }\n+        obj_addr += obj->size();\n+      } else {\n+        \/\/ This object is not live so we don't verify dirty cards contained therein\n+        HeapWord* tams = ctx->top_at_mark_start(r);\n+        obj_addr = ctx->get_next_marked_addr(obj_addr, tams);\n+      }\n+    }\n+  }\n+}\n+\n+\/\/ Assure that the remember set has a dirty card everywhere there is an interesting pointer.\n+\/\/ This examines the read_card_table between bottom() and top() since all PLABS are retired\n+\/\/ before the safepoint for init_mark.  Actually, we retire them before update-references and don't\n+\/\/ restore them until the start of evacuation.\n+void ShenandoahVerifier::verify_rem_set_before_mark() {\n+  shenandoah_assert_safepoint();\n+  assert(_heap->mode()->is_generational(), \"Only verify remembered set for generational operational modes\");\n+\n+  ShenandoahRegionIterator iterator;\n+  RememberedScanner* scanner = _heap->card_scan();\n+  ShenandoahVerifyRemSetClosure check_interesting_pointers(true);\n+  ShenandoahMarkingContext* ctx;\n+\n+  log_debug(gc)(\"Verifying remembered set at %s mark\", _heap->doing_mixed_evacuations()? \"mixed\": \"young\");\n+\n+  if (_heap->is_old_bitmap_stable() || _heap->active_generation()->is_global()) {\n+    ctx = _heap->complete_marking_context();\n+  } else {\n+    ctx = nullptr;\n+  }\n+\n+  while (iterator.has_next()) {\n+    ShenandoahHeapRegion* r = iterator.next();\n+    if (r == nullptr) {\n+      \/\/ TODO: Can this really happen?\n+      break;\n+    }\n+\n+    HeapWord* tams = (ctx != nullptr) ? ctx->top_at_mark_start(r) : nullptr;\n+\n+    \/\/ TODO: Is this replaceable with call to help_verify_region_rem_set?\n+\n+    if (r->is_old() && r->is_active()) {\n+      HeapWord* obj_addr = r->bottom();\n+      if (r->is_humongous_start()) {\n+        oop obj = cast_to_oop(obj_addr);\n+        if ((ctx == nullptr) || ctx->is_marked(obj)) {\n+          \/\/ For humongous objects, the typical object is an array, so the following checks may be overkill\n+          \/\/ For regular objects (not object arrays), if the card holding the start of the object is dirty,\n+          \/\/ we do not need to verify that cards spanning interesting pointers within this object are dirty.\n+          if (!scanner->is_card_dirty(obj_addr) || obj->is_objArray()) {\n+            obj->oop_iterate(&check_interesting_pointers);\n+          }\n+          \/\/ else, object's start is marked dirty and obj is not an objArray, so any interesting pointers are covered\n+        }\n+        \/\/ else, this humongous object is not marked so no need to verify its internal pointers\n+        if (!scanner->verify_registration(obj_addr, ctx)) {\n+          ShenandoahAsserts::print_failure(ShenandoahAsserts::_safe_all, obj, obj_addr, nullptr,\n+                                           \"Verify init-mark remembered set violation\", \"object not properly registered\", __FILE__, __LINE__);\n+        }\n+      } else if (!r->is_humongous()) {\n+        HeapWord* top = r->top();\n+        while (obj_addr < top) {\n+          oop obj = cast_to_oop(obj_addr);\n+          \/\/ ctx->is_marked() returns true if mark bit set (TAMS not relevant during init mark)\n+          if ((ctx == nullptr) || ctx->is_marked(obj)) {\n+            \/\/ For regular objects (not object arrays), if the card holding the start of the object is dirty,\n+            \/\/ we do not need to verify that cards spanning interesting pointers within this object are dirty.\n+            if (!scanner->is_card_dirty(obj_addr) || obj->is_objArray()) {\n+              obj->oop_iterate(&check_interesting_pointers);\n+            }\n+            \/\/ else, object's start is marked dirty and obj is not an objArray, so any interesting pointers are covered\n+            if (!scanner->verify_registration(obj_addr, ctx)) {\n+              ShenandoahAsserts::print_failure(ShenandoahAsserts::_safe_all, obj, obj_addr, nullptr,\n+                                               \"Verify init-mark remembered set violation\", \"object not properly registered\", __FILE__, __LINE__);\n+            }\n+            obj_addr += obj->size();\n+          } else {\n+            \/\/ This object is not live so we don't verify dirty cards contained therein\n+            assert(tams != nullptr, \"If object is not live, ctx and tams should be non-null\");\n+            obj_addr = ctx->get_next_marked_addr(obj_addr, tams);\n+          }\n+        }\n+      } \/\/ else, we ignore humongous continuation region\n+    } \/\/ else, this is not an OLD region so we ignore it\n+  } \/\/ all regions have been processed\n+}\n+\n+void ShenandoahVerifier::verify_rem_set_after_full_gc() {\n+  shenandoah_assert_safepoint();\n+  assert(_heap->mode()->is_generational(), \"Only verify remembered set for generational operational modes\");\n+\n+  ShenandoahRegionIterator iterator;\n+\n+  while (iterator.has_next()) {\n+    ShenandoahHeapRegion* r = iterator.next();\n+    if (r == nullptr) {\n+      \/\/ TODO: Can this really happen?\n+      break;\n+    }\n+    if (r->is_old() && !r->is_cset()) {\n+      help_verify_region_rem_set(r, nullptr, r->bottom(), r->top(), r->top(), \"Remembered set violation at end of Full GC\");\n+    }\n+  }\n+}\n+\n+\/\/ Assure that the remember set has a dirty card everywhere there is an interesting pointer.  Even though\n+\/\/ the update-references scan of remembered set only examines cards up to update_watermark, the remembered\n+\/\/ set should be valid through top.  This examines the write_card_table between bottom() and top() because\n+\/\/ all PLABS are retired immediately before the start of update refs.\n+void ShenandoahVerifier::verify_rem_set_before_update_ref() {\n+  shenandoah_assert_safepoint();\n+  assert(_heap->mode()->is_generational(), \"Only verify remembered set for generational operational modes\");\n+\n+  ShenandoahRegionIterator iterator;\n+  ShenandoahMarkingContext* ctx;\n+\n+  if (_heap->is_old_bitmap_stable() || _heap->active_generation()->is_global()) {\n+    ctx = _heap->complete_marking_context();\n+  } else {\n+    ctx = nullptr;\n+  }\n+\n+  while (iterator.has_next()) {\n+    ShenandoahHeapRegion* r = iterator.next();\n+    if (r == nullptr) {\n+      \/\/ TODO: Can this really happen?\n+      break;\n+    }\n+    if (r->is_old() && !r->is_cset()) {\n+      help_verify_region_rem_set(r, ctx, r->bottom(), r->top(), r->get_update_watermark(),\n+                                 \"Remembered set violation at init-update-references\");\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVerifier.cpp","additions":223,"deletions":11,"binary":false,"changes":234,"status":"modified"},{"patch":"@@ -66,2 +66,2 @@\n-    \/\/ interesting pointers.\n-    _verify_remembered_for_marking,\n+    \/\/ inter-generational pointers.\n+    _verify_remembered_before_marking,\n@@ -70,2 +70,2 @@\n-    \/\/ interesting pointers.\n-    _verify_remembered_for_updating_references,\n+    \/\/ inter-generational pointers.\n+    _verify_remembered_before_updating_references,\n@@ -74,1 +74,1 @@\n-    \/\/ interesting pointers.\n+    \/\/ inter-generational pointers.\n@@ -214,0 +214,8 @@\n+\n+private:\n+   void help_verify_region_rem_set(ShenandoahHeapRegion* r, ShenandoahMarkingContext* ctx,\n+                                    HeapWord* from, HeapWord* top, HeapWord* update_watermark, const char* message);\n+\n+  void verify_rem_set_before_mark();\n+  void verify_rem_set_before_update_ref();\n+  void verify_rem_set_after_full_gc();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVerifier.hpp","additions":13,"deletions":5,"binary":false,"changes":18,"status":"modified"}]}