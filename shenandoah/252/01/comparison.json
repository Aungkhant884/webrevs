{"files":[{"patch":"@@ -358,5 +358,1 @@\n-    if (heap->mode()->is_generational()) {\n-      heap->verifier()->verify_after_generational_fullgc();\n-    } else {\n-      heap->verifier()->verify_after_fullgc();\n-    }\n+    heap->verifier()->verify_after_fullgc();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3135,167 +3135,0 @@\n-\/\/ Assure that the remember set has a dirty card everywhere there is an interesting pointer.\n-\/\/ This examines the read_card_table between bottom() and top() since all PLABS are retired\n-\/\/ before the safepoint for init_mark.  Actually, we retire them before update-references and don't\n-\/\/ restore them until the start of evacuation.\n-void ShenandoahHeap::verify_rem_set_at_mark() {\n-  shenandoah_assert_safepoint();\n-  assert(mode()->is_generational(), \"Only verify remembered set for generational operational modes\");\n-\n-  ShenandoahRegionIterator iterator;\n-  RememberedScanner* scanner = card_scan();\n-  ShenandoahVerifyRemSetClosure check_interesting_pointers(true);\n-  ShenandoahMarkingContext* ctx;\n-\n-  log_debug(gc)(\"Verifying remembered set at %s mark\", doing_mixed_evacuations()? \"mixed\": \"young\");\n-\n-  if (is_old_bitmap_stable() || active_generation()->is_global()) {\n-    ctx = complete_marking_context();\n-  } else {\n-    ctx = nullptr;\n-  }\n-\n-  while (iterator.has_next()) {\n-    ShenandoahHeapRegion* r = iterator.next();\n-    HeapWord* tams = ctx? ctx->top_at_mark_start(r): nullptr;\n-    if (r == nullptr)\n-      break;\n-    if (r->is_old() && r->is_active()) {\n-      HeapWord* obj_addr = r->bottom();\n-      if (r->is_humongous_start()) {\n-        oop obj = cast_to_oop(obj_addr);\n-        if (!ctx || ctx->is_marked(obj)) {\n-          \/\/ For humongous objects, the typical object is an array, so the following checks may be overkill\n-          \/\/ For regular objects (not object arrays), if the card holding the start of the object is dirty,\n-          \/\/ we do not need to verify that cards spanning interesting pointers within this object are dirty.\n-          if (!scanner->is_card_dirty(obj_addr) || obj->is_objArray()) {\n-            obj->oop_iterate(&check_interesting_pointers);\n-          }\n-          \/\/ else, object's start is marked dirty and obj is not an objArray, so any interesting pointers are covered\n-        }\n-        \/\/ else, this humongous object is not marked so no need to verify its internal pointers\n-        if (!scanner->verify_registration(obj_addr, ctx)) {\n-          ShenandoahAsserts::print_failure(ShenandoahAsserts::_safe_all, obj, obj_addr, nullptr,\n-                                          \"Verify init-mark remembered set violation\", \"object not properly registered\", __FILE__, __LINE__);\n-        }\n-      } else if (!r->is_humongous()) {\n-        HeapWord* top = r->top();\n-        while (obj_addr < top) {\n-          oop obj = cast_to_oop(obj_addr);\n-          \/\/ ctx->is_marked() returns true if mark bit set (TAMS not relevant during init mark)\n-          if (!ctx || ctx->is_marked(obj)) {\n-            \/\/ For regular objects (not object arrays), if the card holding the start of the object is dirty,\n-            \/\/ we do not need to verify that cards spanning interesting pointers within this object are dirty.\n-            if (!scanner->is_card_dirty(obj_addr) || obj->is_objArray()) {\n-              obj->oop_iterate(&check_interesting_pointers);\n-            }\n-            \/\/ else, object's start is marked dirty and obj is not an objArray, so any interesting pointers are covered\n-            if (!scanner->verify_registration(obj_addr, ctx)) {\n-              ShenandoahAsserts::print_failure(ShenandoahAsserts::_safe_all, obj, obj_addr, nullptr,\n-                                               \"Verify init-mark remembered set violation\", \"object not properly registered\", __FILE__, __LINE__);\n-            }\n-            obj_addr += obj->size();\n-          } else {\n-            \/\/ This object is not live so we don't verify dirty cards contained therein\n-            assert(tams != nullptr, \"If object is not live, ctx and tams should be non-null\");\n-            obj_addr = ctx->get_next_marked_addr(obj_addr, tams);\n-          }\n-        }\n-      } \/\/ else, we ignore humongous continuation region\n-    } \/\/ else, this is not an OLD region so we ignore it\n-  } \/\/ all regions have been processed\n-}\n-\n-void ShenandoahHeap::help_verify_region_rem_set(ShenandoahHeapRegion* r, ShenandoahMarkingContext* ctx, HeapWord* from,\n-                                                HeapWord* top, HeapWord* registration_watermark, const char* message) {\n-  RememberedScanner* scanner = card_scan();\n-  ShenandoahVerifyRemSetClosure check_interesting_pointers(false);\n-\n-  HeapWord* obj_addr = from;\n-  if (r->is_humongous_start()) {\n-    oop obj = cast_to_oop(obj_addr);\n-    if (!ctx || ctx->is_marked(obj)) {\n-      size_t card_index = scanner->card_index_for_addr(obj_addr);\n-      \/\/ For humongous objects, the typical object is an array, so the following checks may be overkill\n-      \/\/ For regular objects (not object arrays), if the card holding the start of the object is dirty,\n-      \/\/ we do not need to verify that cards spanning interesting pointers within this object are dirty.\n-      if (!scanner->is_write_card_dirty(card_index) || obj->is_objArray()) {\n-        obj->oop_iterate(&check_interesting_pointers);\n-      }\n-      \/\/ else, object's start is marked dirty and obj is not an objArray, so any interesting pointers are covered\n-    }\n-    \/\/ else, this humongous object is not live so no need to verify its internal pointers\n-\n-    if ((obj_addr < registration_watermark) && !scanner->verify_registration(obj_addr, ctx)) {\n-      ShenandoahAsserts::print_failure(ShenandoahAsserts::_safe_all, obj, obj_addr, nullptr, message,\n-                                       \"object not properly registered\", __FILE__, __LINE__);\n-    }\n-  } else if (!r->is_humongous()) {\n-    while (obj_addr < top) {\n-      oop obj = cast_to_oop(obj_addr);\n-      \/\/ ctx->is_marked() returns true if mark bit set or if obj above TAMS.\n-      if (!ctx || ctx->is_marked(obj)) {\n-        size_t card_index = scanner->card_index_for_addr(obj_addr);\n-        \/\/ For regular objects (not object arrays), if the card holding the start of the object is dirty,\n-        \/\/ we do not need to verify that cards spanning interesting pointers within this object are dirty.\n-        if (!scanner->is_write_card_dirty(card_index) || obj->is_objArray()) {\n-          obj->oop_iterate(&check_interesting_pointers);\n-        }\n-        \/\/ else, object's start is marked dirty and obj is not an objArray, so any interesting pointers are covered\n-\n-        if ((obj_addr < registration_watermark) && !scanner->verify_registration(obj_addr, ctx)) {\n-          ShenandoahAsserts::print_failure(ShenandoahAsserts::_safe_all, obj, obj_addr, nullptr, message,\n-                                           \"object not properly registered\", __FILE__, __LINE__);\n-        }\n-        obj_addr += obj->size();\n-      } else {\n-        \/\/ This object is not live so we don't verify dirty cards contained therein\n-        HeapWord* tams = ctx->top_at_mark_start(r);\n-        obj_addr = ctx->get_next_marked_addr(obj_addr, tams);\n-      }\n-    }\n-  }\n-}\n-\n-void ShenandoahHeap::verify_rem_set_after_full_gc() {\n-  shenandoah_assert_safepoint();\n-  assert(mode()->is_generational(), \"Only verify remembered set for generational operational modes\");\n-\n-  ShenandoahRegionIterator iterator;\n-\n-  while (iterator.has_next()) {\n-    ShenandoahHeapRegion* r = iterator.next();\n-    if (r == nullptr)\n-      break;\n-    if (r->is_old() && !r->is_cset()) {\n-      help_verify_region_rem_set(r, nullptr, r->bottom(), r->top(), r->top(), \"Remembered set violation at end of Full GC\");\n-    }\n-  }\n-}\n-\n-\/\/ Assure that the remember set has a dirty card everywhere there is an interesting pointer.  Even though\n-\/\/ the update-references scan of remembered set only examines cards up to update_watermark, the remembered\n-\/\/ set should be valid through top.  This examines the write_card_table between bottom() and top() because\n-\/\/ all PLABS are retired immediately before the start of update refs.\n-void ShenandoahHeap::verify_rem_set_at_update_ref() {\n-  shenandoah_assert_safepoint();\n-  assert(mode()->is_generational(), \"Only verify remembered set for generational operational modes\");\n-\n-  ShenandoahRegionIterator iterator;\n-  ShenandoahMarkingContext* ctx;\n-\n-  if (is_old_bitmap_stable() || active_generation()->is_global()) {\n-    ctx = complete_marking_context();\n-  } else {\n-    ctx = nullptr;\n-  }\n-\n-  while (iterator.has_next()) {\n-    ShenandoahHeapRegion* r = iterator.next();\n-    if (r == nullptr)\n-      break;\n-    if (r->is_old() && !r->is_cset()) {\n-      help_verify_region_rem_set(r, ctx, r->bottom(), r->top(), r->get_update_watermark(),\n-                                 \"Remembered set violation at init-update-references\");\n-    }\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":0,"deletions":167,"binary":false,"changes":167,"status":"modified"},{"patch":"@@ -209,3 +209,0 @@\n-  void verify_rem_set_at_mark();\n-  void verify_rem_set_at_update_ref();\n-  void verify_rem_set_after_full_gc();\n@@ -229,3 +226,0 @@\n-  void help_verify_region_rem_set(ShenandoahHeapRegion* r, ShenandoahMarkingContext* ctx,\n-                                  HeapWord* from, HeapWord* top, HeapWord* update_watermark, const char* message);\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-  ShenandoahObjToScanQueue* old = get_old_queue(w);\n+  ShenandoahObjToScanQueue* old_q = get_old_queue(w);\n@@ -79,1 +79,1 @@\n-    Closure cl(q, rp, old);\n+    Closure cl(q, rp, old_q);\n@@ -83,1 +83,1 @@\n-    Closure cl(q, rp, old);\n+    Closure cl(q, rp, old_q);\n@@ -178,1 +178,1 @@\n-  ShenandoahObjToScanQueue* old = get_old_queue(worker_id);\n+  ShenandoahObjToScanQueue* old_q = get_old_queue(worker_id);\n@@ -180,1 +180,1 @@\n-  ShenandoahSATBBufferClosure<GENERATION> drain_satb(q, old);\n+  ShenandoahSATBBufferClosure<GENERATION> drain_satb(q, old_q);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMark.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-  static inline void mark_through_ref(T* p, ShenandoahObjToScanQueue* q, ShenandoahObjToScanQueue* old, ShenandoahMarkingContext* const mark_context, bool weak);\n+  static inline void mark_through_ref(T* p, ShenandoahObjToScanQueue* q, ShenandoahObjToScanQueue* old_q, ShenandoahMarkingContext* const mark_context, bool weak);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMark.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -244,1 +244,1 @@\n-  ShenandoahObjToScanQueue* _old;\n+  ShenandoahObjToScanQueue* _old_queue;\n@@ -248,1 +248,1 @@\n-  ShenandoahSATBBufferClosure(ShenandoahObjToScanQueue* q, ShenandoahObjToScanQueue* old) :\n+  ShenandoahSATBBufferClosure(ShenandoahObjToScanQueue* q, ShenandoahObjToScanQueue* old_q) :\n@@ -250,1 +250,1 @@\n-    _old(old),\n+    _old_queue(old_q),\n@@ -260,1 +260,1 @@\n-      ShenandoahMark::mark_through_ref<oop, GENERATION>(p, _queue, _old, _mark_context, false);\n+      ShenandoahMark::mark_through_ref<oop, GENERATION>(p, _queue, _old_queue, _mark_context, false);\n@@ -268,1 +268,1 @@\n-  if (GENERATION == YOUNG)\n+  if (GENERATION == YOUNG) {\n@@ -270,1 +270,1 @@\n-  else if (GENERATION == OLD)\n+  } else if (GENERATION == OLD) {\n@@ -272,1 +272,1 @@\n-  else if (GENERATION == GLOBAL)\n+  } else if (GENERATION == GLOBAL) {\n@@ -274,1 +274,1 @@\n-  else\n+  } else {\n@@ -276,0 +276,1 @@\n+  }\n@@ -279,1 +280,1 @@\n-inline void ShenandoahMark::mark_through_ref(T *p, ShenandoahObjToScanQueue* q, ShenandoahObjToScanQueue* old, ShenandoahMarkingContext* const mark_context, bool weak) {\n+inline void ShenandoahMark::mark_through_ref(T *p, ShenandoahObjToScanQueue* q, ShenandoahObjToScanQueue* old_q, ShenandoahMarkingContext* const mark_context, bool weak) {\n@@ -290,0 +291,1 @@\n+      \/\/ TODO: This is v-call on very hot path, can we sense the same from GENERATION?\n@@ -304,3 +306,3 @@\n-    } else if (old != nullptr) {\n-      \/\/ Young mark, bootstrapping old or concurrent with old marking.\n-      mark_ref(old, mark_context, weak, obj);\n+    } else if (old_q != nullptr) {\n+      \/\/ Young mark, bootstrapping old_q or concurrent with old_q marking.\n+      mark_ref(old_q, mark_context, weak, obj);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMark.inline.hpp","additions":14,"deletions":12,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-      if (!heap->is_bitmap_slice_committed(r))\n+      if (!heap->is_bitmap_slice_committed(r)) {\n@@ -60,0 +60,1 @@\n+      }\n@@ -82,0 +83,6 @@\n+  if (!r->is_affiliated()) {\n+    \/\/ Heap iterators include FREE regions, which don't need to be cleared.\n+    \/\/ TODO: would be better for certain iterators to not include FREE regions.\n+    return;\n+  }\n+\n@@ -88,8 +95,3 @@\n-  if (r->is_affiliated()) {\n-    if (top_bitmap > bottom) {\n-      _mark_bit_map.clear_range_large(MemRegion(bottom, top_bitmap));\n-      _top_bitmaps[r->index()] = bottom;\n-    }\n-    r->clear_live_data();\n-    assert(is_bitmap_clear_range(bottom, r->end()),\n-           \"Region \" SIZE_FORMAT \" should have no marks in bitmap\", r->index());\n+  if (top_bitmap > bottom) {\n+    _mark_bit_map.clear_range_large(MemRegion(bottom, top_bitmap));\n+    _top_bitmaps[r->index()] = bottom;\n@@ -97,2 +99,6 @@\n-  \/\/ heap iterators include FREE regions, which don't need to be cleared.\n-  \/\/ TODO: would be better for certain iterators to not include FREE regions.\n+\n+  \/\/ TODO: Why is clear_live_data here?\n+  r->clear_live_data();\n+\n+  assert(is_bitmap_clear_range(bottom, r->end()),\n+         \"Region \" SIZE_FORMAT \" should have no marks in bitmap\", r->index());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkingContext.cpp","additions":17,"deletions":11,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+  \/\/ TODO: Do these really need to be const?\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkingContext.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -78,30 +78,34 @@\n-  if (r->is_affiliated()) {\n-    size_t idx = r->index();\n-    HeapWord* old_tams = _top_at_mark_starts_base[idx];\n-    HeapWord* new_tams = r->top();\n-\n-    assert(new_tams >= old_tams,\n-           \"Region \" SIZE_FORMAT\", TAMS updates should be monotonic: \" PTR_FORMAT \" -> \" PTR_FORMAT,\n-           idx, p2i(old_tams), p2i(new_tams));\n-    assert((new_tams == r->bottom()) || (old_tams == r->bottom()) || (new_tams >= _top_bitmaps[idx]),\n-           \"Region \" SIZE_FORMAT\", top_bitmaps updates should be monotonic: \" PTR_FORMAT \" -> \" PTR_FORMAT,\n-           idx, p2i(_top_bitmaps[idx]), p2i(new_tams));\n-    assert(old_tams == r->bottom() || is_bitmap_clear_range(old_tams, new_tams),\n-           \"Region \" SIZE_FORMAT \", bitmap should be clear while adjusting TAMS: \" PTR_FORMAT \" -> \" PTR_FORMAT,\n-           idx, p2i(old_tams), p2i(new_tams));\n-\n-    log_debug(gc)(\"Capturing TAMS for %s Region \" SIZE_FORMAT \", was: %llx, now: %llx\",\n-                  r->affiliation_name(), idx, (unsigned long long) old_tams, (unsigned long long) new_tams);\n-\n-    if ((old_tams == r->bottom()) && (new_tams > old_tams)) {\n-      log_debug(gc)(\"Clearing mark bitmap for %s Region \" SIZE_FORMAT \" while capturing TAMS\",\n-                    r->affiliation_name(), idx);\n-\n-      clear_bitmap(r);\n-    }\n-\n-    _top_at_mark_starts_base[idx] = new_tams;\n-    if (new_tams > r->bottom()) {\n-      \/\/ In this case, new_tams is greater than old _top_bitmaps[idx]\n-      _top_bitmaps[idx] = new_tams;\n-    }\n+  if (!r->is_affiliated()) {\n+    \/\/ Non-affiliated regions do not need their TAMS updated\n+    return;\n+  }\n+\n+  size_t idx = r->index();\n+  HeapWord* old_tams = _top_at_mark_starts_base[idx];\n+  HeapWord* new_tams = r->top();\n+\n+  assert(new_tams >= old_tams,\n+         \"Region \" SIZE_FORMAT\", TAMS updates should be monotonic: \" PTR_FORMAT \" -> \" PTR_FORMAT,\n+         idx, p2i(old_tams), p2i(new_tams));\n+  assert((new_tams == r->bottom()) || (old_tams == r->bottom()) || (new_tams >= _top_bitmaps[idx]),\n+         \"Region \" SIZE_FORMAT\", top_bitmaps updates should be monotonic: \" PTR_FORMAT \" -> \" PTR_FORMAT,\n+         idx, p2i(_top_bitmaps[idx]), p2i(new_tams));\n+  assert(old_tams == r->bottom() || is_bitmap_clear_range(old_tams, new_tams),\n+         \"Region \" SIZE_FORMAT \", bitmap should be clear while adjusting TAMS: \" PTR_FORMAT \" -> \" PTR_FORMAT,\n+         idx, p2i(old_tams), p2i(new_tams));\n+\n+  log_debug(gc)(\"Capturing TAMS for %s Region \" SIZE_FORMAT \", was: \" PTR_FORMAT \", now: \" PTR_FORMAT,\n+                r->affiliation_name(), idx, p2i(old_tams), p2i(new_tams));\n+\n+  if ((old_tams == r->bottom()) && (new_tams > old_tams)) {\n+    log_debug(gc)(\"Clearing mark bitmap for %s Region \" SIZE_FORMAT \" while capturing TAMS\",\n+                  r->affiliation_name(), idx);\n+    \/\/ TODO: Do we really need to do bitmap clears here?\n+    \/\/ This could take a while, and we would instead like to clear bitmaps outside the pause.\n+    clear_bitmap(r);\n+  }\n+\n+  _top_at_mark_starts_base[idx] = new_tams;\n+  if (new_tams > r->bottom()) {\n+    \/\/ In this case, new_tams is greater than old _top_bitmaps[idx]\n+    _top_bitmaps[idx] = new_tams;\n@@ -109,1 +113,0 @@\n-  \/\/ else, FREE regions do not need their TAMS updated\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkingContext.inline.hpp","additions":34,"deletions":31,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-                      const char* name = \"Shenandoah\");\n+                       const char* name = \"Shenandoah\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMemoryPool.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n- private:\n+private:\n@@ -58,1 +58,1 @@\n- public:\n+public:\n@@ -69,3 +69,3 @@\n- private:\n-  ShenandoahObjToScanQueue* _queue;\n-  ShenandoahHeap* _heap;\n+private:\n+  ShenandoahObjToScanQueue*       _queue;\n+  ShenandoahHeap*                 _heap;\n@@ -73,0 +73,1 @@\n+  size_t                          _trashed_oops;\n@@ -74,3 +75,1 @@\n- public:\n-  size_t _trashed_oops;\n-\n+public:\n@@ -83,1 +82,1 @@\n-  void do_buffer(void **buffer, size_t size) {\n+  void do_buffer(void** buffer, size_t size) {\n@@ -91,1 +90,1 @@\n-        ++_trashed_oops;\n+        _trashed_oops++;\n@@ -95,0 +94,4 @@\n+\n+  size_t trashed_oops() {\n+    return _trashed_oops;\n+  }\n@@ -100,0 +103,1 @@\n+  volatile size_t             _trashed_oops;\n@@ -102,2 +106,0 @@\n-  volatile size_t _trashed_oops;\n-\n@@ -113,1 +115,1 @@\n-      log_info(gc)(\"Purged \" SIZE_FORMAT \" oops from old generation SATB buffers.\", _trashed_oops);\n+      log_info(gc)(\"Purged \" SIZE_FORMAT \" oops from old generation SATB buffers\", _trashed_oops);\n@@ -127,1 +129,1 @@\n-    Atomic::add(&_trashed_oops, processor._trashed_oops);\n+    Atomic::add(&_trashed_oops, processor.trashed_oops());\n@@ -132,8 +134,9 @@\n- private:\n-  uint _nworkers;\n-  ShenandoahHeapRegion** _coalesce_and_fill_region_array;\n-  uint _coalesce_and_fill_region_count;\n-  volatile bool _is_preempted;\n-\n- public:\n-  ShenandoahConcurrentCoalesceAndFillTask(uint nworkers, ShenandoahHeapRegion** coalesce_and_fill_region_array,\n+private:\n+  uint                    _nworkers;\n+  ShenandoahHeapRegion**  _coalesce_and_fill_region_array;\n+  uint                    _coalesce_and_fill_region_count;\n+  volatile bool           _is_preempted;\n+\n+public:\n+  ShenandoahConcurrentCoalesceAndFillTask(uint nworkers,\n+                                          ShenandoahHeapRegion** coalesce_and_fill_region_array,\n@@ -152,1 +155,2 @@\n-        \/\/ there's only one object in this region and it's not garbage, so no need to coalesce or fill\n+        \/\/ There is only one object in this region and it is not garbage,\n+        \/\/ so no need to coalesce or fill.\n@@ -179,4 +183,0 @@\n-const char* ShenandoahOldGeneration::name() const {\n-  return \"OLD\";\n-}\n-\n@@ -208,1 +208,1 @@\n-    log_info(gc)(\"Abandon satb buffers.\");\n+    log_info(gc)(\"Abandon SATB buffers\");\n@@ -216,1 +216,0 @@\n-\n@@ -234,1 +233,0 @@\n-  char msg[1024];\n@@ -237,1 +235,2 @@\n-  ShenandoahConcurrentPhase gc_phase(\"Coalescing and filling (OLD)\", ShenandoahPhaseTimings::coalesce_and_fill);\n+  static const char* msg = \"Coalescing and filling (OLD)\";\n+  ShenandoahConcurrentPhase gc_phase(msg, ShenandoahPhaseTimings::coalesce_and_fill);\n@@ -244,1 +243,1 @@\n-                              \"concurrent coalesce and fill\");\n+                              msg);\n@@ -284,1 +283,1 @@\n-  log_info(gc)(\"Transfer satb buffers.\");\n+  log_info(gc)(\"Transfer SATB buffers\");\n@@ -301,1 +300,3 @@\n-    ShenandoahGCPhase phase(concurrent ? ShenandoahPhaseTimings::final_update_region_states : ShenandoahPhaseTimings::degen_gc_final_update_region_states);\n+    ShenandoahGCPhase phase(concurrent ?\n+        ShenandoahPhaseTimings::final_update_region_states :\n+        ShenandoahPhaseTimings::degen_gc_final_update_region_states);\n@@ -311,1 +312,3 @@\n-    ShenandoahGCPhase phase(concurrent ? ShenandoahPhaseTimings::choose_cset : ShenandoahPhaseTimings::degen_gc_choose_cset);\n+    ShenandoahGCPhase phase(concurrent ?\n+        ShenandoahPhaseTimings::choose_cset :\n+        ShenandoahPhaseTimings::degen_gc_choose_cset);\n@@ -319,1 +322,3 @@\n-    ShenandoahGCPhase phase(concurrent ? ShenandoahPhaseTimings::final_rebuild_freeset : ShenandoahPhaseTimings::degen_gc_final_rebuild_freeset);\n+    ShenandoahGCPhase phase(concurrent ?\n+        ShenandoahPhaseTimings::final_rebuild_freeset :\n+        ShenandoahPhaseTimings::degen_gc_final_rebuild_freeset);\n@@ -327,4 +332,4 @@\n-    case IDLE:          return \"Idle\";\n-    case FILLING:       return \"Coalescing\";\n-    case BOOTSTRAPPING: return \"Bootstrapping\";\n-    case MARKING:       return \"Marking\";\n+    case IDLE:              return \"Idle\";\n+    case FILLING:           return \"Coalescing\";\n+    case BOOTSTRAPPING:     return \"Bootstrapping\";\n+    case MARKING:           return \"Marking\";\n@@ -342,1 +347,1 @@\n-    assert(validate_transition(new_state), \"Invalid state transition.\");\n+    validate_transition(new_state);\n@@ -398,1 +403,1 @@\n-bool ShenandoahOldGeneration::validate_transition(State new_state) {\n+void ShenandoahOldGeneration::validate_transition(State new_state) {\n@@ -407,1 +412,1 @@\n-      return true;\n+      break;\n@@ -411,1 +416,1 @@\n-      return true;\n+      break;\n@@ -416,1 +421,1 @@\n-      return true;\n+      break;\n@@ -421,1 +426,1 @@\n-      return true;\n+      break;\n@@ -425,1 +430,1 @@\n-      return true;\n+      break;\n@@ -429,1 +434,1 @@\n-      return true;\n+      break;\n@@ -431,2 +436,1 @@\n-      ShouldNotReachHere();\n-      return false;\n+      fatal(\"Unknown new state\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.cpp","additions":54,"deletions":50,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -35,2 +35,3 @@\n- public:\n-  ShenandoahOldGeneration(uint max_queues, size_t max_capacity, size_t soft_max_capacity);\n+private:\n+  ShenandoahHeapRegion** _coalesce_and_fill_region_array;\n+  ShenandoahOldHeuristics* _old_heuristics;\n@@ -38,1 +39,2 @@\n-  const char* name() const override;\n+  bool entry_coalesce_and_fill();\n+  bool coalesce_and_fill();\n@@ -40,1 +42,2 @@\n-  bool contains(ShenandoahHeapRegion* region) const override;\n+public:\n+  ShenandoahOldGeneration(uint max_queues, size_t max_capacity, size_t soft_max_capacity);\n@@ -42,1 +45,1 @@\n-  bool contains(oop obj) const override;\n+  virtual ShenandoahHeuristics* initialize_heuristics(ShenandoahMode* gc_mode) override;\n@@ -44,1 +47,3 @@\n-  void parallel_heap_region_iterate(ShenandoahHeapRegionClosure* cl) override;\n+  const char* name() const override {\n+    return \"OLD\";\n+  }\n@@ -46,0 +51,1 @@\n+  void parallel_heap_region_iterate(ShenandoahHeapRegionClosure* cl) override;\n@@ -48,1 +54,2 @@\n-  void set_concurrent_mark_in_progress(bool in_progress) override;\n+  bool contains(ShenandoahHeapRegion* region) const override;\n+  bool contains(oop obj) const override;\n@@ -50,1 +57,2 @@\n-  virtual void cancel_marking() override;\n+  void set_concurrent_mark_in_progress(bool in_progress) override;\n+  bool is_concurrent_mark_in_progress() override;\n@@ -53,1 +61,0 @@\n-\n@@ -55,2 +62,2 @@\n-\n-  virtual ShenandoahHeuristics* initialize_heuristics(ShenandoahMode* gc_mode) override;\n+  virtual void record_success_concurrent(bool abbreviated) override;\n+  virtual void cancel_marking() override;\n@@ -78,4 +85,1 @@\n-  bool is_concurrent_mark_in_progress() override;\n-\n-  virtual void record_success_concurrent(bool abbreviated) override;\n-\n+public:\n@@ -86,7 +90,2 @@\n-  static const char* state_name(State state);\n-\n-  void transition_to(State new_state);\n-\n-#ifdef ASSERT\n-  bool validate_transition(State new_state);\n-#endif\n+private:\n+  State _state;\n@@ -94,0 +93,1 @@\n+public:\n@@ -102,3 +102,1 @@\n- private:\n-  bool entry_coalesce_and_fill();\n-  bool coalesce_and_fill();\n+  static const char* state_name(State state);\n@@ -106,3 +104,2 @@\n-  ShenandoahHeapRegion** _coalesce_and_fill_region_array;\n-  ShenandoahOldHeuristics* _old_heuristics;\n-  State _state;\n+  void transition_to(State new_state);\n+  void validate_transition(State new_state) NOT_DEBUG_RETURN;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.hpp","additions":25,"deletions":28,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-  ShenandoahMarkRefsSuperClosure(ShenandoahObjToScanQueue* q, ShenandoahReferenceProcessor* rp,  ShenandoahObjToScanQueue* old_queue = nullptr);\n+  ShenandoahMarkRefsSuperClosure(ShenandoahObjToScanQueue* q, ShenandoahReferenceProcessor* rp, ShenandoahObjToScanQueue* old_q);\n@@ -79,2 +79,2 @@\n-  ShenandoahMarkUpdateRefsSuperClosure(ShenandoahObjToScanQueue* q, ShenandoahReferenceProcessor* rp, ShenandoahObjToScanQueue* old = nullptr) :\n-    ShenandoahMarkRefsSuperClosure(q, rp, old),\n+  ShenandoahMarkUpdateRefsSuperClosure(ShenandoahObjToScanQueue* q, ShenandoahReferenceProcessor* rp, ShenandoahObjToScanQueue* old_q) :\n+    ShenandoahMarkRefsSuperClosure(q, rp, old_q),\n@@ -93,2 +93,2 @@\n-  ShenandoahMarkUpdateRefsClosure(ShenandoahObjToScanQueue* q, ShenandoahReferenceProcessor* rp, ShenandoahObjToScanQueue* old = nullptr) :\n-    ShenandoahMarkUpdateRefsSuperClosure(q, rp, old) {}\n+  ShenandoahMarkUpdateRefsClosure(ShenandoahObjToScanQueue* q, ShenandoahReferenceProcessor* rp, ShenandoahObjToScanQueue* old_q) :\n+    ShenandoahMarkUpdateRefsSuperClosure(q, rp, old_q) {}\n@@ -107,2 +107,2 @@\n-  ShenandoahMarkRefsClosure(ShenandoahObjToScanQueue* q, ShenandoahReferenceProcessor* rp, ShenandoahObjToScanQueue* old = nullptr) :\n-    ShenandoahMarkRefsSuperClosure(q, rp, old) {};\n+  ShenandoahMarkRefsClosure(ShenandoahObjToScanQueue* q, ShenandoahReferenceProcessor* rp, ShenandoahObjToScanQueue* old_q) :\n+    ShenandoahMarkRefsSuperClosure(q, rp, old_q) {};\n@@ -148,19 +148,0 @@\n-class ShenandoahVerifyRemSetClosure : public BasicOopIterateClosure {\n-  protected:\n-  bool _init_mark;\n-  ShenandoahHeap* _heap;\n-  RememberedScanner* _scanner;\n-\n-  public:\n-\/\/ Argument distinguishes between initial mark or start of update refs verification.\n-  ShenandoahVerifyRemSetClosure(bool init_mark) :\n-      _init_mark(init_mark),\n-      _heap(ShenandoahHeap::heap()),\n-      _scanner(_heap->card_scan()) {  }\n-  template<class T>\n-  inline void work(T* p);\n-\n-  virtual void do_oop(narrowOop* p) { work(p); }\n-  virtual void do_oop(oop* p) { work(p); }\n-};\n-\n@@ -168,1 +149,0 @@\n-\n@@ -170,2 +150,2 @@\n-  ShenandoahHeap* _heap;\n-  RememberedScanner* _scanner;\n+  ShenandoahHeap*    const _heap;\n+  RememberedScanner* const _scanner;\n@@ -174,1 +154,0 @@\n-\n@@ -177,1 +156,1 @@\n-      _scanner(_heap->card_scan()) {  }\n+      _scanner(_heap->card_scan()) {}\n@@ -183,1 +162,1 @@\n-  virtual void do_oop(oop* p) { work(p); }\n+  virtual void do_oop(oop* p)       { work(p); }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOopClosures.hpp","additions":11,"deletions":32,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -58,18 +58,0 @@\n-template<class T>\n-inline void ShenandoahVerifyRemSetClosure::work(T* p) {\n-  T o = RawAccess<>::oop_load(p);\n-  if (!CompressedOops::is_null(o)) {\n-    oop obj = CompressedOops::decode_not_null(o);\n-    if (_heap->is_in_young(obj)) {\n-      size_t card_index = _scanner->card_index_for_addr((HeapWord*) p);\n-      if (_init_mark && !_scanner->is_card_dirty(card_index)) {\n-        ShenandoahAsserts::print_failure(ShenandoahAsserts::_safe_all, obj, p, nullptr,\n-                                        \"Verify init-mark remembered set violation\", \"clean card should be dirty\", __FILE__, __LINE__);\n-      } else if (!_init_mark && !_scanner->is_write_card_dirty(card_index)) {\n-        ShenandoahAsserts::print_failure(ShenandoahAsserts::_safe_all, obj, p, nullptr,\n-                                        \"Verify init-update-refs remembered set violation\", \"clean card should be dirty\", __FILE__, __LINE__);\n-      }\n-    }\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOopClosures.inline.hpp","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-  f(CNT_PREFIX ## ScanClusters,             DESC_PREFIX \"Scan Clusters\")\n+  f(CNT_PREFIX ## ScanClusters,             DESC_PREFIX \"Scan Clusters\")               \\\n@@ -264,2 +264,4 @@\n-  ShenandoahWorkerTimingsTracker(ShenandoahPhaseTimings::Phase phase, ShenandoahPhaseTimings::ParPhase par_phase,\n-                                 uint worker_id, bool cumulative = false);\n+  ShenandoahWorkerTimingsTracker(ShenandoahPhaseTimings::Phase phase,\n+                                 ShenandoahPhaseTimings::ParPhase par_phase,\n+                                 uint worker_id,\n+                                 bool cumulative = false);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahPhaseTimings.hpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n- private:\n+private:\n@@ -48,1 +48,1 @@\n-    inline void do_oop_work(T* p);\n+  inline void do_oop_work(T* p);\n@@ -50,1 +50,1 @@\n- public:\n+public:\n@@ -57,1 +57,1 @@\n-template<ShenandoahGenerationType GENERATION>\n+template <ShenandoahGenerationType GENERATION>\n@@ -59,2 +59,2 @@\n-_queue(q),\n-_mark_context(ShenandoahHeap::heap()->marking_context()) {\n+  _queue(q),\n+  _mark_context(ShenandoahHeap::heap()->marking_context()) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahSTWMark.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -100,1 +100,0 @@\n-    _evacuation_stats = nullptr;\n@@ -211,0 +210,1 @@\n+    \/\/ TODO: Assert underflow\n@@ -227,0 +227,1 @@\n+    \/\/ TODO: Assert underflow\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahThreadLocalData.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+    \/\/ TODO: In non-generational mode, this should still be complete_marking_context()\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahUnload.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -95,1 +95,2 @@\n-        } else if (heap->is_aging_cycle()){\n+        } else if (heap->is_aging_cycle()) {\n+          \/\/ TODO: Does _incr_region_ages imply heap->is_aging_cycle()?\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVMOperations.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-  explicit VM_ShenandoahInitMark(ShenandoahConcurrentGC* gc) :\n+  VM_ShenandoahInitMark(ShenandoahConcurrentGC* gc) :\n@@ -77,1 +77,1 @@\n-  explicit VM_ShenandoahFinalMarkStartEvac(ShenandoahConcurrentGC* gc) :\n+  VM_ShenandoahFinalMarkStartEvac(ShenandoahConcurrentGC* gc) :\n@@ -136,1 +136,1 @@\n-  bool _incr_region_ages;\n+  const bool _incr_region_ages;\n@@ -140,1 +140,2 @@\n-    _gc(gc), _incr_region_ages(incr_region_ages) {};\n+    _gc(gc),\n+    _incr_region_ages(incr_region_ages) {};\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVMOperations.hpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -121,1 +121,3 @@\n-      if ( in_generation(obj) && _map->par_mark(obj)) {\n+      \/\/ TODO: We should consider specializing this closure by generation ==\/!= null,\n+      \/\/ to avoid in_generation check on fast path here for non-generational mode.\n+      if (in_generation(obj) && _map->par_mark(obj)) {\n@@ -147,1 +149,1 @@\n-    ShenandoahHeapRegion* obj_reg = _heap->heap_region_containing(obj);\n+    ShenandoahHeapRegion *obj_reg = _heap->heap_region_containing(obj);\n@@ -158,1 +160,1 @@\n-      HeapWord* obj_addr = cast_from_oop<HeapWord*>(obj);\n+      HeapWord *obj_addr = cast_from_oop<HeapWord*>(obj);\n@@ -223,1 +225,1 @@\n-      HeapWord* fwd_addr = cast_from_oop<HeapWord* >(fwd);\n+      HeapWord *fwd_addr = cast_from_oop<HeapWord *>(fwd);\n@@ -354,2 +356,0 @@\n-    log_debug(gc)(\"ShenandoahCalculateRegionStatsClosure added \" SIZE_FORMAT \" for %s Region \" SIZE_FORMAT \", yielding: \" SIZE_FORMAT,\n-                  r->used(), r->is_humongous()? \"humongous\": \"regular\", r->index(), _used);\n@@ -359,0 +359,2 @@\n+    log_debug(gc)(\"ShenandoahCalculateRegionStatsClosure: adding \" SIZE_FORMAT \" for %s Region \" SIZE_FORMAT \", yielding: \" SIZE_FORMAT,\n+            r->used(), (r->is_humongous() ? \"humongous\" : \"regular\"), r->index(), _used);\n@@ -378,2 +380,1 @@\n-      default:\n-        ShouldNotReachHere();\n+      case FREE:\n@@ -381,1 +382,0 @@\n-      case FREE: return;\n@@ -384,0 +384,1 @@\n+        global.heap_region_do(r);\n@@ -387,0 +388,1 @@\n+        global.heap_region_do(r);\n@@ -388,0 +390,2 @@\n+      default:\n+        ShouldNotReachHere();\n@@ -389,1 +393,0 @@\n-    global.heap_region_do(r);\n@@ -396,1 +399,1 @@\n-                  byte_size_in_proper_unit(stats.used()), proper_unit_for_byte_size(stats.used()));\n+                  byte_size_in_proper_unit(stats.used()),       proper_unit_for_byte_size(stats.used()));\n@@ -405,1 +408,1 @@\n-              byte_size_in_proper_unit(stats.used()), proper_unit_for_byte_size(stats.used()));\n+              byte_size_in_proper_unit(stats.used()),    proper_unit_for_byte_size(stats.used()));\n@@ -582,1 +585,1 @@\n-  ShenandoahHeap* _heap;\n+  ShenandoahHeap *_heap;\n@@ -642,1 +645,1 @@\n-  virtual void work_humongous(ShenandoahHeapRegion* r, ShenandoahVerifierStack& stack, ShenandoahVerifyOopClosure& cl) {\n+  virtual void work_humongous(ShenandoahHeapRegion *r, ShenandoahVerifierStack& stack, ShenandoahVerifyOopClosure& cl) {\n@@ -651,1 +654,1 @@\n-  virtual void work_regular(ShenandoahHeapRegion* r, ShenandoahVerifierStack &stack, ShenandoahVerifyOopClosure &cl) {\n+  virtual void work_regular(ShenandoahHeapRegion *r, ShenandoahVerifierStack &stack, ShenandoahVerifyOopClosure &cl) {\n@@ -684,1 +687,1 @@\n-  void verify_and_follow(HeapWord* addr, ShenandoahVerifierStack &stack, ShenandoahVerifyOopClosure &cl, size_t* processed) {\n+  void verify_and_follow(HeapWord *addr, ShenandoahVerifierStack &stack, ShenandoahVerifyOopClosure &cl, size_t *processed) {\n@@ -714,1 +717,1 @@\n-    if (actual != _expected && !(actual & ShenandoahHeap::OLD_MARKING)) {\n+    if (!verify_gc_state(actual, _expected)) {\n@@ -718,0 +721,7 @@\n+\n+  static bool verify_gc_state(char actual, char expected) {\n+    \/\/ Old generation marking is allowed in all states.\n+    \/\/ TODO: This actually accepts more than just OLD_MARKING.\n+    \/\/ TODO: Also, only accept OLD_MARKING in generational mode.\n+    return (actual == expected) || (actual & ShenandoahHeap::OLD_MARKING);\n+  }\n@@ -777,2 +787,1 @@\n-      \/\/ Old generation marking is allowed in all states.\n-      if (actual != expected && !(actual & ShenandoahHeap::OLD_MARKING)) {\n+      if (!VerifyThreadGCState::verify_gc_state(actual, expected)) {\n@@ -824,14 +833,17 @@\n-    if (remembered == _verify_remembered_for_marking) {\n-      log_debug(gc)(\"Safepoint verification of remembered set at mark\");\n-    } else if (remembered == _verify_remembered_for_updating_references) {\n-      log_debug(gc)(\"Safepoint verification of remembered set at update ref\");\n-    } else if (remembered == _verify_remembered_after_full_gc) {\n-      log_debug(gc)(\"Safepoint verification of remembered set after full gc\");\n-    }\n-\n-    if (remembered == _verify_remembered_for_marking) {\n-      _heap->verify_rem_set_at_mark();\n-    } else if (remembered == _verify_remembered_for_updating_references) {\n-      _heap->verify_rem_set_at_update_ref();\n-    } else if (remembered == _verify_remembered_after_full_gc) {\n-      _heap->verify_rem_set_after_full_gc();\n+    switch (remembered) {\n+      case _verify_remembered_disable:\n+        break;\n+      case _verify_remembered_before_marking:\n+        log_debug(gc)(\"Safepoint verification of remembered set at mark\");\n+        verify_rem_set_before_mark();\n+        break;\n+      case _verify_remembered_before_updating_references:\n+        log_debug(gc)(\"Safepoint verification of remembered set at update ref\");\n+        verify_rem_set_before_update_ref();\n+        break;\n+      case _verify_remembered_after_full_gc:\n+        log_debug(gc)(\"Safepoint verification of remembered set after full gc\");\n+        verify_rem_set_after_full_gc();\n+        break;\n+      default:\n+        fatal(\"Unhandled remembered set verification mode\");\n@@ -844,2 +856,2 @@\n-      ShenandoahGenerationStatsClosure::log_usage(_heap->old_generation(), cl.old);\n-      ShenandoahGenerationStatsClosure::log_usage(_heap->young_generation(), cl.young);\n+      ShenandoahGenerationStatsClosure::log_usage(_heap->old_generation(),    cl.old);\n+      ShenandoahGenerationStatsClosure::log_usage(_heap->young_generation(),  cl.young);\n@@ -849,2 +861,2 @@\n-    ShenandoahGenerationStatsClosure::validate_usage(label, _heap->old_generation(), cl.old);\n-    ShenandoahGenerationStatsClosure::validate_usage(label, _heap->young_generation(), cl.young);\n+    ShenandoahGenerationStatsClosure::validate_usage(label, _heap->old_generation(),    cl.old);\n+    ShenandoahGenerationStatsClosure::validate_usage(label, _heap->young_generation(),  cl.young);\n@@ -969,2 +981,2 @@\n-          \"Before Mark\",\n-          _verify_remembered_for_marking,  \/\/ verify read-only remembered set from bottom() to top()\n+            \"Before Mark\",\n+            _verify_remembered_before_marking,  \/\/ verify read-only remembered set from bottom() to top()\n@@ -1035,1 +1047,1 @@\n-          _verify_remembered_for_updating_references,  \/\/ verify read-write remembered set\n+          _verify_remembered_before_updating_references,  \/\/ verify read-write remembered set\n@@ -1084,13 +1096,0 @@\n-void ShenandoahVerifier::verify_after_generational_fullgc() {\n-  verify_at_safepoint(\n-          \"After Full Generational GC\",\n-          _verify_remembered_after_full_gc,  \/\/ verify read-write remembered set\n-          _verify_forwarded_none,      \/\/ all objects are non-forwarded\n-          _verify_marked_complete,     \/\/ all objects are marked in complete bitmap\n-          _verify_cset_none,           \/\/ no cset references\n-          _verify_liveness_disable,    \/\/ no reliable liveness data anymore\n-          _verify_regions_notrash_nocset, \/\/ no trash, no cset\n-          _verify_gcstate_stable       \/\/ full gc cleaned up everything\n-  );\n-}\n-\n@@ -1100,1 +1099,1 @@\n-          _verify_remembered_disable,  \/\/ do not verify remembered set\n+          _verify_remembered_after_full_gc,  \/\/ verify read-write remembered set\n@@ -1110,0 +1109,1 @@\n+\/\/ TODO: Why this closure does not visit metadata?\n@@ -1130,0 +1130,1 @@\n+\/\/ TODO: Why this closure does not visit metadata?\n@@ -1171,0 +1172,212 @@\n+\n+class ShenandoahVerifyRemSetClosure : public BasicOopIterateClosure {\n+protected:\n+  bool               const _init_mark;\n+  ShenandoahHeap*    const _heap;\n+  RememberedScanner* const _scanner;\n+\n+public:\n+  \/\/ Argument distinguishes between initial mark or start of update refs verification.\n+  ShenandoahVerifyRemSetClosure(bool init_mark) :\n+            _init_mark(init_mark),\n+            _heap(ShenandoahHeap::heap()),\n+            _scanner(_heap->card_scan()) {}\n+\n+  template<class T>\n+  inline void work(T* p) {\n+    T o = RawAccess<>::oop_load(p);\n+    if (!CompressedOops::is_null(o)) {\n+      oop obj = CompressedOops::decode_not_null(o);\n+      if (_heap->is_in_young(obj)) {\n+        size_t card_index = _scanner->card_index_for_addr((HeapWord*) p);\n+        if (_init_mark && !_scanner->is_card_dirty(card_index)) {\n+          ShenandoahAsserts::print_failure(ShenandoahAsserts::_safe_all, obj, p, nullptr,\n+                                           \"Verify init-mark remembered set violation\", \"clean card should be dirty\", __FILE__, __LINE__);\n+        } else if (!_init_mark && !_scanner->is_write_card_dirty(card_index)) {\n+          ShenandoahAsserts::print_failure(ShenandoahAsserts::_safe_all, obj, p, nullptr,\n+                                           \"Verify init-update-refs remembered set violation\", \"clean card should be dirty\", __FILE__, __LINE__);\n+        }\n+      }\n+    }\n+  }\n+\n+  virtual void do_oop(narrowOop* p) { work(p); }\n+  virtual void do_oop(oop* p)       { work(p); }\n+};\n+\n+void ShenandoahVerifier::help_verify_region_rem_set(ShenandoahHeapRegion* r, ShenandoahMarkingContext* ctx, HeapWord* from,\n+                                                    HeapWord* top, HeapWord* registration_watermark, const char* message) {\n+  RememberedScanner* scanner = _heap->card_scan();\n+  ShenandoahVerifyRemSetClosure check_interesting_pointers(false);\n+\n+  HeapWord* obj_addr = from;\n+  if (r->is_humongous_start()) {\n+    oop obj = cast_to_oop(obj_addr);\n+    if ((ctx == nullptr) || ctx->is_marked(obj)) {\n+      size_t card_index = scanner->card_index_for_addr(obj_addr);\n+      \/\/ For humongous objects, the typical object is an array, so the following checks may be overkill\n+      \/\/ For regular objects (not object arrays), if the card holding the start of the object is dirty,\n+      \/\/ we do not need to verify that cards spanning interesting pointers within this object are dirty.\n+      if (!scanner->is_write_card_dirty(card_index) || obj->is_objArray()) {\n+        obj->oop_iterate(&check_interesting_pointers);\n+      }\n+      \/\/ else, object's start is marked dirty and obj is not an objArray, so any interesting pointers are covered\n+    }\n+    \/\/ else, this humongous object is not live so no need to verify its internal pointers\n+\n+    if ((obj_addr < registration_watermark) && !scanner->verify_registration(obj_addr, ctx)) {\n+      ShenandoahAsserts::print_failure(ShenandoahAsserts::_safe_all, obj, obj_addr, nullptr, message,\n+                                       \"object not properly registered\", __FILE__, __LINE__);\n+    }\n+  } else if (!r->is_humongous()) {\n+    while (obj_addr < top) {\n+      oop obj = cast_to_oop(obj_addr);\n+      \/\/ ctx->is_marked() returns true if mark bit set or if obj above TAMS.\n+      if ((ctx == nullptr) || ctx->is_marked(obj)) {\n+        size_t card_index = scanner->card_index_for_addr(obj_addr);\n+        \/\/ For regular objects (not object arrays), if the card holding the start of the object is dirty,\n+        \/\/ we do not need to verify that cards spanning interesting pointers within this object are dirty.\n+        if (!scanner->is_write_card_dirty(card_index) || obj->is_objArray()) {\n+          obj->oop_iterate(&check_interesting_pointers);\n+        }\n+        \/\/ else, object's start is marked dirty and obj is not an objArray, so any interesting pointers are covered\n+\n+        if ((obj_addr < registration_watermark) && !scanner->verify_registration(obj_addr, ctx)) {\n+          ShenandoahAsserts::print_failure(ShenandoahAsserts::_safe_all, obj, obj_addr, nullptr, message,\n+                                           \"object not properly registered\", __FILE__, __LINE__);\n+        }\n+        obj_addr += obj->size();\n+      } else {\n+        \/\/ This object is not live so we don't verify dirty cards contained therein\n+        HeapWord* tams = ctx->top_at_mark_start(r);\n+        obj_addr = ctx->get_next_marked_addr(obj_addr, tams);\n+      }\n+    }\n+  }\n+}\n+\n+\/\/ Assure that the remember set has a dirty card everywhere there is an interesting pointer.\n+\/\/ This examines the read_card_table between bottom() and top() since all PLABS are retired\n+\/\/ before the safepoint for init_mark.  Actually, we retire them before update-references and don't\n+\/\/ restore them until the start of evacuation.\n+void ShenandoahVerifier::verify_rem_set_before_mark() {\n+  shenandoah_assert_safepoint();\n+  assert(_heap->mode()->is_generational(), \"Only verify remembered set for generational operational modes\");\n+\n+  ShenandoahRegionIterator iterator;\n+  RememberedScanner* scanner = _heap->card_scan();\n+  ShenandoahVerifyRemSetClosure check_interesting_pointers(true);\n+  ShenandoahMarkingContext* ctx;\n+\n+  log_debug(gc)(\"Verifying remembered set at %s mark\", _heap->doing_mixed_evacuations()? \"mixed\": \"young\");\n+\n+  if (_heap->is_old_bitmap_stable() || _heap->active_generation()->is_global()) {\n+    ctx = _heap->complete_marking_context();\n+  } else {\n+    ctx = nullptr;\n+  }\n+\n+  while (iterator.has_next()) {\n+    ShenandoahHeapRegion* r = iterator.next();\n+    if (r == nullptr) {\n+      \/\/ TODO: Can this really happen?\n+      break;\n+    }\n+\n+    HeapWord* tams = (ctx != nullptr) ? ctx->top_at_mark_start(r) : nullptr;\n+\n+    \/\/ TODO: Is this replaceable with call to help_verify_region_rem_set?\n+\n+    if (r->is_old() && r->is_active()) {\n+      HeapWord* obj_addr = r->bottom();\n+      if (r->is_humongous_start()) {\n+        oop obj = cast_to_oop(obj_addr);\n+        if ((ctx == nullptr) || ctx->is_marked(obj)) {\n+          \/\/ For humongous objects, the typical object is an array, so the following checks may be overkill\n+          \/\/ For regular objects (not object arrays), if the card holding the start of the object is dirty,\n+          \/\/ we do not need to verify that cards spanning interesting pointers within this object are dirty.\n+          if (!scanner->is_card_dirty(obj_addr) || obj->is_objArray()) {\n+            obj->oop_iterate(&check_interesting_pointers);\n+          }\n+          \/\/ else, object's start is marked dirty and obj is not an objArray, so any interesting pointers are covered\n+        }\n+        \/\/ else, this humongous object is not marked so no need to verify its internal pointers\n+        if (!scanner->verify_registration(obj_addr, ctx)) {\n+          ShenandoahAsserts::print_failure(ShenandoahAsserts::_safe_all, obj, obj_addr, nullptr,\n+                                           \"Verify init-mark remembered set violation\", \"object not properly registered\", __FILE__, __LINE__);\n+        }\n+      } else if (!r->is_humongous()) {\n+        HeapWord* top = r->top();\n+        while (obj_addr < top) {\n+          oop obj = cast_to_oop(obj_addr);\n+          \/\/ ctx->is_marked() returns true if mark bit set (TAMS not relevant during init mark)\n+          if ((ctx == nullptr) || ctx->is_marked(obj)) {\n+            \/\/ For regular objects (not object arrays), if the card holding the start of the object is dirty,\n+            \/\/ we do not need to verify that cards spanning interesting pointers within this object are dirty.\n+            if (!scanner->is_card_dirty(obj_addr) || obj->is_objArray()) {\n+              obj->oop_iterate(&check_interesting_pointers);\n+            }\n+            \/\/ else, object's start is marked dirty and obj is not an objArray, so any interesting pointers are covered\n+            if (!scanner->verify_registration(obj_addr, ctx)) {\n+              ShenandoahAsserts::print_failure(ShenandoahAsserts::_safe_all, obj, obj_addr, nullptr,\n+                                               \"Verify init-mark remembered set violation\", \"object not properly registered\", __FILE__, __LINE__);\n+            }\n+            obj_addr += obj->size();\n+          } else {\n+            \/\/ This object is not live so we don't verify dirty cards contained therein\n+            assert(tams != nullptr, \"If object is not live, ctx and tams should be non-null\");\n+            obj_addr = ctx->get_next_marked_addr(obj_addr, tams);\n+          }\n+        }\n+      } \/\/ else, we ignore humongous continuation region\n+    } \/\/ else, this is not an OLD region so we ignore it\n+  } \/\/ all regions have been processed\n+}\n+\n+void ShenandoahVerifier::verify_rem_set_after_full_gc() {\n+  shenandoah_assert_safepoint();\n+  assert(_heap->mode()->is_generational(), \"Only verify remembered set for generational operational modes\");\n+\n+  ShenandoahRegionIterator iterator;\n+\n+  while (iterator.has_next()) {\n+    ShenandoahHeapRegion* r = iterator.next();\n+    if (r == nullptr) {\n+      \/\/ TODO: Can this really happen?\n+      break;\n+    }\n+    if (r->is_old() && !r->is_cset()) {\n+      help_verify_region_rem_set(r, nullptr, r->bottom(), r->top(), r->top(), \"Remembered set violation at end of Full GC\");\n+    }\n+  }\n+}\n+\n+\/\/ Assure that the remember set has a dirty card everywhere there is an interesting pointer.  Even though\n+\/\/ the update-references scan of remembered set only examines cards up to update_watermark, the remembered\n+\/\/ set should be valid through top.  This examines the write_card_table between bottom() and top() because\n+\/\/ all PLABS are retired immediately before the start of update refs.\n+void ShenandoahVerifier::verify_rem_set_before_update_ref() {\n+  shenandoah_assert_safepoint();\n+  assert(_heap->mode()->is_generational(), \"Only verify remembered set for generational operational modes\");\n+\n+  ShenandoahRegionIterator iterator;\n+  ShenandoahMarkingContext* ctx;\n+\n+  if (_heap->is_old_bitmap_stable() || _heap->active_generation()->is_global()) {\n+    ctx = _heap->complete_marking_context();\n+  } else {\n+    ctx = nullptr;\n+  }\n+\n+  while (iterator.has_next()) {\n+    ShenandoahHeapRegion* r = iterator.next();\n+    if (r == nullptr) {\n+      \/\/ TODO: Can this really happen?\n+      break;\n+    }\n+    if (r->is_old() && !r->is_cset()) {\n+      help_verify_region_rem_set(r, ctx, r->bottom(), r->top(), r->get_update_watermark(),\n+                                 \"Remembered set violation at init-update-references\");\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVerifier.cpp","additions":267,"deletions":54,"binary":false,"changes":321,"status":"modified"},{"patch":"@@ -65,4 +65,3 @@\n-    \/\/ Assure old objects are registered and remembered set cards within the read-only remembered set are dirty\n-    \/\/ for every interesting pointer within each OLD ShenandoahHeapRegion between bottom() and top().  This is\n-    \/\/ appropriate at the init_mark safepoint since all TLABS are retired before we reach this code.\n-    _verify_remembered_for_marking,\n+    \/\/ Old objects should be registered and RS cards within *read-only* RS are dirty for all\n+    \/\/ inter-generational pointers.\n+    _verify_remembered_before_marking,\n@@ -70,3 +69,3 @@\n-    \/\/ Assure old objects are registered and remembered set cards within the read-write remembered set are dirty\n-    \/\/ for every interesting pointer within each OLD ShenandoahHeapRegion between bottom() and top().\n-    _verify_remembered_for_updating_references,\n+    \/\/ Old objects should be registered and RS cards within *read-write* RS are dirty for all\n+    \/\/ inter-generational pointers.\n+    _verify_remembered_before_updating_references,\n@@ -74,2 +73,3 @@\n-    \/\/ Assure old objects are registered and remembered set cards within the read-write remembered set are dirty\n-    \/\/ for every interesting pointer within each OLD ShenandoahHeapRegion between bottom() and top().\n+    \/\/ Old objects should be registered and RS cards within *read-write* RS are dirty for all\n+    \/\/ inter-generational pointers.\n+    \/\/ TODO: This differs from the previous mode by update-watermark() vs top() end range?\n@@ -160,1 +160,1 @@\n-    \/\/ Evacuation is done, objects are forwarded, updating is in progress\n+    \/\/ Evacuation is done, some objects are forwarded, updating is in progress\n@@ -207,1 +207,0 @@\n-  void verify_after_generational_fullgc();\n@@ -215,0 +214,8 @@\n+\n+private:\n+   void help_verify_region_rem_set(ShenandoahHeapRegion* r, ShenandoahMarkingContext* ctx,\n+                                    HeapWord* from, HeapWord* top, HeapWord* update_watermark, const char* message);\n+\n+  void verify_rem_set_before_mark();\n+  void verify_rem_set_before_update_ref();\n+  void verify_rem_set_after_full_gc();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVerifier.hpp","additions":18,"deletions":11,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -40,4 +40,0 @@\n-const char* ShenandoahYoungGeneration::name() const {\n-  return \"YOUNG\";\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahYoungGeneration.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,1 +37,5 @@\n-  const char* name() const override;\n+  virtual ShenandoahHeuristics* initialize_heuristics(ShenandoahMode* gc_mode) override;\n+\n+  const char* name() const override {\n+    return \"YOUNG\";\n+  }\n@@ -40,1 +44,1 @@\n-  void parallel_heap_region_iterate(ShenandoahHeapRegionClosure* cl) override;\n+  bool is_concurrent_mark_in_progress() override;\n@@ -42,0 +46,1 @@\n+  void parallel_heap_region_iterate(ShenandoahHeapRegionClosure* cl) override;\n@@ -47,0 +52,1 @@\n+  void reserve_task_queues(uint workers) override;\n@@ -50,1 +56,0 @@\n-\n@@ -61,4 +66,0 @@\n-  void reserve_task_queues(uint workers) override;\n-\n-  virtual ShenandoahHeuristics* initialize_heuristics(ShenandoahMode* gc_mode) override;\n-\n@@ -66,4 +67,0 @@\n-\n- protected:\n-  bool is_concurrent_mark_in_progress() override;\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahYoungGeneration.hpp","additions":8,"deletions":11,"binary":false,"changes":19,"status":"modified"}]}