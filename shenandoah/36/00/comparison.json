{"files":[{"patch":"@@ -1015,37 +1015,0 @@\n-  \/\/ Register the newly allocated object while we're holding the global lock since there's no synchronization\n-  \/\/ built in to the implementation of register_object().  There are potential races when multiple independent\n-  \/\/ threads are allocating objects, some of which might span the same card region.  For example, consider\n-  \/\/ a card table's memory region within which three objects are being allocated by three different threads:\n-  \/\/\n-  \/\/ objects being \"concurrently\" allocated:\n-  \/\/    [-----a------][-----b-----][--------------c------------------]\n-  \/\/            [---- card table memory range --------------]\n-  \/\/\n-  \/\/ Before any objects are allocated, this card's memory range holds no objects.  Note that:\n-  \/\/   allocation of object a wants to set the has-object, first-start, and last-start attributes of the preceding card region.\n-  \/\/   allocation of object b wants to set the has-object, first-start, and last-start attributes of this card region.\n-  \/\/   allocation of object c also wants to set the has-object, first-start, and last-start attributes of this card region.\n-  \/\/\n-  \/\/ The thread allocating b and the thread allocating c can \"race\" in various ways, resulting in confusion, such as last-start\n-  \/\/ representing object b while first-start represents object c.  This is why we need to require all register_object()\n-  \/\/ invocations to be \"mutually exclusive\".  Later, when we use GCLABs and PLABs to allocate memory for promotions and evacuations,\n-  \/\/ the protocol may work something like the following:\n-  \/\/   1. The GCLAB\/PLAB is allocated by this (or similar) function, while holding the global lock.\n-  \/\/   2. The GCLAB\/PLAB is always aligned at the start of a card memory range\n-  \/\/      and is always a multiple of the card-table memory range size.\n-  \/\/   3. Individual allocations carved from a GCLAB\/PLAB are not immediately registered.\n-  \/\/   4. A PLAB is registered as a single object.\n-  \/\/   5. When a PLAB is eventually retired, all of the objects allocated within the GCLAB\/PLAB are registered in batch by a\n-   \/\/      single thread.  No further synchronization is required because no other allocations will pertain to the same\n-  \/\/      card-table memory ranges.\n-  \/\/\n-  \/\/ The other case that needs special handling is region promotion.  When a region is promoted, all objects contained\n-  \/\/ in it are registered.  Since the region is a multiple of card table memory range sizes, there is no need for\n-  \/\/ synchronization.\n-  \/\/ TODO: figure out how to allow multiple threads to work together to register all of the objects in\n-  \/\/ a promoted region, or at least try to balance the efforts so that different GC threads work\n-  \/\/ on registering the objects of different heap regions.\n-  \/\/\n-  if (mode()->is_generational() && result != NULL && req.affiliation() == ShenandoahRegionAffiliation::OLD_GENERATION) {\n-    ShenandoahHeap::heap()->card_scan()->register_object(result);\n-  }\n@@ -1302,0 +1265,31 @@\n+class ShenandoahTagGCLABClosure : public ThreadClosure {\n+public:\n+  void do_thread(Thread* thread) {\n+    PLAB* gclab = ShenandoahThreadLocalData::gclab(thread);\n+    assert(gclab != NULL, \"GCLAB should be initialized for %s\", thread->name());\n+    if (gclab->words_remaining() > 0) {\n+      ShenandoahHeapRegion* r = ShenandoahHeap::heap()->heap_region_containing(gclab->allocate(0));\n+      r->set_young_lab_flag();\n+    }\n+  }\n+};\n+\n+void ShenandoahHeap::set_young_lab_region_flags() {\n+  if (!UseTLAB) {\n+    return;\n+  }\n+  for (size_t i = 0; i < _num_regions; i++) {\n+    _regions[i]->clear_young_lab_flags();\n+  }\n+  ShenandoahTagGCLABClosure cl;\n+  workers()->threads_do(&cl);\n+  for (JavaThreadIteratorWithHandle jtiwh; JavaThread *t = jtiwh.next(); ) {\n+    cl.do_thread(t);\n+    ThreadLocalAllocBuffer& tlab = t->tlab();\n+    if (tlab.end() != NULL) {\n+      ShenandoahHeapRegion* r = heap_region_containing(tlab.start());\n+      r->set_young_lab_flag();\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":31,"deletions":37,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -601,0 +601,2 @@\n+  void set_young_lab_region_flags();\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -74,0 +74,1 @@\n+  _has_young_lab(false),\n@@ -870,2 +871,0 @@\n-\n-    size_t index_limit = index() + ShenandoahHeapRegion::required_regions(obj->size() * HeapWordSize);\n@@ -873,0 +872,1 @@\n+    size_t index_limit = index() + ShenandoahHeapRegion::required_regions(obj->size() * HeapWordSize);\n@@ -875,1 +875,1 @@\n-      log_debug(gc)(\"promoting region \" SIZE_FORMAT \", clear cards from \" SIZE_FORMAT \" to \" SIZE_FORMAT,\n+      log_debug(gc)(\"promoting region \" SIZE_FORMAT \", from \" SIZE_FORMAT \" to \" SIZE_FORMAT,\n@@ -877,2 +877,6 @@\n-\n-      ShenandoahBarrierSet::barrier_set()->card_table()->clear_MemRegion(MemRegion(r->bottom(), r->end()));\n+      if (top() < end()) {\n+        ShenandoahHeap::fill_with_object(top(), (end() - top()) \/ HeapWordSize);\n+        heap->card_scan()->register_object(top());\n+        ShenandoahBarrierSet::barrier_set()->card_table()->clear_MemRegion(MemRegion(top(), end()));\n+      }\n+      ShenandoahBarrierSet::barrier_set()->card_table()->dirty_MemRegion(MemRegion(bottom(), top()));\n@@ -883,6 +887,0 @@\n-    \/\/ HEY!  Better to call ShenandoahHeap::heap()->card_scan()->mark_range_as_clean(r->bottom(), obj->size())\n-    \/\/  and skip the calls to clear_MemRegion() above.\n-\n-    \/\/ Iterate over all humongous regions that are spanned by the humongous object obj.  The remnant\n-    \/\/ of memory in the last humongous region that is not spanned by obj is currently not used.\n-    obj->oop_iterate(&update_card_values);\n@@ -891,1 +889,1 @@\n-    log_debug(gc)(\"promoting region \" SIZE_FORMAT \", clear cards from \" SIZE_FORMAT \" to \" SIZE_FORMAT,\n+    log_debug(gc)(\"promoting region \" SIZE_FORMAT \", from \" SIZE_FORMAT \" to \" SIZE_FORMAT,\n@@ -895,10 +893,0 @@\n-    \/\/ Rather than scanning entire contents of the promoted region right now to determine which\n-    \/\/ cards to mark dirty, we just mark them all as dirty.  Later, when we scan the remembered\n-    \/\/ set, we will clear cards that are found to not contain live references to young memory.\n-    \/\/ Ultimately, this approach is more efficient as it only scans the \"dirty\" cards once and\n-    \/\/ the clean cards once.  The alternative approach of scanning all cards now and then scanning\n-    \/\/ dirty cards again at next concurrent mark pass scans the clean cards once and the dirty\n-    \/\/ cards twice.\n-\n-    \/\/ HEY!  Better to call ShenandoahHeap::heap()->card_scan()->mark_range_as_dirty(r->bottom(), obj->size());\n-    ShenandoahBarrierSet::barrier_set()->card_table()->dirty_MemRegion(MemRegion(bottom(), end()));\n@@ -908,0 +896,6 @@\n+\n+    ShenandoahBarrierSet::barrier_set()->card_table()->clear_MemRegion(MemRegion(top(), end()));\n+    \/\/ In terms of card marking, We could just set the whole occupied range in this region to dirty instead of iterating here.\n+    \/\/ Card scanning could correct false positives later and that would be more efficient.\n+    \/\/ But oop_iterate_objects() has other, indispensable effects: filling dead objects and registering object starts.\n+    \/\/ So while we are already doing this here, we may as well also set more precise card values.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.cpp","additions":16,"deletions":22,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -215,0 +215,4 @@\n+  void clear_young_lab_flags();\n+  void set_young_lab_flag();\n+  bool has_young_lab_flag();\n+\n@@ -247,0 +251,2 @@\n+  bool _has_young_lab;\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -138,0 +138,12 @@\n+inline void ShenandoahHeapRegion::clear_young_lab_flags() {\n+  _has_young_lab = false;\n+}\n+\n+inline void ShenandoahHeapRegion::set_young_lab_flag() {\n+  _has_young_lab = true;\n+}\n+\n+inline bool ShenandoahHeapRegion::has_young_lab_flag() {\n+  return _has_young_lab;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.inline.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -48,0 +48,3 @@\n+\n+  \/\/ Thread-local allocation buffer for object evacuations.\n+  \/\/ In generational mode, it is exclusive to the young generation.\n@@ -50,0 +53,5 @@\n+\n+  \/\/ Thread-local allocation buffer only used in generational mode.\n+  \/\/ Used both by mutator threads and by GC worker threads\n+  \/\/ for evacuations within the old generation and\n+  \/\/ for promotions from the young generation into the old generation.\n@@ -52,0 +60,1 @@\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahThreadLocalData.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -71,8 +71,5 @@\n-      if (r->is_young()) {\n-        \/\/ The thread that first encounters a humongous start region is responsible\n-        \/\/ for promoting the continuation regions so we need this guard here to\n-        \/\/ keep other worker threads from trying to promote the continuations.\n-        if (r->age() >= InitialTenuringThreshold && !r->is_humongous_continuation()) {\n-          size_t promoted = r->promote();\n-          Atomic::add(&_promoted, promoted);\n-        }\n+      if (r->is_young() && r->age() >= InitialTenuringThreshold && ((r->is_regular() && !r->has_young_lab_flag()) || r->is_humongous_start())) {\n+        \/\/ The above condition filtered out humongous continuations, among other states.\n+        \/\/ Here we rely on promote() below promoting related continuation regions when encountering a homongous start.\n+        size_t promoted = r->promote();\n+        Atomic::add(&_promoted, promoted);\n@@ -86,0 +83,1 @@\n+  ShenandoahHeap::heap()->set_young_lab_region_flags();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahYoungGeneration.cpp","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"}]}