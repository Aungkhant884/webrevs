{"files":[{"patch":"@@ -516,7 +516,2 @@\n-  \/\/ This bit is set iff at least one object starts within a\n-  \/\/ particular card region.\n-  static const uint16_t ObjectStartsInCardRegion = 0x8000;\n-  static const uint16_t FirstStartBits = 0x003f;\n-  static const uint16_t LastStartBits = 0x0fc0;\n-  static const uint16_t FirstStartShift = 0;\n-  static const uint16_t LastStartShift = 6;\n+  typedef struct cross_map { uint8_t first; uint8_t last; } xmap;\n+  typedef union crossing_info { uint16_t short_word; xmap offsets; } crossing_info;\n@@ -524,1 +519,7 @@\n-  uint16_t *object_starts;\n+  \/\/ ObjectStartsInCardRegion bit is set within a crossing_info.offsets.start iff at least one object starts within\n+  \/\/ a particular card region.  We pack this bit into start byte under assumption that start byte is accessed less\n+  \/\/ frequently that last byte.  This is true when number of clean cards is greater than number of dirty cards.\n+  static const uint16_t ObjectStartsInCardRegion = 0x80;\n+  static const uint16_t FirstStartBits           = 0x3f;\n+\n+  crossing_info *object_starts;\n@@ -527,0 +528,1 @@\n+  \/\/ If we're setting first_start, assume the card has an object.\n@@ -528,2 +530,1 @@\n-    object_starts[card_index] &= ~FirstStartBits;\n-    object_starts[card_index] |= (FirstStartBits & (value << FirstStartShift));\n+    object_starts[card_index].offsets.first = ObjectStartsInCardRegion | value;\n@@ -533,2 +534,1 @@\n-    object_starts[card_index] &= ~LastStartBits;\n-    object_starts[card_index] |= (LastStartBits & (value << LastStartShift));\n+    object_starts[card_index].offsets.last = value;\n@@ -538,1 +538,1 @@\n-    object_starts[card_index] |= ObjectStartsInCardRegion;\n+    object_starts[card_index].offsets.first |= ObjectStartsInCardRegion;\n@@ -542,1 +542,6 @@\n-    object_starts[card_index] &= ~ObjectStartsInCardRegion;\n+    object_starts[card_index].offsets.first &= ~ObjectStartsInCardRegion;\n+  }\n+\n+  \/\/ Returns true iff an object is known to start within the card memory associated with card card_index.\n+  inline bool has_object(size_t card_index) {\n+    return (object_starts[card_index].offsets.first & ObjectStartsInCardRegion) != 0;\n@@ -549,1 +554,1 @@\n-      object_starts[card_index++] = 0;\n+      object_starts[card_index++].short_word = 0;\n@@ -556,2 +561,2 @@\n-    object_starts = (uint16_t *) malloc(rs->total_cards() * sizeof(uint16_t));\n-    if (object_starts == NULL)\n+    object_starts = (crossing_info *) malloc(rs->total_cards() * sizeof(crossing_info));\n+    if (object_starts == nullptr)\n@@ -560,1 +565,1 @@\n-      object_starts[i] = 0;\n+      object_starts[i].short_word = 0;\n@@ -564,1 +569,1 @@\n-    if (object_starts != NULL)\n+    if (object_starts != nullptr)\n@@ -568,13 +573,1 @@\n-  \/\/ There is one entry within the object_starts array for each\n-  \/\/ card entry.  The interpretation of the data contained within each\n-  \/\/ object_starts entry is described below:\n-  \/\/\n-  \/\/ Bits 0x003f: Value ranges from 0-63, which is multiplied by 8\n-  \/\/              to obtain the offset at which the first object\n-  \/\/              beginning within this card region begins.\n-  \/\/ Bits 0x0fc0: Value ranges from 0-63, which is multiplied by 8 to\n-  \/\/              obtain the offset at which the last object beginning\n-  \/\/              within this card region begins.\n-  \/\/ Bits 0x8000: This bit is on if an object starts within this card\n-  \/\/              region.\n-  \/\/ Bits 0x7000: Reserved for future uses\n+  \/\/ There is one entry within the object_starts array for each card entry.\n@@ -638,1 +631,1 @@\n-  \/\/      processing the contents of retired GCLAB buffers.\n+  \/\/      processing the contents of retired PLAB buffers.\n@@ -824,6 +817,0 @@\n-  \/\/ Returns true iff an object is known to start within the card memory\n-  \/\/ associated with addr p.\n-  \/\/ Returns true iff an object is known to start within the card memory\n-  \/\/ associated with addr p.\n-  bool has_object(size_t card_index);\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.hpp","additions":26,"deletions":39,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -174,1 +174,1 @@\n-    object_starts[card_at_start + i] = 0;\n+    object_starts[card_at_start + i].short_word = 0;\n@@ -184,0 +184,1 @@\n+\n@@ -194,1 +195,1 @@\n-  if ((object_starts[card_at_start] & ObjectStartsInCardRegion) == 0) {\n+  if (!has_object(card_at_start)) {\n@@ -215,5 +216,12 @@\n-    \/\/ No changes to object_starts array.  Either:\n-    \/\/  get_first_start(card_at_start) returns this coalesced object,\n-    \/\/    or it returns an object that precedes the coalesced object.\n-    \/\/  get_last_start(card_at_start) returns the object that immediately follows the coalesced object,\n-    \/\/    or it returns an object that comes after the object immediately following the coalesced object.\n+    \/\/ There are no changes to the get_first_start array.  Either get_first_start(card_at_start) returns this coalesced object,\n+    \/\/ or it returns an object that precedes the coalesced object.\n+    if (card_start_address + get_last_start(card_at_start) < address + length_in_words) {\n+      uint8_t coalesced_offset = static_cast<uint8_t>(address - card_start_address);\n+      \/\/ The object that used to be the last object starting within this card is being subsumed within the coalesced\n+      \/\/ object.  Since we always coalesce entire objects, this condition only occurs if the last object ends before or at\n+      \/\/ the end of the card's memory range and there is no object following this object.  In this case, adjust last_start\n+      \/\/ to represent the start of the coalesced range.\n+      set_last_start(card_at_start, coalesced_offset);\n+    }\n+    \/\/ Else, no changes to last_starts information.  Either get_last_start(card_at_start) returns the object that immediately\n+    \/\/ follows the coalesced object, or it returns an object that follows the object immediately following the coalesced object.\n@@ -252,6 +260,0 @@\n-template<typename RememberedSet>\n-inline bool\n-ShenandoahCardCluster<RememberedSet>::has_object(size_t card_index) {\n-  return object_starts[card_index] & ObjectStartsInCardRegion;\n-}\n-\n@@ -261,2 +263,2 @@\n-  assert(object_starts[card_index] & ObjectStartsInCardRegion, \"Can't get first start because no object starts here\");\n-  return (object_starts[card_index] & FirstStartBits) >> FirstStartShift;\n+  assert(has_object(card_index), \"Can't get first start because no object starts here\");\n+  return object_starts[card_index].offsets.first & FirstStartBits;\n@@ -268,2 +270,2 @@\n-  assert(object_starts[card_index] & ObjectStartsInCardRegion, \"Can't get last start because no objects starts here\");\n-  return (object_starts[card_index] & LastStartBits) >> LastStartShift;\n+  assert(has_object(card_index), \"Can't get last start because no object starts here\");\n+  return object_starts[card_index].offsets.last;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.inline.hpp","additions":19,"deletions":17,"binary":false,"changes":36,"status":"modified"}]}