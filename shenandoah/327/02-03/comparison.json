{"files":[{"patch":"@@ -155,1 +155,1 @@\n-#define KELVIN_PUZZLE\n+#undef KELVIN_PUZZLE\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -214,1 +214,1 @@\n-#define KELVIN_FULL\n+#undef KELVIN_FULL\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -163,1 +163,1 @@\n-#define KELVIN_FULL\n+#undef KELVIN_FULL\n@@ -904,1 +904,1 @@\n-#define KELVIN_CONTROL\n+#undef KELVIN_CONTROL\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-#define KELVIN_TRACE\n+#undef KELVIN_TRACE\n@@ -105,1 +105,1 @@\n-        \/\/ until we experienced allocation failures, at which point we would perform degen or full GCs.  \n+        \/\/ until we experienced allocation failures, at which point we would perform degen or full GCs.\n@@ -107,1 +107,38 @@\n-        if (start_old_cycle()) {\n+        \/\/ Give priority to starting young cycles.  If both old and young cycle are ready to run, starting the\n+        \/\/ old cycle first is counterproductive, because it will be immediately preempted.  On typical hosts, this\n+        \/\/ would result in 10 ms of context-switching overhead and less than 1 ms of old execution time.  In some\n+        \/\/ cases, it results in much more than 10 ms of context-switching overhead (and delays in the start of young,\n+        \/\/ which may result in degenerated and full gc cycles).  This effect can be exacerbated if old-gen cannot be\n+        \/\/ \"immediately\" preempted.  We have observed very rare delays of over 500 ms (some even longer than 2s) in\n+        \/\/ the processing of these context switch requests.\n+\n+        \/\/ Because we are giving priority to young cycles over old, it is possible that we may starve old entirely.\n+        \/\/ TODO: It may be worthwhile to force a 10ms old timeslice once out of every ten young-cycle dispatches.\n+        \/\/ Similarly, we may want to force an old-gen cycle that was not forced (because young trigger was not active\n+        \/\/ when old wanted to fire) to run a minimum of 20 ms.  The code as is seems to run well with workloads that\n+        \/\/ have been tested, so I'm not introducing this change into the current patch.  Here is what the refinement\n+        \/\/ might look like:\n+        \/\/\n+        \/\/   int cycles_until_forced_old = 10;\n+        \/\/   while (!should_terminate()) {\n+        \/\/     if (should_unload_classes() {\n+        \/\/       ...\n+        \/\/     } else {\n+        \/\/       if (cycles_until_forced_old-- == 0) {\n+        \/\/         cycles_until_forced_old = 10;\n+        \/\/         if (start_old_cycle()) {\n+        \/\/           log_info(gc)(\"Heuristics request for forced old collection accepted\");\n+        \/\/           os::naked_short_sleep(10.0);  \/\/ Let the old-gc run for 10 ms before triggering its preemption\n+        \/\/           continue;                     \/\/ This is not ideal, because old-gc might finish before 10 ms,\n+        \/\/                                         \/\/   but this would very rare, only on final increment of old gc effort.\n+        \/\/         }\n+        \/\/         \/\/ else, old cycle is not required, so fall through to normal control\n+        \/\/       }\n+        \/\/       if (start_young_cycle()) { ... }\n+        \/\/       else if (start_old_cycle()) {\n+        \/\/         \/\/ code as before, but add\n+        \/\/         os::naked_short_sleep(20.0);   \/\/ Let this old-gc run for 20 ms before triggering its preemption\n+        \/\/         cycles_until_forced_old = 20;  \/\/ because we just got 20 ms of execution time, we can delay longer before forced\n+        \/\/       }\n+\n+        if (start_young_cycle()) {\n@@ -111,2 +148,2 @@\n-          log_info(gc)(\"Heuristics request for old collection accepted\");\n-        } else if (start_young_cycle()) {\n+          log_info(gc)(\"Heuristics request for young collection accepted\");\n+        } else if (start_old_cycle()) {\n@@ -116,1 +153,1 @@\n-          log_info(gc)(\"Heuristics request for young collection accepted\");\n+          log_info(gc)(\"Heuristics request for old collection accepted\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRegulatorThread.cpp","additions":43,"deletions":6,"binary":false,"changes":49,"status":"modified"}]}