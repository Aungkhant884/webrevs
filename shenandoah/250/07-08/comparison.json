{"files":[{"patch":"@@ -58,2 +58,11 @@\n-inline bool ShenandoahFreeSet::probe_mutator_set(size_t idx) const {\n-  return _mutator_free_bitmap.at(idx);\n+template <MemoryReserve SET> inline bool ShenandoahFreeSet::probe_set(size_t idx) const {\n+  assert (idx < _max, \"index is sane: \" SIZE_FORMAT \" < \" SIZE_FORMAT \" (left: \" SIZE_FORMAT \", right: \" SIZE_FORMAT \")\",\n+          idx, _max, _collector_leftmost, _collector_rightmost);\n+  switch(SET) {\n+    case Mutator:\n+      return _mutator_free_bitmap.at(idx);\n+    case Collector:\n+      return _collector_free_bitmap.at(idx);\n+    case OldCollector:\n+      return _old_collector_free_bitmap.at(idx);\n+  }\n@@ -62,2 +71,1 @@\n-inline bool ShenandoahFreeSet::in_mutator_set(size_t idx) const {\n-  bool is_mutator_free = _mutator_free_bitmap.at(idx);\n+template <MemoryReserve SET> inline bool ShenandoahFreeSet::in_set(size_t idx) const {\n@@ -66,6 +74,14 @@\n-  assert(!is_mutator_free || has_alloc_capacity(idx), \"Mutator free set should contain useful regions\");\n-  return is_mutator_free;\n-}\n-\n-inline bool ShenandoahFreeSet::probe_collector_set(size_t idx) const {\n-  return _collector_free_bitmap.at(idx);\n+  bool is_free;\n+  switch(SET) {\n+    case Mutator:\n+      is_free = _mutator_free_bitmap.at(idx);\n+      break;\n+    case Collector:\n+      is_free = _collector_free_bitmap.at(idx);;\n+      break;\n+    case OldCollector:\n+      is_free = _old_collector_free_bitmap.at(idx);\n+      break;\n+  }\n+  assert(!is_free || has_alloc_capacity(idx), \"Free set should contain useful regions\");\n+  return is_free;\n@@ -74,2 +90,1 @@\n-inline bool ShenandoahFreeSet::in_collector_set(size_t idx) const {\n-  bool is_collector_free = _collector_free_bitmap.at(idx);\n+template <MemoryReserve SET> inline void ShenandoahFreeSet::expand_bounds_maybe(size_t idx) {\n@@ -77,7 +92,27 @@\n-          idx, _max, _collector_leftmost, _collector_rightmost);\n-  assert(!is_collector_free || has_alloc_capacity(idx), \"Collector free set should contain useful regions\");\n-  return is_collector_free;\n-}\n-\n-inline bool ShenandoahFreeSet::probe_old_collector_set(size_t idx) const {\n-  return _old_collector_free_bitmap.at(idx);\n+          idx, _max, _mutator_leftmost, _mutator_rightmost);\n+  switch(SET) {\n+    case Mutator:\n+      if (idx < _mutator_leftmost) {\n+        _mutator_leftmost = idx;\n+      }\n+      if (idx > _mutator_rightmost) {\n+        _mutator_rightmost = idx;\n+      }\n+      break;\n+    case Collector:\n+      if (idx < _collector_leftmost) {\n+        _collector_leftmost = idx;\n+      }\n+      if (idx > _collector_rightmost) {\n+        _collector_rightmost = idx;\n+      }\n+      break;\n+    case OldCollector:\n+      if (idx < _old_collector_leftmost) {\n+        _old_collector_leftmost = idx;\n+      }\n+      if (idx > _old_collector_rightmost) {\n+        _old_collector_rightmost = idx;\n+      }\n+      break;\n+  }\n@@ -86,2 +121,1 @@\n-inline bool ShenandoahFreeSet::in_old_collector_set(size_t idx) const {\n-  bool is_old_collector_free = _old_collector_free_bitmap.at(idx);\n+template <MemoryReserve SET> inline void ShenandoahFreeSet::add_to_set(size_t idx) {\n@@ -89,23 +123,17 @@\n-          idx, _max, _old_collector_leftmost, _old_collector_rightmost);\n-  assert(!is_old_collector_free || has_alloc_capacity(idx), \"Old collector free set should contain useful regions\");\n-  return is_old_collector_free;\n-}\n-\n-inline void ShenandoahFreeSet::add_to_mutator_set(size_t idx) {\n-  assert(has_alloc_capacity(idx), \"Mutator free set should contain useful regions\");\n-  assert(!in_old_collector_set(idx) && !in_collector_set(idx), \"Freeset membership is mutually exclusive\");\n-  _mutator_free_bitmap.set_bit(idx);\n-}\n-\n-inline void ShenandoahFreeSet::remove_from_mutator_set(size_t idx) {\n-  _mutator_free_bitmap.clear_bit(idx);\n-}\n-\n-inline void ShenandoahFreeSet::add_to_collector_set(size_t idx) {\n-  assert(has_alloc_capacity(idx), \"Collector free set should contain useful regions\");\n-  assert(!in_mutator_set(idx) && !in_old_collector_set(idx), \"Freeset membership is mutually exclusive\");\n-  _collector_free_bitmap.set_bit(idx);\n-}\n-\n-inline void ShenandoahFreeSet::remove_from_collector_set(size_t idx) {\n-  _collector_free_bitmap.clear_bit(idx);\n+          idx, _max, _mutator_leftmost, _mutator_rightmost);\n+  assert(has_alloc_capacity(idx), \"Regions added to free set should have allocation capacity\");\n+  switch(SET) {\n+    case Mutator:\n+      assert(!_collector_free_bitmap.at(idx) && !_old_collector_free_bitmap.at(idx), \"Freeset membership is mutually exclusive\");\n+      _mutator_free_bitmap.set_bit(idx);\n+      break;\n+    case Collector:\n+      assert(!_mutator_free_bitmap.at(idx) && !_old_collector_free_bitmap.at(idx), \"Freeset membership is mutually exclusive\");\n+      _collector_free_bitmap.set_bit(idx);\n+      break;\n+    case OldCollector:\n+      assert(!_mutator_free_bitmap.at(idx) && !_collector_free_bitmap.at(idx), \"Freeset membership is mutually exclusive\");\n+      _old_collector_free_bitmap.set_bit(idx);\n+      break;\n+  }\n+  expand_bounds_maybe<SET>(idx);\n@@ -114,4 +142,15 @@\n-inline void ShenandoahFreeSet::add_to_old_collector_set(size_t idx) {\n-  assert(has_alloc_capacity(idx), \"Old collector free set should contain useful regions\");\n-  assert(!in_mutator_set(idx) && !in_collector_set(idx), \"Freeset membership is mutually exclusive\");\n-  _old_collector_free_bitmap.set_bit(idx);\n+template <MemoryReserve SET> inline void ShenandoahFreeSet::remove_from_set(size_t idx) {\n+  assert (idx < _max, \"index is sane: \" SIZE_FORMAT \" < \" SIZE_FORMAT \" (left: \" SIZE_FORMAT \", right: \" SIZE_FORMAT \")\",\n+          idx, _max, _mutator_leftmost, _mutator_rightmost);\n+  switch(SET) {\n+    case Mutator:\n+      _mutator_free_bitmap.clear_bit(idx);\n+      break;\n+    case Collector:\n+      _collector_free_bitmap.clear_bit(idx);\n+      break;\n+    case OldCollector:\n+      _old_collector_free_bitmap.clear_bit(idx);\n+      break;\n+  }\n+  adjust_bounds_if_touched<SET>(idx);\n@@ -120,2 +159,43 @@\n-inline void ShenandoahFreeSet::remove_from_old_collector_set(size_t idx) {\n-  _old_collector_free_bitmap.clear_bit(idx);\n+\/\/ If idx represents a mutator bound, recompute the mutator bounds, returning true iff bounds were adjusted.\n+template <MemoryReserve SET> bool ShenandoahFreeSet::adjust_bounds_if_touched(size_t idx) {\n+  assert (idx < _max, \"index is sane: \" SIZE_FORMAT \" < \" SIZE_FORMAT \" (left: \" SIZE_FORMAT \", right: \" SIZE_FORMAT \")\",\n+          idx, _max, _mutator_leftmost, _mutator_rightmost);\n+  switch(SET) {\n+    case Mutator:\n+      if (idx == _mutator_leftmost || idx == _mutator_rightmost) {\n+        \/\/ Rewind both mutator bounds until the next bit.\n+        while (_mutator_leftmost < _max && !_mutator_free_bitmap.at(_mutator_leftmost)) {\n+          _mutator_leftmost++;\n+        }\n+        while (_mutator_rightmost > 0 && !_mutator_free_bitmap.at(_mutator_rightmost)) {\n+          _mutator_rightmost--;\n+        }\n+        return true;\n+      }\n+      break;        \n+    case Collector:\n+      if (idx == _collector_leftmost || idx == _collector_rightmost) {\n+        \/\/ Rewind both collector bounds until the next bit.\n+        while (_collector_leftmost < _max && !_collector_free_bitmap.at(_collector_leftmost)) {\n+          _collector_leftmost++;\n+        }\n+        while (_collector_rightmost > 0 && !_collector_free_bitmap.at(_collector_rightmost)) {\n+          _collector_rightmost--;\n+        }\n+        return true;\n+      }\n+      break;        \n+    case OldCollector:\n+      if (idx == _old_collector_leftmost || idx == _old_collector_rightmost) {\n+        \/\/ Rewind both old_collector bounds until the next bit.\n+        while (_old_collector_leftmost < _max && !_old_collector_free_bitmap.at(_old_collector_leftmost)) {\n+          _old_collector_leftmost++;\n+        }\n+        while (_old_collector_rightmost > 0 && !_old_collector_free_bitmap.at(_old_collector_rightmost)) {\n+          _old_collector_rightmost--;\n+        }\n+        return true;\n+      }\n+      break;        \n+  }\n+  return false;\n@@ -124,1 +204,3 @@\n-\n+\/\/ This allocates from a region within the old_collector_set.  If affiliation equals OLD, the allocation must be taken\n+\/\/ from a region that is_old().  Otherwise, affiliation should be FREE, in which case this will put a previously unaffiliated\n+\/\/ region into service.\n@@ -133,1 +215,1 @@\n-      if (in_old_collector_set(c)) {\n+      if (in_set<OldCollector>(c)) {\n@@ -149,1 +231,1 @@\n-      if (in_old_collector_set(idx)) {\n+      if (in_set<OldCollector>(idx)) {\n@@ -169,1 +251,1 @@\n-    if (in_collector_set(idx)) {\n+    if (in_set<Collector>(idx)) {\n@@ -232,1 +314,1 @@\n-        if (in_mutator_set(idx) && (allow_new_region || r->is_affiliated())) {\n+        if (in_set<Mutator>(idx) && (allow_new_region || r->is_affiliated())) {\n@@ -256,1 +338,1 @@\n-          if (in_collector_set(idx)) {\n+          if (in_set<Collector>(idx)) {\n@@ -309,1 +391,1 @@\n-          if (in_mutator_set(idx)) {\n+          if (in_set<Mutator>(idx)) {\n@@ -517,1 +599,1 @@\n-    \/\/ Region cannot afford this or future allocations. Retire it.\n+    \/\/ Region cannot afford this and is likely to not afford future allocations. Retire it.\n@@ -520,1 +602,1 @@\n-    \/\/ fit, but the next small one would, we are risking to inflate scan times when lots of\n+    \/\/ fit but the next small one would, we are risking to inflate scan times when lots of\n@@ -534,4 +616,3 @@\n-      assert(probe_mutator_set(idx), \"Must be mutator free: \" SIZE_FORMAT, idx);\n-      remove_from_mutator_set(idx);\n-      assert(!in_collector_set(idx) && !in_old_collector_set(idx), \"Region cannot be in multiple free sets\");\n-      adjust_mutator_bounds_if_touched(idx);\n+      assert(probe_set<Mutator>(idx), \"Must be mutator free: \" SIZE_FORMAT, idx);\n+      remove_from_set<Mutator>(idx);\n+      assert(!in_set<Collector>(idx) && !in_set<OldCollector>(idx), \"Region cannot be in multiple free sets\");\n@@ -539,1 +620,7 @@\n-      \/\/ Permanently retire this region if there's room for a fill object\n+      \/\/ Permanently retire this region if there's room for a fill object.  By permanently retiring the region,\n+      \/\/ we simplify future allocation efforts.  Regions with \"very limited\" available will not be added to \n+      \/\/ future collector or old_collector sets.  This allows the sets to be more represented more compactly, with\n+      \/\/ a smaller delta between leftmost and rightmost indexes.  It reduces the effort required to find a region\n+      \/\/ with sufficient memory to satisfy future allocation requests.  It reduces the need to rediscover that\n+      \/\/ this region has insufficient memory, eliminates the need to retire the region multiple times, and\n+      \/\/ reduces the need to adjust bounds each time a region is retired.\n@@ -552,1 +639,1 @@\n-      if (probe_old_collector_set(idx)) {\n+      if (probe_set<OldCollector>(idx)) {\n@@ -558,3 +645,2 @@\n-        remove_from_old_collector_set(idx);\n-        assert(!in_collector_set(idx) && !in_mutator_set(idx), \"Region cannot be in multiple free sets\");\n-        adjust_old_collector_bounds_if_touched(idx);\n+        remove_from_set<OldCollector>(idx);\n+        assert(!in_set<Collector>(idx) && !in_set<Mutator>(idx), \"Region cannot be in multiple free sets\");\n@@ -562,1 +648,1 @@\n-        assert(probe_collector_set(idx), \"Region that is not mutator free must be collector free or old collector free\");\n+        assert(probe_set<Collector>(idx), \"Region that is not mutator free must be collector free or old collector free\");\n@@ -567,3 +653,2 @@\n-        remove_from_collector_set(idx);\n-        assert(!in_mutator_set(idx) && !in_old_collector_set(idx), \"Region cannot be in multiple free sets\");\n-        adjust_collector_bounds_if_touched(idx);\n+        remove_from_set<Collector>(idx);\n+        assert(!in_set<Mutator>(idx) && !in_set<OldCollector>(idx), \"Region cannot be in multiple free sets\");\n@@ -577,48 +662,0 @@\n-\/\/ If idx represents a mutator bound, recompute the mutator bounds, returning true iff bounds were adjusted.\n-bool ShenandoahFreeSet::adjust_mutator_bounds_if_touched(size_t idx) {\n-  if (idx == _mutator_leftmost || idx == _mutator_rightmost) {\n-    \/\/ Rewind both mutator bounds until the next bit.\n-    while (_mutator_leftmost < _max && !in_mutator_set(_mutator_leftmost)) {\n-      _mutator_leftmost++;\n-    }\n-    while (_mutator_rightmost > 0 && !in_mutator_set(_mutator_rightmost)) {\n-      _mutator_rightmost--;\n-    }\n-    return true;\n-  } else {\n-    return false;\n-  }\n-}\n-\n-\/\/ If idx represents an old collector bound, recompute the old collector bounds, returning true iff bounds were adjusted.\n-bool ShenandoahFreeSet::adjust_old_collector_bounds_if_touched(size_t idx) {\n-  if (idx == _old_collector_leftmost || idx == _old_collector_rightmost) {\n-    \/\/ Rewind both old collector bounds until the next bit.\n-    while (_old_collector_leftmost < _max && !in_old_collector_set(_old_collector_leftmost)) {\n-      _old_collector_leftmost++;\n-    }\n-    while (_old_collector_rightmost > 0 && !in_old_collector_set(_old_collector_rightmost)) {\n-      _old_collector_rightmost--;\n-    }\n-    return true;\n-  } else {\n-    return false;\n-  }\n-}\n-\n-\/\/ If idx represents a collector bound, recompute the collector bounds, returning true iff bounds were adjusted.\n-bool ShenandoahFreeSet::adjust_collector_bounds_if_touched(size_t idx) {\n-  if (idx == _collector_leftmost || idx == _collector_rightmost) {\n-    \/\/ Rewind both old collector bounds until the next bit.\n-    while (_collector_leftmost < _max && !in_collector_set(_collector_leftmost)) {\n-      _collector_leftmost++;\n-    }\n-    while (_collector_rightmost > 0 && !in_collector_set(_collector_rightmost)) {\n-      _collector_rightmost--;\n-    }\n-    return true;\n-  } else {\n-    return false;\n-  }\n-}\n-\n@@ -648,1 +685,1 @@\n-      if (in_old_collector_set(index)) {\n+      if (in_set<OldCollector>(index)) {\n@@ -654,1 +691,1 @@\n-      if (in_old_collector_set(index)) {\n+      if (in_set<OldCollector>(index)) {\n@@ -670,18 +707,0 @@\n-void ShenandoahFreeSet::expand_collector_bounds_maybe(size_t idx) {\n-  if (idx < _collector_leftmost) {\n-    _collector_leftmost = idx;\n-  }\n-  if (idx > _collector_rightmost) {\n-    _collector_rightmost = idx;\n-  }\n-}\n-\n-void ShenandoahFreeSet::expand_old_collector_bounds_maybe(size_t idx) {\n-  if (idx < _old_collector_leftmost) {\n-    _old_collector_leftmost = idx;\n-  }\n-  if (idx > _old_collector_rightmost) {\n-    _old_collector_rightmost = idx;\n-  }\n-}\n-\n@@ -690,1 +709,1 @@\n-  while (_mutator_leftmost < _max && !in_mutator_set(_mutator_leftmost)) {\n+  while (_mutator_leftmost < _max && !in_set<Mutator>(_mutator_leftmost)) {\n@@ -693,1 +712,1 @@\n-  while (_mutator_rightmost > 0 && !in_mutator_set(_mutator_rightmost)) {\n+  while (_mutator_rightmost > 0 && !in_set<Mutator>(_mutator_rightmost)) {\n@@ -697,1 +716,1 @@\n-  while (_collector_leftmost < _max && !in_collector_set(_collector_leftmost)) {\n+  while (_collector_leftmost < _max && !in_set<Collector>(_collector_leftmost)) {\n@@ -700,1 +719,1 @@\n-  while (_collector_rightmost > 0 && !in_collector_set(_collector_rightmost)) {\n+  while (_collector_rightmost > 0 && !in_set<Collector>(_collector_rightmost)) {\n@@ -704,1 +723,1 @@\n-  while (_old_collector_leftmost < _max && !in_old_collector_set(_old_collector_leftmost)) {\n+  while (_old_collector_leftmost < _max && !in_set<OldCollector>(_old_collector_leftmost)) {\n@@ -707,1 +726,1 @@\n-  while (_old_collector_rightmost > 0 && !in_old_collector_set(_old_collector_rightmost)) {\n+  while (_old_collector_rightmost > 0 && !in_set<OldCollector>(_old_collector_rightmost)) {\n@@ -747,1 +766,1 @@\n-    if (!in_mutator_set(end) || !can_allocate_from(_heap->get_region(end))) {\n+    if (!in_set<Mutator>(end) || !can_allocate_from(_heap->get_region(end))) {\n@@ -801,1 +820,1 @@\n-    remove_from_mutator_set(r->index());\n+    remove_from_set<Mutator>(r->index());\n@@ -891,3 +910,2 @@\n-  remove_from_mutator_set(idx);\n-  add_to_old_collector_set(idx);\n-  expand_old_collector_bounds_maybe(idx);\n+  remove_from_set<Mutator>(idx);\n+  add_to_set<OldCollector>(idx);\n@@ -898,1 +916,0 @@\n-  adjust_mutator_bounds_if_touched(idx);\n@@ -912,3 +929,2 @@\n-  remove_from_mutator_set(idx);\n-  add_to_collector_set(idx);\n-  expand_collector_bounds_maybe(idx);\n+  remove_from_set<Mutator>(idx);\n+  add_to_set<Collector>(idx);\n@@ -917,1 +933,0 @@\n-  adjust_mutator_bounds_if_touched(idx);\n@@ -962,2 +977,2 @@\n-        assert(!in_old_collector_set(idx), \"We are about to add it, it shouldn't be there already\");\n-        add_to_old_collector_set(idx);\n+        assert(!in_set<OldCollector>(idx), \"We are about to add it, it shouldn't be there already\");\n+        add_to_set<OldCollector>(idx);\n@@ -971,2 +986,2 @@\n-        assert(!in_mutator_set(idx), \"We are about to add it, it shouldn't be there already\");\n-        add_to_mutator_set(idx);\n+        assert(!in_set<Mutator>(idx), \"We are about to add it, it shouldn't be there already\");\n+        add_to_set<Mutator>(idx);\n@@ -1016,1 +1031,0 @@\n-  recompute_bounds();\n@@ -1034,2 +1048,2 @@\n-        remove_from_mutator_set(idx);\n-        add_to_old_collector_set(idx);\n+        remove_from_set<Mutator>(idx);\n+        add_to_set<OldCollector>(idx);\n@@ -1045,2 +1059,2 @@\n-        remove_from_mutator_set(idx);\n-        add_to_collector_set(idx);\n+        remove_from_set<Mutator>(idx);\n+        add_to_set<Collector>(idx);\n@@ -1090,1 +1104,1 @@\n-      if (in_mutator_set(i) && in_collector_set(i) && in_old_collector_set(i)) {\n+      if (in_set<Mutator>(i) && in_set<Collector>(i) && in_set<OldCollector>(i)) {\n@@ -1092,1 +1106,1 @@\n-      } else if (in_mutator_set(i) && in_collector_set(i)) {\n+      } else if (in_set<Mutator>(i) && in_set<Collector>(i)) {\n@@ -1095,1 +1109,1 @@\n-      } else if (in_mutator_set(i) && in_old_collector_set(i)) {\n+      } else if (in_set<Mutator>(i) && in_set<OldCollector>(i)) {\n@@ -1098,1 +1112,1 @@\n-      } else if (in_collector_set(i) && in_old_collector_set(i)) {\n+      } else if (in_set<Collector>(i) && in_set<OldCollector>(i)) {\n@@ -1100,1 +1114,1 @@\n-      } else if (in_mutator_set(i)) {\n+      } else if (in_set<Mutator>(i)) {\n@@ -1103,1 +1117,1 @@\n-      } else if (in_collector_set(i)) {\n+      } else if (in_set<Collector>(i)) {\n@@ -1106,1 +1120,1 @@\n-      } else if (in_old_collector_set(i)) {\n+      } else if (in_set<OldCollector>(i)) {\n@@ -1161,1 +1175,1 @@\n-        if (in_mutator_set(idx)) {\n+        if (in_set<Mutator>(idx)) {\n@@ -1224,1 +1238,1 @@\n-        if (in_collector_set(idx)) {\n+        if (in_set<Collector>(idx)) {\n@@ -1244,1 +1258,1 @@\n-        if (in_old_collector_set(idx)) {\n+        if (in_set<OldCollector>(idx)) {\n@@ -1291,1 +1305,1 @@\n-    if (index < _max && in_mutator_set(index)) {\n+    if (index < _max && in_set<Mutator>(index)) {\n@@ -1306,1 +1320,1 @@\n-    if (in_mutator_set(index)) {\n+    if (in_set<Mutator>(index)) {\n@@ -1312,1 +1326,1 @@\n-    if (in_collector_set(index)) {\n+    if (in_set<Collector>(index)) {\n@@ -1345,1 +1359,1 @@\n-    if (in_mutator_set(index)) {\n+    if (in_set<Mutator>(index)) {\n@@ -1383,1 +1397,1 @@\n-    if (in_mutator_set(index)) {\n+    if (in_set<Mutator>(index)) {\n@@ -1415,2 +1429,2 @@\n-  assert (_mutator_leftmost == _max || in_mutator_set(_mutator_leftmost),  \"leftmost region should be free: \" SIZE_FORMAT,  _mutator_leftmost);\n-  assert (_mutator_rightmost == 0   || in_mutator_set(_mutator_rightmost), \"rightmost region should be free: \" SIZE_FORMAT, _mutator_rightmost);\n+  assert (_mutator_leftmost == _max || in_set<Mutator>(_mutator_leftmost),  \"leftmost region should be free: \" SIZE_FORMAT,  _mutator_leftmost);\n+  assert (_mutator_rightmost == 0   || in_set<Mutator>(_mutator_rightmost), \"rightmost region should be free: \" SIZE_FORMAT, _mutator_rightmost);\n@@ -1426,2 +1440,2 @@\n-  assert (_collector_leftmost == _max || in_collector_set(_collector_leftmost),  \"leftmost region should be free: \" SIZE_FORMAT,  _collector_leftmost);\n-  assert (_collector_rightmost == 0   || in_collector_set(_collector_rightmost), \"rightmost region should be free: \" SIZE_FORMAT, _collector_rightmost);\n+  assert (_collector_leftmost == _max || in_set<Collector>(_collector_leftmost),  \"leftmost region should be free: \" SIZE_FORMAT,  _collector_leftmost);\n+  assert (_collector_rightmost == 0   || in_set<Collector>(_collector_rightmost), \"rightmost region should be free: \" SIZE_FORMAT, _collector_rightmost);\n@@ -1437,2 +1451,2 @@\n-  assert (_old_collector_leftmost == _max || in_old_collector_set(_old_collector_leftmost),  \"leftmost region should be free: \" SIZE_FORMAT,  _old_collector_leftmost);\n-  assert (_old_collector_rightmost == 0   || in_old_collector_set(_old_collector_rightmost), \"rightmost region should be free: \" SIZE_FORMAT, _old_collector_rightmost);\n+  assert (_old_collector_leftmost == _max || in_set<OldCollector>(_old_collector_leftmost),  \"leftmost region should be free: \" SIZE_FORMAT,  _old_collector_leftmost);\n+  assert (_old_collector_rightmost == 0   || in_set<OldCollector>(_old_collector_rightmost), \"rightmost region should be free: \" SIZE_FORMAT, _old_collector_rightmost);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":200,"deletions":186,"binary":false,"changes":386,"status":"modified"},{"patch":"@@ -32,0 +32,6 @@\n+enum MemoryReserve {\n+  Mutator,\n+  Collector,\n+  OldCollector\n+};\n+\n@@ -34,0 +40,1 @@\n+\n@@ -52,2 +59,6 @@\n-  \/\/ The sets are not necessarily contiguous.  It is common for collector_is_free regions to reside within the mutator_is_free\n-  \/\/ range, and for _old_collector_is_free regions to reside within the collector_is_free range.\n+  \/\/ For a free set of a given kind (mutator, collector, old_collector), we maintain left and right indices to limit\n+  \/\/ searching. The intervals represented by these extremal indices designate the lowest and highest indices at which\n+  \/\/ that kind of free region exists. These intervals may overlap. In particular, it is quite common for the collector\n+  \/\/ free interval to overlap the mutator free interval on one side (the low end) and the old_collector free interval\n+  \/\/ on the other (the high end).  It is also possible for the mutator interval to overlap the old_collector free\n+  \/\/ interval.\n@@ -55,0 +66,1 @@\n+\n@@ -100,2 +112,1 @@\n-  \/\/ in_xx_set() implies that the region has allocation capacity (i.e. is not yet fully allocated).  Assertions enforce\n-  \/\/ that in_xx_set(idx) implies has_alloc_capacity(idx).\n+  \/\/ in_set() implies that the region has allocation capacity (i.e. is not yet fully allocated) as assured by assertions.\n@@ -105,3 +116,0 @@\n-  inline bool in_mutator_set(size_t idx) const;\n-  inline bool in_collector_set(size_t idx) const;\n-  inline bool in_old_collector_set(size_t idx) const;\n@@ -109,6 +117,1 @@\n-  \/\/ The following three probe routines mimic the behavior is in_mutator_set(), in_collector_set() and in_old_collector_set()\n-  \/\/ but do not assert that the regions have allocation capacity.  These probe routines are used in assertions enforced\n-  \/\/ during certain state transitions.\n-  inline bool probe_mutator_set(size_t idx) const;\n-  inline bool probe_collector_set(size_t idx) const;\n-  inline bool probe_old_collector_set(size_t idx) const;\n+  template <MemoryReserve SET> inline bool in_set(size_t idx) const;\n@@ -116,3 +119,3 @@\n-  inline void add_to_mutator_set(size_t idx);\n-  inline void add_to_collector_set(size_t idx);\n-  inline void add_to_old_collector_set(size_t idx);\n+  \/\/ The following probe routine mimics the behavior is in_set() but does not assert that regions have allocation capacity.\n+  \/\/ This probe routine is used in assertions enforced during certain state transitions.\n+  template <MemoryReserve SET> inline bool probe_set(size_t idx) const;\n@@ -120,3 +123,3 @@\n-  inline void remove_from_mutator_set(size_t idx);\n-  inline void remove_from_collector_set(size_t idx);\n-  inline void remove_from_old_collector_set(size_t idx);\n+  \/\/ The next two methods change set membership of regions\n+  template <MemoryReserve SET> inline void add_to_set(size_t idx);\n+  template <MemoryReserve SSET> inline void remove_from_set(size_t idx);\n@@ -153,2 +156,2 @@\n-  \/\/ Adjust left-most and right-most indexes for the mutator_is_free set after removing region idx from this set.\n-  bool adjust_mutator_bounds_if_touched(size_t idx);\n+  \/\/ Adjust left-most and right-most indexes for the <SET> free set after adding region idx to this set.\n+  template <MemoryReserve SET> inline void expand_bounds_maybe(size_t idx);\n@@ -156,5 +159,2 @@\n-  \/\/ Adjust left-most and right-most indexes for the collector_is_free set after removing region idx from this set.\n-  bool adjust_collector_bounds_if_touched(size_t idx);\n-\n-  \/\/ Adjust left-most and right-most indexes for the old_collector_is_free set after removing region idx from this set.\n-  bool adjust_old_collector_bounds_if_touched(size_t idx);\n+  \/\/ Adjust left-most and right-most indexes for the <SET> free set after removing region idx from this set.\n+  template <MemoryReserve SET> bool adjust_bounds_if_touched(size_t idx);\n@@ -165,6 +165,0 @@\n-  \/\/ Adjust left-most and right-most indexes for the collector_is_free set after adding region idx to this set.\n-  void expand_collector_bounds_maybe(size_t idx);\n-\n-  \/\/ Adjust left-most and right-most indexes for the old_collector_is_free set after adding region idx to this set.\n-  void expand_old_collector_bounds_maybe(size_t idx);\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.hpp","additions":26,"deletions":32,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -312,1 +312,1 @@\n-    OLD_MARKING_BITPOS = 5,\n+    OLD_MARKING_BITPOS = 5\n@@ -322,1 +322,1 @@\n-    OLD_MARKING   = 1 << OLD_MARKING_BITPOS,\n+    OLD_MARKING   = 1 << OLD_MARKING_BITPOS\n@@ -380,0 +380,12 @@\n+  \/\/ At the end of final mark, but before we begin evacuating, heuristics calculate how much memory is required to\n+  \/\/ hold the results of evacuating to young-gen and to old-gen.  These quantitites, stored in _promoted_reserve,\n+  \/\/ _old_evac_reserve, and _young_evac_reserve, are consulted prior to rebuilding the free set (ShenandoahFreeSet)\n+  \/\/ in preparation for evacuation.  When the free set is rebuilt, we make sure to reserve sufficient memory in the\n+  \/\/ collector and old_collector sets to hold if _has_evacuation_reserve_quantities is true.  The other time we\n+  \/\/ rebuild the freeset is at the end of GC, as we prepare to idle GC until the next trigger.  In this case,\n+  \/\/ _has_evacuation_reserve_quantities is false because we don't yet know how much memory will need to be evacuated\n+  \/\/ in the next GC cycle.  When _has_evacuation_reserve_quantities is false, the free set rebuild operation reserves\n+  \/\/ for the collector and old_collector sets based on alternative mechanisms, such as ShenandoahEvacReserve,\n+  \/\/ ShenandoahOldEvacReserve, and ShenandoahOldCompactionReserve.  In a future planned enhancement, the reserve\n+  \/\/ for old_collector set when not _has_evacuation_reserve_quantities is based in part on anticipated promotion as\n+  \/\/ determined by analysis of live data found during the previous GC pass which is one less than the current tenure age.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"}]}