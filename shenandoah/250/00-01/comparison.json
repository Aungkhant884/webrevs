{"files":[{"patch":"@@ -52,1 +52,1 @@\n-void ShenandoahFreeSet::increase_used(size_t num_bytes) {\n+inline void ShenandoahFreeSet::increase_used(size_t num_bytes) {\n@@ -56,2 +56,10 @@\n-  assert(_used <= _capacity, \"must not use more than we have: used: \" SIZE_FORMAT\n-         \", capacity: \" SIZE_FORMAT \", num_bytes: \" SIZE_FORMAT, _used, _capacity, num_bytes);\n+#undef KELVIN_INCREASE_USED\n+#ifdef KELVIN_INCREASE_USED\n+  log_info(gc, ergo)(\"FreeSet::increase_used by \" SIZE_FORMAT \", yielding \" SIZE_FORMAT, num_bytes, _used);\n+#endif\n+  assert(_used <= _capacity, \"must not use (\" SIZE_FORMAT \") more than we have (\" SIZE_FORMAT \") after increase by \" SIZE_FORMAT,\n+         _used, _capacity, num_bytes);\n+}\n+\n+inline bool ShenandoahFreeSet::peek_is_mutator_free(size_t idx) const {\n+  return _mutator_free_bitmap.at(idx);\n@@ -60,1 +68,1 @@\n-bool ShenandoahFreeSet::is_mutator_free(size_t idx) const {\n+inline bool ShenandoahFreeSet::is_mutator_free(size_t idx) const {\n@@ -63,0 +71,2 @@\n+  assert(!_mutator_free_bitmap.at(idx) || (alloc_capacity(ShenandoahHeap::heap()->get_region(idx)) > 0),\n+         \"mutator_free implies available memory in region \" SIZE_FORMAT, idx);\n@@ -66,1 +76,5 @@\n-bool ShenandoahFreeSet::is_collector_free(size_t idx) const {\n+inline bool ShenandoahFreeSet::peek_is_collector_free(size_t idx) const {\n+  return _collector_free_bitmap.at(idx);\n+}\n+\n+inline bool ShenandoahFreeSet::is_collector_free(size_t idx) const {\n@@ -69,0 +83,2 @@\n+  assert(!_collector_free_bitmap.at(idx) || (alloc_capacity(ShenandoahHeap::heap()->get_region(idx)) > 0),\n+         \"collector_free implies available memory in region \" SIZE_FORMAT, idx);\n@@ -72,1 +88,5 @@\n-bool ShenandoahFreeSet::is_old_collector_free(size_t idx) const {\n+inline bool ShenandoahFreeSet::peek_is_old_collector_free(size_t idx) const {\n+  return _old_collector_free_bitmap.at(idx);\n+}\n+\n+inline bool ShenandoahFreeSet::is_old_collector_free(size_t idx) const {\n@@ -75,0 +95,2 @@\n+  assert(!_old_collector_free_bitmap.at(idx) || (alloc_capacity(ShenandoahHeap::heap()->get_region(idx)) > 0),\n+         \"old_collector_free implies available memory in region \" SIZE_FORMAT, idx);\n@@ -78,0 +100,34 @@\n+inline void ShenandoahFreeSet::set_mutator_free(size_t idx) {\n+  assert(alloc_capacity(ShenandoahHeap::heap()->get_region(idx)) > 0, \"mutator_free implies available memory in region \"\n+         SIZE_FORMAT, idx);\n+  assert(!is_old_collector_free(idx) && !is_collector_free(idx), \"Freeset membership is mutually exclusive\");\n+  _mutator_free_bitmap.set_bit(idx);\n+}\n+\n+inline void ShenandoahFreeSet::clear_mutator_free(size_t idx) {\n+  _mutator_free_bitmap.clear_bit(idx);\n+}\n+\n+inline void ShenandoahFreeSet::set_collector_free(size_t idx) {\n+  assert(alloc_capacity(ShenandoahHeap::heap()->get_region(idx)) > 0, \"mutator_free implies available memory in region \"\n+         SIZE_FORMAT, idx);\n+  assert(!is_mutator_free(idx) && !is_old_collector_free(idx), \"Freeset membership is mutually exclusive\");\n+  _collector_free_bitmap.set_bit(idx);\n+}\n+\n+inline void ShenandoahFreeSet::clear_collector_free(size_t idx) {\n+  _collector_free_bitmap.clear_bit(idx);\n+}\n+\n+inline void ShenandoahFreeSet::set_old_collector_free(size_t idx) {\n+  assert(alloc_capacity(ShenandoahHeap::heap()->get_region(idx)) > 0, \"old_collector_free implies available memory in region \"\n+         SIZE_FORMAT, idx);\n+  assert(!is_mutator_free(idx) && !is_collector_free(idx), \"Freeset membership is mutually exclusive\");\n+  _old_collector_free_bitmap.set_bit(idx);\n+}\n+\n+inline void ShenandoahFreeSet::clear_old_collector_free(size_t idx) {\n+  _old_collector_free_bitmap.clear_bit(idx);\n+}\n+\n+\n@@ -401,1 +457,0 @@\n-          increase_used(padding);\n@@ -453,1 +508,0 @@\n-        increase_used(padding);\n@@ -494,0 +548,11 @@\n+#ifdef KELVIN_INCREASE_USED\n+  if (result != nullptr) {\n+    log_info(gc, ergo)(\"try_allocate_in() allocated \" SIZE_FORMAT \" in region \" SIZE_FORMAT \", leaving remnant free: \" SIZE_FORMAT,\n+                       size * HeapWordSize, r->index(), r->free());\n+  } else {\n+    log_info(gc, ergo)(\"try_allocate_in() failed to allocate \" SIZE_FORMAT \" in region \" SIZE_FORMAT \", which has free: \" SIZE_FORMAT,\n+                       size * HeapWordSize, r->index(), r->free());\n+  }\n+  log_info(gc, ergo)(\"has_no_alloc_capacity(\" SIZE_FORMAT \") is %d\", r->index(), has_no_alloc_capacity(r));\n+#endif\n+\n@@ -495,0 +560,4 @@\n+#ifdef KELVIN_INCREASE_USED\n+    log_info(gc, ergo)(\"Retire this region\");\n+#endif\n+\n@@ -504,0 +573,1 @@\n+    size_t idx = r->index();\n@@ -511,0 +581,4 @@\n+      assert(peek_is_mutator_free(idx), \"Must be mutator free: \" SIZE_FORMAT, idx);\n+      clear_mutator_free(idx);\n+      assert(!is_collector_free(idx) && !is_old_collector_free(idx), \"Region cannot be in multiple free sets\");\n+      adjust_mutator_bounds_if_touched(idx);\n@@ -513,3 +587,3 @@\n-      if (r->free() >= ShenandoahHeap::min_fill_size()) {\n-        size_t waste = r->free();\n-        HeapWord* fill_addr = r->top();\n+      size_t waste = r->free();\n+      HeapWord* fill_addr = r->top();\n+      if (waste >= ShenandoahHeap::min_fill_size()) {\n@@ -521,6 +595,2 @@\n-        if (_heap->mode()->is_generational()) {\n-          _heap->generation_for(req.affiliation())->increase_used(waste);\n-          if (req.affiliation() == ShenandoahRegionAffiliation::OLD_GENERATION) {\n-            _heap->card_scan()->register_object(fill_addr);\n-          }\n-        }\n+      } else {\n+        waste = 0;              \/\/ if we don't make fill object, then the waste is not permanent\n@@ -528,14 +598,17 @@\n-    }\n-\n-    size_t num = r->index();\n-    _old_collector_free_bitmap.clear_bit(num);\n-    _collector_free_bitmap.clear_bit(num);\n-    _mutator_free_bitmap.clear_bit(num);\n-    \/\/ Touched the bounds? Need to update:\n-    if (touches_bounds(num)) {\n-#ifdef KELVIN_MONITOR\n-      if (!req.is_mutator_alloc()) {\n-        \/\/ I only want to see retiring of _is_collector_free and\n-        \/\/ _is_old_collector_free regions\n-        log_info(gc, ergo)(\"try_allocate_in() retiring region \" SIZE_FORMAT \" with free: \" SIZE_FORMAT\n-                           \" from all sets, and adjusting bounds\", num, r->free());\n+      if (peek_is_old_collector_free(idx)) {\n+        assert(_heap->mode()->is_generational(), \"Old collector free regions only present in generational mode\");\n+        if (waste > 0) {\n+          _heap->old_generation()->increase_used(waste);\n+          _heap->card_scan()->register_object(fill_addr);\n+        }\n+        clear_old_collector_free(idx);\n+        assert(!is_collector_free(idx) && !is_mutator_free(idx), \"Region cannot be in multiple free sets\");\n+        adjust_old_collector_bounds_if_touched(idx);\n+      } else if (peek_is_collector_free(idx)) {\n+        if ((waste > 0) && _heap->mode()->is_generational()) {\n+          _heap->young_generation()->increase_used(waste);\n+        }\n+        \/\/ This applies to both generational and non-generational mode\n+        clear_collector_free(idx);\n+        assert(!is_mutator_free(idx) && !is_old_collector_free(idx), \"Region cannot be in multiple free sets\");\n+        adjust_collector_bounds_if_touched(idx);\n@@ -543,2 +616,0 @@\n-#endif\n-      adjust_bounds();\n@@ -567,0 +638,32 @@\n+\/\/ If idx represents an old collector bound, recompute the old collector bounds, returning true iff bounds were adjusted.\n+bool ShenandoahFreeSet::adjust_old_collector_bounds_if_touched(size_t idx) {\n+  if (idx == _old_collector_leftmost || idx == _old_collector_rightmost) {\n+    \/\/ Rewind both old collector bounds until the next bit.\n+    while (_old_collector_leftmost < _max && !is_old_collector_free(_old_collector_leftmost)) {\n+      _old_collector_leftmost++;\n+    }\n+    while (_old_collector_rightmost > 0 && !is_old_collector_free(_old_collector_rightmost)) {\n+      _old_collector_rightmost--;\n+    }\n+    return true;\n+  } else {\n+    return false;\n+  }\n+}\n+\n+\/\/ If idx represents a collector bound, recompute the collector bounds, returning true iff bounds were adjusted.\n+bool ShenandoahFreeSet::adjust_collector_bounds_if_touched(size_t idx) {\n+  if (idx == _collector_leftmost || idx == _collector_rightmost) {\n+    \/\/ Rewind both old collector bounds until the next bit.\n+    while (_collector_leftmost < _max && !is_collector_free(_collector_leftmost)) {\n+      _collector_leftmost++;\n+    }\n+    while (_collector_rightmost > 0 && !is_collector_free(_collector_rightmost)) {\n+      _collector_rightmost--;\n+    }\n+    return true;\n+  } else {\n+    return false;\n+  }\n+}\n+\n@@ -764,2 +867,1 @@\n-\n-    _mutator_free_bitmap.clear_bit(r->index());\n+    clear_mutator_free(r->index());\n@@ -796,1 +898,1 @@\n-bool ShenandoahFreeSet::can_allocate_from(ShenandoahHeapRegion *r) {\n+bool ShenandoahFreeSet::can_allocate_from(ShenandoahHeapRegion *r) const {\n@@ -800,1 +902,1 @@\n-size_t ShenandoahFreeSet::alloc_capacity(ShenandoahHeapRegion *r) {\n+size_t ShenandoahFreeSet::alloc_capacity(ShenandoahHeapRegion *r) const {\n@@ -809,1 +911,1 @@\n-bool ShenandoahFreeSet::has_no_alloc_capacity(ShenandoahHeapRegion *r) {\n+bool ShenandoahFreeSet::has_no_alloc_capacity(ShenandoahHeapRegion *r) const {\n@@ -844,2 +946,2 @@\n-  _mutator_free_bitmap.clear_bit(idx);\n-  _old_collector_free_bitmap.set_bit(idx);\n+  clear_mutator_free(idx);\n+  set_old_collector_free(idx);\n@@ -854,0 +956,4 @@\n+#ifdef KELVIN_INCREASE_USED\n+  log_info(gc, ergo)(\"Capacity decreased by \" SIZE_FORMAT \" to \" SIZE_FORMAT \" after flipping region \" SIZE_FORMAT\n+                     \" to old collector\", alloc_capacity(r), _capacity, r->index());\n+#endif\n@@ -872,2 +978,2 @@\n-  _mutator_free_bitmap.clear_bit(idx);\n-  _collector_free_bitmap.set_bit(idx);\n+  clear_mutator_free(idx);\n+  set_collector_free(idx);\n@@ -882,0 +988,4 @@\n+#ifdef KELVIN_INCREASE_USED\n+  log_info(gc, ergo)(\"Capacity decreased by \" SIZE_FORMAT \" to \" SIZE_FORMAT \" after flipping region \" SIZE_FORMAT \" to collector\",\n+                     alloc_capacity(r), _capacity, r->index());\n+#endif\n@@ -929,3 +1039,3 @@\n-    _mutator_free_bitmap.clear_bit(idx);\n-    _collector_free_bitmap.clear_bit(idx);\n-    _old_collector_free_bitmap.clear_bit(idx);\n+    clear_mutator_free(idx);\n+    clear_collector_free(idx);\n+    clear_old_collector_free(idx);\n@@ -947,1 +1057,1 @@\n-        _old_collector_free_bitmap.set_bit(idx);\n+        set_old_collector_free(idx);\n@@ -951,0 +1061,5 @@\n+#ifdef KELVIN_INCREASE_USED\n+        log_info(gc, ergo)(\"Rebuild capacity increased by \" SIZE_FORMAT \" to \" SIZE_FORMAT \" for region \" SIZE_FORMAT,\n+                           alloc_capacity(region), _capacity, region->index());\n+#endif\n+\n@@ -953,1 +1068,1 @@\n-        _mutator_free_bitmap.set_bit(idx);\n+        set_mutator_free(idx);\n@@ -1043,2 +1158,2 @@\n-        _mutator_free_bitmap.clear_bit(idx);\n-        _old_collector_free_bitmap.set_bit(idx);\n+        clear_mutator_free(idx);\n+        set_old_collector_free(idx);\n@@ -1047,0 +1162,5 @@\n+#ifdef KELVIN_INCREASE_USED\n+        log_info(gc, ergo)(\"Rebuild reserve capacity decreased by \" SIZE_FORMAT \" to \" SIZE_FORMAT\n+                           \" after flipping region \" SIZE_FORMAT \" to old collector\",\n+                           ac, _capacity, r->index());\n+#endif\n@@ -1060,2 +1180,2 @@\n-        _mutator_free_bitmap.clear_bit(idx);\n-        _collector_free_bitmap.set_bit(idx);\n+        clear_mutator_free(idx);\n+        set_collector_free(idx);\n@@ -1064,0 +1184,5 @@\n+#ifdef KELVIN_INCREASE_USED\n+        log_info(gc, ergo)(\"Rebuild reserve capacity decreased by \" SIZE_FORMAT \" to \" SIZE_FORMAT\n+                           \" after flipping region \" SIZE_FORMAT \" to young collector\",\n+                           ac, _capacity, r->index());\n+#endif\n@@ -1095,0 +1220,5 @@\n+    size_t retired_old = 0;\n+    size_t retired_old_humongous = 0;\n+    size_t retired_young = 0;\n+    size_t retired_young_humongous = 0;\n+    size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n@@ -1100,2 +1230,2 @@\n-                       \" m - mutator_free, c - collector_free, C - old_collector_free,\"\n-                       \" h - humongous young, H - humongous old, ~ - retired old, _ - retired young\");\n+                       \" m:mutator_free c:collector_free C:old_collector_free\"\n+                       \" h:humongous young H:humongous old ~:retired old _:retired young\");\n@@ -1104,1 +1234,1 @@\n-                       \"old collector free range [\" SIZE_FORMAT \"..\" SIZE_FORMAT \"]\",\n+                       \"old collector free range [\" SIZE_FORMAT \"..\" SIZE_FORMAT \"] allocates from %s\",\n@@ -1106,1 +1236,2 @@\n-                       _old_collector_leftmost, _old_collector_rightmost);\n+                       _old_collector_leftmost, _old_collector_rightmost,\n+                       _old_collector_search_left_to_right? \"left to right\": \"right to left\");\n@@ -1133,1 +1264,7 @@\n-        buffer[idx] = (r->is_old())? 'H': 'h';\n+        if (r->is_old()) {\n+          buffer[idx] = 'H';\n+          retired_old_humongous += region_size_bytes;\n+        } else {\n+          buffer[idx] = 'h';\n+          retired_young_humongous += region_size_bytes;\n+        }\n@@ -1135,1 +1272,8 @@\n-        buffer[idx] = (r->is_old())? '~': '_';\n+        if (r->is_old()) {\n+          buffer[idx] = '~';\n+          retired_old += region_size_bytes;\n+        } else {\n+          buffer[idx] = '_';\n+          retired_young += region_size_bytes;\n+        }\n+\n@@ -1145,0 +1289,8 @@\n+    size_t total_young = retired_young + retired_young_humongous;\n+    size_t total_old = retired_old + retired_old_humongous;\n+    log_info(gc, ergo)(\"Retired young: \" SIZE_FORMAT \"%s (including humongous: \" SIZE_FORMAT \"%s), old: \" SIZE_FORMAT\n+                       \"%s (including humongous: \" SIZE_FORMAT \"%s)\",\n+                       byte_size_in_proper_unit(total_young),             proper_unit_for_byte_size(total_young),\n+                       byte_size_in_proper_unit(retired_young_humongous), proper_unit_for_byte_size(retired_young_humongous),\n+                       byte_size_in_proper_unit(total_old),               proper_unit_for_byte_size(total_old),\n+                       byte_size_in_proper_unit(retired_old_humongous),   proper_unit_for_byte_size(retired_old_humongous));\n@@ -1183,1 +1335,4 @@\n-\n+#ifdef KELVIN_INCREASE_USED\n+          log_info(gc, ergo)(\"FreeSet:free increased by \" SIZE_FORMAT \", yielding \" SIZE_FORMAT \", for region \" SIZE_FORMAT,\n+                             free, total_free, idx);\n+#endif\n@@ -1192,0 +1347,4 @@\n+      assert(free == total_free, \"Sum of free within mutator regions (\" SIZE_FORMAT\n+             \") should match mutator capacity (\" SIZE_FORMAT \") minus mutator used (\" SIZE_FORMAT \")\",\n+             total_free, capacity(), used());\n+\n@@ -1433,0 +1592,11 @@\n+\n+  assert (_old_collector_leftmost <= _max, \"leftmost in bounds: \"  SIZE_FORMAT \" < \" SIZE_FORMAT, _old_collector_leftmost,  _max);\n+  assert (_old_collector_rightmost < _max, \"rightmost in bounds: \" SIZE_FORMAT \" < \" SIZE_FORMAT, _old_collector_rightmost, _max);\n+\n+  assert (_old_collector_leftmost == _max || is_old_collector_free(_old_collector_leftmost),  \"leftmost region should be free: \" SIZE_FORMAT,  _old_collector_leftmost);\n+  assert (_old_collector_rightmost == 0   || is_old_collector_free(_old_collector_rightmost), \"rightmost region should be free: \" SIZE_FORMAT, _old_collector_rightmost);\n+\n+  beg_off = _old_collector_free_bitmap.find_first_set_bit(0);\n+  end_off = _old_collector_free_bitmap.find_first_set_bit(_old_collector_rightmost + 1);\n+  assert (beg_off >= _old_collector_leftmost, \"free regions before the leftmost: \" SIZE_FORMAT \", bound \" SIZE_FORMAT, beg_off, _old_collector_leftmost);\n+  assert (end_off == _max,      \"free regions past the rightmost: \" SIZE_FORMAT \", bound \" SIZE_FORMAT,  end_off, _old_collector_rightmost);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":228,"deletions":58,"binary":false,"changes":286,"status":"modified"},{"patch":"@@ -62,3 +62,16 @@\n-  bool is_mutator_free(size_t idx) const;\n-  bool is_collector_free(size_t idx) const;\n-  bool is_old_collector_free(size_t idx) const;\n+  inline bool is_mutator_free(size_t idx) const;\n+  inline bool is_collector_free(size_t idx) const;\n+  inline bool is_old_collector_free(size_t idx) const;\n+\n+  \/\/ Routines that do not assert non-empty free, for use in assertions and during state transitions\n+  inline bool peek_is_mutator_free(size_t idx) const;\n+  inline bool peek_is_collector_free(size_t idx) const;\n+  inline bool peek_is_old_collector_free(size_t idx) const;\n+\n+  inline void set_mutator_free(size_t idx);\n+  inline void set_collector_free(size_t idx);\n+  inline void set_old_collector_free(size_t idx);\n+\n+  inline void clear_mutator_free(size_t idx);\n+  inline void clear_collector_free(size_t idx);\n+  inline void clear_old_collector_free(size_t idx);\n@@ -86,0 +99,2 @@\n+  bool adjust_collector_bounds_if_touched(size_t idx);\n+  bool adjust_old_collector_bounds_if_touched(size_t idx);\n@@ -90,1 +105,1 @@\n-  void increase_used(size_t amount);\n+  inline void increase_used(size_t amount);\n@@ -95,3 +110,3 @@\n-  bool can_allocate_from(ShenandoahHeapRegion *r);\n-  size_t alloc_capacity(ShenandoahHeapRegion *r);\n-  bool has_no_alloc_capacity(ShenandoahHeapRegion *r);\n+  bool can_allocate_from(ShenandoahHeapRegion *r) const;\n+  size_t alloc_capacity(ShenandoahHeapRegion *r) const;\n+  bool has_no_alloc_capacity(ShenandoahHeapRegion *r) const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.hpp","additions":22,"deletions":7,"binary":false,"changes":29,"status":"modified"}]}