{"files":[{"patch":"@@ -74,0 +74,10 @@\n+#ifndef PRODUCT\n+bool AgeTable::is_clear() {\n+  size_t total = 0;\n+  for (size_t* p = sizes; p < sizes + table_size; ++p) {\n+    total += *p;\n+  }\n+  return total == 0;\n+}\n+#endif \/\/ !PRODUCT\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/ageTable.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"memory\/allocation.hpp\"\n@@ -39,1 +40,1 @@\n-class AgeTable {\n+class AgeTable: public CHeapObj<mtGC> {\n@@ -55,0 +56,2 @@\n+  \/\/ check whether it's clear\n+  bool is_clear() PRODUCT_RETURN0;\n@@ -60,1 +63,1 @@\n-    assert(age > 0 && age < table_size, \"invalid age of object\");\n+    assert(age < table_size, \"invalid age of object\");\n@@ -64,2 +67,1 @@\n-  \/\/ Merge another age table with the current one.  Used\n-  \/\/ for parallel young generation gc.\n+  \/\/ Merge another age table with the current one.\n","filename":"src\/hotspot\/share\/gc\/shared\/ageTable.hpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -67,0 +67,2 @@\n+  const uint tenuring_threshold = heap->age_census()->tenuring_threshold();\n+\n@@ -85,1 +87,1 @@\n-      free += ShenandoahHeapRegion::region_size_bytes();\n+      free += region_size_bytes;\n@@ -96,2 +98,1 @@\n-          \/\/ If !is_generational, we cannot ask if is_preselected.  If is_preselected, we know\n-          \/\/   region->age() >= InitialTenuringThreshold).\n+          assert(region->age() >= tenuring_threshold, \"Preselection filter\");\n@@ -102,1 +103,1 @@\n-        } else if (region->is_young() && (region->age() >= InitialTenuringThreshold)) {\n+        } else if (region->is_young() && (region->age() >= tenuring_threshold)) {\n@@ -139,1 +140,1 @@\n-        if (region->is_young() && region->age() >= InitialTenuringThreshold) {\n+        if (region->is_young() && region->age() >= tenuring_threshold) {\n@@ -233,0 +234,4 @@\n+#ifdef ASSERT\n+  const uint tenuring_threshold = ShenandoahHeap::heap()->age_census()->tenuring_threshold();\n+#endif\n+\n@@ -240,1 +245,1 @@\n-      assert(r->age() >= InitialTenuringThreshold, \"Preselected regions must have tenure age\");\n+      assert(r->age() >= tenuring_threshold, \"Preselected regions must have tenure age\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahGenerationalHeuristics.cpp","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -86,0 +86,1 @@\n+  const uint tenuring_threshold = heap->age_census()->tenuring_threshold();\n@@ -112,1 +113,1 @@\n-    } else if (r->age() < InitialTenuringThreshold) {\n+    } else if (r->age() < tenuring_threshold) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahGlobalHeuristics.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -87,0 +87,1 @@\n+  const uint tenuring_threshold = heap->age_census()->tenuring_threshold();\n@@ -95,0 +96,1 @@\n+\n@@ -105,1 +107,1 @@\n-    if (r->age() < InitialTenuringThreshold) {\n+    if (r->age() < tenuring_threshold) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahYoungHeuristics.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,325 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"gc\/shenandoah\/mode\/shenandoahGenerationalMode.hpp\"\n+#include \"gc\/shenandoah\/shenandoahAgeCensus.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n+\n+ShenandoahAgeCensus::ShenandoahAgeCensus() {\n+  assert(ShenandoahHeap::heap()->mode()->is_generational(), \"Only in generational mode\");\n+\n+  _global_age_table = NEW_C_HEAP_ARRAY(AgeTable*, MAX_SNAPSHOTS, mtGC);\n+  CENSUS_NOISE(_global_noise = NEW_C_HEAP_ARRAY(ShenandoahNoiseStats, MAX_SNAPSHOTS, mtGC);)\n+  _tenuring_threshold = NEW_C_HEAP_ARRAY(uint, MAX_SNAPSHOTS, mtGC);\n+\n+  for (int i = 0; i < MAX_SNAPSHOTS; i++) {\n+    \/\/ Note that we don't now get perfdata from age_table\n+    _global_age_table[i] = new AgeTable(false);\n+    CENSUS_NOISE(_global_noise[i].clear();)\n+    \/\/ Sentinel value\n+    _tenuring_threshold[i] = MAX_COHORTS;\n+  }\n+  if (ShenandoahGenerationalAdaptiveTenuring && !ShenandoahGenerationalCensusAtEvac) {\n+    size_t max_workers = ShenandoahHeap::heap()->max_workers();\n+    _local_age_table = NEW_C_HEAP_ARRAY(AgeTable*, max_workers, mtGC);\n+    CENSUS_NOISE(_local_noise = NEW_C_HEAP_ARRAY(ShenandoahNoiseStats, max_workers, mtGC);)\n+    for (uint i = 0; i < max_workers; i++) {\n+      _local_age_table[i] = new AgeTable(false);\n+      CENSUS_NOISE(_local_noise[i].clear();)\n+    }\n+  } else {\n+    _local_age_table = nullptr;\n+  }\n+  _epoch = MAX_SNAPSHOTS - 1;  \/\/ see update_epoch()\n+}\n+\n+CENSUS_NOISE(void ShenandoahAgeCensus::add(uint obj_age, uint region_age, uint region_youth, size_t size, uint worker_id) {)\n+NO_CENSUS_NOISE(void ShenandoahAgeCensus::add(uint obj_age, uint region_age, size_t size, uint worker_id) {)\n+  if (obj_age <= markWord::max_age) {\n+    assert(obj_age < MAX_COHORTS && region_age < MAX_COHORTS, \"Should have been tenured\");\n+#ifdef SHENANDOAH_CENSUS_NOISE\n+    \/\/ Region ageing is stochastic and non-monotonic; this vitiates mortality\n+    \/\/ demographics in ways that might defeat our algorithms. Marking may be a\n+    \/\/ time when we might be able to correct this, but we currently do not do\n+    \/\/ this. Like skipped statistics further below, we want to track the\n+    \/\/ impact of this noise to see if this may be worthwhile. JDK-<TBD>.\n+    uint age = obj_age;\n+    if (region_age > 0) {\n+      add_aged(size, worker_id);   \/\/ this tracking is coarse for now\n+      age += region_age;\n+      if (age >= MAX_COHORTS) {\n+        age = (uint)(MAX_COHORTS - 1);  \/\/ clamp\n+        add_clamped(size, worker_id);\n+      }\n+    }\n+    if (region_youth > 0) {   \/\/ track object volume with retrograde age\n+      add_young(size, worker_id);\n+    }\n+#else   \/\/ SHENANDOAH_CENSUS_NOISE\n+    uint age = MIN2(obj_age + region_age, (uint)(MAX_COHORTS - 1));  \/\/ clamp\n+#endif  \/\/ SHENANDOAH_CENSUS_NOISE\n+    get_local_age_table(worker_id)->add(age, size);\n+  } else {\n+    \/\/ update skipped statistics\n+    CENSUS_NOISE(add_skipped(size, worker_id);)\n+  }\n+}\n+\n+#ifdef SHENANDOAH_CENSUS_NOISE\n+void ShenandoahAgeCensus::add_skipped(size_t size, uint worker_id) {\n+  _local_noise[worker_id].skipped += size;\n+}\n+\n+void ShenandoahAgeCensus::add_aged(size_t size, uint worker_id) {\n+  _local_noise[worker_id].aged += size;\n+}\n+\n+void ShenandoahAgeCensus::add_clamped(size_t size, uint worker_id) {\n+  _local_noise[worker_id].clamped += size;\n+}\n+\n+void ShenandoahAgeCensus::add_young(size_t size, uint worker_id) {\n+  _local_noise[worker_id].young += size;\n+}\n+#endif \/\/ SHENANDOAH_CENSUS_NOISE\n+\n+\/\/ Prepare for a new census update, by clearing appropriate global slots.\n+void ShenandoahAgeCensus::prepare_for_census_update() {\n+  assert(_epoch < MAX_SNAPSHOTS, \"Out of bounds\");\n+  if (++_epoch >= MAX_SNAPSHOTS) {\n+    _epoch=0;\n+  }\n+  _global_age_table[_epoch]->clear();\n+  CENSUS_NOISE(_global_noise[_epoch].clear();)\n+}\n+\n+\/\/ Update the census data from appropriate sources,\n+\/\/ and compute the new tenuring threshold.\n+void ShenandoahAgeCensus::update_census(size_t age0_pop, AgeTable* pv1, AgeTable* pv2) {\n+  \/\/ Check that we won't overwrite existing data: caller is\n+  \/\/ responsible for explicitly clearing the slot via calling\n+  \/\/ prepare_for_census_update().\n+  assert(_global_age_table[_epoch]->is_clear(), \"Dirty decks\");\n+  CENSUS_NOISE(assert(_global_noise[_epoch].is_clear(), \"Dirty decks\");)\n+  if (ShenandoahGenerationalAdaptiveTenuring && !ShenandoahGenerationalCensusAtEvac) {\n+    assert(pv1 == nullptr && pv2 == nullptr, \"Error, check caller\");\n+    \/\/ Seed cohort 0 with population that may have been missed during\n+    \/\/ regular census.\n+    _global_age_table[_epoch]->add((uint)0, age0_pop);\n+\n+    size_t max_workers = ShenandoahHeap::heap()->max_workers();\n+    \/\/ Merge data from local age tables into the global age table for the epoch,\n+    \/\/ clearing the local tables.\n+    for (uint i = 0; i < max_workers; i++) {\n+      \/\/ age stats\n+      _global_age_table[_epoch]->merge(_local_age_table[i]);\n+      _local_age_table[i]->clear();   \/\/ clear for next census\n+      \/\/ Merge noise stats\n+      CENSUS_NOISE(_global_noise[_epoch].merge(_local_noise[i]);)\n+      CENSUS_NOISE(_local_noise[i].clear();)\n+    }\n+  } else {\n+    \/\/ census during evac\n+    assert(pv1 != nullptr && pv2 != nullptr, \"Error, check caller\");\n+    _global_age_table[_epoch]->merge(pv1);\n+    _global_age_table[_epoch]->merge(pv2);\n+  }\n+\n+  update_tenuring_threshold();\n+}\n+\n+\n+\/\/ Reset the epoch for the global age tables,\n+\/\/ clearing all history.\n+void ShenandoahAgeCensus::reset_global() {\n+  assert(_epoch < MAX_SNAPSHOTS, \"Out of bounds\");\n+  for (uint i = 0; i < MAX_SNAPSHOTS; i++) {\n+    _global_age_table[i]->clear();\n+    CENSUS_NOISE(_global_noise[i].clear();)\n+  }\n+  _epoch = MAX_SNAPSHOTS;\n+  assert(_epoch < MAX_SNAPSHOTS, \"Error\");\n+}\n+\n+\/\/ Reset the local age tables, clearing any partial census.\n+void ShenandoahAgeCensus::reset_local() {\n+  if (!ShenandoahGenerationalAdaptiveTenuring || ShenandoahGenerationalCensusAtEvac) {\n+    assert(_local_age_table == nullptr, \"Error\");\n+    return;\n+  }\n+  size_t max_workers = ShenandoahHeap::heap()->max_workers();\n+  for (uint i = 0; i < max_workers; i++) {\n+    _local_age_table[i]->clear();\n+    CENSUS_NOISE(_local_noise[i].clear();)\n+  }\n+}\n+\n+\/\/ Is global census information clear?\n+bool ShenandoahAgeCensus::is_clear_global() {\n+  assert(_epoch < MAX_SNAPSHOTS, \"Out of bounds\");\n+  for (uint i = 0; i < MAX_SNAPSHOTS; i++) {\n+    bool clear = _global_age_table[i]->is_clear();\n+    CENSUS_NOISE(clear |= _global_noise[i].is_clear();)\n+    if (!clear) {\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n+\/\/ Is local census information clear?\n+bool ShenandoahAgeCensus::is_clear_local() {\n+  if (!ShenandoahGenerationalAdaptiveTenuring || ShenandoahGenerationalCensusAtEvac) {\n+    assert(_local_age_table == nullptr, \"Error\");\n+    return true;\n+  }\n+  size_t max_workers = ShenandoahHeap::heap()->max_workers();\n+  for (uint i = 0; i < max_workers; i++) {\n+    bool clear = _local_age_table[i]->is_clear();\n+    CENSUS_NOISE(clear |= _local_noise[i].is_clear();)\n+    if (!clear) {\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n+void ShenandoahAgeCensus::update_tenuring_threshold() {\n+  if (!ShenandoahGenerationalAdaptiveTenuring) {\n+    _tenuring_threshold[_epoch] = InitialTenuringThreshold;\n+  } else {\n+    uint tt = compute_tenuring_threshold();\n+    assert(tt <= MAX_COHORTS, \"Out of bounds\");\n+    _tenuring_threshold[_epoch] = tt;\n+  }\n+  print();\n+  log_trace(gc, age)(\"New tenuring threshold \" UINTX_FORMAT \" (min \" UINTX_FORMAT \", max \" UINTX_FORMAT\")\",\n+    (uintx) _tenuring_threshold[_epoch], ShenandoahGenerationalMinTenuringAge, ShenandoahGenerationalMaxTenuringAge);\n+}\n+\n+uint ShenandoahAgeCensus::compute_tenuring_threshold() {\n+  \/\/ Starting with the oldest cohort with a non-trivial population\n+  \/\/ (as specified by ShenandoahGenerationalTenuringCohortPopulationThreshold) in the\n+  \/\/ previous epoch, and working down the cohorts by age, find the\n+  \/\/ oldest age that has a significant mortality rate (as specified by\n+  \/\/ ShenandoahGenerationalTenuringMortalityRateThreshold). We use this as\n+  \/\/ tenuring age to be used for the evacuation cycle to follow.\n+  \/\/ Results are clamped between user-specified min & max guardrails,\n+  \/\/ so we ignore any cohorts outside ShenandoahGenerational[Min,Max]Age.\n+\n+  \/\/ Current and previous epoch in ring\n+  const uint cur_epoch = _epoch;\n+  const uint prev_epoch = cur_epoch > 0  ? cur_epoch - 1 : markWord::max_age;\n+  uint tenuring_threshold = ShenandoahGenerationalMaxTenuringAge;\n+\n+  \/\/ Current and previous population vectors in ring\n+  const AgeTable* cur_pv = _global_age_table[cur_epoch];\n+  const AgeTable* prev_pv = _global_age_table[prev_epoch];\n+  for (uint i = ShenandoahGenerationalMaxTenuringAge - 1; i > MAX2((uint)ShenandoahGenerationalMinTenuringAge, (uint)0); i--) {\n+    assert(i > 0, \"Index (i-1) would underflow\/wrap\");\n+    \/\/ Cohort of current age i\n+    const size_t cur_pop = cur_pv->sizes[i];\n+    const size_t prev_pop = prev_pv->sizes[i-1];\n+    const double mr = mortality_rate(prev_pop, cur_pop);\n+    \/\/ We ignore any cohorts that had a very low population count, or\n+    \/\/ that have a lower mortality rate than we care to age in young; these\n+    \/\/ cohorts are considered eligible for tenuring when all older\n+    \/\/ cohorts are.\n+    if (prev_pop < ShenandoahGenerationalTenuringCohortPopulationThreshold ||\n+        mr < ShenandoahGenerationalTenuringMortalityRateThreshold) {\n+      tenuring_threshold = i;\n+      continue;\n+    }\n+    return tenuring_threshold;\n+  }\n+  return tenuring_threshold;\n+}\n+\n+\/\/ Mortality rate of a cohort, given its previous and current population\n+double ShenandoahAgeCensus::mortality_rate(size_t prev_pop, size_t cur_pop) {\n+  \/\/ The following also covers the case where both entries are 0\n+  if (prev_pop <= cur_pop) {\n+    \/\/ adjust for inaccurate censuses by finessing the\n+    \/\/ reappearance of dark matter as normal matter;\n+    \/\/ mortality rate is 0 if population remained the same\n+    \/\/ or increased.\n+    if (cur_pop > prev_pop) {\n+      log_trace(gc, age)\n+        (\" (dark matter) Cohort population \" SIZE_FORMAT_W(10) \" to \" SIZE_FORMAT_W(10),\n+        prev_pop*oopSize, cur_pop*oopSize);\n+    }\n+    return 0.0;\n+  }\n+  assert(prev_pop > 0 && prev_pop > cur_pop, \"Error\");\n+  return 1.0 - (((double)cur_pop)\/((double)prev_pop));\n+}\n+\n+void ShenandoahAgeCensus::print() {\n+  \/\/ Print the population vector for the current epoch, and\n+  \/\/ for the previous epoch, as well as the computed mortality\n+  \/\/ ratio for each extant cohort.\n+  const uint cur_epoch = _epoch;\n+  const uint prev_epoch = cur_epoch > 0 ? cur_epoch - 1: markWord::max_age;\n+\n+  const AgeTable* cur_pv = _global_age_table[cur_epoch];\n+  const AgeTable* prev_pv = _global_age_table[prev_epoch];\n+\n+  const uint tt = tenuring_threshold();\n+\n+  size_t total= 0;\n+  for (uint i = 1; i < MAX_COHORTS; i++) {\n+    const size_t prev_pop = prev_pv->sizes[i-1];  \/\/ (i-1) OK because i >= 1\n+    const size_t cur_pop  = cur_pv->sizes[i];\n+    double mr = mortality_rate(prev_pop, cur_pop);\n+    \/\/ Suppress printing when everything is zero\n+    if (prev_pop + cur_pop > 0) {\n+      log_info(gc, age)\n+        (\" - age %3u: prev \" SIZE_FORMAT_W(10) \" bytes, curr \" SIZE_FORMAT_W(10) \" bytes, mortality %.2f \",\n+         i, prev_pop*oopSize, cur_pop*oopSize, mr);\n+    }\n+    total += cur_pop;\n+    if (i == tt) {\n+      \/\/ Underline the cohort for tenuring threshold (if < MAX_COHORTS)\n+      log_info(gc, age)(\"----------------------------------------------------------------------------\");\n+    }\n+  }\n+  CENSUS_NOISE(_global_noise[cur_epoch].print(total);)\n+}\n+\n+#ifdef SHENANDOAH_CENSUS_NOISE\n+void ShenandoahNoiseStats::print(size_t total) {\n+  if (total > 0) {\n+    float f_skipped = (float)skipped\/(float)total;\n+    float f_aged    = (float)aged\/(float)total;\n+    float f_clamped = (float)clamped\/(float)total;\n+    float f_young   = (float)young\/(float)total;\n+    log_info(gc, age)(\"Skipped: \" SIZE_FORMAT_W(10) \" (%.2f),  R-Aged: \" SIZE_FORMAT_W(10) \" (%.2f),  \"\n+                      \"Clamped: \" SIZE_FORMAT_W(10) \" (%.2f),  R-Young: \" SIZE_FORMAT_W(10) \" (%.2f)\",\n+                      skipped*oopSize, f_skipped, aged*oopSize, f_aged,\n+                      clamped*oopSize, f_clamped, young*oopSize, f_young);\n+  }\n+}\n+#endif \/\/ SHENANDOAH_CENSUS_NOISE\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAgeCensus.cpp","additions":325,"deletions":0,"binary":false,"changes":325,"status":"added"},{"patch":"@@ -0,0 +1,180 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHENANDOAH_SHENANDOAHAGECENSUS_HPP\n+#define SHARE_GC_SHENANDOAH_SHENANDOAHAGECENSUS_HPP\n+\n+#include \"gc\/shared\/ageTable.hpp\"\n+\n+#ifndef PRODUCT\n+\/\/ Enable noise instrumentation\n+#define SHENANDOAH_CENSUS_NOISE 1\n+#endif  \/\/ PRODUCT\n+\n+#ifdef SHENANDOAH_CENSUS_NOISE\n+\n+#define CENSUS_NOISE(x) x\n+#define NO_CENSUS_NOISE(x)\n+\n+struct ShenandoahNoiseStats {\n+  size_t skipped;   \/\/ Volume of objects skipped\n+  size_t aged;      \/\/ Volume of objects from aged regions\n+  size_t clamped;   \/\/ Volume of objects whose ages were clamped\n+  size_t young;     \/\/ Volume of (rejuvenated) objects of retrograde age\n+\n+  ShenandoahNoiseStats() {\n+    clear();\n+  }\n+\n+  void clear() {\n+    skipped = 0;\n+    aged = 0;\n+    clamped = 0;\n+    young = 0;\n+  }\n+\n+#ifndef PRODUCT\n+  bool is_clear() {\n+    return (skipped + aged + clamped + young) == 0;\n+  }\n+#endif \/\/ !PRODUCT\n+\n+  void merge(ShenandoahNoiseStats& other) {\n+    skipped += other.skipped;\n+    aged    += other.aged;\n+    clamped += other.clamped;\n+    young   += other.young;\n+  }\n+\n+  void print(size_t total);\n+};\n+#else  \/\/ SHENANDOAH_CENSUS_NOISE\n+#define CENSUS_NOISE(x)\n+#define NO_CENSUS_NOISE(x) x\n+#endif \/\/ SHENANDOAH_CENSUS_NOISE\n+\n+\/\/ A class for tracking a sequence of cohort population vectors (or,\n+\/\/ interchangeably, age tables) for up to C=MAX_COHORTS age cohorts, where a cohort\n+\/\/ represents the set of objects allocated during a specific inter-GC epoch.\n+\/\/ Epochs are demarcated by GC cycles, with those surviving a cycle aging by\n+\/\/ an epoch. The census tracks the historical variation of cohort demographics\n+\/\/ across N=MAX_SNAPSHOTS recent epochs. Since there are at most C age cohorts in\n+\/\/ the population, we need only track at most N=C epochal snapshots to track a\n+\/\/ maximal longitudinal demographics of every object's longitudinal cohort in\n+\/\/ the young generation. The _global_age_table is thus, currently, a C x N (row-major)\n+\/\/ matrix, with C=16, and, for now N=C=16, currently.\n+\/\/ In theory, we might decide to track even longer (N=MAX_SNAPSHOTS) demographic\n+\/\/ histories, but that isn't the case today. In particular, the current tenuring\n+\/\/ threshold algorithm uses only 2 most recent snapshots, with the remaining\n+\/\/ MAX_SNAPSHOTS-2=14 reserved for research purposes.\n+\/\/\n+\/\/ In addition, this class also maintains per worker population vectors into which\n+\/\/ census for the current minor GC is accumulated (during marking or, optionally, during\n+\/\/ evacuation). These are cleared after each marking (resectively, evacuation) cycle,\n+\/\/ once the per-worker data is consolidated into the appropriate population vector\n+\/\/ per minor collection. The _local_age_table is thus C x N, for N GC workers.\n+class ShenandoahAgeCensus: public CHeapObj<mtGC> {\n+  AgeTable** _global_age_table;      \/\/ Global age table used for adapting tenuring threshold, one per snapshot\n+  AgeTable** _local_age_table;       \/\/ Local scratch age tables to track object ages, one per worker\n+\n+#ifdef SHENANDOAH_CENSUS_NOISE\n+  ShenandoahNoiseStats* _global_noise; \/\/ Noise stats, one per snapshot\n+  ShenandoahNoiseStats* _local_noise;  \/\/ Local scratch table for noise stats, one per worker\n+#endif \/\/ SHENANDOAH_CENSUS_NOISE\n+\n+  uint _epoch;                       \/\/ Current epoch (modulo max age)\n+  uint *_tenuring_threshold;         \/\/ An array of the last N tenuring threshold values we\n+                                     \/\/ computed.\n+\n+  \/\/ A private work method invoked by the public compute_tenuring_threshold() method.\n+  \/\/ This uses the data in the ShenandoahAgeCensus object's _global_age_table and the\n+  \/\/ current _epoch to compute a new tenuring threshold, which will be remembered\n+  \/\/ until the next invocation of compute_tenuring_threshold.\n+  uint compute_tenuring_threshold_work();\n+\n+  \/\/ Mortality rate of a cohort, given its population in\n+  \/\/ previous and current epochs\n+  double mortality_rate(size_t prev_pop, size_t cur_pop);\n+\n+  \/\/ Update the tenuring threshold, calling\n+  \/\/ compute_tenuring_threshold to calculate the new\n+  \/\/ value\n+  void update_tenuring_threshold();\n+  uint compute_tenuring_threshold();\n+\n+ public:\n+  enum {\n+    MAX_COHORTS = AgeTable::table_size,    \/\/ = markWord::max_age + 1\n+    MAX_SNAPSHOTS = MAX_COHORTS            \/\/ May change in the future\n+  };\n+\n+  ShenandoahAgeCensus();\n+\n+  \/\/ Return the local age table (population vector) for worker_id.\n+  \/\/ Only used in the case of (ShenandoahGenerationalAdaptiveTenuring && !ShenandoahGenerationalCensusAtEvac)\n+  AgeTable* get_local_age_table(uint worker_id) {\n+    return (AgeTable*) _local_age_table[worker_id];\n+  }\n+\n+  \/\/ Update the local age table for worker_id by size for\n+  \/\/ given obj_age, region_age, and region_youth\n+  CENSUS_NOISE(void add(uint obj_age, uint region_age, uint region_youth, size_t size, uint worker_id);)\n+  NO_CENSUS_NOISE(void add(uint obj_age, uint region_age, size_t size, uint worker_id);)\n+\n+#ifdef SHENANDOAH_CENSUS_NOISE\n+  \/\/ Update the local skip table for worker_id by size\n+  void add_skipped(size_t size, uint worker_id);\n+  \/\/ Update the local aged region volume table for worker_id by size\n+  void add_aged(size_t size, uint worker_id);\n+  \/\/ Update the local clamped object volume table for worker_id by size\n+  void add_clamped(size_t size, uint worker_id);\n+  \/\/ Update the local (rejuvenated) object volume (retrograde age) for worker_id by size\n+  void add_young(size_t size, uint worker_id);\n+#endif \/\/ SHENANDOAH_CENSUS_NOISE\n+\n+  \/\/ Update to a new epoch, creating a slot for new census.\n+  void prepare_for_census_update();\n+\n+  \/\/ Update the census data, and compute the new tenuring threshold.\n+  \/\/ age0_pop is the population of Cohort 0 that may have been missed in\n+  \/\/ the regular census.\n+  void update_census(size_t age0_pop, AgeTable* pv1 = nullptr, AgeTable* pv2 = nullptr);\n+\n+  \/\/ Return the most recently computed tenuring threshold\n+  uint tenuring_threshold() const { return _tenuring_threshold[_epoch]; }\n+\n+  \/\/ Reset the epoch, clearing accumulated census history\n+  void reset_global();\n+  \/\/ Reset any partial census information\n+  void reset_local();\n+\n+  \/\/ Check whether census information is clear\n+  bool is_clear_global();\n+  bool is_clear_local();\n+\n+  \/\/ Print the age census information\n+  void print();\n+};\n+\n+#endif \/\/ SHARE_GC_SHENANDOAH_SHENANDOAHAGECENSUS_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAgeCensus.hpp","additions":180,"deletions":0,"binary":false,"changes":180,"status":"added"},{"patch":"@@ -100,1 +100,1 @@\n-    if (r->age() >= InitialTenuringThreshold) {\n+    if (ShenandoahHeap::heap()->mode()->is_generational() && r->age() >= ShenandoahHeap::heap()->age_census()->tenuring_threshold()) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCollectionSet.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -248,0 +248,3 @@\n+        \/\/ Clear any old\/partial local census data before the start of marking.\n+        heap->age_census()->reset_local();\n+        assert(heap->age_census()->is_clear_local(), \"Error\");\n@@ -260,0 +263,3 @@\n+        \/\/ Clear any old\/partial local census data before the start of marking.\n+        heap->age_census()->reset_local();\n+        assert(heap->age_census()->is_clear_local(), \"Error\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentMark.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -432,1 +432,2 @@\n-  ShenandoahCycleStats evac_stats = heap->evac_tracker()->flush_cycle_to_global();\n+  ShenandoahEvacuationTracker* evac_tracker = heap->evac_tracker();\n+  ShenandoahCycleStats         evac_stats   = evac_tracker->flush_cycle_to_global();\n@@ -441,2 +442,2 @@\n-      ShenandoahEvacuationTracker::print_evacuations_on(&ls, &evac_stats.workers,\n-                                                        &evac_stats.mutators);\n+      evac_tracker->print_evacuations_on(&ls, &evac_stats.workers,\n+                                              &evac_stats.mutators);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahEvacOOMHandler.inline.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"gc\/shenandoah\/shenandoahAgeCensus.hpp\"\n@@ -33,1 +34,1 @@\n-ShenandoahEvacuationStats::ShenandoahEvacuationStats()\n+ShenandoahEvacuationStats::ShenandoahEvacuationStats(bool generational)\n@@ -36,1 +37,10 @@\n-    _age_table(false) {}\n+    _use_age_table(generational && (ShenandoahGenerationalCensusAtEvac || !ShenandoahGenerationalAdaptiveTenuring)) {\n+  if (_use_age_table) {\n+    _age_table = new AgeTable(false);\n+  }\n+}\n+\n+AgeTable* ShenandoahEvacuationStats::age_table() const {\n+  assert(_use_age_table, \"Don't call\");\n+  return _age_table;\n+}\n@@ -43,1 +53,1 @@\n-void ShenandoahEvacuationStats::end_evacuation(size_t bytes, uint age) {\n+void ShenandoahEvacuationStats::end_evacuation(size_t bytes) {\n@@ -46,3 +56,5 @@\n-  if (age > 0) {\n-    _age_table.add(age, bytes >> LogBytesPerWord);\n-  }\n+}\n+\n+void ShenandoahEvacuationStats::record_age(size_t bytes, uint age) {\n+  assert(_use_age_table, \"Don't call!\");\n+  _age_table->add(age, bytes >> LogBytesPerWord);\n@@ -56,2 +68,3 @@\n-\n-  _age_table.merge(&other->_age_table);\n+  if (_use_age_table) {\n+    _age_table->merge(other->age_table());\n+  }\n@@ -63,1 +76,3 @@\n-  _age_table.clear();\n+  if (_use_age_table) {\n+    _age_table->clear();\n+  }\n@@ -75,1 +90,3 @@\n-  _age_table.print_on(st, InitialTenuringThreshold);\n+  if (_use_age_table) {\n+    _age_table->print_on(st, ShenandoahHeap::heap()->age_census()->tenuring_threshold());\n+  }\n@@ -92,1 +109,0 @@\n-  AgeTable young_region_ages(false), old_region_ages(false);\n@@ -94,3 +110,4 @@\n-  for (uint i = 0; i < heap->num_regions(); ++i) {\n-    ShenandoahHeapRegion* r = heap->get_region(i);\n-    if (r->age() > 0 && r->age() < AgeTable::table_size) {\n+  if (_generational) {\n+    AgeTable young_region_ages(false);\n+    for (uint i = 0; i < heap->num_regions(); ++i) {\n+      ShenandoahHeapRegion* r = heap->get_region(i);\n@@ -99,3 +116,0 @@\n-      } else {\n-        assert(r->is_old(), \"Sanity\");\n-        old_region_ages.add(r->age(), r->get_live_data_words());\n@@ -104,0 +118,4 @@\n+    uint tenuring_threshold = heap->age_census()->tenuring_threshold();\n+    st->print(\"Young regions: \");\n+    young_region_ages.print_on(st, tenuring_threshold);\n+    st->cr();\n@@ -105,5 +123,0 @@\n-  st->print(\"Young regions: \");\n-  young_region_ages.print_on(st, InitialTenuringThreshold);\n-  st->cr();\n-  st->print(\"Old regions: \");\n-  old_region_ages.print_on(st, InitialTenuringThreshold);\n@@ -124,1 +137,1 @@\n-  ShenandoahEvacuationStats mutators, workers;\n+  ShenandoahEvacuationStats mutators(_generational), workers(_generational);\n@@ -136,0 +149,11 @@\n+  if (_generational && (ShenandoahGenerationalCensusAtEvac || !ShenandoahGenerationalAdaptiveTenuring)) {\n+    \/\/ Ingest population vectors into the heap's global census\n+    \/\/ data, and use it to compute an appropriate tenuring threshold\n+    \/\/ for use in the next cycle.\n+    ShenandoahAgeCensus* census = ShenandoahHeap::heap()->age_census();\n+    census->prepare_for_census_update();\n+    \/\/ The first argument is used for any age 0 cohort population that we may otherwise have\n+    \/\/ missed during the census. This is non-zero only when census happens at marking.\n+    census->update_census(0, _mutators_global.age_table(), _workers_global.age_table());\n+  }\n+\n@@ -143,2 +167,6 @@\n-void ShenandoahEvacuationTracker::end_evacuation(Thread* thread, size_t bytes, uint age) {\n-  ShenandoahThreadLocalData::end_evacuation(thread, bytes, age);\n+void ShenandoahEvacuationTracker::end_evacuation(Thread* thread, size_t bytes) {\n+  ShenandoahThreadLocalData::end_evacuation(thread, bytes);\n+}\n+\n+void ShenandoahEvacuationTracker::record_age(Thread* thread, size_t bytes, uint age) {\n+  ShenandoahThreadLocalData::record_age(thread, bytes, age);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahEvacTracker.cpp","additions":53,"deletions":25,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -38,1 +38,7 @@\n-  AgeTable _age_table;\n+  bool      _use_age_table;\n+  AgeTable* _age_table;\n+\n+ public:\n+  ShenandoahEvacuationStats(bool generational);\n+\n+  AgeTable* age_table() const;\n@@ -40,2 +46,0 @@\n-public:\n-  ShenandoahEvacuationStats();\n@@ -43,1 +47,2 @@\n-  void end_evacuation(size_t bytes, uint age);\n+  void end_evacuation(size_t bytes);\n+  void record_age(size_t bytes, uint age);\n@@ -57,0 +62,2 @@\n+  bool _generational;\n+\n@@ -61,0 +68,5 @@\n+  ShenandoahEvacuationTracker(bool generational) :\n+   _generational(generational),\n+   _workers_global(generational),\n+   _mutators_global(generational) {}\n+\n@@ -62,1 +74,2 @@\n-  void end_evacuation(Thread* thread, size_t bytes, uint age);\n+  void end_evacuation(Thread* thread, size_t bytes);\n+  void record_age(Thread* thread, size_t bytes, uint age);\n@@ -65,1 +78,1 @@\n-  static void print_evacuations_on(outputStream* st,\n+  void print_evacuations_on(outputStream* st,\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahEvacTracker.hpp","additions":19,"deletions":6,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -449,0 +449,1 @@\n+  uint                           _tenuring_threshold;\n@@ -470,0 +471,1 @@\n+      _tenuring_threshold(0),\n@@ -477,1 +479,5 @@\n-      _worker_id(worker_id) {}\n+      _worker_id(worker_id) {\n+    if (_heap->mode()->is_generational()) {\n+      _tenuring_threshold = _heap->age_census()->tenuring_threshold();\n+    }\n+  }\n@@ -542,1 +548,1 @@\n-        (from_region_age + object_age >= InitialTenuringThreshold)) {\n+        (from_region_age + object_age >= _tenuring_threshold)) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -498,0 +498,3 @@\n+\n+  const uint tenuring_threshold = heap->age_census()->tenuring_threshold();\n+\n@@ -522,1 +525,1 @@\n-    if (r->age() >= InitialTenuringThreshold) {\n+    if (r->age() >= tenuring_threshold) {\n@@ -582,1 +585,1 @@\n-      if (heap->is_aging_cycle() && (r->age() + 1 == InitialTenuringThreshold)) {\n+      if (heap->is_aging_cycle() && (r->age() + 1 == tenuring_threshold)) {\n@@ -625,0 +628,1 @@\n+  bool is_generational = heap->mode()->is_generational();\n@@ -644,0 +648,17 @@\n+  \/\/ Tally the census counts and compute the adaptive tenuring threshold\n+  if (is_generational && ShenandoahGenerationalAdaptiveTenuring && !ShenandoahGenerationalCensusAtEvac) {\n+    \/\/ Objects above TAMS weren't included in the age census. Since they were all\n+    \/\/ allocated in this cycle they belong in the age 0 cohort. We walk over all\n+    \/\/ young regions and sum the volume of objects between TAMS and top.\n+    ShenandoahUpdateCensusZeroCohortClosure age0_cl(complete_marking_context());\n+    heap->young_generation()->heap_region_iterate(&age0_cl);\n+    size_t age0_pop = age0_cl.get_population();\n+\n+    \/\/ Age table updates\n+    ShenandoahAgeCensus* census = heap->age_census();\n+    census->prepare_for_census_update();\n+    \/\/ Update the global census, including the missed age 0 cohort above,\n+    \/\/ along with the census during marking, and compute the tenuring threshold\n+    census->update_census(age0_pop);\n+  }\n+\n@@ -650,1 +671,1 @@\n-    if (heap->mode()->is_generational()) {\n+    if (is_generational) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":24,"deletions":3,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"gc\/shenandoah\/shenandoahAgeCensus.hpp\"\n@@ -242,0 +243,3 @@\n+\n+    \/\/ Age census structure\n+    _age_census = new ShenandoahAgeCensus();\n@@ -554,2 +558,5 @@\n-  _young_generation->initialize_heuristics(_gc_mode);\n-  _old_generation->initialize_heuristics(_gc_mode);\n+  if (mode()->is_generational()) {\n+    _young_generation->initialize_heuristics(_gc_mode);\n+    _old_generation->initialize_heuristics(_gc_mode);\n+  }\n+  _evac_tracker = new ShenandoahEvacuationTracker(mode()->is_generational());\n@@ -586,0 +593,1 @@\n+  _age_census(nullptr),\n@@ -598,1 +606,1 @@\n-  _evac_tracker(new ShenandoahEvacuationTracker()),\n+  _evac_tracker(nullptr),\n@@ -1699,0 +1707,2 @@\n+  uint _tenuring_threshold;\n+\n@@ -1706,2 +1716,7 @@\n-    _concurrent(concurrent)\n-  {}\n+    _concurrent(concurrent),\n+    _tenuring_threshold(0)\n+  {\n+    if (_sh->mode()->is_generational()) {\n+      _tenuring_threshold = _sh->age_census()->tenuring_threshold();\n+    }\n+  }\n@@ -1742,1 +1757,1 @@\n-      } else if (r->is_young() && r->is_active() && (r->age() >= InitialTenuringThreshold)) {\n+      } else if (r->is_young() && r->is_active() && (r->age() >= _tenuring_threshold)) {\n@@ -3462,1 +3477,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":21,"deletions":7,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"gc\/shared\/ageTable.hpp\"\n@@ -33,0 +34,1 @@\n+#include \"gc\/shenandoah\/shenandoahAgeCensus.hpp\"\n@@ -36,0 +38,1 @@\n+#include \"gc\/shenandoah\/shenandoahAsserts.hpp\"\n@@ -42,0 +45,1 @@\n+#include \"gc\/shenandoah\/shenandoahScanRemembered.hpp\"\n@@ -44,1 +48,0 @@\n-#include \"gc\/shenandoah\/shenandoahScanRemembered.hpp\"\n@@ -380,0 +383,2 @@\n+  ShenandoahAgeCensus* _age_census;    \/\/ Age census used for adapting tenuring threshold in generational mode\n+\n@@ -486,0 +491,3 @@\n+  \/\/ Return the age census object for young gen (in generational mode)\n+  inline ShenandoahAgeCensus* age_census() const;\n+\n@@ -884,0 +892,3 @@\n+\n+  \/\/ Return the object's age (at a safepoint or when object isn't\n+  \/\/ mutable by the mutator)\n@@ -886,0 +897,5 @@\n+  \/\/ Return the object's age, or a sentinel value when the age can't\n+  \/\/ necessarily be determined because of concurrent locking by the\n+  \/\/ mutator\n+  static inline uint get_object_age_concurrent(oop obj);\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -321,0 +321,6 @@\n+inline ShenandoahAgeCensus* ShenandoahHeap::age_census() const {\n+  assert(mode()->is_generational(), \"Only in generational mode\");\n+  assert(_age_census != nullptr, \"Error: not initialized\");\n+  return _age_census;\n+}\n+\n@@ -345,1 +351,1 @@\n-    } else if (r->age() + mark.age() >= InitialTenuringThreshold) {\n+    } else if (r->age() + mark.age() >= age_census()->tenuring_threshold()) {\n@@ -473,3 +479,14 @@\n-    _evac_tracker->end_evacuation(thread, size * HeapWordSize, ShenandoahHeap::get_object_age(copy_val));\n-    if (mode()->is_generational() && target_gen == OLD_GENERATION) {\n-      handle_old_evacuation(copy, size, from_region->is_young());\n+    _evac_tracker->end_evacuation(thread, size * HeapWordSize);\n+    if (mode()->is_generational()) {\n+      if (target_gen == OLD_GENERATION) {\n+        handle_old_evacuation(copy, size, from_region->is_young());\n+      } else {\n+        \/\/ When copying to the old generation above, we don't care\n+        \/\/ about recording object age in the census stats.\n+        assert(target_gen == YOUNG_GENERATION, \"Error\");\n+        \/\/ We record this census only when simulating pre-adaptive tenuring behavior, or\n+        \/\/ when we have been asked to record the census at evacuation rather than at mark\n+        if (ShenandoahGenerationalCensusAtEvac || !ShenandoahGenerationalAdaptiveTenuring) {\n+          _evac_tracker->record_age(thread, size * HeapWordSize, ShenandoahHeap::get_object_age(copy_val));\n+        }\n+      }\n@@ -532,0 +549,2 @@\n+\/\/ Return the object's age (at a safepoint or when object isn't\n+\/\/ mutable by the mutator)\n@@ -534,0 +553,17 @@\n+  assert(w.age() <= markWord::max_age, \"Impossible!\");\n+  return w.age();\n+}\n+\n+\/\/ Return the object's age, or a sentinel value when the age can't\n+\/\/ necessarily be determined because of concurrent locking by the\n+\/\/ mutator\n+uint ShenandoahHeap::get_object_age_concurrent(oop obj) {\n+  \/\/ This is impossible to do unless we \"freeze\" ABA-type oscillations\n+  \/\/ With Lilliput, we can do this more easily.\n+  markWord w = obj->mark();\n+  \/\/ We can do better for objects with inflated monitor\n+  if (w.is_being_inflated() || w.has_displaced_mark_helper()) {\n+    \/\/ Informs caller that we aren't able to determine the age\n+    return markWord::max_age + 1; \/\/ sentinel\n+  }\n+  assert(w.age() <= markWord::max_age, \"Impossible!\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.inline.hpp","additions":40,"deletions":4,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -84,1 +84,5 @@\n-  _age(0) {\n+  _age(0)\n+#ifdef SHENANDOAH_CENSUS_NOISE\n+  , _youth(0)\n+#endif \/\/ SHENANDOAH_CENSUS_NOISE\n+  {\n@@ -325,0 +329,1 @@\n+  CENSUS_NOISE(clear_youth();)\n@@ -1007,1 +1012,1 @@\n-  assert(age() >= InitialTenuringThreshold, \"Only promote regions that are sufficiently aged\");\n+  assert(age() >= heap->age_census()->tenuring_threshold(), \"Only promote regions that are sufficiently aged\");\n@@ -1087,1 +1092,1 @@\n-  assert(age() >= InitialTenuringThreshold, \"Only promote regions that are sufficiently aged\");\n+  assert(age() >= heap->age_census()->tenuring_threshold(), \"Only promote regions that are sufficiently aged\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.cpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -266,0 +266,1 @@\n+  CENSUS_NOISE(uint _youth;)   \/\/ tracks epochs of retrograde ageing (rejuvenation)\n@@ -463,4 +464,18 @@\n-  uint age()           { return _age; }\n-  void increment_age() { _age++; }\n-  void decrement_age() { if (_age-- == 0) { _age = 0; } }\n-  void reset_age()     { _age = 0; }\n+  \/\/ Region ageing and rejuvenation\n+  uint age() { return _age; }\n+  CENSUS_NOISE(uint youth() { return _youth; })\n+\n+  void increment_age() {\n+    const uint max_age = markWord::max_age;\n+    assert(_age <= max_age, \"Error\");\n+    if (_age++ >= max_age) {\n+      _age = max_age;   \/\/ clamp\n+    }\n+  }\n+\n+  void reset_age() {\n+    CENSUS_NOISE(_youth += _age;)\n+    _age = 0;\n+  }\n+\n+  CENSUS_NOISE(void clear_youth() { _youth = 0; })\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.hpp","additions":19,"deletions":4,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -172,1 +172,1 @@\n-        do_task<T, STRING_DEDUP>(q, cl, live_data, req, &t);\n+        do_task<T, GENERATION, STRING_DEDUP>(q, cl, live_data, req, &t, worker_id);\n@@ -201,1 +201,1 @@\n-        do_task<T, STRING_DEDUP>(q, cl, live_data, req, &t);\n+        do_task<T, GENERATION, STRING_DEDUP>(q, cl, live_data, req, &t, worker_id);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMark.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/shared\/ageTable.hpp\"\n@@ -66,1 +67,0 @@\n-\/\/ ---------- Marking loop and tasks\n@@ -68,2 +68,4 @@\n-  template <class T, StringDedupMode STRING_DEDUP>\n-  inline void do_task(ShenandoahObjToScanQueue* q, T* cl, ShenandoahLiveData* live_data, StringDedup::Requests* const req, ShenandoahMarkTask* task);\n+\/\/ ---------- Marking loop and tasks\n+\n+  template <class T, ShenandoahGenerationType GENERATION, StringDedupMode STRING_DEDUP>\n+  inline void do_task(ShenandoahObjToScanQueue* q, T* cl, ShenandoahLiveData* live_data, StringDedup::Requests* const req, ShenandoahMarkTask* task, uint worker_id);\n@@ -77,1 +79,2 @@\n-  inline void count_liveness(ShenandoahLiveData* live_data, oop obj);\n+  template <ShenandoahGenerationType GENERATION>\n+  inline void count_liveness(ShenandoahLiveData* live_data, oop obj, uint worker_id);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMark.hpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -60,2 +60,2 @@\n-template <class T, StringDedupMode STRING_DEDUP>\n-void ShenandoahMark::do_task(ShenandoahObjToScanQueue* q, T* cl, ShenandoahLiveData* live_data, StringDedup::Requests* const req, ShenandoahMarkTask* task) {\n+template <class T, ShenandoahGenerationType GENERATION, StringDedupMode STRING_DEDUP>\n+void ShenandoahMark::do_task(ShenandoahObjToScanQueue* q, T* cl, ShenandoahLiveData* live_data, StringDedup::Requests* const req, ShenandoahMarkTask* task, uint worker_id) {\n@@ -102,1 +102,1 @@\n-      count_liveness(live_data, obj);\n+      count_liveness<GENERATION>(live_data, obj, worker_id);\n@@ -110,5 +110,17 @@\n-inline void ShenandoahMark::count_liveness(ShenandoahLiveData* live_data, oop obj) {\n-  ShenandoahHeap* const heap = ShenandoahHeap::heap();\n-  size_t region_idx = heap->heap_region_index_containing(obj);\n-  ShenandoahHeapRegion* region = heap->get_region(region_idx);\n-  size_t size = obj->size();\n+template <ShenandoahGenerationType GENERATION>\n+inline void ShenandoahMark::count_liveness(ShenandoahLiveData* live_data, oop obj, uint worker_id) {\n+  const ShenandoahHeap* const heap = ShenandoahHeap::heap();\n+  const size_t region_idx = heap->heap_region_index_containing(obj);\n+  ShenandoahHeapRegion* const region = heap->get_region(region_idx);\n+  const size_t size = obj->size();\n+\n+  \/\/ Age census for objects in the young generation\n+  if (ShenandoahGenerationalAdaptiveTenuring && !ShenandoahGenerationalCensusAtEvac) {\n+    assert(heap->mode()->is_generational(), \"Only if generational\");\n+    if (GENERATION == YOUNG || (GENERATION == GLOBAL_GEN && region->is_young())) {\n+      assert(region->is_young(), \"Only for young objects\");\n+      uint age = ShenandoahHeap::get_object_age_concurrent(obj);\n+      CENSUS_NOISE(heap->age_census()->add(age, region->age(), region->youth(), size, worker_id);)\n+      NO_CENSUS_NOISE(heap->age_census()->add(age, region->age(), size, worker_id);)\n+    }\n+  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMark.inline.hpp","additions":20,"deletions":8,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -80,0 +80,16 @@\n+\n+\n+ShenandoahUpdateCensusZeroCohortClosure::ShenandoahUpdateCensusZeroCohortClosure(\n+  ShenandoahMarkingContext *ctx) :\n+  _ctx(ctx), _pop(0) {}\n+\n+void ShenandoahUpdateCensusZeroCohortClosure::heap_region_do(ShenandoahHeapRegion* r) {\n+  if (_ctx != nullptr && r->is_active()) {\n+    assert(r->is_young(), \"Young regions only\");\n+    HeapWord* tams = _ctx->top_at_mark_start(r);\n+    HeapWord* top  = r->top();\n+    if (top > tams) {\n+      _pop += pointer_delta(top, tams);\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkClosures.cpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/shenandoah\/shenandoahAgeCensus.hpp\"\n@@ -45,0 +46,13 @@\n+\/\/ Add [TAMS, top) volume over young regions. Used to correct age 0 cohort census\n+\/\/ for adaptive tenuring when census is taken during marking.\n+class ShenandoahUpdateCensusZeroCohortClosure : public ShenandoahHeapRegionClosure {\n+private:\n+  ShenandoahMarkingContext* const _ctx;\n+  size_t _pop;   \/\/ running tally of population\n+public:\n+  ShenandoahUpdateCensusZeroCohortClosure(ShenandoahMarkingContext* ctx);\n+\n+  void heap_region_do(ShenandoahHeapRegion* r);\n+\n+  size_t get_population() { return _pop; }\n+};\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkClosures.hpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"gc\/shenandoah\/shenandoahSharedVariables.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahPacer.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -37,0 +37,2 @@\n+class ShenandoahHeap;\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahTaskqueue.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2018, 2023, Red Hat, Inc. All rights reserved.\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"gc\/shenandoah\/mode\/shenandoahMode.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahThreadLocalData.hpp\"\n+\n+ShenandoahThreadLocalData::ShenandoahThreadLocalData() :\n+  _gc_state(0),\n+  _oom_scope_nesting_level(0),\n+  _oom_during_evac(false),\n+  _satb_mark_queue(&ShenandoahBarrierSet::satb_mark_queue_set()),\n+  _gclab(nullptr),\n+  _gclab_size(0),\n+  _paced_time(0),\n+  _plab(nullptr),\n+  _plab_size(0),\n+  _plab_evacuated(0),\n+  _plab_promoted(0),\n+  _plab_preallocated_promoted(0),\n+  _plab_allows_promotion(true),\n+  _plab_retries_enabled(true),\n+  _evacuation_stats(nullptr) {\n+  bool gen_mode = ShenandoahHeap::heap()->mode()->is_generational();\n+  _evacuation_stats = new ShenandoahEvacuationStats(gen_mode);\n+}\n+\n+ShenandoahThreadLocalData::~ShenandoahThreadLocalData() {\n+  if (_gclab != nullptr) {\n+    delete _gclab;\n+  }\n+  if (_plab != nullptr) {\n+    ShenandoahHeap::heap()->retire_plab(_plab);\n+    delete _plab;\n+  }\n+\n+  \/\/ TODO: Preserve these stats somewhere for mutator threads.\n+  delete _evacuation_stats;\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahThreadLocalData.cpp","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -71,30 +71,2 @@\n-  ShenandoahThreadLocalData() :\n-    _gc_state(0),\n-    _oom_scope_nesting_level(0),\n-    _oom_during_evac(false),\n-    _satb_mark_queue(&ShenandoahBarrierSet::satb_mark_queue_set()),\n-    _gclab(nullptr),\n-    _gclab_size(0),\n-    _paced_time(0),\n-    _plab(nullptr),\n-    _plab_size(0),\n-    _plab_evacuated(0),\n-    _plab_promoted(0),\n-    _plab_preallocated_promoted(0),\n-    _plab_allows_promotion(true),\n-    _plab_retries_enabled(true),\n-    _evacuation_stats(new ShenandoahEvacuationStats()) {\n-  }\n-\n-  ~ShenandoahThreadLocalData() {\n-    if (_gclab != nullptr) {\n-      delete _gclab;\n-    }\n-    if (_plab != nullptr) {\n-      ShenandoahHeap::heap()->retire_plab(_plab);\n-      delete _plab;\n-    }\n-\n-    \/\/ TODO: Preserve these stats somewhere for mutator threads.\n-    delete _evacuation_stats;\n-  }\n+  ShenandoahThreadLocalData();\n+  ~ShenandoahThreadLocalData();\n@@ -157,2 +129,6 @@\n-  static void end_evacuation(Thread* thread, size_t bytes, uint age) {\n-    data(thread)->_evacuation_stats->end_evacuation(bytes, age);\n+  static void end_evacuation(Thread* thread, size_t bytes) {\n+    data(thread)->_evacuation_stats->end_evacuation(bytes);\n+  }\n+\n+  static void record_age(Thread* thread, size_t bytes, uint age) {\n+    data(thread)->_evacuation_stats->record_age(bytes, age);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahThreadLocalData.hpp","additions":8,"deletions":32,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -38,0 +38,36 @@\n+  product(bool, ShenandoahGenerationalCensusAtEvac, true, EXPERIMENTAL,     \\\n+          \"(Generational mode only) Object age census at evacuation, \"      \\\n+          \"rather than during marking.\")                                    \\\n+                                                                            \\\n+  product(bool, ShenandoahGenerationalAdaptiveTenuring, false, EXPERIMENTAL,\\\n+          \"(Generational mode only) Dynamically adapt tenuring age.\")       \\\n+                                                                            \\\n+  product(uintx, ShenandoahGenerationalMinTenuringAge, 0, EXPERIMENTAL,     \\\n+          \"(Generational mode only) Floor for adaptive tenuring age.\")      \\\n+          range(0,16)                                                       \\\n+                                                                            \\\n+  product(uintx, ShenandoahGenerationalMaxTenuringAge, 15, EXPERIMENTAL,    \\\n+          \"(Generational mode only) Ceiling for adaptive tenuring age. \"    \\\n+          \"Setting min and max to the same value fixes the tenuring age, \"  \\\n+          \"setting both to 0 simulates Always Tenure, and setting both to \" \\\n+          \"16 simulates Never Tenure.\")                                     \\\n+          range(0,16)                                                       \\\n+                                                                            \\\n+  product(double, ShenandoahGenerationalTenuringMortalityRateThreshold,     \\\n+                                                         0.1, EXPERIMENTAL, \\\n+          \"(Generational mode only) Cohort mortality rates below this \"     \\\n+          \"value will be treated as indicative of longevity, leading to \"   \\\n+          \"tenuring. A lower value delays tenuring, a higher value hastens \"\\\n+          \"it. Used only when ShenandoahGenerationalhenAdaptiveTenuring is \"\\\n+          \"enabled.\")                                                       \\\n+          range(0.001,0.999)                                                \\\n+                                                                            \\\n+  product(size_t, ShenandoahGenerationalTenuringCohortPopulationThreshold,  \\\n+                                                         4*K, EXPERIMENTAL, \\\n+          \"(Generational mode only) Cohorts whose population is lower than \"\\\n+          \"this value in the previous census are ignored wrt tenuring \"     \\\n+          \"decisions. Effectively this makes then tenurable as soon as all \"\\\n+          \"older cohorts are. Set this value to the largest cohort \"        \\\n+          \"population volume that you are comfortable ignoring when making \"\\\n+          \"tenuring decisions.\")                                            \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoah_globals.hpp","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"}]}