{"files":[{"patch":"@@ -568,0 +568,2 @@\n+        Op_VectorizedHashCode,\n+        { { 2, ShenandoahLoad },                  { -1, ShenandoahNone } },\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -794,0 +794,1 @@\n+         cause == GCCause::_wb_young_gc ||\n@@ -797,1 +798,1 @@\n-         \"only requested GCs here\");\n+         \"only requested GCs here: %s\", GCCause::to_string(cause));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -2498,1 +2499,1 @@\n-oop ShenandoahHeap::pin_object(JavaThread* thr, oop o) {\n+void ShenandoahHeap::pin_object(JavaThread* thr, oop o) {\n@@ -2500,1 +2501,0 @@\n-  return o;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -185,2 +186,2 @@\n-  const char* name()          const { return \"Shenandoah\"; }\n-  ShenandoahHeap::Name kind() const { return CollectedHeap::Shenandoah; }\n+  const char* name()          const override { return \"Shenandoah\"; }\n+  ShenandoahHeap::Name kind() const override { return CollectedHeap::Shenandoah; }\n@@ -189,2 +190,2 @@\n-  jint initialize();\n-  void post_initialize();\n+  jint initialize() override;\n+  void post_initialize() override;\n@@ -195,1 +196,1 @@\n-  void initialize_serviceability();\n+  void initialize_serviceability() override;\n@@ -197,3 +198,3 @@\n-  void print_on(outputStream* st)              const;\n-  void print_extended_on(outputStream *st)     const;\n-  void print_tracing_info()                    const;\n+  void print_on(outputStream* st)              const override;\n+  void print_extended_on(outputStream *st)     const override;\n+  void print_tracing_info()                    const override;\n@@ -202,1 +203,1 @@\n-  void stop();\n+  void stop() override;\n@@ -204,2 +205,2 @@\n-  void prepare_for_verify();\n-  void verify(VerifyOption vo);\n+  void prepare_for_verify() override;\n+  void verify(VerifyOption vo) override;\n@@ -211,1 +212,1 @@\n-  bool supports_concurrent_gc_breakpoints() const {\n+  bool supports_concurrent_gc_breakpoints() const override {\n@@ -240,1 +241,1 @@\n-  size_t max_capacity()      const;\n+  size_t max_capacity()      const override;\n@@ -243,2 +244,2 @@\n-  size_t capacity()          const;\n-  size_t used()              const;\n+  size_t capacity()          const override;\n+  size_t used()              const override;\n@@ -261,1 +262,1 @@\n-  WorkerThreads* safepoint_workers();\n+  WorkerThreads* safepoint_workers() override;\n@@ -263,1 +264,1 @@\n-  void gc_threads_do(ThreadClosure* tcl) const;\n+  void gc_threads_do(ThreadClosure* tcl) const override;\n@@ -583,8 +584,8 @@\n-  ShenandoahMonitoringSupport* monitoring_support() const { return _monitoring_support;    }\n-  GCMemoryManager* cycle_memory_manager()           { return &_cycle_memory_manager; }\n-  GCMemoryManager* stw_memory_manager()             { return &_stw_memory_manager;   }\n-  SoftRefPolicy* soft_ref_policy()                  { return &_soft_ref_policy;      }\n-\n-  GrowableArray<GCMemoryManager*> memory_managers();\n-  GrowableArray<MemoryPool*> memory_pools();\n-  MemoryUsage memory_usage();\n+  ShenandoahMonitoringSupport* monitoring_support() const    { return _monitoring_support;    }\n+  GCMemoryManager* cycle_memory_manager()                    { return &_cycle_memory_manager; }\n+  GCMemoryManager* stw_memory_manager()                      { return &_stw_memory_manager;   }\n+  SoftRefPolicy* soft_ref_policy()                  override { return &_soft_ref_policy;      }\n+\n+  GrowableArray<GCMemoryManager*> memory_managers() override;\n+  GrowableArray<MemoryPool*> memory_pools() override;\n+  MemoryUsage memory_usage() override;\n@@ -627,2 +628,1 @@\n-  AdaptiveSizePolicy* size_policy() shenandoah_not_implemented_return(NULL);\n-  bool is_maximal_no_gc() const shenandoah_not_implemented_return(false);\n+  bool is_maximal_no_gc() const override shenandoah_not_implemented_return(false);\n@@ -630,1 +630,1 @@\n-  inline bool is_in(const void* p) const;\n+  inline bool is_in(const void* p) const override;\n@@ -643,1 +643,1 @@\n-  bool requires_barriers(stackChunkOop obj) const;\n+  bool requires_barriers(stackChunkOop obj) const override;\n@@ -648,2 +648,2 @@\n-  void collect(GCCause::Cause cause);\n-  void do_full_collection(bool clear_all_soft_refs);\n+  void collect(GCCause::Cause cause) override;\n+  void do_full_collection(bool clear_all_soft_refs) override;\n@@ -654,1 +654,1 @@\n-  bool print_location(outputStream* st, void* addr) const;\n+  bool print_location(outputStream* st, void* addr) const override;\n@@ -657,1 +657,1 @@\n-  void object_iterate(ObjectClosure* cl);\n+  void object_iterate(ObjectClosure* cl) override;\n@@ -659,1 +659,1 @@\n-  virtual ParallelObjectIteratorImpl* parallel_object_iterator(uint workers);\n+  ParallelObjectIteratorImpl* parallel_object_iterator(uint workers) override;\n@@ -662,1 +662,1 @@\n-  void keep_alive(oop obj);\n+  void keep_alive(oop obj) override;\n@@ -667,2 +667,2 @@\n-  void safepoint_synchronize_begin();\n-  void safepoint_synchronize_end();\n+  void safepoint_synchronize_begin() override;\n+  void safepoint_synchronize_end() override;\n@@ -673,3 +673,3 @@\n-  void register_nmethod(nmethod* nm);\n-  void unregister_nmethod(nmethod* nm);\n-  void verify_nmethod(nmethod* nm) {}\n+  void register_nmethod(nmethod* nm) override;\n+  void unregister_nmethod(nmethod* nm) override;\n+  void verify_nmethod(nmethod* nm) override {}\n@@ -681,4 +681,2 @@\n-  bool supports_object_pinning() const { return true; }\n-\n-  oop pin_object(JavaThread* thread, oop obj);\n-  void unpin_object(JavaThread* thread, oop obj);\n+  void pin_object(JavaThread* thread, oop obj) override;\n+  void unpin_object(JavaThread* thread, oop obj) override;\n@@ -692,1 +690,1 @@\n-  bool uses_stack_watermark_barrier() const { return true; }\n+  bool uses_stack_watermark_barrier() const override { return true; }\n@@ -709,1 +707,1 @@\n-  HeapWord* mem_allocate(size_t size, bool* what);\n+  HeapWord* mem_allocate(size_t size, bool* what) override;\n@@ -712,1 +710,1 @@\n-                                               Metaspace::MetadataType mdtype);\n+                                               Metaspace::MetadataType mdtype) override;\n@@ -716,5 +714,5 @@\n-  HeapWord* allocate_new_tlab(size_t min_size, size_t requested_size, size_t* actual_size);\n-  size_t tlab_capacity(Thread *thr) const;\n-  size_t unsafe_max_tlab_alloc(Thread *thread) const;\n-  size_t max_tlab_size() const;\n-  size_t tlab_used(Thread* ignored) const;\n+  HeapWord* allocate_new_tlab(size_t min_size, size_t requested_size, size_t* actual_size) override;\n+  size_t tlab_capacity(Thread *thr) const override;\n+  size_t unsafe_max_tlab_alloc(Thread *thread) const override;\n+  size_t max_tlab_size() const override;\n+  size_t tlab_used(Thread* ignored) const override;\n@@ -722,1 +720,1 @@\n-  void ensure_parsability(bool retire_labs);\n+  void ensure_parsability(bool retire_labs) override;\n@@ -871,1 +869,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":51,"deletions":54,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -123,1 +123,1 @@\n-      if (next == NULL) {\n+      if (next == nullptr) {\n@@ -131,1 +131,1 @@\n-    } while (next != NULL);\n+    } while (next != nullptr);\n","filename":"src\/hotspot\/share\/logging\/logFileStreamOutput.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}