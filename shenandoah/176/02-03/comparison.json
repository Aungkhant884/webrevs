{"files":[{"patch":"@@ -0,0 +1,126 @@\n+\/*\n+ * Copyright (c) 2022, Amazon.com, Inc. or its affiliates.  All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"gc\/shenandoah\/shenandoahCardStats.hpp\"\n+#include \"logging\/log.hpp\"\n+\n+#ifndef PRODUCT\n+void ShenandoahCardStats::update_run_work(bool record) {\n+  assert(!(_last_dirty || _last_clean) || (_last_dirty && _dirty_run > 0) || (_last_clean && _clean_run > 0),\n+         \"dirty\/clean run stats inconsistent\");\n+  assert(_dirty_run == 0 || _clean_run == 0, \"Both shouldn't be non-zero\");\n+  if (_dirty_run > _max_dirty_run) {\n+    assert(_last_dirty, \"Error\");\n+    _max_dirty_run = _dirty_run;\n+  } else if (_clean_run > _max_clean_run) {\n+    assert(_last_clean, \"Error\");\n+    _max_clean_run = _clean_run;\n+  }\n+  _dirty_card_cnt += _dirty_run;\n+  _clean_card_cnt += _clean_run;\n+\n+  \/\/ Update local stats\n+  {\n+    assert(_dirty_run <= _cards_in_cluster, \"Error\");\n+    assert(_clean_run <= _cards_in_cluster, \"Error\");\n+    \/\/ Update global stats for distribution of dirty\/clean run lengths\n+    _local_card_stats[DIRTY_RUN].add((double)_dirty_run*100\/(double)_cards_in_cluster);\n+    _local_card_stats[CLEAN_RUN].add((double)_clean_run*100\/(double)_cards_in_cluster);\n+\n+    if (record) {\n+      \/\/ Update global stats for distribution of dirty\/clean card %ge\n+      _local_card_stats[DIRTY_CARDS].add((double)_dirty_card_cnt*100\/(double)_cards_in_cluster);\n+      _local_card_stats[CLEAN_CARDS].add((double)_clean_card_cnt*100\/(double)_cards_in_cluster);\n+\n+      \/\/ Update global stats for max run distribution as dirty\/clean card %ge\n+      _local_card_stats[MAX_DIRTY_RUN].add((double)_max_dirty_run*100\/(double)_cards_in_cluster);\n+      _local_card_stats[MAX_CLEAN_RUN].add((double)_max_clean_run*100\/(double)_cards_in_cluster);\n+\n+      \/\/ Update global stats for dirty & clean objects\n+      _local_card_stats[DIRTY_OBJS].add(_dirty_obj_cnt);\n+      _local_card_stats[CLEAN_OBJS].add(_clean_obj_cnt);\n+      _local_card_stats[DIRTY_SCANS].add(_dirty_scan_cnt);\n+      _local_card_stats[CLEAN_SCANS].add(_clean_scan_cnt);\n+\n+      _local_card_stats[ALTERNATIONS].add(_alternation_cnt);\n+    }\n+  }\n+\n+  if (record) {\n+    \/\/ reset the stats for the next cluster\n+    _dirty_card_cnt = 0;\n+    _clean_card_cnt = 0;\n+\n+    _max_dirty_run = 0;\n+    _max_clean_run = 0;\n+\n+    _dirty_obj_cnt = 0;\n+    _clean_obj_cnt = 0;\n+\n+    _dirty_scan_cnt = 0;\n+    _clean_scan_cnt = 0;\n+\n+    _alternation_cnt = 0;\n+  }\n+  _dirty_run = 0;\n+  _clean_run = 0;\n+  _last_dirty = false;\n+  _last_clean = false;\n+  assert(!record || is_clean(), \"Error\");\n+}\n+\n+bool ShenandoahCardStats::is_clean() {\n+  return\n+    _dirty_card_cnt == 0 &&\n+    _clean_card_cnt == 0 &&\n+    _max_dirty_run == 0 &&\n+    _max_clean_run == 0 &&\n+    _dirty_obj_cnt == 0 &&\n+    _clean_obj_cnt == 0 &&\n+    _dirty_scan_cnt == 0 &&\n+    _clean_scan_cnt == 0 &&\n+    _alternation_cnt == 0 &&\n+    _dirty_run == 0 &&\n+    _clean_run == 0 &&\n+    _last_dirty == false &&\n+    _last_clean == false;\n+}\n+\n+void ShenandoahCardStats::log() const {\n+  if (ShenandoahEnableCardStats) {\n+    log_info(gc,remset)(\"Card stats: dirty \" SIZE_FORMAT \" (max run: \" SIZE_FORMAT \"),\"\n+      \" clean \" SIZE_FORMAT \" (max run: \" SIZE_FORMAT \"),\"\n+      \" dirty objs \" SIZE_FORMAT \", clean objs \" SIZE_FORMAT \",\"\n+      \" dirty scans \" SIZE_FORMAT \", clean scans \" SIZE_FORMAT,\n+      _dirty_card_cnt, _max_dirty_run, _clean_card_cnt, _max_clean_run,\n+      _dirty_obj_cnt, _clean_obj_cnt,\n+      _dirty_scan_cnt, _clean_scan_cnt);\n+  }\n+}\n+#endif \/\/ !PRODUCT\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCardStats.cpp","additions":126,"deletions":0,"binary":false,"changes":126,"status":"added"},{"patch":"@@ -0,0 +1,164 @@\n+\/*\n+ * Copyright (c) 2022, Amazon.com, Inc. or its affiliates.  All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHENANDOAH_SHENANDOAHCARDSTATS_HPP\n+#define SHARE_GC_SHENANDOAH_SHENANDOAHCARDSTATS_HPP\n+\n+#include \"gc\/shared\/gc_globals.hpp\"\n+#include \"gc\/shenandoah\/shenandoahNumberSeq.hpp\"\n+\n+class ShenandoahCardStats: public CHeapObj<mtGC> {\n+private:\n+  size_t _cards_in_cluster;\n+  HdrSeq* _local_card_stats;\n+\n+  bool _last_dirty;\n+  bool _last_clean;\n+\n+  size_t _dirty_card_cnt;\n+  size_t _clean_card_cnt;\n+\n+  size_t _dirty_run;\n+  size_t _clean_run;\n+\n+  size_t _max_dirty_run;\n+  size_t _max_clean_run;\n+\n+  size_t _dirty_obj_cnt;\n+  size_t _clean_obj_cnt;\n+\n+  size_t _dirty_scan_cnt;\n+  size_t _clean_scan_cnt;\n+\n+  size_t _alternation_cnt;\n+\n+public:\n+  ShenandoahCardStats(size_t cards_in_cluster, HdrSeq* card_stats) :\n+    _cards_in_cluster(cards_in_cluster),\n+    _local_card_stats(card_stats),\n+    _last_dirty(false),\n+    _last_clean(false),\n+    _dirty_card_cnt(0),\n+    _clean_card_cnt(0),\n+    _dirty_run(0),\n+    _clean_run(0),\n+    _max_dirty_run(0),\n+    _max_clean_run(0),\n+    _dirty_obj_cnt(0),\n+    _clean_obj_cnt(0),\n+    _dirty_scan_cnt(0),\n+    _clean_scan_cnt(0),\n+    _alternation_cnt(0)\n+  { }\n+\n+private:\n+  void increment_card_cnt_work(bool dirty) {\n+    if (dirty) { \/\/ dirty card\n+      if (_last_dirty) {\n+        assert(_dirty_run > 0 && _clean_run == 0 && !_last_clean, \"Error\");\n+        _dirty_run++;\n+      } else {\n+        if (_last_clean) {\n+          _alternation_cnt++;\n+        }\n+        update_run(false);\n+        _last_dirty = true;\n+        _dirty_run = 1;\n+      }\n+    } else { \/\/ clean card\n+      if (_last_clean) {\n+        assert(_clean_run > 0 && _dirty_run == 0 && !_last_dirty, \"Error\");\n+        _clean_run++;\n+      } else {\n+        if (_last_dirty) {\n+          _alternation_cnt++;\n+        }\n+        update_run(false);\n+        _last_clean = true;\n+        _clean_run = 1;\n+      }\n+    }\n+  }\n+\n+  inline void increment_obj_cnt_work(bool dirty)  {\n+    assert(!dirty || (_last_dirty && _dirty_run > 0), \"Error\");\n+    assert(dirty  || (_last_clean && _clean_run > 0), \"Error\");\n+    dirty ? _dirty_obj_cnt++ : _clean_obj_cnt++;\n+  }\n+\n+  inline void increment_scan_cnt_work(bool dirty) {\n+    assert(!dirty || (_last_dirty && _dirty_run > 0), \"Error\");\n+    assert(dirty  || (_last_clean && _clean_run > 0), \"Error\");\n+    dirty ? _dirty_scan_cnt++ : _clean_scan_cnt++;\n+  }\n+\n+  void update_run_work(bool cluster) PRODUCT_RETURN;\n+\n+public:\n+  inline void increment_card_cnt(bool dirty) {\n+    if (ShenandoahEnableCardStats) {\n+      increment_card_cnt_work(dirty);\n+    }\n+  }\n+\n+  inline void increment_obj_cnt(bool dirty) {\n+    if (ShenandoahEnableCardStats) {\n+      increment_obj_cnt_work(dirty);\n+    }\n+  }\n+\n+  inline void increment_scan_cnt(bool dirty) {\n+    if (ShenandoahEnableCardStats) {\n+      increment_scan_cnt_work(dirty);\n+    }\n+  }\n+\n+  inline void update_run(bool record) {\n+    if (ShenandoahEnableCardStats) {\n+      update_run_work(record);\n+    }\n+  }\n+\n+  bool is_clean() PRODUCT_RETURN0;\n+\n+  void log() const PRODUCT_RETURN;\n+};\n+\n+enum CardStatType {\n+    DIRTY_RUN = 0,\n+    CLEAN_RUN = 1,\n+    DIRTY_CARDS = 2,\n+    CLEAN_CARDS = 3,\n+    MAX_DIRTY_RUN = 4,\n+    MAX_CLEAN_RUN = 5,\n+    DIRTY_OBJS = 6,\n+    CLEAN_OBJS = 7,\n+    DIRTY_SCANS = 8,\n+    CLEAN_SCANS= 9,\n+    ALTERNATIONS = 10,\n+    MAX_CARD_STAT_TYPE = 11\n+};\n+\n+#endif \/\/ SHARE_GC_SHENANDOAH_SHENANDOAHCARDSTATS_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCardStats.hpp","additions":164,"deletions":0,"binary":false,"changes":164,"status":"added"},{"patch":"@@ -51,95 +51,0 @@\n-#ifndef PRODUCT\n-void ShenandoahCardStats::update_run_work(bool record) {\n-  assert(!(_last_dirty || _last_clean) || (_last_dirty && _dirty_run > 0) || (_last_clean && _clean_run > 0),\n-         \"dirty\/clean run stats inconsistent\");\n-  assert(_dirty_run == 0 || _clean_run == 0, \"Both shouldn't be non-zero\");\n-  if (_dirty_run > _max_dirty_run) {\n-    assert(_last_dirty, \"Error\");\n-    _max_dirty_run = _dirty_run;\n-  } else if (_clean_run > _max_clean_run) {\n-    assert(_last_clean, \"Error\");\n-    _max_clean_run = _clean_run;\n-  }\n-  _dirty_card_cnt += _dirty_run;\n-  _clean_card_cnt += _clean_run;\n-\n-  \/\/ Update local stats\n-  {\n-    assert(_dirty_run <= _cards_in_cluster, \"Error\");\n-    assert(_clean_run <= _cards_in_cluster, \"Error\");\n-    \/\/ Update global stats for distribution of dirty\/clean run lengths\n-    _local_card_stats[DIRTY_RUN].add((double)_dirty_run*100\/(double)_cards_in_cluster);\n-    _local_card_stats[CLEAN_RUN].add((double)_clean_run*100\/(double)_cards_in_cluster);\n-\n-    if (record) {\n-      \/\/ Update global stats for distribution of dirty\/clean card %ge\n-      _local_card_stats[DIRTY_CARDS].add((double)_dirty_card_cnt*100\/(double)_cards_in_cluster);\n-      _local_card_stats[CLEAN_CARDS].add((double)_clean_card_cnt*100\/(double)_cards_in_cluster);\n-\n-      \/\/ Update global stats for max run distribution as dirty\/clean card %ge\n-      _local_card_stats[MAX_DIRTY_RUN].add((double)_max_dirty_run*100\/(double)_cards_in_cluster);\n-      _local_card_stats[MAX_CLEAN_RUN].add((double)_max_clean_run*100\/(double)_cards_in_cluster);\n-\n-      \/\/ Update global stats for dirty & clean objects\n-      _local_card_stats[DIRTY_OBJS].add(_dirty_obj_cnt);\n-      _local_card_stats[CLEAN_OBJS].add(_clean_obj_cnt);\n-      _local_card_stats[DIRTY_SCANS].add(_dirty_scan_cnt);\n-      _local_card_stats[CLEAN_SCANS].add(_clean_scan_cnt);\n-\n-      _local_card_stats[ALTERNATIONS].add(_alternation_cnt);\n-    }\n-  }\n-\n-  if (record) {\n-    \/\/ reset the stats for the next cluster\n-    _dirty_card_cnt = 0;\n-    _clean_card_cnt = 0;\n-\n-    _max_dirty_run = 0;\n-    _max_clean_run = 0;\n-\n-    _dirty_obj_cnt = 0;\n-    _clean_obj_cnt = 0;\n-\n-    _dirty_scan_cnt = 0;\n-    _clean_scan_cnt = 0;\n-\n-    _alternation_cnt = 0;\n-  }\n-  _dirty_run = 0;\n-  _clean_run = 0;\n-  _last_dirty = false;\n-  _last_clean = false;\n-  assert(!record || is_clean(), \"Error\");\n-}\n-\n-bool ShenandoahCardStats::is_clean() {\n-  return\n-    _dirty_card_cnt == 0 &&\n-    _clean_card_cnt == 0 &&\n-    _max_dirty_run == 0 &&\n-    _max_clean_run == 0 &&\n-    _dirty_obj_cnt == 0 &&\n-    _clean_obj_cnt == 0 &&\n-    _dirty_scan_cnt == 0 &&\n-    _clean_scan_cnt == 0 &&\n-    _alternation_cnt == 0 &&\n-    _dirty_run == 0 &&\n-    _clean_run == 0 &&\n-    _last_dirty == false &&\n-    _last_clean == false;\n-}\n-\n-void ShenandoahCardStats::log() const {\n-  if (ShenandoahEnableCardStats) {\n-    log_info(gc,remset)(\"Card stats: dirty \" SIZE_FORMAT \" (max run: \" SIZE_FORMAT \"),\"\n-      \" clean \" SIZE_FORMAT \" (max run: \" SIZE_FORMAT \"),\"\n-      \" dirty objs \" SIZE_FORMAT \", clean objs \" SIZE_FORMAT \",\"\n-      \" dirty scans \" SIZE_FORMAT \", clean scans \" SIZE_FORMAT,\n-      _dirty_card_cnt, _max_dirty_run, _clean_card_cnt, _max_clean_run,\n-      _dirty_obj_cnt, _clean_obj_cnt,\n-      _dirty_scan_cnt, _clean_scan_cnt);\n-  }\n-}\n-#endif \/\/ !PRODUCT\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.cpp","additions":0,"deletions":95,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -182,0 +182,1 @@\n+#include \"gc\/shenandoah\/shenandoahCardStats.hpp\"\n@@ -185,0 +186,1 @@\n+#include \"gc\/shenandoah\/shenandoahNumberSeq.hpp\"\n@@ -681,117 +683,0 @@\n-class ShenandoahCardStats: public CHeapObj<mtGC> {\n-private:\n-  size_t _cards_in_cluster;\n-  HdrSeq* _local_card_stats;\n-\n-  bool _last_dirty;\n-  bool _last_clean;\n-\n-  size_t _dirty_card_cnt;\n-  size_t _clean_card_cnt;\n-\n-  size_t _dirty_run;\n-  size_t _clean_run;\n-\n-  size_t _max_dirty_run;\n-  size_t _max_clean_run;\n-\n-  size_t _dirty_obj_cnt;\n-  size_t _clean_obj_cnt;\n-\n-  size_t _dirty_scan_cnt;\n-  size_t _clean_scan_cnt;\n-\n-  size_t _alternation_cnt;\n-\n-public:\n-  ShenandoahCardStats(size_t cards_in_cluster, HdrSeq* card_stats) :\n-    _cards_in_cluster(cards_in_cluster),\n-    _local_card_stats(card_stats),\n-    _last_dirty(false),\n-    _last_clean(false),\n-    _dirty_card_cnt(0),\n-    _clean_card_cnt(0),\n-    _dirty_run(0),\n-    _clean_run(0),\n-    _max_dirty_run(0),\n-    _max_clean_run(0),\n-    _dirty_obj_cnt(0),\n-    _clean_obj_cnt(0),\n-    _dirty_scan_cnt(0),\n-    _clean_scan_cnt(0),\n-    _alternation_cnt(0)\n-  { }\n-\n-private:\n-  void increment_card_cnt_work(bool dirty) {\n-    if (dirty) { \/\/ dirty card\n-      if (_last_dirty) {\n-        assert(_dirty_run > 0 && _clean_run == 0 && !_last_clean, \"Error\");\n-        _dirty_run++;\n-      } else {\n-        if (_last_clean) {\n-          _alternation_cnt++;\n-        }\n-        update_run(false);\n-        _last_dirty = true;\n-        _dirty_run = 1;\n-      }\n-    } else { \/\/ clean card\n-      if (_last_clean) {\n-        assert(_clean_run > 0 && _dirty_run == 0 && !_last_dirty, \"Error\");\n-        _clean_run++;\n-      } else {\n-        if (_last_dirty) {\n-          _alternation_cnt++;\n-        }\n-        update_run(false);\n-        _last_clean = true;\n-        _clean_run = 1;\n-      }\n-    }\n-  }\n-\n-  inline void increment_obj_cnt_work(bool dirty)  {\n-    assert(!dirty || (_last_dirty && _dirty_run > 0), \"Error\");\n-    assert(dirty  || (_last_clean && _clean_run > 0), \"Error\");\n-    dirty ? _dirty_obj_cnt++ : _clean_obj_cnt++;\n-  }\n-\n-  inline void increment_scan_cnt_work(bool dirty) {\n-    assert(!dirty || (_last_dirty && _dirty_run > 0), \"Error\");\n-    assert(dirty  || (_last_clean && _clean_run > 0), \"Error\");\n-    dirty ? _dirty_scan_cnt++ : _clean_scan_cnt++;\n-  }\n-\n-  void update_run_work(bool cluster) PRODUCT_RETURN;\n-\n-public:\n-  inline void increment_card_cnt(bool dirty) {\n-    if (ShenandoahEnableCardStats) {\n-      increment_card_cnt_work(dirty);\n-    }\n-  }\n-\n-  inline void increment_obj_cnt(bool dirty) {\n-    if (ShenandoahEnableCardStats) {\n-      increment_obj_cnt_work(dirty);\n-    }\n-  }\n-\n-  inline void increment_scan_cnt(bool dirty) {\n-    if (ShenandoahEnableCardStats) {\n-      increment_scan_cnt_work(dirty);\n-    }\n-  }\n-\n-  inline void update_run(bool record) {\n-    if (ShenandoahEnableCardStats) {\n-      update_run_work(record);\n-    }\n-  }\n-\n-  bool is_clean() PRODUCT_RETURN0;\n-\n-  void log() const PRODUCT_RETURN;\n-};\n-\n@@ -801,1 +686,1 @@\n-\/\/\n+\/\/  \n@@ -807,1 +692,1 @@\n-\/\/\n+\/\/  \n@@ -812,16 +697,1 @@\n-\/\/\n-\n-typedef  enum CardStatType {\n-    DIRTY_RUN = 0,\n-    CLEAN_RUN = 1,\n-    DIRTY_CARDS = 2,\n-    CLEAN_CARDS = 3,\n-    MAX_DIRTY_RUN = 4,\n-    MAX_CLEAN_RUN = 5,\n-    DIRTY_OBJS = 6,\n-    CLEAN_OBJS = 7,\n-    DIRTY_SCANS = 8,\n-    CLEAN_SCANS= 9,\n-    ALTERNATIONS = 10,\n-    MAX_CARD_STAT_TYPE = 11\n-} CardStatType;\n+\/\/      \n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.hpp","additions":5,"deletions":135,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"gc\/shenandoah\/shenandoahCardStats.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}