{"files":[{"patch":"@@ -0,0 +1,126 @@\n+\/*\n+ * Copyright (c) 2022, Amazon.com, Inc. or its affiliates.  All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"gc\/shenandoah\/shenandoahCardStats.hpp\"\n+#include \"logging\/log.hpp\"\n+\n+#ifndef PRODUCT\n+void ShenandoahCardStats::update_run_work(bool record) {\n+  assert(!(_last_dirty || _last_clean) || (_last_dirty && _dirty_run > 0) || (_last_clean && _clean_run > 0),\n+         \"dirty\/clean run stats inconsistent\");\n+  assert(_dirty_run == 0 || _clean_run == 0, \"Both shouldn't be non-zero\");\n+  if (_dirty_run > _max_dirty_run) {\n+    assert(_last_dirty, \"Error\");\n+    _max_dirty_run = _dirty_run;\n+  } else if (_clean_run > _max_clean_run) {\n+    assert(_last_clean, \"Error\");\n+    _max_clean_run = _clean_run;\n+  }\n+  _dirty_card_cnt += _dirty_run;\n+  _clean_card_cnt += _clean_run;\n+\n+  \/\/ Update local stats\n+  {\n+    assert(_dirty_run <= _cards_in_cluster, \"Error\");\n+    assert(_clean_run <= _cards_in_cluster, \"Error\");\n+    \/\/ Update global stats for distribution of dirty\/clean run lengths\n+    _local_card_stats[DIRTY_RUN].add((double)_dirty_run*100\/(double)_cards_in_cluster);\n+    _local_card_stats[CLEAN_RUN].add((double)_clean_run*100\/(double)_cards_in_cluster);\n+\n+    if (record) {\n+      \/\/ Update global stats for distribution of dirty\/clean card %ge\n+      _local_card_stats[DIRTY_CARDS].add((double)_dirty_card_cnt*100\/(double)_cards_in_cluster);\n+      _local_card_stats[CLEAN_CARDS].add((double)_clean_card_cnt*100\/(double)_cards_in_cluster);\n+\n+      \/\/ Update global stats for max run distribution as dirty\/clean card %ge\n+      _local_card_stats[MAX_DIRTY_RUN].add((double)_max_dirty_run*100\/(double)_cards_in_cluster);\n+      _local_card_stats[MAX_CLEAN_RUN].add((double)_max_clean_run*100\/(double)_cards_in_cluster);\n+\n+      \/\/ Update global stats for dirty & clean objects\n+      _local_card_stats[DIRTY_OBJS].add(_dirty_obj_cnt);\n+      _local_card_stats[CLEAN_OBJS].add(_clean_obj_cnt);\n+      _local_card_stats[DIRTY_SCANS].add(_dirty_scan_cnt);\n+      _local_card_stats[CLEAN_SCANS].add(_clean_scan_cnt);\n+\n+      _local_card_stats[ALTERNATIONS].add(_alternation_cnt);\n+    }\n+  }\n+\n+  if (record) {\n+    \/\/ reset the stats for the next cluster\n+    _dirty_card_cnt = 0;\n+    _clean_card_cnt = 0;\n+\n+    _max_dirty_run = 0;\n+    _max_clean_run = 0;\n+\n+    _dirty_obj_cnt = 0;\n+    _clean_obj_cnt = 0;\n+\n+    _dirty_scan_cnt = 0;\n+    _clean_scan_cnt = 0;\n+\n+    _alternation_cnt = 0;\n+  }\n+  _dirty_run = 0;\n+  _clean_run = 0;\n+  _last_dirty = false;\n+  _last_clean = false;\n+  assert(!record || is_clean(), \"Error\");\n+}\n+\n+bool ShenandoahCardStats::is_clean() {\n+  return\n+    _dirty_card_cnt == 0 &&\n+    _clean_card_cnt == 0 &&\n+    _max_dirty_run == 0 &&\n+    _max_clean_run == 0 &&\n+    _dirty_obj_cnt == 0 &&\n+    _clean_obj_cnt == 0 &&\n+    _dirty_scan_cnt == 0 &&\n+    _clean_scan_cnt == 0 &&\n+    _alternation_cnt == 0 &&\n+    _dirty_run == 0 &&\n+    _clean_run == 0 &&\n+    _last_dirty == false &&\n+    _last_clean == false;\n+}\n+\n+void ShenandoahCardStats::log() const {\n+  if (ShenandoahEnableCardStats) {\n+    log_info(gc,remset)(\"Card stats: dirty \" SIZE_FORMAT \" (max run: \" SIZE_FORMAT \"),\"\n+      \" clean \" SIZE_FORMAT \" (max run: \" SIZE_FORMAT \"),\"\n+      \" dirty objs \" SIZE_FORMAT \", clean objs \" SIZE_FORMAT \",\"\n+      \" dirty scans \" SIZE_FORMAT \", clean scans \" SIZE_FORMAT,\n+      _dirty_card_cnt, _max_dirty_run, _clean_card_cnt, _max_clean_run,\n+      _dirty_obj_cnt, _clean_obj_cnt,\n+      _dirty_scan_cnt, _clean_scan_cnt);\n+  }\n+}\n+#endif \/\/ !PRODUCT\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCardStats.cpp","additions":126,"deletions":0,"binary":false,"changes":126,"status":"added"},{"patch":"@@ -0,0 +1,170 @@\n+\/*\n+ * Copyright (c) 2022, Amazon.com, Inc. or its affiliates.  All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHENANDOAH_SHENANDOAHCARDSTATS_HPP\n+#define SHARE_GC_SHENANDOAH_SHENANDOAHCARDSTATS_HPP\n+\n+#include \"gc\/shared\/gc_globals.hpp\"\n+#include \"gc\/shenandoah\/shenandoahNumberSeq.hpp\"\n+\n+class ShenandoahCardStats: public CHeapObj<mtGC> {\n+private:\n+  size_t _cards_in_cluster;\n+  HdrSeq* _local_card_stats;\n+\n+  bool _last_dirty;\n+  bool _last_clean;\n+\n+  size_t _dirty_card_cnt;\n+  size_t _clean_card_cnt;\n+\n+  size_t _dirty_run;\n+  size_t _clean_run;\n+\n+  size_t _max_dirty_run;\n+  size_t _max_clean_run;\n+\n+  size_t _dirty_obj_cnt;\n+  size_t _clean_obj_cnt;\n+\n+  size_t _dirty_scan_cnt;\n+  size_t _clean_scan_cnt;\n+\n+  size_t _alternation_cnt;\n+\n+public:\n+  ShenandoahCardStats(size_t cards_in_cluster, HdrSeq* card_stats) :\n+    _cards_in_cluster(cards_in_cluster),\n+    _local_card_stats(card_stats),\n+    _last_dirty(false),\n+    _last_clean(false),\n+    _dirty_card_cnt(0),\n+    _clean_card_cnt(0),\n+    _dirty_run(0),\n+    _clean_run(0),\n+    _max_dirty_run(0),\n+    _max_clean_run(0),\n+    _dirty_obj_cnt(0),\n+    _clean_obj_cnt(0),\n+    _dirty_scan_cnt(0),\n+    _clean_scan_cnt(0),\n+    _alternation_cnt(0)\n+  { }\n+\n+private:\n+  void increment_card_cnt_work(bool dirty) {\n+    if (dirty) { \/\/ dirty card\n+      if (_last_dirty) {\n+        assert(_dirty_run > 0 && _clean_run == 0 && !_last_clean, \"Error\");\n+        _dirty_run++;\n+      } else {\n+        if (_last_clean) {\n+          _alternation_cnt++;\n+        }\n+        update_run(false);\n+        _last_dirty = true;\n+        _dirty_run = 1;\n+      }\n+    } else { \/\/ clean card\n+      if (_last_clean) {\n+        assert(_clean_run > 0 && _dirty_run == 0 && !_last_dirty, \"Error\");\n+        _clean_run++;\n+      } else {\n+        if (_last_dirty) {\n+          _alternation_cnt++;\n+        }\n+        update_run(false);\n+        _last_clean = true;\n+        _clean_run = 1;\n+      }\n+    }\n+  }\n+\n+  inline void increment_obj_cnt_work(bool dirty)  {\n+    assert(!dirty || (_last_dirty && _dirty_run > 0), \"Error\");\n+    assert(dirty  || (_last_clean && _clean_run > 0), \"Error\");\n+    dirty ? _dirty_obj_cnt++ : _clean_obj_cnt++;\n+  }\n+\n+  inline void increment_scan_cnt_work(bool dirty) {\n+    assert(!dirty || (_last_dirty && _dirty_run > 0), \"Error\");\n+    assert(dirty  || (_last_clean && _clean_run > 0), \"Error\");\n+    dirty ? _dirty_scan_cnt++ : _clean_scan_cnt++;\n+  }\n+\n+  void update_run_work(bool cluster) PRODUCT_RETURN;\n+\n+public:\n+  inline void increment_card_cnt(bool dirty) {\n+    if (ShenandoahEnableCardStats) {\n+      increment_card_cnt_work(dirty);\n+    }\n+  }\n+\n+  inline void increment_obj_cnt(bool dirty) {\n+    if (ShenandoahEnableCardStats) {\n+      increment_obj_cnt_work(dirty);\n+    }\n+  }\n+\n+  inline void increment_scan_cnt(bool dirty) {\n+    if (ShenandoahEnableCardStats) {\n+      increment_scan_cnt_work(dirty);\n+    }\n+  }\n+\n+  inline void update_run(bool record) {\n+    if (ShenandoahEnableCardStats) {\n+      update_run_work(record);\n+    }\n+  }\n+\n+  bool is_clean() PRODUCT_RETURN0;\n+\n+  void log() const PRODUCT_RETURN;\n+};\n+\n+enum CardStatType {\n+  DIRTY_RUN = 0,\n+  CLEAN_RUN = 1,\n+  DIRTY_CARDS = 2,\n+  CLEAN_CARDS = 3,\n+  MAX_DIRTY_RUN = 4,\n+  MAX_CLEAN_RUN = 5,\n+  DIRTY_OBJS = 6,\n+  CLEAN_OBJS = 7,\n+  DIRTY_SCANS = 8,\n+  CLEAN_SCANS= 9,\n+  ALTERNATIONS = 10,\n+  MAX_CARD_STAT_TYPE = 11\n+};\n+\n+enum CardStatLogType {\n+  CARD_STAT_SCAN_RS = 0,\n+  CARD_STAT_UPDATE_REFS = 1,\n+  MAX_CARD_STAT_LOG_TYPE = 2\n+};\n+\n+#endif \/\/ SHARE_GC_SHENANDOAH_SHENANDOAHCARDSTATS_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCardStats.hpp","additions":170,"deletions":0,"binary":false,"changes":170,"status":"added"},{"patch":"@@ -915,0 +915,4 @@\n+  if (ShenandoahEnableCardStats) {\n+    assert(heap->card_scan() != NULL, \"Not generational\");\n+    heap->card_scan()->log_card_stats(nworkers, CARD_STAT_SCAN_RS);\n+  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2629,0 +2629,1 @@\n+\n@@ -2637,1 +2638,0 @@\n-      bool have_work = _work_chunks->next(&assignment);\n@@ -2639,1 +2639,3 @@\n-      while (have_work) {\n+\n+      while (!_heap->check_cancelled_gc_and_yield(CONCURRENT) && _work_chunks->next(&assignment)) {\n+        \/\/ Keep grabbing next work chunk to process until finished, or asked to yield\n@@ -2732,1 +2734,1 @@\n-              scanner->process_region_slice(r, assignment._chunk_offset, clusters, end_of_range, &cl, true, CONCURRENT);\n+              scanner->process_region_slice(r, assignment._chunk_offset, clusters, end_of_range, &cl, true, CONCURRENT, worker_id);\n@@ -2739,7 +2741,0 @@\n-        \/\/ Otherwise, this work chunk had nothing for me to do, so do not report pacer progress.\n-\n-        \/\/ Before we take responsibility for another chunk of work, see if cancellation is requested.\n-        if (_heap->check_cancelled_gc_and_yield(CONCURRENT)) {\n-          return;\n-        }\n-        have_work = _work_chunks->next(&assignment);\n@@ -2753,1 +2748,2 @@\n-  ShenandoahRegionChunkIterator work_list(workers()->active_workers());\n+  uint nworkers = workers()->active_workers();\n+  ShenandoahRegionChunkIterator work_list(nworkers);\n@@ -2762,0 +2758,3 @@\n+  if (ShenandoahEnableCardStats && card_scan()!=NULL) { \/\/ generational check proxy\n+    card_scan()->log_card_stats(nworkers, CARD_STAT_UPDATE_REFS);\n+  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"logging\/log.hpp\"\n@@ -82,9 +83,1 @@\n-  bool has_work = _work_list->next(&assignment);\n-  while (has_work) {\n-#ifdef ENABLE_REMEMBERED_SET_CANCELLATION\n-    \/\/ This check is currently disabled to avoid crashes that occur\n-    \/\/ when we try to cancel remembered set scanning\n-    if (heap->check_cancelled_gc_and_yield(_is_concurrent)) {\n-      return;\n-    }\n-#endif\n+  while (_work_list->next(&assignment)) {\n@@ -102,1 +95,1 @@\n-      \/\/ During concurrent mark, region->top() equals TAMS with respect to the current young-gen pass.  *\/\n+      \/\/ During concurrent mark, region->top() equals TAMS with respect to the current young-gen pass.\n@@ -106,1 +99,1 @@\n-      scanner->process_region_slice(region, assignment._chunk_offset, clusters, end_of_range, &cl, false, _is_concurrent);\n+      scanner->process_region_slice(region, assignment._chunk_offset, clusters, end_of_range, &cl, false, _is_concurrent, worker_id);\n@@ -108,1 +101,7 @@\n-    has_work = _work_list->next(&assignment);\n+#ifdef ENABLE_REMEMBERED_SET_CANCELLATION\n+    \/\/ This check is currently disabled to avoid crashes that occur\n+    \/\/ when we try to cancel remembered set scanning\n+    if (heap->check_cancelled_gc_and_yield(_is_concurrent)) {\n+      return;\n+    }\n+#endif\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.cpp","additions":11,"deletions":12,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -48,3 +48,8 @@\n-\/\/               that object will be scanned in its entirety). For these\n-\/\/               reasons, it is advisable for the multiple worker threads\n-\/\/               to be flexible in the number of clusters to be\n+\/\/               that object, if it's not an array, may need to be scanned in\n+\/\/               its entirety, when the object is imprecisely dirtied. Imprecise\n+\/\/               dirtying is when the card corresponding to the object header\n+\/\/               is dirtied, rather than the card on which the updated field lives).\n+\/\/               TODO CHECK AND CORRECT THIS, IT SEEMS WISHY-WASHY: ysr\n+\/\/               To allow better balancing of work among parallel workers, especially\n+\/\/               in the absence of cluster claiming, it is advisable for the multiple\n+\/\/               worker threads to be flexible in the number of clusters to be\n@@ -58,1 +63,4 @@\n-\/\/ labor between multiple threads.\n+\/\/ labor between multiple threads, and potentially better load balancing\n+\/\/ when dirty cards are not uniformly distributed in the heap, as is often\n+\/\/ the case with generational workloads where more recently promoted objects\n+\/\/ may be dirtied more frequently that older objects.\n@@ -66,1 +74,1 @@\n-\/\/     Assume one long word of card table entries represents a cluster.\n+\/\/     Assume one long word (8 B)of the card table represents a cluster.\n@@ -68,2 +76,2 @@\n-\/\/       total of 4KB\n-\/\/     The number of clusters per region is 128 MB \/ 4 KB = 32K\n+\/\/       total of 8*512 B = 4 KB of the heap\n+\/\/     The number of clusters per region is 128 MB \/ 4 KB = 32 K\n@@ -75,4 +83,4 @@\n-\/\/     Assume one int word of card tables represents a cluster.\n-\/\/       This int word holds 32 card table entries, spanning a\n-\/\/       total of 4KB\n-\/\/     The number of clusters per region is 128 MB \/ 4 KB = 32K\n+\/\/     Assume one int word (4 B) of the card table represents a cluster.\n+\/\/       This int word holds 32 b\/1 b = 32 card table entries, spanning a\n+\/\/       total of 32 * 128 B = 4 KB of the heap\n+\/\/     The number of clusters per region is 128 MB \/ 4 KB = 32 K\n@@ -84,4 +92,4 @@\n-\/\/     Assume one long word of card tables represents a cluster.\n-\/\/       This long word holds 64 card table entries, spanning a\n-\/\/       total of 32 KB\n-\/\/     The number of clusters per region is 128 MB \/ 32 KB = 4K\n+\/\/     Assume one long word (8 B) of card table represents a cluster.\n+\/\/       This long word holds 64 b\/ 1 b = 64 card table entries, spanning a\n+\/\/       total of 64 * 512 B = 32 KB of the heap\n+\/\/     The number of clusters per region is 128 MB \/ 32 KB = 4 K\n@@ -106,15 +114,0 @@\n-\/\/      Assure that exactly one worker thread initializes each\n-\/\/      cluster of overreach memory by invoking:\n-\/\/\n-\/\/        rs->initialize_overreach(cluster_no, cluster_count)\n-\/\/\n-\/\/      in separate threads.  (Divide up the clusters so that\n-\/\/      different threads are responsible for initializing different\n-\/\/      clusters.  Initialization cost is essentially identical for\n-\/\/      each cluster.)\n-\/\/\n-\/\/  Next, we repeat the process for invocations of process_clusters.\n-\/\/  for each ShenandoahHeapRegion old_region in the whole heap\n-\/\/    determine the cluster number of the first cluster belonging\n-\/\/      to that region\n-\/\/    for each cluster contained within that region\n@@ -137,2 +130,2 @@\n-\/\/        c) some clusters are spanned by very large objects that\n-\/\/           begin in some other cluster.  When a large object\n+\/\/        c) some clusters are spanned by very large non-array objects that\n+\/\/           begin in some other cluster.  When a large non-array object\n@@ -140,4 +133,4 @@\n-\/\/           this cluster, the processing of this cluster gets a\n-\/\/           \"free ride\" because the thread responsible for processing\n-\/\/           the cluster that holds the object's header does the\n-\/\/           processing.\n+\/\/           this cluster, then because of imprecise dirtying, the\n+\/\/           portion of the object in this cluster may be clean, but\n+\/\/           will need to be processed by the worker responsible for\n+\/\/           this cluster, potentially increasing its work.\n@@ -145,4 +138,3 @@\n-\/\/           very large object, the processing of this cluster will\n-\/\/           be responsible for examining the entire object,\n-\/\/           potentially requiring this thread to process large amounts\n-\/\/           of memory pertaining to other clusters.\n+\/\/           very large non-array object, the worker for this cluster will\n+\/\/           be responsible for processing the portion of the object\n+\/\/           in this cluster.\n@@ -180,20 +172,2 @@\n-\/\/  Once all clusters have been processed, the gang of GC worker\n-\/\/  threads collaborate to merge the overreach data.\n-\/\/\n-\/\/  for each ShenandoahHeapRegion old_region in the whole heap\n-\/\/    determine the cluster number of the first cluster belonging\n-\/\/      to that region\n-\/\/    for each cluster contained within that region\n-\/\/      Assure that exactly one worker thread initializes each\n-\/\/      cluster of overreach memory by invoking:\n-\/\/\n-\/\/        rs->merge_overreach(cluster_no, cluster_count)\n-\/\/\n-\/\/      in separate threads.  (Divide up the clusters so that\n-\/\/      different threads are responsible for merging different\n-\/\/      clusters.  Merging cost is essentially identical for\n-\/\/      each cluster.)\n-\/\/\n-\/\/ Though remembered set scanning is designed to run concurrently with\n-\/\/ mutator threads, the current implementation of remembered set\n-\/\/ scanning runs in parallel during a GC safepoint.  Furthermore, the\n+\/\/ Remembered set scanning is designed to run concurrently with\n+\/\/ mutator threads, with multiple concurrent workers. Furthermore, the\n@@ -201,3 +175,1 @@\n-\/\/ card once it has been marked.  Since the current implementation\n-\/\/ never clears marked pages, the current implementation does not\n-\/\/ invoke initialize_overreach() or merge_overreach().\n+\/\/ card once it has been marked.\n@@ -210,0 +182,1 @@\n+#include \"gc\/shenandoah\/shenandoahCardStats.hpp\"\n@@ -213,0 +186,1 @@\n+#include \"gc\/shenandoah\/shenandoahNumberSeq.hpp\"\n@@ -323,9 +297,1 @@\n-\/\/ In the initial implementation, we assume that scanning of card\n-\/\/ table entries occurs only while the JVM is at a safe point.  Thus,\n-\/\/ there is no synchronization required between GC threads that are\n-\/\/ scanning card-table entries and marking certain entries that were\n-\/\/ previously dirty as clean, and mutator threads which would possibly\n-\/\/ be marking certain card-table entries as dirty.\n-\/\/\n-\/\/ There is however a need to implement concurrency control and memory\n-\/\/ coherency between multiple GC threads that scan the remembered set\n+\/\/ Multiple GC threads that scan the remembered set\n@@ -340,2 +306,2 @@\n-\/\/ between adjacent cluster regions.  Here is the protocol that is\n-\/\/ followed:\n+\/\/ between adjacent cluster regions.  Here is the protocol that we currently\n+\/\/ follow:\n@@ -343,59 +309,20 @@\n-\/\/  1. We implement a supplemental data structure known as the overreach\n-\/\/     card table.  The thread that is responsible for scanning each\n-\/\/     cluster of card-table entries is granted exclusive access to\n-\/\/     modify the associated card-table entries.  In the case that a\n-\/\/     thread scans a very large object that reaches into one or more\n-\/\/     following clusters, that thread has exclusive access to the\n-\/\/     overreach card table for all of the entries belonging to the\n-\/\/     following clusters that are spanned by this large object.\n-\/\/     After all clusters have been scanned, the scanning threads\n-\/\/     briefly synchronize to merge the contents of the overreach\n-\/\/     entries with the traditional card table entries using logical-\n-\/\/     and operations.\n-\/\/  2. Every object is scanned in its \"entirety\" by the thread that is\n-\/\/     responsible for the cluster that holds its starting address.\n-\/\/     Entirety is in quotes because there are various situations in\n-\/\/     which some portions of the object will not be scanned by this\n-\/\/     thread:\n-\/\/     a) If an object spans multiple card regions, all of which are\n-\/\/        contained within the same cluster, the scanning thread\n-\/\/        consults the existing card-table entries and does not scan\n-\/\/        portions of the object that are not currently dirty.\n-\/\/     b) For any cluster that is spanned in its entirety by a very\n-\/\/        large object, the GC thread that scans this object assumes\n-\/\/        full responsibility for maintenance of the associated\n-\/\/        card-table entries.\n-\/\/     c) If a cluster is partially spanned by an object originating\n-\/\/        in a preceding cluster, the portion of the object that\n-\/\/        partially spans the following cluster is scanned in its\n-\/\/        entirety (because the thread that is responsible for\n-\/\/        scanning the object cannot rely upon the card-table entries\n-\/\/        associated with the following cluster).  Whenever references\n-\/\/        to young-gen memory are found within the scanned data, the\n-\/\/        associated overreach card table entries are marked as dirty\n-\/\/        by the scanning thread.\n-\/\/  3. If a cluster is spanned in its entirety by an object that\n-\/\/     originates within a preceding cluster's memory, the thread\n-\/\/     assigned to examine this cluster does absolutely nothing.  The\n-\/\/     thread assigned to scan the cluster that holds the object's\n-\/\/     starting address takes full responsibility for scanning the\n-\/\/     entire object and updating the associated card-table entries.\n-\/\/  4. If a cluster is spanned partially by an object that originates\n-\/\/     within a preceding cluster's memory, the thread assigned to\n-\/\/     examine this cluster marks the card-table entry as clean for\n-\/\/     each card table that is fully spanned by this overreaching\n-\/\/     object.  If a card-table entry's memory is partially spanned\n-\/\/     by the overreaching object, the thread sets the card-table\n-\/\/     entry to clean if it was previously dirty and if the portion\n-\/\/     of the card-table entry's memory that is not spanned by the\n-\/\/     overreaching object does not hold pointers to young-gen\n-\/\/     memory.\n-\/\/  5. While examining a particular card belonging to a particular\n-\/\/     cluster, if an object reaches beyond the end of its card\n-\/\/     memory, the thread \"scans\" all portions of the object that\n-\/\/     correspond to DIRTY card entries within the current cluster and\n-\/\/     all portions of the object that reach into following clustesr.\n-\/\/     After this object is scanned, continue scanning with the memory\n-\/\/     that follows this object if this memory pertains to the same\n-\/\/     cluster.  Otherwise, consider this cluster's memory to have\n-\/\/     been fully examined.\n+\/\/  1. The thread responsible for scanning the cards in a cluster modifies\n+\/\/     the associated card-table entries. Only cards that are dirty are\n+\/\/     processed, except as described below for the case of objects that\n+\/\/     straddle more than one card.\n+\/\/  2. Object Arrays are precisely dirtied, so only the portion of the obj-array\n+\/\/     that overlaps the range of dirty cards in its cluster are scanned\n+\/\/     by each worker thread. This holds for portions of obj-arrays that extend\n+\/\/     over clusters processed by different workers, with each worked responsible\n+\/\/     for scanning the portion of the obj-array overlapping the dirty cards in\n+\/\/     its cluster.\n+\/\/  3. Non-array objects are precisely dirtied by the interpreter and the compilers\n+\/\/     (why? Are offsets of a field in an object that expensive to determine?).\n+\/\/     For such objects that extend over multiple cards, or even multiple clusters,\n+\/\/     the entire object is scanned by the worker that processes the (dirty) card on\n+\/\/     which the object's header lies. However, GC workers then precisley dirty the\n+\/\/     cards in the body of this object, thus making the subsequent scans potentially\n+\/\/     less expensive. This is achieved by means of marking the card \"younger-gen-val\",\n+\/\/     indicating the presence of an intergenerational pointer on the card on which the\n+\/\/     intergenerational pointer is found. GC threads always maintain this value\n+\/\/     in preference to \"dirty-card-val\" for cards with intergenerational pointers.\n@@ -403,24 +330,2 @@\n-\/\/ Discussion:\n-\/\/  Though this design results from careful consideration of multiple\n-\/\/  design objectives, it is subject to various criticisms.  Some\n-\/\/  discussion of the design choices is provided here:\n-\/\/\n-\/\/  1. Note that remembered sets are a heuristic technique to avoid\n-\/\/     the need to scan all of old-gen memory with each young-gen\n-\/\/     collection.  If we sometimes scan a bit more memory than is\n-\/\/     absolutely necessary, that should be considered a reasonable\n-\/\/     compromise.  This compromise is already present in the sizing\n-\/\/     of card table memory areas.  Note that a single dirty pointer\n-\/\/     within a 512-byte card region forces the \"unnecessary\" scanning\n-\/\/     of 63 = ((512 - 8 = 504) \/ 8) pointers.\n-\/\/  2. One undesirable aspect of this design is that we sometimes have\n-\/\/     to scan large amounts of memory belonging to very large\n-\/\/     objects, even for parts of the very large object that do not\n-\/\/     correspond to dirty card table entries.  Note that this design\n-\/\/     limits the amount of non-dirty scanning that might have to\n-\/\/     be performed for these very large objects.  In particular, only\n-\/\/     the last part of the very large object that extends into but\n-\/\/     does not completely span a particular cluster is unnecessarily\n-\/\/     scanned.  Thus, for each very large object, the maximum\n-\/\/     over-scan is the size of memory spanned by a single cluster.\n-\/\/  3. The representation of pointer location descriptive information\n+\/\/  A possible criticism:\n+\/\/  C. The representation of pointer location descriptive information\n@@ -456,1 +361,1 @@\n-\/\/  3. (A corollary) In the case that an old-gen object spans the\n+\/\/  3. (A corollary) In the case that an old-gen object straddles the\n@@ -460,2 +365,1 @@\n-\n-\n+\/\/\n@@ -468,18 +372,5 @@\n-\/\/\n-\/\/ There are two situations under which we need to know the location\n-\/\/ at which the object spanning the start of a particular card-table\n-\/\/ memory region begins:\n-\/\/\n-\/\/ 1. When we begin to scan dirty card memory that is not the\n-\/\/    first card region within a cluster, and the object that\n-\/\/    crosses into this card memory was not previously scanned,\n-\/\/    we need to find where that object starts so we can scan it.\n-\/\/    (Asides: if the objects starts within a previous cluster, it\n-\/\/     has already been scanned.  If the object starts within this\n-\/\/     cluster and it spans at least one card region that is dirty\n-\/\/     and precedes this card region within the cluster, then it has\n-\/\/     already been scanned.)\n-\/\/ 2. When we are otherwise done scanning a complete cluster, if the\n-\/\/    last object within the cluster reaches into the following\n-\/\/    cluster, we need to scan this object.  Thus, we need to find\n-\/\/    its starting location.\n+\/\/ Note that we only need to register the start addresses of the object that\n+\/\/ overlays the first address of a card; we need to do this for every card.\n+\/\/ In other words, register_object() checks if the object crosses a card boundary,\n+\/\/ and updates the offset value for each card that the object crosses into.\n+\/\/ For objects that don't straddle cards, nothing needs to be done.\n@@ -558,20 +449,0 @@\n-  \/\/ In the most recent implementation of ShenandoahScanRemembered::process_clusters(),\n-  \/\/ there is no need for the get_crossing_object_start() method function, so there is no\n-  \/\/ need to maintain the following information.  The comment is left in place for now in\n-  \/\/ case we find it necessary to add support for this service at a later time.\n-  \/\/\n-  \/\/ Bits 0x7fff: If no object starts within this card region, the\n-  \/\/              remaining bits of the object_starts array represent\n-  \/\/              the absolute word offset within the enclosing\n-  \/\/              cluster's memory of the starting address for the\n-  \/\/              object that spans the start of this card region's\n-  \/\/              memory.  If the spanning object begins in memory\n-  \/\/              that precedes this card region's cluster, the value\n-  \/\/              stored in these bits is the special value 0x7fff.\n-  \/\/              (Note that the maximum value required to represent a\n-  \/\/              spanning object from within the current cluster is\n-  \/\/              ((63 * 64) - 8), which equals 0x0fbf.\n-  \/\/\n-  \/\/ In the absence of the need to support get_crossing_object_start(),\n-  \/\/ here is discussion of performance:\n-  \/\/\n@@ -832,1 +703,0 @@\n-\n@@ -836,0 +706,21 @@\n+  \/\/ Global card stats (cumulative)\n+  HdrSeq _card_stats_scan_rs[MAX_CARD_STAT_TYPE];\n+  HdrSeq _card_stats_update_refs[MAX_CARD_STAT_TYPE];\n+  \/\/ Per worker card stats (multiplexed by phase)\n+  HdrSeq** _card_stats;\n+\n+  const char* _card_stats_name[MAX_CARD_STAT_TYPE] = {\n+   \"dirty_run\", \"clean_run\",\n+   \"dirty_cards\", \"clean_cards\",\n+   \"max_dirty_run\", \"max_clean_run\",\n+   \"dirty_objs\", \"clean_objs\",\n+   \"dirty_scans\", \"clean_scans\",\n+   \"alternations\"\n+  };\n+\n+  const char* _card_stat_log_type[MAX_CARD_STAT_LOG_TYPE] = {\n+   \"Scan Remembered Set\", \"Update Refs\"\n+  };\n+\n+  int _card_stats_log_counter[2] = {0, 0};\n+\n@@ -855,0 +746,12 @@\n+\n+    \/\/ We allocate ParallelGCThreads worth even though we usually only\n+    \/\/ use up to ConcGCThreads, because degenerate collections may employ\n+    \/\/ ParallelGCThreads for remembered set scanning.\n+    if (ShenandoahEnableCardStats) {\n+      _card_stats = NEW_C_HEAP_ARRAY(HdrSeq*, ParallelGCThreads, mtGC);\n+      for (uint i = 0; i < ParallelGCThreads; i++) {\n+        _card_stats[i] = new HdrSeq[MAX_CARD_STAT_TYPE];\n+      }\n+    } else {\n+      _card_stats = nullptr;\n+    }\n@@ -859,0 +762,26 @@\n+    if (ShenandoahEnableCardStats) {\n+      for (uint i = 0; i < ParallelGCThreads; i++) {\n+        delete _card_stats[i];\n+      }\n+      FREE_C_HEAP_ARRAY(HdrSeq*, _card_stats);\n+      _card_stats = nullptr;\n+    }\n+    assert(_card_stats == nullptr, \"Error\");\n+  }\n+\n+  HdrSeq* card_stats(uint worker_id) {\n+    assert(worker_id < ParallelGCThreads, \"Error\");\n+    assert(ShenandoahEnableCardStats == (_card_stats != nullptr), \"Error\");\n+    return ShenandoahEnableCardStats ? _card_stats[worker_id] : nullptr;\n+  }\n+\n+  HdrSeq* card_stats_for_phase(CardStatLogType t) {\n+    switch (t) {\n+      case CARD_STAT_SCAN_RS:\n+        return _card_stats_scan_rs;\n+      case CARD_STAT_UPDATE_REFS:\n+        return _card_stats_update_refs;\n+      default:\n+        guarantee(false, \"No such CardStatLogType\");\n+    }\n+    return nullptr; \/\/ Quiet compiler\n@@ -926,6 +855,6 @@\n-  \/\/ process_clusters() scans a portion of the remembered set during a JVM\n-  \/\/ safepoint as part of the root scanning activities that serve to\n-  \/\/ initiate concurrent scanning and concurrent evacuation.  Multiple\n-  \/\/ threads may scan different portions of the remembered set by\n-  \/\/ making parallel invocations of process_clusters() with each\n-  \/\/ invocation scanning different clusters of the remembered set.\n+  \/\/ process_clusters() scans a portion of the remembered set\n+  \/\/ to scan roots from old gen into young to identify live objects\n+  \/\/ in the young generation. Several worker threads scan different\n+  \/\/ portions of the remembered set by making parallel invocations\n+  \/\/ of process_clusters() with each invocation scanning different\n+  \/\/ \"clusters\" of the remembered set.\n@@ -934,4 +863,3 @@\n-  \/\/ intergenerational references spanned by count clusters starting\n-  \/\/ with first_cluster.  The oops argument is assumed to represent a\n-  \/\/ thread-local OopClosure into which addresses of intergenerational\n-  \/\/ pointer values will be accumulated for the purposes of root scanning.\n+  \/\/ intergenerational references spanned by `count` clusters starting\n+  \/\/ with `first_cluster`.  The `oops` argument is a worker-thread-local\n+  \/\/ OopClosure that is applied to all \"valid\" references in the remembered set.\n@@ -939,3 +867,3 @@\n-  \/\/ A side effect of executing process_clusters() is to update the card\n-  \/\/ table entries, marking dirty cards as clean if they no longer\n-  \/\/ hold references to young-gen memory.  (THIS IS NOT YET IMPLEMENTED.)\n+  \/\/ A side-effect of executing process_clusters() is to update the remembered\n+  \/\/ set entries (e.g. marking dirty cards clean if they no longer\n+  \/\/ hold references to young-gen memory).\n@@ -943,3 +871,8 @@\n-  \/\/ The implementation of process_clusters() is designed to efficiently\n-  \/\/ minimize work in the large majority of cases for which the\n-  \/\/ associated cluster has very few dirty card-table entries.\n+  \/\/ An implementation of process_clusters() may choose to efficiently\n+  \/\/ address more typical scenarios in the structure of remembered sets. E.g.\n+  \/\/ in the generational setting, one might expect remembered sets to be very sparse\n+  \/\/ (low mutation rates in the old generation leading to sparse dirty cards,\n+  \/\/ each with very few intergenerational pointers). Specific implementations\n+  \/\/ may choose to degrade gracefully as the sparsity assumption fails to hold,\n+  \/\/ such as when there are sudden spikes in (premature) promotion or in the\n+  \/\/ case of an underprovisioned, poorly-tuned, or poorly-shaped heap.\n@@ -947,2 +880,2 @@\n-  \/\/ At initialization of concurrent marking, invoke process_clusters with\n-  \/\/ ClosureType equal to ShenandoahInitMarkRootsClosure.\n+  \/\/ At the start of a concurrent young generation marking cycle, we invoke process_clusters\n+  \/\/ with ClosureType ShenandoahInitMarkRootsClosure.\n@@ -950,2 +883,2 @@\n-  \/\/ At initialization of concurrent evacuation, invoke process_clusters with\n-  \/\/ ClosureType equal to ShenandoahEvacuateUpdateRootsClosure.\n+  \/\/ At the start of a concurrent evacuation phase, we invoke process_clusters with\n+  \/\/ ClosureType ShenandoahEvacuateUpdateRootsClosure.\n@@ -953,4 +886,2 @@\n-  \/\/ This is big enough it probably shouldn't be in-lined.  On the other hand, there are only a few places this\n-  \/\/ code is called from, so it might as well be in-lined.  The \"real\" reason I'm inlining at the moment is because\n-  \/\/ the template expansions were making it difficult for the link\/loader to resolve references to the template-\n-  \/\/ parameterized implementations of this service.\n+  \/\/ All template expansions require methods to be defined in the inline.hpp file, but larger\n+  \/\/ such methods need not be declared as inline.\n@@ -958,1 +889,1 @@\n-  inline void process_clusters(size_t first_cluster, size_t count, HeapWord *end_of_range, ClosureType *oops, bool is_concurrent);\n+  inline void process_clusters(size_t first_cluster, size_t count, HeapWord *end_of_range, ClosureType *oops, bool is_concurrent, uint worker_id);\n@@ -961,2 +892,2 @@\n-  inline void process_clusters(size_t first_cluster, size_t count, HeapWord *end_of_range, ClosureType *oops,\n-                               bool use_write_table, bool is_concurrent);\n+  void process_clusters(size_t first_cluster, size_t count, HeapWord *end_of_range, ClosureType *oops,\n+                               bool use_write_table, bool is_concurrent, uint worker_id);\n@@ -968,7 +899,0 @@\n-\n-  template <typename ClosureType>\n-  inline void process_region(ShenandoahHeapRegion* region, ClosureType *cl, bool is_concurrent);\n-\n-  template <typename ClosureType>\n-  inline void process_region(ShenandoahHeapRegion* region, ClosureType *cl, bool use_write_table, bool is_concurrent);\n-\n@@ -977,1 +901,1 @@\n-                                   ClosureType *cl, bool use_write_table, bool is_concurrent);\n+                                   ClosureType *cl, bool use_write_table, bool is_concurrent, uint worker_id);\n@@ -1001,0 +925,12 @@\n+\n+  \/\/ Log stats related to card\/RS stats for given phase t\n+  void log_card_stats(uint nworkers, CardStatLogType t) PRODUCT_RETURN;\n+private:\n+  \/\/ Log stats for given worker id related into given cumulative card\/RS stats\n+  void log_worker_card_stats(uint worker_id, HdrSeq* cum_stats) PRODUCT_RETURN;\n+\n+  \/\/ Log given stats\n+  inline void log_card_stats(HdrSeq* stats) PRODUCT_RETURN;\n+\n+  \/\/ Merge the stats from worked_id into the given summary stats, and clear the worker_id's stats.\n+  void merge_worker_card_stats_cumulative(HdrSeq* worker_stats, HdrSeq* cum_stats) PRODUCT_RETURN;\n@@ -1114,0 +1050,1 @@\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.hpp","additions":171,"deletions":234,"binary":false,"changes":405,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"gc\/shenandoah\/shenandoahCardStats.hpp\"\n@@ -466,4 +467,3 @@\n-inline void\n-ShenandoahScanRemembered<RememberedSet>::process_clusters(size_t first_cluster, size_t count, HeapWord *end_of_range,\n-                                                          ClosureType *cl, bool is_concurrent) {\n-  process_clusters(first_cluster, count, end_of_range, cl, false, is_concurrent);\n+inline void ShenandoahScanRemembered<RememberedSet>::process_clusters(size_t first_cluster, size_t count, HeapWord *end_of_range,\n+                                                          ClosureType *cl, bool is_concurrent, uint worker_id) {\n+  process_clusters(first_cluster, count, end_of_range, cl, false, is_concurrent, worker_id);\n@@ -473,2 +473,4 @@\n-\/\/ less than end_of_range.  For any such object, process the complete object, even if its end reaches beyond end_of_range.\n-\n+\/\/ less than end_of_range.  For any non-array object whose header lies on a dirty card, scan the entire object,\n+\/\/ even if its end reaches beyond end_of_range. Object arrays, on the other hand,s are precisely dirtied and only\n+\/\/ the portions of the array on dirty cards need to be scanned.\n+\/\/\n@@ -480,3 +482,2 @@\n-inline void\n-ShenandoahScanRemembered<RememberedSet>::process_clusters(size_t first_cluster, size_t count, HeapWord *end_of_range,\n-                                                          ClosureType *cl, bool write_table, bool is_concurrent) {\n+void ShenandoahScanRemembered<RememberedSet>::process_clusters(size_t first_cluster, size_t count, HeapWord *end_of_range,\n+                                                               ClosureType *cl, bool write_table, bool is_concurrent, uint worker_id) {\n@@ -485,2 +486,2 @@\n-  \/\/ themselves marked.  Each such object will be scanned only once.  Any young-gen objects referenced from the remembered set will\n-  \/\/ be marked and then subsequently scanned.\n+  \/\/ always themselves marked.  Each such object will be scanned exactly once.  Any young-gen objects referenced from the remembered\n+  \/\/ set will be marked and then subsequently scanned.\n@@ -490,1 +491,1 @@\n-  \/\/ regions which are in the candidate collection set have not been coalesced and filled.  Thus, these heap regions\n+  \/\/ regions that are in the candidate collection set have not been coalesced and filled.  Thus, these heap regions\n@@ -493,1 +494,2 @@\n-  \/\/ collected and their memory repurposed, and because zombie objects might refer to objects that are themselves dead.\n+  \/\/ collected (if dead), or relocated (if live), or if dead but not yet collected, we don't want to \"revive\" them\n+  \/\/ by marking them (when marking) or evacuating them (when updating refereces).\n@@ -504,2 +506,4 @@\n-  size_t card_index = first_cluster * ShenandoahCardCluster<RememberedSet>::CardsPerCluster;\n-  HeapWord *start_of_range = _rs->addr_for_card_index(card_index);\n+  size_t cur_cluster = first_cluster;\n+  size_t cur_count = count;\n+  size_t card_index = cur_cluster * ShenandoahCardCluster<RememberedSet>::CardsPerCluster;\n+  HeapWord* start_of_range = _rs->addr_for_card_index(card_index);\n@@ -509,1 +513,3 @@\n-  while (count-- > 0) {\n+  NOT_PRODUCT(ShenandoahCardStats stats(ShenandoahCardCluster<RememberedSet>::CardsPerCluster, card_stats(worker_id));)\n+\n+  while (cur_count-- > 0) {\n@@ -512,1 +518,1 @@\n-    card_index = first_cluster * ShenandoahCardCluster<RememberedSet>::CardsPerCluster;\n+    card_index = cur_cluster * ShenandoahCardCluster<RememberedSet>::CardsPerCluster;\n@@ -514,1 +520,1 @@\n-    first_cluster++;\n+    cur_cluster++;\n@@ -516,1 +522,3 @@\n-    while (card_index < end_card_index) {\n+\n+    assert(stats.is_clean(), \"Error\");\n+    while (card_index < end_card_index) {    \/\/ TODO: understand why end_of_range is needed.\n@@ -518,1 +526,1 @@\n-        count = 0;\n+        cur_count = 0;\n@@ -524,0 +532,1 @@\n+      NOT_PRODUCT(stats.increment_card_cnt(is_dirty);)\n@@ -549,0 +558,1 @@\n+            NOT_PRODUCT(stats.increment_obj_cnt(is_dirty);)\n@@ -560,0 +570,1 @@\n+                NOT_PRODUCT(stats.increment_scan_cnt(is_dirty);)\n@@ -562,0 +573,1 @@\n+                NOT_PRODUCT(stats.increment_scan_cnt(is_dirty);)\n@@ -589,29 +601,30 @@\n-      } else if (has_object) {\n-        \/\/ Card is clean but has object.\n-\n-        \/\/ Scan the last object that starts within this card memory if it spans at least one dirty card within this cluster\n-        \/\/ or if it reaches into the next cluster.\n-        size_t start_offset = _scc->get_last_start(card_index);\n-        HeapWord *card_start = _rs->addr_for_card_index(card_index);\n-        HeapWord *p = card_start + start_offset;\n-        oop obj = cast_to_oop(p);\n-\n-        size_t last_card;\n-        if (!ctx || ctx->is_marked(obj)) {\n-          HeapWord *nextp = p + obj->size();\n-\n-          \/\/ Can't use _scc->card_index_for_addr(endp) here because it crashes with assertion\n-          \/\/ failure if nextp points to end of heap. Must also not attempt to read past last\n-          \/\/ valid index for card table.\n-          last_card = card_index + (nextp - card_start) \/ CardTable::card_size_in_words();\n-          last_card = MIN2(last_card, last_valid_index());\n-\n-          bool reaches_next_cluster = (last_card > end_card_index);\n-          bool spans_dirty_within_this_cluster = false;\n-\n-          if (!reaches_next_cluster) {\n-            size_t span_card;\n-            for (span_card = card_index+1; span_card <= last_card; span_card++)\n-              if ((write_table)? _rs->is_write_card_dirty(span_card): _rs->is_card_dirty(span_card)) {\n-                spans_dirty_within_this_cluster = true;\n-                break;\n+      } else {\n+        if (has_object) {\n+          \/\/ Card is clean but has object.\n+          \/\/ Scan the last object that starts within this card memory if it spans at least one dirty card within this cluster\n+          \/\/ or if it reaches into the next cluster.\n+          size_t start_offset = _scc->get_last_start(card_index);\n+          HeapWord *card_start = _rs->addr_for_card_index(card_index);\n+          HeapWord *p = card_start + start_offset;\n+          oop obj = cast_to_oop(p);\n+\n+          size_t last_card;\n+          if (!ctx || ctx->is_marked(obj)) {\n+            HeapWord *nextp = p + obj->size();\n+            NOT_PRODUCT(stats.increment_obj_cnt(is_dirty);)\n+\n+            \/\/ Can't use _scc->card_index_for_addr(endp) here because it crashes with assertion\n+            \/\/ failure if nextp points to end of heap. Must also not attempt to read past last\n+            \/\/ valid index for card table.\n+            last_card = card_index + (nextp - card_start) \/ CardTable::card_size_in_words();\n+            last_card = MIN2(last_card, last_valid_index());\n+\n+            bool reaches_next_cluster = (last_card > end_card_index);\n+            bool spans_dirty_within_this_cluster = false;\n+\n+            if (!reaches_next_cluster) {\n+              for (size_t span_card = card_index+1; span_card <= last_card; span_card++) {\n+                if ((write_table)? _rs->is_write_card_dirty(span_card): _rs->is_card_dirty(span_card)) {\n+                  spans_dirty_within_this_cluster = true;\n+                  break;\n+                }\n@@ -619,1 +632,6 @@\n-          }\n+            }\n+\n+            \/\/ TODO: only iterate over this object if it spans dirty within this cluster or within following clusters.\n+            \/\/ Code as written is known not to examine a zombie object because either the object is marked, or we are\n+            \/\/ not using the mark-context to differentiate objects, so the object is known to have been coalesced and\n+            \/\/ filled if it is not \"live\".\n@@ -621,12 +639,24 @@\n-          \/\/ TODO: only iterate over this object if it spans dirty within this cluster or within following clusters.\n-          \/\/ Code as written is known not to examine a zombie object because either the object is marked, or we are\n-          \/\/ not using the mark-context to differentiate objects, so the object is known to have been coalesced and\n-          \/\/ filled if it is not \"live\".\n-\n-          if (reaches_next_cluster || spans_dirty_within_this_cluster) {\n-            if (obj->is_objArray()) {\n-              objArrayOop array = objArrayOop(obj);\n-              int len = array->length();\n-              array->oop_iterate_range(cl, 0, len);\n-            } else if (obj->is_instance()) {\n-              obj->oop_iterate(cl);\n+            if (reaches_next_cluster || spans_dirty_within_this_cluster) {\n+              if (obj->is_objArray()) {\n+                objArrayOop array = objArrayOop(obj);\n+                int len = array->length();\n+                array->oop_iterate_range(cl, 0, len);\n+                NOT_PRODUCT(stats.increment_scan_cnt(is_dirty);)\n+              } else if (obj->is_instance()) {\n+                obj->oop_iterate(cl);\n+                NOT_PRODUCT(stats.increment_scan_cnt(is_dirty);)\n+              } else {\n+                \/\/ Case 3: Primitive array. Do nothing, no oops there. We use the same\n+                \/\/ performance tweak TypeArrayKlass::oop_oop_iterate_impl is using:\n+                \/\/ We skip iterating over the klass pointer since we know that\n+                \/\/ Universe::TypeArrayKlass never moves.\n+                assert (obj->is_typeArray(), \"should be type array\");\n+              }\n+            }\n+          } else {\n+            \/\/ The object that spans end of this clean card is not marked, so no need to scan it or its\n+            \/\/ unmarked neighbors.  Containing region r is initialized above.\n+            HeapWord* tams = ctx->top_at_mark_start(r);\n+            HeapWord* nextp;\n+            if (p >= tams) {\n+              nextp = p + obj->size();\n@@ -634,5 +664,1 @@\n-              \/\/ Case 3: Primitive array. Do nothing, no oops there. We use the same\n-              \/\/ performance tweak TypeArrayKlass::oop_oop_iterate_impl is using:\n-              \/\/ We skip iterating over the klass pointer since we know that\n-              \/\/ Universe::TypeArrayKlass never moves.\n-              assert (obj->is_typeArray(), \"should be type array\");\n+              nextp = ctx->get_next_marked_addr(p, tams);\n@@ -640,0 +666,1 @@\n+            last_card = card_index + (nextp - card_start) \/ CardTable::card_size_in_words();\n@@ -641,0 +668,2 @@\n+          \/\/ Increment card_index to account for the spanning object, even if we didn't scan it.\n+          card_index = (last_card > card_index)? last_card: card_index + 1;\n@@ -642,10 +671,2 @@\n-          \/\/ The object that spans end of this clean card is not marked, so no need to scan it or its\n-          \/\/ unmarked neighbors.  Containing region r is initialized above.\n-          HeapWord* tams = ctx->top_at_mark_start(r);\n-          HeapWord* nextp;\n-          if (p >= tams) {\n-            nextp = p + obj->size();\n-          } else {\n-            nextp = ctx->get_next_marked_addr(p, tams);\n-          }\n-          last_card = card_index + (nextp - card_start) \/ CardTable::card_size_in_words();\n+          \/\/ Card is clean and has no object.  No need to clean this card.\n+          card_index++;\n@@ -653,5 +674,0 @@\n-        \/\/ Increment card_index to account for the spanning object, even if we didn't scan it.\n-        card_index = (last_card > card_index)? last_card: card_index + 1;\n-      } else {\n-        \/\/ Card is clean and has no object.  No need to clean this card.\n-        card_index++;\n@@ -659,2 +675,3 @@\n-    }\n-  }\n+    } \/\/ end of a range of cards in current cluster\n+    NOT_PRODUCT(stats.update_run(true \/* record *\/);)\n+  } \/\/ end of all clusters\n@@ -684,18 +701,0 @@\n-template<typename RememberedSet>\n-template <typename ClosureType>\n-inline void\n-ShenandoahScanRemembered<RememberedSet>::process_region(ShenandoahHeapRegion *region, ClosureType *cl, bool is_concurrent) {\n-  process_region(region, cl, false, is_concurrent);\n-}\n-\n-template<typename RememberedSet>\n-template <typename ClosureType>\n-inline void\n-ShenandoahScanRemembered<RememberedSet>::process_region(ShenandoahHeapRegion *region, ClosureType *cl,\n-                                                        bool use_write_table, bool is_concurrent) {\n-  size_t cluster_size =\n-    CardTable::card_size_in_words() * ShenandoahCardCluster<ShenandoahDirectCardMarkRememberedSet>::CardsPerCluster;\n-  size_t clusters = ShenandoahHeapRegion::region_size_words() \/ cluster_size;\n-  process_region_slice(region, 0, clusters, region->end(), cl, use_write_table, is_concurrent);\n-}\n-\n@@ -707,1 +706,1 @@\n-                                                              bool is_concurrent) {\n+                                                              bool is_concurrent, uint worker_id) {\n@@ -756,1 +755,1 @@\n-      process_clusters(start_cluster_no, clusters, end_of_range, cl, use_write_table, is_concurrent);\n+      process_clusters(start_cluster_no, clusters, end_of_range, cl, use_write_table, is_concurrent, worker_id);\n@@ -778,1 +777,1 @@\n-inline void ShenandoahScanRemembered<RememberedSet>::roots_do(OopIterateClosure* cl) {\n+void ShenandoahScanRemembered<RememberedSet>::roots_do(OopIterateClosure* cl) {\n@@ -796,1 +795,1 @@\n-        process_clusters(start_cluster_no, num_clusters, end_of_range, cl, false \/* is_concurrent *\/);\n+        process_clusters(start_cluster_no, num_clusters, end_of_range, cl, false \/* is_concurrent *\/, 0);\n@@ -802,0 +801,52 @@\n+#ifndef PRODUCT\n+\/\/ Log given card stats\n+template<typename RememberedSet>\n+inline void ShenandoahScanRemembered<RememberedSet>::log_card_stats(HdrSeq* stats) {\n+  for (int i = 0; i < MAX_CARD_STAT_TYPE; i++) {\n+    log_info(gc, remset)(\"%18s: [ %8.2f %8.2f %8.2f %8.2f %8.2f ]\",\n+      _card_stats_name[i],\n+      stats[i].percentile(0), stats[i].percentile(25),\n+      stats[i].percentile(50), stats[i].percentile(75),\n+      stats[i].maximum());\n+  }\n+}\n+\n+\/\/ Log card stats for all nworkers for a specific phase t\n+template<typename RememberedSet>\n+void ShenandoahScanRemembered<RememberedSet>::log_card_stats(uint nworkers, CardStatLogType t) {\n+  assert(ShenandoahEnableCardStats, \"Do not call\");\n+  HdrSeq* cum_stats = card_stats_for_phase(t);\n+  log_info(gc, remset)(\"%s\", _card_stat_log_type[t]);\n+  for (uint i = 0; i < nworkers; i++) {\n+    log_worker_card_stats(i, cum_stats);\n+  }\n+\n+  \/\/ Every so often, log the cumulative global stats\n+  if (++_card_stats_log_counter[t] >= ShenandoahCardStatsLogInterval) {\n+    _card_stats_log_counter[t] = 0;\n+    log_info(gc, remset)(\"Cumulative stats\");\n+    log_card_stats(cum_stats);\n+  }\n+}\n+\n+\/\/ Log card stats for given worker_id, & clear them after merging into given cumulative stats\n+template<typename RememberedSet>\n+void ShenandoahScanRemembered<RememberedSet>::log_worker_card_stats(uint worker_id, HdrSeq* cum_stats) {\n+  assert(ShenandoahEnableCardStats, \"Do not call\");\n+\n+  HdrSeq* worker_card_stats = card_stats(worker_id);\n+  log_info(gc, remset)(\"Worker %u Card Stats Histo: \", worker_id);\n+  log_card_stats(worker_card_stats);\n+  \/\/ Merge worker stats into the cumulative stats & clear worker stats\n+  merge_worker_card_stats_cumulative(worker_card_stats, cum_stats);\n+}\n+\n+template<typename RememberedSet>\n+void ShenandoahScanRemembered<RememberedSet>::merge_worker_card_stats_cumulative(\n+  HdrSeq* worker_stats, HdrSeq* cum_stats) {\n+  for (int i = 0; i < MAX_CARD_STAT_TYPE; i++) {\n+    worker_stats[i].merge(cum_stats[i]);\n+  }\n+}\n+#endif\n+\n@@ -841,1 +892,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.inline.hpp","additions":157,"deletions":107,"binary":false,"changes":264,"status":"modified"},{"patch":"@@ -543,2 +543,8 @@\n-          \"regions each time this many young-gen GC cycles are completed.\")\n- \/\/ end of GC_SHENANDOAH_FLAGS\n+          \"regions each time this many young-gen GC cycles are completed.\") \\\n+                                                                            \\\n+  notproduct(bool, ShenandoahEnableCardStats, trueInDebug,                  \\\n+          \"Enable statistics collection related to clean & dirty cards\")    \\\n+                                                                            \\\n+  notproduct(int, ShenandoahCardStatsLogInterval, 50,                       \\\n+          \"Log cumulative card stats every so many cycles\")                 \\\n+  \/\/ end of GC_SHENANDOAH_FLAGS\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoah_globals.hpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -113,1 +113,0 @@\n-\n@@ -124,2 +123,1 @@\n-\n-  \/\/ Until JDK-... is fixed, we taint the decaying statistics\n+  \/\/ Until JDK-8298902 is fixed, we taint the decaying statistics\n","filename":"src\/hotspot\/share\/utilities\/numberSeq.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"}]}