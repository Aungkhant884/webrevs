{"files":[{"patch":"@@ -986,31 +986,27 @@\n-  if (!mode()->is_generational()) {\n-    plab->retire();\n-  } else {\n-    \/\/ We don't enforce limits on plab_evacuated.  We let it consume all available old-gen memory in order to reduce\n-    \/\/ probability of an evacuation failure.  We do enforce limits on promotion, to make sure that excessive promotion\n-    \/\/ does not result in an old-gen evacuation failure.  Note that a failed promotion is relatively harmless.  Any\n-    \/\/ object that fails to promote in the current cycle will be eligible for promotion in a subsequent cycle.\n-\n-    \/\/ When the plab was instantiated, its entirety was treated as if the entire buffer was going to be dedicated to\n-    \/\/ promotions.  Now that we are retiring the buffer, we adjust for the reality that the plab is not entirely promotions.\n-    \/\/  1. Some of the plab may have been dedicated to evacuations.\n-    \/\/  2. Some of the plab may have been abandoned due to waste (at the end of the plab).\n-    size_t not_promoted =\n-      ShenandoahThreadLocalData::get_plab_preallocated_promoted(thread) - ShenandoahThreadLocalData::get_plab_promoted(thread);\n-    ShenandoahThreadLocalData::reset_plab_promoted(thread);\n-    ShenandoahThreadLocalData::reset_plab_evacuated(thread);\n-    ShenandoahThreadLocalData::set_plab_preallocated_promoted(thread, 0);\n-    if (not_promoted > 0) {\n-      unexpend_promoted(not_promoted);\n-    }\n-    size_t waste = plab->waste();\n-    HeapWord* top = plab->top();\n-    plab->retire();\n-    if (top != NULL && plab->waste() > waste && is_in_old(top)) {\n-      \/\/ If retiring the plab created a filler object, then we\n-      \/\/ need to register it with our card scanner so it can\n-      \/\/ safely walk the region backing the plab.\n-      log_debug(gc)(\"retire_plab() is registering remnant of size \" SIZE_FORMAT \" at \" PTR_FORMAT,\n-                    plab->waste() - waste, p2i(top));\n-      card_scan()->register_object_wo_lock(top);\n-    }\n+  \/\/ We don't enforce limits on plab_evacuated.  We let it consume all available old-gen memory in order to reduce\n+  \/\/ probability of an evacuation failure.  We do enforce limits on promotion, to make sure that excessive promotion\n+  \/\/ does not result in an old-gen evacuation failure.  Note that a failed promotion is relatively harmless.  Any\n+  \/\/ object that fails to promote in the current cycle will be eligible for promotion in a subsequent cycle.\n+\n+  \/\/ When the plab was instantiated, its entirety was treated as if the entire buffer was going to be dedicated to\n+  \/\/ promotions.  Now that we are retiring the buffer, we adjust for the reality that the plab is not entirely promotions.\n+  \/\/  1. Some of the plab may have been dedicated to evacuations.\n+  \/\/  2. Some of the plab may have been abandoned due to waste (at the end of the plab).\n+  size_t not_promoted =\n+    ShenandoahThreadLocalData::get_plab_preallocated_promoted(thread) - ShenandoahThreadLocalData::get_plab_promoted(thread);\n+  ShenandoahThreadLocalData::reset_plab_promoted(thread);\n+  ShenandoahThreadLocalData::reset_plab_evacuated(thread);\n+  ShenandoahThreadLocalData::set_plab_preallocated_promoted(thread, 0);\n+  if (not_promoted > 0) {\n+    unexpend_promoted(not_promoted);\n+  }\n+  size_t waste = plab->waste();\n+  HeapWord* top = plab->top();\n+  plab->retire();\n+  if (top != NULL && plab->waste() > waste && is_in_old(top)) {\n+    \/\/ If retiring the plab created a filler object, then we\n+    \/\/ need to register it with our card scanner so it can\n+    \/\/ safely walk the region backing the plab.\n+    log_debug(gc)(\"retire_plab() is registering remnant of size \" SIZE_FORMAT \" at \" PTR_FORMAT,\n+                  plab->waste() - waste, p2i(top));\n+    card_scan()->register_object_wo_lock(top);\n@@ -1021,6 +1017,2 @@\n-  if (!mode()->is_generational()) {\n-    plab->retire();\n-  } else {\n-    Thread* thread = Thread::current();\n-    retire_plab(plab, thread);\n-  }\n+  Thread* thread = Thread::current();\n+  retire_plab(plab, thread);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":29,"deletions":37,"binary":false,"changes":66,"status":"modified"}]}