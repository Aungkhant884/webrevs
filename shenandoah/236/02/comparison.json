{"files":[{"patch":"@@ -115,0 +115,1 @@\n+    \/\/ We have added the last of our collection candidates to a mixed collection.\n@@ -116,0 +117,10 @@\n+  } else if (included_old_regions == 0) {\n+    \/\/ We have candidates, but none were included for evacuation - are they all be pinned?\n+    \/\/ or did we just not have enough room for any of them in this collection set?\n+    \/\/ We don't want a region with a stuck pin to prevent subsequent old collections, so\n+    \/\/ if they are all pinned we transition to a state that will allow us to make these uncollected\n+    \/\/ (pinned) regions parseable.\n+    if (all_candidates_are_pinned()) {\n+      log_info(gc)(\"All candidate regions \" UINT32_FORMAT \" are pinned.\", unprocessed_old_collection_candidates());\n+      _old_generation->transition_to(ShenandoahOldGeneration::WAITING_FOR_FILL);\n+    }\n@@ -121,0 +132,16 @@\n+bool ShenandoahOldHeuristics::all_candidates_are_pinned() {\n+#ifdef ASSERT\n+  if (uint(os::random()) % 100 < ShenandoahCoalesceChance) {\n+    return true;\n+  }\n+#endif\n+\n+  for (uint i = _next_old_collection_candidate; i < _last_old_collection_candidate; ++i) {\n+    auto region = _region_data[i]._region;\n+    if (!region->is_pinned()) {\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n@@ -276,1 +303,1 @@\n-    _old_generation->transition_to(ShenandoahOldGeneration::WAITING);\n+    _old_generation->transition_to(ShenandoahOldGeneration::WAITING_FOR_EVAC);\n@@ -352,1 +379,1 @@\n-  if (unprocessed_old_collection_candidates() > 0) {\n+  if (!_old_generation->can_start_gc()) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.cpp","additions":29,"deletions":2,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -164,0 +164,1 @@\n+  bool all_candidates_are_pinned();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -510,0 +510,1 @@\n+    case ShenandoahOldGeneration::WAITING_FOR_FILL:\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -252,1 +252,0 @@\n-  ShenandoahOldHeuristics* old_heuristics = heap->old_heuristics();\n@@ -254,1 +253,1 @@\n-  if (old_heuristics->unprocessed_old_collection_candidates() > 0) {\n+  if (heap->doing_mixed_evacuations()) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -681,1 +681,1 @@\n-  return old_heuristics()->unprocessed_old_collection_candidates() > 0;\n+  return _old_generation->state() == ShenandoahOldGeneration::WAITING_FOR_EVAC;\n@@ -1071,4 +1071,1 @@\n-  return is_concurrent_old_mark_in_progress()\n-         || is_prepare_for_old_mark_in_progress()\n-         || old_heuristics()->unprocessed_old_collection_candidates() > 0\n-         || young_generation()->old_gen_task_queues() != nullptr;\n+  return _old_generation->state() != ShenandoahOldGeneration::IDLE;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -258,0 +258,3 @@\n+  \/\/ This code will see the same set of regions to filled on each resumption as it did\n+  \/\/ on the initial run. That's okay because each region keeps track of its own coalesce\n+  \/\/ and fill state. Region that were filled on a prior attempt will not try to fill again.\n@@ -266,0 +269,1 @@\n+    old_heuristics->abandon_collection_candidates();\n@@ -326,1 +330,2 @@\n-    case WAITING:       return \"Waiting\";\n+    case WAITING_FOR_EVAC:  return \"Waiting for evacuation\";\n+    case WAITING_FOR_FILL:  return \"Waiting for fill\";\n@@ -389,0 +394,1 @@\n+      assert(_state == MARKING || _state == WAITING_FOR_EVAC, \"Must come from marking or evacuating.\");\n@@ -395,1 +401,1 @@\n-      assert(_state == IDLE, \"Cannot begin filling without first being idle.\");\n+      assert(_state == IDLE || _state == WAITING_FOR_FILL, \"Cannot begin filling without first completing evacuations.\");\n@@ -400,1 +406,1 @@\n-      \/\/ assert(heap->young_generation()->old_gen_task_queues() != nullptr, \"Cannot bootstrap without old mark queues.\");\n+      assert(_old_heuristics->unprocessed_old_collection_candidates() == 0, \"Cannot bootstrap with mixed collection candidates\");\n@@ -408,1 +414,1 @@\n-    case WAITING:\n+    case WAITING_FOR_EVAC:\n@@ -412,0 +418,4 @@\n+    case WAITING_FOR_FILL:\n+      assert(_state == MARKING || _state == WAITING_FOR_EVAC, \"Cannot begin filling without first marking or evacuating.\");\n+      assert(_old_heuristics->unprocessed_old_collection_candidates() > 0, \"Cannot wait for fill without something to fill.\");\n+      return true;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.cpp","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n-    IDLE, FILLING, BOOTSTRAPPING, MARKING, WAITING\n+    IDLE, FILLING, BOOTSTRAPPING, MARKING, WAITING_FOR_EVAC, WAITING_FOR_FILL\n@@ -98,0 +98,4 @@\n+  bool can_start_gc() {\n+    return _state == IDLE || _state == WAITING_FOR_FILL;\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -454,0 +454,9 @@\n+  product(uintx, ShenandoahCoalesceChance, 0, DIAGNOSTIC,                   \\\n+          \"Testing: Abandon remaining mixed collections with this \"         \\\n+          \"likelihood. Following each mixed collection, abandon all \"       \\\n+          \"remaining mixed collection candidate regions with likelihood \"   \\\n+          \"ShenandoahCoalesceChance. Abandoning a mixed collection will \"   \\\n+          \"cause the old regions to be made parseable, rather than being \"  \\\n+          \"evacuated.\")                                                     \\\n+          range(0, 100)                                                     \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoah_globals.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -70,0 +70,4 @@\n+  ShenandoahOldGeneration::State old_generation_state() {\n+    return _heap->old_generation()->state();\n+  }\n+\n@@ -314,0 +318,20 @@\n+TEST_VM_F(ShenandoahOldHeuristicTest, all_candidates_are_pinned) {\n+  SKIP_IF_NOT_SHENANDOAH();\n+\n+  size_t g1 = make_garbage_above_threshold(0);\n+  size_t g2 = make_garbage_above_threshold(1);\n+  size_t g3 = make_garbage_above_threshold(2);\n+\n+  make_pinned(0);\n+  make_pinned(1);\n+  make_pinned(2);\n+  _heuristics->prepare_for_old_collections();\n+  _heuristics->prime_collection_set(_collection_set);\n+\n+  \/\/ In the case when all candidates are pinned, we want to abandon\n+  \/\/ this set of mixed collection candidates so that another old collection\n+  \/\/ can run. This is meant to defend against \"bad\" JNI code that permanently\n+  \/\/ leaves an old region in the pinned state.\n+  EXPECT_EQ(_collection_set->count(), 0UL);\n+  EXPECT_EQ(old_generation_state(), ShenandoahOldGeneration::WAITING_FOR_FILL);\n+}\n","filename":"test\/hotspot\/gtest\/gc\/shenandoah\/test_shenandoahOldHeuristic.cpp","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"}]}