{"files":[{"patch":"@@ -26,0 +26,7 @@\n+#include \"shenandoahAdaptiveHeuristics.hpp\"\n+#include \"runtime\/globals_extension.hpp\"\n+#include \"gc\/shenandoah\/heuristics\/shenandoahHeuristics.hpp\"\n+#include \"gc\/shenandoah\/heuristics\/shenandoahHeapStats.hpp\"\n+#include \"gc\/shenandoah\/shenandoahMarkingContext.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahCollectorPolicy.hpp\"\n+#include \"gc\/shared\/gcCause.hpp\"\n@@ -58,2 +65,3 @@\n-ShenandoahAdaptiveHeuristics::ShenandoahAdaptiveHeuristics(ShenandoahHeapCharacteristics* heap_info) :\n-  ShenandoahHeuristics(heap_info),\n+ShenandoahAdaptiveHeuristics::ShenandoahAdaptiveHeuristics(ShenandoahHeapStats* heap_stats) :\n+  ShenandoahHeuristics(),\n+  _heap_stats(heap_stats),\n@@ -133,1 +141,1 @@\n-  size_t available = MIN2(_heap_info->available(), ShenandoahHeap::heap()->free_set()->available());\n+  size_t available = MIN2(_heap_stats->available(), ShenandoahHeap::heap()->free_set()->available());\n@@ -141,1 +149,1 @@\n-                        _heap_info->name(),\n+                        _heap_stats->name(),\n@@ -204,3 +212,3 @@\n-  size_t capacity = _heap_info->soft_max_capacity();\n-  size_t available = _heap_info->soft_available();\n-  size_t allocated = _heap_info->bytes_allocated_since_gc_start();\n+  size_t capacity = _heap_stats->soft_max_capacity();\n+  size_t available = _heap_stats->soft_available();\n+  size_t allocated = _heap_stats->bytes_allocated_since_gc_start();\n@@ -210,1 +218,1 @@\n-                _heap_info->name(), available, capacity, allocated);\n+                _heap_stats->name(), available, capacity, allocated);\n@@ -218,1 +226,1 @@\n-    log_info(gc)(\"Trigger (%s): Free (\" SIZE_FORMAT \"%s) is below minimum threshold (\" SIZE_FORMAT \"%s)\", _heap_info->name(),\n+    log_info(gc)(\"Trigger (%s): Free (\" SIZE_FORMAT \"%s) is below minimum threshold (\" SIZE_FORMAT \"%s)\", _heap_stats->name(),\n@@ -230,1 +238,1 @@\n-                   _heap_info->name(), _gc_times_learned + 1, max_learn,\n+                   _heap_stats->name(), _gc_times_learned + 1, max_learn,\n@@ -278,1 +286,1 @@\n-                _heap_info->name(),\n+                _heap_stats->name(),\n@@ -283,1 +291,1 @@\n-                 _heap_info->name(), avg_cycle_time * 1000,\n+                 _heap_stats->name(), avg_cycle_time * 1000,\n@@ -299,1 +307,1 @@\n-                 _heap_info->name(), avg_cycle_time * 1000,\n+                 _heap_stats->name(), avg_cycle_time * 1000,\n@@ -336,0 +344,7 @@\n+size_t ShenandoahAdaptiveHeuristics::min_free_threshold() {\n+  \/\/ Note that soft_max_capacity() \/ 100 * min_free_threshold is smaller than max_capacity() \/ 100 * min_free_threshold.\n+  \/\/ We want to behave conservatively here, so use max_capacity().  By returning a larger value, we cause the GC to\n+  \/\/ trigger when the remaining amount of free shrinks below the larger threshold.\n+  return _heap_stats->max_capacity() \/ 100 * ShenandoahMinFreeThreshold;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.cpp","additions":28,"deletions":13,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -29,0 +29,4 @@\n+#include \"runtime\/globals_extension.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"gc\/shenandoah\/heuristics\/shenandoahHeapStats.hpp\"\n+#include \"gc\/shenandoah\/shenandoahSharedVariables.hpp\"\n@@ -55,1 +59,1 @@\n-  ShenandoahAdaptiveHeuristics(ShenandoahHeapCharacteristics* heap_info);\n+  ShenandoahAdaptiveHeuristics(ShenandoahHeapStats* heap_stats);\n@@ -102,0 +106,2 @@\n+  ShenandoahHeapStats* _heap_stats;\n+\n@@ -106,1 +112,1 @@\n-  \/\/ tend to over estimate the rate at which mutators will deplete the\n+  \/\/ tend to overestimate the rate at which mutators will deplete the\n@@ -129,0 +135,2 @@\n+\n+  size_t min_free_threshold();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.hpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -35,3 +35,1 @@\n-ShenandoahAggressiveHeuristics::ShenandoahAggressiveHeuristics(ShenandoahHeapCharacteristics* heap_info) :\n-  ShenandoahHeuristics(heap_info) {\n-\n+ShenandoahAggressiveHeuristics::ShenandoahAggressiveHeuristics() : ShenandoahHeuristics() {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAggressiveHeuristics.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-  ShenandoahAggressiveHeuristics(ShenandoahHeapCharacteristics* heap_info);\n+  ShenandoahAggressiveHeuristics();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAggressiveHeuristics.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"gc\/shenandoah\/shenandoahGeneration.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n@@ -36,2 +36,1 @@\n-ShenandoahCompactHeuristics::ShenandoahCompactHeuristics(ShenandoahHeapCharacteristics* heap_info) :\n-  ShenandoahHeuristics(heap_info) {\n+ShenandoahCompactHeuristics::ShenandoahCompactHeuristics() : ShenandoahHeuristics() {\n@@ -50,4 +49,5 @@\n-  size_t max_capacity = _heap_info->max_capacity();\n-  size_t capacity     = _heap_info->soft_max_capacity();\n-  size_t usage        = _heap_info->used();\n-  size_t available    = (capacity > usage)? capacity - usage: 0;\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+\n+  size_t max_capacity = heap->max_capacity();\n+  size_t capacity = heap->soft_max_capacity();\n+  size_t available = heap->free_set()->available();\n@@ -60,1 +60,1 @@\n-  size_t min_threshold = min_free_threshold();\n+  size_t min_threshold = capacity \/ 100 * ShenandoahMinFreeThreshold;\n@@ -69,1 +69,1 @@\n-  size_t bytes_allocated = _heap_info->bytes_allocated_since_gc_start();\n+  size_t bytes_allocated = heap->bytes_allocated_since_gc_start();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahCompactHeuristics.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-  ShenandoahCompactHeuristics(ShenandoahHeapCharacteristics* heap_info);\n+  ShenandoahCompactHeuristics();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahCompactHeuristics.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-class ShenandoahHeapCharacteristics {\n+class ShenandoahHeapStats {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeapStats.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeapCharacteristics.hpp","status":"renamed"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"gc\/shenandoah\/heuristics\/shenandoahHeapCharacteristics.hpp\"\n@@ -37,0 +36,1 @@\n+#include \"shenandoahAdaptiveHeuristics.hpp\"\n@@ -47,2 +47,1 @@\n-ShenandoahHeuristics::ShenandoahHeuristics(ShenandoahHeapCharacteristics* heap_info) :\n-        _heap_info(heap_info),\n+ShenandoahHeuristics::ShenandoahHeuristics() :\n@@ -205,2 +204,2 @@\n-      log_info(gc)(\"Trigger (%s): Time since last GC (%.0f ms) is larger than guaranteed interval (\" UINTX_FORMAT \" ms)\",\n-                   _heap_info->name(), last_time_ms, _guaranteed_gc_interval);\n+      log_info(gc)(\"Trigger: Time since last GC (%.0f ms) is larger than guaranteed interval (\" UINTX_FORMAT \" ms)\",\n+                   last_time_ms, _guaranteed_gc_interval);\n@@ -302,7 +301,0 @@\n-\n-size_t ShenandoahHeuristics::min_free_threshold() {\n-  \/\/ Note that soft_max_capacity() \/ 100 * min_free_threshold is smaller than max_capacity() \/ 100 * min_free_threshold.\n-  \/\/ We want to behave conservatively here, so use max_capacity().  By returning a larger value, we cause the GC to\n-  \/\/ trigger when the remaining amount of free shrinks below the larger threshold.\n-  return _heap_info->max_capacity() \/ 100 * ShenandoahMinFreeThreshold;\n-}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.cpp","additions":4,"deletions":12,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"gc\/shenandoah\/heuristics\/shenandoahHeapCharacteristics.hpp\"\n+#include \"gc\/shenandoah\/heuristics\/shenandoahHeapStats.hpp\"\n@@ -78,2 +78,0 @@\n-  ShenandoahHeapCharacteristics* _heap_info;\n-\n@@ -121,2 +119,0 @@\n-  size_t min_free_threshold();\n-\n@@ -124,1 +120,1 @@\n-  ShenandoahHeuristics(ShenandoahHeapCharacteristics* heap_info);\n+  ShenandoahHeuristics();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.hpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-  ShenandoahHeuristics(generation),\n+  ShenandoahHeuristics(),\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"gc\/shenandoah\/heuristics\/shenandoahHeapCharacteristics.hpp\"\n@@ -57,1 +56,1 @@\n-  size_t max_capacity = _heap_info->max_capacity();\n+  size_t max_capacity = ShenandoahHeap::heap()->max_capacity();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahPassiveHeuristics.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -32,2 +32,0 @@\n-  ShenandoahPassiveHeuristics(ShenandoahHeapCharacteristics* heap_info)\n-    : ShenandoahHeuristics(heap_info) {}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahPassiveHeuristics.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n@@ -32,1 +33,0 @@\n-#include \"gc\/shenandoah\/shenandoahGeneration.hpp\"\n@@ -36,2 +36,1 @@\n-ShenandoahStaticHeuristics::ShenandoahStaticHeuristics(ShenandoahHeapCharacteristics* heap_info) :\n-  ShenandoahHeuristics(heap_info) {\n+ShenandoahStaticHeuristics::ShenandoahStaticHeuristics() : ShenandoahHeuristics() {\n@@ -45,3 +44,5 @@\n-  size_t max_capacity = _heap_info->max_capacity();\n-  size_t capacity     = _heap_info->soft_max_capacity();\n-  size_t available    = _heap_info->available();\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+\n+  size_t max_capacity = heap->max_capacity();\n+  size_t capacity = heap->soft_max_capacity();\n+  size_t available = heap->free_set()->available();\n@@ -53,1 +54,1 @@\n-  size_t threshold_available = min_free_threshold();\n+  size_t threshold_available = capacity \/ 100 * ShenandoahMinFreeThreshold;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahStaticHeuristics.cpp","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-  ShenandoahStaticHeuristics(ShenandoahHeapCharacteristics* heap_info);\n+  ShenandoahStaticHeuristics();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahStaticHeuristics.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"shenandoahAdaptiveHeuristics.hpp\"\n@@ -143,1 +144,1 @@\n-                 _heap_info->name(),\n+                 _heap_stats->name(),\n@@ -154,1 +155,1 @@\n-                 _heap_info->name(),\n+                 _heap_stats->name(),\n@@ -165,1 +166,1 @@\n-                 _heap_info->name(), mixed_candidates);\n+                 _heap_stats->name(), mixed_candidates);\n@@ -177,2 +178,2 @@\n-  size_t capacity = _heap_info->soft_max_capacity();\n-  size_t usage = _heap_info->used();\n+  size_t capacity = _heap_stats->soft_max_capacity();\n+  size_t usage = _heap_stats->used();\n@@ -180,1 +181,1 @@\n-  size_t allocated = _heap_info->bytes_allocated_since_gc_start();\n+  size_t allocated = _heap_stats->bytes_allocated_since_gc_start();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahYoungHeuristics.cpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"gc\/shenandoah\/heuristics\/shenandoahHeapCharacteristics.hpp\"\n+#include \"gc\/shenandoah\/heuristics\/shenandoahHeapStats.hpp\"\n@@ -34,1 +34,1 @@\n-ShenandoahHeuristics* ShenandoahMode::initialize_heuristics(ShenandoahHeapCharacteristics* heap_info) const {\n+ShenandoahHeuristics* ShenandoahMode::initialize_heuristics(ShenandoahHeapStats* heap_info) const {\n@@ -40,1 +40,1 @@\n-    return new ShenandoahAggressiveHeuristics(heap_info);\n+    return new ShenandoahAggressiveHeuristics();\n@@ -42,1 +42,1 @@\n-    return new ShenandoahStaticHeuristics(heap_info);\n+    return new ShenandoahStaticHeuristics();\n@@ -46,1 +46,1 @@\n-    return new ShenandoahCompactHeuristics(heap_info);\n+    return new ShenandoahCompactHeuristics();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/mode\/shenandoahMode.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-class ShenandoahHeapCharacteristics;\n+class ShenandoahHeapStats;\n@@ -55,1 +55,1 @@\n-  virtual ShenandoahHeuristics* initialize_heuristics(ShenandoahHeapCharacteristics* heap_info) const;\n+  virtual ShenandoahHeuristics* initialize_heuristics(ShenandoahHeapStats* heap_info) const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/mode\/shenandoahMode.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"gc\/shenandoah\/heuristics\/shenandoahHeapCharacteristics.hpp\"\n+#include \"gc\/shenandoah\/heuristics\/shenandoahHeapStats.hpp\"\n@@ -59,1 +59,1 @@\n-ShenandoahHeuristics* ShenandoahPassiveMode::initialize_heuristics(ShenandoahHeapCharacteristics* heap_info) const {\n+ShenandoahHeuristics* ShenandoahPassiveMode::initialize_heuristics(ShenandoahHeapStats* heap_info) const {\n@@ -63,1 +63,1 @@\n-  return new ShenandoahPassiveHeuristics(heap_info);\n+  return new ShenandoahPassiveHeuristics();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/mode\/shenandoahPassiveMode.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-  virtual ShenandoahHeuristics* initialize_heuristics(ShenandoahHeapCharacteristics* heap_info) const;\n+  virtual ShenandoahHeuristics* initialize_heuristics(ShenandoahHeapStats* heap_info) const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/mode\/shenandoahPassiveMode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -886,3 +886,1 @@\n-  size_t in_use = used() + get_humongous_waste();\n-  size_t capacity = max_capacity();\n-  return in_use > capacity ? 0 : capacity - in_use;\n+  return available(max_capacity());\n@@ -892,0 +890,4 @@\n+  return available(soft_max_capacity());\n+}\n+\n+size_t ShenandoahGeneration::available(size_t capacity) const {\n@@ -893,2 +895,1 @@\n-  size_t soft_capacity = soft_max_capacity();\n-  size_t soft_available = in_use > soft_capacity ? 0 : soft_capacity - in_use;\n+  size_t available = in_use > capacity ? 0 : capacity - in_use;\n@@ -898,1 +899,1 @@\n-  if (usable < soft_available) {\n+  if (usable < available) {\n@@ -900,3 +901,3 @@\n-                  byte_size_in_proper_unit(usable),    proper_unit_for_byte_size(usable),\n-                  byte_size_in_proper_unit(soft_available), proper_unit_for_byte_size(soft_available));\n-    soft_available = usable;\n+                  byte_size_in_proper_unit(usable), proper_unit_for_byte_size(usable),\n+                  byte_size_in_proper_unit(available), proper_unit_for_byte_size(available));\n+    available = usable;\n@@ -904,1 +905,1 @@\n-  return soft_available;\n+  return available;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"gc\/shenandoah\/heuristics\/shenandoahHeapCharacteristics.hpp\"\n+#include \"gc\/shenandoah\/heuristics\/shenandoahHeapStats.hpp\"\n@@ -41,1 +41,1 @@\n-class ShenandoahGeneration : public CHeapObj<mtGC>, public ShenandoahHeapCharacteristics {\n+class ShenandoahGeneration : public CHeapObj<mtGC>, public ShenandoahHeapStats {\n@@ -89,3 +89,5 @@\n-  virtual size_t select_aged_regions(size_t old_available,\n-                                     size_t num_regions, bool\n-                                     candidate_regions_for_promotion_by_copy[]);\n+  size_t select_aged_regions(size_t old_available,\n+                             size_t num_regions, bool\n+                             candidate_regions_for_promotion_by_copy[]);\n+\n+  size_t available(size_t capacity) const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.hpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2662,0 +2662,5 @@\n+size_t ShenandoahHeap::bytes_allocated_since_gc_start() {\n+  assert(!mode()->is_generational(), \"This is used for heuristics that are not compatible with generational mode\");\n+  return global_generation()->bytes_allocated_since_gc_start();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -247,0 +247,1 @@\n+  size_t bytes_allocated_since_gc_start();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}