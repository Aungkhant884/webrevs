{"files":[{"patch":"@@ -55,1 +55,1 @@\n-template<UpdateRefsMode UPDATE_REFS>\n+template<GenerationMode GENERATION, UpdateRefsMode UPDATE_REFS>\n@@ -64,1 +64,1 @@\n-    ShenandoahConcurrentMark::mark_through_ref<T, UPDATE_REFS, NO_DEDUP>(p, _heap, _queue, _mark_context);\n+    ShenandoahConcurrentMark::mark_through_ref<T, GENERATION, UPDATE_REFS, NO_DEDUP>(p, _heap, _queue, _mark_context);\n@@ -87,1 +87,2 @@\n-  ShenandoahRootScanner* _rp;\n+  ShenandoahConcurrentMark* const _scm;\n+  ShenandoahRootScanner* const _rp;\n@@ -89,1 +90,1 @@\n-  ShenandoahInitMarkRootsTask(ShenandoahRootScanner* rp) :\n+  ShenandoahInitMarkRootsTask(ShenandoahConcurrentMark* scm, ShenandoahRootScanner* rp) :\n@@ -91,0 +92,1 @@\n+    _scm(scm),\n@@ -99,1 +101,1 @@\n-    ShenandoahObjToScanQueueSet* queues = heap->concurrent_mark()->task_queues();\n+    ShenandoahObjToScanQueueSet* queues = _scm->task_queues();\n@@ -104,2 +106,16 @@\n-    ShenandoahInitMarkRootsClosure<UPDATE_REFS> mark_cl(q);\n-    do_work(heap, &mark_cl, worker_id);\n+    switch (_scm->generation_mode()) {\n+      case YOUNG: {\n+        ShenandoahInitMarkRootsClosure<YOUNG, UPDATE_REFS> mark_cl(q);\n+        do_work(heap, &mark_cl, worker_id);\n+        break;\n+      }\n+      case GLOBAL: {\n+        ShenandoahInitMarkRootsClosure<GLOBAL, UPDATE_REFS> mark_cl(q);\n+        do_work(heap, &mark_cl, worker_id);\n+        break;\n+      }\n+      default: {\n+        ShouldNotReachHere();\n+        break;\n+      }\n+    }\n@@ -170,0 +186,1 @@\n+template <GenerationMode GENERATION>\n@@ -172,1 +189,1 @@\n-  ShenandoahSATBBufferClosure* _satb_cl;\n+  ShenandoahSATBBufferClosure<GENERATION>* _satb_cl;\n@@ -178,1 +195,1 @@\n-  ShenandoahSATBAndRemarkCodeRootsThreadsClosure(ShenandoahSATBBufferClosure* satb_cl, OopClosure* cl, MarkingCodeBlobClosure* code_cl) :\n+  ShenandoahSATBAndRemarkCodeRootsThreadsClosure(ShenandoahSATBBufferClosure<GENERATION>* satb_cl, OopClosure* cl, MarkingCodeBlobClosure* code_cl) :\n@@ -241,0 +258,1 @@\n+template <GenerationMode GENERATION>\n@@ -272,1 +290,1 @@\n-      ShenandoahSATBBufferClosure cl(q);\n+      ShenandoahSATBBufferClosure<GENERATION> cl(q);\n@@ -277,1 +295,1 @@\n-        ShenandoahMarkResolveRefsClosure resolve_mark_cl(q, rp);\n+        ShenandoahMarkResolveRefsClosure<GENERATION> resolve_mark_cl(q, rp);\n@@ -279,3 +297,3 @@\n-        ShenandoahSATBAndRemarkCodeRootsThreadsClosure tc(&cl,\n-                                                          ShenandoahStoreValEnqueueBarrier ? &resolve_mark_cl : NULL,\n-                                                          do_nmethods ? &blobsCl : NULL);\n+        ShenandoahSATBAndRemarkCodeRootsThreadsClosure<GENERATION> tc(&cl,\n+                                                                      ShenandoahStoreValEnqueueBarrier ? &resolve_mark_cl : NULL,\n+                                                                      do_nmethods ? &blobsCl : NULL);\n@@ -284,1 +302,1 @@\n-        ShenandoahMarkRefsClosure mark_cl(q, rp);\n+        ShenandoahMarkRefsClosure<GENERATION> mark_cl(q, rp);\n@@ -286,3 +304,3 @@\n-        ShenandoahSATBAndRemarkCodeRootsThreadsClosure tc(&cl,\n-                                                          ShenandoahStoreValEnqueueBarrier ? &mark_cl : NULL,\n-                                                          do_nmethods ? &blobsCl : NULL);\n+        ShenandoahSATBAndRemarkCodeRootsThreadsClosure<GENERATION> tc(&cl,\n+                                                                      ShenandoahStoreValEnqueueBarrier ? &mark_cl : NULL,\n+                                                                      do_nmethods ? &blobsCl : NULL);\n@@ -301,1 +319,1 @@\n-void ShenandoahConcurrentMark::mark_roots(ShenandoahPhaseTimings::Phase root_phase) {\n+void ShenandoahConcurrentMark::mark_roots(GenerationMode generation, ShenandoahPhaseTimings::Phase root_phase) {\n@@ -319,1 +337,1 @@\n-    ShenandoahInitMarkRootsTask<RESOLVE> mark_roots(&root_proc);\n+    ShenandoahInitMarkRootsTask<RESOLVE> mark_roots(this, &root_proc);\n@@ -324,1 +342,1 @@\n-    ShenandoahInitMarkRootsTask<NONE> mark_roots(&root_proc);\n+    ShenandoahInitMarkRootsTask<NONE> mark_roots(this, &root_proc);\n@@ -410,0 +428,1 @@\n+  ShenandoahConcurrentMark*          _scm;\n@@ -416,1 +435,2 @@\n-  ShenandoahMarkConcurrentRootsTask(ShenandoahObjToScanQueueSet* qs,\n+  ShenandoahMarkConcurrentRootsTask(ShenandoahConcurrentMark* scm,\n+                                    ShenandoahObjToScanQueueSet* qs,\n@@ -423,1 +443,2 @@\n-ShenandoahMarkConcurrentRootsTask::ShenandoahMarkConcurrentRootsTask(ShenandoahObjToScanQueueSet* qs,\n+ShenandoahMarkConcurrentRootsTask::ShenandoahMarkConcurrentRootsTask(ShenandoahConcurrentMark* scm,\n+                                                                     ShenandoahObjToScanQueueSet* qs,\n@@ -428,0 +449,1 @@\n+  _scm(scm),\n@@ -437,2 +459,16 @@\n-  ShenandoahMarkResolveRefsClosure cl(q, _rp);\n-  _rs.oops_do(&cl, worker_id);\n+  switch (_scm->generation_mode()) {\n+    case YOUNG: {\n+      ShenandoahMarkResolveRefsClosure<YOUNG> cl(q, _rp);\n+      _rs.oops_do(&cl, worker_id);\n+      break;\n+    }\n+    case GLOBAL: {\n+      ShenandoahMarkResolveRefsClosure<GLOBAL> cl(q, _rp);\n+      _rs.oops_do(&cl, worker_id);\n+      break;\n+    }\n+    default: {\n+      ShouldNotReachHere();\n+      break;\n+    }\n+  }\n@@ -464,1 +500,1 @@\n-    ShenandoahMarkConcurrentRootsTask task(task_queues(), rp, ShenandoahPhaseTimings::conc_mark_roots, nworkers);\n+    ShenandoahMarkConcurrentRootsTask task(this, task_queues(), rp, ShenandoahPhaseTimings::conc_mark_roots, nworkers);\n@@ -496,6 +532,25 @@\n-      if (_heap->has_forwarded_objects()) {\n-        ShenandoahProcessConcurrentRootsTask<ShenandoahMarkResolveRefsClosure> task(this, phase, nworkers);\n-        _heap->workers()->run_task(&task);\n-      } else {\n-        ShenandoahProcessConcurrentRootsTask<ShenandoahMarkRefsClosure> task(this, phase, nworkers);\n-        _heap->workers()->run_task(&task);\n+      switch (generation_mode()) {\n+         case YOUNG: {\n+           if (_heap->has_forwarded_objects()) {\n+             ShenandoahProcessConcurrentRootsTask<ShenandoahMarkResolveRefsClosure<YOUNG>> task(this, phase, nworkers);\n+             _heap->workers()->run_task(&task);\n+           } else {\n+             ShenandoahProcessConcurrentRootsTask<ShenandoahMarkRefsClosure<YOUNG>> task(this, phase, nworkers);\n+             _heap->workers()->run_task(&task);\n+           }\n+           break;\n+         }\n+         case GLOBAL: {\n+           if (_heap->has_forwarded_objects()) {\n+             ShenandoahProcessConcurrentRootsTask<ShenandoahMarkResolveRefsClosure<GLOBAL>> task(this, phase, nworkers);\n+             _heap->workers()->run_task(&task);\n+           } else {\n+             ShenandoahProcessConcurrentRootsTask<ShenandoahMarkRefsClosure<GLOBAL>> task(this, phase, nworkers);\n+             _heap->workers()->run_task(&task);\n+           }\n+           break;\n+         }\n+         default: {\n+           ShouldNotReachHere();\n+           break;\n+         }\n@@ -520,2 +575,16 @@\n-      ShenandoahFinalMarkingTask task(this, &terminator, ShenandoahStringDedup::is_enabled());\n-      _heap->workers()->run_task(&task);\n+      switch (generation_mode()) {\n+        case YOUNG: {\n+          ShenandoahFinalMarkingTask<YOUNG> task(this, &terminator, ShenandoahStringDedup::is_enabled());\n+          _heap->workers()->run_task(&task);\n+          break;\n+        }\n+        case GLOBAL: {\n+          ShenandoahFinalMarkingTask<GLOBAL> task(this, &terminator, ShenandoahStringDedup::is_enabled());\n+          _heap->workers()->run_task(&task);\n+          break;\n+        }\n+        default: {\n+          ShouldNotReachHere();\n+          break;\n+        }\n+      }\n@@ -539,0 +608,1 @@\n+  ShenandoahConcurrentMark* _scm;\n@@ -544,1 +614,2 @@\n-  ShenandoahCMDrainMarkingStackClosure(uint worker_id, TaskTerminator* t, bool reset_terminator = false):\n+  ShenandoahCMDrainMarkingStackClosure(ShenandoahConcurrentMark* scm, uint worker_id, TaskTerminator* t, bool reset_terminator = false) :\n+    _scm(scm),\n@@ -554,1 +625,0 @@\n-    ShenandoahConcurrentMark* scm = sh->concurrent_mark();\n@@ -560,3 +630,3 @@\n-    scm->mark_loop(_worker_id, _terminator, rp,\n-                   false,   \/\/ not cancellable\n-                   false);  \/\/ do not do strdedup\n+    _scm->mark_loop(_worker_id, _terminator, rp,\n+                    false,   \/\/ not cancellable\n+                    false);  \/\/ do not do strdedup\n@@ -570,0 +640,1 @@\n+template <GenerationMode GENERATION>\n@@ -578,1 +649,1 @@\n-    ShenandoahConcurrentMark::mark_through_ref<T, NONE, NO_DEDUP>(p, _heap, _queue, _mark_context);\n+    ShenandoahConcurrentMark::mark_through_ref<T, GENERATION, NONE, NO_DEDUP>(p, _heap, _queue, _mark_context);\n@@ -591,0 +662,1 @@\n+template <GenerationMode GENERATION>\n@@ -599,1 +671,1 @@\n-    ShenandoahConcurrentMark::mark_through_ref<T, SIMPLE, NO_DEDUP>(p, _heap, _queue, _mark_context);\n+    ShenandoahConcurrentMark::mark_through_ref<T, GENERATION, SIMPLE, NO_DEDUP>(p, _heap, _queue, _mark_context);\n@@ -631,0 +703,1 @@\n+  ShenandoahConcurrentMark* _scm;\n@@ -635,1 +708,2 @@\n-  ShenandoahRefProcTaskProxy(AbstractRefProcTaskExecutor::ProcessTask& proc_task,\n+  ShenandoahRefProcTaskProxy(ShenandoahConcurrentMark* scm,\n+                             AbstractRefProcTaskExecutor::ProcessTask& proc_task,\n@@ -638,0 +712,1 @@\n+    _scm(scm),\n@@ -649,1 +724,1 @@\n-    ShenandoahCMDrainMarkingStackClosure complete_gc(worker_id, _terminator);\n+    ShenandoahCMDrainMarkingStackClosure complete_gc(_scm, worker_id, _terminator);\n@@ -652,1 +727,1 @@\n-      ShenandoahCMKeepAliveUpdateClosure keep_alive(heap->concurrent_mark()->get_queue(worker_id));\n+      ShenandoahCMKeepAliveUpdateClosure<GLOBAL> keep_alive(_scm->get_queue(worker_id));\n@@ -656,1 +731,1 @@\n-      ShenandoahCMKeepAliveClosure keep_alive(heap->concurrent_mark()->get_queue(worker_id));\n+      ShenandoahCMKeepAliveClosure<GLOBAL> keep_alive(_scm->get_queue(worker_id));\n@@ -664,0 +739,1 @@\n+  ShenandoahConcurrentMark* _scm;\n@@ -667,1 +743,2 @@\n-  ShenandoahRefProcTaskExecutor(WorkGang* workers) :\n+  ShenandoahRefProcTaskExecutor(ShenandoahConcurrentMark* scm, WorkGang* workers) :\n+    _scm(scm),\n@@ -675,3 +752,2 @@\n-    ShenandoahHeap* heap = ShenandoahHeap::heap();\n-    ShenandoahConcurrentMark* cm = heap->concurrent_mark();\n-    ShenandoahPushWorkerQueuesScope scope(_workers, cm->task_queues(),\n+    ShenandoahPushWorkerQueuesScope scope(_workers,\n+                                          _scm->task_queues(),\n@@ -681,3 +757,3 @@\n-    cm->task_queues()->reserve(nworkers);\n-    TaskTerminator terminator(nworkers, cm->task_queues());\n-    ShenandoahRefProcTaskProxy proc_task_proxy(task, &terminator);\n+    _scm->task_queues()->reserve(nworkers);\n+    TaskTerminator terminator(nworkers, _scm->task_queues());\n+    ShenandoahRefProcTaskProxy proc_task_proxy(_scm, task, &terminator);\n@@ -707,1 +783,0 @@\n-\n@@ -736,3 +811,2 @@\n-  ShenandoahCMDrainMarkingStackClosure complete_gc(serial_worker_id, &terminator, \/* reset_terminator = *\/ true);\n-\n-  ShenandoahRefProcTaskExecutor executor(workers);\n+  ShenandoahCMDrainMarkingStackClosure complete_gc(this, serial_worker_id, &terminator, \/* reset_terminator = *\/ true);\n+  ShenandoahRefProcTaskExecutor executor(this, workers);\n@@ -750,1 +824,1 @@\n-      ShenandoahCMKeepAliveUpdateClosure keep_alive(get_queue(serial_worker_id));\n+      ShenandoahCMKeepAliveUpdateClosure<GLOBAL> keep_alive(get_queue(serial_worker_id));\n@@ -757,1 +831,1 @@\n-      ShenandoahCMKeepAliveClosure keep_alive(get_queue(serial_worker_id));\n+      ShenandoahCMKeepAliveClosure<GLOBAL> keep_alive(get_queue(serial_worker_id));\n@@ -780,0 +854,2 @@\n+private:\n+  ShenandoahConcurrentMark* _scm;\n@@ -781,0 +857,2 @@\n+  ShenandoahPrecleanCompleteGCClosure(ShenandoahConcurrentMark* scm) : _scm(scm) { }\n+\n@@ -783,1 +861,0 @@\n-    ShenandoahConcurrentMark* scm = sh->concurrent_mark();\n@@ -785,1 +862,1 @@\n-    TaskTerminator terminator(1, scm->task_queues());\n+    TaskTerminator terminator(1, _scm->task_queues());\n@@ -790,3 +867,3 @@\n-    scm->mark_loop(0, &terminator, rp,\n-                   false, \/\/ not cancellable\n-                   false); \/\/ do not do strdedup\n+    _scm->mark_loop(0, &terminator, rp,\n+                    false, \/\/ not cancellable\n+                    false); \/\/ do not do strdedup\n@@ -798,0 +875,1 @@\n+  ShenandoahConcurrentMark* _scm;\n@@ -801,1 +879,1 @@\n-  ShenandoahPrecleanTask(ReferenceProcessor* rp) :\n+  ShenandoahPrecleanTask(ShenandoahConcurrentMark* scm, ReferenceProcessor* rp) :\n@@ -803,0 +881,1 @@\n+          _scm(scm),\n@@ -809,2 +888,1 @@\n-    ShenandoahHeap* sh = ShenandoahHeap::heap();\n-    assert(!sh->has_forwarded_objects(), \"No forwarded objects expected here\");\n+    assert(!ShenandoahHeap::heap()->has_forwarded_objects(), \"No forwarded objects expected here\");\n@@ -812,1 +890,1 @@\n-    ShenandoahObjToScanQueue* q = sh->concurrent_mark()->get_queue(worker_id);\n+    ShenandoahObjToScanQueue* q = _scm->get_queue(worker_id);\n@@ -815,1 +893,1 @@\n-    ShenandoahPrecleanCompleteGCClosure complete_gc;\n+    ShenandoahPrecleanCompleteGCClosure complete_gc(_scm);\n@@ -818,1 +896,0 @@\n-    ShenandoahCMKeepAliveClosure keep_alive(q);\n@@ -820,3 +897,21 @@\n-    _rp->preclean_discovered_references(&is_alive, &keep_alive,\n-                                        &complete_gc, &yield,\n-                                        NULL);\n+    switch (_scm->generation_mode()) {\n+      case YOUNG: {\n+        ShenandoahCMKeepAliveClosure<YOUNG> keep_alive(q);\n+        _rp->preclean_discovered_references(&is_alive, &keep_alive,\n+                                            &complete_gc, &yield,\n+                                            NULL);\n+        break;\n+      }\n+      case GLOBAL: {\n+        ShenandoahCMKeepAliveClosure<GLOBAL> keep_alive(q);\n+        ResourceMark rm;\n+        _rp->preclean_discovered_references(&is_alive, &keep_alive,\n+                                            &complete_gc, &yield,\n+                                            NULL);\n+        break;\n+      }\n+      default: {\n+        ShouldNotReachHere();\n+        break;\n+      }\n+    }\n@@ -858,1 +953,1 @@\n-  ShenandoahPrecleanTask task(rp);\n+  ShenandoahPrecleanTask task(this, rp);\n@@ -878,1 +973,25 @@\n-template <bool CANCELLABLE>\n+void ShenandoahConcurrentMark::mark_loop(uint worker_id, TaskTerminator* terminator, ReferenceProcessor *rp, bool cancellable, bool strdedup) {\n+  switch (generation_mode()) {\n+    case YOUNG: {\n+      if (cancellable) {\n+        mark_loop_prework<YOUNG, true>(worker_id, terminator, rp, strdedup);\n+      } else {\n+        mark_loop_prework<YOUNG, false>(worker_id, terminator, rp, strdedup);\n+      }\n+      break;\n+    }\n+    case GLOBAL: {\n+      if (cancellable) {\n+        mark_loop_prework<GLOBAL, true>(worker_id, terminator, rp, strdedup);\n+      } else {\n+        mark_loop_prework<GLOBAL, false>(worker_id, terminator, rp, strdedup);\n+      }\n+      break;\n+    }\n+    default: {\n+      ShouldNotReachHere();\n+      break;\n+    }\n+  }\n+}\n+template <GenerationMode GENERATION, bool CANCELLABLE>\n@@ -890,2 +1009,2 @@\n-        ShenandoahMarkUpdateRefsMetadataDedupClosure cl(q, rp);\n-        mark_loop_work<ShenandoahMarkUpdateRefsMetadataDedupClosure, CANCELLABLE>(&cl, ld, w, t);\n+        ShenandoahMarkUpdateRefsMetadataDedupClosure<GENERATION> cl(q, rp);\n+        mark_loop_work<ShenandoahMarkUpdateRefsMetadataDedupClosure<GENERATION>, GENERATION, CANCELLABLE>(&cl, ld, w, t);\n@@ -893,2 +1012,2 @@\n-        ShenandoahMarkUpdateRefsMetadataClosure cl(q, rp);\n-        mark_loop_work<ShenandoahMarkUpdateRefsMetadataClosure, CANCELLABLE>(&cl, ld, w, t);\n+        ShenandoahMarkUpdateRefsMetadataClosure<GENERATION> cl(q, rp);\n+        mark_loop_work<ShenandoahMarkUpdateRefsMetadataClosure<GENERATION>, GENERATION, CANCELLABLE>(&cl, ld, w, t);\n@@ -898,2 +1017,2 @@\n-        ShenandoahMarkRefsMetadataDedupClosure cl(q, rp);\n-        mark_loop_work<ShenandoahMarkRefsMetadataDedupClosure, CANCELLABLE>(&cl, ld, w, t);\n+        ShenandoahMarkRefsMetadataDedupClosure<GENERATION> cl(q, rp);\n+        mark_loop_work<ShenandoahMarkRefsMetadataDedupClosure<GENERATION>, GENERATION, CANCELLABLE>(&cl, ld, w, t);\n@@ -901,2 +1020,2 @@\n-        ShenandoahMarkRefsMetadataClosure cl(q, rp);\n-        mark_loop_work<ShenandoahMarkRefsMetadataClosure, CANCELLABLE>(&cl, ld, w, t);\n+        ShenandoahMarkRefsMetadataClosure<GENERATION> cl(q, rp);\n+        mark_loop_work<ShenandoahMarkRefsMetadataClosure<GENERATION>, GENERATION, CANCELLABLE>(&cl, ld, w, t);\n@@ -908,2 +1027,2 @@\n-        ShenandoahMarkUpdateRefsDedupClosure cl(q, rp);\n-        mark_loop_work<ShenandoahMarkUpdateRefsDedupClosure, CANCELLABLE>(&cl, ld, w, t);\n+        ShenandoahMarkUpdateRefsDedupClosure<GENERATION> cl(q, rp);\n+        mark_loop_work<ShenandoahMarkUpdateRefsDedupClosure<GENERATION>, GENERATION, CANCELLABLE>(&cl, ld, w, t);\n@@ -911,2 +1030,2 @@\n-        ShenandoahMarkUpdateRefsClosure cl(q, rp);\n-        mark_loop_work<ShenandoahMarkUpdateRefsClosure, CANCELLABLE>(&cl, ld, w, t);\n+        ShenandoahMarkUpdateRefsClosure<GENERATION> cl(q, rp);\n+        mark_loop_work<ShenandoahMarkUpdateRefsClosure<GENERATION>, GENERATION, CANCELLABLE>(&cl, ld, w, t);\n@@ -916,2 +1035,2 @@\n-        ShenandoahMarkRefsDedupClosure cl(q, rp);\n-        mark_loop_work<ShenandoahMarkRefsDedupClosure, CANCELLABLE>(&cl, ld, w, t);\n+        ShenandoahMarkRefsDedupClosure<GENERATION> cl(q, rp);\n+        mark_loop_work<ShenandoahMarkRefsDedupClosure<GENERATION>, GENERATION, CANCELLABLE>(&cl, ld, w, t);\n@@ -919,2 +1038,2 @@\n-        ShenandoahMarkRefsClosure cl(q, rp);\n-        mark_loop_work<ShenandoahMarkRefsClosure, CANCELLABLE>(&cl, ld, w, t);\n+        ShenandoahMarkRefsClosure<GENERATION> cl(q, rp);\n+        mark_loop_work<ShenandoahMarkRefsClosure<GENERATION>, GENERATION, CANCELLABLE>(&cl, ld, w, t);\n@@ -928,1 +1047,1 @@\n-template <class T, bool CANCELLABLE>\n+template <class T, GenerationMode GENERATION, bool CANCELLABLE>\n@@ -965,1 +1084,1 @@\n-  ShenandoahSATBBufferClosure drain_satb(q);\n+  ShenandoahSATBBufferClosure<GENERATION> drain_satb(q);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentMark.cpp","additions":211,"deletions":92,"binary":false,"changes":303,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+  GenerationMode const _generation_mode;\n@@ -42,0 +43,2 @@\n+  ShenandoahConcurrentMark(GenerationMode generation_mode) : _generation_mode(generation_mode) { }\n+\n@@ -45,0 +48,2 @@\n+  GenerationMode generation_mode() const { return _generation_mode; }\n+\n@@ -59,1 +64,1 @@\n-  template <class T, bool CANCELLABLE>\n+  template <class T, GenerationMode GENERATION, bool CANCELLABLE>\n@@ -62,1 +67,1 @@\n-  template <bool CANCELLABLE>\n+  template <GenerationMode GENERATION, bool CANCELLABLE>\n@@ -66,10 +71,3 @@\n-  void mark_loop(uint worker_id, TaskTerminator* terminator, ReferenceProcessor *rp,\n-                 bool cancellable, bool strdedup) {\n-    if (cancellable) {\n-      mark_loop_prework<true>(worker_id, terminator, rp, strdedup);\n-    } else {\n-      mark_loop_prework<false>(worker_id, terminator, rp, strdedup);\n-    }\n-  }\n-\n-  template<class T, UpdateRefsMode UPDATE_REFS, StringDedupMode STRING_DEDUP>\n+  void mark_loop(uint worker_id, TaskTerminator* terminator, ReferenceProcessor *rp, bool cancellable, bool strdedup);\n+\n+  template<class T, GenerationMode GENERATION, UpdateRefsMode UPDATE_REFS, StringDedupMode STRING_DEDUP>\n@@ -81,1 +79,1 @@\n-  void mark_roots(ShenandoahPhaseTimings::Phase root_phase);\n+  void mark_roots(GenerationMode generation, ShenandoahPhaseTimings::Phase root_phase);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentMark.hpp","additions":11,"deletions":13,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -192,0 +192,1 @@\n+template <GenerationMode GENERATION>\n@@ -218,1 +219,1 @@\n-      ShenandoahConcurrentMark::mark_through_ref<oop, NONE, STRING_DEDUP>(p, _heap, _queue, _mark_context);\n+      ShenandoahConcurrentMark::mark_through_ref<oop, GENERATION, NONE, STRING_DEDUP>(p, _heap, _queue, _mark_context);\n@@ -223,1 +224,1 @@\n-template<class T, UpdateRefsMode UPDATE_REFS, StringDedupMode STRING_DEDUP>\n+template<class T, GenerationMode GENERATION, UpdateRefsMode UPDATE_REFS, StringDedupMode STRING_DEDUP>\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentMark.inline.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"gc\/shenandoah\/shenandoahGeneration.hpp\"\n@@ -39,0 +40,1 @@\n+#include \"gc\/shenandoah\/mode\/shenandoahMode.hpp\"\n@@ -209,1 +211,7 @@\n-          service_concurrent_normal_cycle(cause);\n+          if (heap->mode()->is_generational()) {\n+            \/\/ TODO: Only young collections for now.\n+            \/\/ We'll add old collections later.\n+            service_concurrent_young_cycle(cause);\n+          } else {\n+            service_concurrent_global_cycle(cause);\n+          }\n@@ -352,1 +360,1 @@\n-void ShenandoahControlThread::service_concurrent_normal_cycle(GCCause::Cause cause) {\n+void ShenandoahControlThread::service_concurrent_global_cycle(GCCause::Cause cause) {\n@@ -389,0 +397,86 @@\n+  ShenandoahGeneration* generation = heap->global_generation();\n+\n+  if (check_cancellation_or_degen(ShenandoahHeap::_degenerated_outside_cycle)) return;\n+\n+  GCIdMark gc_id_mark;\n+  ShenandoahGCSession session(cause);\n+\n+  TraceCollectorStats tcs(heap->monitoring_support()->concurrent_collection_counters());\n+\n+  \/\/ Reset for upcoming marking\n+  heap->entry_reset();\n+\n+  \/\/ Start initial mark under STW\n+  heap->vmop_entry_init_mark(generation);\n+\n+  \/\/ Continue concurrent mark\n+  generation->entry_mark();\n+  if (check_cancellation_or_degen(ShenandoahHeap::_degenerated_mark)) return;\n+\n+  \/\/ If not cancelled, can try to concurrently pre-clean\n+  heap->entry_preclean();\n+\n+  \/\/ Complete marking under STW, and start evacuation\n+  heap->vmop_entry_final_mark(generation);\n+\n+  \/\/ Process weak roots that might still point to regions that would be broken by cleanup\n+  if (heap->is_concurrent_weak_root_in_progress()) {\n+    heap->entry_weak_roots();\n+  }\n+\n+  \/\/ Final mark might have reclaimed some immediate garbage, kick cleanup to reclaim\n+  \/\/ the space. This would be the last action if there is nothing to evacuate.\n+  heap->entry_cleanup_early();\n+\n+  {\n+    ShenandoahHeapLocker locker(heap->lock());\n+    heap->free_set()->log_status();\n+  }\n+\n+  \/\/ Perform concurrent class unloading\n+  if (heap->is_concurrent_weak_root_in_progress()) {\n+    heap->entry_class_unloading();\n+  }\n+\n+  \/\/ Processing strong roots\n+  \/\/ This may be skipped if there is nothing to update\/evacuate.\n+  \/\/ If so, strong_root_in_progress would be unset.\n+  if (heap->is_concurrent_strong_root_in_progress()) {\n+    heap->entry_strong_roots();\n+  }\n+\n+  \/\/ Continue the cycle with evacuation and optional update-refs.\n+  \/\/ This may be skipped if there is nothing to evacuate.\n+  \/\/ If so, evac_in_progress would be unset by collection set preparation code.\n+  if (heap->is_evacuation_in_progress()) {\n+    \/\/ Concurrently evacuate\n+    heap->entry_evac();\n+    if (check_cancellation_or_degen(ShenandoahHeap::_degenerated_evac)) return;\n+\n+    \/\/ Perform update-refs phase.\n+    heap->vmop_entry_init_updaterefs();\n+    heap->entry_updaterefs();\n+    if (check_cancellation_or_degen(ShenandoahHeap::_degenerated_updaterefs)) return;\n+\n+    heap->vmop_entry_final_updaterefs();\n+\n+    \/\/ Update references freed up collection set, kick the cleanup to reclaim the space.\n+    heap->entry_cleanup_complete();\n+  } else {\n+    \/\/ Concurrent weak\/strong root flags are unset concurrently. We depend on updateref GC safepoints\n+    \/\/ to ensure the changes are visible to all mutators before gc cycle is completed.\n+    \/\/ In case of no evacuation, updateref GC safepoints are skipped. Therefore, we will need\n+    \/\/ to perform thread handshake to ensure their consistences.\n+    heap->entry_rendezvous_roots();\n+  }\n+\n+  \/\/ Cycle is complete\n+  heap->heuristics()->record_success_concurrent();\n+  heap->shenandoah_policy()->record_success_concurrent();\n+}\n+\n+\/\/ Young cycle goes through all concurrent phases like the global cycle described above,\n+\/\/ but collects only the young generation.\n+void ShenandoahControlThread::service_concurrent_young_cycle(GCCause::Cause cause) {\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  ShenandoahGeneration* generation = heap->young_generation();\n@@ -401,1 +495,1 @@\n-  heap->vmop_entry_init_mark();\n+  heap->vmop_entry_init_mark(generation);\n@@ -404,1 +498,1 @@\n-  heap->entry_mark();\n+  generation->entry_mark();\n@@ -411,1 +505,1 @@\n-  heap->vmop_entry_final_mark();\n+  heap->vmop_entry_final_mark(generation);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":99,"deletions":5,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -103,1 +103,2 @@\n-  void service_concurrent_normal_cycle(GCCause::Cause cause);\n+  void service_concurrent_global_cycle(GCCause::Cause cause);\n+  void service_concurrent_young_cycle(GCCause::Cause cause);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -149,0 +149,2 @@\n+  try_recycle_trashed(r);\n+\n@@ -155,2 +157,0 @@\n-  try_recycle_trashed(r);\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,0 +26,7 @@\n+#include \"gc\/shenandoah\/shenandoahConcurrentRoots.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeap.hpp\"\n+#include \"gc\/shenandoah\/shenandoahConcurrentMark.hpp\"\n+#include \"gc\/shenandoah\/shenandoahMonitoringSupport.hpp\"\n+#include \"gc\/shenandoah\/shenandoahUtils.hpp\"\n+#include \"gc\/shenandoah\/shenandoahVerifier.hpp\"\n+#include \"gc\/shenandoah\/shenandoahWorkerPolicy.hpp\"\n@@ -27,0 +34,122 @@\n+\n+void ShenandoahGeneration::entry_init_mark() {\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+\n+  const char* msg = heap->init_mark_event_message();\n+  ShenandoahPausePhase gc_phase(msg, ShenandoahPhaseTimings::init_mark);\n+  EventMark em(\"%s\", msg);\n+\n+  ShenandoahWorkerScope scope(heap->workers(),\n+                              ShenandoahWorkerPolicy::calc_workers_for_init_marking(),\n+                              \"init marking\");\n+\n+  op_init_mark();\n+}\n+\n+void ShenandoahGeneration::entry_mark() {\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  TraceCollectorStats tcs(heap->monitoring_support()->concurrent_collection_counters());\n+\n+  const char* msg = heap->conc_mark_event_message();\n+  ShenandoahConcurrentPhase gc_phase(msg, ShenandoahPhaseTimings::conc_mark);\n+  EventMark em(\"%s\", msg);\n+\n+  ShenandoahWorkerScope scope(heap->workers(),\n+                              ShenandoahWorkerPolicy::calc_workers_for_conc_marking(),\n+                              \"concurrent marking\");\n+\n+  heap->try_inject_alloc_failure();\n+  op_mark();\n+}\n+\n+void ShenandoahGeneration::entry_final_mark() {\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+\n+  const char* msg = heap->final_mark_event_message();\n+  ShenandoahPausePhase gc_phase(msg, ShenandoahPhaseTimings::final_mark);\n+  EventMark em(\"%s\", msg);\n+\n+  ShenandoahWorkerScope scope(heap->workers(),\n+                              ShenandoahWorkerPolicy::calc_workers_for_final_marking(),\n+                              \"final marking\");\n+\n+  op_final_mark();\n+}\n+\n+class ShenandoahInitMarkUpdateRegionStateClosure : public ShenandoahHeapRegionClosure {\n+private:\n+  ShenandoahMarkingContext* const _ctx;\n+public:\n+  ShenandoahInitMarkUpdateRegionStateClosure() : _ctx(ShenandoahHeap::heap()->marking_context()) {}\n+\n+  void heap_region_do(ShenandoahHeapRegion* r) {\n+    assert(!r->has_live(), \"Region \" SIZE_FORMAT \" should have no live data\", r->index());\n+    if (r->is_active()) {\n+      \/\/ Check if region needs updating its TAMS. We have updated it already during concurrent\n+      \/\/ reset, so it is very likely we don't need to do another write here.\n+      if (_ctx->top_at_mark_start(r) != r->top()) {\n+        _ctx->capture_top_at_mark_start(r);\n+      }\n+    } else {\n+      assert(_ctx->top_at_mark_start(r) == r->top(),\n+             \"Region \" SIZE_FORMAT \" should already have correct TAMS\", r->index());\n+    }\n+  }\n+\n+  bool is_thread_safe() { return true; }\n+};\n+\n+void ShenandoahGeneration::op_init_mark() {\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+\n+  assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), \"Should be at safepoint\");\n+  assert(Thread::current()->is_VM_thread(), \"can only do this in VMThread\");\n+\n+  assert(heap->marking_context()->is_bitmap_clear(), \"need clear marking bitmap\");\n+  assert(!heap->marking_context()->is_complete(), \"should not be complete\");\n+  assert(!heap->has_forwarded_objects(), \"No forwarded objects on this path\");\n+\n+  if (ShenandoahVerify) {\n+    heap->verifier()->verify_before_concmark();\n+  }\n+\n+  if (VerifyBeforeGC) {\n+    Universe::verify();\n+  }\n+\n+  heap->set_concurrent_mark_in_progress(true);\n+\n+  \/\/ We need to reset all TLABs because they might be below the TAMS, and we need to mark\n+  \/\/ the objects in them. Do not let mutators allocate any new objects in their current TLABs.\n+  \/\/ It is also a good place to resize the TLAB sizes for future allocations.\n+  if (UseTLAB) {\n+    ShenandoahGCPhase phase(ShenandoahPhaseTimings::init_manage_tlabs);\n+    heap->tlabs_retire(ResizeTLAB);\n+  }\n+\n+  {\n+    ShenandoahGCPhase phase(ShenandoahPhaseTimings::init_update_region_states);\n+    ShenandoahInitMarkUpdateRegionStateClosure cl;\n+    heap->parallel_heap_region_iterate(&cl);\n+  }\n+\n+  \/\/ Make above changes visible to worker threads\n+  OrderAccess::fence();\n+\n+  concurrent_mark()->mark_roots(generation_mode(), ShenandoahPhaseTimings::scan_roots);\n+\n+  if (ShenandoahPacing) {\n+    heap->pacer()->setup_for_mark();\n+  }\n+\n+  \/\/ Arm nmethods for concurrent marking. When a nmethod is about to be executed,\n+  \/\/ we need to make sure that all its metadata are marked. alternative is to remark\n+  \/\/ thread roots at final mark pause, but it can be potential latency killer.\n+  if (ShenandoahConcurrentRoots::should_do_concurrent_class_unloading()) {\n+    ShenandoahCodeRoots::arm_nmethods();\n+  }\n+}\n+\n+void ShenandoahGeneration::op_mark() {\n+  concurrent_mark()->mark_from_roots();\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":129,"deletions":0,"binary":false,"changes":129,"status":"modified"},{"patch":"@@ -28,1 +28,10 @@\n-class ShenandoahGeneration {\n+#include \"memory\/allocation.hpp\"\n+#include \"gc\/shenandoah\/shenandoahLock.hpp\"\n+#include \"gc\/shenandoah\/shenandoahMarkingContext.hpp\"\n+#include \"gc\/shenandoah\/shenandoahConcurrentMark.hpp\"\n+#include \"gc\/shenandoah\/shenandoahOopClosures.hpp\"\n+\n+class ShenandoahGeneration : public CHeapObj<mtGC> {\n+private:\n+  GenerationMode const _generation_mode;\n+  ShenandoahConcurrentMark* const _scm;\n@@ -30,2 +39,4 @@\n-  ShenandoahGeneration();\n-};\n+  ShenandoahGeneration(GenerationMode generation_mode) :\n+    _generation_mode(generation_mode),\n+    _scm(new ShenandoahConcurrentMark(generation_mode)) {\n+  }\n@@ -33,2 +44,12 @@\n-class ShenandoahYoungGeneration : public ShenandoahGeneration {\n-};\n+  inline GenerationMode generation_mode() const { return _generation_mode; }\n+\n+  inline ShenandoahConcurrentMark* concurrent_mark() const { return _scm; }\n+\n+  \/\/ Entry methods to normally STW GC operations. These set up logging, monitoring\n+  \/\/ and workers for net VM operation\n+  void entry_init_mark();\n+  void entry_mark();\n+  void entry_final_mark();\n+\n+  void op_init_mark();\n+  virtual void op_final_mark() = 0;\n@@ -36,1 +57,2 @@\n-class ShenandoahOldGeneration : public ShenandoahGeneration {\n+private:\n+  void op_mark();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.hpp","additions":28,"deletions":6,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -0,0 +1,161 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat, Inc. and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/shenandoah\/shenandoahConcurrentMark.hpp\"\n+#include \"gc\/shenandoah\/shenandoahConcurrentRoots.hpp\"\n+#include \"gc\/shenandoah\/shenandoahFreeSet.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeap.hpp\"\n+#include \"gc\/shenandoah\/shenandoahMarkClosures.hpp\"\n+#include \"gc\/shenandoah\/shenandoahOopClosures.hpp\"\n+#include \"gc\/shenandoah\/shenandoahUtils.hpp\"\n+#include \"gc\/shenandoah\/shenandoahVerifier.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGlobalGeneration.hpp\"\n+#include \"gc\/shenandoah\/heuristics\/shenandoahHeuristics.hpp\"\n+\n+void ShenandoahGlobalGeneration::op_final_mark() {\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+\n+  assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), \"Should be at safepoint\");\n+  assert(!heap->has_forwarded_objects(), \"No forwarded objects on this path\");\n+\n+  \/\/ It is critical that we\n+  \/\/ evacuate roots right after finishing marking, so that we don't\n+  \/\/ get unmarked objects in the roots.\n+\n+  if (!heap->cancelled_gc()) {\n+    concurrent_mark()->finish_mark_from_roots(\/* full_gc = *\/ false);\n+\n+    \/\/ Marking is completed, deactivate SATB barrier\n+    heap->set_concurrent_mark_in_progress(false);\n+    heap->mark_complete_marking_context();\n+\n+    heap->parallel_cleaning(false \/* full gc*\/);\n+\n+    if (ShenandoahVerify) {\n+      heap->verifier()->verify_roots_no_forwarded();\n+    }\n+\n+    {\n+      ShenandoahGCPhase phase(ShenandoahPhaseTimings::final_update_region_states);\n+      ShenandoahFinalMarkUpdateRegionStateClosure cl;\n+      heap->parallel_heap_region_iterate(&cl);\n+\n+      heap->assert_pinned_region_status();\n+    }\n+\n+    \/\/ Retire the TLABs, which will force threads to reacquire their TLABs after the pause.\n+    \/\/ This is needed for two reasons. Strong one: new allocations would be with new freeset,\n+    \/\/ which would be outside the collection set, so no cset writes would happen there.\n+    \/\/ Weaker one: new allocations would happen past update watermark, and so less work would\n+    \/\/ be needed for reference updates (would update the large filler instead).\n+    if (UseTLAB) {\n+      ShenandoahGCPhase phase(ShenandoahPhaseTimings::final_manage_labs);\n+      heap->tlabs_retire(false);\n+    }\n+\n+    {\n+      ShenandoahGCPhase phase(ShenandoahPhaseTimings::choose_cset);\n+      ShenandoahHeapLocker locker(heap->lock());\n+      heap->collection_set()->clear();\n+      heap->heuristics()->choose_collection_set(heap->collection_set());\n+    }\n+\n+    {\n+      ShenandoahGCPhase phase(ShenandoahPhaseTimings::final_rebuild_freeset);\n+      ShenandoahHeapLocker locker(heap->lock());\n+      heap->free_set()->rebuild();\n+    }\n+\n+    if (!heap->is_degenerated_gc_in_progress()) {\n+      heap->prepare_concurrent_roots();\n+      heap->prepare_concurrent_unloading();\n+    }\n+\n+    \/\/ If collection set has candidates, start evacuation.\n+    \/\/ Otherwise, bypass the rest of the cycle.\n+    if (!heap->collection_set()->is_empty()) {\n+      ShenandoahGCPhase init_evac(ShenandoahPhaseTimings::init_evac);\n+\n+      if (ShenandoahVerify) {\n+        heap->verifier()->verify_before_evacuation();\n+      }\n+\n+      heap->set_evacuation_in_progress(true);\n+      \/\/ From here on, we need to update references.\n+      heap->set_has_forwarded_objects(true);\n+\n+      if (!heap->is_degenerated_gc_in_progress()) {\n+        if (ShenandoahConcurrentRoots::should_do_concurrent_class_unloading()) {\n+          ShenandoahCodeRoots::arm_nmethods();\n+        }\n+        heap->evacuate_and_update_roots();\n+      }\n+\n+      if (ShenandoahPacing) {\n+        heap->pacer()->setup_for_evac();\n+      }\n+\n+      if (ShenandoahVerify) {\n+        \/\/ If OOM while evacuating\/updating of roots, there is no guarantee of their consistencies\n+        if (!heap->cancelled_gc()) {\n+          ShenandoahRootVerifier::RootTypes types = ShenandoahRootVerifier::None;\n+          if (ShenandoahConcurrentRoots::should_do_concurrent_roots()) {\n+            types = ShenandoahRootVerifier::combine(ShenandoahRootVerifier::JNIHandleRoots, ShenandoahRootVerifier::WeakRoots);\n+            types = ShenandoahRootVerifier::combine(types, ShenandoahRootVerifier::CLDGRoots);\n+            types = ShenandoahRootVerifier::combine(types, ShenandoahRootVerifier::StringDedupRoots);\n+          }\n+\n+          if (ShenandoahConcurrentRoots::should_do_concurrent_class_unloading()) {\n+            types = ShenandoahRootVerifier::combine(types, ShenandoahRootVerifier::CodeRoots);\n+          }\n+          heap->verifier()->verify_roots_no_forwarded_except(types);\n+        }\n+        heap->verifier()->verify_during_evacuation();\n+      }\n+    } else {\n+      if (ShenandoahVerify) {\n+        heap->verifier()->verify_after_concmark();\n+      }\n+\n+      if (VerifyAfterGC) {\n+        Universe::verify();\n+      }\n+    }\n+\n+  } else {\n+    \/\/ If this cycle was updating references, we need to keep the has_forwarded_objects\n+    \/\/ flag on, for subsequent phases to deal with it.\n+    concurrent_mark()->cancel();\n+    heap->set_concurrent_mark_in_progress(false);\n+\n+    if (heap->process_references()) {\n+      \/\/ Abandon reference processing right away: pre-cleaning must have failed.\n+      ReferenceProcessor *rp = heap->ref_processor();\n+      rp->disable_discovery();\n+      rp->abandon_partial_discovery();\n+      rp->verify_no_references_recorded();\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGlobalGeneration.cpp","additions":161,"deletions":0,"binary":false,"changes":161,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2020, Amazon.com, Inc. and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_VM_GC_SHENANDOAH_SHENANDOAHGLOBALGENERATION_HPP\n+#define SHARE_VM_GC_SHENANDOAH_SHENANDOAHGLOBALGENERATION_HPP\n+\n+#include \"gc\/shenandoah\/shenandoahGeneration.hpp\"\n+\n+\/\/ A \"generation\" that represents the whole heap.\n+class ShenandoahGlobalGeneration : public ShenandoahGeneration {\n+public:\n+  ShenandoahGlobalGeneration() : ShenandoahGeneration(GLOBAL) { }\n+\n+  virtual void op_final_mark();\n+};\n+\n+#endif \/\/ SHARE_VM_GC_SHENANDOAH_SHENANDOAHGLOBALGENERATION_HPP\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGlobalGeneration.hpp","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -45,0 +45,1 @@\n+#include \"gc\/shenandoah\/shenandoahGlobalGeneration.hpp\"\n@@ -68,0 +69,1 @@\n+#include \"gc\/shenandoah\/shenandoahYoungGeneration.hpp\"\n@@ -488,0 +490,2 @@\n+  _young_generation(new ShenandoahYoungGeneration()),\n+  _global_generation(new ShenandoahGlobalGeneration()),\n@@ -492,1 +496,0 @@\n-  _scm(new ShenandoahConcurrentMark()),\n@@ -622,1 +625,2 @@\n-  _scm->initialize(_max_workers);\n+  young_generation()->concurrent_mark()->initialize(_max_workers);\n+  global_generation()->concurrent_mark()->initialize(_max_workers);\n@@ -1568,247 +1572,0 @@\n-class ShenandoahInitMarkUpdateRegionStateClosure : public ShenandoahHeapRegionClosure {\n-private:\n-  ShenandoahMarkingContext* const _ctx;\n-public:\n-  ShenandoahInitMarkUpdateRegionStateClosure() : _ctx(ShenandoahHeap::heap()->marking_context()) {}\n-\n-  void heap_region_do(ShenandoahHeapRegion* r) {\n-    assert(!r->has_live(), \"Region \" SIZE_FORMAT \" should have no live data\", r->index());\n-    if (r->is_active()) {\n-      \/\/ Check if region needs updating its TAMS. We have updated it already during concurrent\n-      \/\/ reset, so it is very likely we don't need to do another write here.\n-      if (_ctx->top_at_mark_start(r) != r->top()) {\n-        _ctx->capture_top_at_mark_start(r);\n-      }\n-    } else {\n-      assert(_ctx->top_at_mark_start(r) == r->top(),\n-             \"Region \" SIZE_FORMAT \" should already have correct TAMS\", r->index());\n-    }\n-  }\n-\n-  bool is_thread_safe() { return true; }\n-};\n-\n-void ShenandoahHeap::op_init_mark() {\n-  assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), \"Should be at safepoint\");\n-  assert(Thread::current()->is_VM_thread(), \"can only do this in VMThread\");\n-\n-  assert(marking_context()->is_bitmap_clear(), \"need clear marking bitmap\");\n-  assert(!marking_context()->is_complete(), \"should not be complete\");\n-  assert(!has_forwarded_objects(), \"No forwarded objects on this path\");\n-\n-  if (ShenandoahVerify) {\n-    verifier()->verify_before_concmark();\n-  }\n-\n-  if (VerifyBeforeGC) {\n-    Universe::verify();\n-  }\n-\n-  set_concurrent_mark_in_progress(true);\n-\n-  \/\/ We need to reset all TLABs because they might be below the TAMS, and we need to mark\n-  \/\/ the objects in them. Do not let mutators allocate any new objects in their current TLABs.\n-  \/\/ It is also a good place to resize the TLAB sizes for future allocations.\n-  if (UseTLAB) {\n-    ShenandoahGCPhase phase(ShenandoahPhaseTimings::init_manage_tlabs);\n-    tlabs_retire(ResizeTLAB);\n-  }\n-\n-  {\n-    ShenandoahGCPhase phase(ShenandoahPhaseTimings::init_update_region_states);\n-    ShenandoahInitMarkUpdateRegionStateClosure cl;\n-    parallel_heap_region_iterate(&cl);\n-  }\n-\n-  \/\/ Make above changes visible to worker threads\n-  OrderAccess::fence();\n-\n-  concurrent_mark()->mark_roots(ShenandoahPhaseTimings::scan_roots);\n-\n-  if (ShenandoahPacing) {\n-    pacer()->setup_for_mark();\n-  }\n-\n-  \/\/ Arm nmethods for concurrent marking. When a nmethod is about to be executed,\n-  \/\/ we need to make sure that all its metadata are marked. alternative is to remark\n-  \/\/ thread roots at final mark pause, but it can be potential latency killer.\n-  if (ShenandoahConcurrentRoots::should_do_concurrent_class_unloading()) {\n-    ShenandoahCodeRoots::arm_nmethods();\n-  }\n-}\n-\n-void ShenandoahHeap::op_mark() {\n-  concurrent_mark()->mark_from_roots();\n-}\n-\n-class ShenandoahFinalMarkUpdateRegionStateClosure : public ShenandoahHeapRegionClosure {\n-private:\n-  ShenandoahMarkingContext* const _ctx;\n-  ShenandoahHeapLock* const _lock;\n-\n-public:\n-  ShenandoahFinalMarkUpdateRegionStateClosure() :\n-    _ctx(ShenandoahHeap::heap()->complete_marking_context()), _lock(ShenandoahHeap::heap()->lock()) {}\n-\n-  void heap_region_do(ShenandoahHeapRegion* r) {\n-    if (r->is_active()) {\n-      \/\/ All allocations past TAMS are implicitly live, adjust the region data.\n-      \/\/ Bitmaps\/TAMS are swapped at this point, so we need to poll complete bitmap.\n-      HeapWord *tams = _ctx->top_at_mark_start(r);\n-      HeapWord *top = r->top();\n-      if (top > tams) {\n-        r->increase_live_data_alloc_words(pointer_delta(top, tams));\n-      }\n-\n-      \/\/ We are about to select the collection set, make sure it knows about\n-      \/\/ current pinning status. Also, this allows trashing more regions that\n-      \/\/ now have their pinning status dropped.\n-      if (r->is_pinned()) {\n-        if (r->pin_count() == 0) {\n-          ShenandoahHeapLocker locker(_lock);\n-          r->make_unpinned();\n-        }\n-      } else {\n-        if (r->pin_count() > 0) {\n-          ShenandoahHeapLocker locker(_lock);\n-          r->make_pinned();\n-        }\n-      }\n-\n-      \/\/ Remember limit for updating refs. It's guaranteed that we get no\n-      \/\/ from-space-refs written from here on.\n-      r->set_update_watermark_at_safepoint(r->top());\n-    } else {\n-      assert(!r->has_live(), \"Region \" SIZE_FORMAT \" should have no live data\", r->index());\n-      assert(_ctx->top_at_mark_start(r) == r->top(),\n-             \"Region \" SIZE_FORMAT \" should have correct TAMS\", r->index());\n-    }\n-  }\n-\n-  bool is_thread_safe() { return true; }\n-};\n-\n-void ShenandoahHeap::op_final_mark() {\n-  assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), \"Should be at safepoint\");\n-  assert(!has_forwarded_objects(), \"No forwarded objects on this path\");\n-\n-  \/\/ It is critical that we\n-  \/\/ evacuate roots right after finishing marking, so that we don't\n-  \/\/ get unmarked objects in the roots.\n-\n-  if (!cancelled_gc()) {\n-    concurrent_mark()->finish_mark_from_roots(\/* full_gc = *\/ false);\n-\n-    \/\/ Marking is completed, deactivate SATB barrier\n-    set_concurrent_mark_in_progress(false);\n-    mark_complete_marking_context();\n-\n-    parallel_cleaning(false \/* full gc*\/);\n-\n-    if (ShenandoahVerify) {\n-      verifier()->verify_roots_no_forwarded();\n-    }\n-\n-    {\n-      ShenandoahGCPhase phase(ShenandoahPhaseTimings::final_update_region_states);\n-      ShenandoahFinalMarkUpdateRegionStateClosure cl;\n-      parallel_heap_region_iterate(&cl);\n-\n-      assert_pinned_region_status();\n-    }\n-\n-    \/\/ Retire the TLABs, which will force threads to reacquire their TLABs after the pause.\n-    \/\/ This is needed for two reasons. Strong one: new allocations would be with new freeset,\n-    \/\/ which would be outside the collection set, so no cset writes would happen there.\n-    \/\/ Weaker one: new allocations would happen past update watermark, and so less work would\n-    \/\/ be needed for reference updates (would update the large filler instead).\n-    if (UseTLAB) {\n-      ShenandoahGCPhase phase(ShenandoahPhaseTimings::final_manage_labs);\n-      tlabs_retire(false);\n-    }\n-\n-    {\n-      ShenandoahGCPhase phase(ShenandoahPhaseTimings::choose_cset);\n-      ShenandoahHeapLocker locker(lock());\n-      _collection_set->clear();\n-      heuristics()->choose_collection_set(_collection_set);\n-    }\n-\n-    {\n-      ShenandoahGCPhase phase(ShenandoahPhaseTimings::final_rebuild_freeset);\n-      ShenandoahHeapLocker locker(lock());\n-      _free_set->rebuild();\n-    }\n-\n-    if (!is_degenerated_gc_in_progress()) {\n-      prepare_concurrent_roots();\n-      prepare_concurrent_unloading();\n-    }\n-\n-    \/\/ If collection set has candidates, start evacuation.\n-    \/\/ Otherwise, bypass the rest of the cycle.\n-    if (!collection_set()->is_empty()) {\n-      ShenandoahGCPhase init_evac(ShenandoahPhaseTimings::init_evac);\n-\n-      if (ShenandoahVerify) {\n-        verifier()->verify_before_evacuation();\n-      }\n-\n-      set_evacuation_in_progress(true);\n-      \/\/ From here on, we need to update references.\n-      set_has_forwarded_objects(true);\n-\n-      if (!is_degenerated_gc_in_progress()) {\n-        if (ShenandoahConcurrentRoots::should_do_concurrent_class_unloading()) {\n-          ShenandoahCodeRoots::arm_nmethods();\n-        }\n-        evacuate_and_update_roots();\n-      }\n-\n-      if (ShenandoahPacing) {\n-        pacer()->setup_for_evac();\n-      }\n-\n-      if (ShenandoahVerify) {\n-        \/\/ If OOM while evacuating\/updating of roots, there is no guarantee of their consistencies\n-        if (!cancelled_gc()) {\n-          ShenandoahRootVerifier::RootTypes types = ShenandoahRootVerifier::None;\n-          if (ShenandoahConcurrentRoots::should_do_concurrent_roots()) {\n-            types = ShenandoahRootVerifier::combine(ShenandoahRootVerifier::JNIHandleRoots, ShenandoahRootVerifier::WeakRoots);\n-            types = ShenandoahRootVerifier::combine(types, ShenandoahRootVerifier::CLDGRoots);\n-            types = ShenandoahRootVerifier::combine(types, ShenandoahRootVerifier::StringDedupRoots);\n-          }\n-\n-          if (ShenandoahConcurrentRoots::should_do_concurrent_class_unloading()) {\n-            types = ShenandoahRootVerifier::combine(types, ShenandoahRootVerifier::CodeRoots);\n-          }\n-          verifier()->verify_roots_no_forwarded_except(types);\n-        }\n-        verifier()->verify_during_evacuation();\n-      }\n-    } else {\n-      if (ShenandoahVerify) {\n-        verifier()->verify_after_concmark();\n-      }\n-\n-      if (VerifyAfterGC) {\n-        Universe::verify();\n-      }\n-    }\n-\n-  } else {\n-    \/\/ If this cycle was updating references, we need to keep the has_forwarded_objects\n-    \/\/ flag on, for subsequent phases to deal with it.\n-    concurrent_mark()->cancel();\n-    set_concurrent_mark_in_progress(false);\n-\n-    if (process_references()) {\n-      \/\/ Abandon reference processing right away: pre-cleaning must have failed.\n-      ReferenceProcessor *rp = ref_processor();\n-      rp->disable_discovery();\n-      rp->abandon_partial_discovery();\n-      rp->verify_no_references_recorded();\n-    }\n-  }\n-}\n-\n@@ -2095,1 +1852,1 @@\n-  concurrent_mark()->preclean_weak_refs();\n+  global_generation()->concurrent_mark()->preclean_weak_refs();\n@@ -2144,1 +1901,1 @@\n-      op_init_mark();\n+      global_generation()->op_init_mark();\n@@ -2151,1 +1908,1 @@\n-      op_final_mark();\n+      global_generation()->op_final_mark();\n@@ -2773,1 +2530,1 @@\n-    concurrent_mark()->update_roots(ShenandoahPhaseTimings::degen_gc_update_roots);\n+    global_generation()->concurrent_mark()->update_roots(ShenandoahPhaseTimings::degen_gc_update_roots);\n@@ -2899,1 +2656,1 @@\n-void ShenandoahHeap::vmop_entry_init_mark() {\n+void ShenandoahHeap::vmop_entry_init_mark(ShenandoahGeneration* generation) {\n@@ -2904,1 +2661,1 @@\n-  VM_ShenandoahInitMark op;\n+  VM_ShenandoahInitMark op(generation);\n@@ -2908,1 +2665,1 @@\n-void ShenandoahHeap::vmop_entry_final_mark() {\n+void ShenandoahHeap::vmop_entry_final_mark(ShenandoahGeneration* generation) {\n@@ -2913,1 +2670,1 @@\n-  VM_ShenandoahFinalMarkStartEvac op;\n+  VM_ShenandoahFinalMarkStartEvac op(generation);\n@@ -2952,24 +2709,0 @@\n-void ShenandoahHeap::entry_init_mark() {\n-  const char* msg = init_mark_event_message();\n-  ShenandoahPausePhase gc_phase(msg, ShenandoahPhaseTimings::init_mark);\n-  EventMark em(\"%s\", msg);\n-\n-  ShenandoahWorkerScope scope(workers(),\n-                              ShenandoahWorkerPolicy::calc_workers_for_init_marking(),\n-                              \"init marking\");\n-\n-  op_init_mark();\n-}\n-\n-void ShenandoahHeap::entry_final_mark() {\n-  const char* msg = final_mark_event_message();\n-  ShenandoahPausePhase gc_phase(msg, ShenandoahPhaseTimings::final_mark);\n-  EventMark em(\"%s\", msg);\n-\n-  ShenandoahWorkerScope scope(workers(),\n-                              ShenandoahWorkerPolicy::calc_workers_for_final_marking(),\n-                              \"final marking\");\n-\n-  op_final_mark();\n-}\n-\n@@ -3025,15 +2758,0 @@\n-void ShenandoahHeap::entry_mark() {\n-  TraceCollectorStats tcs(monitoring_support()->concurrent_collection_counters());\n-\n-  const char* msg = conc_mark_event_message();\n-  ShenandoahConcurrentPhase gc_phase(msg, ShenandoahPhaseTimings::conc_mark);\n-  EventMark em(\"%s\", msg);\n-\n-  ShenandoahWorkerScope scope(workers(),\n-                              ShenandoahWorkerPolicy::calc_workers_for_conc_marking(),\n-                              \"concurrent marking\");\n-\n-  try_inject_alloc_failure();\n-  op_mark();\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":14,"deletions":296,"binary":false,"changes":310,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+class ShenandoahGeneration;\n@@ -61,1 +62,0 @@\n-class ShenandoahMarkCompact;\n@@ -373,2 +373,2 @@\n-  void vmop_entry_init_mark();\n-  void vmop_entry_final_mark();\n+  void vmop_entry_init_mark(ShenandoahGeneration* generation);\n+  void vmop_entry_final_mark(ShenandoahGeneration* generation);\n@@ -382,2 +382,0 @@\n-  void entry_init_mark();\n-  void entry_final_mark();\n@@ -392,1 +390,0 @@\n-  void entry_mark();\n@@ -405,0 +402,7 @@\n+  \/\/ Messages for GC trace events, they have to be immortal for\n+  \/\/ passing around the logging\/tracing systems\n+  const char* init_mark_event_message() const;\n+  const char* conc_mark_event_message() const;\n+  const char* final_mark_event_message() const;\n+  const char* degen_event_message(ShenandoahDegenPoint point) const;\n+\n@@ -407,2 +411,0 @@\n-  void op_init_mark();\n-  void op_final_mark();\n@@ -417,1 +419,0 @@\n-  void op_mark();\n@@ -433,7 +434,0 @@\n-  \/\/ Messages for GC trace events, they have to be immortal for\n-  \/\/ passing around the logging\/tracing systems\n-  const char* init_mark_event_message() const;\n-  const char* final_mark_event_message() const;\n-  const char* conc_mark_event_message() const;\n-  const char* degen_event_message(ShenandoahDegenPoint point) const;\n-\n@@ -443,0 +437,2 @@\n+  ShenandoahGeneration*      _young_generation;\n+  ShenandoahGeneration*      _global_generation;\n@@ -448,1 +444,0 @@\n-  ShenandoahConcurrentMark*  _scm;\n@@ -459,0 +454,2 @@\n+  ShenandoahGeneration*      young_generation()  const { return _young_generation;  }\n+  ShenandoahGeneration*      global_generation() const { return _global_generation; }\n@@ -463,1 +460,0 @@\n-  ShenandoahConcurrentMark*  concurrent_mark()         { return _scm;               }\n@@ -525,4 +521,0 @@\n-private:\n-  void stw_unload_classes(bool full_gc);\n-  void stw_process_weak_roots(bool full_gc);\n-\n@@ -531,0 +523,1 @@\n+\n@@ -533,0 +526,5 @@\n+\n+private:\n+  void stw_unload_classes(bool full_gc);\n+  void stw_process_weak_roots(bool full_gc);\n+\n@@ -681,0 +679,3 @@\n+\n+  void evacuate_and_update_roots();\n+\n@@ -685,2 +686,0 @@\n-  void evacuate_and_update_roots();\n-\n@@ -735,0 +734,4 @@\n+\n+public:\n+  void try_inject_alloc_failure();\n+\n@@ -738,1 +741,0 @@\n-  void try_inject_alloc_failure();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":27,"deletions":25,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2014, 2020, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contac    _ctx(ShenandoahHeap::heap()->complete_marking_context()), _lock(ShenandoahHeap::heap()->lock()) {}\n+ Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/shenandoah\/shenandoahMarkClosures.hpp\"\n+\n+void ShenandoahFinalMarkUpdateRegionStateClosure::heap_region_do(ShenandoahHeapRegion* r) {\n+  if (r->is_active()) {\n+    \/\/ All allocations past TAMS are implicitly live, adjust the region data.\n+    \/\/ Bitmaps\/TAMS are swapped at this point, so we need to poll complete bitmap.\n+    HeapWord *tams = _ctx->top_at_mark_start(r);\n+    HeapWord *top = r->top();\n+    if (top > tams) {\n+      r->increase_live_data_alloc_words(pointer_delta(top, tams));\n+    }\n+\n+    \/\/ We are about to select the collection set, make sure it knows about\n+    \/\/ current pinning status. Also, this allows trashing more regions that\n+    \/\/ now have their pinning status dropped.\n+    if (r->is_pinned()) {\n+      if (r->pin_count() == 0) {\n+        ShenandoahHeapLocker locker(_lock);\n+        r->make_unpinned();\n+      }\n+    } else {\n+      if (r->pin_count() > 0) {\n+        ShenandoahHeapLocker locker(_lock);\n+        r->make_pinned();\n+      }\n+    }\n+\n+    \/\/ Remember limit for updating refs. It's guaranteed that we get no\n+    \/\/ from-space-refs written from here on.\n+    r->set_update_watermark_at_safepoint(r->top());\n+  } else {\n+    assert(!r->has_live(), \"Region \" SIZE_FORMAT \" should have no live data\", r->index());\n+    assert(_ctx->top_at_mark_start(r) == r->top(),\n+           \"Region \" SIZE_FORMAT \" should have correct TAMS\", r->index());\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkClosures.cpp","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2014, 2020, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contac    _ctx(ShenandoahHeap::heap()->complete_marking_context()), _lock(ShenandoahHeap::heap()->lock()) {}\n+ Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHENANDOAH_SHENANDOAHMARKCLOSURES_HPP\n+#define SHARE_GC_SHENANDOAH_SHENANDOAHMARKCLOSURES_HPP\n+\n+#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeap.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeapRegion.hpp\"\n+#include \"gc\/shenandoah\/shenandoahSharedVariables.hpp\"\n+#include \"gc\/shenandoah\/shenandoahMarkingContext.hpp\"\n+#include \"gc\/shenandoah\/shenandoahMarkClosures.hpp\"\n+\n+class ShenandoahFinalMarkUpdateRegionStateClosure : public ShenandoahHeapRegionClosure {\n+private:\n+  ShenandoahMarkingContext* const _ctx;\n+  ShenandoahHeapLock* const _lock;\n+public:\n+  ShenandoahFinalMarkUpdateRegionStateClosure() :\n+    _ctx(ShenandoahHeap::heap()->complete_marking_context()), _lock(ShenandoahHeap::heap()->lock()) {}\n+\n+  void heap_region_do(ShenandoahHeapRegion* r);\n+\n+  bool is_thread_safe() { return true; }\n+};\n+\n+#endif \/\/ SHARE_GC_SHENANDOAH_SHENANDOAHMARKCLOSURES_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkClosures.hpp","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"gc\/shenandoah\/shenandoahGeneration.hpp\"\n@@ -116,1 +117,1 @@\n-      heap->concurrent_mark()->cancel();\n+      heap->global_generation()->concurrent_mark()->cancel();\n@@ -123,1 +124,1 @@\n-      heap->concurrent_mark()->update_roots(ShenandoahPhaseTimings::full_gc_update_roots);\n+      heap->global_generation()->concurrent_mark()->update_roots(ShenandoahPhaseTimings::full_gc_update_roots);\n@@ -242,2 +243,0 @@\n-  ShenandoahConcurrentMark* cm = heap->concurrent_mark();\n-\n@@ -253,2 +252,3 @@\n-  cm->mark_roots(ShenandoahPhaseTimings::full_gc_scan_roots);\n-  cm->finish_mark_from_roots(\/* full_gc = *\/ true);\n+  ShenandoahConcurrentMark* scm = heap->global_generation()->concurrent_mark();\n+  scm->mark_roots(GLOBAL, ShenandoahPhaseTimings::full_gc_scan_roots);\n+  scm->finish_mark_from_roots(\/* full_gc = *\/ true);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkCompact.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -35,0 +35,5 @@\n+enum GenerationMode {\n+  YOUNG,\n+  GLOBAL\n+};\n+\n@@ -54,1 +59,1 @@\n-  template <class T, UpdateRefsMode UPDATE_MODE, StringDedupMode STRING_DEDUP>\n+  template <class T, GenerationMode GENERATION, UpdateRefsMode UPDATE_MODE, StringDedupMode STRING_DEDUP>\n@@ -61,0 +66,1 @@\n+template <GenerationMode GENERATION>\n@@ -64,1 +70,1 @@\n-  inline void do_oop_work(T* p)     { work<T, CONCURRENT, NO_DEDUP>(p); }\n+  inline void do_oop_work(T* p)     { work<T, GENERATION, CONCURRENT, NO_DEDUP>(p); }\n@@ -75,0 +81,1 @@\n+template <GenerationMode GENERATION>\n@@ -78,1 +85,1 @@\n-  inline void do_oop_work(T* p)     { work<T, CONCURRENT, ENQUEUE_DEDUP>(p); }\n+  inline void do_oop_work(T* p)     { work<T, GENERATION, CONCURRENT, ENQUEUE_DEDUP>(p); }\n@@ -89,0 +96,1 @@\n+template <GenerationMode GENERATION>\n@@ -92,1 +100,1 @@\n-  inline void do_oop_work(T* p)     { work<T, CONCURRENT, NO_DEDUP>(p); }\n+  inline void do_oop_work(T* p)     { work<T, GENERATION, CONCURRENT, NO_DEDUP>(p); }\n@@ -103,0 +111,1 @@\n+template <GenerationMode GENERATION>\n@@ -106,1 +115,1 @@\n-  inline void do_oop_work(T* p)     { work<T, CONCURRENT, ENQUEUE_DEDUP>(p); }\n+  inline void do_oop_work(T* p)     { work<T, GENERATION, CONCURRENT, ENQUEUE_DEDUP>(p); }\n@@ -117,0 +126,1 @@\n+template <GenerationMode GENERATION>\n@@ -120,1 +130,1 @@\n-  inline void do_oop_work(T* p)     { work<T, NONE, NO_DEDUP>(p); }\n+  inline void do_oop_work(T* p)     { work<T, GENERATION, NONE, NO_DEDUP>(p); }\n@@ -131,0 +141,1 @@\n+template <GenerationMode GENERATION>\n@@ -134,1 +145,1 @@\n-  inline void do_oop_work(T* p)     { work<T, NONE, ENQUEUE_DEDUP>(p); }\n+  inline void do_oop_work(T* p)     { work<T, GENERATION, NONE, ENQUEUE_DEDUP>(p); }\n@@ -145,0 +156,1 @@\n+template <GenerationMode GENERATION>\n@@ -148,1 +160,1 @@\n-  inline void do_oop_work(T* p)     { work<T, RESOLVE, NO_DEDUP>(p); }\n+  inline void do_oop_work(T* p)     { work<T, GENERATION, RESOLVE, NO_DEDUP>(p); }\n@@ -159,0 +171,1 @@\n+template <GenerationMode GENERATION>\n@@ -162,1 +175,1 @@\n-  inline void do_oop_work(T* p)     { work<T, NONE, NO_DEDUP>(p); }\n+  inline void do_oop_work(T* p)     { work<T, GENERATION, NONE, NO_DEDUP>(p); }\n@@ -173,0 +186,1 @@\n+template <GenerationMode GENERATION>\n@@ -176,1 +190,1 @@\n-  inline void do_oop_work(T* p)     { work<T, NONE, ENQUEUE_DEDUP>(p); }\n+  inline void do_oop_work(T* p)     { work<T, GENERATION, NONE, ENQUEUE_DEDUP>(p); }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOopClosures.hpp","additions":24,"deletions":10,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"gc\/shenandoah\/shenandoahGeneration.hpp\"\n@@ -31,1 +32,1 @@\n-template<class T, UpdateRefsMode UPDATE_REFS, StringDedupMode STRING_DEDUP>\n+template<class T, GenerationMode GENERATION, UpdateRefsMode UPDATE_REFS, StringDedupMode STRING_DEDUP>\n@@ -33,1 +34,1 @@\n-  ShenandoahConcurrentMark::mark_through_ref<T, UPDATE_REFS, STRING_DEDUP>(p, _heap, _queue, _mark_context);\n+  ShenandoahConcurrentMark::mark_through_ref<T, GENERATION, UPDATE_REFS, STRING_DEDUP>(p, _heap, _queue, _mark_context);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOopClosures.inline.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/shenandoah\/shenandoahGeneration.hpp\"\n@@ -46,2 +47,1 @@\n-  ShenandoahHeap::heap()->entry_init_mark();\n-}\n+  _generation->entry_init_mark();}\n@@ -51,1 +51,1 @@\n-  ShenandoahHeap::heap()->entry_final_mark();\n+  _generation->entry_final_mark();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVMOperations.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -55,0 +55,2 @@\n+private:\n+  ShenandoahGeneration* _generation;\n@@ -56,1 +58,1 @@\n-  VM_ShenandoahInitMark() : VM_ShenandoahOperation() {};\n+  VM_ShenandoahInitMark(ShenandoahGeneration* generation) : VM_ShenandoahOperation(), _generation(generation) {};\n@@ -63,0 +65,2 @@\n+private:\n+  ShenandoahGeneration* _generation;\n@@ -64,1 +68,1 @@\n-  VM_ShenandoahFinalMarkStartEvac() : VM_ShenandoahReferenceOperation() {};\n+  VM_ShenandoahFinalMarkStartEvac(ShenandoahGeneration* generation) : VM_ShenandoahReferenceOperation(), _generation(generation) {};\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVMOperations.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,154 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat, Inc. and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/shenandoah\/shenandoahConcurrentMark.hpp\"\n+#include \"gc\/shenandoah\/shenandoahConcurrentRoots.hpp\"\n+#include \"gc\/shenandoah\/shenandoahFreeSet.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeap.hpp\"\n+#include \"gc\/shenandoah\/shenandoahMarkClosures.hpp\"\n+#include \"gc\/shenandoah\/shenandoahOopClosures.hpp\"\n+#include \"gc\/shenandoah\/shenandoahUtils.hpp\"\n+#include \"gc\/shenandoah\/shenandoahVerifier.hpp\"\n+#include \"gc\/shenandoah\/shenandoahYoungGeneration.hpp\"\n+#include \"gc\/shenandoah\/heuristics\/shenandoahHeuristics.hpp\"\n+\n+\/\/ TODO: This is almost the same code as in ShenandoahGlobalGeneration for now, to be further differentiated.\n+void ShenandoahYoungGeneration::op_final_mark() {\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+\n+  assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), \"Should be at safepoint\");\n+  assert(!heap->has_forwarded_objects(), \"No forwarded objects on this path\");\n+\n+  \/\/ It is critical that we\n+  \/\/ evacuate roots right after finishing marking, so that we don't\n+  \/\/ get unmarked objects in the roots.\n+\n+  if (!heap->cancelled_gc()) {\n+    concurrent_mark()->finish_mark_from_roots(\/* full_gc = *\/ false);\n+\n+    \/\/ Marking is completed, deactivate SATB barrier\n+    heap->set_concurrent_mark_in_progress(false);\n+    heap->mark_complete_marking_context();\n+\n+    heap->parallel_cleaning(false \/* full gc*\/);\n+\n+    if (ShenandoahVerify) {\n+      heap->verifier()->verify_roots_no_forwarded();\n+    }\n+\n+    {\n+      ShenandoahGCPhase phase(ShenandoahPhaseTimings::final_update_region_states);\n+      ShenandoahFinalMarkUpdateRegionStateClosure cl;\n+      heap->parallel_heap_region_iterate(&cl);\n+\n+      heap->assert_pinned_region_status();\n+    }\n+\n+    \/\/ Retire the TLABs, which will force threads to reacquire their TLABs after the pause.\n+    \/\/ This is needed for two reasons. Strong one: new allocations would be with new freeset,\n+    \/\/ which would be outside the collection set, so no cset writes would happen there.\n+    \/\/ Weaker one: new allocations would happen past update watermark, and so less work would\n+    \/\/ be needed for reference updates (would update the large filler instead).\n+    if (UseTLAB) {\n+      ShenandoahGCPhase phase(ShenandoahPhaseTimings::final_manage_labs);\n+      heap->tlabs_retire(false);\n+    }\n+\n+    {\n+      ShenandoahGCPhase phase(ShenandoahPhaseTimings::choose_cset);\n+      ShenandoahHeapLocker locker(heap->lock());\n+      heap->collection_set()->clear();\n+      heap->heuristics()->choose_collection_set(heap->collection_set());\n+    }\n+\n+    {\n+      ShenandoahGCPhase phase(ShenandoahPhaseTimings::final_rebuild_freeset);\n+      ShenandoahHeapLocker locker(heap->lock());\n+      heap->free_set()->rebuild();\n+    }\n+\n+    if (!heap->is_degenerated_gc_in_progress()) {\n+      heap->prepare_concurrent_roots();\n+      heap->prepare_concurrent_unloading();\n+    }\n+\n+    \/\/ If collection set has candidates, start evacuation.\n+    \/\/ Otherwise, bypass the rest of the cycle.\n+    if (!heap->collection_set()->is_empty()) {\n+      ShenandoahGCPhase init_evac(ShenandoahPhaseTimings::init_evac);\n+\n+      if (ShenandoahVerify) {\n+        heap->verifier()->verify_before_evacuation();\n+      }\n+\n+      heap->set_evacuation_in_progress(true);\n+      \/\/ From here on, we need to update references.\n+      heap->set_has_forwarded_objects(true);\n+\n+      if (!heap->is_degenerated_gc_in_progress()) {\n+        if (ShenandoahConcurrentRoots::should_do_concurrent_class_unloading()) {\n+          ShenandoahCodeRoots::arm_nmethods();\n+        }\n+        heap->evacuate_and_update_roots();\n+      }\n+\n+      if (ShenandoahPacing) {\n+        heap->pacer()->setup_for_evac();\n+      }\n+\n+      if (ShenandoahVerify) {\n+        \/\/ If OOM while evacuating\/updating of roots, there is no guarantee of their consistencies\n+        if (!heap->cancelled_gc()) {\n+          ShenandoahRootVerifier::RootTypes types = ShenandoahRootVerifier::None;\n+          if (ShenandoahConcurrentRoots::should_do_concurrent_roots()) {\n+            types = ShenandoahRootVerifier::combine(ShenandoahRootVerifier::JNIHandleRoots, ShenandoahRootVerifier::WeakRoots);\n+            types = ShenandoahRootVerifier::combine(types, ShenandoahRootVerifier::CLDGRoots);\n+            types = ShenandoahRootVerifier::combine(types, ShenandoahRootVerifier::StringDedupRoots);\n+          }\n+\n+          if (ShenandoahConcurrentRoots::should_do_concurrent_class_unloading()) {\n+            types = ShenandoahRootVerifier::combine(types, ShenandoahRootVerifier::CodeRoots);\n+          }\n+          heap->verifier()->verify_roots_no_forwarded_except(types);\n+        }\n+        heap->verifier()->verify_during_evacuation();\n+      }\n+    } else {\n+      if (ShenandoahVerify) {\n+        heap->verifier()->verify_after_concmark();\n+      }\n+\n+      if (VerifyAfterGC) {\n+        Universe::verify();\n+      }\n+    }\n+\n+  } else {\n+    \/\/ If this cycle was updating references, we need to keep the has_forwarded_objects\n+    \/\/ flag on, for subsequent phases to deal with it.\n+    concurrent_mark()->cancel();\n+    heap->set_concurrent_mark_in_progress(false);\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahYoungGeneration.cpp","additions":154,"deletions":0,"binary":false,"changes":154,"status":"added"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2020, Amazon.com, Inc. and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_VM_GC_SHENANDOAH_SHENANDOAHYOUNGGENERATION_HPP\n+#define SHARE_VM_GC_SHENANDOAH_SHENANDOAHYOUNGGENERATION_HPP\n+\n+#include \"gc\/shenandoah\/shenandoahGeneration.hpp\"\n+\n+class ShenandoahYoungGeneration : public ShenandoahGeneration {\n+public:\n+  ShenandoahYoungGeneration() : ShenandoahGeneration(YOUNG) { }\n+\n+  virtual void op_final_mark();\n+};\n+\n+#endif \/\/ SHARE_VM_GC_SHENANDOAH_SHENANDOAHYOUNGGENERATION_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahYoungGeneration.hpp","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"}]}