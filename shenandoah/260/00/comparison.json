{"files":[{"patch":"@@ -65,0 +65,1 @@\n+  size_t _waste;\n@@ -73,1 +74,1 @@\n-          _actual_size(0), _alloc_type(_alloc_type), _affiliation(affiliation)\n+          _actual_size(0), _waste(0), _alloc_type(_alloc_type), _affiliation(affiliation)\n@@ -100,1 +101,1 @@\n-  inline size_t size() {\n+  inline size_t size() const {\n@@ -104,1 +105,1 @@\n-  inline Type type() {\n+  inline Type type() const {\n@@ -108,1 +109,1 @@\n-  inline const char* type_string() {\n+  inline const char* type_string() const {\n@@ -112,1 +113,1 @@\n-  inline size_t min_size() {\n+  inline size_t min_size() const {\n@@ -117,1 +118,1 @@\n-  inline size_t actual_size() {\n+  inline size_t actual_size() const {\n@@ -130,1 +131,9 @@\n-  inline bool is_mutator_alloc() {\n+  inline size_t waste() const {\n+    return _waste;\n+  }\n+\n+  inline void set_waste(size_t v) {\n+    _waste = v;\n+  }\n+\n+  inline bool is_mutator_alloc() const {\n@@ -145,1 +154,1 @@\n-  inline bool is_gc_alloc() {\n+  inline bool is_gc_alloc() const {\n@@ -160,1 +169,1 @@\n-  inline bool is_lab_alloc() {\n+  inline bool is_lab_alloc() const {\n@@ -175,1 +184,1 @@\n-  bool is_old() {\n+  bool is_old() const {\n@@ -179,1 +188,1 @@\n-  bool is_young() {\n+  bool is_young() const {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAllocRequest.hpp","additions":20,"deletions":11,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -249,0 +249,32 @@\n+size_t get_usable_free_words(size_t free) {\n+  \/\/ e.g. card_size is 512, card_shift is 9, min_fill_size() is 8\n+  \/\/      free is 514\n+  \/\/      usable_free is 512, which is decreased to 0\n+  size_t usable_free = (free \/ CardTable::card_size()) << CardTable::card_shift();\n+  if ((free != usable_free) && (free - usable_free < ShenandoahHeap::min_fill_size() * HeapWordSize)) {\n+    \/\/ We'll have to add another card's memory to the padding\n+    if (usable_free >= CardTable::card_size()) {\n+      usable_free -= CardTable::card_size();\n+    } else {\n+      assert(usable_free == 0, \"usable_free is a multiple of card_size and card_size > min_fill_size\");\n+    }\n+  }\n+\n+  return usable_free \/ HeapWordSize;;\n+}\n+\n+HeapWord* ShenandoahFreeSet::allocated_aligned_plab(size_t size, ShenandoahAllocRequest& req, ShenandoahHeapRegion* r) {\n+  assert(_heap->mode()->is_generational(), \"PLABs are only for generational mode\");\n+  assert(r->is_old(), \"All PLABs reside in old-gen\");\n+  assert(!req.is_mutator_alloc(), \"PLABs should not be allocated by mutators.\");\n+  assert(size % CardTable::card_size_in_words() == 0, \"size must be multiple of card table size, was \" SIZE_FORMAT, size);\n+\n+  HeapWord* result = r->allocate_aligned(size, req, CardTable::card_size());\n+  assert(result != nullptr, \"Allocation cannot fail\");\n+  assert(r->top() <= r->end(), \"Allocation cannot span end of region\");\n+  assert(req.actual_size() % CardTable::card_size_in_words() == 0, \"PLAB size must be multiple of card size\");\n+  assert(((uintptr_t) result) % CardTable::card_size_in_words() == 0, \"PLAB start must align with card boundary\");\n+\n+  return result;\n+}\n+\n@@ -252,2 +284,1 @@\n-  if (_heap->is_concurrent_weak_root_in_progress() &&\n-      r->is_trash()) {\n+  if (_heap->is_concurrent_weak_root_in_progress() && r->is_trash()) {\n@@ -256,0 +287,1 @@\n+\n@@ -281,1 +313,0 @@\n-  size_t size = req.size();\n@@ -291,1 +322,0 @@\n-      assert(_heap->mode()->is_generational(), \"PLABs are only for generational mode\");\n@@ -293,20 +323,5 @@\n-      size_t free = r->free();\n-      \/\/ e.g. card_size is 512, card_shift is 9, min_fill_size() is 8\n-      \/\/      free is 514\n-      \/\/      usable_free is 512, which is decreased to 0\n-      size_t usable_free = (free \/ CardTable::card_size()) << CardTable::card_shift();\n-      if ((free != usable_free) && (free - usable_free < ShenandoahHeap::min_fill_size() * HeapWordSize)) {\n-        \/\/ We'll have to add another card's memory to the padding\n-        if (usable_free >= CardTable::card_size()) {\n-          usable_free -= CardTable::card_size();\n-        } else {\n-          assert(usable_free == 0, \"usable_free is a multiple of card_size and card_size > min_fill_size\");\n-        }\n-      }\n-      free \/= HeapWordSize;\n-      usable_free \/= HeapWordSize;\n-      size_t remnant = size % CardTable::card_size_in_words();\n-      if (remnant > 0) {\n-        \/\/ Since we have Elastic TLABs, align size up.  This is consistent with aligning min_size up.\n-        size = size - remnant + CardTable::card_size_in_words();\n-      }\n+      \/\/ Since we have Elastic TLABs, align size up.  This is consistent with aligning min_size up.\n+      size_t usable_free = get_usable_free_words(r->free());\n+      size_t size = align_up(req.size(), CardTable::card_size_in_words());\n+      size_t adjusted_min_size = align_up(req.min_size(), CardTable::card_size_in_words());\n+\n@@ -315,1 +330,0 @@\n-        assert(size % CardTable::card_size_in_words() == 0, \"usable_free is a multiple of card table size\");\n@@ -318,6 +332,0 @@\n-      size_t adjusted_min_size = req.min_size();\n-      remnant = adjusted_min_size % CardTable::card_size_in_words();\n-      if (remnant > 0) {\n-        \/\/ Round up adjusted_min_size to a multiple of alignment size\n-        adjusted_min_size = adjusted_min_size - remnant + CardTable::card_size_in_words();\n-      }\n@@ -325,18 +333,1 @@\n-        result = r->allocate_aligned(size, req, CardTable::card_size());\n-        assert(result != nullptr, \"Allocation cannot fail\");\n-        size = req.actual_size();\n-        assert(r->top() <= r->end(), \"Allocation cannot span end of region\");\n-        \/\/ actual_size() will be set to size below.\n-        assert((result == nullptr) || (size % CardTable::card_size_in_words() == 0),\n-               \"PLAB size must be multiple of card size\");\n-        assert((result == nullptr) || (((uintptr_t) result) % CardTable::card_size_in_words() == 0),\n-               \"PLAB start must align with card boundary\");\n-        if (free > usable_free) {\n-          \/\/ Account for the alignment padding\n-          size_t padding = (free - usable_free) * HeapWordSize;\n-          increase_used(padding);\n-          assert(r->is_old(), \"All PLABs reside in old-gen\");\n-          _heap->old_generation()->increase_used(padding);\n-          \/\/ For verification consistency, we need to report this padding to _heap\n-          _heap->increase_used(padding);\n-        }\n+        result = allocated_aligned_plab(size, req, r);\n@@ -347,0 +338,1 @@\n+      size_t size = req.size();\n@@ -353,4 +345,0 @@\n-        if (result != nullptr) {\n-          \/\/ Record actual allocation size\n-          req.set_actual_size(size);\n-        }\n@@ -358,0 +346,1 @@\n+        req.set_actual_size(size);\n@@ -364,1 +353,1 @@\n-    assert(_heap->mode()->is_generational(), \"PLABs are only for generational mode\");\n+\n@@ -366,13 +355,2 @@\n-    size_t free = r->free();\n-    size_t usable_free = (free \/ CardTable::card_size()) << CardTable::card_shift();\n-    free \/= HeapWordSize;\n-    usable_free \/= HeapWordSize;\n-    if ((free != usable_free) && (free - usable_free < ShenandoahHeap::min_fill_size() * HeapWordSize)) {\n-      \/\/ We'll have to add another card's memory to the padding\n-      if (usable_free > CardTable::card_size_in_words()) {\n-        usable_free -= CardTable::card_size_in_words();\n-      } else {\n-        assert(usable_free == 0, \"usable_free is a multiple of card_size and card_size > min_fill_size\");\n-      }\n-    }\n-    assert(size % CardTable::card_size_in_words() == 0, \"PLAB size must be multiple of remembered set card size\");\n+    size_t size = req.size();\n+    size_t usable_free = get_usable_free_words(r->free());\n@@ -380,15 +358,1 @@\n-      result = r->allocate_aligned(size, req, CardTable::card_size());\n-      size = req.actual_size();\n-      assert(result != nullptr, \"Allocation cannot fail\");\n-      assert(r->top() <= r->end(), \"Allocation cannot span end of region\");\n-      assert(req.actual_size() % CardTable::card_size_in_words() == 0, \"PLAB start must align with card boundary\");\n-      assert(((uintptr_t) result) % CardTable::card_size_in_words() == 0, \"PLAB start must align with card boundary\");\n-      if (free > usable_free) {\n-        \/\/ Account for the alignment padding\n-        size_t padding = (free - usable_free) * HeapWordSize;\n-        increase_used(padding);\n-        assert(r->is_old(), \"All PLABs reside in old-gen\");\n-        _heap->old_generation()->increase_used(padding);\n-        \/\/ For verification consistency, we need to report this padding to _heap\n-        _heap->increase_used(padding);\n-      }\n+      result = allocated_aligned_plab(size, req, r);\n@@ -397,0 +361,1 @@\n+    size_t size = req.size();\n@@ -408,3 +373,1 @@\n-      assert(req.is_young(), \"Mutator allocations always come from young generation.\");\n-      generation->increase_used(size * HeapWordSize);\n-      increase_used(size * HeapWordSize);\n+      increase_used(req.actual_size() * HeapWordSize);\n@@ -422,1 +385,0 @@\n-      generation->increase_used(size * HeapWordSize);\n@@ -444,2 +406,2 @@\n-        generation->increase_allocated(waste);\n-        _heap->notify_mutator_alloc_words(waste >> LogHeapWordSize, true);\n+        \/\/ This one request could cause several regions to be \"retired\", so we must accumulate the waste\n+        req.set_waste((waste >> LogHeapWordSize) + req.waste());\n@@ -582,0 +544,1 @@\n+    \/\/ While individual regions report their true use, all humongous regions are marked used in the free set.\n@@ -584,12 +547,2 @@\n-\n-  \/\/ While individual regions report their true use, all humongous regions are\n-  \/\/ marked used in the free set.\n-  increase_used(ShenandoahHeapRegion::region_size_bytes() * num);\n-  generation->increase_used(words_size * HeapWordSize);\n-\n-  if (remainder != 0) {\n-    \/\/ Record this remainder as allocation waste\n-    size_t waste = ShenandoahHeapRegion::region_size_words() - remainder;\n-    _heap->notify_mutator_alloc_words(waste, true);\n-    generation->increase_allocated(waste * HeapWordSize);\n-  }\n+  size_t total_humongous_size = ShenandoahHeapRegion::region_size_bytes() * num;\n+  increase_used(total_humongous_size);\n@@ -604,0 +557,3 @@\n+  if (remainder != 0) {\n+    req.set_waste(ShenandoahHeapRegion::region_size_words() - remainder);\n+  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":56,"deletions":100,"binary":false,"changes":156,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+  HeapWord* allocated_aligned_plab(size_t size, ShenandoahAllocRequest& req, ShenandoahHeapRegion* r);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"gc\/shenandoah\/shenandoahAllocRequest.hpp\"\n@@ -80,0 +81,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -713,0 +715,48 @@\n+\/\/ For tracking usage based on allocations, it should be the case that:\n+\/\/ * The sum of regions::used == heap::used\n+\/\/ * The sum of a generation's regions::used == generation::used\n+\/\/ * The sum of a generation's humongous regions::free == generation::humongous_waste\n+\/\/ These invariants are checked by the verifier on safepoints.\n+\/\/\n+\/\/ Additional notes:\n+\/\/ * When a mutator's allocation request causes a region to be retired, the\n+\/\/   free memory left in that region is considered waste. It does not contribute\n+\/\/   to the usage, but it _does_ contribute to allocation rate.\n+\/\/ * The bottom of a PLAB must be aligned on card size. In some cases this will\n+\/\/   require padding in front of the PLAB (a filler object). Because this padding\n+\/\/   is included in the region's used memory we include the padding in the accounting.\n+\/\/ * Mutator allocations are used to compute an allocation rate. They are also\n+\/\/   sent to the Pacer for those purposes.\n+\/\/ * There are three sources of waste:\n+\/\/  * The padding used to align a PLAB on card size\n+\/\/  * Region's free is less than minimum TLAB size and is retired\n+\/\/  * The unused portion of memory in the last region of a humongous object\n+void ShenandoahHeap::increase_used(const ShenandoahAllocRequest& req) {\n+  size_t actual_bytes = req.actual_size() * HeapWordSize;\n+  size_t wasted_bytes = req.waste() * HeapWordSize;\n+  ShenandoahGeneration* generation = generation_for(req.affiliation());\n+\n+  if (req.is_gc_alloc()) {\n+    assert(wasted_bytes == 0 || req.type() == ShenandoahAllocRequest::_alloc_plab, \"Only PLABs have waste\");\n+    generation->increase_used(actual_bytes + wasted_bytes);\n+    increase_used(actual_bytes + wasted_bytes);\n+  } else {\n+    assert(req.is_mutator_alloc(), \"Expected mutator alloc here\");\n+    \/\/ padding and actual size both count towards allocation counter\n+    generation->increase_allocated(actual_bytes + wasted_bytes);\n+\n+    \/\/ only actual size counts toward usage for mutator allocations\n+    generation->increase_used(actual_bytes);\n+    increase_used(actual_bytes);\n+\n+    \/\/ notify pacer of both actual size and waste\n+    notify_mutator_alloc_words(req.actual_size(), req.waste());\n+\n+    if (wasted_bytes > 0) {\n+      if (req.actual_size() > ShenandoahHeapRegion::humongous_threshold_words()) {\n+        \/\/ generation->increase_humongous_waste(wasted_bytes);\n+      }\n+    }\n+  }\n+}\n+\n@@ -726,6 +776,1 @@\n-void ShenandoahHeap::notify_mutator_alloc_words(size_t words, bool waste) {\n-  size_t bytes = words * HeapWordSize;\n-  if (!waste) {\n-    increase_used(bytes);\n-  }\n-\n+void ShenandoahHeap::notify_mutator_alloc_words(size_t words, size_t waste) {\n@@ -734,3 +779,1 @@\n-    if (waste) {\n-      pacer()->claim_for_alloc(words, true);\n-    }\n+    pacer()->claim_for_alloc(waste, true);\n@@ -1196,0 +1239,8 @@\n+  if (result == nullptr) {\n+    req.set_actual_size(0);\n+  }\n+\n+  \/\/ This is called regardless of the outcome of the allocation to account\n+  \/\/ for any waste created by retiring regions with this request.\n+  increase_used(req);\n+\n@@ -1197,1 +1248,0 @@\n-    ShenandoahGeneration* alloc_generation = generation_for(req.affiliation());\n@@ -1200,1 +1250,0 @@\n-    size_t actual_bytes = actual * HeapWordSize;\n@@ -1207,3 +1256,0 @@\n-      notify_mutator_alloc_words(actual, false);\n-      alloc_generation->increase_allocated(actual_bytes);\n-\n@@ -1216,2 +1262,0 @@\n-    } else {\n-      increase_used(actual_bytes);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":60,"deletions":16,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -227,0 +227,1 @@\n+  void increase_used(const ShenandoahAllocRequest& req);\n@@ -708,1 +709,1 @@\n-  void notify_mutator_alloc_words(size_t words, bool waste);\n+  void notify_mutator_alloc_words(size_t words, size_t waste);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -96,0 +96,1 @@\n+    req.set_waste(pad_words);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}