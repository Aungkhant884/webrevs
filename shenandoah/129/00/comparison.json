{"files":[{"patch":"@@ -137,1 +137,1 @@\n-          for (int i = region->age() - InitialTenuringThreshold; i >= 0; i--) {\n+          for (uint j = region->age() - InitialTenuringThreshold; j > 0; j--) {\n@@ -222,1 +222,0 @@\n-    size_t preapproved_evac_reserve_loan = 0;\n@@ -242,2 +241,0 @@\n-      size_t old_region_borrow_count = 0;\n-\n@@ -251,1 +248,0 @@\n-      ShenandoahYoungGeneration* young_generation = heap->young_generation();\n@@ -277,1 +273,0 @@\n-        preapproved_evac_reserve_loan = loaned_region_request * region_size_bytes;\n@@ -289,1 +284,0 @@\n-    heap->reset_young_evac_expended();\n@@ -294,5 +288,0 @@\n-    size_t young_evacuated_bytes = collection_set->get_young_bytes_reserved_for_evacuation();;\n-    if (young_evacuated_bytes * ShenandoahEvacWaste < young_evacuation_reserve) {\n-      young_evacuation_reserve = (size_t) (young_evacuated_bytes * ShenandoahEvacWaste);\n-      heap->set_young_evac_reserve((size_t) young_evacuation_reserve);\n-    }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.cpp","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -231,1 +231,0 @@\n-    young_gen->increase_used(heap->get_young_evac_expended());\n@@ -239,1 +238,0 @@\n-    heap->reset_young_evac_expended();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -283,1 +283,0 @@\n-    heap->young_generation()->increase_used(heap->get_young_evac_expended());\n@@ -288,1 +287,0 @@\n-    heap->reset_young_evac_expended();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahDegeneratedGC.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -296,9 +296,1 @@\n-        \/\/ This is either a GCLAB or it is a shared evacuation allocation.  In either case, we expend young evac.\n-        \/\/ At end of update refs, we'll add expended young evac into young_gen->used.  We hide this usage\n-        \/\/ from current accounting because memory reserved for evacuation is not part of adjusted capacity.\n-        if (_heap->mode()->is_generational()) {\n-          _heap->expend_young_evac(size * HeapWordSize);\n-        } else {\n-          \/\/ If we are not in generational mode, we still need to count this allocation as used memory.\n-          _heap->young_generation()->increase_used(size * HeapWordSize);\n-        }\n+        _heap->young_generation()->increase_used(size * HeapWordSize);\n@@ -307,1 +299,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -188,1 +188,0 @@\n-  heap->young_generation()->increase_used(heap->get_young_evac_expended());\n@@ -193,1 +192,0 @@\n-  heap->reset_young_evac_expended();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -399,0 +399,1 @@\n+  log_info(gc)(\"Cancel marking: %s\", name());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -518,1 +518,0 @@\n-  _young_evac_expended(0),\n@@ -1170,8 +1169,4 @@\n-      if (req.type() == ShenandoahAllocRequest::_alloc_gclab) {\n-        if (requested_bytes + get_young_evac_expended() > get_young_evac_reserve()) {\n-          \/\/ This should only happen if evacuation waste is too low.  Rejecting one thread's request for GCLAB does not\n-          \/\/ necessarily result in failure of the evacuation effort.  A different thread may be able to copy from-space object.\n-\n-          \/\/ TODO: Should we really fail here in the case that there is sufficient memory to allow us to allocate a gclab\n-          \/\/ beyond the young_evac_reserve?  Seems it would be better to take away from mutator allocation budget if this\n-          \/\/ prevents fall-back to full GC in order to recover from failed evacuation.\n+      if (req.is_mutator_alloc()) {\n+        if (requested_bytes >= young_generation()->adjusted_available()) {\n+          \/\/ We know this is not a GCLAB.  This must be a TLAB or a shared allocation.  Reject the allocation request if\n+          \/\/ exceeds established capacity limits.\n@@ -1180,15 +1175,0 @@\n-        \/\/ else, there is sufficient memory to allocate this GCLAB so do nothing here.\n-      } else if (req.is_gc_alloc()) {\n-        \/\/ This is a shared alloc for purposes of evacuation.\n-        if (requested_bytes + get_young_evac_expended() > get_young_evac_reserve()) {\n-          \/\/ TODO: Should we really fail here in the case that there is sufficient memory to allow us to allocate a gclab\n-          \/\/ beyond the young_evac_reserve?  Seems it would be better to take away from mutator allocation budget if this\n-          \/\/ prevents fall-back to full GC in order to recover from failed evacuation.\n-          return nullptr;\n-        } else {\n-          \/\/ There is sufficient memory to allocate this shared evacuation object.\n-        }\n-      }  else if (requested_bytes >= young_generation()->adjusted_available()) {\n-        \/\/ We know this is not a GCLAB.  This must be a TLAB or a shared allocation.  Reject the allocation request if\n-        \/\/ exceeds established capacity limits.\n-        return nullptr;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":4,"deletions":24,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -349,2 +349,1 @@\n-  \/\/ subtracting the amount to be loaned to young-gen.  At the end of update-refs, we unadjust the capacity of each generation,\n-  \/\/ and add _young_evac_expended to young-gen used.\n+  \/\/ subtracting the amount to be loaned to young-gen.\n@@ -355,4 +354,1 @@\n-  \/\/ During evacuation, we assure that _young_evac_expended does not exceed _young_evac_reserve and that _old_evac_expended\n-  \/\/ does not exceed _old_evac_reserve.  GCLAB allocations do not immediately affect used within the young generation\n-  \/\/ since the adjusted capacity already accounts for the entire evacuation reserve.  Each GCLAB allocations increments\n-  \/\/ _young_evac_expended rather than incrementing the affiliated generation's used value.\n+  \/\/ During evacuation, we assure that _old_evac_expended does not exceed _old_evac_reserve.\n@@ -364,2 +360,1 @@\n-  \/\/ 2. Increase young_gen->used() by _young_evac_expended.  This represents memory consumed by evacutions from young-gen.\n-  \/\/ 3. Clear (reset to zero) _alloc_supplement_reserve, _young_evac_reserve, _old_evac_reserve, and _promotion_reserve\n+  \/\/ 2. Clear (reset to zero) _alloc_supplement_reserve, _young_evac_reserve, _old_evac_reserve, and _promotion_reserve\n@@ -369,3 +364,0 @@\n-  \/\/ Allocation of young GCLABs assures that _young_evac_expended + request-size < _young_evac_reserved.  If the allocation\n-  \/\/  is authorized, increment _young_evac_expended by request size.  This allocation ignores young_gen->available().\n-  \/\/\n@@ -389,1 +381,0 @@\n-  size_t _young_evac_expended;         \/\/ Bytes old-gen memory has been expended on young-gen evacuations\n@@ -460,4 +451,0 @@\n-  inline void reset_young_evac_expended();\n-  inline size_t expend_young_evac(size_t increment);\n-  inline size_t get_young_evac_expended() const;\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":3,"deletions":16,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -649,13 +649,0 @@\n-inline void ShenandoahHeap::reset_young_evac_expended() {\n-  _young_evac_expended = 0;\n-}\n-\n-inline size_t ShenandoahHeap::expend_young_evac(size_t increment) {\n-  _young_evac_expended += increment;\n-  return _young_evac_expended;\n-}\n-\n-inline size_t ShenandoahHeap::get_young_evac_expended() const {\n-  return _young_evac_expended;\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.inline.hpp","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -161,0 +161,1 @@\n+    log_info(gc)(\"Abandon satb buffers.\");\n@@ -168,1 +169,1 @@\n-  ShenandoahHeap *heap = ShenandoahHeap::heap();\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n@@ -171,1 +172,1 @@\n-\n+  log_info(gc)(\"Transfer satb buffers.\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -391,10 +391,1 @@\n-    size_t generation_used;\n-    if (generation->generation_mode() == YOUNG) {\n-      \/\/ young_evac_expended is \"usually zero\".  If it is non-zero, this means we are doing evacuation or updating references\n-      \/\/ and young-gen memory that holds the results of evacuation is being temporarily hidden from the usage accounting,\n-      \/\/ so we add it back in here to make verification happy.\n-      generation_used = generation->used() + ShenandoahHeap::heap()->get_young_evac_expended();\n-    } else {\n-      generation_used = generation->used();\n-    }\n-\n+    size_t generation_used = generation->used();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVerifier.cpp","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"}]}