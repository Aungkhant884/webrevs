{"files":[{"patch":"@@ -218,2 +218,1 @@\n-                                                      size_t &old_regions_loaned_for_young_evac, size_t &regions_available_to_loan,\n-                                                      size_t &minimum_evacuation_reserve, size_t &consumed_by_advance_promotion) {\n+                                                      size_t &consumed_by_advance_promotion) {\n@@ -221,3 +220,3 @@\n-  minimum_evacuation_reserve = ShenandoahOldCompactionReserve * region_size_bytes;\n-  old_regions_loaned_for_young_evac = 0;\n-  regions_available_to_loan = 0;\n+  size_t regions_available_to_loan = 0;\n+  size_t minimum_evacuation_reserve = ShenandoahOldCompactionReserve * region_size_bytes;\n+  size_t old_regions_loaned_for_young_evac = 0;\n@@ -273,6 +272,0 @@\n-    if (old_evacuation_reserve < minimum_evacuation_reserve) {\n-      \/\/ Even if there's nothing to be evacuated on this cycle, we still need to reserve this memory for future\n-      \/\/ evacuations.  It is ok to loan this memory to young-gen if we don't need it for evacuation on this pass.\n-      avail_evac_reserve_for_loan_to_young_gen = minimum_evacuation_reserve - old_evacuation_reserve;\n-      old_evacuation_reserve = minimum_evacuation_reserve;\n-    }\n@@ -364,2 +357,11 @@\n-    consumed_by_advance_promotion = _heuristics->select_aged_regions(old_generation->available() - old_evacuation_reserve,\n-                                                                     num_regions, preselected_regions);\n+\n+    size_t required_evacuation_reserve;\n+    \/\/ Memory evacuated from old-gen on this pass will be available to hold old-gen evacuations in next pass.\n+    if (old_evacuation_reserve > minimum_evacuation_reserve) {\n+      required_evacuation_reserve = 0;\n+    } else {\n+      required_evacuation_reserve = minimum_evacuation_reserve - old_evacuation_reserve;\n+    }\n+\n+    consumed_by_advance_promotion = _heuristics->select_aged_regions(\n+      old_generation->available() - old_evacuation_reserve - required_evacuation_reserve, num_regions, preselected_regions);\n@@ -369,1 +371,1 @@\n-    if (regions_available_to_loan > net_available_old_regions) {\n+   if (regions_available_to_loan > net_available_old_regions) {\n@@ -388,2 +390,0 @@\n-    } else {\n-      old_regions_loaned_for_young_evac = 0;\n@@ -410,0 +410,1 @@\n+\n@@ -411,2 +412,16 @@\n-                                                     size_t old_regions_loaned_for_young_evac, size_t regions_available_to_loan,\n-                                                     size_t minimum_evacuation_reserve, size_t consumed_by_advance_promotion) {\n+                                                     size_t consumed_by_advance_promotion) {\n+  \/\/ We may find that old_evacuation_reserve and\/or loaned_for_young_evacuation are not fully consumed, in which case we may\n+  \/\/  be able to increase regions_available_to_loan\n+\n+  \/\/ The role of adjust_evacuation_budgets() is to compute the correct value of regions_available_to_loan and to make\n+  \/\/ effective use of this memory, including the remnant memory within these regions that may result from rounding loan to\n+  \/\/ integral number of regions.  Excess memory that is available to be loaned is applied to an allocation supplement,\n+  \/\/ which allows mutators to allocate memory beyond the current capacity of young-gen on the promise that the loan\n+  \/\/ will be repaid as soon as we finish updating references for the recently evacuated collection set.\n+\n+  \/\/ We cannot recalculate regions_available_to_loan by simply dividing old_generation->available() by region_size_bytes\n+  \/\/ because the available memory may be distributed between many partially occupied regions that are already holding old-gen\n+  \/\/ objects.  Memory in partially occupied regions is not \"available\" to be loaned.  Note that an increase in old-gen\n+  \/\/ available that results from a decrease in memory consumed by old evacuation is not necessarily available to be loaned\n+  \/\/ to young-gen.\n+\n@@ -414,0 +429,1 @@\n+    size_t old_regions_loaned_for_young_evac, regions_available_to_loan;\n@@ -424,0 +440,2 @@\n+    size_t loaned_regions = 0;\n+    size_t available_loan_remnant = 0; \/\/ loaned memory that is not yet dedicated to any particular budget\n@@ -442,5 +460,0 @@\n-\n-      \/\/ If we shrink old_evacuation_reserve by more than a region size, we can expand regions_available_to_loan.\n-      \/\/ Can only give back regions that are fully unused, so round down.\n-      size_t old_evac_regions_unused = (old_evacuation_reserve - old_evacuated_committed) \/ region_size_bytes;\n-      regions_available_to_loan += old_evac_regions_unused;\n@@ -459,1 +472,1 @@\n-    heap->set_young_evac_reserve(young_evacuated_reserve_used);\n+    \/\/ We'll invoke heap->set_young_evac_reserve() further below, after we make additional adjustments to its value\n@@ -468,3 +481,4 @@\n-      \/\/ Undo the previous loan\n-      regions_available_to_loan += old_regions_loaned_for_young_evac;\n-      old_regions_loaned_for_young_evac = revised_loan_for_young_evacuation;\n+      \/\/ available_loan_remnant represents memory loaned from old-gen but not required for young evacuation.\n+      \/\/ This is the excess loaned memory that results from rounding the required loan up to an integral number\n+      \/\/ of heap regions.  This will be dedicated to alloc_supplement below.\n+      available_loan_remnant = (revised_loan_for_young_evacuation * region_size_bytes) - short_fall;\n@@ -472,3 +486,3 @@\n-      \/\/ And make a new loan\n-      assert(regions_available_to_loan > old_regions_loaned_for_young_evac, \"Cannot loan regions that we do not have\");\n-      regions_available_to_loan -= revised_loan_for_young_evacuation;\n+      \/\/ We previously loaned more than was required by young-gen evacuation.  So claw some of this memory back.\n+      old_regions_loaned_for_young_evac = revised_loan_for_young_evacuation;\n+      loaned_regions = old_regions_loaned_for_young_evac;\n@@ -476,2 +490,1 @@\n-      \/\/ Undo the prevous loan\n-      regions_available_to_loan += old_regions_loaned_for_young_evac;\n+      \/\/ Undo the prevous loan, if any.\n@@ -479,0 +492,1 @@\n+      loaned_regions = 0;\n@@ -481,4 +495,51 @@\n-    size_t old_bytes_loaned_for_young_evac = old_regions_loaned_for_young_evac * region_size_bytes;\n-    size_t old_bytes_reserved_for_alloc_supplement = 0;\n-    size_t old_regions_reserved_for_alloc_supplement = 0;\n-    \/\/ Need to enforce that old_evacuated_committed + old_bytes_loaned_for_young_evac >= minimum_evacuation_reserve\n+    size_t old_bytes_loaned_for_young_evac = old_regions_loaned_for_young_evac * region_size_bytes - available_loan_remnant;\n+\n+    \/\/ Recompute regions_available_to_loan based on possible changes to old_regions_loaned_for_young_evac and\n+    \/\/ old_evacuation_reserve.\n+\n+    \/\/ Any decrease in old_regions_loaned_for_young_evac are immediately available to be loaned\n+    \/\/ However, a change to old_evacuation_reserve() is not necessarily available to loan, because this memory may\n+    \/\/ reside within many fragments scattered throughout old-gen.\n+\n+    regions_available_to_loan = old_generation->free_unaffiliated_regions();\n+    size_t working_old_available = old_generation->available();\n+\n+    assert(regions_available_to_loan * region_size_bytes <= working_old_available,\n+           \"Regions available to loan  must be less than available memory\");\n+\n+    \/\/ fragmented_old_total is the amount of memory in old-gen beyond regions_available_to_loan that is otherwise not\n+    \/\/ yet dedicated to a particular budget.  This memory can be used for promotion_reserve.\n+    size_t fragmented_old_total = working_old_available - regions_available_to_loan * region_size_bytes;\n+\n+    \/\/ fragmented_old_usage is the memory that is dedicated to holding evacuated old-gen objects, which does not need\n+    \/\/ to be an integral number of regions.\n+    size_t fragmented_old_usage = old_evacuated_committed + consumed_by_advance_promotion;\n+\n+\n+\n+    if (fragmented_old_total >= fragmented_old_usage) {\n+      \/\/ Seems this will be rare.  In this case, all of the memory required for old-gen evacuations and promotions can be\n+      \/\/ taken from the existing fragments within old-gen.  Reduce this fragmented total by this amount.\n+      fragmented_old_total -= fragmented_old_usage;\n+      \/\/ And reduce regions_available_to_loan by the regions dedicated to young_evac.\n+      regions_available_to_loan -= old_regions_loaned_for_young_evac;\n+    } else {\n+      \/\/ In this case, we need to dedicate some of the regions_available_to_loan to hold the results of old-gen evacuations\n+      \/\/ and promotions.\n+\n+      size_t unaffiliated_memory_required_for_old = fragmented_old_usage - fragmented_old_total;\n+      size_t unaffiliated_regions_used_by_old = (unaffiliated_memory_required_for_old + region_size_bytes - 1) \/ region_size_bytes;\n+      regions_available_to_loan -= (unaffiliated_regions_used_by_old + old_regions_loaned_for_young_evac);\n+\n+      size_t memory_for_promotions_and_old_evac = fragmented_old_total + unaffiliated_regions_used_by_old;\n+      size_t memory_required_for_promotions_and_old_evac = fragmented_old_usage;\n+      size_t excess_fragmented = memory_for_promotions_and_old_evac - memory_required_for_promotions_and_old_evac;\n+      fragmented_old_total = excess_fragmented;\n+    }\n+\n+    \/\/ Subtract from working_old_available old_evacuated_committed and consumed_by_advance_promotion\n+    working_old_available -= fragmented_old_usage;\n+    \/\/ And also subtract out the regions loaned for young evacuation\n+    working_old_available -= old_regions_loaned_for_young_evac * region_size_bytes;\n+\n+    \/\/ Assure that old_evacuated_committed + old_bytes_loaned_for_young_evac >= the minimum evacuation reserve\n@@ -486,9 +547,84 @@\n-    if (old_evacuated_committed + old_bytes_loaned_for_young_evac < minimum_evacuation_reserve) {\n-      \/\/ Reserve some of the regions available to loan for use as allocation supplement to assure memory not consumed by promotion\n-      size_t excess_bytes = minimum_evacuation_reserve - (old_evacuated_committed + old_bytes_loaned_for_young_evac);\n-      size_t excess_regions = (excess_bytes - 1 + region_size_bytes) \/ region_size_bytes;\n-      if (regions_available_to_loan <= excess_regions) {\n-        excess_regions = regions_available_to_loan;\n-        \/\/ Since we can't reserve entire excess for alloc supplement, pretend more is consumed by old-evacuation\n-        old_evacuated_committed =\n-          minimum_evacuation_reserve - old_bytes_loaned_for_young_evac - excess_regions * region_size_bytes;\n+    size_t old_regions_reserved_for_alloc_supplement = 0;\n+    size_t old_bytes_reserved_for_alloc_supplement = 0;\n+    size_t reserved_bytes_for_future_old_evac = 0;\n+\n+    old_bytes_reserved_for_alloc_supplement = available_loan_remnant;\n+    available_loan_remnant = 0;\n+\n+    \/\/ Memory that has been loaned for young evacuations and old-gen regions in the current mixed-evacuation collection\n+    \/\/ set will be available to hold future old-gen evacuations.  If this memory is less than the desired amount of memory\n+    \/\/ set aside for old-gen compaction reserve, try to set aside additional memory so that it will be available during\n+    \/\/ the next mixed evacuation cycle.  Note that memory loaned to young-gen for allocation supplement is excluded from\n+    \/\/ the old-gen promotion reserve.\n+    size_t future_evac_reserve_regions = old_regions_loaned_for_young_evac + collection_set->get_old_region_count();\n+    size_t collected_regions = collection_set->get_young_region_count();\n+\n+    if (future_evac_reserve_regions < ShenandoahOldCompactionReserve) {\n+      \/\/ Require that we loan more memory for holding young evacuations to assure that we have adequate reserves to receive\n+      \/\/ old-gen evacuations during subsequent collections.  Loaning this memory for an allocation supplement does not\n+      \/\/ satisfy our needs because newly allocated objects are not necessarily counter-balanced by reclaimed collection\n+      \/\/ set regions.\n+\n+      \/\/ Put this memory into reserve by identifying it as old_regions_loaned_for_young_evac\n+      size_t additional_regions_to_loan = ShenandoahOldCompactionReserve - future_evac_reserve_regions;\n+\n+      \/\/ We can loan additional regions to be repaid from the anticipated recycling of young collection set regions\n+      \/\/ provided that these regions are currently available within old-gen memory.\n+      size_t collected_regions_to_loan;\n+      if (collected_regions >= additional_regions_to_loan) {\n+        collected_regions_to_loan = additional_regions_to_loan;\n+        additional_regions_to_loan = 0;\n+      } else if (collected_regions > 0) {\n+        collected_regions_to_loan = collected_regions;\n+        additional_regions_to_loan -= collected_regions_to_loan;\n+      } else {\n+        collected_regions_to_loan = 0;\n+      }\n+\n+      if (collected_regions_to_loan > 0) {\n+        \/\/ We're evacuating at least this many regions, it's ok to use these regions for allocation supplement since\n+        \/\/ we'll be able to repay the loan at end of this GC pass, assuming the regions are available.\n+        if (collected_regions_to_loan > regions_available_to_loan) {\n+          collected_regions_to_loan = regions_available_to_loan;\n+        }\n+        old_bytes_reserved_for_alloc_supplement += collected_regions_to_loan * region_size_bytes;\n+        regions_available_to_loan -= collected_regions_to_loan;\n+        loaned_regions += collected_regions_to_loan;\n+        working_old_available -= collected_regions_to_loan * region_size_bytes;\n+      }\n+\n+      \/\/ If there's still memory that we want to exclude from the current promotion reserve, but we are unable to loan\n+      \/\/ this memory because fully empty old-gen regions are not available, decrement the working_old_available to make\n+      \/\/ sure that this memory is not used to hold the results of old-gen evacuation.\n+      if (additional_regions_to_loan > regions_available_to_loan) {\n+        size_t unloaned_regions = additional_regions_to_loan - regions_available_to_loan;\n+        size_t unloaned_bytes = unloaned_regions * region_size_bytes;\n+\n+        if (working_old_available < unloaned_bytes) {\n+          \/\/ We're in dire straits.  We won't be able to reserve all the memory that we want to make available for the\n+          \/\/ next old-gen evacuation.  We'll reserve as much of it as possible.  Setting working_old_available to zero\n+          \/\/ means there will be no promotion except for the advance promotion.  Note that if some advance promotion fails,\n+          \/\/ the object will be evacuated to young-gen so we should still end up reclaiming the entire advance promotion\n+          \/\/ collection set.\n+          reserved_bytes_for_future_old_evac = working_old_available;\n+          working_old_available = 0;\n+        } else {\n+          reserved_bytes_for_future_old_evac = unloaned_bytes;\n+          working_old_available -= unloaned_bytes;\n+        }\n+        size_t regions_reserved_for_future_old_evac =\n+          (reserved_bytes_for_future_old_evac + region_size_bytes - 1) \/ region_size_bytes;\n+\n+        if (regions_reserved_for_future_old_evac < regions_available_to_loan) {\n+          regions_available_to_loan -= regions_reserved_for_future_old_evac;\n+        } else {\n+          regions_available_to_loan = 0;\n+        }\n+\n+        \/\/ Since we're in dire straits, zero out fragmented_old_total so this won't be used for promotion;\n+        if (working_old_available > fragmented_old_total) {\n+          working_old_available -= fragmented_old_total;\n+        } else {\n+          working_old_available = 0;\n+        }\n+        fragmented_old_total = 0;\n@@ -496,3 +632,0 @@\n-      regions_available_to_loan -= excess_regions;\n-      old_bytes_reserved_for_alloc_supplement = excess_regions * region_size_bytes;\n-      old_regions_reserved_for_alloc_supplement = excess_regions;\n@@ -501,0 +634,4 @@\n+    \/\/ Establish young_evac_reserve so that this young-gen memory is not used for new allocations, allowing the memory\n+    \/\/ to be returned to old-gen as soon as the current collection set regions are reclaimed.\n+    heap->set_young_evac_reserve(young_evacuated_reserve_used);\n+\n@@ -506,2 +643,3 @@\n-    \/\/  1. old_gen->available - (old_evacuation_committed + old_bytes_loaned_for_young_evac + consumed_by_advance_promotion\n-    \/\/                           + old_bytes_[already]_ reserved_for_alloc_supplement)\n+    \/\/  1. old_available\n+    \/\/     (old_available is old_gen->available() -\n+    \/\/      (old_evacuated_committed + consumed_by_advance_promotion + loaned_for_young_evac + reserved_for_alloc_supplement))\n@@ -509,14 +647,1 @@\n-\n-    assert(old_available > old_evacuated_committed, \"Cannot evacuate more than available\");\n-    assert(old_available > old_evacuated_committed + old_bytes_loaned_for_young_evac,\n-           \"Cannot loan young evac more than available\");\n-    assert(old_available > old_evacuated_committed + old_bytes_loaned_for_young_evac + consumed_by_advance_promotion,\n-           \"Cannot promote more than available\");\n-    assert(old_available > (old_evacuated_committed + old_bytes_loaned_for_young_evac +\n-                                          consumed_by_advance_promotion + old_bytes_reserved_for_alloc_supplement),\n-           \"Cannot loan for alloc supplement more than available\");\n-\n-    size_t promotion_reserve = regions_available_to_loan * region_size_bytes;\n-    assert(promotion_reserve <= old_available - (old_evacuated_committed + consumed_by_advance_promotion +\n-                                                 old_bytes_loaned_for_young_evac + old_bytes_reserved_for_alloc_supplement),\n-           \"Byte reserves do not match region reserves\");\n+    size_t promotion_reserve = working_old_available;\n@@ -545,0 +670,11 @@\n+    assert(working_old_available >= promotion_reserve, \"Cannot reserve for promotion more than is available\");\n+    working_old_available -= promotion_reserve;\n+    \/\/ Having reserved this memory for promotion, the regions are no longer available to be loaned.\n+    size_t regions_consumed_by_promotion_reserve = (promotion_reserve + region_size_bytes - 1) \/ region_size_bytes;\n+    if (regions_consumed_by_promotion_reserve > regions_available_to_loan) {\n+      \/\/ This can happen if the promotion reserve makes use of memory that is fragmented between many partially available\n+      \/\/ old-gen regions.\n+      regions_available_to_loan = 0;\n+    } else {\n+      regions_available_to_loan -= regions_consumed_by_promotion_reserve;\n+    }\n@@ -546,7 +682,4 @@\n-    assert(old_available >= (promotion_reserve + old_evacuated_committed + old_bytes_loaned_for_young_evac +\n-                             consumed_by_advance_promotion + old_bytes_reserved_for_alloc_supplement),\n-           \"Budget exceeds available old-gen memory\");\n-    log_debug(gc)(\"Old available: \" SIZE_FORMAT \", Original promotion reserve: \" SIZE_FORMAT \", Old evacuation reserve: \"\n-                  SIZE_FORMAT \", Advance promotion reserve supplement: \" SIZE_FORMAT\n-                  \", Old loaned for young evacuation: \" SIZE_FORMAT \", Old reserved for alloc supplement: \" SIZE_FORMAT,\n-                  old_available, promotion_reserve, old_evacuated_committed, consumed_by_advance_promotion,\n+    log_debug(gc)(\"old_gen->available(): \" SIZE_FORMAT \" divided between promotion reserve: \" SIZE_FORMAT\n+                  \", old evacuation reserve: \" SIZE_FORMAT \", advance promotion reserve supplement: \" SIZE_FORMAT\n+                  \", old loaned for young evacuation: \" SIZE_FORMAT \", old reserved for alloc supplement: \" SIZE_FORMAT,\n+                  old_generation->available(), promotion_reserve, old_evacuated_committed, consumed_by_advance_promotion,\n@@ -558,3 +691,0 @@\n-    size_t promotion_regions = (promotion_reserve + region_size_bytes - 1) \/ region_size_bytes;\n-    assert(regions_available_to_loan >= promotion_regions, \"Promoting more regions than memory is available\");\n-    regions_available_to_loan -= promotion_regions;\n@@ -570,1 +700,1 @@\n-    \/\/ Compute the evacuation supplement, which is extra memory borrowed from old-gen that can be allocated\n+    \/\/ Compute additional evacuation supplement, which is extra memory borrowed from old-gen that can be allocated\n@@ -575,1 +705,2 @@\n-    \/\/ during the evacuation and update-refs phases of execution.  The total available supplement is the smaller of:\n+    \/\/ during the evacuation and update-refs phases of execution.  The total available supplement is the result\n+    \/\/ of adding old_bytes_reserved_for_alloc_supplement to the smaller of:\n@@ -577,2 +708,1 @@\n-    \/\/   1. old_gen->available() -\n-    \/\/        (promotion_reserve + old_evacuation_commitment + old_bytes_loaned_for_young_evac)\n+    \/\/   1. regions_available_to_loan * region_size_bytes\n@@ -586,10 +716,3 @@\n-    size_t young_regions_evacuated = collection_set->get_young_region_count();\n-    size_t regions_for_runway = 0;\n-    size_t already_loaned_regions = old_regions_loaned_for_young_evac + old_regions_reserved_for_alloc_supplement;\n-    if (already_loaned_regions == 0) {\n-      regions_for_runway = young_regions_evacuated;\n-    } else if (young_regions_evacuated > already_loaned_regions) {\n-      regions_for_runway = young_regions_evacuated - already_loaned_regions;\n-    } else {\n-      regions_for_runway = 0;\n-    }\n+    if (regions_available_to_loan > 0 && (collected_regions > loaned_regions)) {\n+      assert(regions_available_to_loan * region_size_bytes <= working_old_available,\n+             \"regions_available_to_loan should not exceed working_old_available\");\n@@ -597,5 +720,7 @@\n-    if (regions_available_to_loan > regions_for_runway) {\n-      regions_available_to_loan -= regions_for_runway;\n-    } else {\n-      regions_for_runway = regions_available_to_loan;\n-      regions_available_to_loan = 0;\n+      size_t additional_regions_to_loan = collected_regions - loaned_regions;\n+      if (additional_regions_to_loan > regions_available_to_loan) {\n+        additional_regions_to_loan = regions_available_to_loan;\n+      }\n+      loaned_regions += additional_regions_to_loan;\n+      old_bytes_reserved_for_alloc_supplement += additional_regions_to_loan * region_size_bytes;\n+      working_old_available -= additional_regions_to_loan * region_size_bytes;\n@@ -603,2 +728,1 @@\n-\n-    size_t allocation_supplement = regions_for_runway * region_size_bytes + old_bytes_reserved_for_alloc_supplement;\n+    size_t allocation_supplement = old_bytes_reserved_for_alloc_supplement;\n@@ -624,3 +748,0 @@\n-    assert(old_available >= old_evacuation_reserve + promotion_reserve + old_bytes_loaned_for_young_evac + allocation_supplement,\n-           \"old_available must be larger than accumulated reserves\");\n-\n@@ -675,1 +796,1 @@\n-    size_t old_regions_loaned_for_young_evac, regions_available_to_loan, minimum_evacuation_reserve, consumed_by_advance_promotion;\n+    size_t consumed_by_advance_promotion;\n@@ -698,2 +819,1 @@\n-    compute_evacuation_budgets(heap, preselected_regions, collection_set, old_regions_loaned_for_young_evac,\n-                               regions_available_to_loan, minimum_evacuation_reserve, consumed_by_advance_promotion);\n+    compute_evacuation_budgets(heap, preselected_regions, collection_set, consumed_by_advance_promotion);\n@@ -702,2 +822,1 @@\n-      adjust_evacuation_budgets(heap, collection_set, old_regions_loaned_for_young_evac, regions_available_to_loan,\n-                                minimum_evacuation_reserve, consumed_by_advance_promotion);\n+      adjust_evacuation_budgets(heap, collection_set, consumed_by_advance_promotion);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":222,"deletions":103,"binary":false,"changes":325,"status":"modified"},{"patch":"@@ -64,2 +64,1 @@\n-                                  size_t &old_regions_loaned_for_young_evac, size_t &regions_available_to_loan,\n-                                  size_t &minimum_evacuation_reserve, size_t &consumed_by_advance_promotion);\n+                                  size_t &consumed_by_advance_promotion);\n@@ -69,2 +68,1 @@\n-                                 size_t old_regions_loaned_for_young_evac, size_t regions_available_to_loan,\n-                                 size_t minimum_evacuation_reserve, size_t consumed_by_advance_promotion);\n+                                 size_t consumed_by_advance_promotion);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"}]}