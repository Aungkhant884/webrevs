{"files":[{"patch":"@@ -54,1 +54,2 @@\n-  _gc_waiters_lock(Mutex::leaf, \"ShenandoahRequestedGC_lock\", true, Monitor::_safepoint_check_always),\n+  _gc_waiters_lock(Mutex::safepoint, \"ShenandoahRequestedGC_lock\", true, Monitor::_safepoint_check_always),\n+  _control_lock(Mutex::leaf, \"ShenandoahControlGC_lock\", true, Monitor::_safepoint_check_never),\n@@ -370,5 +371,6 @@\n-    \/\/ HEY! kemperw would like to have this thread sleep on a timed wait so it\n-    \/\/ could be explicitly woken when there is something to do. The timed wait\n-    \/\/ is necessary because this thread has a responsibility to send\n-    \/\/ 'alloc_words' to the pacer when it does not perform a GC.\n-    os::naked_short_sleep(ShenandoahControlIntervalMin);\n+    {\n+      \/\/ The timed wait is necessary because this thread has a responsibility to send\n+      \/\/ 'alloc_words' to the pacer when it does not perform a GC.\n+      MonitorLocker lock(&_control_lock, Mutex::_no_safepoint_check_flag);\n+      lock.wait(ShenandoahControlIntervalMax);\n+    }\n@@ -724,0 +726,1 @@\n+    notify_control_thread();\n@@ -733,0 +736,1 @@\n+    notify_control_thread();\n@@ -739,0 +743,5 @@\n+void ShenandoahControlThread::notify_control_thread() {\n+  MonitorLocker locker(&_control_lock, Mutex::_no_safepoint_check_flag);\n+  _control_lock.notify();\n+}\n+\n@@ -759,0 +768,1 @@\n+    notify_control_thread();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":16,"deletions":6,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+  Monitor _control_lock;\n@@ -178,0 +179,1 @@\n+  void notify_control_thread();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}