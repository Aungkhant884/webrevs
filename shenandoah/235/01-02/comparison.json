{"files":[{"patch":"@@ -326,3 +326,1 @@\n-    if (heap->mode()->is_generational()) {\n-      phase5_restore_generation_usage();\n-    }\n+    phase5_epilog();\n@@ -1453,0 +1451,58 @@\n+}\n+\n+static void account_for_region(ShenandoahHeapRegion* r, size_t &region_count, size_t &region_usage, size_t &humongous_waste) {\n+  region_count++;\n+  region_usage += r->used();\n+  if (r->is_humongous_start()) {\n+    \/\/ For each humongous object, we take this path once regardless of how many regions it spans.\n+    HeapWord* obj_addr = r->bottom();\n+    oop obj = cast_to_oop(obj_addr);\n+    size_t word_size = obj->size();\n+    size_t region_size_words = ShenandoahHeapRegion::region_size_words();\n+    size_t overreach = word_size % region_size_words;\n+    if (overreach != 0) {\n+      humongous_waste += (region_size_words - overreach) * HeapWordSize;\n+    }\n+    \/\/ else, this humongous object aligns exactly on region size, so no waste.\n+  }\n+}\n+\n+void ShenandoahFullGC::phase5_epilog() {\n+  GCTraceTime(Info, gc, phases) time(\"Phase 5: Full GC epilog\", _gc_timer);\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  size_t num_regions = heap->num_regions();\n+  size_t young_usage = 0;\n+  size_t young_regions = 0;\n+  size_t young_humongous_waste = 0;\n+  size_t old_usage = 0;\n+  size_t old_regions = 0;\n+  size_t old_humongous_waste = 0;\n+  ShenandoahHeapRegion* r;\n+\n+  if (heap->mode()->is_generational()) {\n+    \/\/ TODO: We may be able remove code that recomputes generation usage after we fix the incremental updates to generation\n+    \/\/ usage that are scattered throughout the existing Full GC implementation.  There's an error in there somewhere that\n+    \/\/ has not yet been figured out.  Or maybe it is easier to just not try to do the generation accounting on the fly, keep\n+    \/\/ this code, and remove all of the other attempts to increase\/decrease affiliated regions, used, and humongous_waste.\n+    {\n+      ShenandoahGCPhase phase(ShenandoahPhaseTimings::full_gc_recompute_generation_usage);\n+      for (size_t i = 0; i < num_regions; i++) {\n+        switch (heap->region_affiliation(i)) {\n+          case ShenandoahRegionAffiliation::FREE:\n+            break;\n+          case ShenandoahRegionAffiliation::YOUNG_GENERATION:\n+            r = heap->get_region(i);\n+            account_for_region(r, young_regions, young_usage, young_humongous_waste);\n+            break;\n+          case ShenandoahRegionAffiliation::OLD_GENERATION:\n+            r = heap->get_region(i);\n+            account_for_region(r, old_regions, old_usage, old_humongous_waste);\n+            break;\n+          default:\n+            assert(false, \"Should not reach\");\n+        }\n+      }\n+      heap->old_generation()->establish_usage(old_regions, old_usage, old_humongous_waste);\n+      heap->young_generation()->establish_usage(young_regions, young_usage, young_humongous_waste);\n+    }\n+  }\n@@ -1485,58 +1541,0 @@\n-\n-void ShenandoahFullGC::phase5_restore_generation_usage() {\n-  GCTraceTime(Info, gc, phases) time(\"Phase 5: Restore generation accounts\", _gc_timer);\n-  ShenandoahHeap* heap = ShenandoahHeap::heap();\n-  size_t num_regions = heap->num_regions();\n-  size_t young_usage = 0;\n-  size_t young_regions = 0;\n-  size_t young_humongous_waste = 0;\n-  size_t old_usage = 0;\n-  size_t old_regions = 0;\n-  size_t old_humongous_waste = 0;\n-  ShenandoahHeapRegion* r;\n-\n-  for (size_t i = 0; i < num_regions; i++) {\n-    switch (heap->region_affiliation(i)) {\n-      case ShenandoahRegionAffiliation::FREE:\n-        break;\n-      case ShenandoahRegionAffiliation::YOUNG_GENERATION:\n-        r = heap->get_region(i);\n-        young_regions++;\n-        young_usage += r->used();\n-        if (r->is_humongous()) {\n-          ShenandoahHeapRegion* start = r->humongous_start_region();\n-          HeapWord* obj_addr = start->bottom();\n-          oop obj = cast_to_oop(obj_addr);\n-          size_t word_size = obj->size();\n-          HeapWord* end_addr = obj_addr + word_size;\n-          if (end_addr < r->end()) {\n-            size_t humongous_waste = (r->end() - end_addr) * HeapWordSize;\n-            young_humongous_waste += humongous_waste;\n-          }\n-          \/\/ else, this region is entirely spanned by humongous object so contributes no humongous waste\n-        }\n-        break;\n-      case ShenandoahRegionAffiliation::OLD_GENERATION:\n-        r = heap->get_region(i);\n-        old_regions++;\n-        old_usage += r->used();\n-        if (r->is_humongous()) {\n-          ShenandoahHeapRegion* start = r->humongous_start_region();\n-          HeapWord* obj_addr = start->bottom();\n-          oop obj = cast_to_oop(obj_addr);\n-          size_t word_size = obj->size();\n-          HeapWord* end_addr = obj_addr + word_size;\n-          if (end_addr < r->end()) {\n-            size_t humongous_waste = (r->end() - end_addr) * HeapWordSize;\n-            old_humongous_waste += humongous_waste;\n-          }\n-          \/\/ else, this region is entirely spanned by humongous object so contributes no humongous waste\n-        }\n-        break;\n-      default:\n-        assert(false, \"Should not reach\");\n-    }\n-  }\n-  heap->old_generation()->establish_usage(old_regions, old_usage, old_humongous_waste);\n-  heap->young_generation()->establish_usage(young_regions, young_usage, young_humongous_waste);\n-}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":59,"deletions":61,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-  void phase5_restore_generation_usage();\n+  void phase5_epilog();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -181,0 +181,1 @@\n+  f(full_gc_recompute_generation_usage,             \"    Recompute generation usage\")  \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahPhaseTimings.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}