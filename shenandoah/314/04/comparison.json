{"files":[{"patch":"@@ -66,1 +66,2 @@\n-  if (heap->mode()->is_generational() && heap->is_in_old(field) && heap->is_in_young(value)) {\n+  assert(ShenandoahCardBarrier, \"Card-mark barrier should be on\");\n+  if (heap->is_in_old(field) && heap->is_in_young(value)) {\n@@ -84,1 +85,3 @@\n-  card_mark_barrier(field, value);\n+  if (ShenandoahCardBarrier) {\n+    card_mark_barrier(field, value);\n+  }\n@@ -90,1 +93,3 @@\n-  card_mark_barrier(field, value);\n+  if (ShenandoahCardBarrier) {\n+    card_mark_barrier(field, value);\n+  }\n@@ -367,0 +372,3 @@\n+  \/\/ Each worker thread has a private copy of refproc_data, which includes a private discovered list.  This means\n+  \/\/ there's no risk that a different worker thread will try to manipulate my discovered list head while I'm making\n+  \/\/ reference the head of my discovered list.\n@@ -375,0 +383,12 @@\n+    \/\/ We successfully set this reference object's next pointer to discovered_head.  This marks reference as discovered.\n+    \/\/ If reference_cas_discovered fails, that means some other worker thread took credit for discovery of this reference,\n+    \/\/ and that other thread will place reference on its discovered list, so I can ignore reference.\n+\n+    \/\/ In case we have created an interesting pointer, mark the remembered set card as dirty.\n+    ShenandoahHeap* heap = ShenandoahHeap::heap();\n+    if (ShenandoahCardBarrier) {\n+      T* addr = reinterpret_cast<T*>(java_lang_ref_Reference::discovered_addr_raw(reference));\n+      card_mark_barrier(addr, discovered_head);\n+    }\n+\n+    \/\/ Make the discovered_list_head point to reference.\n@@ -471,0 +491,1 @@\n+  \/\/ set_oop_field maintains the card mark barrier as this list is constructed.\n@@ -547,0 +568,13 @@\n+\n+  \/\/ During reference processing, we maintain a local list of references that are identified by\n+  \/\/   _pending_list and _pending_list_tail.  _pending_list_tail points to the next field of the last Reference object on\n+  \/\/   the local list.\n+  \/\/\n+  \/\/ There is also a global list of reference identified by Universe::_reference_pending_list\n+\n+  \/\/ The following code has the effect of:\n+  \/\/  1. Making the global Universe::_reference_pending_list point to my local list\n+  \/\/  2. Overwriting the next field of the last Reference on my local list to point at the previous head of the\n+  \/\/     global Universe::_reference_pending_list\n+\n+  oop former_head_of_global_list = Universe::swap_reference_pending_list(_pending_list);\n@@ -548,1 +582,1 @@\n-    *reinterpret_cast<narrowOop*>(_pending_list_tail) = CompressedOops::encode(Universe::swap_reference_pending_list(_pending_list));\n+    *reinterpret_cast<narrowOop*>(_pending_list_tail) = CompressedOops::encode(former_head_of_global_list);\n@@ -550,1 +584,7 @@\n-    *reinterpret_cast<oop*>(_pending_list_tail) = Universe::swap_reference_pending_list(_pending_list);\n+    *reinterpret_cast<oop*>(_pending_list_tail) = former_head_of_global_list;\n+  }\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  if (ShenandoahCardBarrier) {\n+    if (heap->is_in_old(_pending_list_tail) && heap->is_in_young(former_head_of_global_list)) {\n+      heap->mark_card_as_dirty(_pending_list_tail);\n+    }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahReferenceProcessor.cpp","additions":45,"deletions":5,"binary":false,"changes":50,"status":"modified"}]}