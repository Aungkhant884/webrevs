{"files":[{"patch":"@@ -367,0 +367,3 @@\n+  \/\/ Each worker thread has a private copy of refproc_data, which includes a private discovered list.  This means\n+  \/\/ there's no risk that a different worker thread will try to manipulate my discovered list head while I'm making\n+  \/\/ reference the head of my discovered list.\n@@ -375,0 +378,14 @@\n+    \/\/ We successfully set this reference object's next pointer to discovered_head.  This marks reference as discovered.\n+    \/\/ If reference_cas_discovered fails, that means some other worker thread took credit for discovery of this reference,\n+    \/\/ and that other thread will place reference on its discovered list, so I can ignore reference.\n+\n+    \/\/ In case we have created an interesting pointer, mark the remembered set card as dirty.\n+    ShenandoahHeap* heap = ShenandoahHeap::heap();\n+    if (heap->mode()->is_generational()) {\n+      T* addr = reinterpret_cast<T*>(java_lang_ref_Reference::discovered_addr_raw(reference));\n+      if (heap->is_in_old(addr) && heap->is_in_young(discovered_head)) {\n+        heap->mark_card_as_dirty(addr);\n+      }\n+    }\n+\n+    \/\/ Make the discovered_list_head point to reference.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahReferenceProcessor.cpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"}]}