{"files":[{"patch":"@@ -2304,5 +2304,1 @@\n-            if (ShenandoahUseSimpleCardScanning) {\n-              if (ShenandoahBarrierSet::barrier_set()->card_table()->is_dirty(MemRegion(r->bottom(), r->top()))) {\n-                update_all_references(&cl, r, update_watermark );\n-              }\n-            } else if (!_mixed_evac) {\n+            if (!_mixed_evac) {\n@@ -2378,19 +2374,0 @@\n-\n-  template<class T>\n-  void update_all_references(T* cl, ShenandoahHeapRegion* r, HeapWord* update_watermark) {\n-    if (r->is_humongous()) {\n-      r->oop_iterate_humongous(cl);\n-    } else {\n-      \/\/ We don't have liveness information about this region.\n-      \/\/ Therefore we process all objects, rather than just marked ones.\n-      \/\/ Otherwise subsequent traversals will encounter stale pointers.\n-      HeapWord* p = r->bottom();\n-      ShenandoahObjectToOopBoundedClosure<T> objs(cl, p, update_watermark);\n-      \/\/ Anything beyond update_watermark is not yet allocated or initialized.\n-      while (p < update_watermark) {\n-        oop obj = cast_to_oop(p);\n-        objs.do_object(obj);\n-        p += obj->size();\n-      }\n-    }\n-  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":1,"deletions":24,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -29,4 +29,0 @@\n-\/\/ During development of this new feature, we want the option to test\n-\/\/ with and without, and to compare performance before and after.\n-#define FAST_REMEMBERED_SET_SCANNING\n-\n@@ -506,1 +502,0 @@\n-#ifdef FAST_REMEMBERED_SET_SCANNING\n@@ -516,2 +511,0 @@\n-  static const uint16_t CardOffsetMultiplier = 8;\n-\n@@ -545,1 +538,0 @@\n-#endif  \/\/ FAST_REMEMBERED_SET_SCANNING\n@@ -549,2 +541,1 @@\n-#ifdef FAST_REMEMBERED_SET_SCANNING\n-    \/\/ HEY!  We don't really need object_starts entries for every card entry.  We only need these for the\n+    \/\/ HEY!  We don't really need object_starts entries for every card entry.  We only need these for\n@@ -557,1 +548,0 @@\n-#endif\n@@ -646,9 +636,0 @@\n-private:\n-  const size_t CardByteOffsetMultiplier = 8;\n-  const size_t CardWordOffsetMultiplier = 1;\n-\n-public:\n-#ifdef CROSSING_OFFSETS_NO_LONGER_NEEDED\n-private:\n-  const uint16_t CrossingObjectOverflow = 0x7fff;\n-\n@@ -657,7 +638,0 @@\n-  \/\/ This has side effect of clearing ObjectStartsInCardRegion bit.\n-  inline void set_crossing_object_start(size_t card_index, uint16_t crossing_offset) {\n-    object_starts[card_index] = crossing_offset;\n-  }\n-#endif  \/\/ CROSSING_OFFSETS_NO_LONGER_NEEDED\n-\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.hpp","additions":1,"deletions":27,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -209,1 +209,1 @@\n-#ifdef FAST_REMEMBERED_SET_SCANNING\n+\n@@ -249,4 +249,0 @@\n-#else  \/\/ FAST_REMEMBERED_SET_SCANNING\n-  \/\/ Do nothing for now as we have a brute-force implementation\n-  \/\/ of findSpanningObject().\n-#endif \/\/ FAST_REMEMBERED_SET_SCANNING\n@@ -259,43 +255,1 @@\n-#ifdef FAST_REMEMBERED_SET_SCANNING\n-  if (object_starts[card_index] & ObjectStartsInCardRegion)\n-    return true;\n-  else\n-    return false;\n-#else \/\/ FAST_REMEMBERED_SET_SCANNING'\n-  ShenandoahHeap *heap = ShenandoahHeap::heap();\n-  HeapWord *addr = _rs->addr_for_card_index(card_index);\n-  ShenandoahHeapRegion *region = heap->heap_region_containing(addr);\n-\n-  \/\/ region->block_start(addr) is not robust to inquiries beyond top() and it crashes.\n-  if (region->top() <= addr)\n-    return false;\n-\n-  \/\/ region->block_start(addr) is also not robust to inquiries within a humongous continuation region.\n-  \/\/ if region is humongous continuation, no object starts within it.\n-  if (region->is_humongous_continuation())\n-    return false;\n-\n-  HeapWord *obj = region->block_start(addr);\n-\n-  \/\/ addr is the first address of the card region.\n-  \/\/ obj is the object that spans addr (or starts at addr).\n-  assert(obj != NULL, \"Object cannot be null\");\n-  if (obj >= addr)\n-    return true;\n-  else {\n-    HeapWord *end_addr = addr + CardTable::card_size_in_words;\n-\n-    \/\/ end_addr needs to be adjusted downward if top address of the enclosing region is less than end_addr.  this is intended\n-    \/\/ to be slow and reliable alternative to the planned production quality replacement, so go ahead and spend some extra\n-    \/\/ cycles here in order to make this code reliable.\n-    if (region->top() < end_addr) {\n-      end_addr = region->top();\n-    }\n-\n-    obj += oop(obj)->size();\n-    if (obj < end_addr)\n-      return true;\n-    else\n-      return false;\n-  }\n-#endif \/\/ FAST_REMEMBERED_SET_SCANNING'\n+  return object_starts[card_index] & ObjectStartsInCardRegion;\n@@ -307,1 +261,0 @@\n-#ifdef FAST_REMEMBERED_SET_SCANNING\n@@ -310,21 +263,0 @@\n-#else  \/\/ FAST_REMEMBERED_SET_SCANNING\n-  HeapWord *addr = _rs->addr_for_card_index(card_index);\n-  ShenandoahHeap *heap = ShenandoahHeap::heap();\n-  ShenandoahHeapRegion *region = heap->heap_region_containing(addr);\n-\n-  HeapWord *obj = region->block_start(addr);\n-\n-  assert(obj != NULL, \"Object cannot be null.\");\n-  if (obj >= addr)\n-    return obj - addr;\n-  else {\n-    HeapWord *end_addr = addr + CardTable::card_size_in_words;\n-    obj += oop(obj)->size();\n-\n-    \/\/ If obj > end_addr, offset will reach beyond end of this card\n-    \/\/ region.  But clients should not invoke this service unless\n-    \/\/ they first confirm that this card has an object.\n-    assert(obj < end_addr, \"Object out of range\");\n-    return obj - addr;\n-  }\n-#endif  \/\/ FAST_REMEMBERED_SET_SCANNING\n@@ -336,1 +268,0 @@\n-#ifdef FAST_REMEMBERED_SET_SCANNING\n@@ -339,38 +270,0 @@\n-#else  \/\/ FAST_REMEMBERED_SET_SCANNING\n-  HeapWord *addr = _rs->addr_for_card_index(card_index);\n-  HeapWord *end_addr = addr + CardTable::card_size_in_words;\n-  ShenandoahHeap *heap = ShenandoahHeap::heap();\n-  ShenandoahHeapRegion *region = heap->heap_region_containing(addr);\n-  HeapWord *obj = region->block_start(addr);\n-  assert(obj != NULL, \"Object cannot be null.\");\n-\n-  if (region->top() <= end_addr) {\n-    end_addr = region->top();\n-  }\n-\n-  HeapWord *end_obj = obj + oop(obj)->size();\n-  while (end_obj < end_addr) {\n-    obj = end_obj;\n-    end_obj = obj + oop(obj)->size();\n-  }\n-  assert(obj >= addr, \"Object out of range.\");\n-  return obj - addr;\n-#endif  \/\/ FAST_REMEMBERED_SET_SCANNING\n-}\n-\n-#ifdef CROSSING_OFFSETS_NO_LONGER_NEEDED\n-template<typename RememberedSet>\n-inline size_t\n-ShenandoahCardCluster<RememberedSet>::get_crossing_object_start(size_t card_index) {\n-  HeapWord *addr = _rs->addr_for_card_index(card_index);\n-  size_t cluster_no = card_index \/ ShenandoahCardCluster<RememberedSet>::CardsPerCluster;\n-  HeapWord *cluster_addr = _rs->addr_for_card_index(cluster_no * CardsPerCluster);\n-\n-  ShenandoahHeap *heap = ShenandoahHeap::heap();\n-  ShenandoahHeapRegion *region = heap->heap_region_containing(addr);\n-  HeapWord *obj = region->block_start(addr);\n-\n-  if (obj > cluster_addr)\n-    return obj - cluster_addr;\n-  else\n-    return 0x7fff;\n@@ -378,1 +271,0 @@\n-#endif\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.inline.hpp","additions":2,"deletions":110,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -408,4 +408,0 @@\n-  product(bool, ShenandoahUseSimpleCardScanning, false, DIAGNOSTIC,         \\\n-          \"Testing: use simplified, very inefficient but much less complex\" \\\n-          \" card table scanning.\")                                          \\\n-                                                                            \\\n@@ -433,4 +429,0 @@\n-  product(bool, ShenandoahPromoteTenuredRegions, true, DIAGNOSTIC,          \\\n-          \"Turn on\/off transitioning tenured young regions \"                \\\n-          \" to the old generation.\")                                        \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoah_globals.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"}]}