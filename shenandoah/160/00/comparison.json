{"files":[{"patch":"@@ -81,0 +81,4 @@\n+size_t ShenandoahCardTable::last_valid_index() {\n+  return _last_valid_index;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCardTable.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -67,0 +67,2 @@\n+  size_t last_valid_index();\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCardTable.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,2 +44,0 @@\n-  _whole_heap_end = _whole_heap_base + total_card_count * CardTable::card_size();\n-\n@@ -48,4 +46,0 @@\n-  _overreach_map = (uint8_t *) malloc(total_card_count);\n-  _overreach_map_base = (_overreach_map -\n-                         (uintptr_t(_whole_heap_base) >> _card_shift));\n-\n@@ -54,31 +48,0 @@\n-  \/\/ assert(_overreach_cards != NULL);\n-}\n-\n-ShenandoahDirectCardMarkRememberedSet::~ShenandoahDirectCardMarkRememberedSet() {\n-  free(_overreach_map);\n-}\n-\n-void ShenandoahDirectCardMarkRememberedSet::initialize_overreach(size_t first_cluster, size_t count) {\n-\n-  \/\/ We can make this run faster in the future by explicitly\n-  \/\/ unrolling the loop and doing wide writes if the compiler\n-  \/\/ doesn't do this for us.\n-  size_t first_card_index = first_cluster * ShenandoahCardCluster<ShenandoahDirectCardMarkRememberedSet>::CardsPerCluster;\n-  uint8_t* omp = &_overreach_map[first_card_index];\n-  uint8_t* endp = omp + count * ShenandoahCardCluster<ShenandoahDirectCardMarkRememberedSet>::CardsPerCluster;\n-  while (omp < endp)\n-    *omp++ = CardTable::clean_card_val();\n-}\n-\n-void ShenandoahDirectCardMarkRememberedSet::merge_overreach(size_t first_cluster, size_t count) {\n-\n-  \/\/ We can make this run faster in the future by explicitly unrolling the loop and doing wide writes if the compiler\n-  \/\/ doesn't do this for us.\n-  size_t first_card_index = first_cluster * ShenandoahCardCluster<ShenandoahDirectCardMarkRememberedSet>::CardsPerCluster;\n-  uint8_t* bmp = &_byte_map[first_card_index];\n-  uint8_t* endp = bmp + count * ShenandoahCardCluster<ShenandoahDirectCardMarkRememberedSet>::CardsPerCluster;\n-  uint8_t* omp = &_overreach_map[first_card_index];\n-\n-  \/\/ dirty_card is 0, clean card is 0xff; if either *bmp or *omp is dirty, we need to mark it as dirty\n-  while (bmp < endp)\n-    *bmp++ &= *omp++;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.cpp","additions":0,"deletions":37,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -209,1 +209,0 @@\n-#include \"memory\/iterator.hpp\"\n@@ -215,0 +214,1 @@\n+#include \"memory\/iterator.hpp\"\n@@ -242,1 +242,0 @@\n-  HeapWord *_whole_heap_end;\n@@ -245,4 +244,0 @@\n-  uint8_t *_overreach_map;      \/\/ Points to first entry within the overreach card table\n-  uint8_t *_overreach_map_base; \/\/ Points to overreach_map minus the bias computed from address of heap memory\n-\n-  uint64_t _wide_clean_value;\n@@ -256,0 +251,1 @@\n+  size_t last_valid_index();\n@@ -266,1 +262,0 @@\n-  void mark_overreach_card_as_dirty(size_t card_index);\n@@ -272,1 +267,0 @@\n-  void mark_overreach_card_as_dirty(void *p);\n@@ -275,8 +269,0 @@\n-  \/\/ Called by multiple GC threads at start of concurrent mark and evacuation phases.  Each parallel GC thread typically\n-  \/\/ initializes a different subranges of all overreach entries.\n-  void initialize_overreach(size_t first_cluster, size_t count);\n-\n-  \/\/ Called by GC thread at end of concurrent mark or evacuation phase.  Each parallel GC thread typically merges different\n-  \/\/ subranges of all overreach entries.\n-  void merge_overreach(size_t first_cluster, size_t count);\n-\n@@ -300,3 +286,0 @@\n-  HeapWord* whole_heap_base() { return _whole_heap_base; }\n-  HeapWord* whole_heap_end() { return _whole_heap_end; }\n-\n@@ -562,2 +545,2 @@\n-    object_starts = (crossing_info *) malloc(rs->total_cards() * sizeof(crossing_info));\n-    if (object_starts == nullptr)\n+    object_starts = NEW_C_HEAP_ARRAY(crossing_info, rs->total_cards(), mtGC);\n+    if (object_starts == nullptr) {\n@@ -565,1 +548,2 @@\n-    for (size_t i = 0; i < rs->total_cards(); i++)\n+    }\n+    for (size_t i = 0; i < rs->total_cards(); i++) {\n@@ -567,0 +551,1 @@\n+    }\n@@ -570,2 +555,3 @@\n-    if (object_starts != nullptr)\n-      free(object_starts);\n+    if (object_starts != nullptr) {\n+      FREE_C_HEAP_ARRAY(crossing_info, object_starts);\n+    }\n@@ -895,0 +881,1 @@\n+  size_t last_valid_index();\n@@ -905,1 +892,0 @@\n-  void mark_overreach_card_as_dirty(size_t card_index);\n@@ -911,1 +897,0 @@\n-  void mark_overreach_card_as_dirty(void *p);\n@@ -913,2 +898,0 @@\n-  void initialize_overreach(size_t first_cluster, size_t count);\n-  void merge_overreach(size_t first_cluster, size_t count);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.hpp","additions":11,"deletions":28,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -38,0 +38,5 @@\n+inline size_t\n+ShenandoahDirectCardMarkRememberedSet::last_valid_index() {\n+  return _card_table->last_valid_index();\n+}\n+\n@@ -93,6 +98,0 @@\n-inline void\n-ShenandoahDirectCardMarkRememberedSet::mark_overreach_card_as_dirty(size_t card_index) {\n-  uint8_t *bp = &_overreach_map[card_index];\n-  bp[0] = CardTable::dirty_card_val();\n-}\n-\n@@ -152,6 +151,0 @@\n-inline void\n-ShenandoahDirectCardMarkRememberedSet::mark_overreach_card_as_dirty(void *p) {\n-  uint8_t *bp = &_overreach_map_base[uintptr_t(p) >> _card_shift];\n-  bp[0] = CardTable::dirty_card_val();\n-}\n-\n@@ -274,0 +267,4 @@\n+template<typename RememberedSet>\n+inline size_t\n+ShenandoahScanRemembered<RememberedSet>::last_valid_index() { return _rs->last_valid_index(); }\n+\n@@ -306,4 +303,0 @@\n-template<typename RememberedSet>\n-inline void\n-ShenandoahScanRemembered<RememberedSet>:: mark_overreach_card_as_dirty(size_t card_index) { _rs->mark_overreach_card_as_dirty(card_index); }\n-\n@@ -330,4 +323,0 @@\n-template<typename RememberedSet>\n-inline void\n-ShenandoahScanRemembered<RememberedSet>::mark_overreach_card_as_dirty(void *p) { _rs->mark_overreach_card_as_dirty(p); }\n-\n@@ -338,8 +327,0 @@\n-template<typename RememberedSet>\n-inline void\n-ShenandoahScanRemembered<RememberedSet>::initialize_overreach(size_t first_cluster, size_t count) { _rs->initialize_overreach(first_cluster, count); }\n-\n-template<typename RememberedSet>\n-inline void\n-ShenandoahScanRemembered<RememberedSet>::merge_overreach(size_t first_cluster, size_t count) { _rs->merge_overreach(first_cluster, count); }\n-\n@@ -422,1 +403,1 @@\n-    if (end_card_index > index) {\n+    if (end_card_index > index && end_card_index < _rs->last_valid_index()) {\n@@ -424,1 +405,1 @@\n-      if ((base_addr + offset < _rs->whole_heap_end()) && _scc->has_object(end_card_index) &&\n+      if (_scc->has_object(end_card_index) &&\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.inline.hpp","additions":11,"deletions":30,"binary":false,"changes":41,"status":"modified"}]}