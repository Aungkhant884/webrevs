{"files":[{"patch":"@@ -410,1 +410,1 @@\n-  ObjectMonitor* _current_pending_monitor;      \/\/ ObjectMonitor this thread\n+  ObjectMonitor* volatile _current_pending_monitor; \/\/ ObjectMonitor this thread\n@@ -418,1 +418,1 @@\n-  ObjectMonitor* _current_waiting_monitor;\n+  ObjectMonitor* volatile _current_waiting_monitor;\n@@ -623,1 +623,4 @@\n-    return _current_pending_monitor;\n+    \/\/ Use Atomic::load() to prevent data race between concurrent modification and\n+    \/\/ concurrent readers, e.g. ThreadService::get_current_contended_monitor().\n+    \/\/ Especially, reloading pointer from thread after NULL check must be prevented.\n+    return Atomic::load(&_current_pending_monitor);\n@@ -626,1 +629,1 @@\n-    _current_pending_monitor = monitor;\n+    Atomic::store(&_current_pending_monitor, monitor);\n@@ -637,1 +640,2 @@\n-    return _current_waiting_monitor;\n+    \/\/ See the comment in current_pending_monitor() above.\n+    return Atomic::load(&_current_waiting_monitor);\n@@ -640,1 +644,1 @@\n-    _current_waiting_monitor = monitor;\n+    Atomic::store(&_current_waiting_monitor, monitor);\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -741,1 +741,1 @@\n-  nonstatic_field(Thread,                      _current_pending_monitor,                      ObjectMonitor*)                        \\\n+  volatile_nonstatic_field(Thread,             _current_pending_monitor,                      ObjectMonitor*)                        \\\n@@ -743,1 +743,1 @@\n-  nonstatic_field(Thread,                      _current_waiting_monitor,                      ObjectMonitor*)                        \\\n+  volatile_nonstatic_field(Thread,             _current_waiting_monitor,                      ObjectMonitor*)                        \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}