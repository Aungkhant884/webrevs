{"files":[{"patch":"@@ -581,0 +581,6 @@\n+      } else if (ZERO_ONLY(true) NOT_ZERO(false)) {\n+        \/\/ Non-arch-specific Zero code does not really know the pc.\n+        \/\/ This can be alleviated by making arch-specific os::Posix::ucontext_get_pc\n+        \/\/ available for Zero for known architectures. But for generic Zero\n+        \/\/ code, it would still remain unknown.\n+        pc = NULL;\n@@ -585,16 +591,6 @@\n-#if defined(ZERO) && !defined(PRODUCT)\n-    char buf[64];\n-    VMError::report_and_die(t, sig, pc, info, ucVoid,\n-          \"\\n#\"\n-          \"\\n#    \/--------------------\\\\\"\n-          \"\\n#    |      %-7s       |\"\n-          \"\\n#    \\\\---\\\\ \/--------------\/\"\n-          \"\\n#        \/\"\n-          \"\\n#    [-]        |\\\\_\/|    \"\n-          \"\\n#    (+)=C      |o o|__  \"\n-          \"\\n#    | |        =-*-=__\\\\ \"\n-          \"\\n#    OOO        c_c_(___)\",\n-          get_signal_name(sig, buf, sizeof(buf)));\n-#else\n-    VMError::report_and_die(t, sig, pc, info, ucVoid);\n-#endif\n+    \/\/ For Zero, we ignore the crash context, because:\n+    \/\/  a) The crash would be in C++ interpreter code, so context is not really relevant;\n+    \/\/  b) Generic Zero code would not be able to parse it, so when generic error\n+    \/\/     reporting code asks e.g. about frames on stack, Zero would experience\n+    \/\/     a secondary ShouldNotCallThis() crash.\n+    VMError::report_and_die(t, sig, pc, info, NOT_ZERO(ucVoid) ZERO_ONLY(NULL));\n","filename":"src\/hotspot\/os\/posix\/signals_posix.cpp","additions":12,"deletions":16,"binary":false,"changes":28,"status":"modified"}]}